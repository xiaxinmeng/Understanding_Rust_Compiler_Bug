{"sha": "be0141666dd12316034499db12ee9fcf9ba648dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlMDE0MTY2NmRkMTIzMTYwMzQ0OTlkYjEyZWU5ZmNmOWJhNjQ4ZGQ=", "commit": {"author": {"name": "Gareth Daniel Smith", "email": "garethdanielsmith@gmail.com", "date": "2012-07-04T21:53:12Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-05T02:18:13Z"}, "message": "convert doc-attributes to doc-comments using ./src/etc/sugarise-doc-comments.py (and manually tweaking) - for issue #2498", "tree": {"sha": "7d4c985a73e9a85de0e6c1bf2beeed44ebbd0102", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d4c985a73e9a85de0e6c1bf2beeed44ebbd0102"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be0141666dd12316034499db12ee9fcf9ba648dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be0141666dd12316034499db12ee9fcf9ba648dd", "html_url": "https://github.com/rust-lang/rust/commit/be0141666dd12316034499db12ee9fcf9ba648dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be0141666dd12316034499db12ee9fcf9ba648dd/comments", "author": {"login": "Dretch", "id": 1428731, "node_id": "MDQ6VXNlcjE0Mjg3MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1428731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dretch", "html_url": "https://github.com/Dretch", "followers_url": "https://api.github.com/users/Dretch/followers", "following_url": "https://api.github.com/users/Dretch/following{/other_user}", "gists_url": "https://api.github.com/users/Dretch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dretch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dretch/subscriptions", "organizations_url": "https://api.github.com/users/Dretch/orgs", "repos_url": "https://api.github.com/users/Dretch/repos", "events_url": "https://api.github.com/users/Dretch/events{/privacy}", "received_events_url": "https://api.github.com/users/Dretch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfa43ca3011bd1296cb1797ad3ea1c5dc4056749", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfa43ca3011bd1296cb1797ad3ea1c5dc4056749", "html_url": "https://github.com/rust-lang/rust/commit/bfa43ca3011bd1296cb1797ad3ea1c5dc4056749"}], "stats": {"total": 10029, "additions": 4983, "deletions": 5046}, "files": [{"sha": "04a8751045b9c1f5ef818c5026e34fc4bf0de4a2", "filename": "src/libcore/arc.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farc.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,5 +1,7 @@\n-#[doc = \"An atomically reference counted wrapper that can be used to\n-share immutable data between tasks.\"]\n+/**\n+ * An atomically reference counted wrapper that can be used to\n+ * share immutable data between tasks.\n+ */\n \n import comm::{port, chan, methods};\n import sys::methods;\n@@ -41,7 +43,7 @@ class arc_destruct<T> {\n \n type arc<T: const> = arc_destruct<T>;\n \n-#[doc=\"Create an atomically reference counted wrapper.\"]\n+/// Create an atomically reference counted wrapper.\n fn arc<T: const>(-data: T) -> arc<T> {\n     let data = ~{mut count: 1, data: data};\n     unsafe {\n@@ -50,8 +52,10 @@ fn arc<T: const>(-data: T) -> arc<T> {\n     }\n }\n \n-#[doc=\"Access the underlying data in an atomically reference counted\n- wrapper.\"]\n+/**\n+ * Access the underlying data in an atomically reference counted\n+ * wrapper.\n+ */\n fn get<T: const>(rc: &a.arc<T>) -> &a.T {\n     unsafe {\n         let ptr: ~arc_data<T> = unsafe::reinterpret_cast((*rc).data);\n@@ -62,11 +66,13 @@ fn get<T: const>(rc: &a.arc<T>) -> &a.T {\n     }\n }\n \n-#[doc=\"Duplicate an atomically reference counted wrapper.\n-\n-The resulting two `arc` objects will point to the same underlying data\n-object. However, one of the `arc` objects can be sent to another task,\n-allowing them to share the underlying data.\"]\n+/**\n+ * Duplicate an atomically reference counted wrapper.\n+ *\n+ * The resulting two `arc` objects will point to the same underlying data\n+ * object. However, one of the `arc` objects can be sent to another task,\n+ * allowing them to share the underlying data.\n+ */\n fn clone<T: const>(rc: &arc<T>) -> arc<T> {\n     unsafe {\n         let ptr: ~arc_data<T> = unsafe::reinterpret_cast((*rc).data);"}, {"sha": "1f0d9174c735921f88ba4e8a1af0d860c7214dad", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,45 +1,43 @@\n // -*- rust -*-\n \n-#[doc = \"Boolean logic\"];\n+//! Boolean logic\n \n export not, and, or, xor, implies;\n export eq, ne, is_true, is_false;\n export from_str, to_str, all_values, to_bit;\n \n-#[doc = \"Negation / inverse\"]\n+/// Negation / inverse\n pure fn not(v: bool) -> bool { !v }\n \n-#[doc = \"Conjunction\"]\n+/// Conjunction\n pure fn and(a: bool, b: bool) -> bool { a && b }\n \n-#[doc = \"Disjunction\"]\n+/// Disjunction\n pure fn or(a: bool, b: bool) -> bool { a || b }\n \n-#[doc = \"\n-Exclusive or\n-\n-Identical to `or(and(a, not(b)), and(not(a), b))`\n-\"]\n+/**\n+ * Exclusive or\n+ *\n+ * Identical to `or(and(a, not(b)), and(not(a), b))`\n+ */\n pure fn xor(a: bool, b: bool) -> bool { (a && !b) || (!a && b) }\n \n-#[doc = \"Implication in the logic, i.e. from `a` follows `b`\"]\n+/// Implication in the logic, i.e. from `a` follows `b`\n pure fn implies(a: bool, b: bool) -> bool { !a || b }\n \n-#[doc = \"\n-true if truth values `a` and `b` are indistinguishable in the logic\n-\"]\n+/// true if truth values `a` and `b` are indistinguishable in the logic\n pure fn eq(a: bool, b: bool) -> bool { a == b }\n \n-#[doc = \"true if truth values `a` and `b` are distinguishable in the logic\"]\n+/// true if truth values `a` and `b` are distinguishable in the logic\n pure fn ne(a: bool, b: bool) -> bool { a != b }\n \n-#[doc = \"true if `v` represents truth in the logic\"]\n+/// true if `v` represents truth in the logic\n pure fn is_true(v: bool) -> bool { v }\n \n-#[doc = \"true if `v` represents falsehood in the logic\"]\n+/// true if `v` represents falsehood in the logic\n pure fn is_false(v: bool) -> bool { !v }\n \n-#[doc = \"Parse logic value from `s`\"]\n+/// Parse logic value from `s`\n pure fn from_str(s: str) -> option<bool> {\n     alt check s {\n       \"true\" { some(true) }\n@@ -48,19 +46,19 @@ pure fn from_str(s: str) -> option<bool> {\n     }\n }\n \n-#[doc = \"Convert `v` into a string\"]\n+/// Convert `v` into a string\n pure fn to_str(v: bool) -> str { if v { \"true\" } else { \"false\" } }\n \n-#[doc = \"\n-Iterates over all truth values by passing them to `blk` in an unspecified\n-order\n-\"]\n+/**\n+ * Iterates over all truth values by passing them to `blk` in an unspecified\n+ * order\n+ */\n fn all_values(blk: fn(v: bool)) {\n     blk(true);\n     blk(false);\n }\n \n-#[doc = \"converts truth value to an 8 bit byte\"]\n+/// converts truth value to an 8 bit byte\n pure fn to_bit(v: bool) -> u8 { if v { 1u8 } else { 0u8 } }\n \n #[test]"}, {"sha": "bbafc87774d3e923cb273054dcdc3f89a52ec5e5", "filename": "src/libcore/box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbox.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,9 +1,9 @@\n-#[doc = \"Operations on shared box types\"];\n+//! Operations on shared box types\n \n export ptr_eq;\n \n pure fn ptr_eq<T>(a: @T, b: @T) -> bool {\n-    #[doc = \"Determine if two shared boxes point to the same object\"];\n+    //! Determine if two shared boxes point to the same object\n     unsafe { ptr::addr_of(*a) == ptr::addr_of(*b) }\n }\n "}, {"sha": "28645df1b46c01900556c39aadfcb8b0a584caaf", "filename": "src/libcore/char.rs", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Utilities for manipulating the char type\"];\n+//! Utilities for manipulating the char type\n \n /*\n     Lu  Uppercase_Letter    an uppercase letter\n@@ -46,72 +46,72 @@ import is_XID_start = unicode::derived_property::XID_Start;\n import is_XID_continue = unicode::derived_property::XID_Continue;\n \n \n-#[doc = \"\n-Indicates whether a character is in lower case, defined\n-in terms of the Unicode General Category 'Ll'\n-\"]\n+/**\n+ * Indicates whether a character is in lower case, defined\n+ * in terms of the Unicode General Category 'Ll'\n+ */\n pure fn is_lowercase(c: char) -> bool {\n     ret unicode::general_category::Ll(c);\n }\n \n-#[doc = \"\n-Indicates whether a character is in upper case, defined\n-in terms of the Unicode General Category 'Lu'.\n-\"]\n+/**\n+ * Indicates whether a character is in upper case, defined\n+ * in terms of the Unicode General Category 'Lu'.\n+ */\n pure fn is_uppercase(c: char) -> bool {\n     ret unicode::general_category::Lu(c);\n }\n \n-#[doc = \"\n-Indicates whether a character is whitespace, defined in\n-terms of the Unicode General Categories 'Zs', 'Zl', 'Zp'\n-additional 'Cc'-category control codes in the range [0x09, 0x0d]/~\n-\"]\n+/**\n+ * Indicates whether a character is whitespace, defined in\n+ * terms of the Unicode General Categories 'Zs', 'Zl', 'Zp'\n+ * additional 'Cc'-category control codes in the range [0x09, 0x0d]\n+ */\n pure fn is_whitespace(c: char) -> bool {\n     ret ('\\x09' <= c && c <= '\\x0d')\n         || unicode::general_category::Zs(c)\n         || unicode::general_category::Zl(c)\n         || unicode::general_category::Zp(c);\n }\n \n-#[doc = \"\n-Indicates whether a character is alphanumeric, defined\n-in terms of the Unicode General Categories 'Nd',\n-'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n-\"]\n+/**\n+ * Indicates whether a character is alphanumeric, defined\n+ * in terms of the Unicode General Categories 'Nd',\n+ * 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n+ */\n pure fn is_alphanumeric(c: char) -> bool {\n     ret unicode::derived_property::Alphabetic(c) ||\n         unicode::general_category::Nd(c) ||\n         unicode::general_category::Nl(c) ||\n         unicode::general_category::No(c);\n }\n \n-#[doc = \"Indicates whether the character is an ASCII character\"]\n+/// Indicates whether the character is an ASCII character\n pure fn is_ascii(c: char) -> bool {\n    c - ('\\x7F' & c) == '\\x00'\n }\n \n-#[doc = \"Indicates whether the character is numeric (Nd, Nl, or No)\"]\n+/// Indicates whether the character is numeric (Nd, Nl, or No)\n pure fn is_digit(c: char) -> bool {\n     ret unicode::general_category::Nd(c) ||\n         unicode::general_category::Nl(c) ||\n         unicode::general_category::No(c);\n }\n \n-#[doc = \"\n-Convert a char to the corresponding digit.\n-\n-# Safety note\n-\n-This function fails if `c` is not a valid char\n-\n-# Return value\n-\n-If `c` is between '0' and '9', the corresponding value\n-between 0 and 9. If `c` is 'a' or 'A', 10. If `c` is\n-'b' or 'B', 11, etc. Returns none if the char does not\n-refer to a digit in the given radix.\n-\"]\n+/**\n+ * Convert a char to the corresponding digit.\n+ *\n+ * # Safety note\n+ *\n+ * This function fails if `c` is not a valid char\n+ *\n+ * # Return value\n+ *\n+ * If `c` is between '0' and '9', the corresponding value\n+ * between 0 and 9. If `c` is 'a' or 'A', 10. If `c` is\n+ * 'b' or 'B', 11, etc. Returns none if the char does not\n+ * refer to a digit in the given radix.\n+ */\n pure fn to_digit(c: char, radix: uint) -> option<uint> {\n     let val = alt c {\n       '0' to '9' { c as uint - ('0' as uint) }\n@@ -123,15 +123,15 @@ pure fn to_digit(c: char, radix: uint) -> option<uint> {\n     else { none }\n }\n \n-#[doc = \"\n-Return the hexadecimal unicode escape of a char.\n-\n-The rules are as follows:\n-\n-  - chars in [0,0xff]/~ get 2-digit escapes: `\\\\xNN`\n-  - chars in [0x100,0xffff]/~ get 4-digit escapes: `\\\\uNNNN`\n-  - chars above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`\n-\"]\n+/**\n+ * Return the hexadecimal unicode escape of a char.\n+ *\n+ * The rules are as follows:\n+ *\n+ *   - chars in [0,0xff] get 2-digit escapes: `\\\\xNN`\n+ *   - chars in [0x100,0xffff] get 4-digit escapes: `\\\\uNNNN`\n+ *   - chars above 0x10000 get 8-digit escapes: `\\\\UNNNNNNNN`\n+ */\n fn escape_unicode(c: char) -> str {\n     let s = u32::to_str(c as u32, 16u);\n     let (c, pad) = (if c <= '\\xff' { ('x', 2u) }\n@@ -145,18 +145,18 @@ fn escape_unicode(c: char) -> str {\n     ret out;\n }\n \n-#[doc = \"\n-Return a 'default' ASCII and C++11-like char-literal escape of a char.\n-\n-The default is chosen with a bias toward producing literals that are\n-legal in a variety of languages, including C++11 and similar C-family\n-languages. The exact rules are:\n-\n-  - Tab, CR and LF are escaped as '\\t', '\\r' and '\\n' respectively.\n-  - Single-quote, double-quote and backslash chars are backslash-escaped.\n-  - Any other chars in the range [0x20,0x7e]/~ are not escaped.\n-  - Any other chars are given hex unicode escapes; see `escape_unicode`.\n-\"]\n+/**\n+ * Return a 'default' ASCII and C++11-like char-literal escape of a char.\n+ *\n+ * The default is chosen with a bias toward producing literals that are\n+ * legal in a variety of languages, including C++11 and similar C-family\n+ * languages. The exact rules are:\n+ *\n+ *   - Tab, CR and LF are escaped as '\\t', '\\r' and '\\n' respectively.\n+ *   - Single-quote, double-quote and backslash chars are backslash-escaped.\n+ *   - Any other chars in the range [0x20,0x7e] are not escaped.\n+ *   - Any other chars are given hex unicode escapes; see `escape_unicode`.\n+ */\n fn escape_default(c: char) -> str {\n     alt c {\n       '\\t' { \"\\\\t\" }\n@@ -170,13 +170,13 @@ fn escape_default(c: char) -> str {\n     }\n }\n \n-#[doc = \"\n-Compare two chars\n-\n-# Return value\n-\n--1 if a < b, 0 if a == b, +1 if a > b\n-\"]\n+/**\n+ * Compare two chars\n+ *\n+ * # Return value\n+ *\n+ * -1 if a < b, 0 if a == b, +1 if a > b\n+ */\n pure fn cmp(a: char, b: char) -> int {\n     ret  if b > a { -1 }\n     else if b < a { 1 }"}, {"sha": "1bdf3b9909ac4f5ec5f5558fd3dc639e26d526ee", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc=\"Interfaces used for comparison.\"]\n+/// Interfaces used for comparison.\n \n iface ord {\n     fn lt(&&other: self) -> bool;"}, {"sha": "7276bea5b1c04230b2b8f8b69d00f1824bc87bbf", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,28 +1,28 @@\n-#[doc = \"\n-Communication between tasks\n-\n-Communication between tasks is facilitated by ports (in the receiving\n-task), and channels (in the sending task). Any number of channels may\n-feed into a single port.  Ports and channels may only transmit values\n-of unique types; that is, values that are statically guaranteed to be\n-accessed by a single 'owner' at a time.  Unique types include scalars,\n-vectors, strings, and records, tags, tuples and unique boxes (`~T`)\n-thereof. Most notably, shared boxes (`@T`) may not be transmitted\n-across channels.\n-\n-# Example\n-\n-~~~\n-let po = comm::port();\n-let ch = comm::chan(po);\n-\n-task::spawn {||\n-    comm::send(ch, \\\"Hello, World\\\");\n-});\n-\n-io::println(comm::recv(p));\n-~~~\n-\"];\n+/*!\n+ * Communication between tasks\n+ *\n+ * Communication between tasks is facilitated by ports (in the receiving\n+ * task), and channels (in the sending task). Any number of channels may\n+ * feed into a single port.  Ports and channels may only transmit values\n+ * of unique types; that is, values that are statically guaranteed to be\n+ * accessed by a single 'owner' at a time.  Unique types include scalars,\n+ * vectors, strings, and records, tags, tuples and unique boxes (`~T`)\n+ * thereof. Most notably, shared boxes (`@T`) may not be transmitted\n+ * across channels.\n+ *\n+ * # Example\n+ *\n+ * ~~~\n+ * let po = comm::port();\n+ * let ch = comm::chan(po);\n+ *\n+ * task::spawn {||\n+ *     comm::send(ch, \"Hello, World\");\n+ * });\n+ *\n+ * io::println(comm::recv(p));\n+ * ~~~\n+ */\n \n import either::either;\n import libc::size_t;\n@@ -38,34 +38,34 @@ export methods;\n export listen;\n \n \n-#[doc = \"\n-A communication endpoint that can receive messages\n-\n-Each port has a unique per-task identity and may not be replicated or\n-transmitted. If a port value is copied, both copies refer to the same\n-port.  Ports may be associated with multiple `chan`s.\n-\"]\n+/**\n+ * A communication endpoint that can receive messages\n+ *\n+ * Each port has a unique per-task identity and may not be replicated or\n+ * transmitted. If a port value is copied, both copies refer to the same\n+ * port.  Ports may be associated with multiple `chan`s.\n+ */\n enum port<T: send> {\n     port_t(@port_ptr<T>)\n }\n \n // It's critical that this only have one variant, so it has a record\n // layout, and will work in the rust_task structure in task.rs.\n-#[doc = \"\n-A communication endpoint that can send messages\n-\n-Each channel is bound to a port when the channel is constructed, so\n-the destination port for a channel must exist before the channel\n-itself.  Channels are weak: a channel does not keep the port it is\n-bound to alive. If a channel attempts to send data to a dead port that\n-data will be silently dropped.  Channels may be duplicated and\n-themselves transmitted over other channels.\n-\"]\n+/**\n+ * A communication endpoint that can send messages\n+ *\n+ * Each channel is bound to a port when the channel is constructed, so\n+ * the destination port for a channel must exist before the channel\n+ * itself.  Channels are weak: a channel does not keep the port it is\n+ * bound to alive. If a channel attempts to send data to a dead port that\n+ * data will be silently dropped.  Channels may be duplicated and\n+ * themselves transmitted over other channels.\n+ */\n enum chan<T: send> {\n     chan_t(port_id)\n }\n \n-#[doc = \"Constructs a port\"]\n+/// Constructs a port\n fn port<T: send>() -> port<T> {\n     port_t(@port_ptr(rustrt::new_port(sys::size_of::<T>() as size_t)))\n }\n@@ -88,7 +88,7 @@ impl methods<T: send> for chan<T> {\n \n }\n \n-#[doc = \"Open a new receiving channel for the duration of a function\"]\n+/// Open a new receiving channel for the duration of a function\n fn listen<T: send, U>(f: fn(chan<T>) -> U) -> U {\n     let po = port();\n     f(po.chan())\n@@ -119,14 +119,14 @@ class port_ptr<T:send> {\n   }\n }\n \n-#[doc = \"\n-Internal function for converting from a channel to a port\n-\n-# Failure\n-\n-Fails if the port is detached or dead. Fails if the port\n-is owned by a different task.\n-\"]\n+/**\n+ * Internal function for converting from a channel to a port\n+ *\n+ * # Failure\n+ *\n+ * Fails if the port is detached or dead. Fails if the port\n+ * is owned by a different task.\n+ */\n fn as_raw_port<T: send, U>(ch: comm::chan<T>, f: fn(*rust_port) -> U) -> U {\n \n     class portref {\n@@ -150,18 +150,18 @@ fn as_raw_port<T: send, U>(ch: comm::chan<T>, f: fn(*rust_port) -> U) -> U {\n     f(p.p)\n }\n \n-#[doc = \"\n-Constructs a channel. The channel is bound to the port used to\n-construct it.\n-\"]\n+/**\n+ * Constructs a channel. The channel is bound to the port used to\n+ * construct it.\n+ */\n fn chan<T: send>(p: port<T>) -> chan<T> {\n     chan_t(rustrt::get_port_id((**p).po))\n }\n \n-#[doc = \"\n-Sends data over a channel. The sent data is moved into the channel,\n-whereupon the caller loses access to it.\n-\"]\n+/**\n+ * Sends data over a channel. The sent data is moved into the channel,\n+ * whereupon the caller loses access to it.\n+ */\n fn send<T: send>(ch: chan<T>, -data: T) {\n     let chan_t(p) = ch;\n     let data_ptr = ptr::addr_of(data) as *();\n@@ -173,13 +173,13 @@ fn send<T: send>(ch: chan<T>, -data: T) {\n     task::yield();\n }\n \n-#[doc = \"\n-Receive from a port.  If no data is available on the port then the\n-task will block until data becomes available.\n-\"]\n+/**\n+ * Receive from a port.  If no data is available on the port then the\n+ * task will block until data becomes available.\n+ */\n fn recv<T: send>(p: port<T>) -> T { recv_((**p).po) }\n \n-#[doc = \"Returns true if there are messages available\"]\n+/// Returns true if there are messages available\n fn peek<T: send>(p: port<T>) -> bool { peek_((**p).po) }\n \n #[doc(hidden)]\n@@ -191,7 +191,7 @@ fn peek_chan<T: send>(ch: comm::chan<T>) -> bool {\n     as_raw_port(ch, |x|peek_(x))\n }\n \n-#[doc = \"Receive on a raw port pointer\"]\n+/// Receive on a raw port pointer\n fn recv_<T: send>(p: *rust_port) -> T {\n     let yield = 0u;\n     let yieldp = ptr::addr_of(yield);\n@@ -214,7 +214,7 @@ fn peek_(p: *rust_port) -> bool {\n     rustrt::rust_port_size(p) != 0u as libc::size_t\n }\n \n-#[doc = \"Receive on one of two ports\"]\n+/// Receive on one of two ports\n fn select2<A: send, B: send>(p_a: port<A>, p_b: port<B>)\n     -> either<A, B> {\n     let ports = ~[(**p_a).po, (**p_b).po];"}, {"sha": "58f2281daf384d684c2473dee8531541f2da4bcc", "filename": "src/libcore/core.rc", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -7,26 +7,26 @@\n #[license = \"MIT\"];\n #[crate_type = \"lib\"];\n \n-#[doc = \"\n-The Rust core library provides functionality that is closely tied to the Rust\n-built-in types and runtime services, or that is used in nearly every\n-non-trivial program.\n-\n-`core` includes modules corresponding to each of the integer types, each of\n-the floating point types, the `bool` type, tuples, characters, strings,\n-vectors (`vec`), shared boxes (`box`), and unsafe pointers (`ptr`).\n-Additionally, `core` provides very commonly used built-in types and\n-operations, concurrency primitives, platform abstractions, I/O, and complete\n-bindings to the C standard library.\n-\n-`core` is linked by default to all crates and the contents imported.\n-Implicitly, all crates behave as if they included the following prologue:\n-\n-    use core;\n-    import core::*;\n-\n-This behavior can be disabled with the `#[no_core]` crate attribute.\n-\"];\n+/*!\n+ * The Rust core library provides functionality that is closely tied to the\n+ * Rust built-in types and runtime services, or that is used in nearly every\n+ * non-trivial program.\n+ *\n+ * `core` includes modules corresponding to each of the integer types, each of\n+ * the floating point types, the `bool` type, tuples, characters, strings,\n+ * vectors (`vec`), shared boxes (`box`), and unsafe pointers (`ptr`).\n+ * Additionally, `core` provides very commonly used built-in types and\n+ * operations, concurrency primitives, platform abstractions, I/O, and\n+ * complete bindings to the C standard library.\n+ *\n+ * `core` is linked by default to all crates and the contents imported.\n+ * Implicitly, all crates behave as if they included the following prologue:\n+ *\n+ *     use core;\n+ *     import core::*;\n+ *\n+ * This behavior can be disabled with the `#[no_core]` crate attribute.\n+ */\n \n // Don't link to core. We are core.\n #[no_core];\n@@ -58,7 +58,7 @@ export priv;\n \n // Built-in-type support modules\n \n-#[doc = \"Operations and constants for `int`\"]\n+/// Operations and constants for `int`\n #[path = \"int-template\"]\n mod int {\n     import inst::{ hash, pow };\n@@ -67,35 +67,35 @@ mod int {\n     mod inst;\n }\n \n-#[doc = \"Operations and constants for `i8`\"]\n+/// Operations and constants for `i8`\n #[path = \"int-template\"]\n mod i8 {\n     #[path = \"i8.rs\"]\n     mod inst;\n }\n \n-#[doc = \"Operations and constants for `i16`\"]\n+/// Operations and constants for `i16`\n #[path = \"int-template\"]\n mod i16 {\n     #[path = \"i16.rs\"]\n     mod inst;\n }\n \n-#[doc = \"Operations and constants for `i32`\"]\n+/// Operations and constants for `i32`\n #[path = \"int-template\"]\n mod i32 {\n     #[path = \"i32.rs\"]\n     mod inst;\n }\n \n-#[doc = \"Operations and constants for `i64`\"]\n+/// Operations and constants for `i64`\n #[path = \"int-template\"]\n mod i64 {\n     #[path = \"i64.rs\"]\n     mod inst;\n }\n \n-#[doc = \"Operations and constants for `uint`\"]\n+/// Operations and constants for `uint`\n #[path = \"uint-template\"]\n mod uint {\n     import inst::{\n@@ -109,7 +109,7 @@ mod uint {\n     mod inst;\n }\n \n-#[doc = \"Operations and constants for `u8`\"]\n+/// Operations and constants for `u8`\n #[path = \"uint-template\"]\n mod u8 {\n     import inst::is_ascii;\n@@ -119,21 +119,21 @@ mod u8 {\n     mod inst;\n }\n \n-#[doc = \"Operations and constants for `u16`\"]\n+/// Operations and constants for `u16`\n #[path = \"uint-template\"]\n mod u16 {\n     #[path = \"u16.rs\"]\n     mod inst;\n }\n \n-#[doc = \"Operations and constants for `u32`\"]\n+/// Operations and constants for `u32`\n #[path = \"uint-template\"]\n mod u32 {\n     #[path = \"u32.rs\"]\n     mod inst;\n }\n \n-#[doc = \"Operations and constants for `u64`\"]\n+/// Operations and constants for `u64`\n #[path = \"uint-template\"]\n mod u64 {\n     #[path = \"u64.rs\"]"}, {"sha": "f97d2727194ebb2783e1ba41ec1730687e15983e", "filename": "src/libcore/core.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -37,13 +37,13 @@ export num;\n \n export error, warn, info, debug;\n \n-#[doc = \"The error log level\"]\n+/// The error log level\n const error : u32 = 0_u32;\n-#[doc = \"The warning log level\"]\n+/// The warning log level\n const warn : u32 = 1_u32;\n-#[doc = \"The info log level\"]\n+/// The info log level\n const info : u32 = 2_u32;\n-#[doc = \"The debug log level\"]\n+/// The debug log level\n const debug : u32 = 3_u32;\n \n // A curious inner-module that's not exported that contains the binding\n@@ -63,11 +63,11 @@ mod std {\n     import std::test;\n }\n \n-#[doc = \"\n-A standard function to use to indicate unreachable code. Because the\n-function is guaranteed to fail typestate will correctly identify\n-any code paths following the appearance of this function as unreachable.\n-\"]\n+/**\n+ * A standard function to use to indicate unreachable code. Because the\n+ * function is guaranteed to fail typestate will correctly identify\n+ * any code paths following the appearance of this function as unreachable.\n+ */\n fn unreachable() -> ! {\n     fail \"Internal error: entered unreachable code\";\n }"}, {"sha": "f80972d50b33e4ab0fc8bfe0ddfc103108811bfe", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 64, "deletions": 48, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,8 +1,8 @@\n-#[doc = \"\n-A doubly-linked list. Supports O(1) head, tail, count, push, pop, etc.\n-\n-Do not use ==, !=, <, etc on doubly-linked lists -- it may not terminate.\n-\"]\n+/**\n+ * A doubly-linked list. Supports O(1) head, tail, count, push, pop, etc.\n+ *\n+ * Do not use ==, !=, <, etc on doubly-linked lists -- it may not terminate.\n+ */\n \n import dlist_iter::extensions;\n \n@@ -57,32 +57,32 @@ impl private_methods<T> for dlist_node<T> {\n }\n \n impl extensions<T> for dlist_node<T> {\n-    #[doc = \"Get the next node in the list, if there is one.\"]\n+    /// Get the next node in the list, if there is one.\n     pure fn next_link() -> option<dlist_node<T>> {\n         self.assert_links();\n         self.next\n     }\n-    #[doc = \"Get the next node in the list, failing if there isn't one.\"]\n+    /// Get the next node in the list, failing if there isn't one.\n     pure fn next_node() -> dlist_node<T> {\n         alt self.next_link() {\n             some(nobe) { nobe }\n             none       { fail \"This dlist node has no next neighbour.\" }\n         }\n     }\n-    #[doc = \"Get the previous node in the list, if there is one.\"]\n+    /// Get the previous node in the list, if there is one.\n     pure fn prev_link() -> option<dlist_node<T>> {\n         self.assert_links();\n         self.prev\n     }\n-    #[doc = \"Get the previous node in the list, failing if there isn't one.\"]\n+    /// Get the previous node in the list, failing if there isn't one.\n     pure fn prev_node() -> dlist_node<T> {\n         alt self.prev_link() {\n             some(nobe) { nobe }\n             none       { fail \"This dlist node has no previous neighbour.\" }\n         }\n     }\n \n-    #[doc = \"Remove a node from whatever dlist it's on (failing if none).\"]\n+    /// Remove a node from whatever dlist it's on (failing if none).\n     fn remove() {\n         if option::is_some(self.root) {\n             option::get(self.root).remove(self);\n@@ -92,17 +92,17 @@ impl extensions<T> for dlist_node<T> {\n     }\n }\n \n-#[doc = \"Creates a new dlist node with the given data.\"]\n+/// Creates a new dlist node with the given data.\n pure fn create_node<T>(+data: T) -> dlist_node<T> {\n     dlist_node(@{data: data, mut root: none, mut prev: none, mut next: none})\n }\n \n-#[doc = \"Creates a new, empty dlist.\"]\n+/// Creates a new, empty dlist.\n pure fn create<T>() -> dlist<T> {\n     dlist(@{mut size: 0, mut hd: none, mut tl: none})\n }\n \n-#[doc = \"Creates a new dlist with a single element\"]\n+/// Creates a new dlist with a single element\n fn from_elt<T>(+data: T) -> dlist<T> {\n     let list = create();\n     list.push(data);\n@@ -184,108 +184,124 @@ impl private_methods<T> for dlist<T> {\n }\n \n impl extensions<T> for dlist<T> {\n-    #[doc = \"Get the size of the list. O(1).\"]\n+    /// Get the size of the list. O(1).\n     pure fn len()          -> uint { self.size }\n-    #[doc = \"Returns true if the list is empty. O(1).\"]\n+    /// Returns true if the list is empty. O(1).\n     pure fn is_empty()     -> bool { self.len() == 0 }\n-    #[doc = \"Returns true if the list is not empty. O(1).\"]\n+    /// Returns true if the list is not empty. O(1).\n     pure fn is_not_empty() -> bool { self.len() != 0 }\n \n-    #[doc = \"Add data to the head of the list. O(1).\"]\n+    /// Add data to the head of the list. O(1).\n     fn push_head(+data: T) {\n         self.add_head(self.new_link(data));\n     }\n-    #[doc = \"Add data to the head of the list, and get the new containing\n-             node. O(1).\"]\n+    /**\n+     * Add data to the head of the list, and get the new containing\n+     * node. O(1).\n+     */\n     fn push_head_n(+data: T) -> dlist_node<T> {\n         let mut nobe = self.new_link(data);\n         self.add_head(nobe);\n         option::get(nobe)\n     }\n-    #[doc = \"Add data to the tail of the list. O(1).\"]\n+    /// Add data to the tail of the list. O(1).\n     fn push(+data: T) {\n         self.add_tail(self.new_link(data));\n     }\n-    #[doc = \"Add data to the tail of the list, and get the new containing\n-             node. O(1).\"]\n+    /**\n+     * Add data to the tail of the list, and get the new containing\n+     * node. O(1).\n+     */\n     fn push_n(+data: T) -> dlist_node<T> {\n         let mut nobe = self.new_link(data);\n         self.add_tail(nobe);\n         option::get(nobe)\n     }\n-    #[doc = \"Insert data into the middle of the list, left of the given node.\n-             O(1).\"]\n+    /**\n+     * Insert data into the middle of the list, left of the given node.\n+     * O(1).\n+     */\n     fn insert_before(+data: T, neighbour: dlist_node<T>) {\n         self.insert_left(self.new_link(data), neighbour);\n     }\n-    #[doc = \"Insert an existing node in the middle of the list, left of the\n-             given node. O(1).\"]\n+    /**\n+     * Insert an existing node in the middle of the list, left of the\n+     * given node. O(1).\n+     */\n     fn insert_n_before(nobe: dlist_node<T>, neighbour: dlist_node<T>) {\n         self.make_mine(nobe);\n         self.insert_left(some(nobe), neighbour);\n     }\n-    #[doc = \"Insert data in the middle of the list, left of the given node,\n-             and get its containing node. O(1).\"]\n+    /**\n+     * Insert data in the middle of the list, left of the given node,\n+     * and get its containing node. O(1).\n+     */\n     fn insert_before_n(+data: T, neighbour: dlist_node<T>) -> dlist_node<T> {\n         let mut nobe = self.new_link(data);\n         self.insert_left(nobe, neighbour);\n         option::get(nobe)\n     }\n-    #[doc = \"Insert data into the middle of the list, right of the given node.\n-             O(1).\"]\n+    /**\n+     * Insert data into the middle of the list, right of the given node.\n+     * O(1).\n+     */\n     fn insert_after(+data: T, neighbour: dlist_node<T>) {\n         self.insert_right(neighbour, self.new_link(data));\n     }\n-    #[doc = \"Insert an existing node in the middle of the list, right of the\n-             given node. O(1).\"]\n+    /**\n+     * Insert an existing node in the middle of the list, right of the\n+     * given node. O(1).\n+     */\n     fn insert_n_after(nobe: dlist_node<T>, neighbour: dlist_node<T>) {\n         self.make_mine(nobe);\n         self.insert_right(neighbour, some(nobe));\n     }\n-    #[doc = \"Insert data in the middle of the list, right of the given node,\n-             and get its containing node. O(1).\"]\n+    /**\n+     * Insert data in the middle of the list, right of the given node,\n+     * and get its containing node. O(1).\n+     */\n     fn insert_after_n(+data: T, neighbour: dlist_node<T>) -> dlist_node<T> {\n         let mut nobe = self.new_link(data);\n         self.insert_right(neighbour, nobe);\n         option::get(nobe)\n     }\n \n-    #[doc = \"Remove a node from the head of the list. O(1).\"]\n+    /// Remove a node from the head of the list. O(1).\n     fn pop_n() -> option<dlist_node<T>> {\n         let hd = self.peek_n();\n         hd.map(|nobe| self.unlink(nobe));\n         hd\n     }\n-    #[doc = \"Remove a node from the tail of the list. O(1).\"]\n+    /// Remove a node from the tail of the list. O(1).\n     fn pop_tail_n() -> option<dlist_node<T>> {\n         let tl = self.peek_tail_n();\n         tl.map(|nobe| self.unlink(nobe));\n         tl\n     }\n-    #[doc = \"Get the node at the list's head. O(1).\"]\n+    /// Get the node at the list's head. O(1).\n     pure fn peek_n() -> option<dlist_node<T>> { self.hd }\n-    #[doc = \"Get the node at the list's tail. O(1).\"]\n+    /// Get the node at the list's tail. O(1).\n     pure fn peek_tail_n() -> option<dlist_node<T>> { self.tl }\n \n-    #[doc = \"Get the node at the list's head, failing if empty. O(1).\"]\n+    /// Get the node at the list's head, failing if empty. O(1).\n     pure fn head_n() -> dlist_node<T> {\n         alt self.hd {\n             some(nobe) { nobe }\n             none       { fail \"Attempted to get the head of an empty dlist.\" }\n         }\n     }\n-    #[doc = \"Get the node at the list's tail, failing if empty. O(1).\"]\n+    /// Get the node at the list's tail, failing if empty. O(1).\n     pure fn tail_n() -> dlist_node<T> {\n         alt self.tl {\n             some(nobe) { nobe }\n             none       { fail \"Attempted to get the tail of an empty dlist.\" }\n         }\n     }\n \n-    #[doc = \"Remove a node from anywhere in the list. O(1).\"]\n+    /// Remove a node from anywhere in the list. O(1).\n     fn remove(nobe: dlist_node<T>) { self.unlink(nobe); }\n \n-    #[doc = \"Check data structure integrity. O(n).\"]\n+    /// Check data structure integrity. O(n).\n     fn assert_consistent() {\n         if option::is_none(self.hd) || option::is_none(self.tl) {\n             assert option::is_none(self.hd) && option::is_none(self.tl);\n@@ -333,17 +349,17 @@ impl extensions<T> for dlist<T> {\n }\n \n impl extensions<T: copy> for dlist<T> {\n-    #[doc = \"Remove data from the head of the list. O(1).\"]\n+    /// Remove data from the head of the list. O(1).\n     fn pop()       -> option<T> { self.pop_n().map       (|nobe| nobe.data) }\n-    #[doc = \"Remove data from the tail of the list. O(1).\"]\n+    /// Remove data from the tail of the list. O(1).\n     fn pop_tail()  -> option<T> { self.pop_tail_n().map  (|nobe| nobe.data) }\n-    #[doc = \"Get data at the list's head. O(1).\"]\n+    /// Get data at the list's head. O(1).\n     fn peek()      -> option<T> { self.peek_n().map      (|nobe| nobe.data) }\n-    #[doc = \"Get data at the list's tail. O(1).\"]\n+    /// Get data at the list's tail. O(1).\n     fn peek_tail() -> option<T> { self.peek_tail_n().map (|nobe| nobe.data) }\n-    #[doc = \"Get data at the list's head, failing if empty. O(1).\"]\n+    /// Get data at the list's head, failing if empty. O(1).\n     pure fn head() -> T         { self.head_n().data }\n-    #[doc = \"Get data at the list's tail, failing if empty. O(1).\"]\n+    /// Get data at the list's tail, failing if empty. O(1).\n     pure fn tail() -> T         { self.tail_n().data }\n }\n "}, {"sha": "9c1d6cae36b144c2d9b9950dde6b8479ccb3344d", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 73, "deletions": 77, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -15,59 +15,57 @@ export from_vec;\n export extensions;\n export unwrap;\n \n-#[doc = \"\n-\n-A growable, modifiable vector type that accumulates elements into a\n-unique vector.\n-\n-# Limitations on recursive use\n-\n-This class works by swapping the unique vector out of the data\n-structure whenever it is to be used.  Therefore, recursive use is not\n-permitted.  That is, while iterating through a vector, you cannot\n-access the vector in any other way or else the program will fail.  If\n-you wish, you can use the `swap()` method to gain access to the raw\n-vector and transform it or use it any way you like.  Eventually, we\n-may permit read-only access during iteration or other use.\n-\n-# WARNING\n-\n-For maximum performance, this type is implemented using some rather\n-unsafe code.  In particular, this innocent looking `[mut A]/~` pointer\n-*may be null!*  Therefore, it is important you not reach into the\n-data structure manually but instead use the provided extensions.\n-\n-The reason that I did not use an unsafe pointer in the structure\n-itself is that I wanted to ensure that the vector would be freed when\n-the dvec is dropped.  The reason that I did not use an `option<T>`\n-instead of a nullable pointer is that I found experimentally that it\n-becomes approximately 50% slower. This can probably be improved\n-through optimization.  You can run your own experiments using\n-`src/test/bench/vec-append.rs`. My own tests found that using null\n-pointers achieved about 103 million pushes/second.  Using an option\n-type could only produce 47 million pushes/second.\n-\n-\"]\n+/**\n+ * A growable, modifiable vector type that accumulates elements into a\n+ * unique vector.\n+ *\n+ * # Limitations on recursive use\n+ *\n+ * This class works by swapping the unique vector out of the data\n+ * structure whenever it is to be used.  Therefore, recursive use is not\n+ * permitted.  That is, while iterating through a vector, you cannot\n+ * access the vector in any other way or else the program will fail.  If\n+ * you wish, you can use the `swap()` method to gain access to the raw\n+ * vector and transform it or use it any way you like.  Eventually, we\n+ * may permit read-only access during iteration or other use.\n+ *\n+ * # WARNING\n+ *\n+ * For maximum performance, this type is implemented using some rather\n+ * unsafe code.  In particular, this innocent looking `[mut A]/~` pointer\n+ * *may be null!*  Therefore, it is important you not reach into the\n+ * data structure manually but instead use the provided extensions.\n+ *\n+ * The reason that I did not use an unsafe pointer in the structure\n+ * itself is that I wanted to ensure that the vector would be freed when\n+ * the dvec is dropped.  The reason that I did not use an `option<T>`\n+ * instead of a nullable pointer is that I found experimentally that it\n+ * becomes approximately 50% slower. This can probably be improved\n+ * through optimization.  You can run your own experiments using\n+ * `src/test/bench/vec-append.rs`. My own tests found that using null\n+ * pointers achieved about 103 million pushes/second.  Using an option\n+ * type could only produce 47 million pushes/second.\n+ */\n type dvec<A> = {\n     mut data: ~[mut A]\n };\n \n-#[doc = \"Creates a new, empty dvec\"]\n+/// Creates a new, empty dvec\n fn dvec<A>() -> dvec<A> {\n     {mut data: ~[mut]}\n }\n \n-#[doc = \"Creates a new dvec with a single element\"]\n+/// Creates a new dvec with a single element\n fn from_elt<A>(+e: A) -> dvec<A> {\n     {mut data: ~[mut e]}\n }\n \n-#[doc = \"Creates a new dvec with the contents of a vector\"]\n+/// Creates a new dvec with the contents of a vector\n fn from_vec<A>(+v: ~[mut A]) -> dvec<A> {\n     {mut data: v}\n }\n \n-#[doc = \"Consumes the vector and returns its contents\"]\n+/// Consumes the vector and returns its contents\n fn unwrap<A>(-d: dvec<A>) -> ~[mut A] {\n     let {data: v} <- d;\n     ret v;\n@@ -106,19 +104,17 @@ impl private_methods<A> for dvec<A> {\n // almost nothing works without the copy bound due to limitations\n // around closures.\n impl extensions<A> for dvec<A> {\n-    #[doc = \"\n-\n-    Swaps out the current vector and hands it off to a user-provided\n-    function `f`.  The function should transform it however is desired\n-    and return a new vector to replace it with.\n-\n-    \"]\n+    /**\n+     * Swaps out the current vector and hands it off to a user-provided\n+     * function `f`.  The function should transform it however is desired\n+     * and return a new vector to replace it with.\n+     */\n     #[inline(always)]\n     fn swap(f: fn(-~[mut A]) -> ~[mut A]) {\n         self.borrow(|v| self.return(f(v)))\n     }\n \n-    #[doc = \"Returns the number of elements currently in the dvec\"]\n+    /// Returns the number of elements currently in the dvec\n     fn len() -> uint {\n         do self.borrow |v| {\n             let l = v.len();\n@@ -127,13 +123,13 @@ impl extensions<A> for dvec<A> {\n         }\n     }\n \n-    #[doc = \"Overwrite the current contents\"]\n+    /// Overwrite the current contents\n     fn set(+w: ~[mut A]) {\n         self.check_not_borrowed();\n         self.data <- w;\n     }\n \n-    #[doc = \"Remove and return the last element\"]\n+    /// Remove and return the last element\n     fn pop() -> A {\n         do self.borrow |v| {\n             let mut v <- v;\n@@ -143,7 +139,7 @@ impl extensions<A> for dvec<A> {\n         }\n     }\n \n-    #[doc = \"Insert a single item at the front of the list\"]\n+    /// Insert a single item at the front of the list\n     fn unshift(-t: A) {\n         unsafe {\n             let mut data = unsafe::reinterpret_cast(null::<()>());\n@@ -157,13 +153,13 @@ impl extensions<A> for dvec<A> {\n         }\n     }\n \n-    #[doc = \"Append a single item to the end of the list\"]\n+    /// Append a single item to the end of the list\n     fn push(+t: A) {\n         self.check_not_borrowed();\n         vec::push(self.data, t);\n     }\n \n-    #[doc = \"Remove and return the first element\"]\n+    /// Remove and return the first element\n     fn shift() -> A {\n         do self.borrow |v| {\n             let mut v = vec::from_mut(v);\n@@ -175,18 +171,16 @@ impl extensions<A> for dvec<A> {\n }\n \n impl extensions<A:copy> for dvec<A> {\n-    #[doc = \"\n-        Append all elements of a vector to the end of the list\n-\n-        Equivalent to `append_iter()` but potentially more efficient.\n-    \"]\n+    /**\n+     * Append all elements of a vector to the end of the list\n+     *\n+     * Equivalent to `append_iter()` but potentially more efficient.\n+     */\n     fn push_all(ts: &[const A]) {\n         self.push_slice(ts, 0u, vec::len(ts));\n     }\n \n-    #[doc = \"\n-        Appends elements from `from_idx` to `to_idx` (exclusive)\n-    \"]\n+    /// Appends elements from `from_idx` to `to_idx` (exclusive)\n     fn push_slice(ts: &[const A], from_idx: uint, to_idx: uint) {\n         do self.swap |v| {\n             let mut v <- v;\n@@ -202,12 +196,12 @@ impl extensions<A:copy> for dvec<A> {\n     }\n \n     /*\n-    #[doc = \"\n-        Append all elements of an iterable.\n-\n-        Failure will occur if the iterable's `each()` method\n-        attempts to access this vector.\n-    \"]\n+    /**\n+     * Append all elements of an iterable.\n+     *\n+     * Failure will occur if the iterable's `each()` method\n+     * attempts to access this vector.\n+     */\n     fn append_iter<A, I:iter::base_iter<A>>(ts: I) {\n         do self.swap |v| {\n            let mut v = alt ts.size_hint() {\n@@ -226,11 +220,11 @@ impl extensions<A:copy> for dvec<A> {\n     }\n     */\n \n-    #[doc = \"\n-        Gets a copy of the current contents.\n-\n-        See `unwrap()` if you do not wish to copy the contents.\n-    \"]\n+    /**\n+     * Gets a copy of the current contents.\n+     *\n+     * See `unwrap()` if you do not wish to copy the contents.\n+     */\n     fn get() -> ~[A] {\n         do self.borrow |v| {\n             let w = vec::from_mut(copy v);\n@@ -239,28 +233,30 @@ impl extensions<A:copy> for dvec<A> {\n         }\n     }\n \n-    #[doc = \"Copy out an individual element\"]\n+    /// Copy out an individual element\n     #[inline(always)]\n     fn [](idx: uint) -> A {\n         self.get_elt(idx)\n     }\n \n-    #[doc = \"Copy out an individual element\"]\n+    /// Copy out an individual element\n     #[inline(always)]\n     fn get_elt(idx: uint) -> A {\n         self.check_not_borrowed();\n         ret self.data[idx];\n     }\n \n-    #[doc = \"Overwrites the contents of the element at `idx` with `a`\"]\n+    /// Overwrites the contents of the element at `idx` with `a`\n     fn set_elt(idx: uint, a: A) {\n         self.check_not_borrowed();\n         self.data[idx] = a;\n     }\n \n-    #[doc = \"Overwrites the contents of the element at `idx` with `a`,\n-    growing the vector if necessary.  New elements will be initialized\n-    with `initval`\"]\n+    /**\n+     * Overwrites the contents of the element at `idx` with `a`,\n+     * growing the vector if necessary.  New elements will be initialized\n+     * with `initval`\n+     */\n     fn grow_set_elt(idx: uint, initval: A, val: A) {\n         do self.swap |v| {\n             let mut v <- v;\n@@ -269,7 +265,7 @@ impl extensions<A:copy> for dvec<A> {\n         }\n     }\n \n-    #[doc = \"Returns the last element, failing if the vector is empty\"]\n+    /// Returns the last element, failing if the vector is empty\n     #[inline(always)]\n     fn last() -> A {\n         self.check_not_borrowed();\n@@ -282,7 +278,7 @@ impl extensions<A:copy> for dvec<A> {\n         ret self.data[length - 1u];\n     }\n \n-    #[doc=\"Iterates over the elements in reverse order\"]\n+    /// Iterates over the elements in reverse order\n     #[inline(always)]\n     fn reach(f: fn(A) -> bool) {\n         let length = self.len();"}, {"sha": "d1ea214ef0a8dd377d2a91d56121708e621ca6a7", "filename": "src/libcore/either.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,28 +1,28 @@\n-#[doc = \"A type that represents one of two alternatives\"];\n+//! A type that represents one of two alternatives\n \n import result::result;\n \n-#[doc = \"The either type\"]\n+/// The either type\n enum either<T, U> {\n     left(T),\n     right(U)\n }\n \n fn either<T, U, V>(f_left: fn(T) -> V,\n                    f_right: fn(U) -> V, value: either<T, U>) -> V {\n-    #[doc = \"\n-    Applies a function based on the given either value\n-\n-    If `value` is left(T) then `f_left` is applied to its contents, if `value`\n-    is right(U) then `f_right` is applied to its contents, and the result is\n-    returned.\n-    \"];\n+    /*!\n+     * Applies a function based on the given either value\n+     *\n+     * If `value` is left(T) then `f_left` is applied to its contents, if\n+     * `value` is right(U) then `f_right` is applied to its contents, and the\n+     * result is returned.\n+     */\n \n     alt value { left(l) { f_left(l) } right(r) { f_right(r) } }\n }\n \n fn lefts<T: copy, U>(eithers: ~[either<T, U>]) -> ~[T] {\n-    #[doc = \"Extracts from a vector of either all the left values\"];\n+    //! Extracts from a vector of either all the left values\n \n     let mut result: ~[T] = ~[];\n     for vec::each(eithers) |elt| {\n@@ -32,7 +32,7 @@ fn lefts<T: copy, U>(eithers: ~[either<T, U>]) -> ~[T] {\n }\n \n fn rights<T, U: copy>(eithers: ~[either<T, U>]) -> ~[U] {\n-    #[doc = \"Extracts from a vector of either all the right values\"];\n+    //! Extracts from a vector of either all the right values\n \n     let mut result: ~[U] = ~[];\n     for vec::each(eithers) |elt| {\n@@ -43,12 +43,12 @@ fn rights<T, U: copy>(eithers: ~[either<T, U>]) -> ~[U] {\n \n fn partition<T: copy, U: copy>(eithers: ~[either<T, U>])\n     -> {lefts: ~[T], rights: ~[U]} {\n-    #[doc = \"\n-    Extracts from a vector of either all the left values and right values\n-\n-    Returns a structure containing a vector of left values and a vector of\n-    right values.\n-    \"];\n+    /*!\n+     * Extracts from a vector of either all the left values and right values\n+     *\n+     * Returns a structure containing a vector of left values and a vector of\n+     * right values.\n+     */\n \n     let mut lefts: ~[T] = ~[];\n     let mut rights: ~[U] = ~[];\n@@ -62,7 +62,7 @@ fn partition<T: copy, U: copy>(eithers: ~[either<T, U>])\n }\n \n pure fn flip<T: copy, U: copy>(eith: either<T, U>) -> either<U, T> {\n-    #[doc = \"Flips between left and right of a given either\"];\n+    //! Flips between left and right of a given either\n \n     alt eith {\n       right(r) { left(r) }\n@@ -72,12 +72,12 @@ pure fn flip<T: copy, U: copy>(eith: either<T, U>) -> either<U, T> {\n \n pure fn to_result<T: copy, U: copy>(\n     eith: either<T, U>) -> result<U, T> {\n-    #[doc = \"\n-    Converts either::t to a result::t\n-\n-    Converts an `either` type to a `result` type, making the \\\"right\\\" choice\n-    an ok result, and the \\\"left\\\" choice a fail\n-    \"];\n+    /*!\n+     * Converts either::t to a result::t\n+     *\n+     * Converts an `either` type to a `result` type, making the \"right\" choice\n+     * an ok result, and the \"left\" choice a fail\n+     */\n \n     alt eith {\n       right(r) { result::ok(r) }\n@@ -86,13 +86,13 @@ pure fn to_result<T: copy, U: copy>(\n }\n \n pure fn is_left<T, U>(eith: either<T, U>) -> bool {\n-    #[doc = \"Checks whether the given value is a left\"];\n+    //! Checks whether the given value is a left\n \n     alt eith { left(_) { true } _ { false } }\n }\n \n pure fn is_right<T, U>(eith: either<T, U>) -> bool {\n-    #[doc = \"Checks whether the given value is a right\"];\n+    //! Checks whether the given value is a right\n \n     alt eith { right(_) { true } _ { false } }\n }"}, {"sha": "c72aa6e3aef0be8ea71d39546a3a0c524940b7fe", "filename": "src/libcore/f32.rs", "status": "modified", "additions": 29, "deletions": 35, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff32.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Operations and constants for `f32`\"];\n+//! Operations and constants for `f32`\n \n // PORT\n \n@@ -56,49 +56,43 @@ pure fn gt(x: f32, y: f32) -> bool { ret x > y; }\n // FIXME (#1999): replace the predicates below with llvm intrinsics or\n // calls to the libmath macros in the rust runtime for performance.\n \n-#[doc = \"\n-Returns true if `x` is a positive number, including +0.0f320 and +Infinity\n-\"]\n+/// Returns true if `x` is a positive number, including +0.0f320 and +Infinity\n pure fn is_positive(x: f32) -> bool\n     { ret x > 0.0f32 || (1.0f32/x) == infinity; }\n \n-#[doc = \"\n-Returns true if `x` is a negative number, including -0.0f320 and -Infinity\n-\"]\n+/// Returns true if `x` is a negative number, including -0.0f320 and -Infinity\n pure fn is_negative(x: f32) -> bool\n     { ret x < 0.0f32 || (1.0f32/x) == neg_infinity; }\n \n-#[doc = \"\n-Returns true if `x` is a negative number, including -0.0f320 and -Infinity\n-\n-This is the same as `f32::is_negative`.\n-\"]\n+/**\n+ * Returns true if `x` is a negative number, including -0.0f320 and -Infinity\n+ *\n+ * This is the same as `f32::is_negative`.\n+ */\n pure fn is_nonpositive(x: f32) -> bool {\n   ret x < 0.0f32 || (1.0f32/x) == neg_infinity;\n }\n \n-#[doc = \"\n-Returns true if `x` is a positive number, including +0.0f320 and +Infinity\n-\n-This is the same as `f32::is_positive`.)\n-\"]\n+/**\n+ * Returns true if `x` is a positive number, including +0.0f320 and +Infinity\n+ *\n+ * This is the same as `f32::is_positive`.)\n+ */\n pure fn is_nonnegative(x: f32) -> bool {\n   ret x > 0.0f32 || (1.0f32/x) == infinity;\n }\n \n-#[doc = \"\n-Returns true if `x` is a zero number (positive or negative zero)\n-\"]\n+/// Returns true if `x` is a zero number (positive or negative zero)\n pure fn is_zero(x: f32) -> bool {\n     ret x == 0.0f32 || x == -0.0f32;\n }\n \n-#[doc = \"Returns true if `x`is an infinite number\"]\n+/// Returns true if `x`is an infinite number\n pure fn is_infinite(x: f32) -> bool {\n     ret x == infinity || x == neg_infinity;\n }\n \n-#[doc = \"Returns true if `x`is a finite number\"]\n+/// Returns true if `x`is a finite number\n pure fn is_finite(x: f32) -> bool {\n     ret !(is_NaN(x) || is_infinite(x));\n }\n@@ -110,43 +104,43 @@ mod consts {\n \n     // FIXME (requires Issue #1433 to fix): replace with mathematical\n     // constants from cmath.\n-    #[doc = \"Archimedes' constant\"]\n+    /// Archimedes' constant\n     const pi: f32 = 3.14159265358979323846264338327950288_f32;\n \n-    #[doc = \"pi/2.0\"]\n+    /// pi/2.0\n     const frac_pi_2: f32 = 1.57079632679489661923132169163975144_f32;\n \n-    #[doc = \"pi/4.0\"]\n+    /// pi/4.0\n     const frac_pi_4: f32 = 0.785398163397448309615660845819875721_f32;\n \n-    #[doc = \"1.0/pi\"]\n+    /// 1.0/pi\n     const frac_1_pi: f32 = 0.318309886183790671537767526745028724_f32;\n \n-    #[doc = \"2.0/pi\"]\n+    /// 2.0/pi\n     const frac_2_pi: f32 = 0.636619772367581343075535053490057448_f32;\n \n-    #[doc = \"2.0/sqrt(pi)\"]\n+    /// 2.0/sqrt(pi)\n     const frac_2_sqrtpi: f32 = 1.12837916709551257389615890312154517_f32;\n \n-    #[doc = \"sqrt(2.0)\"]\n+    /// sqrt(2.0)\n     const sqrt2: f32 = 1.41421356237309504880168872420969808_f32;\n \n-    #[doc = \"1.0/sqrt(2.0)\"]\n+    /// 1.0/sqrt(2.0)\n     const frac_1_sqrt2: f32 = 0.707106781186547524400844362104849039_f32;\n \n-    #[doc = \"Euler's number\"]\n+    /// Euler's number\n     const e: f32 = 2.71828182845904523536028747135266250_f32;\n \n-    #[doc = \"log2(e)\"]\n+    /// log2(e)\n     const log2_e: f32 = 1.44269504088896340735992468100189214_f32;\n \n-    #[doc = \"log10(e)\"]\n+    /// log10(e)\n     const log10_e: f32 = 0.434294481903251827651128918916605082_f32;\n \n-    #[doc = \"ln(2.0)\"]\n+    /// ln(2.0)\n     const ln_2: f32 = 0.693147180559945309417232121458176568_f32;\n \n-    #[doc = \"ln(10.0)\"]\n+    /// ln(10.0)\n     const ln_10: f32 = 2.30258509299404568401799145468436421_f32;\n }\n "}, {"sha": "40488d9f8f4f7a146153fceee54a6014afa27ace", "filename": "src/libcore/f64.rs", "status": "modified", "additions": 29, "deletions": 33, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ff64.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Operations and constants for `f64`\"];\n+//! Operations and constants for `f64`\n \n // PORT\n \n@@ -83,47 +83,43 @@ pure fn sqrt(x: f64) -> f64 {\n     cmath::c_double::sqrt(x as libc::c_double) as f64\n }\n \n-#[doc = \"\n-Returns true if `x` is a positive number, including +0.0f640 and +Infinity.\n-\"]\n+/// Returns true if `x` is a positive number, including +0.0f640 and +Infinity\n pure fn is_positive(x: f64) -> bool\n     { ret x > 0.0f64 || (1.0f64/x) == infinity; }\n \n-#[doc = \"\n-Returns true if `x` is a negative number, including -0.0f640 and -Infinity\n-\"]\n+/// Returns true if `x` is a negative number, including -0.0f640 and -Infinity\n pure fn is_negative(x: f64) -> bool\n     { ret x < 0.0f64 || (1.0f64/x) == neg_infinity; }\n \n-#[doc = \"\n-Returns true if `x` is a negative number, including -0.0f640 and -Infinity\n-\n-This is the same as `f64::is_negative`.\n-\"]\n+/**\n+ * Returns true if `x` is a negative number, including -0.0f640 and -Infinity\n+ *\n+ * This is the same as `f64::is_negative`.\n+ */\n pure fn is_nonpositive(x: f64) -> bool {\n   ret x < 0.0f64 || (1.0f64/x) == neg_infinity;\n }\n \n-#[doc = \"\n-Returns true if `x` is a positive number, including +0.0f640 and +Infinity\n-\n-This is the same as `f64::positive`.\n-\"]\n+/**\n+ * Returns true if `x` is a positive number, including +0.0f640 and +Infinity\n+ *\n+ * This is the same as `f64::positive`.\n+ */\n pure fn is_nonnegative(x: f64) -> bool {\n   ret x > 0.0f64 || (1.0f64/x) == infinity;\n }\n \n-#[doc = \"Returns true if `x` is a zero number (positive or negative zero)\"]\n+/// Returns true if `x` is a zero number (positive or negative zero)\n pure fn is_zero(x: f64) -> bool {\n     ret x == 0.0f64 || x == -0.0f64;\n }\n \n-#[doc = \"Returns true if `x`is an infinite number\"]\n+/// Returns true if `x`is an infinite number\n pure fn is_infinite(x: f64) -> bool {\n     ret x == infinity || x == neg_infinity;\n }\n \n-#[doc = \"Returns true if `x`is a finite number\"]\n+/// Returns true if `x`is a finite number\n pure fn is_finite(x: f64) -> bool {\n     ret !(is_NaN(x) || is_infinite(x));\n }\n@@ -135,43 +131,43 @@ mod consts {\n \n     // FIXME (requires Issue #1433 to fix): replace with mathematical\n     // constants from cmath.\n-    #[doc = \"Archimedes' constant\"]\n+    /// Archimedes' constant\n     const pi: f64 = 3.14159265358979323846264338327950288_f64;\n \n-    #[doc = \"pi/2.0\"]\n+    /// pi/2.0\n     const frac_pi_2: f64 = 1.57079632679489661923132169163975144_f64;\n \n-    #[doc = \"pi/4.0\"]\n+    /// pi/4.0\n     const frac_pi_4: f64 = 0.785398163397448309615660845819875721_f64;\n \n-    #[doc = \"1.0/pi\"]\n+    /// 1.0/pi\n     const frac_1_pi: f64 = 0.318309886183790671537767526745028724_f64;\n \n-    #[doc = \"2.0/pi\"]\n+    /// 2.0/pi\n     const frac_2_pi: f64 = 0.636619772367581343075535053490057448_f64;\n \n-    #[doc = \"2.0/sqrt(pi)\"]\n+    /// 2.0/sqrt(pi)\n     const frac_2_sqrtpi: f64 = 1.12837916709551257389615890312154517_f64;\n \n-    #[doc = \"sqrt(2.0)\"]\n+    /// sqrt(2.0)\n     const sqrt2: f64 = 1.41421356237309504880168872420969808_f64;\n \n-    #[doc = \"1.0/sqrt(2.0)\"]\n+    /// 1.0/sqrt(2.0)\n     const frac_1_sqrt2: f64 = 0.707106781186547524400844362104849039_f64;\n \n-    #[doc = \"Euler's number\"]\n+    /// Euler's number\n     const e: f64 = 2.71828182845904523536028747135266250_f64;\n \n-    #[doc = \"log2(e)\"]\n+    /// log2(e)\n     const log2_e: f64 = 1.44269504088896340735992468100189214_f64;\n \n-    #[doc = \"log10(e)\"]\n+    /// log10(e)\n     const log10_e: f64 = 0.434294481903251827651128918916605082_f64;\n \n-    #[doc = \"ln(2.0)\"]\n+    /// ln(2.0)\n     const ln_2: f64 = 0.693147180559945309417232121458176568_f64;\n \n-    #[doc = \"ln(10.0)\"]\n+    /// ln(10.0)\n     const ln_10: f64 = 2.30258509299404568401799145468436421_f64;\n }\n "}, {"sha": "7d13602ecc01b59b37777aafa2ad00419fb7d107", "filename": "src/libcore/float.rs", "status": "modified", "additions": 79, "deletions": 79, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Operations and constants for `float`\"];\n+//! Operations and constants for `float`\n \n // Even though this module exports everything defined in it,\n // because it contains re-exports, we also have to explicitly\n@@ -49,59 +49,59 @@ mod consts {\n \n     // FIXME (requires Issue #1433 to fix): replace with mathematical\n     // constants from cmath.\n-    #[doc = \"Archimedes' constant\"]\n+    /// Archimedes' constant\n     const pi: float = 3.14159265358979323846264338327950288;\n \n-    #[doc = \"pi/2.0\"]\n+    /// pi/2.0\n     const frac_pi_2: float = 1.57079632679489661923132169163975144;\n \n-    #[doc = \"pi/4.0\"]\n+    /// pi/4.0\n     const frac_pi_4: float = 0.785398163397448309615660845819875721;\n \n-    #[doc = \"1.0/pi\"]\n+    /// 1.0/pi\n     const frac_1_pi: float = 0.318309886183790671537767526745028724;\n \n-    #[doc = \"2.0/pi\"]\n+    /// 2.0/pi\n     const frac_2_pi: float = 0.636619772367581343075535053490057448;\n \n-    #[doc = \"2.0/sqrt(pi)\"]\n+    /// 2.0/sqrt(pi)\n     const frac_2_sqrtpi: float = 1.12837916709551257389615890312154517;\n \n-    #[doc = \"sqrt(2.0)\"]\n+    /// sqrt(2.0)\n     const sqrt2: float = 1.41421356237309504880168872420969808;\n \n-    #[doc = \"1.0/sqrt(2.0)\"]\n+    /// 1.0/sqrt(2.0)\n     const frac_1_sqrt2: float = 0.707106781186547524400844362104849039;\n \n-    #[doc = \"Euler's number\"]\n+    /// Euler's number\n     const e: float = 2.71828182845904523536028747135266250;\n \n-    #[doc = \"log2(e)\"]\n+    /// log2(e)\n     const log2_e: float = 1.44269504088896340735992468100189214;\n \n-    #[doc = \"log10(e)\"]\n+    /// log10(e)\n     const log10_e: float = 0.434294481903251827651128918916605082;\n \n-    #[doc = \"ln(2.0)\"]\n+    /// ln(2.0)\n     const ln_2: float = 0.693147180559945309417232121458176568;\n \n-    #[doc = \"ln(10.0)\"]\n+    /// ln(10.0)\n     const ln_10: float = 2.30258509299404568401799145468436421;\n }\n \n /**\n  * Section: String Conversions\n  */\n \n-#[doc = \"\n-Converts a float to a string\n-\n-# Arguments\n-\n-* num - The float value\n-* digits - The number of significant digits\n-* exact - Whether to enforce the exact number of significant digits\n-\"]\n+/**\n+ * Converts a float to a string\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ * * digits - The number of significant digits\n+ * * exact - Whether to enforce the exact number of significant digits\n+ */\n fn to_str_common(num: float, digits: uint, exact: bool) -> str {\n     if is_NaN(num) { ret \"NaN\"; }\n     if num == infinity { ret \"inf\"; }\n@@ -179,15 +179,15 @@ fn to_str_common(num: float, digits: uint, exact: bool) -> str {\n     ret acc;\n }\n \n-#[doc = \"\n-Converts a float to a string with exactly the number of\n-provided significant digits\n-\n-# Arguments\n-\n-* num - The float value\n-* digits - The number of significant digits\n-\"]\n+/**\n+ * Converts a float to a string with exactly the number of\n+ * provided significant digits\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ * * digits - The number of significant digits\n+ */\n fn to_str_exact(num: float, digits: uint) -> str {\n     to_str_common(num, digits, true)\n }\n@@ -199,45 +199,45 @@ fn test_to_str_exact_do_decimal() {\n }\n \n \n-#[doc = \"\n-Converts a float to a string with a maximum number of\n-significant digits\n-\n-# Arguments\n-\n-* num - The float value\n-* digits - The number of significant digits\n-\"]\n+/**\n+ * Converts a float to a string with a maximum number of\n+ * significant digits\n+ *\n+ * # Arguments\n+ *\n+ * * num - The float value\n+ * * digits - The number of significant digits\n+ */\n fn to_str(num: float, digits: uint) -> str {\n     to_str_common(num, digits, false)\n }\n \n-#[doc = \"\n-Convert a string to a float\n-\n-This function accepts strings such as\n-\n-* '3.14'\n-* '+3.14', equivalent to '3.14'\n-* '-3.14'\n-* '2.5E10', or equivalently, '2.5e10'\n-* '2.5E-10'\n-* '', or, equivalently, '.' (understood as 0)\n-* '5.'\n-* '.5', or, equivalently,  '0.5'\n-* 'inf', '-inf', 'NaN'\n-\n-Leading and trailing whitespace are ignored.\n-\n-# Arguments\n-\n-* num - A string\n-\n-# Return value\n-\n-`none` if the string did not represent a valid number.  Otherwise, `some(n)`\n-where `n` is the floating-point number represented by `[num]/~`.\n-\"]\n+/**\n+ * Convert a string to a float\n+ *\n+ * This function accepts strings such as\n+ *\n+ * * '3.14'\n+ * * '+3.14', equivalent to '3.14'\n+ * * '-3.14'\n+ * * '2.5E10', or equivalently, '2.5e10'\n+ * * '2.5E-10'\n+ * * '', or, equivalently, '.' (understood as 0)\n+ * * '5.'\n+ * * '.5', or, equivalently,  '0.5'\n+ * * 'inf', '-inf', 'NaN'\n+ *\n+ * Leading and trailing whitespace are ignored.\n+ *\n+ * # Arguments\n+ *\n+ * * num - A string\n+ *\n+ * # Return value\n+ *\n+ * `none` if the string did not represent a valid number.  Otherwise,\n+ * `some(n)` where `n` is the floating-point number represented by `[num]/~`.\n+ */\n fn from_str(num: str) -> option<float> {\n    if num == \"inf\" {\n        ret some(infinity as float);\n@@ -371,18 +371,18 @@ fn from_str(num: str) -> option<float> {\n  * Section: Arithmetics\n  */\n \n-#[doc = \"\n-Compute the exponentiation of an integer by another integer as a float\n-\n-# Arguments\n-\n-* x - The base\n-* pow - The exponent\n-\n-# Return value\n-\n-`NaN` if both `x` and `pow` are `0u`, otherwise `x^pow`\n-\"]\n+/**\n+ * Compute the exponentiation of an integer by another integer as a float\n+ *\n+ * # Arguments\n+ *\n+ * * x - The base\n+ * * pow - The exponent\n+ *\n+ * # Return value\n+ *\n+ * `NaN` if both `x` and `pow` are `0u`, otherwise `x^pow`\n+ */\n fn pow_with_uint(base: uint, pow: uint) -> float {\n     if base == 0u {\n         if pow == 0u {"}, {"sha": "322b75da7dae79e2f5c95b67a7123c47ab802478", "filename": "src/libcore/future.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,15 +1,15 @@\n-#[doc = \"\n-A type representing values that may be computed concurrently and\n-operations for working with them.\n-\n-# Example\n-\n-~~~\n-let delayed_fib = future::spawn {|| fib(5000) };\n-make_a_sandwich();\n-io::println(#fmt(\\\"fib(5000) = %?\\\", delayed_fib.get()))\n-~~~\n-\"];\n+/*!\n+ * A type representing values that may be computed concurrently and\n+ * operations for working with them.\n+ *\n+ * # Example\n+ *\n+ * ~~~\n+ * let delayed_fib = future::spawn {|| fib(5000) };\n+ * make_a_sandwich();\n+ * io::println(#fmt(\"fib(5000) = %?\", delayed_fib.get()))\n+ * ~~~\n+ */\n \n import either::either;\n \n@@ -22,74 +22,74 @@ export get;\n export with;\n export spawn;\n \n-#[doc = \"The future type\"]\n+/// The future type\n enum future<A> = {\n     mut v: either<@A, fn@() -> A>\n };\n \n-#[doc = \"Methods on the `future` type\"]\n+/// Methods on the `future` type\n impl extensions<A:copy send> for future<A> {\n \n     fn get() -> A {\n-        #[doc = \"Get the value of the future\"];\n+        //! Get the value of the future\n \n         get(self)\n     }\n \n     fn with<B>(blk: fn(A) -> B) -> B {\n-        #[doc = \"Work with the value without copying it\"];\n+        //! Work with the value without copying it\n \n         with(self, blk)\n     }\n }\n \n fn from_value<A>(+val: A) -> future<A> {\n-    #[doc = \"\n-    Create a future from a value\n-\n-    The value is immediately available and calling `get` later will\n-    not block.\n-    \"];\n+    /*!\n+     * Create a future from a value\n+     *\n+     * The value is immediately available and calling `get` later will\n+     * not block.\n+     */\n \n     future({\n         mut v: either::left(@val)\n     })\n }\n \n fn from_port<A:send>(-port: comm::port<A>) -> future<A> {\n-    #[doc = \"\n-    Create a future from a port\n-\n-    The first time that the value is requested the task will block\n-    waiting for the result to be received on the port.\n-    \"];\n+    /*!\n+     * Create a future from a port\n+     *\n+     * The first time that the value is requested the task will block\n+     * waiting for the result to be received on the port.\n+     */\n \n     do from_fn {\n         comm::recv(port)\n     }\n }\n \n fn from_fn<A>(f: fn@() -> A) -> future<A> {\n-    #[doc = \"\n-    Create a future from a function.\n-\n-    The first time that the value is requested it will be retreived by\n-    calling the function.  Note that this function is a local\n-    function. It is not spawned into another task.\n-    \"];\n+    /*!\n+     * Create a future from a function.\n+     *\n+     * The first time that the value is requested it will be retreived by\n+     * calling the function.  Note that this function is a local\n+     * function. It is not spawned into another task.\n+     */\n \n     future({\n         mut v: either::right(f)\n     })\n }\n \n fn spawn<A:send>(+blk: fn~() -> A) -> future<A> {\n-    #[doc = \"\n-    Create a future from a unique closure.\n-\n-    The closure will be run in a new task and its result used as the\n-    value of the future.\n-    \"];\n+    /*!\n+     * Create a future from a unique closure.\n+     *\n+     * The closure will be run in a new task and its result used as the\n+     * value of the future.\n+     */\n \n     let mut po = comm::port();\n     let ch = comm::chan(po);\n@@ -100,13 +100,13 @@ fn spawn<A:send>(+blk: fn~() -> A) -> future<A> {\n }\n \n fn get<A:copy>(future: future<A>) -> A {\n-    #[doc = \"Get the value of the future\"];\n+    //! Get the value of the future\n \n     do with(future) |v| { v }\n }\n \n fn with<A,B>(future: future<A>, blk: fn(A) -> B) -> B {\n-    #[doc = \"Work with the value without copying it\"];\n+    //! Work with the value without copying it\n \n     let v = alt copy future.v {\n       either::left(v) { v }"}, {"sha": "407b810e95d5ca76d71745227127b1aa464c29ad", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -38,7 +38,7 @@ pure fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n \n #[inline(always)]\n-#[doc = \"Iterate over the range [`lo`..`hi`)\"]\n+/// Iterate over the range [`lo`..`hi`)\n fn range(lo: T, hi: T, it: fn(T) -> bool) {\n     let mut i = lo;\n     while i < hi {\n@@ -47,25 +47,25 @@ fn range(lo: T, hi: T, it: fn(T) -> bool) {\n     }\n }\n \n-#[doc = \"Computes the bitwise complement\"]\n+/// Computes the bitwise complement\n pure fn compl(i: T) -> T {\n     -1 as T ^ i\n }\n \n-#[doc = \"Computes the absolute value\"]\n+/// Computes the absolute value\n // FIXME: abs should return an unsigned int (#2353)\n pure fn abs(i: T) -> T {\n     if is_negative(i) { -i } else { i }\n }\n \n-#[doc = \"\n-Parse a buffer of bytes\n-\n-# Arguments\n-\n-* buf - A byte buffer\n-* radix - The base of the number\n-\"]\n+/**\n+ * Parse a buffer of bytes\n+ *\n+ * # Arguments\n+ *\n+ * * buf - A byte buffer\n+ * * radix - The base of the number\n+ */\n fn parse_buf(buf: ~[u8], radix: uint) -> option<T> {\n     if vec::len(buf) == 0u { ret none; }\n     let mut i = vec::len(buf) - 1u;\n@@ -88,10 +88,10 @@ fn parse_buf(buf: ~[u8], radix: uint) -> option<T> {\n     };\n }\n \n-#[doc = \"Parse a string to an int\"]\n+/// Parse a string to an int\n fn from_str(s: str) -> option<T> { parse_buf(str::bytes(s), 10u) }\n \n-#[doc = \"Convert to a string in a given base\"]\n+/// Convert to a string in a given base\n fn to_str(n: T, radix: uint) -> str {\n     do to_str_bytes(n, radix) |slice| {\n         do vec::unpack_slice(slice) |p, len| {\n@@ -108,7 +108,7 @@ fn to_str_bytes<U>(n: T, radix: uint, f: fn(v: &[u8]) -> U) -> U {\n     }\n }\n \n-#[doc = \"Convert to a string\"]\n+/// Convert to a string\n fn str(i: T) -> str { ret to_str(i, 10u); }\n \n impl ord of ord for T {"}, {"sha": "07acb4be8ce1f5ebe6eb40cd2dfce11bd990e960", "filename": "src/libcore/int-template/int.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fint-template%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fint-template%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template%2Fint.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -6,10 +6,10 @@ const bits: T = 32 as T;\n #[cfg(target_arch = \"x86_64\")]\n const bits: T = 64 as T;\n \n-#[doc = \"Produce a uint suitable for use in a hash table\"]\n+/// Produce a uint suitable for use in a hash table\n pure fn hash(&&x: int) -> uint { ret x as uint; }\n \n-#[doc = \"Returns `base` raised to the power of `exponent`\"]\n+/// Returns `base` raised to the power of `exponent`\n fn pow(base: int, exponent: uint) -> int {\n     if exponent == 0u { ret 1; } //Not mathemtically true if ~[base == 0]\n     if base     == 0  { ret 0; }"}, {"sha": "d34ea38034dea87ef4788abfba6fdb5ae67b060d", "filename": "src/libcore/iter-trait/dlist.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdlist.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,12 +1,12 @@\n type IMPL_T<A> = dlist::dlist<A>;\n \n-#[doc = \"\n-Iterates through the current contents.\n-\n-Attempts to access this dlist during iteration are allowed (to allow for e.g.\n-breadth-first search with in-place enqueues), but removing the current node\n-is forbidden.\n-\"]\n+/**\n+ * Iterates through the current contents.\n+ *\n+ * Attempts to access this dlist during iteration are allowed (to allow for\n+ * e.g. breadth-first search with in-place enqueues), but removing the current\n+ * node is forbidden.\n+ */\n fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n     import dlist::extensions;\n "}, {"sha": "efab0b70b5754dff9ffc04179e26adadd0f101d1", "filename": "src/libcore/iter-trait/dvec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdvec.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,10 +1,10 @@\n type IMPL_T<A> = dvec::dvec<A>;\n \n-#[doc = \"\n-Iterates through the current contents.\n-\n-Attempts to access this dvec during iteration will fail.\n-\"]\n+/**\n+ * Iterates through the current contents.\n+ *\n+ * Attempts to access this dvec during iteration will fail.\n+ */\n fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n     import dvec::extensions;\n     self.swap(|v| { vec::each(v, f); v })"}, {"sha": "740a78a6d9ceec4f49bef209f8c4de10343de45c", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,38 +1,38 @@\n-#[doc = \"\n-Bindings for libc.\n-\n-We consider the following specs reasonably normative with respect\n-to interoperating with the C standard library (libc/msvcrt):\n-\n-* ISO 9899:1990 ('C95', 'ANSI C', 'Standard C'), NA1, 1995.\n-* ISO 9899:1999 ('C99' or 'C9x').\n-* ISO 9945:1988 / IEEE 1003.1-1988 ('POSIX.1').\n-* ISO 9945:2001 / IEEE 1003.1-2001 ('POSIX:2001', 'SUSv3').\n-* ISO 9945:2008 / IEEE 1003.1-2008 ('POSIX:2008', 'SUSv4').\n-\n-Despite having several names each, these are *reasonably* coherent\n-point-in-time, list-of-definition sorts of specs. You can get each under a\n-variety of names but will wind up with the same definition in each case.\n-\n-Our interface to these libraries is complicated by the non-universality of\n-conformance to any of them. About the only thing universally supported is\n-the first (C95), beyond that definitions quickly become absent on various\n-platforms.\n-\n-We therefore wind up dividing our module-space up (mostly for the sake of\n-sanity while editing, filling-in-details and eliminating duplication) into\n-definitions common-to-all (held in modules named c95, c99, posix88, posix01\n-and posix08) and definitions that appear only on *some* platforms (named\n-'extra'). This would be things like significant OSX foundation kit, or\n-win32 library kernel32.dll, or various fancy glibc, linux or BSD\n-extensions.\n-\n-In addition to the per-platform 'extra' modules, we define a module of\n-'common BSD' libc routines that never quite made it into POSIX but show up\n-in multiple derived systems. This is the 4.4BSD r2 / 1995 release, the\n-final one from Berkeley after the lawsuits died down and the CSRG\n-dissolved.\n-\"];\n+/*!\n+ * Bindings for libc.\n+ *\n+ * We consider the following specs reasonably normative with respect\n+ * to interoperating with the C standard library (libc/msvcrt):\n+ *\n+ * * ISO 9899:1990 ('C95', 'ANSI C', 'Standard C'), NA1, 1995.\n+ * * ISO 9899:1999 ('C99' or 'C9x').\n+ * * ISO 9945:1988 / IEEE 1003.1-1988 ('POSIX.1').\n+ * * ISO 9945:2001 / IEEE 1003.1-2001 ('POSIX:2001', 'SUSv3').\n+ * * ISO 9945:2008 / IEEE 1003.1-2008 ('POSIX:2008', 'SUSv4').\n+ *\n+ * Despite having several names each, these are *reasonably* coherent\n+ * point-in-time, list-of-definition sorts of specs. You can get each under a\n+ * variety of names but will wind up with the same definition in each case.\n+ *\n+ * Our interface to these libraries is complicated by the non-universality of\n+ * conformance to any of them. About the only thing universally supported is\n+ * the first (C95), beyond that definitions quickly become absent on various\n+ * platforms.\n+ *\n+ * We therefore wind up dividing our module-space up (mostly for the sake of\n+ * sanity while editing, filling-in-details and eliminating duplication) into\n+ * definitions common-to-all (held in modules named c95, c99, posix88, posix01\n+ * and posix08) and definitions that appear only on *some* platforms (named\n+ * 'extra'). This would be things like significant OSX foundation kit, or\n+ * win32 library kernel32.dll, or various fancy glibc, linux or BSD\n+ * extensions.\n+ *\n+ * In addition to the per-platform 'extra' modules, we define a module of\n+ * 'common BSD' libc routines that never quite made it into POSIX but show up\n+ * in multiple derived systems. This is the 4.4BSD r2 / 1995 release, the\n+ * final one from Berkeley after the lawsuits died down and the CSRG\n+ * dissolved.\n+ */\n \n // Initial glob-exports mean that all the contents of all the modules\n // wind up exported, if you're interested in writing platform-specific code."}, {"sha": "1e233dfe8d53455c8ceb79d37e8a4d50b0b8bdb9", "filename": "src/libcore/logging.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flogging.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Logging\"];\n+//! Logging\n \n export console_on, console_off;\n \n@@ -8,18 +8,18 @@ extern mod rustrt {\n     fn rust_log_console_off();\n }\n \n-#[doc = \"Turns on logging to stdout globally\"]\n+/// Turns on logging to stdout globally\n fn console_on() {\n     rustrt::rust_log_console_on();\n }\n \n-#[doc = \"\n-Turns off logging to stdout globally\n-\n-Turns off the console unless the user has overridden the\n-runtime environment's logging spec, e.g. by setting\n-the RUST_LOG environment variable\n-\"]\n+/**\n+ * Turns off logging to stdout globally\n+ *\n+ * Turns off the console unless the user has overridden the\n+ * runtime environment's logging spec, e.g. by setting\n+ * the RUST_LOG environment variable\n+ */\n fn console_off() {\n     rustrt::rust_log_console_off();\n }\n\\ No newline at end of file"}, {"sha": "e78b8551c6dd47aad3ae0bc4288b9e8862a8d43e", "filename": "src/libcore/newcomm.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fnewcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fnewcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnewcomm.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,7 +1,9 @@\n-#[doc=\"A new implementation of communication.\n-\n-This should be implementing almost entirely in Rust, and hopefully\n-avoid needing a single global lock.\"]\n+/**\n+ * A new implementation of communication.\n+ *\n+ * This should be implementing almost entirely in Rust, and hopefully\n+ * avoid needing a single global lock.\n+ */\n \n import arc::methods;\n import dvec::dvec;"}, {"sha": "551b444d89cfec33725a8bcc2f63f17ea5b1e272", "filename": "src/libcore/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc=\"An interface for numbers.\"]\n+/// An interface for numbers.\n \n iface num {\n     // FIXME: Cross-crate overloading doesn't work yet. (#2615)"}, {"sha": "ac7dd013be9ae6391d242aac6153dc2b222a0b89", "filename": "src/libcore/option.rs", "status": "modified", "additions": 66, "deletions": 64, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,26 +1,27 @@\n-#[doc = \"\n-Operations on the ubiquitous `option` type.\n-\n-Type `option` represents an optional value.\n-\n-Every `option<T>` value can either be `some(T)` or `none`. Where in other\n-languages you might use a nullable type, in Rust you would use an option type.\n-\"];\n-\n-#[doc = \"The option type\"]\n+/*!\n+ * Operations on the ubiquitous `option` type.\n+ *\n+ * Type `option` represents an optional value.\n+ *\n+ * Every `option<T>` value can either be `some(T)` or `none`. Where in other\n+ * languages you might use a nullable type, in Rust you would use an option\n+ * type.\n+ */\n+\n+/// The option type\n enum option<T> {\n     none,\n     some(T),\n }\n \n pure fn get<T: copy>(opt: option<T>) -> T {\n-    #[doc = \"\n-    Gets the value out of an option\n-\n-    # Failure\n-\n-    Fails if the value equals `none`\n-    \"];\n+    /*!\n+     * Gets the value out of an option\n+     *\n+     * # Failure\n+     *\n+     * Fails if the value equals `none`\n+     */\n \n     alt opt { some(x) { ret x; } none { fail \"option none\"; } }\n }\n@@ -37,57 +38,57 @@ pure fn expect<T: copy>(opt: option<T>, reason: str) -> T {\n }\n \n pure fn map<T, U: copy>(opt: option<T>, f: fn(T) -> U) -> option<U> {\n-    #[doc = \"Maps a `some` value from one type to another\"];\n+    //! Maps a `some` value from one type to another\n \n     alt opt { some(x) { some(f(x)) } none { none } }\n }\n \n pure fn chain<T, U>(opt: option<T>, f: fn(T) -> option<U>) -> option<U> {\n-    #[doc = \"\n-    Update an optional value by optionally running its content through a\n-    function that returns an option.\n-    \"];\n+    /*!\n+     * Update an optional value by optionally running its content through a\n+     * function that returns an option.\n+     */\n \n     alt opt { some(x) { f(x) } none { none } }\n }\n \n pure fn is_none<T>(opt: option<T>) -> bool {\n-    #[doc = \"Returns true if the option equals `none`\"];\n+    //! Returns true if the option equals `none`\n \n     alt opt { none { true } some(_) { false } }\n }\n \n pure fn is_some<T>(opt: option<T>) -> bool {\n-    #[doc = \"Returns true if the option contains some value\"];\n+    //! Returns true if the option contains some value\n \n     !is_none(opt)\n }\n \n pure fn get_default<T: copy>(opt: option<T>, def: T) -> T {\n-    #[doc = \"Returns the contained value or a default\"];\n+    //! Returns the contained value or a default\n \n     alt opt { some(x) { x } none { def } }\n }\n \n pure fn map_default<T, U: copy>(opt: option<T>, def: U, f: fn(T) -> U) -> U {\n-    #[doc = \"Applies a function to the contained value or returns a default\"];\n+    //! Applies a function to the contained value or returns a default\n \n     alt opt { none { def } some(t) { f(t) } }\n }\n \n pure fn iter<T>(opt: option<T>, f: fn(T)) {\n-    #[doc = \"Performs an operation on the contained value or does nothing\"];\n+    //! Performs an operation on the contained value or does nothing\n \n     alt opt { none { } some(t) { f(t); } }\n }\n \n pure fn unwrap<T>(-opt: option<T>) -> T {\n-    #[doc = \"\n-    Moves a value out of an option type and returns it.\n-\n-    Useful primarily for getting strings, vectors and unique pointers out of\n-    option types without copying them.\n-    \"];\n+    /*!\n+     * Moves a value out of an option type and returns it.\n+     *\n+     * Useful primarily for getting strings, vectors and unique pointers out\n+     * of option types without copying them.\n+     */\n \n     unsafe {\n         let addr = alt opt {\n@@ -101,41 +102,42 @@ pure fn unwrap<T>(-opt: option<T>) -> T {\n }\n \n impl extensions<T> for option<T> {\n-    #[doc = \"\n-    Update an optional value by optionally running its content through a\n-    function that returns an option.\n-    \"]\n-    pure fn chain<U>(f: fn(T) -> option<U>) -> option<U> { chain(self, f) }\n-    #[doc = \"Applies a function to the contained value or returns a default\"]\n-    pure fn map_default<U: copy>(def: U, f: fn(T) -> U) -> U\n+    /**\n+     * Update an optional value by optionally running its content through a\n+     * function that returns an option.\n+     */\n+    fn chain<U>(f: fn(T) -> option<U>) -> option<U> { chain(self, f) }\n+    /// Applies a function to the contained value or returns a default\n+    fn map_default<U: copy>(def: U, f: fn(T) -> U) -> U\n         { map_default(self, def, f) }\n-    #[doc = \"Performs an operation on the contained value or does nothing\"]\n-    pure fn iter(f: fn(T)) { iter(self, f) }\n-    #[doc = \"Returns true if the option equals `none`\"]\n-    pure fn is_none() -> bool { is_none(self) }\n-    #[doc = \"Returns true if the option contains some value\"]\n-    pure fn is_some() -> bool { is_some(self) }\n-    #[doc = \"Maps a `some` value from one type to another\"]\n-    pure fn map<U:copy>(f: fn(T) -> U) -> option<U> { map(self, f) }\n+    /// Performs an operation on the contained value or does nothing\n+    fn iter(f: fn(T)) { iter(self, f) }\n+    /// Returns true if the option equals `none`\n+    fn is_none() -> bool { is_none(self) }\n+    /// Returns true if the option contains some value\n+    fn is_some() -> bool { is_some(self) }\n+    /// Maps a `some` value from one type to another\n+    fn map<U:copy>(f: fn(T) -> U) -> option<U> { map(self, f) }\n }\n \n impl extensions<T: copy> for option<T> {\n-    #[doc = \"\n-    Gets the value out of an option\n-\n-    # Failure\n-\n-    Fails if the value equals `none`\n-    \"]\n-    pure fn get() -> T { get(self) }\n-    pure fn get_default(def: T) -> T { get_default(self, def) }\n-    #[doc = \"\n-    Gets the value out of an option, printing a specified message on failure\n-\n-    # Failure\n-\n-    Fails if the value equals `none`\n-    \"]\n+    /**\n+     * Gets the value out of an option\n+     *\n+     * # Failure\n+     *\n+     * Fails if the value equals `none`\n+     */\n+    fn get() -> T { get(self) }\n+    fn get_default(def: T) -> T { get_default(self, def) }\n+    /**\n+     * Gets the value out of an option, printing a specified message on\n+     * failure\n+     *\n+     * # Failure\n+     *\n+     * Fails if the value equals `none`\n+     */\n     pure fn expect(reason: str) -> T { expect(self, reason) }\n }\n "}, {"sha": "808552fca6c0266e1c3c7122aae932131314b17b", "filename": "src/libcore/os.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,20 +1,20 @@\n-#[doc = \"\n-Higher-level interfaces to libc::* functions and operating system services.\n-\n-In general these take and return rust types, use rust idioms (enums,\n-closures, vectors) rather than C idioms, and do more extensive safety\n-checks.\n-\n-This module is not meant to only contain 1:1 mappings to libc entries; any\n-os-interface code that is reasonably useful and broadly applicable can go\n-here. Including utility routines that merely build on other os code.\n-\n-We assume the general case is that users do not care, and do not want to\n-be made to care, which operating system they are on. While they may want\n-to special case various special cases -- and so we will not _hide_ the\n-facts of which OS the user is on -- they should be given the opportunity\n-to write OS-ignorant code by default.\n-\"];\n+/*!\n+ * Higher-level interfaces to libc::* functions and operating system services.\n+ *\n+ * In general these take and return rust types, use rust idioms (enums,\n+ * closures, vectors) rather than C idioms, and do more extensive safety\n+ * checks.\n+ *\n+ * This module is not meant to only contain 1:1 mappings to libc entries; any\n+ * os-interface code that is reasonably useful and broadly applicable can go\n+ * here. Including utility routines that merely build on other os code.\n+ *\n+ * We assume the general case is that users do not care, and do not want to\n+ * be made to care, which operating system they are on. While they may want\n+ * to special case various special cases -- and so we will not _hide_ the\n+ * facts of which OS the user is on -- they should be given the opportunity\n+ * to write OS-ignorant code by default.\n+ */\n \n import libc::{c_char, c_void, c_int, c_uint, size_t, ssize_t,\n               mode_t, pid_t, FILE};\n@@ -130,7 +130,7 @@ fn setenv(n: str, v: str) {\n }\n \n mod global_env {\n-    #[doc = \"Internal module for serializing access to getenv/setenv\"];\n+    //! Internal module for serializing access to getenv/setenv\n \n     export getenv;\n     export setenv;\n@@ -418,19 +418,19 @@ fn self_exe_path() -> option<path> {\n }\n \n \n-#[doc = \"\n-Returns the path to the user's home directory, if known.\n-\n-On Unix, returns the value of the 'HOME' environment variable if it is set and\n-not equal to the empty string.\n-\n-On Windows, returns the value of the 'HOME' environment variable if it is set\n-and not equal to the empty string. Otherwise, returns the value of the\n-'USERPROFILE' environment variable if it is set and not equal to the empty\n-string.\n-\n-Otherwise, homedir returns option::none.\n-\"]\n+/**\n+ * Returns the path to the user's home directory, if known.\n+ *\n+ * On Unix, returns the value of the 'HOME' environment variable if it is set\n+ * and not equal to the empty string.\n+ *\n+ * On Windows, returns the value of the 'HOME' environment variable if it is\n+ * set and not equal to the empty string. Otherwise, returns the value of the\n+ * 'USERPROFILE' environment variable if it is set and not equal to the empty\n+ * string.\n+ *\n+ * Otherwise, homedir returns option::none.\n+ */\n fn homedir() -> option<path> {\n     ret alt getenv(\"HOME\") {\n         some(p) {\n@@ -462,7 +462,7 @@ fn homedir() -> option<path> {\n     }\n }\n \n-#[doc = \"Recursively walk a directory structure\"]\n+/// Recursively walk a directory structure\n fn walk_dir(p: path, f: fn(path) -> bool) {\n \n     walk_dir_(p, f);\n@@ -491,14 +491,14 @@ fn walk_dir(p: path, f: fn(path) -> bool) {\n     }\n }\n \n-#[doc = \"Indicates whether a path represents a directory\"]\n+/// Indicates whether a path represents a directory\n fn path_is_dir(p: path) -> bool {\n     do str::as_c_str(p) |buf| {\n         rustrt::rust_path_is_dir(buf) != 0 as c_int\n     }\n }\n \n-#[doc = \"Indicates whether a path exists\"]\n+/// Indicates whether a path exists\n fn path_exists(p: path) -> bool {\n     do str::as_c_str(p) |buf| {\n         rustrt::rust_path_exists(buf) != 0 as c_int\n@@ -507,13 +507,13 @@ fn path_exists(p: path) -> bool {\n \n // FIXME (#2622): under Windows, we should prepend the current drive letter\n // to paths that start with a slash.\n-#[doc = \"\n-Convert a relative path to an absolute path\n-\n-If the given path is relative, return it prepended with the current working\n-directory. If the given path is already an absolute path, return it\n-as is.\n-\"]\n+/**\n+ * Convert a relative path to an absolute path\n+ *\n+ * If the given path is relative, return it prepended with the current working\n+ * directory. If the given path is already an absolute path, return it\n+ * as is.\n+ */\n // NB: this is here rather than in path because it is a form of environment\n // querying; what it does depends on the process working directory, not just\n // the input paths.\n@@ -526,7 +526,7 @@ fn make_absolute(p: path) -> path {\n }\n \n \n-#[doc = \"Creates a directory at the specified path\"]\n+/// Creates a directory at the specified path\n fn make_dir(p: path, mode: c_int) -> bool {\n     ret mkdir(p, mode);\n \n@@ -551,7 +551,7 @@ fn make_dir(p: path, mode: c_int) -> bool {\n     }\n }\n \n-#[doc = \"Lists the contents of a directory\"]\n+/// Lists the contents of a directory\n fn list_dir(p: path) -> ~[str] {\n \n     #[cfg(unix)]\n@@ -573,11 +573,11 @@ fn list_dir(p: path) -> ~[str] {\n     }\n }\n \n-#[doc = \"\n-Lists the contents of a directory\n-\n-This version prepends each entry with the directory.\n-\"]\n+/**\n+ * Lists the contents of a directory\n+ *\n+ * This version prepends each entry with the directory.\n+ */\n fn list_dir_path(p: path) -> ~[str] {\n     let mut p = p;\n     let pl = str::len(p);\n@@ -588,7 +588,7 @@ fn list_dir_path(p: path) -> ~[str] {\n     os::list_dir(p).map(|f| p + f)\n }\n \n-#[doc = \"Removes a directory at the specified path\"]\n+/// Removes a directory at the specified path\n fn remove_dir(p: path) -> bool {\n    ret rmdir(p);\n \n@@ -633,7 +633,7 @@ fn change_dir(p: path) -> bool {\n     }\n }\n \n-#[doc = \"Copies a file from one location to another\"]\n+/// Copies a file from one location to another\n fn copy_file(from: path, to: path) -> bool {\n     ret do_copy_file(from, to);\n \n@@ -696,7 +696,7 @@ fn copy_file(from: path, to: path) -> bool {\n     }\n }\n \n-#[doc = \"Deletes an existing file\"]\n+/// Deletes an existing file\n fn remove_file(p: path) -> bool {\n     ret unlink(p);\n \n@@ -720,19 +720,19 @@ fn remove_file(p: path) -> bool {\n     }\n }\n \n-#[doc = \"Get a string representing the platform-dependent last error\"]\n+/// Get a string representing the platform-dependent last error\n fn last_os_error() -> str {\n     rustrt::last_os_error()\n }\n \n-#[doc = \"\n-Sets the process exit code\n-\n-Sets the exit code returned by the process if all supervised tasks terminate\n-successfully (without failing). If the current root task fails and is\n-supervised by the scheduler then any user-specified exit status is ignored and\n-the process exits with the default failure status\n-\"]\n+/**\n+ * Sets the process exit code\n+ *\n+ * Sets the exit code returned by the process if all supervised tasks\n+ * terminate successfully (without failing). If the current root task fails\n+ * and is supervised by the scheduler then any user-specified exit status is\n+ * ignored and the process exits with the default failure status\n+ */\n fn set_exit_status(code: int) {\n     rustrt::rust_set_exit_status(code as libc::intptr_t);\n }"}, {"sha": "67f42002557203de8a594822d5090e2ac79633b2", "filename": "src/libcore/path.rs", "status": "modified", "additions": 78, "deletions": 79, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Path data type and helper functions\"];\n+//! Path data type and helper functions\n \n export path;\n export consts;\n@@ -13,22 +13,22 @@ export splitext;\n export normalize;\n \n // FIXME: This type should probably be constrained (#2624)\n-#[doc = \"A path or fragment of a filesystem path\"]\n+/// A path or fragment of a filesystem path\n type path = str;\n \n #[cfg(unix)]\n mod consts {\n-    #[doc = \"\n-    The primary path separator character for the platform\n-\n-    On all platforms it is '/'\n-    \"]\n+    /**\n+     * The primary path separator character for the platform\n+     *\n+     * On all platforms it is '/'\n+     */\n     const path_sep: char = '/';\n-    #[doc = \"\n-    The secondary path separator character for the platform\n-\n-    On Unixes it is '/'. On Windows it is '\\\\'.\n-    \"]\n+    /**\n+     * The secondary path separator character for the platform\n+     *\n+     * On Unixes it is '/'. On Windows it is '\\'.\n+     */\n     const alt_path_sep: char = '/';\n }\n \n@@ -38,12 +38,12 @@ mod consts {\n     const alt_path_sep: char = '\\\\';\n }\n \n-#[doc = \"\n-Indicates whether a path is absolute.\n-\n-A path is considered absolute if it begins at the filesystem root (\\\"/\\\") or,\n-on Windows, begins with a drive letter.\n-\"]\n+/**\n+ * Indicates whether a path is absolute.\n+ *\n+ * A path is considered absolute if it begins at the filesystem root (\"/\") or,\n+ * on Windows, begins with a drive letter.\n+ */\n #[cfg(unix)]\n fn path_is_absolute(p: path) -> bool {\n     str::char_at(p, 0u) == '/'\n@@ -57,7 +57,7 @@ fn path_is_absolute(p: str) -> bool {\n             || str::char_at(p, 2u) == consts::alt_path_sep);\n }\n \n-#[doc = \"Get the default path separator for the host platform\"]\n+/// Get the default path separator for the host platform\n fn path_sep() -> str { ret str::from_char(consts::path_sep); }\n \n fn split_dirname_basename (pp: path) -> {dirname: str, basename: str} {\n@@ -72,39 +72,39 @@ fn split_dirname_basename (pp: path) -> {dirname: str, basename: str} {\n     }\n }\n \n-#[doc = \"\n-Get the directory portion of a path\n-\n-Returns all of the path up to, but excluding, the final path separator.\n-The dirname of \\\"/usr/share\\\" will be \\\"/usr\\\", but the dirname of\n-\\\"/usr/share/\\\" is \\\"/usr/share\\\".\n-\n-If the path is not prefixed with a directory, then \\\".\\\" is returned.\n-\"]\n+/**\n+ * Get the directory portion of a path\n+ *\n+ * Returns all of the path up to, but excluding, the final path separator.\n+ * The dirname of \"/usr/share\" will be \"/usr\", but the dirname of\n+ * \"/usr/share/\" is \"/usr/share\".\n+ *\n+ * If the path is not prefixed with a directory, then \".\" is returned.\n+ */\n fn dirname(pp: path) -> path {\n     ret split_dirname_basename(pp).dirname;\n }\n \n-#[doc = \"\n-Get the file name portion of a path\n-\n-Returns the portion of the path after the final path separator.\n-The basename of \\\"/usr/share\\\" will be \\\"share\\\". If there are no\n-path separators in the path then the returned path is identical to\n-the provided path. If an empty path is provided or the path ends\n-with a path separator then an empty path is returned.\n-\"]\n+/**\n+ * Get the file name portion of a path\n+ *\n+ * Returns the portion of the path after the final path separator.\n+ * The basename of \"/usr/share\" will be \"share\". If there are no\n+ * path separators in the path then the returned path is identical to\n+ * the provided path. If an empty path is provided or the path ends\n+ * with a path separator then an empty path is returned.\n+ */\n fn basename(pp: path) -> path {\n     ret split_dirname_basename(pp).basename;\n }\n \n-#[doc = \"\n-Connects to path segments\n-\n-Given paths `pre` and `post, removes any trailing path separator on `pre` and\n-any leading path separator on `post`, and returns the concatenation of the two\n-with a single path separator between them.\n-\"]\n+/**\n+ * Connects to path segments\n+ *\n+ * Given paths `pre` and `post, removes any trailing path separator on `pre`\n+ * and any leading path separator on `post`, and returns the concatenation of\n+ * the two with a single path separator between them.\n+ */\n fn connect(pre: path, post: path) -> path {\n     let mut pre_ = pre;\n     let mut post_ = post;\n@@ -122,11 +122,11 @@ fn connect(pre: path, post: path) -> path {\n     ret pre_ + path_sep() + post_;\n }\n \n-#[doc = \"\n-Connects a vector of path segments into a single path.\n-\n-Inserts path separators as needed.\n-\"]\n+/**\n+ * Connects a vector of path segments into a single path.\n+ *\n+ * Inserts path separators as needed.\n+ */\n fn connect_many(paths: ~[path]) -> path {\n     ret if vec::len(paths) == 1u {\n         paths[0]\n@@ -136,29 +136,29 @@ fn connect_many(paths: ~[path]) -> path {\n     }\n }\n \n-#[doc = \"\n-Split a path into its individual components\n-\n-Splits a given path by path separators and returns a vector containing\n-each piece of the path. On Windows, if the path is absolute then\n-the first element of the returned vector will be the drive letter\n-followed by a colon.\n-\"]\n+/**\n+ * Split a path into its individual components\n+ *\n+ * Splits a given path by path separators and returns a vector containing\n+ * each piece of the path. On Windows, if the path is absolute then\n+ * the first element of the returned vector will be the drive letter\n+ * followed by a colon.\n+ */\n fn split(p: path) -> ~[path] {\n     str::split_nonempty(p, |c| {\n         c == consts::path_sep || c == consts::alt_path_sep\n     })\n }\n \n-#[doc = \"\n-Split a path into the part before the extension and the extension\n-\n-Split a path into a pair of strings with the first element being the filename\n-without the extension and the second being either empty or the file extension\n-including the period. Leading periods in the basename are ignored.  If the\n-path includes directory components then they are included in the filename part\n-of the result pair.\n-\"]\n+/**\n+ * Split a path into the part before the extension and the extension\n+ *\n+ * Split a path into a pair of strings with the first element being the\n+ * filename without the extension and the second being either empty or the\n+ * file extension including the period. Leading periods in the basename are\n+ * ignored.  If the path includes directory components then they are included\n+ * in the filename part of the result pair.\n+ */\n fn splitext(p: path) -> (str, str) {\n     if str::is_empty(p) { (\"\", \"\") }\n     else {\n@@ -200,19 +200,18 @@ fn splitext(p: path) -> (str, str) {\n     }\n }\n \n-#[doc = \"\n-Collapses redundant path separators.\n-\n-Does not follow symbolic links.\n-\n-# Examples\n-\n-* '/a/../b' becomes '/b'\n-* 'a/./b/' becomes 'a/b/'\n-* 'a/b/../../../' becomes '..'\n-* '/a/b/c/../d/./../../e/' becomes '/a/e/'\n-\n-\"]\n+/**\n+ * Collapses redundant path separators.\n+ *\n+ * Does not follow symbolic links.\n+ *\n+ * # Examples\n+ *\n+ * * '/a/../b' becomes '/b'\n+ * * 'a/./b/' becomes 'a/b/'\n+ * * 'a/b/../../../' becomes '..'\n+ * * '/a/b/c/../d/./../../e/' becomes '/a/e/'\n+ */\n fn normalize(p: path) -> path {\n     let s = split(p);\n     let s = strip_dots(s);"}, {"sha": "adda674de322ac899aafed694aa1a584f262c270", "filename": "src/libcore/priv.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fpriv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fpriv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpriv.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -16,11 +16,11 @@ extern mod rustrt {\n \n type global_ptr = *libc::uintptr_t;\n \n-#[doc = \"\n-Atomically gets a channel from a pointer to a pointer-sized memory location\n-or, if no channel exists creates and installs a new channel and sets up a new\n-task to receive from it.\n-\"]\n+/**\n+ * Atomically gets a channel from a pointer to a pointer-sized memory location\n+ * or, if no channel exists creates and installs a new channel and sets up a\n+ * new task to receive from it.\n+ */\n unsafe fn chan_from_global_ptr<T: send>(\n     global: global_ptr,\n     builder: fn() -> task::builder,\n@@ -161,25 +161,25 @@ fn test_from_global_chan2() {\n     }\n }\n \n-#[doc = \"\n-Convert the current task to a 'weak' task temporarily\n-\n-As a weak task it will not be counted towards the runtime's set\n-of live tasks. When there are no more outstanding live (non-weak) tasks\n-the runtime will send an exit message on the provided channel.\n-\n-This function is super-unsafe. Do not use.\n-\n-# Safety notes\n-\n-* Weak tasks must either die on their own or exit upon receipt of\n-  the exit message. Failure to do so will cause the runtime to never\n-  exit\n-* Tasks must not call `weaken_task` multiple times. This will\n-  break the kernel's accounting of live tasks.\n-* Weak tasks must not be supervised. A supervised task keeps\n-  a reference to its parent, so the parent will not die.\n-\"]\n+/**\n+ * Convert the current task to a 'weak' task temporarily\n+ *\n+ * As a weak task it will not be counted towards the runtime's set\n+ * of live tasks. When there are no more outstanding live (non-weak) tasks\n+ * the runtime will send an exit message on the provided channel.\n+ *\n+ * This function is super-unsafe. Do not use.\n+ *\n+ * # Safety notes\n+ *\n+ * * Weak tasks must either die on their own or exit upon receipt of\n+ *   the exit message. Failure to do so will cause the runtime to never\n+ *   exit\n+ * * Tasks must not call `weaken_task` multiple times. This will\n+ *   break the kernel's accounting of live tasks.\n+ * * Weak tasks must not be supervised. A supervised task keeps\n+ *   a reference to its parent, so the parent will not die.\n+ */\n unsafe fn weaken_task(f: fn(comm::port<()>)) {\n     let po = comm::port();\n     let ch = comm::chan(po);"}, {"sha": "704c0fcaf4b71d4687addefc4fe02bc12512c5b2", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Unsafe pointer utility functions\"];\n+//! Unsafe pointer utility functions\n \n export addr_of;\n export mut_addr_of;\n@@ -33,47 +33,47 @@ extern mod rusti {\n     fn addr_of<T>(val: T) -> *T;\n }\n \n-#[doc = \"Get an unsafe pointer to a value\"]\n+/// Get an unsafe pointer to a value\n #[inline(always)]\n pure fn addr_of<T>(val: T) -> *T { unchecked { rusti::addr_of(val) } }\n \n-#[doc = \"Get an unsafe mut pointer to a value\"]\n+/// Get an unsafe mut pointer to a value\n #[inline(always)]\n pure fn mut_addr_of<T>(val: T) -> *mut T {\n     unsafe {\n         unsafe::reinterpret_cast(rusti::addr_of(val))\n     }\n }\n \n-#[doc = \"Calculate the offset from a pointer\"]\n+/// Calculate the offset from a pointer\n #[inline(always)]\n fn offset<T>(ptr: *T, count: uint) -> *T {\n     unsafe {\n         (ptr as uint + count * sys::size_of::<T>()) as *T\n     }\n }\n \n-#[doc = \"Calculate the offset from a const pointer\"]\n+/// Calculate the offset from a const pointer\n #[inline(always)]\n fn const_offset<T>(ptr: *const T, count: uint) -> *const T {\n     unsafe {\n         (ptr as uint + count * sys::size_of::<T>()) as *T\n     }\n }\n \n-#[doc = \"Calculate the offset from a mut pointer\"]\n+/// Calculate the offset from a mut pointer\n #[inline(always)]\n fn mut_offset<T>(ptr: *mut T, count: uint) -> *mut T {\n     (ptr as uint + count * sys::size_of::<T>()) as *mut T\n }\n \n-#[doc = \"Return the offset of the first null pointer in `buf`.\"]\n+/// Return the offset of the first null pointer in `buf`.\n #[inline(always)]\n unsafe fn buf_len<T>(buf: **T) -> uint {\n     position(buf, |i| i == null())\n }\n \n-#[doc = \"Return the first offset `i` such that `f(buf[i]) == true`.\"]\n+/// Return the first offset `i` such that `f(buf[i]) == true`.\n #[inline(always)]\n unsafe fn position<T>(buf: *T, f: fn(T) -> bool) -> uint {\n     let mut i = 0u;\n@@ -83,34 +83,34 @@ unsafe fn position<T>(buf: *T, f: fn(T) -> bool) -> uint {\n     }\n }\n \n-#[doc = \"Create an unsafe null pointer\"]\n+/// Create an unsafe null pointer\n #[inline(always)]\n pure fn null<T>() -> *T { unsafe { unsafe::reinterpret_cast(0u) } }\n \n-#[doc = \"Returns true if the pointer is equal to the null pointer.\"]\n+/// Returns true if the pointer is equal to the null pointer.\n pure fn is_null<T>(ptr: *const T) -> bool { ptr == null() }\n \n-#[doc = \"Returns true if the pointer is not equal to the null pointer.\"]\n+/// Returns true if the pointer is not equal to the null pointer.\n pure fn is_not_null<T>(ptr: *const T) -> bool { !is_null(ptr) }\n \n-#[doc = \"\n-Copies data from one location to another\n-\n-Copies `count` elements (not bytes) from `src` to `dst`. The source\n-and destination may not overlap.\n-\"]\n+/**\n+ * Copies data from one location to another\n+ *\n+ * Copies `count` elements (not bytes) from `src` to `dst`. The source\n+ * and destination may not overlap.\n+ */\n #[inline(always)]\n unsafe fn memcpy<T>(dst: *T, src: *T, count: uint) {\n     let n = count * sys::size_of::<T>();\n     libc_::memcpy(dst as *c_void, src as *c_void, n as size_t);\n }\n \n-#[doc = \"\n-Copies data from one location to another\n-\n-Copies `count` elements (not bytes) from `src` to `dst`. The source\n-and destination may overlap.\n-\"]\n+/**\n+ * Copies data from one location to another\n+ *\n+ * Copies `count` elements (not bytes) from `src` to `dst`. The source\n+ * and destination may overlap.\n+ */\n #[inline(always)]\n unsafe fn memmove<T>(dst: *T, src: *T, count: uint)  {\n     let n = count * sys::size_of::<T>();\n@@ -123,12 +123,12 @@ unsafe fn memset<T>(dst: *mut T, c: int, count: uint)  {\n     libc_::memset(dst as *c_void, c as libc::c_int, n as size_t);\n }\n \n-#[doc = \"Extension methods for pointers\"]\n+/// Extension methods for pointers\n impl extensions<T> for *T {\n-    #[doc = \"Returns true if the pointer is equal to the null pointer.\"]\n+    /// Returns true if the pointer is equal to the null pointer.\n     pure fn is_null() -> bool { is_null(self) }\n \n-    #[doc = \"Returns true if the pointer is not equal to the null pointer.\"]\n+    /// Returns true if the pointer is not equal to the null pointer.\n     pure fn is_not_null() -> bool { is_not_null(self) }\n }\n "}, {"sha": "4db2cdb086d5ee29d818b560facaf42b6cf649d9", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 60, "deletions": 46, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Random number generation\"];\n+//! Random number generation\n \n export rng, seed, seeded_rng, weighted, extensions;\n export xorshift, seeded_xorshift;\n@@ -14,93 +14,97 @@ extern mod rustrt {\n     fn rand_free(c: *rctx);\n }\n \n-#[doc = \"A random number generator\"]\n+/// A random number generator\n iface rng {\n-    #[doc = \"Return the next random integer\"]\n+    /// Return the next random integer\n     fn next() -> u32;\n }\n \n-#[doc = \"A value with a particular weight compared to other values\"]\n+/// A value with a particular weight compared to other values\n type weighted<T> = { weight: uint, item: T };\n \n-#[doc = \"Extension methods for random number generators\"]\n+/// Extension methods for random number generators\n impl extensions for rng {\n \n-    #[doc = \"Return a random int\"]\n+    /// Return a random int\n     fn gen_int() -> int {\n         self.gen_i64() as int\n     }\n \n-    #[doc = \"Return an int randomly chosen from the range [start, end), \\\n-             failing if start >= end\"]\n+    /**\n+     * Return an int randomly chosen from the range [start, end),\n+     * failing if start >= end\n+     */\n     fn gen_int_range(start: int, end: int) -> int {\n         assert start < end;\n         start + int::abs(self.gen_int() % (end - start))\n     }\n \n-    #[doc = \"Return a random i8\"]\n+    /// Return a random i8\n     fn gen_i8() -> i8 {\n         self.next() as i8\n     }\n \n-    #[doc = \"Return a random i16\"]\n+    /// Return a random i16\n     fn gen_i16() -> i16 {\n         self.next() as i16\n     }\n \n-    #[doc = \"Return a random i32\"]\n+    /// Return a random i32\n     fn gen_i32() -> i32 {\n         self.next() as i32\n     }\n \n-    #[doc = \"Return a random i64\"]\n+    /// Return a random i64\n     fn gen_i64() -> i64 {\n         (self.next() as i64 << 32) | self.next() as i64\n     }\n \n-    #[doc = \"Return a random uint\"]\n+    /// Return a random uint\n     fn gen_uint() -> uint {\n         self.gen_u64() as uint\n     }\n \n-    #[doc = \"Return a uint randomly chosen from the range [start, end), \\\n-             failing if start >= end\"]\n+    /**\n+     * Return a uint randomly chosen from the range [start, end),\n+     * failing if start >= end\n+     */\n     fn gen_uint_range(start: uint, end: uint) -> uint {\n         assert start < end;\n         start + (self.gen_uint() % (end - start))\n     }\n \n-    #[doc = \"Return a random u8\"]\n+    /// Return a random u8\n     fn gen_u8() -> u8 {\n         self.next() as u8\n     }\n \n-    #[doc = \"Return a random u16\"]\n+    /// Return a random u16\n     fn gen_u16() -> u16 {\n         self.next() as u16\n     }\n \n-    #[doc = \"Return a random u32\"]\n+    /// Return a random u32\n     fn gen_u32() -> u32 {\n         self.next()\n     }\n \n-    #[doc = \"Return a random u64\"]\n+    /// Return a random u64\n     fn gen_u64() -> u64 {\n         (self.next() as u64 << 32) | self.next() as u64\n     }\n \n-    #[doc = \"Return a random float\"]\n+    /// Return a random float\n     fn gen_float() -> float {\n         self.gen_f64() as float\n     }\n \n-    #[doc = \"Return a random f32\"]\n+    /// Return a random f32\n     fn gen_f32() -> f32 {\n         self.gen_f64() as f32\n     }\n \n-    #[doc = \"Return a random f64\"]\n+    /// Return a random f64\n     fn gen_f64() -> f64 {\n         let u1 = self.next() as f64;\n         let u2 = self.next() as f64;\n@@ -109,24 +113,25 @@ impl extensions for rng {\n         ret ((u1 / scale + u2) / scale + u3) / scale;\n     }\n \n-    #[doc = \"Return a random char\"]\n+    /// Return a random char\n     fn gen_char() -> char {\n         self.next() as char\n     }\n \n-    #[doc = \"Return a char randomly chosen from chars, failing if chars is \\\n-             empty\"]\n+    /**\n+     * Return a char randomly chosen from chars, failing if chars is empty\n+     */\n     fn gen_char_from(chars: str) -> char {\n         assert !chars.is_empty();\n         self.choose(str::chars(chars))\n     }\n \n-    #[doc = \"Return a random bool\"]\n+    /// Return a random bool\n     fn gen_bool() -> bool {\n         self.next() & 1u32 == 1u32\n     }\n \n-    #[doc = \"Return a bool with a 1 in n chance of true\"]\n+    /// Return a bool with a 1 in n chance of true\n     fn gen_weighted_bool(n: uint) -> bool {\n         if n == 0u {\n             true\n@@ -135,8 +140,9 @@ impl extensions for rng {\n         }\n     }\n \n-    #[doc = \"Return a random string of the specified length composed of A-Z, \\\n-             a-z, 0-9\"]\n+    /**\n+     * Return a random string of the specified length composed of A-Z,a-z,0-9\n+     */\n     fn gen_str(len: uint) -> str {\n         let charset = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n                       \"abcdefghijklmnopqrstuvwxyz\" +\n@@ -150,19 +156,19 @@ impl extensions for rng {\n         s\n     }\n \n-    #[doc = \"Return a random byte string of the specified length\"]\n+    /// Return a random byte string of the specified length\n     fn gen_bytes(len: uint) -> ~[u8] {\n         do vec::from_fn(len) |_i| {\n             self.gen_u8()\n         }\n     }\n \n-    #[doc = \"Choose an item randomly, failing if values is empty\"]\n+    /// Choose an item randomly, failing if values is empty\n     fn choose<T:copy>(values: ~[T]) -> T {\n         self.choose_option(values).get()\n     }\n \n-    #[doc = \"Choose some(item) randomly, returning none if values is empty\"]\n+    /// Choose some(item) randomly, returning none if values is empty\n     fn choose_option<T:copy>(values: ~[T]) -> option<T> {\n         if values.is_empty() {\n             none\n@@ -171,14 +177,18 @@ impl extensions for rng {\n         }\n     }\n \n-    #[doc = \"Choose an item respecting the relative weights, failing if \\\n-             the sum of the weights is 0\"]\n+    /**\n+     * Choose an item respecting the relative weights, failing if the sum of\n+     * the weights is 0\n+     */\n     fn choose_weighted<T: copy>(v : ~[weighted<T>]) -> T {\n         self.choose_weighted_option(v).get()\n     }\n \n-    #[doc = \"Choose some(item) respecting the relative weights, returning \\\n-             none if the sum of the weights is 0\"]\n+    /**\n+     * Choose some(item) respecting the relative weights, returning none if\n+     * the sum of the weights is 0\n+     */\n     fn choose_weighted_option<T:copy>(v: ~[weighted<T>]) -> option<T> {\n         let mut total = 0u;\n         for v.each |item| {\n@@ -198,8 +208,10 @@ impl extensions for rng {\n         unreachable();\n     }\n \n-    #[doc = \"Return a vec containing copies of the items, in order, where \\\n-             the weight of the item determines how many copies there are\"]\n+    /**\n+     * Return a vec containing copies of the items, in order, where\n+     * the weight of the item determines how many copies there are\n+     */\n     fn weighted_vec<T:copy>(v: ~[weighted<T>]) -> ~[T] {\n         let mut r = ~[];\n         for v.each |item| {\n@@ -210,14 +222,14 @@ impl extensions for rng {\n         r\n     }\n \n-    #[doc = \"Shuffle a vec\"]\n+    /// Shuffle a vec\n     fn shuffle<T:copy>(values: ~[T]) -> ~[T] {\n         let mut m = vec::to_mut(values);\n         self.shuffle_mut(m);\n         ret vec::from_mut(m);\n     }\n \n-    #[doc = \"Shuffle a mutable vec in place\"]\n+    /// Shuffle a mutable vec in place\n     fn shuffle_mut<T>(&&values: ~[mut T]) {\n         let mut i = values.len();\n         while i >= 2u {\n@@ -240,20 +252,22 @@ impl of rng for @rand_res {\n     fn next() -> u32 { ret rustrt::rand_next((*self).c); }\n }\n \n-#[doc = \"Create a new random seed for seeded_rng\"]\n+/// Create a new random seed for seeded_rng\n fn seed() -> ~[u8] {\n     rustrt::rand_seed()\n }\n \n-#[doc = \"Create a random number generator with a system specified seed\"]\n+/// Create a random number generator with a system specified seed\n fn rng() -> rng {\n     @rand_res(rustrt::rand_new()) as rng\n }\n \n-#[doc = \"Create a random number generator using the specified seed. A \\\n-         generator constructed with a given seed will generate the same \\\n-         sequence of values as all other generators constructed with the \\\n-         same seed. The seed may be any length.\"]\n+/**\n+ * Create a random number generator using the specified seed. A generator\n+ * constructed with a given seed will generate the same sequence of values as\n+ * all other generators constructed with the same seed. The seed may be any\n+ * length.\n+ */\n fn seeded_rng(seed: ~[u8]) -> rng {\n     @rand_res(rustrt::rand_new_seeded(seed)) as rng\n }"}, {"sha": "677d19e096444fae2c69f5d0a95398ef9756ed88", "filename": "src/libcore/result.rs", "status": "modified", "additions": 124, "deletions": 122, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,22 +1,22 @@\n-#[doc = \"A type representing either success or failure\"];\n+//! A type representing either success or failure\n \n import either::either;\n \n-#[doc = \"The result type\"]\n+/// The result type\n enum result<T, U> {\n-    #[doc = \"Contains the successful result value\"]\n+    /// Contains the successful result value\n     ok(T),\n-    #[doc = \"Contains the error value\"]\n+    /// Contains the error value\n     err(U)\n }\n \n-#[doc = \"\n-Get the value out of a successful result\n-\n-# Failure\n-\n-If the result is an error\n-\"]\n+/**\n+ * Get the value out of a successful result\n+ *\n+ * # Failure\n+ *\n+ * If the result is an error\n+ */\n pure fn get<T: copy, U>(res: result<T, U>) -> T {\n     alt res {\n       ok(t) { t }\n@@ -26,13 +26,13 @@ pure fn get<T: copy, U>(res: result<T, U>) -> T {\n     }\n }\n \n-#[doc = \"\n-Get the value out of an error result\n-\n-# Failure\n-\n-If the result is not an error\n-\"]\n+/**\n+ * Get the value out of an error result\n+ *\n+ * # Failure\n+ *\n+ * If the result is not an error\n+ */\n pure fn get_err<T, U: copy>(res: result<T, U>) -> U {\n     alt res {\n       err(u) { u }\n@@ -42,45 +42,46 @@ pure fn get_err<T, U: copy>(res: result<T, U>) -> U {\n     }\n }\n \n-#[doc = \"Returns true if the result is `ok`\"]\n+/// Returns true if the result is `ok`\n pure fn is_ok<T, U>(res: result<T, U>) -> bool {\n     alt res {\n       ok(_) { true }\n       err(_) { false }\n     }\n }\n \n-#[doc = \"Returns true if the result is `err`\"]\n+/// Returns true if the result is `err`\n pure fn is_err<T, U>(res: result<T, U>) -> bool {\n     !is_ok(res)\n }\n \n-#[doc = \"\n-Convert to the `either` type\n-\n-`ok` result variants are converted to `either::right` variants, `err`\n-result variants are converted to `either::left`.\n-\"]\n+/**\n+ * Convert to the `either` type\n+ *\n+ * `ok` result variants are converted to `either::right` variants, `err`\n+ * result variants are converted to `either::left`.\n+ */\n pure fn to_either<T: copy, U: copy>(res: result<U, T>) -> either<T, U> {\n     alt res {\n       ok(res) { either::right(res) }\n       err(fail_) { either::left(fail_) }\n     }\n }\n \n-#[doc = \"\n-Call a function based on a previous result\n-\n-If `res` is `ok` then the value is extracted and passed to `op` whereupon\n-`op`s result is returned. if `res` is `err` then it is immediately returned.\n-This function can be used to compose the results of two functions.\n-\n-Example:\n-\n-    let res = chain(read_file(file)) { |buf|\n-        ok(parse_buf(buf))\n-    }\n-\"]\n+/**\n+ * Call a function based on a previous result\n+ *\n+ * If `res` is `ok` then the value is extracted and passed to `op` whereupon\n+ * `op`s result is returned. if `res` is `err` then it is immediately\n+ * returned. This function can be used to compose the results of two\n+ * functions.\n+ *\n+ * Example:\n+ *\n+ *     let res = chain(read_file(file)) { |buf|\n+ *         ok(parse_buf(buf))\n+ *     }\n+ */\n fn chain<T, U: copy, V: copy>(res: result<T, V>, op: fn(T) -> result<U, V>)\n     -> result<U, V> {\n     alt res {\n@@ -89,14 +90,14 @@ fn chain<T, U: copy, V: copy>(res: result<T, V>, op: fn(T) -> result<U, V>)\n     }\n }\n \n-#[doc = \"\n-Call a function based on a previous result\n-\n-If `res` is `err` then the value is extracted and passed to `op`\n-whereupon `op`s result is returned. if `res` is `ok` then it is\n-immediately returned.  This function can be used to pass through a\n-successful result while handling an error.\n-\"]\n+/**\n+ * Call a function based on a previous result\n+ *\n+ * If `res` is `err` then the value is extracted and passed to `op`\n+ * whereupon `op`s result is returned. if `res` is `ok` then it is\n+ * immediately returned.  This function can be used to pass through a\n+ * successful result while handling an error.\n+ */\n fn chain_err<T: copy, U: copy, V: copy>(\n     res: result<T, V>,\n     op: fn(V) -> result<T, U>)\n@@ -107,55 +108,56 @@ fn chain_err<T: copy, U: copy, V: copy>(\n     }\n }\n \n-#[doc = \"\n-Call a function based on a previous result\n-\n-If `res` is `ok` then the value is extracted and passed to `op` whereupon\n-`op`s result is returned. if `res` is `err` then it is immediately returned.\n-This function can be used to compose the results of two functions.\n-\n-Example:\n-\n-    iter(read_file(file)) { |buf|\n-        print_buf(buf)\n-    }\n-\"]\n+/**\n+ * Call a function based on a previous result\n+ *\n+ * If `res` is `ok` then the value is extracted and passed to `op` whereupon\n+ * `op`s result is returned. if `res` is `err` then it is immediately\n+ * returned. This function can be used to compose the results of two\n+ * functions.\n+ *\n+ * Example:\n+ *\n+ *     iter(read_file(file)) { |buf|\n+ *         print_buf(buf)\n+ *     }\n+ */\n fn iter<T, E>(res: result<T, E>, f: fn(T)) {\n     alt res {\n       ok(t) { f(t) }\n       err(_) { }\n     }\n }\n \n-#[doc = \"\n-Call a function based on a previous result\n-\n-If `res` is `err` then the value is extracted and passed to `op` whereupon\n-`op`s result is returned. if `res` is `ok` then it is immediately returned.\n-This function can be used to pass through a successful result while handling\n-an error.\n-\"]\n+/**\n+ * Call a function based on a previous result\n+ *\n+ * If `res` is `err` then the value is extracted and passed to `op` whereupon\n+ * `op`s result is returned. if `res` is `ok` then it is immediately returned.\n+ * This function can be used to pass through a successful result while\n+ * handling an error.\n+ */\n fn iter_err<T, E>(res: result<T, E>, f: fn(E)) {\n     alt res {\n       ok(_) { }\n       err(e) { f(e) }\n     }\n }\n \n-#[doc = \"\n-Call a function based on a previous result\n-\n-If `res` is `ok` then the value is extracted and passed to `op` whereupon\n-`op`s result is wrapped in `ok` and returned. if `res` is `err` then it is\n-immediately returned.  This function can be used to compose the results of two\n-functions.\n-\n-Example:\n-\n-    let res = map(read_file(file)) { |buf|\n-        parse_buf(buf)\n-    }\n-\"]\n+/**\n+ * Call a function based on a previous result\n+ *\n+ * If `res` is `ok` then the value is extracted and passed to `op` whereupon\n+ * `op`s result is wrapped in `ok` and returned. if `res` is `err` then it is\n+ * immediately returned.  This function can be used to compose the results of\n+ * two functions.\n+ *\n+ * Example:\n+ *\n+ *     let res = map(read_file(file)) { |buf|\n+ *         parse_buf(buf)\n+ *     }\n+ */\n fn map<T, E: copy, U: copy>(res: result<T, E>, op: fn(T) -> U)\n   -> result<U, E> {\n     alt res {\n@@ -164,14 +166,14 @@ fn map<T, E: copy, U: copy>(res: result<T, E>, op: fn(T) -> U)\n     }\n }\n \n-#[doc = \"\n-Call a function based on a previous result\n-\n-If `res` is `err` then the value is extracted and passed to `op` whereupon\n-`op`s result is wrapped in an `err` and returned. if `res` is `ok` then it is\n-immediately returned.  This function can be used to pass through a successful\n-result while handling an error.\n-\"]\n+/**\n+ * Call a function based on a previous result\n+ *\n+ * If `res` is `err` then the value is extracted and passed to `op` whereupon\n+ * `op`s result is wrapped in an `err` and returned. if `res` is `ok` then it\n+ * is immediately returned.  This function can be used to pass through a\n+ * successful result while handling an error.\n+ */\n fn map_err<T: copy, E, F: copy>(res: result<T, E>, op: fn(E) -> F)\n   -> result<T, F> {\n     alt res {\n@@ -232,23 +234,23 @@ impl extensions<T:copy, E:copy> for result<T,E> {\n     }\n }\n \n-#[doc = \"\n-Maps each element in the vector `ts` using the operation `op`.  Should an\n-error occur, no further mappings are performed and the error is returned.\n-Should no error occur, a vector containing the result of each map is\n-returned.\n-\n-Here is an example which increments every integer in a vector,\n-checking for overflow:\n-\n-    fn inc_conditionally(x: uint) -> result<uint,str> {\n-        if x == uint::max_value { ret err(\\\"overflow\\\"); }\n-        else { ret ok(x+1u); }\n-    }\n-    map([1u, 2u, 3u]/~, inc_conditionally).chain {|incd|\n-        assert incd == [2u, 3u, 4u]/~;\n-    }\n-\"]\n+/**\n+ * Maps each element in the vector `ts` using the operation `op`.  Should an\n+ * error occur, no further mappings are performed and the error is returned.\n+ * Should no error occur, a vector containing the result of each map is\n+ * returned.\n+ *\n+ * Here is an example which increments every integer in a vector,\n+ * checking for overflow:\n+ *\n+ *     fn inc_conditionally(x: uint) -> result<uint,str> {\n+ *         if x == uint::max_value { ret err(\"overflow\"); }\n+ *         else { ret ok(x+1u); }\n+ *     }\n+ *     map([1u, 2u, 3u]/~, inc_conditionally).chain {|incd|\n+ *         assert incd == [2u, 3u, 4u]/~;\n+ *     }\n+ */\n fn map_vec<T,U:copy,V:copy>(\n     ts: ~[T], op: fn(T) -> result<V,U>) -> result<~[V],U> {\n \n@@ -277,13 +279,15 @@ fn map_opt<T,U:copy,V:copy>(\n     }\n }\n \n-#[doc = \"Same as map, but it operates over two parallel vectors.\n-\n-A precondition is used here to ensure that the vectors are the same\n-length.  While we do not often use preconditions in the standard\n-library, a precondition is used here because result::t is generally\n-used in 'careful' code contexts where it is both appropriate and easy\n-to accommodate an error like the vectors being of different lengths.\"]\n+/**\n+ * Same as map, but it operates over two parallel vectors.\n+ *\n+ * A precondition is used here to ensure that the vectors are the same\n+ * length.  While we do not often use preconditions in the standard\n+ * library, a precondition is used here because result::t is generally\n+ * used in 'careful' code contexts where it is both appropriate and easy\n+ * to accommodate an error like the vectors being of different lengths.\n+ */\n fn map_vec2<S,T,U:copy,V:copy>(ss: ~[S], ts: ~[T],\n                                op: fn(S,T) -> result<V,U>)\n     : vec::same_length(ss, ts) -> result<~[V],U> {\n@@ -302,11 +306,11 @@ fn map_vec2<S,T,U:copy,V:copy>(ss: ~[S], ts: ~[T],\n     ret ok(vs);\n }\n \n-#[doc = \"\n-Applies op to the pairwise elements from `ss` and `ts`, aborting on\n-error.  This could be implemented using `map2()` but it is more efficient\n-on its own as no result vector is built.\n-\"]\n+/**\n+ * Applies op to the pairwise elements from `ss` and `ts`, aborting on\n+ * error.  This could be implemented using `map2()` but it is more efficient\n+ * on its own as no result vector is built.\n+ */\n fn iter_vec2<S,T,U:copy>(ss: ~[S], ts: ~[T],\n                          op: fn(S,T) -> result<(),U>)\n     : vec::same_length(ss, ts)\n@@ -324,9 +328,7 @@ fn iter_vec2<S,T,U:copy>(ss: ~[S], ts: ~[T],\n     ret ok(());\n }\n \n-#[doc=\"\n-Unwraps a result, assuming it is an `ok(T)`\n-\"]\n+/// Unwraps a result, assuming it is an `ok(T)`\n fn unwrap<T, U>(-res: result<T, U>) -> T {\n     unsafe {\n         let addr = alt res {"}, {"sha": "55a58430fc04f19298d912e944c342cf171460d4", "filename": "src/libcore/run.rs", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc =\"Process spawning\"];\n+//! Process spawning\n import option::{some, none};\n import libc::{pid_t, c_void, c_int};\n \n@@ -17,51 +17,51 @@ extern mod rustrt {\n         -> pid_t;\n }\n \n-#[doc =\"A value representing a child process\"]\n+/// A value representing a child process\n iface program {\n-    #[doc =\"Returns the process id of the program\"]\n+    /// Returns the process id of the program\n     fn get_id() -> pid_t;\n \n-    #[doc =\"Returns an io::writer that can be used to write to stdin\"]\n+    /// Returns an io::writer that can be used to write to stdin\n     fn input() -> io::writer;\n \n-    #[doc =\"Returns an io::reader that can be used to read from stdout\"]\n+    /// Returns an io::reader that can be used to read from stdout\n     fn output() -> io::reader;\n \n-    #[doc =\"Returns an io::reader that can be used to read from stderr\"]\n+    /// Returns an io::reader that can be used to read from stderr\n     fn err() -> io::reader;\n \n-    #[doc = \"Closes the handle to the child processes standard input\"]\n+    /// Closes the handle to the child processes standard input\n     fn close_input();\n \n-    #[doc = \"\n-    Waits for the child process to terminate. Closes the handle\n-    to stdin if necessary.\n-    \"]\n+    /**\n+     * Waits for the child process to terminate. Closes the handle\n+     * to stdin if necessary.\n+     */\n     fn finish() -> int;\n \n-    #[doc =\"Closes open handles\"]\n+    /// Closes open handles\n     fn destroy();\n }\n \n \n-#[doc = \"\n-Run a program, providing stdin, stdout and stderr handles\n-\n-# Arguments\n-\n-* prog - The path to an executable\n-* args - Vector of arguments to pass to the child process\n-* env - optional env-modification for child\n-* dir - optional dir to run child in (default current dir)\n-* in_fd - A file descriptor for the child to use as std input\n-* out_fd - A file descriptor for the child to use as std output\n-* err_fd - A file descriptor for the child to use as std error\n-\n-# Return value\n-\n-The process id of the spawned process\n-\"]\n+/**\n+ * Run a program, providing stdin, stdout and stderr handles\n+ *\n+ * # Arguments\n+ *\n+ * * prog - The path to an executable\n+ * * args - Vector of arguments to pass to the child process\n+ * * env - optional env-modification for child\n+ * * dir - optional dir to run child in (default current dir)\n+ * * in_fd - A file descriptor for the child to use as std input\n+ * * out_fd - A file descriptor for the child to use as std output\n+ * * err_fd - A file descriptor for the child to use as std error\n+ *\n+ * # Return value\n+ *\n+ * The process id of the spawned process\n+ */\n fn spawn_process(prog: str, args: ~[str],\n                  env: option<~[(str,str)]>,\n                  dir: option<str>,\n@@ -152,41 +152,41 @@ fn with_dirp<T>(d: option<str>,\n     }\n }\n \n-#[doc =\"\n-Spawns a process and waits for it to terminate\n-\n-# Arguments\n-\n-* prog - The path to an executable\n-* args - Vector of arguments to pass to the child process\n-\n-# Return value\n-\n-The process id\n-\"]\n+/**\n+ * Spawns a process and waits for it to terminate\n+ *\n+ * # Arguments\n+ *\n+ * * prog - The path to an executable\n+ * * args - Vector of arguments to pass to the child process\n+ *\n+ * # Return value\n+ *\n+ * The process id\n+ */\n fn run_program(prog: str, args: ~[str]) -> int {\n     let pid = spawn_process(prog, args, none, none,\n                             0i32, 0i32, 0i32);\n     if pid == -1 as pid_t { fail; }\n     ret waitpid(pid);\n }\n \n-#[doc =\"\n-Spawns a process and returns a program\n-\n-The returned value is a boxed class containing a <program> object that can\n-be used for sending and receiving data over the standard file descriptors.\n-The class will ensure that file descriptors are closed properly.\n-\n-# Arguments\n-\n-* prog - The path to an executable\n-* args - Vector of arguments to pass to the child process\n-\n-# Return value\n-\n-A class with a <program> field\n-\"]\n+/**\n+ * Spawns a process and returns a program\n+ *\n+ * The returned value is a boxed class containing a <program> object that can\n+ * be used for sending and receiving data over the standard file descriptors.\n+ * The class will ensure that file descriptors are closed properly.\n+ *\n+ * # Arguments\n+ *\n+ * * prog - The path to an executable\n+ * * args - Vector of arguments to pass to the child process\n+ *\n+ * # Return value\n+ *\n+ * A class with a <program> field\n+ */\n fn start_program(prog: str, args: ~[str]) -> program {\n     let pipe_input = os::pipe();\n     let pipe_output = os::pipe();\n@@ -257,20 +257,20 @@ fn read_all(rd: io::reader) -> str {\n     ret buf;\n }\n \n-#[doc =\"\n-Spawns a process, waits for it to exit, and returns the exit code, and\n-contents of stdout and stderr.\n-\n-# Arguments\n-\n-* prog - The path to an executable\n-* args - Vector of arguments to pass to the child process\n-\n-# Return value\n-\n-A record, {status: int, out: str, err: str} containing the exit code,\n-the contents of stdout and the contents of stderr.\n-\"]\n+/**\n+ * Spawns a process, waits for it to exit, and returns the exit code, and\n+ * contents of stdout and stderr.\n+ *\n+ * # Arguments\n+ *\n+ * * prog - The path to an executable\n+ * * args - Vector of arguments to pass to the child process\n+ *\n+ * # Return value\n+ *\n+ * A record, {status: int, out: str, err: str} containing the exit code,\n+ * the contents of stdout and the contents of stderr.\n+ */\n fn program_output(prog: str, args: ~[str]) ->\n    {status: int, out: str, err: str} {\n \n@@ -347,7 +347,7 @@ fn readclose(fd: c_int) -> str {\n     ret buf;\n }\n \n-#[doc =\"Waits for a process to exit and returns the exit code\"]\n+/// Waits for a process to exit and returns the exit code\n fn waitpid(pid: pid_t) -> int {\n     ret waitpid_os(pid);\n "}, {"sha": "43a9e8f6981bf82f526182d7387e351e33416b25", "filename": "src/libcore/str.rs", "status": "modified", "additions": 745, "deletions": 766, "changes": 1511, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,11 +1,11 @@\n-#[doc = \"\n-String manipulation\n-\n-Strings are a packed UTF-8 representation of text, stored as null\n-terminated buffers of u8 bytes.  Strings should be indexed in bytes,\n-for efficiency, but UTF-8 unsafe operations should be avoided.  For\n-some heavy-duty uses, try std::rope.\n-\"];\n+/*!\n+ * String manipulation\n+ *\n+ * Strings are a packed UTF-8 representation of text, stored as null\n+ * terminated buffers of u8 bytes.  Strings should be indexed in bytes,\n+ * for efficiency, but UTF-8 unsafe operations should be avoided.  For\n+ * some heavy-duty uses, try std::rope.\n+ */\n \n import libc::size_t;\n \n@@ -115,32 +115,32 @@ extern mod rustrt {\n Section: Creating a string\n */\n \n-#[doc = \"\n-Convert a vector of bytes to a UTF-8 string\n-\n-# Failure\n-\n-Fails if invalid UTF-8\n-\"]\n+/**\n+ * Convert a vector of bytes to a UTF-8 string\n+ *\n+ * # Failure\n+ *\n+ * Fails if invalid UTF-8\n+ */\n pure fn from_bytes(+vv: ~[u8]) -> str {\n     assert is_utf8(vv);\n     ret unsafe { unsafe::from_bytes(vv) };\n }\n \n-#[doc = \"\n-Convert a byte to a UTF-8 string\n-\n-# Failure\n-\n-Fails if invalid UTF-8\n-\"]\n+/**\n+ * Convert a byte to a UTF-8 string\n+ *\n+ * # Failure\n+ *\n+ * Fails if invalid UTF-8\n+ */\n pure fn from_byte(b: u8) -> str {\n     assert b < 128u8;\n     let mut v = ~[b, 0u8];\n     unsafe { ::unsafe::transmute(v) }\n }\n \n-#[doc = \"Appends a character at the end of a string\"]\n+/// Appends a character at the end of a string\n fn push_char(&s: str, ch: char) {\n     unsafe {\n         let code = ch as uint;\n@@ -216,14 +216,14 @@ fn push_char(&s: str, ch: char) {\n     }\n }\n \n-#[doc = \"Convert a char to a string\"]\n+/// Convert a char to a string\n pure fn from_char(ch: char) -> str {\n     let mut buf = \"\";\n     unchecked { push_char(buf, ch); }\n     ret buf;\n }\n \n-#[doc = \"Convert a vector of chars to a string\"]\n+/// Convert a vector of chars to a string\n pure fn from_chars(chs: &[const char]) -> str {\n     let mut buf = \"\";\n     unchecked {\n@@ -233,16 +233,14 @@ pure fn from_chars(chs: &[const char]) -> str {\n     ret buf;\n }\n \n-#[doc = \"Concatenate a vector of strings\"]\n+/// Concatenate a vector of strings\n pure fn concat(v: &[const str]) -> str {\n     let mut s: str = \"\";\n     for vec::each(v) |ss| { s += ss; }\n     ret s;\n }\n \n-#[doc = \"\n-Concatenate a vector of strings, placing a given separator between each\n-\"]\n+/// Concatenate a vector of strings, placing a given separator between each\n pure fn connect(v: &[const str], sep: str) -> str {\n     let mut s = \"\", first = true;\n     for vec::each(v) |ss| {\n@@ -256,13 +254,13 @@ pure fn connect(v: &[const str], sep: str) -> str {\n Section: Adding to and removing from a string\n */\n \n-#[doc = \"\n-Remove the final character from a string and return it\n-\n-# Failure\n-\n-If the string does not contain any characters\n-\"]\n+/**\n+ * Remove the final character from a string and return it\n+ *\n+ * # Failure\n+ *\n+ * If the string does not contain any characters\n+ */\n fn pop_char(&s: str) -> char {\n     let end = len(s);\n     assert end > 0u;\n@@ -271,23 +269,23 @@ fn pop_char(&s: str) -> char {\n     ret ch;\n }\n \n-#[doc = \"\n-Remove the first character from a string and return it\n-\n-# Failure\n-\n-If the string does not contain any characters\n-\"]\n+/**\n+ * Remove the first character from a string and return it\n+ *\n+ * # Failure\n+ *\n+ * If the string does not contain any characters\n+ */\n fn shift_char(&s: str) -> char {\n     let {ch, next} = char_range_at(s, 0u);\n     s = unsafe { unsafe::slice_bytes(s, next, len(s)) };\n     ret ch;\n }\n \n-#[doc = \"Prepend a char to a string\"]\n+/// Prepend a char to a string\n fn unshift_char(&s: str, ch: char) { s = from_char(ch) + s; }\n \n-#[doc = \"Returns a string with leading whitespace removed\"]\n+/// Returns a string with leading whitespace removed\n pure fn trim_left(+s: str) -> str {\n     alt find(s, |c| !char::is_whitespace(c)) {\n       none { \"\" }\n@@ -298,7 +296,7 @@ pure fn trim_left(+s: str) -> str {\n     }\n }\n \n-#[doc = \"Returns a string with trailing whitespace removed\"]\n+/// Returns a string with trailing whitespace removed\n pure fn trim_right(+s: str) -> str {\n     alt rfind(s, |c| !char::is_whitespace(c)) {\n       none { \"\" }\n@@ -310,18 +308,18 @@ pure fn trim_right(+s: str) -> str {\n     }\n }\n \n-#[doc = \"Returns a string with leading and trailing whitespace removed\"]\n+/// Returns a string with leading and trailing whitespace removed\n pure fn trim(+s: str) -> str { trim_left(trim_right(s)) }\n \n /*\n Section: Transforming strings\n */\n \n-#[doc = \"\n-Converts a string to a vector of bytes\n-\n-The result vector is not null-terminated.\n-\"]\n+/**\n+ * Converts a string to a vector of bytes\n+ *\n+ * The result vector is not null-terminated.\n+ */\n pure fn bytes(s: str) -> ~[u8] {\n     unsafe {\n         let mut s_copy = s;\n@@ -331,17 +329,15 @@ pure fn bytes(s: str) -> ~[u8] {\n     }\n }\n \n-#[doc = \"\n-Work with the string as a byte slice, not including trailing null.\n-\"]\n+/// Work with the string as a byte slice, not including trailing null.\n #[inline(always)]\n pure fn byte_slice<T>(s: str/&, f: fn(v: &[u8]) -> T) -> T {\n     do unpack_slice(s) |p,n| {\n         unsafe { vec::unsafe::form_slice(p, n-1u, f) }\n     }\n }\n \n-#[doc = \"Convert a string to a vector of characters\"]\n+/// Convert a string to a vector of characters\n pure fn chars(s: str/&) -> ~[char] {\n     let mut buf = ~[], i = 0u;\n     let len = len(s);\n@@ -353,48 +349,44 @@ pure fn chars(s: str/&) -> ~[char] {\n     ret buf;\n }\n \n-#[doc = \"\n-Take a substring of another.\n-\n-Returns a string containing `n` characters starting at byte offset\n-`begin`.\n-\"]\n+/**\n+ * Take a substring of another.\n+ *\n+ * Returns a string containing `n` characters starting at byte offset\n+ * `begin`.\n+ */\n pure fn substr(s: str/&, begin: uint, n: uint) -> str {\n     slice(s, begin, begin + count_bytes(s, begin, n))\n }\n \n-#[doc = \"\n-Returns a slice of the given string from the byte range [`begin`..`end`)\n-\n-Fails when `begin` and `end` do not point to valid characters or\n-beyond the last character of the string\n-\"]\n+/**\n+ * Returns a slice of the given string from the byte range [`begin`..`end`)\n+ *\n+ * Fails when `begin` and `end` do not point to valid characters or\n+ * beyond the last character of the string\n+ */\n pure fn slice(s: str/&, begin: uint, end: uint) -> str {\n     assert is_char_boundary(s, begin);\n     assert is_char_boundary(s, end);\n     unsafe { unsafe::slice_bytes(s, begin, end) }\n }\n \n-#[doc = \"\n-Splits a string into substrings at each occurrence of a given character\n-\"]\n+/// Splits a string into substrings at each occurrence of a given character\n pure fn split_char(s: str/&, sep: char) -> ~[str] {\n     split_char_inner(s, sep, len(s), true)\n }\n \n-#[doc = \"\n-Splits a string into substrings at each occurrence of a given\n-character up to 'count' times\n-\n-The byte must be a valid UTF-8/ASCII byte\n-\"]\n+/**\n+ * Splits a string into substrings at each occurrence of a given\n+ * character up to 'count' times\n+ *\n+ * The byte must be a valid UTF-8/ASCII byte\n+ */\n pure fn splitn_char(s: str/&, sep: char, count: uint) -> ~[str] {\n     split_char_inner(s, sep, count, true)\n }\n \n-#[doc = \"\n-Like `split_char`, but omits empty strings from the returned vector\n-\"]\n+/// Like `split_char`, but omits empty strings from the returned vector\n pure fn split_char_nonempty(s: str/&, sep: char) -> ~[str] {\n     split_char_inner(s, sep, len(s), false)\n }\n@@ -426,20 +418,20 @@ pure fn split_char_inner(s: str/&, sep: char, count: uint, allow_empty: bool)\n }\n \n \n-#[doc = \"Splits a string into substrings using a character function\"]\n+/// Splits a string into substrings using a character function\n pure fn split(s: str/&, sepfn: fn(char) -> bool) -> ~[str] {\n     split_inner(s, sepfn, len(s), true)\n }\n \n-#[doc = \"\n-Splits a string into substrings using a character function, cutting at\n-most `count` times.\n-\"]\n+/**\n+ * Splits a string into substrings using a character function, cutting at\n+ * most `count` times.\n+ */\n pure fn splitn(s: str/&, sepfn: fn(char) -> bool, count: uint) -> ~[str] {\n     split_inner(s, sepfn, count, true)\n }\n \n-#[doc = \"Like `split`, but omits empty strings from the returned vector\"]\n+/// Like `split`, but omits empty strings from the returned vector\n pure fn split_nonempty(s: str/&, sepfn: fn(char) -> bool) -> ~[str] {\n     split_inner(s, sepfn, len(s), false)\n }\n@@ -502,15 +494,15 @@ pure fn iter_between_matches(s: str/&a, sep: str/&b, f: fn(uint, uint)) {\n     f(last_end, len(s));\n }\n \n-#[doc = \"\n-Splits a string into a vector of the substrings separated by a given string\n-\n-# Example\n-\n-~~~\n-assert [\\\"\\\", \\\"XXX\\\", \\\"YYY\\\", \\\"\\\"] == split_str(\\\".XXX.YYY.\\\", \\\".\\\")\n-~~~\n-\"]\n+/**\n+ * Splits a string into a vector of the substrings separated by a given string\n+ *\n+ * # Example\n+ *\n+ * ~~~\n+ * assert [\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\")\n+ * ~~~\n+ */\n pure fn split_str(s: str/&a, sep: str/&b) -> ~[str] {\n     let mut result = ~[];\n     do iter_between_matches(s, sep) |from, to| {\n@@ -529,15 +521,15 @@ pure fn split_str_nonempty(s: str/&a, sep: str/&b) -> ~[str] {\n     result\n }\n \n-#[doc = \"\n-Splits a string into a vector of the substrings separated by LF ('\\\\n')\n-\"]\n+/**\n+ * Splits a string into a vector of the substrings separated by LF ('\\n')\n+ */\n pure fn lines(s: str/&) -> ~[str] { split_char(s, '\\n') }\n \n-#[doc = \"\n-Splits a string into a vector of the substrings separated by LF ('\\\\n')\n-and/or CR LF ('\\\\r\\\\n')\n-\"]\n+/**\n+ * Splits a string into a vector of the substrings separated by LF ('\\n')\n+ * and/or CR LF (\"\\r\\n\")\n+ */\n pure fn lines_any(s: str/&) -> ~[str] {\n     vec::map(lines(s), |s| {\n         let l = len(s);\n@@ -549,40 +541,38 @@ pure fn lines_any(s: str/&) -> ~[str] {\n     })\n }\n \n-#[doc = \"\n-Splits a string into a vector of the substrings separated by whitespace\n-\"]\n+/// Splits a string into a vector of the substrings separated by whitespace\n pure fn words(s: str/&) -> ~[str] {\n     split_nonempty(s, |c| char::is_whitespace(c))\n }\n \n-#[doc = \"Convert a string to lowercase. ASCII only\"]\n+/// Convert a string to lowercase. ASCII only\n pure fn to_lower(s: str/&) -> str {\n     map(s,\n         |c| unchecked{(libc::tolower(c as libc::c_char)) as char}\n     )\n }\n \n-#[doc = \"Convert a string to uppercase. ASCII only\"]\n+/// Convert a string to uppercase. ASCII only\n pure fn to_upper(s: str/&) -> str {\n     map(s,\n         |c| unchecked{(libc::toupper(c as libc::c_char)) as char}\n     )\n }\n \n-#[doc = \"\n-Replace all occurrences of one string with another\n-\n-# Arguments\n-\n-* s - The string containing substrings to replace\n-* from - The string to replace\n-* to - The replacement string\n-\n-# Return value\n-\n-The original string with all occurances of `from` replaced with `to`\n-\"]\n+/**\n+ * Replace all occurrences of one string with another\n+ *\n+ * # Arguments\n+ *\n+ * * s - The string containing substrings to replace\n+ * * from - The string to replace\n+ * * to - The replacement string\n+ *\n+ * # Return value\n+ *\n+ * The original string with all occurances of `from` replaced with `to`\n+ */\n pure fn replace(s: str, from: str, to: str) -> str {\n     let mut result = \"\", first = true;\n     do iter_between_matches(s, from) |start, end| {\n@@ -596,7 +586,7 @@ pure fn replace(s: str, from: str, to: str) -> str {\n Section: Comparing strings\n */\n \n-#[doc = \"Bytewise string equality\"]\n+/// Bytewise string equality\n pure fn eq(&&a: str, &&b: str) -> bool {\n     // FIXME (#2627): This should just be \"a == b\" but that calls into the\n     // shape code.\n@@ -614,10 +604,10 @@ pure fn eq(&&a: str, &&b: str) -> bool {\n     ret true;\n }\n \n-#[doc = \"Bytewise less than or equal\"]\n+/// Bytewise less than or equal\n pure fn le(&&a: str, &&b: str) -> bool { a <= b }\n \n-#[doc = \"String hash function\"]\n+/// String hash function\n pure fn hash(&&s: str) -> uint {\n     // djb hash.\n     // FIXME: replace with murmur. (see #859 and #1616)\n@@ -630,23 +620,23 @@ pure fn hash(&&s: str) -> uint {\n Section: Iterating through strings\n */\n \n-#[doc = \"\n-Return true if a predicate matches all characters or if the string\n-contains no characters\n-\"]\n+/**\n+ * Return true if a predicate matches all characters or if the string\n+ * contains no characters\n+ */\n pure fn all(s: str/&, it: fn(char) -> bool) -> bool {\n     all_between(s, 0u, len(s), it)\n }\n \n-#[doc = \"\n-Return true if a predicate matches any character (and false if it\n-matches none or there are no characters)\n-\"]\n+/**\n+ * Return true if a predicate matches any character (and false if it\n+ * matches none or there are no characters)\n+ */\n pure fn any(ss: str/&, pred: fn(char) -> bool) -> bool {\n     !all(ss, |cc| !pred(cc))\n }\n \n-#[doc = \"Apply a function to each character\"]\n+/// Apply a function to each character\n pure fn map(ss: str/&, ff: fn(char) -> char) -> str {\n     let mut result = \"\";\n     unchecked {\n@@ -658,7 +648,7 @@ pure fn map(ss: str/&, ff: fn(char) -> char) -> str {\n     result\n }\n \n-#[doc = \"Iterate over the bytes in a string\"]\n+/// Iterate over the bytes in a string\n pure fn bytes_iter(ss: str/&, it: fn(u8)) {\n     let mut pos = 0u;\n     let len = len(ss);\n@@ -669,13 +659,13 @@ pure fn bytes_iter(ss: str/&, it: fn(u8)) {\n     }\n }\n \n-#[doc = \"Iterate over the bytes in a string\"]\n+/// Iterate over the bytes in a string\n #[inline(always)]\n pure fn each(s: str/&, it: fn(u8) -> bool) {\n     eachi(s, |_i, b| it(b) )\n }\n \n-#[doc = \"Iterate over the bytes in a string, with indices\"]\n+/// Iterate over the bytes in a string, with indices\n #[inline(always)]\n pure fn eachi(s: str/&, it: fn(uint, u8) -> bool) {\n     let mut i = 0u, l = len(s);\n@@ -685,13 +675,13 @@ pure fn eachi(s: str/&, it: fn(uint, u8) -> bool) {\n     }\n }\n \n-#[doc = \"Iterates over the chars in a string\"]\n+/// Iterates over the chars in a string\n #[inline(always)]\n pure fn each_char(s: str/&, it: fn(char) -> bool) {\n     each_chari(s, |_i, c| it(c))\n }\n \n-#[doc = \"Iterates over the chars in a string, with indices\"]\n+/// Iterates over the chars in a string, with indices\n #[inline(always)]\n pure fn each_chari(s: str/&, it: fn(uint, char) -> bool) {\n     let mut pos = 0u, ch_pos = 0u;\n@@ -704,7 +694,7 @@ pure fn each_chari(s: str/&, it: fn(uint, char) -> bool) {\n     }\n }\n \n-#[doc = \"Iterate over the characters in a string\"]\n+/// Iterate over the characters in a string\n pure fn chars_iter(s: str/&, it: fn(char)) {\n     let mut pos = 0u;\n     let len = len(s);\n@@ -715,28 +705,28 @@ pure fn chars_iter(s: str/&, it: fn(char)) {\n     }\n }\n \n-#[doc = \"\n-Apply a function to each substring after splitting by character\n-\"]\n+/// Apply a function to each substring after splitting by character\n pure fn split_char_iter(ss: str/&, cc: char, ff: fn(&&str)) {\n    vec::iter(split_char(ss, cc), ff)\n }\n \n-#[doc = \"\n-Apply a function to each substring after splitting by character, up to\n-`count` times\n-\"]\n+/**\n+ * Apply a function to each substring after splitting by character, up to\n+ * `count` times\n+ */\n pure fn splitn_char_iter(ss: str/&, sep: char, count: uint,\n                          ff: fn(&&str)) {\n    vec::iter(splitn_char(ss, sep, count), ff)\n }\n \n-#[doc = \"Apply a function to each word\"]\n+/// Apply a function to each word\n pure fn words_iter(ss: str/&, ff: fn(&&str)) {\n     vec::iter(words(ss), ff)\n }\n \n-#[doc = \"Apply a function to each line (by '\\\\n')\"]\n+/**\n+ * Apply a function to each line (by '\\n')\n+ */\n pure fn lines_iter(ss: str/&, ff: fn(&&str)) {\n     vec::iter(lines(ss), ff)\n }\n@@ -745,68 +735,68 @@ pure fn lines_iter(ss: str/&, ff: fn(&&str)) {\n Section: Searching\n */\n \n-#[doc = \"\n-Returns the byte index of the first matching character\n-\n-# Arguments\n-\n-* `s` - The string to search\n-* `c` - The character to search for\n-\n-# Return value\n-\n-An `option` containing the byte index of the first matching character\n-or `none` if there is no match\n-\"]\n+/**\n+ * Returns the byte index of the first matching character\n+ *\n+ * # Arguments\n+ *\n+ * * `s` - The string to search\n+ * * `c` - The character to search for\n+ *\n+ * # Return value\n+ *\n+ * An `option` containing the byte index of the first matching character\n+ * or `none` if there is no match\n+ */\n pure fn find_char(s: str/&, c: char) -> option<uint> {\n     find_char_between(s, c, 0u, len(s))\n }\n \n-#[doc = \"\n-Returns the byte index of the first matching character beginning\n-from a given byte offset\n-\n-# Arguments\n-\n-* `s` - The string to search\n-* `c` - The character to search for\n-* `start` - The byte index to begin searching at, inclusive\n-\n-# Return value\n-\n-An `option` containing the byte index of the first matching character\n-or `none` if there is no match\n-\n-# Failure\n-\n-`start` must be less than or equal to `len(s)`. `start` must be the\n-index of a character boundary, as defined by `is_char_boundary`.\n-\"]\n+/**\n+ * Returns the byte index of the first matching character beginning\n+ * from a given byte offset\n+ *\n+ * # Arguments\n+ *\n+ * * `s` - The string to search\n+ * * `c` - The character to search for\n+ * * `start` - The byte index to begin searching at, inclusive\n+ *\n+ * # Return value\n+ *\n+ * An `option` containing the byte index of the first matching character\n+ * or `none` if there is no match\n+ *\n+ * # Failure\n+ *\n+ * `start` must be less than or equal to `len(s)`. `start` must be the\n+ * index of a character boundary, as defined by `is_char_boundary`.\n+ */\n pure fn find_char_from(s: str/&, c: char, start: uint) -> option<uint> {\n     find_char_between(s, c, start, len(s))\n }\n \n-#[doc = \"\n-Returns the byte index of the first matching character within a given range\n-\n-# Arguments\n-\n-* `s` - The string to search\n-* `c` - The character to search for\n-* `start` - The byte index to begin searching at, inclusive\n-* `end` - The byte index to end searching at, exclusive\n-\n-# Return value\n-\n-An `option` containing the byte index of the first matching character\n-or `none` if there is no match\n-\n-# Failure\n-\n-`start` must be less than or equal to `end` and `end` must be less than\n-or equal to `len(s)`. `start` must be the index of a character boundary,\n-as defined by `is_char_boundary`.\n-\"]\n+/**\n+ * Returns the byte index of the first matching character within a given range\n+ *\n+ * # Arguments\n+ *\n+ * * `s` - The string to search\n+ * * `c` - The character to search for\n+ * * `start` - The byte index to begin searching at, inclusive\n+ * * `end` - The byte index to end searching at, exclusive\n+ *\n+ * # Return value\n+ *\n+ * An `option` containing the byte index of the first matching character\n+ * or `none` if there is no match\n+ *\n+ * # Failure\n+ *\n+ * `start` must be less than or equal to `end` and `end` must be less than\n+ * or equal to `len(s)`. `start` must be the index of a character boundary,\n+ * as defined by `is_char_boundary`.\n+ */\n pure fn find_char_between(s: str/&, c: char, start: uint, end: uint)\n     -> option<uint> {\n     if c < 128u as char {\n@@ -824,68 +814,68 @@ pure fn find_char_between(s: str/&, c: char, start: uint, end: uint)\n     }\n }\n \n-#[doc = \"\n-Returns the byte index of the last matching character\n-\n-# Arguments\n-\n-* `s` - The string to search\n-* `c` - The character to search for\n-\n-# Return value\n-\n-An `option` containing the byte index of the last matching character\n-or `none` if there is no match\n-\"]\n+/**\n+ * Returns the byte index of the last matching character\n+ *\n+ * # Arguments\n+ *\n+ * * `s` - The string to search\n+ * * `c` - The character to search for\n+ *\n+ * # Return value\n+ *\n+ * An `option` containing the byte index of the last matching character\n+ * or `none` if there is no match\n+ */\n pure fn rfind_char(s: str/&, c: char) -> option<uint> {\n     rfind_char_between(s, c, len(s), 0u)\n }\n \n-#[doc = \"\n-Returns the byte index of the last matching character beginning\n-from a given byte offset\n-\n-# Arguments\n-\n-* `s` - The string to search\n-* `c` - The character to search for\n-* `start` - The byte index to begin searching at, exclusive\n-\n-# Return value\n-\n-An `option` containing the byte index of the last matching character\n-or `none` if there is no match\n-\n-# Failure\n-\n-`start` must be less than or equal to `len(s)`. `start` must be\n-the index of a character boundary, as defined by `is_char_boundary`.\n-\"]\n+/**\n+ * Returns the byte index of the last matching character beginning\n+ * from a given byte offset\n+ *\n+ * # Arguments\n+ *\n+ * * `s` - The string to search\n+ * * `c` - The character to search for\n+ * * `start` - The byte index to begin searching at, exclusive\n+ *\n+ * # Return value\n+ *\n+ * An `option` containing the byte index of the last matching character\n+ * or `none` if there is no match\n+ *\n+ * # Failure\n+ *\n+ * `start` must be less than or equal to `len(s)`. `start` must be\n+ * the index of a character boundary, as defined by `is_char_boundary`.\n+ */\n pure fn rfind_char_from(s: str/&, c: char, start: uint) -> option<uint> {\n     rfind_char_between(s, c, start, 0u)\n }\n \n-#[doc = \"\n-Returns the byte index of the last matching character within a given range\n-\n-# Arguments\n-\n-* `s` - The string to search\n-* `c` - The character to search for\n-* `start` - The byte index to begin searching at, exclusive\n-* `end` - The byte index to end searching at, inclusive\n-\n-# Return value\n-\n-An `option` containing the byte index of the last matching character\n-or `none` if there is no match\n-\n-# Failure\n-\n-`end` must be less than or equal to `start` and `start` must be less than\n-or equal to `len(s)`. `start` must be the index of a character boundary,\n-as defined by `is_char_boundary`.\n-\"]\n+/**\n+ * Returns the byte index of the last matching character within a given range\n+ *\n+ * # Arguments\n+ *\n+ * * `s` - The string to search\n+ * * `c` - The character to search for\n+ * * `start` - The byte index to begin searching at, exclusive\n+ * * `end` - The byte index to end searching at, inclusive\n+ *\n+ * # Return value\n+ *\n+ * An `option` containing the byte index of the last matching character\n+ * or `none` if there is no match\n+ *\n+ * # Failure\n+ *\n+ * `end` must be less than or equal to `start` and `start` must be less than\n+ * or equal to `len(s)`. `start` must be the index of a character boundary,\n+ * as defined by `is_char_boundary`.\n+ */\n pure fn rfind_char_between(s: str/&, c: char, start: uint, end: uint)\n     -> option<uint> {\n     if c < 128u as char {\n@@ -903,71 +893,71 @@ pure fn rfind_char_between(s: str/&, c: char, start: uint, end: uint)\n     }\n }\n \n-#[doc = \"\n-Returns the byte index of the first character that satisfies\n-the given predicate\n-\n-# Arguments\n-\n-* `s` - The string to search\n-* `f` - The predicate to satisfy\n-\n-# Return value\n-\n-An `option` containing the byte index of the first matching character\n-or `none` if there is no match\n-\"]\n+/**\n+ * Returns the byte index of the first character that satisfies\n+ * the given predicate\n+ *\n+ * # Arguments\n+ *\n+ * * `s` - The string to search\n+ * * `f` - The predicate to satisfy\n+ *\n+ * # Return value\n+ *\n+ * An `option` containing the byte index of the first matching character\n+ * or `none` if there is no match\n+ */\n pure fn find(s: str/&, f: fn(char) -> bool) -> option<uint> {\n     find_between(s, 0u, len(s), f)\n }\n \n-#[doc = \"\n-Returns the byte index of the first character that satisfies\n-the given predicate, beginning from a given byte offset\n-\n-# Arguments\n-\n-* `s` - The string to search\n-* `start` - The byte index to begin searching at, inclusive\n-* `f` - The predicate to satisfy\n-\n-# Return value\n-\n-An `option` containing the byte index of the first matching charactor\n-or `none` if there is no match\n-\n-# Failure\n-\n-`start` must be less than or equal to `len(s)`. `start` must be the\n-index of a character boundary, as defined by `is_char_boundary`.\n-\"]\n+/**\n+ * Returns the byte index of the first character that satisfies\n+ * the given predicate, beginning from a given byte offset\n+ *\n+ * # Arguments\n+ *\n+ * * `s` - The string to search\n+ * * `start` - The byte index to begin searching at, inclusive\n+ * * `f` - The predicate to satisfy\n+ *\n+ * # Return value\n+ *\n+ * An `option` containing the byte index of the first matching charactor\n+ * or `none` if there is no match\n+ *\n+ * # Failure\n+ *\n+ * `start` must be less than or equal to `len(s)`. `start` must be the\n+ * index of a character boundary, as defined by `is_char_boundary`.\n+ */\n pure fn find_from(s: str/&, start: uint, f: fn(char)\n     -> bool) -> option<uint> {\n     find_between(s, start, len(s), f)\n }\n \n-#[doc = \"\n-Returns the byte index of the first character that satisfies\n-the given predicate, within a given range\n-\n-# Arguments\n-\n-* `s` - The string to search\n-* `start` - The byte index to begin searching at, inclusive\n-* `end` - The byte index to end searching at, exclusive\n-* `f` - The predicate to satisfy\n-\n-# Return value\n-\n-An `option` containing the byte index of the first matching character\n-or `none` if there is no match\n-\n-# Failure\n-\n-`start` must be less than or equal to `end` and `end` must be less than\n-or equal to `len(s)`. `start` must be the index of a character\n-boundary, as defined by `is_char_boundary`.\n-\"]\n+/**\n+ * Returns the byte index of the first character that satisfies\n+ * the given predicate, within a given range\n+ *\n+ * # Arguments\n+ *\n+ * * `s` - The string to search\n+ * * `start` - The byte index to begin searching at, inclusive\n+ * * `end` - The byte index to end searching at, exclusive\n+ * * `f` - The predicate to satisfy\n+ *\n+ * # Return value\n+ *\n+ * An `option` containing the byte index of the first matching character\n+ * or `none` if there is no match\n+ *\n+ * # Failure\n+ *\n+ * `start` must be less than or equal to `end` and `end` must be less than\n+ * or equal to `len(s)`. `start` must be the index of a character\n+ * boundary, as defined by `is_char_boundary`.\n+ */\n pure fn find_between(s: str/&, start: uint, end: uint, f: fn(char) -> bool)\n     -> option<uint> {\n     assert start <= end;\n@@ -982,71 +972,71 @@ pure fn find_between(s: str/&, start: uint, end: uint, f: fn(char) -> bool)\n     ret none;\n }\n \n-#[doc = \"\n-Returns the byte index of the last character that satisfies\n-the given predicate\n-\n-# Arguments\n-\n-* `s` - The string to search\n-* `f` - The predicate to satisfy\n-\n-# Return value\n-\n-An option containing the byte index of the last matching character\n-or `none` if there is no match\n-\"]\n+/**\n+ * Returns the byte index of the last character that satisfies\n+ * the given predicate\n+ *\n+ * # Arguments\n+ *\n+ * * `s` - The string to search\n+ * * `f` - The predicate to satisfy\n+ *\n+ * # Return value\n+ *\n+ * An option containing the byte index of the last matching character\n+ * or `none` if there is no match\n+ */\n pure fn rfind(s: str/&, f: fn(char) -> bool) -> option<uint> {\n     rfind_between(s, len(s), 0u, f)\n }\n \n-#[doc = \"\n-Returns the byte index of the last character that satisfies\n-the given predicate, beginning from a given byte offset\n-\n-# Arguments\n-\n-* `s` - The string to search\n-* `start` - The byte index to begin searching at, exclusive\n-* `f` - The predicate to satisfy\n-\n-# Return value\n-\n-An `option` containing the byte index of the last matching character\n-or `none` if there is no match\n-\n-# Failure\n-\n-`start` must be less than or equal to `len(s)', `start` must be the\n-index of a character boundary, as defined by `is_char_boundary`\n-\"]\n+/**\n+ * Returns the byte index of the last character that satisfies\n+ * the given predicate, beginning from a given byte offset\n+ *\n+ * # Arguments\n+ *\n+ * * `s` - The string to search\n+ * * `start` - The byte index to begin searching at, exclusive\n+ * * `f` - The predicate to satisfy\n+ *\n+ * # Return value\n+ *\n+ * An `option` containing the byte index of the last matching character\n+ * or `none` if there is no match\n+ *\n+ * # Failure\n+ *\n+ * `start` must be less than or equal to `len(s)', `start` must be the\n+ * index of a character boundary, as defined by `is_char_boundary`\n+ */\n pure fn rfind_from(s: str/&, start: uint, f: fn(char) -> bool)\n     -> option<uint> {\n     rfind_between(s, start, 0u, f)\n }\n \n-#[doc = \"\n-Returns the byte index of the last character that satisfies\n-the given predicate, within a given range\n-\n-# Arguments\n-\n-* `s` - The string to search\n-* `start` - The byte index to begin searching at, exclusive\n-* `end` - The byte index to end searching at, inclusive\n-* `f` - The predicate to satisfy\n-\n-# Return value\n-\n-An `option` containing the byte index of the last matching character\n-or `none` if there is no match\n-\n-# Failure\n-\n-`end` must be less than or equal to `start` and `start` must be less\n-than or equal to `len(s)`. `start` must be the index of a character\n-boundary, as defined by `is_char_boundary`\n-\"]\n+/**\n+ * Returns the byte index of the last character that satisfies\n+ * the given predicate, within a given range\n+ *\n+ * # Arguments\n+ *\n+ * * `s` - The string to search\n+ * * `start` - The byte index to begin searching at, exclusive\n+ * * `end` - The byte index to end searching at, inclusive\n+ * * `f` - The predicate to satisfy\n+ *\n+ * # Return value\n+ *\n+ * An `option` containing the byte index of the last matching character\n+ * or `none` if there is no match\n+ *\n+ * # Failure\n+ *\n+ * `end` must be less than or equal to `start` and `start` must be less\n+ * than or equal to `len(s)`. `start` must be the index of a character\n+ * boundary, as defined by `is_char_boundary`\n+ */\n pure fn rfind_between(s: str/&, start: uint, end: uint, f: fn(char) -> bool)\n     -> option<uint> {\n     assert start >= end;\n@@ -1068,67 +1058,67 @@ pure fn match_at(haystack: str/&a, needle: str/&b, at: uint) -> bool {\n     ret true;\n }\n \n-#[doc = \"\n-Returns the byte index of the first matching substring\n-\n-# Arguments\n-\n-* `haystack` - The string to search\n-* `needle` - The string to search for\n-\n-# Return value\n-\n-An `option` containing the byte index of the first matching substring\n-or `none` if there is no match\n-\"]\n+/**\n+ * Returns the byte index of the first matching substring\n+ *\n+ * # Arguments\n+ *\n+ * * `haystack` - The string to search\n+ * * `needle` - The string to search for\n+ *\n+ * # Return value\n+ *\n+ * An `option` containing the byte index of the first matching substring\n+ * or `none` if there is no match\n+ */\n pure fn find_str(haystack: str/&a, needle: str/&b) -> option<uint> {\n     find_str_between(haystack, needle, 0u, len(haystack))\n }\n \n-#[doc = \"\n-Returns the byte index of the first matching substring beginning\n-from a given byte offset\n-\n-# Arguments\n-\n-* `haystack` - The string to search\n-* `needle` - The string to search for\n-* `start` - The byte index to begin searching at, inclusive\n-\n-# Return value\n-\n-An `option` containing the byte index of the last matching character\n-or `none` if there is no match\n-\n-# Failure\n-\n-`start` must be less than or equal to `len(s)`\n-\"]\n+/**\n+ * Returns the byte index of the first matching substring beginning\n+ * from a given byte offset\n+ *\n+ * # Arguments\n+ *\n+ * * `haystack` - The string to search\n+ * * `needle` - The string to search for\n+ * * `start` - The byte index to begin searching at, inclusive\n+ *\n+ * # Return value\n+ *\n+ * An `option` containing the byte index of the last matching character\n+ * or `none` if there is no match\n+ *\n+ * # Failure\n+ *\n+ * `start` must be less than or equal to `len(s)`\n+ */\n pure fn find_str_from(haystack: str/&a, needle: str/&b, start: uint)\n   -> option<uint> {\n     find_str_between(haystack, needle, start, len(haystack))\n }\n \n-#[doc = \"\n-Returns the byte index of the first matching substring within a given range\n-\n-# Arguments\n-\n-* `haystack` - The string to search\n-* `needle` - The string to search for\n-* `start` - The byte index to begin searching at, inclusive\n-* `end` - The byte index to end searching at, exclusive\n-\n-# Return value\n-\n-An `option` containing the byte index of the first matching character\n-or `none` if there is no match\n-\n-# Failure\n-\n-`start` must be less than or equal to `end` and `end` must be less than\n-or equal to `len(s)`.\n-\"]\n+/**\n+ * Returns the byte index of the first matching substring within a given range\n+ *\n+ * # Arguments\n+ *\n+ * * `haystack` - The string to search\n+ * * `needle` - The string to search for\n+ * * `start` - The byte index to begin searching at, inclusive\n+ * * `end` - The byte index to end searching at, exclusive\n+ *\n+ * # Return value\n+ *\n+ * An `option` containing the byte index of the first matching character\n+ * or `none` if there is no match\n+ *\n+ * # Failure\n+ *\n+ * `start` must be less than or equal to `end` and `end` must be less than\n+ * or equal to `len(s)`.\n+ */\n pure fn find_str_between(haystack: str/&a, needle: str/&b, start: uint,\n                          end:uint)\n   -> option<uint> {\n@@ -1147,53 +1137,53 @@ pure fn find_str_between(haystack: str/&a, needle: str/&b, start: uint,\n     ret none;\n }\n \n-#[doc = \"\n-Returns true if one string contains another\n-\n-# Arguments\n-\n-* haystack - The string to look in\n-* needle - The string to look for\n-\"]\n+/**\n+ * Returns true if one string contains another\n+ *\n+ * # Arguments\n+ *\n+ * * haystack - The string to look in\n+ * * needle - The string to look for\n+ */\n pure fn contains(haystack: str/&a, needle: str/&b) -> bool {\n     option::is_some(find_str(haystack, needle))\n }\n \n-#[doc = \"\n-Returns true if a string contains a char.\n-\n-# Arguments\n-\n-* haystack - The string to look in\n-* needle - The char to look for\n-\"]\n+/**\n+ * Returns true if a string contains a char.\n+ *\n+ * # Arguments\n+ *\n+ * * haystack - The string to look in\n+ * * needle - The char to look for\n+ */\n pure fn contains_char(haystack: str/&, needle: char) -> bool {\n     option::is_some(find_char(haystack, needle))\n }\n \n-#[doc = \"\n-Returns true if one string starts with another\n-\n-# Arguments\n-\n-* haystack - The string to look in\n-* needle - The string to look for\n-\"]\n+/**\n+ * Returns true if one string starts with another\n+ *\n+ * # Arguments\n+ *\n+ * * haystack - The string to look in\n+ * * needle - The string to look for\n+ */\n pure fn starts_with(haystack: str/&a, needle: str/&b) -> bool {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n     else { match_at(haystack, needle, 0u) }\n }\n \n-#[doc = \"\n-Returns true if one string ends with another\n-\n-# Arguments\n-\n-* haystack - The string to look in\n-* needle - The string to look for\n-\"]\n+/**\n+ * Returns true if one string ends with another\n+ *\n+ * # Arguments\n+ *\n+ * * haystack - The string to look in\n+ * * needle - The string to look for\n+ */\n pure fn ends_with(haystack: str/&a, needle: str/&b) -> bool {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n@@ -1205,52 +1195,50 @@ pure fn ends_with(haystack: str/&a, needle: str/&b) -> bool {\n Section: String properties\n */\n \n-#[doc = \"Determines if a string contains only ASCII characters\"]\n+/// Determines if a string contains only ASCII characters\n pure fn is_ascii(s: str/&) -> bool {\n     let mut i: uint = len(s);\n     while i > 0u { i -= 1u; if !u8::is_ascii(s[i]) { ret false; } }\n     ret true;\n }\n \n-#[doc = \"Returns true if the string has length 0\"]\n+/// Returns true if the string has length 0\n pure fn is_empty(s: str/&) -> bool { len(s) == 0u }\n \n-#[doc = \"Returns true if the string has length greater than 0\"]\n+/// Returns true if the string has length greater than 0\n pure fn is_not_empty(s: str/&) -> bool { !is_empty(s) }\n \n-#[doc = \"\n-Returns true if the string contains only whitespace\n-\n-Whitespace characters are determined by `char::is_whitespace`\n-\"]\n+/**\n+ * Returns true if the string contains only whitespace\n+ *\n+ * Whitespace characters are determined by `char::is_whitespace`\n+ */\n pure fn is_whitespace(s: str/&) -> bool {\n     ret all(s, char::is_whitespace);\n }\n \n-#[doc = \"\n-Returns true if the string contains only alphanumerics\n-\n-Alphanumeric characters are determined by `char::is_alphanumeric`\n-\"]\n+/**\n+ * Returns true if the string contains only alphanumerics\n+ *\n+ * Alphanumeric characters are determined by `char::is_alphanumeric`\n+ */\n fn is_alphanumeric(s: str/&) -> bool {\n     ret all(s, char::is_alphanumeric);\n }\n \n-#[doc = \"\n-Returns the string length/size in bytes not counting the null terminator\n-\"]\n+/// Returns the string length/size in bytes not counting the null terminator\n pure fn len(s: str/&) -> uint {\n     do unpack_slice(s) |_p, n| { n - 1u }\n }\n \n-#[doc = \"Returns the number of characters that a string holds\"]\n+/// Returns the number of characters that a string holds\n pure fn char_len(s: str/&) -> uint { count_chars(s, 0u, len(s)) }\n \n /*\n Section: Misc\n */\n \n-#[doc = \"Determines if a vector of bytes contains valid UTF-8\"]\n+/// Determines if a vector of bytes contains valid UTF-8\n pure fn is_utf8(v: &[const u8]) -> bool {\n     let mut i = 0u;\n     let total = vec::len::<u8>(v);\n@@ -1268,7 +1256,7 @@ pure fn is_utf8(v: &[const u8]) -> bool {\n     ret true;\n }\n \n-#[doc = \"Determines if a vector of `u16` contains valid UTF-16\"]\n+/// Determines if a vector of `u16` contains valid UTF-16\n pure fn is_utf16(v: &[const u16]) -> bool {\n     let len = vec::len(v);\n     let mut i = 0u;\n@@ -1289,7 +1277,7 @@ pure fn is_utf16(v: &[const u16]) -> bool {\n     ret true;\n }\n \n-#[doc = \"Converts to a vector of `u16` encoded as UTF-16\"]\n+/// Converts to a vector of `u16` encoded as UTF-16\n pure fn to_utf16(s: str/&) -> ~[u16] {\n     let mut u = ~[];\n     do chars_iter(s) |cch| {\n@@ -1347,19 +1335,19 @@ pure fn from_utf16(v: &[const u16]) -> str {\n }\n \n \n-#[doc = \"\n-As char_len but for a slice of a string\n-\n-# Arguments\n-\n-* s - A valid string\n-* start - The position inside `s` where to start counting in bytes\n-* end - The position where to stop counting\n-\n-# Return value\n-\n-The number of Unicode characters in `s` between the given indices.\n-\"]\n+/**\n+ * As char_len but for a slice of a string\n+ *\n+ * # Arguments\n+ *\n+ * * s - A valid string\n+ * * start - The position inside `s` where to start counting in bytes\n+ * * end - The position where to stop counting\n+ *\n+ * # Return value\n+ *\n+ * The number of Unicode characters in `s` between the given indices.\n+ */\n pure fn count_chars(s: str/&, start: uint, end: uint) -> uint {\n     assert is_char_boundary(s, start);\n     assert is_char_boundary(s, end);\n@@ -1372,9 +1360,7 @@ pure fn count_chars(s: str/&, start: uint, end: uint) -> uint {\n     ret len;\n }\n \n-#[doc = \"\n-Counts the number of bytes taken by the `n` in `s` starting from `start`.\n-\"]\n+/// Counts the number of bytes taken by the `n` in `s` starting from `start`.\n pure fn count_bytes(s: str/&b, start: uint, n: uint) -> uint {\n     assert is_char_boundary(s, start);\n     let mut end = start, cnt = n;\n@@ -1388,9 +1374,7 @@ pure fn count_bytes(s: str/&b, start: uint, n: uint) -> uint {\n     end - start\n }\n \n-#[doc = \"\n-Given a first byte, determine how many bytes are in this UTF-8 character\n-\"]\n+/// Given a first byte, determine how many bytes are in this UTF-8 character\n pure fn utf8_char_width(b: u8) -> uint {\n     let byte: uint = b as uint;\n     if byte < 128u { ret 1u; }\n@@ -1403,63 +1387,65 @@ pure fn utf8_char_width(b: u8) -> uint {\n     ret 6u;\n }\n \n-#[doc = \"\n-Returns false if the index points into the middle of a multi-byte\n-character sequence.\n-\"]\n+/**\n+ * Returns false if the index points into the middle of a multi-byte\n+ * character sequence.\n+ */\n pure fn is_char_boundary(s: str/&, index: uint) -> bool {\n     if index == len(s) { ret true; }\n     let b = s[index];\n     ret b < 128u8 || b >= 192u8;\n }\n \n-#[doc = \"\n-Pluck a character out of a string and return the index of the next character.\n-\n-This function can be used to iterate over the unicode characters of a string.\n-\n-# Example\n-\n-~~~\n-let s = \\\"\u4e2d\u534eVi\u1ec7t Nam\\\";\n-let i = 0u;\n-while i < str::len(s) {\n-    let {ch, next} = str::char_range_at(s, i);\n-    std::io::println(#fmt(\\\"%u: %c\\\",i,ch));\n-    i = next;\n-}\n-~~~\n-\n-# Example output\n-\n-~~~\n-0: \u4e2d\n-3: \u534e\n-6: V\n-7: i\n-8: \u1ec7\n-11: t\n-12:\n-13: N\n-14: a\n-15: m\n-~~~\n-\n-# Arguments\n-\n-* s - The string\n-* i - The byte offset of the char to extract\n-\n-# Return value\n-\n-A record {ch: char, next: uint} containing the char value and the byte\n-index of the next unicode character.\n-\n-# Failure\n-\n-If `i` is greater than or equal to the length of the string.\n-If `i` is not the index of the beginning of a valid UTF-8 character.\n-\"]\n+/**\n+ * Pluck a character out of a string and return the index of the next\n+ * character.\n+ *\n+ * This function can be used to iterate over the unicode characters of a\n+ * string.\n+ *\n+ * # Example\n+ *\n+ * ~~~\n+ * let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+ * let i = 0u;\n+ * while i < str::len(s) {\n+ *     let {ch, next} = str::char_range_at(s, i);\n+ *     std::io::println(#fmt(\"%u: %c\",i,ch));\n+ *     i = next;\n+ * }\n+ * ~~~\n+ *\n+ * # Example output\n+ *\n+ * ~~~\n+ * 0: \u4e2d\n+ * 3: \u534e\n+ * 6: V\n+ * 7: i\n+ * 8: \u1ec7\n+ * 11: t\n+ * 12:\n+ * 13: N\n+ * 14: a\n+ * 15: m\n+ * ~~~\n+ *\n+ * # Arguments\n+ *\n+ * * s - The string\n+ * * i - The byte offset of the char to extract\n+ *\n+ * # Return value\n+ *\n+ * A record {ch: char, next: uint} containing the char value and the byte\n+ * index of the next unicode character.\n+ *\n+ * # Failure\n+ *\n+ * If `i` is greater than or equal to the length of the string.\n+ * If `i` is not the index of the beginning of a valid UTF-8 character.\n+ */\n pure fn char_range_at(s: str/&, i: uint) -> {ch: char, next: uint} {\n     let b0 = s[i];\n     let w = utf8_char_width(b0);\n@@ -1482,14 +1468,14 @@ pure fn char_range_at(s: str/&, i: uint) -> {ch: char, next: uint} {\n     ret {ch: val as char, next: i};\n }\n \n-#[doc = \"Pluck a character out of a string\"]\n+/// Pluck a character out of a string\n pure fn char_at(s: str/&, i: uint) -> char { ret char_range_at(s, i).ch; }\n \n-#[doc = \"\n-Given a byte position and a str, return the previous char and its position\n-\n-This function can be used to iterate over a unicode string in reverse.\n-\"]\n+/**\n+ * Given a byte position and a str, return the previous char and its position\n+ *\n+ * This function can be used to iterate over a unicode string in reverse.\n+ */\n pure fn char_range_at_reverse(ss: str/&, start: uint)\n     -> {ch: char, prev: uint} {\n \n@@ -1507,28 +1493,28 @@ pure fn char_range_at_reverse(ss: str/&, start: uint)\n     ret {ch:ch, prev:prev};\n }\n \n-#[doc = \"\n-Loop through a substring, char by char\n-\n-# Safety note\n-\n-* This function does not check whether the substring is valid.\n-* This function fails if `start` or `end` do not\n-  represent valid positions inside `s`\n-\n-# Arguments\n-\n-* s - A string to traverse. It may be empty.\n-* start - The byte offset at which to start in the string.\n-* end - The end of the range to traverse\n-* it - A block to execute with each consecutive character of `s`.\n-       Return `true` to continue, `false` to stop.\n-\n-# Return value\n-\n-`true` If execution proceeded correctly, `false` if it was interrupted,\n-that is if `it` returned `false` at any point.\n-\"]\n+/**\n+ * Loop through a substring, char by char\n+ *\n+ * # Safety note\n+ *\n+ * * This function does not check whether the substring is valid.\n+ * * This function fails if `start` or `end` do not\n+ *   represent valid positions inside `s`\n+ *\n+ * # Arguments\n+ *\n+ * * s - A string to traverse. It may be empty.\n+ * * start - The byte offset at which to start in the string.\n+ * * end - The end of the range to traverse\n+ * * it - A block to execute with each consecutive character of `s`.\n+ *        Return `true` to continue, `false` to stop.\n+ *\n+ * # Return value\n+ *\n+ * `true` If execution proceeded correctly, `false` if it was interrupted,\n+ * that is if `it` returned `false` at any point.\n+ */\n pure fn all_between(s: str/&, start: uint, end: uint,\n                     it: fn(char) -> bool) -> bool {\n     assert is_char_boundary(s, start);\n@@ -1541,27 +1527,27 @@ pure fn all_between(s: str/&, start: uint, end: uint,\n     ret true;\n }\n \n-#[doc = \"\n-Loop through a substring, char by char\n-\n-# Safety note\n-\n-* This function does not check whether the substring is valid.\n-* This function fails if `start` or `end` do not\n-  represent valid positions inside `s`\n-\n-# Arguments\n-\n-* s - A string to traverse. It may be empty.\n-* start - The byte offset at which to start in the string.\n-* end - The end of the range to traverse\n-* it - A block to execute with each consecutive character of `s`.\n-       Return `true` to continue, `false` to stop.\n-\n-# Return value\n-\n-`true` if `it` returns `true` for any character\n-\"]\n+/**\n+ * Loop through a substring, char by char\n+ *\n+ * # Safety note\n+ *\n+ * * This function does not check whether the substring is valid.\n+ * * This function fails if `start` or `end` do not\n+ *   represent valid positions inside `s`\n+ *\n+ * # Arguments\n+ *\n+ * * s - A string to traverse. It may be empty.\n+ * * start - The byte offset at which to start in the string.\n+ * * end - The end of the range to traverse\n+ * * it - A block to execute with each consecutive character of `s`.\n+ *        Return `true` to continue, `false` to stop.\n+ *\n+ * # Return value\n+ *\n+ * `true` if `it` returns `true` for any character\n+ */\n pure fn any_between(s: str/&, start: uint, end: uint,\n                     it: fn(char) -> bool) -> bool {\n     !all_between(s, start, end, |c| !it(c))\n@@ -1582,60 +1568,60 @@ const max_five_b: uint = 67108864u;\n const tag_six_b: uint = 252u;\n \n \n-#[doc = \"\n-Work with the byte buffer of a string.\n-\n-Allows for unsafe manipulation of strings, which is useful for foreign\n-interop.\n-\n-# Example\n-\n-~~~\n-let i = str::as_bytes(\\\"Hello World\\\") { |bytes| vec::len(bytes) };\n-~~~\n-\"]\n+/**\n+ * Work with the byte buffer of a string.\n+ *\n+ * Allows for unsafe manipulation of strings, which is useful for foreign\n+ * interop.\n+ *\n+ * # Example\n+ *\n+ * ~~~\n+ * let i = str::as_bytes(\"Hello World\") { |bytes| vec::len(bytes) };\n+ * ~~~\n+ */\n pure fn as_bytes<T>(s: str, f: fn(~[u8]) -> T) -> T {\n     unsafe {\n         let v: *~[u8] = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n         f(*v)\n     }\n }\n \n-#[doc = \"\n-Work with the byte buffer of a string.\n-\n-Allows for unsafe manipulation of strings, which is useful for foreign\n-interop.\n-\"]\n+/**\n+ * Work with the byte buffer of a string.\n+ *\n+ * Allows for unsafe manipulation of strings, which is useful for foreign\n+ * interop.\n+ */\n pure fn as_buf<T>(s: str, f: fn(*u8) -> T) -> T {\n     as_bytes(s, |v| unsafe { vec::as_buf(v, f) })\n }\n \n-#[doc = \"\n-Work with the byte buffer of a string as a null-terminated C string.\n-\n-Allows for unsafe manipulation of strings, which is useful for foreign\n-interop, without copying the original string.\n-\n-# Example\n-\n-~~~\n-let s = str::as_buf(\\\"PATH\\\", { |path_buf| libc::getenv(path_buf) });\n-~~~\n-\"]\n+/**\n+ * Work with the byte buffer of a string as a null-terminated C string.\n+ *\n+ * Allows for unsafe manipulation of strings, which is useful for foreign\n+ * interop, without copying the original string.\n+ *\n+ * # Example\n+ *\n+ * ~~~\n+ * let s = str::as_buf(\"PATH\", { |path_buf| libc::getenv(path_buf) });\n+ * ~~~\n+ */\n pure fn as_c_str<T>(s: str, f: fn(*libc::c_char) -> T) -> T {\n     as_buf(s, |buf| f(buf as *libc::c_char))\n }\n \n \n-#[doc = \"\n-Work with the byte buffer and length of a slice.\n-\n-The unpacked length is one byte longer than the 'official' indexable\n-length of the string. This is to permit probing the byte past the\n-indexable area for a null byte, as is the case in slices pointing\n-to full strings, or suffixes of them.\n-\"]\n+/**\n+ * Work with the byte buffer and length of a slice.\n+ *\n+ * The unpacked length is one byte longer than the 'official' indexable\n+ * length of the string. This is to permit probing the byte past the\n+ * indexable area for a null byte, as is the case in slices pointing\n+ * to full strings, or suffixes of them.\n+ */\n #[inline(always)]\n pure fn unpack_slice<T>(s: str/&, f: fn(*u8, uint) -> T) -> T {\n     unsafe {\n@@ -1645,56 +1631,56 @@ pure fn unpack_slice<T>(s: str/&, f: fn(*u8, uint) -> T) -> T {\n     }\n }\n \n-#[doc = \"\n-Reserves capacity for exactly `n` bytes in the given string, not including\n-the null terminator.\n-\n-Assuming single-byte characters, the resulting string will be large\n-enough to hold a string of length `n`. To account for the null terminator,\n-the underlying buffer will have the size `n` + 1.\n-\n-If the capacity for `s` is already equal to or greater than the requested\n-capacity, then no action is taken.\n-\n-# Arguments\n-\n-* s - A string\n-* n - The number of bytes to reserve space for\n-\"]\n+/**\n+ * Reserves capacity for exactly `n` bytes in the given string, not including\n+ * the null terminator.\n+ *\n+ * Assuming single-byte characters, the resulting string will be large\n+ * enough to hold a string of length `n`. To account for the null terminator,\n+ * the underlying buffer will have the size `n` + 1.\n+ *\n+ * If the capacity for `s` is already equal to or greater than the requested\n+ * capacity, then no action is taken.\n+ *\n+ * # Arguments\n+ *\n+ * * s - A string\n+ * * n - The number of bytes to reserve space for\n+ */\n fn reserve(&s: str, n: uint) {\n     if capacity(s) < n {\n         rustrt::str_reserve_shared(s, n as size_t);\n     }\n }\n \n-#[doc = \"\n-Reserves capacity for at least `n` bytes in the given string, not including\n-the null terminator.\n-\n-Assuming single-byte characters, the resulting string will be large\n-enough to hold a string of length `n`. To account for the null terminator,\n-the underlying buffer will have the size `n` + 1.\n-\n-This function will over-allocate in order to amortize the allocation costs\n-in scenarios where the caller may need to repeatedly reserve additional\n-space.\n-\n-If the capacity for `s` is already equal to or greater than the requested\n-capacity, then no action is taken.\n-\n-# Arguments\n-\n-* s - A string\n-* n - The number of bytes to reserve space for\n-\"]\n+/**\n+ * Reserves capacity for at least `n` bytes in the given string, not including\n+ * the null terminator.\n+ *\n+ * Assuming single-byte characters, the resulting string will be large\n+ * enough to hold a string of length `n`. To account for the null terminator,\n+ * the underlying buffer will have the size `n` + 1.\n+ *\n+ * This function will over-allocate in order to amortize the allocation costs\n+ * in scenarios where the caller may need to repeatedly reserve additional\n+ * space.\n+ *\n+ * If the capacity for `s` is already equal to or greater than the requested\n+ * capacity, then no action is taken.\n+ *\n+ * # Arguments\n+ *\n+ * * s - A string\n+ * * n - The number of bytes to reserve space for\n+ */\n fn reserve_at_least(&s: str, n: uint) {\n     reserve(s, uint::next_power_of_two(n + 1u) - 1u)\n }\n \n-#[doc = \"\n-Returns the number of single-byte characters the string can hold without\n-reallocating\n-\"]\n+/**\n+ * Returns the number of single-byte characters the string can hold without\n+ * reallocating\n+ */\n pure fn capacity(&&s: str) -> uint {\n     do as_bytes(s) |buf| {\n         let vcap = vec::capacity(buf);\n@@ -1703,7 +1689,7 @@ pure fn capacity(&&s: str) -> uint {\n     }\n }\n \n-#[doc = \"Escape each char in `s` with char::escape_default.\"]\n+/// Escape each char in `s` with char::escape_default.\n pure fn escape_default(s: str/&) -> str {\n     let mut out: str = \"\";\n     unchecked {\n@@ -1713,7 +1699,7 @@ pure fn escape_default(s: str/&) -> str {\n     ret out;\n }\n \n-#[doc = \"Escape each char in `s` with char::escape_unicode.\"]\n+/// Escape each char in `s` with char::escape_unicode.\n pure fn escape_unicode(s: str/&) -> str {\n     let mut out: str = \"\";\n     unchecked {\n@@ -1723,7 +1709,7 @@ pure fn escape_unicode(s: str/&) -> str {\n     ret out;\n }\n \n-#[doc = \"Unsafe operations\"]\n+/// Unsafe operations\n mod unsafe {\n    export\n       from_buf,\n@@ -1737,7 +1723,7 @@ mod unsafe {\n       shift_byte,\n       set_len;\n \n-    #[doc = \"Create a Rust string from a null-terminated *u8 buffer\"]\n+    /// Create a Rust string from a null-terminated *u8 buffer\n     unsafe fn from_buf(buf: *u8) -> str {\n         let mut curr = buf, i = 0u;\n         while *curr != 0u8 {\n@@ -1747,7 +1733,7 @@ mod unsafe {\n         ret from_buf_len(buf, i);\n     }\n \n-    #[doc = \"Create a Rust string from a *u8 buffer of the given length\"]\n+    /// Create a Rust string from a *u8 buffer of the given length\n     unsafe fn from_buf_len(buf: *u8, len: uint) -> str {\n         let mut v: ~[u8] = ~[];\n         vec::reserve(v, len + 1u);\n@@ -1759,23 +1745,21 @@ mod unsafe {\n         ret ::unsafe::transmute(v);\n     }\n \n-    #[doc = \"Create a Rust string from a null-terminated C string\"]\n+    /// Create a Rust string from a null-terminated C string\n     unsafe fn from_c_str(c_str: *libc::c_char) -> str {\n         from_buf(::unsafe::reinterpret_cast(c_str))\n     }\n \n-    #[doc = \"\n-    Create a Rust string from a `*c_char` buffer of the given length\n-    \"]\n+    /// Create a Rust string from a `*c_char` buffer of the given length\n     unsafe fn from_c_str_len(c_str: *libc::c_char, len: uint) -> str {\n         from_buf_len(::unsafe::reinterpret_cast(c_str), len)\n     }\n \n-   #[doc = \"\n-   Converts a vector of bytes to a string.\n-\n-   Does not verify that the vector contains valid UTF-8.\n-   \"]\n+   /**\n+    * Converts a vector of bytes to a string.\n+    *\n+    * Does not verify that the vector contains valid UTF-8.\n+    */\n    unsafe fn from_bytes(+v: ~[const u8]) -> str {\n        unsafe {\n            let mut vcopy = ::unsafe::transmute(v);\n@@ -1784,23 +1768,23 @@ mod unsafe {\n        }\n    }\n \n-   #[doc = \"\n-   Converts a byte to a string.\n-\n-   Does not verify that the byte is valid UTF-8.\n-   \"]\n+   /**\n+    * Converts a byte to a string.\n+    *\n+    * Does not verify that the byte is valid UTF-8.\n+    */\n    unsafe fn from_byte(u: u8) -> str { unsafe::from_bytes(~[u]) }\n \n-   #[doc = \"\n-   Takes a bytewise (not UTF-8) slice from a string.\n-\n-   Returns the substring from [`begin`..`end`).\n-\n-   # Failure\n-\n-   If begin is greater than end.\n-   If end is greater than the length of the string.\n-   \"]\n+   /**\n+    * Takes a bytewise (not UTF-8) slice from a string.\n+    *\n+    * Returns the substring from [`begin`..`end`).\n+    *\n+    * # Failure\n+    *\n+    * If begin is greater than end.\n+    * If end is greater than the length of the string.\n+    */\n    unsafe fn slice_bytes(s: str/&, begin: uint, end: uint) -> str {\n        do unpack_slice(s) |sbuf, n| {\n            assert (begin <= end);\n@@ -1820,19 +1804,17 @@ mod unsafe {\n        }\n    }\n \n-   #[doc = \"Appends a byte to a string. (Not UTF-8 safe).\"]\n+   /// Appends a byte to a string. (Not UTF-8 safe).\n    unsafe fn push_byte(&s: str, b: u8) {\n        rustrt::rust_str_push(s, b);\n    }\n \n-   #[doc = \"Appends a vector of bytes to a string. (Not UTF-8 safe).\"]\n+   /// Appends a vector of bytes to a string. (Not UTF-8 safe).\n    unsafe fn push_bytes(&s: str, bytes: ~[u8]) {\n        for vec::each(bytes) |byte| { rustrt::rust_str_push(s, byte); }\n    }\n \n-   #[doc = \"\n-   Removes the last byte from a string and returns it. (Not UTF-8 safe).\n-   \"]\n+   /// Removes the last byte from a string and returns it. (Not UTF-8 safe).\n    unsafe fn pop_byte(&s: str) -> u8 {\n        let len = len(s);\n        assert (len > 0u);\n@@ -1841,9 +1823,7 @@ mod unsafe {\n        ret b;\n    }\n \n-   #[doc = \"\n-   Removes the first byte from a string and returns it. (Not UTF-8 safe).\n-   \"]\n+   /// Removes the first byte from a string and returns it. (Not UTF-8 safe).\n    unsafe fn shift_byte(&s: str) -> u8 {\n        let len = len(s);\n        assert (len > 0u);\n@@ -1852,9 +1832,7 @@ mod unsafe {\n        ret b;\n    }\n \n-    #[doc = \"\n-    Sets the length of the string and adds the null terminator\n-    \"]\n+    /// Sets the length of the string and adds the null terminator\n     unsafe fn set_len(&v: str, new_len: uint) {\n         let repr: *vec::unsafe::vec_repr = ::unsafe::reinterpret_cast(v);\n         (*repr).fill = new_len + 1u;\n@@ -1874,120 +1852,121 @@ mod unsafe {\n \n }\n \n-#[doc = \"Extension methods for strings\"]\n+/// Extension methods for strings\n impl extensions for str {\n-    #[doc = \"Returns a string with leading and trailing whitespace removed\"]\n+    /// Returns a string with leading and trailing whitespace removed\n     #[inline]\n     fn trim() -> str { trim(self) }\n-    #[doc = \"Returns a string with leading whitespace removed\"]\n+    /// Returns a string with leading whitespace removed\n     #[inline]\n     fn trim_left() -> str { trim_left(self) }\n-    #[doc = \"Returns a string with trailing whitespace removed\"]\n+    /// Returns a string with trailing whitespace removed\n     #[inline]\n     fn trim_right() -> str { trim_right(self) }\n }\n \n-#[doc = \"Extension methods for strings\"]\n+/// Extension methods for strings\n impl extensions/& for str/& {\n-    #[doc = \"\n-    Return true if a predicate matches all characters or if the string\n-    contains no characters\n-    \"]\n+    /**\n+     * Return true if a predicate matches all characters or if the string\n+     * contains no characters\n+     */\n     #[inline]\n     fn all(it: fn(char) -> bool) -> bool { all(self, it) }\n-    #[doc = \"\n-    Return true if a predicate matches any character (and false if it\n-    matches none or there are no characters)\n-    \"]\n+    /**\n+     * Return true if a predicate matches any character (and false if it\n+     * matches none or there are no characters)\n+     */\n     #[inline]\n     fn any(it: fn(char) -> bool) -> bool { any(self, it) }\n-    #[doc = \"Returns true if one string contains another\"]\n+    /// Returns true if one string contains another\n     #[inline]\n     fn contains(needle: str/&a) -> bool { contains(self, needle) }\n-    #[doc = \"Returns true if a string contains a char\"]\n+    /// Returns true if a string contains a char\n     #[inline]\n     fn contains_char(needle: char) -> bool { contains_char(self, needle) }\n-    #[doc = \"Iterate over the bytes in a string\"]\n+    /// Iterate over the bytes in a string\n     #[inline]\n     fn each(it: fn(u8) -> bool) { each(self, it) }\n-    #[doc = \"Iterate over the bytes in a string, with indices\"]\n+    /// Iterate over the bytes in a string, with indices\n     #[inline]\n     fn eachi(it: fn(uint, u8) -> bool) { eachi(self, it) }\n-    #[doc = \"Iterate over the chars in a string\"]\n+    /// Iterate over the chars in a string\n     #[inline]\n     fn each_char(it: fn(char) -> bool) { each_char(self, it) }\n-    #[doc = \"Iterate over the chars in a string, with indices\"]\n+    /// Iterate over the chars in a string, with indices\n     #[inline]\n     fn each_chari(it: fn(uint, char) -> bool) { each_chari(self, it) }\n-    #[doc = \"Returns true if one string ends with another\"]\n+    /// Returns true if one string ends with another\n     #[inline]\n     fn ends_with(needle: str/&) -> bool { ends_with(self, needle) }\n-    #[doc = \"Returns true if the string has length 0\"]\n+    /// Returns true if the string has length 0\n     #[inline]\n     fn is_empty() -> bool { is_empty(self) }\n-    #[doc = \"Returns true if the string has length greater than 0\"]\n+    /// Returns true if the string has length greater than 0\n     #[inline]\n     fn is_not_empty() -> bool { is_not_empty(self) }\n-    #[doc = \"\n-    Returns true if the string contains only whitespace\n-\n-    Whitespace characters are determined by `char::is_whitespace`\n-    \"]\n+    /**\n+     * Returns true if the string contains only whitespace\n+     *\n+     * Whitespace characters are determined by `char::is_whitespace`\n+     */\n     #[inline]\n     fn is_whitespace() -> bool { is_whitespace(self) }\n-    #[doc = \"\n-    Returns true if the string contains only alphanumerics\n-\n-    Alphanumeric characters are determined by `char::is_alphanumeric`\n-    \"]\n+    /**\n+     * Returns true if the string contains only alphanumerics\n+     *\n+     * Alphanumeric characters are determined by `char::is_alphanumeric`\n+     */\n     #[inline]\n     fn is_alphanumeric() -> bool { is_alphanumeric(self) }\n     #[inline]\n-    #[doc =\"Returns the size in bytes not counting the null terminator\"]\n+    /// Returns the size in bytes not counting the null terminator\n     pure fn len() -> uint { len(self) }\n-    #[doc = \"\n-    Returns a slice of the given string from the byte range [`begin`..`end`)\n-\n-    Fails when `begin` and `end` do not point to valid characters or\n-    beyond the last character of the string\n-    \"]\n+    /**\n+     * Returns a slice of the given string from the byte range\n+     * [`begin`..`end`)\n+     *\n+     * Fails when `begin` and `end` do not point to valid characters or\n+     * beyond the last character of the string\n+     */\n     #[inline]\n     fn slice(begin: uint, end: uint) -> str { slice(self, begin, end) }\n-    #[doc = \"Splits a string into substrings using a character function\"]\n+    /// Splits a string into substrings using a character function\n     #[inline]\n     fn split(sepfn: fn(char) -> bool) -> ~[str] { split(self, sepfn) }\n-    #[doc = \"\n-    Splits a string into substrings at each occurrence of a given character\n-    \"]\n+    /**\n+     * Splits a string into substrings at each occurrence of a given character\n+     */\n     #[inline]\n     fn split_char(sep: char) -> ~[str] { split_char(self, sep) }\n-    #[doc = \"\n-    Splits a string into a vector of the substrings separated by a given\n-    string\n-    \"]\n+    /**\n+     * Splits a string into a vector of the substrings separated by a given\n+     * string\n+     */\n     #[inline]\n     fn split_str(sep: str/&a) -> ~[str] { split_str(self, sep) }\n-    #[doc = \"Returns true if one string starts with another\"]\n+    /// Returns true if one string starts with another\n     #[inline]\n     fn starts_with(needle: str/&a) -> bool { starts_with(self, needle) }\n-    #[doc = \"\n-    Take a substring of another.\n-\n-    Returns a string containing `n` characters starting at byte offset\n-    `begin`.\n-    \"]\n+    /**\n+     * Take a substring of another.\n+     *\n+     * Returns a string containing `n` characters starting at byte offset\n+     * `begin`.\n+     */\n     #[inline]\n     fn substr(begin: uint, n: uint) -> str { substr(self, begin, n) }\n-    #[doc = \"Convert a string to lowercase\"]\n+    /// Convert a string to lowercase\n     #[inline]\n     fn to_lower() -> str { to_lower(self) }\n-    #[doc = \"Convert a string to uppercase\"]\n+    /// Convert a string to uppercase\n     #[inline]\n     fn to_upper() -> str { to_upper(self) }\n-    #[doc = \"Escape each char in `s` with char::escape_default.\"]\n+    /// Escape each char in `s` with char::escape_default.\n     #[inline]\n     fn escape_default() -> str { escape_default(self) }\n-    #[doc = \"Escape each char in `s` with char::escape_unicode.\"]\n+    /// Escape each char in `s` with char::escape_unicode.\n     #[inline]\n     fn escape_unicode() -> str { escape_unicode(self) }\n }"}, {"sha": "e99860a6250e7c3c52803f9f61c1ce8609c7f9ba", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Misc low level stuff\"];\n+//! Misc low level stuff\n \n export type_desc;\n export get_type_desc;\n@@ -39,38 +39,38 @@ extern mod rusti {\n     fn min_align_of<T>() -> uint;\n }\n \n-#[doc = \"\n-Returns a pointer to a type descriptor.\n-\n-Useful for calling certain function in the Rust runtime or otherwise\n-performing dark magick.\n-\"]\n+/**\n+ * Returns a pointer to a type descriptor.\n+ *\n+ * Useful for calling certain function in the Rust runtime or otherwise\n+ * performing dark magick.\n+ */\n pure fn get_type_desc<T>() -> *type_desc {\n     unchecked { rusti::get_tydesc::<T>() as *type_desc }\n }\n \n-#[doc = \"Returns the size of a type\"]\n+/// Returns the size of a type\n #[inline(always)]\n pure fn size_of<T>() -> uint {\n     unchecked { rusti::size_of::<T>() }\n }\n \n-#[doc = \"\n-Returns the ABI-required minimum alignment of a type\n-\n-This is the alignment used for struct fields. It may be smaller\n-than the preferred alignment.\n-\"]\n+/**\n+ * Returns the ABI-required minimum alignment of a type\n+ *\n+ * This is the alignment used for struct fields. It may be smaller\n+ * than the preferred alignment.\n+ */\n pure fn min_align_of<T>() -> uint {\n     unchecked { rusti::min_align_of::<T>() }\n }\n \n-#[doc = \"Returns the preferred alignment of a type\"]\n+/// Returns the preferred alignment of a type\n pure fn pref_align_of<T>() -> uint {\n     unchecked { rusti::pref_align_of::<T>() }\n }\n \n-#[doc = \"Returns the refcount of a shared box (as just before calling this)\"]\n+/// Returns the refcount of a shared box (as just before calling this)\n pure fn refcount<T>(+t: @T) -> uint {\n     unsafe {\n         let ref_ptr: *uint = unsafe::reinterpret_cast(t);"}, {"sha": "7794798de1147c7abde8ef511104020b11442ea8", "filename": "src/libcore/task.rs", "status": "modified", "additions": 257, "deletions": 246, "changes": 503, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,26 +1,27 @@\n-#[doc = \"\n-Task management.\n-\n-An executing Rust program consists of a tree of tasks, each with their own\n-stack, and sole ownership of their allocated heap data. Tasks communicate\n-with each other using ports and channels.\n-\n-When a task fails, that failure will propagate to its parent (the task\n-that spawned it) and the parent will fail as well. The reverse is not\n-true: when a parent task fails its children will continue executing. When\n-the root (main) task fails, all tasks fail, and then so does the entire\n-process.\n-\n-Tasks may execute in parallel and are scheduled automatically by the runtime.\n-\n-# Example\n-\n-~~~\n-spawn {||\n-    log(error, \\\"Hello, World!\\\");\n-}\n-~~~\n-\"];\n+/*!\n+ * Task management.\n+ *\n+ * An executing Rust program consists of a tree of tasks, each with their own\n+ * stack, and sole ownership of their allocated heap data. Tasks communicate\n+ * with each other using ports and channels.\n+ *\n+ * When a task fails, that failure will propagate to its parent (the task\n+ * that spawned it) and the parent will fail as well. The reverse is not\n+ * true: when a parent task fails its children will continue executing. When\n+ * the root (main) task fails, all tasks fail, and then so does the entire\n+ * process.\n+ *\n+ * Tasks may execute in parallel and are scheduled automatically by the\n+ * runtime.\n+ *\n+ * # Example\n+ *\n+ * ~~~\n+ * spawn {||\n+ *     log(error, \"Hello, World!\");\n+ * }\n+ * ~~~\n+ */\n \n import result::result;\n import dvec::extensions;\n@@ -63,106 +64,106 @@ export local_data_modify;\n \n /* Data types */\n \n-#[doc = \"A handle to a task\"]\n+/// A handle to a task\n enum task = task_id;\n \n-#[doc = \"\n-Indicates the manner in which a task exited.\n-\n-A task that completes without failing and whose supervised children complete\n-without failing is considered to exit successfully.\n-\n-FIXME (See #1868): This description does not indicate the current behavior\n-for linked failure.\n-\"]\n+/**\n+ * Indicates the manner in which a task exited.\n+ *\n+ * A task that completes without failing and whose supervised children\n+ * complete without failing is considered to exit successfully.\n+ *\n+ * FIXME (See #1868): This description does not indicate the current behavior\n+ * for linked failure.\n+ */\n enum task_result {\n     success,\n     failure,\n }\n \n-#[doc = \"A message type for notifying of task lifecycle events\"]\n+/// A message type for notifying of task lifecycle events\n enum notification {\n-    #[doc = \"Sent when a task exits with the task handle and result\"]\n+    /// Sent when a task exits with the task handle and result\n     exit(task, task_result)\n }\n \n-#[doc = \"Scheduler modes\"]\n+/// Scheduler modes\n enum sched_mode {\n-    #[doc = \"1:N -- All tasks run in the same OS thread\"]\n+    /// All tasks run in the same OS thread\n     single_threaded,\n-    #[doc = \"M:N -- Tasks are distributed among available CPUs\"]\n+    /// Tasks are distributed among available CPUs\n     thread_per_core,\n-    #[doc = \"N:N -- Each task runs in its own OS thread\"]\n+    /// Each task runs in its own OS thread\n     thread_per_task,\n-    #[doc = \"?:N -- Tasks are distributed among a fixed number of OS threads\"]\n+    /// Tasks are distributed among a fixed number of OS threads\n     manual_threads(uint),\n-    #[doc = \"\n-    Tasks are scheduled on the main OS thread\n-\n-    The main OS thread is the thread used to launch the runtime which,\n-    in most cases, is the process's initial thread as created by the OS.\n-    \"]\n+    /**\n+     * Tasks are scheduled on the main OS thread\n+     *\n+     * The main OS thread is the thread used to launch the runtime which,\n+     * in most cases, is the process's initial thread as created by the OS.\n+     */\n     osmain\n }\n \n-#[doc = \"\n-Scheduler configuration options\n-\n-# Fields\n-\n-* sched_mode - The operating mode of the scheduler\n-\n-* foreign_stack_size - The size of the foreign stack, in bytes\n-\n-    Rust code runs on Rust-specific stacks. When Rust code calls foreign code\n-    (via functions in foreign modules) it switches to a typical, large stack\n-    appropriate for running code written in languages like C. By default these\n-    foreign stacks have unspecified size, but with this option their size can\n-    be precisely specified.\n-\"]\n+/**\n+ * Scheduler configuration options\n+ *\n+ * # Fields\n+ *\n+ * * sched_mode - The operating mode of the scheduler\n+ *\n+ * * foreign_stack_size - The size of the foreign stack, in bytes\n+ *\n+ *     Rust code runs on Rust-specific stacks. When Rust code calls foreign\n+ *     code (via functions in foreign modules) it switches to a typical, large\n+ *     stack appropriate for running code written in languages like C. By\n+ *     default these foreign stacks have unspecified size, but with this\n+ *     option their size can be precisely specified.\n+ */\n type sched_opts = {\n     mode: sched_mode,\n     foreign_stack_size: option<uint>\n };\n \n-#[doc = \"\n-Task configuration options\n-\n-# Fields\n-\n-* supervise - Do not propagate failure to the parent task\n-\n-    All tasks are linked together via a tree, from parents to children. By\n-    default children are 'supervised' by their parent and when they fail\n-    so too will their parents. Settings this flag to false disables that\n-    behavior.\n-\n-* notify_chan - Enable lifecycle notifications on the given channel\n-\n-* sched - Specify the configuration of a new scheduler to create the task in\n-\n-    By default, every task is created in the same scheduler as its\n-    parent, where it is scheduled cooperatively with all other tasks\n-    in that scheduler. Some specialized applications may want more\n-    control over their scheduling, in which case they can be spawned\n-    into a new scheduler with the specific properties required.\n-\n-    This is of particular importance for libraries which want to call\n-    into foreign code that blocks. Without doing so in a different\n-    scheduler other tasks will be impeded or even blocked indefinitely.\n-\n-\"]\n+/**\n+ * Task configuration options\n+ *\n+ * # Fields\n+ *\n+ * * supervise - Do not propagate failure to the parent task\n+ *\n+ *     All tasks are linked together via a tree, from parents to children. By\n+ *     default children are 'supervised' by their parent and when they fail\n+ *     so too will their parents. Settings this flag to false disables that\n+ *     behavior.\n+ *\n+ * * notify_chan - Enable lifecycle notifications on the given channel\n+ *\n+ * * sched - Specify the configuration of a new scheduler to create the task\n+ *           in\n+ *\n+ *     By default, every task is created in the same scheduler as its\n+ *     parent, where it is scheduled cooperatively with all other tasks\n+ *     in that scheduler. Some specialized applications may want more\n+ *     control over their scheduling, in which case they can be spawned\n+ *     into a new scheduler with the specific properties required.\n+ *\n+ *     This is of particular importance for libraries which want to call\n+ *     into foreign code that blocks. Without doing so in a different\n+ *     scheduler other tasks will be impeded or even blocked indefinitely.\n+ */\n type task_opts = {\n     supervise: bool,\n     notify_chan: option<comm::chan<notification>>,\n     sched: option<sched_opts>,\n };\n \n-#[doc = \"\n-The task builder type.\n-\n-Provides detailed control over the properties and behavior of new tasks.\n-\"]\n+/**\n+ * The task builder type.\n+ *\n+ * Provides detailed control over the properties and behavior of new tasks.\n+ */\n // NB: Builders are designed to be single-use because they do stateful\n // things that get weird when reusing - e.g. if you create a result future\n // it only applies to a single task, so then you have to maintain some\n@@ -182,12 +183,12 @@ enum builder {\n /* Task construction */\n \n fn default_task_opts() -> task_opts {\n-    #[doc = \"\n-    The default task options\n-\n-    By default all tasks are supervised by their parent, are spawned\n-    into the same scheduler, and do not post lifecycle notifications.\n-    \"];\n+    /*!\n+     * The default task options\n+     *\n+     * By default all tasks are supervised by their parent, are spawned\n+     * into the same scheduler, and do not post lifecycle notifications.\n+     */\n \n     {\n         supervise: true,\n@@ -197,7 +198,7 @@ fn default_task_opts() -> task_opts {\n }\n \n fn builder() -> builder {\n-    #[doc = \"Construct a builder\"];\n+    //! Construct a builder\n \n     let body_identity = fn@(+body: fn~()) -> fn~() { body };\n \n@@ -209,39 +210,39 @@ fn builder() -> builder {\n }\n \n fn get_opts(builder: builder) -> task_opts {\n-    #[doc = \"Get the task_opts associated with a builder\"];\n+    //! Get the task_opts associated with a builder\n \n     builder.opts\n }\n \n fn set_opts(builder: builder, opts: task_opts) {\n-    #[doc = \"\n-    Set the task_opts associated with a builder\n-\n-    To update a single option use a pattern like the following:\n-\n-        set_opts(builder, {\n-            supervise: false\n-            with get_opts(builder)\n-        });\n-    \"];\n+    /*!\n+     * Set the task_opts associated with a builder\n+     *\n+     * To update a single option use a pattern like the following:\n+     *\n+     *     set_opts(builder, {\n+     *         supervise: false\n+     *         with get_opts(builder)\n+     *     });\n+     */\n \n     builder.opts = opts;\n }\n \n fn add_wrapper(builder: builder, gen_body: fn@(+fn~()) -> fn~()) {\n-    #[doc = \"\n-    Add a wrapper to the body of the spawned task.\n-\n-    Before the task is spawned it is passed through a 'body generator'\n-    function that may perform local setup operations as well as wrap\n-    the task body in remote setup operations. With this the behavior\n-    of tasks can be extended in simple ways.\n-\n-    This function augments the current body generator with a new body\n-    generator by applying the task body which results from the\n-    existing body generator to the new body generator.\n-    \"];\n+    /*!\n+     * Add a wrapper to the body of the spawned task.\n+     *\n+     * Before the task is spawned it is passed through a 'body generator'\n+     * function that may perform local setup operations as well as wrap\n+     * the task body in remote setup operations. With this the behavior\n+     * of tasks can be extended in simple ways.\n+     *\n+     * This function augments the current body generator with a new body\n+     * generator by applying the task body which results from the\n+     * existing body generator to the new body generator.\n+     */\n \n     let prev_gen_body = builder.gen_body;\n     builder.gen_body = fn@(+body: fn~()) -> fn~() {\n@@ -250,18 +251,18 @@ fn add_wrapper(builder: builder, gen_body: fn@(+fn~()) -> fn~()) {\n }\n \n fn run(-builder: builder, +f: fn~()) {\n-    #[doc = \"\n-    Creates and exucutes a new child task\n-\n-    Sets up a new task with its own call stack and schedules it to run\n-    the provided unique closure. The task has the properties and behavior\n-    specified by `builder`.\n-\n-    # Failure\n-\n-    When spawning into a new scheduler, the number of threads requested\n-    must be greater than zero.\n-    \"];\n+    /*!\n+     * Creates and exucutes a new child task\n+     *\n+     * Sets up a new task with its own call stack and schedules it to run\n+     * the provided unique closure. The task has the properties and behavior\n+     * specified by `builder`.\n+     *\n+     * # Failure\n+     *\n+     * When spawning into a new scheduler, the number of threads requested\n+     * must be greater than zero.\n+     */\n \n     let body = builder.gen_body(f);\n     spawn_raw(builder.opts, body);\n@@ -271,17 +272,18 @@ fn run(-builder: builder, +f: fn~()) {\n /* Builder convenience functions */\n \n fn future_result(builder: builder) -> future::future<task_result> {\n-    #[doc = \"\n-    Get a future representing the exit status of the task.\n-\n-    Taking the value of the future will block until the child task terminates.\n-\n-    Note that the future returning by this function is only useful for\n-    obtaining the value of the next task to be spawning with the\n-    builder. If additional tasks are spawned with the same builder\n-    then a new result future must be obtained prior to spawning each\n-    task.\n-    \"];\n+    /*!\n+     * Get a future representing the exit status of the task.\n+     *\n+     * Taking the value of the future will block until the child task\n+     * terminates.\n+     *\n+     * Note that the future returning by this function is only useful for\n+     * obtaining the value of the next task to be spawning with the\n+     * builder. If additional tasks are spawned with the same builder\n+     * then a new result future must be obtained prior to spawning each\n+     * task.\n+     */\n \n     // FIXME (#1087, #1857): Once linked failure and notification are\n     // handled in the library, I can imagine implementing this by just\n@@ -304,7 +306,7 @@ fn future_result(builder: builder) -> future::future<task_result> {\n }\n \n fn future_task(builder: builder) -> future::future<task> {\n-    #[doc = \"Get a future representing the handle to the new task\"];\n+    //! Get a future representing the handle to the new task\n \n     let mut po = comm::port();\n     let ch = comm::chan(po);\n@@ -318,7 +320,7 @@ fn future_task(builder: builder) -> future::future<task> {\n }\n \n fn unsupervise(builder: builder) {\n-    #[doc = \"Configures the new task to not propagate failure to its parent\"];\n+    //! Configures the new task to not propagate failure to its parent\n \n     set_opts(builder, {\n         supervise: false\n@@ -328,17 +330,17 @@ fn unsupervise(builder: builder) {\n \n fn run_listener<A:send>(-builder: builder,\n                         +f: fn~(comm::port<A>)) -> comm::chan<A> {\n-    #[doc = \"\n-    Runs a new task while providing a channel from the parent to the child\n-\n-    Sets up a communication channel from the current task to the new\n-    child task, passes the port to child's body, and returns a channel\n-    linked to the port to the parent.\n-\n-    This encapsulates some boilerplate handshaking logic that would\n-    otherwise be required to establish communication from the parent\n-    to the child.\n-    \"];\n+    /*!\n+     * Runs a new task while providing a channel from the parent to the child\n+     *\n+     * Sets up a communication channel from the current task to the new\n+     * child task, passes the port to child's body, and returns a channel\n+     * linked to the port to the parent.\n+     *\n+     * This encapsulates some boilerplate handshaking logic that would\n+     * otherwise be required to establish communication from the parent\n+     * to the child.\n+     */\n \n     let setup_po = comm::port();\n     let setup_ch = comm::chan(setup_po);\n@@ -357,60 +359,60 @@ fn run_listener<A:send>(-builder: builder,\n /* Spawn convenience functions */\n \n fn spawn(+f: fn~()) {\n-    #[doc = \"\n-    Creates and executes a new child task\n-\n-    Sets up a new task with its own call stack and schedules it to run\n-    the provided unique closure.\n-\n-    This function is equivalent to `run(new_builder(), f)`.\n-    \"];\n+    /*!\n+     * Creates and executes a new child task\n+     *\n+     * Sets up a new task with its own call stack and schedules it to run\n+     * the provided unique closure.\n+     *\n+     * This function is equivalent to `run(new_builder(), f)`.\n+     */\n \n     run(builder(), f);\n }\n \n fn spawn_listener<A:send>(+f: fn~(comm::port<A>)) -> comm::chan<A> {\n-    #[doc = \"\n-    Runs a new task while providing a channel from the parent to the child\n-\n-    Sets up a communication channel from the current task to the new\n-    child task, passes the port to child's body, and returns a channel\n-    linked to the port to the parent.\n-\n-    This encapsulates some boilerplate handshaking logic that would\n-    otherwise be required to establish communication from the parent\n-    to the child.\n-\n-    The simplest way to establish bidirectional communication between\n-    a parent in child is as follows:\n-\n-        let po = comm::port();\n-        let ch = comm::chan(po);\n-        let ch = spawn_listener {|po|\n-            // Now the child has a port called 'po' to read from and\n-            // an environment-captured channel called 'ch'.\n-        };\n-        // Likewise, the parent has both a 'po' and 'ch'\n-\n-    This function is equivalent to `run_listener(builder(), f)`.\n-    \"];\n+    /*!\n+     * Runs a new task while providing a channel from the parent to the child\n+     *\n+     * Sets up a communication channel from the current task to the new\n+     * child task, passes the port to child's body, and returns a channel\n+     * linked to the port to the parent.\n+     *\n+     * This encapsulates some boilerplate handshaking logic that would\n+     * otherwise be required to establish communication from the parent\n+     * to the child.\n+     *\n+     * The simplest way to establish bidirectional communication between\n+     * a parent in child is as follows:\n+     *\n+     *     let po = comm::port();\n+     *     let ch = comm::chan(po);\n+     *     let ch = spawn_listener {|po|\n+     *         // Now the child has a port called 'po' to read from and\n+     *         // an environment-captured channel called 'ch'.\n+     *     };\n+     *     // Likewise, the parent has both a 'po' and 'ch'\n+     *\n+     * This function is equivalent to `run_listener(builder(), f)`.\n+     */\n \n     run_listener(builder(), f)\n }\n \n fn spawn_sched(mode: sched_mode, +f: fn~()) {\n-    #[doc = \"\n-    Creates a new scheduler and executes a task on it\n-\n-    Tasks subsequently spawned by that task will also execute on\n-    the new scheduler. When there are no more tasks to execute the\n-    scheduler terminates.\n-\n-    # Failure\n-\n-    In manual threads mode the number of threads requested must be\n-    greater than zero.\n-    \"];\n+    /*!\n+     * Creates a new scheduler and executes a task on it\n+     *\n+     * Tasks subsequently spawned by that task will also execute on\n+     * the new scheduler. When there are no more tasks to execute the\n+     * scheduler terminates.\n+     *\n+     * # Failure\n+     *\n+     * In manual threads mode the number of threads requested must be\n+     * greater than zero.\n+     */\n \n     let mut builder = builder();\n     set_opts(builder, {\n@@ -424,16 +426,16 @@ fn spawn_sched(mode: sched_mode, +f: fn~()) {\n }\n \n fn try<T:send>(+f: fn~() -> T) -> result<T,()> {\n-    #[doc = \"\n-    Execute a function in another task and return either the return value\n-    of the function or result::err.\n-\n-    # Return value\n-\n-    If the function executed successfully then try returns result::ok\n-    containing the value returned by the function. If the function fails\n-    then try returns result::err containing nil.\n-    \"];\n+    /*!\n+     * Execute a function in another task and return either the return value\n+     * of the function or result::err.\n+     *\n+     * # Return value\n+     *\n+     * If the function executed successfully then try returns result::ok\n+     * containing the value returned by the function. If the function fails\n+     * then try returns result::err containing nil.\n+     */\n \n     let po = comm::port();\n     let ch = comm::chan(po);\n@@ -453,7 +455,7 @@ fn try<T:send>(+f: fn~() -> T) -> result<T,()> {\n /* Lifecycle functions */\n \n fn yield() {\n-    #[doc = \"Yield control to the task scheduler\"];\n+    //! Yield control to the task scheduler\n \n     let task_ = rustrt::rust_get_task();\n     let mut killed = false;\n@@ -464,31 +466,30 @@ fn yield() {\n }\n \n fn failing() -> bool {\n-    #[doc = \"True if the running task has failed\"];\n+    //! True if the running task has failed\n \n     rustrt::rust_task_is_unwinding(rustrt::rust_get_task())\n }\n \n fn get_task() -> task {\n-    #[doc = \"Get a handle to the running task\"];\n+    //! Get a handle to the running task\n \n     task(rustrt::get_task_id())\n }\n \n-#[doc = \"\n-Temporarily make the task unkillable\n-\n-# Example\n-\n-    task::unkillable {||\n-        // detach / yield / destroy must all be called together\n-        rustrt::rust_port_detach(po);\n-        // This must not result in the current task being killed\n-        task::yield();\n-        rustrt::rust_port_destroy(po);\n-    }\n-\n-\"]\n+/**\n+ * Temporarily make the task unkillable\n+ *\n+ * # Example\n+ *\n+ *     task::unkillable {||\n+ *         // detach / yield / destroy must all be called together\n+ *         rustrt::rust_port_detach(po);\n+ *         // This must not result in the current task being killed\n+ *         task::yield();\n+ *         rustrt::rust_port_destroy(po);\n+ *     }\n+ */\n unsafe fn unkillable(f: fn()) {\n     class allow_failure {\n       let i: (); // since a class must have at least one field\n@@ -596,14 +597,16 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n  * Casting 'Arcane Sight' reveals an overwhelming aura of Transmutation magic.\n  ****************************************************************************/\n \n-#[doc = \"Indexes a task-local data slot. The function itself is used to\n-automatically finalise stored values; also, its code pointer is used for\n-comparison. Recommended use is to write an empty function for each desired\n-task-local data slot (and use class destructors, instead of code inside the\n-finaliser, if specific teardown is needed). DO NOT use multiple instantiations\n-of a single polymorphic function to index data of different types; arbitrary\n-type coercion is possible this way. The interface is safe as long as all key\n-functions are monomorphic.\"]\n+/**\n+ * Indexes a task-local data slot. The function itself is used to\n+ * automatically finalise stored values; also, its code pointer is used for\n+ * comparison. Recommended use is to write an empty function for each desired\n+ * task-local data slot (and use class destructors, instead of code inside the\n+ * finaliser, if specific teardown is needed). DO NOT use multiple\n+ * instantiations of a single polymorphic function to index data of different\n+ * types; arbitrary type coercion is possible this way. The interface is safe\n+ * as long as all key functions are monomorphic.\n+ */\n type local_data_key<T> = fn@(+@T);\n \n // We use dvec because it's the best data structure in core. If TLS is used\n@@ -741,23 +744,31 @@ unsafe fn local_modify<T>(task: *rust_task, key: local_data_key<T>,\n }\n \n /* Exported interface for task-local data (plus local_data_key above). */\n-#[doc = \"Remove a task-local data value from the table, returning the\n-reference that was originally created to insert it.\"]\n+/**\n+ * Remove a task-local data value from the table, returning the\n+ * reference that was originally created to insert it.\n+ */\n unsafe fn local_data_pop<T>(key: local_data_key<T>) -> option<@T> {\n     local_pop(rustrt::rust_get_task(), key)\n }\n-#[doc = \"Retrieve a task-local data value. It will also be kept alive in the\n-table until explicitly removed.\"]\n+/**\n+ * Retrieve a task-local data value. It will also be kept alive in the\n+ * table until explicitly removed.\n+ */\n unsafe fn local_data_get<T>(key: local_data_key<T>) -> option<@T> {\n     local_get(rustrt::rust_get_task(), key)\n }\n-#[doc = \"Store a value in task-local data. If this key already has a value,\n-that value is overwritten (and its destructor is run).\"]\n+/**\n+ * Store a value in task-local data. If this key already has a value,\n+ * that value is overwritten (and its destructor is run).\n+ */\n unsafe fn local_data_set<T>(key: local_data_key<T>, -data: @T) {\n     local_set(rustrt::rust_get_task(), key, data)\n }\n-#[doc = \"Modify a task-local data value. If the function returns 'none', the\n-data is removed (and its reference dropped).\"]\n+/**\n+ * Modify a task-local data value. If the function returns 'none', the\n+ * data is removed (and its reference dropped).\n+ */\n unsafe fn local_data_modify<T>(key: local_data_key<T>,\n                                modify_fn: fn(option<@T>) -> option<@T>) {\n     local_modify(rustrt::rust_get_task(), key, modify_fn)"}, {"sha": "d50ee4ac6872e9257023ef926e13a3bcb9376733", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,18 +1,18 @@\n-#[doc = \"Operations on tuples\"];\n+//! Operations on tuples\n \n-#[doc = \"Return the first element of a pair\"]\n+/// Return the first element of a pair\n pure fn first<T:copy, U:copy>(pair: (T, U)) -> T {\n     let (t, _) = pair;\n     ret t;\n }\n \n-#[doc = \"Return the second element of a pair\"]\n+/// Return the second element of a pair\n pure fn second<T:copy, U:copy>(pair: (T, U)) -> U {\n     let (_, u) = pair;\n     ret u;\n }\n \n-#[doc = \"Return the results of swapping the two elements of a pair\"]\n+/// Return the results of swapping the two elements of a pair\n pure fn swap<T:copy, U:copy>(pair: (T, U)) -> (U, T) {\n     let (t, u) = pair;\n     ret (u, t);"}, {"sha": "91b9eb856e4951c6dab88217e4620e5b2f51c9a3", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -38,7 +38,7 @@ pure fn is_nonpositive(x: T) -> bool { x <= 0 as T }\n pure fn is_nonnegative(x: T) -> bool { x >= 0 as T }\n \n #[inline(always)]\n-#[doc = \"Iterate over the range [`lo`..`hi`)\"]\n+/// Iterate over the range [`lo`..`hi`)\n fn range(lo: T, hi: T, it: fn(T) -> bool) {\n     let mut i = lo;\n     while i < hi {\n@@ -47,7 +47,7 @@ fn range(lo: T, hi: T, it: fn(T) -> bool) {\n     }\n }\n \n-#[doc = \"Computes the bitwise complement\"]\n+/// Computes the bitwise complement\n pure fn compl(i: T) -> T {\n     max_value ^ i\n }\n@@ -76,18 +76,18 @@ impl num of num::num for T {\n     fn from_int(n: int) -> T   { ret n as T;      }\n }\n \n-#[doc = \"\n-Parse a buffer of bytes\n-\n-# Arguments\n-\n-* buf - A byte buffer\n-* radix - The base of the number\n-\n-# Failure\n-\n-`buf` must not be empty\n-\"]\n+/**\n+ * Parse a buffer of bytes\n+ *\n+ * # Arguments\n+ *\n+ * * buf - A byte buffer\n+ * * radix - The base of the number\n+ *\n+ * # Failure\n+ *\n+ * `buf` must not be empty\n+ */\n fn parse_buf(buf: ~[u8], radix: uint) -> option<T> {\n     if vec::len(buf) == 0u { ret none; }\n     let mut i = vec::len(buf) - 1u;\n@@ -104,10 +104,10 @@ fn parse_buf(buf: ~[u8], radix: uint) -> option<T> {\n     };\n }\n \n-#[doc = \"Parse a string to an int\"]\n+/// Parse a string to an int\n fn from_str(s: str) -> option<T> { parse_buf(str::bytes(s), 10u) }\n \n-#[doc = \"Parse a string as an unsigned integer.\"]\n+/// Parse a string as an unsigned integer.\n fn from_str_radix(buf: str, radix: u64) -> option<u64> {\n     if str::len(buf) == 0u { ret none; }\n     let mut i = str::len(buf) - 1u;\n@@ -123,13 +123,13 @@ fn from_str_radix(buf: str, radix: u64) -> option<u64> {\n     };\n }\n \n-#[doc = \"\n-Convert to a string in a given base\n-\n-# Failure\n-\n-Fails if `radix` < 2 or `radix` > 16\n-\"]\n+/**\n+ * Convert to a string in a given base\n+ *\n+ * # Failure\n+ *\n+ * Fails if `radix` < 2 or `radix` > 16\n+ */\n fn to_str(num: T, radix: uint) -> str {\n     do to_str_bytes(false, num, radix) |slice| {\n         do vec::unpack_slice(slice) |p, len| {\n@@ -138,7 +138,7 @@ fn to_str(num: T, radix: uint) -> str {\n     }\n }\n \n-#[doc = \"Low-level helper routine for string conversion.\"]\n+/// Low-level helper routine for string conversion.\n fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n                    f: fn(v: &[u8]) -> U) -> U {\n \n@@ -203,7 +203,7 @@ fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n     }\n }\n \n-#[doc = \"Convert to a string\"]\n+/// Convert to a string\n fn str(i: T) -> str { ret to_str(i, 10u); }\n \n #[test]"}, {"sha": "19d0a3e9e45627553c7bcb80e370b74cfcd7c41f", "filename": "src/libcore/uint-template/uint.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fuint-template%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fuint-template%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template%2Fuint.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,76 +1,76 @@\n type T = uint;\n \n-#[doc = \"\n-Divide two numbers, return the result, rounded up.\n-\n-# Arguments\n-\n-* x - an integer\n-* y - an integer distinct from 0u\n-\n-# Return value\n-\n-The smallest integer `q` such that `x/y <= q`.\n-\"]\n+/**\n+ * Divide two numbers, return the result, rounded up.\n+ *\n+ * # Arguments\n+ *\n+ * * x - an integer\n+ * * y - an integer distinct from 0u\n+ *\n+ * # Return value\n+ *\n+ * The smallest integer `q` such that `x/y <= q`.\n+ */\n pure fn div_ceil(x: uint, y: uint) -> uint {\n     let div = div(x, y);\n     if x % y == 0u { ret div;}\n     else { ret div + 1u; }\n }\n \n-#[doc = \"\n-Divide two numbers, return the result, rounded to the closest integer.\n-\n-# Arguments\n-\n-* x - an integer\n-* y - an integer distinct from 0u\n-\n-# Return value\n-\n-The integer `q` closest to `x/y`.\n-\"]\n+/**\n+ * Divide two numbers, return the result, rounded to the closest integer.\n+ *\n+ * # Arguments\n+ *\n+ * * x - an integer\n+ * * y - an integer distinct from 0u\n+ *\n+ * # Return value\n+ *\n+ * The integer `q` closest to `x/y`.\n+ */\n pure fn div_round(x: uint, y: uint) -> uint {\n     let div = div(x, y);\n     if x % y * 2u  < y { ret div;}\n     else { ret div + 1u; }\n }\n \n-#[doc = \"\n-Divide two numbers, return the result, rounded down.\n-\n-Note: This is the same function as `div`.\n-\n-# Arguments\n-\n-* x - an integer\n-* y - an integer distinct from 0u\n-\n-# Return value\n-\n-The smallest integer `q` such that `x/y <= q`. This\n-is either `x/y` or `x/y + 1`.\n-\"]\n+/**\n+ * Divide two numbers, return the result, rounded down.\n+ *\n+ * Note: This is the same function as `div`.\n+ *\n+ * # Arguments\n+ *\n+ * * x - an integer\n+ * * y - an integer distinct from 0u\n+ *\n+ * # Return value\n+ *\n+ * The smallest integer `q` such that `x/y <= q`. This\n+ * is either `x/y` or `x/y + 1`.\n+ */\n pure fn div_floor(x: uint, y: uint) -> uint { ret x / y; }\n \n-#[doc = \"Produce a uint suitable for use in a hash table\"]\n+/// Produce a uint suitable for use in a hash table\n pure fn hash(&&x: uint) -> uint { ret x; }\n \n-#[doc = \"\n-Iterate over the range [`lo`..`hi`), or stop when requested\n-\n-# Arguments\n-\n-* lo - The integer at which to start the loop (included)\n-* hi - The integer at which to stop the loop (excluded)\n-* it - A block to execute with each consecutive integer of the range.\n-       Return `true` to continue, `false` to stop.\n-\n-# Return value\n-\n-`true` If execution proceeded correctly, `false` if it was interrupted,\n-that is if `it` returned `false` at any point.\n-\"]\n+/**\n+ * Iterate over the range [`lo`..`hi`), or stop when requested\n+ *\n+ * # Arguments\n+ *\n+ * * lo - The integer at which to start the loop (included)\n+ * * hi - The integer at which to stop the loop (excluded)\n+ * * it - A block to execute with each consecutive integer of the range.\n+ *        Return `true` to continue, `false` to stop.\n+ *\n+ * # Return value\n+ *\n+ * `true` If execution proceeded correctly, `false` if it was interrupted,\n+ * that is if `it` returned `false` at any point.\n+ */\n fn iterate(lo: uint, hi: uint, it: fn(uint) -> bool) -> bool {\n     let mut i = lo;\n     while i < hi {\n@@ -80,7 +80,7 @@ fn iterate(lo: uint, hi: uint, it: fn(uint) -> bool) -> bool {\n     ret true;\n }\n \n-#[doc = \"Returns the smallest power of 2 greater than or equal to `n`\"]\n+/// Returns the smallest power of 2 greater than or equal to `n`\n #[inline(always)]\n fn next_power_of_two(n: uint) -> uint {\n     let halfbits: uint = sys::size_of::<uint>() * 4u;"}, {"sha": "716a59f8ea91e1080b32a4694b0e0ab0db1d382e", "filename": "src/libcore/unicode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -2565,7 +2565,7 @@ mod general_category {\n \n }\n mod derived_property {\n-    #[doc = \"Check if a character has the alphabetic unicode property\"]\n+    /// Check if a character has the alphabetic unicode property\n     pure fn Alphabetic(c: char) -> bool {\n         ret alt c {\n               '\\x41' to '\\x5a'"}, {"sha": "ad7017444dd78bd28916755d2ef8a936d3fb3803", "filename": "src/libcore/unsafe.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Unsafe operations\"];\n+//! Unsafe operations\n \n export reinterpret_cast, forget, bump_box_refcount, transmute;\n \n@@ -8,39 +8,39 @@ extern mod rusti {\n     fn reinterpret_cast<T, U>(e: T) -> U;\n }\n \n-#[doc = \"\n-Casts the value at `src` to U. The two types must have the same length.\n-\"]\n+/// Casts the value at `src` to U. The two types must have the same length.\n #[inline(always)]\n unsafe fn reinterpret_cast<T, U>(src: T) -> U {\n     rusti::reinterpret_cast(src)\n }\n \n-#[doc =\"\n-Move a thing into the void\n-\n-The forget function will take ownership of the provided value but neglect\n-to run any required cleanup or memory-management operations on it. This\n-can be used for various acts of magick, particularly when using\n-reinterpret_cast on managed pointer types.\n-\"]\n+/**\n+ * Move a thing into the void\n+ *\n+ * The forget function will take ownership of the provided value but neglect\n+ * to run any required cleanup or memory-management operations on it. This\n+ * can be used for various acts of magick, particularly when using\n+ * reinterpret_cast on managed pointer types.\n+ */\n #[inline(always)]\n unsafe fn forget<T>(-thing: T) { rusti::forget(thing); }\n \n-#[doc = \"Force-increment the reference count on a shared box. If used\n-uncarefully, this can leak the box. Use this in conjunction with transmute\n-and/or reinterpret_cast when such calls would otherwise scramble a box's\n-reference count\"]\n+/**\n+ * Force-increment the reference count on a shared box. If used\n+ * uncarefully, this can leak the box. Use this in conjunction with transmute\n+ * and/or reinterpret_cast when such calls would otherwise scramble a box's\n+ * reference count\n+ */\n unsafe fn bump_box_refcount<T>(+t: @T) { forget(t); }\n \n-#[doc = \"\n-Transform a value of one type into a value of another type.\n-Both types must have the same size and alignment.\n-\n-# Example\n-\n-    assert transmute(\\\"L\\\") == [76u8, 0u8]/~;\n-\"]\n+/**\n+ * Transform a value of one type into a value of another type.\n+ * Both types must have the same size and alignment.\n+ *\n+ * # Example\n+ *\n+ *     assert transmute(\"L\") == [76u8, 0u8]/~;\n+ */\n unsafe fn transmute<L, G>(-thing: L) -> G {\n     let newthing = reinterpret_cast(thing);\n     forget(thing);"}, {"sha": "895377170bc0bb91d95e8529aeeed8fd0103fdba", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 440, "deletions": 458, "changes": 898, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Vectors\"];\n+//! Vectors\n \n import option::{some, none};\n import ptr::addr_of;\n@@ -99,35 +99,35 @@ extern mod rusti {\n     fn move_val_init<T>(&dst: T, -src: T);\n }\n \n-#[doc = \"A function used to initialize the elements of a vector\"]\n+/// A function used to initialize the elements of a vector\n type init_op<T> = fn(uint) -> T;\n \n-#[doc = \"Returns true if a vector contains no elements\"]\n+/// Returns true if a vector contains no elements\n pure fn is_empty<T>(v: &[const T]) -> bool {\n     unpack_const_slice(v, |_p, len| len == 0u)\n }\n \n-#[doc = \"Returns true if a vector contains some elements\"]\n+/// Returns true if a vector contains some elements\n pure fn is_not_empty<T>(v: &[const T]) -> bool {\n     unpack_const_slice(v, |_p, len| len > 0u)\n }\n \n-#[doc = \"Returns true if two vectors have the same length\"]\n+/// Returns true if two vectors have the same length\n pure fn same_length<T, U>(xs: &[const T], ys: &[const U]) -> bool {\n     len(xs) == len(ys)\n }\n \n-#[doc = \"\n-Reserves capacity for exactly `n` elements in the given vector.\n-\n-If the capacity for `v` is already equal to or greater than the requested\n-capacity, then no action is taken.\n-\n-# Arguments\n-\n-* v - A vector\n-* n - The number of elements to reserve space for\n-\"]\n+/**\n+ * Reserves capacity for exactly `n` elements in the given vector.\n+ *\n+ * If the capacity for `v` is already equal to or greater than the requested\n+ * capacity, then no action is taken.\n+ *\n+ * # Arguments\n+ *\n+ * * v - A vector\n+ * * n - The number of elements to reserve space for\n+ */\n fn reserve<T>(&v: ~[const T], n: uint) {\n     // Only make the (slow) call into the runtime if we have to\n     if capacity(v) < n {\n@@ -137,28 +137,26 @@ fn reserve<T>(&v: ~[const T], n: uint) {\n     }\n }\n \n-#[doc = \"\n-Reserves capacity for at least `n` elements in the given vector.\n-\n-This function will over-allocate in order to amortize the allocation costs\n-in scenarios where the caller may need to repeatedly reserve additional\n-space.\n-\n-If the capacity for `v` is already equal to or greater than the requested\n-capacity, then no action is taken.\n-\n-# Arguments\n-\n-* v - A vector\n-* n - The number of elements to reserve space for\n-\"]\n+/**\n+ * Reserves capacity for at least `n` elements in the given vector.\n+ *\n+ * This function will over-allocate in order to amortize the allocation costs\n+ * in scenarios where the caller may need to repeatedly reserve additional\n+ * space.\n+ *\n+ * If the capacity for `v` is already equal to or greater than the requested\n+ * capacity, then no action is taken.\n+ *\n+ * # Arguments\n+ *\n+ * * v - A vector\n+ * * n - The number of elements to reserve space for\n+ */\n fn reserve_at_least<T>(&v: ~[const T], n: uint) {\n     reserve(v, uint::next_power_of_two(n));\n }\n \n-#[doc = \"\n-Returns the number of elements the vector can hold without reallocating\n-\"]\n+/// Returns the number of elements the vector can hold without reallocating\n #[inline(always)]\n pure fn capacity<T>(&&v: ~[const T]) -> uint {\n     unsafe {\n@@ -167,18 +165,18 @@ pure fn capacity<T>(&&v: ~[const T]) -> uint {\n     }\n }\n \n-#[doc = \"Returns the length of a vector\"]\n+/// Returns the length of a vector\n #[inline(always)]\n pure fn len<T>(&&v: &[const T]) -> uint {\n     unpack_const_slice(v, |_p, len| len)\n }\n \n-#[doc = \"\n-Creates and initializes an immutable vector.\n-\n-Creates an immutable vector of size `n_elts` and initializes the elements\n-to the value returned by the function `op`.\n-\"]\n+/**\n+ * Creates and initializes an immutable vector.\n+ *\n+ * Creates an immutable vector of size `n_elts` and initializes the elements\n+ * to the value returned by the function `op`.\n+ */\n pure fn from_fn<T>(n_elts: uint, op: init_op<T>) -> ~[T] {\n     let mut v = ~[];\n     unchecked{reserve(v, n_elts);}\n@@ -187,12 +185,12 @@ pure fn from_fn<T>(n_elts: uint, op: init_op<T>) -> ~[T] {\n     ret v;\n }\n \n-#[doc = \"\n-Creates and initializes an immutable vector.\n-\n-Creates an immutable vector of size `n_elts` and initializes the elements\n-to the value `t`.\n-\"]\n+/**\n+ * Creates and initializes an immutable vector.\n+ *\n+ * Creates an immutable vector of size `n_elts` and initializes the elements\n+ * to the value `t`.\n+ */\n pure fn from_elem<T: copy>(n_elts: uint, t: T) -> ~[T] {\n     let mut v = ~[];\n     unchecked{reserve(v, n_elts)}\n@@ -203,56 +201,56 @@ pure fn from_elem<T: copy>(n_elts: uint, t: T) -> ~[T] {\n     ret v;\n }\n \n-#[doc = \"Produces a mut vector from an immutable vector.\"]\n+/// Produces a mut vector from an immutable vector.\n fn to_mut<T>(+v: ~[T]) -> ~[mut T] {\n     unsafe { ::unsafe::transmute(v) }\n }\n \n-#[doc = \"Produces an immutable vector from a mut vector.\"]\n+/// Produces an immutable vector from a mut vector.\n fn from_mut<T>(+v: ~[mut T]) -> ~[T] {\n     unsafe { ::unsafe::transmute(v) }\n }\n \n // Accessors\n \n-#[doc = \"Returns the first element of a vector\"]\n+/// Returns the first element of a vector\n pure fn head<T: copy>(v: &[const T]) -> T { v[0] }\n \n-#[doc = \"Returns a vector containing all but the first element of a slice\"]\n+/// Returns a vector containing all but the first element of a slice\n pure fn tail<T: copy>(v: &[const T]) -> ~[T] {\n     ret slice(v, 1u, len(v));\n }\n \n-#[doc = \"Returns a vector containing all but the first `n` \\\n-         elements of a slice\"]\n+/**\n+ * Returns a vector containing all but the first `n` \\\n+ * elements of a slice\n+ */\n pure fn tailn<T: copy>(v: &[const T], n: uint) -> ~[T] {\n     slice(v, n, len(v))\n }\n \n-#[doc = \"Returns a vector containing all but the last element of a slice\"]\n+/// Returns a vector containing all but the last element of a slice\n pure fn init<T: copy>(v: &[const T]) -> ~[T] {\n     assert len(v) != 0u;\n     slice(v, 0u, len(v) - 1u)\n }\n \n-#[doc = \"\n-Returns the last element of the slice `v`, failing if the slice is empty.\n-\"]\n+/// Returns the last element of the slice `v`, failing if the slice is empty.\n pure fn last<T: copy>(v: &[const T]) -> T {\n     if len(v) == 0u { fail \"last_unsafe: empty vector\" }\n     v[len(v) - 1u]\n }\n \n-#[doc = \"\n-Returns `some(x)` where `x` is the last element of the slice `v`,\n-or `none` if the vector is empty.\n-\"]\n+/**\n+ * Returns `some(x)` where `x` is the last element of the slice `v`,\n+ * or `none` if the vector is empty.\n+ */\n pure fn last_opt<T: copy>(v: &[const T]) -> option<T> {\n     if len(v) == 0u { ret none; }\n     some(v[len(v) - 1u])\n }\n \n-#[doc = \"Returns a copy of the elements from [`start`..`end`) from `v`.\"]\n+/// Returns a copy of the elements from [`start`..`end`) from `v`.\n pure fn slice<T: copy>(v: &[const T], start: uint, end: uint) -> ~[T] {\n     assert (start <= end);\n     assert (end <= len(v));\n@@ -263,7 +261,7 @@ pure fn slice<T: copy>(v: &[const T], start: uint, end: uint) -> ~[T] {\n     ret result;\n }\n \n-#[doc = \"Return a slice that points into another slice.\"]\n+/// Return a slice that points into another slice.\n pure fn view<T: copy>(v: &[const T], start: uint, end: uint) -> &a.[T] {\n     assert (start <= end);\n     assert (end <= len(v));\n@@ -275,9 +273,7 @@ pure fn view<T: copy>(v: &[const T], start: uint, end: uint) -> &a.[T] {\n     }\n }\n \n-#[doc = \"\n-Split the vector `v` by applying each element against the predicate `f`.\n-\"]\n+/// Split the vector `v` by applying each element against the predicate `f`.\n fn split<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret ~[] }\n@@ -297,10 +293,10 @@ fn split<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n     result\n }\n \n-#[doc = \"\n-Split the vector `v` by applying each element against the predicate `f` up\n-to `n` times.\n-\"]\n+/**\n+ * Split the vector `v` by applying each element against the predicate `f` up\n+ * to `n` times.\n+ */\n fn splitn<T: copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret ~[] }\n@@ -323,10 +319,10 @@ fn splitn<T: copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n     result\n }\n \n-#[doc = \"\n-Reverse split the vector `v` by applying each element against the predicate\n-`f`.\n-\"]\n+/**\n+ * Reverse split the vector `v` by applying each element against the predicate\n+ * `f`.\n+ */\n fn rsplit<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret ~[] }\n@@ -346,10 +342,10 @@ fn rsplit<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[~[T]] {\n     reversed(result)\n }\n \n-#[doc = \"\n-Reverse split the vector `v` by applying each element against the predicate\n-`f` up to `n times.\n-\"]\n+/**\n+ * Reverse split the vector `v` by applying each element against the predicate\n+ * `f` up to `n times.\n+ */\n fn rsplitn<T: copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret ~[] }\n@@ -374,7 +370,7 @@ fn rsplitn<T: copy>(v: &[T], n: uint, f: fn(T) -> bool) -> ~[~[T]] {\n \n // Mutators\n \n-#[doc = \"Removes the first element from a vector and return it\"]\n+/// Removes the first element from a vector and return it\n fn shift<T>(&v: ~[T]) -> T {\n     let ln = len::<T>(v);\n     assert (ln > 0u);\n@@ -399,7 +395,7 @@ fn shift<T>(&v: ~[T]) -> T {\n     }\n }\n \n-#[doc = \"Prepend an element to the vector\"]\n+/// Prepend an element to the vector\n fn unshift<T>(&v: ~[T], +x: T) {\n     let mut vv = ~[x];\n     v <-> vv;\n@@ -408,7 +404,7 @@ fn unshift<T>(&v: ~[T], +x: T) {\n     }\n }\n \n-#[doc = \"Remove the last element from a vector and return it\"]\n+/// Remove the last element from a vector and return it\n fn pop<T>(&v: ~[const T]) -> T {\n     let ln = len(v);\n     assert ln > 0u;\n@@ -420,7 +416,7 @@ fn pop<T>(&v: ~[const T]) -> T {\n     }\n }\n \n-#[doc = \"Append an element to a vector\"]\n+/// Append an element to a vector\n #[inline(always)]\n fn push<T>(&v: ~[const T], +initval: T) {\n     unsafe {\n@@ -519,49 +515,49 @@ pure fn append_mut<T: copy>(lhs: &[mut T], rhs: &[const T]) -> ~[mut T] {\n     ret v;\n }\n \n-#[doc = \"\n-Expands a vector in place, initializing the new elements to a given value\n-\n-# Arguments\n-\n-* v - The vector to grow\n-* n - The number of elements to add\n-* initval - The value for the new elements\n-\"]\n+/**\n+ * Expands a vector in place, initializing the new elements to a given value\n+ *\n+ * # Arguments\n+ *\n+ * * v - The vector to grow\n+ * * n - The number of elements to add\n+ * * initval - The value for the new elements\n+ */\n fn grow<T: copy>(&v: ~[const T], n: uint, initval: T) {\n     reserve_at_least(v, len(v) + n);\n     let mut i: uint = 0u;\n \n     while i < n { push(v, initval); i += 1u; }\n }\n \n-#[doc = \"\n-Expands a vector in place, initializing the new elements to the result of\n-a function\n-\n-Function `init_op` is called `n` times with the values [0..`n`)\n-\n-# Arguments\n-\n-* v - The vector to grow\n-* n - The number of elements to add\n-* init_op - A function to call to retreive each appended element's\n-            value\n-\"]\n+/**\n+ * Expands a vector in place, initializing the new elements to the result of\n+ * a function\n+ *\n+ * Function `init_op` is called `n` times with the values [0..`n`)\n+ *\n+ * # Arguments\n+ *\n+ * * v - The vector to grow\n+ * * n - The number of elements to add\n+ * * init_op - A function to call to retreive each appended element's\n+ *             value\n+ */\n fn grow_fn<T>(&v: ~[const T], n: uint, op: init_op<T>) {\n     reserve_at_least(v, len(v) + n);\n     let mut i: uint = 0u;\n     while i < n { push(v, op(i)); i += 1u; }\n }\n \n-#[doc = \"\n-Sets the value of a vector element at a given index, growing the vector as\n-needed\n-\n-Sets the element at position `index` to `val`. If `index` is past the end\n-of the vector, expands the vector by replicating `initval` to fill the\n-intervening space.\n-\"]\n+/**\n+ * Sets the value of a vector element at a given index, growing the vector as\n+ * needed\n+ *\n+ * Sets the element at position `index` to `val`. If `index` is past the end\n+ * of the vector, expands the vector by replicating `initval` to fill the\n+ * intervening space.\n+ */\n #[inline(always)]\n fn grow_set<T: copy>(&v: ~[mut T], index: uint, initval: T, val: T) {\n     if index >= len(v) { grow(v, index - len(v) + 1u, initval); }\n@@ -571,39 +567,33 @@ fn grow_set<T: copy>(&v: ~[mut T], index: uint, initval: T, val: T) {\n \n // Functional utilities\n \n-#[doc = \"\n-Apply a function to each element of a vector and return the results\n-\"]\n+/// Apply a function to each element of a vector and return the results\n pure fn map<T, U>(v: &[T], f: fn(T) -> U) -> ~[U] {\n     let mut result = ~[];\n     unchecked{reserve(result, len(v));}\n     for each(v) |elem| { unsafe { push(result, f(elem)); } }\n     ret result;\n }\n \n-#[doc = \"\n-Apply a function to each element of a vector and return the results\n-\"]\n+/// Apply a function to each element of a vector and return the results\n pure fn mapi<T, U>(v: &[T], f: fn(uint, T) -> U) -> ~[U] {\n     let mut result = ~[];\n     unchecked{reserve(result, len(v));}\n     for eachi(v) |i, elem| { unsafe { push(result, f(i, elem)); } }\n     ret result;\n }\n \n-#[doc = \"\n-Apply a function to each element of a vector and return a concatenation\n-of each result vector\n-\"]\n+/**\n+ * Apply a function to each element of a vector and return a concatenation\n+ * of each result vector\n+ */\n pure fn flat_map<T, U>(v: &[T], f: fn(T) -> ~[U]) -> ~[U] {\n     let mut result = ~[];\n     for each(v) |elem| { unchecked{ push_all_move(result, f(elem)); } }\n     ret result;\n }\n \n-#[doc = \"\n-Apply a function to each pair of elements and return the results\n-\"]\n+/// Apply a function to each pair of elements and return the results\n pure fn map2<T: copy, U: copy, V>(v0: &[T], v1: &[U],\n                                   f: fn(T, U) -> V) -> ~[V] {\n     let v0_len = len(v0);\n@@ -617,12 +607,12 @@ pure fn map2<T: copy, U: copy, V>(v0: &[T], v1: &[U],\n     ret u;\n }\n \n-#[doc = \"\n-Apply a function to each element of a vector and return the results\n-\n-If function `f` returns `none` then that element is excluded from\n-the resulting vector.\n-\"]\n+/**\n+ * Apply a function to each element of a vector and return the results\n+ *\n+ * If function `f` returns `none` then that element is excluded from\n+ * the resulting vector.\n+ */\n pure fn filter_map<T, U: copy>(v: &[T], f: fn(T) -> option<U>)\n     -> ~[U] {\n     let mut result = ~[];\n@@ -635,13 +625,13 @@ pure fn filter_map<T, U: copy>(v: &[T], f: fn(T) -> option<U>)\n     ret result;\n }\n \n-#[doc = \"\n-Construct a new vector from the elements of a vector for which some predicate\n-holds.\n-\n-Apply function `f` to each element of `v` and return a vector containing\n-only those elements for which `f` returned true.\n-\"]\n+/**\n+ * Construct a new vector from the elements of a vector for which some\n+ * predicate holds.\n+ *\n+ * Apply function `f` to each element of `v` and return a vector containing\n+ * only those elements for which `f` returned true.\n+ */\n pure fn filter<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[T] {\n     let mut result = ~[];\n     for each(v) |elem| {\n@@ -650,20 +640,18 @@ pure fn filter<T: copy>(v: &[T], f: fn(T) -> bool) -> ~[T] {\n     ret result;\n }\n \n-#[doc = \"\n-Concatenate a vector of vectors.\n-\n-Flattens a vector of vectors of T into a single vector of T.\n-\"]\n+/**\n+ * Concatenate a vector of vectors.\n+ *\n+ * Flattens a vector of vectors of T into a single vector of T.\n+ */\n pure fn concat<T: copy>(v: &[[T]/~]) -> ~[T] {\n     let mut r = ~[];\n     for each(v) |inner| { unsafe { push_all(r, inner); } }\n     ret r;\n }\n \n-#[doc = \"\n-Concatenate a vector of vectors, placing a given separator between each\n-\"]\n+/// Concatenate a vector of vectors, placing a given separator between each\n pure fn connect<T: copy>(v: &[[T]/~], sep: T) -> ~[T] {\n     let mut r: ~[T] = ~[];\n     let mut first = true;\n@@ -674,7 +662,7 @@ pure fn connect<T: copy>(v: &[[T]/~], sep: T) -> ~[T] {\n     ret r;\n }\n \n-#[doc = \"Reduce a vector from left to right\"]\n+/// Reduce a vector from left to right\n pure fn foldl<T: copy, U>(z: T, v: &[U], p: fn(T, U) -> T) -> T {\n     let mut accum = z;\n     do iter(v) |elt| {\n@@ -683,7 +671,7 @@ pure fn foldl<T: copy, U>(z: T, v: &[U], p: fn(T, U) -> T) -> T {\n     ret accum;\n }\n \n-#[doc = \"Reduce a vector from right to left\"]\n+/// Reduce a vector from right to left\n pure fn foldr<T, U: copy>(v: &[T], z: U, p: fn(T, U) -> U) -> U {\n     let mut accum = z;\n     do riter(v) |elt| {\n@@ -692,21 +680,21 @@ pure fn foldr<T, U: copy>(v: &[T], z: U, p: fn(T, U) -> U) -> U {\n     ret accum;\n }\n \n-#[doc = \"\n-Return true if a predicate matches any elements\n-\n-If the vector contains no elements then false is returned.\n-\"]\n+/**\n+ * Return true if a predicate matches any elements\n+ *\n+ * If the vector contains no elements then false is returned.\n+ */\n pure fn any<T>(v: &[T], f: fn(T) -> bool) -> bool {\n     for each(v) |elem| { if f(elem) { ret true; } }\n     ret false;\n }\n \n-#[doc = \"\n-Return true if a predicate matches any elements in both vectors.\n-\n-If the vectors contains no elements then false is returned.\n-\"]\n+/**\n+ * Return true if a predicate matches any elements in both vectors.\n+ *\n+ * If the vectors contains no elements then false is returned.\n+ */\n pure fn any2<T, U>(v0: &[T], v1: &[U],\n                    f: fn(T, U) -> bool) -> bool {\n     let v0_len = len(v0);\n@@ -719,31 +707,31 @@ pure fn any2<T, U>(v0: &[T], v1: &[U],\n     ret false;\n }\n \n-#[doc = \"\n-Return true if a predicate matches all elements\n-\n-If the vector contains no elements then true is returned.\n-\"]\n+/**\n+ * Return true if a predicate matches all elements\n+ *\n+ * If the vector contains no elements then true is returned.\n+ */\n pure fn all<T>(v: &[T], f: fn(T) -> bool) -> bool {\n     for each(v) |elem| { if !f(elem) { ret false; } }\n     ret true;\n }\n \n-#[doc = \"\n-Return true if a predicate matches all elements\n-\n-If the vector contains no elements then true is returned.\n-\"]\n+/**\n+ * Return true if a predicate matches all elements\n+ *\n+ * If the vector contains no elements then true is returned.\n+ */\n pure fn alli<T>(v: &[T], f: fn(uint, T) -> bool) -> bool {\n     for eachi(v) |i, elem| { if !f(i, elem) { ret false; } }\n     ret true;\n }\n \n-#[doc = \"\n-Return true if a predicate matches all elements in both vectors.\n-\n-If the vectors are not the same size then false is returned.\n-\"]\n+/**\n+ * Return true if a predicate matches all elements in both vectors.\n+ *\n+ * If the vectors are not the same size then false is returned.\n+ */\n pure fn all2<T, U>(v0: &[T], v1: &[U],\n                    f: fn(T, U) -> bool) -> bool {\n     let v0_len = len(v0);\n@@ -753,88 +741,88 @@ pure fn all2<T, U>(v0: &[T], v1: &[U],\n     ret true;\n }\n \n-#[doc = \"Return true if a vector contains an element with the given value\"]\n+/// Return true if a vector contains an element with the given value\n pure fn contains<T>(v: &[T], x: T) -> bool {\n     for each(v) |elt| { if x == elt { ret true; } }\n     ret false;\n }\n \n-#[doc = \"Returns the number of elements that are equal to a given value\"]\n+/// Returns the number of elements that are equal to a given value\n pure fn count<T>(v: &[T], x: T) -> uint {\n     let mut cnt = 0u;\n     for each(v) |elt| { if x == elt { cnt += 1u; } }\n     ret cnt;\n }\n \n-#[doc = \"\n-Search for the first element that matches a given predicate\n-\n-Apply function `f` to each element of `v`, starting from the first.\n-When function `f` returns true then an option containing the element\n-is returned. If `f` matches no elements then none is returned.\n-\"]\n+/**\n+ * Search for the first element that matches a given predicate\n+ *\n+ * Apply function `f` to each element of `v`, starting from the first.\n+ * When function `f` returns true then an option containing the element\n+ * is returned. If `f` matches no elements then none is returned.\n+ */\n pure fn find<T: copy>(v: &[T], f: fn(T) -> bool) -> option<T> {\n     find_between(v, 0u, len(v), f)\n }\n \n-#[doc = \"\n-Search for the first element that matches a given predicate within a range\n-\n-Apply function `f` to each element of `v` within the range [`start`, `end`).\n-When function `f` returns true then an option containing the element\n-is returned. If `f` matches no elements then none is returned.\n-\"]\n+/**\n+ * Search for the first element that matches a given predicate within a range\n+ *\n+ * Apply function `f` to each element of `v` within the range\n+ * [`start`, `end`). When function `f` returns true then an option containing\n+ * the element is returned. If `f` matches no elements then none is returned.\n+ */\n pure fn find_between<T: copy>(v: &[T], start: uint, end: uint,\n                       f: fn(T) -> bool) -> option<T> {\n     option::map(position_between(v, start, end, f), |i| v[i])\n }\n \n-#[doc = \"\n-Search for the last element that matches a given predicate\n-\n-Apply function `f` to each element of `v` in reverse order. When function `f`\n-returns true then an option containing the element is returned. If `f`\n-matches no elements then none is returned.\n-\"]\n+/**\n+ * Search for the last element that matches a given predicate\n+ *\n+ * Apply function `f` to each element of `v` in reverse order. When function\n+ * `f` returns true then an option containing the element is returned. If `f`\n+ * matches no elements then none is returned.\n+ */\n pure fn rfind<T: copy>(v: &[T], f: fn(T) -> bool) -> option<T> {\n     rfind_between(v, 0u, len(v), f)\n }\n \n-#[doc = \"\n-Search for the last element that matches a given predicate within a range\n-\n-Apply function `f` to each element of `v` in reverse order within the range\n-[`start`, `end`). When function `f` returns true then an option containing\n-the element is returned. If `f` matches no elements then none is returned.\n-\"]\n+/**\n+ * Search for the last element that matches a given predicate within a range\n+ *\n+ * Apply function `f` to each element of `v` in reverse order within the range\n+ * [`start`, `end`). When function `f` returns true then an option containing\n+ * the element is returned. If `f` matches no elements then none is returned.\n+ */\n pure fn rfind_between<T: copy>(v: &[T], start: uint, end: uint,\n                                f: fn(T) -> bool) -> option<T> {\n     option::map(rposition_between(v, start, end, f), |i| v[i])\n }\n \n-#[doc = \"Find the first index containing a matching value\"]\n+/// Find the first index containing a matching value\n pure fn position_elem<T>(v: &[T], x: T) -> option<uint> {\n     position(v, |y| x == y)\n }\n \n-#[doc = \"\n-Find the first index matching some predicate\n-\n-Apply function `f` to each element of `v`.  When function `f` returns true\n-then an option containing the index is returned. If `f` matches no elements\n-then none is returned.\n-\"]\n+/**\n+ * Find the first index matching some predicate\n+ *\n+ * Apply function `f` to each element of `v`.  When function `f` returns true\n+ * then an option containing the index is returned. If `f` matches no elements\n+ * then none is returned.\n+ */\n pure fn position<T>(v: &[T], f: fn(T) -> bool) -> option<uint> {\n     position_between(v, 0u, len(v), f)\n }\n \n-#[doc = \"\n-Find the first index matching some predicate within a range\n-\n-Apply function `f` to each element of `v` between the range [`start`, `end`).\n-When function `f` returns true then an option containing the index is\n-returned. If `f` matches no elements then none is returned.\n-\"]\n+/**\n+ * Find the first index matching some predicate within a range\n+ *\n+ * Apply function `f` to each element of `v` between the range\n+ * [`start`, `end`). When function `f` returns true then an option containing\n+ * the index is returned. If `f` matches no elements then none is returned.\n+ */\n pure fn position_between<T>(v: &[T], start: uint, end: uint,\n                             f: fn(T) -> bool) -> option<uint> {\n     assert start <= end;\n@@ -844,29 +832,30 @@ pure fn position_between<T>(v: &[T], start: uint, end: uint,\n     ret none;\n }\n \n-#[doc = \"Find the last index containing a matching value\"]\n+/// Find the last index containing a matching value\n pure fn rposition_elem<T>(v: &[T], x: T) -> option<uint> {\n     rposition(v, |y| x == y)\n }\n \n-#[doc = \"\n-Find the last index matching some predicate\n-\n-Apply function `f` to each element of `v` in reverse order.  When function\n-`f` returns true then an option containing the index is returned. If `f`\n-matches no elements then none is returned.\n-\"]\n+/**\n+ * Find the last index matching some predicate\n+ *\n+ * Apply function `f` to each element of `v` in reverse order.  When function\n+ * `f` returns true then an option containing the index is returned. If `f`\n+ * matches no elements then none is returned.\n+ */\n pure fn rposition<T>(v: &[T], f: fn(T) -> bool) -> option<uint> {\n     rposition_between(v, 0u, len(v), f)\n }\n \n-#[doc = \"\n-Find the last index matching some predicate within a range\n-\n-Apply function `f` to each element of `v` in reverse order between the range\n-[`start`, `end`). When function `f` returns true then an option containing\n-the index is returned. If `f` matches no elements then none is returned.\n-\"]\n+/**\n+ * Find the last index matching some predicate within a range\n+ *\n+ * Apply function `f` to each element of `v` in reverse order between the\n+ * range [`start`, `end`). When function `f` returns true then an option\n+ * containing the index is returned. If `f` matches no elements then none is\n+ * returned.\n+ */\n pure fn rposition_between<T>(v: &[T], start: uint, end: uint,\n                              f: fn(T) -> bool) -> option<uint> {\n     assert start <= end;\n@@ -883,14 +872,14 @@ pure fn rposition_between<T>(v: &[T], start: uint, end: uint,\n // saying the two result lists have the same length -- or, could\n // return a nominal record with a constraint saying that, instead of\n // returning a tuple (contingent on issue #869)\n-#[doc = \"\n-Convert a vector of pairs into a pair of vectors\n-\n-Returns a tuple containing two vectors where the i-th element of the first\n-vector contains the first element of the i-th tuple of the input vector,\n-and the i-th element of the second vector contains the second element\n-of the i-th tuple of the input vector.\n-\"]\n+/**\n+ * Convert a vector of pairs into a pair of vectors\n+ *\n+ * Returns a tuple containing two vectors where the i-th element of the first\n+ * vector contains the first element of the i-th tuple of the input vector,\n+ * and the i-th element of the second vector contains the second element\n+ * of the i-th tuple of the input vector.\n+ */\n pure fn unzip<T: copy, U: copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n     let mut as = ~[], bs = ~[];\n     for each(v) |p| {\n@@ -903,12 +892,12 @@ pure fn unzip<T: copy, U: copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n     ret (as, bs);\n }\n \n-#[doc = \"\n-Convert two vectors to a vector of pairs\n-\n-Returns a vector of tuples, where the i-th tuple contains contains the\n-i-th elements from each of the input vectors.\n-\"]\n+/**\n+ * Convert two vectors to a vector of pairs\n+ *\n+ * Returns a vector of tuples, where the i-th tuple contains contains the\n+ * i-th elements from each of the input vectors.\n+ */\n pure fn zip<T: copy, U: copy>(v: &[const T], u: &[const U]) -> ~[(T, U)] {\n     let mut zipped = ~[];\n     let sz = len(v);\n@@ -918,28 +907,28 @@ pure fn zip<T: copy, U: copy>(v: &[const T], u: &[const U]) -> ~[(T, U)] {\n     ret zipped;\n }\n \n-#[doc = \"\n-Swaps two elements in a vector\n-\n-# Arguments\n-\n-* v  The input vector\n-* a - The index of the first element\n-* b - The index of the second element\n-\"]\n+/**\n+ * Swaps two elements in a vector\n+ *\n+ * # Arguments\n+ *\n+ * * v  The input vector\n+ * * a - The index of the first element\n+ * * b - The index of the second element\n+ */\n fn swap<T>(&&v: ~[mut T], a: uint, b: uint) {\n     v[a] <-> v[b];\n }\n \n-#[doc = \"Reverse the order of elements in a vector, in place\"]\n+/// Reverse the order of elements in a vector, in place\n fn reverse<T>(v: ~[mut T]) {\n     let mut i: uint = 0u;\n     let ln = len::<T>(v);\n     while i < ln / 2u { v[i] <-> v[ln - i - 1u]; i += 1u; }\n }\n \n \n-#[doc = \"Returns a vector with the order of elements reversed\"]\n+/// Returns a vector with the order of elements reversed\n pure fn reversed<T: copy>(v: &[const T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n     let mut i = len::<T>(v);\n@@ -951,12 +940,12 @@ pure fn reversed<T: copy>(v: &[const T]) -> ~[T] {\n     ret rs;\n }\n \n-#[doc = \"\n-Iterates over a slice\n-\n-Iterates over slice `v` and, for each element, calls function `f` with the\n-element's value.\n-\"]\n+/**\n+ * Iterates over a slice\n+ *\n+ * Iterates over slice `v` and, for each element, calls function `f` with the\n+ * element's value.\n+ */\n #[inline(always)]\n pure fn iter<T>(v: &[T], f: fn(T)) {\n     iter_between(v, 0u, vec::len(v), f)\n@@ -988,11 +977,11 @@ pure fn iter_between<T>(v: &[T], start: uint, end: uint, f: fn(T)) {\n     }\n }\n \n-#[doc = \"\n-Iterates over a vector, with option to break\n-\n-Return true to continue, false to break.\n-\"]\n+/**\n+ * Iterates over a vector, with option to break\n+ *\n+ * Return true to continue, false to break.\n+ */\n #[inline(always)]\n pure fn each<T>(v: &[const T], f: fn(T) -> bool) {\n     do vec::unpack_slice(v) |p, n| {\n@@ -1008,11 +997,11 @@ pure fn each<T>(v: &[const T], f: fn(T) -> bool) {\n     }\n }\n \n-#[doc = \"\n-Iterates over a vector's elements and indices\n-\n-Return true to continue, false to break.\n-\"]\n+/**\n+ * Iterates over a vector's elements and indices\n+ *\n+ * Return true to continue, false to break.\n+ */\n #[inline(always)]\n pure fn eachi<T>(v: &[const T], f: fn(uint, T) -> bool) {\n     do vec::unpack_slice(v) |p, n| {\n@@ -1028,13 +1017,13 @@ pure fn eachi<T>(v: &[const T], f: fn(uint, T) -> bool) {\n     }\n }\n \n-#[doc = \"\n-Iterates over two vectors simultaneously\n-\n-# Failure\n-\n-Both vectors must have the same length\n-\"]\n+/**\n+ * Iterates over two vectors simultaneously\n+ *\n+ * # Failure\n+ *\n+ * Both vectors must have the same length\n+ */\n #[inline]\n fn iter2<U, T>(v1: &[U], v2: &[T], f: fn(U, T)) {\n     assert len(v1) == len(v2);\n@@ -1043,35 +1032,35 @@ fn iter2<U, T>(v1: &[U], v2: &[T], f: fn(U, T)) {\n     }\n }\n \n-#[doc = \"\n-Iterates over a vector's elements and indexes\n-\n-Iterates over vector `v` and, for each element, calls function `f` with the\n-element's value and index.\n-\"]\n+/**\n+ * Iterates over a vector's elements and indexes\n+ *\n+ * Iterates over vector `v` and, for each element, calls function `f` with the\n+ * element's value and index.\n+ */\n #[inline(always)]\n pure fn iteri<T>(v: &[T], f: fn(uint, T)) {\n     let mut i = 0u;\n     let l = len(v);\n     while i < l { f(i, v[i]); i += 1u; }\n }\n \n-#[doc = \"\n-Iterates over a vector in reverse\n-\n-Iterates over vector `v` and, for each element, calls function `f` with the\n-element's value.\n-\"]\n+/**\n+ * Iterates over a vector in reverse\n+ *\n+ * Iterates over vector `v` and, for each element, calls function `f` with the\n+ * element's value.\n+ */\n pure fn riter<T>(v: &[T], f: fn(T)) {\n     riteri(v, |_i, v| f(v))\n }\n \n-#[doc =\"\n-Iterates over a vector's elements and indexes in reverse\n-\n-Iterates over vector `v` and, for each element, calls function `f` with the\n-element's value and index.\n-\"]\n+/**\n+ * Iterates over a vector's elements and indexes in reverse\n+ *\n+ * Iterates over vector `v` and, for each element, calls function `f` with the\n+ * element's value and index.\n+ */\n pure fn riteri<T>(v: &[T], f: fn(uint, T)) {\n     let mut i = len(v);\n     while 0u < i {\n@@ -1080,16 +1069,16 @@ pure fn riteri<T>(v: &[T], f: fn(uint, T)) {\n     };\n }\n \n-#[doc = \"\n-Iterate over all permutations of vector `v`.\n-\n-Permutations are produced in lexicographic order with respect to the order of\n-elements in `v` (so if `v` is sorted then the permutations are\n-lexicographically sorted).\n-\n-The total number of permutations produced is `len(v)!`.  If `v` contains\n-repeated elements, then some permutations are repeated.\n-\"]\n+/**\n+ * Iterate over all permutations of vector `v`.\n+ *\n+ * Permutations are produced in lexicographic order with respect to the order\n+ * of elements in `v` (so if `v` is sorted then the permutations are\n+ * lexicographically sorted).\n+ *\n+ * The total number of permutations produced is `len(v)!`.  If `v` contains\n+ * repeated elements, then some permutations are repeated.\n+ */\n pure fn permute<T: copy>(v: &[T], put: fn(~[T])) {\n     let ln = len(v);\n     if ln == 0u {\n@@ -1122,12 +1111,12 @@ pure fn windowed<TT: copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n     ret ww;\n }\n \n-#[doc = \"\n-Work with the buffer of a vector.\n-\n-Allows for unsafe manipulation of vector contents, which is useful for\n-foreign interop.\n-\"]\n+/**\n+ * Work with the buffer of a vector.\n+ *\n+ * Allows for unsafe manipulation of vector contents, which is useful for\n+ * foreign interop.\n+ */\n fn as_buf<E,T>(v: &[E], f: fn(*E) -> T) -> T {\n     unpack_slice(v, |buf, _len| f(buf))\n }\n@@ -1136,9 +1125,7 @@ fn as_mut_buf<E,T>(v: &[mut E], f: fn(*mut E) -> T) -> T {\n     unpack_mut_slice(v, |buf, _len| f(buf))\n }\n \n-#[doc = \"\n-Work with the buffer and length of a slice.\n-\"]\n+/// Work with the buffer and length of a slice.\n #[inline(always)]\n pure fn unpack_slice<T,U>(s: &[const T],\n                           f: fn(*T, uint) -> U) -> U {\n@@ -1149,9 +1136,7 @@ pure fn unpack_slice<T,U>(s: &[const T],\n     }\n }\n \n-#[doc = \"\n-Work with the buffer and length of a slice.\n-\"]\n+/// Work with the buffer and length of a slice.\n #[inline(always)]\n pure fn unpack_const_slice<T,U>(s: &[const T],\n                                 f: fn(*const T, uint) -> U) -> U {\n@@ -1163,9 +1148,7 @@ pure fn unpack_const_slice<T,U>(s: &[const T],\n     }\n }\n \n-#[doc = \"\n-Work with the buffer and length of a slice.\n-\"]\n+/// Work with the buffer and length of a slice.\n #[inline(always)]\n pure fn unpack_mut_slice<T,U>(s: &[mut T],\n                               f: fn(*mut T, uint) -> U) -> U {\n@@ -1191,187 +1174,185 @@ impl extensions<T: copy> for ~[mut T] {\n     }\n }\n \n-#[doc = \"Extension methods for vectors\"]\n+/// Extension methods for vectors\n impl extensions/&<T> for &[const T] {\n-    #[doc = \"Returns true if a vector contains no elements\"]\n+    /// Returns true if a vector contains no elements\n     #[inline]\n     pure fn is_empty() -> bool { is_empty(self) }\n-    #[doc = \"Returns true if a vector contains some elements\"]\n+    /// Returns true if a vector contains some elements\n     #[inline]\n     pure fn is_not_empty() -> bool { is_not_empty(self) }\n-    #[doc = \"Returns the length of a vector\"]\n+    /// Returns the length of a vector\n     #[inline]\n     pure fn len() -> uint { len(self) }\n }\n \n-#[doc = \"Extension methods for vectors\"]\n+/// Extension methods for vectors\n impl extensions/&<T: copy> for &[const T] {\n-    #[doc = \"Returns the first element of a vector\"]\n+    /// Returns the first element of a vector\n     #[inline]\n     pure fn head() -> T { head(self) }\n-    #[doc = \"Returns all but the last elemnt of a vector\"]\n+    /// Returns all but the last elemnt of a vector\n     #[inline]\n     pure fn init() -> ~[T] { init(self) }\n-    #[doc = \"\n-    Returns the last element of a `v`, failing if the vector is empty.\n-    \"]\n+    /// Returns the last element of a `v`, failing if the vector is empty.\n     #[inline]\n     pure fn last() -> T { last(self) }\n-    #[doc = \"Returns a copy of the elements from [`start`..`end`) from `v`.\"]\n+    /// Returns a copy of the elements from [`start`..`end`) from `v`.\n     #[inline]\n     pure fn slice(start: uint, end: uint) -> ~[T] { slice(self, start, end) }\n-    #[doc = \"Returns all but the first element of a vector\"]\n+    /// Returns all but the first element of a vector\n     #[inline]\n     pure fn tail() -> ~[T] { tail(self) }\n }\n \n-#[doc = \"Extension methods for vectors\"]\n+/// Extension methods for vectors\n impl extensions/&<T> for &[T] {\n-    #[doc = \"Reduce a vector from right to left\"]\n+    /// Reduce a vector from right to left\n     #[inline]\n     pure fn foldr<U: copy>(z: U, p: fn(T, U) -> U) -> U { foldr(self, z, p) }\n-    #[doc = \"\n-    Iterates over a vector\n-\n-    Iterates over vector `v` and, for each element, calls function `f` with\n-    the element's value.\n-    \"]\n+    /**\n+     * Iterates over a vector\n+     *\n+     * Iterates over vector `v` and, for each element, calls function `f` with\n+     * the element's value.\n+     */\n     #[inline]\n     pure fn iter(f: fn(T)) { iter(self, f) }\n-    #[doc = \"\n-    Iterates over a vector's elements and indexes\n-\n-    Iterates over vector `v` and, for each element, calls function `f` with\n-    the element's value and index.\n-    \"]\n+    /**\n+     * Iterates over a vector's elements and indexes\n+     *\n+     * Iterates over vector `v` and, for each element, calls function `f` with\n+     * the element's value and index.\n+     */\n     #[inline]\n     pure fn iteri(f: fn(uint, T)) { iteri(self, f) }\n-    #[doc = \"\n-    Find the first index matching some predicate\n-\n-    Apply function `f` to each element of `v`.  When function `f` returns true\n-    then an option containing the index is returned. If `f` matches no\n-    elements then none is returned.\n-    \"]\n+    /**\n+     * Find the first index matching some predicate\n+     *\n+     * Apply function `f` to each element of `v`.  When function `f` returns\n+     * true then an option containing the index is returned. If `f` matches no\n+     * elements then none is returned.\n+     */\n     #[inline]\n     pure fn position(f: fn(T) -> bool) -> option<uint> { position(self, f) }\n-    #[doc = \"Find the first index containing a matching value\"]\n+    /// Find the first index containing a matching value\n     #[inline]\n     pure fn position_elem(x: T) -> option<uint> { position_elem(self, x) }\n-    #[doc = \"\n-    Iterates over a vector in reverse\n-\n-    Iterates over vector `v` and, for each element, calls function `f` with\n-    the element's value.\n-    \"]\n+    /**\n+     * Iterates over a vector in reverse\n+     *\n+     * Iterates over vector `v` and, for each element, calls function `f` with\n+     * the element's value.\n+     */\n     #[inline]\n     pure fn riter(f: fn(T)) { riter(self, f) }\n-    #[doc =\"\n-    Iterates over a vector's elements and indexes in reverse\n-\n-    Iterates over vector `v` and, for each element, calls function `f` with\n-    the element's value and index.\n-    \"]\n+    /**\n+     * Iterates over a vector's elements and indexes in reverse\n+     *\n+     * Iterates over vector `v` and, for each element, calls function `f` with\n+     * the element's value and index.\n+     */\n     #[inline]\n     pure fn riteri(f: fn(uint, T)) { riteri(self, f) }\n-    #[doc = \"\n-    Find the last index matching some predicate\n-\n-    Apply function `f` to each element of `v` in reverse order.  When function\n-    `f` returns true then an option containing the index is returned. If `f`\n-    matches no elements then none is returned.\n-    \"]\n+    /**\n+     * Find the last index matching some predicate\n+     *\n+     * Apply function `f` to each element of `v` in reverse order.  When\n+     * function `f` returns true then an option containing the index is\n+     * returned. If `f` matches no elements then none is returned.\n+     */\n     #[inline]\n     pure fn rposition(f: fn(T) -> bool) -> option<uint> { rposition(self, f) }\n-    #[doc = \"Find the last index containing a matching value\"]\n+    /// Find the last index containing a matching value\n     #[inline]\n     pure fn rposition_elem(x: T) -> option<uint> { rposition_elem(self, x) }\n-    #[doc = \"\n-    Apply a function to each element of a vector and return the results\n-    \"]\n+    /// Apply a function to each element of a vector and return the results\n     #[inline]\n     pure fn map<U>(f: fn(T) -> U) -> ~[U] { map(self, f) }\n-    #[doc = \"\n-    Apply a function to the index and value of each element in the vector\n-    and return the results\n-    \"]\n+    /**\n+     * Apply a function to the index and value of each element in the vector\n+     * and return the results\n+     */\n     pure fn mapi<U>(f: fn(uint, T) -> U) -> ~[U] {\n         mapi(self, f)\n     }\n-    #[doc = \"Returns true if the function returns true for all elements.\n-\n-    If the vector is empty, true is returned.\"]\n+    /**\n+     * Returns true if the function returns true for all elements.\n+     *\n+     *     If the vector is empty, true is returned.\n+     */\n     pure fn alli(f: fn(uint, T) -> bool) -> bool {\n         alli(self, f)\n     }\n-    #[doc = \"\n-    Apply a function to each element of a vector and return a concatenation\n-    of each result vector\n-    \"]\n+    /**\n+     * Apply a function to each element of a vector and return a concatenation\n+     * of each result vector\n+     */\n     #[inline]\n     pure fn flat_map<U>(f: fn(T) -> ~[U]) -> ~[U] { flat_map(self, f) }\n-    #[doc = \"\n-    Apply a function to each element of a vector and return the results\n-\n-    If function `f` returns `none` then that element is excluded from\n-    the resulting vector.\n-    \"]\n+    /**\n+     * Apply a function to each element of a vector and return the results\n+     *\n+     * If function `f` returns `none` then that element is excluded from\n+     * the resulting vector.\n+     */\n     #[inline]\n     pure fn filter_map<U: copy>(f: fn(T) -> option<U>) -> ~[U] {\n         filter_map(self, f)\n     }\n }\n \n-#[doc = \"Extension methods for vectors\"]\n+/// Extension methods for vectors\n impl extensions/&<T: copy> for &[T] {\n-    #[doc = \"\n-    Construct a new vector from the elements of a vector for which some\n-    predicate holds.\n-\n-    Apply function `f` to each element of `v` and return a vector containing\n-    only those elements for which `f` returned true.\n-    \"]\n+    /**\n+     * Construct a new vector from the elements of a vector for which some\n+     * predicate holds.\n+     *\n+     * Apply function `f` to each element of `v` and return a vector\n+     * containing only those elements for which `f` returned true.\n+     */\n     #[inline]\n     pure fn filter(f: fn(T) -> bool) -> ~[T] { filter(self, f) }\n-    #[doc = \"\n-    Search for the first element that matches a given predicate\n-\n-    Apply function `f` to each element of `v`, starting from the first.\n-    When function `f` returns true then an option containing the element\n-    is returned. If `f` matches no elements then none is returned.\n-    \"]\n+    /**\n+     * Search for the first element that matches a given predicate\n+     *\n+     * Apply function `f` to each element of `v`, starting from the first.\n+     * When function `f` returns true then an option containing the element\n+     * is returned. If `f` matches no elements then none is returned.\n+     */\n     #[inline]\n     pure fn find(f: fn(T) -> bool) -> option<T> { find(self, f) }\n-    #[doc = \"\n-    Search for the last element that matches a given predicate\n-\n-    Apply function `f` to each element of `v` in reverse order. When function\n-    `f` returns true then an option containing the element is returned. If `f`\n-    matches no elements then none is returned.\n-    \"]\n+    /**\n+     * Search for the last element that matches a given predicate\n+     *\n+     * Apply function `f` to each element of `v` in reverse order. When\n+     * function `f` returns true then an option containing the element is\n+     * returned. If `f` matches no elements then none is returned.\n+     */\n     #[inline]\n     pure fn rfind(f: fn(T) -> bool) -> option<T> { rfind(self, f) }\n }\n \n-#[doc = \"Unsafe operations\"]\n+/// Unsafe operations\n mod unsafe {\n     // FIXME: This should have crate visibility (#1893 blocks that)\n-    #[doc = \"The internal representation of a vector\"]\n+    /// The internal representation of a vector\n     type vec_repr = {\n         box_header: (uint, uint, uint, uint),\n         mut fill: uint,\n         mut alloc: uint,\n         data: u8\n     };\n \n-    #[doc = \"\n-    Constructs a vector from an unsafe pointer to a buffer\n-\n-    # Arguments\n-\n-    * ptr - An unsafe pointer to a buffer of `T`\n-    * elts - The number of elements in the buffer\n-    \"]\n+    /**\n+     * Constructs a vector from an unsafe pointer to a buffer\n+     *\n+     * # Arguments\n+     *\n+     * * ptr - An unsafe pointer to a buffer of `T`\n+     * * elts - The number of elements in the buffer\n+     */\n     #[inline(always)]\n     unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {\n         ret ::unsafe::reinterpret_cast(\n@@ -1380,38 +1361,39 @@ mod unsafe {\n                                         elts as size_t));\n     }\n \n-    #[doc = \"\n-    Sets the length of a vector\n-\n-    This will explicitly set the size of the vector, without actually\n-    modifing its buffers, so it is up to the caller to ensure that\n-    the vector is actually the specified size.\n-    \"]\n+    /**\n+     * Sets the length of a vector\n+     *\n+     * This will explicitly set the size of the vector, without actually\n+     * modifing its buffers, so it is up to the caller to ensure that\n+     * the vector is actually the specified size.\n+     */\n     #[inline(always)]\n     unsafe fn set_len<T>(&&v: ~[const T], new_len: uint) {\n         let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n         (**repr).fill = new_len * sys::size_of::<T>();\n     }\n \n-    #[doc = \"\n-    Returns an unsafe pointer to the vector's buffer\n-\n-    The caller must ensure that the vector outlives the pointer this\n-    function returns, or else it will end up pointing to garbage.\n-\n-    Modifying the vector may cause its buffer to be reallocated, which\n-    would also make any pointers to it invalid.\n-    \"]\n+    /**\n+     * Returns an unsafe pointer to the vector's buffer\n+     *\n+     * The caller must ensure that the vector outlives the pointer this\n+     * function returns, or else it will end up pointing to garbage.\n+     *\n+     * Modifying the vector may cause its buffer to be reallocated, which\n+     * would also make any pointers to it invalid.\n+     */\n     #[inline(always)]\n     unsafe fn to_ptr<T>(v: ~[const T]) -> *T {\n         let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n         ret ::unsafe::reinterpret_cast(addr_of((**repr).data));\n     }\n \n \n-    #[doc = \"\n-    Form a slice from a pointer and length (as a number of units, not bytes).\n-    \"]\n+    /**\n+     * Form a slice from a pointer and length (as a number of units,\n+     * not bytes).\n+     */\n     #[inline(always)]\n     unsafe fn form_slice<T,U>(p: *T, len: uint, f: fn(&& &[T]) -> U) -> U {\n         let pair = (p, len * sys::size_of::<T>());\n@@ -1421,13 +1403,13 @@ mod unsafe {\n     }\n }\n \n-#[doc = \"Operations on `[u8]`\"]\n+/// Operations on `[u8]`\n mod u8 {\n     export cmp;\n     export lt, le, eq, ne, ge, gt;\n     export hash;\n \n-    #[doc = \"Bytewise string comparison\"]\n+    /// Bytewise string comparison\n     pure fn cmp(&&a: ~[u8], &&b: ~[u8]) -> int {\n         let a_len = len(a);\n         let b_len = len(b);\n@@ -1448,25 +1430,25 @@ mod u8 {\n         }\n     }\n \n-    #[doc = \"Bytewise less than or equal\"]\n+    /// Bytewise less than or equal\n     pure fn lt(&&a: ~[u8], &&b: ~[u8]) -> bool { cmp(a, b) < 0 }\n \n-    #[doc = \"Bytewise less than or equal\"]\n+    /// Bytewise less than or equal\n     pure fn le(&&a: ~[u8], &&b: ~[u8]) -> bool { cmp(a, b) <= 0 }\n \n-    #[doc = \"Bytewise equality\"]\n+    /// Bytewise equality\n     pure fn eq(&&a: ~[u8], &&b: ~[u8]) -> bool { unsafe { cmp(a, b) == 0 } }\n \n-    #[doc = \"Bytewise inequality\"]\n+    /// Bytewise inequality\n     pure fn ne(&&a: ~[u8], &&b: ~[u8]) -> bool { unsafe { cmp(a, b) != 0 } }\n \n-    #[doc =\"Bytewise greater than or equal\"]\n+    /// Bytewise greater than or equal\n     pure fn ge(&&a: ~[u8], &&b: ~[u8]) -> bool { cmp(a, b) >= 0 }\n \n-    #[doc = \"Bytewise greater than\"]\n+    /// Bytewise greater than\n     pure fn gt(&&a: ~[u8], &&b: ~[u8]) -> bool { cmp(a, b) > 0 }\n \n-    #[doc = \"String hash function\"]\n+    /// String hash function\n     fn hash(&&s: ~[u8]) -> uint {\n         /* Seems to have been tragically copy/pasted from str.rs,\n            or vice versa. But I couldn't figure out how to abstract"}, {"sha": "f6c7b573f65ed3240c02707d0c7eb5a0156881c3", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -21,19 +21,19 @@ export eq_vec;\n // write an optimizing version of this module that produces a different obj\n // for the case where nbits <= 32.\n \n-#[doc = \"The bitvector type\"]\n+/// The bitvector type\n type bitv = @{storage: ~[mut uint], nbits: uint};\n \n const uint_bits: uint = 32u + (1u << 32u >> 27u);\n \n-#[doc = \"\n-Constructs a bitvector\n-\n-# Arguments\n-\n-* nbits - The number of bits in the bitvector\n-* init - If true then the bits are initialized to 1, otherwise 0\n-\"]\n+/**\n+ * Constructs a bitvector\n+ *\n+ * # Arguments\n+ *\n+ * * nbits - The number of bits in the bitvector\n+ * * init - If true then the bits are initialized to 1, otherwise 0\n+ */\n fn bitv(nbits: uint, init: bool) -> bitv {\n     let elt = if init { !0u } else { 0u };\n     let storage = vec::to_mut(vec::from_elem(nbits / uint_bits + 1u, elt));\n@@ -63,37 +63,37 @@ fn union(v0: bitv, v1: bitv) -> bool {\n \n fn land(w0: uint, w1: uint) -> uint { ret w0 & w1; }\n \n-#[doc = \"\n-Calculates the intersection of two bitvectors\n-\n-Sets `v0` to the intersection of `v0` and `v1`. Both bitvectors must be the\n-same length. Returns 'true' if `v0` was changed.\n-\"]\n+/**\n+ * Calculates the intersection of two bitvectors\n+ *\n+ * Sets `v0` to the intersection of `v0` and `v1`. Both bitvectors must be the\n+ * same length. Returns 'true' if `v0` was changed.\n+ */\n fn intersect(v0: bitv, v1: bitv) -> bool {\n     let sub = land;\n     ret process(v0, v1, sub);\n }\n \n fn right(_w0: uint, w1: uint) -> uint { ret w1; }\n \n-#[doc = \"\n-Assigns the value of `v1` to `v0`\n-\n-Both bitvectors must be the same length. Returns `true` if `v0` was changed\n-\"]\n+/**\n+ * Assigns the value of `v1` to `v0`\n+ *\n+ * Both bitvectors must be the same length. Returns `true` if `v0` was changed\n+ */\n fn assign(v0: bitv, v1: bitv) -> bool {\n     let sub = right; ret process(v0, v1, sub);\n }\n \n-#[doc = \"Makes a copy of a bitvector\"]\n+/// Makes a copy of a bitvector\n fn clone(v: bitv) -> bitv {\n     let storage = vec::to_mut(vec::from_elem(v.nbits / uint_bits + 1u, 0u));\n     let len = vec::len(v.storage);\n     for uint::range(0u, len) |i| { storage[i] = v.storage[i]; };\n     ret @{storage: storage, nbits: v.nbits};\n }\n \n-#[doc = \"Retrieve the value at index `i`\"]\n+/// Retrieve the value at index `i`\n #[inline(always)]\n pure fn get(v: bitv, i: uint) -> bool {\n     assert (i < v.nbits);\n@@ -104,12 +104,12 @@ pure fn get(v: bitv, i: uint) -> bool {\n     ret x == 1u;\n }\n \n-#[doc = \"\n-Compares two bitvectors\n-\n-Both bitvectors must be the same length. Returns `true` if both bitvectors\n-contain identical elements.\n-\"]\n+/**\n+ * Compares two bitvectors\n+ *\n+ * Both bitvectors must be the same length. Returns `true` if both bitvectors\n+ * contain identical elements.\n+ */\n fn equal(v0: bitv, v1: bitv) -> bool {\n     if v0.nbits != v1.nbits { ret false; }\n     let len = vec::len(v1.storage);\n@@ -118,38 +118,38 @@ fn equal(v0: bitv, v1: bitv) -> bool {\n     }\n }\n \n-#[doc = \"Set all bits to 0\"]\n+/// Set all bits to 0\n #[inline(always)]\n fn clear(v: bitv) { for each_storage(v) |w| { w = 0u } }\n \n-#[doc = \"Set all bits to 1\"]\n+/// Set all bits to 1\n #[inline(always)]\n fn set_all(v: bitv) { for each_storage(v) |w| { w = !0u } }\n \n-#[doc = \"Invert all bits\"]\n+/// Invert all bits\n #[inline(always)]\n fn invert(v: bitv) { for each_storage(v) |w| { w = !w } }\n \n-#[doc = \"\n-Calculate the difference between two bitvectors\n-\n-Sets each element of `v0` to the value of that element minus the element\n-of `v1` at the same index. Both bitvectors must be the same length.\n-\n-Returns `true` if `v0` was changed.\n-\"]\n+/**\n+ * Calculate the difference between two bitvectors\n+ *\n+ * Sets each element of `v0` to the value of that element minus the element\n+ * of `v1` at the same index. Both bitvectors must be the same length.\n+ *\n+ * Returns `true` if `v0` was changed.\n+ */\n fn difference(v0: bitv, v1: bitv) -> bool {\n     invert(v1);\n     let b = intersect(v0, v1);\n     invert(v1);\n     ret b;\n }\n \n-#[doc = \"\n-Set the value of a bit at a given index\n-\n-`i` must be less than the length of the bitvector.\n-\"]\n+/**\n+ * Set the value of a bit at a given index\n+ *\n+ * `i` must be less than the length of the bitvector.\n+ */\n #[inline(always)]\n fn set(v: bitv, i: uint, x: bool) {\n     assert (i < v.nbits);\n@@ -161,14 +161,14 @@ fn set(v: bitv, i: uint, x: bool) {\n }\n \n \n-#[doc = \"Returns true if all bits are 1\"]\n+/// Returns true if all bits are 1\n fn is_true(v: bitv) -> bool {\n     for each(v) |i| { if !i { ret false; } }\n     ret true;\n }\n \n \n-#[doc = \"Returns true if all bits are 0\"]\n+/// Returns true if all bits are 0\n fn is_false(v: bitv) -> bool {\n     for each(v) |i| { if i { ret false; } }\n     ret true;\n@@ -178,11 +178,11 @@ fn init_to_vec(v: bitv, i: uint) -> uint {\n     ret if get(v, i) { 1u } else { 0u };\n }\n \n-#[doc = \"\n-Converts the bitvector to a vector of uint with the same length.\n-\n-Each uint in the resulting vector has either value 0u or 1u.\n-\"]\n+/**\n+ * Converts the bitvector to a vector of uint with the same length.\n+ *\n+ * Each uint in the resulting vector has either value 0u or 1u.\n+ */\n fn to_vec(v: bitv) -> ~[uint] {\n     let sub = |x| init_to_vec(v, x);\n     ret vec::from_fn::<uint>(v.nbits, sub);\n@@ -207,24 +207,24 @@ fn each_storage(v: bitv, op: fn(&uint) -> bool) {\n     }\n }\n \n-#[doc = \"\n-Converts the bitvector to a string.\n-\n-The resulting string has the same length as the bitvector, and each character\n-is either '0' or '1'.\n-\"]\n+/**\n+ * Converts the bitvector to a string.\n+ *\n+ * The resulting string has the same length as the bitvector, and each\n+ * character is either '0' or '1'.\n+ */\n fn to_str(v: bitv) -> str {\n     let mut rs = \"\";\n     for each(v) |i| { if i { rs += \"1\"; } else { rs += \"0\"; } }\n     ret rs;\n }\n \n-#[doc = \"\n-Compare a bitvector to a vector of uint\n-\n-The uint vector is expected to only contain the values 0u and 1u. Both the\n-bitvector and vector must have the same length\n-\"]\n+/**\n+ * Compare a bitvector to a vector of uint\n+ *\n+ * The uint vector is expected to only contain the values 0u and 1u. Both the\n+ * bitvector and vector must have the same length\n+ */\n fn eq_vec(v0: bitv, v1: ~[uint]) -> bool {\n     assert (v0.nbits == vec::len::<uint>(v1));\n     let len = v0.nbits;"}, {"sha": "7f71b999d6f4f5bbcfdb80efdca534de9e596790", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 65, "deletions": 64, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,42 +1,43 @@\n-#[doc = \"\n-Library to interface with chunks of memory allocated in C.\n-\n-It is often desirable to safely interface with memory allocated from C,\n-encapsulating the unsafety into allocation and destruction time.  Indeed,\n-allocating memory externally is currently the only way to give Rust shared\n-mut state with C programs that keep their own references; vectors are\n-unsuitable because they could be reallocated or moved at any time, and\n-importing C memory into a vector takes a one-time snapshot of the memory.\n-\n-This module simplifies the usage of such external blocks of memory.  Memory\n-is encapsulated into an opaque object after creation; the lifecycle of the\n-memory can be optionally managed by Rust, if an appropriate destructor\n-closure is provided.  Safety is ensured by bounds-checking accesses, which\n-are marshalled through get and set functions.\n-\n-There are three unsafe functions: the two introduction forms, and the\n-pointer elimination form.  The introduction forms are unsafe for the obvious\n-reason (they act on a pointer that cannot be checked inside the method), but\n-the elimination form is somewhat more subtle in its unsafety.  By using a\n-pointer taken from a c_vec::t without keeping a reference to the c_vec::t\n-itself around, the c_vec could be garbage collected, and the memory within\n-could be destroyed.  There are legitimate uses for the pointer elimination\n-form -- for instance, to pass memory back into C -- but great care must be\n-taken to ensure that a reference to the c_vec::t is still held if needed.\n-\"];\n+/*!\n+ * Library to interface with chunks of memory allocated in C.\n+ *\n+ * It is often desirable to safely interface with memory allocated from C,\n+ * encapsulating the unsafety into allocation and destruction time.  Indeed,\n+ * allocating memory externally is currently the only way to give Rust shared\n+ * mut state with C programs that keep their own references; vectors are\n+ * unsuitable because they could be reallocated or moved at any time, and\n+ * importing C memory into a vector takes a one-time snapshot of the memory.\n+ *\n+ * This module simplifies the usage of such external blocks of memory.  Memory\n+ * is encapsulated into an opaque object after creation; the lifecycle of the\n+ * memory can be optionally managed by Rust, if an appropriate destructor\n+ * closure is provided.  Safety is ensured by bounds-checking accesses, which\n+ * are marshalled through get and set functions.\n+ *\n+ * There are three unsafe functions: the two introduction forms, and the\n+ * pointer elimination form.  The introduction forms are unsafe for the\n+ * obvious reason (they act on a pointer that cannot be checked inside the\n+ * method), but the elimination form is somewhat more subtle in its unsafety.\n+ * By using a pointer taken from a c_vec::t without keeping a reference to the\n+ * c_vec::t itself around, the c_vec could be garbage collected, and the\n+ * memory within could be destroyed.  There are legitimate uses for the\n+ * pointer elimination form -- for instance, to pass memory back into C -- but\n+ * great care must be taken to ensure that a reference to the c_vec::t is\n+ * still held if needed.\n+ */\n \n export c_vec;\n export c_vec, c_vec_with_dtor;\n export get, set;\n export len;\n export ptr;\n \n-#[doc = \"\n-The type representing a foreign chunk of memory\n-\n-Wrapped in a enum for opacity; FIXME #818 when it is possible to have\n-truly opaque types, this should be revisited.\n-\"]\n+/**\n+ * The type representing a foreign chunk of memory\n+ *\n+ * Wrapped in a enum for opacity; FIXME #818 when it is possible to have\n+ * truly opaque types, this should be revisited.\n+ */\n enum c_vec<T> {\n     c_vec_({ base: *mut T, len: uint, rsrc: @dtor_res})\n }\n@@ -56,14 +57,14 @@ class dtor_res {\n  Section: Introduction forms\n  */\n \n-#[doc = \"\n-Create a `c_vec` from a foreign buffer with a given length.\n-\n-# Arguments\n-\n-* base - A foreign pointer to a buffer\n-* len - The number of elements in the buffer\n-\"]\n+/**\n+ * Create a `c_vec` from a foreign buffer with a given length.\n+ *\n+ * # Arguments\n+ *\n+ * * base - A foreign pointer to a buffer\n+ * * len - The number of elements in the buffer\n+ */\n unsafe fn c_vec<T>(base: *mut T, len: uint) -> c_vec<T> {\n     ret c_vec_({\n         base: base,\n@@ -72,17 +73,17 @@ unsafe fn c_vec<T>(base: *mut T, len: uint) -> c_vec<T> {\n     });\n }\n \n-#[doc = \"\n-Create a `c_vec` from a foreign buffer, with a given length,\n-and a function to run upon destruction.\n-\n-# Arguments\n-\n-* base - A foreign pointer to a buffer\n-* len - The number of elements in the buffer\n-* dtor - A function to run when the value is destructed, useful\n-         for freeing the buffer, etc.\n-\"]\n+/**\n+ * Create a `c_vec` from a foreign buffer, with a given length,\n+ * and a function to run upon destruction.\n+ *\n+ * # Arguments\n+ *\n+ * * base - A foreign pointer to a buffer\n+ * * len - The number of elements in the buffer\n+ * * dtor - A function to run when the value is destructed, useful\n+ *          for freeing the buffer, etc.\n+ */\n unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: fn@())\n   -> c_vec<T> {\n     ret c_vec_({\n@@ -96,21 +97,21 @@ unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: fn@())\n  Section: Operations\n  */\n \n-#[doc = \"\n-Retrieves an element at a given index\n-\n-Fails if `ofs` is greater or equal to the length of the vector\n-\"]\n+/**\n+ * Retrieves an element at a given index\n+ *\n+ * Fails if `ofs` is greater or equal to the length of the vector\n+ */\n fn get<T: copy>(t: c_vec<T>, ofs: uint) -> T {\n     assert ofs < len(t);\n     ret unsafe { *ptr::mut_offset((*t).base, ofs) };\n }\n \n-#[doc = \"\n-Sets the value of an element at a given index\n-\n-Fails if `ofs` is greater or equal to the length of the vector\n-\"]\n+/**\n+ * Sets the value of an element at a given index\n+ *\n+ * Fails if `ofs` is greater or equal to the length of the vector\n+ */\n fn set<T: copy>(t: c_vec<T>, ofs: uint, v: T) {\n     assert ofs < len(t);\n     unsafe { *ptr::mut_offset((*t).base, ofs) = v };\n@@ -120,12 +121,12 @@ fn set<T: copy>(t: c_vec<T>, ofs: uint, v: T) {\n  Section: Elimination forms\n  */\n \n-#[doc = \"Returns the length of the vector\"]\n+/// Returns the length of the vector\n fn len<T>(t: c_vec<T>) -> uint {\n     ret (*t).len;\n }\n \n-#[doc = \"Returns a pointer to the first element of the vector\"]\n+/// Returns a pointer to the first element of the vector\n unsafe fn ptr<T>(t: c_vec<T>) -> *mut T {\n     ret (*t).base;\n }\n@@ -183,4 +184,4 @@ mod tests {\n         set(cv, 2u, 34u8); /* safety */\n     }\n \n-}\n\\ No newline at end of file\n+}"}, {"sha": "a89148ecec9defebe20b1f950ee7b87d34eeb3be", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc=\"Additional general-purpose comparison functionality.\"]\n+/// Additional general-purpose comparison functionality.\n \n const fuzzy_epsilon: float = 1.0e-6;\n "}, {"sha": "ddc0d3b4450a852e2f056f9cf7bf2b62e548dfd4", "filename": "src/libstd/dbg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdbg.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Unsafe debugging functions for inspecting values.\"];\n+//! Unsafe debugging functions for inspecting values.\n \n import unsafe::reinterpret_cast;\n \n@@ -47,7 +47,7 @@ unsafe fn ptr_cast<T, U>(x: @T) -> @U {\n                               reinterpret_cast(x)))\n }\n \n-#[doc = \"Triggers a debugger breakpoint\"]\n+/// Triggers a debugger breakpoint\n fn breakpoint() {\n     rustrt::rust_dbg_breakpoint();\n }"}, {"sha": "416a52cde5b60c2f4b59e59f999e0cf02dcb6433", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"A deque. Untested as of yet. Likely buggy\"];\n+//! A deque. Untested as of yet. Likely buggy\n \n import option::{some, none};\n import dvec::{dvec, extensions};"}, {"sha": "6a3b40b88ff50fe504ab5c4a9017a6b27ddf2985", "filename": "src/libstd/fun_treemap.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffun_treemap.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,13 +1,13 @@\n-#[doc = \"\n-A functional key,value store that works on anything.\n-\n-This works using a binary search tree. In the first version, it's a\n-very naive algorithm, but it will probably be updated to be a\n-red-black tree or something else.\n-\n-This is copied and modified from treemap right now. It's missing a lot\n-of features.\n-\"];\n+/*!\n+ * A functional key,value store that works on anything.\n+ *\n+ * This works using a binary search tree. In the first version, it's a\n+ * very naive algorithm, but it will probably be updated to be a\n+ * red-black tree or something else.\n+ *\n+ * This is copied and modified from treemap right now. It's missing a lot\n+ * of features.\n+ */\n \n import option::{some, none};\n import option = option;\n@@ -25,10 +25,10 @@ enum tree_node<K, V> {\n     node(@K, @V, @tree_node<K, V>, @tree_node<K, V>)\n }\n \n-#[doc = \"Create a treemap\"]\n+/// Create a treemap\n fn init<K, V>() -> treemap<K, V> { @empty }\n \n-#[doc = \"Insert a value into the map\"]\n+/// Insert a value into the map\n fn insert<K: copy, V: copy>(m: treemap<K, V>, k: K, v: V) -> treemap<K, V> {\n     @alt m {\n        @empty { node(@k, @v, @empty, @empty) }\n@@ -42,7 +42,7 @@ fn insert<K: copy, V: copy>(m: treemap<K, V>, k: K, v: V) -> treemap<K, V> {\n      }\n }\n \n-#[doc = \"Find a value based on the key\"]\n+/// Find a value based on the key\n fn find<K, V: copy>(m: treemap<K, V>, k: K) -> option<V> {\n     alt *m {\n       empty { none }\n@@ -54,7 +54,7 @@ fn find<K, V: copy>(m: treemap<K, V>, k: K) -> option<V> {\n     }\n }\n \n-#[doc = \"Visit all pairs in the map in order.\"]\n+/// Visit all pairs in the map in order.\n fn traverse<K, V: copy>(m: treemap<K, V>, f: fn(K, V)) {\n     alt *m {\n       empty { }"}, {"sha": "fba3ae9e3dbe6d3ac4e7f3dde8d22cbc828bc201", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 120, "deletions": 121, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,67 +1,66 @@\n-#[doc = \"\n-Simple getopt alternative.\n-\n-Construct a vector of options, either by using reqopt, optopt, and optflag or\n-by building them from components yourself, and pass them to getopts, along\n-with a vector of actual arguments (not including argv[0]). You'll either get a\n-failure code back, or a match. You'll have to verify whether the amount of\n-'free' arguments in the match is what you expect. Use opt_* accessors to get\n-argument values out of the match object.\n-\n-Single-character options are expected to appear on the command line with a\n-single preceding dash; multiple-character options are expected to be\n-proceeded by two dashes. Options that expect an argument accept their argument\n-following either a space or an equals sign.\n-\n-# Example\n-\n-The following example shows simple command line parsing for an application\n-that requires an input file to be specified, accepts an optional output file\n-name following -o, and accepts both -h and --help as optional flags.\n-\n-    use std;\n-    import std::getopts::{optopt,optflag,getopts,opt_present,opt_maybe_str,\n-        fail_str};\n-\n-    fn do_work(in: str, out: option<str>) {\n-        // ...\n-    }\n-\n-    fn print_usage(program: str) {\n-        io::println(\\\"Usage: \\\" + program + \\\" [options]/~\\\");\n-        io::println(\\\"-o\\t\\tOutput\\\");\n-        io::println(\\\"-h --help\\tUsage\\\");\n-    }\n-\n-    fn main(args: [str]/~) {\n-        check vec::is_not_empty(args);\n-\n-        let program : str = vec::head(args);\n-\n-        let opts = [\n-            optopt(\\\"o\\\"),\n-            optflag(\\\"h\\\"),\n-            optflag(\\\"help\\\")\n-        ]/~;\n-        let match = alt getopts(vec::tail(args), opts) {\n-            result::ok(m) { m }\n-            result::err(f) { fail fail_str(f) }\n-        };\n-        if opt_present(match, \\\"h\\\") || opt_present(match, \\\"help\\\") {\n-            print_usage(program);\n-            ret;\n-        }\n-        let output = opt_maybe_str(match, \\\"o\\\");\n-        let input = if vec::is_not_empty(match.free) {\n-            match.free[0]\n-        } else {\n-            print_usage(program);\n-            ret;\n-        };\n-        do_work(input, output);\n-    }\n-\n-\"];\n+/*!\n+ * Simple getopt alternative.\n+ *\n+ * Construct a vector of options, either by using reqopt, optopt, and optflag\n+ * or by building them from components yourself, and pass them to getopts,\n+ * along with a vector of actual arguments (not including argv[0]). You'll\n+ * either get a failure code back, or a match. You'll have to verify whether\n+ * the amount of 'free' arguments in the match is what you expect. Use opt_*\n+ * accessors to get argument values out of the match object.\n+ *\n+ * Single-character options are expected to appear on the command line with a\n+ * single preceding dash; multiple-character options are expected to be\n+ * proceeded by two dashes. Options that expect an argument accept their\n+ * argument following either a space or an equals sign.\n+ *\n+ * # Example\n+ *\n+ * The following example shows simple command line parsing for an application\n+ * that requires an input file to be specified, accepts an optional output\n+ * file name following -o, and accepts both -h and --help as optional flags.\n+ *\n+ *     use std;\n+ *     import std::getopts::{optopt,optflag,getopts,opt_present,opt_maybe_str,\n+ *         fail_str};\n+ *\n+ *     fn do_work(in: str, out: option<str>) {\n+ *         // ...\n+ *     }\n+ *\n+ *     fn print_usage(program: str) {\n+ *         io::println(\"Usage: \" + program + \" [options]/~\");\n+ *         io::println(\"-o\\t\\tOutput\");\n+ *         io::println(\"-h --help\\tUsage\");\n+ *     }\n+ *\n+ *     fn main(args: [str]/~) {\n+ *         check vec::is_not_empty(args);\n+ *\n+ *         let program : str = vec::head(args);\n+ *\n+ *         let opts = [\n+ *             optopt(\"o\"),\n+ *             optflag(\"h\"),\n+ *             optflag(\"help\")\n+ *         ]/~;\n+ *         let match = alt getopts(vec::tail(args), opts) {\n+ *             result::ok(m) { m }\n+ *             result::err(f) { fail fail_str(f) }\n+ *         };\n+ *         if opt_present(match, \"h\") || opt_present(match, \"help\") {\n+ *             print_usage(program);\n+ *             ret;\n+ *         }\n+ *         let output = opt_maybe_str(match, \"o\");\n+ *         let input = if vec::is_not_empty(match.free) {\n+ *             match.free[0]\n+ *         } else {\n+ *             print_usage(program);\n+ *             ret;\n+ *         };\n+ *         do_work(input, output);\n+ *     }\n+ */\n \n import core::result::{err, ok};\n import core::option;\n@@ -91,7 +90,7 @@ enum hasarg { yes, no, maybe, }\n \n enum occur { req, optional, multi, }\n \n-#[doc = \"A description of a possible option\"]\n+/// A description of a possible option\n type opt = {name: name, hasarg: hasarg, occur: occur};\n \n fn mkname(nm: str) -> name {\n@@ -100,40 +99,40 @@ fn mkname(nm: str) -> name {\n         } else { long(nm) };\n }\n \n-#[doc = \"Create an option that is required and takes an argument\"]\n+/// Create an option that is required and takes an argument\n fn reqopt(name: str) -> opt {\n     ret {name: mkname(name), hasarg: yes, occur: req};\n }\n \n-#[doc = \"Create an option that is optional and takes an argument\"]\n+/// Create an option that is optional and takes an argument\n fn optopt(name: str) -> opt {\n     ret {name: mkname(name), hasarg: yes, occur: optional};\n }\n \n-#[doc = \"Create an option that is optional and does not take an argument\"]\n+/// Create an option that is optional and does not take an argument\n fn optflag(name: str) -> opt {\n     ret {name: mkname(name), hasarg: no, occur: optional};\n }\n \n-#[doc = \"Create an option that is optional and takes an optional argument\"]\n+/// Create an option that is optional and takes an optional argument\n fn optflagopt(name: str) -> opt {\n     ret {name: mkname(name), hasarg: maybe, occur: optional};\n }\n \n-#[doc = \"\n-Create an option that is optional, takes an argument, and may occur\n-multiple times\n-\"]\n+/**\n+ * Create an option that is optional, takes an argument, and may occur\n+ * multiple times\n+ */\n fn optmulti(name: str) -> opt {\n     ret {name: mkname(name), hasarg: yes, occur: multi};\n }\n \n enum optval { val(str), given, }\n \n-#[doc = \"\n-The result of checking command line arguments. Contains a vector\n-of matches and a vector of free strings.\n-\"]\n+/**\n+ * The result of checking command line arguments. Contains a vector\n+ * of matches and a vector of free strings.\n+ */\n type match = {opts: ~[opt], vals: ~[~[optval]], free: ~[str]};\n \n fn is_arg(arg: str) -> bool {\n@@ -148,10 +147,10 @@ fn find_opt(opts: ~[opt], nm: name) -> option<uint> {\n     vec::position(opts, |opt| opt.name == nm)\n }\n \n-#[doc = \"\n-The type returned when the command line does not conform to the\n-expected format. Pass this value to <fail_str> to get an error message.\n-\"]\n+/**\n+ * The type returned when the command line does not conform to the\n+ * expected format. Pass this value to <fail_str> to get an error message.\n+ */\n enum fail_ {\n     argument_missing(str),\n     unrecognized_option(str),\n@@ -160,7 +159,7 @@ enum fail_ {\n     unexpected_argument(str),\n }\n \n-#[doc = \"Convert a `fail_` enum into an error string\"]\n+/// Convert a `fail_` enum into an error string\n fn fail_str(f: fail_) -> str {\n     ret alt f {\n           argument_missing(nm) { \"Argument to option '\" + nm + \"' missing.\" }\n@@ -175,19 +174,19 @@ fn fail_str(f: fail_) -> str {\n         };\n }\n \n-#[doc = \"\n-The result of parsing a command line with a set of options\n-(result::t<match, fail_>)\n-\"]\n+/**\n+ * The result of parsing a command line with a set of options\n+ * (result::t<match, fail_>)\n+ */\n type result = result::result<match, fail_>;\n \n-#[doc = \"\n-Parse command line arguments according to the provided options\n-\n-On success returns `ok(opt)`. Use functions such as `opt_present` `opt_str`,\n-etc. to interrogate results.  Returns `err(fail_)` on failure. Use <fail_str>\n-to get an error message.\n-\"]\n+/**\n+ * Parse command line arguments according to the provided options\n+ *\n+ * On success returns `ok(opt)`. Use functions such as `opt_present`\n+ * `opt_str`, etc. to interrogate results.  Returns `err(fail_)` on failure.\n+ * Use <fail_str> to get an error message.\n+ */\n fn getopts(args: ~[str], opts: ~[opt]) -> result unsafe {\n     let n_opts = vec::len::<opt>(opts);\n     fn f(_x: uint) -> ~[optval] { ret ~[]; }\n@@ -319,12 +318,12 @@ fn opt_vals(m: match, nm: str) -> ~[optval] {\n \n fn opt_val(m: match, nm: str) -> optval { ret opt_vals(m, nm)[0]; }\n \n-#[doc = \"Returns true if an option was matched\"]\n+/// Returns true if an option was matched\n fn opt_present(m: match, nm: str) -> bool {\n     ret vec::len::<optval>(opt_vals(m, nm)) > 0u;\n }\n \n-#[doc = \"Returns true if any of several options were matched\"]\n+/// Returns true if any of several options were matched\n fn opts_present(m: match, names: ~[str]) -> bool {\n     for vec::each(names) |nm| {\n         alt find_opt(m.opts, mkname(nm)) {\n@@ -336,21 +335,22 @@ fn opts_present(m: match, names: ~[str]) -> bool {\n }\n \n \n-#[doc = \"\n-Returns the string argument supplied to a matching option\n-\n-Fails if the option was not matched or if the match did not take an argument\n-\"]\n+/**\n+ * Returns the string argument supplied to a matching option\n+ *\n+ * Fails if the option was not matched or if the match did not take an\n+ * argument\n+ */\n fn opt_str(m: match, nm: str) -> str {\n     ret alt opt_val(m, nm) { val(s) { s } _ { fail } };\n }\n \n-#[doc = \"\n-Returns the string argument supplied to one of several matching options\n-\n-Fails if the no option was provided from the given list, or if the no such\n-option took an argument\n-\"]\n+/**\n+ * Returns the string argument supplied to one of several matching options\n+ *\n+ * Fails if the no option was provided from the given list, or if the no such\n+ * option took an argument\n+ */\n fn opts_str(m: match, names: ~[str]) -> str {\n     for vec::each(names) |nm| {\n         alt opt_val(m, nm) {\n@@ -362,11 +362,12 @@ fn opts_str(m: match, names: ~[str]) -> str {\n }\n \n \n-#[doc = \"\n-Returns a vector of the arguments provided to all matches of the given option.\n-\n-Used when an option accepts multiple values.\n-\"]\n+/**\n+ * Returns a vector of the arguments provided to all matches of the given\n+ * option.\n+ *\n+ * Used when an option accepts multiple values.\n+ */\n fn opt_strs(m: match, nm: str) -> ~[str] {\n     let mut acc: ~[str] = ~[];\n     for vec::each(opt_vals(m, nm)) |v| {\n@@ -375,23 +376,21 @@ fn opt_strs(m: match, nm: str) -> ~[str] {\n     ret acc;\n }\n \n-#[doc = \"\n-Returns the string argument supplied to a matching option or none\n-\"]\n+/// Returns the string argument supplied to a matching option or none\n fn opt_maybe_str(m: match, nm: str) -> option<str> {\n     let vals = opt_vals(m, nm);\n     if vec::len::<optval>(vals) == 0u { ret none::<str>; }\n     ret alt vals[0] { val(s) { some::<str>(s) } _ { none::<str> } };\n }\n \n \n-#[doc = \"\n-Returns the matching string, a default, or none\n-\n-Returns none if the option was not present, `def` if the option was\n-present but no argument was provided, and the argument if the option was\n-present and an argument was provided.\n-\"]\n+/**\n+ * Returns the matching string, a default, or none\n+ *\n+ * Returns none if the option was not present, `def` if the option was\n+ * present but no argument was provided, and the argument if the option was\n+ * present and an argument was provided.\n+ */\n fn opt_default(m: match, nm: str, def: str) -> option<str> {\n     let vals = opt_vals(m, nm);\n     if vec::len::<optval>(vals) == 0u { ret none::<str>; }"}, {"sha": "9f51ab157b76dcd1b90f4a45963deda0e9d9f893", "filename": "src/libstd/json.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,7 +1,7 @@\n // Rust JSON serialization library\n // Copyright (c) 2011 Google Inc.\n \n-#[doc = \"json serialization\"];\n+//! json serialization\n \n import result::{result, ok, err};\n import io;\n@@ -26,7 +26,7 @@ export list;\n export dict;\n export null;\n \n-#[doc = \"Represents a json value\"]\n+/// Represents a json value\n enum json {\n     num(float),\n     string(@str),\n@@ -42,7 +42,7 @@ type error = {\n     msg: @str,\n };\n \n-#[doc = \"Serializes a json value into a io::writer\"]\n+/// Serializes a json value into a io::writer\n fn to_writer(wr: io::writer, j: json) {\n     alt j {\n       num(n) { wr.write_str(float::to_str(n, 6u)); }\n@@ -109,7 +109,7 @@ fn escape_str(s: str) -> str {\n     escaped\n }\n \n-#[doc = \"Serializes a json value into a string\"]\n+/// Serializes a json value into a string\n fn to_str(j: json) -> str {\n     io::with_str_writer(|wr| to_writer(wr, j))\n }\n@@ -461,7 +461,7 @@ impl parser for parser {\n     }\n }\n \n-#[doc = \"Deserializes a json value from an io::reader\"]\n+/// Deserializes a json value from an io::reader\n fn from_reader(rdr: io::reader) -> result<json, error> {\n     let parser = {\n         rdr: rdr,\n@@ -473,12 +473,12 @@ fn from_reader(rdr: io::reader) -> result<json, error> {\n     parser.parse()\n }\n \n-#[doc = \"Deserializes a json value from a string\"]\n+/// Deserializes a json value from a string\n fn from_str(s: str) -> result<json, error> {\n     io::with_str_reader(s, from_reader)\n }\n \n-#[doc = \"Test if two json values are equal\"]\n+/// Test if two json values are equal\n fn eq(value0: json, value1: json) -> bool {\n     alt (value0, value1) {\n       (num(f0), num(f1)) { f0 == f1 }"}, {"sha": "3a7b0ffd79a25019b22c37253a35612c08a9ac61", "filename": "src/libstd/list.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"A standard linked list\"];\n+//! A standard linked list\n \n import core::option;\n import option::*;\n@@ -9,37 +9,37 @@ enum list<T> {\n     nil,\n }\n \n-#[doc = \"Create a list from a vector\"]\n+/// Create a list from a vector\n fn from_vec<T: copy>(v: &[T]) -> @list<T> {\n     vec::foldr(v, @nil::<T>, |h, t| @cons(h, t))\n }\n \n-#[doc = \"\n-Left fold\n-\n-Applies `f` to `u` and the first element in the list, then applies `f` to the\n-result of the previous call and the second element, and so on, returning the\n-accumulated result.\n-\n-# Arguments\n-\n-* ls - The list to fold\n-* z - The initial value\n-* f - The function to apply\n-\"]\n+/**\n+ * Left fold\n+ *\n+ * Applies `f` to `u` and the first element in the list, then applies `f` to\n+ * the result of the previous call and the second element, and so on,\n+ * returning the accumulated result.\n+ *\n+ * # Arguments\n+ *\n+ * * ls - The list to fold\n+ * * z - The initial value\n+ * * f - The function to apply\n+ */\n fn foldl<T: copy, U>(z: T, ls: @list<U>, f: fn(T, U) -> T) -> T {\n     let mut accum: T = z;\n     do iter(ls) |elt| { accum = f(accum, elt);}\n     accum\n }\n \n-#[doc = \"\n-Search for an element that matches a given predicate\n-\n-Apply function `f` to each element of `v`, starting from the first.\n-When function `f` returns true then an option containing the element\n-is returned. If `f` matches no elements then none is returned.\n-\"]\n+/**\n+ * Search for an element that matches a given predicate\n+ *\n+ * Apply function `f` to each element of `v`, starting from the first.\n+ * When function `f` returns true then an option containing the element\n+ * is returned. If `f` matches no elements then none is returned.\n+ */\n fn find<T: copy>(ls: @list<T>, f: fn(T) -> bool) -> option<T> {\n     let mut ls = ls;\n     loop {\n@@ -53,61 +53,61 @@ fn find<T: copy>(ls: @list<T>, f: fn(T) -> bool) -> option<T> {\n     };\n }\n \n-#[doc = \"Returns true if a list contains an element with the given value\"]\n+/// Returns true if a list contains an element with the given value\n fn has<T: copy>(ls: @list<T>, elt: T) -> bool {\n     for each(ls) |e| {\n         if e == elt { ret true; }\n     }\n     ret false;\n }\n \n-#[doc = \"Returns true if the list is empty\"]\n+/// Returns true if the list is empty\n pure fn is_empty<T: copy>(ls: @list<T>) -> bool {\n     alt *ls {\n         nil { true }\n         _ { false }\n     }\n }\n \n-#[doc = \"Returns true if the list is not empty\"]\n+/// Returns true if the list is not empty\n pure fn is_not_empty<T: copy>(ls: @list<T>) -> bool {\n     ret !is_empty(ls);\n }\n \n-#[doc = \"Returns the length of a list\"]\n+/// Returns the length of a list\n fn len<T>(ls: @list<T>) -> uint {\n     let mut count = 0u;\n     iter(ls, |_e| count += 1u);\n     count\n }\n \n-#[doc = \"Returns all but the first element of a list\"]\n+/// Returns all but the first element of a list\n pure fn tail<T: copy>(ls: @list<T>) -> @list<T> {\n     alt *ls {\n         cons(_, tl) { ret tl; }\n         nil { fail \"list empty\" }\n     }\n }\n \n-#[doc = \"Returns the first element of a list\"]\n+/// Returns the first element of a list\n pure fn head<T: copy>(ls: @list<T>) -> T {\n     alt check *ls { cons(hd, _) { hd } }\n }\n \n-#[doc = \"Appends one list to another\"]\n+/// Appends one list to another\n pure fn append<T: copy>(l: @list<T>, m: @list<T>) -> @list<T> {\n     alt *l {\n       nil { ret m; }\n       cons(x, xs) { let rest = append(xs, m); ret @cons(x, rest); }\n     }\n }\n \n-#[doc = \"Push an element to the front of a list\"]\n+/// Push an element to the front of a list\n fn push<T: copy>(&l: list<T>, v: T) {\n     l = cons(v, @l);\n }\n \n-#[doc = \"Iterate over a list\"]\n+/// Iterate over a list\n fn iter<T>(l: @list<T>, f: fn(T)) {\n     let mut cur = l;\n     loop {\n@@ -121,7 +121,7 @@ fn iter<T>(l: @list<T>, f: fn(T)) {\n     }\n }\n \n-#[doc = \"Iterate over a list\"]\n+/// Iterate over a list\n fn each<T>(l: @list<T>, f: fn(T) -> bool) {\n     let mut cur = l;\n     loop {"}, {"sha": "46f2ca053ad9df0655f1b897a66a6c05965d5701", "filename": "src/libstd/map.rs", "status": "modified", "additions": 45, "deletions": 49, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"A map type\"];\n+//! A map type\n \n import chained::hashmap;\n export hashmap, hashfn, eqfn, set, map, chained, hashmap, str_hash;\n@@ -8,65 +8,65 @@ export hash_from_vec, hash_from_strs, hash_from_bytes;\n export hash_from_ints, hash_from_uints;\n export vec_from_set;\n \n-#[doc = \"\n-A function that returns a hash of a value\n-\n-The hash should concentrate entropy in the lower bits.\n-\"]\n+/**\n+ * A function that returns a hash of a value\n+ *\n+ * The hash should concentrate entropy in the lower bits.\n+ */\n type hashfn<K> = fn@(K) -> uint;\n \n type eqfn<K> = fn@(K, K) -> bool;\n \n-#[doc = \"A convenience type to treat a hashmap as a set\"]\n+/// A convenience type to treat a hashmap as a set\n type set<K> = hashmap<K, ()>;\n \n type hashmap<K, V> = chained::t<K, V>;\n \n iface map<K, V: copy> {\n-    #[doc = \"Return the number of elements in the map\"]\n+    /// Return the number of elements in the map\n     fn size() -> uint;\n \n-    #[doc = \"\n-    Add a value to the map.\n-\n-    If the map already contains a value for the specified key then the\n-    original value is replaced.\n-\n-    Returns true if the key did not already exist in the map\n-    \"]\n+    /**\n+     * Add a value to the map.\n+     *\n+     * If the map already contains a value for the specified key then the\n+     * original value is replaced.\n+     *\n+     * Returns true if the key did not already exist in the map\n+     */\n     fn insert(+K, +V) -> bool;\n \n-    #[doc = \"Returns true if the map contains a value for the specified key\"]\n+    /// Returns true if the map contains a value for the specified key\n     fn contains_key(K) -> bool;\n \n-    #[doc = \"\n-    Get the value for the specified key. Fails if the key does not exist in\n-    the map.\n-    \"]\n+    /**\n+     * Get the value for the specified key. Fails if the key does not exist in\n+     * the map.\n+     */\n     fn get(K) -> V;\n \n-    #[doc = \"Like get, but as an operator.\"]\n+    /// Like get, but as an operator.\n     fn [](K) -> V;\n \n-    #[doc = \"\n-    Get the value for the specified key. If the key does not exist in\n-    the map then returns none.\n-    \"]\n+    /**\n+     * Get the value for the specified key. If the key does not exist in\n+     * the map then returns none.\n+     */\n     fn find(K) -> option<V>;\n \n-    #[doc = \"\n-    Remove and return a value from the map. If the key does not exist\n-    in the map then returns none.\n-    \"]\n+    /**\n+     * Remove and return a value from the map. If the key does not exist\n+     * in the map then returns none.\n+     */\n     fn remove(K) -> option<V>;\n \n-    #[doc = \"Iterate over all the key/value pairs in the map\"]\n+    /// Iterate over all the key/value pairs in the map\n     fn each(fn(K, V) -> bool);\n \n-    #[doc = \"Iterate over all the keys in the map\"]\n+    /// Iterate over all the keys in the map\n     fn each_key(fn(K) -> bool);\n \n-    #[doc = \"Iterate over all the values in the map\"]\n+    /// Iterate over all the values in the map\n     fn each_value(fn(V) -> bool);\n }\n \n@@ -295,41 +295,37 @@ fn hashmap<K: const, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>)\n     chained::mk(hasher, eqer)\n }\n \n-#[doc = \"Construct a hashmap for string keys\"]\n+/// Construct a hashmap for string keys\n fn str_hash<V: copy>() -> hashmap<str, V> {\n     ret hashmap(str::hash, str::eq);\n }\n \n-#[doc = \"Construct a hashmap for boxed string keys\"]\n+/// Construct a hashmap for boxed string keys\n fn box_str_hash<V: copy>() -> hashmap<@str, V> {\n     ret hashmap(|x: @str| str::hash(*x), |x,y| str::eq(*x,*y));\n }\n \n-#[doc = \"Construct a hashmap for byte string keys\"]\n+/// Construct a hashmap for byte string keys\n fn bytes_hash<V: copy>() -> hashmap<~[u8], V> {\n     ret hashmap(vec::u8::hash, vec::u8::eq);\n }\n \n-#[doc = \"Construct a hashmap for int keys\"]\n+/// Construct a hashmap for int keys\n fn int_hash<V: copy>() -> hashmap<int, V> {\n     ret hashmap(int::hash, int::eq);\n }\n \n-#[doc = \"Construct a hashmap for uint keys\"]\n+/// Construct a hashmap for uint keys\n fn uint_hash<V: copy>() -> hashmap<uint, V> {\n     ret hashmap(uint::hash, uint::eq);\n }\n \n-#[doc = \"\n-Convenience function for adding keys to a hashmap with nil type keys\n-\"]\n+/// Convenience function for adding keys to a hashmap with nil type keys\n fn set_add<K: const copy>(set: set<K>, key: K) -> bool {\n     ret set.insert(key, ());\n }\n \n-#[doc = \"\n-Convert a set into a vector.\n-\"]\n+/// Convert a set into a vector.\n fn vec_from_set<T: copy>(s: set<T>) -> ~[T] {\n     let mut v = ~[];\n     do s.each_key() |k| {\n@@ -339,7 +335,7 @@ fn vec_from_set<T: copy>(s: set<T>) -> ~[T] {\n     v\n }\n \n-#[doc = \"Construct a hashmap from a vector\"]\n+/// Construct a hashmap from a vector\n fn hash_from_vec<K: const copy, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>,\n                                          items: ~[(K, V)]) -> hashmap<K, V> {\n     let map = hashmap(hasher, eqer);\n@@ -350,22 +346,22 @@ fn hash_from_vec<K: const copy, V: copy>(hasher: hashfn<K>, eqer: eqfn<K>,\n     map\n }\n \n-#[doc = \"Construct a hashmap from a vector with string keys\"]\n+/// Construct a hashmap from a vector with string keys\n fn hash_from_strs<V: copy>(items: ~[(str, V)]) -> hashmap<str, V> {\n     hash_from_vec(str::hash, str::eq, items)\n }\n \n-#[doc = \"Construct a hashmap from a vector with byte keys\"]\n+/// Construct a hashmap from a vector with byte keys\n fn hash_from_bytes<V: copy>(items: ~[(~[u8], V)]) -> hashmap<~[u8], V> {\n     hash_from_vec(vec::u8::hash, vec::u8::eq, items)\n }\n \n-#[doc = \"Construct a hashmap from a vector with int keys\"]\n+/// Construct a hashmap from a vector with int keys\n fn hash_from_ints<V: copy>(items: ~[(int, V)]) -> hashmap<int, V> {\n     hash_from_vec(int::hash, int::eq, items)\n }\n \n-#[doc = \"Construct a hashmap from a vector with uint keys\"]\n+/// Construct a hashmap from a vector with uint keys\n fn hash_from_uints<V: copy>(items: ~[(uint, V)]) -> hashmap<uint, V> {\n     hash_from_vec(uint::hash, uint::eq, items)\n }"}, {"sha": "8b71de2632eeeccd3a0d371d37c6fc3c572e0701", "filename": "src/libstd/net.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,6 +1,4 @@\n-#[doc=\"\n-Top-level module for network-related functionality\n-\"];\n+//! Top-level module for network-related functionality\n \n import tcp = net_tcp;\n export tcp;"}, {"sha": "2353a983dc2bd054c5c296e479a70e80d3c526d6", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 56, "deletions": 62, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,6 +1,4 @@\n-#[doc=\"\n-Types/fns concerning Internet Protocol (IP), versions 4 & 6\n-\"];\n+//! Types/fns concerning Internet Protocol (IP), versions 4 & 6\n \n import vec;\n import uint;\n@@ -28,27 +26,25 @@ export format_addr;\n export v4, v6;\n export get_addr;\n \n-#[doc = \"An IP address\"]\n+/// An IP address\n enum ip_addr {\n-    #[doc=\"An IPv4 address\"]\n+    /// An IPv4 address\n     ipv4(sockaddr_in),\n     ipv6(sockaddr_in6)\n }\n \n-#[doc=\"\n-Human-friendly feedback on why a parse_addr attempt failed\n-\"]\n+/// Human-friendly feedback on why a parse_addr attempt failed\n type parse_addr_err = {\n     err_msg: str\n };\n \n-#[doc=\"\n-Convert a `ip_addr` to a str\n-\n-# Arguments\n-\n-* ip - a `std::net::ip::ip_addr`\n-\"]\n+/**\n+ * Convert a `ip_addr` to a str\n+ *\n+ * # Arguments\n+ *\n+ * * ip - a `std::net::ip::ip_addr`\n+ */\n fn format_addr(ip: ip_addr) -> str {\n     alt ip {\n       ipv4(addr) {\n@@ -72,27 +68,25 @@ fn format_addr(ip: ip_addr) -> str {\n     }\n }\n \n-#[doc=\"\n-Represents errors returned from `net::ip::get_addr()`\n-\"]\n+/// Represents errors returned from `net::ip::get_addr()`\n enum ip_get_addr_err {\n     get_addr_unknown_error\n }\n \n-#[doc=\"\n-Attempts name resolution on the provided `node` string\n-\n-# Arguments\n-\n-* `node` - a string representing some host address\n-* `iotask` - a `uv::iotask` used to interact with the underlying event loop\n-\n-# Returns\n-\n-A `result<[ip_addr]/~, ip_get_addr_err>` instance that will contain\n-a vector of `ip_addr` results, in the case of success, or an error\n-object in the case of failure\n-\"]\n+/**\n+ * Attempts name resolution on the provided `node` string\n+ *\n+ * # Arguments\n+ *\n+ * * `node` - a string representing some host address\n+ * * `iotask` - a `uv::iotask` used to interact with the underlying event loop\n+ *\n+ * # Returns\n+ *\n+ * A `result<[ip_addr]/~, ip_get_addr_err>` instance that will contain\n+ * a vector of `ip_addr` results, in the case of success, or an error\n+ * object in the case of failure\n+ */\n fn get_addr(++node: str, iotask: iotask)\n         -> result::result<[ip_addr]/~, ip_get_addr_err> unsafe {\n     do comm::listen |output_ch| {\n@@ -127,21 +121,21 @@ fn get_addr(++node: str, iotask: iotask)\n }\n \n mod v4 {\n-    #[doc = \"\n-    Convert a str to `ip_addr`\n-\n-    # Failure\n-\n-    Fails if the string is not a valid IPv4 address\n-\n-    # Arguments\n-\n-    * ip - a string of the format `x.x.x.x`\n-\n-    # Returns\n-\n-    * an `ip_addr` of the `ipv4` variant\n-    \"]\n+    /**\n+     * Convert a str to `ip_addr`\n+     *\n+     * # Failure\n+     *\n+     * Fails if the string is not a valid IPv4 address\n+     *\n+     * # Arguments\n+     *\n+     * * ip - a string of the format `x.x.x.x`\n+     *\n+     * # Returns\n+     *\n+     * * an `ip_addr` of the `ipv4` variant\n+     */\n     fn parse_addr(ip: str) -> ip_addr {\n         alt try_parse_addr(ip) {\n           result::ok(addr) { copy(addr) }\n@@ -210,21 +204,21 @@ mod v4 {\n     }\n }\n mod v6 {\n-    #[doc = \"\n-    Convert a str to `ip_addr`\n-\n-    # Failure\n-\n-    Fails if the string is not a valid IPv6 address\n-\n-    # Arguments\n-\n-    * ip - an ipv6 string. See RFC2460 for spec.\n-\n-    # Returns\n-\n-    * an `ip_addr` of the `ipv6` variant\n-    \"]\n+    /**\n+     * Convert a str to `ip_addr`\n+     *\n+     * # Failure\n+     *\n+     * Fails if the string is not a valid IPv6 address\n+     *\n+     * # Arguments\n+     *\n+     * * ip - an ipv6 string. See RFC2460 for spec.\n+     *\n+     * # Returns\n+     *\n+     * * an `ip_addr` of the `ipv6` variant\n+     */\n     fn parse_addr(ip: str) -> ip_addr {\n         alt try_parse_addr(ip) {\n           result::ok(addr) { copy(addr) }"}, {"sha": "128490048dbca3ce6da51a8c19ade465482cd512", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 284, "deletions": 296, "changes": 580, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,6 +1,4 @@\n-#[doc=\"\n-High-level interface to libuv's TCP functionality\n-\"];\n+//! High-level interface to libuv's TCP functionality\n \n import ip = net_ip;\n import uv::iotask;\n@@ -34,13 +32,13 @@ extern mod rustrt {\n     fn rust_uv_helper_uv_tcp_t_size() -> libc::c_uint;\n }\n \n-#[doc=\"\n-Encapsulates an open TCP/IP connection through libuv\n-\n-`tcp_socket` is non-copyable/sendable and automagically handles closing the\n-underlying libuv data structures when it goes out of scope. This is the\n-data structure that is used for read/write operations over a TCP stream.\n-\"]\n+/**\n+ * Encapsulates an open TCP/IP connection through libuv\n+ *\n+ * `tcp_socket` is non-copyable/sendable and automagically handles closing the\n+ * underlying libuv data structures when it goes out of scope. This is the\n+ * data structure that is used for read/write operations over a TCP stream.\n+ */\n class tcp_socket {\n   let socket_data: @tcp_socket_data;\n   new(socket_data: @tcp_socket_data) { self.socket_data = socket_data; }\n@@ -51,84 +49,76 @@ class tcp_socket {\n   }\n }\n \n-#[doc=\"\n-A buffered wrapper for `net::tcp::tcp_socket`\n-\n-It is created with a call to `net::tcp::socket_buf()` and has impls that\n-satisfy both the `io::reader` and `io::writer` ifaces.\n-\"]\n+/**\n+ * A buffered wrapper for `net::tcp::tcp_socket`\n+ *\n+ * It is created with a call to `net::tcp::socket_buf()` and has impls that\n+ * satisfy both the `io::reader` and `io::writer` ifaces.\n+ */\n class tcp_socket_buf {\n   let data: @tcp_buffered_socket_data;\n   new(data: @tcp_buffered_socket_data) { self.data = data; }\n }\n \n-#[doc=\"\n-Contains raw, string-based, error information returned from libuv\n-\"]\n+/// Contains raw, string-based, error information returned from libuv\n type tcp_err_data = {\n     err_name: str,\n     err_msg: str\n };\n-#[doc=\"\n-Details returned as part of a `result::err` result from `tcp::listen`\n-\"]\n+/// Details returned as part of a `result::err` result from `tcp::listen`\n enum tcp_listen_err_data {\n-    #[doc=\"\n-    Some unplanned-for error. The first and second fields correspond\n-    to libuv's `err_name` and `err_msg` fields, respectively.\n-    \"]\n+    /**\n+     * Some unplanned-for error. The first and second fields correspond\n+     * to libuv's `err_name` and `err_msg` fields, respectively.\n+     */\n     generic_listen_err(str, str),\n-    #[doc=\"\n-    Failed to bind to the requested IP/Port, because it is already in use.\n-\n-    # Possible Causes\n-\n-    * Attempting to bind to a port already bound to another listener\n-    \"]\n+    /**\n+     * Failed to bind to the requested IP/Port, because it is already in use.\n+     *\n+     * # Possible Causes\n+     *\n+     * * Attempting to bind to a port already bound to another listener\n+     */\n     address_in_use,\n-    #[doc=\"\n-    Request to bind to an IP/Port was denied by the system.\n-\n-    # Possible Causes\n-\n-    * Attemping to binding to an IP/Port as a non-Administrator\n-      on Windows Vista+\n-    * Attempting to bind, as a non-priv'd\n-      user, to 'privileged' ports (< 1024) on *nix\n-    \"]\n+    /**\n+     * Request to bind to an IP/Port was denied by the system.\n+     *\n+     * # Possible Causes\n+     *\n+     * * Attemping to binding to an IP/Port as a non-Administrator\n+     *   on Windows Vista+\n+     * * Attempting to bind, as a non-priv'd\n+     *   user, to 'privileged' ports (< 1024) on *nix\n+     */\n     access_denied\n }\n-#[doc=\"\n-Details returned as part of a `result::err` result from `tcp::connect`\n-\"]\n+/// Details returned as part of a `result::err` result from `tcp::connect`\n enum tcp_connect_err_data {\n-    #[doc=\"\n-    Some unplanned-for error. The first and second fields correspond\n-    to libuv's `err_name` and `err_msg` fields, respectively.\n-    \"]\n+    /**\n+     * Some unplanned-for error. The first and second fields correspond\n+     * to libuv's `err_name` and `err_msg` fields, respectively.\n+     */\n     generic_connect_err(str, str),\n-    #[doc=\"\n-    Invalid IP or invalid port\n-    \"]\n+    /// Invalid IP or invalid port\n     connection_refused\n }\n \n-#[doc=\"\n-Initiate a client connection over TCP/IP\n-\n-# Arguments\n-\n-* `input_ip` - The IP address (versions 4 or 6) of the remote host\n-* `port` - the unsigned integer of the desired remote host port\n-* `iotask` - a `uv::iotask` that the tcp request will run on\n-\n-# Returns\n-\n-A `result` that, if the operation succeeds, contains a `net::net::tcp_socket`\n-that can be used to send and receive data to/from the remote host. In the\n-event of failure, a `net::tcp::tcp_connect_err_data` instance will be\n-returned\n-\"]\n+/**\n+ * Initiate a client connection over TCP/IP\n+ *\n+ * # Arguments\n+ *\n+ * * `input_ip` - The IP address (versions 4 or 6) of the remote host\n+ * * `port` - the unsigned integer of the desired remote host port\n+ * * `iotask` - a `uv::iotask` that the tcp request will run on\n+ *\n+ * # Returns\n+ *\n+ * A `result` that, if the operation succeeds, contains a\n+ * `net::net::tcp_socket` that can be used to send and receive data to/from\n+ * the remote host. In the event of failure, a\n+ * `net::tcp::tcp_connect_err_data` instance will be returned\n+ */\n fn connect(-input_ip: ip::ip_addr, port: uint,\n            iotask: iotask)\n     -> result::result<tcp_socket, tcp_connect_err_data> unsafe {\n@@ -252,56 +242,57 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n     }\n }\n \n-#[doc=\"\n-Write binary data to a tcp stream; Blocks until operation completes\n-\n-# Arguments\n-\n-* sock - a `tcp_socket` to write to\n-* raw_write_data - a vector of `[u8]/~` that will be written to the stream.\n-This value must remain valid for the duration of the `write` call\n-\n-# Returns\n-\n-A `result` object with a `nil` value as the `ok` variant, or a `tcp_err_data`\n-value as the `err` variant\n-\"]\n+/**\n+ * Write binary data to a tcp stream; Blocks until operation completes\n+ *\n+ * # Arguments\n+ *\n+ * * sock - a `tcp_socket` to write to\n+ * * raw_write_data - a vector of `[u8]/~` that will be written to the stream.\n+ * This value must remain valid for the duration of the `write` call\n+ *\n+ * # Returns\n+ *\n+ * A `result` object with a `nil` value as the `ok` variant, or a\n+ * `tcp_err_data` value as the `err` variant\n+ */\n fn write(sock: tcp_socket, raw_write_data: ~[u8])\n     -> result::result<(), tcp_err_data> unsafe {\n     let socket_data_ptr = ptr::addr_of(*(sock.socket_data));\n     write_common_impl(socket_data_ptr, raw_write_data)\n }\n \n-#[doc=\"\n-Write binary data to tcp stream; Returns a `future::future` value immediately\n-\n-# Safety\n-\n-This function can produce unsafe results if:\n-\n-1. the call to `write_future` is made\n-2. the `future::future` value returned is never resolved via\n-`future::get`\n-3. and then the `tcp_socket` passed in to `write_future` leaves\n-scope and is destructed before the task that runs the libuv write\n-operation completes.\n-\n-As such: If using `write_future`, always be sure to resolve the returned\n-`future` so as to ensure libuv doesn't try to access a released write handle.\n-Otherwise, use the blocking `tcp::write` function instead.\n-\n-# Arguments\n-\n-* sock - a `tcp_socket` to write to\n-* raw_write_data - a vector of `[u8]/~` that will be written to the stream.\n-This value must remain valid for the duration of the `write` call\n-\n-# Returns\n-\n-A `future` value that, once the `write` operation completes, resolves to a\n-`result` object with a `nil` value as the `ok` variant, or a `tcp_err_data`\n-value as the `err` variant\n-\"]\n+/**\n+ * Write binary data to tcp stream; Returns a `future::future` value\n+ * immediately\n+ *\n+ * # Safety\n+ *\n+ * This function can produce unsafe results if:\n+ *\n+ * 1. the call to `write_future` is made\n+ * 2. the `future::future` value returned is never resolved via\n+ * `future::get`\n+ * 3. and then the `tcp_socket` passed in to `write_future` leaves\n+ * scope and is destructed before the task that runs the libuv write\n+ * operation completes.\n+ *\n+ * As such: If using `write_future`, always be sure to resolve the returned\n+ * `future` so as to ensure libuv doesn't try to access a released write\n+ * handle. Otherwise, use the blocking `tcp::write` function instead.\n+ *\n+ * # Arguments\n+ *\n+ * * sock - a `tcp_socket` to write to\n+ * * raw_write_data - a vector of `[u8]/~` that will be written to the stream.\n+ * This value must remain valid for the duration of the `write` call\n+ *\n+ * # Returns\n+ *\n+ * A `future` value that, once the `write` operation completes, resolves to a\n+ * `result` object with a `nil` value as the `ok` variant, or a `tcp_err_data`\n+ * value as the `err` variant\n+ */\n fn write_future(sock: tcp_socket, raw_write_data: ~[u8])\n     -> future::future<result::result<(), tcp_err_data>> unsafe {\n     let socket_data_ptr = ptr::addr_of(*(sock.socket_data));\n@@ -311,33 +302,34 @@ fn write_future(sock: tcp_socket, raw_write_data: ~[u8])\n     }\n }\n \n-#[doc=\"\n-Begin reading binary data from an open TCP connection; used with `read_stop`\n-\n-# Arguments\n-\n-* sock -- a `net::tcp::tcp_socket` for the connection to read from\n-\n-# Returns\n-\n-* A `result` instance that will either contain a\n-`comm::port<tcp_read_result>` that the user can read (and optionally, loop\n-on) from until `read_stop` is called, or a `tcp_err_data` record\n-\"]\n+/**\n+ * Begin reading binary data from an open TCP connection; used with\n+ * `read_stop`\n+ *\n+ * # Arguments\n+ *\n+ * * sock -- a `net::tcp::tcp_socket` for the connection to read from\n+ *\n+ * # Returns\n+ *\n+ * * A `result` instance that will either contain a\n+ * `comm::port<tcp_read_result>` that the user can read (and optionally, loop\n+ * on) from until `read_stop` is called, or a `tcp_err_data` record\n+ */\n fn read_start(sock: tcp_socket)\n     -> result::result<comm::port<\n         result::result<~[u8], tcp_err_data>>, tcp_err_data> unsafe {\n     let socket_data = ptr::addr_of(*(sock.socket_data));\n     read_start_common_impl(socket_data)\n }\n \n-#[doc=\"\n-Stop reading from an open TCP connection; used with `read_start`\n-\n-# Arguments\n-\n-* `sock` - a `net::tcp::tcp_socket` that you wish to stop reading on\n-\"]\n+/**\n+ * Stop reading from an open TCP connection; used with `read_start`\n+ *\n+ * # Arguments\n+ *\n+ * * `sock` - a `net::tcp::tcp_socket` that you wish to stop reading on\n+ */\n fn read_stop(sock: tcp_socket,\n              -read_port: comm::port<result::result<[u8]/~, tcp_err_data>>) ->\n     result::result<(), tcp_err_data> unsafe {\n@@ -346,54 +338,56 @@ fn read_stop(sock: tcp_socket,\n     read_stop_common_impl(socket_data)\n }\n \n-#[doc=\"\n-Reads a single chunk of data from `tcp_socket`; block until data/error recv'd\n-\n-Does a blocking read operation for a single chunk of data from a `tcp_socket`\n-until a data arrives or an error is received. The provided `timeout_msecs`\n-value is used to raise an error if the timeout period passes without any\n-data received.\n-\n-# Arguments\n-\n-* `sock` - a `net::tcp::tcp_socket` that you wish to read from\n-* `timeout_msecs` - a `uint` value, in msecs, to wait before dropping the\n-read attempt. Pass `0u` to wait indefinitely\n-\"]\n+/**\n+ * Reads a single chunk of data from `tcp_socket`; block until data/error\n+ * recv'd\n+ *\n+ * Does a blocking read operation for a single chunk of data from a\n+ * `tcp_socket` until a data arrives or an error is received. The provided\n+ * `timeout_msecs` value is used to raise an error if the timeout period\n+ * passes without any data received.\n+ *\n+ * # Arguments\n+ *\n+ * * `sock` - a `net::tcp::tcp_socket` that you wish to read from\n+ * * `timeout_msecs` - a `uint` value, in msecs, to wait before dropping the\n+ * read attempt. Pass `0u` to wait indefinitely\n+ */\n fn read(sock: tcp_socket, timeout_msecs: uint)\n     -> result::result<~[u8],tcp_err_data> {\n     let socket_data = ptr::addr_of(*(sock.socket_data));\n     read_common_impl(socket_data, timeout_msecs)\n }\n \n-#[doc=\"\n-Reads a single chunk of data; returns a `future::future<[u8]/~>` immediately\n-\n-Does a non-blocking read operation for a single chunk of data from a\n-`tcp_socket` and immediately returns a `future` value representing the\n-result. When resolving the returned `future`, it will block until data\n-arrives or an error is received. The provided `timeout_msecs`\n-value is used to raise an error if the timeout period passes without any\n-data received.\n-\n-# Safety\n-\n-This function can produce unsafe results if the call to `read_future` is\n-made, the `future::future` value returned is never resolved via\n-`future::get`, and then the `tcp_socket` passed in to `read_future` leaves\n-scope and is destructed before the task that runs the libuv read\n-operation completes.\n-\n-As such: If using `read_future`, always be sure to resolve the returned\n-`future` so as to ensure libuv doesn't try to access a released read handle.\n-Otherwise, use the blocking `tcp::read` function instead.\n-\n-# Arguments\n-\n-* `sock` - a `net::tcp::tcp_socket` that you wish to read from\n-* `timeout_msecs` - a `uint` value, in msecs, to wait before dropping the\n-read attempt. Pass `0u` to wait indefinitely\n-\"]\n+/**\n+ * Reads a single chunk of data; returns a `future::future<[u8]/~>`\n+ * immediately\n+ *\n+ * Does a non-blocking read operation for a single chunk of data from a\n+ * `tcp_socket` and immediately returns a `future` value representing the\n+ * result. When resolving the returned `future`, it will block until data\n+ * arrives or an error is received. The provided `timeout_msecs`\n+ * value is used to raise an error if the timeout period passes without any\n+ * data received.\n+ *\n+ * # Safety\n+ *\n+ * This function can produce unsafe results if the call to `read_future` is\n+ * made, the `future::future` value returned is never resolved via\n+ * `future::get`, and then the `tcp_socket` passed in to `read_future` leaves\n+ * scope and is destructed before the task that runs the libuv read\n+ * operation completes.\n+ *\n+ * As such: If using `read_future`, always be sure to resolve the returned\n+ * `future` so as to ensure libuv doesn't try to access a released read\n+ * handle. Otherwise, use the blocking `tcp::read` function instead.\n+ *\n+ * # Arguments\n+ *\n+ * * `sock` - a `net::tcp::tcp_socket` that you wish to read from\n+ * * `timeout_msecs` - a `uint` value, in msecs, to wait before dropping the\n+ * read attempt. Pass `0u` to wait indefinitely\n+ */\n fn read_future(sock: tcp_socket, timeout_msecs: uint)\n     -> future::future<result::result<~[u8],tcp_err_data>> {\n     let socket_data = ptr::addr_of(*(sock.socket_data));\n@@ -402,75 +396,75 @@ fn read_future(sock: tcp_socket, timeout_msecs: uint)\n     }\n }\n \n-#[doc=\"\n-Bind an incoming client connection to a `net::tcp::tcp_socket`\n-\n-# Notes\n-\n-It is safe to call `net::tcp::accept` _only_ within the context of the\n-`new_connect_cb` callback provided as the final argument to the\n-`net::tcp::listen` function.\n-\n-The `new_conn` opaque value is provided _only_ as the first argument to the\n-`new_connect_cb` provided as a part of `net::tcp::listen`.\n-It can be safely sent to another task but it _must_ be\n-used (via `net::tcp::accept`) before the `new_connect_cb` call it was\n-provided to returns.\n-\n-This implies that a port/chan pair must be used to make sure that the\n-`new_connect_cb` call blocks until an attempt to create a\n-`net::tcp::tcp_socket` is completed.\n-\n-# Example\n-\n-Here, the `new_conn` is used in conjunction with `accept` from within\n-a task spawned by the `new_connect_cb` passed into `listen`\n-\n-~~~~~~~~~~~\n-net::tcp::listen(remote_ip, remote_port, backlog)\n-    // this callback is ran once after the connection is successfully\n-    // set up\n-    {|kill_ch|\n-      // pass the kill_ch to your main loop or wherever you want\n-      // to be able to externally kill the server from\n-    }\n-    // this callback is ran when a new connection arrives\n-    {|new_conn, kill_ch|\n-    let cont_po = comm::port::<option<tcp_err_data>>();\n-    let cont_ch = comm::chan(cont_po);\n-    task::spawn {||\n-        let accept_result = net::tcp::accept(new_conn);\n-        if accept_result.is_err() {\n-            comm::send(cont_ch, result::get_err(accept_result));\n-            // fail?\n-        }\n-        else {\n-            let sock = result::get(accept_result);\n-            comm::send(cont_ch, true);\n-            // do work here\n-        }\n-    };\n-    alt comm::recv(cont_po) {\n-      // shut down listen()\n-      some(err_data) { comm::send(kill_chan, some(err_data)) }\n-      // wait for next connection\n-      none {}\n-    }\n-};\n-~~~~~~~~~~~\n-\n-# Arguments\n-\n-* `new_conn` - an opaque value used to create a new `tcp_socket`\n-\n-# Returns\n-\n-On success, this function will return a `net::tcp::tcp_socket` as the\n-`ok` variant of a `result`. The `net::tcp::tcp_socket` is anchored within\n-the task that `accept` was called within for its lifetime. On failure,\n-this function will return a `net::tcp::tcp_err_data` record\n-as the `err` variant of a `result`.\n-\"]\n+/**\n+ * Bind an incoming client connection to a `net::tcp::tcp_socket`\n+ *\n+ * # Notes\n+ *\n+ * It is safe to call `net::tcp::accept` _only_ within the context of the\n+ * `new_connect_cb` callback provided as the final argument to the\n+ * `net::tcp::listen` function.\n+ *\n+ * The `new_conn` opaque value is provided _only_ as the first argument to the\n+ * `new_connect_cb` provided as a part of `net::tcp::listen`.\n+ * It can be safely sent to another task but it _must_ be\n+ * used (via `net::tcp::accept`) before the `new_connect_cb` call it was\n+ * provided to returns.\n+ *\n+ * This implies that a port/chan pair must be used to make sure that the\n+ * `new_connect_cb` call blocks until an attempt to create a\n+ * `net::tcp::tcp_socket` is completed.\n+ *\n+ * # Example\n+ *\n+ * Here, the `new_conn` is used in conjunction with `accept` from within\n+ * a task spawned by the `new_connect_cb` passed into `listen`\n+ *\n+ * ~~~~~~~~~~~\n+ * net::tcp::listen(remote_ip, remote_port, backlog)\n+ *     // this callback is ran once after the connection is successfully\n+ *     // set up\n+ *     {|kill_ch|\n+ *       // pass the kill_ch to your main loop or wherever you want\n+ *       // to be able to externally kill the server from\n+ *     }\n+ *     // this callback is ran when a new connection arrives\n+ *     {|new_conn, kill_ch|\n+ *     let cont_po = comm::port::<option<tcp_err_data>>();\n+ *     let cont_ch = comm::chan(cont_po);\n+ *     task::spawn {||\n+ *         let accept_result = net::tcp::accept(new_conn);\n+ *         if accept_result.is_err() {\n+ *             comm::send(cont_ch, result::get_err(accept_result));\n+ *             // fail?\n+ *         }\n+ *         else {\n+ *             let sock = result::get(accept_result);\n+ *             comm::send(cont_ch, true);\n+ *             // do work here\n+ *         }\n+ *     };\n+ *     alt comm::recv(cont_po) {\n+ *       // shut down listen()\n+ *       some(err_data) { comm::send(kill_chan, some(err_data)) }\n+ *       // wait for next connection\n+ *       none {}\n+ *     }\n+ * };\n+ * ~~~~~~~~~~~\n+ *\n+ * # Arguments\n+ *\n+ * * `new_conn` - an opaque value used to create a new `tcp_socket`\n+ *\n+ * # Returns\n+ *\n+ * On success, this function will return a `net::tcp::tcp_socket` as the\n+ * `ok` variant of a `result`. The `net::tcp::tcp_socket` is anchored within\n+ * the task that `accept` was called within for its lifetime. On failure,\n+ * this function will return a `net::tcp::tcp_err_data` record\n+ * as the `err` variant of a `result`.\n+ */\n fn accept(new_conn: tcp_new_connection)\n     -> result::result<tcp_socket, tcp_err_data> unsafe {\n \n@@ -545,34 +539,34 @@ fn accept(new_conn: tcp_new_connection)\n     }\n }\n \n-#[doc=\"\n-Bind to a given IP/port and listen for new connections\n-\n-# Arguments\n-\n-* `host_ip` - a `net::ip::ip_addr` representing a unique IP\n-(versions 4 or 6)\n-* `port` - a uint representing the port to listen on\n-* `backlog` - a uint representing the number of incoming connections\n-to cache in memory\n-* `hl_loop` - a `uv::hl::high_level_loop` that the tcp request will run on\n-* `on_establish_cb` - a callback that is evaluated if/when the listener\n-is successfully established. it takes no parameters\n-* `new_connect_cb` - a callback to be evaluated, on the libuv thread,\n-whenever a client attempts to conect on the provided ip/port. the\n-callback's arguments are:\n-    * `new_conn` - an opaque type that can be passed to\n-    `net::tcp::accept` in order to be converted to a `tcp_socket`.\n-    * `kill_ch` - channel of type `comm::chan<option<tcp_err_data>>`. this\n-    channel can be used to send a message to cause `listen` to begin\n-    closing the underlying libuv data structures.\n-\n-# returns\n-\n-a `result` instance containing empty data of type `()` on a\n-successful/normal shutdown, and a `tcp_listen_err_data` enum in the event\n-of listen exiting because of an error\n-\"]\n+/**\n+ * Bind to a given IP/port and listen for new connections\n+ *\n+ * # Arguments\n+ *\n+ * * `host_ip` - a `net::ip::ip_addr` representing a unique IP\n+ * (versions 4 or 6)\n+ * * `port` - a uint representing the port to listen on\n+ * * `backlog` - a uint representing the number of incoming connections\n+ * to cache in memory\n+ * * `hl_loop` - a `uv::hl::high_level_loop` that the tcp request will run on\n+ * * `on_establish_cb` - a callback that is evaluated if/when the listener\n+ * is successfully established. it takes no parameters\n+ * * `new_connect_cb` - a callback to be evaluated, on the libuv thread,\n+ * whenever a client attempts to conect on the provided ip/port. the\n+ * callback's arguments are:\n+ *     * `new_conn` - an opaque type that can be passed to\n+ *     `net::tcp::accept` in order to be converted to a `tcp_socket`.\n+ *     * `kill_ch` - channel of type `comm::chan<option<tcp_err_data>>`. this\n+ *     channel can be used to send a message to cause `listen` to begin\n+ *     closing the underlying libuv data structures.\n+ *\n+ * # returns\n+ *\n+ * a `result` instance containing empty data of type `()` on a\n+ * successful/normal shutdown, and a `tcp_listen_err_data` enum in the event\n+ * of listen exiting because of an error\n+ */\n fn listen(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n           iotask: iotask,\n           on_establish_cb: fn~(comm::chan<option<tcp_err_data>>),\n@@ -721,28 +715,26 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n     }\n }\n \n-#[doc=\"\n-Convert a `net::tcp::tcp_socket` to a `net::tcp::tcp_socket_buf`.\n-\n-This function takes ownership of a `net::tcp::tcp_socket`, returning it\n-stored within a buffered wrapper, which can be converted to a `io::reader`\n-or `io::writer`\n-\n-# Arguments\n-\n-* `sock` -- a `net::tcp::tcp_socket` that you want to buffer\n-\n-# Returns\n-\n-A buffered wrapper that you can cast as an `io::reader` or `io::writer`\n-\"]\n+/**\n+ * Convert a `net::tcp::tcp_socket` to a `net::tcp::tcp_socket_buf`.\n+ *\n+ * This function takes ownership of a `net::tcp::tcp_socket`, returning it\n+ * stored within a buffered wrapper, which can be converted to a `io::reader`\n+ * or `io::writer`\n+ *\n+ * # Arguments\n+ *\n+ * * `sock` -- a `net::tcp::tcp_socket` that you want to buffer\n+ *\n+ * # Returns\n+ *\n+ * A buffered wrapper that you can cast as an `io::reader` or `io::writer`\n+ */\n fn socket_buf(-sock: tcp_socket) -> tcp_socket_buf {\n     tcp_socket_buf(@{ sock: sock, mut buf: []/~ })\n }\n \n-#[doc=\"\n-Convenience methods extending `net::tcp::tcp_socket`\n-\"]\n+/// Convenience methods extending `net::tcp::tcp_socket`\n impl tcp_socket for tcp_socket {\n     fn read_start() -> result::result<comm::port<\n         result::result<~[u8], tcp_err_data>>, tcp_err_data> {\n@@ -771,9 +763,7 @@ impl tcp_socket for tcp_socket {\n     }\n }\n \n-#[doc=\"\n-Implementation of `io::reader` iface for a buffered `net::tcp::tcp_socket`\n-\"]\n+/// Implementation of `io::reader` iface for a buffered `net::tcp::tcp_socket`\n impl tcp_socket_buf of io::reader for @tcp_socket_buf {\n     fn read_bytes(amt: uint) -> [u8]/~ {\n         let has_amt_available =\n@@ -819,9 +809,7 @@ impl tcp_socket_buf of io::reader for @tcp_socket_buf {\n     }\n }\n \n-#[doc=\"\n-Implementation of `io::reader` iface for a buffered `net::tcp::tcp_socket`\n-\"]\n+/// Implementation of `io::reader` iface for a buffered `net::tcp::tcp_socket`\n impl tcp_socket_buf of io::writer for @tcp_socket_buf {\n     fn write(data: [const u8]/&) unsafe {\n         let socket_data_ptr ="}, {"sha": "9bf6a0212828a354e5d8151697910288a7743f6b", "filename": "src/libstd/par.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -8,18 +8,22 @@ import core::vec::extensions;\n \n export map, mapi, alli, any, mapi_factory;\n \n-#[doc=\"The maximum number of tasks this module will spawn for a single\n-operation.\"]\n+/**\n+ * The maximum number of tasks this module will spawn for a single\n+ * operation.\n+ */\n const max_tasks : uint = 32u;\n \n-#[doc=\"The minimum number of elements each task will process.\"]\n+/// The minimum number of elements each task will process.\n const min_granularity : uint = 1024u;\n \n-#[doc=\"An internal helper to map a function over a large vector and\n-return the intermediate results.\n-\n-This is used to build most of the other parallel vector functions,\n-like map or alli.\"]\n+/**\n+ * An internal helper to map a function over a large vector and\n+ * return the intermediate results.\n+ *\n+ * This is used to build most of the other parallel vector functions,\n+ * like map or alli.\n+ */\n fn map_slices<A: copy send, B: copy send>(\n     xs: ~[A],\n     f: fn() -> fn~(uint, v: &[A]) -> B)\n@@ -75,7 +79,7 @@ fn map_slices<A: copy send, B: copy send>(\n     }\n }\n \n-#[doc=\"A parallel version of map.\"]\n+/// A parallel version of map.\n fn map<A: copy send, B: copy send>(xs: ~[A], f: fn~(A) -> B) -> ~[B] {\n     vec::concat(map_slices(xs, || {\n         fn~(_base: uint, slice : &[A], copy f) -> ~[B] {\n@@ -84,7 +88,7 @@ fn map<A: copy send, B: copy send>(xs: ~[A], f: fn~(A) -> B) -> ~[B] {\n     }))\n }\n \n-#[doc=\"A parallel version of mapi.\"]\n+/// A parallel version of mapi.\n fn mapi<A: copy send, B: copy send>(xs: ~[A],\n                                     f: fn~(uint, A) -> B) -> ~[B] {\n     let slices = map_slices(xs, || {\n@@ -100,10 +104,12 @@ fn mapi<A: copy send, B: copy send>(xs: ~[A],\n     r\n }\n \n-#[doc=\"A parallel version of mapi.\n-\n-In this case, f is a function that creates functions to run over the\n-inner elements. This is to skirt the need for copy constructors.\"]\n+/**\n+ * A parallel version of mapi.\n+ *\n+ * In this case, f is a function that creates functions to run over the\n+ * inner elements. This is to skirt the need for copy constructors.\n+ */\n fn mapi_factory<A: copy send, B: copy send>(\n     xs: ~[A], f: fn() -> fn~(uint, A) -> B) -> ~[B] {\n     let slices = map_slices(xs, || {\n@@ -120,7 +126,7 @@ fn mapi_factory<A: copy send, B: copy send>(\n     r\n }\n \n-#[doc=\"Returns true if the function holds for all elements in the vector.\"]\n+/// Returns true if the function holds for all elements in the vector.\n fn alli<A: copy send>(xs: ~[A], f: fn~(uint, A) -> bool) -> bool {\n     do vec::all(map_slices(xs, || {\n         fn~(base: uint, slice : &[A], copy f) -> bool {\n@@ -131,7 +137,7 @@ fn alli<A: copy send>(xs: ~[A], f: fn~(uint, A) -> bool) -> bool {\n     })) |x| { x }\n }\n \n-#[doc=\"Returns true if the function holds for any elements in the vector.\"]\n+/// Returns true if the function holds for any elements in the vector.\n fn any<A: copy send>(xs: ~[A], f: fn~(A) -> bool) -> bool {\n     do vec::any(map_slices(xs, || {\n         fn~(_base : uint, slice: &[A], copy f) -> bool {"}, {"sha": "1a90612869bdcf0410cefa0c924db495dc03eca8", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 480, "deletions": 479, "changes": 959, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,84 +1,84 @@\n-#[doc = \"\n-High-level text containers.\n-\n-Ropes are a high-level representation of text that offers\n-much better performance than strings for common operations,\n-and generally reduce memory allocations and copies, while only\n-entailing a small degradation of less common operations.\n-\n-More precisely, where a string is represented as a memory buffer,\n-a rope is a tree structure whose leaves are slices of immutable\n-strings. Therefore, concatenation, appending, prepending, substrings,\n-etc. are operations that require only trivial tree manipulation,\n-generally without having to copy memory. In addition, the tree\n-structure of ropes makes them suitable as a form of index to speed-up\n-access to Unicode characters by index in long chunks of text.\n-\n-The following operations are algorithmically faster in ropes:\n-\n-* extracting a subrope is logarithmic (linear in strings);\n-* appending/prepending is near-constant time (linear in strings);\n-* concatenation is near-constant time (linear in strings);\n-* char length is constant-time (linear in strings);\n-* access to a character by index is logarithmic (linear in strings);\n-\"];\n+/*!\n+ * High-level text containers.\n+ *\n+ * Ropes are a high-level representation of text that offers\n+ * much better performance than strings for common operations,\n+ * and generally reduce memory allocations and copies, while only\n+ * entailing a small degradation of less common operations.\n+ *\n+ * More precisely, where a string is represented as a memory buffer,\n+ * a rope is a tree structure whose leaves are slices of immutable\n+ * strings. Therefore, concatenation, appending, prepending, substrings,\n+ * etc. are operations that require only trivial tree manipulation,\n+ * generally without having to copy memory. In addition, the tree\n+ * structure of ropes makes them suitable as a form of index to speed-up\n+ * access to Unicode characters by index in long chunks of text.\n+ *\n+ * The following operations are algorithmically faster in ropes:\n+ *\n+ * * extracting a subrope is logarithmic (linear in strings);\n+ * * appending/prepending is near-constant time (linear in strings);\n+ * * concatenation is near-constant time (linear in strings);\n+ * * char length is constant-time (linear in strings);\n+ * * access to a character by index is logarithmic (linear in strings);\n+ */\n \n \n-#[doc = \"The type of ropes.\"]\n+/// The type of ropes.\n type rope = node::root;\n \n /*\n  Section: Creating a rope\n  */\n \n-#[doc = \"Create an empty rope\"]\n+/// Create an empty rope\n fn empty() -> rope {\n    ret node::empty;\n }\n \n-#[doc = \"\n-Adopt a string as a rope.\n-\n-# Arguments\n-\n-* str - A valid string.\n-\n-# Return value\n-\n-A rope representing the same string as `str`. Depending of the length\n-of `str`, this rope may be empty, flat or complex.\n-\n-# Performance notes\n-\n-* this operation does not copy the string;\n-* the function runs in linear time.\n-\"]\n+/**\n+ * Adopt a string as a rope.\n+ *\n+ * # Arguments\n+ *\n+ * * str - A valid string.\n+ *\n+ * # Return value\n+ *\n+ * A rope representing the same string as `str`. Depending of the length\n+ * of `str`, this rope may be empty, flat or complex.\n+ *\n+ * # Performance notes\n+ *\n+ * * this operation does not copy the string;\n+ * * the function runs in linear time.\n+ */\n fn of_str(str: @str) -> rope {\n     ret of_substr(str, 0u, str::len(*str));\n }\n \n-#[doc = \"\n-As `of_str` but for a substring.\n-\n-# Arguments\n-* byte_offset - The offset of `str` at which the rope starts.\n-* byte_len - The number of bytes of `str` to use.\n-\n-# Return value\n-\n-A rope representing the same string as `str::substr(str, byte_offset,\n-byte_len)`.  Depending on `byte_len`, this rope may be empty, flat or\n-complex.\n-\n-# Performance note\n-\n-This operation does not copy the substring.\n-\n-# Safety notes\n-\n-* this function does _not_ check the validity of the substring;\n-* this function fails if `byte_offset` or `byte_len` do not match `str`.\n-\"]\n+/**\n+ * As `of_str` but for a substring.\n+ *\n+ * # Arguments\n+ * * byte_offset - The offset of `str` at which the rope starts.\n+ * * byte_len - The number of bytes of `str` to use.\n+ *\n+ * # Return value\n+ *\n+ * A rope representing the same string as `str::substr(str, byte_offset,\n+ * byte_len)`.  Depending on `byte_len`, this rope may be empty, flat or\n+ * complex.\n+ *\n+ * # Performance note\n+ *\n+ * This operation does not copy the substring.\n+ *\n+ * # Safety notes\n+ *\n+ * * this function does _not_ check the validity of the substring;\n+ * * this function fails if `byte_offset` or `byte_len` do not match `str`.\n+ */\n fn of_substr(str: @str, byte_offset: uint, byte_len: uint) -> rope {\n     if byte_len == 0u { ret node::empty; }\n     if byte_offset + byte_len  > str::len(*str) { fail; }\n@@ -89,49 +89,49 @@ fn of_substr(str: @str, byte_offset: uint, byte_len: uint) -> rope {\n Section: Adding things to a rope\n  */\n \n-#[doc = \"\n-Add one char to the end of the rope\n-\n-# Performance note\n-\n-* this function executes in near-constant time\n-\"]\n+/**\n+ * Add one char to the end of the rope\n+ *\n+ * # Performance note\n+ *\n+ * * this function executes in near-constant time\n+ */\n fn append_char(rope: rope, char: char) -> rope {\n     ret append_str(rope, @str::from_chars(~[char]));\n }\n \n-#[doc = \"\n-Add one string to the end of the rope\n-\n-# Performance note\n-\n-* this function executes in near-linear time\n-\"]\n+/**\n+ * Add one string to the end of the rope\n+ *\n+ * # Performance note\n+ *\n+ * * this function executes in near-linear time\n+ */\n fn append_str(rope: rope, str: @str) -> rope {\n     ret append_rope(rope, of_str(str))\n }\n \n-#[doc = \"\n-Add one char to the beginning of the rope\n-\n-# Performance note\n-* this function executes in near-constant time\n-\"]\n+/**\n+ * Add one char to the beginning of the rope\n+ *\n+ * # Performance note\n+ * * this function executes in near-constant time\n+ */\n fn prepend_char(rope: rope, char: char) -> rope {\n     ret prepend_str(rope, @str::from_chars(~[char]));\n }\n \n-#[doc = \"\n-Add one string to the beginning of the rope\n-\n-# Performance note\n-* this function executes in near-linear time\n-\"]\n+/**\n+ * Add one string to the beginning of the rope\n+ *\n+ * # Performance note\n+ * * this function executes in near-linear time\n+ */\n fn prepend_str(rope: rope, str: @str) -> rope {\n     ret append_rope(of_str(str), rope)\n }\n \n-#[doc = \"Concatenate two ropes\"]\n+/// Concatenate two ropes\n fn append_rope(left: rope, right: rope) -> rope {\n    alt(left) {\n      node::empty { ret right; }\n@@ -146,13 +146,13 @@ fn append_rope(left: rope, right: rope) -> rope {\n    }\n }\n \n-#[doc = \"\n-Concatenate many ropes.\n-\n-If the ropes are balanced initially and have the same height, the resulting\n-rope remains balanced. However, this function does not take any further\n-measure to ensure that the result is balanced.\n-\"]\n+/**\n+ * Concatenate many ropes.\n+ *\n+ * If the ropes are balanced initially and have the same height, the resulting\n+ * rope remains balanced. However, this function does not take any further\n+ * measure to ensure that the result is balanced.\n+ */\n fn concat(v: ~[rope]) -> rope {\n     //Copy `v` into a mut vector\n     let mut len = vec::len(v);\n@@ -185,17 +185,17 @@ Section: Keeping ropes healthy\n  */\n \n \n-#[doc = \"\n-Balance a rope.\n-\n-# Return value\n-\n-A copy of the rope in which small nodes have been grouped in memory,\n-and with a reduced height.\n-\n-If you perform numerous rope concatenations, it is generally a good idea\n-to rebalance your rope at some point, before using it for other purposes.\n-\"]\n+/**\n+ * Balance a rope.\n+ *\n+ * # Return value\n+ *\n+ * A copy of the rope in which small nodes have been grouped in memory,\n+ * and with a reduced height.\n+ *\n+ * If you perform numerous rope concatenations, it is generally a good idea\n+ * to rebalance your rope at some point, before using it for other purposes.\n+ */\n fn bal(rope:rope) -> rope {\n     alt(rope) {\n       node::empty { ret rope }\n@@ -213,19 +213,19 @@ Section: Transforming ropes\n  */\n \n \n-#[doc = \"\n-Extract a subrope from a rope.\n-\n-# Performance note\n-\n-* on a balanced rope, this operation takes algorithmic time;\n-* this operation does not involve any copying\n-\n-# Safety note\n-\n-* this function fails if char_offset/char_len do not represent\n-  valid positions in rope\n-\"]\n+/**\n+ * Extract a subrope from a rope.\n+ *\n+ * # Performance note\n+ *\n+ * * on a balanced rope, this operation takes algorithmic time;\n+ * * this operation does not involve any copying\n+ *\n+ * # Safety note\n+ *\n+ * * this function fails if char_offset/char_len do not represent\n+ *   valid positions in rope\n+ */\n fn sub_chars(rope: rope, char_offset: uint, char_len: uint) -> rope {\n     if char_len == 0u { ret node::empty; }\n     alt(rope) {\n@@ -239,19 +239,19 @@ fn sub_chars(rope: rope, char_offset: uint, char_len: uint) -> rope {\n     }\n }\n \n-#[doc = \"\n-Extract a subrope from a rope.\n-\n-# Performance note\n-\n-* on a balanced rope, this operation takes algorithmic time;\n-* this operation does not involve any copying\n-\n-# Safety note\n-\n-* this function fails if byte_offset/byte_len do not represent\n-  valid positions in rope\n-\"]\n+/**\n+ * Extract a subrope from a rope.\n+ *\n+ * # Performance note\n+ *\n+ * * on a balanced rope, this operation takes algorithmic time;\n+ * * this operation does not involve any copying\n+ *\n+ * # Safety note\n+ *\n+ * * this function fails if byte_offset/byte_len do not represent\n+ *   valid positions in rope\n+ */\n fn sub_bytes(rope: rope, byte_offset: uint, byte_len: uint) -> rope {\n     if byte_len == 0u { ret node::empty; }\n     alt(rope) {\n@@ -269,16 +269,16 @@ fn sub_bytes(rope: rope, byte_offset: uint, byte_len: uint) -> rope {\n Section: Comparing ropes\n  */\n \n-#[doc = \"\n-Compare two ropes by Unicode lexicographical order.\n-\n-This function compares only the contents of the rope, not their structure.\n-\n-# Return value\n-\n-A negative value if `left < right`, 0 if eq(left, right) or a positive\n-value if `left > right`\n-\"]\n+/**\n+ * Compare two ropes by Unicode lexicographical order.\n+ *\n+ * This function compares only the contents of the rope, not their structure.\n+ *\n+ * # Return value\n+ *\n+ * A negative value if `left < right`, 0 if eq(left, right) or a positive\n+ * value if `left > right`\n+ */\n fn cmp(left: rope, right: rope) -> int {\n     alt((left, right)) {\n       (node::empty, node::empty) { ret 0; }\n@@ -290,70 +290,70 @@ fn cmp(left: rope, right: rope) -> int {\n     }\n }\n \n-#[doc = \"\n-Returns `true` if both ropes have the same content (regardless of\n-their structure), `false` otherwise\n-\"]\n+/**\n+ * Returns `true` if both ropes have the same content (regardless of\n+ * their structure), `false` otherwise\n+ */\n fn eq(left: rope, right: rope) -> bool {\n     ret cmp(left, right) == 0;\n }\n \n-#[doc = \"\n-# Arguments\n-\n-* left - an arbitrary rope\n-* right - an arbitrary rope\n-\n-# Return value\n-\n-`true` if `left <= right` in lexicographical order (regardless of their\n-structure), `false` otherwise\n-\"]\n+/**\n+ * # Arguments\n+ *\n+ * * left - an arbitrary rope\n+ * * right - an arbitrary rope\n+ *\n+ * # Return value\n+ *\n+ * `true` if `left <= right` in lexicographical order (regardless of their\n+ * structure), `false` otherwise\n+ */\n fn le(left: rope, right: rope) -> bool {\n     ret cmp(left, right) <= 0;\n }\n \n-#[doc = \"\n-# Arguments\n-\n-* left - an arbitrary rope\n-* right - an arbitrary rope\n-\n-# Return value\n-\n-`true` if `left < right` in lexicographical order (regardless of their\n-structure), `false` otherwise\n-\"]\n+/**\n+ * # Arguments\n+ *\n+ * * left - an arbitrary rope\n+ * * right - an arbitrary rope\n+ *\n+ * # Return value\n+ *\n+ * `true` if `left < right` in lexicographical order (regardless of their\n+ * structure), `false` otherwise\n+ */\n fn lt(left: rope, right: rope) -> bool {\n     ret cmp(left, right) < 0;\n }\n \n-#[doc = \"\n-# Arguments\n-\n-* left - an arbitrary rope\n-* right - an arbitrary rope\n-\n-# Return value\n-\n- `true` if `left >= right` in lexicographical order (regardless of their\n-structure), `false` otherwise\n-\"]\n+/**\n+ * # Arguments\n+ *\n+ * * left - an arbitrary rope\n+ * * right - an arbitrary rope\n+ *\n+ * # Return value\n+ *\n+ *  `true` if `left >= right` in lexicographical order (regardless of their\n+ * structure), `false` otherwise\n+ */\n fn ge(left: rope, right: rope) -> bool {\n     ret cmp(left, right) >= 0;\n }\n \n-#[doc = \"\n-# Arguments\n-\n-* left - an arbitrary rope\n-* right - an arbitrary rope\n-\n-# Return value\n-\n-`true` if `left > right` in lexicographical order (regardless of their\n-structure), `false` otherwise\n-\"]\n+/**\n+ * # Arguments\n+ *\n+ * * left - an arbitrary rope\n+ * * right - an arbitrary rope\n+ *\n+ * # Return value\n+ *\n+ * `true` if `left > right` in lexicographical order (regardless of their\n+ * structure), `false` otherwise\n+ */\n fn gt(left: rope, right: rope) -> bool {\n     ret cmp(left, right) > 0;\n }\n@@ -362,69 +362,69 @@ fn gt(left: rope, right: rope) -> bool {\n Section: Iterating\n  */\n \n-#[doc = \"\n-Loop through a rope, char by char\n-\n-While other mechanisms are available, this is generally the best manner\n-of looping through the contents of a rope char by char. If you prefer a\n-loop that iterates through the contents string by string (e.g. to print\n-the contents of the rope or output it to the system), however,\n-you should rather use `traverse_components`.\n-\n-# Arguments\n-\n-* rope - A rope to traverse. It may be empty.\n-* it - A block to execute with each consecutive character of the rope.\n-       Return `true` to continue, `false` to stop.\n-\n-# Return value\n-\n-`true` If execution proceeded correctly, `false` if it was interrupted,\n-that is if `it` returned `false` at any point.\n-\"]\n+/**\n+ * Loop through a rope, char by char\n+ *\n+ * While other mechanisms are available, this is generally the best manner\n+ * of looping through the contents of a rope char by char. If you prefer a\n+ * loop that iterates through the contents string by string (e.g. to print\n+ * the contents of the rope or output it to the system), however,\n+ * you should rather use `traverse_components`.\n+ *\n+ * # Arguments\n+ *\n+ * * rope - A rope to traverse. It may be empty.\n+ * * it - A block to execute with each consecutive character of the rope.\n+ *        Return `true` to continue, `false` to stop.\n+ *\n+ * # Return value\n+ *\n+ * `true` If execution proceeded correctly, `false` if it was interrupted,\n+ * that is if `it` returned `false` at any point.\n+ */\n fn loop_chars(rope: rope, it: fn(char) -> bool) -> bool {\n    alt(rope) {\n       node::empty { ret true }\n       node::content(x) { ret node::loop_chars(x, it) }\n    }\n }\n \n-#[doc = \"\n-Loop through a rope, char by char, until the end.\n-\n-# Arguments\n-* rope - A rope to traverse. It may be empty\n-* it - A block to execute with each consecutive character of the rope.\n-\"]\n+/**\n+ * Loop through a rope, char by char, until the end.\n+ *\n+ * # Arguments\n+ * * rope - A rope to traverse. It may be empty\n+ * * it - A block to execute with each consecutive character of the rope.\n+ */\n fn iter_chars(rope: rope, it: fn(char)) {\n     do loop_chars(rope) |x| {\n         it(x);\n         true\n     };\n }\n \n-#[doc =\"\n-Loop through a rope, string by string\n-\n-While other mechanisms are available, this is generally the best manner of\n-looping through the contents of a rope string by string, which may be useful\n-e.g. to print strings as you see them (without having to copy their\n-contents into a new string), to send them to then network, to write them to\n-a file, etc.. If you prefer a loop that iterates through the contents\n-char by char (e.g. to search for a char), however, you should rather\n-use `traverse`.\n-\n-# Arguments\n-\n-* rope - A rope to traverse. It may be empty\n-* it - A block to execute with each consecutive string component of the rope.\n-       Return `true` to continue, `false` to stop\n-\n-# Return value\n-\n-`true` If execution proceeded correctly, `false` if it was interrupted,\n-that is if `it` returned `false` at any point.\n-\"]\n+/**\n+ * Loop through a rope, string by string\n+ *\n+ * While other mechanisms are available, this is generally the best manner of\n+ * looping through the contents of a rope string by string, which may be\n+ * useful e.g. to print strings as you see them (without having to copy their\n+ * contents into a new string), to send them to then network, to write them to\n+ * a file, etc.. If you prefer a loop that iterates through the contents\n+ * char by char (e.g. to search for a char), however, you should rather\n+ * use `traverse`.\n+ *\n+ * # Arguments\n+ *\n+ * * rope - A rope to traverse. It may be empty\n+ * * it - A block to execute with each consecutive string component of the\n+ *        rope. Return `true` to continue, `false` to stop\n+ *\n+ * # Return value\n+ *\n+ * `true` If execution proceeded correctly, `false` if it was interrupted,\n+ * that is if `it` returned `false` at any point.\n+ */\n fn loop_leaves(rope: rope, it: fn(node::leaf) -> bool) -> bool{\n    alt(rope) {\n       node::empty { ret true }\n@@ -461,17 +461,17 @@ mod iterator {\n  Section: Rope properties\n  */\n \n-#[doc =\"\n-Returns the height of the rope.\n-\n-The height of the rope is a bound on the number of operations which\n-must be performed during a character access before finding the leaf in\n-which a character is contained.\n-\n-# Performance note\n-\n-Constant time.\n-\"]\n+/**\n+ * Returns the height of the rope.\n+ *\n+ * The height of the rope is a bound on the number of operations which\n+ * must be performed during a character access before finding the leaf in\n+ * which a character is contained.\n+ *\n+ * # Performance note\n+ *\n+ * Constant time.\n+ */\n fn height(rope: rope) -> uint {\n    alt(rope) {\n       node::empty    { ret 0u; }\n@@ -481,50 +481,50 @@ fn height(rope: rope) -> uint {\n \n \n \n-#[doc =\"\n-The number of character in the rope\n-\n-# Performance note\n-\n-Constant time.\n-\"]\n+/**\n+ * The number of character in the rope\n+ *\n+ * # Performance note\n+ *\n+ * Constant time.\n+ */\n pure fn char_len(rope: rope) -> uint {\n    alt(rope) {\n      node::empty           { ret 0u; }\n      node::content(x)       { ret node::char_len(x) }\n    }\n }\n \n-#[doc = \"\n-The number of bytes in the rope\n-\n-# Performance note\n-\n-Constant time.\n-\"]\n+/**\n+ * The number of bytes in the rope\n+ *\n+ * # Performance note\n+ *\n+ * Constant time.\n+ */\n pure fn byte_len(rope: rope) -> uint {\n    alt(rope) {\n      node::empty           { ret 0u; }\n      node::content(x)       { ret node::byte_len(x) }\n    }\n }\n \n-#[doc = \"\n-The character at position `pos`\n-\n-# Arguments\n-\n-* pos - A position in the rope\n-\n-# Safety notes\n-\n-The function will fail if `pos` is not a valid position in the rope.\n-\n-# Performance note\n-\n-This function executes in a time proportional to the height of the\n-rope + the (bounded) length of the largest leaf.\n-\"]\n+/**\n+ * The character at position `pos`\n+ *\n+ * # Arguments\n+ *\n+ * * pos - A position in the rope\n+ *\n+ * # Safety notes\n+ *\n+ * The function will fail if `pos` is not a valid position in the rope.\n+ *\n+ * # Performance note\n+ *\n+ * This function executes in a time proportional to the height of the\n+ * rope + the (bounded) length of the largest leaf.\n+ */\n fn char_at(rope: rope, pos: uint) -> char {\n    alt(rope) {\n       node::empty { fail }\n@@ -538,54 +538,55 @@ fn char_at(rope: rope, pos: uint) -> char {\n */\n mod node {\n \n-    #[doc = \"Implementation of type `rope`\"]\n+    /// Implementation of type `rope`\n     enum root {\n-        #[doc = \"An empty rope\"]\n+        /// An empty rope\n         empty,\n-        #[doc = \"A non-empty rope\"]\n+        /// A non-empty rope\n         content(@node),\n     }\n \n-    #[doc = \"\n-    A text component in a rope.\n-\n-    This is actually a slice in a rope, so as to ensure maximal sharing.\n-\n-    # Fields\n-\n-    * byte_offset = The number of bytes skippen in `content`\n-    * byte_len - The number of bytes of `content` to use\n-    * char_len - The number of chars in the leaf.\n-    * content - Contents of the leaf.\n-\n-        Note that we can have `char_len < str::char_len(content)`, if\n-        this leaf is only a subset of the string. Also note that the\n-        string can be shared between several ropes, e.g. for indexing\n-        purposes.\n-    \"]\n+    /**\n+     * A text component in a rope.\n+     *\n+     * This is actually a slice in a rope, so as to ensure maximal sharing.\n+     *\n+     * # Fields\n+     *\n+     * * byte_offset = The number of bytes skippen in `content`\n+     * * byte_len - The number of bytes of `content` to use\n+     * * char_len - The number of chars in the leaf.\n+     * * content - Contents of the leaf.\n+     *\n+     *     Note that we can have `char_len < str::char_len(content)`, if\n+     *     this leaf is only a subset of the string. Also note that the\n+     *     string can be shared between several ropes, e.g. for indexing\n+     *     purposes.\n+     */\n     type leaf = {\n         byte_offset: uint,\n         byte_len:    uint,\n         char_len:   uint,\n         content:    @str\n     };\n \n-    #[doc = \"\n-    A node obtained from the concatenation of two other nodes\n-\n-    # Fields\n-\n-    * left - The node containing the beginning of the text.\n-    * right - The node containing the end of the text.\n-    * char_len - The number of chars contained in all leaves of this node.\n-    * byte_len - The number of bytes in the subrope.\n-\n-        Used to pre-allocate the correct amount of storage for serialization.\n-\n-    * height - Height of the subrope.\n-\n-        Used for rebalancing and to allocate stacks for traversals.\n-    \"]\n+    /**\n+     * A node obtained from the concatenation of two other nodes\n+     *\n+     * # Fields\n+     *\n+     * * left - The node containing the beginning of the text.\n+     * * right - The node containing the end of the text.\n+     * * char_len - The number of chars contained in all leaves of this node.\n+     * * byte_len - The number of bytes in the subrope.\n+     *\n+     *     Used to pre-allocate the correct amount of storage for\n+     *     serialization.\n+     *\n+     * * height - Height of the subrope.\n+     *\n+     *     Used for rebalancing and to allocate stacks for traversals.\n+     */\n     type concat = {\n         left:     @node,//TODO: Perhaps a `vec` instead of `left`/`right`\n         right:    @node,\n@@ -595,83 +596,83 @@ mod node {\n     };\n \n     enum node {\n-        #[doc = \"A leaf consisting in a `str`\"]\n+        /// A leaf consisting in a `str`\n         leaf(leaf),\n-        #[doc = \"The concatenation of two ropes\"]\n+        /// The concatenation of two ropes\n         concat(concat),\n     }\n \n-    #[doc = \"\n-    The maximal number of chars that _should_ be permitted in a single node.\n-\n-    This is not a strict value\n-    \"]\n+    /**\n+     * The maximal number of chars that _should_ be permitted in a single node\n+     *\n+     * This is not a strict value\n+     */\n     const hint_max_leaf_char_len: uint = 256u;\n \n-    #[doc = \"\n-    The maximal height that _should_ be permitted in a tree.\n-\n-    This is not a strict value\n-    \"]\n+    /**\n+     * The maximal height that _should_ be permitted in a tree.\n+     *\n+     * This is not a strict value\n+     */\n     const hint_max_node_height:   uint = 16u;\n \n-    #[doc = \"\n-    Adopt a string as a node.\n-\n-    If the string is longer than `max_leaf_char_len`, it is\n-    logically split between as many leaves as necessary. Regardless,\n-    the string itself is not copied.\n-\n-    Performance note: The complexity of this function is linear in\n-    the length of `str`.\n-    \"]\n+    /**\n+     * Adopt a string as a node.\n+     *\n+     * If the string is longer than `max_leaf_char_len`, it is\n+     * logically split between as many leaves as necessary. Regardless,\n+     * the string itself is not copied.\n+     *\n+     * Performance note: The complexity of this function is linear in\n+     * the length of `str`.\n+     */\n     fn of_str(str: @str) -> @node {\n         ret of_substr(str, 0u, str::len(*str));\n     }\n \n-    #[doc =\"\n-    Adopt a slice of a string as a node.\n-\n-    If the slice is longer than `max_leaf_char_len`, it is logically split\n-    between as many leaves as necessary. Regardless, the string itself\n-    is not copied\n-\n-    # Arguments\n-\n-    * byte_start - The byte offset where the slice of `str` starts.\n-    * byte_len   - The number of bytes from `str` to use.\n-\n-    # Safety note\n-\n-    Behavior is undefined if `byte_start` or `byte_len` do not represent\n-    valid positions in `str`\n-    \"]\n+    /**\n+     * Adopt a slice of a string as a node.\n+     *\n+     * If the slice is longer than `max_leaf_char_len`, it is logically split\n+     * between as many leaves as necessary. Regardless, the string itself\n+     * is not copied\n+     *\n+     * # Arguments\n+     *\n+     * * byte_start - The byte offset where the slice of `str` starts.\n+     * * byte_len   - The number of bytes from `str` to use.\n+     *\n+     * # Safety note\n+     *\n+     * Behavior is undefined if `byte_start` or `byte_len` do not represent\n+     * valid positions in `str`\n+     */\n     fn of_substr(str: @str, byte_start: uint, byte_len: uint) -> @node {\n         ret of_substr_unsafer(str, byte_start, byte_len,\n                               str::count_chars(*str, byte_start, byte_len));\n     }\n \n-    #[doc = \"\n-    Adopt a slice of a string as a node.\n-\n-    If the slice is longer than `max_leaf_char_len`, it is logically split\n-    between as many leaves as necessary. Regardless, the string itself\n-    is not copied\n-\n-    # Arguments\n-\n-    * byte_start - The byte offset where the slice of `str` starts.\n-    * byte_len - The number of bytes from `str` to use.\n-    * char_len - The number of chars in `str` in the interval\n-                 [byte_start, byte_start+byte_len)\n-\n-    # Safety notes\n-\n-    * Behavior is undefined if `byte_start` or `byte_len` do not represent\n-      valid positions in `str`\n-    * Behavior is undefined if `char_len` does not accurately represent the\n-      number of chars between byte_start and byte_start+byte_len\n-    \"]\n+    /**\n+     * Adopt a slice of a string as a node.\n+     *\n+     * If the slice is longer than `max_leaf_char_len`, it is logically split\n+     * between as many leaves as necessary. Regardless, the string itself\n+     * is not copied\n+     *\n+     * # Arguments\n+     *\n+     * * byte_start - The byte offset where the slice of `str` starts.\n+     * * byte_len - The number of bytes from `str` to use.\n+     * * char_len - The number of chars in `str` in the interval\n+     *              [byte_start, byte_start+byte_len)\n+     *\n+     * # Safety notes\n+     *\n+     * * Behavior is undefined if `byte_start` or `byte_len` do not represent\n+     *   valid positions in `str`\n+     * * Behavior is undefined if `char_len` does not accurately represent the\n+     *   number of chars between byte_start and byte_start+byte_len\n+     */\n     fn of_substr_unsafer(str: @str, byte_start: uint, byte_len: uint,\n                           char_len: uint) -> @node {\n         assert(byte_start + byte_len <= str::len(*str));\n@@ -744,14 +745,14 @@ mod node {\n         }\n     }\n \n-    #[doc =\"\n-    Concatenate a forest of nodes into one tree.\n-\n-    # Arguments\n-\n-    * forest - The forest. This vector is progressively rewritten during\n-               execution and should be discarded as meaningless afterwards.\n-    \"]\n+    /**\n+     * Concatenate a forest of nodes into one tree.\n+     *\n+     * # Arguments\n+     *\n+     * * forest - The forest. This vector is progressively rewritten during\n+     *            execution and should be discarded as meaningless afterwards.\n+     */\n     fn tree_from_forest_destructive(forest: ~[mut @node]) -> @node {\n         let mut i;\n         let mut len = vec::len(forest);\n@@ -820,13 +821,13 @@ mod node {\n         ret unsafe::transmute(buf);\n     }\n \n-    #[doc =\"\n-    Replace a subtree by a single leaf with the same contents.\n-\n-    * Performance note\n-\n-    This function executes in linear time.\n-    \"]\n+    /**\n+     * Replace a subtree by a single leaf with the same contents.\n+     *\n+     * * Performance note\n+     *\n+     * This function executes in linear time.\n+     */\n     fn flatten(node: @node) -> @node unsafe {\n         alt(*node) {\n           leaf(_) { ret node }\n@@ -841,21 +842,21 @@ mod node {\n         }\n     }\n \n-    #[doc =\"\n-    Balance a node.\n-\n-    # Algorithm\n-\n-    * if the node height is smaller than `hint_max_node_height`, do nothing\n-    * otherwise, gather all leaves as a forest, rebuild a balanced node,\n-      concatenating small leaves along the way\n-\n-    # Return value\n-\n-    * `option::none` if no transformation happened\n-    * `option::some(x)` otherwise, in which case `x` has the same contents\n-       as `node` bot lower height and/or fragmentation.\n-    \"]\n+    /**\n+     * Balance a node.\n+     *\n+     * # Algorithm\n+     *\n+     * * if the node height is smaller than `hint_max_node_height`, do nothing\n+     * * otherwise, gather all leaves as a forest, rebuild a balanced node,\n+     *   concatenating small leaves along the way\n+     *\n+     * # Return value\n+     *\n+     * * `option::none` if no transformation happened\n+     * * `option::some(x)` otherwise, in which case `x` has the same contents\n+     *    as `node` bot lower height and/or fragmentation.\n+     */\n     fn bal(node: @node) -> option<@node> {\n         if height(node) < hint_max_node_height { ret option::none; }\n         //1. Gather all leaves as a forest\n@@ -873,25 +874,25 @@ mod node {\n \n     }\n \n-    #[doc =\"\n-    Compute the subnode of a node.\n-\n-    # Arguments\n-\n-    * node        - A node\n-    * byte_offset - A byte offset in `node`\n-    * byte_len    - The number of bytes to return\n-\n-    # Performance notes\n-\n-    * this function performs no copying;\n-    * this function executes in a time proportional to the height of `node`.\n-\n-    # Safety notes\n-\n-    This function fails if `byte_offset` or `byte_len` do not represent\n-    valid positions in `node`.\n-    \"]\n+    /**\n+     * Compute the subnode of a node.\n+     *\n+     * # Arguments\n+     *\n+     * * node        - A node\n+     * * byte_offset - A byte offset in `node`\n+     * * byte_len    - The number of bytes to return\n+     *\n+     * # Performance notes\n+     *\n+     * * this function performs no copying;\n+     * * this function executes in a time proportional to the height of `node`\n+     *\n+     * # Safety notes\n+     *\n+     * This function fails if `byte_offset` or `byte_len` do not represent\n+     * valid positions in `node`.\n+     */\n     fn sub_bytes(node: @node, byte_offset: uint, byte_len: uint) -> @node {\n         let mut node        = node;\n         let mut byte_offset = byte_offset;\n@@ -934,25 +935,25 @@ mod node {\n         };\n     }\n \n-    #[doc =\"\n-    Compute the subnode of a node.\n-\n-    # Arguments\n-\n-    * node        - A node\n-    * char_offset - A char offset in `node`\n-    * char_len    - The number of chars to return\n-\n-    # Performance notes\n-\n-    * this function performs no copying;\n-    * this function executes in a time proportional to the height of `node`.\n-\n-    # Safety notes\n-\n-    This function fails if `char_offset` or `char_len` do not represent\n-    valid positions in `node`.\n-    \"]\n+    /**\n+     * Compute the subnode of a node.\n+     *\n+     * # Arguments\n+     *\n+     * * node        - A node\n+     * * char_offset - A char offset in `node`\n+     * * char_len    - The number of chars to return\n+     *\n+     * # Performance notes\n+     *\n+     * * this function performs no copying;\n+     * * this function executes in a time proportional to the height of `node`\n+     *\n+     * # Safety notes\n+     *\n+     * This function fails if `char_offset` or `char_len` do not represent\n+     * valid positions in `node`.\n+     */\n     fn sub_chars(node: @node, char_offset: uint, char_len: uint) -> @node {\n         let mut node        = node;\n         let mut char_offset = char_offset;\n@@ -1045,20 +1046,20 @@ mod node {\n         });\n     }\n \n-    #[doc =\"\n-    Loop through a node, leaf by leaf\n-\n-    # Arguments\n-\n-    * rope - A node to traverse.\n-    * it - A block to execute with each consecutive leaf of the node.\n-           Return `true` to continue, `false` to stop\n-\n-    # Arguments\n-\n-    `true` If execution proceeded correctly, `false` if it was interrupted,\n-    that is if `it` returned `false` at any point.\n-    \"]\n+    /**\n+     * Loop through a node, leaf by leaf\n+     *\n+     * # Arguments\n+     *\n+     * * rope - A node to traverse.\n+     * * it - A block to execute with each consecutive leaf of the node.\n+     *        Return `true` to continue, `false` to stop\n+     *\n+     * # Arguments\n+     *\n+     * `true` If execution proceeded correctly, `false` if it was interrupted,\n+     * that is if `it` returned `false` at any point.\n+     */\n     fn loop_leaves(node: @node, it: fn(leaf) -> bool) -> bool{\n         let mut current = node;\n         loop {\n@@ -1077,23 +1078,23 @@ mod node {\n         };\n     }\n \n-    #[doc =\"\n-    # Arguments\n-\n-    * pos - A position in the rope\n-\n-    # Return value\n-\n-    The character at position `pos`\n-\n-    # Safety notes\n-\n-    The function will fail if `pos` is not a valid position in the rope.\n-\n-    Performance note: This function executes in a time\n-    proportional to the height of the rope + the (bounded)\n-    length of the largest leaf.\n-    \"]\n+    /**\n+     * # Arguments\n+     *\n+     * * pos - A position in the rope\n+     *\n+     * # Return value\n+     *\n+     * The character at position `pos`\n+     *\n+     * # Safety notes\n+     *\n+     * The function will fail if `pos` is not a valid position in the rope.\n+     *\n+     * Performance note: This function executes in a time\n+     * proportional to the height of the rope + the (bounded)\n+     * length of the largest leaf.\n+     */\n     fn char_at(node: @node, pos: uint) -> char {\n         let mut node    = node;\n         let mut pos     = pos;"}, {"sha": "aafe31ec011834fff6b9c7519eced18d394a1697", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Support code for serialization.\"];\n+//! Support code for serialization.\n \n use core;\n "}, {"sha": "607388bd559123bc6537b28d3ccb16971c9f5bdb", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,16 +1,16 @@\n-#[doc =\"\n-An implementation of the SHA-1 cryptographic hash.\n-\n-First create a `sha1` object using the `sha1` constructor, then\n-feed it input using the `input` or `input_str` methods, which may be\n-called any number of times.\n-\n-After the entire input has been fed to the hash read the result using\n-the `result` or `result_str` methods.\n-\n-The `sha1` object may be reused to create multiple hashes by calling\n-the `reset` method.\n-\"];\n+/*!\n+ * An implementation of the SHA-1 cryptographic hash.\n+ *\n+ * First create a `sha1` object using the `sha1` constructor, then\n+ * feed it input using the `input` or `input_str` methods, which may be\n+ * called any number of times.\n+ *\n+ * After the entire input has been fed to the hash read the result using\n+ * the `result` or `result_str` methods.\n+ *\n+ * The `sha1` object may be reused to create multiple hashes by calling\n+ * the `reset` method.\n+ */\n \n /*\n  * A SHA-1 implementation derived from Paul E. Jones's reference\n@@ -19,23 +19,23 @@ the `reset` method.\n  */\n export sha1;\n \n-#[doc = \"The SHA-1 interface\"]\n+/// The SHA-1 interface\n iface sha1 {\n-    #[doc = \"Provide message input as bytes\"]\n+    /// Provide message input as bytes\n     fn input(~[u8]);\n-    #[doc = \"Provide message input as string\"]\n+    /// Provide message input as string\n     fn input_str(str);\n-    #[doc = \"\n-    Read the digest as a vector of 20 bytes. After calling this no further\n-    input may be provided until reset is called.\n-    \"]\n+    /**\n+     * Read the digest as a vector of 20 bytes. After calling this no further\n+     * input may be provided until reset is called.\n+     */\n     fn result() -> ~[u8];\n-    #[doc = \"\n-    Read the digest as a hex string. After calling this no further\n-    input may be provided until reset is called.\n-    \"]\n+    /**\n+     * Read the digest as a hex string. After calling this no further\n+     * input may be provided until reset is called.\n+     */\n     fn result_str() -> str;\n-    #[doc = \"Reset the SHA-1 state for reuse\"]\n+    /// Reset the SHA-1 state for reuse\n     fn reset();\n }\n \n@@ -49,7 +49,7 @@ const k2: u32 = 0x8F1BBCDCu32;\n const k3: u32 = 0xCA62C1D6u32;\n \n \n-#[doc = \"Construct a `sha` object\"]\n+/// Construct a `sha` object\n fn sha1() -> sha1 {\n     type sha1state =\n         {h: ~[mut u32],"}, {"sha": "9fb4be4804de28c6e1e312c3fc170b56d094c564", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,7 +1,7 @@\n-#[doc = \"\n-A simple map based on a vector for small integer keys. Space requirements\n-are O(highest integer key).\n-\"];\n+/*!\n+ * A simple map based on a vector for small integer keys. Space requirements\n+ * are O(highest integer key).\n+ */\n import core::option;\n import core::option::{some, none};\n import dvec::{dvec, extensions};\n@@ -10,51 +10,49 @@ import dvec::{dvec, extensions};\n // requires this to be.\n type smallintmap<T: copy> = @{v: dvec<option<T>>};\n \n-#[doc = \"Create a smallintmap\"]\n+/// Create a smallintmap\n fn mk<T: copy>() -> smallintmap<T> {\n     ret @{v: dvec()};\n }\n \n-#[doc = \"\n-Add a value to the map. If the map already contains a value for\n-the specified key then the original value is replaced.\n-\"]\n+/**\n+ * Add a value to the map. If the map already contains a value for\n+ * the specified key then the original value is replaced.\n+ */\n #[inline(always)]\n fn insert<T: copy>(self: smallintmap<T>, key: uint, val: T) {\n     self.v.grow_set_elt(key, none, some(val));\n }\n \n-#[doc = \"\n-Get the value for the specified key. If the key does not exist\n-in the map then returns none\n-\"]\n+/**\n+ * Get the value for the specified key. If the key does not exist\n+ * in the map then returns none\n+ */\n fn find<T: copy>(self: smallintmap<T>, key: uint) -> option<T> {\n     if key < self.v.len() { ret self.v.get_elt(key); }\n     ret none::<T>;\n }\n \n-#[doc = \"\n-Get the value for the specified key\n-\n-# Failure\n-\n-If the key does not exist in the map\n-\"]\n+/**\n+ * Get the value for the specified key\n+ *\n+ * # Failure\n+ *\n+ * If the key does not exist in the map\n+ */\n fn get<T: copy>(self: smallintmap<T>, key: uint) -> T {\n     alt find(self, key) {\n       none { #error(\"smallintmap::get(): key not present\"); fail; }\n       some(v) { ret v; }\n     }\n }\n \n-#[doc = \"\n-Returns true if the map contains a value for the specified key\n-\"]\n+/// Returns true if the map contains a value for the specified key\n fn contains_key<T: copy>(self: smallintmap<T>, key: uint) -> bool {\n     ret !option::is_none(find(self, key));\n }\n \n-#[doc = \"Implements the map::map interface for smallintmap\"]\n+/// Implements the map::map interface for smallintmap\n impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n     fn size() -> uint {\n         let mut sz = 0u;\n@@ -106,7 +104,7 @@ impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n     }\n }\n \n-#[doc = \"Cast the given smallintmap to a map::map\"]\n+/// Cast the given smallintmap to a map::map\n fn as_map<V: copy>(s: smallintmap<V>) -> map::map<uint, V> {\n     s as map::map::<uint, V>\n }"}, {"sha": "d0092e97cb3fd1b93d3b4fb3cc1a9dee0de9991e", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Sorting methods\"];\n+//! Sorting methods\n import vec::{len, push};\n import int::{eq, ord};\n \n@@ -9,12 +9,12 @@ export quick_sort3;\n \n type le<T> = fn(T, T) -> bool;\n \n-#[doc = \"\n-Merge sort. Returns a new vector containing the sorted list.\n-\n-Has worst case O(n log n) performance, best case O(n), but\n-is not space efficient. This is a stable sort.\n-\"]\n+/**\n+ * Merge sort. Returns a new vector containing the sorted list.\n+ *\n+ * Has worst case O(n log n) performance, best case O(n), but\n+ * is not space efficient. This is a stable sort.\n+ */\n fn merge_sort<T: copy>(le: le<T>, v: ~[const T]) -> ~[T] {\n     type slice = (uint, uint);\n \n@@ -84,12 +84,12 @@ fn qsort<T: copy>(compare_func: le<T>, arr: ~[mut T], left: uint,\n     }\n }\n \n-#[doc = \"\n-Quicksort. Sorts a mut vector in place.\n-\n-Has worst case O(n^2) performance, average case O(n log n).\n-This is an unstable sort.\n-\"]\n+/**\n+ * Quicksort. Sorts a mut vector in place.\n+ *\n+ * Has worst case O(n^2) performance, average case O(n log n).\n+ * This is an unstable sort.\n+ */\n fn quick_sort<T: copy>(compare_func: le<T>, arr: ~[mut T]) {\n     if len::<T>(arr) == 0u { ret; }\n     qsort::<T>(compare_func, arr, 0u, len::<T>(arr) - 1u);\n@@ -143,16 +143,16 @@ fn qsort3<T: copy>(compare_func_lt: le<T>, compare_func_eq: le<T>,\n     qsort3::<T>(compare_func_lt, compare_func_eq, arr, i, right);\n }\n \n-#[doc = \"\n-Fancy quicksort. Sorts a mut vector in place.\n-\n-Based on algorithm presented by [Sedgewick and Bentley]/~\n-(http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf).\n-According to these slides this is the algorithm of choice for\n-'randomly ordered keys, abstract compare' & 'small number of key values'.\n-\n-This is an unstable sort.\n-\"]\n+/**\n+ * Fancy quicksort. Sorts a mut vector in place.\n+ *\n+ * Based on algorithm presented by [Sedgewick and Bentley]/~\n+ * (http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf).\n+ * According to these slides this is the algorithm of choice for\n+ * 'randomly ordered keys, abstract compare' & 'small number of key values'.\n+ *\n+ * This is an unstable sort.\n+ */\n fn quick_sort3<T: copy ord eq>(arr: ~[mut T]) {\n     if len::<T>(arr) == 0u { ret; }\n     qsort3::<T>(|x, y| x.lt(y), |x, y| x.eq(y), arr, 0,"}, {"sha": "e30e9fc4774386f1aeefa6bc91d25d6f0e19951d", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -6,7 +6,7 @@\n #[comment = \"The Rust standard library\"];\n #[license = \"MIT\"];\n #[crate_type = \"lib\"];\n-#[doc = \"The Rust standard library\"];\n+//! The Rust standard library\n \n #[no_core];\n "}, {"sha": "536f633f8a76fcc2a4bf43b548f12a6cd12d4214", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Temporary files and directories\"];\n+//! Temporary files and directories\n \n import core::option;\n import option::{none, some};"}, {"sha": "fb134e852959c039b297c29be495e0248159553d", "filename": "src/libstd/term.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Simple ANSI color library\"];\n+//! Simple ANSI color library\n \n import core::option;\n \n@@ -25,13 +25,13 @@ const color_bright_white: u8 = 15u8;\n \n fn esc(writer: io::writer) { writer.write([0x1bu8, '[' as u8]/~); }\n \n-#[doc = \"Reset the foreground and background colors to default\"]\n+/// Reset the foreground and background colors to default\n fn reset(writer: io::writer) {\n     esc(writer);\n     writer.write(~['0' as u8, 'm' as u8]);\n }\n \n-#[doc = \"Returns true if the terminal supports color\"]\n+/// Returns true if the terminal supports color\n fn color_supported() -> bool {\n     let supported_terms = ~[\"xterm-color\", \"xterm\",\n                            \"screen-bce\", \"xterm-256color\"];\n@@ -54,12 +54,12 @@ fn set_color(writer: io::writer, first_char: u8, color: u8) {\n     writer.write(~[first_char, ('0' as u8) + color, 'm' as u8]);\n }\n \n-#[doc = \"Set the foreground color\"]\n+/// Set the foreground color\n fn fg(writer: io::writer, color: u8) {\n     ret set_color(writer, '3' as u8, color);\n }\n \n-#[doc = \"Set the background color\"]\n+/// Set the background color\n fn bg(writer: io::writer, color: u8) {\n     ret set_color(writer, '4' as u8, color);\n }"}, {"sha": "3f3749cb0648b3aeaad49c10e8a08f7776d17a37", "filename": "src/libstd/time.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -29,34 +29,34 @@ extern mod rustrt {\n     fn rust_mktime(&&tm: tm, &sec: i64);\n }\n \n-#[doc = \"A record specifying a time value in seconds and microseconds.\"]\n+/// A record specifying a time value in seconds and microseconds.\n type timespec = {sec: i64, nsec: i32};\n \n-#[doc = \"\n-Returns the current time as a `timespec` containing the seconds and\n-microseconds since 1970-01-01T00:00:00Z.\n-\"]\n+/**\n+ * Returns the current time as a `timespec` containing the seconds and\n+ * microseconds since 1970-01-01T00:00:00Z.\n+ */\n fn get_time() -> timespec {\n     let mut sec = 0i64;\n     let mut nsec = 0i32;\n     rustrt::get_time(sec, nsec);\n     ret {sec: sec, nsec: nsec};\n }\n \n-#[doc = \"\n-Returns the current value of a high-resolution performance counter\n-in nanoseconds since an unspecified epoch.\n-\"]\n+/**\n+ * Returns the current value of a high-resolution performance counter\n+ * in nanoseconds since an unspecified epoch.\n+ */\n fn precise_time_ns() -> u64 {\n     let mut ns = 0u64;\n     rustrt::precise_time_ns(ns);\n     ns\n }\n \n-#[doc = \"\n-Returns the current value of a high-resolution performance counter\n-in seconds since an unspecified epoch.\n-\"]\n+/**\n+ * Returns the current value of a high-resolution performance counter\n+ * in seconds since an unspecified epoch.\n+ */\n fn precise_time_s() -> float {\n     ret (precise_time_ns() as float) / 1000000000.;\n }\n@@ -97,33 +97,33 @@ fn empty_tm() -> tm {\n     }\n }\n \n-#[doc = \"Returns the specified time in UTC\"]\n+/// Returns the specified time in UTC\n fn at_utc(clock: timespec) -> tm {\n     let mut {sec, nsec} = clock;\n     let mut tm = empty_tm();\n     rustrt::rust_gmtime(sec, nsec, tm);\n     tm\n }\n \n-#[doc = \"Returns the current time in UTC\"]\n+/// Returns the current time in UTC\n fn now_utc() -> tm {\n     at_utc(get_time())\n }\n \n-#[doc = \"Returns the specified time in the local timezone\"]\n+/// Returns the specified time in the local timezone\n fn at(clock: timespec) -> tm {\n     let mut {sec, nsec} = clock;\n     let mut tm = empty_tm();\n     rustrt::rust_localtime(sec, nsec, tm);\n     tm\n }\n \n-#[doc = \"Returns the current time in the local timezone\"]\n+/// Returns the current time in the local timezone\n fn now() -> tm {\n     at(get_time())\n }\n \n-#[doc = \"Parses the time from the string according to the format string.\"]\n+/// Parses the time from the string according to the format string.\n fn strptime(s: str, format: str) -> result<tm, str> {\n     type tm_mut = {\n        mut tm_sec: i32,\n@@ -751,7 +751,7 @@ fn strftime(format: str, tm: tm) -> str {\n }\n \n impl tm for tm {\n-    #[doc = \"Convert time to the seconds from January 1, 1970\"]\n+    /// Convert time to the seconds from January 1, 1970\n     fn to_timespec() -> timespec {\n         let mut sec = 0i64;\n         if self.tm_gmtoff == 0_i32 {\n@@ -762,31 +762,31 @@ impl tm for tm {\n         { sec: sec, nsec: self.tm_nsec }\n     }\n \n-    #[doc = \"Convert time to the local timezone\"]\n+    /// Convert time to the local timezone\n     fn to_local() -> tm {\n         at(self.to_timespec())\n     }\n \n-    #[doc = \"Convert time to the UTC\"]\n+    /// Convert time to the UTC\n     fn to_utc() -> tm {\n         at_utc(self.to_timespec())\n     }\n \n-    #[doc = \"\n-    Return a string of the current time in the form\n-    \\\"Thu Jan  1 00:00:00 1970\\\".\n-    \"]\n+    /**\n+     * Return a string of the current time in the form\n+     * \"Thu Jan  1 00:00:00 1970\".\n+     */\n     fn ctime() -> str { self.strftime(\"%c\") }\n \n-    #[doc = \"Formats the time according to the format string.\"]\n+    /// Formats the time according to the format string.\n     fn strftime(format: str) -> str { strftime(format, self) }\n \n-    #[doc = \"\n-    Returns a time string formatted according to RFC 822.\n-\n-    local: \\\"Thu, 22 Mar 2012 07:53:18 PST\\\"\n-    utc:   \\\"Thu, 22 Mar 2012 14:53:18 UTC\\\"\n-    \"]\n+    /**\n+     * Returns a time string formatted according to RFC 822.\n+     *\n+     * local: \"Thu, 22 Mar 2012 07:53:18 PST\"\n+     * utc:   \"Thu, 22 Mar 2012 14:53:18 UTC\"\n+     */\n     fn rfc822() -> str {\n         if self.tm_gmtoff == 0_i32 {\n             self.strftime(\"%a, %d %b %Y %T GMT\")\n@@ -795,22 +795,22 @@ impl tm for tm {\n         }\n     }\n \n-    #[doc = \"\n-    Returns a time string formatted according to RFC 822 with Zulu time.\n-\n-    local: \\\"Thu, 22 Mar 2012 07:53:18 -0700\\\"\n-    utc:   \\\"Thu, 22 Mar 2012 14:53:18 -0000\\\"\n-    \"]\n+    /**\n+     * Returns a time string formatted according to RFC 822 with Zulu time.\n+     *\n+     * local: \"Thu, 22 Mar 2012 07:53:18 -0700\"\n+     * utc:   \"Thu, 22 Mar 2012 14:53:18 -0000\"\n+     */\n     fn rfc822z() -> str {\n         self.strftime(\"%a, %d %b %Y %T %z\")\n     }\n \n-    #[doc = \"\n-    Returns a time string formatted according to ISO 8601.\n-\n-    local: \\\"2012-02-22T07:53:18-07:00\\\"\n-    utc:   \\\"2012-02-22T14:53:18Z\\\"\n-    \"]\n+    /**\n+     * Returns a time string formatted according to ISO 8601.\n+     *\n+     * local: \"2012-02-22T07:53:18-07:00\"\n+     * utc:   \"2012-02-22T14:53:18Z\"\n+     */\n     fn rfc3339() -> str {\n         if self.tm_gmtoff == 0_i32 {\n             self.strftime(\"%Y-%m-%dT%H:%M:%SZ\")"}, {"sha": "87d7dd67577b4e6ab5edb304c98495427421d5f5", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 48, "deletions": 49, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,28 +1,26 @@\n-#[doc =\"\n-Utilities that leverage libuv's `uv_timer_*` API\n-\"];\n+//! Utilities that leverage libuv's `uv_timer_*` API\n \n import uv = uv;\n import uv::iotask;\n import iotask::iotask;\n export delayed_send, sleep, recv_timeout;\n \n-#[doc = \"\n-Wait for timeout period then send provided value over a channel\n-\n-This call returns immediately. Useful as the building block for a number\n-of higher-level timer functions.\n-\n-Is not guaranteed to wait for exactly the specified time, but will wait\n-for *at least* that period of time.\n-\n-# Arguments\n-\n-* `hl_loop` - a `uv::hl::high_level_loop` that the tcp request will run on\n-* msecs - a timeout period, in milliseconds, to wait\n-* ch - a channel of type T to send a `val` on\n-* val - a value of type T to send over the provided `ch`\n-\"]\n+/**\n+ * Wait for timeout period then send provided value over a channel\n+ *\n+ * This call returns immediately. Useful as the building block for a number\n+ * of higher-level timer functions.\n+ *\n+ * Is not guaranteed to wait for exactly the specified time, but will wait\n+ * for *at least* that period of time.\n+ *\n+ * # Arguments\n+ *\n+ * * `hl_loop` - a `uv::hl::high_level_loop` that the tcp request will run on\n+ * * msecs - a timeout period, in milliseconds, to wait\n+ * * ch - a channel of type T to send a `val` on\n+ * * val - a value of type T to send over the provided `ch`\n+ */\n fn delayed_send<T: copy send>(iotask: iotask,\n                               msecs: uint, ch: comm::chan<T>, val: T) {\n         unsafe {\n@@ -60,43 +58,44 @@ fn delayed_send<T: copy send>(iotask: iotask,\n     };\n }\n \n-#[doc = \"\n-Blocks the current task for (at least) the specified time period.\n-\n-Is not guaranteed to sleep for exactly the specified time, but will sleep\n-for *at least* that period of time.\n-\n-# Arguments\n-\n-* `iotask` - a `uv::iotask` that the tcp request will run on\n-* msecs - an amount of time, in milliseconds, for the current task to block\n-\"]\n+/**\n+ * Blocks the current task for (at least) the specified time period.\n+ *\n+ * Is not guaranteed to sleep for exactly the specified time, but will sleep\n+ * for *at least* that period of time.\n+ *\n+ * # Arguments\n+ *\n+ * * `iotask` - a `uv::iotask` that the tcp request will run on\n+ * * msecs - an amount of time, in milliseconds, for the current task to block\n+ */\n fn sleep(iotask: iotask, msecs: uint) {\n     let exit_po = comm::port::<()>();\n     let exit_ch = comm::chan(exit_po);\n     delayed_send(iotask, msecs, exit_ch, ());\n     comm::recv(exit_po);\n }\n \n-#[doc = \"\n-Receive on a port for (up to) a specified time, then return an `option<T>`\n-\n-This call will block to receive on the provided port for up to the specified\n-timeout. Depending on whether the provided port receives in that time period,\n-`recv_timeout` will return an `option<T>` representing the result.\n-\n-# Arguments\n-\n-* `iotask' - `uv::iotask` that the tcp request will run on\n-* msecs - an mount of time, in milliseconds, to wait to receive\n-* wait_port - a `comm::port<T>` to receive on\n-\n-# Returns\n-\n-An `option<T>` representing the outcome of the call. If the call `recv`'d on\n-the provided port in the allotted timeout period, then the result will be a\n-`some(T)`. If not, then `none` will be returned.\n-\"]\n+/**\n+ * Receive on a port for (up to) a specified time, then return an `option<T>`\n+ *\n+ * This call will block to receive on the provided port for up to the\n+ * specified timeout. Depending on whether the provided port receives in that\n+ * time period, `recv_timeout` will return an `option<T>` representing the\n+ * result.\n+ *\n+ * # Arguments\n+ *\n+ * * `iotask' - `uv::iotask` that the tcp request will run on\n+ * * msecs - an mount of time, in milliseconds, to wait to receive\n+ * * wait_port - a `comm::port<T>` to receive on\n+ *\n+ * # Returns\n+ *\n+ * An `option<T>` representing the outcome of the call. If the call `recv`'d\n+ * on the provided port in the allotted timeout period, then the result will\n+ * be a `some(T)`. If not, then `none` will be returned.\n+ */\n fn recv_timeout<T: copy send>(iotask: iotask,\n                               msecs: uint,\n                               wait_po: comm::port<T>) -> option<T> {"}, {"sha": "1fde1c4fd6ae6420c32f13fa271d8b18d2cdc603", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,10 +1,10 @@\n-#[doc = \"\n-A key,value store that works on anything.\n-\n-This works using a binary search tree. In the first version, it's a\n-very naive algorithm, but it will probably be updated to be a\n-red-black tree or something else.\n-\"];\n+/*!\n+ * A key,value store that works on anything.\n+ *\n+ * This works using a binary search tree. In the first version, it's a\n+ * very naive algorithm, but it will probably be updated to be a\n+ * red-black tree or something else.\n+ */\n \n import core::option::{some, none};\n import option = core::option;\n@@ -25,10 +25,10 @@ enum tree_node<K, V> = {\n     mut right: tree_edge<K, V>\n };\n \n-#[doc = \"Create a treemap\"]\n+/// Create a treemap\n fn treemap<K, V>() -> treemap<K, V> { @mut none }\n \n-#[doc = \"Insert a value into the map\"]\n+/// Insert a value into the map\n fn insert<K: copy, V: copy>(m: &mut tree_edge<K, V>, k: K, v: V) {\n     alt copy *m {\n       none {\n@@ -50,7 +50,7 @@ fn insert<K: copy, V: copy>(m: &mut tree_edge<K, V>, k: K, v: V) {\n     };\n }\n \n-#[doc = \"Find a value based on the key\"]\n+/// Find a value based on the key\n fn find<K: copy, V: copy>(m: &const tree_edge<K, V>, k: K) -> option<V> {\n     alt copy *m {\n       none { none }\n@@ -68,7 +68,7 @@ fn find<K: copy, V: copy>(m: &const tree_edge<K, V>, k: K) -> option<V> {\n     }\n }\n \n-#[doc = \"Visit all pairs in the map in order.\"]\n+/// Visit all pairs in the map in order.\n fn traverse<K, V: copy>(m: &const tree_edge<K, V>, f: fn(K, V)) {\n     alt copy *m {\n       none { }"}, {"sha": "1101be170bac90ab3b47a0c57a9b29152c248d86", "filename": "src/libstd/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Futil.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,9 +1,9 @@\n-#[doc = \"The identity function\"]\n+/// The identity function\n pure fn id<T: copy>(x: T) -> T { x }\n \n /* FIXME (issue #141):  See test/run-pass/constrained-type.rs.  Uncomment\n  * the constraint once fixed. */\n-#[doc = \"A rational number\"]\n+/// A rational number\n type rational = {num: int, den: int}; // : int::positive(*.den);\n \n pure fn rational_leq(x: rational, y: rational) -> bool {"}, {"sha": "50f5d9704faeb41cf876b2be70de4aad74db55be", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,27 +1,27 @@\n-#[doc = \"\n-Rust bindings to libuv\n-\n-This is the base-module for various levels of bindings to\n-the libuv library.\n-\n-These modules are seeing heavy work, currently, and the final\n-API layout should not be inferred from its current form.\n-\n-This base module currently contains a historical, rust-based\n-implementation of a few libuv operations that hews closely to\n-the patterns of the libuv C-API. It was used, mostly, to explore\n-some implementation details and will most likely be deprecated\n-in the near future.\n-\n-The `ll` module contains low-level mappings for working directly\n-with the libuv C-API.\n-\n-The `hl` module contains a set of tools library developers can\n-use for interacting with an active libuv loop. This modules's\n-API is meant to be used to write high-level,\n-rust-idiomatic abstractions for utilizes libuv's asynchronous IO\n-facilities.\n-\"];\n+/*!\n+ * Rust bindings to libuv\n+ *\n+ * This is the base-module for various levels of bindings to\n+ * the libuv library.\n+ *\n+ * These modules are seeing heavy work, currently, and the final\n+ * API layout should not be inferred from its current form.\n+ *\n+ * This base module currently contains a historical, rust-based\n+ * implementation of a few libuv operations that hews closely to\n+ * the patterns of the libuv C-API. It was used, mostly, to explore\n+ * some implementation details and will most likely be deprecated\n+ * in the near future.\n+ *\n+ * The `ll` module contains low-level mappings for working directly\n+ * with the libuv C-API.\n+ *\n+ * The `hl` module contains a set of tools library developers can\n+ * use for interacting with an active libuv loop. This modules's\n+ * API is meant to be used to write high-level,\n+ * rust-idiomatic abstractions for utilizes libuv's asynchronous IO\n+ * facilities.\n+ */\n \n import ll = uv_ll;\n export ll;"}, {"sha": "a099d4f8b187edfed50ef56295a78d6ccbaddab3", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,6 +1,4 @@\n-#[doc=\"\n-A process-wide libuv event loop for library use.\n-\"];\n+//! A process-wide libuv event loop for library use.\n \n export get;\n \n@@ -16,18 +14,18 @@ extern mod rustrt {\n     fn rust_uv_get_kernel_global_chan_ptr() -> *libc::uintptr_t;\n }\n \n-#[doc =\"\n-Race-free helper to get access to a global task where a libuv\n-loop is running.\n-\n-Use `uv::hl::interact` to do operations against the global\n-loop that this function returns.\n-\n-# Return\n-\n-* A `hl::high_level_loop` that encapsulates communication with the global\n-loop.\n-\"]\n+/**\n+ * Race-free helper to get access to a global task where a libuv\n+ * loop is running.\n+ *\n+ * Use `uv::hl::interact` to do operations against the global\n+ * loop that this function returns.\n+ *\n+ * # Return\n+ *\n+ * * A `hl::high_level_loop` that encapsulates communication with the global\n+ * loop.\n+ */\n fn get() -> iotask {\n     ret get_monitor_task_gl();\n }"}, {"sha": "35e4446f8d83386469ee7b177b4a211d1647fe74", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 38, "deletions": 44, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,11 +1,9 @@\n-#[doc = \"\n-\n-A task-based interface to the uv loop\n-\n-The I/O task runs in its own single-threaded scheduler.  By using the\n-`interact` function you can execute code in a uv callback.\n-\n-\"];\n+/*!\n+ * A task-based interface to the uv loop\n+ *\n+ * The I/O task runs in its own single-threaded scheduler.  By using the\n+ * `interact` function you can execute code in a uv callback.\n+ */\n \n export iotask;\n export spawn_iotask;\n@@ -17,9 +15,7 @@ import ptr::addr_of;\n import comm::{port, chan, methods, listen};\n import ll = uv_ll;\n \n-#[doc = \"\n-Used to abstract-away direct interaction with a libuv loop.\n-\"]\n+/// Used to abstract-away direct interaction with a libuv loop.\n enum iotask {\n     iotask_({\n         async_handle: *ll::uv_async_t,\n@@ -52,40 +48,40 @@ fn spawn_iotask(-builder: task::builder) -> iotask {\n }\n \n \n-#[doc = \"\n-Provide a callback to be processed by `iotask`\n-\n-The primary way to do operations again a running `iotask` that\n-doesn't involve creating a uv handle via `safe_handle`\n-\n-# Warning\n-\n-This function is the only safe way to interact with _any_ `iotask`.\n-Using functions in the `uv::ll` module outside of the `cb` passed into\n-this function is _very dangerous_.\n-\n-# Arguments\n-\n-* iotask - a uv I/O task that you want to do operations against\n-* cb - a function callback to be processed on the running loop's\n-thread. The only parameter passed in is an opaque pointer representing the\n-running `uv_loop_t*`. In the context of this callback, it is safe to use\n-this pointer to do various uv_* API calls contained within the `uv::ll`\n-module. It is not safe to send the `loop_ptr` param to this callback out\n-via ports/chans.\n-\"]\n+/**\n+ * Provide a callback to be processed by `iotask`\n+ *\n+ * The primary way to do operations again a running `iotask` that\n+ * doesn't involve creating a uv handle via `safe_handle`\n+ *\n+ * # Warning\n+ *\n+ * This function is the only safe way to interact with _any_ `iotask`.\n+ * Using functions in the `uv::ll` module outside of the `cb` passed into\n+ * this function is _very dangerous_.\n+ *\n+ * # Arguments\n+ *\n+ * * iotask - a uv I/O task that you want to do operations against\n+ * * cb - a function callback to be processed on the running loop's\n+ * thread. The only parameter passed in is an opaque pointer representing the\n+ * running `uv_loop_t*`. In the context of this callback, it is safe to use\n+ * this pointer to do various uv_* API calls contained within the `uv::ll`\n+ * module. It is not safe to send the `loop_ptr` param to this callback out\n+ * via ports/chans.\n+ */\n unsafe fn interact(iotask: iotask,\n                    -cb: fn~(*c_void)) {\n     send_msg(iotask, interaction(cb));\n }\n \n-#[doc=\"\n-Shut down the I/O task\n-\n-Is used to signal to the loop that it should close the internally-held\n-async handle and do a sanity check to make sure that all other handles are\n-closed, causing a failure otherwise.\n-\"]\n+/**\n+ * Shut down the I/O task\n+ *\n+ * Is used to signal to the loop that it should close the internally-held\n+ * async handle and do a sanity check to make sure that all other handles are\n+ * closed, causing a failure otherwise.\n+ */\n fn exit(iotask: iotask) unsafe {\n     send_msg(iotask, teardown_loop);\n }\n@@ -98,9 +94,7 @@ enum iotask_msg {\n     teardown_loop\n }\n \n-#[doc = \"\n-Run the loop and begin handling messages\n-\"]\n+/// Run the loop and begin handling messages\n fn run_loop(iotask_ch: chan<iotask>) unsafe {\n \n     let loop_ptr = ll::loop_new();\n@@ -147,7 +141,7 @@ fn send_msg(iotask: iotask,\n     ll::async_send(iotask.async_handle);\n }\n \n-#[doc =\"Dispatch all pending messages\"]\n+/// Dispatch all pending messages\n extern fn wake_up_cb(async_handle: *ll::uv_async_t,\n                     status: int) unsafe {\n "}, {"sha": "dfb64fc430bead4e906fd9edf1581d5e302c7e37", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,24 +1,24 @@\n-#[doc = \"\n-Low-level bindings to the libuv library.\n-\n-This module contains a set of direct, 'bare-metal' wrappers around\n-the libuv C-API.\n-\n-Also contained herein are a set of rust records that map, in\n-approximate memory-size, to the libuv data structures. The record\n-implementations are adjusted, per-platform, to match their respective\n-representations.\n-\n-There are also a collection of helper functions to ease interacting\n-with the low-level API (such as a function to return the latest\n-libuv error as a rust-formatted string).\n-\n-As new functionality, existant in uv.h, is added to the rust stdlib,\n-the mappings should be added in this module.\n-\n-This module's implementation will hopefully be, eventually, replaced\n-with per-platform, generated source files from rust-bindgen.\n-\"];\n+/*!\n+ * Low-level bindings to the libuv library.\n+ *\n+ * This module contains a set of direct, 'bare-metal' wrappers around\n+ * the libuv C-API.\n+ *\n+ * Also contained herein are a set of rust records that map, in\n+ * approximate memory-size, to the libuv data structures. The record\n+ * implementations are adjusted, per-platform, to match their respective\n+ * representations.\n+ *\n+ * There are also a collection of helper functions to ease interacting\n+ * with the low-level API (such as a function to return the latest\n+ * libuv error as a rust-formatted string).\n+ *\n+ * As new functionality, existant in uv.h, is added to the rust stdlib,\n+ * the mappings should be added in this module.\n+ *\n+ * This module's implementation will hopefully be, eventually, replaced\n+ * with per-platform, generated source files from rust-bindgen.\n+ */\n \n import libc::size_t;\n "}, {"sha": "551c6817405dcf353545b04e2531aa0949fc4986", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -365,7 +365,7 @@ fn is_self(d: ast::def) -> bool {\n   }\n }\n \n-#[doc = \"Maps a binary operator to its precedence\"]\n+/// Maps a binary operator to its precedence\n fn operator_prec(op: ast::binop) -> uint {\n   alt op {\n       mul | div | rem   { 12u }"}, {"sha": "838e275332b8705a0c7d63d709fbfa28e15d0b19", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -120,10 +120,10 @@ fn get_meta_item_name(meta: @ast::meta_item) -> ast::ident {\n     }\n }\n \n-#[doc = \"\n-Gets the string value if the meta_item is a meta_name_value variant\n-containing a string, otherwise none\n-\"]\n+/**\n+ * Gets the string value if the meta_item is a meta_name_value variant\n+ * containing a string, otherwise none\n+ */\n fn get_meta_item_value_str(meta: @ast::meta_item) -> option<@str> {\n     alt meta.node {\n       ast::meta_name_value(_, v) {\n@@ -140,18 +140,18 @@ fn get_meta_item_value_str(meta: @ast::meta_item) -> option<@str> {\n     }\n }\n \n-#[doc = \"Gets a list of inner meta items from a list meta_item type\"]\n+/// Gets a list of inner meta items from a list meta_item type\n fn get_meta_item_list(meta: @ast::meta_item) -> option<~[@ast::meta_item]> {\n     alt meta.node {\n       ast::meta_list(_, l) { option::some(/* FIXME (#2543) */ copy l) }\n       _ { option::none }\n     }\n }\n \n-#[doc = \"\n-If the meta item is a nam-value type with a string value then returns\n-a tuple containing the name and string value, otherwise `none`\n-\"]\n+/**\n+ * If the meta item is a nam-value type with a string value then returns\n+ * a tuple containing the name and string value, otherwise `none`\n+ */\n fn get_name_value_str_pair(\n     item: @ast::meta_item\n ) -> option<(ast::ident, @str)> {\n@@ -167,9 +167,7 @@ fn get_name_value_str_pair(\n \n /* Searching */\n \n-#[doc = \"\n-Search a list of attributes and return only those with a specific name\n-\"]\n+/// Search a list of attributes and return only those with a specific name\n fn find_attrs_by_name(attrs: ~[ast::attribute], +name: str) ->\n    ~[ast::attribute] {\n     let filter = (\n@@ -182,9 +180,7 @@ fn find_attrs_by_name(attrs: ~[ast::attribute], +name: str) ->\n     ret vec::filter_map(attrs, filter);\n }\n \n-#[doc = \"\n-Searcha list of meta items and return only those with a specific name\n-\"]\n+/// Searcha list of meta items and return only those with a specific name\n fn find_meta_items_by_name(metas: ~[@ast::meta_item], +name: str) ->\n    ~[@ast::meta_item] {\n     let filter = fn@(&&m: @ast::meta_item) -> option<@ast::meta_item> {\n@@ -195,10 +191,10 @@ fn find_meta_items_by_name(metas: ~[@ast::meta_item], +name: str) ->\n     ret vec::filter_map(metas, filter);\n }\n \n-#[doc = \"\n-Returns true if a list of meta items contains another meta item. The\n-comparison is performed structurally.\n-\"]\n+/**\n+ * Returns true if a list of meta items contains another meta item. The\n+ * comparison is performed structurally.\n+ */\n fn contains(haystack: ~[@ast::meta_item], needle: @ast::meta_item) -> bool {\n     #debug(\"looking for %s\",\n            print::pprust::meta_item_to_str(*needle));\n@@ -332,10 +328,10 @@ fn find_linkage_attrs(attrs: ~[ast::attribute]) -> ~[ast::attribute] {\n     ret found;\n }\n \n-#[doc = \"\n-From a list of crate attributes get only the meta_items that impact crate\n-linkage\n-\"]\n+/**\n+ * From a list of crate attributes get only the meta_items that impact crate\n+ * linkage\n+ */\n fn find_linkage_metas(attrs: ~[ast::attribute]) -> ~[@ast::meta_item] {\n     do find_linkage_attrs(attrs).flat_map |attr| {\n         alt check attr.node.value.node {\n@@ -370,7 +366,7 @@ enum inline_attr {\n     ia_always\n }\n \n-#[doc = \"True if something like #[inline] is found in the list of attrs.\"]\n+/// True if something like #[inline] is found in the list of attrs.\n fn find_inline_attr(attrs: ~[ast::attribute]) -> inline_attr {\n     // TODO---validate the usage of #[inline] and #[inline(always)]\n     do vec::foldl(ia_none, attrs) |ia,attr| {"}, {"sha": "04f533be5bf87a7bc28aa2dacc44cfe14447cb31", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"The main parser interface\"];\n+//! The main parser interface\n import dvec::extensions;\n \n export parse_sess;"}, {"sha": "a85e791696ff983873ea2c722a216d52c2f41a4f", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -24,7 +24,7 @@ enum tt_frame_up { /* to break a circularity */\n }\n \n /* TODO: figure out how to have a uniquely linked stack, and change to `~` */\n-#[doc = \"an unzipping of `token_tree`s\"]\n+/// an unzipping of `token_tree`s\n type tt_frame = @{\n     readme: ~[ast::token_tree],\n     mut idx: uint,"}, {"sha": "c92923088104607036803632edd528969abf11f5", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1057,7 +1057,7 @@ class parser {\n     }\n \n     fn parse_token_tree() -> token_tree {\n-        #[doc=\"what's the opposite delimiter?\"]\n+        /// what's the opposite delimiter?\n         fn flip(&t: token::token) -> token::token {\n             alt t {\n               token::LPAREN { token::RPAREN }"}, {"sha": "8ea7306e1808787ba284a7c74f38a05d29b12f54", "filename": "src/libsyntax/parse/prec.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibsyntax%2Fparse%2Fprec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibsyntax%2Fparse%2Fprec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fprec.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -6,17 +6,19 @@ import token::*;\n import token::token;\n import ast::*;\n \n-#[doc = \"Unary operators have higher precedence than binary\"]\n+/// Unary operators have higher precedence than binary\n const unop_prec: uint = 100u;\n \n-#[doc = \"\n-Precedence of the `as` operator, which is a binary operator\n-but is not represented in the precedence table.\n-\"]\n+/**\n+ * Precedence of the `as` operator, which is a binary operator\n+ * but is not represented in the precedence table.\n+ */\n const as_prec: uint = 11u;\n \n-#[doc = \"Maps a token to a record specifying the corresponding binary\n-         operator and its precedence\"]\n+/**\n+ * Maps a token to a record specifying the corresponding binary\n+ * operator and its precedence\n+ */\n fn token_to_binop(tok: token) -> option<ast::binop> {\n   alt tok {\n       BINOP(STAR)    { some(mul) }"}, {"sha": "c4ae9269914f980d1e695d5e49afb88fc5dbe791", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -85,7 +85,7 @@ enum token {\n }\n \n #[auto_serialize]\n-#[doc = \"For interpolation during macro expansion.\"]\n+/// For interpolation during macro expansion.\n enum whole_nt {\n     w_item(@ast::item),\n     w_block(ast::blk),\n@@ -233,14 +233,14 @@ pure fn is_bar(t: token) -> bool {\n     alt t { BINOP(OR) | OROR { true } _ { false } }\n }\n \n-#[doc = \"\n-All the valid words that have meaning in the Rust language.\n-\n-Rust keywords are either 'contextual' or 'restricted'. Contextual\n-keywords may be used as identifiers because their appearance in\n-the grammar is unambiguous. Restricted keywords may not appear\n-in positions that might otherwise contain _value identifiers_.\n-\"]\n+/**\n+ * All the valid words that have meaning in the Rust language.\n+ *\n+ * Rust keywords are either 'contextual' or 'restricted'. Contextual\n+ * keywords may be used as identifiers because their appearance in\n+ * the grammar is unambiguous. Restricted keywords may not appear\n+ * in positions that might otherwise contain _value identifiers_.\n+ */\n fn keyword_table() -> hashmap<str, ()> {\n     let keywords = str_hash();\n     for contextual_keyword_table().each_key |word| {\n@@ -252,7 +252,7 @@ fn keyword_table() -> hashmap<str, ()> {\n     keywords\n }\n \n-#[doc = \"Keywords that may be used as identifiers\"]\n+/// Keywords that may be used as identifiers\n fn contextual_keyword_table() -> hashmap<str, ()> {\n     let words = str_hash();\n     let keys = ~[\n@@ -274,19 +274,20 @@ fn contextual_keyword_table() -> hashmap<str, ()> {\n     words\n }\n \n-#[doc = \"\n-Keywords that may not appear in any position that might otherwise contain a\n-_value identifier_. Restricted keywords may still be used as other types of\n-identifiers.\n-\n-Reasons:\n-\n-* For some (most?), if used at the start of a line, they will cause the line\n-  to be interpreted as a specific kind of statement, which would be confusing.\n-\n-* `true` or `false` as identifiers would always be shadowed by\n-  the boolean constants\n-\"]\n+/**\n+ * Keywords that may not appear in any position that might otherwise contain a\n+ * _value identifier_. Restricted keywords may still be used as other types of\n+ * identifiers.\n+ *\n+ * Reasons:\n+ *\n+ * * For some (most?), if used at the start of a line, they will cause the\n+ *   line to be interpreted as a specific kind of statement, which would be\n+ *   confusing.\n+ *\n+ * * `true` or `false` as identifiers would always be shadowed by\n+ *   the boolean constants\n+ */\n fn restricted_keyword_table() -> hashmap<str, ()> {\n     let words = str_hash();\n     let keys = ~["}, {"sha": "bb0f82e89fc6ab4d6db3756555a58c9689f519f9", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -44,13 +44,13 @@ mod parse {\n     mod comments;\n     mod attr;\n \n-    #[doc = \"Common routines shared by parser mods\"]\n+    /// Common routines shared by parser mods\n     mod common;\n \n-    #[doc = \"Functions dealing with operator precedence\"]\n+    /// Functions dealing with operator precedence\n     mod prec;\n \n-    #[doc = \"Routines the parser uses to classify AST nodes\"]\n+    /// Routines the parser uses to classify AST nodes\n     mod classify;\n }\n "}, {"sha": "799f34377ede4955bb503fd7982f8f6a5f97ba74", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -18,10 +18,10 @@ import std::map::hashmap;\n enum pp_mode {ppm_normal, ppm_expanded, ppm_typed, ppm_identified,\n               ppm_expanded_identified }\n \n-#[doc = \"\n-The name used for source code that doesn't originate in a file\n-(e.g. source from stdin or a string)\n-\"]\n+/**\n+ * The name used for source code that doesn't originate in a file\n+ * (e.g. source from stdin or a string)\n+ */\n fn anon_src() -> str { \"<anon>\" }\n \n fn source_name(input: input) -> str {\n@@ -88,9 +88,9 @@ fn parse_cfgspecs(cfgspecs: ~[str]) -> ast::crate_cfg {\n }\n \n enum input {\n-    #[doc = \"Load source from file\"]\n+    /// Load source from file\n     file_input(str),\n-    #[doc = \"The string is the source\"]\n+    /// The string is the source\n     str_input(str)\n }\n "}, {"sha": "49c829adc00eeae60c2616604e761123ebcb6263", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -167,7 +167,7 @@ impl session for session {\n     fn fast_resolve() -> bool { self.debugging_opt(fast_resolve) }\n }\n \n-#[doc = \"Some reasonable defaults\"]\n+/// Some reasonable defaults\n fn basic_options() -> @options {\n     @{\n         crate_type: session::lib_crate,"}, {"sha": "c755235f4e8965c2853c92dd654420fefca60468", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,8 +1,4 @@\n-#[doc = \"\n-\n-Validates all used crates and extern libraries and loads their metadata\n-\n-\"];\n+//! Validates all used crates and extern libraries and loads their metadata\n \n import syntax::diagnostic::span_handler;\n import syntax::{ast, ast_util};"}, {"sha": "aec32aecc430907915cba6dcfecd960d12950d0f", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -82,7 +82,7 @@ fn resolve_path(cstore: cstore::cstore, cnum: ast::crate_num,\n     ret result;\n }\n \n-#[doc=\"Iterates over all the paths in the given crate.\"]\n+/// Iterates over all the paths in the given crate.\n fn each_path(cstore: cstore::cstore, cnum: ast::crate_num,\n              f: fn(decoder::path_entry) -> bool) {\n     let crate_data = cstore::get_crate_data(cstore, cnum);"}, {"sha": "21cfd77bd1604d28a9a939e056eb91c79a057fdc", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -414,7 +414,7 @@ class path_entry {\n     }\n }\n \n-#[doc=\"Iterates over all the paths in the given crate.\"]\n+/// Iterates over all the paths in the given crate.\n fn each_path(cdata: cmd, f: fn(path_entry) -> bool) {\n     let root = ebml::doc(cdata.data);\n     let items = ebml::get_doc(root, tag_items);"}, {"sha": "63f3658a4e93ec872f8cac0a756550f68463ba92", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,8 +1,4 @@\n-#[doc = \"\n-\n-Finds crate binaries and loads their metadata\n-\n-\"];\n+//! Finds crate binaries and loads their metadata\n \n import syntax::diagnostic::span_handler;\n import syntax::{ast, attr};"}, {"sha": "38559aec28dd2084d7add43075c53d1047077103", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 148, "deletions": 150, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,152 +1,150 @@\n-#[doc = \"\n-\n-# Borrow check\n-\n-This pass is in job of enforcing *memory safety* and *purity*.  As\n-memory safety is by far the more complex topic, I'll focus on that in\n-this description, but purity will be covered later on. In the context\n-of Rust, memory safety means three basic things:\n-\n-- no writes to immutable memory;\n-- all pointers point to non-freed memory;\n-- all pointers point to memory of the same type as the pointer.\n-\n-The last point might seem confusing: after all, for the most part,\n-this condition is guaranteed by the type check.  However, there are\n-two cases where the type check effectively delegates to borrow check.\n-\n-The first case has to do with enums.  If there is a pointer to the\n-interior of an enum, and the enum is in a mutable location (such as a\n-local variable or field declared to be mutable), it is possible that\n-the user will overwrite the enum with a new value of a different\n-variant, and thus effectively change the type of the memory that the\n-pointer is pointing at.\n-\n-The second case has to do with mutability.  Basically, the type\n-checker has only a limited understanding of mutability.  It will allow\n-(for example) the user to get an immutable pointer with the address of\n-a mutable local variable.  It will also allow a `@mut T` or `~mut T`\n-pointer to be borrowed as a `&r.T` pointer.  These seeming oversights\n-are in fact intentional; they allow the user to temporarily treat a\n-mutable value as immutable.  It is up to the borrow check to guarantee\n-that the value in question is not in fact mutated during the lifetime\n-`r` of the reference.\n-\n-# Summary of the safety check\n-\n-In order to enforce mutability, the borrow check has three tricks up\n-its sleeve.\n-\n-First, data which is uniquely tied to the current stack frame (that'll\n-be defined shortly) is tracked very precisely.  This means that, for\n-example, if an immutable pointer to a mutable local variable is\n-created, the borrowck will simply check for assignments to that\n-particular local variable: no other memory is affected.\n-\n-Second, if the data is not uniquely tied to the stack frame, it may\n-still be possible to ensure its validity by rooting garbage collected\n-pointers at runtime.  For example, if there is a mutable local\n-variable `x` of type `@T`, and its contents are borrowed with an\n-expression like `&*x`, then the value of `x` will be rooted (today,\n-that means its ref count will be temporary increased) for the lifetime\n-of the reference that is created.  This means that the pointer remains\n-valid even if `x` is reassigned.\n-\n-Finally, if neither of these two solutions are applicable, then we\n-require that all operations within the scope of the reference be\n-*pure*.  A pure operation is effectively one that does not write to\n-any aliasable memory.  This means that it is still possible to write\n-to local variables or other data that is uniquely tied to the stack\n-frame (there's that term again; formal definition still pending) but\n-not to data reached via a `&T` or `@T` pointer.  Such writes could\n-possibly have the side-effect of causing the data which must remain\n-valid to be overwritten.\n-\n-# Possible future directions\n-\n-There are numerous ways that the `borrowck` could be strengthened, but\n-these are the two most likely:\n-\n-- flow-sensitivity: we do not currently consider flow at all but only\n-  block-scoping.  This means that innocent code like the following is\n-  rejected:\n-\n-      let mut x: int;\n-      ...\n-      x = 5;\n-      let y: &int = &x; // immutable ptr created\n-      ...\n-\n-  The reason is that the scope of the pointer `y` is the entire\n-  enclosing block, and the assignment `x = 5` occurs within that\n-  block.  The analysis is not smart enough to see that `x = 5` always\n-  happens before the immutable pointer is created.  This is relatively\n-  easy to fix and will surely be fixed at some point.\n-\n-- finer-grained purity checks: currently, our fallback for\n-  guaranteeing random references into mutable, aliasable memory is to\n-  require *total purity*.  This is rather strong.  We could use local\n-  type-based alias analysis to distinguish writes that could not\n-  possibly invalid the references which must be guaranteed.  This\n-  would only work within the function boundaries; function calls would\n-  still require total purity.  This seems less likely to be\n-  implemented in the short term as it would make the code\n-  significantly more complex; there is currently no code to analyze\n-  the types and determine the possible impacts of a write.\n-\n-# Terminology\n-\n-A **loan** is .\n-\n-# How the code works\n-\n-The borrow check code is divided into several major modules, each of\n-which is documented in its own file.\n-\n-The `gather_loans` and `check_loans` are the two major passes of the\n-analysis.  The `gather_loans` pass runs over the IR once to determine\n-what memory must remain valid and for how long.  Its name is a bit of\n-a misnomer; it does in fact gather up the set of loans which are\n-granted, but it also determines when @T pointers must be rooted and\n-for which scopes purity must be required.\n-\n-The `check_loans` pass walks the IR and examines the loans and purity\n-requirements computed in `gather_loans`.  It checks to ensure that (a)\n-the conditions of all loans are honored; (b) no contradictory loans\n-were granted (for example, loaning out the same memory as mutable and\n-immutable simultaneously); and (c) any purity requirements are\n-honored.\n-\n-The remaining modules are helper modules used by `gather_loans` and\n-`check_loans`:\n-\n-- `categorization` has the job of analyzing an expression to determine\n-  what kind of memory is used in evaluating it (for example, where\n-  dereferences occur and what kind of pointer is dereferenced; whether\n-  the memory is mutable; etc)\n-- `loan` determines when data uniquely tied to the stack frame can be\n-  loaned out.\n-- `preserve` determines what actions (if any) must be taken to preserve\n-  aliasable data.  This is the code which decides when to root\n-  an @T pointer or to require purity.\n-\n-# Maps that are created\n-\n-Borrowck results in two maps.\n-\n-- `root_map`: identifies those expressions or patterns whose result\n-  needs to be rooted.  Conceptually the root_map maps from an\n-  expression or pattern node to a `node_id` identifying the scope for\n-  which the expression must be rooted (this `node_id` should identify\n-  a block or call).  The actual key to the map is not an expression id,\n-  however, but a `root_map_key`, which combines an expression id with a\n-  deref count and is used to cope with auto-deref.\n-\n-- `mutbl_map`: identifies those local variables which are modified or\n-  moved. This is used by trans to guarantee that such variables are\n-  given a memory location and not used as immediates.\n-\n-\"];\n+/*!\n+ * # Borrow check\n+ *\n+ * This pass is in job of enforcing *memory safety* and *purity*.  As\n+ * memory safety is by far the more complex topic, I'll focus on that in\n+ * this description, but purity will be covered later on. In the context\n+ * of Rust, memory safety means three basic things:\n+ *\n+ * - no writes to immutable memory;\n+ * - all pointers point to non-freed memory;\n+ * - all pointers point to memory of the same type as the pointer.\n+ *\n+ * The last point might seem confusing: after all, for the most part,\n+ * this condition is guaranteed by the type check.  However, there are\n+ * two cases where the type check effectively delegates to borrow check.\n+ *\n+ * The first case has to do with enums.  If there is a pointer to the\n+ * interior of an enum, and the enum is in a mutable location (such as a\n+ * local variable or field declared to be mutable), it is possible that\n+ * the user will overwrite the enum with a new value of a different\n+ * variant, and thus effectively change the type of the memory that the\n+ * pointer is pointing at.\n+ *\n+ * The second case has to do with mutability.  Basically, the type\n+ * checker has only a limited understanding of mutability.  It will allow\n+ * (for example) the user to get an immutable pointer with the address of\n+ * a mutable local variable.  It will also allow a `@mut T` or `~mut T`\n+ * pointer to be borrowed as a `&r.T` pointer.  These seeming oversights\n+ * are in fact intentional; they allow the user to temporarily treat a\n+ * mutable value as immutable.  It is up to the borrow check to guarantee\n+ * that the value in question is not in fact mutated during the lifetime\n+ * `r` of the reference.\n+ *\n+ * # Summary of the safety check\n+ *\n+ * In order to enforce mutability, the borrow check has three tricks up\n+ * its sleeve.\n+ *\n+ * First, data which is uniquely tied to the current stack frame (that'll\n+ * be defined shortly) is tracked very precisely.  This means that, for\n+ * example, if an immutable pointer to a mutable local variable is\n+ * created, the borrowck will simply check for assignments to that\n+ * particular local variable: no other memory is affected.\n+ *\n+ * Second, if the data is not uniquely tied to the stack frame, it may\n+ * still be possible to ensure its validity by rooting garbage collected\n+ * pointers at runtime.  For example, if there is a mutable local\n+ * variable `x` of type `@T`, and its contents are borrowed with an\n+ * expression like `&*x`, then the value of `x` will be rooted (today,\n+ * that means its ref count will be temporary increased) for the lifetime\n+ * of the reference that is created.  This means that the pointer remains\n+ * valid even if `x` is reassigned.\n+ *\n+ * Finally, if neither of these two solutions are applicable, then we\n+ * require that all operations within the scope of the reference be\n+ * *pure*.  A pure operation is effectively one that does not write to\n+ * any aliasable memory.  This means that it is still possible to write\n+ * to local variables or other data that is uniquely tied to the stack\n+ * frame (there's that term again; formal definition still pending) but\n+ * not to data reached via a `&T` or `@T` pointer.  Such writes could\n+ * possibly have the side-effect of causing the data which must remain\n+ * valid to be overwritten.\n+ *\n+ * # Possible future directions\n+ *\n+ * There are numerous ways that the `borrowck` could be strengthened, but\n+ * these are the two most likely:\n+ *\n+ * - flow-sensitivity: we do not currently consider flow at all but only\n+ *   block-scoping.  This means that innocent code like the following is\n+ *   rejected:\n+ *\n+ *       let mut x: int;\n+ *       ...\n+ *       x = 5;\n+ *       let y: &int = &x; // immutable ptr created\n+ *       ...\n+ *\n+ *   The reason is that the scope of the pointer `y` is the entire\n+ *   enclosing block, and the assignment `x = 5` occurs within that\n+ *   block.  The analysis is not smart enough to see that `x = 5` always\n+ *   happens before the immutable pointer is created.  This is relatively\n+ *   easy to fix and will surely be fixed at some point.\n+ *\n+ * - finer-grained purity checks: currently, our fallback for\n+ *   guaranteeing random references into mutable, aliasable memory is to\n+ *   require *total purity*.  This is rather strong.  We could use local\n+ *   type-based alias analysis to distinguish writes that could not\n+ *   possibly invalid the references which must be guaranteed.  This\n+ *   would only work within the function boundaries; function calls would\n+ *   still require total purity.  This seems less likely to be\n+ *   implemented in the short term as it would make the code\n+ *   significantly more complex; there is currently no code to analyze\n+ *   the types and determine the possible impacts of a write.\n+ *\n+ * # Terminology\n+ *\n+ * A **loan** is .\n+ *\n+ * # How the code works\n+ *\n+ * The borrow check code is divided into several major modules, each of\n+ * which is documented in its own file.\n+ *\n+ * The `gather_loans` and `check_loans` are the two major passes of the\n+ * analysis.  The `gather_loans` pass runs over the IR once to determine\n+ * what memory must remain valid and for how long.  Its name is a bit of\n+ * a misnomer; it does in fact gather up the set of loans which are\n+ * granted, but it also determines when @T pointers must be rooted and\n+ * for which scopes purity must be required.\n+ *\n+ * The `check_loans` pass walks the IR and examines the loans and purity\n+ * requirements computed in `gather_loans`.  It checks to ensure that (a)\n+ * the conditions of all loans are honored; (b) no contradictory loans\n+ * were granted (for example, loaning out the same memory as mutable and\n+ * immutable simultaneously); and (c) any purity requirements are\n+ * honored.\n+ *\n+ * The remaining modules are helper modules used by `gather_loans` and\n+ * `check_loans`:\n+ *\n+ * - `categorization` has the job of analyzing an expression to determine\n+ *   what kind of memory is used in evaluating it (for example, where\n+ *   dereferences occur and what kind of pointer is dereferenced; whether\n+ *   the memory is mutable; etc)\n+ * - `loan` determines when data uniquely tied to the stack frame can be\n+ *   loaned out.\n+ * - `preserve` determines what actions (if any) must be taken to preserve\n+ *   aliasable data.  This is the code which decides when to root\n+ *   an @T pointer or to require purity.\n+ *\n+ * # Maps that are created\n+ *\n+ * Borrowck results in two maps.\n+ *\n+ * - `root_map`: identifies those expressions or patterns whose result\n+ *   needs to be rooted.  Conceptually the root_map maps from an\n+ *   expression or pattern node to a `node_id` identifying the scope for\n+ *   which the expression must be rooted (this `node_id` should identify\n+ *   a block or call).  The actual key to the map is not an expression id,\n+ *   however, but a `root_map_key`, which combines an expression id with a\n+ *   deref count and is used to cope with auto-deref.\n+ *\n+ * - `mutbl_map`: identifies those local variables which are modified or\n+ *   moved. This is used by trans to guarantee that such variables are\n+ *   given a memory location and not used as immediates.\n+ */\n \n import syntax::ast;\n import syntax::ast::{mutability, m_mutbl, m_imm, m_const};\n@@ -304,7 +302,7 @@ fn save_and_restore<T:copy,U>(&save_and_restore_t: T, f: fn() -> U) -> U {\n     ret u;\n }\n \n-#[doc = \"Creates and returns a new root_map\"]\n+/// Creates and returns a new root_map\n fn root_map() -> root_map {\n     ret hashmap(root_map_key_hash, root_map_key_eq);\n "}, {"sha": "deccf0af2b46d8e3273e643121519e6a887e55e9", "filename": "src/rustc/middle/borrowck/categorization.rs", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,41 +1,40 @@\n-#[doc = \"\n-\n-# Categorization\n-\n-The job of the categorization module is to analyze an expression to\n-determine what kind of memory is used in evaluating it (for example,\n-where dereferences occur and what kind of pointer is dereferenced;\n-whether the memory is mutable; etc)\n-\n-Categorization effectively transforms all of our expressions into\n-expressions of the following forms (the actual enum has many more\n-possibilities, naturally, but they are all variants of these base\n-forms):\n-\n-    E = rvalue    // some computed rvalue\n-      | x         // address of a local variable, arg, or upvar\n-      | *E        // deref of a ptr\n-      | E.comp    // access to an interior component\n-\n-Imagine a routine ToAddr(Expr) that evaluates an expression and returns an\n-address where the result is to be found.  If Expr is an lvalue, then this\n-is the address of the lvalue.  If Expr is an rvalue, this is the address of\n-some temporary spot in memory where the result is stored.\n-\n-Now, cat_expr() classies the expression Expr and the address A=ToAddr(Expr)\n-as follows:\n-\n-- cat: what kind of expression was this?  This is a subset of the\n-  full expression forms which only includes those that we care about\n-  for the purpose of the analysis.\n-- mutbl: mutability of the address A\n-- ty: the type of data found at the address A\n-\n-The resulting categorization tree differs somewhat from the expressions\n-themselves.  For example, auto-derefs are explicit.  Also, an index a[b] is\n-decomposed into two operations: a derefence to reach the array data and\n-then an index to jump forward to the relevant item.\n-\"];\n+/*!\n+ * # Categorization\n+ *\n+ * The job of the categorization module is to analyze an expression to\n+ * determine what kind of memory is used in evaluating it (for example,\n+ * where dereferences occur and what kind of pointer is dereferenced;\n+ * whether the memory is mutable; etc)\n+ *\n+ * Categorization effectively transforms all of our expressions into\n+ * expressions of the following forms (the actual enum has many more\n+ * possibilities, naturally, but they are all variants of these base\n+ * forms):\n+ *\n+ *     E = rvalue    // some computed rvalue\n+ *       | x         // address of a local variable, arg, or upvar\n+ *       | *E        // deref of a ptr\n+ *       | E.comp    // access to an interior component\n+ *\n+ * Imagine a routine ToAddr(Expr) that evaluates an expression and returns an\n+ * address where the result is to be found.  If Expr is an lvalue, then this\n+ * is the address of the lvalue.  If Expr is an rvalue, this is the address of\n+ * some temporary spot in memory where the result is stored.\n+ *\n+ * Now, cat_expr() classies the expression Expr and the address A=ToAddr(Expr)\n+ * as follows:\n+ *\n+ * - cat: what kind of expression was this?  This is a subset of the\n+ *   full expression forms which only includes those that we care about\n+ *   for the purpose of the analysis.\n+ * - mutbl: mutability of the address A\n+ * - ty: the type of data found at the address A\n+ *\n+ * The resulting categorization tree differs somewhat from the expressions\n+ * themselves.  For example, auto-derefs are explicit.  Also, an index a[b] is\n+ * decomposed into two operations: a derefence to reach the array data and\n+ * then an index to jump forward to the relevant item.\n+ */\n \n export public_methods;\n export opt_deref_kind;"}, {"sha": "11d26ddbbb180c4e0066ceb354dd35b02bbf257a", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -17,27 +17,26 @@ export get_warning_level, get_warning_settings_level;\n export check_crate, build_settings_crate, mk_warning_settings;\n export warning_settings;\n \n-#[doc=\"\n-\n-A 'lint' check is a kind of miscellaneous constraint that a user _might_ want\n-to enforce, but might reasonably want to permit as well, on a module-by-module\n-basis. They contrast with static constraints enforced by other phases of the\n-compiler, which are generally required to hold in order to compile the program\n-at all.\n-\n-We also build up a table containing information about lint settings, in order\n-to allow other passes to take advantage of the warning attribute\n-infrastructure. To save space, the table is keyed by the id of /items/, not of\n-every expression. When an item has the default settings, the entry will be\n-omitted. If we start allowing warn attributes on expressions, we will start\n-having entries for expressions that do not share their enclosing items\n-settings.\n-\n-This module then, exports two passes: one that populates the warning settings\n-table in the session and is run early in the compile process, and one that\n-does a variety of lint checks, and is run late in the compile process.\n-\n-\"]\n+/**\n+ * A 'lint' check is a kind of miscellaneous constraint that a user _might_\n+ * want to enforce, but might reasonably want to permit as well, on a\n+ * module-by-module basis. They contrast with static constraints enforced by\n+ * other phases of the compiler, which are generally required to hold in order\n+ * to compile the program at all.\n+ *\n+ * We also build up a table containing information about lint settings, in\n+ * order to allow other passes to take advantage of the warning attribute\n+ * infrastructure. To save space, the table is keyed by the id of /items/, not\n+ * of every expression. When an item has the default settings, the entry will\n+ * be omitted. If we start allowing warn attributes on expressions, we will\n+ * start having entries for expressions that do not share their enclosing\n+ * items settings.\n+ *\n+ * This module then, exports two passes: one that populates the warning\n+ * settings table in the session and is run early in the compile process, and\n+ * one that does a variety of lint checks, and is run late in the compile\n+ * process.\n+ */\n \n enum lint {\n     ctypes,\n@@ -203,11 +202,11 @@ impl methods for ctxt {\n         self.sess.span_lint_level(level, span, msg);\n     }\n \n-    #[doc=\"\n-          Merge the warnings specified by any `warn(...)` attributes into the\n-          current lint context, call the provided function, then reset the\n-          warnings in effect to their previous state.\n-    \"]\n+    /**\n+     * Merge the warnings specified by any `warn(...)` attributes into the\n+     * current lint context, call the provided function, then reset the\n+     * warnings in effect to their previous state.\n+     */\n     fn with_warn_attrs(attrs: ~[ast::attribute], f: fn(ctxt)) {\n \n         let mut new_ctxt = self;"}, {"sha": "2f87f6d55de79324dddc7faa86321eb1d2f7ac71", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 101, "deletions": 103, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,106 +1,104 @@\n-#[doc = \"\n-\n-A classic liveness analysis based on dataflow over the AST.  Computes,\n-for each local variable in a function, whether that variable is live\n-at a given point.  Program execution points are identified by their\n-id.\n-\n-# Basic idea\n-\n-The basic model is that each local variable is assigned an index.  We\n-represent sets of local variables using a vector indexed by this\n-index.  The value in the vector is either 0, indicating the variable\n-is dead, or the id of an expression that uses the variable.\n-\n-We conceptually walk over the AST in reverse execution order.  If we\n-find a use of a variable, we add it to the set of live variables.  If\n-we find an assignment to a variable, we remove it from the set of live\n-variables.  When we have to merge two flows, we take the union of\n-those two flows---if the variable is live on both paths, we simply\n-pick one id.  In the event of loops, we continue doing this until a\n-fixed point is reached.\n-\n-## Checking initialization\n-\n-At the function entry point, all variables must be dead.  If this is\n-not the case, we can report an error using the id found in the set of\n-live variables, which identifies a use of the variable which is not\n-dominated by an assignment.\n-\n-## Checking moves\n-\n-After each explicit move, the variable must be dead.\n-\n-## Computing last uses\n-\n-Any use of the variable where the variable is dead afterwards is a\n-last use.\n-\n-# Extension to handle constructors\n-\n-Each field is assigned an index just as with local variables.  A use of\n-`self` is considered a use of all fields.  A use of `self.f` is just a use\n-of `f`.\n-\n-# Implementation details\n-\n-The actual implementation contains two (nested) walks over the AST.\n-The outer walk has the job of building up the ir_maps instance for the\n-enclosing function.  On the way down the tree, it identifies those AST\n-nodes and variable IDs that will be needed for the liveness analysis\n-and assigns them contiguous IDs.  The liveness id for an AST node is\n-called a `live_node` (it's a newtype'd uint) and the id for a variable\n-is called a `variable` (another newtype'd uint).\n-\n-On the way back up the tree, as we are about to exit from a function\n-declaration we allocate a `liveness` instance.  Now that we know\n-precisely how many nodes and variables we need, we can allocate all\n-the various arrays that we will need to precisely the right size.  We then\n-perform the actual propagation on the `liveness` instance.\n-\n-This propagation is encoded in the various `propagate_through_*()`\n-methods.  It effectively does a reverse walk of the AST; whenever we\n-reach a loop node, we iterate until a fixed point is reached.\n-\n-## The `users` struct\n-\n-At each live node `N`, we track three pieces of information for each\n-variable `V` (these are encapsulated in the `users` struct):\n-\n-- `reader`: the `live_node` ID of some node which will read the value\n-   that `V` holds on entry to `N`.  Formally: a node `M` such\n-   that there exists a path `P` from `N` to `M` where `P` does not\n-   write `V`.  If the `reader` is `invalid_node()`, then the current\n-   value will never be read (the variable is dead, essentially).\n-\n-- `writer`: the `live_node` ID of some node which will write the\n-   variable `V` and which is reachable from `N`.  Formally: a node `M`\n-   such that there exists a path `P` from `N` to `M` and `M` writes\n-   `V`.  If the `writer` is `invalid_node()`, then there is no writer\n-   of `V` that follows `N`.\n-\n-- `used`: a boolean value indicating whether `V` is *used*.  We\n-  distinguish a *read* from a *use* in that a *use* is some read that\n-  is not just used to generate a new value.  For example, `x += 1` is\n-  a read but not a use.  This is used to generate better warnings.\n-\n-## Special Variables\n-\n-We generate various special variables for various, well, special purposes.\n-These are described in the `specials` struct:\n-\n-- `exit_ln`: a live node that is generated to represent every 'exit' from the\n-  function, whether it be by explicit return, fail, or other means.\n-\n-- `fallthrough_ln`: a live node that represents a fallthrough\n-\n-- `no_ret_var`: a synthetic variable that is only 'read' from, the\n-  fallthrough node.  This allows us to detect functions where we fail\n-  to return explicitly.\n-\n-- `self_var`: a variable representing 'self'\n-\n-\"];\n+/*!\n+ * A classic liveness analysis based on dataflow over the AST.  Computes,\n+ * for each local variable in a function, whether that variable is live\n+ * at a given point.  Program execution points are identified by their\n+ * id.\n+ *\n+ * # Basic idea\n+ *\n+ * The basic model is that each local variable is assigned an index.  We\n+ * represent sets of local variables using a vector indexed by this\n+ * index.  The value in the vector is either 0, indicating the variable\n+ * is dead, or the id of an expression that uses the variable.\n+ *\n+ * We conceptually walk over the AST in reverse execution order.  If we\n+ * find a use of a variable, we add it to the set of live variables.  If\n+ * we find an assignment to a variable, we remove it from the set of live\n+ * variables.  When we have to merge two flows, we take the union of\n+ * those two flows---if the variable is live on both paths, we simply\n+ * pick one id.  In the event of loops, we continue doing this until a\n+ * fixed point is reached.\n+ *\n+ * ## Checking initialization\n+ *\n+ * At the function entry point, all variables must be dead.  If this is\n+ * not the case, we can report an error using the id found in the set of\n+ * live variables, which identifies a use of the variable which is not\n+ * dominated by an assignment.\n+ *\n+ * ## Checking moves\n+ *\n+ * After each explicit move, the variable must be dead.\n+ *\n+ * ## Computing last uses\n+ *\n+ * Any use of the variable where the variable is dead afterwards is a\n+ * last use.\n+ *\n+ * # Extension to handle constructors\n+ *\n+ * Each field is assigned an index just as with local variables.  A use of\n+ * `self` is considered a use of all fields.  A use of `self.f` is just a use\n+ * of `f`.\n+ *\n+ * # Implementation details\n+ *\n+ * The actual implementation contains two (nested) walks over the AST.\n+ * The outer walk has the job of building up the ir_maps instance for the\n+ * enclosing function.  On the way down the tree, it identifies those AST\n+ * nodes and variable IDs that will be needed for the liveness analysis\n+ * and assigns them contiguous IDs.  The liveness id for an AST node is\n+ * called a `live_node` (it's a newtype'd uint) and the id for a variable\n+ * is called a `variable` (another newtype'd uint).\n+ *\n+ * On the way back up the tree, as we are about to exit from a function\n+ * declaration we allocate a `liveness` instance.  Now that we know\n+ * precisely how many nodes and variables we need, we can allocate all\n+ * the various arrays that we will need to precisely the right size.  We then\n+ * perform the actual propagation on the `liveness` instance.\n+ *\n+ * This propagation is encoded in the various `propagate_through_*()`\n+ * methods.  It effectively does a reverse walk of the AST; whenever we\n+ * reach a loop node, we iterate until a fixed point is reached.\n+ *\n+ * ## The `users` struct\n+ *\n+ * At each live node `N`, we track three pieces of information for each\n+ * variable `V` (these are encapsulated in the `users` struct):\n+ *\n+ * - `reader`: the `live_node` ID of some node which will read the value\n+ *    that `V` holds on entry to `N`.  Formally: a node `M` such\n+ *    that there exists a path `P` from `N` to `M` where `P` does not\n+ *    write `V`.  If the `reader` is `invalid_node()`, then the current\n+ *    value will never be read (the variable is dead, essentially).\n+ *\n+ * - `writer`: the `live_node` ID of some node which will write the\n+ *    variable `V` and which is reachable from `N`.  Formally: a node `M`\n+ *    such that there exists a path `P` from `N` to `M` and `M` writes\n+ *    `V`.  If the `writer` is `invalid_node()`, then there is no writer\n+ *    of `V` that follows `N`.\n+ *\n+ * - `used`: a boolean value indicating whether `V` is *used*.  We\n+ *   distinguish a *read* from a *use* in that a *use* is some read that\n+ *   is not just used to generate a new value.  For example, `x += 1` is\n+ *   a read but not a use.  This is used to generate better warnings.\n+ *\n+ * ## Special Variables\n+ *\n+ * We generate various special variables for various, well, special purposes.\n+ * These are described in the `specials` struct:\n+ *\n+ * - `exit_ln`: a live node that is generated to represent every 'exit' from\n+ *   the function, whether it be by explicit return, fail, or other means.\n+ *\n+ * - `fallthrough_ln`: a live node that represents a fallthrough\n+ *\n+ * - `no_ret_var`: a synthetic variable that is only 'read' from, the\n+ *   fallthrough node.  This allows us to detect functions where we fail\n+ *   to return explicitly.\n+ *\n+ * - `self_var`: a variable representing 'self'\n+ */\n \n import dvec::{dvec, extensions};\n import std::map::{hashmap, int_hash, str_hash, box_str_hash};"}, {"sha": "f149379130c817fa954fd34555e50f298d5dc4ff", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 95, "deletions": 95, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -109,13 +109,13 @@ enum ModuleDef {\n     ModuleDef(@Module),     // Defines a module.\n }\n \n-#[doc=\"Contains data for specific types of import directives.\"]\n+/// Contains data for specific types of import directives.\n enum ImportDirectiveSubclass {\n     SingleImport(Atom /* target */, Atom /* source */),\n     GlobImport\n }\n \n-#[doc=\"The context that we thread through while building the reduced graph.\"]\n+/// The context that we thread through while building the reduced graph.\n enum ReducedGraphParent {\n     ModuleReducedGraphParent(@Module)\n }\n@@ -235,15 +235,15 @@ class AtomTable {\n     }\n }\n \n-#[doc=\"Creates a hash table of atoms.\"]\n+/// Creates a hash table of atoms.\n fn atom_hashmap<V:copy>() -> hashmap<Atom,V> {\n     ret hashmap::<Atom,V>(|a| a, |a, b| a == b);\n }\n \n-#[doc=\"\n-    One local scope. In Rust, local scopes can only contain value bindings.\n-    Therefore, we don't have to worry about the other namespaces here.\n-\"]\n+/**\n+ * One local scope. In Rust, local scopes can only contain value bindings.\n+ * Therefore, we don't have to worry about the other namespaces here.\n+ */\n class Rib {\n     let bindings: hashmap<Atom,def_like>;\n     let kind: RibKind;\n@@ -254,7 +254,7 @@ class Rib {\n     }\n }\n \n-#[doc=\"One import directive.\"]\n+/// One import directive.\n class ImportDirective {\n     let module_path: @dvec<Atom>;\n     let subclass: @ImportDirectiveSubclass;\n@@ -265,7 +265,7 @@ class ImportDirective {\n     }\n }\n \n-#[doc=\"The item that an import resolves to.\"]\n+/// The item that an import resolves to.\n class Target {\n     let target_module: @Module;\n     let bindings: @NameBindings;\n@@ -313,14 +313,14 @@ class ImportResolution {\n     }\n }\n \n-#[doc=\"The link from a module up to its nearest parent node.\"]\n+/// The link from a module up to its nearest parent node.\n enum ParentLink {\n     NoParentLink,\n     ModuleParentLink(@Module, Atom),\n     BlockParentLink(@Module, node_id)\n }\n \n-#[doc=\"One node in the tree of modules.\"]\n+/// One node in the tree of modules.\n class Module {\n     let parent_link: ParentLink;\n     let mut def_id: option<def_id>;\n@@ -398,10 +398,10 @@ pure fn is_none<T>(x: option<T>) -> bool {\n     }\n }\n \n-#[doc=\"\n-    Records the definitions (at most one for each namespace) that a name is\n-    bound to.\n-\"]\n+/**\n+ * Records the definitions (at most one for each namespace) that a name is\n+ * bound to.\n+ */\n class NameBindings {\n     let mut module_def: ModuleDef;      //< Meaning in the module namespace.\n     let mut type_def: option<def>;      //< Meaning in the type namespace.\n@@ -415,41 +415,41 @@ class NameBindings {\n         self.impl_defs = ~[];\n     }\n \n-    #[doc=\"Creates a new module in this set of name bindings.\"]\n+    /// Creates a new module in this set of name bindings.\n     fn define_module(parent_link: ParentLink, def_id: option<def_id>) {\n         if self.module_def == NoModuleDef {\n             let module = @Module(parent_link, def_id);\n             self.module_def = ModuleDef(module);\n         }\n     }\n \n-    #[doc=\"Records a type definition.\"]\n+    /// Records a type definition.\n     fn define_type(def: def) {\n         self.type_def = some(def);\n     }\n \n-    #[doc=\"Records a value definition.\"]\n+    /// Records a value definition.\n     fn define_value(def: def) {\n         self.value_def = some(def);\n     }\n \n-    #[doc=\"Records an impl definition.\"]\n+    /// Records an impl definition.\n     fn define_impl(implementation: @Impl) {\n         self.impl_defs += ~[implementation];\n     }\n \n-    #[doc=\"Returns the module node if applicable.\"]\n+    /// Returns the module node if applicable.\n     fn get_module_if_available() -> option<@Module> {\n         alt self.module_def {\n             NoModuleDef         { ret none;         }\n             ModuleDef(module)   { ret some(module); }\n         }\n     }\n \n-    #[doc=\"\n-        Returns the module node. Fails if this node does not have a module\n-        definition.\n-    \"]\n+    /**\n+     * Returns the module node. Fails if this node does not have a module\n+     * definition.\n+     */\n     fn get_module() -> @Module {\n         alt self.module_def {\n             NoModuleDef {\n@@ -508,7 +508,7 @@ class NameBindings {\n     }\n }\n \n-#[doc=\"Interns the names of the primitive types.\"]\n+/// Interns the names of the primitive types.\n class PrimitiveTypeTable {\n     let primitive_types: hashmap<Atom,prim_ty>;\n \n@@ -539,7 +539,7 @@ class PrimitiveTypeTable {\n     }\n }\n \n-#[doc=\"The main resolver class.\"]\n+/// The main resolver class.\n class Resolver {\n     let session: session;\n     let ast_map: ASTMap;\n@@ -611,7 +611,7 @@ class Resolver {\n         self.export_map = int_hash();\n     }\n \n-    #[doc=\"The main name resolution procedure.\"]\n+    /// The main name resolution procedure.\n     fn resolve(this: @Resolver) {\n         self.build_reduced_graph(this);\n         self.resolve_imports();\n@@ -627,7 +627,7 @@ class Resolver {\n     // any imports resolved.\n     //\n \n-    #[doc=\"Constructs the reduced graph for the entire crate.\"]\n+    /// Constructs the reduced graph for the entire crate.\n     fn build_reduced_graph(this: @Resolver) {\n         let initial_parent =\n             ModuleReducedGraphParent((*self.graph_root).get_module());\n@@ -654,7 +654,7 @@ class Resolver {\n         }));\n     }\n \n-    #[doc=\"Returns the current module tracked by the reduced graph parent.\"]\n+    /// Returns the current module tracked by the reduced graph parent.\n     fn get_module_from_parent(reduced_graph_parent: ReducedGraphParent)\n                            -> @Module {\n         alt reduced_graph_parent {\n@@ -664,16 +664,16 @@ class Resolver {\n         }\n     }\n \n-    #[doc=\"\n-        Adds a new child item to the module definition of the parent node and\n-        returns its corresponding name bindings as well as the current parent.\n-        Or, if we're inside a block, creates (or reuses) an anonymous module\n-        corresponding to the innermost block ID and returns the name bindings\n-        as well as the newly-created parent.\n-\n-        If this node does not have a module definition and we are not inside\n-        a block, fails.\n-    \"]\n+    /**\n+     * Adds a new child item to the module definition of the parent node and\n+     * returns its corresponding name bindings as well as the current parent.\n+     * Or, if we're inside a block, creates (or reuses) an anonymous module\n+     * corresponding to the innermost block ID and returns the name bindings\n+     * as well as the newly-created parent.\n+     *\n+     * If this node does not have a module definition and we are not inside\n+     * a block, fails.\n+     */\n     fn add_child(name: Atom,\n                  reduced_graph_parent: ReducedGraphParent)\n               -> (@NameBindings, ReducedGraphParent) {\n@@ -742,7 +742,7 @@ class Resolver {\n         }\n     }\n \n-    #[doc=\"Constructs the reduced graph for one item.\"]\n+    /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(item: @item,\n                                     parent: ReducedGraphParent,\n                                     &&visitor: vt<ReducedGraphParent>) {\n@@ -874,10 +874,10 @@ class Resolver {\n         }\n     }\n \n-    #[doc=\"\n-        Constructs the reduced graph for one variant. Variants exist in the\n-        type namespace.\n-    \"]\n+    /**\n+     * Constructs the reduced graph for one variant. Variants exist in the\n+     * type namespace.\n+     */\n     fn build_reduced_graph_for_variant(variant: variant,\n                                        item_id: def_id,\n                                        parent: ReducedGraphParent,\n@@ -890,10 +890,10 @@ class Resolver {\n                                           local_def(variant.node.id)));\n     }\n \n-    #[doc=\"\n-        Constructs the reduced graph for one 'view item'. View items consist\n-        of imports and use directives.\n-    \"]\n+    /**\n+     * Constructs the reduced graph for one 'view item'. View items consist\n+     * of imports and use directives.\n+     */\n     fn build_reduced_graph_for_view_item(view_item: @view_item,\n                                          parent: ReducedGraphParent,\n                                          &&_visitor: vt<ReducedGraphParent>) {\n@@ -1045,7 +1045,7 @@ class Resolver {\n         }\n     }\n \n-    #[doc=\"Constructs the reduced graph for one foreign item.\"]\n+    /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item(foreign_item: @foreign_item,\n                                             parent: ReducedGraphParent,\n                                             &&visitor:\n@@ -1095,10 +1095,10 @@ class Resolver {\n         visit_block(block, new_parent, visitor);\n     }\n \n-    #[doc=\"\n-        Builds the reduced graph rooted at the 'use' directive for an external\n-        crate.\n-    \"]\n+    /**\n+     * Builds the reduced graph rooted at the 'use' directive for an external\n+     * crate.\n+     */\n     fn build_reduced_graph_for_external_crate(root: @Module) {\n         // Create all the items reachable by paths.\n         for each_path(self.session.cstore, get(root.def_id).crate)\n@@ -1285,7 +1285,7 @@ class Resolver {\n         }\n     }\n \n-    #[doc=\"Creates and adds an import directive to the given module.\"]\n+    /// Creates and adds an import directive to the given module.\n     fn build_import_directive(module: @Module,\n                               module_path: @dvec<Atom>,\n                               subclass: @ImportDirectiveSubclass) {\n@@ -1328,10 +1328,10 @@ class Resolver {\n     // remain or unsuccessfully when no forward progress in resolving imports\n     // is made.\n \n-    #[doc=\"\n-        Resolves all imports for the crate. This method performs the fixed-\n-        point iteration.\n-    \"]\n+    /**\n+     * Resolves all imports for the crate. This method performs the fixed-\n+     * point iteration.\n+     */\n     fn resolve_imports() {\n         let mut i = 0u;\n         let mut prev_unresolved_imports = 0u;\n@@ -1358,10 +1358,10 @@ class Resolver {\n         }\n     }\n \n-    #[doc=\"\n-        Attempts to resolve imports for the given module and all of its\n-        submodules.\n-    \"]\n+    /**\n+     * Attempts to resolve imports for the given module and all of its\n+     * submodules.\n+     */\n     fn resolve_imports_for_module_subtree(module: @Module) {\n         #debug(\"(resolving imports for module subtree) resolving %s\",\n                self.module_to_str(module));\n@@ -1383,7 +1383,7 @@ class Resolver {\n         }\n     }\n \n-    #[doc=\"Attempts to resolve imports for the given module only.\"]\n+    /// Attempts to resolve imports for the given module only.\n     fn resolve_imports_for_module(module: @Module) {\n         if (*module).all_imports_resolved() {\n             #debug(\"(resolving imports for module) all imports resolved for \\\n@@ -1416,13 +1416,13 @@ class Resolver {\n         }\n     }\n \n-    #[doc=\"\n-        Attempts to resolve the given import. The return value indicates\n-        failure if we're certain the name does not exist, indeterminate if we\n-        don't know whether the name exists at the moment due to other\n-        currently-unresolved imports, or success if we know the name exists.\n-        If successful, the resolved bindings are written into the module.\n-    \"]\n+    /**\n+     * Attempts to resolve the given import. The return value indicates\n+     * failure if we're certain the name does not exist, indeterminate if we\n+     * don't know whether the name exists at the moment due to other\n+     * currently-unresolved imports, or success if we know the name exists.\n+     * If successful, the resolved bindings are written into the module.\n+     */\n     fn resolve_import_for_module(module: @Module,\n                                  import_directive: @ImportDirective)\n                               -> ResolveResult<()> {\n@@ -1721,11 +1721,11 @@ class Resolver {\n         ret Success(());\n     }\n \n-    #[doc=\"\n-        Resolves a glob import. Note that this function cannot fail; it either\n-        succeeds or bails out (as importing * from an empty module or a module\n-        that exports nothing is valid).\n-    \"]\n+    /**\n+     * Resolves a glob import. Note that this function cannot fail; it either\n+     * succeeds or bails out (as importing * from an empty module or a module\n+     * that exports nothing is valid).\n+     */\n     fn resolve_glob_import(module: @Module, containing_module: @Module)\n                         -> ResolveResult<()> {\n \n@@ -1927,10 +1927,10 @@ class Resolver {\n         ret Success(search_module);\n     }\n \n-    #[doc=\"\n-        Attempts to resolve the module part of an import directive rooted at\n-        the given module.\n-    \"]\n+    /**\n+     * Attempts to resolve the module part of an import directive rooted at\n+     * the given module.\n+     */\n     fn resolve_module_path_for_import(module: @Module,\n                                       module_path: @dvec<Atom>,\n                                       xray: XrayFlag)\n@@ -2093,11 +2093,11 @@ class Resolver {\n                 module.exported_names.contains_key(name);\n     }\n \n-    #[doc=\"\n-        Attempts to resolve the supplied name in the given module for the\n-        given namespace. If successful, returns the target corresponding to\n-        the name.\n-    \"]\n+    /**\n+     * Attempts to resolve the supplied name in the given module for the\n+     * given namespace. If successful, returns the target corresponding to\n+     * the name.\n+     */\n     fn resolve_name_in_module(module: @Module,\n                               name: Atom,\n                               namespace: Namespace,\n@@ -2168,11 +2168,11 @@ class Resolver {\n         ret Failed;\n     }\n \n-    #[doc=\"\n-        Resolves a one-level renaming import of the kind `import foo = bar;`\n-        This needs special handling, as, unlike all of the other imports, it\n-        needs to look in the scope chain for modules and non-modules alike.\n-    \"]\n+    /**\n+     * Resolves a one-level renaming import of the kind `import foo = bar;`\n+     * This needs special handling, as, unlike all of the other imports, it\n+     * needs to look in the scope chain for modules and non-modules alike.\n+     */\n     fn resolve_one_level_renaming_import(module: @Module,\n                                          import_directive: @ImportDirective)\n                                       -> ResolveResult<()> {\n@@ -3496,10 +3496,10 @@ class Resolver {\n         }\n     }\n \n-    #[doc=\"\n-        If `check_ribs` is true, checks the local definitions first; i.e.\n-        doesn't skip straight to the containing module.\n-    \"]\n+    /**\n+     * If `check_ribs` is true, checks the local definitions first; i.e.\n+     * doesn't skip straight to the containing module.\n+     */\n     fn resolve_path(path: @path, namespace: Namespace, check_ribs: bool,\n                     visitor: ResolveVisitor)\n                  -> option<def> {\n@@ -3859,7 +3859,7 @@ class Resolver {\n     // hit.\n     //\n \n-    #[doc=\"A somewhat inefficient routine to print out the name of a module.\"]\n+    /// A somewhat inefficient routine to print out the name of a module.\n     fn module_to_str(module: @Module) -> str {\n         let atoms = dvec();\n         let mut current_module = module;\n@@ -3977,7 +3977,7 @@ class Resolver {\n     }\n }\n \n-#[doc=\"Entry point to crate resolution.\"]\n+/// Entry point to crate resolution.\n fn resolve_crate(session: session, ast_map: ASTMap, crate: @crate)\n               -> { def_map: DefMap, exp_map: ExportMap, impl_map: ImplMap } {\n "}, {"sha": "1dab44d43c0d36352f4b61f14818868ce73edd75", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -2735,14 +2735,14 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n     }\n }\n \n-#[doc = \"\n-Get the type of a box in the default address space.\n-\n-Shared box pointers live in address space 1 so the GC strategy can find them.\n-Before taking a pointer to the inside of a box it should be cast into address\n-space 0. Otherwise the resulting (non-box) pointer will be in the wrong\n-address space and thus be the wrong type.\n-\"]\n+/**\n+ * Get the type of a box in the default address space.\n+ *\n+ * Shared box pointers live in address space 1 so the GC strategy can find\n+ * them. Before taking a pointer to the inside of a box it should be cast into\n+ * address space 0. Otherwise the resulting (non-box) pointer will be in the\n+ * wrong address space and thus be the wrong type.\n+ */\n fn non_gc_box_cast(cx: block, val: ValueRef) -> ValueRef {\n     #debug(\"non_gc_box_cast\");\n     add_comment(cx, \"non_gc_box_cast\");"}, {"sha": "455408b7e5a23c43e8ca6050021ce5654b89342e", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -2996,9 +2996,7 @@ fn ty_params_to_tys(tcx: ty::ctxt, tps: ~[ast::ty_param]) -> ~[t] {\n         })\n }\n \n-#[doc = \"\n-Returns an equivalent type with all the typedefs and self regions removed.\n-\"]\n+/// Returns an equivalent type with all the typedefs and self regions removed.\n fn normalize_ty(cx: ctxt, t: t) -> t {\n     alt cx.normalized_cache.find(t) {\n       some(t) { ret t; }"}, {"sha": "c48c46151e7d7c28c122acf3118e09583d96b3cd", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 43, "deletions": 45, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,48 +1,46 @@\n-#[doc = \"\n-\n-Conversion from AST representation of types to the ty.rs\n-representation.  The main routine here is `ast_ty_to_ty()`: each use\n-is parameterized by an instance of `ast_conv` and a `region_scope`.\n-\n-The parameterization of `ast_ty_to_ty()` is because it behaves\n-somewhat differently during the collect and check phases, particularly\n-with respect to looking up the types of top-level items.  In the\n-collect phase, the crate context is used as the `ast_conv` instance;\n-in this phase, the `get_item_ty()` function triggers a recursive call\n-to `ty_of_item()` (note that `ast_ty_to_ty()` will detect recursive\n-types and report an error).  In the check phase, when the @fn_ctxt is\n-used as the `ast_conv`, `get_item_ty()` just looks up the item type in\n-`tcx.tcache`.\n-\n-The `region_scope` interface controls how region references are\n-handled.  It has two methods which are used to resolve anonymous\n-region references (e.g., `&T`) and named region references (e.g.,\n-`&a.T`).  There are numerous region scopes that can be used, but most\n-commonly you want either `empty_rscope`, which permits only the static\n-region, or `type_rscope`, which permits the self region if the type in\n-question is parameterized by a region.\n-\n-Unlike the `ast_conv` iface, the region scope can change as we descend\n-the type.  This is to accommodate the fact that (a) fn types are binding\n-scopes and (b) the default region may change.  To understand case (a),\n-consider something like:\n-\n-  type foo = { x: &a.int, y: fn(&a.int) }\n-\n-The type of `x` is an error because there is no region `a` in scope.\n-In the type of `y`, however, region `a` is considered a bound region\n-as it does not already appear in scope.\n-\n-Case (b) says that if you have a type:\n-  type foo/& = ...;\n-  type bar = fn(&foo, &a.foo)\n-The fully expanded version of type bar is:\n-  type bar = fn(&foo/&, &a.foo/&a)\n-Note that the self region for the `foo` defaulted to `&` in the first\n-case but `&a` in the second.  Basically, defaults that appear inside\n-an rptr (`&r.T`) use the region `r` that appears in the rptr.\n-\n-\"];\n+/*!\n+ * Conversion from AST representation of types to the ty.rs\n+ * representation.  The main routine here is `ast_ty_to_ty()`: each use\n+ * is parameterized by an instance of `ast_conv` and a `region_scope`.\n+ *\n+ * The parameterization of `ast_ty_to_ty()` is because it behaves\n+ * somewhat differently during the collect and check phases, particularly\n+ * with respect to looking up the types of top-level items.  In the\n+ * collect phase, the crate context is used as the `ast_conv` instance;\n+ * in this phase, the `get_item_ty()` function triggers a recursive call\n+ * to `ty_of_item()` (note that `ast_ty_to_ty()` will detect recursive\n+ * types and report an error).  In the check phase, when the @fn_ctxt is\n+ * used as the `ast_conv`, `get_item_ty()` just looks up the item type in\n+ * `tcx.tcache`.\n+ *\n+ * The `region_scope` interface controls how region references are\n+ * handled.  It has two methods which are used to resolve anonymous\n+ * region references (e.g., `&T`) and named region references (e.g.,\n+ * `&a.T`).  There are numerous region scopes that can be used, but most\n+ * commonly you want either `empty_rscope`, which permits only the static\n+ * region, or `type_rscope`, which permits the self region if the type in\n+ * question is parameterized by a region.\n+ *\n+ * Unlike the `ast_conv` iface, the region scope can change as we descend\n+ * the type.  This is to accommodate the fact that (a) fn types are binding\n+ * scopes and (b) the default region may change.  To understand case (a),\n+ * consider something like:\n+ *\n+ *   type foo = { x: &a.int, y: fn(&a.int) }\n+ *\n+ * The type of `x` is an error because there is no region `a` in scope.\n+ * In the type of `y`, however, region `a` is considered a bound region\n+ * as it does not already appear in scope.\n+ *\n+ * Case (b) says that if you have a type:\n+ *   type foo/& = ...;\n+ *   type bar = fn(&foo, &a.foo)\n+ * The fully expanded version of type bar is:\n+ *   type bar = fn(&foo/&, &a.foo/&a)\n+ * Note that the self region for the `foo` defaulted to `&` in the first\n+ * case but `&a` in the second.  Basically, defaults that appear inside\n+ * an rptr (`&r.T`) use the region `r` that appears in the rptr.\n+ */\n \n import check::fn_ctxt;\n import rscope::{anon_rscope, binding_rscope, empty_rscope, in_anon_rscope};"}, {"sha": "181c682fffabac3e58623b5f14f14bc903790035", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -152,18 +152,18 @@ fn ensure_iface_methods(ccx: @crate_ctxt, id: ast::node_id) {\n     }\n }\n \n-#[doc = \"\n-Checks that a method from an impl/class conforms to the signature of\n-the same method as declared in the iface.\n-\n-# Parameters\n-\n-- impl_m: the method in the impl\n-- impl_tps: the type params declared on the impl itself (not the method!)\n-- if_m: the method in the iface\n-- if_substs: the substitutions used on the type of the iface\n-- self_ty: the self type of the impl\n-\"]\n+/**\n+ * Checks that a method from an impl/class conforms to the signature of\n+ * the same method as declared in the iface.\n+ *\n+ * # Parameters\n+ *\n+ * - impl_m: the method in the impl\n+ * - impl_tps: the type params declared on the impl itself (not the method!)\n+ * - if_m: the method in the iface\n+ * - if_substs: the substitutions used on the type of the iface\n+ * - self_ty: the self type of the impl\n+ */\n fn compare_impl_method(tcx: ty::ctxt, sp: span,\n                        impl_m: ty::method, impl_tps: uint,\n                        if_m: ty::method, if_substs: ty::substs,"}, {"sha": "6f97f0b635c4c934f7436719c38b73409be89453", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -546,7 +546,7 @@ fn rollback_to<V:copy vid, T:copy>(\n }\n \n impl transaction_methods for infer_ctxt {\n-    #[doc = \"Execute `f` and commit the bindings if successful\"]\n+    /// Execute `f` and commit the bindings if successful\n     fn commit<T,E>(f: fn() -> result<T,E>) -> result<T,E> {\n \n         assert self.tvb.bindings.len() == 0u;\n@@ -562,7 +562,7 @@ impl transaction_methods for infer_ctxt {\n         ret r;\n     }\n \n-    #[doc = \"Execute `f`, unroll bindings on failure\"]\n+    /// Execute `f`, unroll bindings on failure\n     fn try<T,E>(f: fn() -> result<T,E>) -> result<T,E> {\n \n         let tvbl = self.tvb.bindings.len();\n@@ -580,7 +580,7 @@ impl transaction_methods for infer_ctxt {\n         ret r;\n     }\n \n-    #[doc = \"Execute `f` then unroll any bindings it creates\"]\n+    /// Execute `f` then unroll any bindings it creates\n     fn probe<T,E>(f: fn() -> result<T,E>) -> result<T,E> {\n         assert self.tvb.bindings.len() == 0u;\n         assert self.rb.bindings.len() == 0u;"}, {"sha": "32c5f7ccf539a4735602318324e92fa27f79a9ea", "filename": "src/rustdoc/attr_parser.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_parser.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -39,9 +39,10 @@ fn doc_meta(\n     attrs: ~[ast::attribute]\n ) -> option<@ast::meta_item> {\n \n-    #[doc =\n-      \"Given a vec of attributes, extract the meta_items contained in the \\\n-       doc attribute\"];\n+    /*!\n+     * Given a vec of attributes, extract the meta_items contained in the \\\n+     * doc attribute\n+     */\n \n     let doc_attrs = attr::find_attrs_by_name(attrs, \"doc\");\n     let doc_metas = do doc_attrs.map |attr| {"}, {"sha": "94d232778679b51352847df1e164eb2075fda978", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -8,23 +8,23 @@ export default_config;\n export parse_config;\n export usage;\n \n-#[doc = \"The type of document to output\"]\n+/// The type of document to output\n enum output_format {\n-    #[doc = \"Markdown\"]\n+    /// Markdown\n     markdown,\n-    #[doc = \"HTML, via markdown and pandoc\"]\n+    /// HTML, via markdown and pandoc\n     pandoc_html\n }\n \n-#[doc = \"How to organize the output\"]\n+/// How to organize the output\n enum output_style {\n-    #[doc = \"All in a single document\"]\n+    /// All in a single document\n     doc_per_crate,\n-    #[doc = \"Each module in its own document\"]\n+    /// Each module in its own document\n     doc_per_mod\n }\n \n-#[doc = \"The configuration for a rustdoc session\"]\n+/// The configuration for a rustdoc session\n type config = {\n     input_crate: str,\n     output_dir: str,"}, {"sha": "e84551b6a53901073dfb20880e780abb0f1ae5ba", "filename": "src/rustdoc/demo.rs", "status": "modified", "additions": 137, "deletions": 142, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fdemo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fdemo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdemo.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,30 +1,28 @@\n // no-reformat\n \n-#[doc = \"\n-\n-    A demonstration module\n-\n-    Contains documentation in various forms that rustdoc understands,\n-    for testing purposes. It doesn't surve any functional\n-    purpose. This here, for instance, is just some filler text.\n-\n-    FIXME (#1654): It would be nice if we could run some automated\n-    tests on this file\n-\n-\"];\n-\n-#[doc = \"The base price of a muffin on a non-holiday\"]\n+/*!\n+ * A demonstration module\n+ *\n+ * Contains documentation in various forms that rustdoc understands,\n+ * for testing purposes. It doesn't surve any functional\n+ * purpose. This here, for instance, is just some filler text.\n+ *\n+ * FIXME (#1654): It would be nice if we could run some automated\n+ * tests on this file\n+ */\n+\n+/// The base price of a muffin on a non-holiday\n const price_of_a_muffin: float = 70f;\n \n type waitress = {\n     hair_color: str\n };\n \n-#[doc = \"The type of things that produce omnomnom\"]\n+/// The type of things that produce omnomnom\n enum omnomnomy {\n-    #[doc = \"Delicious sugar cookies\"]\n+    /// Delicious sugar cookies\n     cookie,\n-    #[doc = \"It's pizza\"]\n+    /// It's pizza\n     pizza_pie(~[uint])\n }\n \n@@ -33,154 +31,151 @@ fn take_my_order_please(\n     _order: ~[omnomnomy]\n ) -> uint {\n \n-    #[doc = \"\n-    OMG would you take my order already?\n-\n-    # Arguments\n-\n-    * _waitress - The waitress that you want to bother\n-    * _order - The order vector. It should be filled with food\n-\n-    # Return\n-\n-    The price of the order, including tax\n-\n-    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed nec\n-    molestie nisl. Duis massa risus, pharetra a scelerisque a,\n-    molestie eu velit. Donec mattis ligula at ante imperdiet ut\n-    dapibus mauris malesuada.\n-\n-    Sed gravida nisi a metus elementum sit amet hendrerit dolor\n-    bibendum. Aenean sit amet neque massa, sed tempus tortor. Sed ut\n-    lobortis enim. Proin a mauris quis nunc fermentum ultrices eget a\n-    erat. Mauris in lectus vitae metus sodales auctor. Morbi nunc\n-    quam, ultricies at venenatis non, pellentesque ac dui.\n-\n-    # Failure\n-\n-    This function is full of fail\n-    \"];\n+    /*!\n+     * OMG would you take my order already?\n+     *\n+     * # Arguments\n+     *\n+     * * _waitress - The waitress that you want to bother\n+     * * _order - The order vector. It should be filled with food\n+     *\n+     * # Return\n+     *\n+     * The price of the order, including tax\n+     *\n+     * Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed nec\n+     * molestie nisl. Duis massa risus, pharetra a scelerisque a,\n+     * molestie eu velit. Donec mattis ligula at ante imperdiet ut\n+     * dapibus mauris malesuada.\n+     *\n+     * Sed gravida nisi a metus elementum sit amet hendrerit dolor\n+     * bibendum. Aenean sit amet neque massa, sed tempus tortor. Sed ut\n+     * lobortis enim. Proin a mauris quis nunc fermentum ultrices eget a\n+     * erat. Mauris in lectus vitae metus sodales auctor. Morbi nunc\n+     * quam, ultricies at venenatis non, pellentesque ac dui.\n+     *\n+     * # Failure\n+     *\n+     * This function is full of fail\n+     */\n \n     fail;\n }\n \n mod fortress_of_solitude {\n-    #[doc = \"\n-    Superman's vacation home\n-\n-    The fortress of solitude is located in the Arctic and it is\n-    cold. What you may not know about the fortress of solitude\n-    though is that it contains two separate bowling alleys. One of\n-    them features bumper-bowling and is kind of lame.\n-\n-    Really, it's pretty cool.\n-\n-    \"];\n+    /*!\n+     * Superman's vacation home\n+     *\n+     * The fortress of solitude is located in the Arctic and it is\n+     * cold. What you may not know about the fortress of solitude\n+     * though is that it contains two separate bowling alleys. One of\n+     * them features bumper-bowling and is kind of lame.\n+     *\n+     * Really, it's pretty cool.\n+     */\n \n }\n \n mod blade_runner {\n-    #[doc = \"\n-    Blade Runner is probably the best movie ever\n-\n-    I like that in the world of Blade Runner it is always\n-    raining, and that it's always night time. And Aliens\n-    was also a really good movie.\n-\n-    Alien 3 was crap though.\n-    \"];\n+    /*!\n+     * Blade Runner is probably the best movie ever\n+     *\n+     * I like that in the world of Blade Runner it is always\n+     * raining, and that it's always night time. And Aliens\n+     * was also a really good movie.\n+     *\n+     * Alien 3 was crap though.\n+     */\n }\n \n-#[doc = \"\n-Bored\n-\n-Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed nec\n-molestie nisl. Duis massa risus, pharetra a scelerisque a,\n-molestie eu velit. Donec mattis ligula at ante imperdiet ut\n-dapibus mauris malesuada. Sed gravida nisi a metus elementum sit\n-amet hendrerit dolor bibendum. Aenean sit amet neque massa, sed\n-tempus tortor. Sed ut lobortis enim. Proin a mauris quis nunc\n-fermentum ultrices eget a erat. Mauris in lectus vitae metus\n-sodales auctor. Morbi nunc quam, ultricies at venenatis non,\n-pellentesque ac dui.\n-\n-Quisque vitae est id eros placerat laoreet sit amet eu\n-nisi. Curabitur suscipit neque porttitor est euismod\n-lacinia. Curabitur non quam vitae ipsum adipiscing\n-condimentum. Mauris ut ante eget metus sollicitudin\n-blandit. Aliquam erat volutpat. Morbi sed nisl mauris. Nulla\n-facilisi. Phasellus at mollis ipsum. Maecenas sed convallis\n-sapien. Nullam in ligula turpis. Pellentesque a neque augue. Sed\n-eget ante feugiat tortor congue auctor ac quis ante. Proin\n-condimentum lacinia tincidunt.\n-\n-\"]\n+/**\n+ * Bored\n+ *\n+ * Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed nec\n+ * molestie nisl. Duis massa risus, pharetra a scelerisque a,\n+ * molestie eu velit. Donec mattis ligula at ante imperdiet ut\n+ * dapibus mauris malesuada. Sed gravida nisi a metus elementum sit\n+ * amet hendrerit dolor bibendum. Aenean sit amet neque massa, sed\n+ * tempus tortor. Sed ut lobortis enim. Proin a mauris quis nunc\n+ * fermentum ultrices eget a erat. Mauris in lectus vitae metus\n+ * sodales auctor. Morbi nunc quam, ultricies at venenatis non,\n+ * pellentesque ac dui.\n+ *\n+ * Quisque vitae est id eros placerat laoreet sit amet eu\n+ * nisi. Curabitur suscipit neque porttitor est euismod\n+ * lacinia. Curabitur non quam vitae ipsum adipiscing\n+ * condimentum. Mauris ut ante eget metus sollicitudin\n+ * blandit. Aliquam erat volutpat. Morbi sed nisl mauris. Nulla\n+ * facilisi. Phasellus at mollis ipsum. Maecenas sed convallis\n+ * sapien. Nullam in ligula turpis. Pellentesque a neque augue. Sed\n+ * eget ante feugiat tortor congue auctor ac quis ante. Proin\n+ * condimentum lacinia tincidunt.\n+ */\n class bored {\n   let bored: bool;\n   new(bored: bool) { self.bored = bored; }\n   drop { log(error, self.bored); }\n }\n \n-#[doc = \"\n-The Shunned House\n-\n-From even the greatest of horrors irony is seldom absent. Sometimes it\n-enters directly into the composition of the events, while sometimes it\n-relates only to their fortuitous position among persons and\n-places. The latter sort is splendidly exemplified by a case in the\n-ancient city of Providence, where in the late forties Edgar Allan Poe\n-used to sojourn often during his unsuccessful wooing of the gifted\n-poetess, Mrs.  Whitman. Poe generally stopped at the Mansion House in\n-Benefit Street--the renamed Golden Ball Inn whose roof has sheltered\n-Washington, Jefferson, and Lafayette--and his favorite walk led\n-northward along the same street to Mrs. Whitman's home and the\n-neighboring hillside churchyard of St. John's, whose hidden expanse of\n-Eighteenth Century gravestones had for him a peculiar fascination.\n-\n-\"]\n+/**\n+ * The Shunned House\n+ *\n+ * From even the greatest of horrors irony is seldom absent. Sometimes it\n+ * enters directly into the composition of the events, while sometimes it\n+ * relates only to their fortuitous position among persons and\n+ * places. The latter sort is splendidly exemplified by a case in the\n+ * ancient city of Providence, where in the late forties Edgar Allan Poe\n+ * used to sojourn often during his unsuccessful wooing of the gifted\n+ * poetess, Mrs.  Whitman. Poe generally stopped at the Mansion House in\n+ * Benefit Street--the renamed Golden Ball Inn whose roof has sheltered\n+ * Washington, Jefferson, and Lafayette--and his favorite walk led\n+ * northward along the same street to Mrs. Whitman's home and the\n+ * neighboring hillside churchyard of St. John's, whose hidden expanse of\n+ * Eighteenth Century gravestones had for him a peculiar fascination.\n+ */\n iface the_shunned_house {\n-    #[doc = \"\n-    Now the irony is this. In this walk, so many times repeated, the\n-    world's greatest master of the terrible and the bizarre was\n-    obliged to pass a particular house on the eastern side of the\n-    street; a dingy, antiquated structure perched on the abruptly\n-    rising side hill, with a great unkempt yard dating from a time\n-    when the region was partly open country. It does not appear that\n-    he ever wrote or spoke of it, nor is there any evidence that he\n-    even noticed it. And yet that house, to the two persons in\n-    possession of certain information, equals or outranks in horror\n-    the wildest fantasy of the genius who so often passed it\n-    unknowingly, and stands starkly leering as a symbol of all that is\n-    unutterably hideous.\n-\n-    # Arguments\n-\n-    * unkempt_yard - A yard dating from a time when the region was partly\n-                     open country\n-    \"]\n+    /**\n+     * Now the irony is this. In this walk, so many times repeated, the\n+     * world's greatest master of the terrible and the bizarre was\n+     * obliged to pass a particular house on the eastern side of the\n+     * street; a dingy, antiquated structure perched on the abruptly\n+     * rising side hill, with a great unkempt yard dating from a time\n+     * when the region was partly open country. It does not appear that\n+     * he ever wrote or spoke of it, nor is there any evidence that he\n+     * even noticed it. And yet that house, to the two persons in\n+     * possession of certain information, equals or outranks in horror\n+     * the wildest fantasy of the genius who so often passed it\n+     * unknowingly, and stands starkly leering as a symbol of all that is\n+     * unutterably hideous.\n+     *\n+     * # Arguments\n+     *\n+     * * unkempt_yard - A yard dating from a time when the region was partly\n+     *                  open country\n+     */\n     fn dingy_house(unkempt_yard: int);\n \n-    #[doc = \"\n-    The house was--and for that matter still is--of a kind to attract\n-    the attention of the curious. Originally a farm or semi-farm\n-    building, it followed the average New England colonial lines of\n-    the middle Eighteenth Century--the prosperous peaked-roof sort,\n-    with two stories and dormerless attic, and with the Georgian\n-    doorway and interior panelling dictated by the progress of taste\n-    at that time. It faced south, with one gable end buried to the\n-    lower windows in the eastward rising hill, and the other exposed\n-    to the foundations toward the street. Its construction, over a\n-    century and a half ago, had followed the grading and straightening\n-    of the road in that especial vicinity; for Benefit Street--at\n-    first called Back Street--was laid out as a lane winding amongst\n-    the graveyards of the first settlers, and straightened only when\n-    the removal of the bodies to the North Burial Ground made it\n-    decently possible to cut through the old family plots.\n-    \"]\n+    /**\n+     * The house was--and for that matter still is--of a kind to attract\n+     * the attention of the curious. Originally a farm or semi-farm\n+     * building, it followed the average New England colonial lines of\n+     * the middle Eighteenth Century--the prosperous peaked-roof sort,\n+     * with two stories and dormerless attic, and with the Georgian\n+     * doorway and interior panelling dictated by the progress of taste\n+     * at that time. It faced south, with one gable end buried to the\n+     * lower windows in the eastward rising hill, and the other exposed\n+     * to the foundations toward the street. Its construction, over a\n+     * century and a half ago, had followed the grading and straightening\n+     * of the road in that especial vicinity; for Benefit Street--at\n+     * first called Back Street--was laid out as a lane winding amongst\n+     * the graveyards of the first settlers, and straightened only when\n+     * the removal of the bodies to the North Burial Ground made it\n+     * decently possible to cut through the old family plots.\n+     */\n     fn construct() -> bool;\n }\n \n-#[doc = \"Whatever\"]\n+/// Whatever\n impl of the_shunned_house for omnomnomy {\n     fn dingy_house(_unkempt_yard: int) {\n     }"}, {"sha": "15ed16945201ef8751b08f4835d22b7de8598e96", "filename": "src/rustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_to_brief_pass.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,11 +1,9 @@\n-#[doc = \"\n-\n-Pulls a brief description out of a long description.\n-\n-If the first paragraph of a long description is short enough then it\n-is interpreted as the brief description.\n-\n-\"];\n+/*!\n+ * Pulls a brief description out of a long description.\n+ *\n+ * If the first paragraph of a long description is short enough then it\n+ * is interpreted as the brief description.\n+ */\n \n export mk_pass;\n "}, {"sha": "744f62d0eb3d0d22d77a10727a4b4af3489fb30d", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"The document model\"];\n+//! The document model\n \n type ast_id = int;\n \n@@ -11,10 +11,10 @@ enum page {\n     itempage(itemtag)\n }\n \n-#[doc = \"\n-Most rustdocs can be parsed into 'sections' according to their markdown\n-headers\n-\"]\n+/**\n+ * Most rustdocs can be parsed into 'sections' according to their markdown\n+ * headers\n+ */\n type section = {\n     header: str,\n     body: str\n@@ -107,18 +107,16 @@ type index = {\n     entries: ~[index_entry]\n };\n \n-#[doc = \"\n-\n-A single entry in an index\n-\n-Fields:\n-\n-* kind - The type of thing being indexed, e.g. 'Module'\n-* name - The name of the thing\n-* brief - The brief description\n-* link - A format-specific string representing the link target\n-\n-\"]\n+/**\n+ * A single entry in an index\n+ *\n+ * Fields:\n+ *\n+ * * kind - The type of thing being indexed, e.g. 'Module'\n+ * * name - The name of the thing\n+ * * brief - The brief description\n+ * * link - A format-specific string representing the link target\n+ */\n type index_entry = {\n     kind: str,\n     name: str,\n@@ -141,7 +139,7 @@ impl util for doc {\n     }\n }\n \n-#[doc = \"Some helper methods on moddoc, mostly for testing\"]\n+/// Some helper methods on moddoc, mostly for testing\n impl util for moddoc {\n \n     fn mods() -> ~[moddoc] {"}, {"sha": "1cefe410e8ec7d5eb735df396e26dcfd5e0b8bf8", "filename": "src/rustdoc/escape_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fescape_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fescape_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fescape_pass.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Escapes text sequences\"];\n+//! Escapes text sequences\n \n export mk_pass;\n "}, {"sha": "affca61cb961b2474b762ed625ad097ad4d15346", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Converts the Rust AST to the rustdoc document model\"];\n+//! Converts the Rust AST to the rustdoc document model\n \n import syntax::ast;\n \n@@ -9,7 +9,7 @@ fn from_srv(\n     default_name: str\n ) -> doc::doc {\n \n-    #[doc = \"Use the AST service to create a document tree\"];\n+    //! Use the AST service to create a document tree\n \n     do astsrv::exec(srv) |ctxt| {\n         extract(ctxt.ast, default_name)"}, {"sha": "8a68ff8cadb4d64af3e5d41db2fa11aad5fed239", "filename": "src/rustdoc/markdown_index_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_index_pass.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Build indexes as appropriate for the markdown pass\"];\n+//! Build indexes as appropriate for the markdown pass\n \n export mk_pass;\n "}, {"sha": "19a3776f8ccf3167ec5198e738a8be3e827d63da", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Generate markdown from a document tree\"];\n+//! Generate markdown from a document tree\n \n import markdown_writer::writer;\n import markdown_writer::writer_util;"}, {"sha": "255854df8f03a9b68e74a8c8425c4bf8cc8bf237", "filename": "src/rustdoc/page_pass.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpage_pass.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,11 +1,9 @@\n-#[doc = \"\n-\n-Divides the document tree into pages.\n-\n-Each page corresponds is a logical section. There may be pages for individual\n-modules, pages for the crate, indexes, etc.\n-\n-\"];\n+/*!\n+ * Divides the document tree into pages.\n+ *\n+ * Each page corresponds is a logical section. There may be pages for\n+ * individual modules, pages for the crate, indexes, etc.\n+ */\n \n import syntax::ast;\n "}, {"sha": "c327830f517fb1746332d7f71c633c9c2acdf0d1", "filename": "src/rustdoc/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fparse.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"AST-parsing helpers\"];\n+//! AST-parsing helpers\n \n import rustc::driver::driver;\n import driver::{file_input, str_input};"}, {"sha": "91330cb119289e6e38894dce3086ecc10b2580b1", "filename": "src/rustdoc/path_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fpath_pass.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Records the full path to items\"];\n+//! Records the full path to items\n \n import syntax::ast;\n "}, {"sha": "e121cc88dd7f0841b6d5ee360b8f7e7e687a653c", "filename": "src/rustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_hidden_pass.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Prunes things with the #[doc(hidden)] attribute\"];\n+//! Prunes things with the #[doc(hidden)] attribute\n \n import std::map::hashmap;\n export mk_pass;"}, {"sha": "4622aeefba864f89d65f498e1386bcdd256a765d", "filename": "src/rustdoc/prune_unexported_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fprune_unexported_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fprune_unexported_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_unexported_pass.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Prunes branches of the tree that are not exported\"];\n+//! Prunes branches of the tree that are not exported\n \n import syntax::ast;\n import syntax::ast_util;"}, {"sha": "fcebe51dde807e3023d6efdb76217bd189da2386", "filename": "src/rustdoc/reexport_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Freexport_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Freexport_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Freexport_pass.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Finds docs for reexported items and duplicates them\"];\n+//! Finds docs for reexported items and duplicates them\n \n import std::map;\n import std::map::hashmap;"}, {"sha": "ab8f770e87f69cf244e92f62e3e232e5e294c3f6", "filename": "src/rustdoc/rustdoc.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Frustdoc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Frustdoc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rc?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Rustdoc - The Rust documentation generator\"];\n+//! Rustdoc - The Rust documentation generator\n \n #[link(name = \"rustdoc\",\n        vers = \"0.2\","}, {"sha": "2b70ea4ea96e9225ebcd7e4e0d3eff590fec0ca3", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -2,7 +2,7 @@\n import doc::item;\n import doc::util;\n \n-#[doc = \"A single operation on the document model\"]\n+/// A single operation on the document model\n type pass = {\n     name: str,\n     f: fn~(srv: astsrv::srv, doc: doc::doc) -> doc::doc\n@@ -125,7 +125,7 @@ fn time<T>(what: str, f: fn() -> T) -> T {\n     ret rv;\n }\n \n-#[doc = \"Runs rustdoc over the given file\"]\n+/// Runs rustdoc over the given file\n fn run(config: config::config) {\n \n     let source_file = config.input_crate;"}, {"sha": "ced74a9bfd38b3bca8b39d302c60384d5d075ae2", "filename": "src/rustdoc/sectionalize_pass.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsectionalize_pass.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Breaks rustdocs into sections according to their headers\"];\n+//! Breaks rustdocs into sections according to their headers\n \n export mk_pass;\n \n@@ -66,23 +66,21 @@ fn fold_impl(fold: fold::fold<()>, doc: doc::impldoc) -> doc::impldoc {\n \n fn sectionalize(desc: option<str>) -> (option<str>, ~[doc::section]) {\n \n-    #[doc = \"\n-\n-    Take a description of the form\n-\n-        General text\n-\n-        # Section header\n-\n-        Section text\n-\n-        # Section header\n-\n-        Section text\n-\n-    and remove each header and accompanying text into section records.\n-\n-    \"];\n+    /*!\n+     * Take a description of the form\n+     *\n+     *     General text\n+     *\n+     *     # Section header\n+     *\n+     *     Section text\n+     *\n+     *     # Section header\n+     *\n+     *     Section text\n+     *\n+     * and remove each header and accompanying text into section records.\n+     */\n \n     if option::is_none(desc) {\n         ret (none, ~[]);"}, {"sha": "47a69fed953b1297091ff548cdcd96027c419bc4", "filename": "src/rustdoc/sort_item_name_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fsort_item_name_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fsort_item_name_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_item_name_pass.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Sorts items by name\"];\n+//! Sorts items by name\n \n export mk_pass;\n "}, {"sha": "92a2b381fdb13272c172276b1bb0ced2ed1d467e", "filename": "src/rustdoc/sort_item_type_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fsort_item_type_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fsort_item_type_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_item_type_pass.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Sorts items by type\"];\n+//! Sorts items by type\n \n export mk_pass;\n "}, {"sha": "86dc2260e7d7078da20e7419a7d5e776092dadfc", "filename": "src/rustdoc/sort_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fsort_pass.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"A general sorting pass\"];\n+//! A general sorting pass\n \n import std::sort;\n "}, {"sha": "126cdc0d9e0ddfeab47e1e3a30e64e849ee7aa98", "filename": "src/rustdoc/text_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftext_pass.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,4 +1,4 @@\n-#[doc = \"Generic pass for performing an operation on all descriptions\"];\n+//! Generic pass for performing an operation on all descriptions\n \n export mk_pass;\n "}, {"sha": "3d135d8073c02cde0f3928deceec58361cf123e9", "filename": "src/rustdoc/trim_pass.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftrim_pass.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,11 +1,9 @@\n-#[doc = \"\n-\n-Pulls a brief description out of a long description.\n-\n-If the first paragraph of a long description is short enough then it\n-is interpreted as the brief description.\n-\n-\"];\n+/*!\n+ * Pulls a brief description out of a long description.\n+ *\n+ * If the first paragraph of a long description is short enough then it\n+ * is interpreted as the brief description.\n+ */\n \n export mk_pass;\n "}, {"sha": "a09c3a3b2fa84e0d3206356f2b32b0d19c099be7", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,5 +1,4 @@\n-#[doc =\n-  \"Pulls type information out of the AST and attaches it to the document\"];\n+//! Pulls type information out of the AST and attaches it to the document\n \n import syntax::ast;\n import syntax::print::pprust;"}, {"sha": "1df8d5b8f5029294b721d7f1bd41e7cb23d7f15f", "filename": "src/rustdoc/unindent_pass.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Frustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Funindent_pass.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -1,15 +1,13 @@\n-#[doc = \"\n-\n-Removes the common level of indention from description strings. For\n-instance, if an entire doc comment is indented 8 spaces we want to\n-remove those 8 spaces from every line.\n-\n-The first line of a string is allowed to be intend less than\n-subsequent lines in the same paragraph in order to account for\n-instances where the string containing the doc comment is opened in the\n-middle of a line, and each of the following lines is indented.\n-\n-\"];\n+/*!\n+ * Removes the common level of indention from description strings. For\n+ * instance, if an entire doc comment is indented 8 spaces we want to\n+ * remove those 8 spaces from every line.\n+ *\n+ * The first line of a string is allowed to be intend less than\n+ * subsequent lines in the same paragraph in order to account for\n+ * instances where the string containing the doc comment is opened in the\n+ * middle of a line, and each of the following lines is indented.\n+ */\n \n export mk_pass;\n "}, {"sha": "d47053c4da6862ad2d391d354313a40e54060b2c", "filename": "src/test/auxiliary/test_comm.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftest_comm.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -11,18 +11,18 @@ export port;\n export recv;\n \n \n-#[doc = \"\n-A communication endpoint that can receive messages\n-\n-Each port has a unique per-task identity and may not be replicated or\n-transmitted. If a port value is copied, both copies refer to the same\n-port.  Ports may be associated with multiple `chan`s.\n-\"]\n+/**\n+ * A communication endpoint that can receive messages\n+ *\n+ * Each port has a unique per-task identity and may not be replicated or\n+ * transmitted. If a port value is copied, both copies refer to the same\n+ * port.  Ports may be associated with multiple `chan`s.\n+ */\n enum port<T: send> {\n     port_t(@port_ptr<T>)\n }\n \n-#[doc = \"Constructs a port\"]\n+/// Constructs a port\n fn port<T: send>() -> port<T> {\n     port_t(@port_ptr(rustrt::new_port(sys::size_of::<T>() as size_t)))\n }\n@@ -52,14 +52,14 @@ class port_ptr<T:send> {\n }\n \n \n-#[doc = \"\n-Receive from a port.  If no data is available on the port then the\n-task will block until data becomes available.\n-\"]\n+/**\n+ * Receive from a port.  If no data is available on the port then the\n+ * task will block until data becomes available.\n+ */\n fn recv<T: send>(p: port<T>) -> T { recv_((**p).po) }\n \n \n-#[doc = \"Receive on a raw port pointer\"]\n+/// Receive on a raw port pointer\n fn recv_<T: send>(p: *rust_port) -> T {\n     let yield = 0u;\n     let yieldp = ptr::addr_of(yield);"}, {"sha": "5f3946e142436f221b02542d8515baee0fbbb76a", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -98,9 +98,11 @@ fn gen_search_keys(graph: graph, n: uint) -> ~[node_id] {\n     map::vec_from_set(keys)\n }\n \n-#[doc=\"Returns a vector of all the parents in the BFS tree rooted at key.\n-\n-Nodes that are unreachable have a parent of -1.\"]\n+/**\n+ * Returns a vector of all the parents in the BFS tree rooted at key.\n+ *\n+ * Nodes that are unreachable have a parent of -1.\n+ */\n fn bfs(graph: graph, key: node_id) -> bfs_result {\n     let marks : ~[mut node_id] \n         = vec::to_mut(vec::from_elem(vec::len(graph), -1i64));\n@@ -125,10 +127,12 @@ fn bfs(graph: graph, key: node_id) -> bfs_result {\n     vec::from_mut(marks)\n }\n \n-#[doc=\"Another version of the bfs function.\n-\n-This one uses the same algorithm as the parallel one, just without\n-using the parallel vector operators.\"]\n+/**\n+ * Another version of the bfs function.\n+ *\n+ * This one uses the same algorithm as the parallel one, just without\n+ * using the parallel vector operators.\n+ */\n fn bfs2(graph: graph, key: node_id) -> bfs_result {\n     // This works by doing functional updates of a color vector.\n \n@@ -197,7 +201,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n     }\n }\n \n-#[doc=\"A parallel version of the bfs function.\"]\n+/// A parallel version of the bfs function.\n fn pbfs(&&graph: arc::arc<graph>, key: node_id) -> bfs_result {\n     // This works by doing functional updates of a color vector.\n \n@@ -277,7 +281,7 @@ fn pbfs(&&graph: arc::arc<graph>, key: node_id) -> bfs_result {\n     }\n }\n \n-#[doc=\"Performs at least some of the validation in the Graph500 spec.\"]\n+/// Performs at least some of the validation in the Graph500 spec.\n fn validate(edges: ~[(node_id, node_id)], \n             root: node_id, tree: bfs_result) -> bool {\n     // There are 5 things to test. Below is code for each of them."}, {"sha": "835c1d9640a0f433c0106740214c924fa89bd470", "filename": "src/test/pretty/doc-comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Ftest%2Fpretty%2Fdoc-comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Ftest%2Fpretty%2Fdoc-comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdoc-comments.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -6,7 +6,7 @@\n fn a() { }\n \n fn b() {\n-    //~ some single line inner-docs\n+    //! some single line inner-docs\n }\n \n /*"}, {"sha": "47a7d00908c12ed6d36454d82378767ce37a65bd", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be0141666dd12316034499db12ee9fcf9ba648dd/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=be0141666dd12316034499db12ee9fcf9ba648dd", "patch": "@@ -4,14 +4,14 @@\n import intrinsic::ty_visitor;\n import libc::c_void;\n \n-#[doc = \"High-level interfaces to `intrinsic::visit_ty` reflection system.\"]\n+/// High-level interfaces to `intrinsic::visit_ty` reflection system.\n \n-#[doc = \"Iface for visitor that wishes to reflect on data.\"]\n+/// Iface for visitor that wishes to reflect on data.\n iface movable_ptr {\n     fn move_ptr(adjustment: fn(*c_void) -> *c_void);\n }\n \n-#[doc = \"Helper function for alignment calculation.\"]\n+/// Helper function for alignment calculation.\n #[inline(always)]\n fn align(size: uint, align: uint) -> uint {\n     ((size + align) - 1u) & !(align - 1u)"}]}