{"sha": "e783a0a5e39d5ae2fa147508197d09a51530fae8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3ODNhMGE1ZTM5ZDVhZTJmYTE0NzUwODE5N2QwOWE1MTUzMGZhZTg=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2016-05-17T13:45:02Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-06-09T22:06:37Z"}, "message": "make all pattern bindings with the same name resolve to the first one\n\nThis simplifies the code considerably, removing one of the\nlast uses of hygienic matching out of resolution.", "tree": {"sha": "8091cdf9422e139f634fb5624e7cbd86eb4fa3e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8091cdf9422e139f634fb5624e7cbd86eb4fa3e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e783a0a5e39d5ae2fa147508197d09a51530fae8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e783a0a5e39d5ae2fa147508197d09a51530fae8", "html_url": "https://github.com/rust-lang/rust/commit/e783a0a5e39d5ae2fa147508197d09a51530fae8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e783a0a5e39d5ae2fa147508197d09a51530fae8/comments", "author": null, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "392b6e7c8150ca852138212457a0dfae25eaa9b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/392b6e7c8150ca852138212457a0dfae25eaa9b2", "html_url": "https://github.com/rust-lang/rust/commit/392b6e7c8150ca852138212457a0dfae25eaa9b2"}], "stats": {"total": 99, "additions": 22, "deletions": 77}, "files": [{"sha": "6405be7455dfef3f1d8dac2f62a5df81c40782c6", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e783a0a5e39d5ae2fa147508197d09a51530fae8/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e783a0a5e39d5ae2fa147508197d09a51530fae8/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=e783a0a5e39d5ae2fa147508197d09a51530fae8", "patch": "@@ -53,16 +53,6 @@ impl<T: ExactSizeIterator> EnumerateAndAdjustIterator for T {\n     }\n }\n \n-// This is used because same-named variables in alternative patterns need to\n-// use the NodeId of their namesake in the first pattern.\n-pub fn pat_id_map(pat: &hir::Pat) -> PatIdMap {\n-    let mut map = FnvHashMap();\n-    pat_bindings(pat, |_bm, p_id, _s, path1| {\n-        map.insert(path1.node, p_id);\n-    });\n-    map\n-}\n-\n pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n         PatKind::Lit(_) | PatKind::Range(_, _) | PatKind::QPath(..) => true,"}, {"sha": "b5e2ce9de483692054406c1b0371dea674538ae8", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e783a0a5e39d5ae2fa147508197d09a51530fae8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e783a0a5e39d5ae2fa147508197d09a51530fae8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=e783a0a5e39d5ae2fa147508197d09a51530fae8", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use hair::*;\n-use rustc_data_structures::fnv::FnvHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_const_math::ConstInt;\n use hair::cx::Cx;\n@@ -20,7 +19,6 @@ use rustc::hir::def::Def;\n use rustc::middle::const_val::ConstVal;\n use rustc_const_eval as const_eval;\n use rustc::middle::region::CodeExtent;\n-use rustc::hir::pat_util;\n use rustc::ty::{self, VariantDef, Ty};\n use rustc::ty::cast::CastKind as TyCastKind;\n use rustc::mir::repr::*;\n@@ -652,19 +650,8 @@ fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n \n fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                arm: &'tcx hir::Arm) -> Arm<'tcx> {\n-    let mut map;\n-    let opt_map = if arm.pats.len() == 1 {\n-        None\n-    } else {\n-        map = FnvHashMap();\n-        pat_util::pat_bindings(&arm.pats[0], |_, p_id, _, path| {\n-            map.insert(path.node, p_id);\n-        });\n-        Some(&map)\n-    };\n-\n     Arm {\n-        patterns: arm.pats.iter().map(|p| cx.refutable_pat(opt_map, p)).collect(),\n+        patterns: arm.pats.iter().map(|p| cx.refutable_pat(p)).collect(),\n         guard: arm.guard.to_ref(),\n         body: arm.body.to_ref(),\n     }"}, {"sha": "89bd0fdf89760a0ad5f1d06ad3a79b64bdc380bb", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e783a0a5e39d5ae2fa147508197d09a51530fae8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e783a0a5e39d5ae2fa147508197d09a51530fae8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=e783a0a5e39d5ae2fa147508197d09a51530fae8", "patch": "@@ -10,15 +10,13 @@\n \n use hair::*;\n use hair::cx::Cx;\n-use rustc_data_structures::fnv::FnvHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_const_eval as const_eval;\n use rustc::hir::def::Def;\n use rustc::hir::pat_util::{EnumerateAndAdjustIterator, pat_is_resolved_const};\n use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n use rustc::hir::{self, PatKind};\n-use syntax::ast;\n use syntax::codemap::Span;\n use syntax::ptr::P;\n \n@@ -37,29 +35,25 @@ use syntax::ptr::P;\n /// ```\n struct PatCx<'patcx, 'cx: 'patcx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     cx: &'patcx mut Cx<'cx, 'gcx, 'tcx>,\n-    binding_map: Option<&'patcx FnvHashMap<ast::Name, ast::NodeId>>,\n }\n \n impl<'cx, 'gcx, 'tcx> Cx<'cx, 'gcx, 'tcx> {\n     pub fn irrefutable_pat(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n-        PatCx::new(self, None).to_pattern(pat)\n+        PatCx::new(self).to_pattern(pat)\n     }\n \n     pub fn refutable_pat(&mut self,\n-                         binding_map: Option<&FnvHashMap<ast::Name, ast::NodeId>>,\n                          pat: &hir::Pat)\n                          -> Pattern<'tcx> {\n-        PatCx::new(self, binding_map).to_pattern(pat)\n+        PatCx::new(self).to_pattern(pat)\n     }\n }\n \n impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n-    fn new(cx: &'patcx mut Cx<'cx, 'gcx, 'tcx>,\n-               binding_map: Option<&'patcx FnvHashMap<ast::Name, ast::NodeId>>)\n+    fn new(cx: &'patcx mut Cx<'cx, 'gcx, 'tcx>)\n                -> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n         PatCx {\n             cx: cx,\n-            binding_map: binding_map,\n         }\n     }\n \n@@ -168,10 +162,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n             }\n \n             PatKind::Binding(bm, ref ident, ref sub) => {\n-                let id = match self.binding_map {\n-                    None => pat.id,\n-                    Some(ref map) => map[&ident.node],\n-                };\n+                let id = self.cx.tcx.def_map.borrow()[&pat.id].full_def().var_id();\n                 let var_ty = self.cx.tcx.node_id_to_type(pat.id);\n                 let region = match var_ty.sty {\n                     ty::TyRef(&r, _) => Some(r),"}, {"sha": "bee0d6338d8528518cf3c21e5806b6a6f692b07e", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e783a0a5e39d5ae2fa147508197d09a51530fae8/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e783a0a5e39d5ae2fa147508197d09a51530fae8/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=e783a0a5e39d5ae2fa147508197d09a51530fae8", "patch": "@@ -10,7 +10,6 @@\n \n use hir::def::Def;\n use rustc::infer::{self, InferOk, TypeOrigin};\n-use hir::pat_util::{PatIdMap, pat_id_map};\n use hir::pat_util::{EnumerateAndAdjustIterator, pat_is_resolved_const};\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n@@ -21,26 +20,13 @@ use session::Session;\n \n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::cmp;\n-use std::ops::Deref;\n use syntax::ast;\n use syntax::codemap::{Span, Spanned};\n use syntax::ptr::P;\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::print as pprust;\n \n-pub struct PatCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    pub fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    pub map: PatIdMap,\n-}\n-\n-impl<'a, 'gcx, 'tcx> Deref for PatCtxt<'a, 'gcx, 'tcx> {\n-    type Target = FnCtxt<'a, 'gcx, 'tcx>;\n-    fn deref(&self) -> &Self::Target {\n-        self.fcx\n-    }\n-}\n-\n // This function exists due to the warning \"diagnostic code E0164 already used\"\n fn bad_struct_kind_err(sess: &Session, pat: &hir::Pat, path: &hir::Path, lint: bool) {\n     let name = pprust::path_to_string(path);\n@@ -55,7 +41,7 @@ fn bad_struct_kind_err(sess: &Session, pat: &hir::Pat, path: &hir::Path, lint: b\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_pat(&self, pat: &'gcx hir::Pat, expected: Ty<'tcx>) {\n         let tcx = self.tcx;\n \n@@ -194,15 +180,19 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n \n                 // if there are multiple arms, make sure they all agree on\n                 // what the type of the binding `x` ought to be\n-                if let Some(&canon_id) = self.map.get(&path.node) {\n-                    if canon_id != pat.id {\n-                        let ct = self.local_ty(pat.span, canon_id);\n-                        self.demand_eqtype(pat.span, ct, typ);\n+                match tcx.def_map.borrow()[&pat.id].full_def() {\n+                    Def::Err => {}\n+                    Def::Local(_, var_id) => {\n+                        if var_id != pat.id {\n+                            let vt = self.local_ty(pat.span, var_id);\n+                            self.demand_eqtype(pat.span, vt, typ);\n+                        }\n                     }\n+                    d => bug!(\"bad def for pattern binding `{:?}`\", d)\n+                }\n \n-                    if let Some(ref p) = *sub {\n-                        self.check_pat(&p, expected);\n-                    }\n+                if let Some(ref p) = *sub {\n+                    self.check_pat(&p, expected);\n                 }\n             }\n             PatKind::TupleStruct(ref path, ref subpats, ddpos) => {\n@@ -476,12 +466,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Typecheck the patterns first, so that we get types for all the\n         // bindings.\n         for arm in arms {\n-            let pcx = PatCtxt {\n-                fcx: self,\n-                map: pat_id_map(&arm.pats[0]),\n-            };\n             for p in &arm.pats {\n-                pcx.check_pat(&p, discrim_ty);\n+                self.check_pat(&p, discrim_ty);\n             }\n         }\n \n@@ -566,7 +552,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_pat_struct(&self, pat: &'gcx hir::Pat,\n                             path: &hir::Path, fields: &'gcx [Spanned<hir::FieldPat>],\n                             etc: bool, expected: Ty<'tcx>) {"}, {"sha": "4dee1e43d16ab84e429c645bcc6edcc351830dd0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e783a0a5e39d5ae2fa147508197d09a51530fae8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e783a0a5e39d5ae2fa147508197d09a51530fae8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e783a0a5e39d5ae2fa147508197d09a51530fae8", "patch": "@@ -81,14 +81,13 @@ pub use self::compare_method::{compare_impl_method, compare_const_impl};\n use self::TupleArgumentsFlag::*;\n \n use astconv::{AstConv, ast_region_to_region, PathParamMode};\n-use check::_match::PatCtxt;\n use dep_graph::DepNode;\n use fmt_macros::{Parser, Piece, Position};\n use middle::cstore::LOCAL_CRATE;\n use hir::def::{self, Def};\n use hir::def_id::DefId;\n use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin, TypeTrace, type_variable};\n-use hir::pat_util::{self, pat_id_map};\n+use hir::pat_util::{self};\n use rustc::ty::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace};\n use rustc::traits::{self, ProjectionMode};\n use rustc::ty::{GenericPredicates, TypeScheme};\n@@ -672,11 +671,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n             });\n \n             // Check the pattern.\n-            let pcx = PatCtxt {\n-                fcx: &fcx,\n-                map: pat_id_map(&input.pat),\n-            };\n-            pcx.check_pat(&input.pat, *arg_ty);\n+            fcx.check_pat(&input.pat, *arg_ty);\n         }\n \n         visit.visit_block(body);\n@@ -3786,11 +3781,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        let pcx = PatCtxt {\n-            fcx: self,\n-            map: pat_id_map(&local.pat),\n-        };\n-        pcx.check_pat(&local.pat, t);\n+        self.check_pat(&local.pat, t);\n         let pat_ty = self.node_ty(local.pat.id);\n         if pat_ty.references_error() {\n             self.write_ty(local.id, pat_ty);"}]}