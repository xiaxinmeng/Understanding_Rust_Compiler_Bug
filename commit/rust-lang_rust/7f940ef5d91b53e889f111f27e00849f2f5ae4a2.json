{"sha": "7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmOTQwZWY1ZDkxYjUzZTg4OWYxMTFmMjdlMDA4NDlmMmY1YWU0YTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-23T03:30:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-23T03:30:07Z"}, "message": "Auto merge of #72256 - ecstatic-morse:once-cell, r=Mark-Simulacrum\n\nUse `once_cell` crate instead of custom data structure\n\nInternally, we use the [`Once`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/sync/struct.Once.html) type for shared data that is initialized exactly once and only read from afterwards. `Once` uses a `parking_lot::Mutex` when the parallel compiler is enabled and a `RefCell` when it is not. This PR switches to the [`once_cell`](https://crates.io/crates/once_cell) crate, which also uses a `parking_lot::Mutex` for its `sync` version (because we enable the `parking_lot` feature) but has zero overhead for its `unsync` one.\n\nThis PR adds `once_cell` to the list of whitelisted dependencies. I think this is acceptable because it is already used in `rustc_driver`, is owned by a well-known community member (cc @matklad), and has a stable release. cc @rust-lang/compiler\n\n`once_cell` has a slightly more minimal API than `Once`, which allows for initialization to be either optimistic (evaluate the initializer and then synchronize) or pessimistic (synchronize and then evaluate the initializer). `once_cell`'s `get_or_init` is always pessimistic. The optimistic version is only used once in the current `master`.\n\nr? @Mark-Simulacrum", "tree": {"sha": "0ab268d2eb6d5d13266fcf53878919603439c62a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ab268d2eb6d5d13266fcf53878919603439c62a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "html_url": "https://github.com/rust-lang/rust/commit/7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "215f2d3294b08dbdcf8f7d40de21ef1e7eae0a2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/215f2d3294b08dbdcf8f7d40de21ef1e7eae0a2d", "html_url": "https://github.com/rust-lang/rust/commit/215f2d3294b08dbdcf8f7d40de21ef1e7eae0a2d"}, {"sha": "307153e611433f9224224a4511b6ea4f362ffe28", "url": "https://api.github.com/repos/rust-lang/rust/commits/307153e611433f9224224a4511b6ea4f362ffe28", "html_url": "https://github.com/rust-lang/rust/commit/307153e611433f9224224a4511b6ea4f362ffe28"}], "stats": {"total": 388, "additions": 139, "deletions": 249}, "files": [{"sha": "2fdbfa26787e006ad604baa3e30baf48a2b4dc43", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -2327,6 +2327,9 @@ name = \"once_cell\"\n version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d6a04cb71e910d0034815600180f62a95bf6e67942d7ab52a166a68c7d7e9cd0\"\n+dependencies = [\n+ \"parking_lot 0.9.0\",\n+]\n \n [[package]]\n name = \"opaque-debug\"\n@@ -3791,6 +3794,7 @@ dependencies = [\n  \"libc\",\n  \"log\",\n  \"measureme\",\n+ \"once_cell\",\n  \"parking_lot 0.10.2\",\n  \"rustc-hash\",\n  \"rustc-rayon\","}, {"sha": "0eabb726b88c96fe64917415dbf7a4de1c2c940f", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -269,7 +269,7 @@ pub fn lower_crate<'a, 'hir>(\n     let _prof_timer = sess.prof.verbose_generic_activity(\"hir_lowering\");\n \n     LoweringContext {\n-        crate_root: sess.parse_sess.injected_crate_name.try_get().copied(),\n+        crate_root: sess.parse_sess.injected_crate_name.get().copied(),\n         sess,\n         resolver,\n         nt_to_tokenstream,"}, {"sha": "4c810a37d418068bf441597173d9c69bd7f6649f", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -174,7 +174,7 @@ pub unsafe fn create_module(\n         llvm::LLVMRustSetModulePICLevel(llmod);\n         // PIE is potentially more effective than PIC, but can only be used in executables.\n         // If all our outputs are executables, then we can relax PIC to PIE.\n-        if sess.crate_types.get().iter().all(|ty| *ty == CrateType::Executable) {\n+        if sess.crate_types().iter().all(|ty| *ty == CrateType::Executable) {\n             llvm::LLVMRustSetModulePIELevel(llmod);\n         }\n     }"}, {"sha": "9a7c4907754b04b00c688fb965e20430d28f7d33", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -53,7 +53,7 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n ) {\n     let _timer = sess.timer(\"link_binary\");\n     let output_metadata = sess.opts.output_types.contains_key(&OutputType::Metadata);\n-    for &crate_type in sess.crate_types.borrow().iter() {\n+    for &crate_type in sess.crate_types().iter() {\n         // Ignore executable crates if we have -Z no-codegen, as they will error.\n         if (sess.opts.debugging_opts.no_codegen || !sess.opts.output_types.should_codegen())\n             && !output_metadata\n@@ -875,11 +875,8 @@ fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n \n     // If we're only producing artifacts that are archives, no need to preserve\n     // the objects as they're losslessly contained inside the archives.\n-    let output_linked = sess\n-        .crate_types\n-        .borrow()\n-        .iter()\n-        .any(|&x| x != CrateType::Rlib && x != CrateType::Staticlib);\n+    let output_linked =\n+        sess.crate_types().iter().any(|&x| x != CrateType::Rlib && x != CrateType::Staticlib);\n     if !output_linked {\n         return false;\n     }"}, {"sha": "49de8c5e28ab59218d269ebb1ed9919033254559", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -44,8 +44,7 @@ impl LinkerInfo {\n         LinkerInfo {\n             exports: tcx\n                 .sess\n-                .crate_types\n-                .borrow()\n+                .crate_types()\n                 .iter()\n                 .map(|&c| (c, exported_symbols(tcx, c)))\n                 .collect(),"}, {"sha": "970d13b30c04e28feb7a6ba41fd268627a2d0b1c", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -18,7 +18,7 @@ use rustc_middle::ty::{SymbolName, TyCtxt};\n use rustc_session::config::{CrateType, Sanitizer};\n \n pub fn threshold(tcx: TyCtxt<'_>) -> SymbolExportLevel {\n-    crates_export_threshold(&tcx.sess.crate_types.borrow())\n+    crates_export_threshold(&tcx.sess.crate_types())\n }\n \n fn crate_export_threshold(crate_type: CrateType) -> SymbolExportLevel {\n@@ -212,7 +212,7 @@ fn exported_symbols_provider_local(\n         }));\n     }\n \n-    if tcx.sess.crate_types.borrow().contains(&CrateType::Dylib) {\n+    if tcx.sess.crate_types().contains(&CrateType::Dylib) {\n         let symbol_name = metadata_symbol_name(tcx);\n         let exported_symbol = ExportedSymbol::NoDefId(SymbolName::new(&symbol_name));\n "}, {"sha": "9e03c283cfb5c8a25b2aafaa89cf8a61c9c5d199", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -382,7 +382,7 @@ pub struct CompiledModules {\n \n fn need_bitcode_in_object(sess: &Session) -> bool {\n     let requested_for_rlib = sess.opts.cg.embed_bitcode\n-        && sess.crate_types.borrow().contains(&CrateType::Rlib)\n+        && sess.crate_types().contains(&CrateType::Rlib)\n         && sess.opts.output_types.contains_key(&OutputType::Exe);\n     let forced_by_target = sess.target.target.options.forces_embed_bitcode;\n     requested_for_rlib || forced_by_target\n@@ -991,7 +991,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     };\n     let cgcx = CodegenContext::<B> {\n         backend: backend.clone(),\n-        crate_types: sess.crate_types.borrow().clone(),\n+        crate_types: sess.crate_types().to_vec(),\n         each_linked_rlib_for_lto,\n         lto: sess.lto(),\n         no_landing_pads: sess.panic_strategy() == PanicStrategy::Abort,\n@@ -1812,7 +1812,7 @@ fn msvc_imps_needed(tcx: TyCtxt<'_>) -> bool {\n     );\n \n     tcx.sess.target.target.options.is_like_msvc &&\n-        tcx.sess.crate_types.borrow().iter().any(|ct| *ct == CrateType::Rlib) &&\n+        tcx.sess.crate_types().iter().any(|ct| *ct == CrateType::Rlib) &&\n     // ThinLTO can't handle this workaround in all cases, so we don't\n     // emit the `__imp_` symbols. Instead we make them unnecessary by disallowing\n     // dynamic linking when linker plugin LTO is enabled."}, {"sha": "5b14258bd25beb3a7e1045e603dfb1e0359b64e9", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -948,7 +948,7 @@ fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguR\n         match compute_per_cgu_lto_type(\n             &tcx.sess.lto(),\n             &tcx.sess.opts,\n-            &tcx.sess.crate_types.borrow(),\n+            &tcx.sess.crate_types(),\n             ModuleKind::Regular,\n         ) {\n             ComputedLtoType::No => CguReuse::PostLto,"}, {"sha": "67721220526cac88f0f709213b15ccde4119968c", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -15,6 +15,7 @@ indexmap = \"1\"\n log = \"0.4\"\n jobserver_crate = { version = \"0.1.13\", package = \"jobserver\" }\n lazy_static = \"1\"\n+once_cell = { version = \"1\", features = [\"parking_lot\"] }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n graphviz = { path = \"../libgraphviz\" }\n cfg-if = \"0.1.2\""}, {"sha": "39afb3d82ff5aae9ef943718051b9709ff5229c5", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 4, "deletions": 129, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -20,7 +20,6 @@\n use crate::owning_ref::{Erased, OwningRef};\n use std::collections::HashMap;\n use std::hash::{BuildHasher, Hash};\n-use std::marker::PhantomData;\n use std::ops::{Deref, DerefMut};\n \n pub use std::sync::atomic::Ordering;\n@@ -230,6 +229,8 @@ cfg_if! {\n         pub use std::cell::RefMut as LockGuard;\n         pub use std::cell::RefMut as MappedLockGuard;\n \n+        pub use once_cell::unsync::OnceCell;\n+\n         use std::cell::RefCell as InnerRwLock;\n         use std::cell::RefCell as InnerLock;\n \n@@ -313,6 +314,8 @@ cfg_if! {\n         pub use parking_lot::MutexGuard as LockGuard;\n         pub use parking_lot::MappedMutexGuard as MappedLockGuard;\n \n+        pub use once_cell::sync::OnceCell;\n+\n         pub use std::sync::atomic::{AtomicBool, AtomicUsize, AtomicU32, AtomicU64};\n \n         pub use crossbeam_utils::atomic::AtomicCell;\n@@ -432,134 +435,6 @@ impl<K: Eq + Hash, V: Eq, S: BuildHasher> HashMapExt<K, V> for HashMap<K, V, S>\n     }\n }\n \n-/// A type whose inner value can be written once and then will stay read-only\n-// This contains a PhantomData<T> since this type conceptually owns a T outside the Mutex once\n-// initialized. This ensures that Once<T> is Sync only if T is. If we did not have PhantomData<T>\n-// we could send a &Once<Cell<bool>> to multiple threads and call `get` on it to get access\n-// to &Cell<bool> on those threads.\n-pub struct Once<T>(Lock<Option<T>>, PhantomData<T>);\n-\n-impl<T> Once<T> {\n-    /// Creates an Once value which is uninitialized\n-    #[inline(always)]\n-    pub fn new() -> Self {\n-        Once(Lock::new(None), PhantomData)\n-    }\n-\n-    /// Consumes the value and returns Some(T) if it was initialized\n-    #[inline(always)]\n-    pub fn into_inner(self) -> Option<T> {\n-        self.0.into_inner()\n-    }\n-\n-    /// Tries to initialize the inner value to `value`.\n-    /// Returns `None` if the inner value was uninitialized and `value` was consumed setting it\n-    /// otherwise if the inner value was already set it returns `value` back to the caller\n-    #[inline]\n-    pub fn try_set(&self, value: T) -> Option<T> {\n-        let mut lock = self.0.lock();\n-        if lock.is_some() {\n-            return Some(value);\n-        }\n-        *lock = Some(value);\n-        None\n-    }\n-\n-    /// Tries to initialize the inner value to `value`.\n-    /// Returns `None` if the inner value was uninitialized and `value` was consumed setting it\n-    /// otherwise if the inner value was already set it asserts that `value` is equal to the inner\n-    /// value and then returns `value` back to the caller\n-    #[inline]\n-    pub fn try_set_same(&self, value: T) -> Option<T>\n-    where\n-        T: Eq,\n-    {\n-        let mut lock = self.0.lock();\n-        if let Some(ref inner) = *lock {\n-            assert!(*inner == value);\n-            return Some(value);\n-        }\n-        *lock = Some(value);\n-        None\n-    }\n-\n-    /// Tries to initialize the inner value to `value` and panics if it was already initialized\n-    #[inline]\n-    pub fn set(&self, value: T) {\n-        assert!(self.try_set(value).is_none());\n-    }\n-\n-    /// Initializes the inner value if it wasn't already done by calling the provided closure. It\n-    /// ensures that no-one else can access the value in the mean time by holding a lock for the\n-    /// duration of the closure.\n-    /// A reference to the inner value is returned.\n-    #[inline]\n-    pub fn init_locking<F: FnOnce() -> T>(&self, f: F) -> &T {\n-        {\n-            let mut lock = self.0.lock();\n-            if lock.is_none() {\n-                *lock = Some(f());\n-            }\n-        }\n-\n-        self.borrow()\n-    }\n-\n-    /// Tries to initialize the inner value by calling the closure without ensuring that no-one\n-    /// else can access it. This mean when this is called from multiple threads, multiple\n-    /// closures may concurrently be computing a value which the inner value should take.\n-    /// Only one of these closures are used to actually initialize the value.\n-    /// If some other closure already set the value,\n-    /// we return the value our closure computed wrapped in a `Option`.\n-    /// If our closure set the value, `None` is returned.\n-    /// If the value is already initialized, the closure is not called and `None` is returned.\n-    #[inline]\n-    pub fn init_nonlocking<F: FnOnce() -> T>(&self, f: F) -> Option<T> {\n-        if self.0.lock().is_some() { None } else { self.try_set(f()) }\n-    }\n-\n-    /// Tries to initialize the inner value by calling the closure without ensuring that no-one\n-    /// else can access it. This mean when this is called from multiple threads, multiple\n-    /// closures may concurrently be computing a value which the inner value should take.\n-    /// Only one of these closures are used to actually initialize the value.\n-    /// If some other closure already set the value, we assert that it our closure computed\n-    /// a value equal to the value already set and then\n-    /// we return the value our closure computed wrapped in a `Option`.\n-    /// If our closure set the value, `None` is returned.\n-    /// If the value is already initialized, the closure is not called and `None` is returned.\n-    #[inline]\n-    pub fn init_nonlocking_same<F: FnOnce() -> T>(&self, f: F) -> Option<T>\n-    where\n-        T: Eq,\n-    {\n-        if self.0.lock().is_some() { None } else { self.try_set_same(f()) }\n-    }\n-\n-    /// Tries to get a reference to the inner value, returns `None` if it is not yet initialized\n-    #[inline(always)]\n-    pub fn try_get(&self) -> Option<&T> {\n-        let lock = &*self.0.lock();\n-        if let Some(ref inner) = *lock {\n-            // This is safe since we won't mutate the inner value\n-            unsafe { Some(&*(inner as *const T)) }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Gets reference to the inner value, panics if it is not yet initialized\n-    #[inline(always)]\n-    pub fn get(&self) -> &T {\n-        self.try_get().expect(\"value was not set\")\n-    }\n-\n-    /// Gets reference to the inner value, panics if it is not yet initialized\n-    #[inline(always)]\n-    pub fn borrow(&self) -> &T {\n-        self.get()\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct Lock<T>(InnerLock<T>);\n "}, {"sha": "68ce93d3db90f7ef89f2c960c56b60e67529db97", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -586,7 +586,7 @@ impl RustcDefaultCalls {\n         if let Input::File(file) = compiler.input() {\n             // FIXME: #![crate_type] and #![crate_name] support not implemented yet\n             let attrs = vec![];\n-            sess.crate_types.set(collect_crate_types(sess, &attrs));\n+            sess.init_crate_types(collect_crate_types(sess, &attrs));\n             let outputs = compiler.build_output_filenames(&sess, &attrs);\n             let rlink_data = fs::read_to_string(file).unwrap_or_else(|err| {\n                 sess.fatal(&format!(\"failed to read rlink file: {}\", err));"}, {"sha": "0a21eb8de059ced1fd38b371d0e28c89a808c415", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -396,7 +396,7 @@ pub fn print_after_parsing(\n                 annotation.pp_ann(),\n                 false,\n                 parse.edition,\n-                parse.injected_crate_name.try_get().is_some(),\n+                parse.injected_crate_name.get().is_some(),\n             )\n         })\n     } else {\n@@ -438,7 +438,7 @@ pub fn print_after_hir_lowering<'tcx>(\n                     annotation.pp_ann(),\n                     true,\n                     parse.edition,\n-                    parse.injected_crate_name.try_get().is_some(),\n+                    parse.injected_crate_name.get().is_some(),\n                 )\n             })\n         }"}, {"sha": "214701db724ecd7d0752202e50cdece42f598a10", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -7,7 +7,7 @@ use rustc_ast::mut_visit::MutVisitor;\n use rustc_ast::{self, ast, visit};\n use rustc_codegen_ssa::back::link::emit_metadata;\n use rustc_codegen_ssa::traits::CodegenBackend;\n-use rustc_data_structures::sync::{par_iter, Lrc, Once, ParallelIterator, WorkerLocal};\n+use rustc_data_structures::sync::{par_iter, Lrc, OnceCell, ParallelIterator, WorkerLocal};\n use rustc_data_structures::{box_region_allow_access, declare_box_region_type, parallel};\n use rustc_errors::{ErrorReported, PResult};\n use rustc_expand::base::ExtCtxt;\n@@ -169,10 +169,10 @@ pub fn register_plugins<'a>(\n     sess.init_features(features);\n \n     let crate_types = util::collect_crate_types(sess, &krate.attrs);\n-    sess.crate_types.set(crate_types);\n+    sess.init_crate_types(crate_types);\n \n     let disambiguator = util::compute_crate_disambiguator(sess);\n-    sess.crate_disambiguator.set(disambiguator);\n+    sess.crate_disambiguator.set(disambiguator).expect(\"not yet initialized\");\n     rustc_incremental::prepare_session_directory(sess, &crate_name, disambiguator);\n \n     if sess.opts.incremental.is_some() {\n@@ -244,7 +244,7 @@ fn configure_and_expand_inner<'a>(\n             alt_std_name,\n         );\n         if let Some(name) = name {\n-            sess.parse_sess.injected_crate_name.set(name);\n+            sess.parse_sess.injected_crate_name.set(name).expect(\"not yet initialized\");\n         }\n         krate\n     });\n@@ -288,7 +288,7 @@ fn configure_and_expand_inner<'a>(\n         let features = sess.features_untracked();\n         let cfg = rustc_expand::expand::ExpansionConfig {\n             features: Some(&features),\n-            recursion_limit: *sess.recursion_limit.get(),\n+            recursion_limit: sess.recursion_limit(),\n             trace_mac: sess.opts.debugging_opts.trace_macros,\n             should_test: sess.opts.test,\n             ..rustc_expand::expand::ExpansionConfig::default(crate_name.to_string())\n@@ -358,7 +358,7 @@ fn configure_and_expand_inner<'a>(\n         rustc_ast_passes::ast_validation::check_crate(sess, &krate, &mut resolver.lint_buffer())\n     });\n \n-    let crate_types = sess.crate_types.borrow();\n+    let crate_types = sess.crate_types();\n     let is_proc_macro_crate = crate_types.contains(&CrateType::ProcMacro);\n \n     // For backwards compatibility, we don't try to run proc macro injection\n@@ -488,7 +488,7 @@ fn generated_output_paths(\n             // If the filename has been overridden using `-o`, it will not be modified\n             // by appending `.rlib`, `.exe`, etc., so we can skip this transformation.\n             OutputType::Exe if !exact_name => {\n-                for crate_type in sess.crate_types.borrow().iter() {\n+                for crate_type in sess.crate_types().iter() {\n                     let p = filename_for_input(sess, *crate_type, crate_name, outputs);\n                     out_filenames.push(p);\n                 }\n@@ -721,7 +721,7 @@ pub fn create_global_ctxt<'tcx>(\n     mut resolver_outputs: ResolverOutputs,\n     outputs: OutputFilenames,\n     crate_name: &str,\n-    global_ctxt: &'tcx Once<GlobalCtxt<'tcx>>,\n+    global_ctxt: &'tcx OnceCell<GlobalCtxt<'tcx>>,\n     arena: &'tcx WorkerLocal<Arena<'tcx>>,\n ) -> QueryContext<'tcx> {\n     let sess = &compiler.session();\n@@ -743,7 +743,7 @@ pub fn create_global_ctxt<'tcx>(\n     }\n \n     let gcx = sess.time(\"setup_global_ctxt\", || {\n-        global_ctxt.init_locking(|| {\n+        global_ctxt.get_or_init(|| {\n             TyCtxt::create_global_ctxt(\n                 sess,\n                 lint_store,\n@@ -905,8 +905,7 @@ fn encode_and_write_metadata(\n \n     let metadata_kind = tcx\n         .sess\n-        .crate_types\n-        .borrow()\n+        .crate_types()\n         .iter()\n         .map(|ty| match *ty {\n             CrateType::Executable | CrateType::Staticlib | CrateType::Cdylib => MetadataKind::None,"}, {"sha": "283be165c192c17ddd07d197bf27d794a06936fc", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -3,7 +3,7 @@ use crate::passes::{self, BoxedResolver, QueryContext};\n \n use rustc_ast::{self, ast};\n use rustc_codegen_ssa::traits::CodegenBackend;\n-use rustc_data_structures::sync::{Lrc, Once, WorkerLocal};\n+use rustc_data_structures::sync::{Lrc, OnceCell, WorkerLocal};\n use rustc_errors::ErrorReported;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_hir::Crate;\n@@ -65,7 +65,7 @@ impl<T> Default for Query<T> {\n \n pub struct Queries<'tcx> {\n     compiler: &'tcx Compiler,\n-    gcx: Once<GlobalCtxt<'tcx>>,\n+    gcx: OnceCell<GlobalCtxt<'tcx>>,\n \n     arena: WorkerLocal<Arena<'tcx>>,\n     hir_arena: WorkerLocal<rustc_ast_lowering::Arena<'tcx>>,\n@@ -86,7 +86,7 @@ impl<'tcx> Queries<'tcx> {\n     pub fn new(compiler: &'tcx Compiler) -> Queries<'tcx> {\n         Queries {\n             compiler,\n-            gcx: Once::new(),\n+            gcx: OnceCell::new(),\n             arena: WorkerLocal::new(|_| Arena::default()),\n             hir_arena: WorkerLocal::new(|_| rustc_ast_lowering::Arena::default()),\n             dep_graph_future: Default::default(),"}, {"sha": "a15da94a21561c1d7fce50b777fd3f13a16f3467", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -406,7 +406,7 @@ pub(crate) fn compute_crate_disambiguator(session: &Session) -> CrateDisambiguat\n \n     // Also incorporate crate type, so that we don't get symbol conflicts when\n     // linking against a library of the same name, if this is an executable.\n-    let is_exe = session.crate_types.borrow().contains(&CrateType::Executable);\n+    let is_exe = session.crate_types().contains(&CrateType::Executable);\n     hasher.write(if is_exe { b\"exe\" } else { b\"lib\" });\n \n     CrateDisambiguator::from(hasher.finish::<Fingerprint>())"}, {"sha": "b0220ddd3c38efcc316ab86a27fb29705ca92aa3", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -615,7 +615,7 @@ impl<'a> CrateLoader<'a> {\n     fn inject_panic_runtime(&mut self, krate: &ast::Crate) {\n         // If we're only compiling an rlib, then there's no need to select a\n         // panic runtime, so we just skip this section entirely.\n-        let any_non_rlib = self.sess.crate_types.borrow().iter().any(|ct| *ct != CrateType::Rlib);\n+        let any_non_rlib = self.sess.crate_types().iter().any(|ct| *ct != CrateType::Rlib);\n         if !any_non_rlib {\n             info!(\"panic runtime injection skipped, only generating rlib\");\n             return;\n@@ -734,7 +734,7 @@ impl<'a> CrateLoader<'a> {\n         // At this point we've determined that we need an allocator. Let's see\n         // if our compilation session actually needs an allocator based on what\n         // we're emitting.\n-        let all_rlib = self.sess.crate_types.borrow().iter().all(|ct| match *ct {\n+        let all_rlib = self.sess.crate_types().iter().all(|ct| match *ct {\n             CrateType::Rlib => true,\n             _ => false,\n         });"}, {"sha": "aa5fafcc614b655ddcda11bd344451320861a7bc", "filename": "src/librustc_metadata/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_metadata%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_metadata%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdependency_format.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -64,8 +64,7 @@ use rustc_target::spec::PanicStrategy;\n \n crate fn calculate(tcx: TyCtxt<'_>) -> Dependencies {\n     tcx.sess\n-        .crate_types\n-        .borrow()\n+        .crate_types()\n         .iter()\n         .map(|&ty| {\n             let linkage = calculate_type(tcx, ty);"}, {"sha": "5a4862d4521833f38c12ead3abf493d8ca4c770b", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -670,7 +670,7 @@ impl<'a> CrateLocator<'a> {\n \n         // The all loop is because `--crate-type=rlib --crate-type=rlib` is\n         // legal and produces both inside this type.\n-        let is_rlib = self.sess.crate_types.borrow().iter().all(|c| *c == CrateType::Rlib);\n+        let is_rlib = self.sess.crate_types().iter().all(|c| *c == CrateType::Rlib);\n         let needs_object_code = self.sess.opts.output_types.should_codegen();\n         // If we're producing an rlib, then we don't need object code.\n         // Or, if we're not producing object code, then we don't need it either"}, {"sha": "2b292b35c159d169a77ad09306e9b7561e0a6e86", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -10,7 +10,7 @@ use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::svh::Svh;\n-use rustc_data_structures::sync::{AtomicCell, Lock, LockGuard, Lrc, Once};\n+use rustc_data_structures::sync::{AtomicCell, Lock, LockGuard, Lrc, OnceCell};\n use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n use rustc_expand::proc_macro::{AttrProcMacro, BangProcMacro, ProcMacroDerive};\n use rustc_hir as hir;\n@@ -79,7 +79,7 @@ crate struct CrateMetadata {\n     /// Proc macro descriptions for this crate, if it's a proc macro crate.\n     raw_proc_macros: Option<&'static [ProcMacro]>,\n     /// Source maps for code from the crate.\n-    source_map_import_info: Once<Vec<ImportedSourceFile>>,\n+    source_map_import_info: OnceCell<Vec<ImportedSourceFile>>,\n     /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n     alloc_decoding_state: AllocDecodingState,\n     /// The `DepNodeIndex` of the `DepNode` representing this upstream crate.\n@@ -1486,7 +1486,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             }\n         };\n \n-        self.cdata.source_map_import_info.init_locking(|| {\n+        self.cdata.source_map_import_info.get_or_init(|| {\n             let external_source_map = self.root.source_map.decode(self);\n \n             external_source_map\n@@ -1600,7 +1600,7 @@ impl CrateMetadata {\n             def_path_table,\n             trait_impls,\n             raw_proc_macros,\n-            source_map_import_info: Once::new(),\n+            source_map_import_info: OnceCell::new(),\n             alloc_decoding_state,\n             dep_node_index: AtomicCell::new(DepNodeIndex::INVALID),\n             cnum,"}, {"sha": "91fbfcc0133eba0a8e2b46f61c63458e0bee4893", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -416,7 +416,7 @@ impl<'tcx> EncodeContext<'tcx> {\n     }\n \n     fn encode_crate_root(&mut self) -> Lazy<CrateRoot<'tcx>> {\n-        let is_proc_macro = self.tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n+        let is_proc_macro = self.tcx.sess.crate_types().contains(&CrateType::ProcMacro);\n \n         let mut i = self.position();\n \n@@ -1364,7 +1364,7 @@ impl EncodeContext<'tcx> {\n     }\n \n     fn encode_proc_macros(&mut self) -> Option<Lazy<[DefIndex]>> {\n-        let is_proc_macro = self.tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n+        let is_proc_macro = self.tcx.sess.crate_types().contains(&CrateType::ProcMacro);\n         if is_proc_macro {\n             let tcx = self.tcx;\n             Some(self.lazy(tcx.hir().krate().proc_macros.iter().map(|p| p.owner.local_def_index)))"}, {"sha": "19c056925cf925b15122682a008e6b606ec0f591", "filename": "src/librustc_middle/middle/limits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_middle%2Fmiddle%2Flimits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_middle%2Fmiddle%2Flimits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Flimits.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -7,7 +7,7 @@\n \n use crate::bug;\n use rustc_ast::ast;\n-use rustc_data_structures::sync::Once;\n+use rustc_data_structures::sync::OnceCell;\n use rustc_session::Session;\n use rustc_span::symbol::{sym, Symbol};\n \n@@ -22,7 +22,7 @@ pub fn update_limits(sess: &Session, krate: &ast::Crate) {\n fn update_limit(\n     sess: &Session,\n     krate: &ast::Crate,\n-    limit: &Once<usize>,\n+    limit: &OnceCell<usize>,\n     name: Symbol,\n     default: usize,\n ) {\n@@ -34,7 +34,7 @@ fn update_limit(\n         if let Some(s) = attr.value_str() {\n             match s.as_str().parse() {\n                 Ok(n) => {\n-                    limit.set(n);\n+                    limit.set(n).unwrap();\n                     return;\n                 }\n                 Err(e) => {\n@@ -62,5 +62,5 @@ fn update_limit(\n             }\n         }\n     }\n-    limit.set(default);\n+    limit.set(default).unwrap();\n }"}, {"sha": "7508c0239397f6fe2d96d82bb2c1842511ea0f6a", "filename": "src/librustc_middle/mir/predecessors.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_middle%2Fmir%2Fpredecessors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_middle%2Fmir%2Fpredecessors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fpredecessors.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -1,7 +1,7 @@\n //! Lazily compute the reverse control-flow graph for the MIR.\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::sync::{Lock, Lrc};\n+use rustc_data_structures::sync::OnceCell;\n use rustc_index::vec::IndexVec;\n use rustc_serialize as serialize;\n use smallvec::SmallVec;\n@@ -13,37 +13,33 @@ pub type Predecessors = IndexVec<BasicBlock, SmallVec<[BasicBlock; 4]>>;\n \n #[derive(Clone, Debug)]\n pub(super) struct PredecessorCache {\n-    cache: Lock<Option<Lrc<Predecessors>>>,\n+    cache: OnceCell<Predecessors>,\n }\n \n impl PredecessorCache {\n     #[inline]\n     pub(super) fn new() -> Self {\n-        PredecessorCache { cache: Lock::new(None) }\n+        PredecessorCache { cache: OnceCell::new() }\n     }\n \n     /// Invalidates the predecessor cache.\n-    ///\n-    /// Invalidating the predecessor cache requires mutating the MIR, which in turn requires a\n-    /// unique reference (`&mut`) to the `mir::Body`. Because of this, we can assume that all\n-    /// callers of `invalidate` have a unique reference to the MIR and thus to the predecessor\n-    /// cache. This means we don't actually need to take a lock when `invalidate` is called.\n     #[inline]\n     pub(super) fn invalidate(&mut self) {\n-        *self.cache.get_mut() = None;\n+        // Invalidating the predecessor cache requires mutating the MIR, which in turn requires a\n+        // unique reference (`&mut`) to the `mir::Body`. Because of this, we can assume that all\n+        // callers of `invalidate` have a unique reference to the MIR and thus to the predecessor\n+        // cache. This means we never need to do synchronization when `invalidate` is called, we can\n+        // simply reinitialize the `OnceCell`.\n+        self.cache = OnceCell::new();\n     }\n \n-    /// Returns a ref-counted smart pointer containing the predecessor graph for this MIR.\n-    ///\n-    /// We use ref-counting instead of a mapped `LockGuard` here to ensure that the lock for\n-    /// `cache` is only held inside this function. As long as no other locks are taken while\n-    /// computing the predecessor graph, deadlock is impossible.\n+    /// Returns the the predecessor graph for this MIR.\n     #[inline]\n     pub(super) fn compute(\n         &self,\n         basic_blocks: &IndexVec<BasicBlock, BasicBlockData<'_>>,\n-    ) -> Lrc<Predecessors> {\n-        Lrc::clone(self.cache.lock().get_or_insert_with(|| {\n+    ) -> &Predecessors {\n+        self.cache.get_or_init(|| {\n             let mut preds = IndexVec::from_elem(SmallVec::new(), basic_blocks);\n             for (bb, data) in basic_blocks.iter_enumerated() {\n                 if let Some(term) = &data.terminator {\n@@ -53,8 +49,8 @@ impl PredecessorCache {\n                 }\n             }\n \n-            Lrc::new(preds)\n-        }))\n+            preds\n+        })\n     }\n }\n "}, {"sha": "68c31c68075e05f41b7db532edc19766e745c8f5", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -1380,7 +1380,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn local_crate_exports_generics(self) -> bool {\n         debug_assert!(self.sess.opts.share_generics());\n \n-        self.sess.crate_types.borrow().iter().any(|crate_type| {\n+        self.sess.crate_types().iter().any(|crate_type| {\n             match crate_type {\n                 CrateType::Executable\n                 | CrateType::Staticlib"}, {"sha": "5566e187c0c5cb62820de90eb16d4ef43551e600", "filename": "src/librustc_middle/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_middle%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_middle%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flayout.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -187,7 +187,7 @@ fn layout_raw<'tcx>(\n     query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n ) -> Result<&'tcx Layout, LayoutError<'tcx>> {\n     ty::tls::with_related_context(tcx, move |icx| {\n-        let rec_limit = *tcx.sess.recursion_limit.get();\n+        let rec_limit = tcx.sess.recursion_limit.get().copied().unwrap();\n         let (param_env, ty) = query.into_parts();\n \n         if icx.layout_depth > rec_limit {"}, {"sha": "4eae06742d9d35363363c7d9f0dc726f08d026d9", "filename": "src/librustc_middle/ty/query/on_disk_cache.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -6,7 +6,7 @@ use crate::ty::context::TyCtxt;\n use crate::ty::{self, Ty};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::{HashMapExt, Lock, Lrc, Once};\n+use rustc_data_structures::sync::{HashMapExt, Lock, Lrc, OnceCell};\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, LOCAL_CRATE};\n@@ -49,7 +49,7 @@ pub struct OnDiskCache<'sess> {\n     current_diagnostics: Lock<FxHashMap<DepNodeIndex, Vec<Diagnostic>>>,\n \n     prev_cnums: Vec<(u32, String, CrateDisambiguator)>,\n-    cnum_map: Once<IndexVec<CrateNum, Option<CrateNum>>>,\n+    cnum_map: OnceCell<IndexVec<CrateNum, Option<CrateNum>>>,\n \n     source_map: &'sess SourceMap,\n     file_index_to_stable_id: FxHashMap<SourceFileIndex, StableSourceFileId>,\n@@ -128,7 +128,7 @@ impl<'sess> OnDiskCache<'sess> {\n             file_index_to_stable_id: footer.file_index_to_stable_id,\n             file_index_to_file: Default::default(),\n             prev_cnums: footer.prev_cnums,\n-            cnum_map: Once::new(),\n+            cnum_map: OnceCell::new(),\n             source_map: sess.source_map(),\n             current_diagnostics: Default::default(),\n             query_result_index: footer.query_result_index.into_iter().collect(),\n@@ -144,7 +144,7 @@ impl<'sess> OnDiskCache<'sess> {\n             file_index_to_stable_id: Default::default(),\n             file_index_to_file: Default::default(),\n             prev_cnums: vec![],\n-            cnum_map: Once::new(),\n+            cnum_map: OnceCell::new(),\n             source_map,\n             current_diagnostics: Default::default(),\n             query_result_index: Default::default(),\n@@ -370,14 +370,14 @@ impl<'sess> OnDiskCache<'sess> {\n     {\n         let pos = index.get(&dep_node_index).cloned()?;\n \n-        // Initialize `cnum_map` using the value from the thread that finishes the closure first.\n-        self.cnum_map.init_nonlocking_same(|| Self::compute_cnum_map(tcx, &self.prev_cnums[..]));\n+        let cnum_map =\n+            self.cnum_map.get_or_init(|| Self::compute_cnum_map(tcx, &self.prev_cnums[..]));\n \n         let mut decoder = CacheDecoder {\n             tcx,\n             opaque: opaque::Decoder::new(&self.serialized_data[..], pos.to_usize()),\n             source_map: self.source_map,\n-            cnum_map: self.cnum_map.get(),\n+            cnum_map,\n             synthetic_syntax_contexts: &self.synthetic_syntax_contexts,\n             file_index_to_file: &self.file_index_to_file,\n             file_index_to_stable_id: &self.file_index_to_stable_id,"}, {"sha": "fd5e0632a2c103906c11646c2a7f0cd696c07258", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -89,7 +89,7 @@ pub(super) fn mk_eval_cx<'mir, 'tcx>(\n     InterpCx::new(\n         tcx.at(span),\n         param_env,\n-        CompileTimeInterpreter::new(*tcx.sess.const_eval_limit.get()),\n+        CompileTimeInterpreter::new(tcx.sess.const_eval_limit()),\n         MemoryExtra { can_access_statics },\n     )\n }\n@@ -303,7 +303,7 @@ pub fn const_eval_raw_provider<'tcx>(\n     let mut ecx = InterpCx::new(\n         tcx.at(span),\n         key.param_env,\n-        CompileTimeInterpreter::new(*tcx.sess.const_eval_limit.get()),\n+        CompileTimeInterpreter::new(tcx.sess.const_eval_limit()),\n         MemoryExtra { can_access_statics: is_static },\n     );\n "}, {"sha": "4f91257e2ef83717492970abad8e4c5371ac360b", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -651,7 +651,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         M::after_stack_push(self)?;\n         info!(\"ENTERING({}) {}\", self.frame_idx(), self.frame().instance);\n \n-        if self.stack().len() > *self.tcx.sess.recursion_limit.get() {\n+        if self.stack().len() > self.tcx.sess.recursion_limit() {\n             throw_exhaust!(StackFrameLimitReached)\n         } else {\n             Ok(())"}, {"sha": "081f6435d9db9010e1a107db01b5bb59de458430", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -430,7 +430,7 @@ fn check_recursion_limit<'tcx>(\n     // Code that needs to instantiate the same function recursively\n     // more than the recursion limit is assumed to be causing an\n     // infinite expansion.\n-    if adjusted_recursion_depth > *tcx.sess.recursion_limit.get() {\n+    if adjusted_recursion_depth > tcx.sess.recursion_limit() {\n         let error = format!(\"reached the recursion limit while instantiating `{}`\", instance);\n         if let Some(def_id) = def_id.as_local() {\n             let hir_id = tcx.hir().as_local_hir_id(def_id);\n@@ -463,8 +463,7 @@ fn check_type_length_limit<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) {\n     // which means that rustc basically hangs.\n     //\n     // Bail out in these cases to avoid that bad user experience.\n-    let type_length_limit = *tcx.sess.type_length_limit.get();\n-    if type_length > type_length_limit {\n+    if type_length > tcx.sess.type_length_limit() {\n         // The instance name is already known to be too long for rustc.\n         // Show only the first and last 32 characters to avoid blasting\n         // the user's terminal with thousands of lines of type-name."}, {"sha": "e0ad0ac77476f05216e7204c3f733ef72db9d3df", "filename": "src/librustc_passes/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_passes%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_passes%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fentry.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -51,7 +51,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n fn entry_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<(LocalDefId, EntryFnType)> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n-    let any_exe = tcx.sess.crate_types.borrow().iter().any(|ty| *ty == CrateType::Executable);\n+    let any_exe = tcx.sess.crate_types().iter().any(|ty| *ty == CrateType::Executable);\n     if !any_exe {\n         // No need to find a main function.\n         return None;"}, {"sha": "cac71b3836c54fa2b51226ba210b92fd85385ed4", "filename": "src/librustc_passes/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_passes%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_passes%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Freachable.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -376,7 +376,7 @@ fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> &'tcx HirIdSet\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n     let any_library =\n-        tcx.sess.crate_types.borrow().iter().any(|ty| {\n+        tcx.sess.crate_types().iter().any(|ty| {\n             *ty == CrateType::Rlib || *ty == CrateType::Dylib || *ty == CrateType::ProcMacro\n         });\n     let mut reachable_context = ReachableContext {"}, {"sha": "96ec23692df512dc799b0c5d700b102f91f17d26", "filename": "src/librustc_passes/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_passes%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_passes%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fweak_lang_items.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -37,7 +37,7 @@ pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>, items: &mut lang_items::LanguageItem\n fn verify<'tcx>(tcx: TyCtxt<'tcx>, items: &lang_items::LanguageItems) {\n     // We only need to check for the presence of weak lang items if we're\n     // emitting something that's not an rlib.\n-    let needs_check = tcx.sess.crate_types.borrow().iter().any(|kind| match *kind {\n+    let needs_check = tcx.sess.crate_types().iter().any(|kind| match *kind {\n         CrateType::Dylib\n         | CrateType::ProcMacro\n         | CrateType::Cdylib"}, {"sha": "3bd68a9c656ce2b18711c6b002d2ffe3a805c479", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -87,7 +87,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n     pub fn compilation_output(&self, crate_name: &str) -> PathBuf {\n         let sess = &self.tcx.sess;\n         // Save-analysis is emitted per whole session, not per each crate type\n-        let crate_type = sess.crate_types.borrow()[0];\n+        let crate_type = sess.crate_types()[0];\n         let outputs = &*self.tcx.output_filenames(LOCAL_CRATE);\n \n         if outputs.outputs.contains_key(&OutputType::Metadata) {\n@@ -987,8 +987,7 @@ impl<'a> DumpHandler<'a> {\n                     error!(\"Could not create directory {}: {}\", root_path.display(), e);\n                 }\n \n-                let executable =\n-                    sess.crate_types.borrow().iter().any(|ct| *ct == CrateType::Executable);\n+                let executable = sess.crate_types().iter().any(|ct| *ct == CrateType::Executable);\n                 let mut out_name = if executable { String::new() } else { \"lib\".to_owned() };\n                 out_name.push_str(&self.cratename);\n                 out_name.push_str(&sess.opts.cg.extra_filename);"}, {"sha": "746e3536ce90831bbf95b19532550283b878b65e", "filename": "src/librustc_session/parse.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_session%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_session%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fparse.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -4,7 +4,7 @@\n use crate::lint::{BufferedEarlyLint, BuiltinLintDiagnostics, Lint, LintId};\n use rustc_ast::node_id::NodeId;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::sync::{Lock, Lrc, Once};\n+use rustc_data_structures::sync::{Lock, Lrc, OnceCell};\n use rustc_errors::{emitter::SilentEmitter, ColorConfig, Handler};\n use rustc_errors::{error_code, Applicability, DiagnosticBuilder};\n use rustc_feature::{find_feature_issue, GateIssue, UnstableFeatures};\n@@ -130,7 +130,7 @@ pub struct ParseSess {\n     /// operation token that followed it, but that the parser cannot identify without further\n     /// analysis.\n     pub ambiguous_block_expr_parse: Lock<FxHashMap<Span, Span>>,\n-    pub injected_crate_name: Once<Symbol>,\n+    pub injected_crate_name: OnceCell<Symbol>,\n     pub gated_spans: GatedSpans,\n     pub symbol_gallery: SymbolGallery,\n     /// The parser has reached `Eof` due to an unclosed brace. Used to silence unnecessary errors.\n@@ -156,7 +156,7 @@ impl ParseSess {\n             source_map,\n             buffered_lints: Lock::new(vec![]),\n             ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),\n-            injected_crate_name: Once::new(),\n+            injected_crate_name: OnceCell::new(),\n             gated_spans: GatedSpans::default(),\n             symbol_gallery: SymbolGallery::default(),\n             reached_eof: Lock::new(false),"}, {"sha": "f2f02cb649463c25a09e0c35d75e7fb4a2ca6eb1", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 39, "deletions": 16, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -13,7 +13,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::jobserver::{self, Client};\n use rustc_data_structures::profiling::{duration_to_secs_str, SelfProfiler, SelfProfilerRef};\n use rustc_data_structures::sync::{\n-    self, AtomicU64, AtomicUsize, Lock, Lrc, Once, OneThread, Ordering, Ordering::SeqCst,\n+    self, AtomicU64, AtomicUsize, Lock, Lrc, OnceCell, OneThread, Ordering, Ordering::SeqCst,\n };\n use rustc_errors::annotate_snippet_emitter_writer::AnnotateSnippetEmitterWriter;\n use rustc_errors::emitter::{Emitter, EmitterWriter, HumanReadableErrorType};\n@@ -77,25 +77,25 @@ pub struct Session {\n     /// (sub)diagnostics that have been set once, but should not be set again,\n     /// in order to avoid redundantly verbose output (Issue #24690, #44953).\n     pub one_time_diagnostics: Lock<FxHashSet<(DiagnosticMessageId, Option<Span>, String)>>,\n-    pub crate_types: Once<Vec<CrateType>>,\n+    crate_types: OnceCell<Vec<CrateType>>,\n     /// The `crate_disambiguator` is constructed out of all the `-C metadata`\n     /// arguments passed to the compiler. Its value together with the crate-name\n     /// forms a unique global identifier for the crate. It is used to allow\n     /// multiple crates with the same name to coexist. See the\n     /// `rustc_codegen_llvm::back::symbol_names` module for more information.\n-    pub crate_disambiguator: Once<CrateDisambiguator>,\n+    pub crate_disambiguator: OnceCell<CrateDisambiguator>,\n \n-    features: Once<rustc_feature::Features>,\n+    features: OnceCell<rustc_feature::Features>,\n \n     /// The maximum recursion limit for potentially infinitely recursive\n     /// operations such as auto-dereference and monomorphization.\n-    pub recursion_limit: Once<usize>,\n+    pub recursion_limit: OnceCell<usize>,\n \n     /// The maximum length of types during monomorphization.\n-    pub type_length_limit: Once<usize>,\n+    pub type_length_limit: OnceCell<usize>,\n \n     /// The maximum blocks a const expression can evaluate.\n-    pub const_eval_limit: Once<usize>,\n+    pub const_eval_limit: OnceCell<usize>,\n \n     incr_comp_session: OneThread<RefCell<IncrCompSession>>,\n     /// Used for incremental compilation tests. Will only be populated if\n@@ -244,7 +244,27 @@ impl Session {\n     }\n \n     pub fn local_crate_disambiguator(&self) -> CrateDisambiguator {\n-        *self.crate_disambiguator.get()\n+        self.crate_disambiguator.get().copied().unwrap()\n+    }\n+\n+    pub fn crate_types(&self) -> &[CrateType] {\n+        self.crate_types.get().unwrap().as_slice()\n+    }\n+\n+    pub fn init_crate_types(&self, crate_types: Vec<CrateType>) {\n+        self.crate_types.set(crate_types).expect(\"`crate_types` was initialized twice\")\n+    }\n+\n+    pub fn recursion_limit(&self) -> usize {\n+        self.recursion_limit.get().copied().unwrap()\n+    }\n+\n+    pub fn type_length_limit(&self) -> usize {\n+        self.type_length_limit.get().copied().unwrap()\n+    }\n+\n+    pub fn const_eval_limit(&self) -> usize {\n+        self.const_eval_limit.get().copied().unwrap()\n     }\n \n     pub fn struct_span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> DiagnosticBuilder<'_> {\n@@ -500,11 +520,14 @@ impl Session {\n     /// dependency tracking. Use tcx.features() instead.\n     #[inline]\n     pub fn features_untracked(&self) -> &rustc_feature::Features {\n-        self.features.get()\n+        self.features.get().unwrap()\n     }\n \n     pub fn init_features(&self, features: rustc_feature::Features) {\n-        self.features.set(features);\n+        match self.features.set(features) {\n+            Ok(()) => {}\n+            Err(_) => panic!(\"`features` was initialized twice\"),\n+        }\n     }\n \n     /// Calculates the flavor of LTO to use for this compilation.\n@@ -1208,12 +1231,12 @@ pub fn build_session_with_source_map(\n         local_crate_source_file,\n         working_dir,\n         one_time_diagnostics: Default::default(),\n-        crate_types: Once::new(),\n-        crate_disambiguator: Once::new(),\n-        features: Once::new(),\n-        recursion_limit: Once::new(),\n-        type_length_limit: Once::new(),\n-        const_eval_limit: Once::new(),\n+        crate_types: OnceCell::new(),\n+        crate_disambiguator: OnceCell::new(),\n+        features: OnceCell::new(),\n+        recursion_limit: OnceCell::new(),\n+        type_length_limit: OnceCell::new(),\n+        const_eval_limit: OnceCell::new(),\n         incr_comp_session: OneThread::new(RefCell::new(IncrCompSession::NotInitialized)),\n         cgu_reuse_tracker,\n         prof,"}, {"sha": "50a59469d85301ad8fb49b814341e4ebd2a04ecf", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -1875,7 +1875,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     }\n \n     fn suggest_new_overflow_limit(&self, err: &mut DiagnosticBuilder<'_>) {\n-        let current_limit = self.tcx.sess.recursion_limit.get();\n+        let current_limit = self.tcx.sess.recursion_limit();\n         let suggested_limit = current_limit * 2;\n         err.help(&format!(\n             \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate (`{}`)\","}, {"sha": "914485fd408fcf4777c4eb006c6afa1d94d2b19b", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -332,7 +332,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                     Reveal::UserFacing => ty,\n \n                     Reveal::All => {\n-                        let recursion_limit = *self.tcx().sess.recursion_limit.get();\n+                        let recursion_limit = self.tcx().sess.recursion_limit();\n                         if self.depth >= recursion_limit {\n                             let obligation = Obligation::with_depth(\n                                 self.cause.clone(),\n@@ -520,7 +520,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             );\n \n             // But for now, let's classify this as an overflow:\n-            let recursion_limit = *selcx.tcx().sess.recursion_limit.get();\n+            let recursion_limit = selcx.tcx().sess.recursion_limit();\n             let obligation =\n                 Obligation::with_depth(cause, recursion_limit, param_env, projection_ty);\n             selcx.infcx().report_overflow_error(&obligation, false);\n@@ -814,7 +814,7 @@ fn project_type<'cx, 'tcx>(\n ) -> Result<ProjectedTy<'tcx>, ProjectionTyError<'tcx>> {\n     debug!(\"project(obligation={:?})\", obligation);\n \n-    let recursion_limit = *selcx.tcx().sess.recursion_limit.get();\n+    let recursion_limit = selcx.tcx().sess.recursion_limit();\n     if obligation.recursion_depth >= recursion_limit {\n         debug!(\"project: overflow!\");\n         return Err(ProjectionTyError::TraitSelectionError(SelectionError::Overflow));"}, {"sha": "008ca8d526dd3f3f6a514dbd143c0479eafc3357", "filename": "src/librustc_trait_selection/traits/query/normalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fnormalize.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -108,7 +108,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                     Reveal::UserFacing => ty,\n \n                     Reveal::All => {\n-                        let recursion_limit = *self.tcx().sess.recursion_limit.get();\n+                        let recursion_limit = self.tcx().sess.recursion_limit();\n                         if self.anon_depth >= recursion_limit {\n                             let obligation = Obligation::with_depth(\n                                 self.cause.clone(),"}, {"sha": "b402aba65cdb70136b8c530e27ec2d4c0f8722ed", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -919,8 +919,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &Obligation<'tcx, T>,\n         error_obligation: &Obligation<'tcx, V>,\n     ) -> Result<(), OverflowError> {\n-        let recursion_limit = *self.infcx.tcx.sess.recursion_limit.get();\n-        if obligation.recursion_depth >= recursion_limit {\n+        if obligation.recursion_depth >= self.infcx.tcx.sess.recursion_limit() {\n             match self.query_mode {\n                 TraitQueryMode::Standard => {\n                     self.infcx().report_overflow_error(error_obligation, true);"}, {"sha": "fb9c0d7f99013a841ee03e6f953d1d9a44982a74", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -163,7 +163,7 @@ fn dtorck_constraint_for_ty<'tcx>(\n ) -> Result<(), NoSolution> {\n     debug!(\"dtorck_constraint_for_ty({:?}, {:?}, {:?}, {:?})\", span, for_ty, depth, ty);\n \n-    if depth >= *tcx.sess.recursion_limit.get() {\n+    if depth >= tcx.sess.recursion_limit() {\n         constraints.overflows.push(ty);\n         return Ok(());\n     }"}, {"sha": "e94a47f079a638165610c101db40e627719a73c2", "filename": "src/librustc_ty/needs_drop.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_ty%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_ty%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fneeds_drop.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -43,14 +43,13 @@ impl<'tcx, F> NeedsDropTypes<'tcx, F> {\n     ) -> Self {\n         let mut seen_tys = FxHashSet::default();\n         seen_tys.insert(ty);\n-        let recursion_limit = *tcx.sess.recursion_limit.get();\n         Self {\n             tcx,\n             param_env,\n             seen_tys,\n             query_ty: ty,\n             unchecked_tys: vec![(ty, 0)],\n-            recursion_limit,\n+            recursion_limit: tcx.sess.recursion_limit(),\n             adt_components,\n         }\n     }"}, {"sha": "d4c01a82e0aa5217f8596cfd4bcca925b7b1489b", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -48,7 +48,7 @@ impl<'a, 'tcx> Iterator for Autoderef<'a, 'tcx> {\n             return Some((self.cur_ty, 0));\n         }\n \n-        if self.steps.len() >= *tcx.sess.recursion_limit.get() {\n+        if self.steps.len() >= tcx.sess.recursion_limit() {\n             if !self.silence_errors {\n                 report_autoderef_recursion_limit_error(tcx, self.span, self.cur_ty);\n             }\n@@ -236,7 +236,7 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n \n pub fn report_autoderef_recursion_limit_error<'tcx>(tcx: TyCtxt<'tcx>, span: Span, ty: Ty<'tcx>) {\n     // We've reached the recursion limit, error gracefully.\n-    let suggested_limit = *tcx.sess.recursion_limit.get() * 2;\n+    let suggested_limit = tcx.sess.recursion_limit() * 2;\n     let msg = format!(\"reached the recursion limit while auto-dereferencing `{:?}`\", ty);\n     let error_id = (DiagnosticMessageId::ErrorId(55), Some(span), msg);\n     let fresh = tcx.sess.one_time_diagnostics.borrow_mut().insert(error_id);"}, {"sha": "3ad3d5aee4d4a9a075bb3b1c23fcef58124f3ab6", "filename": "src/tools/clippy/clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -71,7 +71,7 @@ fn check_missing_inline_attrs(cx: &LateContext<'_, '_>, attrs: &[ast::Attribute]\n fn is_executable(cx: &LateContext<'_, '_>) -> bool {\n     use rustc_session::config::CrateType;\n \n-    cx.tcx.sess.crate_types.get().iter().any(|t: &CrateType| match t {\n+    cx.tcx.sess.crate_types().iter().any(|t: &CrateType| match t {\n         CrateType::Executable => true,\n         _ => false,\n     })"}, {"sha": "61389028cc78c1d519f23e7d662b17640a952760", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f940ef5d91b53e889f111f27e00849f2f5ae4a2/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=7f940ef5d91b53e889f111f27e00849f2f5ae4a2", "patch": "@@ -128,6 +128,7 @@ const WHITELIST: &[&str] = &[\n     \"miniz_oxide\",\n     \"nodrop\",\n     \"num_cpus\",\n+    \"once_cell\",\n     \"opaque-debug\",\n     \"parking_lot\",\n     \"parking_lot_core\","}]}