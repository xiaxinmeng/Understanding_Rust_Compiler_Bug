{"sha": "163445ac80225090c81e7ff1b185fb5dca52e3b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2MzQ0NWFjODAyMjUwOTBjODFlN2ZmMWIxODVmYjVkY2E1MmUzYjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-16T00:44:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-16T00:44:57Z"}, "message": "Auto merge of #72251 - Dylan-DPC:rollup-4mik3o7, r=Dylan-DPC\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #71662 (Implement FromStr for OsString)\n - #71677 (Add explicit references to the BuildHasher trait)\n - #71724 (Doc alias improvements)\n - #71948 (Suggest to await future before ? operator)\n - #72090 (rustc_driver: factor out computing the exit code)\n - #72206 (Cleanup stale 'FIXME(#64197)')\n - #72218 (make sure even unleashed miri does not do pointer stuff)\n - #72220 ([const-prop] Don't replace Rvalues that are already constants)\n - #72224 (doc: add links to rotate_(left|right))\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "2b4e970433a44f7b014097600a3d2ed087475a79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b4e970433a44f7b014097600a3d2ed087475a79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/163445ac80225090c81e7ff1b185fb5dca52e3b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/163445ac80225090c81e7ff1b185fb5dca52e3b2", "html_url": "https://github.com/rust-lang/rust/commit/163445ac80225090c81e7ff1b185fb5dca52e3b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/163445ac80225090c81e7ff1b185fb5dca52e3b2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed084b0b8341c974769a0328f61851b0e1fc17fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed084b0b8341c974769a0328f61851b0e1fc17fa", "html_url": "https://github.com/rust-lang/rust/commit/ed084b0b8341c974769a0328f61851b0e1fc17fa"}, {"sha": "a27b1b68edae0662190e9bd546b9a22ffabfb48b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a27b1b68edae0662190e9bd546b9a22ffabfb48b", "html_url": "https://github.com/rust-lang/rust/commit/a27b1b68edae0662190e9bd546b9a22ffabfb48b"}], "stats": {"total": 1156, "additions": 946, "deletions": 210}, "files": [{"sha": "9e1971c9a945b27fff7408e984ad05a1ebb65653", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -1499,8 +1499,8 @@ any high-order bits of `rhs` that would cause the shift to exceed the bitwidth o\n \n Note that this is *not* the same as a rotate-left; the RHS of a wrapping shift-left is restricted to\n the range of the type, rather than the bits shifted out of the LHS being returned to the other end.\n-The primitive integer types all implement a `rotate_left` function, which may be what you want\n-instead.\n+The primitive integer types all implement a `[`rotate_left`](#method.rotate_left) function,\n+which may be what you want instead.\n \n # Examples\n \n@@ -1531,8 +1531,8 @@ removes any high-order bits of `rhs` that would cause the shift to exceed the bi\n \n Note that this is *not* the same as a rotate-right; the RHS of a wrapping shift-right is restricted\n to the range of the type, rather than the bits shifted out of the LHS being returned to the other\n-end. The primitive integer types all implement a `rotate_right` function, which may be what you want\n-instead.\n+end. The primitive integer types all implement a [`rotate_right`](#method.rotate_right) function,\n+which may be what you want instead.\n \n # Examples\n \n@@ -3610,8 +3610,8 @@ Note that this is *not* the same as a rotate-left; the\n RHS of a wrapping shift-left is restricted to the range\n of the type, rather than the bits shifted out of the LHS\n being returned to the other end. The primitive integer\n-types all implement a `rotate_left` function, which may\n-be what you want instead.\n+types all implement a [`rotate_left`](#method.rotate_left) function,\n+which may be what you want instead.\n \n # Examples\n \n@@ -3644,8 +3644,8 @@ Note that this is *not* the same as a rotate-right; the\n RHS of a wrapping shift-right is restricted to the range\n of the type, rather than the bits shifted out of the LHS\n being returned to the other end. The primitive integer\n-types all implement a `rotate_right` function, which may\n-be what you want instead.\n+types all implement a [`rotate_right`](#method.rotate_right) function,\n+which may be what you want instead.\n \n # Examples\n "}, {"sha": "6847b175e60ebdb4b779a249fe8dfd933e5375d6", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -1138,6 +1138,16 @@ pub fn catch_fatal_errors<F: FnOnce() -> R, R>(f: F) -> Result<R, ErrorReported>\n     })\n }\n \n+/// Variant of `catch_fatal_errors` for the `interface::Result` return type\n+/// that also computes the exit code.\n+pub fn catch_with_exit_code(f: impl FnOnce() -> interface::Result<()>) -> i32 {\n+    let result = catch_fatal_errors(f).and_then(|result| result);\n+    match result {\n+        Ok(()) => EXIT_SUCCESS,\n+        Err(_) => EXIT_FAILURE,\n+    }\n+}\n+\n lazy_static! {\n     static ref DEFAULT_HOOK: Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static> = {\n         let hook = panic::take_hook();\n@@ -1228,12 +1238,12 @@ pub fn init_rustc_env_logger() {\n     env_logger::init_from_env(\"RUSTC_LOG\");\n }\n \n-pub fn main() {\n+pub fn main() -> ! {\n     let start = Instant::now();\n     init_rustc_env_logger();\n     let mut callbacks = TimePassesCallbacks::default();\n     install_ice_hook();\n-    let result = catch_fatal_errors(|| {\n+    let exit_code = catch_with_exit_code(|| {\n         let args = env::args_os()\n             .enumerate()\n             .map(|(i, arg)| {\n@@ -1246,13 +1256,8 @@ pub fn main() {\n             })\n             .collect::<Vec<_>>();\n         run_compiler(&args, &mut callbacks, None, None)\n-    })\n-    .and_then(|result| result);\n-    let exit_code = match result {\n-        Ok(_) => EXIT_SUCCESS,\n-        Err(_) => EXIT_FAILURE,\n-    };\n+    });\n     // The extra `\\t` is necessary to align this label with the others.\n     print_time_passes_entry(callbacks.time_passes, \"\\ttotal\", start.elapsed());\n-    process::exit(exit_code);\n+    process::exit(exit_code)\n }"}, {"sha": "2932475430bbfead59547288a7f175200508a777", "filename": "src/librustc_expand/parse/lexer/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustc_expand%2Fparse%2Flexer%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustc_expand%2Fparse%2Flexer%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fparse%2Flexer%2Ftests.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -50,13 +50,13 @@ fn t1() {\n         assert_eq!(string_reader.next_token(), token::Whitespace);\n         // Read another token.\n         let tok3 = string_reader.next_token();\n-        assert_eq!(string_reader.pos.clone(), BytePos(28));\n+        assert_eq!(string_reader.pos(), BytePos(28));\n         let tok4 = Token::new(mk_ident(\"main\"), Span::with_root_ctxt(BytePos(24), BytePos(28)));\n         assert_eq!(tok3.kind, tok4.kind);\n         assert_eq!(tok3.span, tok4.span);\n \n         assert_eq!(string_reader.next_token(), token::OpenDelim(token::Paren));\n-        assert_eq!(string_reader.pos.clone(), BytePos(29))\n+        assert_eq!(string_reader.pos(), BytePos(29))\n     })\n }\n "}, {"sha": "b823516d64f3b76df30f9048204d0d02a7c5ac88", "filename": "src/librustc_middle/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -390,11 +390,7 @@ impl<'hir> Map<'hir> {\n     /// Given a `HirId`, returns the `BodyId` associated with it,\n     /// if the node is a body owner, otherwise returns `None`.\n     pub fn maybe_body_owned_by(&self, hir_id: HirId) -> Option<BodyId> {\n-        if let Some(node) = self.find(hir_id) {\n-            associated_body(node)\n-        } else {\n-            bug!(\"no entry for id `{}`\", hir_id)\n-        }\n+        self.find(hir_id).map(associated_body).flatten()\n     }\n \n     /// Given a body owner's id, returns the `BodyId` associated with it."}, {"sha": "13cf9a934b72c78bdf3125d312a8e1f96c664e2f", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -1164,6 +1164,12 @@ rustc_queries! {\n             desc { \"evaluating trait selection obligation `{}`\", goal.value }\n         }\n \n+        query type_implements_trait(\n+            key: (DefId, Ty<'tcx>, SubstsRef<'tcx>, ty::ParamEnv<'tcx>, )\n+        ) -> bool {\n+            desc { \"evaluating `type_implements_trait` `{:?}`\", key }\n+        }\n+\n         /// Do not call this query directly: part of the `Eq` type-op\n         query type_op_ascribe_user_type(\n             goal: CanonicalTypeOpAscribeUserTypeGoal<'tcx>"}, {"sha": "4acf766f033d8360daa4af60d4d9b292bcd91080", "filename": "src/librustc_middle/ty/query/keys.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustc_middle%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustc_middle%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fkeys.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -295,3 +295,15 @@ impl Key for (Symbol, u32, u32) {\n         DUMMY_SP\n     }\n }\n+\n+impl<'tcx> Key for (DefId, Ty<'tcx>, SubstsRef<'tcx>, ty::ParamEnv<'tcx>) {\n+    type CacheSelector = DefaultCacheSelector;\n+\n+    fn query_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+\n+    fn default_span(&self, _tcx: TyCtxt<'_>) -> Span {\n+        DUMMY_SP\n+    }\n+}"}, {"sha": "bdf2193c6af45692399e7878bf732b76c6607c3b", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -616,6 +616,13 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         value: OpTy<'tcx>,\n         source_info: SourceInfo,\n     ) {\n+        if let Rvalue::Use(Operand::Constant(c)) = rval {\n+            if !matches!(c.literal.val, ConstKind::Unevaluated(..)) {\n+                trace!(\"skipping replace of Rvalue::Use({:?} because it is already a const\", c);\n+                return;\n+            }\n+        }\n+\n         trace!(\"attepting to replace {:?} with {:?}\", rval, value);\n         if let Err(e) = self.ecx.const_validate_operand(\n             value,"}, {"sha": "aa048d682c2da19ecf2066adde9bc93792f412ea", "filename": "src/librustc_parse/lexer/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Fmod.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -31,8 +31,7 @@ pub struct StringReader<'a> {\n     /// Initial position, read-only.\n     start_pos: BytePos,\n     /// The absolute offset within the source_map of the current character.\n-    // FIXME(#64197): `pub` is needed by tests for now.\n-    pub pos: BytePos,\n+    pos: BytePos,\n     /// Stop reading src at this index.\n     end_src_index: usize,\n     /// Source text to tokenize.\n@@ -436,6 +435,10 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n+    pub fn pos(&self) -> BytePos {\n+        self.pos\n+    }\n+\n     #[inline]\n     fn src_index(&self, pos: BytePos) -> usize {\n         (pos - self.start_pos).to_usize()"}, {"sha": "6bd4455e1e3fdbeb0c8a80a237d9eca59215e31a", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -402,6 +402,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         self.suggest_remove_reference(&obligation, &mut err, &trait_ref);\n                         self.suggest_semicolon_removal(&obligation, &mut err, span, &trait_ref);\n                         self.note_version_mismatch(&mut err, &trait_ref);\n+                        self.suggest_await_before_try(&mut err, &obligation, &trait_ref, span);\n                         if self.suggest_impl_trait(&mut err, span, &obligation, &trait_ref) {\n                             err.emit();\n                             return;"}, {"sha": "503daf56b49e461773e7cdccd751a6653b308373", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -1,14 +1,17 @@\n use super::{\n     EvaluationResult, Obligation, ObligationCause, ObligationCauseCode, PredicateObligation,\n+    SelectionContext,\n };\n \n use crate::infer::InferCtxt;\n+use crate::traits::normalize_projection_type;\n \n use rustc_errors::{error_code, struct_span_err, Applicability, DiagnosticBuilder, Style};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n+use rustc_hir::lang_items;\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Node};\n use rustc_middle::ty::TypeckTables;\n use rustc_middle::ty::{\n@@ -150,6 +153,15 @@ pub trait InferCtxtExt<'tcx> {\n         T: fmt::Display;\n \n     fn suggest_new_overflow_limit(&self, err: &mut DiagnosticBuilder<'_>);\n+\n+    /// Suggest to await before try: future? => future.await?\n+    fn suggest_await_before_try(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        span: Span,\n+    );\n }\n \n fn predicate_constraint(generics: &hir::Generics<'_>, pred: String) -> (Span, String) {\n@@ -1822,6 +1834,95 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             suggested_limit, self.tcx.crate_name,\n         ));\n     }\n+\n+    fn suggest_await_before_try(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        span: Span,\n+    ) {\n+        debug!(\n+            \"suggest_await_befor_try: obligation={:?}, span={:?}, trait_ref={:?}, trait_ref_self_ty={:?}\",\n+            obligation,\n+            span,\n+            trait_ref,\n+            trait_ref.self_ty()\n+        );\n+        let body_hir_id = obligation.cause.body_id;\n+        let item_id = self.tcx.hir().get_parent_node(body_hir_id);\n+\n+        if let Some(body_id) = self.tcx.hir().maybe_body_owned_by(item_id) {\n+            let body = self.tcx.hir().body(body_id);\n+            if let Some(hir::GeneratorKind::Async(_)) = body.generator_kind {\n+                let future_trait =\n+                    self.tcx.require_lang_item(lang_items::FutureTraitLangItem, None);\n+\n+                let self_ty = self.resolve_vars_if_possible(&trait_ref.self_ty());\n+\n+                let impls_future = self.tcx.type_implements_trait((\n+                    future_trait,\n+                    self_ty,\n+                    ty::List::empty(),\n+                    obligation.param_env,\n+                ));\n+\n+                let item_def_id = self\n+                    .tcx\n+                    .associated_items(future_trait)\n+                    .in_definition_order()\n+                    .next()\n+                    .unwrap()\n+                    .def_id;\n+                // `<T as Future>::Output`\n+                let projection_ty = ty::ProjectionTy {\n+                    // `T`\n+                    substs: self.tcx.mk_substs_trait(\n+                        trait_ref.self_ty(),\n+                        self.fresh_substs_for_item(span, item_def_id),\n+                    ),\n+                    // `Future::Output`\n+                    item_def_id,\n+                };\n+\n+                let mut selcx = SelectionContext::new(self);\n+\n+                let mut obligations = vec![];\n+                let normalized_ty = normalize_projection_type(\n+                    &mut selcx,\n+                    obligation.param_env,\n+                    projection_ty,\n+                    obligation.cause.clone(),\n+                    0,\n+                    &mut obligations,\n+                );\n+\n+                debug!(\n+                    \"suggest_await_befor_try: normalized_projection_type {:?}\",\n+                    self.resolve_vars_if_possible(&normalized_ty)\n+                );\n+                let try_obligation = self.mk_obligation_for_def_id(\n+                    trait_ref.def_id(),\n+                    normalized_ty,\n+                    obligation.cause.clone(),\n+                    obligation.param_env,\n+                );\n+                debug!(\"suggest_await_befor_try: try_trait_obligation {:?}\", try_obligation);\n+                if self.predicate_may_hold(&try_obligation) && impls_future {\n+                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                        if snippet.ends_with('?') {\n+                            err.span_suggestion(\n+                                span,\n+                                \"consider using `.await` here\",\n+                                format!(\"{}.await?\", snippet.trim_end_matches('?')),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n /// Collect all the returned expressions within the input expression."}, {"sha": "9592f93ce2e7606c21bc540c4bb6c359fdfe28ff", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -31,7 +31,9 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::middle::region;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n-use rustc_middle::ty::{self, GenericParamDefKind, ToPredicate, Ty, TyCtxt, WithConstness};\n+use rustc_middle::ty::{\n+    self, GenericParamDefKind, ParamEnv, ToPredicate, Ty, TyCtxt, WithConstness,\n+};\n use rustc_span::Span;\n \n use std::fmt::Debug;\n@@ -523,6 +525,43 @@ fn vtable_methods<'tcx>(\n     }))\n }\n \n+/// Check whether a `ty` implements given trait(trait_def_id).\n+///\n+/// NOTE: Always return `false` for a type which needs inference.\n+fn type_implements_trait<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    key: (\n+        DefId,    // trait_def_id,\n+        Ty<'tcx>, // type\n+        SubstsRef<'tcx>,\n+        ParamEnv<'tcx>,\n+    ),\n+) -> bool {\n+    let (trait_def_id, ty, params, param_env) = key;\n+\n+    debug!(\n+        \"type_implements_trait: trait_def_id={:?}, type={:?}, params={:?}, param_env={:?}\",\n+        trait_def_id, ty, params, param_env\n+    );\n+\n+    // Do not check on infer_types to avoid panic in evaluate_obligation.\n+    if ty.has_infer_types() {\n+        return false;\n+    }\n+\n+    let ty = tcx.erase_regions(&ty);\n+\n+    let trait_ref = ty::TraitRef { def_id: trait_def_id, substs: tcx.mk_substs_trait(ty, params) };\n+\n+    let obligation = Obligation {\n+        cause: ObligationCause::dummy(),\n+        param_env,\n+        recursion_depth: 0,\n+        predicate: trait_ref.without_const().to_predicate(),\n+    };\n+    tcx.infer_ctxt().enter(|infcx| infcx.predicate_must_hold_modulo_regions(&obligation))\n+}\n+\n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     object_safety::provide(providers);\n     *providers = ty::query::Providers {\n@@ -531,6 +570,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         codegen_fulfill_obligation: codegen::codegen_fulfill_obligation,\n         vtable_methods,\n         substitute_normalize_and_test_predicates,\n+        type_implements_trait,\n         ..*providers\n     };\n }"}, {"sha": "226c187e3cfdf911350e58dfa1ffba4980b69444", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -5282,6 +5282,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n     ) {\n+        debug!(\"suggest_missing_await: expr={:?} expected={:?}, found={:?}\", expr, expected, found);\n         // `.await` is not permitted outside of `async` bodies, so don't bother to suggest if the\n         // body isn't `async`.\n         let item_id = self.tcx().hir().get_parent_node(self.body_id);\n@@ -5299,22 +5300,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .next()\n                     .unwrap()\n                     .def_id;\n+                // `<T as Future>::Output`\n+                let projection_ty = ty::ProjectionTy {\n+                    // `T`\n+                    substs: self\n+                        .tcx\n+                        .mk_substs_trait(found, self.fresh_substs_for_item(sp, item_def_id)),\n+                    // `Future::Output`\n+                    item_def_id,\n+                };\n+\n                 let predicate =\n                     ty::Predicate::Projection(ty::Binder::bind(ty::ProjectionPredicate {\n-                        // `<T as Future>::Output`\n-                        projection_ty: ty::ProjectionTy {\n-                            // `T`\n-                            substs: self.tcx.mk_substs_trait(\n-                                found,\n-                                self.fresh_substs_for_item(sp, item_def_id),\n-                            ),\n-                            // `Future::Output`\n-                            item_def_id,\n-                        },\n+                        projection_ty,\n                         ty: expected,\n                     }));\n                 let obligation = traits::Obligation::new(self.misc(sp), self.param_env, predicate);\n+\n                 debug!(\"suggest_missing_await: trying obligation {:?}\", obligation);\n+\n                 if self.infcx.predicate_may_hold(&obligation) {\n                     debug!(\"suggest_missing_await: obligation held: {:?}\", obligation);\n                     if let Ok(code) = self.sess().source_map().span_to_snippet(sp) {"}, {"sha": "381238165274de42d61683ab44d30eebd2a8cf83", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -643,6 +643,15 @@ impl Attributes {\n             })\n             .collect()\n     }\n+\n+    pub fn get_doc_aliases(&self) -> FxHashSet<String> {\n+        self.other_attrs\n+            .lists(sym::doc)\n+            .filter(|a| a.check_name(sym::alias))\n+            .filter_map(|a| a.value_str().map(|s| s.to_string().replace(\"\\\"\", \"\")))\n+            .filter(|v| !v.is_empty())\n+            .collect::<FxHashSet<_>>()\n+    }\n }\n \n impl PartialEq for Attributes {"}, {"sha": "ea65b3905272e9c180ae75d081c5cca588d9d713", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -114,7 +114,6 @@ pub fn render<T: Print, S: Print>(\n         window.rootPath = \\\"{root_path}\\\";\\\n         window.currentCrate = \\\"{krate}\\\";\\\n     </script>\\\n-    <script src=\\\"{root_path}aliases{suffix}.js\\\"></script>\\\n     <script src=\\\"{static_root_path}main{suffix}.js\\\"></script>\\\n     {static_extra_scripts}\\\n     {extra_scripts}\\"}, {"sha": "646c663ad9ccd737e91e368ef9c7d12a7b3f3144", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 6, "deletions": 37, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -293,7 +293,12 @@ impl Serialize for IndexItem {\n     where\n         S: Serializer,\n     {\n-        assert_eq!(self.parent.is_some(), self.parent_idx.is_some());\n+        assert_eq!(\n+            self.parent.is_some(),\n+            self.parent_idx.is_some(),\n+            \"`{}` is missing idx\",\n+            self.name\n+        );\n \n         (self.ty, &self.name, &self.path, &self.desc, self.parent_idx, &self.search_type)\n             .serialize(serializer)\n@@ -819,42 +824,6 @@ themePicker.onblur = handleThemeButtonsBlur;\n         Ok((ret, krates))\n     }\n \n-    fn show_item(item: &IndexItem, krate: &str) -> String {\n-        format!(\n-            \"{{'crate':'{}','ty':{},'name':'{}','desc':'{}','p':'{}'{}}}\",\n-            krate,\n-            item.ty as usize,\n-            item.name,\n-            item.desc.replace(\"'\", \"\\\\'\"),\n-            item.path,\n-            if let Some(p) = item.parent_idx { format!(\",'parent':{}\", p) } else { String::new() }\n-        )\n-    }\n-\n-    let dst = cx.dst.join(&format!(\"aliases{}.js\", cx.shared.resource_suffix));\n-    {\n-        let (mut all_aliases, _) = try_err!(collect(&dst, &krate.name, \"ALIASES\"), &dst);\n-        let mut output = String::with_capacity(100);\n-        for (alias, items) in &cx.cache.aliases {\n-            if items.is_empty() {\n-                continue;\n-            }\n-            output.push_str(&format!(\n-                \"\\\"{}\\\":[{}],\",\n-                alias,\n-                items.iter().map(|v| show_item(v, &krate.name)).collect::<Vec<_>>().join(\",\")\n-            ));\n-        }\n-        all_aliases.push(format!(\"ALIASES[\\\"{}\\\"] = {{{}}};\", krate.name, output));\n-        all_aliases.sort();\n-        let mut v = Buffer::html();\n-        writeln!(&mut v, \"var ALIASES = {{}};\");\n-        for aliases in &all_aliases {\n-            writeln!(&mut v, \"{}\", aliases);\n-        }\n-        cx.shared.fs.write(&dst, v.into_inner().into_bytes())?;\n-    }\n-\n     use std::ffi::OsString;\n \n     #[derive(Debug)]"}, {"sha": "57d385de32096d88e11c5682a94ffe6213b05716", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 24, "deletions": 40, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -120,7 +120,7 @@ crate struct Cache {\n \n     /// Aliases added through `#[doc(alias = \"...\")]`. Since a few items can have the same alias,\n     /// we need the alias element to have an array of items.\n-    pub(super) aliases: FxHashMap<String, Vec<IndexItem>>,\n+    pub(super) aliases: BTreeMap<String, Vec<usize>>,\n }\n \n impl Cache {\n@@ -311,7 +311,7 @@ impl DocFolder for Cache {\n             };\n \n             match parent {\n-                (parent, Some(path)) if is_inherent_impl_item || (!self.stripped_mod) => {\n+                (parent, Some(path)) if is_inherent_impl_item || !self.stripped_mod => {\n                     debug_assert!(!item.is_stripped());\n \n                     // A crate has a module at its root, containing all items,\n@@ -327,6 +327,13 @@ impl DocFolder for Cache {\n                             parent_idx: None,\n                             search_type: get_index_search_type(&item),\n                         });\n+\n+                        for alias in item.attrs.get_doc_aliases() {\n+                            self.aliases\n+                                .entry(alias.to_lowercase())\n+                                .or_insert(Vec::new())\n+                                .push(self.search_index.len() - 1);\n+                        }\n                     }\n                 }\n                 (Some(parent), None) if is_inherent_impl_item => {\n@@ -376,11 +383,8 @@ impl DocFolder for Cache {\n                 {\n                     self.paths.insert(item.def_id, (self.stack.clone(), item.type_()));\n                 }\n-                self.add_aliases(&item);\n             }\n-\n             clean::PrimitiveItem(..) => {\n-                self.add_aliases(&item);\n                 self.paths.insert(item.def_id, (self.stack.clone(), item.type_()));\n             }\n \n@@ -488,40 +492,6 @@ impl DocFolder for Cache {\n     }\n }\n \n-impl Cache {\n-    fn add_aliases(&mut self, item: &clean::Item) {\n-        if item.def_id.index == CRATE_DEF_INDEX {\n-            return;\n-        }\n-        if let Some(ref item_name) = item.name {\n-            let path = self\n-                .paths\n-                .get(&item.def_id)\n-                .map(|p| p.0[..p.0.len() - 1].join(\"::\"))\n-                .unwrap_or(\"std\".to_owned());\n-            for alias in item\n-                .attrs\n-                .lists(sym::doc)\n-                .filter(|a| a.check_name(sym::alias))\n-                .filter_map(|a| a.value_str().map(|s| s.to_string().replace(\"\\\"\", \"\")))\n-                .filter(|v| !v.is_empty())\n-                .collect::<FxHashSet<_>>()\n-                .into_iter()\n-            {\n-                self.aliases.entry(alias).or_insert(Vec::with_capacity(1)).push(IndexItem {\n-                    ty: item.type_(),\n-                    name: item_name.to_string(),\n-                    path: path.clone(),\n-                    desc: shorten(plain_summary_line(item.doc_value())),\n-                    parent: None,\n-                    parent_idx: None,\n-                    search_type: get_index_search_type(&item),\n-                });\n-            }\n-        }\n-    }\n-}\n-\n /// Attempts to find where an external crate is located, given that we're\n /// rendering in to the specified source destination.\n fn extern_location(\n@@ -567,7 +537,8 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     let mut crate_items = Vec::with_capacity(cache.search_index.len());\n     let mut crate_paths = vec![];\n \n-    let Cache { ref mut search_index, ref orphan_impl_items, ref paths, .. } = *cache;\n+    let Cache { ref mut search_index, ref orphan_impl_items, ref paths, ref mut aliases, .. } =\n+        *cache;\n \n     // Attach all orphan items to the type's definition if the type\n     // has since been learned.\n@@ -582,6 +553,12 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n                 parent_idx: None,\n                 search_type: get_index_search_type(&item),\n             });\n+            for alias in item.attrs.get_doc_aliases() {\n+                aliases\n+                    .entry(alias.to_lowercase())\n+                    .or_insert(Vec::new())\n+                    .push(search_index.len() - 1);\n+            }\n         }\n     }\n \n@@ -630,6 +607,12 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n         items: Vec<&'a IndexItem>,\n         #[serde(rename = \"p\")]\n         paths: Vec<(ItemType, String)>,\n+        // The String is alias name and the vec is the list of the elements with this alias.\n+        //\n+        // To be noted: the `usize` elements are indexes to `items`.\n+        #[serde(rename = \"a\")]\n+        #[serde(skip_serializing_if = \"BTreeMap::is_empty\")]\n+        aliases: &'a BTreeMap<String, Vec<usize>>,\n     }\n \n     // Collect the index into a string\n@@ -640,6 +623,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n             doc: crate_doc,\n             items: crate_items,\n             paths: crate_paths,\n+            aliases,\n         })\n         .expect(\"failed serde conversion\")\n         // All these `replace` calls are because we have to go through JS string for JSON content."}, {"sha": "9b498d66249e2fde35175429162a10f83da2690f", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 110, "deletions": 26, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -531,6 +531,7 @@ function getSearchElement() {\n         var OUTPUT_DATA = 1;\n         var NO_TYPE_FILTER = -1;\n         var currentResults, index, searchIndex;\n+        var ALIASES = {};\n         var params = getQueryStringParams();\n \n         // Populate search bar with query string search term when provided,\n@@ -963,6 +964,72 @@ function getSearchElement() {\n                 return itemTypes[ty.ty] + ty.path + ty.name;\n             }\n \n+            function createAliasFromItem(item) {\n+                return {\n+                    crate: item.crate,\n+                    name: item.name,\n+                    path: item.path,\n+                    desc: item.desc,\n+                    ty: item.ty,\n+                    parent: item.parent,\n+                    type: item.type,\n+                    is_alias: true,\n+                };\n+            }\n+\n+            function handleAliases(ret, query, filterCrates) {\n+                // We separate aliases and crate aliases because we want to have current crate\n+                // aliases to be before the others in the displayed results.\n+                var aliases = [];\n+                var crateAliases = [];\n+                var i;\n+                if (filterCrates !== undefined &&\n+                        ALIASES[filterCrates] &&\n+                        ALIASES[filterCrates][query.search]) {\n+                    for (i = 0; i < ALIASES[crate][query.search].length; ++i) {\n+                        aliases.push(\n+                            createAliasFromItem(searchIndex[ALIASES[filterCrates][query.search]]));\n+                    }\n+                } else {\n+                    Object.keys(ALIASES).forEach(function(crate) {\n+                        if (ALIASES[crate][query.search]) {\n+                            var pushTo = crate === window.currentCrate ? crateAliases : aliases;\n+                            for (i = 0; i < ALIASES[crate][query.search].length; ++i) {\n+                                pushTo.push(\n+                                    createAliasFromItem(\n+                                        searchIndex[ALIASES[crate][query.search][i]]));\n+                            }\n+                        }\n+                    });\n+                }\n+\n+                var sortFunc = function(aaa, bbb) {\n+                    if (aaa.path < bbb.path) {\n+                        return 1;\n+                    } else if (aaa.path === bbb.path) {\n+                        return 0;\n+                    }\n+                    return -1;\n+                };\n+                crateAliases.sort(sortFunc);\n+                aliases.sort(sortFunc);\n+\n+                var pushFunc = function(alias) {\n+                    alias.alias = query.raw;\n+                    var res = buildHrefAndPath(alias);\n+                    alias.displayPath = pathSplitter(res[0]);\n+                    alias.fullPath = alias.displayPath + alias.name;\n+                    alias.href = res[1];\n+\n+                    ret.others.unshift(alias);\n+                    if (ret.others.length > MAX_RESULTS) {\n+                        ret.others.pop();\n+                    }\n+                };\n+                onEach(aliases, pushFunc);\n+                onEach(crateAliases, pushFunc);\n+            }\n+\n             // quoted values mean literal search\n             var nSearchWords = searchWords.length;\n             var i;\n@@ -1190,23 +1257,7 @@ function getSearchElement() {\n                 \"returned\": sortResults(results_returned, true),\n                 \"others\": sortResults(results),\n             };\n-            if (ALIASES && ALIASES[window.currentCrate] &&\n-                    ALIASES[window.currentCrate][query.raw]) {\n-                var aliases = ALIASES[window.currentCrate][query.raw];\n-                for (i = 0; i < aliases.length; ++i) {\n-                    aliases[i].is_alias = true;\n-                    aliases[i].alias = query.raw;\n-                    aliases[i].path = aliases[i].p;\n-                    var res = buildHrefAndPath(aliases[i]);\n-                    aliases[i].displayPath = pathSplitter(res[0]);\n-                    aliases[i].fullPath = aliases[i].displayPath + aliases[i].name;\n-                    aliases[i].href = res[1];\n-                    ret.others.unshift(aliases[i]);\n-                    if (ret.others.length > MAX_RESULTS) {\n-                        ret.others.pop();\n-                    }\n-                }\n-            }\n+            handleAliases(ret, query, filterCrates);\n             return ret;\n         }\n \n@@ -1599,13 +1650,12 @@ function getSearchElement() {\n                     \"returned\": mergeArrays(results.returned),\n                     \"others\": mergeArrays(results.others),\n                 };\n-            } else {\n-                return {\n-                    \"in_args\": results.in_args[0],\n-                    \"returned\": results.returned[0],\n-                    \"others\": results.others[0],\n-                };\n             }\n+            return {\n+                \"in_args\": results.in_args[0],\n+                \"returned\": results.returned[0],\n+                \"others\": results.others[0],\n+            };\n         }\n \n         function getFilterCrates() {\n@@ -1656,10 +1706,13 @@ function getSearchElement() {\n             searchIndex = [];\n             var searchWords = [];\n             var i;\n+            var currentIndex = 0;\n \n             for (var crate in rawSearchIndex) {\n                 if (!rawSearchIndex.hasOwnProperty(crate)) { continue; }\n \n+                var crateSize = 0;\n+\n                 searchWords.push(crate);\n                 searchIndex.push({\n                     crate: crate,\n@@ -1669,6 +1722,7 @@ function getSearchElement() {\n                     desc: rawSearchIndex[crate].doc,\n                     type: null,\n                 });\n+                currentIndex += 1;\n \n                 // an array of [(Number) item type,\n                 //              (String) name,\n@@ -1680,6 +1734,9 @@ function getSearchElement() {\n                 // an array of [(Number) item type,\n                 //              (String) name]\n                 var paths = rawSearchIndex[crate].p;\n+                // a array of [(String) alias name\n+                //             [Number] index to items]\n+                var aliases = rawSearchIndex[crate].a;\n \n                 // convert `rawPaths` entries into object form\n                 var len = paths.length;\n@@ -1698,9 +1755,18 @@ function getSearchElement() {\n                 var lastPath = \"\";\n                 for (i = 0; i < len; ++i) {\n                     var rawRow = items[i];\n-                    var row = {crate: crate, ty: rawRow[0], name: rawRow[1],\n-                               path: rawRow[2] || lastPath, desc: rawRow[3],\n-                               parent: paths[rawRow[4]], type: rawRow[5]};\n+                    if (!rawRow[2]) {\n+                        rawRow[2] = lastPath;\n+                    }\n+                    var row = {\n+                        crate: crate,\n+                        ty: rawRow[0],\n+                        name: rawRow[1],\n+                        path: rawRow[2],\n+                        desc: rawRow[3],\n+                        parent: paths[rawRow[4]],\n+                        type: rawRow[5],\n+                    };\n                     searchIndex.push(row);\n                     if (typeof row.name === \"string\") {\n                         var word = row.name.toLowerCase();\n@@ -1709,7 +1775,25 @@ function getSearchElement() {\n                         searchWords.push(\"\");\n                     }\n                     lastPath = row.path;\n+                    crateSize += 1;\n+                }\n+\n+                if (aliases) {\n+                    ALIASES[crate] = {};\n+                    var j, local_aliases;\n+                    for (var alias_name in aliases) {\n+                        if (!aliases.hasOwnProperty(alias_name)) { continue; }\n+\n+                        if (!ALIASES[crate].hasOwnProperty(alias_name)) {\n+                            ALIASES[crate][alias_name] = [];\n+                        }\n+                        local_aliases = aliases[alias_name];\n+                        for (j = 0; j < local_aliases.length; ++j) {\n+                            ALIASES[crate][alias_name].push(local_aliases[j] + currentIndex);\n+                        }\n+                    }\n                 }\n+                currentIndex += crateSize;\n             }\n             return searchWords;\n         }"}, {"sha": "56cf9be339194e75fe8d09719e03784b66750754", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -251,6 +251,9 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// cause many collisions and very poor performance. Setting it\n     /// manually using this function can expose a DoS attack vector.\n     ///\n+    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n+    /// the HashMap to be useful, see its documentation for details.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -261,6 +264,8 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// let mut map = HashMap::with_hasher(s);\n     /// map.insert(1, 2);\n     /// ```\n+    ///\n+    /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn with_hasher(hash_builder: S) -> HashMap<K, V, S> {\n@@ -278,6 +283,9 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// cause many collisions and very poor performance. Setting it\n     /// manually using this function can expose a DoS attack vector.\n     ///\n+    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n+    /// the HashMap to be useful, see its documentation for details.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -288,6 +296,8 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// let mut map = HashMap::with_capacity_and_hasher(10, s);\n     /// map.insert(1, 2);\n     /// ```\n+    ///\n+    /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S) -> HashMap<K, V, S> {"}, {"sha": "ca06457291cae7e282f800df8fb14e3faec74984", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -273,6 +273,9 @@ impl<T, S> HashSet<T, S> {\n     /// cause many collisions and very poor performance. Setting it\n     /// manually using this function can expose a DoS attack vector.\n     ///\n+    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n+    /// the HashMap to be useful, see its documentation for details.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -283,6 +286,8 @@ impl<T, S> HashSet<T, S> {\n     /// let mut set = HashSet::with_hasher(s);\n     /// set.insert(2);\n     /// ```\n+    ///\n+    /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn with_hasher(hasher: S) -> HashSet<T, S> {\n@@ -300,6 +305,9 @@ impl<T, S> HashSet<T, S> {\n     /// cause many collisions and very poor performance. Setting it\n     /// manually using this function can expose a DoS attack vector.\n     ///\n+    /// The `hash_builder` passed should implement the [`BuildHasher`] trait for\n+    /// the HashMap to be useful, see its documentation for details.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -310,6 +318,8 @@ impl<T, S> HashSet<T, S> {\n     /// let mut set = HashSet::with_capacity_and_hasher(10, s);\n     /// set.insert(1);\n     /// ```\n+    ///\n+    /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n     #[inline]\n     #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n     pub fn with_capacity_and_hasher(capacity: usize, hasher: S) -> HashSet<T, S> {"}, {"sha": "7a05aaf71f2c1d670c91f53fef48a13dc8208187", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -4,6 +4,7 @@ use crate::fmt;\n use crate::hash::{Hash, Hasher};\n use crate::ops;\n use crate::rc::Rc;\n+use crate::str::FromStr;\n use crate::sync::Arc;\n \n use crate::sys::os_str::{Buf, Slice};\n@@ -1174,6 +1175,15 @@ impl AsInner<Slice> for OsStr {\n     }\n }\n \n+#[stable(feature = \"osstring_from_str\", since = \"1.45.0\")]\n+impl FromStr for OsString {\n+    type Err = core::convert::Infallible;\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        Ok(OsString::from(s))\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "187c17454350a05668096496171bd5bcae2bf381", "filename": "src/test/mir-opt/const_prop/mutable_variable/rustc.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable%2Frustc.main.ConstProp.diff?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -26,8 +26,7 @@\n                                            // + ty: i32\n                                            // + val: Value(Scalar(0x00000063))\n                                            // mir::Constant\n--                                          // + span: $DIR/mutable_variable.rs:6:9: 6:11\n-+                                          // + span: $DIR/mutable_variable.rs:6:5: 6:11\n+                                           // + span: $DIR/mutable_variable.rs:6:9: 6:11\n                                            // + literal: Const { ty: i32, val: Value(Scalar(0x00000063)) }\n           StorageLive(_2);                 // scope 1 at $DIR/mutable_variable.rs:7:9: 7:10\n -         _2 = _1;                         // scope 1 at $DIR/mutable_variable.rs:7:13: 7:14"}, {"sha": "cf432b2acc1c5c86be05afc7f964aad2587b328d", "filename": "src/test/mir-opt/const_prop/mutable_variable_aggregate/rustc.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate%2Frustc.main.ConstProp.diff?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -34,8 +34,7 @@\n                                            // + ty: i32\n                                            // + val: Value(Scalar(0x00000063))\n                                            // mir::Constant\n--                                          // + span: $DIR/mutable_variable_aggregate.rs:6:11: 6:13\n-+                                          // + span: $DIR/mutable_variable_aggregate.rs:6:5: 6:13\n+                                           // + span: $DIR/mutable_variable_aggregate.rs:6:11: 6:13\n                                            // + literal: Const { ty: i32, val: Value(Scalar(0x00000063)) }\n           StorageLive(_2);                 // scope 1 at $DIR/mutable_variable_aggregate.rs:7:9: 7:10\n -         _2 = _1;                         // scope 1 at $DIR/mutable_variable_aggregate.rs:7:13: 7:14"}, {"sha": "1e0271a560f650785d410cfc5edf25cf3ee8f11a", "filename": "src/test/mir-opt/copy_propagation_arg/rustc.arg_src.CopyPropagation.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg%2Frustc.arg_src.CopyPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg%2Frustc.arg_src.CopyPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg%2Frustc.arg_src.CopyPropagation.diff?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -17,7 +17,7 @@\n                                            // + ty: i32\n                                            // + val: Value(Scalar(0x0000007b))\n                                            // mir::Constant\n-                                           // + span: $DIR/copy_propagation_arg.rs:29:5: 29:12\n+                                           // + span: $DIR/copy_propagation_arg.rs:29:9: 29:12\n                                            // + literal: Const { ty: i32, val: Value(Scalar(0x0000007b)) }\n           _0 = _2;                         // scope 1 at $DIR/copy_propagation_arg.rs:30:5: 30:6\n           StorageDead(_2);                 // scope 0 at $DIR/copy_propagation_arg.rs:31:1: 31:2"}, {"sha": "b875bbea67bdf0b5bde199b3d5367c959109d2eb", "filename": "src/test/mir-opt/copy_propagation_arg/rustc.bar.CopyPropagation.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg%2Frustc.bar.CopyPropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg%2Frustc.bar.CopyPropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fcopy_propagation_arg%2Frustc.bar.CopyPropagation.diff?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -28,7 +28,7 @@\n                                            // + ty: u8\n                                            // + val: Value(Scalar(0x05))\n                                            // mir::Constant\n-                                           // + span: $DIR/copy_propagation_arg.rs:17:5: 17:10\n+                                           // + span: $DIR/copy_propagation_arg.rs:17:9: 17:10\n                                            // + literal: Const { ty: u8, val: Value(Scalar(0x05)) }\n           _0 = const ();                   // scope 0 at $DIR/copy_propagation_arg.rs:15:19: 18:2\n                                            // ty::Const"}, {"sha": "798fa29efbd2d2c1af3c63143c95bbbfa975e6c1", "filename": "src/test/rustdoc-js-std/alias-2.js", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Frustdoc-js-std%2Falias-2.js", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Frustdoc-js-std%2Falias-2.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Falias-2.js?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -1,10 +1,10 @@\n-// ignore-order\n-\n const QUERY = '+';\n \n const EXPECTED = {\n     'others': [\n         { 'path': 'std::ops', 'name': 'AddAssign' },\n         { 'path': 'std::ops', 'name': 'Add' },\n+        { 'path': 'core::ops', 'name': 'AddAssign' },\n+        { 'path': 'core::ops', 'name': 'Add' },\n     ],\n };"}, {"sha": "896808d4157808e1b0f682bd2c02d4440d0fb85c", "filename": "src/test/rustdoc-js/doc-alias.js", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Frustdoc-js%2Fdoc-alias.js", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Frustdoc-js%2Fdoc-alias.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fdoc-alias.js?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -0,0 +1,263 @@\n+// exact-check\n+\n+const QUERY = [\n+    'StructItem',\n+    'StructFieldItem',\n+    'StructMethodItem',\n+    'ImplTraitItem',\n+    'ImplAssociatedConstItem',\n+    'ImplTraitFunction',\n+    'EnumItem',\n+    'VariantItem',\n+    'EnumMethodItem',\n+    'TypedefItem',\n+    'TraitItem',\n+    'TraitTypeItem',\n+    'AssociatedConstItem',\n+    'TraitFunctionItem',\n+    'FunctionItem',\n+    'ModuleItem',\n+    'ConstItem',\n+    'StaticItem',\n+    'UnionItem',\n+    'UnionFieldItem',\n+    'UnionMethodItem',\n+    'MacroItem',\n+];\n+\n+const EXPECTED = [\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias',\n+                'name': 'Struct',\n+                'alias': 'StructItem',\n+                'href': '../doc_alias/struct.Struct.html',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias::Struct',\n+                'name': 'field',\n+                'alias': 'StructFieldItem',\n+                'href': '../doc_alias/struct.Struct.html#structfield.field',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias::Struct',\n+                'name': 'method',\n+                'alias': 'StructMethodItem',\n+                'href': '../doc_alias/struct.Struct.html#method.method',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        // ImplTraitItem\n+        'others': [],\n+    },\n+    {\n+        // ImplAssociatedConstItem\n+        'others': [],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias::Struct',\n+                'name': 'function',\n+                'alias': 'ImplTraitFunction',\n+                'href': '../doc_alias/struct.Struct.html#method.function',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias',\n+                'name': 'Enum',\n+                'alias': 'EnumItem',\n+                'href': '../doc_alias/enum.Enum.html',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias::Enum',\n+                'name': 'Variant',\n+                'alias': 'VariantItem',\n+                'href': '../doc_alias/enum.Enum.html#variant.Variant',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias::Enum',\n+                'name': 'method',\n+                'alias': 'EnumMethodItem',\n+                'href': '../doc_alias/enum.Enum.html#method.method',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias',\n+                'name': 'Typedef',\n+                'alias': 'TypedefItem',\n+                'href': '../doc_alias/type.Typedef.html',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias',\n+                'name': 'Trait',\n+                'alias': 'TraitItem',\n+                'href': '../doc_alias/trait.Trait.html',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias::Trait',\n+                'name': 'Target',\n+                'alias': 'TraitTypeItem',\n+                'href': '../doc_alias/trait.Trait.html#associatedtype.Target',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias::Trait',\n+                'name': 'AssociatedConst',\n+                'alias': 'AssociatedConstItem',\n+                'href': '../doc_alias/trait.Trait.html#associatedconstant.AssociatedConst',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias::Trait',\n+                'name': 'function',\n+                'alias': 'TraitFunctionItem',\n+                'href': '../doc_alias/trait.Trait.html#tymethod.function',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias',\n+                'name': 'function',\n+                'alias': 'FunctionItem',\n+                'href': '../doc_alias/fn.function.html',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias',\n+                'name': 'Module',\n+                'alias': 'ModuleItem',\n+                'href': '../doc_alias/Module/index.html',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias',\n+                'name': 'Const',\n+                'alias': 'ConstItem',\n+                'href': '../doc_alias/constant.Const.html',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias',\n+                'name': 'Static',\n+                'alias': 'StaticItem',\n+                'href': '../doc_alias/static.Static.html',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias',\n+                'name': 'Union',\n+                'alias': 'UnionItem',\n+                'href': '../doc_alias/union.Union.html',\n+                'is_alias': true\n+            },\n+            // Not an alias!\n+            {\n+                'path': 'doc_alias::Union',\n+                'name': 'union_item',\n+                'href': '../doc_alias/union.Union.html#structfield.union_item'\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias::Union',\n+                'name': 'union_item',\n+                'alias': 'UnionFieldItem',\n+                'href': '../doc_alias/union.Union.html#structfield.union_item',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias::Union',\n+                'name': 'method',\n+                'alias': 'UnionMethodItem',\n+                'href': '../doc_alias/union.Union.html#method.method',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+    {\n+        'others': [\n+            {\n+                'path': 'doc_alias',\n+                'name': 'Macro',\n+                'alias': 'MacroItem',\n+                'href': '../doc_alias/macro.Macro.html',\n+                'is_alias': true\n+            },\n+        ],\n+    },\n+];"}, {"sha": "84c638a199507f25aecbe9823b434d3d0f288b4f", "filename": "src/test/rustdoc-js/doc-alias.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Frustdoc-js%2Fdoc-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Frustdoc-js%2Fdoc-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fdoc-alias.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -0,0 +1,79 @@\n+#![feature(doc_alias)]\n+\n+#[doc(alias = \"StructItem\")]\n+pub struct Struct {\n+    #[doc(alias = \"StructFieldItem\")]\n+    pub field: u32,\n+}\n+\n+impl Struct {\n+    #[doc(alias = \"StructMethodItem\")]\n+    pub fn method(&self) {}\n+}\n+\n+impl Trait for Struct {\n+    // Shouldn't be listed in aliases!\n+    #[doc(alias = \"ImplTraitItem\")]\n+    type Target = u32;\n+    // Shouldn't be listed in aliases!\n+    #[doc(alias = \"ImplAssociatedConstItem\")]\n+    const AssociatedConst: i32 = 12;\n+\n+    #[doc(alias = \"ImplTraitFunction\")]\n+    fn function() -> Self::Target { 0 }\n+}\n+\n+#[doc(alias = \"EnumItem\")]\n+pub enum Enum {\n+    #[doc(alias = \"VariantItem\")]\n+    Variant,\n+}\n+\n+impl Enum {\n+    #[doc(alias = \"EnumMethodItem\")]\n+    pub fn method(&self) {}\n+}\n+\n+#[doc(alias = \"TypedefItem\")]\n+pub type Typedef = i32;\n+\n+#[doc(alias = \"TraitItem\")]\n+pub trait Trait {\n+    #[doc(alias = \"TraitTypeItem\")]\n+    type Target;\n+    #[doc(alias = \"AssociatedConstItem\")]\n+    const AssociatedConst: i32;\n+\n+    #[doc(alias = \"TraitFunctionItem\")]\n+    fn function() -> Self::Target;\n+}\n+\n+#[doc(alias = \"FunctionItem\")]\n+pub fn function() {}\n+\n+#[doc(alias = \"ModuleItem\")]\n+pub mod Module {}\n+\n+#[doc(alias = \"ConstItem\")]\n+pub const Const: u32 = 0;\n+\n+#[doc(alias = \"StaticItem\")]\n+pub static Static: u32 = 0;\n+\n+#[doc(alias = \"UnionItem\")]\n+pub union Union {\n+    #[doc(alias = \"UnionFieldItem\")]\n+    pub union_item: u32,\n+    pub y: f32,\n+}\n+\n+impl Union {\n+    #[doc(alias = \"UnionMethodItem\")]\n+    pub fn method(&self) {}\n+}\n+\n+#[doc(alias = \"MacroItem\")]\n+#[macro_export]\n+macro_rules! Macro {\n+    () => {}\n+}"}, {"sha": "96158fc0e0496c3d76567aa2bed84aa9530e311d", "filename": "src/test/ui/async-await/await-keyword/incorrect-syntax-suggestions.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -237,7 +237,10 @@ error[E0277]: the `?` operator can only be applied to values that implement `std\n   --> $DIR/incorrect-syntax-suggestions.rs:16:19\n    |\n LL |     let _ = await bar()?;\n-   |                   ^^^^^^ the `?` operator cannot be applied to type `impl std::future::Future`\n+   |                   ^^^^^^\n+   |                   |\n+   |                   the `?` operator cannot be applied to type `impl std::future::Future`\n+   |                   help: consider using `.await` here: `bar().await?`\n    |\n    = help: the trait `std::ops::Try` is not implemented for `impl std::future::Future`\n    = note: required by `std::ops::Try::into_result`"}, {"sha": "13b45df64eabeae90a487c58341c964c3207a067", "filename": "src/test/ui/async-await/issue-61076.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -0,0 +1,32 @@\n+// edition:2018\n+\n+use core::future::Future;\n+use core::pin::Pin;\n+use core::task::{Context, Poll};\n+\n+struct T;\n+\n+impl Future for T {\n+    type Output = Result<(), ()>;\n+\n+    fn poll(self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<Self::Output> {\n+        Poll::Pending\n+    }\n+}\n+\n+async fn foo() -> Result<(), ()> {\n+    Ok(())\n+}\n+\n+async fn bar() -> Result<(), ()> {\n+    foo()?; //~ ERROR the `?` operator can only be applied to values that implement `std::ops::Try`\n+    Ok(())\n+}\n+\n+async fn baz() -> Result<(), ()> {\n+    let t = T;\n+    t?; //~ ERROR the `?` operator can only be applied to values that implement `std::ops::Try`\n+    Ok(())\n+}\n+\n+fn main() {}"}, {"sha": "e71f4e7136dad26f44fef9f604ffe14ec57c30de", "filename": "src/test/ui/async-await/issue-61076.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -0,0 +1,27 @@\n+error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n+  --> $DIR/issue-61076.rs:22:5\n+   |\n+LL |     foo()?;\n+   |     ^^^^^^\n+   |     |\n+   |     the `?` operator cannot be applied to type `impl std::future::Future`\n+   |     help: consider using `.await` here: `foo().await?`\n+   |\n+   = help: the trait `std::ops::Try` is not implemented for `impl std::future::Future`\n+   = note: required by `std::ops::Try::into_result`\n+\n+error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n+  --> $DIR/issue-61076.rs:28:5\n+   |\n+LL |     t?;\n+   |     ^^\n+   |     |\n+   |     the `?` operator cannot be applied to type `T`\n+   |     help: consider using `.await` here: `t.await?`\n+   |\n+   = help: the trait `std::ops::Try` is not implemented for `T`\n+   = note: required by `std::ops::Try::into_result`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "c520a07abc17267aed29eca5c119a3fb7c315d24", "filename": "src/test/ui/async-await/try-on-option-in-async.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Fui%2Fasync-await%2Ftry-on-option-in-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Fui%2Fasync-await%2Ftry-on-option-in-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Ftry-on-option-in-async.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -7,7 +7,8 @@ async fn an_async_block() -> u32 {\n         let x: Option<u32> = None;\n         x?; //~ ERROR the `?` operator\n         22\n-    }.await\n+    }\n+    .await\n }\n \n async fn async_closure_containing_fn() -> u32 {"}, {"sha": "700296d6747841408f8312bccdada03b1a0f0cbe", "filename": "src/test/ui/async-await/try-on-option-in-async.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Fui%2Fasync-await%2Ftry-on-option-in-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Fui%2Fasync-await%2Ftry-on-option-in-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Ftry-on-option-in-async.stderr?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -7,14 +7,14 @@ LL | |         let x: Option<u32> = None;\n LL | |         x?;\n    | |         ^^ cannot use the `?` operator in an async block that returns `{integer}`\n LL | |         22\n-LL | |     }.await\n+LL | |     }\n    | |_____- this function should return `Result` or `Option` to accept `?`\n    |\n    = help: the trait `std::ops::Try` is not implemented for `{integer}`\n    = note: required by `std::ops::Try::from_error`\n \n error[E0277]: the `?` operator can only be used in an async closure that returns `Result` or `Option` (or another type that implements `std::ops::Try`)\n-  --> $DIR/try-on-option-in-async.rs:16:9\n+  --> $DIR/try-on-option-in-async.rs:17:9\n    |\n LL |       let async_closure = async || {\n    |  __________________________________-\n@@ -29,7 +29,7 @@ LL | |     };\n    = note: required by `std::ops::Try::from_error`\n \n error[E0277]: the `?` operator can only be used in an async function that returns `Result` or `Option` (or another type that implements `std::ops::Try`)\n-  --> $DIR/try-on-option-in-async.rs:25:5\n+  --> $DIR/try-on-option-in-async.rs:26:5\n    |\n LL |   async fn an_async_function() -> u32 {\n    |  _____________________________________-"}, {"sha": "81985f9f625a5c36299e7abe6fd1589f330a6e0b", "filename": "src/test/ui/consts/miri_unleashed/ptr_arith.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -0,0 +1,29 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+#![feature(core_intrinsics)]\n+#![allow(const_err)]\n+\n+// A test demonstrating that we prevent doing even trivial\n+// pointer arithmetic or comparison during CTFE.\n+\n+static CMP: () = {\n+    let x = &0 as *const _;\n+    let _v = x == x;\n+    //~^ ERROR could not evaluate static initializer\n+    //~| NOTE pointer arithmetic or comparison\n+};\n+\n+static INT_PTR_ARITH: () = unsafe {\n+    let x: usize = std::mem::transmute(&0);\n+    let _v = x + 0;\n+    //~^ ERROR could not evaluate static initializer\n+    //~| NOTE pointer-to-integer cast\n+};\n+\n+static PTR_ARITH: () = unsafe {\n+    let x = &0 as *const _;\n+    let _v = core::intrinsics::offset(x, 0);\n+    //~^ ERROR could not evaluate static initializer\n+    //~| NOTE calling intrinsic `offset`\n+};\n+\n+fn main() {}"}, {"sha": "5bd534a16b8637826b4ba9f5a7c7fdd1760e81c6", "filename": "src/test/ui/consts/miri_unleashed/ptr_arith.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -0,0 +1,39 @@\n+error[E0080]: could not evaluate static initializer\n+  --> $DIR/ptr_arith.rs:10:14\n+   |\n+LL |     let _v = x == x;\n+   |              ^^^^^^ \"pointer arithmetic or comparison\" needs an rfc before being allowed inside constants\n+\n+error[E0080]: could not evaluate static initializer\n+  --> $DIR/ptr_arith.rs:17:14\n+   |\n+LL |     let _v = x + 0;\n+   |              ^^^^^ \"pointer-to-integer cast\" needs an rfc before being allowed inside constants\n+\n+error[E0080]: could not evaluate static initializer\n+  --> $DIR/ptr_arith.rs:24:14\n+   |\n+LL |     let _v = core::intrinsics::offset(x, 0);\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ \"calling intrinsic `offset`\" needs an rfc before being allowed inside constants\n+\n+warning: skipping const checks\n+   |\n+help: skipping check for `const_compare_raw_pointers` feature\n+  --> $DIR/ptr_arith.rs:10:14\n+   |\n+LL |     let _v = x == x;\n+   |              ^^^^^^\n+help: skipping check that does not even have a feature gate\n+  --> $DIR/ptr_arith.rs:16:20\n+   |\n+LL |     let x: usize = std::mem::transmute(&0);\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^\n+help: skipping check that does not even have a feature gate\n+  --> $DIR/ptr_arith.rs:24:14\n+   |\n+LL |     let _v = core::intrinsics::offset(x, 0);\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "438a9f42ccd239341327c88c57ef7ee9df6be779", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -40,15 +40,12 @@ use rustc_hir::{\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::map::Map;\n-use rustc_middle::traits;\n use rustc_middle::ty::{self, layout::IntegerExt, subst::GenericArg, Binder, Ty, TyCtxt, TypeFoldable};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::source_map::original_sp;\n use rustc_span::symbol::{self, kw, Symbol};\n use rustc_span::{BytePos, Pos, Span, DUMMY_SP};\n use rustc_target::abi::Integer;\n-use rustc_trait_selection::traits::predicate_for_trait_def;\n-use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n use smallvec::SmallVec;\n \n@@ -326,19 +323,8 @@ pub fn implements_trait<'a, 'tcx>(\n     trait_id: DefId,\n     ty_params: &[GenericArg<'tcx>],\n ) -> bool {\n-    let ty = cx.tcx.erase_regions(&ty);\n-    let obligation = predicate_for_trait_def(\n-        cx.tcx,\n-        cx.param_env,\n-        traits::ObligationCause::dummy(),\n-        trait_id,\n-        0,\n-        ty,\n-        ty_params,\n-    );\n-    cx.tcx\n-        .infer_ctxt()\n-        .enter(|infcx| infcx.predicate_must_hold_modulo_regions(&obligation))\n+    let ty_params = cx.tcx.mk_substs(ty_params.iter());\n+    cx.tcx.type_implements_trait((trait_id, ty, ty_params, cx.param_env))\n }\n \n /// Gets the `hir::TraitRef` of the trait the given method is implemented for."}, {"sha": "1ce0300f23904c6a9dc80004cfd3bf3959725472", "filename": "src/tools/clippy/src/driver.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -296,7 +296,7 @@ pub fn main() {\n     rustc_driver::init_rustc_env_logger();\n     lazy_static::initialize(&ICE_HOOK);\n     exit(\n-        rustc_driver::catch_fatal_errors(move || {\n+        rustc_driver::catch_with_exit_code(move || {\n             let mut orig_args: Vec<String> = env::args().collect();\n \n             if orig_args.iter().any(|a| a == \"--version\" || a == \"-V\") {\n@@ -411,7 +411,5 @@ pub fn main() {\n                 if clippy_enabled { &mut clippy } else { &mut default };\n             rustc_driver::run_compiler(&args, callbacks, None, None)\n         })\n-        .and_then(|result| result)\n-        .is_err() as i32,\n     )\n }"}, {"sha": "1fa46ce99f5e66794e88b5bccb9a14046892787a", "filename": "src/tools/rustdoc-js/tester.js", "status": "modified", "additions": 68, "deletions": 37, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftools%2Frustdoc-js%2Ftester.js", "raw_url": "https://github.com/rust-lang/rust/raw/163445ac80225090c81e7ff1b185fb5dca52e3b2/src%2Ftools%2Frustdoc-js%2Ftester.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-js%2Ftester.js?ref=163445ac80225090c81e7ff1b185fb5dca52e3b2", "patch": "@@ -181,7 +181,7 @@ function loadThings(thingsToLoad, kindOfLoad, funcToCall, fileContent) {\n     for (var i = 0; i < thingsToLoad.length; ++i) {\n         var tmp = funcToCall(fileContent, thingsToLoad[i]);\n         if (tmp === null) {\n-            console.error('unable to find ' + kindOfLoad + ' \"' + thingsToLoad[i] + '\"');\n+            console.log('unable to find ' + kindOfLoad + ' \"' + thingsToLoad[i] + '\"');\n             process.exit(1);\n         }\n         content += tmp;\n@@ -218,12 +218,13 @@ function lookForEntry(entry, data) {\n     return null;\n }\n \n-function loadMainJsAndIndex(mainJs, aliases, searchIndex, crate) {\n+function loadMainJsAndIndex(mainJs, searchIndex, storageJs, crate) {\n     if (searchIndex[searchIndex.length - 1].length === 0) {\n         searchIndex.pop();\n     }\n     searchIndex.pop();\n-    searchIndex = loadContent(searchIndex.join(\"\\n\") + '\\nexports.searchIndex = searchIndex;');\n+    var fullSearchIndex = searchIndex.join(\"\\n\") + '\\nexports.rawSearchIndex = searchIndex;';\n+    searchIndex = loadContent(fullSearchIndex);\n     var finalJS = \"\";\n \n     var arraysToLoad = [\"itemTypes\"];\n@@ -235,34 +236,28 @@ function loadMainJsAndIndex(mainJs, aliases, searchIndex, crate) {\n     // execQuery last parameter is built in buildIndex.\n     // buildIndex requires the hashmap from search-index.\n     var functionsToLoad = [\"buildHrefAndPath\", \"pathSplitter\", \"levenshtein\", \"validateResult\",\n-                           \"getQuery\", \"buildIndex\", \"execQuery\", \"execSearch\"];\n+                           \"handleAliases\", \"getQuery\", \"buildIndex\", \"execQuery\", \"execSearch\"];\n \n+    ALIASES = {};\n     finalJS += 'window = { \"currentCrate\": \"' + crate + '\" };\\n';\n     finalJS += 'var rootPath = \"../\";\\n';\n-    finalJS += aliases;\n+    finalJS += loadThings([\"onEach\"], 'function', extractFunction, storageJs);\n     finalJS += loadThings(arraysToLoad, 'array', extractArrayVariable, mainJs);\n     finalJS += loadThings(variablesToLoad, 'variable', extractVariable, mainJs);\n     finalJS += loadThings(functionsToLoad, 'function', extractFunction, mainJs);\n \n     var loaded = loadContent(finalJS);\n-    var index = loaded.buildIndex(searchIndex.searchIndex);\n+    var index = loaded.buildIndex(searchIndex.rawSearchIndex);\n \n     return [loaded, index];\n }\n \n-function runChecks(testFile, loaded, index) {\n-    var errors = 0;\n-    var loadedFile = loadContent(\n-        readFile(testFile) + 'exports.QUERY = QUERY;exports.EXPECTED = EXPECTED;');\n-\n-    const expected = loadedFile.EXPECTED;\n-    const query = loadedFile.QUERY;\n+function runSearch(query, expected, index, loaded, loadedFile, queryName) {\n     const filter_crate = loadedFile.FILTER_CRATE;\n     const ignore_order = loadedFile.ignore_order;\n     const exact_check = loadedFile.exact_check;\n-    const should_fail = loadedFile.should_fail;\n \n-    var results = loaded.execSearch(loaded.getQuery(query), index);\n+    var results = loaded.execSearch(loaded.getQuery(query), index, filter_crate);\n     var error_text = [];\n \n     for (var key in expected) {\n@@ -278,41 +273,77 @@ function runChecks(testFile, loaded, index) {\n         for (var i = 0; i < entry.length; ++i) {\n             var entry_pos = lookForEntry(entry[i], results[key]);\n             if (entry_pos === null) {\n-                error_text.push(\"==> Result not found in '\" + key + \"': '\" +\n+                error_text.push(queryName + \"==> Result not found in '\" + key + \"': '\" +\n                                 JSON.stringify(entry[i]) + \"'\");\n             } else if (exact_check === true && prev_pos + 1 !== entry_pos) {\n-                error_text.push(\"==> Exact check failed at position \" + (prev_pos + 1) + \": \" +\n-                                \"expected '\" + JSON.stringify(entry[i]) + \"' but found '\" +\n+                error_text.push(queryName + \"==> Exact check failed at position \" + (prev_pos + 1) +\n+                                \": expected '\" + JSON.stringify(entry[i]) + \"' but found '\" +\n                                 JSON.stringify(results[key][i]) + \"'\");\n             } else if (ignore_order === false && entry_pos < prev_pos) {\n-                error_text.push(\"==> '\" + JSON.stringify(entry[i]) + \"' was supposed to be \" +\n-                                \" before '\" + JSON.stringify(results[key][entry_pos]) + \"'\");\n+                error_text.push(queryName + \"==> '\" + JSON.stringify(entry[i]) + \"' was supposed \" +\n+                                \"to be before '\" + JSON.stringify(results[key][entry_pos]) + \"'\");\n             } else {\n                 prev_pos = entry_pos;\n             }\n         }\n     }\n-    if (error_text.length === 0 && should_fail === true) {\n-        errors += 1;\n-        console.error(\"FAILED\");\n-        console.error(\"==> Test was supposed to fail but all items were found...\");\n-    } else if (error_text.length !== 0 && should_fail === false) {\n-        errors += 1;\n-        console.error(\"FAILED\");\n-        console.error(error_text.join(\"\\n\"));\n+    return error_text;\n+}\n+\n+function checkResult(error_text, loadedFile, displaySuccess) {\n+    if (error_text.length === 0 && loadedFile.should_fail === true) {\n+        console.log(\"FAILED\");\n+        console.log(\"==> Test was supposed to fail but all items were found...\");\n+    } else if (error_text.length !== 0 && loadedFile.should_fail === false) {\n+        console.log(\"FAILED\");\n+        console.log(error_text.join(\"\\n\"));\n     } else {\n+        if (displaySuccess) {\n+            console.log(\"OK\");\n+        }\n+        return 0;\n+    }\n+    return 1;\n+}\n+\n+function runChecks(testFile, loaded, index) {\n+    var loadedFile = loadContent(\n+        readFile(testFile) + 'exports.QUERY = QUERY;exports.EXPECTED = EXPECTED;');\n+\n+    const expected = loadedFile.EXPECTED;\n+    const query = loadedFile.QUERY;\n+\n+    if (Array.isArray(query)) {\n+        if (!Array.isArray(expected)) {\n+            console.log(\"FAILED\");\n+            console.log(\"==> If QUERY variable is an array, EXPECTED should be an array too\");\n+            return 1;\n+        } else if (query.length !== expected.length) {\n+            console.log(\"FAILED\");\n+            console.log(\"==> QUERY variable should have the same length as EXPECTED\");\n+            return 1;\n+        }\n+        for (var i = 0; i < query.length; ++i) {\n+            var error_text = runSearch(query[i], expected[i], index, loaded, loadedFile,\n+                \"[ query `\" + query[i] + \"`]\");\n+            if (checkResult(error_text, loadedFile, false) !== 0) {\n+                return 1;\n+            }\n+        }\n         console.log(\"OK\");\n+        return 0;\n     }\n-    return errors;\n+    var error_text = runSearch(query, expected, index, loaded, loadedFile, \"\");\n+    return checkResult(error_text, loadedFile, true);\n }\n \n function load_files(doc_folder, resource_suffix, crate) {\n     var mainJs = readFile(path.join(doc_folder, \"main\" + resource_suffix + \".js\"));\n-    var aliases = readFile(path.join(doc_folder, \"aliases\" + resource_suffix + \".js\"));\n+    var storageJs = readFile(path.join(doc_folder, \"storage\" + resource_suffix + \".js\"));\n     var searchIndex = readFile(\n         path.join(doc_folder, \"search-index\" + resource_suffix + \".js\")).split(\"\\n\");\n \n-    return loadMainJsAndIndex(mainJs, aliases, searchIndex, crate);\n+    return loadMainJsAndIndex(mainJs, searchIndex, storageJs, crate);\n }\n \n function showHelp() {\n@@ -349,25 +380,25 @@ function parseOptions(args) {\n             || args[i] === \"--crate-name\") {\n             i += 1;\n             if (i >= args.length) {\n-                console.error(\"Missing argument after `\" + args[i - 1] + \"` option.\");\n+                console.log(\"Missing argument after `\" + args[i - 1] + \"` option.\");\n                 return null;\n             }\n             opts[correspondances[args[i - 1]]] = args[i];\n         } else if (args[i] === \"--help\") {\n             showHelp();\n             process.exit(0);\n         } else {\n-            console.error(\"Unknown option `\" + args[i] + \"`.\");\n-            console.error(\"Use `--help` to see the list of options\");\n+            console.log(\"Unknown option `\" + args[i] + \"`.\");\n+            console.log(\"Use `--help` to see the list of options\");\n             return null;\n         }\n     }\n     if (opts[\"doc_folder\"].length < 1) {\n-        console.error(\"Missing `--doc-folder` option.\");\n+        console.log(\"Missing `--doc-folder` option.\");\n     } else if (opts[\"crate_name\"].length < 1) {\n-        console.error(\"Missing `--crate-name` option.\");\n+        console.log(\"Missing `--crate-name` option.\");\n     } else if (opts[\"test_folder\"].length < 1 && opts[\"test_file\"].length < 1) {\n-        console.error(\"At least one of `--test-folder` or `--test-file` option is required.\");\n+        console.log(\"At least one of `--test-folder` or `--test-file` option is required.\");\n     } else {\n         return opts;\n     }"}]}