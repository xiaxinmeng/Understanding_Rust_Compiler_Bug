{"sha": "f0a42332b8ed123a92e9f8e2c329cbd2ad1753e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwYTQyMzMyYjhlZDEyM2E5MmU5ZjhlMmMzMjljYmQyYWQxNzUzZTk=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-06-06T09:56:58Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-06-16T20:01:30Z"}, "message": "memory access sanity checks: abort instead of panic", "tree": {"sha": "4c6283d087c02ed68598d43505d4c74247b9c87b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c6283d087c02ed68598d43505d4c74247b9c87b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0a42332b8ed123a92e9f8e2c329cbd2ad1753e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0a42332b8ed123a92e9f8e2c329cbd2ad1753e9", "html_url": "https://github.com/rust-lang/rust/commit/f0a42332b8ed123a92e9f8e2c329cbd2ad1753e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0a42332b8ed123a92e9f8e2c329cbd2ad1753e9/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8a9c340de32cb70c8bad8af1a4474f805c5a969", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8a9c340de32cb70c8bad8af1a4474f805c5a969", "html_url": "https://github.com/rust-lang/rust/commit/c8a9c340de32cb70c8bad8af1a4474f805c5a969"}], "stats": {"total": 45, "additions": 33, "deletions": 12}, "files": [{"sha": "59809239678a0a3e1fa0d7abfe0d17d0647faeba", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f0a42332b8ed123a92e9f8e2c329cbd2ad1753e9/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0a42332b8ed123a92e9f8e2c329cbd2ad1753e9/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=f0a42332b8ed123a92e9f8e2c329cbd2ad1753e9", "patch": "@@ -2057,9 +2057,14 @@ pub unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n         fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n     }\n \n-    debug_assert!(is_aligned_and_not_null(src), \"attempt to copy from unaligned or null pointer\");\n-    debug_assert!(is_aligned_and_not_null(dst), \"attempt to copy to unaligned or null pointer\");\n-    debug_assert!(is_nonoverlapping(src, dst, count), \"attempt to copy to overlapping memory\");\n+    if cfg!(debug_assertions)\n+        && !(is_aligned_and_not_null(src)\n+            && is_aligned_and_not_null(dst)\n+            && is_nonoverlapping(src, dst, count))\n+    {\n+        // Not panicking to keep codegen impact smaller.\n+        abort();\n+    }\n     copy_nonoverlapping(src, dst, count)\n }\n \n@@ -2122,8 +2127,10 @@ pub unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n         fn copy<T>(src: *const T, dst: *mut T, count: usize);\n     }\n \n-    debug_assert!(is_aligned_and_not_null(src), \"attempt to copy from unaligned or null pointer\");\n-    debug_assert!(is_aligned_and_not_null(dst), \"attempt to copy to unaligned or null pointer\");\n+    if cfg!(debug_assertions) && !(is_aligned_and_not_null(src) && is_aligned_and_not_null(dst)) {\n+        // Not panicking to keep codegen impact smaller.\n+        abort();\n+    }\n     copy(src, dst, count)\n }\n "}, {"sha": "fec638c947ce688c90bf682609af48d570e2a882", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f0a42332b8ed123a92e9f8e2c329cbd2ad1753e9/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0a42332b8ed123a92e9f8e2c329cbd2ad1753e9/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=f0a42332b8ed123a92e9f8e2c329cbd2ad1753e9", "patch": "@@ -70,7 +70,7 @@\n use crate::cmp::Ordering;\n use crate::fmt;\n use crate::hash;\n-use crate::intrinsics::{self, is_aligned_and_not_null, is_nonoverlapping};\n+use crate::intrinsics::{self, abort, is_aligned_and_not_null, is_nonoverlapping};\n use crate::mem::{self, MaybeUninit};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -420,9 +420,14 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n #[inline]\n #[stable(feature = \"swap_nonoverlapping\", since = \"1.27.0\")]\n pub unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n-    debug_assert!(is_aligned_and_not_null(x), \"attempt to swap unaligned or null pointer\");\n-    debug_assert!(is_aligned_and_not_null(y), \"attempt to swap unaligned or null pointer\");\n-    debug_assert!(is_nonoverlapping(x, y, count), \"attempt to swap overlapping memory\");\n+    if cfg!(debug_assertions)\n+        && !(is_aligned_and_not_null(x)\n+            && is_aligned_and_not_null(y)\n+            && is_nonoverlapping(x, y, count))\n+    {\n+        // Not panicking to keep codegen impact smaller.\n+        abort();\n+    }\n \n     let x = x as *mut u8;\n     let y = y as *mut u8;\n@@ -838,7 +843,10 @@ pub unsafe fn read_unaligned<T>(src: *const T) -> T {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn write<T>(dst: *mut T, src: T) {\n-    debug_assert!(is_aligned_and_not_null(dst), \"attempt to write to unaligned or null pointer\");\n+    if cfg!(debug_assertions) && !is_aligned_and_not_null(dst) {\n+        // Not panicking to keep codegen impact smaller.\n+        abort();\n+    }\n     intrinsics::move_val_init(&mut *dst, src)\n }\n \n@@ -1003,7 +1011,10 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n #[inline]\n #[stable(feature = \"volatile\", since = \"1.9.0\")]\n pub unsafe fn read_volatile<T>(src: *const T) -> T {\n-    debug_assert!(is_aligned_and_not_null(src), \"attempt to read from unaligned or null pointer\");\n+    if cfg!(debug_assertions) && !is_aligned_and_not_null(src) {\n+        // Not panicking to keep codegen impact smaller.\n+        abort();\n+    }\n     intrinsics::volatile_load(src)\n }\n \n@@ -1072,7 +1083,10 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n #[inline]\n #[stable(feature = \"volatile\", since = \"1.9.0\")]\n pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n-    debug_assert!(is_aligned_and_not_null(dst), \"attempt to write to unaligned or null pointer\");\n+    if cfg!(debug_assertions) && !is_aligned_and_not_null(dst) {\n+        // Not panicking to keep codegen impact smaller.\n+        abort();\n+    }\n     intrinsics::volatile_store(dst, src);\n }\n "}]}