{"sha": "1ec962fb349f0d4a010af81e7ae0d53fec4e2bb2", "node_id": "C_kwDOAAsO6NoAKDFlYzk2MmZiMzQ5ZjBkNGEwMTBhZjgxZTdhZTBkNTNmZWM0ZTJiYjI", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2022-01-21T18:16:42Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2022-01-21T21:22:24Z"}, "message": "Do not pass OverlapMode down, just create a closure to properly set the filtering", "tree": {"sha": "805b359bcb8707a5501fb971b2512c2f51afe128", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/805b359bcb8707a5501fb971b2512c2f51afe128"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ec962fb349f0d4a010af81e7ae0d53fec4e2bb2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEF0ntrgrd9qf9uuThgTGiTgx5768FAmHrJBAACgkQgTGiTgx5\n76+9bA/8CrwmaIpqylfIOtQgLEp2zzyRTXLYLyyYcXsIAXAvaHqwJbnju1sai3Qz\nl1WtAqJHnE0tJYDjTW6eTGwS6wW+nfyCBatmExkbLPVkoGqCzmsTT1zqS4LuZaMK\n2/1QYk7f9wwUk7JP5frwSGsvid1D0+hMITsXBR5pUhGShlvvfiiGwqoMNeGnhq6G\n7WGxa/AuVIJM48SZOlLELGGTDbcupQukwIR1Su9v/y9pJ2x+a7wPjomF0RO5bPgC\nAeLwnE21T4vSi6Af6Pf8VcsUxB10tkcMwLS24injjlzSExcE8yxlTgpcPssVFv5a\n7b7cago4Y1patJZm+mvK8VslzR+PyDpDVlniCZdViOoJRV7ajJRCV1xFEBIramfs\nxcjCbu2KXUyZtkdh2nyjHh6pRJKAbtloBgPXiCfPKiS312FYeXb6z0DhRN9wXWl+\nN/34LYljMZmM/ZmhL9uEKTmQQ4fD3CCDwqGoZRI0axb2wpzJLilz91hP4uJq/K1f\nbEwF+H1lm0L4q/B2jVhEsQoUbiw8aTAKm1DaqH1PGqZCnx/XxArEXtD//cBkY6X6\n8mWdG9EQQqK/Sphpme3AglaluEoPUMHYNaZ5QfER7ugrsYsBj2QsmNrlrRHOe1SR\nNyRkb3aCfP82SkpWpDuQEn3CG1lYjHj8ijDs9RPkgm26Wq4+1lU=\n=Ff0y\n-----END PGP SIGNATURE-----", "payload": "tree 805b359bcb8707a5501fb971b2512c2f51afe128\nparent d2d25a5be0c45b8aa247a3d0b6c7fda12e9ede9a\nauthor Santiago Pastorino <spastorino@gmail.com> 1642789002 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1642800144 -0300\n\nDo not pass OverlapMode down, just create a closure to properly set the filtering\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ec962fb349f0d4a010af81e7ae0d53fec4e2bb2", "html_url": "https://github.com/rust-lang/rust/commit/1ec962fb349f0d4a010af81e7ae0d53fec4e2bb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ec962fb349f0d4a010af81e7ae0d53fec4e2bb2/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2d25a5be0c45b8aa247a3d0b6c7fda12e9ede9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2d25a5be0c45b8aa247a3d0b6c7fda12e9ede9a", "html_url": "https://github.com/rust-lang/rust/commit/d2d25a5be0c45b8aa247a3d0b6c7fda12e9ede9a"}], "stats": {"total": 49, "additions": 33, "deletions": 16}, "files": [{"sha": "f6101d78f4139d947bed0dc1c1866b5d1c2a8cd8", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/1ec962fb349f0d4a010af81e7ae0d53fec4e2bb2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ec962fb349f0d4a010af81e7ae0d53fec4e2bb2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=1ec962fb349f0d4a010af81e7ae0d53fec4e2bb2", "patch": "@@ -201,17 +201,17 @@ fn overlap_within_probe<'cx, 'tcx>(\n \n     match overlap_mode(tcx, impl1_def_id, impl2_def_id) {\n         OverlapMode::Stable => {\n-            if stable_disjoint(selcx, param_env, &impl1_header, impl2_header, OverlapMode::Stable) {\n+            if stable_disjoint(selcx, param_env, &impl1_header, impl2_header) {\n                 return None;\n             }\n         }\n         OverlapMode::Strict => {\n-            if stable_disjoint(selcx, param_env, &impl1_header, impl2_header, OverlapMode::Strict) {\n+            if strict_disjoint(selcx, param_env, &impl1_header, impl2_header) {\n                 return None;\n             }\n         }\n         OverlapMode::WithNegative => {\n-            if stable_disjoint(selcx, param_env, &impl1_header, impl2_header, OverlapMode::Stable)\n+            if stable_disjoint(selcx, param_env, &impl1_header, impl2_header)\n                 || explicit_disjoint(selcx, impl1_def_id, impl2_def_id)\n                 || explicit_disjoint(selcx, impl2_def_id, impl1_def_id)\n             {\n@@ -244,7 +244,35 @@ fn stable_disjoint<'cx, 'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     impl1_header: &ty::ImplHeader<'tcx>,\n     impl2_header: ty::ImplHeader<'tcx>,\n-    overlap_mode: OverlapMode,\n+) -> bool {\n+    let infcx = selcx.infcx();\n+    let tcx = infcx.tcx;\n+\n+    disjoint_with_filter(selcx, param_env, impl1_header, impl2_header, |selcx, o| {\n+        loose_check(selcx, o) || tcx.features().negative_impls && strict_check(selcx, o)\n+    })\n+}\n+\n+fn strict_disjoint<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    impl1_header: &ty::ImplHeader<'tcx>,\n+    impl2_header: ty::ImplHeader<'tcx>,\n+) -> bool {\n+    disjoint_with_filter(selcx, param_env, impl1_header, impl2_header, |selcx, o| {\n+        strict_check(selcx, o)\n+    })\n+}\n+\n+fn disjoint_with_filter<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    impl1_header: &ty::ImplHeader<'tcx>,\n+    impl2_header: ty::ImplHeader<'tcx>,\n+    mut filter: impl FnMut(\n+        &mut SelectionContext<'cx, 'tcx>,\n+        &rustc_infer::traits::Obligation<'tcx, rustc_middle::ty::Predicate<'tcx>>,\n+    ) -> bool,\n ) -> bool {\n     debug!(\"overlap: impl1_header={:?}\", impl1_header);\n     debug!(\"overlap: impl2_header={:?}\", impl2_header);\n@@ -285,7 +313,6 @@ fn stable_disjoint<'cx, 'tcx>(\n     // hold we need to check if `&'?a str: !Error` holds, if doesn't hold there's overlap because\n     // at some point an impl for `&'?a str: Error` could be added.\n     let infcx = selcx.infcx();\n-    let tcx = infcx.tcx;\n     let opt_failing_obligation = impl1_header\n         .predicates\n         .iter()\n@@ -299,17 +326,7 @@ fn stable_disjoint<'cx, 'tcx>(\n             predicate: p,\n         })\n         .chain(obligations)\n-        .find(|o| {\n-            // if both impl headers are set to strict coherence it means that this will be accepted\n-            // only if it's stated that T: !Trait. So only prove that the negated obligation holds.\n-            match overlap_mode {\n-                OverlapMode::Stable => {\n-                    loose_check(selcx, o) || tcx.features().negative_impls && strict_check(selcx, o)\n-                }\n-                OverlapMode::Strict => strict_check(selcx, o),\n-                OverlapMode::WithNegative => loose_check(selcx, o),\n-            }\n-        });\n+        .find(|o| filter(selcx, o));\n     // FIXME: the call to `selcx.predicate_may_hold_fatal` above should be ported\n     // to the canonical trait query form, `infcx.predicate_may_hold`, once\n     // the new system supports intercrate mode (which coherence needs)."}]}