{"sha": "0af79143ae5b80697acb8a4a78bc3c953dd5478d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhZjc5MTQzYWU1YjgwNjk3YWNiOGE0YTc4YmMzYzk1M2RkNTQ3OGQ=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-10-08T14:58:26Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-10-08T17:17:24Z"}, "message": "codegen_llvm: improve common patterns", "tree": {"sha": "e828b87471749d3cdb69d8ba678b356334b13453", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e828b87471749d3cdb69d8ba678b356334b13453"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0af79143ae5b80697acb8a4a78bc3c953dd5478d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0af79143ae5b80697acb8a4a78bc3c953dd5478d", "html_url": "https://github.com/rust-lang/rust/commit/0af79143ae5b80697acb8a4a78bc3c953dd5478d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0af79143ae5b80697acb8a4a78bc3c953dd5478d/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd41765851fd3b531a1dd8bcb6fcc4ad3e3b750e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd41765851fd3b531a1dd8bcb6fcc4ad3e3b750e", "html_url": "https://github.com/rust-lang/rust/commit/cd41765851fd3b531a1dd8bcb6fcc4ad3e3b750e"}], "stats": {"total": 201, "additions": 86, "deletions": 115}, "files": [{"sha": "1a1aeff3745a6e9d15e137cf349e6476fff3f437", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0af79143ae5b80697acb8a4a78bc3c953dd5478d/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af79143ae5b80697acb8a4a78bc3c953dd5478d/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=0af79143ae5b80697acb8a4a78bc3c953dd5478d", "patch": "@@ -695,14 +695,13 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             // If the value is a boolean, the range is 0..2 and that ultimately\n             // become 0..0 when the type becomes i1, which would be rejected\n             // by the LLVM verifier.\n-            match scalar.value {\n-                layout::Int(..) if !scalar.is_bool() => {\n+            if let layout::Int(..) = scalar.value {\n+                if !scalar.is_bool() {\n                     let range = scalar.valid_range_exclusive(bx.cx);\n                     if range.start != range.end {\n                         bx.range_metadata(callsite, range);\n                     }\n                 }\n-                _ => {}\n             }\n         }\n         for arg in &self.args {"}, {"sha": "0abc26d6cfbc44fc452715a465c04348e42405bb", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0af79143ae5b80697acb8a4a78bc3c953dd5478d/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af79143ae5b80697acb8a4a78bc3c953dd5478d/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=0af79143ae5b80697acb8a4a78bc3c953dd5478d", "patch": "@@ -94,9 +94,8 @@ pub fn set_probestack(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     // Currently stack probes seem somewhat incompatible with the address\n     // sanitizer. With asan we're already protected from stack overflow anyway\n     // so we don't really need stack probes regardless.\n-    match cx.sess().opts.debugging_opts.sanitizer {\n-        Some(Sanitizer::Address) => return,\n-        _ => {}\n+    if let Some(Sanitizer::Address) = cx.sess().opts.debugging_opts.sanitizer {\n+        return\n     }\n \n     // probestack doesn't play nice either with pgo-gen."}, {"sha": "0c2a423a18fa4fb8076d609d21afec0374742fd1", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0af79143ae5b80697acb8a4a78bc3c953dd5478d/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af79143ae5b80697acb8a4a78bc3c953dd5478d/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=0af79143ae5b80697acb8a4a78bc3c953dd5478d", "patch": "@@ -495,10 +495,8 @@ pub fn codegen_instance<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, instance: Instance<'\n     let sig = common::ty_fn_sig(cx, fn_ty);\n     let sig = cx.tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n \n-    let lldecl = match cx.instances.borrow().get(&instance) {\n-        Some(&val) => val,\n-        None => bug!(\"Instance `{:?}` not already declared\", instance)\n-    };\n+    let lldecl = cx.instances.borrow().get(&instance).cloned().unwrap_or_else(||\n+        bug!(\"Instance `{:?}` not already declared\", instance));\n \n     cx.stats.borrow_mut().n_closures += 1;\n \n@@ -836,12 +834,7 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         .iter()\n         .any(|(_, list)| {\n             use rustc::middle::dependency_format::Linkage;\n-            list.iter().any(|linkage| {\n-                match linkage {\n-                    Linkage::Dynamic => true,\n-                    _ => false,\n-                }\n-            })\n+            list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n         });\n     let allocator_module = if any_dynamic_crate {\n         None"}, {"sha": "c08937fa9b9162669bcb04f021cbde86c2aa6736", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0af79143ae5b80697acb8a4a78bc3c953dd5478d/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af79143ae5b80697acb8a4a78bc3c953dd5478d/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=0af79143ae5b80697acb8a4a78bc3c953dd5478d", "patch": "@@ -336,16 +336,13 @@ pub fn langcall(tcx: TyCtxt,\n                 msg: &str,\n                 li: LangItem)\n                 -> DefId {\n-    match tcx.lang_items().require(li) {\n-        Ok(id) => id,\n-        Err(s) => {\n-            let msg = format!(\"{} {}\", msg, s);\n-            match span {\n-                Some(span) => tcx.sess.span_fatal(span, &msg[..]),\n-                None => tcx.sess.fatal(&msg[..]),\n-            }\n+    tcx.lang_items().require(li).unwrap_or_else(|s| {\n+        let msg = format!(\"{} {}\", msg, s);\n+        match span {\n+            Some(span) => tcx.sess.span_fatal(span, &msg[..]),\n+            None => tcx.sess.fatal(&msg[..]),\n         }\n-    }\n+    })\n }\n \n // To avoid UB from LLVM, these two functions mask RHS with an"}, {"sha": "9228870bf3a5c2105d84fe298aca420e165524fb", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0af79143ae5b80697acb8a4a78bc3c953dd5478d/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af79143ae5b80697acb8a4a78bc3c953dd5478d/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=0af79143ae5b80697acb8a4a78bc3c953dd5478d", "patch": "@@ -249,14 +249,13 @@ fn check_and_apply_linkage(\n         // extern \"C\" fn() from being non-null, so we can't just declare a\n         // static and call it a day. Some linkages (like weak) will make it such\n         // that the static actually has a null value.\n-        let llty2 = match ty.sty {\n-            ty::RawPtr(ref mt) => cx.layout_of(mt.ty).llvm_type(cx),\n-            _ => {\n-                if span.is_some() {\n-                    cx.sess().span_fatal(span.unwrap(), \"must have type `*const T` or `*mut T`\")\n-                } else {\n-                    bug!(\"must have type `*const T` or `*mut T`\")\n-                }\n+        let llty2 = if let ty::RawPtr(ref mt) = ty.sty {\n+            cx.layout_of(mt.ty).llvm_type(cx)\n+        } else {\n+            if let Some(span) = span {\n+                cx.sess().span_fatal(span, \"must have type `*const T` or `*mut T`\")\n+            } else {\n+                bug!(\"must have type `*const T` or `*mut T`\")\n             }\n         };\n         unsafe {\n@@ -273,9 +272,9 @@ fn check_and_apply_linkage(\n             let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n             real_name.push_str(&sym);\n             let g2 = declare::define_global(cx, &real_name, llty).unwrap_or_else(||{\n-                if span.is_some() {\n+                if let Some(span) = span {\n                     cx.sess().span_fatal(\n-                        span.unwrap(),\n+                        span,\n                         &format!(\"symbol `{}` is already defined\", &sym)\n                     )\n                 } else {"}, {"sha": "60cdea29fb78416a858317ee67c2df1c2392a1b3", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0af79143ae5b80697acb8a4a78bc3c953dd5478d/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af79143ae5b80697acb8a4a78bc3c953dd5478d/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=0af79143ae5b80697acb8a4a78bc3c953dd5478d", "patch": "@@ -318,10 +318,8 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n         if let Some(v) = self.intrinsics.borrow().get(key).cloned() {\n             return v;\n         }\n-        match declare_intrinsic(self, key) {\n-            Some(v) => return v,\n-            None => bug!(\"unknown intrinsic '{}'\", key)\n-        }\n+\n+        declare_intrinsic(self, key).unwrap_or_else(|| bug!(\"unknown intrinsic '{}'\", key))\n     }\n \n     /// Generate a new symbol name with the given prefix. This symbol name must\n@@ -465,9 +463,10 @@ impl LayoutOf for &'a CodegenCx<'ll, 'tcx> {\n \n     fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n         self.tcx.layout_of(ty::ParamEnv::reveal_all().and(ty))\n-            .unwrap_or_else(|e| match e {\n-                LayoutError::SizeOverflow(_) => self.sess().fatal(&e.to_string()),\n-                _ => bug!(\"failed to get layout for `{}`: {}\", ty, e)\n+            .unwrap_or_else(|e| if let LayoutError::SizeOverflow(_) = e {\n+                self.sess().fatal(&e.to_string())\n+            } else {\n+                bug!(\"failed to get layout for `{}`: {}\", ty, e)\n             })\n     }\n }"}, {"sha": "9e6c84071f789df569a4422041c2c41b6533b3a5", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 52, "deletions": 66, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/0af79143ae5b80697acb8a4a78bc3c953dd5478d/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af79143ae5b80697acb8a4a78bc3c953dd5478d/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=0af79143ae5b80697acb8a4a78bc3c953dd5478d", "patch": "@@ -539,10 +539,9 @@ pub fn codegen_intrinsic_call(\n         }\n \n         _ => {\n-            let intr = match Intrinsic::find(&name) {\n-                Some(intr) => intr,\n-                None => bug!(\"unknown intrinsic '{}'\", name),\n-            };\n+            let intr = Intrinsic::find(&name).unwrap_or_else(||\n+                bug!(\"unknown intrinsic '{}'\", name));\n+\n             fn one<T>(x: Vec<T>) -> T {\n                 assert_eq!(x.len(), 1);\n                 x.into_iter().next().unwrap()\n@@ -1071,11 +1070,8 @@ fn generic_simd_intrinsic(\n     }\n \n     if name.starts_with(\"simd_shuffle\") {\n-        let n: usize = match name[\"simd_shuffle\".len()..].parse() {\n-            Ok(n) => n,\n-            Err(_) => span_bug!(span,\n-                                \"bad `simd_shuffle` instruction only caught in codegen?\")\n-        };\n+        let n: usize = name[\"simd_shuffle\".len()..].parse().unwrap_or_else(|_|\n+            span_bug!(span, \"bad `simd_shuffle` instruction only caught in codegen?\"));\n \n         require_simd!(ret_ty, \"return\");\n \n@@ -1216,63 +1212,53 @@ fn generic_simd_intrinsic(\n                         &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n                         None);\n         unsafe { llvm::LLVMRustSetHasUnsafeAlgebra(c) };\n-        return Ok(c);\n-    }\n-\n-    if name == \"simd_fsqrt\" {\n-        return simd_simple_float_intrinsic(\"sqrt\", in_elem, in_ty, in_len, bx, span, args);\n-    }\n-\n-    if name == \"simd_fsin\" {\n-        return simd_simple_float_intrinsic(\"sin\", in_elem, in_ty, in_len, bx, span, args);\n-    }\n-\n-    if name == \"simd_fcos\" {\n-        return simd_simple_float_intrinsic(\"cos\", in_elem, in_ty, in_len, bx, span, args);\n-    }\n-\n-    if name == \"simd_fabs\" {\n-        return simd_simple_float_intrinsic(\"fabs\", in_elem, in_ty, in_len, bx, span, args);\n+        Ok(c)\n     }\n \n-    if name == \"simd_floor\" {\n-        return simd_simple_float_intrinsic(\"floor\", in_elem, in_ty, in_len, bx, span, args);\n-    }\n-\n-    if name == \"simd_ceil\" {\n-        return simd_simple_float_intrinsic(\"ceil\", in_elem, in_ty, in_len, bx, span, args);\n-    }\n-\n-    if name == \"simd_fexp\" {\n-        return simd_simple_float_intrinsic(\"exp\", in_elem, in_ty, in_len, bx, span, args);\n-    }\n-\n-    if name == \"simd_fexp2\" {\n-        return simd_simple_float_intrinsic(\"exp2\", in_elem, in_ty, in_len, bx, span, args);\n-    }\n-\n-    if name == \"simd_flog10\" {\n-        return simd_simple_float_intrinsic(\"log10\", in_elem, in_ty, in_len, bx, span, args);\n-    }\n-\n-    if name == \"simd_flog2\" {\n-        return simd_simple_float_intrinsic(\"log2\", in_elem, in_ty, in_len, bx, span, args);\n-    }\n-\n-    if name == \"simd_flog\" {\n-        return simd_simple_float_intrinsic(\"log\", in_elem, in_ty, in_len, bx, span, args);\n-    }\n-\n-    if name == \"simd_fpowi\" {\n-        return simd_simple_float_intrinsic(\"powi\", in_elem, in_ty, in_len, bx, span, args);\n-    }\n-\n-    if name == \"simd_fpow\"  {\n-        return simd_simple_float_intrinsic(\"pow\", in_elem, in_ty, in_len, bx, span, args);\n-    }\n-\n-    if name == \"simd_fma\" {\n-        return simd_simple_float_intrinsic(\"fma\", in_elem, in_ty, in_len, bx, span, args);\n+    match name {\n+        \"simd_fsqrt\" => {\n+            return simd_simple_float_intrinsic(\"sqrt\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_fsin\" => {\n+            return simd_simple_float_intrinsic(\"sin\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_fcos\" => {\n+            return simd_simple_float_intrinsic(\"cos\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_fabs\" => {\n+            return simd_simple_float_intrinsic(\"fabs\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_floor\" => {\n+            return simd_simple_float_intrinsic(\"floor\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_ceil\" => {\n+            return simd_simple_float_intrinsic(\"ceil\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_fexp\" => {\n+            return simd_simple_float_intrinsic(\"exp\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_fexp2\" => {\n+            return simd_simple_float_intrinsic(\"exp2\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_flog10\" => {\n+            return simd_simple_float_intrinsic(\"log10\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_flog2\" => {\n+            return simd_simple_float_intrinsic(\"log2\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_flog\" => {\n+            return simd_simple_float_intrinsic(\"log\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_fpowi\" => {\n+            return simd_simple_float_intrinsic(\"powi\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_fpow\" => {\n+            return simd_simple_float_intrinsic(\"pow\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        \"simd_fma\" => {\n+            return simd_simple_float_intrinsic(\"fma\", in_elem, in_ty, in_len, bx, span, args);\n+        }\n+        _ => { /* fallthrough */ }\n     }\n \n     // FIXME: use:\n@@ -1364,7 +1350,7 @@ fn generic_simd_intrinsic(\n             }\n         };\n         assert!(pointer_count > 0);\n-        assert!(pointer_count - 1 == ptr_count(arg_tys[0].simd_type(tcx)));\n+        assert_eq!(pointer_count - 1, ptr_count(arg_tys[0].simd_type(tcx)));\n         assert_eq!(underlying_ty, non_ptr(arg_tys[0].simd_type(tcx)));\n \n         // The element type of the third argument must be a signed integer type of any width:\n@@ -1461,7 +1447,7 @@ fn generic_simd_intrinsic(\n             }\n         };\n         assert!(pointer_count > 0);\n-        assert!(pointer_count - 1 == ptr_count(arg_tys[0].simd_type(tcx)));\n+        assert_eq!(pointer_count - 1, ptr_count(arg_tys[0].simd_type(tcx)));\n         assert_eq!(underlying_ty, non_ptr(arg_tys[0].simd_type(tcx)));\n \n         // The element type of the third argument must be a signed integer type of any width:"}, {"sha": "03ded64e642355706e8c7b5471028a0ec8a5e30e", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0af79143ae5b80697acb8a4a78bc3c953dd5478d/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0af79143ae5b80697acb8a4a78bc3c953dd5478d/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=0af79143ae5b80697acb8a4a78bc3c953dd5478d", "patch": "@@ -65,13 +65,12 @@ fn uncached_llvm_type<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             let mut name = String::with_capacity(32);\n             let printer = DefPathBasedNames::new(cx.tcx, true, true);\n             printer.push_type_name(layout.ty, &mut name);\n-            match (&layout.ty.sty, &layout.variants) {\n-                (&ty::Adt(def, _), &layout::Variants::Single { index }) => {\n-                    if def.is_enum() && !def.variants.is_empty() {\n-                        write!(&mut name, \"::{}\", def.variants[index].name).unwrap();\n-                    }\n+            if let (&ty::Adt(def, _), &layout::Variants::Single { index })\n+                 = (&layout.ty.sty, &layout.variants)\n+            {\n+                if def.is_enum() && !def.variants.is_empty() {\n+                    write!(&mut name, \"::{}\", def.variants[index].name).unwrap();\n                 }\n-                _ => {}\n             }\n             Some(name)\n         }\n@@ -155,7 +154,7 @@ fn struct_llfields<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         debug!(\"struct_llfields: pad_bytes: {:?} offset: {:?} stride: {:?}\",\n                padding, offset, layout.size);\n         result.push(Type::padding_filler(cx, padding, padding_align));\n-        assert!(result.len() == 1 + field_count * 2);\n+        assert_eq!(result.len(), 1 + field_count * 2);\n     } else {\n         debug!(\"struct_llfields: offset: {:?} stride: {:?}\",\n                offset, layout.size);"}]}