{"sha": "0517acd54353869b2fbfc50af61ea7bd1fd309e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1MTdhY2Q1NDM1Mzg2OWIyZmJmYzUwYWY2MWVhN2JkMWZkMzA5ZTA=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2021-03-07T23:59:10Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2021-03-10T10:21:43Z"}, "message": "Remove the -Zinsert-sideeffect\n\nThis removes all of the code we had in place to work-around LLVM's\nhandling of forward progress. From this removal excluded is a workaround\nwhere we'd insert a `sideeffect` into clearly infinite loops such as\n`loop {}`. This code remains conditionally effective when the LLVM\nversion is earlier than 12.0, which fixed the forward progress related\nmiscompilations at their root.", "tree": {"sha": "a3670ca840e1c6def8f4be36a7419f2682488863", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3670ca840e1c6def8f4be36a7419f2682488863"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0517acd54353869b2fbfc50af61ea7bd1fd309e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0517acd54353869b2fbfc50af61ea7bd1fd309e0", "html_url": "https://github.com/rust-lang/rust/commit/0517acd54353869b2fbfc50af61ea7bd1fd309e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0517acd54353869b2fbfc50af61ea7bd1fd309e0/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "861872bc453bde79b83ff99d443d035225f10e87", "url": "https://api.github.com/repos/rust-lang/rust/commits/861872bc453bde79b83ff99d443d035225f10e87", "html_url": "https://github.com/rust-lang/rust/commit/861872bc453bde79b83ff99d443d035225f10e87"}], "stats": {"total": 139, "additions": 52, "deletions": 87}, "files": [{"sha": "f445d708c94f60d1b72cba2d75f97e704d7c7687", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0517acd54353869b2fbfc50af61ea7bd1fd309e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0517acd54353869b2fbfc50af61ea7bd1fd309e0/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=0517acd54353869b2fbfc50af61ea7bd1fd309e0", "patch": "@@ -334,8 +334,11 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         self.call(expect, &[cond, self.const_bool(expected)], None)\n     }\n \n-    fn sideeffect(&mut self, unconditional: bool) {\n-        if unconditional || self.tcx.sess.opts.debugging_opts.insert_sideeffect {\n+    fn sideeffect(&mut self) {\n+        // This kind of check would make a ton of sense in the caller, but currently the only\n+        // caller of this function is in `rustc_codegen_ssa`, which is agnostic to whether LLVM\n+        // codegen backend being used, and so is unable to check the LLVM version.\n+        if unsafe { llvm::LLVMRustVersionMajor() } < 12 {\n             let fnname = self.get_intrinsic(&(\"llvm.sideeffect\"));\n             self.call(fnname, &[], None);\n         }\n@@ -390,7 +393,6 @@ fn codegen_msvc_try(\n ) {\n     let llfn = get_rust_try_fn(bx, &mut |mut bx| {\n         bx.set_personality_fn(bx.eh_personality());\n-        bx.sideeffect(false);\n \n         let mut normal = bx.build_sibling_block(\"normal\");\n         let mut catchswitch = bx.build_sibling_block(\"catchswitch\");\n@@ -552,9 +554,6 @@ fn codegen_gnu_try(\n         //      (%ptr, _) = landingpad\n         //      call %catch_func(%data, %ptr)\n         //      ret 1\n-\n-        bx.sideeffect(false);\n-\n         let mut then = bx.build_sibling_block(\"then\");\n         let mut catch = bx.build_sibling_block(\"catch\");\n \n@@ -614,9 +613,6 @@ fn codegen_emcc_try(\n         //      %catch_data[1] = %is_rust_panic\n         //      call %catch_func(%data, %catch_data)\n         //      ret 1\n-\n-        bx.sideeffect(false);\n-\n         let mut then = bx.build_sibling_block(\"then\");\n         let mut catch = bx.build_sibling_block(\"catch\");\n "}, {"sha": "a8dda100763aae7c2aa076f0c609cf306c385455", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 8, "deletions": 50, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/0517acd54353869b2fbfc50af61ea7bd1fd309e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0517acd54353869b2fbfc50af61ea7bd1fd309e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=0517acd54353869b2fbfc50af61ea7bd1fd309e0", "patch": "@@ -146,24 +146,6 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n             }\n         }\n     }\n-\n-    // Generate sideeffect intrinsic if jumping to any of the targets can form\n-    // a loop.\n-    fn maybe_sideeffect<Bx: BuilderMethods<'a, 'tcx>>(\n-        &self,\n-        mir: &'tcx mir::Body<'tcx>,\n-        bx: &mut Bx,\n-        targets: &[mir::BasicBlock],\n-    ) {\n-        if bx.tcx().sess.opts.debugging_opts.insert_sideeffect {\n-            if targets.iter().any(|&target| {\n-                target <= self.bb\n-                    && target.start_location().is_predecessor_of(self.bb.start_location(), mir)\n-            }) {\n-                bx.sideeffect(false);\n-            }\n-        }\n-    }\n }\n \n /// Codegen implementations for some terminator variants.\n@@ -198,8 +180,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let discr = self.codegen_operand(&mut bx, &discr);\n         // `switch_ty` is redundant, sanity-check that.\n         assert_eq!(discr.layout.ty, switch_ty);\n-        helper.maybe_sideeffect(self.mir, &mut bx, targets.all_targets());\n-\n         let mut target_iter = targets.iter();\n         if target_iter.len() == 1 {\n             // If there are two targets (one conditional, one fallback), emit br instead of switch\n@@ -308,7 +288,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n             // we don't actually need to drop anything.\n-            helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n             helper.funclet_br(self, &mut bx, target);\n             return;\n         }\n@@ -337,7 +316,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n             _ => (bx.get_fn_addr(drop_fn), FnAbi::of_instance(&bx, drop_fn, &[])),\n         };\n-        helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n         helper.do_call(\n             self,\n             &mut bx,\n@@ -379,7 +357,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // Don't codegen the panic block if success if known.\n         if const_cond == Some(expected) {\n-            helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n             helper.funclet_br(self, &mut bx, target);\n             return;\n         }\n@@ -390,7 +367,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // Create the failure block and the conditional branch to it.\n         let lltarget = helper.llblock(self, target);\n         let panic_block = self.new_block(\"panic\");\n-        helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n         if expected {\n             bx.cond_br(cond, lltarget, panic_block.llbb());\n         } else {\n@@ -491,9 +467,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let fn_abi = FnAbi::of_instance(bx, instance, &[]);\n                 let llfn = bx.get_fn_addr(instance);\n \n-                if let Some((_, target)) = destination.as_ref() {\n-                    helper.maybe_sideeffect(self.mir, bx, &[*target]);\n-                }\n                 // Codegen the actual panic invoke/call.\n                 helper.do_call(\n                     self,\n@@ -507,7 +480,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             } else {\n                 // a NOP\n                 let target = destination.as_ref().unwrap().1;\n-                helper.maybe_sideeffect(self.mir, bx, &[target]);\n                 helper.funclet_br(self, bx, target)\n             }\n             true\n@@ -551,7 +523,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         if let Some(ty::InstanceDef::DropGlue(_, None)) = def {\n             // Empty drop glue; a no-op.\n             let &(_, target) = destination.as_ref().unwrap();\n-            helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n             helper.funclet_br(self, &mut bx, target);\n             return;\n         }\n@@ -586,7 +557,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             if let Some(destination_ref) = destination.as_ref() {\n                 let &(dest, target) = destination_ref;\n                 self.codegen_transmute(&mut bx, &args[0], dest);\n-                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n                 helper.funclet_br(self, &mut bx, target);\n             } else {\n                 // If we are trying to transmute to an uninhabited type,\n@@ -634,8 +604,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     location.val.store(&mut bx, tmp);\n                 }\n                 self.store_return(&mut bx, ret_dest, &fn_abi.ret, location.immediate());\n-\n-                helper.maybe_sideeffect(self.mir, &mut bx, &[*target]);\n                 helper.funclet_br(self, &mut bx, *target);\n             }\n             return;\n@@ -700,7 +668,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n \n                 if let Some((_, target)) = *destination {\n-                    helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n                     helper.funclet_br(self, &mut bx, target);\n                 } else {\n                     bx.unreachable();\n@@ -817,9 +784,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             _ => span_bug!(span, \"no llfn for call\"),\n         };\n \n-        if let Some((_, target)) = destination.as_ref() {\n-            helper.maybe_sideeffect(self.mir, &mut bx, &[*target]);\n-        }\n         helper.do_call(\n             self,\n             &mut bx,\n@@ -969,22 +933,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n             mir::TerminatorKind::Goto { target } => {\n                 if bb == target {\n-                    // This is an unconditional branch back to this same basic\n-                    // block. That means we have something like a `loop {}`\n-                    // statement. Currently LLVM miscompiles this because it\n-                    // assumes forward progress. We want to prevent this in all\n-                    // cases, but that has a fairly high cost to compile times\n-                    // currently. Instead, try to handle this specific case\n-                    // which comes up commonly in practice (e.g., in embedded\n-                    // code).\n+                    // This is an unconditional branch back to this same basic block. That means we\n+                    // have something like a `loop {}` statement. LLVM versions before 12.0\n+                    // miscompile this because they assume forward progress. For older versions\n+                    // try to handle just this specific case which comes up commonly in practice\n+                    // (e.g., in embedded code).\n                     //\n-                    // The `true` here means we insert side effects regardless\n-                    // of -Zinsert-sideeffect being passed on unconditional\n-                    // branching to the same basic block.\n-                    bx.sideeffect(true);\n-                } else {\n-                    helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+                    // NB: the `sideeffect` currently checks for the LLVM version used internally.\n+                    bx.sideeffect();\n                 }\n+\n                 helper.funclet_br(self, &mut bx, target);\n             }\n "}, {"sha": "3f945478213494d7d071f6e5af4bb5f111b8a5d5", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0517acd54353869b2fbfc50af61ea7bd1fd309e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0517acd54353869b2fbfc50af61ea7bd1fd309e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=0517acd54353869b2fbfc50af61ea7bd1fd309e0", "patch": "@@ -149,8 +149,6 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         bx.set_personality_fn(cx.eh_personality());\n     }\n \n-    bx.sideeffect(false);\n-\n     let cleanup_kinds = analyze::cleanup_kinds(&mir);\n     // Allocate a `Block` for every basic block, except\n     // the start block, if nothing loops back to it."}, {"sha": "777436ad2ae8fd9290405e131d2c15361958a25d", "filename": "compiler/rustc_codegen_ssa/src/traits/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0517acd54353869b2fbfc50af61ea7bd1fd309e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0517acd54353869b2fbfc50af61ea7bd1fd309e0/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs?ref=0517acd54353869b2fbfc50af61ea7bd1fd309e0", "patch": "@@ -20,9 +20,10 @@ pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n     fn abort(&mut self);\n     fn assume(&mut self, val: Self::Value);\n     fn expect(&mut self, cond: Self::Value, expected: bool) -> Self::Value;\n-    /// Normally, sideeffect is only emitted if -Zinsert-sideeffect is passed;\n-    /// in some cases though we want to emit it regardless.\n-    fn sideeffect(&mut self, unconditional: bool);\n+    /// Emits a forced side effect.\n+    ///\n+    /// Currently has any effect only when LLVM versions prior to 12.0 are used as the backend.\n+    fn sideeffect(&mut self);\n     /// Trait method used to inject `va_start` on the \"spoofed\" `VaListImpl` in\n     /// Rust defined C-variadic functions.\n     fn va_start(&mut self, val: Self::Value) -> Self::Value;"}, {"sha": "93ba2e6a4f1e9c1794944ef0897c5de041216b49", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0517acd54353869b2fbfc50af61ea7bd1fd309e0/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0517acd54353869b2fbfc50af61ea7bd1fd309e0/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=0517acd54353869b2fbfc50af61ea7bd1fd309e0", "patch": "@@ -560,7 +560,6 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(inline_mir, Some(true));\n     tracked!(inline_mir_threshold, Some(123));\n     tracked!(inline_mir_hint_threshold, Some(123));\n-    tracked!(insert_sideeffect, true);\n     tracked!(instrument_coverage, true);\n     tracked!(instrument_mcount, true);\n     tracked!(link_only, true);"}, {"sha": "d9e5a186073b62a2c5b2c86c38e498158765baf0", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0517acd54353869b2fbfc50af61ea7bd1fd309e0/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0517acd54353869b2fbfc50af61ea7bd1fd309e0/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=0517acd54353869b2fbfc50af61ea7bd1fd309e0", "patch": "@@ -967,10 +967,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"control whether `#[inline]` functions are in all CGUs\"),\n     input_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"gather statistics about the input (default: no)\"),\n-    insert_sideeffect: bool = (false, parse_bool, [TRACKED],\n-        \"fix undefined behavior when a thread doesn't eventually make progress \\\n-        (such as entering an empty infinite loop) by inserting llvm.sideeffect \\\n-        (default: no)\"),\n     instrument_coverage: bool = (false, parse_bool, [TRACKED],\n         \"instrument the generated code to support LLVM source-based code coverage \\\n         reports (note, the compiler build config must include `profiler = true`, \\"}, {"sha": "e54298eed059ed69370296d1c37a6e603d291234", "filename": "src/test/codegen/loop.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/861872bc453bde79b83ff99d443d035225f10e87/src%2Ftest%2Fcodegen%2Floop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/861872bc453bde79b83ff99d443d035225f10e87/src%2Ftest%2Fcodegen%2Floop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Floop.rs?ref=861872bc453bde79b83ff99d443d035225f10e87", "patch": "@@ -1,15 +0,0 @@\n-// compile-flags: -C opt-level=3\n-\n-#![crate_type = \"lib\"]\n-\n-// CHECK-LABEL: @check_loop\n-#[no_mangle]\n-pub fn check_loop() -> u8 {\n-    // CHECK-NOT: unreachable\n-    call_looper()\n-}\n-\n-#[no_mangle]\n-fn call_looper() -> ! {\n-    loop {}\n-}"}, {"sha": "8f9a53d19d43a8bfeb7cb6dd430208295c1024b6", "filename": "src/test/codegen/non-terminate/infinite-loop-1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0517acd54353869b2fbfc50af61ea7bd1fd309e0/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-loop-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0517acd54353869b2fbfc50af61ea7bd1fd309e0/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-loop-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-loop-1.rs?ref=0517acd54353869b2fbfc50af61ea7bd1fd309e0", "patch": "@@ -1,4 +1,5 @@\n-// compile-flags: -C opt-level=3 -Z insert-sideeffect\n+// min-llvm-version: 12.0\n+// compile-flags: -C opt-level=3\n \n #![crate_type = \"lib\"]\n "}, {"sha": "a4c76de1e3b8a452d752b814411d408aa44dab05", "filename": "src/test/codegen/non-terminate/infinite-loop-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0517acd54353869b2fbfc50af61ea7bd1fd309e0/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-loop-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0517acd54353869b2fbfc50af61ea7bd1fd309e0/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-loop-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-loop-2.rs?ref=0517acd54353869b2fbfc50af61ea7bd1fd309e0", "patch": "@@ -1,4 +1,5 @@\n-// compile-flags: -C opt-level=3 -Z insert-sideeffect\n+// min-llvm-version: 12.0\n+// compile-flags: -C opt-level=3\n \n #![crate_type = \"lib\"]\n "}, {"sha": "ccb22afbc7ae092a271037771331e4f6fc90693f", "filename": "src/test/codegen/non-terminate/infinite-recursion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0517acd54353869b2fbfc50af61ea7bd1fd309e0/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0517acd54353869b2fbfc50af61ea7bd1fd309e0/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnon-terminate%2Finfinite-recursion.rs?ref=0517acd54353869b2fbfc50af61ea7bd1fd309e0", "patch": "@@ -1,4 +1,5 @@\n-// compile-flags: -C opt-level=3 -Z insert-sideeffect\n+// min-llvm-version: 12.0\n+// compile-flags: -C opt-level=3\n \n #![crate_type = \"lib\"]\n "}, {"sha": "896b7e8721cb741fb6d659216fd297851ce0f0a8", "filename": "src/test/codegen/non-terminate/nonempty-infinite-loop.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0517acd54353869b2fbfc50af61ea7bd1fd309e0/src%2Ftest%2Fcodegen%2Fnon-terminate%2Fnonempty-infinite-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0517acd54353869b2fbfc50af61ea7bd1fd309e0/src%2Ftest%2Fcodegen%2Fnon-terminate%2Fnonempty-infinite-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnon-terminate%2Fnonempty-infinite-loop.rs?ref=0517acd54353869b2fbfc50af61ea7bd1fd309e0", "patch": "@@ -0,0 +1,29 @@\n+// min-llvm-version: 12.0\n+// compile-flags: -C opt-level=3\n+\n+#![crate_type = \"lib\"]\n+\n+// Verify that we don't miscompile this even if rustc didn't apply the trivial loop detection to\n+// insert the sideeffect intrinsic.\n+\n+fn infinite_loop() -> u8 {\n+    let mut x = 0;\n+    // CHECK-NOT: sideeffect\n+    loop {\n+        if x == 42 {\n+            x = 0;\n+        } else {\n+            x = 42;\n+        }\n+    }\n+}\n+\n+// CHECK-LABEL: @test\n+#[no_mangle]\n+fn test() -> u8 {\n+    // CHECK-NOT: unreachable\n+    // CHECK: br label %{{.+}}\n+    // CHECK-NOT: unreachable\n+    let x = infinite_loop();\n+    x\n+}"}]}