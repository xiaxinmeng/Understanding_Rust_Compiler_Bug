{"sha": "297109ea3263a4ea90a7143a82e46903a8890269", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5NzEwOWVhMzI2M2E0ZWE5MGE3MTQzYTgyZTQ2OTAzYTg4OTAyNjk=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-06-24T17:02:24Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-06-29T22:53:32Z"}, "message": "proc-macro: Use transparent marks for call-site hygiene", "tree": {"sha": "2a764a2ec37b900b163e03032ff16a2003597fd0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a764a2ec37b900b163e03032ff16a2003597fd0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/297109ea3263a4ea90a7143a82e46903a8890269", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/297109ea3263a4ea90a7143a82e46903a8890269", "html_url": "https://github.com/rust-lang/rust/commit/297109ea3263a4ea90a7143a82e46903a8890269", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/297109ea3263a4ea90a7143a82e46903a8890269/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99ecdb3f5fc49efb3eccdd10fbe12dc98623a938", "url": "https://api.github.com/repos/rust-lang/rust/commits/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938", "html_url": "https://github.com/rust-lang/rust/commit/99ecdb3f5fc49efb3eccdd10fbe12dc98623a938"}], "stats": {"total": 152, "additions": 116, "deletions": 36}, "files": [{"sha": "a82e3dcb0600cbf8b78d51f28196e2903e3f11c6", "filename": "src/libproc_macro/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/297109ea3263a4ea90a7143a82e46903a8890269/src%2Flibproc_macro%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297109ea3263a4ea90a7143a82e46903a8890269/src%2Flibproc_macro%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fdiagnostic.rs?ref=297109ea3263a4ea90a7143a82e46903a8890269", "patch": "@@ -97,7 +97,7 @@ impl Diagnostic {\n     /// Emit the diagnostic.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn emit(self) {\n-        ::__internal::with_sess(move |(sess, _)| {\n+        ::__internal::with_sess(move |sess, _| {\n             let handler = &sess.span_diagnostic;\n             let level = __internal::level_to_internal_level(self.level);\n             let mut diag = rustc::DiagnosticBuilder::new(handler, level, &*self.message);"}, {"sha": "e580b459196dfc9e287eacbe401b57f09c1c612c", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 54, "deletions": 34, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/297109ea3263a4ea90a7143a82e46903a8890269/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297109ea3263a4ea90a7143a82e46903a8890269/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=297109ea3263a4ea90a7143a82e46903a8890269", "patch": "@@ -58,8 +58,7 @@ use syntax::parse::{self, token};\n use syntax::symbol::{keywords, Symbol};\n use syntax::tokenstream;\n use syntax::parse::lexer::{self, comments};\n-use syntax_pos::{FileMap, Pos, SyntaxContext, FileName};\n-use syntax_pos::hygiene::Mark;\n+use syntax_pos::{FileMap, Pos, FileName};\n \n /// The main type provided by this crate, representing an abstract stream of\n /// tokens, or, more specifically, a sequence of token trees.\n@@ -109,6 +108,7 @@ impl TokenStream {\n /// Attempts to break the string into tokens and parse those tokens into a token stream.\n /// May fail for a number of reasons, for example, if the string contains unbalanced delimiters\n /// or characters not existing in the language.\n+/// All tokens in the parsed stream get `Span::call_site()` spans.\n ///\n /// NOTE: Some errors may cause panics instead of returning `LexError`. We reserve the right to\n /// change these errors into `LexError`s later.\n@@ -117,17 +117,10 @@ impl FromStr for TokenStream {\n     type Err = LexError;\n \n     fn from_str(src: &str) -> Result<TokenStream, LexError> {\n-        __internal::with_sess(|(sess, mark)| {\n-            let src = src.to_string();\n-            let name = FileName::ProcMacroSourceCode;\n-            let expn_info = mark.expn_info().unwrap();\n-            let call_site = expn_info.call_site;\n-            // notify the expansion info that it is unhygienic\n-            let mark = Mark::fresh(mark);\n-            mark.set_expn_info(expn_info);\n-            let span = call_site.with_ctxt(SyntaxContext::empty().apply_mark(mark));\n-            let stream = parse::parse_stream_from_source_str(name, src, sess, Some(span));\n-            Ok(__internal::token_stream_wrap(stream))\n+        __internal::with_sess(|sess, data| {\n+            Ok(__internal::token_stream_wrap(parse::parse_stream_from_source_str(\n+                FileName::ProcMacroSourceCode, src.to_string(), sess, Some(data.call_site.0)\n+            )))\n         })\n     }\n }\n@@ -284,10 +277,7 @@ impl Span {\n     /// A span that resolves at the macro definition site.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn def_site() -> Span {\n-        ::__internal::with_sess(|(_, mark)| {\n-            let call_site = mark.expn_info().unwrap().call_site;\n-            Span(call_site.with_ctxt(SyntaxContext::empty().apply_mark(mark)))\n-        })\n+        ::__internal::with_sess(|_, data| data.def_site)\n     }\n \n     /// The span of the invocation of the current procedural macro.\n@@ -296,7 +286,7 @@ impl Span {\n     /// at the macro call site will be able to refer to them as well.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn call_site() -> Span {\n-        ::__internal::with_sess(|(_, mark)| Span(mark.expn_info().unwrap().call_site))\n+        ::__internal::with_sess(|_, data| data.call_site)\n     }\n \n     /// The original source file into which this span points.\n@@ -1243,7 +1233,7 @@ impl TokenTree {\n             }\n \n             Interpolated(_) => {\n-                __internal::with_sess(|(sess, _)| {\n+                __internal::with_sess(|sess, _| {\n                     let tts = token.interpolated_to_tokenstream(sess, span);\n                     tt!(Group::new(Delimiter::None, TokenStream(tts)))\n                 })\n@@ -1354,20 +1344,21 @@ pub mod __internal {\n     pub use quote::{LiteralKind, SpannedSymbol, Quoter, unquote};\n \n     use std::cell::Cell;\n+    use std::ptr;\n \n     use syntax::ast;\n     use syntax::ext::base::ExtCtxt;\n-    use syntax::ext::hygiene::Mark;\n     use syntax::ptr::P;\n     use syntax::parse::{self, ParseSess};\n     use syntax::parse::token::{self, Token};\n     use syntax::tokenstream;\n     use syntax_pos::{BytePos, Loc, DUMMY_SP};\n+    use syntax_pos::hygiene::{Mark, SyntaxContext, Transparency};\n \n-    use super::{TokenStream, LexError};\n+    use super::{TokenStream, LexError, Span};\n \n     pub fn lookup_char_pos(pos: BytePos) -> Loc {\n-        with_sess(|(sess, _)| sess.codemap().lookup_char_pos(pos))\n+        with_sess(|sess, _| sess.codemap().lookup_char_pos(pos))\n     }\n \n     pub fn new_token_stream(item: P<ast::Item>) -> TokenStream {\n@@ -1380,7 +1371,7 @@ pub mod __internal {\n     }\n \n     pub fn token_stream_parse_items(stream: TokenStream) -> Result<Vec<P<ast::Item>>, LexError> {\n-        with_sess(move |(sess, _)| {\n+        with_sess(move |sess, _| {\n             let mut parser = parse::stream_to_parser(sess, stream.0);\n             let mut items = Vec::new();\n \n@@ -1411,16 +1402,30 @@ pub mod __internal {\n                                     expand: fn(TokenStream) -> TokenStream);\n     }\n \n+    #[derive(Clone, Copy)]\n+    pub struct ProcMacroData {\n+        pub def_site: Span,\n+        pub call_site: Span,\n+    }\n+\n+    #[derive(Clone, Copy)]\n+    struct ProcMacroSess {\n+        parse_sess: *const ParseSess,\n+        data: ProcMacroData,\n+    }\n+\n     // Emulate scoped_thread_local!() here essentially\n     thread_local! {\n-        static CURRENT_SESS: Cell<(*const ParseSess, Mark)> =\n-            Cell::new((0 as *const _, Mark::root()));\n+        static CURRENT_SESS: Cell<ProcMacroSess> = Cell::new(ProcMacroSess {\n+            parse_sess: ptr::null(),\n+            data: ProcMacroData { def_site: Span(DUMMY_SP), call_site: Span(DUMMY_SP) },\n+        });\n     }\n \n     pub fn set_sess<F, R>(cx: &ExtCtxt, f: F) -> R\n         where F: FnOnce() -> R\n     {\n-        struct Reset { prev: (*const ParseSess, Mark) }\n+        struct Reset { prev: ProcMacroSess }\n \n         impl Drop for Reset {\n             fn drop(&mut self) {\n@@ -1430,24 +1435,39 @@ pub mod __internal {\n \n         CURRENT_SESS.with(|p| {\n             let _reset = Reset { prev: p.get() };\n-            p.set((cx.parse_sess, cx.current_expansion.mark));\n+\n+            // No way to determine def location for a proc macro rigth now, so use call location.\n+            let location = cx.current_expansion.mark.expn_info().unwrap().call_site;\n+            // Opaque mark was already created by expansion, now create its transparent twin.\n+            let opaque_mark = cx.current_expansion.mark;\n+            let transparent_mark = Mark::fresh_cloned(opaque_mark);\n+            transparent_mark.set_transparency(Transparency::Transparent);\n+\n+            let to_span = |mark| Span(location.with_ctxt(SyntaxContext::empty().apply_mark(mark)));\n+            p.set(ProcMacroSess {\n+                parse_sess: cx.parse_sess,\n+                data: ProcMacroData {\n+                    def_site: to_span(opaque_mark),\n+                    call_site: to_span(transparent_mark),\n+                },\n+            });\n             f()\n         })\n     }\n \n     pub fn in_sess() -> bool\n     {\n-        let p = CURRENT_SESS.with(|p| p.get());\n-        !p.0.is_null()\n+        !CURRENT_SESS.with(|sess| sess.get()).parse_sess.is_null()\n     }\n \n     pub fn with_sess<F, R>(f: F) -> R\n-        where F: FnOnce((&ParseSess, Mark)) -> R\n+        where F: FnOnce(&ParseSess, &ProcMacroData) -> R\n     {\n-        let p = CURRENT_SESS.with(|p| p.get());\n-        assert!(!p.0.is_null(), \"proc_macro::__internal::with_sess() called \\\n-                                 before set_parse_sess()!\");\n-        f(unsafe { (&*p.0, p.1) })\n+        let sess = CURRENT_SESS.with(|sess| sess.get());\n+        if sess.parse_sess.is_null() {\n+            panic!(\"procedural macro API is used outside of a procedural macro\");\n+        }\n+        f(unsafe { &*sess.parse_sess }, &sess.data)\n     }\n }\n "}, {"sha": "6473b69b4591d3169163caed83305dbe33d85dfd", "filename": "src/test/compile-fail-fulldeps/proc-macro/lints_in_proc_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/297109ea3263a4ea90a7143a82e46903a8890269/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Flints_in_proc_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297109ea3263a4ea90a7143a82e46903a8890269/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Flints_in_proc_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Flints_in_proc_macros.rs?ref=297109ea3263a4ea90a7143a82e46903a8890269", "patch": "@@ -23,5 +23,5 @@ fn main() {\n     bang_proc_macro2!();\n     //~^ ERROR cannot find value `foobar2` in this scope\n     //~^^ did you mean `foobar`?\n-    println!(\"{}\", x); //~ ERROR cannot find value `x` in this scope\n+    println!(\"{}\", x);\n }"}, {"sha": "ab4e082ed74fcb856cd5890796e36e21701dedfc", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/call-site.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/297109ea3263a4ea90a7143a82e46903a8890269/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fcall-site.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297109ea3263a4ea90a7143a82e46903a8890269/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fcall-site.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fcall-site.rs?ref=297109ea3263a4ea90a7143a82e46903a8890269", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(proc_macro)]\n+\n+extern crate proc_macro;\n+use proc_macro::*;\n+\n+#[proc_macro]\n+pub fn check(input: TokenStream) -> TokenStream {\n+    // Parsed `x2` can refer to `x2` from `input`\n+    let parsed1: TokenStream = \"let x3 = x2;\".parse().unwrap();\n+    // `x3` parsed from one string can refer to `x3` parsed from another string.\n+    let parsed2: TokenStream = \"let x4 = x3;\".parse().unwrap();\n+    // Manually assembled `x4` can refer to parsed `x4`.\n+    let manual: Vec<TokenTree> = vec![\n+        Ident::new(\"let\", Span::call_site()).into(),\n+        Ident::new(\"x5\", Span::call_site()).into(),\n+        Punct::new('=', Spacing::Alone).into(),\n+        Ident::new(\"x4\", Span::call_site()).into(),\n+        Punct::new(';', Spacing::Alone).into(),\n+    ];\n+    input.into_iter().chain(parsed1.into_iter())\n+                     .chain(parsed2.into_iter())\n+                     .chain(manual.into_iter())\n+                     .collect()\n+}"}, {"sha": "f0d48972894ae31ecbfaeb60fbbc7f585edd31fa", "filename": "src/test/run-pass-fulldeps/proc-macro/call-site.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/297109ea3263a4ea90a7143a82e46903a8890269/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fcall-site.rs", "raw_url": "https://github.com/rust-lang/rust/raw/297109ea3263a4ea90a7143a82e46903a8890269/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fcall-site.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fcall-site.rs?ref=297109ea3263a4ea90a7143a82e46903a8890269", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:call-site.rs\n+// ignore-stage1\n+\n+#![feature(proc_macro, proc_macro_non_items)]\n+\n+extern crate call_site;\n+use call_site::*;\n+\n+fn main() {\n+    let x1 = 10;\n+    call_site::check!(let x2 = x1;);\n+    let x6 = x5;\n+}"}]}