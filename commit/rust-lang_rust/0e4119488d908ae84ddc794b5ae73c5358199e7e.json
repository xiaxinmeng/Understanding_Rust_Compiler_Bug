{"sha": "0e4119488d908ae84ddc794b5ae73c5358199e7e", "node_id": "C_kwDOAAsO6NoAKDBlNDExOTQ4OGQ5MDhhZTg0ZGRjNzk0YjVhZTczYzUzNTgxOTllN2U", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-12-29T09:17:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-29T09:17:11Z"}, "message": "Rollup merge of #92340 - camelid:search-index-cleanup, r=GuillaumeGomez\n\nrustdoc: Start cleaning up search index generation\n\nI'm trying to simplify and clean up the code, partly to make #90779 easier.\n\nr? `@GuillaumeGomez`", "tree": {"sha": "645b9c91f04ffe839ce5b95e34c58dff97499d1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/645b9c91f04ffe839ce5b95e34c58dff97499d1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e4119488d908ae84ddc794b5ae73c5358199e7e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhzCeXCRBK7hj4Ov3rIwAASiAIAKA/p1nQVw71JWy8IqTHbSLi\nrVQ0XIBNAkCBhj99P/VD0i0p/sLDt1W0BJtuJELS88CDh/3iJSH/cYpAqKap1gFd\nlVIwEV4flFBB3n9g39JT+a5LAzN3+5+3rC6jZH7eGRoOjxDTRILcC8QH5xgZzRq4\n6QbxIiSHCDbtAsUu+wnRJ/ceep0up7PPZaU7H/FN4S4xQLE8CWJVGx7Xe/I5fDbV\nRV4rhvih3XFhl6a1ngDPM9YMdGMtyeYo71olF9NWYF7psWwwOLLnYx8LRFBHO0MP\n+MoMVEhrHQh19YT6Ywlq1ZvCCQd42MrqESP0qwpJLFKiPUzgUGFeUofwgaFJlFM=\n=Odx/\n-----END PGP SIGNATURE-----\n", "payload": "tree 645b9c91f04ffe839ce5b95e34c58dff97499d1c\nparent f044c6c86ccfc517ba336c6a5f45b7d1c1e1b2f2\nparent 908a9d4aad61f4b8108ff91ae42f76e67dec5148\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1640769431 +0100\ncommitter GitHub <noreply@github.com> 1640769431 +0100\n\nRollup merge of #92340 - camelid:search-index-cleanup, r=GuillaumeGomez\n\nrustdoc: Start cleaning up search index generation\n\nI'm trying to simplify and clean up the code, partly to make #90779 easier.\n\nr? `@GuillaumeGomez`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e4119488d908ae84ddc794b5ae73c5358199e7e", "html_url": "https://github.com/rust-lang/rust/commit/0e4119488d908ae84ddc794b5ae73c5358199e7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e4119488d908ae84ddc794b5ae73c5358199e7e/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f044c6c86ccfc517ba336c6a5f45b7d1c1e1b2f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f044c6c86ccfc517ba336c6a5f45b7d1c1e1b2f2", "html_url": "https://github.com/rust-lang/rust/commit/f044c6c86ccfc517ba336c6a5f45b7d1c1e1b2f2"}, {"sha": "908a9d4aad61f4b8108ff91ae42f76e67dec5148", "url": "https://api.github.com/repos/rust-lang/rust/commits/908a9d4aad61f4b8108ff91ae42f76e67dec5148", "html_url": "https://github.com/rust-lang/rust/commit/908a9d4aad61f4b8108ff91ae42f76e67dec5148"}], "stats": {"total": 115, "additions": 65, "deletions": 50}, "files": [{"sha": "2b1a1d4a600d64f84ea9a9a03defb2a9140ceee9", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0e4119488d908ae84ddc794b5ae73c5358199e7e/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4119488d908ae84ddc794b5ae73c5358199e7e/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=0e4119488d908ae84ddc794b5ae73c5358199e7e", "patch": "@@ -39,7 +39,6 @@ use crate::clean::Clean;\n use crate::core::DocContext;\n use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n-use crate::html::render::cache::ExternalLocation;\n use crate::html::render::Context;\n use crate::passes::collect_intra_doc_links::UrlFragment;\n \n@@ -339,6 +338,16 @@ impl ExternalCrate {\n     }\n }\n \n+/// Indicates where an external crate can be found.\n+crate enum ExternalLocation {\n+    /// Remote URL root of the external crate\n+    Remote(String),\n+    /// This external crate can be found in the local doc/ folder\n+    Local,\n+    /// The external crate could not be found.\n+    Unknown,\n+}\n+\n /// Anything with a source location and set of attributes and, optionally, a\n /// name. That is, anything that can be documented. This doesn't correspond\n /// directly to the AST's concept of an item; it's a strict superset."}, {"sha": "6b9ccd37cfb371196476b7c65fb1738541202d33", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e4119488d908ae84ddc794b5ae73c5358199e7e/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4119488d908ae84ddc794b5ae73c5358199e7e/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=0e4119488d908ae84ddc794b5ae73c5358199e7e", "patch": "@@ -6,13 +6,13 @@ use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n \n-use crate::clean::{self, ExternalCrate, ItemId, PrimitiveType};\n+use crate::clean::{self, types::ExternalLocation, ExternalCrate, ItemId, PrimitiveType};\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::formats::item_type::ItemType;\n use crate::formats::Impl;\n use crate::html::markdown::short_markdown_summary;\n-use crate::html::render::cache::{get_index_search_type, ExternalLocation};\n+use crate::html::render::search_index::get_function_type_for_search;\n use crate::html::render::IndexItem;\n \n /// This cache is used to store information about the [`clean::Crate`] being\n@@ -303,7 +303,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                             desc,\n                             parent,\n                             parent_idx: None,\n-                            search_type: get_index_search_type(&item, self.tcx, self.cache),\n+                            search_type: get_function_type_for_search(&item, self.tcx),\n                             aliases: item.attrs.get_doc_aliases(),\n                         });\n                     }"}, {"sha": "3a7c7186877e232cec28e2651e5a5a2706642f51", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e4119488d908ae84ddc794b5ae73c5358199e7e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4119488d908ae84ddc794b5ae73c5358199e7e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=0e4119488d908ae84ddc794b5ae73c5358199e7e", "patch": "@@ -21,10 +21,12 @@ use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::CRATE_DEF_INDEX;\n use rustc_target::spec::abi::Abi;\n \n-use crate::clean::{self, utils::find_nearest_parent_module, ExternalCrate, ItemId, PrimitiveType};\n+use crate::clean::{\n+    self, types::ExternalLocation, utils::find_nearest_parent_module, ExternalCrate, ItemId,\n+    PrimitiveType,\n+};\n use crate::formats::item_type::ItemType;\n use crate::html::escape::Escape;\n-use crate::html::render::cache::ExternalLocation;\n use crate::html::render::Context;\n \n use super::url_parts_builder::UrlPartsBuilder;"}, {"sha": "534a542d58ed0b596e5ffe754128715b5ea80fb9", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e4119488d908ae84ddc794b5ae73c5358199e7e/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4119488d908ae84ddc794b5ae73c5358199e7e/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=0e4119488d908ae84ddc794b5ae73c5358199e7e", "patch": "@@ -13,16 +13,16 @@ use rustc_span::edition::Edition;\n use rustc_span::source_map::FileName;\n use rustc_span::symbol::sym;\n \n-use super::cache::{build_index, ExternalLocation};\n use super::print_item::{full_path, item_path, print_item};\n+use super::search_index::build_index;\n use super::templates;\n use super::write_shared::write_shared;\n use super::{\n     collect_spans_and_sources, print_sidebar, settings, AllTypes, LinkFromSrc, NameDoc, StylePath,\n     BASIC_KEYWORDS,\n };\n \n-use crate::clean::{self, ExternalCrate};\n+use crate::clean::{self, types::ExternalLocation, ExternalCrate};\n use crate::config::RenderOptions;\n use crate::docfs::{DocFS, PathError};\n use crate::error::Error;"}, {"sha": "3e7711181f730b7c5210639ddd48d2d449635b7a", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e4119488d908ae84ddc794b5ae73c5358199e7e/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4119488d908ae84ddc794b5ae73c5358199e7e/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=0e4119488d908ae84ddc794b5ae73c5358199e7e", "patch": "@@ -23,7 +23,7 @@\n //! These threads are not parallelized (they haven't been a bottleneck yet), and\n //! both occur before the crate is rendered.\n \n-crate mod cache;\n+crate mod search_index;\n \n #[cfg(test)]\n mod tests;"}, {"sha": "0fbe090f2190abf831d04d0e3c3b0a6968930ebb", "filename": "src/librustdoc/html/render/search_index.rs", "status": "renamed", "additions": 33, "deletions": 39, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/0e4119488d908ae84ddc794b5ae73c5358199e7e/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4119488d908ae84ddc794b5ae73c5358199e7e/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=0e4119488d908ae84ddc794b5ae73c5358199e7e", "patch": "@@ -7,22 +7,12 @@ use rustc_span::symbol::Symbol;\n use serde::ser::{Serialize, SerializeStruct, Serializer};\n \n use crate::clean;\n-use crate::clean::types::{FnDecl, FnRetTy, GenericBound, Generics, Type, WherePredicate};\n+use crate::clean::types::{FnRetTy, Function, GenericBound, Generics, Type, WherePredicate};\n use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n use crate::html::markdown::short_markdown_summary;\n use crate::html::render::{IndexItem, IndexItemFunctionType, RenderType, TypeWithKind};\n \n-/// Indicates where an external crate can be found.\n-crate enum ExternalLocation {\n-    /// Remote URL root of the external crate\n-    Remote(String),\n-    /// This external crate can be found in the local doc/ folder\n-    Local,\n-    /// The external crate could not be found.\n-    Unknown,\n-}\n-\n /// Builds the search index from the collected metadata\n crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<'tcx>) -> String {\n     let mut defid_to_pathid = FxHashMap::default();\n@@ -42,7 +32,7 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n                 desc,\n                 parent: Some(did),\n                 parent_idx: None,\n-                search_type: get_index_search_type(item, tcx, cache),\n+                search_type: get_function_type_for_search(item, tcx),\n                 aliases: item.attrs.get_doc_aliases(),\n             });\n         }\n@@ -191,15 +181,14 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n     )\n }\n \n-crate fn get_index_search_type<'tcx>(\n+crate fn get_function_type_for_search<'tcx>(\n     item: &clean::Item,\n     tcx: TyCtxt<'tcx>,\n-    cache: &Cache,\n ) -> Option<IndexItemFunctionType> {\n     let (mut inputs, mut output) = match *item.kind {\n-        clean::FunctionItem(ref f) => get_all_types(&f.generics, &f.decl, tcx, cache),\n-        clean::MethodItem(ref m, _) => get_all_types(&m.generics, &m.decl, tcx, cache),\n-        clean::TyMethodItem(ref m) => get_all_types(&m.generics, &m.decl, tcx, cache),\n+        clean::FunctionItem(ref f) => get_fn_inputs_and_outputs(f, tcx),\n+        clean::MethodItem(ref m, _) => get_fn_inputs_and_outputs(m, tcx),\n+        clean::TyMethodItem(ref m) => get_fn_inputs_and_outputs(m, tcx),\n         _ => return None,\n     };\n \n@@ -211,12 +200,12 @@ crate fn get_index_search_type<'tcx>(\n \n fn get_index_type(clean_type: &clean::Type, generics: Vec<TypeWithKind>) -> RenderType {\n     RenderType {\n-        name: get_index_type_name(clean_type, true).map(|s| s.as_str().to_ascii_lowercase()),\n+        name: get_index_type_name(clean_type).map(|s| s.as_str().to_ascii_lowercase()),\n         generics: if generics.is_empty() { None } else { Some(generics) },\n     }\n }\n \n-fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option<Symbol> {\n+fn get_index_type_name(clean_type: &clean::Type) -> Option<Symbol> {\n     match *clean_type {\n         clean::Type::Path { ref path, .. } => {\n             let path_segment = path.segments.last().unwrap();\n@@ -226,11 +215,10 @@ fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option\n             let path = &bounds[0].trait_;\n             Some(path.segments.last().unwrap().name)\n         }\n-        clean::Generic(s) if accept_generic => Some(s),\n+        clean::Generic(s) => Some(s),\n         clean::Primitive(ref p) => Some(p.as_sym()),\n-        clean::BorrowedRef { ref type_, .. } => get_index_type_name(type_, accept_generic),\n-        clean::Generic(_)\n-        | clean::BareFunction(_)\n+        clean::BorrowedRef { ref type_, .. } => get_index_type_name(type_),\n+        clean::BareFunction(_)\n         | clean::Tuple(_)\n         | clean::Slice(_)\n         | clean::Array(_, _)\n@@ -248,20 +236,19 @@ fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option\n ///\n /// Important note: It goes through generics recursively. So if you have\n /// `T: Option<Result<(), ()>>`, it'll go into `Option` and then into `Result`.\n-crate fn get_real_types<'tcx>(\n+#[instrument(level = \"trace\", skip(tcx, res))]\n+fn add_generics_and_bounds_as_types<'tcx>(\n     generics: &Generics,\n     arg: &Type,\n     tcx: TyCtxt<'tcx>,\n     recurse: usize,\n     res: &mut Vec<TypeWithKind>,\n-    cache: &Cache,\n ) {\n     fn insert_ty(\n         res: &mut Vec<TypeWithKind>,\n         tcx: TyCtxt<'_>,\n         ty: Type,\n         mut generics: Vec<TypeWithKind>,\n-        _cache: &Cache,\n     ) {\n         let is_full_generic = ty.is_full_generic();\n \n@@ -330,6 +317,7 @@ crate fn get_real_types<'tcx>(\n \n     if recurse >= 10 {\n         // FIXME: remove this whole recurse thing when the recursion bug is fixed\n+        // See #59502 for the original issue.\n         return;\n     }\n \n@@ -350,32 +338,37 @@ crate fn get_real_types<'tcx>(\n                     for param_def in poly_trait.generic_params.iter() {\n                         match &param_def.kind {\n                             clean::GenericParamDefKind::Type { default: Some(ty), .. } => {\n-                                get_real_types(\n+                                add_generics_and_bounds_as_types(\n                                     generics,\n                                     ty,\n                                     tcx,\n                                     recurse + 1,\n                                     &mut ty_generics,\n-                                    cache,\n                                 )\n                             }\n                             _ => {}\n                         }\n                     }\n                 }\n             }\n-            insert_ty(res, tcx, arg.clone(), ty_generics, cache);\n+            insert_ty(res, tcx, arg.clone(), ty_generics);\n         }\n         // Otherwise we check if the trait bounds are \"inlined\" like `T: Option<u32>`...\n         if let Some(bound) = generics.params.iter().find(|g| g.is_type() && g.name == arg_s) {\n             let mut ty_generics = Vec::new();\n             for bound in bound.get_bounds().unwrap_or(&[]) {\n                 if let Some(path) = bound.get_trait_path() {\n                     let ty = Type::Path { path };\n-                    get_real_types(generics, &ty, tcx, recurse + 1, &mut ty_generics, cache);\n+                    add_generics_and_bounds_as_types(\n+                        generics,\n+                        &ty,\n+                        tcx,\n+                        recurse + 1,\n+                        &mut ty_generics,\n+                    );\n                 }\n             }\n-            insert_ty(res, tcx, arg.clone(), ty_generics, cache);\n+            insert_ty(res, tcx, arg.clone(), ty_generics);\n         }\n     } else {\n         // This is not a type parameter. So for example if we have `T, U: Option<T>`, and we're\n@@ -386,30 +379,31 @@ crate fn get_real_types<'tcx>(\n         let mut ty_generics = Vec::new();\n         if let Some(arg_generics) = arg.generics() {\n             for gen in arg_generics.iter() {\n-                get_real_types(generics, gen, tcx, recurse + 1, &mut ty_generics, cache);\n+                add_generics_and_bounds_as_types(generics, gen, tcx, recurse + 1, &mut ty_generics);\n             }\n         }\n-        insert_ty(res, tcx, arg.clone(), ty_generics, cache);\n+        insert_ty(res, tcx, arg.clone(), ty_generics);\n     }\n }\n \n /// Return the full list of types when bounds have been resolved.\n ///\n /// i.e. `fn foo<A: Display, B: Option<A>>(x: u32, y: B)` will return\n /// `[u32, Display, Option]`.\n-crate fn get_all_types<'tcx>(\n-    generics: &Generics,\n-    decl: &FnDecl,\n+fn get_fn_inputs_and_outputs<'tcx>(\n+    func: &Function,\n     tcx: TyCtxt<'tcx>,\n-    cache: &Cache,\n ) -> (Vec<TypeWithKind>, Vec<TypeWithKind>) {\n+    let decl = &func.decl;\n+    let generics = &func.generics;\n+\n     let mut all_types = Vec::new();\n     for arg in decl.inputs.values.iter() {\n         if arg.type_.is_self_type() {\n             continue;\n         }\n         let mut args = Vec::new();\n-        get_real_types(generics, &arg.type_, tcx, 0, &mut args, cache);\n+        add_generics_and_bounds_as_types(generics, &arg.type_, tcx, 0, &mut args);\n         if !args.is_empty() {\n             all_types.extend(args);\n         } else {\n@@ -423,7 +417,7 @@ crate fn get_all_types<'tcx>(\n     let mut ret_types = Vec::new();\n     match decl.output {\n         FnRetTy::Return(ref return_type) => {\n-            get_real_types(generics, return_type, tcx, 0, &mut ret_types, cache);\n+            add_generics_and_bounds_as_types(generics, return_type, tcx, 0, &mut ret_types);\n             if ret_types.is_empty() {\n                 if let Some(kind) =\n                     return_type.def_id_no_primitives().map(|did| tcx.def_kind(did).into())", "previous_filename": "src/librustdoc/html/render/cache.rs"}, {"sha": "005da01b52b6c43813e1d109a45a8be51c99e2a2", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e4119488d908ae84ddc794b5ae73c5358199e7e/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4119488d908ae84ddc794b5ae73c5358199e7e/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=0e4119488d908ae84ddc794b5ae73c5358199e7e", "patch": "@@ -19,12 +19,11 @@ use rustc_session::Session;\n use rustdoc_json_types as types;\n \n use crate::clean;\n-use crate::clean::ExternalCrate;\n+use crate::clean::types::{ExternalCrate, ExternalLocation};\n use crate::config::RenderOptions;\n use crate::error::Error;\n use crate::formats::cache::Cache;\n use crate::formats::FormatRenderer;\n-use crate::html::render::cache::ExternalLocation;\n use crate::json::conversions::{from_item_id, IntoWithTcx};\n \n #[derive(Clone)]"}, {"sha": "ce51556dd418b4cac6a207a38cbb466aa55c04d9", "filename": "src/test/rustdoc-ui/search-index-generics-recursion-bug-issue-59502.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0e4119488d908ae84ddc794b5ae73c5358199e7e/src%2Ftest%2Frustdoc-ui%2Fsearch-index-generics-recursion-bug-issue-59502.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e4119488d908ae84ddc794b5ae73c5358199e7e/src%2Ftest%2Frustdoc-ui%2Fsearch-index-generics-recursion-bug-issue-59502.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fsearch-index-generics-recursion-bug-issue-59502.rs?ref=0e4119488d908ae84ddc794b5ae73c5358199e7e", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+\n+// Minimization of issue #59502\n+\n+trait MyTrait<T> {\n+    type Output;\n+}\n+\n+pub fn pow<T: MyTrait<T, Output = T>>(arg: T) -> T {\n+    arg\n+}"}]}