{"sha": "b9b82fde7c72e47bd76829bd5322f427bf3f9900", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5YjgyZmRlN2M3MmU0N2JkNzY4MjliZDUzMjJmNDI3YmYzZjk5MDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-23T10:46:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-23T10:46:02Z"}, "message": "Auto merge of #46054 - nikomatsakis:nll-master-to-rust-master-1, r=arielb1\n\ntypeck aggregate rvalues in MIR type checker\n\nThis branch is an attempt to land content by @spastorino and @Nashenas88 that was initially landed on nll-master while we waited for https://github.com/rust-lang/rust/pull/45825 to land.\n\nThe biggest change it contains is that it extends the MIR type-checker to also type-check MIR aggregate rvalues (at least partially). Specifically, it checks that the operands provided for each field have the right type.\n\nIt does not yet check that their well-formedness predicates are met. That is https://github.com/rust-lang/rust/issues/45827. It also does not check other kinds of rvalues (that is https://github.com/rust-lang/rust/issues/45959). @spastorino is working on those issues now.\n\nr? @arielb1", "tree": {"sha": "781c7cf9dddac568bfd89c922540c701302c7aaf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/781c7cf9dddac568bfd89c922540c701302c7aaf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9b82fde7c72e47bd76829bd5322f427bf3f9900", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9b82fde7c72e47bd76829bd5322f427bf3f9900", "html_url": "https://github.com/rust-lang/rust/commit/b9b82fde7c72e47bd76829bd5322f427bf3f9900", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9b82fde7c72e47bd76829bd5322f427bf3f9900/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "247d98ec371210446934c57b419b3b5d23772d02", "url": "https://api.github.com/repos/rust-lang/rust/commits/247d98ec371210446934c57b419b3b5d23772d02", "html_url": "https://github.com/rust-lang/rust/commit/247d98ec371210446934c57b419b3b5d23772d02"}, {"sha": "c52e51dfb7a3d2b9027a36ba93ec73a5c1b7f00a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c52e51dfb7a3d2b9027a36ba93ec73a5c1b7f00a", "html_url": "https://github.com/rust-lang/rust/commit/c52e51dfb7a3d2b9027a36ba93ec73a5c1b7f00a"}], "stats": {"total": 206, "additions": 169, "deletions": 37}, "files": [{"sha": "5a4f2157298b066715a3d92740f7ebb69b80a682", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b9b82fde7c72e47bd76829bd5322f427bf3f9900/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9b82fde7c72e47bd76829bd5322f427bf3f9900/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=b9b82fde7c72e47bd76829bd5322f427bf3f9900", "patch": "@@ -171,7 +171,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n         for (r, vid) in seeds {\n             // While all things transitively reachable in the graph\n             // from the variable (`'0` in the example above).\n-            let seed_index = NodeIndex(vid.index as usize);\n+            let seed_index = NodeIndex(vid.index() as usize);\n             for succ_index in graph.depth_traverse(seed_index, OUTGOING) {\n                 let succ_index = succ_index.0;\n \n@@ -512,16 +512,16 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n             match *constraint {\n                 Constraint::VarSubVar(a_id, b_id) => {\n                     graph.add_edge(\n-                        NodeIndex(a_id.index as usize),\n-                        NodeIndex(b_id.index as usize),\n+                        NodeIndex(a_id.index() as usize),\n+                        NodeIndex(b_id.index() as usize),\n                         *constraint,\n                     );\n                 }\n                 Constraint::RegSubVar(_, b_id) => {\n-                    graph.add_edge(dummy_source, NodeIndex(b_id.index as usize), *constraint);\n+                    graph.add_edge(dummy_source, NodeIndex(b_id.index() as usize), *constraint);\n                 }\n                 Constraint::VarSubReg(a_id, _) => {\n-                    graph.add_edge(NodeIndex(a_id.index as usize), dummy_sink, *constraint);\n+                    graph.add_edge(NodeIndex(a_id.index() as usize), dummy_sink, *constraint);\n                 }\n                 Constraint::RegSubReg(..) => {\n                     // this would be an edge from `dummy_source` to\n@@ -630,9 +630,9 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n             let node_idx = state.stack.pop().unwrap();\n \n             // check whether we've visited this node on some previous walk\n-            if dup_vec[node_idx.index as usize] == u32::MAX {\n-                dup_vec[node_idx.index as usize] = orig_node_idx.index;\n-            } else if dup_vec[node_idx.index as usize] != orig_node_idx.index {\n+            if dup_vec[node_idx.index() as usize] == u32::MAX {\n+                dup_vec[node_idx.index() as usize] = orig_node_idx.index() as u32;\n+            } else if dup_vec[node_idx.index() as usize] != orig_node_idx.index() as u32 {\n                 state.dup_found = true;\n             }\n \n@@ -659,7 +659,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n         ) {\n             debug!(\"process_edges(source_vid={:?}, dir={:?})\", source_vid, dir);\n \n-            let source_node_index = NodeIndex(source_vid.index as usize);\n+            let source_node_index = NodeIndex(source_vid.index() as usize);\n             for (_, edge) in graph.adjacent_edges(source_node_index, dir) {\n                 match edge.data {\n                     Constraint::VarSubVar(from_vid, to_vid) => {"}, {"sha": "72740dd40be2932dab0c771d6c3b9d717be5157a", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9b82fde7c72e47bd76829bd5322f427bf3f9900/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9b82fde7c72e47bd76829bd5322f427bf3f9900/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=b9b82fde7c72e47bd76829bd5322f427bf3f9900", "patch": "@@ -16,7 +16,7 @@ use self::CombineMapType::*;\n use super::{MiscVariable, RegionVariableOrigin, SubregionOrigin};\n use super::unify_key;\n \n-use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::unify::{self, UnificationTable};\n use ty::{self, Ty, TyCtxt};\n@@ -404,7 +404,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             }\n             AddVar(vid) => {\n                 self.var_origins.pop().unwrap();\n-                assert_eq!(self.var_origins.len(), vid.index as usize);\n+                assert_eq!(self.var_origins.len(), vid.index() as usize);\n             }\n             AddConstraint(ref constraint) => {\n                 self.data.constraints.remove(constraint);"}, {"sha": "99b11794cc5b577632b83161652f11e356248260", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9b82fde7c72e47bd76829bd5322f427bf3f9900/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9b82fde7c72e47bd76829bd5322f427bf3f9900/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=b9b82fde7c72e47bd76829bd5322f427bf3f9900", "patch": "@@ -33,7 +33,7 @@ pub struct RegionVidKey {\n \n impl Combine for RegionVidKey {\n     fn combine(&self, other: &RegionVidKey) -> RegionVidKey {\n-        let min_vid = if self.min_vid.index < other.min_vid.index {\n+        let min_vid = if self.min_vid.index() < other.min_vid.index() {\n             self.min_vid\n         } else {\n             other.min_vid\n@@ -45,8 +45,8 @@ impl Combine for RegionVidKey {\n \n impl UnifyKey for ty::RegionVid {\n     type Value = RegionVidKey;\n-    fn index(&self) -> u32 { self.index }\n-    fn from_index(i: u32) -> ty::RegionVid { ty::RegionVid { index: i } }\n+    fn index(&self) -> u32 { self.0 }\n+    fn from_index(i: u32) -> ty::RegionVid { ty::RegionVid(i) }\n     fn tag(_: Option<ty::RegionVid>) -> &'static str { \"RegionVid\" }\n }\n "}, {"sha": "94e8033ed163ed733b186982540f41c111d7ae2b", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b9b82fde7c72e47bd76829bd5322f427bf3f9900/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9b82fde7c72e47bd76829bd5322f427bf3f9900/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=b9b82fde7c72e47bd76829bd5322f427bf3f9900", "patch": "@@ -1375,10 +1375,14 @@ pub enum AggregateKind<'tcx> {\n     /// The type is of the element\n     Array(Ty<'tcx>),\n     Tuple,\n-    /// The second field is variant number (discriminant), it's equal to 0\n-    /// for struct and union expressions. The fourth field is active field\n-    /// number and is present only for union expressions.\n+\n+    /// The second field is variant number (discriminant), it's equal\n+    /// to 0 for struct and union expressions. The fourth field is\n+    /// active field number and is present only for union expressions\n+    /// -- e.g. for a union expression `SomeUnion { c: .. }`, the\n+    /// active field index would identity the field `c`\n     Adt(&'tcx AdtDef, usize, &'tcx Substs<'tcx>, Option<usize>),\n+\n     Closure(DefId, ClosureSubsts<'tcx>),\n     Generator(DefId, ClosureSubsts<'tcx>, GeneratorInterior<'tcx>),\n }"}, {"sha": "caf78309cc2389721deaa871dddf354e39770adb", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b9b82fde7c72e47bd76829bd5322f427bf3f9900/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9b82fde7c72e47bd76829bd5322f427bf3f9900/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=b9b82fde7c72e47bd76829bd5322f427bf3f9900", "patch": "@@ -998,22 +998,11 @@ pub struct FloatVid {\n     pub index: u32,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy, PartialOrd, Ord)]\n-pub struct RegionVid {\n-    pub index: u32,\n-}\n-\n-// FIXME: We could convert this to use `newtype_index!`\n-impl Idx for RegionVid {\n-    fn new(value: usize) -> Self {\n-        assert!(value < ::std::u32::MAX as usize);\n-        RegionVid { index: value as u32 }\n-    }\n-\n-    fn index(self) -> usize {\n-        self.index as usize\n-    }\n-}\n+newtype_index!(RegionVid\n+    {\n+        pub idx\n+        DEBUG_FORMAT = custom,\n+    });\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, PartialOrd, Ord)]\n pub struct SkolemizedRegionVid {"}, {"sha": "9ff3d73f5c40e95678b06e40bd1f042145e8f67c", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b9b82fde7c72e47bd76829bd5322f427bf3f9900/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9b82fde7c72e47bd76829bd5322f427bf3f9900/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=b9b82fde7c72e47bd76829bd5322f427bf3f9900", "patch": "@@ -726,7 +726,7 @@ define_print! {\n                     }\n                 }\n                 ty::ReVar(region_vid) if cx.identify_regions => {\n-                    write!(f, \"'{}rv\", region_vid.index)\n+                    write!(f, \"'{}rv\", region_vid.index())\n                 }\n                 ty::ReScope(_) |\n                 ty::ReVar(_) |\n@@ -850,7 +850,7 @@ impl fmt::Debug for ty::FloatVid {\n \n impl fmt::Debug for ty::RegionVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"'_#{}r\", self.index)\n+        write!(f, \"'_#{}r\", self.index())\n     }\n }\n "}, {"sha": "15c68954230ba2c319a9b66a9292ad3e734ce79e", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b9b82fde7c72e47bd76829bd5322f427bf3f9900/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9b82fde7c72e47bd76829bd5322f427bf3f9900/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=b9b82fde7c72e47bd76829bd5322f427bf3f9900", "patch": "@@ -825,10 +825,16 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n                                       -> Mir<'tcx>\n {\n     let tcx = infcx.tcx;\n+    let gcx = tcx.global_tcx();\n     let def_id = tcx.hir.local_def_id(ctor_id);\n-    let sig = tcx.no_late_bound_regions(&tcx.fn_sig(def_id))\n+    let sig = gcx.no_late_bound_regions(&gcx.fn_sig(def_id))\n         .expect(\"LBR in ADT constructor signature\");\n-    let sig = tcx.erase_regions(&sig);\n+    let sig = gcx.erase_regions(&sig);\n+    let param_env = gcx.param_env(def_id);\n+\n+    // Normalize the sig now that we have liberated the late-bound\n+    // regions.\n+    let sig = gcx.normalize_associated_type_in_env(&sig, param_env);\n \n     let (adt_def, substs) = match sig.output().sty {\n         ty::TyAdt(adt_def, substs) => (adt_def, substs),"}, {"sha": "ade5cf8b70c2b6427662f1a66c1e6c0652ce69fb", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/b9b82fde7c72e47bd76829bd5322f427bf3f9900/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9b82fde7c72e47bd76829bd5322f427bf3f9900/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=b9b82fde7c72e47bd76829bd5322f427bf3f9900", "patch": "@@ -549,6 +549,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         terr\n                     );\n                 }\n+                self.check_rvalue(mir, rv, location);\n             }\n             StatementKind::SetDiscriminant {\n                 ref lvalue,\n@@ -1011,6 +1012,111 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn aggregate_field_ty(\n+        &mut self,\n+        ak: &Box<AggregateKind<'tcx>>,\n+        field_index: usize,\n+        location: Location,\n+    ) -> Result<Ty<'tcx>, FieldAccessError> {\n+        let tcx = self.tcx();\n+\n+        match **ak {\n+            AggregateKind::Adt(def, variant_index, substs, active_field_index) => {\n+                let variant = &def.variants[variant_index];\n+                let adj_field_index = active_field_index.unwrap_or(field_index);\n+                if let Some(field) = variant.fields.get(adj_field_index) {\n+                    Ok(self.normalize(&field.ty(tcx, substs), location))\n+                } else {\n+                    Err(FieldAccessError::OutOfRange {\n+                        field_count: variant.fields.len(),\n+                    })\n+                }\n+            }\n+            AggregateKind::Closure(def_id, substs) => {\n+                match substs.upvar_tys(def_id, tcx).nth(field_index) {\n+                    Some(ty) => Ok(ty),\n+                    None => Err(FieldAccessError::OutOfRange {\n+                        field_count: substs.upvar_tys(def_id, tcx).count(),\n+                    }),\n+                }\n+            }\n+            AggregateKind::Generator(def_id, substs, _) => {\n+                if let Some(ty) = substs.upvar_tys(def_id, tcx).nth(field_index) {\n+                    Ok(ty)\n+                } else {\n+                    match substs.field_tys(def_id, tcx).nth(field_index) {\n+                        Some(ty) => Ok(ty),\n+                        None => Err(FieldAccessError::OutOfRange {\n+                            field_count: substs.field_tys(def_id, tcx).count() + 1,\n+                        }),\n+                    }\n+                }\n+            }\n+            AggregateKind::Array(ty) => {\n+                Ok(ty)\n+            }\n+            AggregateKind::Tuple => {\n+                unreachable!(\"This should have been covered in check_rvalues\");\n+            }\n+        }\n+    }\n+\n+    fn check_rvalue(&mut self, mir: &Mir<'tcx>, rv: &Rvalue<'tcx>, location: Location) {\n+        let tcx = self.tcx();\n+        match rv {\n+            Rvalue::Aggregate(ak, ops) => {\n+                match **ak {\n+                    // tuple rvalue field type is always the type of the op. Nothing to check here.\n+                    AggregateKind::Tuple => {}\n+                    _ => {\n+                        for (i, op) in ops.iter().enumerate() {\n+                            let field_ty = match self.aggregate_field_ty(ak, i, location) {\n+                                Ok(field_ty) => field_ty,\n+                                Err(FieldAccessError::OutOfRange { field_count }) => {\n+                                    span_mirbug!(\n+                                        self,\n+                                        rv,\n+                                        \"accessed field #{} but variant only has {}\",\n+                                        i,\n+                                        field_count\n+                                    );\n+                                    continue;\n+                                }\n+                            };\n+                            let op_ty = op.ty(mir, tcx);\n+                            if let Err(terr) = self.sub_types(\n+                                op_ty,\n+                                field_ty,\n+                                location.at_successor_within_block(),\n+                            )\n+                                {\n+                                    span_mirbug!(\n+                                    self,\n+                                    rv,\n+                                    \"{:?} is not a subtype of {:?}: {:?}\",\n+                                    op_ty,\n+                                    field_ty,\n+                                    terr\n+                                );\n+                                }\n+                        }\n+                    }\n+                }\n+            }\n+            // FIXME: These other cases have to be implemented in future PRs\n+            Rvalue::Use(..) |\n+            Rvalue::Repeat(..) |\n+            Rvalue::Ref(..) |\n+            Rvalue::Len(..) |\n+            Rvalue::Cast(..) |\n+            Rvalue::BinaryOp(..) |\n+            Rvalue::CheckedBinaryOp(..) |\n+            Rvalue::UnaryOp(..) |\n+            Rvalue::Discriminant(..) |\n+            Rvalue::NullaryOp(..) => {}\n+        }\n+    }\n+\n     fn typeck_mir(&mut self, mir: &Mir<'tcx>) {\n         self.last_span = mir.span;\n         debug!(\"run_on_mir: {:?}\", mir.span);"}, {"sha": "afde254082946887573277d23926493cff915880", "filename": "src/test/compile-fail/nll/reference-carried-through-struct-field.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b9b82fde7c72e47bd76829bd5322f427bf3f9900/src%2Ftest%2Fcompile-fail%2Fnll%2Freference-carried-through-struct-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9b82fde7c72e47bd76829bd5322f427bf3f9900/src%2Ftest%2Fcompile-fail%2Fnll%2Freference-carried-through-struct-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnll%2Freference-carried-through-struct-field.rs?ref=b9b82fde7c72e47bd76829bd5322f427bf3f9900", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//revisions: ast mir\n+//[mir] compile-flags: -Z emit-end-regions -Z borrowck-mir -Z nll\n+\n+#![allow(unused_assignments)]\n+\n+struct Wrap<'a> { w: &'a mut u32 }\n+\n+fn foo() {\n+    let mut x = 22;\n+    let wrapper = Wrap { w: &mut x };\n+    x += 1; //[ast]~ ERROR cannot assign to `x` because it is borrowed [E0506]\n+    //[mir]~^ ERROR cannot assign to `x` because it is borrowed (Ast) [E0506]\n+    //[mir]~^^ ERROR cannot assign to `x` because it is borrowed (Mir) [E0506]\n+    //[mir]~^^^ ERROR cannot use `x` because it was mutably borrowed (Mir) [E0503]\n+    *wrapper.w += 1;\n+}\n+\n+fn main() { }\n\\ No newline at end of file"}]}