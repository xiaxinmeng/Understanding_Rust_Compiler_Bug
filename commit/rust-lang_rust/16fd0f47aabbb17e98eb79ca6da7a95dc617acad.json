{"sha": "16fd0f47aabbb17e98eb79ca6da7a95dc617acad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ZmQwZjQ3YWFiYmIxN2U5OGViNzljYTZkYTdhOTVkYzYxN2FjYWQ=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2019-03-09T07:23:35Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2019-04-24T17:51:25Z"}, "message": "hir: remove NodeId from Entry & simplify Map", "tree": {"sha": "355188ea35e79aa8550bc8aea893720a972f49db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/355188ea35e79aa8550bc8aea893720a972f49db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16fd0f47aabbb17e98eb79ca6da7a95dc617acad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16fd0f47aabbb17e98eb79ca6da7a95dc617acad", "html_url": "https://github.com/rust-lang/rust/commit/16fd0f47aabbb17e98eb79ca6da7a95dc617acad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16fd0f47aabbb17e98eb79ca6da7a95dc617acad/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cee58fdc12bea8cc373366bd84fc786277729b1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/cee58fdc12bea8cc373366bd84fc786277729b1c", "html_url": "https://github.com/rust-lang/rust/commit/cee58fdc12bea8cc373366bd84fc786277729b1c"}], "stats": {"total": 158, "additions": 80, "deletions": 78}, "files": [{"sha": "50bd89a1589645d688d15ff719d2366d51afeb14", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/16fd0f47aabbb17e98eb79ca6da7a95dc617acad/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16fd0f47aabbb17e98eb79ca6da7a95dc617acad/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=16fd0f47aabbb17e98eb79ca6da7a95dc617acad", "patch": "@@ -8,8 +8,8 @@ use crate::ich::Fingerprint;\n use crate::middle::cstore::CrateStore;\n use crate::session::CrateDisambiguator;\n use crate::session::Session;\n-use std::iter::repeat;\n-use syntax::ast::{NodeId, CRATE_NODE_ID};\n+use crate::util::nodemap::FxHashMap;\n+use syntax::ast::NodeId;\n use syntax::source_map::SourceMap;\n use syntax_pos::Span;\n \n@@ -25,7 +25,7 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     source_map: &'a SourceMap,\n \n     /// The node map\n-    map: Vec<Option<Entry<'hir>>>,\n+    map: FxHashMap<HirId, Entry<'hir>>,\n     /// The parent of this node\n     parent_node: hir::HirId,\n \n@@ -145,7 +145,8 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         let mut collector = NodeCollector {\n             krate,\n             source_map: sess.source_map(),\n-            map: repeat(None).take(sess.current_node_id_count()).collect(),\n+            map: FxHashMap::with_capacity_and_hasher(sess.current_node_id_count(),\n+                Default::default()),\n             parent_node: hir::CRATE_HIR_ID,\n             current_signature_dep_index: root_mod_sig_dep_index,\n             current_full_dep_index: root_mod_full_dep_index,\n@@ -157,9 +158,8 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             hcx,\n             hir_body_nodes,\n         };\n-        collector.insert_entry(CRATE_NODE_ID, Entry {\n-            parent: CRATE_NODE_ID,\n-            parent_hir: hir::CRATE_HIR_ID,\n+        collector.insert_entry(hir::CRATE_HIR_ID, Entry {\n+            parent: hir::CRATE_HIR_ID,\n             dep_node: root_mod_sig_dep_index,\n             node: Node::Crate,\n         });\n@@ -171,7 +171,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                                                   crate_disambiguator: CrateDisambiguator,\n                                                   cstore: &dyn CrateStore,\n                                                   commandline_args_hash: u64)\n-                                                  -> (Vec<Option<Entry<'hir>>>, Svh)\n+                                                  -> (FxHashMap<HirId, Entry<'hir>>, Svh)\n     {\n         self.hir_body_nodes.sort_unstable_by_key(|bn| bn.0);\n \n@@ -222,15 +222,14 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         (self.map, svh)\n     }\n \n-    fn insert_entry(&mut self, id: NodeId, entry: Entry<'hir>) {\n+    fn insert_entry(&mut self, id: HirId, entry: Entry<'hir>) {\n         debug!(\"hir_map: {:?} => {:?}\", id, entry);\n-        self.map[id.as_usize()] = Some(entry);\n+        self.map.insert(id, entry);\n     }\n \n     fn insert(&mut self, span: Span, hir_id: HirId, node: Node<'hir>) {\n         let entry = Entry {\n-            parent: self.hir_to_node_id[&self.parent_node],\n-            parent_hir: self.parent_node,\n+            parent: self.parent_node,\n             dep_node: if self.currently_in_body {\n                 self.current_full_dep_index\n             } else {\n@@ -239,12 +238,11 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             node,\n         };\n \n-        let node_id = self.hir_to_node_id[&hir_id];\n-\n         // Make sure that the DepNode of some node coincides with the HirId\n         // owner of that node.\n         if cfg!(debug_assertions) {\n-           assert_eq!(self.definitions.node_to_hir_id(node_id), hir_id);\n+            let node_id = self.hir_to_node_id[&hir_id];\n+            assert_eq!(self.definitions.node_to_hir_id(node_id), hir_id);\n \n             if hir_id.owner != self.current_dep_node_owner {\n                 let node_str = match self.definitions.opt_def_index(node_id) {\n@@ -277,7 +275,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             }\n         }\n \n-        self.insert_entry(node_id, entry);\n+        self.insert_entry(hir_id, entry);\n     }\n \n     fn with_parent<F: FnOnce(&mut Self)>("}, {"sha": "0b2f0de68097e8ffcf75daa4172ec43a0ab34006", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 65, "deletions": 62, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/16fd0f47aabbb17e98eb79ca6da7a95dc617acad/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16fd0f47aabbb17e98eb79ca6da7a95dc617acad/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=16fd0f47aabbb17e98eb79ca6da7a95dc617acad", "patch": "@@ -11,7 +11,7 @@ use crate::middle::cstore::CrateStoreDyn;\n \n use rustc_target::spec::abi::Abi;\n use rustc_data_structures::svh::Svh;\n-use syntax::ast::{self, Name, NodeId, CRATE_NODE_ID};\n+use syntax::ast::{self, Name, NodeId};\n use syntax::source_map::Spanned;\n use syntax::ext::base::MacroKind;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -38,14 +38,13 @@ pub const REGULAR_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::High;\n /// Represents an entry and its parent `NodeId`.\n #[derive(Copy, Clone, Debug)]\n pub struct Entry<'hir> {\n-    parent: NodeId,\n-    parent_hir: HirId,\n+    parent: HirId,\n     dep_node: DepNodeIndex,\n     node: Node<'hir>,\n }\n \n impl<'hir> Entry<'hir> {\n-    fn parent_node(self) -> Option<NodeId> {\n+    fn parent_node(self) -> Option<HirId> {\n         match self.node {\n             Node::Crate | Node::MacroDef(_) => None,\n             _ => Some(self.parent),\n@@ -183,7 +182,7 @@ pub struct Map<'hir> {\n     ///\n     /// Also, indexing is pretty quick when you've got a vector and\n     /// plain old integers.\n-    map: Vec<Option<Entry<'hir>>>,\n+    map: FxHashMap<HirId, Entry<'hir>>,\n \n     definitions: &'hir Definitions,\n \n@@ -200,7 +199,8 @@ impl<'hir> Map<'hir> {\n     /// read recorded). If the function just returns a DefId or\n     /// NodeId, no actual content was returned, so no read is needed.\n     pub fn read(&self, id: NodeId) {\n-        if let Some(entry) = self.map[id.as_usize()] {\n+        let hir_id = self.node_to_hir_id(id);\n+        if let Some(entry) = self.map.get(&hir_id) {\n             self.dep_graph.read_index(entry.dep_node);\n         } else {\n             bug!(\"called `HirMap::read()` with invalid `NodeId`: {:?}\", id)\n@@ -242,18 +242,18 @@ impl<'hir> Map<'hir> {\n     #[inline]\n     pub fn local_def_id(&self, node: NodeId) -> DefId {\n         self.opt_local_def_id(node).unwrap_or_else(|| {\n+            let hir_id = self.node_to_hir_id(node);\n             bug!(\"local_def_id: no entry for `{}`, which has a map of `{:?}`\",\n-                 node, self.find_entry(node))\n+                 node, self.find_entry(hir_id))\n         })\n     }\n \n     // FIXME(@ljedrz): replace the NodeId variant\n     #[inline]\n     pub fn local_def_id_from_hir_id(&self, hir_id: HirId) -> DefId {\n-        let node_id = self.hir_to_node_id(hir_id);\n-        self.opt_local_def_id(node_id).unwrap_or_else(|| {\n+        self.opt_local_def_id_from_hir_id(hir_id).unwrap_or_else(|| {\n             bug!(\"local_def_id_from_hir_id: no entry for `{:?}`, which has a map of `{:?}`\",\n-                 hir_id, self.find_entry(node_id))\n+                 hir_id, self.find_entry(hir_id))\n         })\n     }\n \n@@ -424,8 +424,8 @@ impl<'hir> Map<'hir> {\n         self.map.len()\n     }\n \n-    fn find_entry(&self, id: NodeId) -> Option<Entry<'hir>> {\n-        self.map.get(id.as_usize()).cloned().unwrap_or(None)\n+    fn find_entry(&self, id: HirId) -> Option<Entry<'hir>> {\n+        self.map.get(&id).cloned()\n     }\n \n     pub fn krate(&self) -> &'hir Crate {\n@@ -457,7 +457,8 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn fn_decl(&self, node_id: ast::NodeId) -> Option<FnDecl> {\n-        if let Some(entry) = self.find_entry(node_id) {\n+        let hir_id = self.node_to_hir_id(node_id);\n+        if let Some(entry) = self.find_entry(hir_id) {\n             entry.fn_decl().cloned()\n         } else {\n             bug!(\"no entry for node_id `{}`\", node_id)\n@@ -474,10 +475,9 @@ impl<'hir> Map<'hir> {\n     /// which this is the body of, i.e., a `fn`, `const` or `static`\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n     pub fn body_owner(&self, BodyId { hir_id }: BodyId) -> NodeId {\n-        let node_id = self.hir_to_node_id(hir_id);\n-        let parent = self.get_parent_node(node_id);\n-        assert!(self.map[parent.as_usize()].map_or(false, |e| e.is_body_owner(hir_id)));\n-        parent\n+        let parent = self.get_parent_node_by_hir_id(hir_id);\n+        assert!(self.map.get(&parent).map_or(false, |e| e.is_body_owner(hir_id)));\n+        self.hir_to_node_id(parent)\n     }\n \n     pub fn body_owner_def_id(&self, id: BodyId) -> DefId {\n@@ -487,9 +487,10 @@ impl<'hir> Map<'hir> {\n     /// Given a `NodeId`, returns the `BodyId` associated with it,\n     /// if the node is a body owner, otherwise returns `None`.\n     pub fn maybe_body_owned_by(&self, id: NodeId) -> Option<BodyId> {\n-        if let Some(entry) = self.find_entry(id) {\n+        let hir_id = self.node_to_hir_id(id);\n+        if let Some(entry) = self.find_entry(hir_id) {\n             if self.dep_graph.is_fully_enabled() {\n-                let hir_id_owner = self.node_to_hir_id(id).owner;\n+                let hir_id_owner = hir_id.owner;\n                 let def_path_hash = self.definitions.def_path_hash(hir_id_owner);\n                 self.dep_graph.read(def_path_hash.to_dep_node(DepKind::HirBody));\n             }\n@@ -580,11 +581,11 @@ impl<'hir> Map<'hir> {\n         &self.forest.krate.attrs\n     }\n \n-    pub fn get_module(&self, module: DefId) -> (&'hir Mod, Span, HirId) {\n-        let node_id = self.as_local_node_id(module).unwrap();\n-        let hir_id = self.node_to_hir_id(node_id);\n-        self.read(node_id);\n-        match self.find_entry(node_id).unwrap().node {\n+    pub fn get_module(&self, module: DefId) -> (&'hir Mod, Span, HirId)\n+    {\n+        let hir_id = self.as_local_hir_id(module).unwrap();\n+        self.read_by_hir_id(hir_id);\n+        match self.find_entry(hir_id).unwrap().node {\n             Node::Item(&Item {\n                 span,\n                 node: ItemKind::Mod(ref m),\n@@ -667,15 +668,16 @@ impl<'hir> Map<'hir> {\n \n     /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n     pub fn find(&self, id: NodeId) -> Option<Node<'hir>> {\n-        let result = self.find_entry(id).and_then(|entry| {\n+        let hir_id = self.node_to_hir_id(id);\n+        let result = self.find_entry(hir_id).and_then(|entry| {\n             if let Node::Crate = entry.node {\n                 None\n             } else {\n                 Some(entry.node)\n             }\n         });\n         if result.is_some() {\n-            self.read(id);\n+            self.read_by_hir_id(hir_id);\n         }\n         result\n     }\n@@ -697,13 +699,17 @@ impl<'hir> Map<'hir> {\n     /// from a node to the root of the ast (unless you get the same ID back here\n     /// that can happen if the ID is not in the map itself or is just weird).\n     pub fn get_parent_node(&self, id: NodeId) -> NodeId {\n+        let hir_id = self.node_to_hir_id(id);\n         if self.dep_graph.is_fully_enabled() {\n-            let hir_id_owner = self.node_to_hir_id(id).owner;\n+            let hir_id_owner = hir_id.owner;\n             let def_path_hash = self.definitions.def_path_hash(hir_id_owner);\n             self.dep_graph.read(def_path_hash.to_dep_node(DepKind::HirBody));\n         }\n \n-        self.find_entry(id).and_then(|x| x.parent_node()).unwrap_or(id)\n+        self.find_entry(hir_id)\n+            .and_then(|x| x.parent_node())\n+            .map(|x| self.hir_to_node_id(x))\n+            .unwrap_or(id)\n     }\n \n     // FIXME(@ljedrz): replace the NodeId variant\n@@ -740,17 +746,17 @@ impl<'hir> Map<'hir> {\n     /// is not an error, since items in the crate module have the crate root as\n     /// parent.\n     fn walk_parent_nodes<F, F2>(&self,\n-                                start_id: NodeId,\n+                                start_id: HirId,\n                                 found: F,\n                                 bail_early: F2)\n-        -> Result<NodeId, NodeId>\n+        -> Result<HirId, HirId>\n         where F: Fn(&Node<'hir>) -> bool, F2: Fn(&Node<'hir>) -> bool\n     {\n         let mut id = start_id;\n         loop {\n-            let parent_node = self.get_parent_node(id);\n-            if parent_node == CRATE_NODE_ID {\n-                return Ok(CRATE_NODE_ID);\n+            let parent_node = self.get_parent_node_by_hir_id(id);\n+            if parent_node == CRATE_HIR_ID {\n+                return Ok(CRATE_HIR_ID);\n             }\n             if parent_node == id {\n                 return Err(id);\n@@ -817,18 +823,16 @@ impl<'hir> Map<'hir> {\n             }\n         };\n \n-        let node_id = self.hir_to_node_id(id);\n-        self.walk_parent_nodes(node_id, match_fn, match_non_returning_block)\n-            .ok()\n-            .map(|return_node_id| self.node_to_hir_id(return_node_id))\n+        self.walk_parent_nodes(id, match_fn, match_non_returning_block).ok()\n     }\n \n     /// Retrieves the `NodeId` for `id`'s parent item, or `id` itself if no\n     /// parent item is in this map. The \"parent item\" is the closest parent node\n     /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n     pub fn get_parent(&self, id: NodeId) -> NodeId {\n-        match self.walk_parent_nodes(id, |node| match *node {\n+        let hir_id = self.node_to_hir_id(id);\n+        let parent_hid = match self.walk_parent_nodes(hir_id, |node| match *node {\n             Node::Item(_) |\n             Node::ForeignItem(_) |\n             Node::TraitItem(_) |\n@@ -837,7 +841,9 @@ impl<'hir> Map<'hir> {\n         }, |_| false) {\n             Ok(id) => id,\n             Err(id) => id,\n-        }\n+        };\n+\n+        self.hir_to_node_id(parent_hid)\n     }\n \n     // FIXME(@ljedrz): replace the NodeId variant\n@@ -862,28 +868,34 @@ impl<'hir> Map<'hir> {\n     /// Returns the `NodeId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n     pub fn get_module_parent_node(&self, id: NodeId) -> NodeId {\n-        match self.walk_parent_nodes(id, |node| match *node {\n+        let hir_id = self.node_to_hir_id(id);\n+        let parent_hid = match self.walk_parent_nodes(hir_id, |node| match *node {\n             Node::Item(&Item { node: ItemKind::Mod(_), .. }) => true,\n             _ => false,\n         }, |_| false) {\n             Ok(id) => id,\n             Err(id) => id,\n-        }\n+        };\n+\n+        self.hir_to_node_id(parent_hid)\n     }\n \n     /// Returns the nearest enclosing scope. A scope is an item or block.\n     /// FIXME: it is not clear to me that all items qualify as scopes -- statics\n     /// and associated types probably shouldn't, for example. Behavior in this\n     /// regard should be expected to be highly unstable.\n     pub fn get_enclosing_scope(&self, id: NodeId) -> Option<NodeId> {\n-        self.walk_parent_nodes(id, |node| match *node {\n+        let hir_id = self.node_to_hir_id(id);\n+        let parent_hid = self.walk_parent_nodes(hir_id, |node| match *node {\n             Node::Item(_) |\n             Node::ForeignItem(_) |\n             Node::TraitItem(_) |\n             Node::ImplItem(_) |\n             Node::Block(_) => true,\n             _ => false,\n-        }, |_| false).ok()\n+        }, |_| false).ok();\n+\n+        parent_hid.map(|hid| self.hir_to_node_id(hid))\n     }\n \n     pub fn get_parent_did(&self, id: NodeId) -> DefId {\n@@ -897,16 +909,17 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn get_foreign_abi(&self, id: NodeId) -> Abi {\n-        let parent = self.get_parent(id);\n+        let hir_id = self.node_to_hir_id(id);\n+        let parent = self.get_parent_item(hir_id);\n         if let Some(entry) = self.find_entry(parent) {\n             if let Entry {\n                 node: Node::Item(Item { node: ItemKind::ForeignMod(ref nm), .. }), .. } = entry\n             {\n-                self.read(id); // reveals some of the content of a node\n+                self.read_by_hir_id(hir_id); // reveals some of the content of a node\n                 return nm.abi;\n             }\n         }\n-        bug!(\"expected foreign mod or inlined parent, found {}\", self.node_to_string(parent))\n+        bug!(\"expected foreign mod or inlined parent, found {}\", self.hir_to_string(parent))\n     }\n \n     // FIXME(@ljedrz): replace the NodeId variant\n@@ -1052,13 +1065,14 @@ impl<'hir> Map<'hir> {\n             map: self,\n             item_name: parts.last().unwrap(),\n             in_which: &parts[..parts.len() - 1],\n-            idx: CRATE_NODE_ID,\n+            idx: ast::CRATE_NODE_ID,\n         }\n     }\n \n     pub fn span(&self, id: NodeId) -> Span {\n-        self.read(id); // reveals span from node\n-        match self.find_entry(id).map(|entry| entry.node) {\n+        let hir_id = self.node_to_hir_id(id);\n+        self.read_by_hir_id(hir_id); // reveals span from node\n+        match self.find_entry(hir_id).map(|entry| entry.node) {\n             Some(Node::Item(item)) => item.span,\n             Some(Node::ForeignItem(foreign_item)) => foreign_item.span,\n             Some(Node::TraitItem(trait_method)) => trait_method.span,\n@@ -1202,7 +1216,8 @@ impl<'a, 'hir> Iterator for NodesMatchingSuffix<'a, 'hir> {\n                 return None;\n             }\n             self.idx = NodeId::from_u32(self.idx.as_u32() + 1);\n-            let name = match self.map.find_entry(idx).map(|entry| entry.node) {\n+            let hir_idx = self.map.node_to_hir_id(idx);\n+            let name = match self.map.find_entry(hir_idx).map(|entry| entry.node) {\n                 Some(Node::Item(n)) => n.name(),\n                 Some(Node::ForeignItem(n)) => n.name(),\n                 Some(Node::TraitItem(n)) => n.name(),\n@@ -1260,18 +1275,6 @@ pub fn map_crate<'hir>(sess: &crate::session::Session,\n         )\n     };\n \n-    if log_enabled!(::log::Level::Debug) {\n-        // This only makes sense for ordered stores; note the\n-        // enumerate to count the number of entries.\n-        let (entries_less_1, _) = map.iter().filter_map(|x| *x).enumerate().last()\n-            .expect(\"AST map was empty after folding?\");\n-\n-        let entries = entries_less_1 + 1;\n-        let vector_length = map.len();\n-        debug!(\"The AST map has {} entries with a maximum of {}: occupancy {:.1}%\",\n-              entries, vector_length, (entries as f64 / vector_length as f64) * 100.);\n-    }\n-\n     let map = Map {\n         forest,\n         dep_graph: forest.dep_graph.clone(),"}, {"sha": "832944bd01ea2e313f54a71a77252defc11dd6eb", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16fd0f47aabbb17e98eb79ca6da7a95dc617acad/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16fd0f47aabbb17e98eb79ca6da7a95dc617acad/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=16fd0f47aabbb17e98eb79ca6da7a95dc617acad", "patch": "@@ -1809,6 +1809,7 @@ fn check_mod_privacy<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n         empty_tables: &empty_tables,\n     };\n     let (module, span, hir_id) = tcx.hir().get_module(module_def_id);\n+\n     intravisit::walk_mod(&mut visitor, module, hir_id);\n \n     // Check privacy of explicitly written types and traits as well as"}]}