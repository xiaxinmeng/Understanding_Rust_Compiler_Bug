{"sha": "93230281562cd6b1b45eff070c473e3be20d9e72", "node_id": "C_kwDOAAsO6NoAKDkzMjMwMjgxNTYyY2Q2YjFiNDVlZmYwNzBjNDczZTNiZTIwZDllNzI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-27T07:02:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-27T07:02:46Z"}, "message": "Auto merge of #94144 - est31:let_else_trait_selection, r=cjgillot\n\nrustc_trait_selection: adopt let else in more places\n\nContinuation of #89933, #91018, #91481, #93046, #93590, #94011.\n\nI have extended my clippy lint to also recognize tuple passing and match statements. The diff caused by fixing it is way above 1 thousand lines. Thus, I split it up into multiple pull requests to make reviewing easier. This PR handles rustc_trait_selection.", "tree": {"sha": "5463ee22f4457cf23f61f2f961b4699d181d08c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5463ee22f4457cf23f61f2f961b4699d181d08c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93230281562cd6b1b45eff070c473e3be20d9e72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93230281562cd6b1b45eff070c473e3be20d9e72", "html_url": "https://github.com/rust-lang/rust/commit/93230281562cd6b1b45eff070c473e3be20d9e72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93230281562cd6b1b45eff070c473e3be20d9e72/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6abd8cd64339c56ffa768cd440a08a1c0b637bbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/6abd8cd64339c56ffa768cd440a08a1c0b637bbe", "html_url": "https://github.com/rust-lang/rust/commit/6abd8cd64339c56ffa768cd440a08a1c0b637bbe"}, {"sha": "dab5c4480011fadde4302ae356e0a631154d7f08", "url": "https://api.github.com/repos/rust-lang/rust/commits/dab5c4480011fadde4302ae356e0a631154d7f08", "html_url": "https://github.com/rust-lang/rust/commit/dab5c4480011fadde4302ae356e0a631154d7f08"}], "stats": {"total": 192, "additions": 75, "deletions": 117}, "files": [{"sha": "c9398d746d72115dd6f3a4f96664ac1f0c9ad5cf", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/93230281562cd6b1b45eff070c473e3be20d9e72/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93230281562cd6b1b45eff070c473e3be20d9e72/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=93230281562cd6b1b45eff070c473e3be20d9e72", "patch": "@@ -148,17 +148,16 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n             // traits::project will see that 'T: SomeTrait' is in our ParamEnv, allowing\n             // SelectionContext to return it back to us.\n \n-            let (new_env, user_env) = match self.evaluate_predicates(\n+            let Some((new_env, user_env)) = self.evaluate_predicates(\n                 &infcx,\n                 trait_did,\n                 ty,\n                 orig_env,\n                 orig_env,\n                 &mut fresh_preds,\n                 false,\n-            ) {\n-                Some(e) => e,\n-                None => return AutoTraitResult::NegativeImpl,\n+            ) else {\n+                return AutoTraitResult::NegativeImpl;\n             };\n \n             let (full_env, full_user_env) = self"}, {"sha": "018d1eefef7d289e6dba87c9fa62f626eb0b4282", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/93230281562cd6b1b45eff070c473e3be20d9e72/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93230281562cd6b1b45eff070c473e3be20d9e72/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=93230281562cd6b1b45eff070c473e3be20d9e72", "patch": "@@ -328,18 +328,15 @@ fn negative_impl<'cx, 'tcx>(\n             impl_trait_ref_and_oblig(selcx, impl1_env, impl2_def_id, impl2_substs);\n \n         // do the impls unify? If not, not disjoint.\n-        let more_obligations = match infcx\n+        let Ok(InferOk { obligations: more_obligations, .. }) = infcx\n             .at(&ObligationCause::dummy(), impl1_env)\n             .eq(impl1_trait_ref, impl2_trait_ref)\n-        {\n-            Ok(InferOk { obligations, .. }) => obligations,\n-            Err(_) => {\n-                debug!(\n-                    \"explicit_disjoint: {:?} does not unify with {:?}\",\n-                    impl1_trait_ref, impl2_trait_ref\n-                );\n-                return false;\n-            }\n+        else {\n+            debug!(\n+                \"explicit_disjoint: {:?} does not unify with {:?}\",\n+                impl1_trait_ref, impl2_trait_ref\n+            );\n+            return false;\n         };\n \n         let opt_failing_obligation = obligations"}, {"sha": "82c3f79a4fa7bbfb98aef7943d52a3948bb29476", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/93230281562cd6b1b45eff070c473e3be20d9e72/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93230281562cd6b1b45eff070c473e3be20d9e72/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=93230281562cd6b1b45eff070c473e3be20d9e72", "patch": "@@ -804,9 +804,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     return;\n                 }\n \n-                let found_trait_ty = match found_trait_ref.self_ty().no_bound_vars() {\n-                    Some(ty) => ty,\n-                    None => return,\n+                let Some(found_trait_ty) = found_trait_ref.self_ty().no_bound_vars() else {\n+                    return;\n                 };\n \n                 let found_did = match *found_trait_ty.kind() {\n@@ -2097,26 +2096,24 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n         err: &mut Diagnostic,\n         obligation: &PredicateObligation<'tcx>,\n     ) {\n-        let (pred, item_def_id, span) = match (\n+        let (\n+            ty::PredicateKind::Trait(pred),\n+            &ObligationCauseCode::BindingObligation(item_def_id, span),\n+        ) = (\n             obligation.predicate.kind().skip_binder(),\n             obligation.cause.code().peel_derives(),\n-        ) {\n-            (\n-                ty::PredicateKind::Trait(pred),\n-                &ObligationCauseCode::BindingObligation(item_def_id, span),\n-            ) => (pred, item_def_id, span),\n-            _ => return,\n+        )  else {\n+            return;\n         };\n         debug!(\n             \"suggest_unsized_bound_if_applicable: pred={:?} item_def_id={:?} span={:?}\",\n             pred, item_def_id, span\n         );\n-        let node = match (\n+        let (Some(node), true) = (\n             self.tcx.hir().get_if_local(item_def_id),\n             Some(pred.def_id()) == self.tcx.lang_items().sized_trait(),\n-        ) {\n-            (Some(node), true) => node,\n-            _ => return,\n+        ) else {\n+            return;\n         };\n         self.maybe_suggest_unsized_generics(err, span, node);\n     }\n@@ -2127,9 +2124,8 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n         span: Span,\n         node: Node<'hir>,\n     ) {\n-        let generics = match node.generics() {\n-            Some(generics) => generics,\n-            None => return,\n+        let Some(generics) = node.generics() else {\n+            return;\n         };\n         let sized_trait = self.tcx.lang_items().sized_trait();\n         debug!(\"maybe_suggest_unsized_generics: generics.params={:?}\", generics.params);\n@@ -2142,9 +2138,8 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                 .iter()\n                 .all(|bound| bound.trait_ref().and_then(|tr| tr.trait_def_id()) != sized_trait)\n         });\n-        let param = match param {\n-            Some(param) => param,\n-            _ => return,\n+        let Some(param) = param else {\n+            return;\n         };\n         let param_def_id = self.tcx.hir().local_def_id(param.hir_id).to_def_id();\n         let preds = generics.where_clause.predicates.iter();"}, {"sha": "45bfb2b1e9413fd9779ccc58fa7d033b9ba08e4d", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/93230281562cd6b1b45eff070c473e3be20d9e72/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93230281562cd6b1b45eff070c473e3be20d9e72/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=93230281562cd6b1b45eff070c473e3be20d9e72", "patch": "@@ -512,9 +512,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             | ObligationCauseCode::BuiltinDerivedObligation(cause) => cause.parent_trait_pred,\n             _ => trait_pred,\n         };\n-        let real_ty = match real_trait_pred.self_ty().no_bound_vars() {\n-            Some(ty) => ty,\n-            None => return,\n+        let Some(real_ty) = real_trait_pred.self_ty().no_bound_vars() else {\n+            return;\n         };\n \n         if let ty::Ref(region, base_ty, mutbl) = *real_ty.kind() {\n@@ -586,9 +585,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) {\n-        let self_ty = match trait_pred.self_ty().no_bound_vars() {\n-            None => return,\n-            Some(ty) => ty,\n+        let Some(self_ty) = trait_pred.self_ty().no_bound_vars() else {\n+            return;\n         };\n \n         let (def_id, output_ty, callable) = match *self_ty.kind() {\n@@ -600,9 +598,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         // `mk_trait_obligation_with_new_self_ty` only works for types with no escaping bound\n         // variables, so bail out if we have any.\n-        let output_ty = match output_ty.no_bound_vars() {\n-            Some(ty) => ty,\n-            None => return,\n+        let Some(output_ty) = output_ty.no_bound_vars() else {\n+            return;\n         };\n \n         let new_obligation =\n@@ -624,9 +621,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 ..\n             })) => {\n                 err.span_label(*span, \"consider calling this closure\");\n-                let name = match self.get_closure_name(def_id, err, &msg) {\n-                    Some(name) => name,\n-                    None => return,\n+                let Some(name) = self.get_closure_name(def_id, err, &msg) else {\n+                    return;\n                 };\n                 let args = decl.inputs.iter().map(|_| \"_\").collect::<Vec<_>>().join(\", \");\n                 let sugg = format!(\"({})\", args);\n@@ -823,9 +819,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 return;\n             }\n \n-            let mut suggested_ty = match trait_pred.self_ty().no_bound_vars() {\n-                Some(ty) => ty,\n-                None => return,\n+            let Some(mut suggested_ty) = trait_pred.self_ty().no_bound_vars() else {\n+                return;\n             };\n \n             for refs_remaining in 0..refs_number {\n@@ -1039,9 +1034,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn return_type_span(&self, obligation: &PredicateObligation<'tcx>) -> Option<Span> {\n         let hir = self.tcx.hir();\n         let parent_node = hir.get_parent_node(obligation.cause.body_id);\n-        let sig = match hir.find(parent_node) {\n-            Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(sig, ..), .. })) => sig,\n-            _ => return None,\n+        let Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(sig, ..), .. })) = hir.find(parent_node) else {\n+            return None;\n         };\n \n         if let hir::FnRetTy::Return(ret_ty) = sig.decl.output { Some(ret_ty.span) } else { None }\n@@ -1491,11 +1485,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         // Only continue if a generator was found.\n         debug!(?generator, ?trait_ref, ?target_ty, \"maybe_note_obligation_cause_for_async_await\");\n-        let (generator_did, trait_ref, target_ty) = match (generator, trait_ref, target_ty) {\n-            (Some(generator_did), Some(trait_ref), Some(target_ty)) => {\n-                (generator_did, trait_ref, target_ty)\n-            }\n-            _ => return false,\n+        let (Some(generator_did), Some(trait_ref), Some(target_ty)) = (generator, trait_ref, target_ty) else {\n+            return false;\n         };\n \n         let span = self.tcx.def_span(generator_did);"}, {"sha": "3e095dceb21e1583c03c564a89b0c60d7add3ad9", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/93230281562cd6b1b45eff070c473e3be20d9e72/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93230281562cd6b1b45eff070c473e3be20d9e72/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=93230281562cd6b1b45eff070c473e3be20d9e72", "patch": "@@ -340,19 +340,16 @@ pub fn normalize_param_env_or_error<'tcx>(\n         \"normalize_param_env_or_error: predicates=(non-outlives={:?}, outlives={:?})\",\n         predicates, outlives_predicates\n     );\n-    let non_outlives_predicates = match do_normalize_predicates(\n+    let Ok(non_outlives_predicates) = do_normalize_predicates(\n         tcx,\n         region_context,\n         cause.clone(),\n         elaborated_env,\n         predicates,\n-    ) {\n-        Ok(predicates) => predicates,\n+    ) else {\n         // An unnormalized env is better than nothing.\n-        Err(ErrorReported) => {\n-            debug!(\"normalize_param_env_or_error: errored resolving non-outlives predicates\");\n-            return elaborated_env;\n-        }\n+        debug!(\"normalize_param_env_or_error: errored resolving non-outlives predicates\");\n+        return elaborated_env;\n     };\n \n     debug!(\"normalize_param_env_or_error: non-outlives predicates={:?}\", non_outlives_predicates);\n@@ -367,19 +364,16 @@ pub fn normalize_param_env_or_error<'tcx>(\n         unnormalized_env.reveal(),\n         unnormalized_env.constness(),\n     );\n-    let outlives_predicates = match do_normalize_predicates(\n+    let Ok(outlives_predicates) = do_normalize_predicates(\n         tcx,\n         region_context,\n         cause,\n         outlives_env,\n         outlives_predicates,\n-    ) {\n-        Ok(predicates) => predicates,\n+    ) else {\n         // An unnormalized env is better than nothing.\n-        Err(ErrorReported) => {\n-            debug!(\"normalize_param_env_or_error: errored resolving outlives predicates\");\n-            return elaborated_env;\n-        }\n+        debug!(\"normalize_param_env_or_error: errored resolving outlives predicates\");\n+        return elaborated_env;\n     };\n     debug!(\"normalize_param_env_or_error: outlives predicates={:?}\", outlives_predicates);\n \n@@ -834,9 +828,8 @@ pub fn vtable_trait_upcasting_coercion_new_vptr_slot<'tcx>(\n         selcx.select(&obligation).unwrap()\n     });\n \n-    let implsrc_traitcasting = match implsrc {\n-        Some(ImplSource::TraitUpcasting(data)) => data,\n-        _ => bug!(),\n+    let Some(ImplSource::TraitUpcasting(implsrc_traitcasting)) = implsrc else {\n+        bug!();\n     };\n \n     implsrc_traitcasting.vtable_vptr_slot"}, {"sha": "6cceec8621304cf3e5db3a449be8dfde588f15f6", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/93230281562cd6b1b45eff070c473e3be20d9e72/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93230281562cd6b1b45eff070c473e3be20d9e72/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=93230281562cd6b1b45eff070c473e3be20d9e72", "patch": "@@ -322,11 +322,8 @@ fn trait_has_sized_self(tcx: TyCtxt<'_>, trait_def_id: DefId) -> bool {\n }\n \n fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    let sized_def_id = match tcx.lang_items().sized_trait() {\n-        Some(def_id) => def_id,\n-        None => {\n-            return false; /* No Sized trait, can't require it! */\n-        }\n+    let Some(sized_def_id) = tcx.lang_items().sized_trait() else {\n+        return false; /* No Sized trait, can't require it! */\n     };\n \n     // Search for a predicate like `Self : Sized` amongst the trait bounds."}, {"sha": "b4ca1cad1efe245402af04caa01b2a0efb939f75", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/93230281562cd6b1b45eff070c473e3be20d9e72/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93230281562cd6b1b45eff070c473e3be20d9e72/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=93230281562cd6b1b45eff070c473e3be20d9e72", "patch": "@@ -1830,9 +1830,8 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n \n     let param_env = obligation.param_env;\n-    let assoc_ty = match assoc_def(selcx, impl_def_id, assoc_item_id) {\n-        Ok(assoc_ty) => assoc_ty,\n-        Err(ErrorReported) => return Progress { term: tcx.ty_error().into(), obligations: nested },\n+    let Ok(assoc_ty) = assoc_def(selcx, impl_def_id, assoc_item_id) else {\n+        return Progress { term: tcx.ty_error().into(), obligations: nested };\n     };\n \n     if !assoc_ty.item.defaultness.has_value() {"}, {"sha": "d76bcf6807f99541000e5d502d1f191441f0e680", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/93230281562cd6b1b45eff070c473e3be20d9e72/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93230281562cd6b1b45eff070c473e3be20d9e72/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=93230281562cd6b1b45eff070c473e3be20d9e72", "patch": "@@ -436,11 +436,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) {\n-        let kind = match self.tcx().fn_trait_kind_from_lang_item(obligation.predicate.def_id()) {\n-            Some(k) => k,\n-            None => {\n-                return;\n-            }\n+        let Some(kind) = self.tcx().fn_trait_kind_from_lang_item(obligation.predicate.def_id()) else {\n+            return;\n         };\n \n         // Okay to skip binder because the substs on closure types never\n@@ -763,12 +760,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         //     T: Trait\n         // so it seems ok if we (conservatively) fail to accept that `Unsize`\n         // obligation above. Should be possible to extend this in the future.\n-        let source = match obligation.self_ty().no_bound_vars() {\n-            Some(t) => t,\n-            None => {\n-                // Don't add any candidates if there are bound regions.\n-                return;\n-            }\n+        let Some(source) = obligation.self_ty().no_bound_vars() else {\n+            // Don't add any candidates if there are bound regions.\n+            return;\n         };\n         let target = obligation.predicate.skip_binder().trait_ref.substs.type_at(1);\n "}, {"sha": "c7e0c35436afb9752f7b6c3a6002dd295b5861a1", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/93230281562cd6b1b45eff070c473e3be20d9e72/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93230281562cd6b1b45eff070c473e3be20d9e72/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=93230281562cd6b1b45eff070c473e3be20d9e72", "patch": "@@ -272,9 +272,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             } else {\n                 bug!(\"unexpected builtin trait {:?}\", trait_def)\n             };\n-            let nested = match conditions {\n-                BuiltinImplConditions::Where(nested) => nested,\n-                _ => bug!(\"obligation {:?} had matched a builtin impl but now doesn't\", obligation),\n+            let BuiltinImplConditions::Where(nested) = conditions else {\n+                bug!(\"obligation {:?} had matched a builtin impl but now doesn't\", obligation);\n             };\n \n             let cause = obligation.derived_cause(BuiltinDerivedObligation);\n@@ -421,9 +420,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let trait_predicate = self.infcx.replace_bound_vars_with_placeholders(obligation.predicate);\n         let self_ty = self.infcx.shallow_resolve(trait_predicate.self_ty());\n         let obligation_trait_ref = ty::Binder::dummy(trait_predicate.trait_ref);\n-        let data = match *self_ty.kind() {\n-            ty::Dynamic(data, ..) => data,\n-            _ => span_bug!(obligation.cause.span, \"object candidate with non-object\"),\n+        let ty::Dynamic(data, ..) = *self_ty.kind() else {\n+            span_bug!(obligation.cause.span, \"object candidate with non-object\");\n         };\n \n         let object_trait_ref = data.principal().unwrap_or_else(|| {\n@@ -593,9 +591,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters.\n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n-        let (generator_def_id, substs) = match *self_ty.kind() {\n-            ty::Generator(id, substs, _) => (id, substs),\n-            _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n+        let ty::Generator(generator_def_id, substs, _) = *self_ty.kind() else {\n+            bug!(\"closure candidate for non-closure {:?}\", obligation);\n         };\n \n         debug!(?obligation, ?generator_def_id, ?substs, \"confirm_generator_candidate\");\n@@ -622,9 +619,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters.\n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty().skip_binder());\n-        let (closure_def_id, substs) = match *self_ty.kind() {\n-            ty::Closure(id, substs) => (id, substs),\n-            _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n+        let ty::Closure(closure_def_id, substs) = *self_ty.kind() else {\n+            bug!(\"closure candidate for non-closure {:?}\", obligation);\n         };\n \n         let trait_ref = self.closure_trait_ref_unnormalized(obligation, substs);"}, {"sha": "a8a53c297d1a47ae89610beeedbd16b0fd5adc0c", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/93230281562cd6b1b45eff070c473e3be20d9e72/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93230281562cd6b1b45eff070c473e3be20d9e72/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=93230281562cd6b1b45eff070c473e3be20d9e72", "patch": "@@ -192,18 +192,15 @@ fn fulfill_implication<'a, 'tcx>(\n         impl_trait_ref_and_oblig(selcx, param_env, target_impl, target_substs);\n \n     // do the impls unify? If not, no specialization.\n-    let more_obligations =\n-        match infcx.at(&ObligationCause::dummy(), param_env).eq(source_trait_ref, target_trait_ref)\n-        {\n-            Ok(InferOk { obligations, .. }) => obligations,\n-            Err(_) => {\n-                debug!(\n-                    \"fulfill_implication: {:?} does not unify with {:?}\",\n-                    source_trait_ref, target_trait_ref\n-                );\n-                return Err(());\n-            }\n-        };\n+    let Ok(InferOk { obligations: more_obligations, .. }) =\n+        infcx.at(&ObligationCause::dummy(), param_env).eq(source_trait_ref, target_trait_ref)\n+    else {\n+        debug!(\n+            \"fulfill_implication: {:?} does not unify with {:?}\",\n+            source_trait_ref, target_trait_ref\n+        );\n+        return Err(());\n+    };\n \n     // attempt to prove all of the predicates for impl2 given those for impl1\n     // (which are packed up in penv)"}]}