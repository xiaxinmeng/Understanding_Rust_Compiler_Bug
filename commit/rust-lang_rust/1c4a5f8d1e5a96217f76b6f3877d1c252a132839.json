{"sha": "1c4a5f8d1e5a96217f76b6f3877d1c252a132839", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjNGE1ZjhkMWU1YTk2MjE3Zjc2YjZmMzg3N2QxYzI1MmExMzI4Mzk=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-10-01T23:25:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-01T23:25:15Z"}, "message": "Rollup merge of #77147 - fusion-engineering-forks:static-mutex, r=dtolnay\n\nSplit sys_common::Mutex in StaticMutex and MovableMutex.\n\nThe (unsafe) `Mutex` from `sys_common` had a rather complicated interface. You were supposed to call `init()` manually, unless you could guarantee it was neither moved nor used reentrantly.\n\nCalling `destroy()` was also optional, although it was unclear if 1) resources might be leaked or not, and 2) if `destroy()` should only be called when `init()` was called.\n\nThis allowed for a number of interesting (confusing?) different ways to use this `Mutex`, all captured in a single type.\n\nIn practice, this type was only ever used in two ways:\n\n1. As a static variable. In this case, neither `init()` nor `destroy()` are called. The variable is never moved, and it is never used reentrantly. It is only ever locked using the `LockGuard`, never with `raw_lock`.\n\n2. As a `Box`ed variable. In this case, both `init()` and `destroy()` are called, it will be moved and possibly used reentrantly.\n\nNo other combinations are used anywhere in `std`.\n\nThis change simplifies things by splitting this `Mutex` type into two types matching the two use cases: `StaticMutex` and `MovableMutex`.\n\nThe interface of both new types is now both safer and simpler. The first one does not call nor expose `init`/`destroy`, and the second one calls those automatically in its `new()` and `Drop` functions. Also, the locking functions of `MovableMutex` are no longer unsafe.\n\n---\n\nThis will also make it easier to conditionally box mutexes later, by moving that decision into sys/sys_common. Some of the mutex implementations (at least those of Wasm and 'sys/unsupported') are safe to move, so wouldn't need a box. ~~(But that's blocked on  #76932 for now.)~~ (See #77380.)", "tree": {"sha": "971bd61fb505cc83127e03bcc3a27df4e69afd0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/971bd61fb505cc83127e03bcc3a27df4e69afd0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c4a5f8d1e5a96217f76b6f3877d1c252a132839", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfdmVbCRBK7hj4Ov3rIwAAdHIIAKd6F8qzielfvSnkLSjkroeV\n9VDf9sjT1Nj7Wd4p3nT9hUxXXrM2Aqy5DgRVkgD1/DDDkoseLAGRtEeyXoMEPvOU\nqYDwYhHtIDZ5P73r452Eg8Llzc1vtUjon+2UOXvmkKwG44Tnn7/b1+Qo0vbKD/tl\ntoxtLNaKM/EaVVV8lvnjVZkbTyN0/IYwXiChWMbBODYjcmWq4aNHF8Nl4k/HuJZh\nHp2qHx1YpI1sxerocAly9cpefaLfWI+YiLlZ9Q/mMbhzPwhyeoHO51IYPyJsaRZ0\ngv8wU+pVbd2bYlMfZNHfZ/bvqXuYQvdruCP4yMq7mCpCwC1+f/bHnokVsBCdOD0=\n=Un5U\n-----END PGP SIGNATURE-----\n", "payload": "tree 971bd61fb505cc83127e03bcc3a27df4e69afd0c\nparent 9eaf536c3265ac974ff033f6a13fc5904986ac1d\nparent 825dda80601bdb34ef21065052a8866df0fe0838\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1601594715 +0900\ncommitter GitHub <noreply@github.com> 1601594715 +0900\n\nRollup merge of #77147 - fusion-engineering-forks:static-mutex, r=dtolnay\n\nSplit sys_common::Mutex in StaticMutex and MovableMutex.\n\nThe (unsafe) `Mutex` from `sys_common` had a rather complicated interface. You were supposed to call `init()` manually, unless you could guarantee it was neither moved nor used reentrantly.\n\nCalling `destroy()` was also optional, although it was unclear if 1) resources might be leaked or not, and 2) if `destroy()` should only be called when `init()` was called.\n\nThis allowed for a number of interesting (confusing?) different ways to use this `Mutex`, all captured in a single type.\n\nIn practice, this type was only ever used in two ways:\n\n1. As a static variable. In this case, neither `init()` nor `destroy()` are called. The variable is never moved, and it is never used reentrantly. It is only ever locked using the `LockGuard`, never with `raw_lock`.\n\n2. As a `Box`ed variable. In this case, both `init()` and `destroy()` are called, it will be moved and possibly used reentrantly.\n\nNo other combinations are used anywhere in `std`.\n\nThis change simplifies things by splitting this `Mutex` type into two types matching the two use cases: `StaticMutex` and `MovableMutex`.\n\nThe interface of both new types is now both safer and simpler. The first one does not call nor expose `init`/`destroy`, and the second one calls those automatically in its `new()` and `Drop` functions. Also, the locking functions of `MovableMutex` are no longer unsafe.\n\n---\n\nThis will also make it easier to conditionally box mutexes later, by moving that decision into sys/sys_common. Some of the mutex implementations (at least those of Wasm and 'sys/unsupported') are safe to move, so wouldn't need a box. ~~(But that's blocked on  #76932 for now.)~~ (See #77380.)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c4a5f8d1e5a96217f76b6f3877d1c252a132839", "html_url": "https://github.com/rust-lang/rust/commit/1c4a5f8d1e5a96217f76b6f3877d1c252a132839", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9eaf536c3265ac974ff033f6a13fc5904986ac1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9eaf536c3265ac974ff033f6a13fc5904986ac1d", "html_url": "https://github.com/rust-lang/rust/commit/9eaf536c3265ac974ff033f6a13fc5904986ac1d"}, {"sha": "825dda80601bdb34ef21065052a8866df0fe0838", "url": "https://api.github.com/repos/rust-lang/rust/commits/825dda80601bdb34ef21065052a8866df0fe0838", "html_url": "https://github.com/rust-lang/rust/commit/825dda80601bdb34ef21065052a8866df0fe0838"}], "stats": {"total": 237, "additions": 104, "deletions": 133}, "files": [{"sha": "1376d8ebe8f4a6478f358f1be05dedc890767740", "filename": "library/std/src/sync/condvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs?ref=1c4a5f8d1e5a96217f76b6f3877d1c252a132839", "patch": "@@ -553,8 +553,8 @@ impl Condvar {\n         unsafe { self.inner.notify_all() }\n     }\n \n-    fn verify(&self, mutex: &sys_mutex::Mutex) {\n-        let addr = mutex as *const _ as usize;\n+    fn verify(&self, mutex: &sys_mutex::MovableMutex) {\n+        let addr = mutex.raw() as *const _ as usize;\n         match self.mutex.compare_and_swap(0, addr, Ordering::SeqCst) {\n             // If we got out 0, then we have successfully bound the mutex to\n             // this cvar."}, {"sha": "e8f5a6f42948601dd831c3304e07a1cbae326453", "filename": "library/std/src/sync/mutex.rs", "status": "modified", "additions": 4, "deletions": 26, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs?ref=1c4a5f8d1e5a96217f76b6f3877d1c252a132839", "patch": "@@ -166,12 +166,7 @@ use crate::sys_common::poison::{self, LockResult, TryLockError, TryLockResult};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"mutex_type\")]\n pub struct Mutex<T: ?Sized> {\n-    // Note that this mutex is in a *box*, not inlined into the struct itself.\n-    // Once a native mutex has been used once, its address can never change (it\n-    // can't be moved). This mutex type can be safely moved at any time, so to\n-    // ensure that the native mutex is used correctly we box the inner mutex to\n-    // give it a constant address.\n-    inner: Box<sys::Mutex>,\n+    inner: sys::MovableMutex,\n     poison: poison::Flag,\n     data: UnsafeCell<T>,\n }\n@@ -218,15 +213,11 @@ impl<T> Mutex<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(t: T) -> Mutex<T> {\n-        let mut m = Mutex {\n-            inner: box sys::Mutex::new(),\n+        Mutex {\n+            inner: sys::MovableMutex::new(),\n             poison: poison::Flag::new(),\n             data: UnsafeCell::new(t),\n-        };\n-        unsafe {\n-            m.inner.init();\n         }\n-        m\n     }\n }\n \n@@ -378,7 +369,6 @@ impl<T: ?Sized> Mutex<T> {\n                 (ptr::read(inner), ptr::read(poison), ptr::read(data))\n             };\n             mem::forget(self);\n-            inner.destroy(); // Keep in sync with the `Drop` impl.\n             drop(inner);\n \n             poison::map_result(poison.borrow(), |_| data.into_inner())\n@@ -411,18 +401,6 @@ impl<T: ?Sized> Mutex<T> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<#[may_dangle] T: ?Sized> Drop for Mutex<T> {\n-    fn drop(&mut self) {\n-        // This is actually safe b/c we know that there is no further usage of\n-        // this mutex (it's up to the user to arrange for a mutex to get\n-        // dropped, that's not our job)\n-        //\n-        // IMPORTANT: This code must be kept in sync with `Mutex::into_inner`.\n-        unsafe { self.inner.destroy() }\n-    }\n-}\n-\n #[stable(feature = \"mutex_from\", since = \"1.24.0\")]\n impl<T> From<T> for Mutex<T> {\n     /// Creates a new mutex in an unlocked state ready for use.\n@@ -509,7 +487,7 @@ impl<T: ?Sized + fmt::Display> fmt::Display for MutexGuard<'_, T> {\n     }\n }\n \n-pub fn guard_lock<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a sys::Mutex {\n+pub fn guard_lock<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a sys::MovableMutex {\n     &guard.lock.inner\n }\n "}, {"sha": "7727293927282b34e8b1afb750ec36faffbd93d1", "filename": "library/std/src/sys/hermit/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fargs.rs?ref=1c4a5f8d1e5a96217f76b6f3877d1c252a132839", "patch": "@@ -57,11 +57,11 @@ mod imp {\n     use crate::ptr;\n     use crate::sys_common::os_str_bytes::*;\n \n-    use crate::sys_common::mutex::Mutex;\n+    use crate::sys_common::mutex::StaticMutex;\n \n     static mut ARGC: isize = 0;\n     static mut ARGV: *const *const u8 = ptr::null();\n-    static LOCK: Mutex = Mutex::new();\n+    static LOCK: StaticMutex = StaticMutex::new();\n \n     pub unsafe fn init(argc: isize, argv: *const *const u8) {\n         let _guard = LOCK.lock();"}, {"sha": "f7c3f163718183510d78d904fc4bc3773f3aaf8e", "filename": "library/std/src/sys/unix/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs?ref=1c4a5f8d1e5a96217f76b6f3877d1c252a132839", "patch": "@@ -80,13 +80,13 @@ mod imp {\n     use crate::ptr;\n     use crate::sync::atomic::{AtomicIsize, AtomicPtr, Ordering};\n \n-    use crate::sys_common::mutex::Mutex;\n+    use crate::sys_common::mutex::StaticMutex;\n \n     static ARGC: AtomicIsize = AtomicIsize::new(0);\n     static ARGV: AtomicPtr<*const u8> = AtomicPtr::new(ptr::null_mut());\n     // We never call `ENV_LOCK.init()`, so it is UB to attempt to\n     // acquire this mutex reentrantly!\n-    static LOCK: Mutex = Mutex::new();\n+    static LOCK: StaticMutex = StaticMutex::new();\n \n     unsafe fn really_init(argc: isize, argv: *const *const u8) {\n         let _guard = LOCK.lock();"}, {"sha": "c9f9ed01e120e259b6cf408bf7e91bd5addc1521", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=1c4a5f8d1e5a96217f76b6f3877d1c252a132839", "patch": "@@ -21,7 +21,7 @@ use crate::slice;\n use crate::str;\n use crate::sys::cvt;\n use crate::sys::fd;\n-use crate::sys_common::mutex::{Mutex, MutexGuard};\n+use crate::sys_common::mutex::{StaticMutex, StaticMutexGuard};\n use crate::vec;\n \n use libc::{c_char, c_int, c_void};\n@@ -470,10 +470,9 @@ pub unsafe fn environ() -> *mut *const *const c_char {\n     &mut environ\n }\n \n-pub unsafe fn env_lock() -> MutexGuard<'static> {\n-    // We never call `ENV_LOCK.init()`, so it is UB to attempt to\n-    // acquire this mutex reentrantly!\n-    static ENV_LOCK: Mutex = Mutex::new();\n+pub unsafe fn env_lock() -> StaticMutexGuard<'static> {\n+    // It is UB to attempt to acquire this mutex reentrantly!\n+    static ENV_LOCK: StaticMutex = StaticMutex::new();\n     ENV_LOCK.lock()\n }\n "}, {"sha": "30cf7a707c7af9e08d53ec1e6719d98f837ab357", "filename": "library/std/src/sys/vxworks/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fargs.rs?ref=1c4a5f8d1e5a96217f76b6f3877d1c252a132839", "patch": "@@ -57,11 +57,11 @@ mod imp {\n     use crate::marker::PhantomData;\n     use crate::ptr;\n \n-    use crate::sys_common::mutex::Mutex;\n+    use crate::sys_common::mutex::StaticMutex;\n \n     static mut ARGC: isize = 0;\n     static mut ARGV: *const *const u8 = ptr::null();\n-    static LOCK: Mutex = Mutex::new();\n+    static LOCK: StaticMutex = StaticMutex::new();\n \n     pub unsafe fn init(argc: isize, argv: *const *const u8) {\n         let _guard = LOCK.lock();"}, {"sha": "08394a8d29de1c3e024646951c0c51d5443b1341", "filename": "library/std/src/sys/vxworks/os.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fos.rs?ref=1c4a5f8d1e5a96217f76b6f3877d1c252a132839", "patch": "@@ -10,7 +10,7 @@ use crate::path::{self, Path, PathBuf};\n use crate::slice;\n use crate::str;\n use crate::sys::cvt;\n-use crate::sys_common::mutex::{Mutex, MutexGuard};\n+use crate::sys_common::mutex::{StaticMutex, StaticMutexGuard};\n use libc::{self, c_char /*,c_void */, c_int};\n /*use sys::fd; this one is probably important */\n use crate::vec;\n@@ -212,10 +212,9 @@ pub unsafe fn environ() -> *mut *const *const c_char {\n     &mut environ\n }\n \n-pub unsafe fn env_lock() -> MutexGuard<'static> {\n-    // We never call `ENV_LOCK.init()`, so it is UB to attempt to\n-    // acquire this mutex reentrantly!\n-    static ENV_LOCK: Mutex = Mutex::new();\n+pub unsafe fn env_lock() -> StaticMutexGuard<'static> {\n+    // It is UB to attempt to acquire this mutex reentrantly!\n+    static ENV_LOCK: StaticMutex = StaticMutex::new();\n     ENV_LOCK.lock()\n }\n "}, {"sha": "90d5d3a78987fe6b289745fbc3490ab77af36a00", "filename": "library/std/src/sys_common/at_exit_imp.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Fsys_common%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Fsys_common%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fat_exit_imp.rs?ref=1c4a5f8d1e5a96217f76b6f3877d1c252a132839", "patch": "@@ -4,17 +4,16 @@\n \n use crate::mem;\n use crate::ptr;\n-use crate::sys_common::mutex::Mutex;\n+use crate::sys_common::mutex::StaticMutex;\n \n type Queue = Vec<Box<dyn FnOnce()>>;\n \n // NB these are specifically not types from `std::sync` as they currently rely\n // on poisoning and this module needs to operate at a lower level than requiring\n // the thread infrastructure to be in place (useful on the borders of\n // initialization/destruction).\n-// We never call `LOCK.init()`, so it is UB to attempt to\n-// acquire this mutex reentrantly!\n-static LOCK: Mutex = Mutex::new();\n+// It is UB to attempt to acquire this mutex reentrantly!\n+static LOCK: StaticMutex = StaticMutex::new();\n static mut QUEUE: *mut Queue = ptr::null_mut();\n \n const DONE: *mut Queue = 1_usize as *mut _;"}, {"sha": "a48d301f8127bbc18731de82b6eafddf2e91fd9d", "filename": "library/std/src/sys_common/condvar.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar.rs?ref=1c4a5f8d1e5a96217f76b6f3877d1c252a132839", "patch": "@@ -1,5 +1,5 @@\n use crate::sys::condvar as imp;\n-use crate::sys_common::mutex::{self, Mutex};\n+use crate::sys_common::mutex::MovableMutex;\n use crate::time::Duration;\n \n /// An OS-based condition variable.\n@@ -46,8 +46,8 @@ impl Condvar {\n     /// Behavior is also undefined if more than one mutex is used concurrently\n     /// on this condition variable.\n     #[inline]\n-    pub unsafe fn wait(&self, mutex: &Mutex) {\n-        self.0.wait(mutex::raw(mutex))\n+    pub unsafe fn wait(&self, mutex: &MovableMutex) {\n+        self.0.wait(mutex.raw())\n     }\n \n     /// Waits for a signal on the specified mutex with a timeout duration\n@@ -57,8 +57,8 @@ impl Condvar {\n     /// Behavior is also undefined if more than one mutex is used concurrently\n     /// on this condition variable.\n     #[inline]\n-    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n-        self.0.wait_timeout(mutex::raw(mutex), dur)\n+    pub unsafe fn wait_timeout(&self, mutex: &MovableMutex, dur: Duration) -> bool {\n+        self.0.wait_timeout(mutex.raw(), dur)\n     }\n \n     /// Deallocates all resources associated with this condition variable."}, {"sha": "93ec7d89bc5c7e26152f34d5c316f26217354f83", "filename": "library/std/src/sys_common/mutex.rs", "status": "modified", "additions": 66, "deletions": 61, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs?ref=1c4a5f8d1e5a96217f76b6f3877d1c252a132839", "patch": "@@ -1,101 +1,106 @@\n use crate::sys::mutex as imp;\n \n-/// An OS-based mutual exclusion lock.\n+/// An OS-based mutual exclusion lock, meant for use in static variables.\n+///\n+/// This mutex has a const constructor ([`StaticMutex::new`]), does not\n+/// implement `Drop` to cleanup resources, and causes UB when moved or used\n+/// reentrantly.\n+///\n+/// This mutex does not implement poisoning.\n ///\n-/// This is the thinnest cross-platform wrapper around OS mutexes. All usage of\n-/// this mutex is unsafe and it is recommended to instead use the safe wrapper\n-/// at the top level of the crate instead of this type.\n-pub struct Mutex(imp::Mutex);\n+/// This is a wrapper around `imp::Mutex` that does *not* call `init()` and\n+/// `destroy()`.\n+pub struct StaticMutex(imp::Mutex);\n \n-unsafe impl Sync for Mutex {}\n+unsafe impl Sync for StaticMutex {}\n \n-impl Mutex {\n+impl StaticMutex {\n     /// Creates a new mutex for use.\n     ///\n     /// Behavior is undefined if the mutex is moved after it is\n     /// first used with any of the functions below.\n-    /// Also, until `init` is called, behavior is undefined if this\n-    /// mutex is ever used reentrantly, i.e., `raw_lock` or `try_lock`\n-    /// are called by the thread currently holding the lock.\n+    /// Also, the behavior is undefined if this mutex is ever used reentrantly,\n+    /// i.e., `lock` is called by the thread currently holding the lock.\n     #[rustc_const_stable(feature = \"const_sys_mutex_new\", since = \"1.0.0\")]\n-    pub const fn new() -> Mutex {\n-        Mutex(imp::Mutex::new())\n+    pub const fn new() -> Self {\n+        Self(imp::Mutex::new())\n     }\n \n-    /// Prepare the mutex for use.\n+    /// Calls raw_lock() and then returns an RAII guard to guarantee the mutex\n+    /// will be unlocked.\n     ///\n-    /// This should be called once the mutex is at a stable memory address.\n-    /// If called, this must be the very first thing that happens to the mutex.\n-    /// Calling it in parallel with or after any operation (including another\n-    /// `init()`) is undefined behavior.\n+    /// It is undefined behaviour to call this function while locked, or if the\n+    /// mutex has been moved since the last time this was called.\n     #[inline]\n-    pub unsafe fn init(&mut self) {\n-        self.0.init()\n+    pub unsafe fn lock(&self) -> StaticMutexGuard<'_> {\n+        self.0.lock();\n+        StaticMutexGuard(&self.0)\n     }\n+}\n \n-    /// Locks the mutex blocking the current thread until it is available.\n-    ///\n-    /// Behavior is undefined if the mutex has been moved between this and any\n-    /// previous function call.\n+#[must_use]\n+pub struct StaticMutexGuard<'a>(&'a imp::Mutex);\n+\n+impl Drop for StaticMutexGuard<'_> {\n     #[inline]\n-    pub unsafe fn raw_lock(&self) {\n-        self.0.lock()\n+    fn drop(&mut self) {\n+        unsafe {\n+            self.0.unlock();\n+        }\n     }\n+}\n \n-    /// Calls raw_lock() and then returns an RAII guard to guarantee the mutex\n-    /// will be unlocked.\n+/// An OS-based mutual exclusion lock.\n+///\n+/// This mutex does *not* have a const constructor, cleans up its resources in\n+/// its `Drop` implementation, may safely be moved (when not borrowed), and\n+/// does not cause UB when used reentrantly.\n+///\n+/// This mutex does not implement poisoning.\n+///\n+/// This is a wrapper around `Box<imp::Mutex>`, to allow the object to be moved\n+/// without moving the raw mutex.\n+pub struct MovableMutex(Box<imp::Mutex>);\n+\n+unsafe impl Sync for MovableMutex {}\n+\n+impl MovableMutex {\n+    /// Creates a new mutex.\n+    pub fn new() -> Self {\n+        let mut mutex = box imp::Mutex::new();\n+        unsafe { mutex.init() };\n+        Self(mutex)\n+    }\n+\n+    pub(crate) fn raw(&self) -> &imp::Mutex {\n+        &self.0\n+    }\n+\n+    /// Locks the mutex blocking the current thread until it is available.\n     #[inline]\n-    pub unsafe fn lock(&self) -> MutexGuard<'_> {\n-        self.raw_lock();\n-        MutexGuard(&self.0)\n+    pub fn raw_lock(&self) {\n+        unsafe { self.0.lock() }\n     }\n \n     /// Attempts to lock the mutex without blocking, returning whether it was\n     /// successfully acquired or not.\n-    ///\n-    /// Behavior is undefined if the mutex has been moved between this and any\n-    /// previous function call.\n     #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n-        self.0.try_lock()\n+    pub fn try_lock(&self) -> bool {\n+        unsafe { self.0.try_lock() }\n     }\n \n     /// Unlocks the mutex.\n     ///\n     /// Behavior is undefined if the current thread does not actually hold the\n     /// mutex.\n-    ///\n-    /// Consider switching from the pair of raw_lock() and raw_unlock() to\n-    /// lock() whenever possible.\n     #[inline]\n     pub unsafe fn raw_unlock(&self) {\n         self.0.unlock()\n     }\n-\n-    /// Deallocates all resources associated with this mutex.\n-    ///\n-    /// Behavior is undefined if there are current or will be future users of\n-    /// this mutex.\n-    #[inline]\n-    pub unsafe fn destroy(&self) {\n-        self.0.destroy()\n-    }\n }\n \n-// not meant to be exported to the outside world, just the containing module\n-pub fn raw(mutex: &Mutex) -> &imp::Mutex {\n-    &mutex.0\n-}\n-\n-#[must_use]\n-/// A simple RAII utility for the above Mutex without the poisoning semantics.\n-pub struct MutexGuard<'a>(&'a imp::Mutex);\n-\n-impl Drop for MutexGuard<'_> {\n-    #[inline]\n+impl Drop for MovableMutex {\n     fn drop(&mut self) {\n-        unsafe {\n-            self.0.unlock();\n-        }\n+        unsafe { self.0.destroy() };\n     }\n }"}, {"sha": "dbcb7b36265f5941c929b6eb2be8df3c823dacc1", "filename": "library/std/src/sys_common/thread_local_key.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs?ref=1c4a5f8d1e5a96217f76b6f3877d1c252a132839", "patch": "@@ -53,7 +53,7 @@ mod tests;\n \n use crate::sync::atomic::{self, AtomicUsize, Ordering};\n use crate::sys::thread_local_key as imp;\n-use crate::sys_common::mutex::Mutex;\n+use crate::sys_common::mutex::StaticMutex;\n \n /// A type for TLS keys that are statically allocated.\n ///\n@@ -157,7 +157,7 @@ impl StaticKey {\n         if imp::requires_synchronized_create() {\n             // We never call `INIT_LOCK.init()`, so it is UB to attempt to\n             // acquire this mutex reentrantly!\n-            static INIT_LOCK: Mutex = Mutex::new();\n+            static INIT_LOCK: StaticMutex = StaticMutex::new();\n             let _guard = INIT_LOCK.lock();\n             let mut key = self.key.load(Ordering::SeqCst);\n             if key == 0 {"}, {"sha": "087175bb92ab3182600e06926a5dd8d64a52b26d", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=1c4a5f8d1e5a96217f76b6f3877d1c252a132839", "patch": "@@ -972,9 +972,8 @@ pub struct ThreadId(NonZeroU64);\n impl ThreadId {\n     // Generate a new unique thread ID.\n     fn new() -> ThreadId {\n-        // We never call `GUARD.init()`, so it is UB to attempt to\n-        // acquire this mutex reentrantly!\n-        static GUARD: mutex::Mutex = mutex::Mutex::new();\n+        // It is UB to attempt to acquire this mutex reentrantly!\n+        static GUARD: mutex::StaticMutex = mutex::StaticMutex::new();\n         static mut COUNTER: u64 = 1;\n \n         unsafe {"}, {"sha": "e7df38411478d804809c08099af839d170552006", "filename": "library/std/src/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/library%2Fstd%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime.rs?ref=1c4a5f8d1e5a96217f76b6f3877d1c252a132839", "patch": "@@ -20,7 +20,7 @@ use crate::error::Error;\n use crate::fmt;\n use crate::ops::{Add, AddAssign, Sub, SubAssign};\n use crate::sys::time;\n-use crate::sys_common::mutex::Mutex;\n+use crate::sys_common::mutex::StaticMutex;\n use crate::sys_common::FromInner;\n \n #[stable(feature = \"time\", since = \"1.3.0\")]\n@@ -243,7 +243,7 @@ impl Instant {\n             return Instant(os_now);\n         }\n \n-        static LOCK: Mutex = Mutex::new();\n+        static LOCK: StaticMutex = StaticMutex::new();\n         static mut LAST_NOW: time::Instant = time::Instant::zero();\n         unsafe {\n             let _lock = LOCK.lock();"}, {"sha": "093d6601d4e2e6063d7267cfe1abeebff01f6c3a", "filename": "src/test/ui/issues/issue-54062.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/src%2Ftest%2Fui%2Fissues%2Fissue-54062.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/src%2Ftest%2Fui%2Fissues%2Fissue-54062.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54062.rs?ref=1c4a5f8d1e5a96217f76b6f3877d1c252a132839", "patch": "@@ -7,7 +7,6 @@ struct Test {\n fn main() {}\n \n fn testing(test: Test) {\n-    let _ = test.comps.inner.lock().unwrap();\n+    let _ = test.comps.inner.try_lock();\n     //~^ ERROR: field `inner` of struct `Mutex` is private\n-    //~| ERROR: no method named `unwrap` found\n }"}, {"sha": "5361ee1d3455fdb6ed5a3db964b899127c75225d", "filename": "src/test/ui/issues/issue-54062.stderr", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/src%2Ftest%2Fui%2Fissues%2Fissue-54062.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1c4a5f8d1e5a96217f76b6f3877d1c252a132839/src%2Ftest%2Fui%2Fissues%2Fissue-54062.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54062.stderr?ref=1c4a5f8d1e5a96217f76b6f3877d1c252a132839", "patch": "@@ -1,16 +1,9 @@\n error[E0616]: field `inner` of struct `Mutex` is private\n   --> $DIR/issue-54062.rs:10:24\n    |\n-LL |     let _ = test.comps.inner.lock().unwrap();\n+LL |     let _ = test.comps.inner.try_lock();\n    |                        ^^^^^ private field\n \n-error[E0599]: no method named `unwrap` found for struct `std::sys_common::mutex::MutexGuard<'_>` in the current scope\n-  --> $DIR/issue-54062.rs:10:37\n-   |\n-LL |     let _ = test.comps.inner.lock().unwrap();\n-   |                                     ^^^^^^ method not found in `std::sys_common::mutex::MutexGuard<'_>`\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0599, E0616.\n-For more information about an error, try `rustc --explain E0599`.\n+For more information about this error, try `rustc --explain E0616`."}]}