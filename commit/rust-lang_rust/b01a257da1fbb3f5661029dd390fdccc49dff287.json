{"sha": "b01a257da1fbb3f5661029dd390fdccc49dff287", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwMWEyNTdkYTFmYmIzZjU2NjEwMjlkZDM5MGZkY2NjNDlkZmYyODc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-17T13:32:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-17T13:32:35Z"}, "message": "Auto merge of #61857 - Centril:typeck-extract-expr, r=oli-obk\n\ntypeck: extract expr type-checking to expr.rs + refactor check_expr_kind\n\nIn this PR we:\n\n- Extract out the bulk of the expression type checking logic from `check/mod.rs` into a new file `check/expr.rs`.\n\n- Refactor `fn check_expr_kind` into several smaller functions.\n\nMore functions should probably be moved but I think this is a reasonable start.\n\nr? @oli-obk\ncc @eddyb", "tree": {"sha": "a8fd99b2990c8caa9abf0f8d6160f1149b98d2c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8fd99b2990c8caa9abf0f8d6160f1149b98d2c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b01a257da1fbb3f5661029dd390fdccc49dff287", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b01a257da1fbb3f5661029dd390fdccc49dff287", "html_url": "https://github.com/rust-lang/rust/commit/b01a257da1fbb3f5661029dd390fdccc49dff287", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b01a257da1fbb3f5661029dd390fdccc49dff287/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "289b78ac0a2ee91d3872c65438f718780f294a9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/289b78ac0a2ee91d3872c65438f718780f294a9a", "html_url": "https://github.com/rust-lang/rust/commit/289b78ac0a2ee91d3872c65438f718780f294a9a"}, {"sha": "5057552dc6e8b4d259edcb080c525056da46efa3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5057552dc6e8b4d259edcb080c525056da46efa3", "html_url": "https://github.com/rust-lang/rust/commit/5057552dc6e8b4d259edcb080c525056da46efa3"}], "stats": {"total": 2925, "additions": 1543, "deletions": 1382}, "files": [{"sha": "fa9e0d8a8578afd94a12ad3ea7a080f2b379adee", "filename": "src/librustc_typeck/check/expr.rs", "status": "added", "additions": 1537, "deletions": 0, "changes": 1537, "blob_url": "https://github.com/rust-lang/rust/blob/b01a257da1fbb3f5661029dd390fdccc49dff287/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b01a257da1fbb3f5661029dd390fdccc49dff287/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=b01a257da1fbb3f5661029dd390fdccc49dff287", "patch": "@@ -0,0 +1,1537 @@\n+//! Type checking expressions.\n+//!\n+//! See `mod.rs` for more context on type checking in general.\n+\n+use crate::check::BreakableCtxt;\n+use crate::check::cast;\n+use crate::check::coercion::CoerceMany;\n+use crate::check::Diverges;\n+use crate::check::FnCtxt;\n+use crate::check::Expectation::{self, NoExpectation, ExpectHasType, ExpectCastableToType};\n+use crate::check::fatally_break_rust;\n+use crate::check::report_unexpected_variant_res;\n+use crate::check::Needs;\n+use crate::check::TupleArgumentsFlag::DontTupleArguments;\n+use crate::check::method::SelfSource;\n+use crate::middle::lang_items;\n+use crate::util::common::ErrorReported;\n+use crate::util::nodemap::FxHashMap;\n+use crate::astconv::AstConv as _;\n+\n+use errors::{Applicability, DiagnosticBuilder};\n+use syntax::ast;\n+use syntax::ptr::P;\n+use syntax::symbol::{Symbol, LocalInternedString, kw, sym};\n+use syntax::source_map::Span;\n+use syntax::util::lev_distance::find_best_match_for_name;\n+use rustc::hir;\n+use rustc::hir::{ExprKind, QPath};\n+use rustc::hir::def::{CtorKind, Res, DefKind};\n+use rustc::infer;\n+use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc::mir::interpret::GlobalId;\n+use rustc::ty;\n+use rustc::ty::adjustment::{\n+    Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n+};\n+use rustc::ty::{AdtKind, Visibility};\n+use rustc::ty::Ty;\n+use rustc::ty::TypeFoldable;\n+use rustc::ty::subst::InternalSubsts;\n+use rustc::traits::{self, ObligationCauseCode};\n+\n+use std::fmt::Display;\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    fn check_expr_eq_type(&self, expr: &'tcx hir::Expr, expected: Ty<'tcx>) {\n+        let ty = self.check_expr_with_hint(expr, expected);\n+        self.demand_eqtype(expr.span, expected, ty);\n+    }\n+\n+    pub fn check_expr_has_type_or_error(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        expected: Ty<'tcx>,\n+    ) -> Ty<'tcx> {\n+        self.check_expr_meets_expectation_or_error(expr, ExpectHasType(expected))\n+    }\n+\n+    fn check_expr_meets_expectation_or_error(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        expected: Expectation<'tcx>,\n+    ) -> Ty<'tcx> {\n+        let expected_ty = expected.to_option(&self).unwrap_or(self.tcx.types.bool);\n+        let mut ty = self.check_expr_with_expectation(expr, expected);\n+\n+        // While we don't allow *arbitrary* coercions here, we *do* allow\n+        // coercions from ! to `expected`.\n+        if ty.is_never() {\n+            assert!(!self.tables.borrow().adjustments().contains_key(expr.hir_id),\n+                    \"expression with never type wound up being adjusted\");\n+            let adj_ty = self.next_diverging_ty_var(\n+                TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::AdjustmentType,\n+                    span: expr.span,\n+                },\n+            );\n+            self.apply_adjustments(expr, vec![Adjustment {\n+                kind: Adjust::NeverToAny,\n+                target: adj_ty\n+            }]);\n+            ty = adj_ty;\n+        }\n+\n+        if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n+            let expr = match &expr.node {\n+                ExprKind::DropTemps(expr) => expr,\n+                _ => expr,\n+            };\n+            // Error possibly reported in `check_assign` so avoid emitting error again.\n+            err.emit_unless(self.is_assign_to_bool(expr, expected_ty));\n+        }\n+        ty\n+    }\n+\n+    pub(super) fn check_expr_coercable_to_type(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        expected: Ty<'tcx>\n+    ) -> Ty<'tcx> {\n+        let ty = self.check_expr_with_hint(expr, expected);\n+        // checks don't need two phase\n+        self.demand_coerce(expr, ty, expected, AllowTwoPhase::No)\n+    }\n+\n+    pub(super) fn check_expr_with_hint(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        expected: Ty<'tcx>\n+    ) -> Ty<'tcx> {\n+        self.check_expr_with_expectation(expr, ExpectHasType(expected))\n+    }\n+\n+    pub(super) fn check_expr_with_expectation(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        expected: Expectation<'tcx>,\n+    ) -> Ty<'tcx> {\n+        self.check_expr_with_expectation_and_needs(expr, expected, Needs::None)\n+    }\n+\n+    pub(super) fn check_expr(&self, expr: &'tcx hir::Expr) -> Ty<'tcx> {\n+        self.check_expr_with_expectation(expr, NoExpectation)\n+    }\n+\n+    pub(super) fn check_expr_with_needs(&self, expr: &'tcx hir::Expr, needs: Needs) -> Ty<'tcx> {\n+        self.check_expr_with_expectation_and_needs(expr, NoExpectation, needs)\n+    }\n+\n+    /// Invariant:\n+    /// If an expression has any sub-expressions that result in a type error,\n+    /// inspecting that expression's type with `ty.references_error()` will return\n+    /// true. Likewise, if an expression is known to diverge, inspecting its\n+    /// type with `ty::type_is_bot` will return true (n.b.: since Rust is\n+    /// strict, _|_ can appear in the type of an expression that does not,\n+    /// itself, diverge: for example, fn() -> _|_.)\n+    /// Note that inspecting a type's structure *directly* may expose the fact\n+    /// that there are actually multiple representations for `Error`, so avoid\n+    /// that when err needs to be handled differently.\n+    fn check_expr_with_expectation_and_needs(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        expected: Expectation<'tcx>,\n+        needs: Needs,\n+    ) -> Ty<'tcx> {\n+        debug!(\">> type-checking: expr={:?} expected={:?}\",\n+               expr, expected);\n+\n+        // Warn for expressions after diverging siblings.\n+        self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\");\n+\n+        // Hide the outer diverging and has_errors flags.\n+        let old_diverges = self.diverges.get();\n+        let old_has_errors = self.has_errors.get();\n+        self.diverges.set(Diverges::Maybe);\n+        self.has_errors.set(false);\n+\n+        let ty = self.check_expr_kind(expr, expected, needs);\n+\n+        // Warn for non-block expressions with diverging children.\n+        match expr.node {\n+            ExprKind::Block(..) |\n+            ExprKind::Loop(..) | ExprKind::While(..) |\n+            ExprKind::Match(..) => {}\n+\n+            _ => self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\")\n+        }\n+\n+        // Any expression that produces a value of type `!` must have diverged\n+        if ty.is_never() {\n+            self.diverges.set(self.diverges.get() | Diverges::Always);\n+        }\n+\n+        // Record the type, which applies it effects.\n+        // We need to do this after the warning above, so that\n+        // we don't warn for the diverging expression itself.\n+        self.write_ty(expr.hir_id, ty);\n+\n+        // Combine the diverging and has_error flags.\n+        self.diverges.set(self.diverges.get() | old_diverges);\n+        self.has_errors.set(self.has_errors.get() | old_has_errors);\n+\n+        debug!(\"type of {} is...\", self.tcx.hir().hir_to_string(expr.hir_id));\n+        debug!(\"... {:?}, expected is {:?}\", ty, expected);\n+\n+        ty\n+    }\n+\n+    fn check_expr_kind(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        expected: Expectation<'tcx>,\n+        needs: Needs,\n+    ) -> Ty<'tcx> {\n+        debug!(\n+            \"check_expr_kind(expr={:?}, expected={:?}, needs={:?})\",\n+            expr,\n+            expected,\n+            needs,\n+        );\n+\n+        let tcx = self.tcx;\n+        match expr.node {\n+            ExprKind::Box(ref subexpr) => {\n+                self.check_expr_box(subexpr, expected)\n+            }\n+            ExprKind::Lit(ref lit) => {\n+                self.check_lit(&lit, expected)\n+            }\n+            ExprKind::Binary(op, ref lhs, ref rhs) => {\n+                self.check_binop(expr, op, lhs, rhs)\n+            }\n+            ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n+                self.check_binop_assign(expr, op, lhs, rhs)\n+            }\n+            ExprKind::Unary(unop, ref oprnd) => {\n+                self.check_expr_unary(unop, oprnd, expected, needs, expr)\n+            }\n+            ExprKind::AddrOf(mutbl, ref oprnd) => {\n+                self.check_expr_addr_of(mutbl, oprnd, expected, expr)\n+            }\n+            ExprKind::Path(ref qpath) => {\n+                self.check_expr_path(qpath, expr)\n+            }\n+            ExprKind::InlineAsm(_, ref outputs, ref inputs) => {\n+                for expr in outputs.iter().chain(inputs.iter()) {\n+                    self.check_expr(expr);\n+                }\n+                tcx.mk_unit()\n+            }\n+            ExprKind::Break(destination, ref expr_opt) => {\n+                self.check_expr_break(destination, expr_opt.deref(), expr)\n+            }\n+            ExprKind::Continue(destination) => {\n+                if destination.target_id.is_ok() {\n+                    tcx.types.never\n+                } else {\n+                    // There was an error; make type-check fail.\n+                    tcx.types.err\n+                }\n+            }\n+            ExprKind::Ret(ref expr_opt) => {\n+                self.check_expr_return(expr_opt.deref(), expr)\n+            }\n+            ExprKind::Assign(ref lhs, ref rhs) => {\n+                self.check_expr_assign(expr, expected, lhs, rhs)\n+            }\n+            ExprKind::While(ref cond, ref body, _) => {\n+                self.check_expr_while(cond, body, expr)\n+            }\n+            ExprKind::Loop(ref body, _, source) => {\n+                self.check_expr_loop(body, source, expected, expr)\n+            }\n+            ExprKind::Match(ref discrim, ref arms, match_src) => {\n+                self.check_match(expr, &discrim, arms, expected, match_src)\n+            }\n+            ExprKind::Closure(capture, ref decl, body_id, _, gen) => {\n+                self.check_expr_closure(expr, capture, &decl, body_id, gen, expected)\n+            }\n+            ExprKind::Block(ref body, _) => {\n+                self.check_block_with_expected(&body, expected)\n+            }\n+            ExprKind::Call(ref callee, ref args) => {\n+                self.check_call(expr, &callee, args, expected)\n+            }\n+            ExprKind::MethodCall(ref segment, span, ref args) => {\n+                self.check_method_call(expr, segment, span, args, expected, needs)\n+            }\n+            ExprKind::Cast(ref e, ref t) => {\n+                self.check_expr_cast(e, t, expr)\n+            }\n+            ExprKind::Type(ref e, ref t) => {\n+                let ty = self.to_ty_saving_user_provided_ty(&t);\n+                self.check_expr_eq_type(&e, ty);\n+                ty\n+            }\n+            ExprKind::DropTemps(ref e) => {\n+                self.check_expr_with_expectation(e, expected)\n+            }\n+            ExprKind::Array(ref args) => {\n+                self.check_expr_array(args, expected, expr)\n+            }\n+            ExprKind::Repeat(ref element, ref count) => {\n+                self.check_expr_repeat(element, count, expected, expr)\n+            }\n+            ExprKind::Tup(ref elts) => {\n+                self.check_expr_tuple(elts, expected, expr)\n+            }\n+            ExprKind::Struct(ref qpath, ref fields, ref base_expr) => {\n+                self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n+            }\n+            ExprKind::Field(ref base, field) => {\n+                self.check_field(expr, needs, &base, field)\n+            }\n+            ExprKind::Index(ref base, ref idx) => {\n+                self.check_expr_index(base, idx, needs, expr)\n+            }\n+            ExprKind::Yield(ref value) => {\n+                self.check_expr_yield(value, expr)\n+            }\n+            hir::ExprKind::Err => {\n+                tcx.types.err\n+            }\n+        }\n+    }\n+\n+    fn check_expr_box(&self, expr: &'tcx hir::Expr, expected: Expectation<'tcx>) -> Ty<'tcx> {\n+        let expected_inner = expected.to_option(self).map_or(NoExpectation, |ty| {\n+            match ty.sty {\n+                ty::Adt(def, _) if def.is_box()\n+                    => Expectation::rvalue_hint(self, ty.boxed_ty()),\n+                _ => NoExpectation\n+            }\n+        });\n+        let referent_ty = self.check_expr_with_expectation(expr, expected_inner);\n+        self.tcx.mk_box(referent_ty)\n+    }\n+\n+    fn check_expr_unary(\n+        &self,\n+        unop: hir::UnOp,\n+        oprnd: &'tcx hir::Expr,\n+        expected: Expectation<'tcx>,\n+        needs: Needs,\n+        expr: &'tcx hir::Expr,\n+    ) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+        let expected_inner = match unop {\n+            hir::UnNot | hir::UnNeg => expected,\n+            hir::UnDeref => NoExpectation,\n+        };\n+        let needs = match unop {\n+            hir::UnDeref => needs,\n+            _ => Needs::None\n+        };\n+        let mut oprnd_t = self.check_expr_with_expectation_and_needs(&oprnd, expected_inner, needs);\n+\n+        if !oprnd_t.references_error() {\n+            oprnd_t = self.structurally_resolved_type(expr.span, oprnd_t);\n+            match unop {\n+                hir::UnDeref => {\n+                    if let Some(mt) = oprnd_t.builtin_deref(true) {\n+                        oprnd_t = mt.ty;\n+                    } else if let Some(ok) = self.try_overloaded_deref(\n+                            expr.span, oprnd_t, needs) {\n+                        let method = self.register_infer_ok_obligations(ok);\n+                        if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].sty {\n+                            let mutbl = match mutbl {\n+                                hir::MutImmutable => AutoBorrowMutability::Immutable,\n+                                hir::MutMutable => AutoBorrowMutability::Mutable {\n+                                    // (It shouldn't actually matter for unary ops whether\n+                                    // we enable two-phase borrows or not, since a unary\n+                                    // op has no additional operands.)\n+                                    allow_two_phase_borrow: AllowTwoPhase::No,\n+                                }\n+                            };\n+                            self.apply_adjustments(oprnd, vec![Adjustment {\n+                                kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n+                                target: method.sig.inputs()[0]\n+                            }]);\n+                        }\n+                        oprnd_t = self.make_overloaded_place_return_type(method).ty;\n+                        self.write_method_call(expr.hir_id, method);\n+                    } else {\n+                        let mut err = type_error_struct!(\n+                            tcx.sess,\n+                            expr.span,\n+                            oprnd_t,\n+                            E0614,\n+                            \"type `{}` cannot be dereferenced\",\n+                            oprnd_t,\n+                        );\n+                        let sp = tcx.sess.source_map().start_point(expr.span);\n+                        if let Some(sp) = tcx.sess.parse_sess.ambiguous_block_expr_parse\n+                            .borrow().get(&sp)\n+                        {\n+                            tcx.sess.parse_sess.expr_parentheses_needed(\n+                                &mut err,\n+                                *sp,\n+                                None,\n+                            );\n+                        }\n+                        err.emit();\n+                        oprnd_t = tcx.types.err;\n+                    }\n+                }\n+                hir::UnNot => {\n+                    let result = self.check_user_unop(expr, oprnd_t, unop);\n+                    // If it's builtin, we can reuse the type, this helps inference.\n+                    if !(oprnd_t.is_integral() || oprnd_t.sty == ty::Bool) {\n+                        oprnd_t = result;\n+                    }\n+                }\n+                hir::UnNeg => {\n+                    let result = self.check_user_unop(expr, oprnd_t, unop);\n+                    // If it's builtin, we can reuse the type, this helps inference.\n+                    if !oprnd_t.is_numeric() {\n+                        oprnd_t = result;\n+                    }\n+                }\n+            }\n+        }\n+        oprnd_t\n+    }\n+\n+    fn check_expr_addr_of(\n+        &self,\n+        mutbl: hir::Mutability,\n+        oprnd: &'tcx hir::Expr,\n+        expected: Expectation<'tcx>,\n+        expr: &'tcx hir::Expr,\n+    ) -> Ty<'tcx> {\n+        let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n+            match ty.sty {\n+                ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n+                    if oprnd.is_place_expr() {\n+                        // Places may legitimately have unsized types.\n+                        // For example, dereferences of a fat pointer and\n+                        // the last field of a struct can be unsized.\n+                        ExpectHasType(ty)\n+                    } else {\n+                        Expectation::rvalue_hint(self, ty)\n+                    }\n+                }\n+                _ => NoExpectation\n+            }\n+        });\n+        let needs = Needs::maybe_mut_place(mutbl);\n+        let ty = self.check_expr_with_expectation_and_needs(&oprnd, hint, needs);\n+\n+        let tm = ty::TypeAndMut { ty: ty, mutbl: mutbl };\n+        if tm.ty.references_error() {\n+            self.tcx.types.err\n+        } else {\n+            // Note: at this point, we cannot say what the best lifetime\n+            // is to use for resulting pointer.  We want to use the\n+            // shortest lifetime possible so as to avoid spurious borrowck\n+            // errors.  Moreover, the longest lifetime will depend on the\n+            // precise details of the value whose address is being taken\n+            // (and how long it is valid), which we don't know yet until type\n+            // inference is complete.\n+            //\n+            // Therefore, here we simply generate a region variable.  The\n+            // region inferencer will then select the ultimate value.\n+            // Finally, borrowck is charged with guaranteeing that the\n+            // value whose address was taken can actually be made to live\n+            // as long as it needs to live.\n+            let region = self.next_region_var(infer::AddrOfRegion(expr.span));\n+            self.tcx.mk_ref(region, tm)\n+        }\n+    }\n+\n+    fn check_expr_path(&self, qpath: &hir::QPath, expr: &'tcx hir::Expr) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+        let (res, opt_ty, segs) = self.resolve_ty_and_res_ufcs(qpath, expr.hir_id, expr.span);\n+        let ty = match res {\n+            Res::Err => {\n+                self.set_tainted_by_errors();\n+                tcx.types.err\n+            }\n+            Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _) => {\n+                report_unexpected_variant_res(tcx, res, expr.span, qpath);\n+                tcx.types.err\n+            }\n+            _ => self.instantiate_value_path(segs, opt_ty, res, expr.span, expr.hir_id).0,\n+        };\n+\n+        if let ty::FnDef(..) = ty.sty {\n+            let fn_sig = ty.fn_sig(tcx);\n+            if !tcx.features().unsized_locals {\n+                // We want to remove some Sized bounds from std functions,\n+                // but don't want to expose the removal to stable Rust.\n+                // i.e., we don't want to allow\n+                //\n+                // ```rust\n+                // drop as fn(str);\n+                // ```\n+                //\n+                // to work in stable even if the Sized bound on `drop` is relaxed.\n+                for i in 0..fn_sig.inputs().skip_binder().len() {\n+                    // We just want to check sizedness, so instead of introducing\n+                    // placeholder lifetimes with probing, we just replace higher lifetimes\n+                    // with fresh vars.\n+                    let input = self.replace_bound_vars_with_fresh_vars(\n+                        expr.span,\n+                        infer::LateBoundRegionConversionTime::FnCall,\n+                        &fn_sig.input(i)).0;\n+                    self.require_type_is_sized_deferred(input, expr.span,\n+                                                        traits::SizedArgumentType);\n+                }\n+            }\n+            // Here we want to prevent struct constructors from returning unsized types.\n+            // There were two cases this happened: fn pointer coercion in stable\n+            // and usual function call in presense of unsized_locals.\n+            // Also, as we just want to check sizedness, instead of introducing\n+            // placeholder lifetimes with probing, we just replace higher lifetimes\n+            // with fresh vars.\n+            let output = self.replace_bound_vars_with_fresh_vars(\n+                expr.span,\n+                infer::LateBoundRegionConversionTime::FnCall,\n+                &fn_sig.output()).0;\n+            self.require_type_is_sized_deferred(output, expr.span, traits::SizedReturnType);\n+        }\n+\n+        // We always require that the type provided as the value for\n+        // a type parameter outlives the moment of instantiation.\n+        let substs = self.tables.borrow().node_substs(expr.hir_id);\n+        self.add_wf_bounds(substs, expr);\n+\n+        ty\n+    }\n+\n+    fn check_expr_break(\n+        &self,\n+        destination: hir::Destination,\n+        expr_opt: Option<&'tcx hir::Expr>,\n+        expr: &'tcx hir::Expr,\n+    ) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+        if let Ok(target_id) = destination.target_id {\n+            let (e_ty, cause);\n+            if let Some(ref e) = expr_opt {\n+                // If this is a break with a value, we need to type-check\n+                // the expression. Get an expected type from the loop context.\n+                let opt_coerce_to = {\n+                    let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+                    enclosing_breakables.find_breakable(target_id)\n+                                        .coerce\n+                                        .as_ref()\n+                                        .map(|coerce| coerce.expected_ty())\n+                };\n+\n+                // If the loop context is not a `loop { }`, then break with\n+                // a value is illegal, and `opt_coerce_to` will be `None`.\n+                // Just set expectation to error in that case.\n+                let coerce_to = opt_coerce_to.unwrap_or(tcx.types.err);\n+\n+                // Recurse without `enclosing_breakables` borrowed.\n+                e_ty = self.check_expr_with_hint(e, coerce_to);\n+                cause = self.misc(e.span);\n+            } else {\n+                // Otherwise, this is a break *without* a value. That's\n+                // always legal, and is equivalent to `break ()`.\n+                e_ty = tcx.mk_unit();\n+                cause = self.misc(expr.span);\n+            }\n+\n+            // Now that we have type-checked `expr_opt`, borrow\n+            // the `enclosing_loops` field and let's coerce the\n+            // type of `expr_opt` into what is expected.\n+            let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+            let ctxt = enclosing_breakables.find_breakable(target_id);\n+            if let Some(ref mut coerce) = ctxt.coerce {\n+                if let Some(ref e) = expr_opt {\n+                    coerce.coerce(self, &cause, e, e_ty);\n+                } else {\n+                    assert!(e_ty.is_unit());\n+                    coerce.coerce_forced_unit(self, &cause, &mut |_| (), true);\n+                }\n+            } else {\n+                // If `ctxt.coerce` is `None`, we can just ignore\n+                // the type of the expresison.  This is because\n+                // either this was a break *without* a value, in\n+                // which case it is always a legal type (`()`), or\n+                // else an error would have been flagged by the\n+                // `loops` pass for using break with an expression\n+                // where you are not supposed to.\n+                assert!(expr_opt.is_none() || self.tcx.sess.err_count() > 0);\n+            }\n+\n+            ctxt.may_break = true;\n+\n+            // the type of a `break` is always `!`, since it diverges\n+            tcx.types.never\n+        } else {\n+            // Otherwise, we failed to find the enclosing loop;\n+            // this can only happen if the `break` was not\n+            // inside a loop at all, which is caught by the\n+            // loop-checking pass.\n+            if self.tcx.sess.err_count() == 0 {\n+                self.tcx.sess.delay_span_bug(expr.span,\n+                    \"break was outside loop, but no error was emitted\");\n+            }\n+\n+            // We still need to assign a type to the inner expression to\n+            // prevent the ICE in #43162.\n+            if let Some(ref e) = expr_opt {\n+                self.check_expr_with_hint(e, tcx.types.err);\n+\n+                // ... except when we try to 'break rust;'.\n+                // ICE this expression in particular (see #43162).\n+                if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.node {\n+                    if path.segments.len() == 1 &&\n+                        path.segments[0].ident.name == sym::rust {\n+                        fatally_break_rust(self.tcx.sess);\n+                    }\n+                }\n+            }\n+            // There was an error; make type-check fail.\n+            tcx.types.err\n+        }\n+    }\n+\n+    fn check_expr_return(\n+        &self,\n+        expr_opt: Option<&'tcx hir::Expr>,\n+        expr: &'tcx hir::Expr\n+    ) -> Ty<'tcx> {\n+        if self.ret_coercion.is_none() {\n+            struct_span_err!(self.tcx.sess, expr.span, E0572,\n+                                \"return statement outside of function body\").emit();\n+        } else if let Some(ref e) = expr_opt {\n+            if self.ret_coercion_span.borrow().is_none() {\n+                *self.ret_coercion_span.borrow_mut() = Some(e.span);\n+            }\n+            self.check_return_expr(e);\n+        } else {\n+            let mut coercion = self.ret_coercion.as_ref().unwrap().borrow_mut();\n+            if self.ret_coercion_span.borrow().is_none() {\n+                *self.ret_coercion_span.borrow_mut() = Some(expr.span);\n+            }\n+            let cause = self.cause(expr.span, ObligationCauseCode::ReturnNoExpression);\n+            if let Some((fn_decl, _)) = self.get_fn_decl(expr.hir_id) {\n+                coercion.coerce_forced_unit(\n+                    self,\n+                    &cause,\n+                    &mut |db| {\n+                        db.span_label(\n+                            fn_decl.output.span(),\n+                            format!(\n+                                \"expected `{}` because of this return type\",\n+                                fn_decl.output,\n+                            ),\n+                        );\n+                    },\n+                    true,\n+                );\n+            } else {\n+                coercion.coerce_forced_unit(self, &cause, &mut |_| (), true);\n+            }\n+        }\n+        self.tcx.types.never\n+    }\n+\n+    pub(super) fn check_return_expr(&self, return_expr: &'tcx hir::Expr) {\n+        let ret_coercion =\n+            self.ret_coercion\n+                .as_ref()\n+                .unwrap_or_else(|| span_bug!(return_expr.span,\n+                                             \"check_return_expr called outside fn body\"));\n+\n+        let ret_ty = ret_coercion.borrow().expected_ty();\n+        let return_expr_ty = self.check_expr_with_hint(return_expr, ret_ty.clone());\n+        ret_coercion.borrow_mut()\n+                    .coerce(self,\n+                            &self.cause(return_expr.span,\n+                                        ObligationCauseCode::ReturnType(return_expr.hir_id)),\n+                            return_expr,\n+                            return_expr_ty);\n+    }\n+\n+    /// Type check assignment expression `expr` of form `lhs = rhs`.\n+    /// The expected type is `()` and is passsed to the function for the purposes of diagnostics.\n+    fn check_expr_assign(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        expected: Expectation<'tcx>,\n+        lhs: &'tcx hir::Expr,\n+        rhs: &'tcx hir::Expr,\n+    ) -> Ty<'tcx> {\n+        let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n+        let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n+\n+        let expected_ty = expected.coercion_target_type(self, expr.span);\n+        if expected_ty == self.tcx.types.bool {\n+            // The expected type is `bool` but this will result in `()` so we can reasonably\n+            // say that the user intended to write `lhs == rhs` instead of `lhs = rhs`.\n+            // The likely cause of this is `if foo = bar { .. }`.\n+            let actual_ty = self.tcx.mk_unit();\n+            let mut err = self.demand_suptype_diag(expr.span, expected_ty, actual_ty).unwrap();\n+            let msg = \"try comparing for equality\";\n+            let left = self.tcx.sess.source_map().span_to_snippet(lhs.span);\n+            let right = self.tcx.sess.source_map().span_to_snippet(rhs.span);\n+            if let (Ok(left), Ok(right)) = (left, right) {\n+                let help = format!(\"{} == {}\", left, right);\n+                err.span_suggestion(expr.span, msg, help, Applicability::MaybeIncorrect);\n+            } else {\n+                err.help(msg);\n+            }\n+            err.emit();\n+        } else if !lhs.is_place_expr() {\n+            struct_span_err!(self.tcx.sess, expr.span, E0070,\n+                                \"invalid left-hand side expression\")\n+                .span_label(expr.span, \"left-hand of expression not valid\")\n+                .emit();\n+        }\n+\n+        self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);\n+\n+        if lhs_ty.references_error() || rhs_ty.references_error() {\n+            self.tcx.types.err\n+        } else {\n+            self.tcx.mk_unit()\n+        }\n+    }\n+\n+    fn check_expr_while(\n+        &self,\n+        cond: &'tcx hir::Expr,\n+        body: &'tcx hir::Block,\n+        expr: &'tcx hir::Expr\n+    ) -> Ty<'tcx> {\n+        let ctxt = BreakableCtxt {\n+            // Cannot use break with a value from a while loop.\n+            coerce: None,\n+            may_break: false, // Will get updated if/when we find a `break`.\n+        };\n+\n+        let (ctxt, ()) = self.with_breakable_ctxt(expr.hir_id, ctxt, || {\n+            self.check_expr_has_type_or_error(&cond, self.tcx.types.bool);\n+            let cond_diverging = self.diverges.get();\n+            self.check_block_no_value(&body);\n+\n+            // We may never reach the body so it diverging means nothing.\n+            self.diverges.set(cond_diverging);\n+        });\n+\n+        if ctxt.may_break {\n+            // No way to know whether it's diverging because\n+            // of a `break` or an outer `break` or `return`.\n+            self.diverges.set(Diverges::Maybe);\n+        }\n+\n+        self.tcx.mk_unit()\n+    }\n+\n+    fn check_expr_loop(\n+        &self,\n+        body: &'tcx hir::Block,\n+        source: hir::LoopSource,\n+        expected: Expectation<'tcx>,\n+        expr: &'tcx hir::Expr,\n+    ) -> Ty<'tcx> {\n+        let coerce = match source {\n+            // you can only use break with a value from a normal `loop { }`\n+            hir::LoopSource::Loop => {\n+                let coerce_to = expected.coercion_target_type(self, body.span);\n+                Some(CoerceMany::new(coerce_to))\n+            }\n+\n+            hir::LoopSource::WhileLet |\n+            hir::LoopSource::ForLoop => {\n+                None\n+            }\n+        };\n+\n+        let ctxt = BreakableCtxt {\n+            coerce,\n+            may_break: false, // Will get updated if/when we find a `break`.\n+        };\n+\n+        let (ctxt, ()) = self.with_breakable_ctxt(expr.hir_id, ctxt, || {\n+            self.check_block_no_value(&body);\n+        });\n+\n+        if ctxt.may_break {\n+            // No way to know whether it's diverging because\n+            // of a `break` or an outer `break` or `return`.\n+            self.diverges.set(Diverges::Maybe);\n+        }\n+\n+        // If we permit break with a value, then result type is\n+        // the LUB of the breaks (possibly ! if none); else, it\n+        // is nil. This makes sense because infinite loops\n+        // (which would have type !) are only possible iff we\n+        // permit break with a value [1].\n+        if ctxt.coerce.is_none() && !ctxt.may_break {\n+            // [1]\n+            self.tcx.sess.delay_span_bug(body.span, \"no coercion, but loop may not break\");\n+        }\n+        ctxt.coerce.map(|c| c.complete(self)).unwrap_or_else(|| self.tcx.mk_unit())\n+    }\n+\n+    /// Checks a method call.\n+    fn check_method_call(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        segment: &hir::PathSegment,\n+        span: Span,\n+        args: &'tcx [hir::Expr],\n+        expected: Expectation<'tcx>,\n+        needs: Needs,\n+    ) -> Ty<'tcx> {\n+        let rcvr = &args[0];\n+        let rcvr_t = self.check_expr_with_needs(&rcvr, needs);\n+        // no need to check for bot/err -- callee does that\n+        let rcvr_t = self.structurally_resolved_type(args[0].span, rcvr_t);\n+\n+        let method = match self.lookup_method(rcvr_t,\n+                                              segment,\n+                                              span,\n+                                              expr,\n+                                              rcvr) {\n+            Ok(method) => {\n+                self.write_method_call(expr.hir_id, method);\n+                Ok(method)\n+            }\n+            Err(error) => {\n+                if segment.ident.name != kw::Invalid {\n+                    self.report_method_error(span,\n+                                             rcvr_t,\n+                                             segment.ident,\n+                                             SelfSource::MethodCall(rcvr),\n+                                             error,\n+                                             Some(args));\n+                }\n+                Err(())\n+            }\n+        };\n+\n+        // Call the generic checker.\n+        self.check_method_argument_types(span,\n+                                         expr.span,\n+                                         method,\n+                                         &args[1..],\n+                                         DontTupleArguments,\n+                                         expected)\n+    }\n+\n+    fn check_expr_cast(\n+        &self,\n+        e: &'tcx hir::Expr,\n+        t: &'tcx hir::Ty,\n+        expr: &'tcx hir::Expr,\n+    ) -> Ty<'tcx> {\n+        // Find the type of `e`. Supply hints based on the type we are casting to,\n+        // if appropriate.\n+        let t_cast = self.to_ty_saving_user_provided_ty(t);\n+        let t_cast = self.resolve_vars_if_possible(&t_cast);\n+        let t_expr = self.check_expr_with_expectation(e, ExpectCastableToType(t_cast));\n+        let t_cast = self.resolve_vars_if_possible(&t_cast);\n+\n+        // Eagerly check for some obvious errors.\n+        if t_expr.references_error() || t_cast.references_error() {\n+            self.tcx.types.err\n+        } else {\n+            // Defer other checks until we're done type checking.\n+            let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n+            match cast::CastCheck::new(self, e, t_expr, t_cast, t.span, expr.span) {\n+                Ok(cast_check) => {\n+                    deferred_cast_checks.push(cast_check);\n+                    t_cast\n+                }\n+                Err(ErrorReported) => {\n+                    self.tcx.types.err\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_expr_array(\n+        &self,\n+        args: &'tcx [hir::Expr],\n+        expected: Expectation<'tcx>,\n+        expr: &'tcx hir::Expr\n+    ) -> Ty<'tcx> {\n+        let uty = expected.to_option(self).and_then(|uty| {\n+            match uty.sty {\n+                ty::Array(ty, _) | ty::Slice(ty) => Some(ty),\n+                _ => None\n+            }\n+        });\n+\n+        let element_ty = if !args.is_empty() {\n+            let coerce_to = uty.unwrap_or_else(|| {\n+                self.next_ty_var(TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::TypeInference,\n+                    span: expr.span,\n+                })\n+            });\n+            let mut coerce = CoerceMany::with_coercion_sites(coerce_to, args);\n+            assert_eq!(self.diverges.get(), Diverges::Maybe);\n+            for e in args {\n+                let e_ty = self.check_expr_with_hint(e, coerce_to);\n+                let cause = self.misc(e.span);\n+                coerce.coerce(self, &cause, e, e_ty);\n+            }\n+            coerce.complete(self)\n+        } else {\n+            self.next_ty_var(TypeVariableOrigin {\n+                kind: TypeVariableOriginKind::TypeInference,\n+                span: expr.span,\n+            })\n+        };\n+        self.tcx.mk_array(element_ty, args.len() as u64)\n+    }\n+\n+    fn check_expr_repeat(\n+        &self,\n+        element: &'tcx hir::Expr,\n+        count: &'tcx hir::AnonConst,\n+        expected: Expectation<'tcx>,\n+        expr: &'tcx hir::Expr,\n+    ) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+        let count_def_id = tcx.hir().local_def_id_from_hir_id(count.hir_id);\n+        let count = if self.const_param_def_id(count).is_some() {\n+            Ok(self.to_const(count, tcx.type_of(count_def_id)))\n+        } else {\n+            let param_env = ty::ParamEnv::empty();\n+            let substs = InternalSubsts::identity_for_item(tcx.global_tcx(), count_def_id);\n+            let instance = ty::Instance::resolve(\n+                tcx.global_tcx(),\n+                param_env,\n+                count_def_id,\n+                substs,\n+            ).unwrap();\n+            let global_id = GlobalId {\n+                instance,\n+                promoted: None\n+            };\n+\n+            tcx.const_eval(param_env.and(global_id))\n+        };\n+\n+        let uty = match expected {\n+            ExpectHasType(uty) => {\n+                match uty.sty {\n+                    ty::Array(ty, _) | ty::Slice(ty) => Some(ty),\n+                    _ => None\n+                }\n+            }\n+            _ => None\n+        };\n+\n+        let (element_ty, t) = match uty {\n+            Some(uty) => {\n+                self.check_expr_coercable_to_type(&element, uty);\n+                (uty, uty)\n+            }\n+            None => {\n+                let ty = self.next_ty_var(TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::MiscVariable,\n+                    span: element.span,\n+                });\n+                let element_ty = self.check_expr_has_type_or_error(&element, ty);\n+                (element_ty, ty)\n+            }\n+        };\n+\n+        if let Ok(count) = count {\n+            let zero_or_one = count.assert_usize(tcx).map_or(false, |count| count <= 1);\n+            if !zero_or_one {\n+                // For [foo, ..n] where n > 1, `foo` must have\n+                // Copy type:\n+                let lang_item = tcx.require_lang_item(lang_items::CopyTraitLangItem);\n+                self.require_type_meets(t, expr.span, traits::RepeatVec, lang_item);\n+            }\n+        }\n+\n+        if element_ty.references_error() {\n+            tcx.types.err\n+        } else if let Ok(count) = count {\n+            tcx.mk_ty(ty::Array(t, count))\n+        } else {\n+            tcx.types.err\n+        }\n+    }\n+\n+    fn check_expr_tuple(\n+        &self,\n+        elts: &'tcx [hir::Expr],\n+        expected: Expectation<'tcx>,\n+        expr: &'tcx hir::Expr,\n+    ) -> Ty<'tcx> {\n+        let flds = expected.only_has_type(self).and_then(|ty| {\n+            let ty = self.resolve_type_vars_with_obligations(ty);\n+            match ty.sty {\n+                ty::Tuple(ref flds) => Some(&flds[..]),\n+                _ => None\n+            }\n+        });\n+\n+        let elt_ts_iter = elts.iter().enumerate().map(|(i, e)| {\n+            let t = match flds {\n+                Some(ref fs) if i < fs.len() => {\n+                    let ety = fs[i].expect_ty();\n+                    self.check_expr_coercable_to_type(&e, ety);\n+                    ety\n+                }\n+                _ => {\n+                    self.check_expr_with_expectation(&e, NoExpectation)\n+                }\n+            };\n+            t\n+        });\n+        let tuple = self.tcx.mk_tup(elt_ts_iter);\n+        if tuple.references_error() {\n+            self.tcx.types.err\n+        } else {\n+            self.require_type_is_sized(tuple, expr.span, traits::TupleInitializerSized);\n+            tuple\n+        }\n+    }\n+\n+    fn check_expr_struct(\n+        &self,\n+        expr: &hir::Expr,\n+        expected: Expectation<'tcx>,\n+        qpath: &QPath,\n+        fields: &'tcx [hir::Field],\n+        base_expr: &'tcx Option<P<hir::Expr>>,\n+    ) -> Ty<'tcx> {\n+        // Find the relevant variant\n+        let (variant, adt_ty) =\n+            if let Some(variant_ty) = self.check_struct_path(qpath, expr.hir_id) {\n+                variant_ty\n+            } else {\n+                self.check_struct_fields_on_error(fields, base_expr);\n+                return self.tcx.types.err;\n+            };\n+\n+        let path_span = match *qpath {\n+            QPath::Resolved(_, ref path) => path.span,\n+            QPath::TypeRelative(ref qself, _) => qself.span\n+        };\n+\n+        // Prohibit struct expressions when non-exhaustive flag is set.\n+        let adt = adt_ty.ty_adt_def().expect(\"`check_struct_path` returned non-ADT type\");\n+        if !adt.did.is_local() && variant.is_field_list_non_exhaustive() {\n+            span_err!(self.tcx.sess, expr.span, E0639,\n+                      \"cannot create non-exhaustive {} using struct expression\",\n+                      adt.variant_descr());\n+        }\n+\n+        let error_happened = self.check_expr_struct_fields(adt_ty, expected, expr.hir_id, path_span,\n+                                                           variant, fields, base_expr.is_none());\n+        if let &Some(ref base_expr) = base_expr {\n+            // If check_expr_struct_fields hit an error, do not attempt to populate\n+            // the fields with the base_expr. This could cause us to hit errors later\n+            // when certain fields are assumed to exist that in fact do not.\n+            if !error_happened {\n+                self.check_expr_has_type_or_error(base_expr, adt_ty);\n+                match adt_ty.sty {\n+                    ty::Adt(adt, substs) if adt.is_struct() => {\n+                        let fru_field_types = adt.non_enum_variant().fields.iter().map(|f| {\n+                            self.normalize_associated_types_in(expr.span, &f.ty(self.tcx, substs))\n+                        }).collect();\n+\n+                        self.tables\n+                            .borrow_mut()\n+                            .fru_field_types_mut()\n+                            .insert(expr.hir_id, fru_field_types);\n+                    }\n+                    _ => {\n+                        span_err!(self.tcx.sess, base_expr.span, E0436,\n+                                  \"functional record update syntax requires a struct\");\n+                    }\n+                }\n+            }\n+        }\n+        self.require_type_is_sized(adt_ty, expr.span, traits::StructInitializerSized);\n+        adt_ty\n+    }\n+\n+    fn check_expr_struct_fields(\n+        &self,\n+        adt_ty: Ty<'tcx>,\n+        expected: Expectation<'tcx>,\n+        expr_id: hir::HirId,\n+        span: Span,\n+        variant: &'tcx ty::VariantDef,\n+        ast_fields: &'tcx [hir::Field],\n+        check_completeness: bool,\n+    ) -> bool {\n+        let tcx = self.tcx;\n+\n+        let adt_ty_hint =\n+            self.expected_inputs_for_expected_output(span, expected, adt_ty, &[adt_ty])\n+                .get(0).cloned().unwrap_or(adt_ty);\n+        // re-link the regions that EIfEO can erase.\n+        self.demand_eqtype(span, adt_ty_hint, adt_ty);\n+\n+        let (substs, adt_kind, kind_name) = match &adt_ty.sty {\n+            &ty::Adt(adt, substs) => {\n+                (substs, adt.adt_kind(), adt.variant_descr())\n+            }\n+            _ => span_bug!(span, \"non-ADT passed to check_expr_struct_fields\")\n+        };\n+\n+        let mut remaining_fields = variant.fields.iter().enumerate().map(|(i, field)|\n+            (field.ident.modern(), (i, field))\n+        ).collect::<FxHashMap<_, _>>();\n+\n+        let mut seen_fields = FxHashMap::default();\n+\n+        let mut error_happened = false;\n+\n+        // Type-check each field.\n+        for field in ast_fields {\n+            let ident = tcx.adjust_ident(field.ident, variant.def_id);\n+            let field_type = if let Some((i, v_field)) = remaining_fields.remove(&ident) {\n+                seen_fields.insert(ident, field.span);\n+                self.write_field_index(field.hir_id, i);\n+\n+                // We don't look at stability attributes on\n+                // struct-like enums (yet...), but it's definitely not\n+                // a bug to have constructed one.\n+                if adt_kind != AdtKind::Enum {\n+                    tcx.check_stability(v_field.did, Some(expr_id), field.span);\n+                }\n+\n+                self.field_ty(field.span, v_field, substs)\n+            } else {\n+                error_happened = true;\n+                if let Some(prev_span) = seen_fields.get(&ident) {\n+                    let mut err = struct_span_err!(self.tcx.sess,\n+                                                   field.ident.span,\n+                                                   E0062,\n+                                                   \"field `{}` specified more than once\",\n+                                                   ident);\n+\n+                    err.span_label(field.ident.span, \"used more than once\");\n+                    err.span_label(*prev_span, format!(\"first use of `{}`\", ident));\n+\n+                    err.emit();\n+                } else {\n+                    self.report_unknown_field(adt_ty, variant, field, ast_fields, kind_name);\n+                }\n+\n+                tcx.types.err\n+            };\n+\n+            // Make sure to give a type to the field even if there's\n+            // an error, so we can continue type-checking.\n+            self.check_expr_coercable_to_type(&field.expr, field_type);\n+        }\n+\n+        // Make sure the programmer specified correct number of fields.\n+        if kind_name == \"union\" {\n+            if ast_fields.len() != 1 {\n+                tcx.sess.span_err(span, \"union expressions should have exactly one field\");\n+            }\n+        } else if check_completeness && !error_happened && !remaining_fields.is_empty() {\n+            let len = remaining_fields.len();\n+\n+            let mut displayable_field_names = remaining_fields\n+                                              .keys()\n+                                              .map(|ident| ident.as_str())\n+                                              .collect::<Vec<_>>();\n+\n+            displayable_field_names.sort();\n+\n+            let truncated_fields_error = if len <= 3 {\n+                String::new()\n+            } else {\n+                format!(\" and {} other field{}\", (len - 3), if len - 3 == 1 {\"\"} else {\"s\"})\n+            };\n+\n+            let remaining_fields_names = displayable_field_names.iter().take(3)\n+                                        .map(|n| format!(\"`{}`\", n))\n+                                        .collect::<Vec<_>>()\n+                                        .join(\", \");\n+\n+            struct_span_err!(tcx.sess, span, E0063,\n+                             \"missing field{} {}{} in initializer of `{}`\",\n+                             if remaining_fields.len() == 1 { \"\" } else { \"s\" },\n+                             remaining_fields_names,\n+                             truncated_fields_error,\n+                             adt_ty)\n+                .span_label(span, format!(\"missing {}{}\",\n+                                          remaining_fields_names,\n+                                          truncated_fields_error))\n+                .emit();\n+        }\n+        error_happened\n+    }\n+\n+    fn check_struct_fields_on_error(\n+        &self,\n+        fields: &'tcx [hir::Field],\n+        base_expr: &'tcx Option<P<hir::Expr>>,\n+    ) {\n+        for field in fields {\n+            self.check_expr(&field.expr);\n+        }\n+        if let Some(ref base) = *base_expr {\n+            self.check_expr(&base);\n+        }\n+    }\n+\n+    fn report_unknown_field(\n+        &self,\n+        ty: Ty<'tcx>,\n+        variant: &'tcx ty::VariantDef,\n+        field: &hir::Field,\n+        skip_fields: &[hir::Field],\n+        kind_name: &str,\n+    ) {\n+        if variant.recovered {\n+            return;\n+        }\n+        let mut err = self.type_error_struct_with_diag(\n+            field.ident.span,\n+            |actual| match ty.sty {\n+                ty::Adt(adt, ..) if adt.is_enum() => {\n+                    struct_span_err!(self.tcx.sess, field.ident.span, E0559,\n+                                     \"{} `{}::{}` has no field named `{}`\",\n+                                     kind_name, actual, variant.ident, field.ident)\n+                }\n+                _ => {\n+                    struct_span_err!(self.tcx.sess, field.ident.span, E0560,\n+                                     \"{} `{}` has no field named `{}`\",\n+                                     kind_name, actual, field.ident)\n+                }\n+            },\n+            ty);\n+        // prevent all specified fields from being suggested\n+        let skip_fields = skip_fields.iter().map(|ref x| x.ident.as_str());\n+        if let Some(field_name) = Self::suggest_field_name(variant,\n+                                                           &field.ident.as_str(),\n+                                                           skip_fields.collect()) {\n+            err.span_suggestion(\n+                field.ident.span,\n+                \"a field with a similar name exists\",\n+                field_name.to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        } else {\n+            match ty.sty {\n+                ty::Adt(adt, ..) => {\n+                    if adt.is_enum() {\n+                        err.span_label(field.ident.span,\n+                                       format!(\"`{}::{}` does not have this field\",\n+                                               ty, variant.ident));\n+                    } else {\n+                        err.span_label(field.ident.span,\n+                                       format!(\"`{}` does not have this field\", ty));\n+                    }\n+                    let available_field_names = self.available_field_names(variant);\n+                    if !available_field_names.is_empty() {\n+                        err.note(&format!(\"available fields are: {}\",\n+                                          self.name_series_display(available_field_names)));\n+                    }\n+                }\n+                _ => bug!(\"non-ADT passed to report_unknown_field\")\n+            }\n+        };\n+        err.emit();\n+    }\n+\n+    // Return an hint about the closest match in field names\n+    fn suggest_field_name(variant: &'tcx ty::VariantDef,\n+                          field: &str,\n+                          skip: Vec<LocalInternedString>)\n+                          -> Option<Symbol> {\n+        let names = variant.fields.iter().filter_map(|field| {\n+            // ignore already set fields and private fields from non-local crates\n+            if skip.iter().any(|x| *x == field.ident.as_str()) ||\n+               (!variant.def_id.is_local() && field.vis != Visibility::Public)\n+            {\n+                None\n+            } else {\n+                Some(&field.ident.name)\n+            }\n+        });\n+\n+        find_best_match_for_name(names, field, None)\n+    }\n+\n+    fn available_field_names(&self, variant: &'tcx ty::VariantDef) -> Vec<ast::Name> {\n+        variant.fields.iter().filter(|field| {\n+            let def_scope =\n+                self.tcx.adjust_ident_and_get_scope(field.ident, variant.def_id, self.body_id).1;\n+            field.vis.is_accessible_from(def_scope, self.tcx)\n+        })\n+        .map(|field| field.ident.name)\n+        .collect()\n+    }\n+\n+    fn name_series_display(&self, names: Vec<ast::Name>) -> String {\n+        // dynamic limit, to never omit just one field\n+        let limit = if names.len() == 6 { 6 } else { 5 };\n+        let mut display = names.iter().take(limit)\n+            .map(|n| format!(\"`{}`\", n)).collect::<Vec<_>>().join(\", \");\n+        if names.len() > limit {\n+            display = format!(\"{} ... and {} others\", display, names.len() - limit);\n+        }\n+        display\n+    }\n+\n+    // Check field access expressions\n+    fn check_field(\n+        &self,\n+        expr: &'tcx hir::Expr,\n+        needs: Needs,\n+        base: &'tcx hir::Expr,\n+        field: ast::Ident,\n+    ) -> Ty<'tcx> {\n+        let expr_t = self.check_expr_with_needs(base, needs);\n+        let expr_t = self.structurally_resolved_type(base.span,\n+                                                     expr_t);\n+        let mut private_candidate = None;\n+        let mut autoderef = self.autoderef(expr.span, expr_t);\n+        while let Some((base_t, _)) = autoderef.next() {\n+            match base_t.sty {\n+                ty::Adt(base_def, substs) if !base_def.is_enum() => {\n+                    debug!(\"struct named {:?}\",  base_t);\n+                    let (ident, def_scope) =\n+                        self.tcx.adjust_ident_and_get_scope(field, base_def.did, self.body_id);\n+                    let fields = &base_def.non_enum_variant().fields;\n+                    if let Some(index) = fields.iter().position(|f| f.ident.modern() == ident) {\n+                        let field = &fields[index];\n+                        let field_ty = self.field_ty(expr.span, field, substs);\n+                        // Save the index of all fields regardless of their visibility in case\n+                        // of error recovery.\n+                        self.write_field_index(expr.hir_id, index);\n+                        if field.vis.is_accessible_from(def_scope, self.tcx) {\n+                            let adjustments = autoderef.adjust_steps(self, needs);\n+                            self.apply_adjustments(base, adjustments);\n+                            autoderef.finalize(self);\n+\n+                            self.tcx.check_stability(field.did, Some(expr.hir_id), expr.span);\n+                            return field_ty;\n+                        }\n+                        private_candidate = Some((base_def.did, field_ty));\n+                    }\n+                }\n+                ty::Tuple(ref tys) => {\n+                    let fstr = field.as_str();\n+                    if let Ok(index) = fstr.parse::<usize>() {\n+                        if fstr == index.to_string() {\n+                            if let Some(field_ty) = tys.get(index) {\n+                                let adjustments = autoderef.adjust_steps(self, needs);\n+                                self.apply_adjustments(base, adjustments);\n+                                autoderef.finalize(self);\n+\n+                                self.write_field_index(expr.hir_id, index);\n+                                return field_ty.expect_ty();\n+                            }\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+        autoderef.unambiguous_final_ty(self);\n+\n+        if let Some((did, field_ty)) = private_candidate {\n+            let struct_path = self.tcx().def_path_str(did);\n+            let mut err = struct_span_err!(self.tcx().sess, expr.span, E0616,\n+                                           \"field `{}` of struct `{}` is private\",\n+                                           field, struct_path);\n+            // Also check if an accessible method exists, which is often what is meant.\n+            if self.method_exists(field, expr_t, expr.hir_id, false)\n+                && !self.expr_in_place(expr.hir_id)\n+            {\n+                self.suggest_method_call(\n+                    &mut err,\n+                    &format!(\"a method `{}` also exists, call it with parentheses\", field),\n+                    field,\n+                    expr_t,\n+                    expr.hir_id,\n+                );\n+            }\n+            err.emit();\n+            field_ty\n+        } else if field.name == kw::Invalid {\n+            self.tcx().types.err\n+        } else if self.method_exists(field, expr_t, expr.hir_id, true) {\n+            let mut err = type_error_struct!(self.tcx().sess, field.span, expr_t, E0615,\n+                               \"attempted to take value of method `{}` on type `{}`\",\n+                               field, expr_t);\n+\n+            if !self.expr_in_place(expr.hir_id) {\n+                self.suggest_method_call(\n+                    &mut err,\n+                    \"use parentheses to call the method\",\n+                    field,\n+                    expr_t,\n+                    expr.hir_id\n+                );\n+            } else {\n+                err.help(\"methods are immutable and cannot be assigned to\");\n+            }\n+\n+            err.emit();\n+            self.tcx().types.err\n+        } else {\n+            if !expr_t.is_primitive_ty() {\n+                let mut err = self.no_such_field_err(field.span, field, expr_t);\n+\n+                match expr_t.sty {\n+                    ty::Adt(def, _) if !def.is_enum() => {\n+                        if let Some(suggested_field_name) =\n+                            Self::suggest_field_name(def.non_enum_variant(),\n+                                                     &field.as_str(), vec![]) {\n+                                err.span_suggestion(\n+                                    field.span,\n+                                    \"a field with a similar name exists\",\n+                                    suggested_field_name.to_string(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            } else {\n+                                err.span_label(field.span, \"unknown field\");\n+                                let struct_variant_def = def.non_enum_variant();\n+                                let field_names = self.available_field_names(struct_variant_def);\n+                                if !field_names.is_empty() {\n+                                    err.note(&format!(\"available fields are: {}\",\n+                                                      self.name_series_display(field_names)));\n+                                }\n+                            };\n+                    }\n+                    ty::Array(_, len) => {\n+                        if let (Some(len), Ok(user_index)) = (\n+                            len.assert_usize(self.tcx),\n+                            field.as_str().parse::<u64>()\n+                        ) {\n+                            let base = self.tcx.sess.source_map()\n+                                .span_to_snippet(base.span)\n+                                .unwrap_or_else(|_|\n+                                    self.tcx.hir().hir_to_pretty_string(base.hir_id));\n+                            let help = \"instead of using tuple indexing, use array indexing\";\n+                            let suggestion = format!(\"{}[{}]\", base, field);\n+                            let applicability = if len < user_index {\n+                                Applicability::MachineApplicable\n+                            } else {\n+                                Applicability::MaybeIncorrect\n+                            };\n+                            err.span_suggestion(\n+                                expr.span, help, suggestion, applicability\n+                            );\n+                        }\n+                    }\n+                    ty::RawPtr(..) => {\n+                        let base = self.tcx.sess.source_map()\n+                            .span_to_snippet(base.span)\n+                            .unwrap_or_else(|_| self.tcx.hir().hir_to_pretty_string(base.hir_id));\n+                        let msg = format!(\"`{}` is a raw pointer; try dereferencing it\", base);\n+                        let suggestion = format!(\"(*{}).{}\", base, field);\n+                        err.span_suggestion(\n+                            expr.span,\n+                            &msg,\n+                            suggestion,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                    _ => {}\n+                }\n+                err\n+            } else {\n+                type_error_struct!(self.tcx().sess, field.span, expr_t, E0610,\n+                                   \"`{}` is a primitive type and therefore doesn't have fields\",\n+                                   expr_t)\n+            }.emit();\n+            self.tcx().types.err\n+        }\n+    }\n+\n+    fn no_such_field_err<T: Display>(&self, span: Span, field: T, expr_t: &ty::TyS<'_>)\n+        -> DiagnosticBuilder<'_> {\n+        type_error_struct!(self.tcx().sess, span, expr_t, E0609,\n+                           \"no field `{}` on type `{}`\",\n+                           field, expr_t)\n+    }\n+\n+    fn check_expr_index(\n+        &self,\n+        base: &'tcx hir::Expr,\n+        idx: &'tcx hir::Expr,\n+        needs: Needs,\n+        expr: &'tcx hir::Expr,\n+    ) -> Ty<'tcx> {\n+        let base_t = self.check_expr_with_needs(&base, needs);\n+        let idx_t = self.check_expr(&idx);\n+\n+        if base_t.references_error() {\n+            base_t\n+        } else if idx_t.references_error() {\n+            idx_t\n+        } else {\n+            let base_t = self.structurally_resolved_type(base.span, base_t);\n+            match self.lookup_indexing(expr, base, base_t, idx_t, needs) {\n+                Some((index_ty, element_ty)) => {\n+                    // two-phase not needed because index_ty is never mutable\n+                    self.demand_coerce(idx, idx_t, index_ty, AllowTwoPhase::No);\n+                    element_ty\n+                }\n+                None => {\n+                    let mut err =\n+                        type_error_struct!(self.tcx.sess, expr.span, base_t, E0608,\n+                                            \"cannot index into a value of type `{}`\",\n+                                            base_t);\n+                    // Try to give some advice about indexing tuples.\n+                    if let ty::Tuple(..) = base_t.sty {\n+                        let mut needs_note = true;\n+                        // If the index is an integer, we can show the actual\n+                        // fixed expression:\n+                        if let ExprKind::Lit(ref lit) = idx.node {\n+                            if let ast::LitKind::Int(i, ast::LitIntType::Unsuffixed) = lit.node {\n+                                let snip = self.tcx.sess.source_map().span_to_snippet(base.span);\n+                                if let Ok(snip) = snip {\n+                                    err.span_suggestion(\n+                                        expr.span,\n+                                        \"to access tuple elements, use\",\n+                                        format!(\"{}.{}\", snip, i),\n+                                        Applicability::MachineApplicable,\n+                                    );\n+                                    needs_note = false;\n+                                }\n+                            }\n+                        }\n+                        if needs_note {\n+                            err.help(\"to access tuple elements, use tuple indexing \\\n+                                        syntax (e.g., `tuple.0`)\");\n+                        }\n+                    }\n+                    err.emit();\n+                    self.tcx.types.err\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_expr_yield(&self, value: &'tcx hir::Expr, expr: &'tcx hir::Expr) -> Ty<'tcx> {\n+        match self.yield_ty {\n+            Some(ty) => {\n+                self.check_expr_coercable_to_type(&value, ty);\n+            }\n+            None => {\n+                struct_span_err!(self.tcx.sess, expr.span, E0627,\n+                                    \"yield statement outside of generator literal\").emit();\n+            }\n+        }\n+        self.tcx.mk_unit()\n+    }\n+}"}, {"sha": "ecf7860367bec925c2902287335bbd3db6633639", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 1382, "changes": 1387, "blob_url": "https://github.com/rust-lang/rust/blob/b01a257da1fbb3f5661029dd390fdccc49dff287/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b01a257da1fbb3f5661029dd390fdccc49dff287/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b01a257da1fbb3f5661029dd390fdccc49dff287", "patch": "@@ -74,6 +74,7 @@ pub mod writeback;\n mod regionck;\n pub mod coercion;\n pub mod demand;\n+mod expr;\n pub mod method;\n mod upvar;\n mod wfcheck;\n@@ -88,7 +89,7 @@ mod op;\n use crate::astconv::{AstConv, PathSeg};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n use rustc::hir::{self, ExprKind, GenericArg, ItemKind, Node, PatKind, QPath};\n-use rustc::hir::def::{CtorOf, CtorKind, Res, DefKind};\n+use rustc::hir::def::{CtorOf, Res, DefKind};\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -105,7 +106,7 @@ use rustc::middle::region;\n use rustc::mir::interpret::{ConstValue, GlobalId};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n use rustc::ty::{\n-    self, AdtKind, CanonicalUserType, Ty, TyCtxt, Const, GenericParamDefKind, Visibility,\n+    self, AdtKind, CanonicalUserType, Ty, TyCtxt, Const, GenericParamDefKind,\n     ToPolyTraitRef, ToPredicate, RegionKind, UserType\n };\n use rustc::ty::adjustment::{\n@@ -123,13 +124,11 @@ use syntax::attr;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::ptr::P;\n use syntax::source_map::{DUMMY_SP, original_sp};\n-use syntax::symbol::{Symbol, LocalInternedString, kw, sym};\n-use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax::symbol::{kw, sym};\n \n use std::cell::{Cell, RefCell, Ref, RefMut};\n use std::collections::hash_map::Entry;\n use std::cmp;\n-use std::fmt::Display;\n use std::iter;\n use std::mem::replace;\n use std::ops::{self, Deref};\n@@ -142,7 +141,7 @@ use crate::TypeAndSubsts;\n use crate::lint;\n use crate::util::captures::Captures;\n use crate::util::common::{ErrorReported, indenter};\n-use crate::util::nodemap::{DefIdMap, DefIdSet, FxHashMap, FxHashSet, HirIdMap};\n+use crate::util::nodemap::{DefIdMap, DefIdSet, FxHashSet, HirIdMap};\n \n pub use self::Expectation::*;\n use self::autoderef::Autoderef;\n@@ -3196,82 +3195,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_expr_eq_type(&self, expr: &'tcx hir::Expr, expected: Ty<'tcx>) {\n-        let ty = self.check_expr_with_hint(expr, expected);\n-        self.demand_eqtype(expr.span, expected, ty);\n-    }\n-\n-    pub fn check_expr_has_type_or_error(\n-        &self,\n-        expr: &'tcx hir::Expr,\n-        expected: Ty<'tcx>,\n-    ) -> Ty<'tcx> {\n-        self.check_expr_meets_expectation_or_error(expr, ExpectHasType(expected))\n-    }\n-\n-    fn check_expr_meets_expectation_or_error(\n-        &self,\n-        expr: &'tcx hir::Expr,\n-        expected: Expectation<'tcx>,\n-    ) -> Ty<'tcx> {\n-        let expected_ty = expected.to_option(&self).unwrap_or(self.tcx.types.bool);\n-        let mut ty = self.check_expr_with_expectation(expr, expected);\n-\n-        // While we don't allow *arbitrary* coercions here, we *do* allow\n-        // coercions from ! to `expected`.\n-        if ty.is_never() {\n-            assert!(!self.tables.borrow().adjustments().contains_key(expr.hir_id),\n-                    \"expression with never type wound up being adjusted\");\n-            let adj_ty = self.next_diverging_ty_var(\n-                TypeVariableOrigin {\n-                    kind: TypeVariableOriginKind::AdjustmentType,\n-                    span: expr.span,\n-                },\n-            );\n-            self.apply_adjustments(expr, vec![Adjustment {\n-                kind: Adjust::NeverToAny,\n-                target: adj_ty\n-            }]);\n-            ty = adj_ty;\n-        }\n-\n-        if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n-            let expr = match &expr.node {\n-                ExprKind::DropTemps(expr) => expr,\n-                _ => expr,\n-            };\n-            // Error possibly reported in `check_assign` so avoid emitting error again.\n-            err.emit_unless(self.is_assign_to_bool(expr, expected_ty));\n-        }\n-        ty\n-    }\n-\n-    fn check_expr_coercable_to_type(&self, expr: &'tcx hir::Expr, expected: Ty<'tcx>) -> Ty<'tcx> {\n-        let ty = self.check_expr_with_hint(expr, expected);\n-        // checks don't need two phase\n-        self.demand_coerce(expr, ty, expected, AllowTwoPhase::No)\n-    }\n-\n-    fn check_expr_with_hint(&self, expr: &'tcx hir::Expr, expected: Ty<'tcx>) -> Ty<'tcx> {\n-        self.check_expr_with_expectation(expr, ExpectHasType(expected))\n-    }\n-\n-    fn check_expr_with_expectation(\n-        &self,\n-        expr: &'tcx hir::Expr,\n-        expected: Expectation<'tcx>,\n-    ) -> Ty<'tcx> {\n-        self.check_expr_with_expectation_and_needs(expr, expected, Needs::None)\n-    }\n-\n-    fn check_expr(&self, expr: &'tcx hir::Expr) -> Ty<'tcx> {\n-        self.check_expr_with_expectation(expr, NoExpectation)\n-    }\n-\n-    fn check_expr_with_needs(&self, expr: &'tcx hir::Expr, needs: Needs) -> Ty<'tcx> {\n-        self.check_expr_with_expectation_and_needs(expr, NoExpectation, needs)\n-    }\n-\n     // Determine the `Self` type, using fresh variables for all variables\n     // declared on the impl declaration e.g., `impl<A,B> for Vec<(A,B)>`\n     // would return `($0, $1)` where `$0` and `$1` are freshly instantiated type\n@@ -3341,470 +3264,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expect_args\n     }\n \n-    // Checks a method call.\n-    fn check_method_call(\n-        &self,\n-        expr: &'tcx hir::Expr,\n-        segment: &hir::PathSegment,\n-        span: Span,\n-        args: &'tcx [hir::Expr],\n-        expected: Expectation<'tcx>,\n-        needs: Needs,\n-    ) -> Ty<'tcx> {\n-        let rcvr = &args[0];\n-        let rcvr_t = self.check_expr_with_needs(&rcvr, needs);\n-        // no need to check for bot/err -- callee does that\n-        let rcvr_t = self.structurally_resolved_type(args[0].span, rcvr_t);\n-\n-        let method = match self.lookup_method(rcvr_t,\n-                                              segment,\n-                                              span,\n-                                              expr,\n-                                              rcvr) {\n-            Ok(method) => {\n-                self.write_method_call(expr.hir_id, method);\n-                Ok(method)\n-            }\n-            Err(error) => {\n-                if segment.ident.name != kw::Invalid {\n-                    self.report_method_error(span,\n-                                             rcvr_t,\n-                                             segment.ident,\n-                                             SelfSource::MethodCall(rcvr),\n-                                             error,\n-                                             Some(args));\n-                }\n-                Err(())\n-            }\n-        };\n-\n-        // Call the generic checker.\n-        self.check_method_argument_types(span,\n-                                         expr.span,\n-                                         method,\n-                                         &args[1..],\n-                                         DontTupleArguments,\n-                                         expected)\n-    }\n-\n-    fn check_return_expr(&self, return_expr: &'tcx hir::Expr) {\n-        let ret_coercion =\n-            self.ret_coercion\n-                .as_ref()\n-                .unwrap_or_else(|| span_bug!(return_expr.span,\n-                                             \"check_return_expr called outside fn body\"));\n-\n-        let ret_ty = ret_coercion.borrow().expected_ty();\n-        let return_expr_ty = self.check_expr_with_hint(return_expr, ret_ty.clone());\n-        ret_coercion.borrow_mut()\n-                    .coerce(self,\n-                            &self.cause(return_expr.span,\n-                                        ObligationCauseCode::ReturnType(return_expr.hir_id)),\n-                            return_expr,\n-                            return_expr_ty);\n-    }\n-\n-    // Check field access expressions\n-    fn check_field(\n-        &self,\n-        expr: &'tcx hir::Expr,\n-        needs: Needs,\n-        base: &'tcx hir::Expr,\n-        field: ast::Ident,\n-    ) -> Ty<'tcx> {\n-        let expr_t = self.check_expr_with_needs(base, needs);\n-        let expr_t = self.structurally_resolved_type(base.span,\n-                                                     expr_t);\n-        let mut private_candidate = None;\n-        let mut autoderef = self.autoderef(expr.span, expr_t);\n-        while let Some((base_t, _)) = autoderef.next() {\n-            match base_t.sty {\n-                ty::Adt(base_def, substs) if !base_def.is_enum() => {\n-                    debug!(\"struct named {:?}\",  base_t);\n-                    let (ident, def_scope) =\n-                        self.tcx.adjust_ident_and_get_scope(field, base_def.did, self.body_id);\n-                    let fields = &base_def.non_enum_variant().fields;\n-                    if let Some(index) = fields.iter().position(|f| f.ident.modern() == ident) {\n-                        let field = &fields[index];\n-                        let field_ty = self.field_ty(expr.span, field, substs);\n-                        // Save the index of all fields regardless of their visibility in case\n-                        // of error recovery.\n-                        self.write_field_index(expr.hir_id, index);\n-                        if field.vis.is_accessible_from(def_scope, self.tcx) {\n-                            let adjustments = autoderef.adjust_steps(self, needs);\n-                            self.apply_adjustments(base, adjustments);\n-                            autoderef.finalize(self);\n-\n-                            self.tcx.check_stability(field.did, Some(expr.hir_id), expr.span);\n-                            return field_ty;\n-                        }\n-                        private_candidate = Some((base_def.did, field_ty));\n-                    }\n-                }\n-                ty::Tuple(ref tys) => {\n-                    let fstr = field.as_str();\n-                    if let Ok(index) = fstr.parse::<usize>() {\n-                        if fstr == index.to_string() {\n-                            if let Some(field_ty) = tys.get(index) {\n-                                let adjustments = autoderef.adjust_steps(self, needs);\n-                                self.apply_adjustments(base, adjustments);\n-                                autoderef.finalize(self);\n-\n-                                self.write_field_index(expr.hir_id, index);\n-                                return field_ty.expect_ty();\n-                            }\n-                        }\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-        autoderef.unambiguous_final_ty(self);\n-\n-        if let Some((did, field_ty)) = private_candidate {\n-            let struct_path = self.tcx().def_path_str(did);\n-            let mut err = struct_span_err!(self.tcx().sess, expr.span, E0616,\n-                                           \"field `{}` of struct `{}` is private\",\n-                                           field, struct_path);\n-            // Also check if an accessible method exists, which is often what is meant.\n-            if self.method_exists(field, expr_t, expr.hir_id, false)\n-                && !self.expr_in_place(expr.hir_id)\n-            {\n-                self.suggest_method_call(\n-                    &mut err,\n-                    &format!(\"a method `{}` also exists, call it with parentheses\", field),\n-                    field,\n-                    expr_t,\n-                    expr.hir_id,\n-                );\n-            }\n-            err.emit();\n-            field_ty\n-        } else if field.name == kw::Invalid {\n-            self.tcx().types.err\n-        } else if self.method_exists(field, expr_t, expr.hir_id, true) {\n-            let mut err = type_error_struct!(self.tcx().sess, field.span, expr_t, E0615,\n-                               \"attempted to take value of method `{}` on type `{}`\",\n-                               field, expr_t);\n-\n-            if !self.expr_in_place(expr.hir_id) {\n-                self.suggest_method_call(\n-                    &mut err,\n-                    \"use parentheses to call the method\",\n-                    field,\n-                    expr_t,\n-                    expr.hir_id\n-                );\n-            } else {\n-                err.help(\"methods are immutable and cannot be assigned to\");\n-            }\n-\n-            err.emit();\n-            self.tcx().types.err\n-        } else {\n-            if !expr_t.is_primitive_ty() {\n-                let mut err = self.no_such_field_err(field.span, field, expr_t);\n-\n-                match expr_t.sty {\n-                    ty::Adt(def, _) if !def.is_enum() => {\n-                        if let Some(suggested_field_name) =\n-                            Self::suggest_field_name(def.non_enum_variant(),\n-                                                     &field.as_str(), vec![]) {\n-                                err.span_suggestion(\n-                                    field.span,\n-                                    \"a field with a similar name exists\",\n-                                    suggested_field_name.to_string(),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            } else {\n-                                err.span_label(field.span, \"unknown field\");\n-                                let struct_variant_def = def.non_enum_variant();\n-                                let field_names = self.available_field_names(struct_variant_def);\n-                                if !field_names.is_empty() {\n-                                    err.note(&format!(\"available fields are: {}\",\n-                                                      self.name_series_display(field_names)));\n-                                }\n-                            };\n-                    }\n-                    ty::Array(_, len) => {\n-                        if let (Some(len), Ok(user_index)) = (\n-                            len.assert_usize(self.tcx),\n-                            field.as_str().parse::<u64>()\n-                        ) {\n-                            let base = self.tcx.sess.source_map()\n-                                .span_to_snippet(base.span)\n-                                .unwrap_or_else(|_|\n-                                    self.tcx.hir().hir_to_pretty_string(base.hir_id));\n-                            let help = \"instead of using tuple indexing, use array indexing\";\n-                            let suggestion = format!(\"{}[{}]\", base, field);\n-                            let applicability = if len < user_index {\n-                                Applicability::MachineApplicable\n-                            } else {\n-                                Applicability::MaybeIncorrect\n-                            };\n-                            err.span_suggestion(\n-                                expr.span, help, suggestion, applicability\n-                            );\n-                        }\n-                    }\n-                    ty::RawPtr(..) => {\n-                        let base = self.tcx.sess.source_map()\n-                            .span_to_snippet(base.span)\n-                            .unwrap_or_else(|_| self.tcx.hir().hir_to_pretty_string(base.hir_id));\n-                        let msg = format!(\"`{}` is a raw pointer; try dereferencing it\", base);\n-                        let suggestion = format!(\"(*{}).{}\", base, field);\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &msg,\n-                            suggestion,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                    _ => {}\n-                }\n-                err\n-            } else {\n-                type_error_struct!(self.tcx().sess, field.span, expr_t, E0610,\n-                                   \"`{}` is a primitive type and therefore doesn't have fields\",\n-                                   expr_t)\n-            }.emit();\n-            self.tcx().types.err\n-        }\n-    }\n-\n-    // Return an hint about the closest match in field names\n-    fn suggest_field_name(variant: &'tcx ty::VariantDef,\n-                          field: &str,\n-                          skip: Vec<LocalInternedString>)\n-                          -> Option<Symbol> {\n-        let names = variant.fields.iter().filter_map(|field| {\n-            // ignore already set fields and private fields from non-local crates\n-            if skip.iter().any(|x| *x == field.ident.as_str()) ||\n-               (!variant.def_id.is_local() && field.vis != Visibility::Public)\n-            {\n-                None\n-            } else {\n-                Some(&field.ident.name)\n-            }\n-        });\n-\n-        find_best_match_for_name(names, field, None)\n-    }\n-\n-    fn available_field_names(&self, variant: &'tcx ty::VariantDef) -> Vec<ast::Name> {\n-        variant.fields.iter().filter(|field| {\n-            let def_scope =\n-                self.tcx.adjust_ident_and_get_scope(field.ident, variant.def_id, self.body_id).1;\n-            field.vis.is_accessible_from(def_scope, self.tcx)\n-        })\n-        .map(|field| field.ident.name)\n-        .collect()\n-    }\n-\n-    fn name_series_display(&self, names: Vec<ast::Name>) -> String {\n-        // dynamic limit, to never omit just one field\n-        let limit = if names.len() == 6 { 6 } else { 5 };\n-        let mut display = names.iter().take(limit)\n-            .map(|n| format!(\"`{}`\", n)).collect::<Vec<_>>().join(\", \");\n-        if names.len() > limit {\n-            display = format!(\"{} ... and {} others\", display, names.len() - limit);\n-        }\n-        display\n-    }\n-\n-    fn no_such_field_err<T: Display>(&self, span: Span, field: T, expr_t: &ty::TyS<'_>)\n-        -> DiagnosticBuilder<'_> {\n-        type_error_struct!(self.tcx().sess, span, expr_t, E0609,\n-                           \"no field `{}` on type `{}`\",\n-                           field, expr_t)\n-    }\n-\n-    fn report_unknown_field(\n-        &self,\n-        ty: Ty<'tcx>,\n-        variant: &'tcx ty::VariantDef,\n-        field: &hir::Field,\n-        skip_fields: &[hir::Field],\n-        kind_name: &str,\n-    ) {\n-        if variant.recovered {\n-            return;\n-        }\n-        let mut err = self.type_error_struct_with_diag(\n-            field.ident.span,\n-            |actual| match ty.sty {\n-                ty::Adt(adt, ..) if adt.is_enum() => {\n-                    struct_span_err!(self.tcx.sess, field.ident.span, E0559,\n-                                     \"{} `{}::{}` has no field named `{}`\",\n-                                     kind_name, actual, variant.ident, field.ident)\n-                }\n-                _ => {\n-                    struct_span_err!(self.tcx.sess, field.ident.span, E0560,\n-                                     \"{} `{}` has no field named `{}`\",\n-                                     kind_name, actual, field.ident)\n-                }\n-            },\n-            ty);\n-        // prevent all specified fields from being suggested\n-        let skip_fields = skip_fields.iter().map(|ref x| x.ident.as_str());\n-        if let Some(field_name) = Self::suggest_field_name(variant,\n-                                                           &field.ident.as_str(),\n-                                                           skip_fields.collect()) {\n-            err.span_suggestion(\n-                field.ident.span,\n-                \"a field with a similar name exists\",\n-                field_name.to_string(),\n-                Applicability::MaybeIncorrect,\n-            );\n-        } else {\n-            match ty.sty {\n-                ty::Adt(adt, ..) => {\n-                    if adt.is_enum() {\n-                        err.span_label(field.ident.span,\n-                                       format!(\"`{}::{}` does not have this field\",\n-                                               ty, variant.ident));\n-                    } else {\n-                        err.span_label(field.ident.span,\n-                                       format!(\"`{}` does not have this field\", ty));\n-                    }\n-                    let available_field_names = self.available_field_names(variant);\n-                    if !available_field_names.is_empty() {\n-                        err.note(&format!(\"available fields are: {}\",\n-                                          self.name_series_display(available_field_names)));\n-                    }\n-                }\n-                _ => bug!(\"non-ADT passed to report_unknown_field\")\n-            }\n-        };\n-        err.emit();\n-    }\n-\n-    fn check_expr_struct_fields(\n-        &self,\n-        adt_ty: Ty<'tcx>,\n-        expected: Expectation<'tcx>,\n-        expr_id: hir::HirId,\n-        span: Span,\n-        variant: &'tcx ty::VariantDef,\n-        ast_fields: &'tcx [hir::Field],\n-        check_completeness: bool,\n-    ) -> bool {\n-        let tcx = self.tcx;\n-\n-        let adt_ty_hint =\n-            self.expected_inputs_for_expected_output(span, expected, adt_ty, &[adt_ty])\n-                .get(0).cloned().unwrap_or(adt_ty);\n-        // re-link the regions that EIfEO can erase.\n-        self.demand_eqtype(span, adt_ty_hint, adt_ty);\n-\n-        let (substs, adt_kind, kind_name) = match &adt_ty.sty {\n-            &ty::Adt(adt, substs) => {\n-                (substs, adt.adt_kind(), adt.variant_descr())\n-            }\n-            _ => span_bug!(span, \"non-ADT passed to check_expr_struct_fields\")\n-        };\n-\n-        let mut remaining_fields = variant.fields.iter().enumerate().map(|(i, field)|\n-            (field.ident.modern(), (i, field))\n-        ).collect::<FxHashMap<_, _>>();\n-\n-        let mut seen_fields = FxHashMap::default();\n-\n-        let mut error_happened = false;\n-\n-        // Type-check each field.\n-        for field in ast_fields {\n-            let ident = tcx.adjust_ident(field.ident, variant.def_id);\n-            let field_type = if let Some((i, v_field)) = remaining_fields.remove(&ident) {\n-                seen_fields.insert(ident, field.span);\n-                self.write_field_index(field.hir_id, i);\n-\n-                // We don't look at stability attributes on\n-                // struct-like enums (yet...), but it's definitely not\n-                // a bug to have constructed one.\n-                if adt_kind != AdtKind::Enum {\n-                    tcx.check_stability(v_field.did, Some(expr_id), field.span);\n-                }\n-\n-                self.field_ty(field.span, v_field, substs)\n-            } else {\n-                error_happened = true;\n-                if let Some(prev_span) = seen_fields.get(&ident) {\n-                    let mut err = struct_span_err!(self.tcx.sess,\n-                                                   field.ident.span,\n-                                                   E0062,\n-                                                   \"field `{}` specified more than once\",\n-                                                   ident);\n-\n-                    err.span_label(field.ident.span, \"used more than once\");\n-                    err.span_label(*prev_span, format!(\"first use of `{}`\", ident));\n-\n-                    err.emit();\n-                } else {\n-                    self.report_unknown_field(adt_ty, variant, field, ast_fields, kind_name);\n-                }\n-\n-                tcx.types.err\n-            };\n-\n-            // Make sure to give a type to the field even if there's\n-            // an error, so we can continue type-checking.\n-            self.check_expr_coercable_to_type(&field.expr, field_type);\n-        }\n-\n-        // Make sure the programmer specified correct number of fields.\n-        if kind_name == \"union\" {\n-            if ast_fields.len() != 1 {\n-                tcx.sess.span_err(span, \"union expressions should have exactly one field\");\n-            }\n-        } else if check_completeness && !error_happened && !remaining_fields.is_empty() {\n-            let len = remaining_fields.len();\n-\n-            let mut displayable_field_names = remaining_fields\n-                                              .keys()\n-                                              .map(|ident| ident.as_str())\n-                                              .collect::<Vec<_>>();\n-\n-            displayable_field_names.sort();\n-\n-            let truncated_fields_error = if len <= 3 {\n-                String::new()\n-            } else {\n-                format!(\" and {} other field{}\", (len - 3), if len - 3 == 1 {\"\"} else {\"s\"})\n-            };\n-\n-            let remaining_fields_names = displayable_field_names.iter().take(3)\n-                                        .map(|n| format!(\"`{}`\", n))\n-                                        .collect::<Vec<_>>()\n-                                        .join(\", \");\n-\n-            struct_span_err!(tcx.sess, span, E0063,\n-                             \"missing field{} {}{} in initializer of `{}`\",\n-                             if remaining_fields.len() == 1 { \"\" } else { \"s\" },\n-                             remaining_fields_names,\n-                             truncated_fields_error,\n-                             adt_ty)\n-                .span_label(span, format!(\"missing {}{}\",\n-                                          remaining_fields_names,\n-                                          truncated_fields_error))\n-                .emit();\n-        }\n-        error_happened\n-    }\n-\n-    fn check_struct_fields_on_error(\n-        &self,\n-        fields: &'tcx [hir::Field],\n-        base_expr: &'tcx Option<P<hir::Expr>>,\n-    ) {\n-        for field in fields {\n-            self.check_expr(&field.expr);\n-        }\n-        if let Some(ref base) = *base_expr {\n-            self.check_expr(&base);\n-        }\n-    }\n-\n     pub fn check_struct_path(&self,\n                              qpath: &QPath,\n                              hir_id: hir::HirId)\n@@ -3863,842 +3322,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_expr_struct(\n-        &self,\n-        expr: &hir::Expr,\n-        expected: Expectation<'tcx>,\n-        qpath: &QPath,\n-        fields: &'tcx [hir::Field],\n-        base_expr: &'tcx Option<P<hir::Expr>>,\n-    ) -> Ty<'tcx> {\n-        // Find the relevant variant\n-        let (variant, adt_ty) =\n-            if let Some(variant_ty) = self.check_struct_path(qpath, expr.hir_id) {\n-                variant_ty\n-            } else {\n-                self.check_struct_fields_on_error(fields, base_expr);\n-                return self.tcx.types.err;\n-            };\n-\n-        let path_span = match *qpath {\n-            QPath::Resolved(_, ref path) => path.span,\n-            QPath::TypeRelative(ref qself, _) => qself.span\n-        };\n-\n-        // Prohibit struct expressions when non-exhaustive flag is set.\n-        let adt = adt_ty.ty_adt_def().expect(\"`check_struct_path` returned non-ADT type\");\n-        if !adt.did.is_local() && variant.is_field_list_non_exhaustive() {\n-            span_err!(self.tcx.sess, expr.span, E0639,\n-                      \"cannot create non-exhaustive {} using struct expression\",\n-                      adt.variant_descr());\n-        }\n-\n-        let error_happened = self.check_expr_struct_fields(adt_ty, expected, expr.hir_id, path_span,\n-                                                           variant, fields, base_expr.is_none());\n-        if let &Some(ref base_expr) = base_expr {\n-            // If check_expr_struct_fields hit an error, do not attempt to populate\n-            // the fields with the base_expr. This could cause us to hit errors later\n-            // when certain fields are assumed to exist that in fact do not.\n-            if !error_happened {\n-                self.check_expr_has_type_or_error(base_expr, adt_ty);\n-                match adt_ty.sty {\n-                    ty::Adt(adt, substs) if adt.is_struct() => {\n-                        let fru_field_types = adt.non_enum_variant().fields.iter().map(|f| {\n-                            self.normalize_associated_types_in(expr.span, &f.ty(self.tcx, substs))\n-                        }).collect();\n-\n-                        self.tables\n-                            .borrow_mut()\n-                            .fru_field_types_mut()\n-                            .insert(expr.hir_id, fru_field_types);\n-                    }\n-                    _ => {\n-                        span_err!(self.tcx.sess, base_expr.span, E0436,\n-                                  \"functional record update syntax requires a struct\");\n-                    }\n-                }\n-            }\n-        }\n-        self.require_type_is_sized(adt_ty, expr.span, traits::StructInitializerSized);\n-        adt_ty\n-    }\n-\n-\n-    /// Invariant:\n-    /// If an expression has any sub-expressions that result in a type error,\n-    /// inspecting that expression's type with `ty.references_error()` will return\n-    /// true. Likewise, if an expression is known to diverge, inspecting its\n-    /// type with `ty::type_is_bot` will return true (n.b.: since Rust is\n-    /// strict, _|_ can appear in the type of an expression that does not,\n-    /// itself, diverge: for example, fn() -> _|_.)\n-    /// Note that inspecting a type's structure *directly* may expose the fact\n-    /// that there are actually multiple representations for `Error`, so avoid\n-    /// that when err needs to be handled differently.\n-    fn check_expr_with_expectation_and_needs(\n-        &self,\n-        expr: &'tcx hir::Expr,\n-        expected: Expectation<'tcx>,\n-        needs: Needs,\n-    ) -> Ty<'tcx> {\n-        debug!(\">> type-checking: expr={:?} expected={:?}\",\n-               expr, expected);\n-\n-        // Warn for expressions after diverging siblings.\n-        self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\");\n-\n-        // Hide the outer diverging and has_errors flags.\n-        let old_diverges = self.diverges.get();\n-        let old_has_errors = self.has_errors.get();\n-        self.diverges.set(Diverges::Maybe);\n-        self.has_errors.set(false);\n-\n-        let ty = self.check_expr_kind(expr, expected, needs);\n-\n-        // Warn for non-block expressions with diverging children.\n-        match expr.node {\n-            ExprKind::Block(..) |\n-            ExprKind::Loop(..) | ExprKind::While(..) |\n-            ExprKind::Match(..) => {}\n-\n-            _ => self.warn_if_unreachable(expr.hir_id, expr.span, \"expression\")\n-        }\n-\n-        // Any expression that produces a value of type `!` must have diverged\n-        if ty.is_never() {\n-            self.diverges.set(self.diverges.get() | Diverges::Always);\n-        }\n-\n-        // Record the type, which applies it effects.\n-        // We need to do this after the warning above, so that\n-        // we don't warn for the diverging expression itself.\n-        self.write_ty(expr.hir_id, ty);\n-\n-        // Combine the diverging and has_error flags.\n-        self.diverges.set(self.diverges.get() | old_diverges);\n-        self.has_errors.set(self.has_errors.get() | old_has_errors);\n-\n-        debug!(\"type of {} is...\", self.tcx.hir().hir_to_string(expr.hir_id));\n-        debug!(\"... {:?}, expected is {:?}\", ty, expected);\n-\n-        ty\n-    }\n-\n-    fn check_expr_kind(\n-        &self,\n-        expr: &'tcx hir::Expr,\n-        expected: Expectation<'tcx>,\n-        needs: Needs,\n-    ) -> Ty<'tcx> {\n-        debug!(\n-            \"check_expr_kind(expr={:?}, expected={:?}, needs={:?})\",\n-            expr,\n-            expected,\n-            needs,\n-        );\n-\n-        let tcx = self.tcx;\n-        let id = expr.hir_id;\n-        match expr.node {\n-            ExprKind::Box(ref subexpr) => {\n-                let expected_inner = expected.to_option(self).map_or(NoExpectation, |ty| {\n-                    match ty.sty {\n-                        ty::Adt(def, _) if def.is_box()\n-                            => Expectation::rvalue_hint(self, ty.boxed_ty()),\n-                        _ => NoExpectation\n-                    }\n-                });\n-                let referent_ty = self.check_expr_with_expectation(subexpr, expected_inner);\n-                tcx.mk_box(referent_ty)\n-            }\n-\n-            ExprKind::Lit(ref lit) => {\n-                self.check_lit(&lit, expected)\n-            }\n-            ExprKind::Binary(op, ref lhs, ref rhs) => {\n-                self.check_binop(expr, op, lhs, rhs)\n-            }\n-            ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n-                self.check_binop_assign(expr, op, lhs, rhs)\n-            }\n-            ExprKind::Unary(unop, ref oprnd) => {\n-                let expected_inner = match unop {\n-                    hir::UnNot | hir::UnNeg => {\n-                        expected\n-                    }\n-                    hir::UnDeref => {\n-                        NoExpectation\n-                    }\n-                };\n-                let needs = match unop {\n-                    hir::UnDeref => needs,\n-                    _ => Needs::None\n-                };\n-                let mut oprnd_t = self.check_expr_with_expectation_and_needs(&oprnd,\n-                                                                             expected_inner,\n-                                                                             needs);\n-\n-                if !oprnd_t.references_error() {\n-                    oprnd_t = self.structurally_resolved_type(expr.span, oprnd_t);\n-                    match unop {\n-                        hir::UnDeref => {\n-                            if let Some(mt) = oprnd_t.builtin_deref(true) {\n-                                oprnd_t = mt.ty;\n-                            } else if let Some(ok) = self.try_overloaded_deref(\n-                                    expr.span, oprnd_t, needs) {\n-                                let method = self.register_infer_ok_obligations(ok);\n-                                if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].sty {\n-                                    let mutbl = match mutbl {\n-                                        hir::MutImmutable => AutoBorrowMutability::Immutable,\n-                                        hir::MutMutable => AutoBorrowMutability::Mutable {\n-                                            // (It shouldn't actually matter for unary ops whether\n-                                            // we enable two-phase borrows or not, since a unary\n-                                            // op has no additional operands.)\n-                                            allow_two_phase_borrow: AllowTwoPhase::No,\n-                                        }\n-                                    };\n-                                    self.apply_adjustments(oprnd, vec![Adjustment {\n-                                        kind: Adjust::Borrow(AutoBorrow::Ref(region, mutbl)),\n-                                        target: method.sig.inputs()[0]\n-                                    }]);\n-                                }\n-                                oprnd_t = self.make_overloaded_place_return_type(method).ty;\n-                                self.write_method_call(expr.hir_id, method);\n-                            } else {\n-                                let mut err = type_error_struct!(\n-                                    tcx.sess,\n-                                    expr.span,\n-                                    oprnd_t,\n-                                    E0614,\n-                                    \"type `{}` cannot be dereferenced\",\n-                                    oprnd_t,\n-                                );\n-                                let sp = tcx.sess.source_map().start_point(expr.span);\n-                                if let Some(sp) = tcx.sess.parse_sess.ambiguous_block_expr_parse\n-                                    .borrow().get(&sp)\n-                                {\n-                                    tcx.sess.parse_sess.expr_parentheses_needed(\n-                                        &mut err,\n-                                        *sp,\n-                                        None,\n-                                    );\n-                                }\n-                                err.emit();\n-                                oprnd_t = tcx.types.err;\n-                            }\n-                        }\n-                        hir::UnNot => {\n-                            let result = self.check_user_unop(expr, oprnd_t, unop);\n-                            // If it's builtin, we can reuse the type, this helps inference.\n-                            if !(oprnd_t.is_integral() || oprnd_t.sty == ty::Bool) {\n-                                oprnd_t = result;\n-                            }\n-                        }\n-                        hir::UnNeg => {\n-                            let result = self.check_user_unop(expr, oprnd_t, unop);\n-                            // If it's builtin, we can reuse the type, this helps inference.\n-                            if !oprnd_t.is_numeric() {\n-                                oprnd_t = result;\n-                            }\n-                        }\n-                    }\n-                }\n-                oprnd_t\n-            }\n-            ExprKind::AddrOf(mutbl, ref oprnd) => {\n-                let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n-                    match ty.sty {\n-                        ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n-                            if oprnd.is_place_expr() {\n-                                // Places may legitimately have unsized types.\n-                                // For example, dereferences of a fat pointer and\n-                                // the last field of a struct can be unsized.\n-                                ExpectHasType(ty)\n-                            } else {\n-                                Expectation::rvalue_hint(self, ty)\n-                            }\n-                        }\n-                        _ => NoExpectation\n-                    }\n-                });\n-                let needs = Needs::maybe_mut_place(mutbl);\n-                let ty = self.check_expr_with_expectation_and_needs(&oprnd, hint, needs);\n-\n-                let tm = ty::TypeAndMut { ty: ty, mutbl: mutbl };\n-                if tm.ty.references_error() {\n-                    tcx.types.err\n-                } else {\n-                    // Note: at this point, we cannot say what the best lifetime\n-                    // is to use for resulting pointer.  We want to use the\n-                    // shortest lifetime possible so as to avoid spurious borrowck\n-                    // errors.  Moreover, the longest lifetime will depend on the\n-                    // precise details of the value whose address is being taken\n-                    // (and how long it is valid), which we don't know yet until type\n-                    // inference is complete.\n-                    //\n-                    // Therefore, here we simply generate a region variable.  The\n-                    // region inferencer will then select the ultimate value.\n-                    // Finally, borrowck is charged with guaranteeing that the\n-                    // value whose address was taken can actually be made to live\n-                    // as long as it needs to live.\n-                    let region = self.next_region_var(infer::AddrOfRegion(expr.span));\n-                    tcx.mk_ref(region, tm)\n-                }\n-            }\n-            ExprKind::Path(ref qpath) => {\n-                let (res, opt_ty, segs) = self.resolve_ty_and_res_ufcs(qpath, expr.hir_id,\n-                    expr.span);\n-                let ty = match res {\n-                    Res::Err => {\n-                        self.set_tainted_by_errors();\n-                        tcx.types.err\n-                    }\n-                    Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _) => {\n-                        report_unexpected_variant_res(tcx, res, expr.span, qpath);\n-                        tcx.types.err\n-                    }\n-                    _ => self.instantiate_value_path(segs, opt_ty, res, expr.span, id).0,\n-                };\n-\n-                if let ty::FnDef(..) = ty.sty {\n-                    let fn_sig = ty.fn_sig(tcx);\n-                    if !tcx.features().unsized_locals {\n-                        // We want to remove some Sized bounds from std functions,\n-                        // but don't want to expose the removal to stable Rust.\n-                        // i.e., we don't want to allow\n-                        //\n-                        // ```rust\n-                        // drop as fn(str);\n-                        // ```\n-                        //\n-                        // to work in stable even if the Sized bound on `drop` is relaxed.\n-                        for i in 0..fn_sig.inputs().skip_binder().len() {\n-                            // We just want to check sizedness, so instead of introducing\n-                            // placeholder lifetimes with probing, we just replace higher lifetimes\n-                            // with fresh vars.\n-                            let input = self.replace_bound_vars_with_fresh_vars(\n-                                expr.span,\n-                                infer::LateBoundRegionConversionTime::FnCall,\n-                                &fn_sig.input(i)).0;\n-                            self.require_type_is_sized_deferred(input, expr.span,\n-                                                                traits::SizedArgumentType);\n-                        }\n-                    }\n-                    // Here we want to prevent struct constructors from returning unsized types.\n-                    // There were two cases this happened: fn pointer coercion in stable\n-                    // and usual function call in presense of unsized_locals.\n-                    // Also, as we just want to check sizedness, instead of introducing\n-                    // placeholder lifetimes with probing, we just replace higher lifetimes\n-                    // with fresh vars.\n-                    let output = self.replace_bound_vars_with_fresh_vars(\n-                        expr.span,\n-                        infer::LateBoundRegionConversionTime::FnCall,\n-                        &fn_sig.output()).0;\n-                    self.require_type_is_sized_deferred(output, expr.span, traits::SizedReturnType);\n-                }\n-\n-                // We always require that the type provided as the value for\n-                // a type parameter outlives the moment of instantiation.\n-                let substs = self.tables.borrow().node_substs(expr.hir_id);\n-                self.add_wf_bounds(substs, expr);\n-\n-                ty\n-            }\n-            ExprKind::InlineAsm(_, ref outputs, ref inputs) => {\n-                for expr in outputs.iter().chain(inputs.iter()) {\n-                    self.check_expr(expr);\n-                }\n-                tcx.mk_unit()\n-            }\n-            ExprKind::Break(destination, ref expr_opt) => {\n-                if let Ok(target_id) = destination.target_id {\n-                    let (e_ty, cause);\n-                    if let Some(ref e) = *expr_opt {\n-                        // If this is a break with a value, we need to type-check\n-                        // the expression. Get an expected type from the loop context.\n-                        let opt_coerce_to = {\n-                            let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-                            enclosing_breakables.find_breakable(target_id)\n-                                                .coerce\n-                                                .as_ref()\n-                                                .map(|coerce| coerce.expected_ty())\n-                        };\n-\n-                        // If the loop context is not a `loop { }`, then break with\n-                        // a value is illegal, and `opt_coerce_to` will be `None`.\n-                        // Just set expectation to error in that case.\n-                        let coerce_to = opt_coerce_to.unwrap_or(tcx.types.err);\n-\n-                        // Recurse without `enclosing_breakables` borrowed.\n-                        e_ty = self.check_expr_with_hint(e, coerce_to);\n-                        cause = self.misc(e.span);\n-                    } else {\n-                        // Otherwise, this is a break *without* a value. That's\n-                        // always legal, and is equivalent to `break ()`.\n-                        e_ty = tcx.mk_unit();\n-                        cause = self.misc(expr.span);\n-                    }\n-\n-                    // Now that we have type-checked `expr_opt`, borrow\n-                    // the `enclosing_loops` field and let's coerce the\n-                    // type of `expr_opt` into what is expected.\n-                    let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-                    let ctxt = enclosing_breakables.find_breakable(target_id);\n-                    if let Some(ref mut coerce) = ctxt.coerce {\n-                        if let Some(ref e) = *expr_opt {\n-                            coerce.coerce(self, &cause, e, e_ty);\n-                        } else {\n-                            assert!(e_ty.is_unit());\n-                            coerce.coerce_forced_unit(self, &cause, &mut |_| (), true);\n-                        }\n-                    } else {\n-                        // If `ctxt.coerce` is `None`, we can just ignore\n-                        // the type of the expresison.  This is because\n-                        // either this was a break *without* a value, in\n-                        // which case it is always a legal type (`()`), or\n-                        // else an error would have been flagged by the\n-                        // `loops` pass for using break with an expression\n-                        // where you are not supposed to.\n-                        assert!(expr_opt.is_none() || self.tcx.sess.err_count() > 0);\n-                    }\n-\n-                    ctxt.may_break = true;\n-\n-                    // the type of a `break` is always `!`, since it diverges\n-                    tcx.types.never\n-                } else {\n-                    // Otherwise, we failed to find the enclosing loop;\n-                    // this can only happen if the `break` was not\n-                    // inside a loop at all, which is caught by the\n-                    // loop-checking pass.\n-                    if self.tcx.sess.err_count() == 0 {\n-                        self.tcx.sess.delay_span_bug(expr.span,\n-                            \"break was outside loop, but no error was emitted\");\n-                    }\n-\n-                    // We still need to assign a type to the inner expression to\n-                    // prevent the ICE in #43162.\n-                    if let Some(ref e) = *expr_opt {\n-                        self.check_expr_with_hint(e, tcx.types.err);\n-\n-                        // ... except when we try to 'break rust;'.\n-                        // ICE this expression in particular (see #43162).\n-                        if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.node {\n-                            if path.segments.len() == 1 &&\n-                               path.segments[0].ident.name == sym::rust {\n-                                fatally_break_rust(self.tcx.sess);\n-                            }\n-                        }\n-                    }\n-                    // There was an error; make type-check fail.\n-                    tcx.types.err\n-                }\n-\n-            }\n-            ExprKind::Continue(destination) => {\n-                if destination.target_id.is_ok() {\n-                    tcx.types.never\n-                } else {\n-                    // There was an error; make type-check fail.\n-                    tcx.types.err\n-                }\n-            }\n-            ExprKind::Ret(ref expr_opt) => {\n-                if self.ret_coercion.is_none() {\n-                    struct_span_err!(self.tcx.sess, expr.span, E0572,\n-                                     \"return statement outside of function body\").emit();\n-                } else if let Some(ref e) = *expr_opt {\n-                    if self.ret_coercion_span.borrow().is_none() {\n-                        *self.ret_coercion_span.borrow_mut() = Some(e.span);\n-                    }\n-                    self.check_return_expr(e);\n-                } else {\n-                    let mut coercion = self.ret_coercion.as_ref().unwrap().borrow_mut();\n-                    if self.ret_coercion_span.borrow().is_none() {\n-                        *self.ret_coercion_span.borrow_mut() = Some(expr.span);\n-                    }\n-                    let cause = self.cause(expr.span, ObligationCauseCode::ReturnNoExpression);\n-                    if let Some((fn_decl, _)) = self.get_fn_decl(expr.hir_id) {\n-                        coercion.coerce_forced_unit(\n-                            self,\n-                            &cause,\n-                            &mut |db| {\n-                                db.span_label(\n-                                    fn_decl.output.span(),\n-                                    format!(\n-                                        \"expected `{}` because of this return type\",\n-                                        fn_decl.output,\n-                                    ),\n-                                );\n-                            },\n-                            true,\n-                        );\n-                    } else {\n-                        coercion.coerce_forced_unit(self, &cause, &mut |_| (), true);\n-                    }\n-                }\n-                tcx.types.never\n-            }\n-            ExprKind::Assign(ref lhs, ref rhs) => {\n-                self.check_assign(expr, expected, lhs, rhs)\n-            }\n-            ExprKind::While(ref cond, ref body, _) => {\n-                let ctxt = BreakableCtxt {\n-                    // cannot use break with a value from a while loop\n-                    coerce: None,\n-                    may_break: false,  // Will get updated if/when we find a `break`.\n-                };\n-\n-                let (ctxt, ()) = self.with_breakable_ctxt(expr.hir_id, ctxt, || {\n-                    self.check_expr_has_type_or_error(&cond, tcx.types.bool);\n-                    let cond_diverging = self.diverges.get();\n-                    self.check_block_no_value(&body);\n-\n-                    // We may never reach the body so it diverging means nothing.\n-                    self.diverges.set(cond_diverging);\n-                });\n-\n-                if ctxt.may_break {\n-                    // No way to know whether it's diverging because\n-                    // of a `break` or an outer `break` or `return`.\n-                    self.diverges.set(Diverges::Maybe);\n-                }\n-\n-                self.tcx.mk_unit()\n-            }\n-            ExprKind::Loop(ref body, _, source) => {\n-                let coerce = match source {\n-                    // you can only use break with a value from a normal `loop { }`\n-                    hir::LoopSource::Loop => {\n-                        let coerce_to = expected.coercion_target_type(self, body.span);\n-                        Some(CoerceMany::new(coerce_to))\n-                    }\n-\n-                    hir::LoopSource::WhileLet |\n-                    hir::LoopSource::ForLoop => {\n-                        None\n-                    }\n-                };\n-\n-                let ctxt = BreakableCtxt {\n-                    coerce,\n-                    may_break: false, // Will get updated if/when we find a `break`.\n-                };\n-\n-                let (ctxt, ()) = self.with_breakable_ctxt(expr.hir_id, ctxt, || {\n-                    self.check_block_no_value(&body);\n-                });\n-\n-                if ctxt.may_break {\n-                    // No way to know whether it's diverging because\n-                    // of a `break` or an outer `break` or `return`.\n-                    self.diverges.set(Diverges::Maybe);\n-                }\n-\n-                // If we permit break with a value, then result type is\n-                // the LUB of the breaks (possibly ! if none); else, it\n-                // is nil. This makes sense because infinite loops\n-                // (which would have type !) are only possible iff we\n-                // permit break with a value [1].\n-                if ctxt.coerce.is_none() && !ctxt.may_break {\n-                    // [1]\n-                    self.tcx.sess.delay_span_bug(body.span, \"no coercion, but loop may not break\");\n-                }\n-                ctxt.coerce.map(|c| c.complete(self)).unwrap_or_else(|| self.tcx.mk_unit())\n-            }\n-            ExprKind::Match(ref discrim, ref arms, match_src) => {\n-                self.check_match(expr, &discrim, arms, expected, match_src)\n-            }\n-            ExprKind::Closure(capture, ref decl, body_id, _, gen) => {\n-                self.check_expr_closure(expr, capture, &decl, body_id, gen, expected)\n-            }\n-            ExprKind::Block(ref body, _) => {\n-                self.check_block_with_expected(&body, expected)\n-            }\n-            ExprKind::Call(ref callee, ref args) => {\n-                self.check_call(expr, &callee, args, expected)\n-            }\n-            ExprKind::MethodCall(ref segment, span, ref args) => {\n-                self.check_method_call(expr, segment, span, args, expected, needs)\n-            }\n-            ExprKind::Cast(ref e, ref t) => {\n-                // Find the type of `e`. Supply hints based on the type we are casting to,\n-                // if appropriate.\n-                let t_cast = self.to_ty_saving_user_provided_ty(t);\n-                let t_cast = self.resolve_vars_if_possible(&t_cast);\n-                let t_expr = self.check_expr_with_expectation(e, ExpectCastableToType(t_cast));\n-                let t_cast = self.resolve_vars_if_possible(&t_cast);\n-\n-                // Eagerly check for some obvious errors.\n-                if t_expr.references_error() || t_cast.references_error() {\n-                    tcx.types.err\n-                } else {\n-                    // Defer other checks until we're done type checking.\n-                    let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n-                    match cast::CastCheck::new(self, e, t_expr, t_cast, t.span, expr.span) {\n-                        Ok(cast_check) => {\n-                            deferred_cast_checks.push(cast_check);\n-                            t_cast\n-                        }\n-                        Err(ErrorReported) => {\n-                            tcx.types.err\n-                        }\n-                    }\n-                }\n-            }\n-            ExprKind::Type(ref e, ref t) => {\n-                let ty = self.to_ty_saving_user_provided_ty(&t);\n-                self.check_expr_eq_type(&e, ty);\n-                ty\n-            }\n-            ExprKind::DropTemps(ref e) => {\n-                self.check_expr_with_expectation(e, expected)\n-            }\n-            ExprKind::Array(ref args) => {\n-                let uty = expected.to_option(self).and_then(|uty| {\n-                    match uty.sty {\n-                        ty::Array(ty, _) | ty::Slice(ty) => Some(ty),\n-                        _ => None\n-                    }\n-                });\n-\n-                let element_ty = if !args.is_empty() {\n-                    let coerce_to = uty.unwrap_or_else(|| {\n-                        self.next_ty_var(TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::TypeInference,\n-                            span: expr.span,\n-                        })\n-                    });\n-                    let mut coerce = CoerceMany::with_coercion_sites(coerce_to, args);\n-                    assert_eq!(self.diverges.get(), Diverges::Maybe);\n-                    for e in args {\n-                        let e_ty = self.check_expr_with_hint(e, coerce_to);\n-                        let cause = self.misc(e.span);\n-                        coerce.coerce(self, &cause, e, e_ty);\n-                    }\n-                    coerce.complete(self)\n-                } else {\n-                    self.next_ty_var(TypeVariableOrigin {\n-                        kind: TypeVariableOriginKind::TypeInference,\n-                        span: expr.span,\n-                    })\n-                };\n-                tcx.mk_array(element_ty, args.len() as u64)\n-            }\n-            ExprKind::Repeat(ref element, ref count) => {\n-                let count_def_id = tcx.hir().local_def_id_from_hir_id(count.hir_id);\n-                let count = if self.const_param_def_id(count).is_some() {\n-                    Ok(self.to_const(count, self.tcx.type_of(count_def_id)))\n-                } else {\n-                    let param_env = ty::ParamEnv::empty();\n-                    let substs = InternalSubsts::identity_for_item(tcx.global_tcx(), count_def_id);\n-                    let instance = ty::Instance::resolve(\n-                        tcx.global_tcx(),\n-                        param_env,\n-                        count_def_id,\n-                        substs,\n-                    ).unwrap();\n-                    let global_id = GlobalId {\n-                        instance,\n-                        promoted: None\n-                    };\n-\n-                    tcx.const_eval(param_env.and(global_id))\n-                };\n-\n-                let uty = match expected {\n-                    ExpectHasType(uty) => {\n-                        match uty.sty {\n-                            ty::Array(ty, _) | ty::Slice(ty) => Some(ty),\n-                            _ => None\n-                        }\n-                    }\n-                    _ => None\n-                };\n-\n-                let (element_ty, t) = match uty {\n-                    Some(uty) => {\n-                        self.check_expr_coercable_to_type(&element, uty);\n-                        (uty, uty)\n-                    }\n-                    None => {\n-                        let ty = self.next_ty_var(TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::MiscVariable,\n-                            span: element.span,\n-                        });\n-                        let element_ty = self.check_expr_has_type_or_error(&element, ty);\n-                        (element_ty, ty)\n-                    }\n-                };\n-\n-                if let Ok(count) = count {\n-                    let zero_or_one = count.assert_usize(tcx).map_or(false, |count| count <= 1);\n-                    if !zero_or_one {\n-                        // For [foo, ..n] where n > 1, `foo` must have\n-                        // Copy type:\n-                        let lang_item = self.tcx.require_lang_item(lang_items::CopyTraitLangItem);\n-                        self.require_type_meets(t, expr.span, traits::RepeatVec, lang_item);\n-                    }\n-                }\n-\n-                if element_ty.references_error() {\n-                    tcx.types.err\n-                } else if let Ok(count) = count {\n-                    tcx.mk_ty(ty::Array(t, count))\n-                } else {\n-                    tcx.types.err\n-                }\n-            }\n-            ExprKind::Tup(ref elts) => {\n-                let flds = expected.only_has_type(self).and_then(|ty| {\n-                    let ty = self.resolve_type_vars_with_obligations(ty);\n-                    match ty.sty {\n-                        ty::Tuple(ref flds) => Some(&flds[..]),\n-                        _ => None\n-                    }\n-                });\n-\n-                let elt_ts_iter = elts.iter().enumerate().map(|(i, e)| {\n-                    let t = match flds {\n-                        Some(ref fs) if i < fs.len() => {\n-                            let ety = fs[i].expect_ty();\n-                            self.check_expr_coercable_to_type(&e, ety);\n-                            ety\n-                        }\n-                        _ => {\n-                            self.check_expr_with_expectation(&e, NoExpectation)\n-                        }\n-                    };\n-                    t\n-                });\n-                let tuple = tcx.mk_tup(elt_ts_iter);\n-                if tuple.references_error() {\n-                    tcx.types.err\n-                } else {\n-                    self.require_type_is_sized(tuple, expr.span, traits::TupleInitializerSized);\n-                    tuple\n-                }\n-            }\n-            ExprKind::Struct(ref qpath, ref fields, ref base_expr) => {\n-                self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n-            }\n-            ExprKind::Field(ref base, field) => {\n-                self.check_field(expr, needs, &base, field)\n-            }\n-            ExprKind::Index(ref base, ref idx) => {\n-                let base_t = self.check_expr_with_needs(&base, needs);\n-                let idx_t = self.check_expr(&idx);\n-\n-                if base_t.references_error() {\n-                    base_t\n-                } else if idx_t.references_error() {\n-                    idx_t\n-                } else {\n-                    let base_t = self.structurally_resolved_type(base.span, base_t);\n-                    match self.lookup_indexing(expr, base, base_t, idx_t, needs) {\n-                        Some((index_ty, element_ty)) => {\n-                            // two-phase not needed because index_ty is never mutable\n-                            self.demand_coerce(idx, idx_t, index_ty, AllowTwoPhase::No);\n-                            element_ty\n-                        }\n-                        None => {\n-                            let mut err =\n-                                type_error_struct!(tcx.sess, expr.span, base_t, E0608,\n-                                                   \"cannot index into a value of type `{}`\",\n-                                                   base_t);\n-                            // Try to give some advice about indexing tuples.\n-                            if let ty::Tuple(..) = base_t.sty {\n-                                let mut needs_note = true;\n-                                // If the index is an integer, we can show the actual\n-                                // fixed expression:\n-                                if let ExprKind::Lit(ref lit) = idx.node {\n-                                    if let ast::LitKind::Int(i,\n-                                            ast::LitIntType::Unsuffixed) = lit.node {\n-                                        let snip = tcx.sess.source_map().span_to_snippet(base.span);\n-                                        if let Ok(snip) = snip {\n-                                            err.span_suggestion(\n-                                                expr.span,\n-                                                \"to access tuple elements, use\",\n-                                                format!(\"{}.{}\", snip, i),\n-                                                Applicability::MachineApplicable,\n-                                            );\n-                                            needs_note = false;\n-                                        }\n-                                    }\n-                                }\n-                                if needs_note {\n-                                    err.help(\"to access tuple elements, use tuple indexing \\\n-                                              syntax (e.g., `tuple.0`)\");\n-                                }\n-                            }\n-                            err.emit();\n-                            self.tcx.types.err\n-                        }\n-                    }\n-                }\n-            }\n-            ExprKind::Yield(ref value) => {\n-                match self.yield_ty {\n-                    Some(ty) => {\n-                        self.check_expr_coercable_to_type(&value, ty);\n-                    }\n-                    None => {\n-                        struct_span_err!(self.tcx.sess, expr.span, E0627,\n-                                         \"yield statement outside of generator literal\").emit();\n-                    }\n-                }\n-                tcx.mk_unit()\n-            }\n-            hir::ExprKind::Err => {\n-                tcx.types.err\n-            }\n-        }\n-    }\n-\n-    /// Type check assignment expression `expr` of form `lhs = rhs`.\n-    /// The expected type is `()` and is passsed to the function for the purposes of diagnostics.\n-    fn check_assign(\n-        &self,\n-        expr: &'tcx hir::Expr,\n-        expected: Expectation<'tcx>,\n-        lhs: &'tcx hir::Expr,\n-        rhs: &'tcx hir::Expr,\n-    ) -> Ty<'tcx> {\n-        let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n-        let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n-\n-        let expected_ty = expected.coercion_target_type(self, expr.span);\n-        if expected_ty == self.tcx.types.bool {\n-            // The expected type is `bool` but this will result in `()` so we can reasonably\n-            // say that the user intended to write `lhs == rhs` instead of `lhs = rhs`.\n-            // The likely cause of this is `if foo = bar { .. }`.\n-            let actual_ty = self.tcx.mk_unit();\n-            let mut err = self.demand_suptype_diag(expr.span, expected_ty, actual_ty).unwrap();\n-            let msg = \"try comparing for equality\";\n-            let left = self.tcx.sess.source_map().span_to_snippet(lhs.span);\n-            let right = self.tcx.sess.source_map().span_to_snippet(rhs.span);\n-            if let (Ok(left), Ok(right)) = (left, right) {\n-                let help = format!(\"{} == {}\", left, right);\n-                err.span_suggestion(expr.span, msg, help, Applicability::MaybeIncorrect);\n-            } else {\n-                err.help(msg);\n-            }\n-            err.emit();\n-        } else if !lhs.is_place_expr() {\n-            struct_span_err!(self.tcx.sess, expr.span, E0070,\n-                                \"invalid left-hand side expression\")\n-                .span_label(expr.span, \"left-hand of expression not valid\")\n-                .emit();\n-        }\n-\n-        self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);\n-\n-        if lhs_ty.references_error() || rhs_ty.references_error() {\n-            self.tcx.types.err\n-        } else {\n-            self.tcx.mk_unit()\n-        }\n-    }\n-\n     // Finish resolving a path in a struct expression or pattern `S::A { .. }` if necessary.\n     // The newly resolved definition is written into `type_dependent_defs`.\n     fn finish_resolving_struct_path(&self,"}, {"sha": "cc6f7a07d9621c841099ca8045a359097be8bb47", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b01a257da1fbb3f5661029dd390fdccc49dff287/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b01a257da1fbb3f5661029dd390fdccc49dff287/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=b01a257da1fbb3f5661029dd390fdccc49dff287", "patch": "@@ -68,6 +68,7 @@ This API is completely unstable and subject to change.\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]\n #![feature(never_type)]\n+#![feature(inner_deref)]\n \n #![recursion_limit=\"256\"]\n "}]}