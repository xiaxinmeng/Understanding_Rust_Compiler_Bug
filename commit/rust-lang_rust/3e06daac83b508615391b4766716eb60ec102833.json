{"sha": "3e06daac83b508615391b4766716eb60ec102833", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlMDZkYWFjODNiNTA4NjE1MzkxYjQ3NjY3MTZlYjYwZWMxMDI4MzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-03T17:33:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-03T17:33:10Z"}, "message": "Auto merge of #28521 - arielb1:metadiet, r=eddyb\n\nlibcore.rlib reduced from 19121 kiB to 15934 kiB - 20% win.\r\n\r\nThe librustc encoded AST is 9013500 bytes long - for the record, librustc consists of about 2254126 characters. Might be worth looking at.\r\n\r\nr? @eddyb", "tree": {"sha": "6f928d841422540417fced4e2c4038c115ee74f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f928d841422540417fced4e2c4038c115ee74f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e06daac83b508615391b4766716eb60ec102833", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e06daac83b508615391b4766716eb60ec102833", "html_url": "https://github.com/rust-lang/rust/commit/3e06daac83b508615391b4766716eb60ec102833", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e06daac83b508615391b4766716eb60ec102833/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0369304feb732f0bc89e19e9f09cb3ec9d94fe9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0369304feb732f0bc89e19e9f09cb3ec9d94fe9a", "html_url": "https://github.com/rust-lang/rust/commit/0369304feb732f0bc89e19e9f09cb3ec9d94fe9a"}, {"sha": "eae41d3078562aef1cd4fc8a26f859c168ca4c4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/eae41d3078562aef1cd4fc8a26f859c168ca4c4a", "html_url": "https://github.com/rust-lang/rust/commit/eae41d3078562aef1cd4fc8a26f859c168ca4c4a"}], "stats": {"total": 1020, "additions": 473, "deletions": 547}, "files": [{"sha": "4f7bbe9e0272563ea2d0b17aaa0bc4f9a6b5f47b", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 45, "deletions": 30, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=3e06daac83b508615391b4766716eb60ec102833", "patch": "@@ -467,37 +467,44 @@ pub mod reader {\n         f(&d.data[d.start..d.end])\n     }\n \n-\n     pub fn doc_as_u8(d: Doc) -> u8 {\n         assert_eq!(d.end, d.start + 1);\n         d.data[d.start]\n     }\n \n-    pub fn doc_as_u16(d: Doc) -> u16 {\n-        assert_eq!(d.end, d.start + 2);\n-        let mut b = [0; 2];\n-        bytes::copy_memory(&d.data[d.start..d.end], &mut b);\n-        unsafe { (*(b.as_ptr() as *const u16)).to_be() }\n-    }\n-\n-    pub fn doc_as_u32(d: Doc) -> u32 {\n-        assert_eq!(d.end, d.start + 4);\n-        let mut b = [0; 4];\n-        bytes::copy_memory(&d.data[d.start..d.end], &mut b);\n-        unsafe { (*(b.as_ptr() as *const u32)).to_be() }\n-    }\n-\n     pub fn doc_as_u64(d: Doc) -> u64 {\n-        assert_eq!(d.end, d.start + 8);\n-        let mut b = [0; 8];\n-        bytes::copy_memory(&d.data[d.start..d.end], &mut b);\n-        unsafe { (*(b.as_ptr() as *const u64)).to_be() }\n+        if d.end >= 8 {\n+            // For performance, we read 8 big-endian bytes,\n+            // and mask off the junk if there is any. This\n+            // obviously won't work on the first 8 bytes\n+            // of a file - we will fall of the start\n+            // of the page and segfault.\n+\n+            let mut b = [0; 8];\n+            bytes::copy_memory(&d.data[d.end-8..d.end], &mut b);\n+            let data = unsafe { (*(b.as_ptr() as *const u64)).to_be() };\n+            let len = d.end - d.start;\n+            if len < 8 {\n+                data & ((1<<(len*8))-1)\n+            } else {\n+                data\n+            }\n+        } else {\n+            let mut result = 0;\n+            for b in &d.data[d.start..d.end] {\n+                result = (result<<8) + (*b as u64);\n+            }\n+            result\n+        }\n     }\n \n-    pub fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n-    pub fn doc_as_i16(d: Doc) -> i16 { doc_as_u16(d) as i16 }\n-    pub fn doc_as_i32(d: Doc) -> i32 { doc_as_u32(d) as i32 }\n-    pub fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n+    #[inline] pub fn doc_as_u16(d: Doc) -> u16 { doc_as_u64(d) as u16 }\n+    #[inline] pub fn doc_as_u32(d: Doc) -> u32 { doc_as_u64(d) as u32 }\n+\n+    #[inline] pub fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n+    #[inline] pub fn doc_as_i16(d: Doc) -> i16 { doc_as_u16(d) as i16 }\n+    #[inline] pub fn doc_as_i32(d: Doc) -> i32 { doc_as_u32(d) as i32 }\n+    #[inline] pub fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n \n     pub struct Decoder<'a> {\n         parent: Doc<'a>,\n@@ -907,7 +914,7 @@ pub mod writer {\n         }\n     }\n \n-    fn write_vuint<W: Write>(w: &mut W, n: usize) -> EncodeResult {\n+    pub fn write_vuint<W: Write>(w: &mut W, n: usize) -> EncodeResult {\n         if n < 0x7f { return write_sized_vuint(w, n, 1); }\n         if n < 0x4000 { return write_sized_vuint(w, n, 2); }\n         if n < 0x200000 { return write_sized_vuint(w, n, 3); }\n@@ -996,35 +1003,43 @@ pub mod writer {\n \n         pub fn wr_tagged_u64(&mut self, tag_id: usize, v: u64) -> EncodeResult {\n             let bytes: [u8; 8] = unsafe { mem::transmute(v.to_be()) };\n-            self.wr_tagged_bytes(tag_id, &bytes)\n+            // tagged integers are emitted in big-endian, with no\n+            // leading zeros.\n+            let leading_zero_bytes = v.leading_zeros()/8;\n+            self.wr_tagged_bytes(tag_id, &bytes[leading_zero_bytes as usize..])\n         }\n \n-        pub fn wr_tagged_u32(&mut self, tag_id: usize, v: u32)  -> EncodeResult{\n-            let bytes: [u8; 4] = unsafe { mem::transmute(v.to_be()) };\n-            self.wr_tagged_bytes(tag_id, &bytes)\n+        #[inline]\n+        pub fn wr_tagged_u32(&mut self, tag_id: usize, v: u32)  -> EncodeResult {\n+            self.wr_tagged_u64(tag_id, v as u64)\n         }\n \n+        #[inline]\n         pub fn wr_tagged_u16(&mut self, tag_id: usize, v: u16) -> EncodeResult {\n-            let bytes: [u8; 2] = unsafe { mem::transmute(v.to_be()) };\n-            self.wr_tagged_bytes(tag_id, &bytes)\n+            self.wr_tagged_u64(tag_id, v as u64)\n         }\n \n+        #[inline]\n         pub fn wr_tagged_u8(&mut self, tag_id: usize, v: u8) -> EncodeResult {\n             self.wr_tagged_bytes(tag_id, &[v])\n         }\n \n+        #[inline]\n         pub fn wr_tagged_i64(&mut self, tag_id: usize, v: i64) -> EncodeResult {\n             self.wr_tagged_u64(tag_id, v as u64)\n         }\n \n+        #[inline]\n         pub fn wr_tagged_i32(&mut self, tag_id: usize, v: i32) -> EncodeResult {\n             self.wr_tagged_u32(tag_id, v as u32)\n         }\n \n+        #[inline]\n         pub fn wr_tagged_i16(&mut self, tag_id: usize, v: i16) -> EncodeResult {\n             self.wr_tagged_u16(tag_id, v as u16)\n         }\n \n+        #[inline]\n         pub fn wr_tagged_i8(&mut self, tag_id: usize, v: i8) -> EncodeResult {\n             self.wr_tagged_bytes(tag_id, &[v as u8])\n         }"}, {"sha": "a4fee5b7aa805f063835a603459fed7b8dd9b3fe", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 20, "deletions": 41, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=3e06daac83b508615391b4766716eb60ec102833", "patch": "@@ -44,14 +44,14 @@ pub const tag_items_data_parent_item: usize = 0x28;\n pub const tag_items_data_item_is_tuple_struct_ctor: usize = 0x29;\n \n pub const tag_items_closure_kind: usize = 0x2a;\n-\n pub const tag_items_closure_ty: usize = 0x2b;\n+pub const tag_def_key: usize = 0x2c;\n \n-pub const tag_index: usize = 0x2c;\n-\n-pub const tag_def_key: usize = 0x2d;\n+// GAP 0x2d 0x2e\n \n-// GAP 0x2e\n+pub const tag_index: usize = 0x110; // top-level only\n+pub const tag_xref_index: usize = 0x111; // top-level only\n+pub const tag_xref_data: usize = 0x112; // top-level only\n \n pub const tag_meta_item_name_value: usize = 0x2f;\n \n@@ -80,8 +80,6 @@ pub const tag_crate_dep_crate_name: usize = 0x36;\n pub const tag_crate_dep_hash: usize = 0x37;\n pub const tag_crate_dep_explicitly_linked: usize = 0x38; // top-level only\n \n-pub const tag_mod_impl: usize = 0x39;\n-\n pub const tag_item_trait_item: usize = 0x3a;\n \n pub const tag_item_trait_ref: usize = 0x3b;\n@@ -95,7 +93,6 @@ pub const tag_path_len: usize = 0x3e;\n pub const tag_path_elem_mod: usize = 0x3f;\n pub const tag_path_elem_name: usize = 0x40;\n pub const tag_item_field: usize = 0x41;\n-pub const tag_item_field_origin: usize = 0x42;\n \n pub const tag_item_variances: usize = 0x43;\n /*\n@@ -125,39 +122,27 @@ enum_from_u32! {\n \n         tag_tree = 0x51,\n \n-        tag_id_range = 0x52,\n-\n+        // GAP 0x52\n         tag_table = 0x53,\n         // GAP 0x54, 0x55\n         tag_table_def = 0x56,\n         tag_table_node_type = 0x57,\n         tag_table_item_subst = 0x58,\n         tag_table_freevars = 0x59,\n-        tag_table_tcache = 0x5a,\n-        tag_table_param_defs = 0x5b,\n-        tag_table_mutbl = 0x5c,\n-        tag_table_last_use = 0x5d,\n-        tag_table_spill = 0x5e,\n+        // GAP 0x5a, 0x5b, 0x5c, 0x5d, 0x5e\n         tag_table_method_map = 0x5f,\n-        tag_table_vtable_map = 0x60,\n+        // GAP 0x60\n         tag_table_adjustments = 0x61,\n-        tag_table_moves_map = 0x62,\n-        tag_table_capture_map = 0x63,\n-            // GAP 0x64, 0x65\n+        // GAP 0x62, 0x63, 0x64, 0x65\n         tag_table_upvar_capture_map = 0x66,\n-        tag_table_capture_modes = 0x67,\n-        // GAP 0x68\n+        // GAP 0x67, 0x68\n         tag_table_const_qualif = 0x69,\n         tag_table_cast_kinds = 0x6a,\n     }\n }\n \n pub const tag_item_trait_item_sort: usize = 0x70;\n \n-pub const tag_item_trait_parent_sort: usize = 0x71;\n-\n-pub const tag_item_impl_type_basename: usize = 0x72;\n-\n pub const tag_crate_triple: usize = 0x105; // top-level only\n \n pub const tag_dylib_dependency_formats: usize = 0x106; // top-level only\n@@ -177,23 +162,17 @@ pub const tag_lang_items_missing: usize = 0x76;\n \n pub const tag_item_unnamed_field: usize = 0x77;\n pub const tag_items_data_item_visibility: usize = 0x78;\n-\n-pub const tag_item_method_tps: usize = 0x79;\n-pub const tag_item_method_fty: usize = 0x7a;\n-\n+pub const tag_items_data_item_inherent_impl: usize = 0x79;\n+// GAP 0x7a\n pub const tag_mod_child: usize = 0x7b;\n pub const tag_misc_info: usize = 0x108; // top-level only\n pub const tag_misc_info_crate_items: usize = 0x7c;\n \n-// GAP 0x7d\n-pub const tag_item_impl_vtables: usize = 0x7e;\n-\n pub const tag_impls: usize = 0x109; // top-level only\n-pub const tag_impls_impl: usize = 0x7f;\n-pub const tag_impls_impl_trait_def_id: usize = 0x8d;\n+pub const tag_impls_trait: usize = 0x7d;\n+pub const tag_impls_trait_impl: usize = 0x7e;\n \n-pub const tag_items_data_item_inherent_impl: usize = 0x80;\n-pub const tag_items_data_item_extension_impl: usize = 0x81;\n+// GAP 0x7f, 0x80, 0x81\n \n pub const tag_native_libraries: usize = 0x10a; // top-level only\n pub const tag_native_libraries_lib: usize = 0x82;\n@@ -220,10 +199,10 @@ pub struct LinkMeta {\n \n pub const tag_struct_fields: usize = 0x10d; // top-level only\n pub const tag_struct_field: usize = 0x8a;\n-// GAP 0x8b\n \n+pub const tag_items_data_item_struct_ctor: usize = 0x8b;\n pub const tag_attribute_is_sugared_doc: usize = 0x8c;\n-\n+// GAP 0x8d\n pub const tag_items_data_region: usize = 0x8e;\n \n pub const tag_region_param_def: usize = 0x8f;\n@@ -237,9 +216,9 @@ pub const tag_type_param_def: usize = 0x94;\n pub const tag_item_generics: usize = 0x95;\n pub const tag_method_ty_generics: usize = 0x96;\n \n-pub const tag_predicate: usize = 0x97;\n-pub const tag_predicate_space: usize = 0x98;\n-pub const tag_predicate_data: usize = 0x99;\n+pub const tag_type_predicate: usize = 0x97;\n+pub const tag_self_predicate: usize = 0x98;\n+pub const tag_fn_predicate: usize = 0x99;\n \n pub const tag_unsafety: usize = 0x9a;\n "}, {"sha": "6c81562f7b2912e892111c98954d6526ba75c9be", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=3e06daac83b508615391b4766716eb60ec102833", "patch": "@@ -327,6 +327,7 @@ impl<'a> CrateReader<'a> {\n             local_path: RefCell::new(SmallVector::zero()),\n             local_def_path: RefCell::new(vec![]),\n             index: decoder::load_index(metadata.as_slice()),\n+            xref_index: decoder::load_xrefs(metadata.as_slice()),\n             data: metadata,\n             cnum_map: RefCell::new(cnum_map),\n             cnum: cnum,"}, {"sha": "e04df51dc6862dce539c49b2510fa798a1ecc74f", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=3e06daac83b508615391b4766716eb60ec102833", "patch": "@@ -171,12 +171,6 @@ pub fn get_associated_consts<'tcx>(tcx: &ty::ctxt<'tcx>, def: DefId)\n     decoder::get_associated_consts(cstore.intr.clone(), &*cdata, def.index, tcx)\n }\n \n-pub fn get_type_name_if_impl(cstore: &cstore::CStore, def: DefId)\n-                          -> Option<ast::Name> {\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_type_name_if_impl(&*cdata, def.index)\n-}\n-\n pub fn get_methods_if_impl(cstore: &cstore::CStore,\n                                   def: DefId)\n                                -> Option<Vec<MethodInfo> > {"}, {"sha": "c0e7667666c096fbd5ddfc825b30ac1b6e5396f9", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=3e06daac83b508615391b4766716eb60ec102833", "patch": "@@ -66,7 +66,9 @@ pub struct crate_metadata {\n     pub codemap_import_info: RefCell<Vec<ImportedFileMap>>,\n     pub span: codemap::Span,\n     pub staged_api: bool,\n+\n     pub index: index::Index,\n+    pub xref_index: index::DenseIndex,\n \n     /// Flag if this crate is required by an rlib version of this crate, or in\n     /// other words whether it was explicitly linked to. An example of a crate"}, {"sha": "f51fb068219c917e3f294891f11f1bb1949c5cd0", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 65, "deletions": 53, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=3e06daac83b508615391b4766716eb60ec102833", "patch": "@@ -83,6 +83,11 @@ pub fn crate_rustc_version(data: &[u8]) -> Option<String> {\n     reader::maybe_get_doc(doc, tag_rustc_version).map(|s| s.as_str())\n }\n \n+pub fn load_xrefs(data: &[u8]) -> index::DenseIndex {\n+    let index = reader::get_doc(rbml::Doc::new(data), tag_xref_index);\n+    index::DenseIndex::from_buf(index.data, index.start, index.end)\n+}\n+\n #[derive(Debug, PartialEq)]\n enum Family {\n     ImmStatic,             // c\n@@ -216,14 +221,6 @@ fn maybe_doc_type<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd) -> Opt\n     })\n }\n \n-fn doc_method_fty<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>,\n-                        cdata: Cmd) -> ty::BareFnTy<'tcx> {\n-    let tp = reader::get_doc(doc, tag_item_method_fty);\n-    TyDecoder::with_doc(tcx, cdata.cnum, tp,\n-                        &mut |did| translate_def_id(cdata, did))\n-        .parse_bare_fn_ty()\n-}\n-\n pub fn item_type<'tcx>(_item_id: DefId, item: rbml::Doc,\n                        tcx: &ty::ctxt<'tcx>, cdata: Cmd) -> Ty<'tcx> {\n     doc_type(item, tcx, cdata)\n@@ -391,6 +388,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n                 did: did,\n                 name: item_name(intr, item),\n                 fields: get_variant_fields(intr, cdata, item, tcx),\n+                ctor_id: did,\n                 disr_val: disr\n             }\n         }).collect()\n@@ -419,23 +417,34 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n                                 cdata: Cmd,\n                                 doc: rbml::Doc,\n                                 did: DefId,\n+                                ctor_id: DefId,\n                                 tcx: &ty::ctxt<'tcx>) -> ty::VariantDefData<'tcx, 'tcx> {\n         ty::VariantDefData {\n             did: did,\n             name: item_name(intr, doc),\n             fields: get_variant_fields(intr, cdata, doc, tcx),\n+            ctor_id: ctor_id,\n             disr_val: 0\n         }\n     }\n \n     let doc = cdata.lookup_item(item_id);\n     let did = DefId { krate: cdata.cnum, index: item_id };\n     let (kind, variants) = match item_family(doc) {\n-        Enum => (ty::AdtKind::Enum,\n-                 get_enum_variants(intr, cdata, doc, tcx)),\n-        Struct => (ty::AdtKind::Struct,\n-                   vec![get_struct_variant(intr, cdata, doc, did, tcx)]),\n-        _ => tcx.sess.bug(\"get_adt_def called on a non-ADT\")\n+        Enum => {\n+            (ty::AdtKind::Enum,\n+             get_enum_variants(intr, cdata, doc, tcx))\n+        }\n+        Struct => {\n+            let ctor_did =\n+                reader::maybe_get_doc(doc, tag_items_data_item_struct_ctor).\n+                map_or(did, |ctor_doc| translated_def_id(cdata, ctor_doc));\n+            (ty::AdtKind::Struct,\n+             vec![get_struct_variant(intr, cdata, doc, did, ctor_did, tcx)])\n+        }\n+        _ => tcx.sess.bug(\n+            &format!(\"get_adt_def called on a non-ADT {:?} - {:?}\",\n+                     item_family(doc), did))\n     };\n \n     let adt = tcx.intern_adt_def(did, kind, variants);\n@@ -758,7 +767,8 @@ pub type DecodeInlinedItem<'a> =\n                         &ty::ctxt<'tcx>,\n                         Vec<hir_map::PathElem>,\n                         hir_map::DefPath,\n-                        rbml::Doc)\n+                        rbml::Doc,\n+                        DefId)\n                         -> Result<&'tcx InlinedItem, (Vec<hir_map::PathElem>,\n                                                       hir_map::DefPath)> + 'a>;\n \n@@ -767,15 +777,16 @@ pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: DefIndex,\n                                 -> csearch::FoundAst<'tcx> {\n     debug!(\"Looking up item: {:?}\", id);\n     let item_doc = cdata.lookup_item(id);\n+    let item_did = item_def_id(item_doc, cdata);\n     let path = item_path(item_doc).split_last().unwrap().1.to_vec();\n     let def_path = def_path(cdata, id);\n-    match decode_inlined_item(cdata, tcx, path, def_path, item_doc) {\n+    match decode_inlined_item(cdata, tcx, path, def_path, item_doc, item_did) {\n         Ok(ii) => csearch::FoundAst::Found(ii),\n         Err((path, def_path)) => {\n             match item_parent_item(cdata, item_doc) {\n                 Some(did) => {\n                     let parent_item = cdata.lookup_item(did.index);\n-                    match decode_inlined_item(cdata, tcx, path, def_path, parent_item) {\n+                    match decode_inlined_item(cdata, tcx, path, def_path, parent_item, did) {\n                         Ok(ii) => csearch::FoundAst::FoundParent(did, ii),\n                         Err(_) => csearch::FoundAst::NotFound\n                     }\n@@ -879,7 +890,13 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n         Some('r') | Some('p') => {\n             let generics = doc_generics(item_doc, tcx, cdata, tag_method_ty_generics);\n             let predicates = doc_predicates(item_doc, tcx, cdata, tag_method_ty_generics);\n-            let fty = doc_method_fty(item_doc, tcx, cdata);\n+            let ity = tcx.lookup_item_type(def_id).ty;\n+            let fty = match ity.sty {\n+                ty::TyBareFn(_, fty) => fty.clone(),\n+                _ => tcx.sess.bug(&format!(\n+                    \"the type {:?} of the method {:?} is not a function?\",\n+                    ity, name))\n+            };\n             let explicit_self = get_explicit_self(item_doc);\n \n             ty::MethodTraitItem(Rc::new(ty::Method::new(name,\n@@ -983,18 +1000,6 @@ pub fn get_associated_consts<'tcx>(intr: Rc<IdentInterner>,\n     }).collect()\n }\n \n-pub fn get_type_name_if_impl(cdata: Cmd,\n-                             node_id: DefIndex) -> Option<ast::Name> {\n-    let item = cdata.lookup_item(node_id);\n-    if item_family(item) != Impl {\n-        return None;\n-    }\n-\n-    reader::tagged_docs(item, tag_item_impl_type_basename).nth(0).map(|doc| {\n-        token::intern(doc.as_str_slice())\n-    })\n-}\n-\n pub fn get_methods_if_impl(intr: Rc<IdentInterner>,\n                                   cdata: Cmd,\n                                   node_id: DefIndex)\n@@ -1279,24 +1284,19 @@ pub fn each_implementation_for_trait<F>(cdata: Cmd,\n                                         mut callback: F) where\n     F: FnMut(DefId),\n {\n-    if cdata.cnum == def_id.krate {\n-        let item_doc = cdata.lookup_item(def_id.index);\n-        for impl_doc in reader::tagged_docs(item_doc, tag_items_data_item_extension_impl) {\n-            callback(item_def_id(impl_doc, cdata));\n-        }\n-        return;\n-    }\n-\n     // Do a reverse lookup beforehand to avoid touching the crate_num\n     // hash map in the loop below.\n     if let Some(crate_local_did) = reverse_translate_def_id(cdata, def_id) {\n         let def_id_u64 = def_to_u64(crate_local_did);\n \n         let impls_doc = reader::get_doc(rbml::Doc::new(cdata.data()), tag_impls);\n-        for impl_doc in reader::tagged_docs(impls_doc, tag_impls_impl) {\n-            let impl_trait = reader::get_doc(impl_doc, tag_impls_impl_trait_def_id);\n-            if reader::doc_as_u64(impl_trait) == def_id_u64 {\n-                callback(item_def_id(impl_doc, cdata));\n+        for trait_doc in reader::tagged_docs(impls_doc, tag_impls_trait) {\n+            let trait_def_id = reader::get_doc(trait_doc, tag_def_id);\n+            if reader::doc_as_u64(trait_def_id) != def_id_u64 {\n+                continue;\n+            }\n+            for impl_doc in reader::tagged_docs(trait_doc, tag_impls_trait_impl) {\n+                callback(translated_def_id(cdata, impl_doc));\n             }\n         }\n     }\n@@ -1484,6 +1484,19 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n     ty::Generics { types: types, regions: regions }\n }\n \n+fn doc_predicate<'tcx>(cdata: Cmd,\n+                       doc: rbml::Doc,\n+                       tcx: &ty::ctxt<'tcx>)\n+                       -> ty::Predicate<'tcx>\n+{\n+    let predicate_pos = cdata.xref_index.lookup(\n+        cdata.data(), reader::doc_as_u32(doc)).unwrap() as usize;\n+    TyDecoder::new(\n+        cdata.data(), cdata.cnum, predicate_pos, tcx,\n+        &mut |did| translate_def_id(cdata, did)\n+    ).parse_predicate()\n+}\n+\n fn doc_predicates<'tcx>(base_doc: rbml::Doc,\n                         tcx: &ty::ctxt<'tcx>,\n                         cdata: Cmd,\n@@ -1493,17 +1506,17 @@ fn doc_predicates<'tcx>(base_doc: rbml::Doc,\n     let doc = reader::get_doc(base_doc, tag);\n \n     let mut predicates = subst::VecPerParamSpace::empty();\n-    for predicate_doc in reader::tagged_docs(doc, tag_predicate) {\n-        let space_doc = reader::get_doc(predicate_doc, tag_predicate_space);\n-        let space = subst::ParamSpace::from_uint(reader::doc_as_u8(space_doc) as usize);\n-\n-        let data_doc = reader::get_doc(predicate_doc, tag_predicate_data);\n-        let data =\n-            TyDecoder::with_doc(tcx, cdata.cnum, data_doc,\n-                                &mut |did| translate_def_id(cdata, did))\n-            .parse_predicate();\n-\n-        predicates.push(space, data);\n+    for predicate_doc in reader::tagged_docs(doc, tag_type_predicate) {\n+        predicates.push(subst::TypeSpace,\n+                        doc_predicate(cdata, predicate_doc, tcx));\n+    }\n+    for predicate_doc in reader::tagged_docs(doc, tag_self_predicate) {\n+        predicates.push(subst::SelfSpace,\n+                        doc_predicate(cdata, predicate_doc, tcx));\n+    }\n+    for predicate_doc in reader::tagged_docs(doc, tag_fn_predicate) {\n+        predicates.push(subst::FnSpace,\n+                        doc_predicate(cdata, predicate_doc, tcx));\n     }\n \n     ty::GenericPredicates { predicates: predicates }\n@@ -1584,4 +1597,3 @@ pub fn def_path(cdata: Cmd, id: DefIndex) -> hir_map::DefPath {\n         def_key(parent_doc)\n     })\n }\n-"}, {"sha": "9d2b1548f29d87c3a4e1dcfec371ae6f05465d70", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 212, "deletions": 215, "changes": 427, "blob_url": "https://github.com/rust-lang/rust/blob/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=3e06daac83b508615391b4766716eb60ec102833", "patch": "@@ -20,12 +20,13 @@ use metadata::cstore;\n use metadata::cstore::LOCAL_CRATE;\n use metadata::decoder;\n use metadata::tyencode;\n-use metadata::index::IndexData;\n+use metadata::index::{self, IndexData};\n use metadata::inline::InlinedItemRef;\n use middle::def;\n use middle::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::dependency_format::Linkage;\n use middle::stability;\n+use middle::subst;\n use middle::ty::{self, Ty};\n use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n \n@@ -82,12 +83,29 @@ impl<'a, 'tcx> EncodeContext<'a,'tcx> {\n     }\n }\n \n-fn encode_name(rbml_w: &mut Encoder, name: Name) {\n-    rbml_w.wr_tagged_str(tag_paths_data_name, &name.as_str());\n+/// \"interned\" entries referenced by id\n+#[derive(PartialEq, Eq, Hash)]\n+pub enum XRef<'tcx> { Predicate(ty::Predicate<'tcx>) }\n+\n+struct CrateIndex<'tcx> {\n+    items: IndexData,\n+    xrefs: FnvHashMap<XRef<'tcx>, u32>, // sequentially-assigned\n+}\n+\n+impl<'tcx> CrateIndex<'tcx> {\n+    fn record(&mut self, id: DefId, rbml_w: &mut Encoder) {\n+        let position = rbml_w.mark_stable_position();\n+        self.items.record(id, position);\n+    }\n+\n+    fn add_xref(&mut self, xref: XRef<'tcx>) -> u32 {\n+        let old_len = self.xrefs.len() as u32;\n+        *self.xrefs.entry(xref).or_insert(old_len)\n+    }\n }\n \n-fn encode_impl_type_basename(rbml_w: &mut Encoder, name: Name) {\n-    rbml_w.wr_tagged_str(tag_item_impl_type_basename, &name.as_str());\n+fn encode_name(rbml_w: &mut Encoder, name: Name) {\n+    rbml_w.wr_tagged_str(tag_paths_data_name, &name.as_str());\n }\n \n fn encode_def_id(rbml_w: &mut Encoder, id: DefId) {\n@@ -155,18 +173,22 @@ fn encode_item_variances(rbml_w: &mut Encoder,\n \n fn encode_bounds_and_type_for_item<'a, 'tcx>(rbml_w: &mut Encoder,\n                                              ecx: &EncodeContext<'a, 'tcx>,\n+                                             index: &mut CrateIndex<'tcx>,\n                                              id: NodeId) {\n     encode_bounds_and_type(rbml_w,\n                            ecx,\n+                           index,\n                            &ecx.tcx.lookup_item_type(ecx.tcx.map.local_def_id(id)),\n                            &ecx.tcx.lookup_predicates(ecx.tcx.map.local_def_id(id)));\n }\n \n fn encode_bounds_and_type<'a, 'tcx>(rbml_w: &mut Encoder,\n                                     ecx: &EncodeContext<'a, 'tcx>,\n+                                    index: &mut CrateIndex<'tcx>,\n                                     scheme: &ty::TypeScheme<'tcx>,\n                                     predicates: &ty::GenericPredicates<'tcx>) {\n-    encode_generics(rbml_w, ecx, &scheme.generics, &predicates, tag_item_generics);\n+    encode_generics(rbml_w, ecx, index,\n+                    &scheme.generics, &predicates, tag_item_generics);\n     encode_type(ecx, rbml_w, scheme.ty);\n }\n \n@@ -240,22 +262,6 @@ fn encode_region(ecx: &EncodeContext,\n     rbml_w.end_tag();\n }\n \n-fn encode_method_fty<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                               rbml_w: &mut Encoder,\n-                               typ: &ty::BareFnTy<'tcx>) {\n-    rbml_w.start_tag(tag_item_method_fty);\n-\n-    let ty_str_ctxt = &tyencode::ctxt {\n-        diag: ecx.diag,\n-        ds: def_to_string,\n-        tcx: ecx.tcx,\n-        abbrevs: &ecx.type_abbrevs\n-    };\n-    tyencode::enc_bare_fn_ty(rbml_w, ty_str_ctxt, typ);\n-\n-    rbml_w.end_tag();\n-}\n-\n fn encode_symbol(ecx: &EncodeContext,\n                  rbml_w: &mut Encoder,\n                  id: NodeId) {\n@@ -282,8 +288,7 @@ fn encode_parent_item(rbml_w: &mut Encoder, id: DefId) {\n }\n \n fn encode_struct_fields(rbml_w: &mut Encoder,\n-                        variant: ty::VariantDef,\n-                        origin: DefId) {\n+                        variant: ty::VariantDef) {\n     for f in &variant.fields {\n         if f.name == special_idents::unnamed_field.name {\n             rbml_w.start_tag(tag_item_unnamed_field);\n@@ -293,16 +298,15 @@ fn encode_struct_fields(rbml_w: &mut Encoder,\n         }\n         encode_struct_field_family(rbml_w, f.vis);\n         encode_def_id(rbml_w, f.did);\n-        rbml_w.wr_tagged_u64(tag_item_field_origin, def_to_u64(origin));\n         rbml_w.end_tag();\n     }\n }\n \n-fn encode_enum_variant_info(ecx: &EncodeContext,\n-                            rbml_w: &mut Encoder,\n-                            id: NodeId,\n-                            vis: hir::Visibility,\n-                            index: &mut IndexData) {\n+fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                                      rbml_w: &mut Encoder,\n+                                      id: NodeId,\n+                                      vis: hir::Visibility,\n+                                      index: &mut CrateIndex<'tcx>) {\n     debug!(\"encode_enum_variant_info(id={})\", id);\n \n     let mut disr_val = 0;\n@@ -337,14 +341,14 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         let stab = stability::lookup(ecx.tcx, vid);\n         encode_stability(rbml_w, stab);\n \n-        encode_struct_fields(rbml_w, variant, vid);\n+        encode_struct_fields(rbml_w, variant);\n \n         let specified_disr_val = variant.disr_val;\n         if specified_disr_val != disr_val {\n             encode_disr_val(ecx, rbml_w, specified_disr_val);\n             disr_val = specified_disr_val;\n         }\n-        encode_bounds_and_type_for_item(rbml_w, ecx, variant_node_id);\n+        encode_bounds_and_type_for_item(rbml_w, ecx, index, variant_node_id);\n \n         ecx.tcx.map.with_path(variant_node_id, |path| encode_path(rbml_w, path));\n         rbml_w.end_tag();\n@@ -440,15 +444,6 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                                  def_to_u64(ecx.tcx.map.local_def_id(auxiliary_node_id)));\n             true\n         });\n-\n-        if let hir::ItemImpl(..) = item.node {\n-            let (name, did) = (item.name, item.id);\n-            debug!(\"(encoding info for module) ... encoding impl {} ({}/{})\",\n-                   name,\n-                   did, ecx.tcx.map.node_to_string(did));\n-\n-            rbml_w.wr_tagged_u64(tag_mod_impl, def_to_u64(ecx.tcx.map.local_def_id(did)));\n-        }\n     }\n \n     encode_path(rbml_w, path.clone());\n@@ -527,23 +522,19 @@ fn encode_item_sort(rbml_w: &mut Encoder, sort: char) {\n     rbml_w.wr_tagged_u8(tag_item_trait_item_sort, sort as u8);\n }\n \n-fn encode_parent_sort(rbml_w: &mut Encoder, sort: char) {\n-    rbml_w.wr_tagged_u8(tag_item_trait_parent_sort, sort as u8);\n-}\n-\n fn encode_field<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                           rbml_w: &mut Encoder,\n                           field: ty::FieldDef<'tcx>,\n-                          global_index: &mut IndexData) {\n+                          index: &mut CrateIndex<'tcx>) {\n     let nm = field.name;\n     let id = ecx.local_id(field.did);\n \n-    global_index.record(field.did, rbml_w);\n+    index.record(field.did, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n     debug!(\"encode_field: encoding {} {}\", nm, id);\n     encode_struct_field_family(rbml_w, field.vis);\n     encode_name(rbml_w, nm);\n-    encode_bounds_and_type_for_item(rbml_w, ecx, id);\n+    encode_bounds_and_type_for_item(rbml_w, ecx, index, id);\n     encode_def_id_and_key(ecx, rbml_w, field.did);\n \n     let stab = stability::lookup(ecx.tcx, field.did);\n@@ -552,20 +543,19 @@ fn encode_field<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     rbml_w.end_tag();\n }\n \n-fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n-                               rbml_w: &mut Encoder,\n-                               name: Name,\n-                               ctor_id: NodeId,\n-                               index: &mut IndexData,\n-                               struct_id: NodeId) {\n+fn encode_info_for_struct_ctor<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                                         rbml_w: &mut Encoder,\n+                                         name: Name,\n+                                         ctor_id: NodeId,\n+                                         index: &mut CrateIndex<'tcx>,\n+                                         struct_id: NodeId) {\n     let ctor_def_id = ecx.tcx.map.local_def_id(ctor_id);\n \n     index.record(ctor_def_id, rbml_w);\n-\n     rbml_w.start_tag(tag_items_data_item);\n     encode_def_id_and_key(ecx, rbml_w, ctor_def_id);\n     encode_family(rbml_w, 'o');\n-    encode_bounds_and_type_for_item(rbml_w, ecx, ctor_id);\n+    encode_bounds_and_type_for_item(rbml_w, ecx, index, ctor_id);\n     encode_name(rbml_w, name);\n     ecx.tcx.map.with_path(ctor_id, |path| encode_path(rbml_w, path));\n     encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(struct_id));\n@@ -587,6 +577,7 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n \n fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n                              ecx: &EncodeContext<'a, 'tcx>,\n+                             index: &mut CrateIndex<'tcx>,\n                              generics: &ty::Generics<'tcx>,\n                              predicates: &ty::GenericPredicates<'tcx>,\n                              tag: usize)\n@@ -631,53 +622,48 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         rbml_w.end_tag();\n     }\n \n-    encode_predicates_in_current_doc(rbml_w, ecx, predicates);\n+    encode_predicates_in_current_doc(rbml_w, ecx, index, predicates);\n \n     rbml_w.end_tag();\n }\n \n fn encode_predicates_in_current_doc<'a,'tcx>(rbml_w: &mut Encoder,\n-                                             ecx: &EncodeContext<'a,'tcx>,\n+                                             _ecx: &EncodeContext<'a,'tcx>,\n+                                             index: &mut CrateIndex<'tcx>,\n                                              predicates: &ty::GenericPredicates<'tcx>)\n {\n-    let ty_str_ctxt = &tyencode::ctxt {\n-        diag: ecx.diag,\n-        ds: def_to_string,\n-        tcx: ecx.tcx,\n-        abbrevs: &ecx.type_abbrevs\n-    };\n-\n     for (space, _, predicate) in predicates.predicates.iter_enumerated() {\n-        rbml_w.start_tag(tag_predicate);\n-\n-        rbml_w.wr_tagged_u8(tag_predicate_space, space as u8);\n-\n-        rbml_w.start_tag(tag_predicate_data);\n-        tyencode::enc_predicate(rbml_w, ty_str_ctxt, predicate);\n-        rbml_w.end_tag();\n+        let tag = match space {\n+            subst::TypeSpace => tag_type_predicate,\n+            subst::SelfSpace => tag_self_predicate,\n+            subst::FnSpace => tag_fn_predicate\n+        };\n \n-        rbml_w.end_tag();\n+        rbml_w.wr_tagged_u32(tag,\n+            index.add_xref(XRef::Predicate(predicate.clone())));\n     }\n }\n \n fn encode_predicates<'a,'tcx>(rbml_w: &mut Encoder,\n                               ecx: &EncodeContext<'a,'tcx>,\n+                              index: &mut CrateIndex<'tcx>,\n                               predicates: &ty::GenericPredicates<'tcx>,\n                               tag: usize)\n {\n     rbml_w.start_tag(tag);\n-    encode_predicates_in_current_doc(rbml_w, ecx, predicates);\n+    encode_predicates_in_current_doc(rbml_w, ecx, index, predicates);\n     rbml_w.end_tag();\n }\n \n fn encode_method_ty_fields<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                      rbml_w: &mut Encoder,\n+                                     index: &mut CrateIndex<'tcx>,\n                                      method_ty: &ty::Method<'tcx>) {\n     encode_def_id_and_key(ecx, rbml_w, method_ty.def_id);\n     encode_name(rbml_w, method_ty.name);\n-    encode_generics(rbml_w, ecx, &method_ty.generics, &method_ty.predicates,\n+    encode_generics(rbml_w, ecx, index,\n+                    &method_ty.generics, &method_ty.predicates,\n                     tag_method_ty_generics);\n-    encode_method_fty(ecx, rbml_w, &method_ty.fty);\n     encode_visibility(rbml_w, method_ty.vis);\n     encode_explicit_self(rbml_w, &method_ty.explicit_self);\n     match method_ty.explicit_self {\n@@ -688,16 +674,18 @@ fn encode_method_ty_fields<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     }\n }\n \n-fn encode_info_for_associated_const(ecx: &EncodeContext,\n-                                    rbml_w: &mut Encoder,\n-                                    associated_const: &ty::AssociatedConst,\n-                                    impl_path: PathElems,\n-                                    parent_id: NodeId,\n-                                    impl_item_opt: Option<&hir::ImplItem>) {\n+fn encode_info_for_associated_const<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                                              rbml_w: &mut Encoder,\n+                                              index: &mut CrateIndex<'tcx>,\n+                                              associated_const: &ty::AssociatedConst,\n+                                              impl_path: PathElems,\n+                                              parent_id: NodeId,\n+                                              impl_item_opt: Option<&hir::ImplItem>) {\n     debug!(\"encode_info_for_associated_const({:?},{:?})\",\n            associated_const.def_id,\n            associated_const.name);\n \n+    index.record(associated_const.def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n \n     encode_def_id_and_key(ecx, rbml_w, associated_const.def_id);\n@@ -708,7 +696,8 @@ fn encode_info_for_associated_const(ecx: &EncodeContext,\n     encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n     encode_item_sort(rbml_w, 'C');\n \n-    encode_bounds_and_type_for_item(rbml_w, ecx, ecx.local_id(associated_const.def_id));\n+    encode_bounds_and_type_for_item(rbml_w, ecx, index,\n+                                    ecx.local_id(associated_const.def_id));\n \n     let stab = stability::lookup(ecx.tcx, associated_const.def_id);\n     encode_stability(rbml_w, stab);\n@@ -729,6 +718,7 @@ fn encode_info_for_associated_const(ecx: &EncodeContext,\n \n fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                     rbml_w: &mut Encoder,\n+                                    index: &mut CrateIndex<'tcx>,\n                                     m: &ty::Method<'tcx>,\n                                     impl_path: PathElems,\n                                     is_default_impl: bool,\n@@ -737,18 +727,18 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n     debug!(\"encode_info_for_method: {:?} {:?}\", m.def_id,\n            m.name);\n+    index.record(m.def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n \n-    encode_method_ty_fields(ecx, rbml_w, m);\n+    encode_method_ty_fields(ecx, rbml_w, index, m);\n     encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n     encode_item_sort(rbml_w, 'r');\n \n     let stab = stability::lookup(ecx.tcx, m.def_id);\n     encode_stability(rbml_w, stab);\n \n-    // The type for methods gets encoded twice, which is unfortunate.\n     let m_node_id = ecx.local_id(m.def_id);\n-    encode_bounds_and_type_for_item(rbml_w, ecx, m_node_id);\n+    encode_bounds_and_type_for_item(rbml_w, ecx, index, m_node_id);\n \n     let elem = ast_map::PathName(m.name);\n     encode_path(rbml_w, impl_path.chain(Some(elem)));\n@@ -779,6 +769,7 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                              rbml_w: &mut Encoder,\n+                                             index: &mut CrateIndex<'tcx>,\n                                              associated_type: &ty::AssociatedType<'tcx>,\n                                              impl_path: PathElems,\n                                              parent_id: NodeId,\n@@ -787,6 +778,7 @@ fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n            associated_type.def_id,\n            associated_type.name);\n \n+    index.record(associated_type.def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n \n     encode_def_id_and_key(ecx, rbml_w, associated_type.def_id);\n@@ -805,7 +797,7 @@ fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     if let Some(ii) = impl_item_opt {\n         encode_attributes(rbml_w, &ii.attrs);\n     } else {\n-        encode_predicates(rbml_w, ecx,\n+        encode_predicates(rbml_w, ecx, index,\n                           &ecx.tcx.lookup_predicates(associated_type.def_id),\n                           tag_item_generics);\n     }\n@@ -873,20 +865,6 @@ fn encode_inherent_implementations(ecx: &EncodeContext,\n     }\n }\n \n-// Encodes the implementations of a trait defined in this crate.\n-fn encode_extension_implementations(ecx: &EncodeContext,\n-                                    rbml_w: &mut Encoder,\n-                                    trait_def_id: DefId) {\n-    assert!(trait_def_id.is_local());\n-    let def = ecx.tcx.lookup_trait_def(trait_def_id);\n-\n-    def.for_each_impl(ecx.tcx, |impl_def_id| {\n-        rbml_w.start_tag(tag_items_data_item_extension_impl);\n-        encode_def_id(rbml_w, impl_def_id);\n-        rbml_w.end_tag();\n-    });\n-}\n-\n fn encode_stability(rbml_w: &mut Encoder, stab_opt: Option<&attr::Stability>) {\n     stab_opt.map(|stab| {\n         rbml_w.start_tag(tag_items_data_item_stability);\n@@ -895,12 +873,40 @@ fn encode_stability(rbml_w: &mut Encoder, stab_opt: Option<&attr::Stability>) {\n     });\n }\n \n-fn encode_info_for_item(ecx: &EncodeContext,\n-                        rbml_w: &mut Encoder,\n-                        item: &hir::Item,\n-                        index: &mut IndexData,\n-                        path: PathElems,\n-                        vis: hir::Visibility) {\n+fn encode_xrefs<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                          rbml_w: &mut Encoder,\n+                          xrefs: FnvHashMap<XRef<'tcx>, u32>)\n+{\n+    let ty_str_ctxt = &tyencode::ctxt {\n+        diag: ecx.diag,\n+        ds: def_to_string,\n+        tcx: ecx.tcx,\n+        abbrevs: &ecx.type_abbrevs\n+    };\n+\n+    let mut xref_positions = vec![0; xrefs.len()];\n+    rbml_w.start_tag(tag_xref_data);\n+    for (xref, id) in xrefs.into_iter() {\n+        xref_positions[id as usize] = rbml_w.mark_stable_position() as u32;\n+        match xref {\n+            XRef::Predicate(p) => {\n+                tyencode::enc_predicate(rbml_w, ty_str_ctxt, &p)\n+            }\n+        }\n+    }\n+    rbml_w.end_tag();\n+\n+    rbml_w.start_tag(tag_xref_index);\n+    index::write_dense_index(xref_positions, rbml_w.writer);\n+    rbml_w.end_tag();\n+}\n+\n+fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                                  rbml_w: &mut Encoder,\n+                                  item: &hir::Item,\n+                                  index: &mut CrateIndex<'tcx>,\n+                                  path: PathElems,\n+                                  vis: hir::Visibility) {\n     let tcx = ecx.tcx;\n \n     debug!(\"encoding info for item at {}\",\n@@ -919,7 +925,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         } else {\n             encode_family(rbml_w, 'c');\n         }\n-        encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n+        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n         encode_symbol(ecx, rbml_w, item.id);\n         encode_name(rbml_w, item.name);\n         encode_path(rbml_w, path);\n@@ -933,7 +939,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'C');\n-        encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n+        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n         encode_name(rbml_w, item.name);\n         encode_path(rbml_w, path);\n         encode_attributes(rbml_w, &item.attrs);\n@@ -948,7 +954,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, FN_FAMILY);\n         let tps_len = generics.ty_params.len();\n-        encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n+        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n         encode_name(rbml_w, item.name);\n         encode_path(rbml_w, path);\n         encode_attributes(rbml_w, &item.attrs);\n@@ -998,7 +1004,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'y');\n-        encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n+        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n         encode_name(rbml_w, item.name);\n         encode_path(rbml_w, path);\n         encode_visibility(rbml_w, vis);\n@@ -1012,7 +1018,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 't');\n         encode_item_variances(rbml_w, ecx, item.id);\n-        encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n+        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n         encode_name(rbml_w, item.name);\n         encode_attributes(rbml_w, &item.attrs);\n         encode_repr_attrs(rbml_w, ecx, &item.attrs);\n@@ -1039,18 +1045,14 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let def = ecx.tcx.lookup_adt_def(def_id);\n         let variant = def.struct_variant();\n \n-        for field in &variant.fields {\n-            encode_field(ecx, rbml_w, field, index);\n-        }\n-\n         /* Index the class*/\n         index.record(def_id, rbml_w);\n \n         /* Now, make an item for the class itself */\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'S');\n-        encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n+        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n \n         encode_item_variances(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.name);\n@@ -1063,22 +1065,29 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n-        encode_struct_fields(rbml_w, variant, def_id);\n+        encode_struct_fields(rbml_w, variant);\n \n         encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n \n         // Encode inherent implementations for this structure.\n         encode_inherent_implementations(ecx, rbml_w, def_id);\n \n+        if let Some(ctor_id) = struct_def.ctor_id {\n+            let ctor_did = ecx.tcx.map.local_def_id(ctor_id);\n+            rbml_w.wr_tagged_u64(tag_items_data_item_struct_ctor,\n+                                 def_to_u64(ctor_did));\n+        }\n+\n         rbml_w.end_tag();\n \n+        for field in &variant.fields {\n+            encode_field(ecx, rbml_w, field, index);\n+        }\n+\n         // If this is a tuple-like struct, encode the type of the constructor.\n-        match struct_def.ctor_id {\n-            Some(ctor_id) => {\n-                encode_info_for_struct_ctor(ecx, rbml_w, item.name,\n-                                            ctor_id, index, item.id);\n-            }\n-            None => {}\n+        if let Some(ctor_id) = struct_def.ctor_id {\n+            encode_info_for_struct_ctor(ecx, rbml_w, item.name,\n+                                        ctor_id, index, item.id);\n         }\n       }\n       hir::ItemDefaultImpl(unsafety, _) => {\n@@ -1093,7 +1102,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n           encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n           rbml_w.end_tag();\n       }\n-      hir::ItemImpl(unsafety, polarity, _, _, ref ty, ref ast_items) => {\n+      hir::ItemImpl(unsafety, polarity, _, _, _, ref ast_items) => {\n         // We need to encode information about the default methods we\n         // have inherited, so we drive this based on the impl structure.\n         let impl_items = tcx.impl_items.borrow();\n@@ -1103,7 +1112,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id_and_key(ecx, rbml_w, def_id);\n         encode_family(rbml_w, 'i');\n-        encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n+        encode_bounds_and_type_for_item(rbml_w, ecx, index, item.id);\n         encode_name(rbml_w, item.name);\n         encode_attributes(rbml_w, &item.attrs);\n         encode_unsafety(rbml_w, unsafety);\n@@ -1118,13 +1127,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             None => {}\n         }\n \n-        match ty.node {\n-            hir::TyPath(None, ref path) if path.segments.len() == 1 => {\n-                let name = path.segments.last().unwrap().identifier.name;\n-                encode_impl_type_basename(rbml_w, name);\n-            }\n-            _ => {}\n-        }\n         for &item_def_id in items {\n             rbml_w.start_tag(tag_item_impl_item);\n             match item_def_id {\n@@ -1162,12 +1164,11 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 None\n             };\n \n-            index.record(trait_item_def_id.def_id(), rbml_w);\n-\n             match tcx.impl_or_trait_item(trait_item_def_id.def_id()) {\n                 ty::ConstTraitItem(ref associated_const) => {\n                     encode_info_for_associated_const(ecx,\n                                                      rbml_w,\n+                                                     index,\n                                                      &*associated_const,\n                                                      path.clone(),\n                                                      item.id,\n@@ -1176,6 +1177,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 ty::MethodTraitItem(ref method_type) => {\n                     encode_info_for_method(ecx,\n                                            rbml_w,\n+                                           index,\n                                            &**method_type,\n                                            path.clone(),\n                                            false,\n@@ -1185,6 +1187,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 ty::TypeTraitItem(ref associated_type) => {\n                     encode_info_for_associated_type(ecx,\n                                                     rbml_w,\n+                                                    index,\n                                                     &**associated_type,\n                                                     path.clone(),\n                                                     item.id,\n@@ -1205,9 +1208,11 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_paren_sugar(rbml_w, trait_def.paren_sugar);\n         encode_defaulted(rbml_w, tcx.trait_has_default_impl(def_id));\n         encode_associated_type_names(rbml_w, &trait_def.associated_type_names);\n-        encode_generics(rbml_w, ecx, &trait_def.generics, &trait_predicates,\n+        encode_generics(rbml_w, ecx, index,\n+                        &trait_def.generics, &trait_predicates,\n                         tag_item_generics);\n-        encode_predicates(rbml_w, ecx, &tcx.lookup_super_predicates(def_id),\n+        encode_predicates(rbml_w, ecx, index,\n+                          &tcx.lookup_super_predicates(def_id),\n                           tag_item_super_predicates);\n         encode_trait_ref(rbml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(rbml_w, item.name);\n@@ -1237,9 +1242,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         }\n         encode_path(rbml_w, path.clone());\n \n-        // Encode the implementations of this trait.\n-        encode_extension_implementations(ecx, rbml_w, def_id);\n-\n         // Encode inherent implementations for this trait.\n         encode_inherent_implementations(ecx, rbml_w, def_id);\n \n@@ -1251,7 +1253,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             assert_eq!(item_def_id.def_id().krate, LOCAL_CRATE);\n \n             index.record(item_def_id.def_id(), rbml_w);\n-\n             rbml_w.start_tag(tag_items_data_item);\n \n             encode_parent_item(rbml_w, def_id);\n@@ -1274,16 +1275,15 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n                     encode_family(rbml_w, 'C');\n \n-                    encode_bounds_and_type_for_item(rbml_w,\n-                                                    ecx,\n+                    encode_bounds_and_type_for_item(rbml_w, ecx, index,\n                                                     ecx.local_id(associated_const.def_id));\n \n                     is_nonstatic_method = false;\n                 }\n                 ty::MethodTraitItem(method_ty) => {\n                     let method_def_id = item_def_id.def_id();\n \n-                    encode_method_ty_fields(ecx, rbml_w, &*method_ty);\n+                    encode_method_ty_fields(ecx, rbml_w, index, &*method_ty);\n \n                     let elem = ast_map::PathName(method_ty.name);\n                     encode_path(rbml_w,\n@@ -1299,7 +1299,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                           METHOD_FAMILY);\n                         }\n                     }\n-                    encode_bounds_and_type_for_item(rbml_w, ecx, ecx.local_id(method_def_id));\n+                    encode_bounds_and_type_for_item(rbml_w, ecx, index,\n+                                                    ecx.local_id(method_def_id));\n \n                     is_nonstatic_method = method_ty.explicit_self !=\n                         ty::StaticExplicitSelfCategory;\n@@ -1323,8 +1324,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 }\n             }\n \n-            encode_parent_sort(rbml_w, 't');\n-\n             let trait_item = &*ms[i];\n             encode_attributes(rbml_w, &trait_item.attrs);\n             match trait_item.node {\n@@ -1344,10 +1343,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     if is_nonstatic_method {\n                         // FIXME: I feel like there is something funny\n                         // going on.\n-                        encode_bounds_and_type_for_item(\n-                            rbml_w,\n-                            ecx,\n-                            ecx.local_id(item_def_id.def_id()));\n+                        encode_bounds_and_type_for_item(rbml_w, ecx, index,\n+                                                        ecx.local_id(item_def_id.def_id()));\n                     }\n \n                     if body.is_some() {\n@@ -1372,23 +1369,22 @@ fn encode_info_for_item(ecx: &EncodeContext,\n     }\n }\n \n-fn encode_info_for_foreign_item(ecx: &EncodeContext,\n-                                rbml_w: &mut Encoder,\n-                                nitem: &hir::ForeignItem,\n-                                index: &mut IndexData,\n-                                path: PathElems,\n-                                abi: abi::Abi) {\n+fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                                          rbml_w: &mut Encoder,\n+                                          nitem: &hir::ForeignItem,\n+                                          index: &mut CrateIndex<'tcx>,\n+                                          path: PathElems,\n+                                          abi: abi::Abi) {\n     let def_id = ecx.tcx.map.local_def_id(nitem.id);\n \n     index.record(def_id, rbml_w);\n-\n     rbml_w.start_tag(tag_items_data_item);\n     encode_def_id_and_key(ecx, rbml_w, def_id);\n     encode_visibility(rbml_w, nitem.vis);\n     match nitem.node {\n       hir::ForeignItemFn(ref fndecl, _) => {\n         encode_family(rbml_w, FN_FAMILY);\n-        encode_bounds_and_type_for_item(rbml_w, ecx, nitem.id);\n+        encode_bounds_and_type_for_item(rbml_w, ecx, index, nitem.id);\n         encode_name(rbml_w, nitem.name);\n         if abi == abi::RustIntrinsic || abi == abi::PlatformIntrinsic {\n             encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(nitem));\n@@ -1405,7 +1401,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         } else {\n             encode_family(rbml_w, 'c');\n         }\n-        encode_bounds_and_type_for_item(rbml_w, ecx, nitem.id);\n+        encode_bounds_and_type_for_item(rbml_w, ecx, index, nitem.id);\n         encode_attributes(rbml_w, &*nitem.attrs);\n         let stab = stability::lookup(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n         encode_stability(rbml_w, stab);\n@@ -1420,7 +1416,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n fn my_visit_expr(expr: &hir::Expr,\n                  rbml_w: &mut Encoder,\n                  ecx: &EncodeContext,\n-                 index: &mut IndexData) {\n+                 index: &mut CrateIndex) {\n     match expr.node {\n         hir::ExprClosure(..) => {\n             let def_id = ecx.tcx.map.local_def_id(expr.id);\n@@ -1446,19 +1442,19 @@ fn my_visit_expr(expr: &hir::Expr,\n     }\n }\n \n-fn my_visit_item(i: &hir::Item,\n-                 rbml_w: &mut Encoder,\n-                 ecx: &EncodeContext,\n-                 index: &mut IndexData) {\n+fn my_visit_item<'a, 'tcx>(i: &hir::Item,\n+                           rbml_w: &mut Encoder,\n+                           ecx: &EncodeContext<'a, 'tcx>,\n+                           index: &mut CrateIndex<'tcx>) {\n     ecx.tcx.map.with_path(i.id, |path| {\n         encode_info_for_item(ecx, rbml_w, i, index, path, i.vis);\n     });\n }\n \n-fn my_visit_foreign_item(ni: &hir::ForeignItem,\n-                         rbml_w: &mut Encoder,\n-                         ecx: &EncodeContext,\n-                         index: &mut IndexData) {\n+fn my_visit_foreign_item<'a, 'tcx>(ni: &hir::ForeignItem,\n+                                   rbml_w: &mut Encoder,\n+                                   ecx: &EncodeContext<'a, 'tcx>,\n+                                   index: &mut CrateIndex<'tcx>) {\n     debug!(\"writing foreign item {}::{}\",\n             ecx.tcx.map.path_to_string(ni.id),\n             ni.name);\n@@ -1474,7 +1470,7 @@ fn my_visit_foreign_item(ni: &hir::ForeignItem,\n struct EncodeVisitor<'a, 'b:'a, 'c:'a, 'tcx:'c> {\n     rbml_w_for_visit_item: &'a mut Encoder<'b>,\n     ecx: &'a EncodeContext<'c,'tcx>,\n-    index: &'a mut IndexData,\n+    index: &'a mut CrateIndex<'tcx>,\n }\n \n impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n@@ -1492,14 +1488,17 @@ impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n     }\n }\n \n-fn encode_info_for_items(ecx: &EncodeContext,\n-                         rbml_w: &mut Encoder,\n-                         krate: &hir::Crate)\n-                         -> IndexData {\n-    let mut index = IndexData::new(ecx.tcx.map.num_local_def_ids());\n-\n+fn encode_info_for_items<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+                                   rbml_w: &mut Encoder,\n+                                   krate: &hir::Crate)\n+                                   -> CrateIndex<'tcx> {\n+    let mut index = CrateIndex {\n+        items: IndexData::new(ecx.tcx.map.num_local_def_ids()),\n+        xrefs: FnvHashMap()\n+    };\n     rbml_w.start_tag(tag_items_data);\n-    index.record_index(CRATE_DEF_INDEX, rbml_w);\n+\n+    index.record(DefId::local(CRATE_DEF_INDEX), rbml_w);\n     encode_info_for_mod(ecx,\n                         rbml_w,\n                         &krate.module,\n@@ -1519,7 +1518,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n     index\n }\n \n-fn encode_index(rbml_w: &mut Encoder, index: IndexData) {\n+fn encode_item_index(rbml_w: &mut Encoder, index: IndexData) {\n     rbml_w.start_tag(tag_index);\n     index.write_index(rbml_w.writer);\n     rbml_w.end_tag();\n@@ -1747,53 +1746,44 @@ fn encode_struct_field_attrs(ecx: &EncodeContext,\n \n \n \n-struct ImplVisitor<'a, 'b:'a, 'c:'a, 'tcx:'b> {\n-    ecx: &'a EncodeContext<'b, 'tcx>,\n-    rbml_w: &'a mut Encoder<'c>,\n+struct ImplVisitor<'a, 'tcx:'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+    impls: FnvHashMap<DefId, Vec<DefId>>\n }\n \n-impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n+impl<'a, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        if let hir::ItemImpl(_, _, _, Some(ref trait_ref), _, _) = item.node {\n-            let def_id = self.ecx.tcx.def_map.borrow().get(&trait_ref.ref_id).unwrap().def_id();\n-\n-            // Load eagerly if this is an implementation of the Drop trait\n-            // or if the trait is not defined in this crate.\n-            if Some(def_id) == self.ecx.tcx.lang_items.drop_trait() ||\n-                    def_id.krate != LOCAL_CRATE {\n-                self.rbml_w.start_tag(tag_impls_impl);\n-                encode_def_id(self.rbml_w, self.ecx.tcx.map.local_def_id(item.id));\n-                self.rbml_w.wr_tagged_u64(tag_impls_impl_trait_def_id, def_to_u64(def_id));\n-                self.rbml_w.end_tag();\n+        if let hir::ItemImpl(..) = item.node {\n+            let impl_id = self.tcx.map.local_def_id(item.id);\n+            if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id) {\n+                self.impls.entry(trait_ref.def_id)\n+                    .or_insert(vec![])\n+                    .push(impl_id);\n             }\n         }\n         visit::walk_item(self, item);\n     }\n }\n \n-/// Encodes implementations that are eagerly loaded.\n-///\n-/// None of this is necessary in theory; we can load all implementations\n-/// lazily. However, in two cases the optimizations to lazily load\n-/// implementations are not yet implemented. These two cases, which require us\n-/// to load implementations eagerly, are:\n-///\n-/// * Destructors (implementations of the Drop trait).\n-///\n-/// * Implementations of traits not defined in this crate.\n+/// Encodes an index, mapping each trait to its (local) implementations.\n fn encode_impls<'a>(ecx: &'a EncodeContext,\n                     krate: &hir::Crate,\n                     rbml_w: &'a mut Encoder) {\n-    rbml_w.start_tag(tag_impls);\n+    let mut visitor = ImplVisitor {\n+        tcx: ecx.tcx,\n+        impls: FnvHashMap()\n+    };\n+    visit::walk_crate(&mut visitor, krate);\n \n-    {\n-        let mut visitor = ImplVisitor {\n-            ecx: ecx,\n-            rbml_w: rbml_w,\n-        };\n-        visit::walk_crate(&mut visitor, krate);\n+    rbml_w.start_tag(tag_impls);\n+    for (trait_, trait_impls) in visitor.impls {\n+        rbml_w.start_tag(tag_impls_trait);\n+        encode_def_id(rbml_w, trait_);\n+        for impl_ in trait_impls {\n+            rbml_w.wr_tagged_u64(tag_impls_trait_impl, def_to_u64(impl_));\n+        }\n+        rbml_w.end_tag();\n     }\n-\n     rbml_w.end_tag();\n }\n \n@@ -1939,6 +1929,7 @@ fn encode_metadata_inner(wr: &mut Cursor<Vec<u8>>,\n         misc_bytes: u64,\n         item_bytes: u64,\n         index_bytes: u64,\n+        xref_bytes: u64,\n         zero_bytes: u64,\n         total_bytes: u64,\n     }\n@@ -1954,6 +1945,7 @@ fn encode_metadata_inner(wr: &mut Cursor<Vec<u8>>,\n         misc_bytes: 0,\n         item_bytes: 0,\n         index_bytes: 0,\n+        xref_bytes: 0,\n         zero_bytes: 0,\n         total_bytes: 0,\n     };\n@@ -2035,14 +2027,18 @@ fn encode_metadata_inner(wr: &mut Cursor<Vec<u8>>,\n     // Encode and index the items.\n     rbml_w.start_tag(tag_items);\n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    let items_index = encode_info_for_items(&ecx, &mut rbml_w, krate);\n+    let index = encode_info_for_items(&ecx, &mut rbml_w, krate);\n     stats.item_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n     rbml_w.end_tag();\n \n     i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n-    encode_index(&mut rbml_w, items_index);\n+    encode_item_index(&mut rbml_w, index.items);\n     stats.index_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n \n+    i = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n+    encode_xrefs(&ecx, &mut rbml_w, index.xrefs);\n+    stats.xref_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap() - i;\n+\n     encode_struct_field_attrs(&ecx, &mut rbml_w, krate);\n \n     stats.total_bytes = rbml_w.writer.seek(SeekFrom::Current(0)).unwrap();\n@@ -2066,19 +2062,20 @@ fn encode_metadata_inner(wr: &mut Cursor<Vec<u8>>,\n         println!(\"            misc bytes: {}\", stats.misc_bytes);\n         println!(\"            item bytes: {}\", stats.item_bytes);\n         println!(\"           index bytes: {}\", stats.index_bytes);\n+        println!(\"            xref bytes: {}\", stats.xref_bytes);\n         println!(\"            zero bytes: {}\", stats.zero_bytes);\n         println!(\"           total bytes: {}\", stats.total_bytes);\n     }\n }\n \n // Get the encoded string for a type\n-pub fn encoded_ty<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> String {\n+pub fn encoded_ty<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> Vec<u8> {\n     let mut wr = Cursor::new(Vec::new());\n     tyencode::enc_ty(&mut Encoder::new(&mut wr), &tyencode::ctxt {\n         diag: tcx.sess.diagnostic(),\n         ds: def_to_string,\n         tcx: tcx,\n         abbrevs: &RefCell::new(FnvHashMap())\n     }, t);\n-    String::from_utf8(wr.into_inner()).unwrap()\n+    wr.into_inner()\n }"}, {"sha": "60bbdaddd751607c7e75c1ffeade30db3d440852", "filename": "src/librustc/metadata/index.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmetadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmetadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Findex.rs?ref=3e06daac83b508615391b4766716eb60ec102833", "patch": "@@ -10,7 +10,6 @@\n \n use middle::def_id::{DefId, DefIndex};\n use rbml;\n-use rbml::writer::Encoder;\n use std::io::{Cursor, Write};\n use std::slice;\n use std::u32;\n@@ -74,16 +73,14 @@ impl IndexData {\n         }\n     }\n \n-    pub fn record(&mut self, def_id: DefId, encoder: &mut Encoder) {\n+    pub fn record(&mut self, def_id: DefId, position: u64) {\n         assert!(def_id.is_local());\n-        self.record_index(def_id.index, encoder)\n+        self.record_index(def_id.index, position)\n     }\n \n-    pub fn record_index(&mut self, item: DefIndex, encoder: &mut Encoder) {\n+    pub fn record_index(&mut self, item: DefIndex, position: u64) {\n         let item = item.as_usize();\n \n-        let position = encoder.mark_stable_position();\n-\n         assert!(position < (u32::MAX as u64));\n         let position = position as u32;\n \n@@ -101,6 +98,38 @@ impl IndexData {\n     }\n }\n \n+/// A dense index with integer keys. Different API from IndexData (should\n+/// these be merged?)\n+pub struct DenseIndex {\n+    start: usize,\n+    end: usize\n+}\n+\n+impl DenseIndex {\n+    pub fn lookup(&self, buf: &[u8], ix: u32) -> Option<u32> {\n+        let data = bytes_to_words(&buf[self.start..self.end]);\n+        data.get(ix as usize).map(|d| u32::from_be(*d))\n+    }\n+    pub fn from_buf(buf: &[u8], start: usize, end: usize) -> Self {\n+        assert!((end-start)%4 == 0 && start <= end && end <= buf.len());\n+        DenseIndex {\n+            start: start,\n+            end: end\n+        }\n+    }\n+}\n+\n+pub fn write_dense_index(entries: Vec<u32>, buf: &mut Cursor<Vec<u8>>) {\n+    let elen = entries.len();\n+    assert!(elen < u32::MAX as usize);\n+\n+    for entry in entries {\n+        write_be_u32(buf, entry);\n+    }\n+\n+    info!(\"write_dense_index: {} entries\", elen);\n+}\n+\n fn write_be_u32<W: Write>(w: &mut W, u: u32) {\n     let _ = w.write_all(&[\n         (u >> 24) as u8,"}, {"sha": "d03af6b672284b2accff9b886315e06aa71ad880", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=3e06daac83b508615391b4766716eb60ec102833", "patch": "@@ -98,6 +98,12 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         return &self.data[start_pos..end_pos];\n     }\n \n+    fn parse_vuint(&mut self) -> usize {\n+        let res = rbml::reader::vuint_at(self.data, self.pos).unwrap();\n+        self.pos = res.next;\n+        res.val\n+    }\n+\n     fn parse_name(&mut self, last: char) -> ast::Name {\n         fn is_last(b: char, c: char) -> bool { return c == b; }\n         let bytes = self.scan(|a| is_last(last, a));\n@@ -373,11 +379,8 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 // we return it (modulo closure types, see below). But if not, then we\n                 // jump to offset 123 and read the type from there.\n \n-                let pos = self.parse_hex();\n-                assert_eq!(self.next(), ':');\n-                let len = self.parse_hex();\n-                assert_eq!(self.next(), '#');\n-                let key = ty::CReaderCacheKey {cnum: self.krate, pos: pos, len: len };\n+                let pos = self.parse_vuint();\n+                let key = ty::CReaderCacheKey { cnum: self.krate, pos: pos };\n                 match tcx.rcache.borrow().get(&key).cloned() {\n                     Some(tt) => {\n                         // If there is a closure buried in the type some where, then we\n@@ -476,19 +479,6 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         subst::ParamSpace::from_uint(self.parse_uint())\n     }\n \n-    fn parse_hex(&mut self) -> usize {\n-        let mut n = 0;\n-        loop {\n-            let cur = self.peek();\n-            if (cur < '0' || cur > '9') && (cur < 'a' || cur > 'f') { return n; }\n-            self.pos = self.pos + 1;\n-            n *= 16;\n-            if '0' <= cur && cur <= '9' {\n-                n += (cur as usize) - ('0' as usize);\n-            } else { n += 10 + (cur as usize) - ('a' as usize); }\n-        };\n-    }\n-\n     fn parse_abi_set(&mut self) -> abi::Abi {\n         assert_eq!(self.next(), '[');\n         let bytes = self.scan(|c| c == ']');"}, {"sha": "1b993a00e28448889342ca4fb373bb3f92dbd812", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=3e06daac83b508615391b4766716eb60ec102833", "patch": "@@ -14,6 +14,7 @@\n #![allow(non_camel_case_types)]\n \n use std::cell::RefCell;\n+use std::io::Cursor;\n use std::io::prelude::*;\n \n use middle::def_id::DefId;\n@@ -30,7 +31,7 @@ use syntax::abi::Abi;\n use syntax::ast;\n use syntax::diagnostic::SpanHandler;\n \n-use rbml::writer::Encoder;\n+use rbml::writer::{self, Encoder};\n \n macro_rules! mywrite { ($w:expr, $($arg:tt)*) => ({ write!($w.writer, $($arg)*); }) }\n \n@@ -47,14 +48,14 @@ pub struct ctxt<'a, 'tcx: 'a> {\n // Extra parameters are for converting to/from def_ids in the string rep.\n // Whatever format you choose should not contain pipe characters.\n pub struct ty_abbrev {\n-    s: String\n+    s: Vec<u8>\n }\n \n pub type abbrev_map<'tcx> = RefCell<FnvHashMap<Ty<'tcx>, ty_abbrev>>;\n \n pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n     match cx.abbrevs.borrow_mut().get(&t) {\n-        Some(a) => { w.writer.write_all(a.s.as_bytes()); return; }\n+        Some(a) => { w.writer.write_all(&a.s); return; }\n         None => {}\n     }\n \n@@ -166,19 +167,22 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n \n     let end = w.mark_stable_position();\n     let len = end - pos;\n-    fn estimate_sz(u: u64) -> u64 {\n-        let mut n = u;\n-        let mut len = 0;\n-        while n != 0 { len += 1; n = n >> 4; }\n-        return len;\n-    }\n-    let abbrev_len = 3 + estimate_sz(pos) + estimate_sz(len);\n-    if abbrev_len < len {\n-        // I.e. it's actually an abbreviation.\n-        cx.abbrevs.borrow_mut().insert(t, ty_abbrev {\n-            s: format!(\"#{:x}:{:x}#\", pos, len)\n-        });\n-    }\n+\n+    let buf: &mut [u8] = &mut [0; 16]; // vuint < 15 bytes\n+    let mut abbrev = Cursor::new(buf);\n+    abbrev.write_all(b\"#\");\n+    writer::write_vuint(&mut abbrev, pos as usize);\n+\n+    cx.abbrevs.borrow_mut().insert(t, ty_abbrev {\n+        s: if abbrev.position() < len {\n+            abbrev.get_ref()[..abbrev.position() as usize].to_owned()\n+        } else {\n+            // if the abbreviation is longer than the real type,\n+            // don't use #-notation. However, insert it here so\n+            // other won't have to `mark_stable_position`\n+            w.writer.get_ref()[pos as usize..end as usize].to_owned()\n+        }\n+    });\n }\n \n fn enc_mutability(w: &mut Encoder, mt: hir::Mutability) {"}, {"sha": "6c23307c67776570279eecaf7d967e81a161f34b", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 47, "deletions": 148, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=3e06daac83b508615391b4766716eb60ec102833", "patch": "@@ -33,7 +33,6 @@ use middle::def_id::DefId;\n use middle::privacy::{AllPublic, LastMod};\n use middle::region;\n use middle::subst;\n-use middle::subst::VecPerParamSpace;\n use middle::ty::{self, Ty};\n \n use syntax::{ast, ast_util, codemap};\n@@ -124,7 +123,8 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n                                  tcx: &ty::ctxt<'tcx>,\n                                  path: Vec<ast_map::PathElem>,\n                                  def_path: ast_map::DefPath,\n-                                 par_doc: rbml::Doc)\n+                                 par_doc: rbml::Doc,\n+                                 orig_did: DefId)\n                                  -> Result<&'tcx InlinedItem, (Vec<ast_map::PathElem>,\n                                                                ast_map::DefPath)> {\n     match par_doc.opt_child(c::tag_ast) {\n@@ -163,6 +163,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n                name);\n         region::resolve_inlined_item(&tcx.sess, &tcx.region_maps, ii);\n         decode_side_tables(dcx, ast_doc);\n+        copy_item_types(dcx, ii, orig_did);\n         match *ii {\n           InlinedItem::Item(ref i) => {\n             debug!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n@@ -554,36 +555,6 @@ pub fn encode_cast_kind(ebml_w: &mut Encoder, kind: cast::CastKind) {\n     kind.encode(ebml_w).unwrap();\n }\n \n-pub trait vtable_decoder_helpers<'tcx> {\n-    fn read_vec_per_param_space<T, F>(&mut self, f: F) -> VecPerParamSpace<T> where\n-        F: FnMut(&mut Self) -> T;\n-}\n-\n-impl<'tcx, 'a> vtable_decoder_helpers<'tcx> for reader::Decoder<'a> {\n-    fn read_vec_per_param_space<T, F>(&mut self, mut f: F) -> VecPerParamSpace<T> where\n-        F: FnMut(&mut reader::Decoder<'a>) -> T,\n-    {\n-        let types = self.read_to_vec(|this| Ok(f(this))).unwrap();\n-        let selfs = self.read_to_vec(|this| Ok(f(this))).unwrap();\n-        let fns = self.read_to_vec(|this| Ok(f(this))).unwrap();\n-        VecPerParamSpace::new(types, selfs, fns)\n-    }\n-}\n-\n-// ___________________________________________________________________________\n-//\n-\n-fn encode_vec_per_param_space<T, F>(rbml_w: &mut Encoder,\n-                                    v: &subst::VecPerParamSpace<T>,\n-                                    mut f: F) where\n-    F: FnMut(&mut Encoder, &T),\n-{\n-    for &space in &subst::ParamSpace::all() {\n-        rbml_w.emit_from_vec(v.get_slice(space),\n-                             |rbml_w, n| Ok(f(rbml_w, n))).unwrap();\n-    }\n-}\n-\n // ______________________________________________________________________\n // Encoding and decoding the side tables\n \n@@ -606,16 +577,10 @@ trait rbml_writer_helpers<'tcx> {\n     fn emit_region(&mut self, ecx: &e::EncodeContext, r: ty::Region);\n     fn emit_ty<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, ty: Ty<'tcx>);\n     fn emit_tys<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, tys: &[Ty<'tcx>]);\n-    fn emit_type_param_def<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                               type_param_def: &ty::TypeParameterDef<'tcx>);\n-    fn emit_region_param_def(&mut self, ecx: &e::EncodeContext,\n-                             region_param_def: &ty::RegionParameterDef);\n     fn emit_predicate<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                           predicate: &ty::Predicate<'tcx>);\n     fn emit_trait_ref<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                           ty: &ty::TraitRef<'tcx>);\n-    fn emit_type_scheme<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n-                            type_scheme: ty::TypeScheme<'tcx>);\n     fn emit_substs<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                        substs: &subst::Substs<'tcx>);\n     fn emit_existential_bounds<'b>(&mut self, ecx: &e::EncodeContext<'b,'tcx>,\n@@ -648,22 +613,6 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         self.emit_opaque(|this| Ok(e::write_trait_ref(ecx, this, trait_ref)));\n     }\n \n-    fn emit_type_param_def<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n-                               type_param_def: &ty::TypeParameterDef<'tcx>) {\n-        self.emit_opaque(|this| {\n-            Ok(tyencode::enc_type_param_def(this,\n-                                         &ecx.ty_str_ctxt(),\n-                                         type_param_def))\n-        });\n-    }\n-    fn emit_region_param_def(&mut self, ecx: &e::EncodeContext,\n-                             region_param_def: &ty::RegionParameterDef) {\n-        self.emit_opaque(|this| {\n-            Ok(tyencode::enc_region_param_def(this,\n-                                              &ecx.ty_str_ctxt(),\n-                                              region_param_def))\n-        });\n-    }\n     fn emit_predicate<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                           predicate: &ty::Predicate<'tcx>) {\n         self.emit_opaque(|this| {\n@@ -673,32 +622,6 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n         });\n     }\n \n-    fn emit_type_scheme<'b>(&mut self,\n-                            ecx: &e::EncodeContext<'b, 'tcx>,\n-                            type_scheme: ty::TypeScheme<'tcx>) {\n-        use serialize::Encoder;\n-\n-        self.emit_struct(\"TypeScheme\", 2, |this| {\n-            this.emit_struct_field(\"generics\", 0, |this| {\n-                this.emit_struct(\"Generics\", 2, |this| {\n-                    this.emit_struct_field(\"types\", 0, |this| {\n-                        Ok(encode_vec_per_param_space(\n-                            this, &type_scheme.generics.types,\n-                            |this, def| this.emit_type_param_def(ecx, def)))\n-                    });\n-                    this.emit_struct_field(\"regions\", 1, |this| {\n-                        Ok(encode_vec_per_param_space(\n-                            this, &type_scheme.generics.regions,\n-                            |this, def| this.emit_region_param_def(ecx, def)))\n-                    })\n-                })\n-            });\n-            this.emit_struct_field(\"ty\", 1, |this| {\n-                Ok(this.emit_ty(ecx, type_scheme.ty))\n-            })\n-        });\n-    }\n-\n     fn emit_existential_bounds<'b>(&mut self, ecx: &e::EncodeContext<'b,'tcx>,\n                                    bounds: &ty::ExistentialBounds<'tcx>) {\n         self.emit_opaque(|this| Ok(tyencode::enc_existential_bounds(this,\n@@ -918,23 +841,6 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         }\n     }\n \n-    let opt_def_id = tcx.map.opt_local_def_id(id);\n-    if let Some(lid) = opt_def_id {\n-        if let Some(type_scheme) = tcx.tcache.borrow().get(&lid) {\n-            rbml_w.tag(c::tag_table_tcache, |rbml_w| {\n-                rbml_w.id(id);\n-                rbml_w.emit_type_scheme(ecx, type_scheme.clone());\n-            })\n-        }\n-    }\n-\n-    if let Some(type_param_def) = tcx.ty_param_defs.borrow().get(&id) {\n-        rbml_w.tag(c::tag_table_param_defs, |rbml_w| {\n-            rbml_w.id(id);\n-            rbml_w.emit_type_param_def(ecx, type_param_def)\n-        })\n-    }\n-\n     let method_call = ty::MethodCall::expr(id);\n     if let Some(method) = tcx.tables.borrow().method_map.get(&method_call) {\n         rbml_w.tag(c::tag_table_method_map, |rbml_w| {\n@@ -1005,14 +911,8 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                               -> ty::TraitRef<'tcx>;\n     fn read_poly_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                    -> ty::PolyTraitRef<'tcx>;\n-    fn read_type_param_def<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                   -> ty::TypeParameterDef<'tcx>;\n-    fn read_region_param_def(&mut self, dcx: &DecodeContext)\n-                             -> ty::RegionParameterDef;\n     fn read_predicate<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                               -> ty::Predicate<'tcx>;\n-    fn read_type_scheme<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n-                                -> ty::TypeScheme<'tcx>;\n     fn read_existential_bounds<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                        -> ty::ExistentialBounds<'tcx>;\n     fn read_substs<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1124,48 +1024,12 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         ty::Binder(self.read_ty_encoded(dcx, |decoder| decoder.parse_trait_ref()))\n     }\n \n-    fn read_type_param_def<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                   -> ty::TypeParameterDef<'tcx> {\n-        self.read_ty_encoded(dcx, |decoder| decoder.parse_type_param_def())\n-    }\n-    fn read_region_param_def(&mut self, dcx: &DecodeContext)\n-                             -> ty::RegionParameterDef {\n-        self.read_ty_encoded(dcx, |decoder| decoder.parse_region_param_def())\n-    }\n     fn read_predicate<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                               -> ty::Predicate<'tcx>\n     {\n         self.read_ty_encoded(dcx, |decoder| decoder.parse_predicate())\n     }\n \n-    fn read_type_scheme<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n-                                -> ty::TypeScheme<'tcx> {\n-        self.read_struct(\"TypeScheme\", 3, |this| {\n-            Ok(ty::TypeScheme {\n-                generics: this.read_struct_field(\"generics\", 0, |this| {\n-                    this.read_struct(\"Generics\", 2, |this| {\n-                        Ok(ty::Generics {\n-                            types:\n-                            this.read_struct_field(\"types\", 0, |this| {\n-                                Ok(this.read_vec_per_param_space(\n-                                    |this| this.read_type_param_def(dcx)))\n-                            }).unwrap(),\n-\n-                            regions:\n-                            this.read_struct_field(\"regions\", 1, |this| {\n-                                Ok(this.read_vec_per_param_space(\n-                                    |this| this.read_region_param_def(dcx)))\n-                            }).unwrap(),\n-                        })\n-                    })\n-                }).unwrap(),\n-                ty: this.read_struct_field(\"ty\", 1, |this| {\n-                    Ok(this.read_ty(dcx))\n-                }).unwrap()\n-            })\n-        }).unwrap()\n-    }\n-\n     fn read_existential_bounds<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                        -> ty::ExistentialBounds<'tcx>\n     {\n@@ -1385,15 +1249,6 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         let ub = val_dsr.read_upvar_capture(dcx);\n                         dcx.tcx.tables.borrow_mut().upvar_capture_map.insert(upvar_id, ub);\n                     }\n-                    c::tag_table_tcache => {\n-                        let type_scheme = val_dsr.read_type_scheme(dcx);\n-                        let lid = dcx.tcx.map.local_def_id(id);\n-                        dcx.tcx.register_item_type(lid, type_scheme);\n-                    }\n-                    c::tag_table_param_defs => {\n-                        let bounds = val_dsr.read_type_param_def(dcx);\n-                        dcx.tcx.ty_param_defs.borrow_mut().insert(id, bounds);\n-                    }\n                     c::tag_table_method_map => {\n                         let (autoderef, method) = val_dsr.read_method_callee(dcx);\n                         let method_call = ty::MethodCall {\n@@ -1429,6 +1284,50 @@ fn decode_side_tables(dcx: &DecodeContext,\n     }\n }\n \n+// copy the tcache entries from the original item to the new\n+// inlined item\n+fn copy_item_types(dcx: &DecodeContext, ii: &InlinedItem, orig_did: DefId) {\n+    fn copy_item_type(dcx: &DecodeContext,\n+                      inlined_id: ast::NodeId,\n+                      remote_did: DefId) {\n+        let inlined_did = dcx.tcx.map.local_def_id(inlined_id);\n+        dcx.tcx.register_item_type(inlined_did,\n+                                   dcx.tcx.lookup_item_type(remote_did));\n+\n+    }\n+    // copy the entry for the item itself\n+    let item_node_id = match ii {\n+        &InlinedItem::Item(ref i) => i.id,\n+        &InlinedItem::TraitItem(_, ref ti) => ti.id,\n+        &InlinedItem::ImplItem(_, ref ii) => ii.id,\n+        &InlinedItem::Foreign(ref fi) => fi.id\n+    };\n+    copy_item_type(dcx, item_node_id, orig_did);\n+\n+    // copy the entries of inner items\n+    if let &InlinedItem::Item(ref item) = ii {\n+        match item.node {\n+            hir::ItemEnum(ref def, _) => {\n+                let orig_def = dcx.tcx.lookup_adt_def(orig_did);\n+                for (i_variant, orig_variant) in\n+                    def.variants.iter().zip(orig_def.variants.iter())\n+                {\n+                    copy_item_type(dcx, i_variant.node.id, orig_variant.did);\n+                }\n+            }\n+            hir::ItemStruct(ref def, _) => {\n+                if let Some(ctor_id) = def.ctor_id {\n+                    let ctor_did = dcx.tcx.lookup_adt_def(orig_did)\n+                        .struct_variant().ctor_id;\n+                    debug!(\"copying ctor {:?}\", ctor_did);\n+                    copy_item_type(dcx, ctor_id, ctor_did);\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n // ______________________________________________________________________\n // Testing of astencode_gen\n "}, {"sha": "e275ac7bc7dc6739536721fc28ec98c5b0d7cb32", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=3e06daac83b508615391b4766716eb60ec102833", "patch": "@@ -143,7 +143,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n         }\n         let mut used_ref_id = false;\n         let expr_id = match csearch::maybe_get_item_ast(tcx, def_id,\n-            Box::new(|a, b, c, d, e| astencode::decode_inlined_item(a, b, c, d, e))) {\n+            Box::new(astencode::decode_inlined_item)) {\n             csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => match item.node {\n                 hir::ItemConst(_, ref const_expr) => Some(const_expr.id),\n                 _ => None\n@@ -199,7 +199,7 @@ fn inline_const_fn_from_external_crate(tcx: &ty::ctxt, def_id: DefId)\n     }\n \n     let fn_id = match csearch::maybe_get_item_ast(tcx, def_id,\n-        box |a, b, c, d, e| astencode::decode_inlined_item(a, b, c, d, e)) {\n+        box astencode::decode_inlined_item) {\n         csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => Some(item.id),\n         csearch::FoundAst::Found(&InlinedItem::ImplItem(_, ref item)) => Some(item.id),\n         _ => None"}, {"sha": "ba4eac9e9eb86410c53aa91bb8d9f02094a1cade", "filename": "src/librustc/middle/def_id.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmiddle%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmiddle%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef_id.rs?ref=3e06daac83b508615391b4766716eb60ec102833", "patch": "@@ -82,5 +82,3 @@ impl DefId {\n         self.krate == LOCAL_CRATE\n     }\n }\n-\n-"}, {"sha": "fddfb7b583eb364559b8362747f93b0b0c89f0e8", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=3e06daac83b508615391b4766716eb60ec102833", "patch": "@@ -367,7 +367,6 @@ pub type MethodMap<'tcx> = FnvHashMap<MethodCall, MethodCallee<'tcx>>;\n pub struct CReaderCacheKey {\n     pub cnum: CrateNum,\n     pub pos: usize,\n-    pub len: usize\n }\n \n /// A restriction that certain types must be the same size. The use of\n@@ -1474,7 +1473,10 @@ pub struct VariantDefData<'tcx, 'container: 'tcx> {\n     pub did: DefId,\n     pub name: Name, // struct's name if this is a struct\n     pub disr_val: Disr,\n-    pub fields: Vec<FieldDefData<'tcx, 'container>>\n+    pub fields: Vec<FieldDefData<'tcx, 'container>>,\n+    /// The DefId of the variant's ctor (unless the variant is a\n+    /// tuple-like struct variant, this is just the variant's def-id).\n+    pub ctor_id: DefId\n }\n \n pub struct FieldDefData<'tcx, 'container: 'tcx> {\n@@ -2820,4 +2822,3 @@ pub trait HasTypeFlags {\n         !self.has_type_flags(TypeFlags::HAS_LOCAL_NAMES)\n     }\n }\n-"}, {"sha": "bae14afd81d66931207654cf121902b4debd5a8c", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=3e06daac83b508615391b4766716eb60ec102833", "patch": "@@ -215,7 +215,7 @@ fn symbol_hash<'tcx>(tcx: &ty::ctxt<'tcx>,\n         symbol_hasher.input_str(&meta[..]);\n     }\n     symbol_hasher.input_str(\"-\");\n-    symbol_hasher.input_str(&encoder::encoded_ty(tcx, t));\n+    symbol_hasher.input(&encoder::encoded_ty(tcx, t));\n     // Prefix with 'h' so that it never blends into adjacent digits\n     let mut hash = String::from(\"h\");\n     hash.push_str(&truncated_hash_result(symbol_hasher));"}, {"sha": "b8f75df8c11caae241d638dbe2bbd0d24a192bc7", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=3e06daac83b508615391b4766716eb60ec102833", "patch": "@@ -44,7 +44,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId)\n     let csearch_result =\n         csearch::maybe_get_item_ast(\n             ccx.tcx(), fn_id,\n-            Box::new(|a,b,c,d,e| astencode::decode_inlined_item(a, b, c, d,e)));\n+            Box::new(astencode::decode_inlined_item));\n \n     let inline_id = match csearch_result {\n         csearch::FoundAst::NotFound => {"}, {"sha": "25a61414ab51429e3ad310b1cb717c54004bb6cf", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e06daac83b508615391b4766716eb60ec102833/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=3e06daac83b508615391b4766716eb60ec102833", "patch": "@@ -1102,7 +1102,8 @@ fn convert_struct_variant<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                 did: DefId,\n                                 name: ast::Name,\n                                 disr_val: ty::Disr,\n-                                def: &hir::StructDef) -> ty::VariantDefData<'tcx, 'tcx> {\n+                                def: &hir::StructDef,\n+                                ctor_id: DefId) -> ty::VariantDefData<'tcx, 'tcx> {\n     let mut seen_fields: FnvHashMap<ast::Name, Span> = FnvHashMap();\n     let fields = def.fields.iter().map(|f| {\n         let fid = tcx.map.local_def_id(f.node.id);\n@@ -1129,7 +1130,8 @@ fn convert_struct_variant<'tcx>(tcx: &ty::ctxt<'tcx>,\n         did: did,\n         name: name,\n         disr_val: disr_val,\n-        fields: fields\n+        fields: fields,\n+        ctor_id: ctor_id\n     }\n }\n \n@@ -1140,10 +1142,12 @@ fn convert_struct_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n {\n \n     let did = tcx.map.local_def_id(it.id);\n+    let ctor_id = def.ctor_id.map_or(did,\n+        |ctor_id| tcx.map.local_def_id(ctor_id));\n     tcx.intern_adt_def(\n         did,\n         ty::AdtKind::Struct,\n-        vec![convert_struct_variant(tcx, did, it.name, 0, def)]\n+        vec![convert_struct_variant(tcx, did, it.name, 0, def, ctor_id)]\n     )\n }\n \n@@ -1233,11 +1237,12 @@ fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n                             special_idents::unnamed_field.name,\n                             hir::Visibility::Public\n                         )\n-                    }).collect()\n+                    }).collect(),\n+                    ctor_id: did\n                 }\n             }\n             hir::StructVariantKind(ref def) => {\n-                convert_struct_variant(tcx, did, name, disr, &def)\n+                convert_struct_variant(tcx, did, name, disr, &def, did)\n             }\n         }\n     }"}]}