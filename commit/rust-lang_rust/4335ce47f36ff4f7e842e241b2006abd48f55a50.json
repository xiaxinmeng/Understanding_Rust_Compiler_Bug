{"sha": "4335ce47f36ff4f7e842e241b2006abd48f55a50", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzMzVjZTQ3ZjM2ZmY0ZjdlODQyZTI0MWIyMDA2YWJkNDhmNTVhNTA=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-06-12T01:58:28Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-06-13T01:10:18Z"}, "message": "Convert most str and vec fns to slices", "tree": {"sha": "0f13e4c6619bea9362fb4ee09c7c392047c4e8ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f13e4c6619bea9362fb4ee09c7c392047c4e8ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4335ce47f36ff4f7e842e241b2006abd48f55a50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4335ce47f36ff4f7e842e241b2006abd48f55a50", "html_url": "https://github.com/rust-lang/rust/commit/4335ce47f36ff4f7e842e241b2006abd48f55a50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4335ce47f36ff4f7e842e241b2006abd48f55a50/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f574cb4ac8ee278095bea740851f1fa435b30188", "url": "https://api.github.com/repos/rust-lang/rust/commits/f574cb4ac8ee278095bea740851f1fa435b30188", "html_url": "https://github.com/rust-lang/rust/commit/f574cb4ac8ee278095bea740851f1fa435b30188"}], "stats": {"total": 223, "additions": 114, "deletions": 109}, "files": [{"sha": "cf81dcd7157fff9a3632f6baea58bd14874d7aaa", "filename": "src/libcore/str.rs", "status": "modified", "additions": 104, "deletions": 99, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/4335ce47f36ff4f7e842e241b2006abd48f55a50/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4335ce47f36ff4f7e842e241b2006abd48f55a50/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=4335ce47f36ff4f7e842e241b2006abd48f55a50", "patch": "@@ -222,7 +222,7 @@ pure fn from_char(ch: char) -> str {\n }\n \n #[doc = \"Convert a vector of chars to a string\"]\n-pure fn from_chars(chs: [char]) -> str {\n+pure fn from_chars(chs: [const char]/&) -> str {\n     let mut buf = \"\";\n     unchecked {\n         reserve(buf, chs.len());\n@@ -232,7 +232,7 @@ pure fn from_chars(chs: [char]) -> str {\n }\n \n #[doc = \"Concatenate a vector of strings\"]\n-pure fn concat(v: [str]) -> str {\n+pure fn concat(v: [const str]/&) -> str {\n     let mut s: str = \"\";\n     for vec::each(v) {|ss| s += ss; }\n     ret s;\n@@ -241,7 +241,7 @@ pure fn concat(v: [str]) -> str {\n #[doc = \"\n Concatenate a vector of strings, placing a given separator between each\n \"]\n-pure fn connect(v: [str], sep: str) -> str {\n+pure fn connect(v: [const str]/&a, sep: str) -> str {\n     let mut s = \"\", first = true;\n     for vec::each(v) {|ss|\n         if first { first = false; } else { s += sep; }\n@@ -338,7 +338,7 @@ pure fn byte_slice<T>(s: str/&, f: fn([u8]/&) -> T) -> T unsafe {\n }\n \n #[doc = \"Convert a string to a vector of characters\"]\n-pure fn chars(s: str) -> [char] {\n+pure fn chars(s: str/&) -> [char] {\n     let mut buf = [], i = 0u;\n     let len = len(s);\n     while i < len {\n@@ -355,7 +355,7 @@ Take a substring of another.\n Returns a string containing `n` characters starting at byte offset\n `begin`.\n \"]\n-pure fn substr(s: str, begin: uint, n: uint) -> str {\n+pure fn substr(s: str/&, begin: uint, n: uint) -> str {\n     slice(s, begin, begin + count_bytes(s, begin, n))\n }\n \n@@ -365,7 +365,7 @@ Returns a slice of the given string from the byte range [`begin`..`end`)\n Fails when `begin` and `end` do not point to valid characters or\n beyond the last character of the string\n \"]\n-pure fn slice(s: str, begin: uint, end: uint) -> str unsafe {\n+pure fn slice(s: str/&, begin: uint, end: uint) -> str unsafe {\n     assert is_char_boundary(s, begin);\n     assert is_char_boundary(s, end);\n     unsafe::slice_bytes(s, begin, end)\n@@ -374,7 +374,7 @@ pure fn slice(s: str, begin: uint, end: uint) -> str unsafe {\n #[doc = \"\n Splits a string into substrings at each occurrence of a given character\n \"]\n-pure fn split_char(s: str, sep: char) -> [str] {\n+pure fn split_char(s: str/&, sep: char) -> [str] {\n     split_char_inner(s, sep, len(s), true)\n }\n \n@@ -384,18 +384,18 @@ character up to 'count' times\n \n The byte must be a valid UTF-8/ASCII byte\n \"]\n-pure fn splitn_char(s: str, sep: char, count: uint) -> [str] {\n+pure fn splitn_char(s: str/&, sep: char, count: uint) -> [str] {\n     split_char_inner(s, sep, count, true)\n }\n \n #[doc = \"\n Like `split_char`, but omits empty strings from the returned vector\n \"]\n-pure fn split_char_nonempty(s: str, sep: char) -> [str] {\n+pure fn split_char_nonempty(s: str/&, sep: char) -> [str] {\n     split_char_inner(s, sep, len(s), false)\n }\n \n-pure fn split_char_inner(s: str, sep: char, count: uint, allow_empty: bool)\n+pure fn split_char_inner(s: str/&, sep: char, count: uint, allow_empty: bool)\n     -> [str] unsafe {\n     if sep < 128u as char {\n         let b = sep as u8, l = len(s);\n@@ -422,24 +422,24 @@ pure fn split_char_inner(s: str, sep: char, count: uint, allow_empty: bool)\n \n \n #[doc = \"Splits a string into substrings using a character function\"]\n-pure fn split(s: str, sepfn: fn(char) -> bool) -> [str] {\n+pure fn split(s: str/&, sepfn: fn(char) -> bool) -> [str] {\n     split_inner(s, sepfn, len(s), true)\n }\n \n #[doc = \"\n Splits a string into substrings using a character function, cutting at\n most `count` times.\n \"]\n-pure fn splitn(s: str, sepfn: fn(char) -> bool, count: uint) -> [str] {\n+pure fn splitn(s: str/&, sepfn: fn(char) -> bool, count: uint) -> [str] {\n     split_inner(s, sepfn, count, true)\n }\n \n #[doc = \"Like `split`, but omits empty strings from the returned vector\"]\n-pure fn split_nonempty(s: str, sepfn: fn(char) -> bool) -> [str] {\n+pure fn split_nonempty(s: str/&, sepfn: fn(char) -> bool) -> [str] {\n     split_inner(s, sepfn, len(s), false)\n }\n \n-pure fn split_inner(s: str, sepfn: fn(cc: char) -> bool, count: uint,\n+pure fn split_inner(s: str/&, sepfn: fn(cc: char) -> bool, count: uint,\n                allow_empty: bool) -> [str] unsafe {\n     let l = len(s);\n     let mut result = [], i = 0u, start = 0u, done = 0u;\n@@ -461,7 +461,7 @@ pure fn split_inner(s: str, sepfn: fn(cc: char) -> bool, count: uint,\n }\n \n // See Issue #1932 for why this is a naive search\n-pure fn iter_matches(s: str, sep: str, f: fn(uint, uint)) {\n+pure fn iter_matches(s: str/&a, sep: str/&b, f: fn(uint, uint)) {\n     let sep_len = len(sep), l = len(s);\n     assert sep_len > 0u;\n     let mut i = 0u, match_start = 0u, match_i = 0u;\n@@ -488,7 +488,7 @@ pure fn iter_matches(s: str, sep: str, f: fn(uint, uint)) {\n     }\n }\n \n-pure fn iter_between_matches(s: str, sep: str, f: fn(uint, uint)) {\n+pure fn iter_between_matches(s: str/&a, sep: str/&b, f: fn(uint, uint)) {\n     let mut last_end = 0u;\n     iter_matches(s, sep) {|from, to|\n         f(last_end, from);\n@@ -506,15 +506,15 @@ Splits a string into a vector of the substrings separated by a given string\n assert [\\\"\\\", \\\"XXX\\\", \\\"YYY\\\", \\\"\\\"] == split_str(\\\".XXX.YYY.\\\", \\\".\\\")\n ~~~\n \"]\n-pure fn split_str(s: str, sep: str) -> [str] {\n+pure fn split_str(s: str/&a, sep: str/&b) -> [str] {\n     let mut result = [];\n     iter_between_matches(s, sep) {|from, to|\n         unsafe { result += [unsafe::slice_bytes(s, from, to)]; }\n     }\n     result\n }\n \n-pure fn split_str_nonempty(s: str, sep: str) -> [str] {\n+pure fn split_str_nonempty(s: str/&a, sep: str/&b) -> [str] {\n     let mut result = [];\n     iter_between_matches(s, sep) {|from, to|\n         if to > from {\n@@ -527,13 +527,13 @@ pure fn split_str_nonempty(s: str, sep: str) -> [str] {\n #[doc = \"\n Splits a string into a vector of the substrings separated by LF ('\\\\n')\n \"]\n-pure fn lines(s: str) -> [str] { split_char(s, '\\n') }\n+pure fn lines(s: str/&) -> [str] { split_char(s, '\\n') }\n \n #[doc = \"\n Splits a string into a vector of the substrings separated by LF ('\\\\n')\n and/or CR LF ('\\\\r\\\\n')\n \"]\n-pure fn lines_any(s: str) -> [str] {\n+pure fn lines_any(s: str/&) -> [str] {\n     vec::map(lines(s), {|s|\n         let l = len(s);\n         let mut cp = s;\n@@ -547,19 +547,19 @@ pure fn lines_any(s: str) -> [str] {\n #[doc = \"\n Splits a string into a vector of the substrings separated by whitespace\n \"]\n-pure fn words(s: str) -> [str] {\n+pure fn words(s: str/&) -> [str] {\n     split_nonempty(s, {|c| char::is_whitespace(c)})\n }\n \n #[doc = \"Convert a string to lowercase. ASCII only\"]\n-pure fn to_lower(s: str) -> str {\n+pure fn to_lower(s: str/&) -> str {\n     map(s, {|c|\n         unchecked{(libc::tolower(c as libc::c_char)) as char}\n     })\n }\n \n #[doc = \"Convert a string to uppercase. ASCII only\"]\n-pure fn to_upper(s: str) -> str {\n+pure fn to_upper(s: str/&) -> str {\n     map(s, {|c|\n         unchecked{(libc::toupper(c as libc::c_char)) as char}\n     })\n@@ -629,20 +629,20 @@ Section: Iterating through strings\n Return true if a predicate matches all characters or if the string\n contains no characters\n \"]\n-pure fn all(s: str, it: fn(char) -> bool) -> bool {\n+pure fn all(s: str/&, it: fn(char) -> bool) -> bool {\n     all_between(s, 0u, len(s), it)\n }\n \n #[doc = \"\n Return true if a predicate matches any character (and false if it\n matches none or there are no characters)\n \"]\n-pure fn any(ss: str, pred: fn(char) -> bool) -> bool {\n+pure fn any(ss: str/&, pred: fn(char) -> bool) -> bool {\n     !all(ss, {|cc| !pred(cc)})\n }\n \n #[doc = \"Apply a function to each character\"]\n-pure fn map(ss: str, ff: fn(char) -> char) -> str {\n+pure fn map(ss: str/&, ff: fn(char) -> char) -> str {\n     let mut result = \"\";\n     unchecked {\n         reserve(result, len(ss));\n@@ -654,7 +654,7 @@ pure fn map(ss: str, ff: fn(char) -> char) -> str {\n }\n \n #[doc = \"Iterate over the bytes in a string\"]\n-pure fn bytes_iter(ss: str, it: fn(u8)) {\n+pure fn bytes_iter(ss: str/&, it: fn(u8)) {\n     let mut pos = 0u;\n     let len = len(ss);\n \n@@ -666,7 +666,7 @@ pure fn bytes_iter(ss: str, it: fn(u8)) {\n \n #[doc = \"Iterate over the bytes in a string\"]\n #[inline(always)]\n-pure fn each(s: str, it: fn(u8) -> bool) {\n+pure fn each(s: str/&, it: fn(u8) -> bool) {\n     let mut i = 0u, l = len(s);\n     while (i < l) {\n         if !it(s[i]) { break; }\n@@ -676,7 +676,7 @@ pure fn each(s: str, it: fn(u8) -> bool) {\n \n #[doc = \"Iterates over the chars in a string\"]\n #[inline(always)]\n-pure fn each_char(s: str, it: fn(char) -> bool) {\n+pure fn each_char(s: str/&, it: fn(char) -> bool) {\n     let mut pos = 0u;\n     let len = len(s);\n     while pos < len {\n@@ -687,7 +687,7 @@ pure fn each_char(s: str, it: fn(char) -> bool) {\n }\n \n #[doc = \"Iterate over the characters in a string\"]\n-pure fn chars_iter(s: str, it: fn(char)) {\n+pure fn chars_iter(s: str/&, it: fn(char)) {\n     let mut pos = 0u;\n     let len = len(s);\n     while (pos < len) {\n@@ -700,26 +700,26 @@ pure fn chars_iter(s: str, it: fn(char)) {\n #[doc = \"\n Apply a function to each substring after splitting by character\n \"]\n-pure fn split_char_iter(ss: str, cc: char, ff: fn(&&str)) {\n+pure fn split_char_iter(ss: str/&, cc: char, ff: fn(&&str)) {\n    vec::iter(split_char(ss, cc), ff)\n }\n \n #[doc = \"\n Apply a function to each substring after splitting by character, up to\n `count` times\n \"]\n-pure fn splitn_char_iter(ss: str, sep: char, count: uint,\n+pure fn splitn_char_iter(ss: str/&, sep: char, count: uint,\n                          ff: fn(&&str)) unsafe {\n    vec::iter(splitn_char(ss, sep, count), ff)\n }\n \n #[doc = \"Apply a function to each word\"]\n-pure fn words_iter(ss: str, ff: fn(&&str)) {\n+pure fn words_iter(ss: str/&, ff: fn(&&str)) {\n     vec::iter(words(ss), ff)\n }\n \n #[doc = \"Apply a function to each line (by '\\\\n')\"]\n-pure fn lines_iter(ss: str, ff: fn(&&str)) {\n+pure fn lines_iter(ss: str/&, ff: fn(&&str)) {\n     vec::iter(lines(ss), ff)\n }\n \n@@ -740,7 +740,7 @@ Returns the byte index of the first matching character\n An `option` containing the byte index of the first matching character\n or `none` if there is no match\n \"]\n-pure fn find_char(s: str, c: char) -> option<uint> {\n+pure fn find_char(s: str/&, c: char) -> option<uint> {\n     find_char_between(s, c, 0u, len(s))\n }\n \n@@ -764,7 +764,7 @@ or `none` if there is no match\n `start` must be less than or equal to `len(s)`. `start` must be the\n index of a character boundary, as defined by `is_char_boundary`.\n \"]\n-pure fn find_char_from(s: str, c: char, start: uint) -> option<uint> {\n+pure fn find_char_from(s: str/&, c: char, start: uint) -> option<uint> {\n     find_char_between(s, c, start, len(s))\n }\n \n@@ -789,7 +789,7 @@ or `none` if there is no match\n or equal to `len(s)`. `start` must be the index of a character boundary,\n as defined by `is_char_boundary`.\n \"]\n-pure fn find_char_between(s: str, c: char, start: uint, end: uint)\n+pure fn find_char_between(s: str/&, c: char, start: uint, end: uint)\n     -> option<uint> {\n     if c < 128u as char {\n         assert start <= end;\n@@ -819,7 +819,7 @@ Returns the byte index of the last matching character\n An `option` containing the byte index of the last matching character\n or `none` if there is no match\n \"]\n-pure fn rfind_char(s: str, c: char) -> option<uint> {\n+pure fn rfind_char(s: str/&, c: char) -> option<uint> {\n     rfind_char_between(s, c, len(s), 0u)\n }\n \n@@ -843,7 +843,7 @@ or `none` if there is no match\n `start` must be less than or equal to `len(s)`. `start` must be\n the index of a character boundary, as defined by `is_char_boundary`.\n \"]\n-pure fn rfind_char_from(s: str, c: char, start: uint) -> option<uint> {\n+pure fn rfind_char_from(s: str/&, c: char, start: uint) -> option<uint> {\n     rfind_char_between(s, c, start, 0u)\n }\n \n@@ -868,7 +868,7 @@ or `none` if there is no match\n or equal to `len(s)`. `start` must be the index of a character boundary,\n as defined by `is_char_boundary`.\n \"]\n-pure fn rfind_char_between(s: str, c: char, start: uint, end: uint)\n+pure fn rfind_char_between(s: str/&, c: char, start: uint, end: uint)\n     -> option<uint> {\n     if c < 128u as char {\n         assert start >= end;\n@@ -899,7 +899,7 @@ the given predicate\n An `option` containing the byte index of the first matching character\n or `none` if there is no match\n \"]\n-pure fn find(s: str, f: fn(char) -> bool) -> option<uint> {\n+pure fn find(s: str/&, f: fn(char) -> bool) -> option<uint> {\n     find_between(s, 0u, len(s), f)\n }\n \n@@ -923,7 +923,8 @@ or `none` if there is no match\n `start` must be less than or equal to `len(s)`. `start` must be the\n index of a character boundary, as defined by `is_char_boundary`.\n \"]\n-pure fn find_from(s: str, start: uint, f: fn(char) -> bool) -> option<uint> {\n+pure fn find_from(s: str/&, start: uint, f: fn(char)\n+    -> bool) -> option<uint> {\n     find_between(s, start, len(s), f)\n }\n \n@@ -949,7 +950,7 @@ or `none` if there is no match\n or equal to `len(s)`. `start` must be the index of a character\n boundary, as defined by `is_char_boundary`.\n \"]\n-pure fn find_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n+pure fn find_between(s: str/&, start: uint, end: uint, f: fn(char) -> bool)\n     -> option<uint> {\n     assert start <= end;\n     assert end <= len(s);\n@@ -977,7 +978,7 @@ the given predicate\n An option containing the byte index of the last matching character\n or `none` if there is no match\n \"]\n-pure fn rfind(s: str, f: fn(char) -> bool) -> option<uint> {\n+pure fn rfind(s: str/&, f: fn(char) -> bool) -> option<uint> {\n     rfind_between(s, len(s), 0u, f)\n }\n \n@@ -1001,7 +1002,8 @@ or `none` if there is no match\n `start` must be less than or equal to `len(s)', `start` must be the\n index of a character boundary, as defined by `is_char_boundary`\n \"]\n-pure fn rfind_from(s: str, start: uint, f: fn(char) -> bool) -> option<uint> {\n+pure fn rfind_from(s: str/&, start: uint, f: fn(char) -> bool)\n+    -> option<uint> {\n     rfind_between(s, start, 0u, f)\n }\n \n@@ -1027,7 +1029,7 @@ or `none` if there is no match\n than or equal to `len(s)`. `start` must be the index of a character\n boundary, as defined by `is_char_boundary`\n \"]\n-pure fn rfind_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n+pure fn rfind_between(s: str/&, start: uint, end: uint, f: fn(char) -> bool)\n     -> option<uint> {\n     assert start >= end;\n     assert start <= len(s);\n@@ -1042,7 +1044,7 @@ pure fn rfind_between(s: str, start: uint, end: uint, f: fn(char) -> bool)\n }\n \n // Utility used by various searching functions\n-pure fn match_at(haystack: str, needle: str, at: uint) -> bool {\n+pure fn match_at(haystack: str/&a, needle: str/&b, at: uint) -> bool {\n     let mut i = at;\n     for each(needle) {|c| if haystack[i] != c { ret false; } i += 1u; }\n     ret true;\n@@ -1061,7 +1063,7 @@ Returns the byte index of the first matching substring\n An `option` containing the byte index of the first matching substring\n or `none` if there is no match\n \"]\n-pure fn find_str(haystack: str, needle: str) -> option<uint> {\n+pure fn find_str(haystack: str/&a, needle: str/&b) -> option<uint> {\n     find_str_between(haystack, needle, 0u, len(haystack))\n }\n \n@@ -1084,7 +1086,7 @@ or `none` if there is no match\n \n `start` must be less than or equal to `len(s)`\n \"]\n-pure fn find_str_from(haystack: str, needle: str, start: uint)\n+pure fn find_str_from(haystack: str/&a, needle: str/&b, start: uint)\n   -> option<uint> {\n     find_str_between(haystack, needle, start, len(haystack))\n }\n@@ -1109,7 +1111,8 @@ or `none` if there is no match\n `start` must be less than or equal to `end` and `end` must be less than\n or equal to `len(s)`.\n \"]\n-pure fn find_str_between(haystack: str, needle: str, start: uint, end:uint)\n+pure fn find_str_between(haystack: str/&a, needle: str/&b, start: uint,\n+                         end:uint)\n   -> option<uint> {\n     // See Issue #1932 for why this is a naive search\n     assert end <= len(haystack);\n@@ -1134,7 +1137,7 @@ Returns true if one string contains another\n * haystack - The string to look in\n * needle - The string to look for\n \"]\n-pure fn contains(haystack: str, needle: str) -> bool {\n+pure fn contains(haystack: str/&a, needle: str/&b) -> bool {\n     option::is_some(find_str(haystack, needle))\n }\n \n@@ -1146,7 +1149,7 @@ Returns true if one string starts with another\n * haystack - The string to look in\n * needle - The string to look for\n \"]\n-pure fn starts_with(haystack: str, needle: str) -> bool unsafe {\n+pure fn starts_with(haystack: str/&a, needle: str/&b) -> bool unsafe {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n@@ -1161,7 +1164,7 @@ Returns true if one string ends with another\n * haystack - The string to look in\n * needle - The string to look for\n \"]\n-pure fn ends_with(haystack: str, needle: str) -> bool {\n+pure fn ends_with(haystack: str/&a, needle: str/&b) -> bool {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n@@ -1173,24 +1176,24 @@ Section: String properties\n */\n \n #[doc = \"Determines if a string contains only ASCII characters\"]\n-pure fn is_ascii(s: str) -> bool {\n+pure fn is_ascii(s: str/&) -> bool {\n     let mut i: uint = len(s);\n     while i > 0u { i -= 1u; if !u8::is_ascii(s[i]) { ret false; } }\n     ret true;\n }\n \n #[doc = \"Returns true if the string has length 0\"]\n-pure fn is_empty(s: str) -> bool { len(s) == 0u }\n+pure fn is_empty(s: str/&) -> bool { len(s) == 0u }\n \n #[doc = \"Returns true if the string has length greater than 0\"]\n-pure fn is_not_empty(s: str) -> bool { !is_empty(s) }\n+pure fn is_not_empty(s: str/&) -> bool { !is_empty(s) }\n \n #[doc = \"\n Returns true if the string contains only whitespace\n \n Whitespace characters are determined by `char::is_whitespace`\n \"]\n-pure fn is_whitespace(s: str) -> bool {\n+pure fn is_whitespace(s: str/&) -> bool {\n     ret all(s, char::is_whitespace);\n }\n \n@@ -1199,27 +1202,26 @@ Returns true if the string contains only alphanumerics\n \n Alphanumeric characters are determined by `char::is_alphanumeric`\n \"]\n-fn is_alphanumeric(s: str) -> bool {\n+fn is_alphanumeric(s: str/&) -> bool {\n     ret all(s, char::is_alphanumeric);\n }\n \n #[doc = \"\n Returns the string length/size in bytes not counting the null terminator\n \"]\n-pure fn len(s: str) -> uint unsafe {\n-    let repr: *vec::unsafe::vec_repr = ::unsafe::reinterpret_cast(s);\n-    (*repr).fill - 1u\n+pure fn len(s: str/&) -> uint {\n+    unpack_slice(s) { |_p, n| n - 1u }\n }\n \n #[doc = \"Returns the number of characters that a string holds\"]\n-pure fn char_len(s: str) -> uint { count_chars(s, 0u, len(s)) }\n+pure fn char_len(s: str/&) -> uint { count_chars(s, 0u, len(s)) }\n \n /*\n Section: Misc\n */\n \n #[doc = \"Determines if a vector of bytes contains valid UTF-8\"]\n-pure fn is_utf8(v: [const u8]) -> bool {\n+pure fn is_utf8(v: [const u8]/&) -> bool {\n     let mut i = 0u;\n     let total = vec::len::<u8>(v);\n     while i < total {\n@@ -1237,7 +1239,7 @@ pure fn is_utf8(v: [const u8]) -> bool {\n }\n \n #[doc = \"Determines if a vector of `u16` contains valid UTF-16\"]\n-pure fn is_utf16(v: [const u16]) -> bool {\n+pure fn is_utf16(v: [const u16]/&) -> bool {\n     let len = vec::len(v);\n     let mut i = 0u;\n     while (i < len) {\n@@ -1258,7 +1260,7 @@ pure fn is_utf16(v: [const u16]) -> bool {\n }\n \n #[doc = \"Converts to a vector of `u16` encoded as UTF-16\"]\n-pure fn to_utf16(s: str) -> [u16] {\n+pure fn to_utf16(s: str/&) -> [u16] {\n     let mut u = [];\n     chars_iter(s) {|cch|\n         // Arithmetic with u32 literals is easier on the eyes than chars.\n@@ -1280,7 +1282,7 @@ pure fn to_utf16(s: str) -> [u16] {\n     ret u;\n }\n \n-pure fn utf16_chars(v: [const u16], f: fn(char)) {\n+pure fn utf16_chars(v: [const u16]/&, f: fn(char)) {\n     let len = vec::len(v);\n     let mut i = 0u;\n     while (i < len && v[i] != 0u16) {\n@@ -1305,7 +1307,7 @@ pure fn utf16_chars(v: [const u16], f: fn(char)) {\n }\n \n \n-pure fn from_utf16(v: [const u16]) -> str {\n+pure fn from_utf16(v: [const u16]/&) -> str {\n     let mut buf = \"\";\n     unchecked {\n         reserve(buf, vec::len(v));\n@@ -1328,7 +1330,7 @@ As char_len but for a slice of a string\n \n The number of Unicode characters in `s` between the given indices.\n \"]\n-pure fn count_chars(s: str, start: uint, end: uint) -> uint {\n+pure fn count_chars(s: str/&, start: uint, end: uint) -> uint {\n     assert is_char_boundary(s, start);\n     assert is_char_boundary(s, end);\n     let mut i = start, len = 0u;\n@@ -1343,7 +1345,7 @@ pure fn count_chars(s: str, start: uint, end: uint) -> uint {\n #[doc = \"\n Counts the number of bytes taken by the `n` in `s` starting from `start`.\n \"]\n-pure fn count_bytes(s: str, start: uint, n: uint) -> uint {\n+pure fn count_bytes(s: str/&b, start: uint, n: uint) -> uint {\n     assert is_char_boundary(s, start);\n     let mut end = start, cnt = n;\n     let l = len(s);\n@@ -1375,7 +1377,7 @@ pure fn utf8_char_width(b: u8) -> uint {\n Returns false if the index points into the middle of a multi-byte\n character sequence.\n \"]\n-pure fn is_char_boundary(s: str, index: uint) -> bool {\n+pure fn is_char_boundary(s: str/&, index: uint) -> bool {\n     if index == len(s) { ret true; }\n     let b = s[index];\n     ret b < 128u8 || b >= 192u8;\n@@ -1428,7 +1430,7 @@ index of the next unicode character.\n If `i` is greater than or equal to the length of the string.\n If `i` is not the index of the beginning of a valid UTF-8 character.\n \"]\n-pure fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n+pure fn char_range_at(s: str/&, i: uint) -> {ch: char, next: uint} {\n     let b0 = s[i];\n     let w = utf8_char_width(b0);\n     assert (w != 0u);\n@@ -1451,14 +1453,14 @@ pure fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n }\n \n #[doc = \"Pluck a character out of a string\"]\n-pure fn char_at(s: str, i: uint) -> char { ret char_range_at(s, i).ch; }\n+pure fn char_at(s: str/&, i: uint) -> char { ret char_range_at(s, i).ch; }\n \n #[doc = \"\n Given a byte position and a str, return the previous char and its position\n \n This function can be used to iterate over a unicode string in reverse.\n \"]\n-pure fn char_range_at_reverse(ss: str, start: uint)\n+pure fn char_range_at_reverse(ss: str/&, start: uint)\n     -> {ch: char, prev: uint} {\n \n     let mut prev = start;\n@@ -1497,7 +1499,7 @@ Loop through a substring, char by char\n `true` If execution proceeded correctly, `false` if it was interrupted,\n that is if `it` returned `false` at any point.\n \"]\n-pure fn all_between(s: str, start: uint, end: uint,\n+pure fn all_between(s: str/&, start: uint, end: uint,\n                     it: fn(char) -> bool) -> bool {\n     assert is_char_boundary(s, start);\n     let mut i = start;\n@@ -1530,7 +1532,7 @@ Loop through a substring, char by char\n \n `true` if `it` returns `true` for any character\n \"]\n-pure fn any_between(s: str, start: uint, end: uint,\n+pure fn any_between(s: str/&, start: uint, end: uint,\n                     it: fn(char) -> bool) -> bool {\n     !all_between(s, start, end, {|c| !it(c)})\n }\n@@ -1668,7 +1670,7 @@ pure fn capacity(&&s: str) -> uint unsafe {\n }\n \n #[doc = \"Escape each char in `s` with char::escape_default.\"]\n-pure fn escape_default(s: str) -> str {\n+pure fn escape_default(s: str/&) -> str {\n     let mut out: str = \"\";\n     unchecked {\n         reserve_at_least(out, str::len(s));\n@@ -1678,7 +1680,7 @@ pure fn escape_default(s: str) -> str {\n }\n \n #[doc = \"Escape each char in `s` with char::escape_unicode.\"]\n-pure fn escape_unicode(s: str) -> str {\n+pure fn escape_unicode(s: str/&) -> str {\n     let mut out: str = \"\";\n     unchecked {\n         reserve_at_least(out, str::len(s));\n@@ -1762,22 +1764,21 @@ mod unsafe {\n    If begin is greater than end.\n    If end is greater than the length of the string.\n    \"]\n-   unsafe fn slice_bytes(s: str, begin: uint, end: uint) -> str unsafe {\n-       assert (begin <= end);\n-       assert (end <= len(s));\n+   unsafe fn slice_bytes(s: str/&, begin: uint, end: uint) -> str unsafe {\n+       unpack_slice(s) { |sbuf, n|\n+           assert (begin <= end);\n+           assert (end <= n);\n \n-       let mut v = as_buf(s) { |sbuf|\n            let mut v = [];\n            vec::reserve(v, end - begin + 1u);\n            vec::as_buf(v) { |vbuf|\n                let src = ptr::offset(sbuf, begin);\n                ptr::memcpy(vbuf, src, end - begin);\n            }\n            vec::unsafe::set_len(v, end - begin);\n-           v\n-       };\n-       v += [0u8];\n-       ret ::unsafe::transmute(v);\n+           v += [0u8];\n+           ::unsafe::transmute(v)\n+       }\n    }\n \n    #[doc = \"Appends a byte to a string. (Not UTF-8 safe).\"]\n@@ -1834,6 +1835,19 @@ mod unsafe {\n \n #[doc = \"Extension methods for strings\"]\n impl extensions for str {\n+    #[doc = \"Returns a string with leading and trailing whitespace removed\"]\n+    #[inline]\n+    fn trim() -> str { trim(self) }\n+    #[doc = \"Returns a string with leading whitespace removed\"]\n+    #[inline]\n+    fn trim_left() -> str { trim_left(self) }\n+    #[doc = \"Returns a string with trailing whitespace removed\"]\n+    #[inline]\n+    fn trim_right() -> str { trim_right(self) }\n+}\n+\n+#[doc = \"Extension methods for strings\"]\n+impl extensions/& for str/& {\n     #[doc = \"\n     Return true if a predicate matches all characters or if the string\n     contains no characters\n@@ -1848,7 +1862,7 @@ impl extensions for str {\n     fn any(it: fn(char) -> bool) -> bool { any(self, it) }\n     #[doc = \"Returns true if one string contains another\"]\n     #[inline]\n-    fn contains(needle: str) -> bool { contains(self, needle) }\n+    fn contains(needle: str/&a) -> bool { contains(self, needle) }\n     #[doc = \"Iterate over the bytes in a string\"]\n     #[inline]\n     fn each(it: fn(u8) -> bool) { each(self, it) }\n@@ -1857,7 +1871,7 @@ impl extensions for str {\n     fn each_char(it: fn(char) -> bool) { each_char(self, it) }\n     #[doc = \"Returns true if one string ends with another\"]\n     #[inline]\n-    fn ends_with(needle: str) -> bool { ends_with(self, needle) }\n+    fn ends_with(needle: str/&) -> bool { ends_with(self, needle) }\n     #[doc = \"Returns true if the string has length 0\"]\n     #[inline]\n     fn is_empty() -> bool { is_empty(self) }\n@@ -1902,10 +1916,10 @@ impl extensions for str {\n     string\n     \"]\n     #[inline]\n-    fn split_str(sep: str) -> [str] { split_str(self, sep) }\n+    fn split_str(sep: str/&a) -> [str] { split_str(self, sep) }\n     #[doc = \"Returns true if one string starts with another\"]\n     #[inline]\n-    fn starts_with(needle: str) -> bool { starts_with(self, needle) }\n+    fn starts_with(needle: str/&a) -> bool { starts_with(self, needle) }\n     #[doc = \"\n     Take a substring of another.\n \n@@ -1920,15 +1934,6 @@ impl extensions for str {\n     #[doc = \"Convert a string to uppercase\"]\n     #[inline]\n     fn to_upper() -> str { to_upper(self) }\n-    #[doc = \"Returns a string with leading and trailing whitespace removed\"]\n-    #[inline]\n-    fn trim() -> str { trim(self) }\n-    #[doc = \"Returns a string with leading whitespace removed\"]\n-    #[inline]\n-    fn trim_left() -> str { trim_left(self) }\n-    #[doc = \"Returns a string with trailing whitespace removed\"]\n-    #[inline]\n-    fn trim_right() -> str { trim_right(self) }\n     #[doc = \"Escape each char in `s` with char::escape_default.\"]\n     #[inline]\n     fn escape_default() -> str { escape_default(self) }\n@@ -2091,7 +2096,7 @@ mod tests {\n \n     #[test]\n     fn test_split_str() {\n-        fn t(s: str, sep: str, i: int, k: str) {\n+        fn t(s: str, sep: str/&a, i: int, k: str) {\n             let v = split_str(s, sep);\n             assert eq(v[i], k);\n         }"}, {"sha": "7058f2202b9f01846a2296080395edb5b1d3df7c", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4335ce47f36ff4f7e842e241b2006abd48f55a50/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4335ce47f36ff4f7e842e241b2006abd48f55a50/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=4335ce47f36ff4f7e842e241b2006abd48f55a50", "patch": "@@ -266,7 +266,7 @@ pure fn view<T: copy>(v: [T]/&, start: uint, end: uint) -> [T]/&a {\n #[doc = \"\n Split the vector `v` by applying each element against the predicate `f`.\n \"]\n-fn split<T: copy>(v: [T], f: fn(T) -> bool) -> [[T]] {\n+fn split<T: copy>(v: [T]/&, f: fn(T) -> bool) -> [[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret [] }\n \n@@ -289,7 +289,7 @@ fn split<T: copy>(v: [T], f: fn(T) -> bool) -> [[T]] {\n Split the vector `v` by applying each element against the predicate `f` up\n to `n` times.\n \"]\n-fn splitn<T: copy>(v: [T], n: uint, f: fn(T) -> bool) -> [[T]] {\n+fn splitn<T: copy>(v: [T]/&, n: uint, f: fn(T) -> bool) -> [[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret [] }\n \n@@ -315,7 +315,7 @@ fn splitn<T: copy>(v: [T], n: uint, f: fn(T) -> bool) -> [[T]] {\n Reverse split the vector `v` by applying each element against the predicate\n `f`.\n \"]\n-fn rsplit<T: copy>(v: [T], f: fn(T) -> bool) -> [[T]] {\n+fn rsplit<T: copy>(v: [T]/&, f: fn(T) -> bool) -> [[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret [] }\n \n@@ -338,7 +338,7 @@ fn rsplit<T: copy>(v: [T], f: fn(T) -> bool) -> [[T]] {\n Reverse split the vector `v` by applying each element against the predicate\n `f` up to `n times.\n \"]\n-fn rsplitn<T: copy>(v: [T], n: uint, f: fn(T) -> bool) -> [[T]] {\n+fn rsplitn<T: copy>(v: [T]/&, n: uint, f: fn(T) -> bool) -> [[T]] {\n     let ln = len(v);\n     if (ln == 0u) { ret [] }\n \n@@ -776,7 +776,7 @@ Convert two vectors to a vector of pairs\n Returns a vector of tuples, where the i-th tuple contains contains the\n i-th elements from each of the input vectors.\n \"]\n-pure fn zip<T: copy, U: copy>(v: [const T], u: [const U]) -> [(T, U)] {\n+pure fn zip<T: copy, U: copy>(v: [const T]/&, u: [const U]/&) -> [(T, U)] {\n     let mut zipped = [];\n     let sz = len(v);\n     let mut i = 0u;\n@@ -859,7 +859,7 @@ Iterates over a vector, with option to break\n Return true to continue, false to break.\n \"]\n #[inline(always)]\n-pure fn each<T>(v: [T]/&, f: fn(T) -> bool) unsafe {\n+pure fn each<T>(v: [const T]/&, f: fn(T) -> bool) unsafe {\n     vec::unpack_slice(v) {|p, n|\n         let mut n = n;\n         let mut p = p;\n@@ -877,7 +877,7 @@ Iterates over a vector's elements and indices\n Return true to continue, false to break.\n \"]\n #[inline(always)]\n-pure fn eachi<T>(v: [T]/&, f: fn(uint, T) -> bool) unsafe {\n+pure fn eachi<T>(v: [const T]/&, f: fn(uint, T) -> bool) unsafe {\n     vec::unpack_slice(v) {|p, n|\n         let mut i = 0u;\n         let mut p = p;\n@@ -996,7 +996,7 @@ fn as_mut_buf<E,T>(v: [mut E]/&, f: fn(*mut E) -> T) -> T unsafe {\n Work with the buffer and length of a slice.\n \"]\n #[inline(always)]\n-pure fn unpack_slice<T,U>(s: [T]/&,\n+pure fn unpack_slice<T,U>(s: [const T]/&,\n                           f: fn(*T, uint) -> U) -> U unsafe {\n     let v : *(*T,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n     let (buf,len) = *v;\n@@ -1316,7 +1316,7 @@ mod u8 {\n //\n // This cannot be used with iter-trait.rs because of the region pointer\n // required in the slice.\n-impl extensions/&<A> of iter::base_iter<A> for [A]/& {\n+impl extensions/&<A> of iter::base_iter<A> for [const A]/& {\n     fn each(blk: fn(A) -> bool) { each(self, blk) }\n     fn size_hint() -> option<uint> { some(len(self)) }\n     fn eachi(blk: fn(uint, A) -> bool) { iter::eachi(self, blk) }\n@@ -1328,7 +1328,7 @@ impl extensions/&<A> of iter::base_iter<A> for [A]/& {\n     fn contains(x: A) -> bool { iter::contains(self, x) }\n     fn count(x: A) -> uint { iter::count(self, x) }\n }\n-impl extensions/&<A:copy> for [A]/& {\n+impl extensions/&<A:copy> for [const A]/& {\n     fn filter_to_vec(pred: fn(A) -> bool) -> [A] {\n         iter::filter_to_vec(self, pred)\n     }"}]}