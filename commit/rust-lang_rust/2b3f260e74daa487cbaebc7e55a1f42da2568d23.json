{"sha": "2b3f260e74daa487cbaebc7e55a1f42da2568d23", "node_id": "C_kwDOAAsO6NoAKDJiM2YyNjBlNzRkYWE0ODdjYmFlYmM3ZTU1YTFmNDJkYTI1NjhkMjM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-11T18:01:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-11T18:01:17Z"}, "message": "Auto merge of #107928 - matthiaskrgr:rollup-qnn380r, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #107657 (Add only modified subcommand for compiletest)\n - #107864 (rustdoc: clean up `write!` calls with less stuttering)\n - #107873 (Emit JSON output for the building of bootstrap itself)\n - #107895 (remove redundant clones)\n - #107897 (Reexported macros docs)\n - #107909 (rustdoc: remove redundant `if s.is_empty()` from `find_testable_code`)\n - #107912 (rustdoc: Don't resolve link to field on different variant)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "d3829d94eae8b866d3e9c38d7f3d00c1a68a1159", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3829d94eae8b866d3e9c38d7f3d00c1a68a1159"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b3f260e74daa487cbaebc7e55a1f42da2568d23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b3f260e74daa487cbaebc7e55a1f42da2568d23", "html_url": "https://github.com/rust-lang/rust/commit/2b3f260e74daa487cbaebc7e55a1f42da2568d23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b3f260e74daa487cbaebc7e55a1f42da2568d23/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8dabf5da9e0318f8c324dc224ad49dc91472c2ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/8dabf5da9e0318f8c324dc224ad49dc91472c2ec", "html_url": "https://github.com/rust-lang/rust/commit/8dabf5da9e0318f8c324dc224ad49dc91472c2ec"}, {"sha": "c8614a7479fb104022daf6946beefaa818f68351", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8614a7479fb104022daf6946beefaa818f68351", "html_url": "https://github.com/rust-lang/rust/commit/c8614a7479fb104022daf6946beefaa818f68351"}], "stats": {"total": 304, "additions": 242, "deletions": 62}, "files": [{"sha": "a130f49b0bec596401a0437fe6881afd0c993459", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2b3f260e74daa487cbaebc7e55a1f42da2568d23/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2b3f260e74daa487cbaebc7e55a1f42da2568d23/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2b3f260e74daa487cbaebc7e55a1f42da2568d23", "patch": "@@ -895,6 +895,7 @@ dependencies = [\n name = \"compiletest\"\n version = \"0.0.0\"\n dependencies = [\n+ \"build_helper\",\n  \"colored\",\n  \"diff\",\n  \"getopts\","}, {"sha": "66ec8f5f57d212935164ebdba14839c539058cfb", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b3f260e74daa487cbaebc7e55a1f42da2568d23/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3f260e74daa487cbaebc7e55a1f42da2568d23/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=2b3f260e74daa487cbaebc7e55a1f42da2568d23", "patch": "@@ -203,7 +203,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n             }\n         }\n \n-        self.src_archives.push((archive_path.to_owned(), archive_map));\n+        self.src_archives.push((archive_path, archive_map));\n         Ok(())\n     }\n "}, {"sha": "22924efa9484240a2d128c104fa41e1e570160ab", "filename": "compiler/rustc_log/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b3f260e74daa487cbaebc7e55a1f42da2568d23/compiler%2Frustc_log%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3f260e74daa487cbaebc7e55a1f42da2568d23/compiler%2Frustc_log%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_log%2Fsrc%2Flib.rs?ref=2b3f260e74daa487cbaebc7e55a1f42da2568d23", "patch": "@@ -92,7 +92,7 @@ pub fn init_env_logger(env: &str) -> Result<(), Error> {\n             let fmt_layer = tracing_subscriber::fmt::layer()\n                 .with_writer(io::stderr)\n                 .without_time()\n-                .event_format(BacktraceFormatter { backtrace_target: str.to_string() });\n+                .event_format(BacktraceFormatter { backtrace_target: str });\n             let subscriber = subscriber.with(fmt_layer);\n             tracing::subscriber::set_global_default(subscriber).unwrap();\n         }"}, {"sha": "34a4fd02ea691cd1c612c2e6b01ec83e4f2145dd", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b3f260e74daa487cbaebc7e55a1f42da2568d23/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3f260e74daa487cbaebc7e55a1f42da2568d23/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=2b3f260e74daa487cbaebc7e55a1f42da2568d23", "patch": "@@ -847,9 +847,7 @@ impl<'a> Parser<'a> {\n                 0,\n                 ParseError {\n                     description: \"expected format parameter to occur after `:`\".to_owned(),\n-                    note: Some(\n-                        format!(\"`?` comes after `:`, try `{}:{}` instead\", word, \"?\").to_owned(),\n-                    ),\n+                    note: Some(format!(\"`?` comes after `:`, try `{}:{}` instead\", word, \"?\")),\n                     label: \"expected `?` to occur after `:`\".to_owned(),\n                     span: pos.to(pos),\n                     secondary_label: None,"}, {"sha": "013d1ab525b0cd3a535737759056ca83dad30da7", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=2b3f260e74daa487cbaebc7e55a1f42da2568d23", "patch": "@@ -784,6 +784,8 @@ def build_bootstrap(self, color, verbose_count):\n         if self.get_toml(\"metrics\", \"build\"):\n             args.append(\"--features\")\n             args.append(\"build-metrics\")\n+        if self.json_output:\n+            args.append(\"--message-format=json\")\n         if color == \"always\":\n             args.append(\"--color=always\")\n         elif color == \"never\":\n@@ -841,6 +843,7 @@ def parse_args():\n     parser.add_argument('--build')\n     parser.add_argument('--color', choices=['always', 'never', 'auto'])\n     parser.add_argument('--clean', action='store_true')\n+    parser.add_argument('--json-output', action='store_true')\n     parser.add_argument('-v', '--verbose', action='count', default=0)\n \n     return parser.parse_known_args(sys.argv)[0]\n@@ -852,6 +855,7 @@ def bootstrap(args):\n     build.rust_root = os.path.abspath(os.path.join(__file__, '../../..'))\n     build.verbose = args.verbose != 0\n     build.clean = args.clean\n+    build.json_output = args.json_output\n \n     # Read from `--config`, then `RUST_BOOTSTRAP_CONFIG`, then `./config.toml`,\n     # then `config.toml` in the root directory."}, {"sha": "3574f11189ee9f2efcf284c70aa480713a85c644", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=2b3f260e74daa487cbaebc7e55a1f42da2568d23", "patch": "@@ -557,6 +557,7 @@ mod dist {\n             rustfix_coverage: false,\n             pass: None,\n             run: None,\n+            only_modified: false,\n         };\n \n         let build = Build::new(config);\n@@ -627,6 +628,7 @@ mod dist {\n             rustfix_coverage: false,\n             pass: None,\n             run: None,\n+            only_modified: false,\n         };\n         // Make sure rustfmt binary not being found isn't an error.\n         config.channel = \"beta\".to_string();"}, {"sha": "ff927ed561b2fe57e44ac1b45ecd9addbb658cb9", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=2b3f260e74daa487cbaebc7e55a1f42da2568d23", "patch": "@@ -124,6 +124,7 @@ pub enum Subcommand {\n         fail_fast: bool,\n         doc_tests: DocTests,\n         rustfix_coverage: bool,\n+        only_modified: bool,\n     },\n     Bench {\n         paths: Vec<PathBuf>,\n@@ -301,6 +302,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n                 opts.optflag(\"\", \"doc\", \"only run doc tests\");\n                 opts.optflag(\"\", \"bless\", \"update all stderr/stdout files of failing ui tests\");\n                 opts.optflag(\"\", \"force-rerun\", \"rerun tests even if the inputs are unchanged\");\n+                opts.optflag(\"\", \"only-modified\", \"only run tests that result has been changed\");\n                 opts.optopt(\n                     \"\",\n                     \"compare-mode\",\n@@ -598,6 +600,7 @@ Arguments:\n                 rustc_args: matches.opt_strs(\"rustc-args\"),\n                 fail_fast: !matches.opt_present(\"no-fail-fast\"),\n                 rustfix_coverage: matches.opt_present(\"rustfix-coverage\"),\n+                only_modified: matches.opt_present(\"only-modified\"),\n                 doc_tests: if matches.opt_present(\"doc\") {\n                     DocTests::Only\n                 } else if matches.opt_present(\"no-doc\") {\n@@ -777,6 +780,13 @@ impl Subcommand {\n         }\n     }\n \n+    pub fn only_modified(&self) -> bool {\n+        match *self {\n+            Subcommand::Test { only_modified, .. } => only_modified,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn force_rerun(&self) -> bool {\n         match *self {\n             Subcommand::Test { force_rerun, .. } => force_rerun,"}, {"sha": "6c9c26faef6aa7a4153f444035fd96f1a1299493", "filename": "src/bootstrap/format.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Fbootstrap%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Fbootstrap%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fformat.rs?ref=2b3f260e74daa487cbaebc7e55a1f42da2568d23", "patch": "@@ -1,8 +1,8 @@\n //! Runs rustfmt on the repository.\n \n use crate::builder::Builder;\n-use crate::util::{output, output_result, program_out_of_date, t};\n-use build_helper::git::updated_master_branch;\n+use crate::util::{output, program_out_of_date, t};\n+use build_helper::git::get_git_modified_files;\n use ignore::WalkBuilder;\n use std::collections::VecDeque;\n use std::path::{Path, PathBuf};\n@@ -80,23 +80,11 @@ fn update_rustfmt_version(build: &Builder<'_>) {\n ///\n /// Returns `None` if all files should be formatted.\n fn get_modified_rs_files(build: &Builder<'_>) -> Result<Option<Vec<String>>, String> {\n-    let Ok(updated_master) = updated_master_branch(Some(&build.config.src)) else { return Ok(None); };\n-\n     if !verify_rustfmt_version(build) {\n         return Ok(None);\n     }\n \n-    let merge_base =\n-        output_result(build.config.git().arg(\"merge-base\").arg(&updated_master).arg(\"HEAD\"))?;\n-    Ok(Some(\n-        output_result(\n-            build.config.git().arg(\"diff-index\").arg(\"--name-only\").arg(merge_base.trim()),\n-        )?\n-        .lines()\n-        .map(|s| s.trim().to_owned())\n-        .filter(|f| Path::new(f).extension().map_or(false, |ext| ext == \"rs\"))\n-        .collect(),\n-    ))\n+    get_git_modified_files(Some(&build.config.src), &vec![\"rs\"])\n }\n \n #[derive(serde::Deserialize)]"}, {"sha": "f8835fe11a8cccad7781c81d083ee262eb68ca11", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=2b3f260e74daa487cbaebc7e55a1f42da2568d23", "patch": "@@ -1510,6 +1510,10 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n         if builder.config.rust_optimize_tests {\n             cmd.arg(\"--optimize-tests\");\n         }\n+        if builder.config.cmd.only_modified() {\n+            cmd.arg(\"--only-modified\");\n+        }\n+\n         let mut flags = if is_rustdoc { Vec::new() } else { vec![\"-Crpath\".to_string()] };\n         flags.push(format!(\"-Cdebuginfo={}\", builder.config.rust_debuginfo_level_tests));\n         flags.extend(builder.config.cmd.rustc_args().iter().map(|s| s.to_string()));"}, {"sha": "42bdbddbce617785abafad98c5a981a277c15b76", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2b3f260e74daa487cbaebc7e55a1f42da2568d23", "patch": "@@ -2209,10 +2209,12 @@ fn clean_maybe_renamed_item<'tcx>(\n         };\n \n         let mut extra_attrs = Vec::new();\n-        if let Some(hir::Node::Item(use_node)) =\n-            import_id.and_then(|def_id| cx.tcx.hir().find_by_def_id(def_id))\n+        if let Some(import_id) = import_id &&\n+            let Some(hir::Node::Item(use_node)) = cx.tcx.hir().find_by_def_id(import_id)\n         {\n-            // We get all the various imports' attributes.\n+            // First, we add the attributes from the current import.\n+            extra_attrs.extend_from_slice(inline::load_attrs(cx, import_id.to_def_id()));\n+            // Then we get all the various imports' attributes.\n             get_all_import_attributes(use_node, cx.tcx, item.owner_id.def_id, &mut extra_attrs);\n         }\n "}, {"sha": "8f401a2fc1d5bd2644c74664e399f9d6ef1d931b", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=2b3f260e74daa487cbaebc7e55a1f42da2568d23", "patch": "@@ -740,11 +740,7 @@ pub(crate) fn find_testable_code<T: doctest::Tester>(\n             }\n             Event::Text(ref s) if register_header.is_some() => {\n                 let level = register_header.unwrap();\n-                if s.is_empty() {\n-                    tests.register_header(\"\", level);\n-                } else {\n-                    tests.register_header(s, level);\n-                }\n+                tests.register_header(s, level);\n                 register_header = None;\n             }\n             _ => {}"}, {"sha": "d0f497321abf534aa47c4e65e70dc29effd82321", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=2b3f260e74daa487cbaebc7e55a1f42da2568d23", "patch": "@@ -1081,10 +1081,10 @@ fn item_typedef(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clea\n     fn write_content(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n         wrap_item(w, |w| {\n             render_attributes_in_pre(w, it, \"\");\n-            write!(w, \"{}\", visibility_print_with_space(it.visibility(cx.tcx()), it.item_id, cx));\n             write!(\n                 w,\n-                \"type {}{}{where_clause} = {type_};\",\n+                \"{}type {}{}{where_clause} = {type_};\",\n+                visibility_print_with_space(it.visibility(cx.tcx()), it.item_id, cx),\n                 it.name.unwrap(),\n                 t.generics.print(cx),\n                 where_clause = print_where_clause(&t.generics, cx, 0, Ending::Newline),\n@@ -1138,13 +1138,11 @@ fn item_union(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean:\n                      <a href=\\\"#{id}\\\" class=\\\"anchor field\\\">\u00a7</a>\\\n                      <code>{name}: {ty}</code>\\\n                  </span>\",\n-                id = id,\n-                name = name,\n                 shortty = ItemType::StructField,\n                 ty = ty.print(cx),\n             );\n             if let Some(stability_class) = field.stability_class(cx.tcx()) {\n-                write!(w, \"<span class=\\\"stab {stab}\\\"></span>\", stab = stability_class);\n+                write!(w, \"<span class=\\\"stab {stability_class}\\\"></span>\");\n             }\n             document(w, cx, field, Some(it), HeadingOffset::H3);\n         }\n@@ -1242,7 +1240,6 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n                 w,\n                 \"<section id=\\\"{id}\\\" class=\\\"variant\\\">\\\n                     <a href=\\\"#{id}\\\" class=\\\"anchor\\\">\u00a7</a>\",\n-                id = id,\n             );\n             render_stability_since_raw_with_extra(\n                 w,\n@@ -1280,8 +1277,11 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n             if let Some((heading, fields)) = heading_and_fields {\n                 let variant_id =\n                     cx.derive_id(format!(\"{}.{}.fields\", ItemType::Variant, variant.name.unwrap()));\n-                write!(w, \"<div class=\\\"sub-variant\\\" id=\\\"{id}\\\">\", id = variant_id);\n-                write!(w, \"<h4>{heading}</h4>\", heading = heading);\n+                write!(\n+                    w,\n+                    \"<div class=\\\"sub-variant\\\" id=\\\"{variant_id}\\\">\\\n+                        <h4>{heading}</h4>\",\n+                );\n                 document_non_exhaustive(w, variant);\n                 for field in fields {\n                     match *field.kind {\n@@ -1299,7 +1299,6 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n                                      <a href=\\\"#{id}\\\" class=\\\"anchor field\\\">\u00a7</a>\\\n                                      <code>{f}: {t}</code>\\\n                                  </span>\",\n-                                id = id,\n                                 f = field.name.unwrap(),\n                                 t = ty.print(cx)\n                             );\n@@ -1450,11 +1449,9 @@ fn item_struct(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean\n                     w,\n                     \"<span id=\\\"{id}\\\" class=\\\"{item_type} small-section-header\\\">\\\n                          <a href=\\\"#{id}\\\" class=\\\"anchor field\\\">\u00a7</a>\\\n-                         <code>{name}: {ty}</code>\\\n+                         <code>{field_name}: {ty}</code>\\\n                      </span>\",\n                     item_type = ItemType::StructField,\n-                    id = id,\n-                    name = field_name,\n                     ty = ty.print(cx)\n                 );\n                 document(w, cx, field, Some(it), HeadingOffset::H3);\n@@ -1840,8 +1837,8 @@ fn document_type_layout(w: &mut Buffer, cx: &Context<'_>, ty_def_id: DefId) {\n         if layout.abi.is_unsized() {\n             write!(w, \"(unsized)\");\n         } else {\n-            let bytes = layout.size.bytes() - tag_size;\n-            write!(w, \"{size} byte{pl}\", size = bytes, pl = if bytes == 1 { \"\" } else { \"s\" },);\n+            let size = layout.size.bytes() - tag_size;\n+            write!(w, \"{size} byte{pl}\", pl = if size == 1 { \"\" } else { \"s\" },);\n         }\n     }\n \n@@ -1896,7 +1893,7 @@ fn document_type_layout(w: &mut Buffer, cx: &Context<'_>, ty_def_id: DefId) {\n \n                     for (index, layout) in variants.iter_enumerated() {\n                         let name = adt.variant(index).name;\n-                        write!(w, \"<li><code>{name}</code>: \", name = name);\n+                        write!(w, \"<li><code>{name}</code>: \");\n                         write_size_of_layout(w, layout, tag_size);\n                         writeln!(w, \"</li>\");\n                     }"}, {"sha": "62e190b4bd8ed7b8ccd7d1e6cbc2a985c635ecce", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=2b3f260e74daa487cbaebc7e55a1f42da2568d23", "patch": "@@ -297,7 +297,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         match ty_res {\n             Res::Def(DefKind::Enum, did) => match tcx.type_of(did).kind() {\n                 ty::Adt(def, _) if def.is_enum() => {\n-                    if let Some(field) = def.all_fields().find(|f| f.name == variant_field_name) {\n+                    if let Some(variant) = def.variants().iter().find(|v| v.name == variant_name)\n+                        && let Some(field) = variant.fields.iter().find(|f| f.name == variant_field_name) {\n                         Ok((ty_res, field.did))\n                     } else {\n                         Err(UnresolvedPath {\n@@ -1716,15 +1717,35 @@ fn resolution_failure(\n \n                     // Otherwise, it must be an associated item or variant\n                     let res = partial_res.expect(\"None case was handled by `last_found_module`\");\n-                    let kind = match res {\n-                        Res::Def(kind, _) => Some(kind),\n+                    let kind_did = match res {\n+                        Res::Def(kind, did) => Some((kind, did)),\n                         Res::Primitive(_) => None,\n                     };\n-                    let path_description = if let Some(kind) = kind {\n+                    let is_struct_variant = |did| {\n+                        if let ty::Adt(def, _) = tcx.type_of(did).kind()\n+                        && def.is_enum()\n+                        && let Some(variant) = def.variants().iter().find(|v| v.name == res.name(tcx)) {\n+                            // ctor is `None` if variant is a struct\n+                            variant.ctor.is_none()\n+                        } else {\n+                            false\n+                        }\n+                    };\n+                    let path_description = if let Some((kind, did)) = kind_did {\n                         match kind {\n                             Mod | ForeignMod => \"inner item\",\n                             Struct => \"field or associated item\",\n                             Enum | Union => \"variant or associated item\",\n+                            Variant if is_struct_variant(did) => {\n+                                let variant = res.name(tcx);\n+                                let note = format!(\"variant `{variant}` has no such field\");\n+                                if let Some(span) = sp {\n+                                    diag.span_label(span, &note);\n+                                } else {\n+                                    diag.note(&note);\n+                                }\n+                                return;\n+                            }\n                             Variant\n                             | Field\n                             | Closure"}, {"sha": "9c1e5f4a3cddb8aa448c5a5e6a72489e6f5f8027", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=2b3f260e74daa487cbaebc7e55a1f42da2568d23", "patch": "@@ -378,7 +378,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 let nonexported = !tcx.has_attr(def_id, sym::macro_export);\n \n                 if is_macro_2_0 || nonexported || self.inlining {\n-                    self.add_to_current_mod(item, renamed, None);\n+                    self.add_to_current_mod(item, renamed, import_id);\n                 }\n             }\n             hir::ItemKind::Mod(ref m) => {"}, {"sha": "168633c8f63349e12a04e46c803a41ce6cecec03", "filename": "src/tools/build_helper/src/git.rs", "status": "modified", "additions": 65, "deletions": 7, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Ftools%2Fbuild_helper%2Fsrc%2Fgit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Ftools%2Fbuild_helper%2Fsrc%2Fgit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild_helper%2Fsrc%2Fgit.rs?ref=2b3f260e74daa487cbaebc7e55a1f42da2568d23", "patch": "@@ -1,5 +1,24 @@\n+use std::process::Stdio;\n use std::{path::Path, process::Command};\n \n+/// Runs a command and returns the output\n+fn output_result(cmd: &mut Command) -> Result<String, String> {\n+    let output = match cmd.stderr(Stdio::inherit()).output() {\n+        Ok(status) => status,\n+        Err(e) => return Err(format!(\"failed to run command: {:?}: {}\", cmd, e)),\n+    };\n+    if !output.status.success() {\n+        return Err(format!(\n+            \"command did not execute successfully: {:?}\\n\\\n+             expected success, got: {}\\n{}\",\n+            cmd,\n+            output.status,\n+            String::from_utf8(output.stderr).map_err(|err| format!(\"{err:?}\"))?\n+        ));\n+    }\n+    Ok(String::from_utf8(output.stdout).map_err(|err| format!(\"{err:?}\"))?)\n+}\n+\n /// Finds the remote for rust-lang/rust.\n /// For example for these remotes it will return `upstream`.\n /// ```text\n@@ -14,13 +33,7 @@ pub fn get_rust_lang_rust_remote(git_dir: Option<&Path>) -> Result<String, Strin\n         git.current_dir(git_dir);\n     }\n     git.args([\"config\", \"--local\", \"--get-regex\", \"remote\\\\..*\\\\.url\"]);\n-\n-    let output = git.output().map_err(|err| format!(\"{err:?}\"))?;\n-    if !output.status.success() {\n-        return Err(\"failed to execute git config command\".to_owned());\n-    }\n-\n-    let stdout = String::from_utf8(output.stdout).map_err(|err| format!(\"{err:?}\"))?;\n+    let stdout = output_result(&mut git)?;\n \n     let rust_lang_remote = stdout\n         .lines()\n@@ -73,3 +86,48 @@ pub fn updated_master_branch(git_dir: Option<&Path>) -> Result<String, String> {\n     // We could implement smarter logic here in the future.\n     Ok(\"origin/master\".into())\n }\n+\n+/// Returns the files that have been modified in the current branch compared to the master branch.\n+/// The `extensions` parameter can be used to filter the files by their extension.\n+/// If `extensions` is empty, all files will be returned.\n+pub fn get_git_modified_files(\n+    git_dir: Option<&Path>,\n+    extensions: &Vec<&str>,\n+) -> Result<Option<Vec<String>>, String> {\n+    let Ok(updated_master) = updated_master_branch(git_dir) else { return Ok(None); };\n+\n+    let git = || {\n+        let mut git = Command::new(\"git\");\n+        if let Some(git_dir) = git_dir {\n+            git.current_dir(git_dir);\n+        }\n+        git\n+    };\n+\n+    let merge_base = output_result(git().arg(\"merge-base\").arg(&updated_master).arg(\"HEAD\"))?;\n+    let files = output_result(git().arg(\"diff-index\").arg(\"--name-only\").arg(merge_base.trim()))?\n+        .lines()\n+        .map(|s| s.trim().to_owned())\n+        .filter(|f| {\n+            Path::new(f).extension().map_or(false, |ext| {\n+                extensions.is_empty() || extensions.contains(&ext.to_str().unwrap())\n+            })\n+        })\n+        .collect();\n+    Ok(Some(files))\n+}\n+\n+/// Returns the files that haven't been added to git yet.\n+pub fn get_git_untracked_files(git_dir: Option<&Path>) -> Result<Option<Vec<String>>, String> {\n+    let Ok(_updated_master) = updated_master_branch(git_dir) else { return Ok(None); };\n+    let mut git = Command::new(\"git\");\n+    if let Some(git_dir) = git_dir {\n+        git.current_dir(git_dir);\n+    }\n+\n+    let files = output_result(git.arg(\"ls-files\").arg(\"--others\").arg(\"--exclude-standard\"))?\n+        .lines()\n+        .map(|s| s.trim().to_owned())\n+        .collect();\n+    Ok(Some(files))\n+}"}, {"sha": "deed6fbd4391fa165fa4beae1a110047a13ba201", "filename": "src/tools/compiletest/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Ftools%2Fcompiletest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Ftools%2Fcompiletest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2FCargo.toml?ref=2b3f260e74daa487cbaebc7e55a1f42da2568d23", "patch": "@@ -9,6 +9,7 @@ diff = \"0.1.10\"\n unified-diff = \"0.2.1\"\n getopts = \"0.2\"\n miropt-test-tools = { path = \"../miropt-test-tools\" }\n+build_helper = { path = \"../build_helper\" }\n tracing = \"0.1\"\n tracing-subscriber = { version = \"0.3.3\", default-features = false, features = [\"fmt\", \"env-filter\", \"smallvec\", \"parking_lot\", \"ansi\"] }\n regex = \"1.0\""}, {"sha": "7fe2e6257d9e78729f65455e00704064118e491e", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=2b3f260e74daa487cbaebc7e55a1f42da2568d23", "patch": "@@ -380,6 +380,9 @@ pub struct Config {\n     /// Whether to rerun tests even if the inputs are unchanged.\n     pub force_rerun: bool,\n \n+    /// Only rerun the tests that result has been modified accoring to Git status\n+    pub only_modified: bool,\n+\n     pub target_cfg: LazyCell<TargetCfg>,\n }\n "}, {"sha": "c648b2f12f1012a89dfe5e5d0b931c0d773517ab", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 50, "deletions": 6, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3f260e74daa487cbaebc7e55a1f42da2568d23/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=2b3f260e74daa487cbaebc7e55a1f42da2568d23", "patch": "@@ -8,15 +8,17 @@ extern crate test;\n use crate::common::{expected_output_path, output_base_dir, output_relative_path, UI_EXTENSIONS};\n use crate::common::{CompareMode, Config, Debugger, Mode, PassMode, TestPaths};\n use crate::util::logv;\n+use build_helper::git::{get_git_modified_files, get_git_untracked_files};\n+use core::panic;\n use getopts::Options;\n use lazycell::LazyCell;\n-use std::env;\n use std::ffi::OsString;\n use std::fs;\n use std::io::{self, ErrorKind};\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n use std::time::SystemTime;\n+use std::{env, vec};\n use test::ColorConfig;\n use tracing::*;\n use walkdir::WalkDir;\n@@ -145,9 +147,10 @@ pub fn parse_config(args: Vec<String>) -> Config {\n             \"\",\n             \"rustfix-coverage\",\n             \"enable this to generate a Rustfix coverage file, which is saved in \\\n-                `./<build_base>/rustfix_missing_coverage.txt`\",\n+            `./<build_base>/rustfix_missing_coverage.txt`\",\n         )\n         .optflag(\"\", \"force-rerun\", \"rerun tests even if the inputs are unchanged\")\n+        .optflag(\"\", \"only-modified\", \"only run tests that result been modified\")\n         .optflag(\"h\", \"help\", \"show this message\")\n         .reqopt(\"\", \"channel\", \"current Rust channel\", \"CHANNEL\")\n         .optopt(\"\", \"edition\", \"default Rust edition\", \"EDITION\");\n@@ -279,6 +282,7 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         lldb_python_dir: matches.opt_str(\"lldb-python-dir\"),\n         verbose: matches.opt_present(\"verbose\"),\n         quiet: matches.opt_present(\"quiet\"),\n+        only_modified: matches.opt_present(\"only-modified\"),\n         color,\n         remote_test_client: matches.opt_str(\"remote-test-client\").map(PathBuf::from),\n         compare_mode: matches.opt_str(\"compare-mode\").map(CompareMode::parse),\n@@ -521,8 +525,18 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n pub fn make_tests(config: &Config, tests: &mut Vec<test::TestDescAndFn>) {\n     debug!(\"making tests from {:?}\", config.src_base.display());\n     let inputs = common_inputs_stamp(config);\n-    collect_tests_from_dir(config, &config.src_base, &PathBuf::new(), &inputs, tests)\n-        .unwrap_or_else(|_| panic!(\"Could not read tests from {}\", config.src_base.display()));\n+    let modified_tests = modified_tests(config, &config.src_base).unwrap_or_else(|err| {\n+        panic!(\"modified_tests got error from dir: {}, error: {}\", config.src_base.display(), err)\n+    });\n+    collect_tests_from_dir(\n+        config,\n+        &config.src_base,\n+        &PathBuf::new(),\n+        &inputs,\n+        tests,\n+        &modified_tests,\n+    )\n+    .unwrap_or_else(|_| panic!(\"Could not read tests from {}\", config.src_base.display()));\n }\n \n /// Returns a stamp constructed from input files common to all test cases.\n@@ -561,12 +575,35 @@ fn common_inputs_stamp(config: &Config) -> Stamp {\n     stamp\n }\n \n+fn modified_tests(config: &Config, dir: &Path) -> Result<Vec<PathBuf>, String> {\n+    if !config.only_modified {\n+        return Ok(vec![]);\n+    }\n+    let files =\n+        get_git_modified_files(Some(dir), &vec![\"rs\", \"stderr\", \"fixed\"])?.unwrap_or(vec![]);\n+    // Add new test cases to the list, it will be convenient in daily development.\n+    let untracked_files = get_git_untracked_files(None)?.unwrap_or(vec![]);\n+\n+    let all_paths = [&files[..], &untracked_files[..]].concat();\n+    let full_paths = {\n+        let mut full_paths: Vec<PathBuf> = all_paths\n+            .into_iter()\n+            .map(|f| fs::canonicalize(&f).unwrap().with_extension(\"\").with_extension(\"rs\"))\n+            .collect();\n+        full_paths.dedup();\n+        full_paths.sort_unstable();\n+        full_paths\n+    };\n+    Ok(full_paths)\n+}\n+\n fn collect_tests_from_dir(\n     config: &Config,\n     dir: &Path,\n     relative_dir_path: &Path,\n     inputs: &Stamp,\n     tests: &mut Vec<test::TestDescAndFn>,\n+    modified_tests: &Vec<PathBuf>,\n ) -> io::Result<()> {\n     // Ignore directories that contain a file named `compiletest-ignore-dir`.\n     if dir.join(\"compiletest-ignore-dir\").exists() {\n@@ -597,7 +634,7 @@ fn collect_tests_from_dir(\n         let file = file?;\n         let file_path = file.path();\n         let file_name = file.file_name();\n-        if is_test(&file_name) {\n+        if is_test(&file_name) && (!config.only_modified || modified_tests.contains(&file_path)) {\n             debug!(\"found test file: {:?}\", file_path.display());\n             let paths =\n                 TestPaths { file: file_path, relative_dir: relative_dir_path.to_path_buf() };\n@@ -607,7 +644,14 @@ fn collect_tests_from_dir(\n             let relative_file_path = relative_dir_path.join(file.file_name());\n             if &file_name != \"auxiliary\" {\n                 debug!(\"found directory: {:?}\", file_path.display());\n-                collect_tests_from_dir(config, &file_path, &relative_file_path, inputs, tests)?;\n+                collect_tests_from_dir(\n+                    config,\n+                    &file_path,\n+                    &relative_file_path,\n+                    inputs,\n+                    tests,\n+                    modified_tests,\n+                )?;\n             }\n         } else {\n             debug!(\"found other file/directory: {:?}\", file_path.display());"}, {"sha": "95dd2b98e037ed1b49001ca610fa6a8a6e19d6ec", "filename": "tests/rustdoc-ui/intra-doc/errors.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2b3f260e74daa487cbaebc7e55a1f42da2568d23/tests%2Frustdoc-ui%2Fintra-doc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3f260e74daa487cbaebc7e55a1f42da2568d23/tests%2Frustdoc-ui%2Fintra-doc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Ferrors.rs?ref=2b3f260e74daa487cbaebc7e55a1f42da2568d23", "patch": "@@ -103,3 +103,19 @@ pub trait T {\n macro_rules! m {\n     () => {};\n }\n+\n+///[`TestEnum::Variant1::field_name`]\n+//~^ ERROR unresolved link\n+//~| NOTE variant `Variant1` has no such field\n+pub enum TestEnum {\n+    Variant1 {},\n+    Variant2 { field_name: u64 },\n+}\n+\n+///[`TestEnumNoFields::Variant1::field_name`]\n+//~^ ERROR unresolved link\n+//~| NOTE `Variant1` is a variant, not a module or type, and cannot have associated items\n+pub enum TestEnumNoFields {\n+    Variant1 (),\n+    Variant2 {},\n+}"}, {"sha": "1b2416d7da76570b745501df69df93a2b0e1e80a", "filename": "tests/rustdoc-ui/intra-doc/errors.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2b3f260e74daa487cbaebc7e55a1f42da2568d23/tests%2Frustdoc-ui%2Fintra-doc%2Ferrors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b3f260e74daa487cbaebc7e55a1f42da2568d23/tests%2Frustdoc-ui%2Fintra-doc%2Ferrors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Ferrors.stderr?ref=2b3f260e74daa487cbaebc7e55a1f42da2568d23", "patch": "@@ -142,6 +142,18 @@ error: unresolved link to `T::h`\n LL | /// [T::h!]\n    |      ^^^^^ the trait `T` has no macro named `h`\n \n+error: unresolved link to `TestEnum::Variant1::field_name`\n+  --> $DIR/errors.rs:107:6\n+   |\n+LL | ///[`TestEnum::Variant1::field_name`]\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ variant `Variant1` has no such field\n+\n+error: unresolved link to `TestEnumNoFields::Variant1::field_name`\n+  --> $DIR/errors.rs:115:6\n+   |\n+LL | ///[`TestEnumNoFields::Variant1::field_name`]\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `Variant1` is a variant, not a module or type, and cannot have associated items\n+\n error: unresolved link to `m`\n   --> $DIR/errors.rs:98:6\n    |\n@@ -153,5 +165,5 @@ help: to link to the macro, add an exclamation mark\n LL | /// [m!()]\n    |       +\n \n-error: aborting due to 20 previous errors\n+error: aborting due to 22 previous errors\n "}, {"sha": "c4dec703aed3ba8a948489923078fa875def2d2d", "filename": "tests/rustdoc/reexport-macro.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2b3f260e74daa487cbaebc7e55a1f42da2568d23/tests%2Frustdoc%2Freexport-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b3f260e74daa487cbaebc7e55a1f42da2568d23/tests%2Frustdoc%2Freexport-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Freexport-macro.rs?ref=2b3f260e74daa487cbaebc7e55a1f42da2568d23", "patch": "@@ -0,0 +1,23 @@\n+// Ensure that macros are correctly reexported and that they get both the comment from the\n+// `pub use` and from the macro.\n+\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/macro.foo.html'\n+// @!has - '//*[@class=\"toggle top-doc\"]/*[@class=\"docblock\"]' 'x y'\n+// @has - '//*[@class=\"toggle top-doc\"]/*[@class=\"docblock\"]' 'y'\n+#[macro_use]\n+mod my_module {\n+    /// y\n+    #[macro_export]\n+    macro_rules! foo {\n+        () => ();\n+    }\n+}\n+\n+// @has 'foo/another_mod/macro.bar.html'\n+// @has - '//*[@class=\"toggle top-doc\"]/*[@class=\"docblock\"]' 'x y'\n+pub mod another_mod {\n+    /// x\n+    pub use crate::foo as bar;\n+}"}]}