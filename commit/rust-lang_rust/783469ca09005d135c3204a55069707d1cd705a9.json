{"sha": "783469ca09005d135c3204a55069707d1cd705a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4MzQ2OWNhMDkwMDVkMTM1YzMyMDRhNTUwNjk3MDdkMWNkNzA1YTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-25T04:26:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-25T04:26:26Z"}, "message": "Auto merge of #63862 - Centril:match-cleanup, r=oli-obk\n\ntypeck: refactor patterns => `pat.rs`  + make the `def_bm` algo more declarative\n\nSpurred by the relative difficulty I had in working up an explanation of how default match bindings work in https://github.com/rust-lang/rust/pull/63118#issuecomment-524161584, this PR refactors the type checking of patterns into `pat.rs`.\n\nThe PR is probably best read commit-by-commit and includes various changes beyond the following, which are the most important highlights:\n\n- The algorithm for determining `def_bm` is encoded in a more declarative fashion now with important sub-steps divided into functions that make sense as logical units (and as described in the reference). This is done starting with *\"extract `is_no_ref_pat`.\"* to *\"extract `calc_default_binding_mode`\"*.\n\n- Dedicated functions like `check_pat_{lit,range,ident,tuple,box,ref,slice}` are then introduced for the various kinds of patterns to make things overall more readable.\n\n- `fn check_pat_top(...)` becomes the sole entry point to type checking patterns.\n\n   This will take care of initializing the default binding mode (hence: `def_bm`) to `BindByValue` and is called by all contexts that have a pattern that needs to be type checked (functions, `match`, `if let`, `let`, ...). The overall result is that the notion of `def_bm` is internal to checking patterns.\n\n- Various diagnostics are extracted to dedicated functions to disturb the flow of type checking logic less.\n\nr? @oli-obk", "tree": {"sha": "05bccc7ce12e8043c03bb0970bde11f11e3b943d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05bccc7ce12e8043c03bb0970bde11f11e3b943d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/783469ca09005d135c3204a55069707d1cd705a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/783469ca09005d135c3204a55069707d1cd705a9", "html_url": "https://github.com/rust-lang/rust/commit/783469ca09005d135c3204a55069707d1cd705a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/783469ca09005d135c3204a55069707d1cd705a9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5", "html_url": "https://github.com/rust-lang/rust/commit/9267119019b48b0c3c6fb44cd3cbab64b2a1a6b5"}, {"sha": "5a7e1cb46a05fd176e5488beb58f72a05f4b1a0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a7e1cb46a05fd176e5488beb58f72a05f4b1a0d", "html_url": "https://github.com/rust-lang/rust/commit/5a7e1cb46a05fd176e5488beb58f72a05f4b1a0d"}], "stats": {"total": 2102, "additions": 1129, "deletions": 973}, "files": [{"sha": "efc37cc04b212b1dd24f32f9418b206b901a04a5", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 965, "changes": 968, "blob_url": "https://github.com/rust-lang/rust/blob/783469ca09005d135c3204a55069707d1cd705a9/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783469ca09005d135c3204a55069707d1cd705a9/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=783469ca09005d135c3204a55069707d1cd705a9", "patch": "@@ -1,631 +1,12 @@\n use crate::check::{FnCtxt, Expectation, Diverges, Needs};\n use crate::check::coercion::CoerceMany;\n-use crate::util::nodemap::FxHashMap;\n-use errors::{Applicability, DiagnosticBuilder};\n-use rustc::hir::{self, PatKind, Pat, ExprKind};\n-use rustc::hir::def::{Res, DefKind, CtorKind};\n-use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n-use rustc::hir::ptr::P;\n-use rustc::infer;\n+use rustc::hir::{self, ExprKind};\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc::traits::{ObligationCause, ObligationCauseCode};\n-use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::ty::subst::Kind;\n-use syntax::ast;\n-use syntax::util::lev_distance::find_best_match_for_name;\n+use rustc::ty::Ty;\n use syntax_pos::Span;\n-use syntax_pos::hygiene::DesugaringKind;\n-\n-use std::collections::hash_map::Entry::{Occupied, Vacant};\n-use std::cmp;\n-\n-use super::report_unexpected_variant_res;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    /// `discrim_span` argument having a `Span` indicates that this pattern is part of a match\n-    /// expression arm guard, and it points to the match discriminant to add context in type errors.\n-    /// In the following example, `discrim_span` corresponds to the `a + b` expression:\n-    ///\n-    /// ```text\n-    /// error[E0308]: mismatched types\n-    ///  --> src/main.rs:5:9\n-    ///   |\n-    /// 4 |    let temp: usize = match a + b {\n-    ///   |                            ----- this expression has type `usize`\n-    /// 5 |         Ok(num) => num,\n-    ///   |         ^^^^^^^ expected usize, found enum `std::result::Result`\n-    ///   |\n-    ///   = note: expected type `usize`\n-    ///              found type `std::result::Result<_, _>`\n-    /// ```\n-    pub fn check_pat_walk(\n-        &self,\n-        pat: &'tcx hir::Pat,\n-        mut expected: Ty<'tcx>,\n-        mut def_bm: ty::BindingMode,\n-        discrim_span: Option<Span>,\n-    ) {\n-        let tcx = self.tcx;\n-\n-        debug!(\"check_pat_walk(pat={:?},expected={:?},def_bm={:?})\", pat, expected, def_bm);\n-\n-        let mut path_resolution = None;\n-        let is_non_ref_pat = match pat.node {\n-            PatKind::Struct(..) |\n-            PatKind::TupleStruct(..) |\n-            PatKind::Or(_) |\n-            PatKind::Tuple(..) |\n-            PatKind::Box(_) |\n-            PatKind::Range(..) |\n-            PatKind::Slice(..) => true,\n-            PatKind::Lit(ref lt) => {\n-                let ty = self.check_expr(lt);\n-                match ty.sty {\n-                    ty::Ref(..) => false,\n-                    _ => true,\n-                }\n-            }\n-            PatKind::Path(ref qpath) => {\n-                let resolution = self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span);\n-                path_resolution = Some(resolution);\n-                match resolution.0 {\n-                    Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) => false,\n-                    _ => true,\n-                }\n-            }\n-            PatKind::Wild |\n-            PatKind::Binding(..) |\n-            PatKind::Ref(..) => false,\n-        };\n-        if is_non_ref_pat {\n-            debug!(\"pattern is non reference pattern\");\n-            let mut exp_ty = self.resolve_type_vars_with_obligations(&expected);\n-\n-            // Peel off as many `&` or `&mut` from the discriminant as possible. For example,\n-            // for `match &&&mut Some(5)` the loop runs three times, aborting when it reaches\n-            // the `Some(5)` which is not of type Ref.\n-            //\n-            // For each ampersand peeled off, update the binding mode and push the original\n-            // type into the adjustments vector.\n-            //\n-            // See the examples in `ui/match-defbm*.rs`.\n-            let mut pat_adjustments = vec![];\n-            while let ty::Ref(_, inner_ty, inner_mutability) = exp_ty.sty {\n-                debug!(\"inspecting {:?}\", exp_ty);\n-\n-                debug!(\"current discriminant is Ref, inserting implicit deref\");\n-                // Preserve the reference type. We'll need it later during HAIR lowering.\n-                pat_adjustments.push(exp_ty);\n-\n-                exp_ty = inner_ty;\n-                def_bm = match def_bm {\n-                    // If default binding mode is by value, make it `ref` or `ref mut`\n-                    // (depending on whether we observe `&` or `&mut`).\n-                    ty::BindByValue(_) =>\n-                        ty::BindByReference(inner_mutability),\n-\n-                    // Once a `ref`, always a `ref`. This is because a `& &mut` can't mutate\n-                    // the underlying value.\n-                    ty::BindByReference(hir::Mutability::MutImmutable) =>\n-                        ty::BindByReference(hir::Mutability::MutImmutable),\n-\n-                    // When `ref mut`, stay a `ref mut` (on `&mut`) or downgrade to `ref`\n-                    // (on `&`).\n-                    ty::BindByReference(hir::Mutability::MutMutable) =>\n-                        ty::BindByReference(inner_mutability),\n-                };\n-            }\n-            expected = exp_ty;\n-\n-            if pat_adjustments.len() > 0 {\n-                debug!(\"default binding mode is now {:?}\", def_bm);\n-                self.inh.tables.borrow_mut()\n-                    .pat_adjustments_mut()\n-                    .insert(pat.hir_id, pat_adjustments);\n-            }\n-        } else if let PatKind::Ref(..) = pat.node {\n-            // When you encounter a `&pat` pattern, reset to \"by\n-            // value\". This is so that `x` and `y` here are by value,\n-            // as they appear to be:\n-            //\n-            // ```\n-            // match &(&22, &44) {\n-            //   (&x, &y) => ...\n-            // }\n-            // ```\n-            //\n-            // See issue #46688.\n-            def_bm = ty::BindByValue(hir::MutImmutable);\n-        }\n-\n-        // Lose mutability now that we know binding mode and discriminant type.\n-        let def_bm = def_bm;\n-        let expected = expected;\n-\n-        let ty = match pat.node {\n-            PatKind::Wild => {\n-                expected\n-            }\n-            PatKind::Lit(ref lt) => {\n-                // We've already computed the type above (when checking for a non-ref pat), so\n-                // avoid computing it again.\n-                let ty = self.node_ty(lt.hir_id);\n-\n-                // Byte string patterns behave the same way as array patterns\n-                // They can denote both statically and dynamically-sized byte arrays.\n-                let mut pat_ty = ty;\n-                if let hir::ExprKind::Lit(ref lt) = lt.node {\n-                    if let ast::LitKind::ByteStr(_) = lt.node {\n-                        let expected_ty = self.structurally_resolved_type(pat.span, expected);\n-                        if let ty::Ref(_, r_ty, _) = expected_ty.sty {\n-                            if let ty::Slice(_) = r_ty.sty {\n-                                pat_ty = tcx.mk_imm_ref(tcx.lifetimes.re_static,\n-                                                        tcx.mk_slice(tcx.types.u8))\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                // Somewhat surprising: in this case, the subtyping\n-                // relation goes the opposite way as the other\n-                // cases. Actually what we really want is not a subtyping\n-                // relation at all but rather that there exists a LUB (so\n-                // that they can be compared). However, in practice,\n-                // constants are always scalars or strings.  For scalars\n-                // subtyping is irrelevant, and for strings `ty` is\n-                // type is `&'static str`, so if we say that\n-                //\n-                //     &'static str <: expected\n-                //\n-                // then that's equivalent to there existing a LUB.\n-                if let Some(mut err) = self.demand_suptype_diag(pat.span, expected, pat_ty) {\n-                    err.emit_unless(discrim_span\n-                        .filter(|&s| {\n-                            // In the case of `if`- and `while`-expressions we've already checked\n-                            // that `scrutinee: bool`. We know that the pattern is `true`,\n-                            // so an error here would be a duplicate and from the wrong POV.\n-                            s.is_desugaring(DesugaringKind::CondTemporary)\n-                        })\n-                        .is_some());\n-                }\n-\n-                pat_ty\n-            }\n-            PatKind::Range(ref begin, ref end, _) => {\n-                let lhs_ty = self.check_expr(begin);\n-                let rhs_ty = self.check_expr(end);\n-\n-                // Check that both end-points are of numeric or char type.\n-                let numeric_or_char = |ty: Ty<'_>| {\n-                    ty.is_numeric()\n-                    || ty.is_char()\n-                    || ty.references_error()\n-                };\n-                let lhs_compat = numeric_or_char(lhs_ty);\n-                let rhs_compat = numeric_or_char(rhs_ty);\n-\n-                if !lhs_compat || !rhs_compat {\n-                    let span = if !lhs_compat && !rhs_compat {\n-                        pat.span\n-                    } else if !lhs_compat {\n-                        begin.span\n-                    } else {\n-                        end.span\n-                    };\n-\n-                    let mut err = struct_span_err!(\n-                        tcx.sess,\n-                        span,\n-                        E0029,\n-                        \"only char and numeric types are allowed in range patterns\"\n-                    );\n-                    err.span_label(span, \"ranges require char or numeric types\");\n-                    err.note(&format!(\"start type: {}\", self.ty_to_string(lhs_ty)));\n-                    err.note(&format!(\"end type: {}\", self.ty_to_string(rhs_ty)));\n-                    if tcx.sess.teach(&err.get_code().unwrap()) {\n-                        err.note(\n-                            \"In a match expression, only numbers and characters can be matched \\\n-                             against a range. This is because the compiler checks that the range \\\n-                             is non-empty at compile-time, and is unable to evaluate arbitrary \\\n-                             comparison functions. If you want to capture values of an orderable \\\n-                             type between two end-points, you can use a guard.\"\n-                         );\n-                    }\n-                    err.emit();\n-                    return;\n-                }\n-\n-                // Now that we know the types can be unified we find the unified type and use\n-                // it to type the entire expression.\n-                let common_type = self.resolve_vars_if_possible(&lhs_ty);\n-\n-                // Subtyping doesn't matter here, as the value is some kind of scalar.\n-                self.demand_eqtype_pat(pat.span, expected, lhs_ty, discrim_span);\n-                self.demand_eqtype_pat(pat.span, expected, rhs_ty, discrim_span);\n-                common_type\n-            }\n-            PatKind::Binding(ba, var_id, _, ref sub) => {\n-                let bm = if ba == hir::BindingAnnotation::Unannotated {\n-                    def_bm\n-                } else {\n-                    ty::BindingMode::convert(ba)\n-                };\n-                self.inh\n-                    .tables\n-                    .borrow_mut()\n-                    .pat_binding_modes_mut()\n-                    .insert(pat.hir_id, bm);\n-                debug!(\"check_pat_walk: pat.hir_id={:?} bm={:?}\", pat.hir_id, bm);\n-                let local_ty = self.local_ty(pat.span, pat.hir_id).decl_ty;\n-                match bm {\n-                    ty::BindByReference(mutbl) => {\n-                        // If the binding is like\n-                        //     ref x | ref const x | ref mut x\n-                        // then `x` is assigned a value of type `&M T` where M is the mutability\n-                        // and T is the expected type.\n-                        let region_var = self.next_region_var(infer::PatternRegion(pat.span));\n-                        let mt = ty::TypeAndMut { ty: expected, mutbl: mutbl };\n-                        let region_ty = tcx.mk_ref(region_var, mt);\n-\n-                        // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)` is\n-                        // required. However, we use equality, which is stronger. See (*) for\n-                        // an explanation.\n-                        self.demand_eqtype_pat(pat.span, region_ty, local_ty, discrim_span);\n-                    }\n-                    // Otherwise, the type of x is the expected type `T`.\n-                    ty::BindByValue(_) => {\n-                        // As above, `T <: typeof(x)` is required, but we\n-                        // use equality, see (*) below.\n-                        self.demand_eqtype_pat(pat.span, expected, local_ty, discrim_span);\n-                    }\n-                }\n-\n-                // If there are multiple arms, make sure they all agree on\n-                // what the type of the binding `x` ought to be.\n-                if var_id != pat.hir_id {\n-                    let vt = self.local_ty(pat.span, var_id).decl_ty;\n-                    self.demand_eqtype_pat(pat.span, vt, local_ty, discrim_span);\n-                }\n-\n-                if let Some(ref p) = *sub {\n-                    self.check_pat_walk(&p, expected, def_bm, discrim_span);\n-                }\n-\n-                local_ty\n-            }\n-            PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n-                self.check_pat_tuple_struct(\n-                    pat,\n-                    qpath,\n-                    &subpats,\n-                    ddpos,\n-                    expected,\n-                    def_bm,\n-                    discrim_span,\n-                )\n-            }\n-            PatKind::Path(ref qpath) => {\n-                self.check_pat_path(pat, path_resolution.unwrap(), qpath, expected)\n-            }\n-            PatKind::Struct(ref qpath, ref fields, etc) => {\n-                self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, discrim_span)\n-            }\n-            PatKind::Or(ref pats) => {\n-                let expected_ty = self.structurally_resolved_type(pat.span, expected);\n-                for pat in pats {\n-                    self.check_pat_walk(pat, expected, def_bm, discrim_span);\n-                }\n-                expected_ty\n-            }\n-            PatKind::Tuple(ref elements, ddpos) => {\n-                let mut expected_len = elements.len();\n-                if ddpos.is_some() {\n-                    // Require known type only when `..` is present.\n-                    if let ty::Tuple(ref tys) =\n-                            self.structurally_resolved_type(pat.span, expected).sty {\n-                        expected_len = tys.len();\n-                    }\n-                }\n-                let max_len = cmp::max(expected_len, elements.len());\n-\n-                let element_tys_iter = (0..max_len).map(|_| {\n-                    Kind::from(self.next_ty_var(\n-                        // FIXME: `MiscVariable` for now -- obtaining the span and name information\n-                        // from all tuple elements isn't trivial.\n-                        TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::TypeInference,\n-                            span: pat.span,\n-                        },\n-                    ))\n-                });\n-                let element_tys = tcx.mk_substs(element_tys_iter);\n-                let pat_ty = tcx.mk_ty(ty::Tuple(element_tys));\n-                if let Some(mut err) = self.demand_eqtype_diag(pat.span, expected, pat_ty) {\n-                    err.emit();\n-                    // Walk subpatterns with an expected type of `err` in this case to silence\n-                    // further errors being emitted when using the bindings. #50333\n-                    let element_tys_iter = (0..max_len).map(|_| tcx.types.err);\n-                    for (_, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                        self.check_pat_walk(elem, &tcx.types.err, def_bm, discrim_span);\n-                    }\n-                    tcx.mk_tup(element_tys_iter)\n-                } else {\n-                    for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                        self.check_pat_walk(\n-                            elem,\n-                            &element_tys[i].expect_ty(),\n-                            def_bm,\n-                            discrim_span,\n-                        );\n-                    }\n-                    pat_ty\n-                }\n-            }\n-            PatKind::Box(ref inner) => {\n-                let inner_ty = self.next_ty_var(TypeVariableOrigin {\n-                    kind: TypeVariableOriginKind::TypeInference,\n-                    span: inner.span,\n-                });\n-                let uniq_ty = tcx.mk_box(inner_ty);\n-\n-                if self.check_dereferencable(pat.span, expected, &inner) {\n-                    // Here, `demand::subtype` is good enough, but I don't\n-                    // think any errors can be introduced by using\n-                    // `demand::eqtype`.\n-                    self.demand_eqtype_pat(pat.span, expected, uniq_ty, discrim_span);\n-                    self.check_pat_walk(&inner, inner_ty, def_bm, discrim_span);\n-                    uniq_ty\n-                } else {\n-                    self.check_pat_walk(&inner, tcx.types.err, def_bm, discrim_span);\n-                    tcx.types.err\n-                }\n-            }\n-            PatKind::Ref(ref inner, mutbl) => {\n-                let expected = self.shallow_resolve(expected);\n-                if self.check_dereferencable(pat.span, expected, &inner) {\n-                    // `demand::subtype` would be good enough, but using\n-                    // `eqtype` turns out to be equally general. See (*)\n-                    // below for details.\n-\n-                    // Take region, inner-type from expected type if we\n-                    // can, to avoid creating needless variables.  This\n-                    // also helps with the bad interactions of the given\n-                    // hack detailed in (*) below.\n-                    debug!(\"check_pat_walk: expected={:?}\", expected);\n-                    let (rptr_ty, inner_ty) = match expected.sty {\n-                        ty::Ref(_, r_ty, r_mutbl) if r_mutbl == mutbl => {\n-                            (expected, r_ty)\n-                        }\n-                        _ => {\n-                            let inner_ty = self.next_ty_var(\n-                                TypeVariableOrigin {\n-                                    kind: TypeVariableOriginKind::TypeInference,\n-                                    span: inner.span,\n-                                }\n-                            );\n-                            let mt = ty::TypeAndMut { ty: inner_ty, mutbl: mutbl };\n-                            let region = self.next_region_var(infer::PatternRegion(pat.span));\n-                            let rptr_ty = tcx.mk_ref(region, mt);\n-                            debug!(\"check_pat_walk: demanding {:?} = {:?}\", expected, rptr_ty);\n-                            let err = self.demand_eqtype_diag(pat.span, expected, rptr_ty);\n-\n-                            // Look for a case like `fn foo(&foo: u32)` and suggest\n-                            // `fn foo(foo: &u32)`\n-                            if let Some(mut err) = err {\n-                                self.borrow_pat_suggestion(&mut err, &pat, &inner, &expected);\n-                                err.emit();\n-                            }\n-                            (rptr_ty, inner_ty)\n-                        }\n-                    };\n-\n-                    self.check_pat_walk(&inner, inner_ty, def_bm, discrim_span);\n-                    rptr_ty\n-                } else {\n-                    self.check_pat_walk(&inner, tcx.types.err, def_bm, discrim_span);\n-                    tcx.types.err\n-                }\n-            }\n-            PatKind::Slice(ref before, ref slice, ref after) => {\n-                let expected_ty = self.structurally_resolved_type(pat.span, expected);\n-                let (inner_ty, slice_ty) = match expected_ty.sty {\n-                    ty::Array(inner_ty, size) => {\n-                        if let Some(size) = size.try_eval_usize(tcx, self.param_env) {\n-                            let min_len = before.len() as u64 + after.len() as u64;\n-                            if slice.is_none() {\n-                                if min_len != size {\n-                                    struct_span_err!(\n-                                        tcx.sess, pat.span, E0527,\n-                                        \"pattern requires {} elements but array has {}\",\n-                                        min_len, size)\n-                                        .span_label(pat.span, format!(\"expected {} elements\", size))\n-                                        .emit();\n-                                }\n-                                (inner_ty, tcx.types.err)\n-                            } else if let Some(rest) = size.checked_sub(min_len) {\n-                                (inner_ty, tcx.mk_array(inner_ty, rest))\n-                            } else {\n-                                struct_span_err!(tcx.sess, pat.span, E0528,\n-                                        \"pattern requires at least {} elements but array has {}\",\n-                                        min_len, size)\n-                                    .span_label(pat.span,\n-                                        format!(\"pattern cannot match array of {} elements\", size))\n-                                    .emit();\n-                                (inner_ty, tcx.types.err)\n-                            }\n-                        } else {\n-                            struct_span_err!(\n-                                tcx.sess,\n-                                pat.span,\n-                                E0730,\n-                                \"cannot pattern-match on an array without a fixed length\",\n-                            ).emit();\n-                            (inner_ty, tcx.types.err)\n-                        }\n-                    }\n-                    ty::Slice(inner_ty) => (inner_ty, expected_ty),\n-                    _ => {\n-                        if !expected_ty.references_error() {\n-                            let mut err = struct_span_err!(\n-                                tcx.sess, pat.span, E0529,\n-                                \"expected an array or slice, found `{}`\",\n-                                expected_ty);\n-                            if let ty::Ref(_, ty, _) = expected_ty.sty {\n-                                match ty.sty {\n-                                    ty::Array(..) | ty::Slice(..) => {\n-                                        err.help(\"the semantics of slice patterns changed \\\n-                                                  recently; see issue #62254\");\n-                                    }\n-                                    _ => {}\n-                                }\n-                            }\n-\n-                            err.span_label( pat.span,\n-                                format!(\"pattern cannot match with input type `{}`\", expected_ty)\n-                            ).emit();\n-                        }\n-                        (tcx.types.err, tcx.types.err)\n-                    }\n-                };\n-\n-                for elt in before {\n-                    self.check_pat_walk(&elt, inner_ty, def_bm, discrim_span);\n-                }\n-                if let Some(ref slice) = *slice {\n-                    self.check_pat_walk(&slice, slice_ty, def_bm, discrim_span);\n-                }\n-                for elt in after {\n-                    self.check_pat_walk(&elt, inner_ty, def_bm, discrim_span);\n-                }\n-                expected_ty\n-            }\n-        };\n-\n-        self.write_ty(pat.hir_id, ty);\n-\n-        // (*) In most of the cases above (literals and constants being\n-        // the exception), we relate types using strict equality, even\n-        // though subtyping would be sufficient. There are a few reasons\n-        // for this, some of which are fairly subtle and which cost me\n-        // (nmatsakis) an hour or two debugging to remember, so I thought\n-        // I'd write them down this time.\n-        //\n-        // 1. There is no loss of expressiveness here, though it does\n-        // cause some inconvenience. What we are saying is that the type\n-        // of `x` becomes *exactly* what is expected. This can cause unnecessary\n-        // errors in some cases, such as this one:\n-        //\n-        // ```\n-        // fn foo<'x>(x: &'x int) {\n-        //    let a = 1;\n-        //    let mut z = x;\n-        //    z = &a;\n-        // }\n-        // ```\n-        //\n-        // The reason we might get an error is that `z` might be\n-        // assigned a type like `&'x int`, and then we would have\n-        // a problem when we try to assign `&a` to `z`, because\n-        // the lifetime of `&a` (i.e., the enclosing block) is\n-        // shorter than `'x`.\n-        //\n-        // HOWEVER, this code works fine. The reason is that the\n-        // expected type here is whatever type the user wrote, not\n-        // the initializer's type. In this case the user wrote\n-        // nothing, so we are going to create a type variable `Z`.\n-        // Then we will assign the type of the initializer (`&'x\n-        // int`) as a subtype of `Z`: `&'x int <: Z`. And hence we\n-        // will instantiate `Z` as a type `&'0 int` where `'0` is\n-        // a fresh region variable, with the constraint that `'x :\n-        // '0`.  So basically we're all set.\n-        //\n-        // Note that there are two tests to check that this remains true\n-        // (`regions-reassign-{match,let}-bound-pointer.rs`).\n-        //\n-        // 2. Things go horribly wrong if we use subtype. The reason for\n-        // THIS is a fairly subtle case involving bound regions. See the\n-        // `givens` field in `region_constraints`, as well as the test\n-        // `regions-relate-bound-regions-on-closures-to-inference-variables.rs`,\n-        // for details. Short version is that we must sometimes detect\n-        // relationships between specific region variables and regions\n-        // bound in a closure signature, and that detection gets thrown\n-        // off when we substitute fresh region variables here to enable\n-        // subtyping.\n-    }\n-\n-    fn borrow_pat_suggestion(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        pat: &Pat,\n-        inner: &Pat,\n-        expected: Ty<'tcx>,\n-    ) {\n-        let tcx = self.tcx;\n-        if let PatKind::Binding(..) = inner.node {\n-            let binding_parent_id = tcx.hir().get_parent_node(pat.hir_id);\n-            let binding_parent = tcx.hir().get(binding_parent_id);\n-            debug!(\"inner {:?} pat {:?} parent {:?}\", inner, pat, binding_parent);\n-            match binding_parent {\n-                hir::Node::Arg(hir::Arg { span, .. }) => {\n-                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(inner.span) {\n-                        err.span_suggestion(\n-                            *span,\n-                            &format!(\"did you mean `{}`\", snippet),\n-                            format!(\" &{}\", expected),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-                }\n-                hir::Node::Arm(_) |\n-                hir::Node::Pat(_) => {\n-                    // rely on match ergonomics or it might be nested `&&pat`\n-                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(inner.span) {\n-                        err.span_suggestion(\n-                            pat.span,\n-                            \"you can probably remove the explicit borrow\",\n-                            snippet,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n-                _ => {} // don't provide suggestions in other cases #55175\n-            }\n-        }\n-    }\n-\n-    pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &hir::Pat) -> bool {\n-        if let PatKind::Binding(..) = inner.node {\n-            if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true) {\n-                if let ty::Dynamic(..) = mt.ty.sty {\n-                    // This is \"x = SomeTrait\" being reduced from\n-                    // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n-                    let type_str = self.ty_to_string(expected);\n-                    let mut err = struct_span_err!(\n-                        self.tcx.sess,\n-                        span,\n-                        E0033,\n-                        \"type `{}` cannot be dereferenced\",\n-                        type_str\n-                    );\n-                    err.span_label(span, format!(\"type `{}` cannot be dereferenced\", type_str));\n-                    if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                        err.note(\"\\\n-This error indicates that a pointer to a trait type cannot be implicitly dereferenced by a \\\n-pattern. Every trait defines a type, but because the size of trait implementors isn't fixed, \\\n-this type has no compile-time size. Therefore, all accesses to trait types must be through \\\n-pointers. If you encounter this error you should try to avoid dereferencing the pointer.\n-\n-You can read more about trait objects in the Trait Objects section of the Reference: \\\n-https://doc.rust-lang.org/reference/types.html#trait-objects\");\n-                    }\n-                    err.emit();\n-                    return false\n-                }\n-            }\n-        }\n-        true\n-    }\n-\n     pub fn check_match(\n         &self,\n         expr: &'tcx hir::Expr,\n@@ -678,8 +59,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             let mut all_pats_diverge = Diverges::WarnedAlways;\n             for p in &arm.pats {\n                 self.diverges.set(Diverges::Maybe);\n-                let binding_mode = ty::BindingMode::BindByValue(hir::Mutability::MutImmutable);\n-                self.check_pat_walk(&p, discrim_ty, binding_mode, Some(discrim.span));\n+                self.check_pat_top(&p, discrim_ty, Some(discrim.span));\n                 all_pats_diverge &= self.diverges.get();\n             }\n \n@@ -1038,346 +418,4 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             discrim_ty\n         }\n     }\n-\n-    fn check_pat_struct(\n-        &self,\n-        pat: &'tcx hir::Pat,\n-        qpath: &hir::QPath,\n-        fields: &'tcx [hir::FieldPat],\n-        etc: bool,\n-        expected: Ty<'tcx>,\n-        def_bm: ty::BindingMode,\n-        discrim_span: Option<Span>,\n-    ) -> Ty<'tcx> {\n-        // Resolve the path and check the definition for errors.\n-        let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(qpath, pat.hir_id)\n-        {\n-            variant_ty\n-        } else {\n-            for field in fields {\n-                self.check_pat_walk(&field.pat, self.tcx.types.err, def_bm, discrim_span);\n-            }\n-            return self.tcx.types.err;\n-        };\n-\n-        // Type-check the path.\n-        self.demand_eqtype_pat(pat.span, expected, pat_ty, discrim_span);\n-\n-        // Type-check subpatterns.\n-        if self.check_struct_pat_fields(pat_ty, pat.hir_id, pat.span, variant, fields, etc, def_bm)\n-        {\n-            pat_ty\n-        } else {\n-            self.tcx.types.err\n-        }\n-    }\n-\n-    fn check_pat_path(\n-        &self,\n-        pat: &hir::Pat,\n-        path_resolution: (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment]),\n-        qpath: &hir::QPath,\n-        expected: Ty<'tcx>,\n-    ) -> Ty<'tcx> {\n-        let tcx = self.tcx;\n-\n-        // We have already resolved the path.\n-        let (res, opt_ty, segments) = path_resolution;\n-        match res {\n-            Res::Err => {\n-                self.set_tainted_by_errors();\n-                return tcx.types.err;\n-            }\n-            Res::Def(DefKind::Method, _) |\n-            Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _) |\n-            Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) => {\n-                report_unexpected_variant_res(tcx, res, pat.span, qpath);\n-                return tcx.types.err;\n-            }\n-            Res::Def(DefKind::Ctor(_, CtorKind::Const), _) | Res::SelfCtor(..) |\n-            Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) => {} // OK\n-            _ => bug!(\"unexpected pattern resolution: {:?}\", res)\n-        }\n-\n-        // Type-check the path.\n-        let pat_ty = self.instantiate_value_path(segments, opt_ty, res, pat.span, pat.hir_id).0;\n-        self.demand_suptype(pat.span, expected, pat_ty);\n-        pat_ty\n-    }\n-\n-    fn check_pat_tuple_struct(\n-        &self,\n-        pat: &hir::Pat,\n-        qpath: &hir::QPath,\n-        subpats: &'tcx [P<hir::Pat>],\n-        ddpos: Option<usize>,\n-        expected: Ty<'tcx>,\n-        def_bm: ty::BindingMode,\n-        match_arm_pat_span: Option<Span>,\n-    ) -> Ty<'tcx> {\n-        let tcx = self.tcx;\n-        let on_error = || {\n-            for pat in subpats {\n-                self.check_pat_walk(&pat, tcx.types.err, def_bm, match_arm_pat_span);\n-            }\n-        };\n-        let report_unexpected_res = |res: Res| {\n-            let msg = format!(\"expected tuple struct/variant, found {} `{}`\",\n-                              res.descr(),\n-                              hir::print::to_string(tcx.hir(), |s| s.print_qpath(qpath, false)));\n-            let mut err = struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg);\n-            match (res, &pat.node) {\n-                (Res::Def(DefKind::Fn, _), _) | (Res::Def(DefKind::Method, _), _) => {\n-                    err.span_label(pat.span, \"`fn` calls are not allowed in patterns\");\n-                    err.help(\"for more information, visit \\\n-                              https://doc.rust-lang.org/book/ch18-00-patterns.html\");\n-                }\n-                _ => {\n-                    err.span_label(pat.span, \"not a tuple variant or struct\");\n-                }\n-            }\n-            err.emit();\n-            on_error();\n-        };\n-\n-        // Resolve the path and check the definition for errors.\n-        let (res, opt_ty, segments) = self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span);\n-        if res == Res::Err {\n-            self.set_tainted_by_errors();\n-            on_error();\n-            return self.tcx.types.err;\n-        }\n-\n-        // Type-check the path.\n-        let (pat_ty, res) = self.instantiate_value_path(segments, opt_ty, res, pat.span,\n-            pat.hir_id);\n-        if !pat_ty.is_fn() {\n-            report_unexpected_res(res);\n-            return self.tcx.types.err;\n-        }\n-\n-        let variant = match res {\n-            Res::Err => {\n-                self.set_tainted_by_errors();\n-                on_error();\n-                return tcx.types.err;\n-            }\n-            Res::Def(DefKind::AssocConst, _) | Res::Def(DefKind::Method, _) => {\n-                report_unexpected_res(res);\n-                return tcx.types.err;\n-            }\n-            Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) => {\n-                tcx.expect_variant_res(res)\n-            }\n-            _ => bug!(\"unexpected pattern resolution: {:?}\", res)\n-        };\n-\n-        // Replace constructor type with constructed type for tuple struct patterns.\n-        let pat_ty = pat_ty.fn_sig(tcx).output();\n-        let pat_ty = pat_ty.no_bound_vars().expect(\"expected fn type\");\n-\n-        self.demand_eqtype_pat(pat.span, expected, pat_ty, match_arm_pat_span);\n-\n-        // Type-check subpatterns.\n-        if subpats.len() == variant.fields.len() ||\n-                subpats.len() < variant.fields.len() && ddpos.is_some() {\n-            let substs = match pat_ty.sty {\n-                ty::Adt(_, substs) => substs,\n-                _ => bug!(\"unexpected pattern type {:?}\", pat_ty),\n-            };\n-            for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n-                let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n-                self.check_pat_walk(&subpat, field_ty, def_bm, match_arm_pat_span);\n-\n-                self.tcx.check_stability(variant.fields[i].did, Some(pat.hir_id), subpat.span);\n-            }\n-        } else {\n-            let subpats_ending = if subpats.len() == 1 { \"\" } else { \"s\" };\n-            let fields_ending = if variant.fields.len() == 1 { \"\" } else { \"s\" };\n-            struct_span_err!(tcx.sess, pat.span, E0023,\n-                             \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n-                             subpats.len(), subpats_ending, res.descr(),\n-                             variant.fields.len(),  fields_ending)\n-                .span_label(pat.span, format!(\"expected {} field{}, found {}\",\n-                                              variant.fields.len(), fields_ending, subpats.len()))\n-                .emit();\n-            on_error();\n-            return tcx.types.err;\n-        }\n-        pat_ty\n-    }\n-\n-    fn check_struct_pat_fields(\n-        &self,\n-        adt_ty: Ty<'tcx>,\n-        pat_id: hir::HirId,\n-        span: Span,\n-        variant: &'tcx ty::VariantDef,\n-        fields: &'tcx [hir::FieldPat],\n-        etc: bool,\n-        def_bm: ty::BindingMode,\n-    ) -> bool {\n-        let tcx = self.tcx;\n-\n-        let (substs, adt) = match adt_ty.sty {\n-            ty::Adt(adt, substs) => (substs, adt),\n-            _ => span_bug!(span, \"struct pattern is not an ADT\")\n-        };\n-        let kind_name = adt.variant_descr();\n-\n-        // Index the struct fields' types.\n-        let field_map = variant.fields\n-            .iter()\n-            .enumerate()\n-            .map(|(i, field)| (field.ident.modern(), (i, field)))\n-            .collect::<FxHashMap<_, _>>();\n-\n-        // Keep track of which fields have already appeared in the pattern.\n-        let mut used_fields = FxHashMap::default();\n-        let mut no_field_errors = true;\n-\n-        let mut inexistent_fields = vec![];\n-        // Typecheck each field.\n-        for field in fields {\n-            let span = field.span;\n-            let ident = tcx.adjust_ident(field.ident, variant.def_id);\n-            let field_ty = match used_fields.entry(ident) {\n-                Occupied(occupied) => {\n-                    struct_span_err!(tcx.sess, span, E0025,\n-                                     \"field `{}` bound multiple times \\\n-                                      in the pattern\",\n-                                     field.ident)\n-                        .span_label(span,\n-                                    format!(\"multiple uses of `{}` in pattern\", field.ident))\n-                        .span_label(*occupied.get(), format!(\"first use of `{}`\", field.ident))\n-                        .emit();\n-                    no_field_errors = false;\n-                    tcx.types.err\n-                }\n-                Vacant(vacant) => {\n-                    vacant.insert(span);\n-                    field_map.get(&ident)\n-                        .map(|(i, f)| {\n-                            self.write_field_index(field.hir_id, *i);\n-                            self.tcx.check_stability(f.did, Some(pat_id), span);\n-                            self.field_ty(span, f, substs)\n-                        })\n-                        .unwrap_or_else(|| {\n-                            inexistent_fields.push(field.ident);\n-                            no_field_errors = false;\n-                            tcx.types.err\n-                        })\n-                }\n-            };\n-\n-            self.check_pat_walk(&field.pat, field_ty, def_bm, None);\n-        }\n-        let mut unmentioned_fields = variant.fields\n-                .iter()\n-                .map(|field| field.ident.modern())\n-                .filter(|ident| !used_fields.contains_key(&ident))\n-                .collect::<Vec<_>>();\n-        if inexistent_fields.len() > 0 && !variant.recovered {\n-            let (field_names, t, plural) = if inexistent_fields.len() == 1 {\n-                (format!(\"a field named `{}`\", inexistent_fields[0]), \"this\", \"\")\n-            } else {\n-                (format!(\"fields named {}\",\n-                         inexistent_fields.iter()\n-                            .map(|ident| format!(\"`{}`\", ident))\n-                            .collect::<Vec<String>>()\n-                            .join(\", \")), \"these\", \"s\")\n-            };\n-            let spans = inexistent_fields.iter().map(|ident| ident.span).collect::<Vec<_>>();\n-            let mut err = struct_span_err!(tcx.sess,\n-                                           spans,\n-                                           E0026,\n-                                           \"{} `{}` does not have {}\",\n-                                           kind_name,\n-                                           tcx.def_path_str(variant.def_id),\n-                                           field_names);\n-            if let Some(ident) = inexistent_fields.last() {\n-                err.span_label(ident.span,\n-                               format!(\"{} `{}` does not have {} field{}\",\n-                                       kind_name,\n-                                       tcx.def_path_str(variant.def_id),\n-                                       t,\n-                                       plural));\n-                if plural == \"\" {\n-                    let input = unmentioned_fields.iter().map(|field| &field.name);\n-                    let suggested_name =\n-                        find_best_match_for_name(input, &ident.as_str(), None);\n-                    if let Some(suggested_name) = suggested_name {\n-                        err.span_suggestion(\n-                            ident.span,\n-                            \"a field with a similar name exists\",\n-                            suggested_name.to_string(),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-\n-                        // we don't want to throw `E0027` in case we have thrown `E0026` for them\n-                        unmentioned_fields.retain(|&x| x.as_str() != suggested_name.as_str());\n-                    }\n-                }\n-            }\n-            if tcx.sess.teach(&err.get_code().unwrap()) {\n-                err.note(\n-                    \"This error indicates that a struct pattern attempted to \\\n-                     extract a non-existent field from a struct. Struct fields \\\n-                     are identified by the name used before the colon : so struct \\\n-                     patterns should resemble the declaration of the struct type \\\n-                     being matched.\\n\\n\\\n-                     If you are using shorthand field patterns but want to refer \\\n-                     to the struct field by a different name, you should rename \\\n-                     it explicitly.\"\n-                );\n-            }\n-            err.emit();\n-        }\n-\n-        // Require `..` if struct has non_exhaustive attribute.\n-        if variant.is_field_list_non_exhaustive() && !adt.did.is_local() && !etc {\n-            span_err!(tcx.sess, span, E0638,\n-                      \"`..` required with {} marked as non-exhaustive\",\n-                      kind_name);\n-        }\n-\n-        // Report an error if incorrect number of the fields were specified.\n-        if kind_name == \"union\" {\n-            if fields.len() != 1 {\n-                tcx.sess.span_err(span, \"union patterns should have exactly one field\");\n-            }\n-            if etc {\n-                tcx.sess.span_err(span, \"`..` cannot be used in union patterns\");\n-            }\n-        } else if !etc {\n-            if unmentioned_fields.len() > 0 {\n-                let field_names = if unmentioned_fields.len() == 1 {\n-                    format!(\"field `{}`\", unmentioned_fields[0])\n-                } else {\n-                    format!(\"fields {}\",\n-                            unmentioned_fields.iter()\n-                                .map(|name| format!(\"`{}`\", name))\n-                                .collect::<Vec<String>>()\n-                                .join(\", \"))\n-                };\n-                let mut diag = struct_span_err!(tcx.sess, span, E0027,\n-                                                \"pattern does not mention {}\",\n-                                                field_names);\n-                diag.span_label(span, format!(\"missing {}\", field_names));\n-                if variant.ctor_kind == CtorKind::Fn {\n-                    diag.note(\"trying to match a tuple variant with a struct variant pattern\");\n-                }\n-                if tcx.sess.teach(&diag.get_code().unwrap()) {\n-                    diag.note(\n-                        \"This error indicates that a pattern for a struct fails to specify a \\\n-                         sub-pattern for every one of the struct's fields. Ensure that each field \\\n-                         from the struct's definition is mentioned in the pattern, or use `..` to \\\n-                         ignore unwanted fields.\"\n-                    );\n-                }\n-                diag.emit();\n-            }\n-        }\n-        no_field_errors\n-    }\n }"}, {"sha": "c4dbe97a7bd96554e0efb32737a5e76db9632a72", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/783469ca09005d135c3204a55069707d1cd705a9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783469ca09005d135c3204a55069707d1cd705a9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=783469ca09005d135c3204a55069707d1cd705a9", "patch": "@@ -70,6 +70,7 @@ type parameter).\n mod autoderef;\n pub mod dropck;\n pub mod _match;\n+mod pat;\n pub mod writeback;\n mod regionck;\n pub mod coercion;\n@@ -1103,8 +1104,7 @@ fn check_fn<'a, 'tcx>(\n     // Add formal parameters.\n     for (arg_ty, arg) in fn_sig.inputs().iter().zip(&body.arguments) {\n         // Check the pattern.\n-        let binding_mode = ty::BindingMode::BindByValue(hir::Mutability::MutImmutable);\n-        fcx.check_pat_walk(&arg.pat, arg_ty, binding_mode, None);\n+        fcx.check_pat_top(&arg.pat, arg_ty, None);\n \n         // Check that argument is Sized.\n         // The check for a non-trivial pattern is a hack to avoid duplicate warnings\n@@ -3630,12 +3630,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        self.check_pat_walk(\n-            &local.pat,\n-            t,\n-            ty::BindingMode::BindByValue(hir::Mutability::MutImmutable),\n-            None,\n-        );\n+        self.check_pat_top(&local.pat, t, None);\n         let pat_ty = self.node_ty(local.pat.hir_id);\n         if pat_ty.references_error() {\n             self.write_ty(local.hir_id, pat_ty);"}, {"sha": "3f6fc95360a5eb4607c08a96308df73e75e072a4", "filename": "src/librustc_typeck/check/pat.rs", "status": "added", "additions": 1123, "deletions": 0, "changes": 1123, "blob_url": "https://github.com/rust-lang/rust/blob/783469ca09005d135c3204a55069707d1cd705a9/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783469ca09005d135c3204a55069707d1cd705a9/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=783469ca09005d135c3204a55069707d1cd705a9", "patch": "@@ -0,0 +1,1123 @@\n+use crate::check::FnCtxt;\n+use crate::util::nodemap::FxHashMap;\n+use errors::{Applicability, DiagnosticBuilder};\n+use rustc::hir::{self, PatKind, Pat, HirId};\n+use rustc::hir::def::{Res, DefKind, CtorKind};\n+use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n+use rustc::hir::ptr::P;\n+use rustc::infer;\n+use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc::ty::{self, Ty, BindingMode, TypeFoldable};\n+use rustc::ty::subst::Kind;\n+use syntax::ast;\n+use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax_pos::Span;\n+use syntax_pos::hygiene::DesugaringKind;\n+\n+use std::collections::hash_map::Entry::{Occupied, Vacant};\n+use std::cmp;\n+\n+use super::report_unexpected_variant_res;\n+\n+const CANNOT_IMPLICITLY_DEREF_POINTER_TRAIT_OBJ: &str = \"\\\n+This error indicates that a pointer to a trait type cannot be implicitly dereferenced by a \\\n+pattern. Every trait defines a type, but because the size of trait implementors isn't fixed, \\\n+this type has no compile-time size. Therefore, all accesses to trait types must be through \\\n+pointers. If you encounter this error you should try to avoid dereferencing the pointer.\n+\n+You can read more about trait objects in the Trait Objects section of the Reference: \\\n+https://doc.rust-lang.org/reference/types.html#trait-objects\";\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    pub fn check_pat_top(&self, pat: &'tcx Pat, expected: Ty<'tcx>, discrim_span: Option<Span>) {\n+        let def_bm = BindingMode::BindByValue(hir::Mutability::MutImmutable);\n+        self.check_pat(pat, expected, def_bm, discrim_span);\n+    }\n+\n+    /// `discrim_span` argument having a `Span` indicates that this pattern is part of a match\n+    /// expression arm guard, and it points to the match discriminant to add context in type errors.\n+    /// In the following example, `discrim_span` corresponds to the `a + b` expression:\n+    ///\n+    /// ```text\n+    /// error[E0308]: mismatched types\n+    ///  --> src/main.rs:5:9\n+    ///   |\n+    /// 4 |    let temp: usize = match a + b {\n+    ///   |                            ----- this expression has type `usize`\n+    /// 5 |         Ok(num) => num,\n+    ///   |         ^^^^^^^ expected usize, found enum `std::result::Result`\n+    ///   |\n+    ///   = note: expected type `usize`\n+    ///              found type `std::result::Result<_, _>`\n+    /// ```\n+    fn check_pat(\n+        &self,\n+        pat: &'tcx Pat,\n+        expected: Ty<'tcx>,\n+        def_bm: BindingMode,\n+        discrim_span: Option<Span>,\n+    ) {\n+        debug!(\"check_pat(pat={:?},expected={:?},def_bm={:?})\", pat, expected, def_bm);\n+\n+        let path_resolution = match &pat.node {\n+            PatKind::Path(qpath) => Some(self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span)),\n+            _ => None,\n+        };\n+        let is_nrp = self.is_non_ref_pat(pat, path_resolution.map(|(res, ..)| res));\n+        let (expected, def_bm) = self.calc_default_binding_mode(pat, expected, def_bm, is_nrp);\n+\n+        let ty = match &pat.node {\n+            PatKind::Wild => expected,\n+            PatKind::Lit(lt) => self.check_pat_lit(pat.span, lt, expected, discrim_span),\n+            PatKind::Range(begin, end, _) => {\n+                match self.check_pat_range(pat.span, begin, end, expected, discrim_span) {\n+                    None => return,\n+                    Some(ty) => ty,\n+                }\n+            }\n+            PatKind::Binding(ba, var_id, _, sub) => {\n+                let sub = sub.as_deref();\n+                self.check_pat_ident(pat, *ba, *var_id, sub, expected, def_bm, discrim_span)\n+            }\n+            PatKind::TupleStruct(qpath, subpats, ddpos) => {\n+                self.check_pat_tuple_struct(\n+                    pat,\n+                    qpath,\n+                    subpats,\n+                    *ddpos,\n+                    expected,\n+                    def_bm,\n+                    discrim_span,\n+                )\n+            }\n+            PatKind::Path(qpath) => {\n+                self.check_pat_path(pat, path_resolution.unwrap(), qpath, expected)\n+            }\n+            PatKind::Struct(qpath, fields, etc) => {\n+                self.check_pat_struct(pat, qpath, fields, *etc, expected, def_bm, discrim_span)\n+            }\n+            PatKind::Or(pats) => {\n+                let expected_ty = self.structurally_resolved_type(pat.span, expected);\n+                for pat in pats {\n+                    self.check_pat(pat, expected, def_bm, discrim_span);\n+                }\n+                expected_ty\n+            }\n+            PatKind::Tuple(elements, ddpos) => {\n+                self.check_pat_tuple(pat.span, elements, *ddpos, expected, def_bm, discrim_span)\n+            }\n+            PatKind::Box(inner) => {\n+                self.check_pat_box(pat.span, inner, expected, def_bm, discrim_span)\n+            }\n+            PatKind::Ref(inner, mutbl) => {\n+                self.check_pat_ref(pat, inner, *mutbl, expected, def_bm, discrim_span)\n+            }\n+            PatKind::Slice(before, slice, after) => {\n+                let slice = slice.as_deref();\n+                self.check_pat_slice(pat.span, before, slice, after, expected, def_bm, discrim_span)\n+            }\n+        };\n+\n+        self.write_ty(pat.hir_id, ty);\n+\n+        // (note_1): In most of the cases where (note_1) is referenced\n+        // (literals and constants being the exception), we relate types\n+        // using strict equality, even though subtyping would be sufficient.\n+        // There are a few reasons for this, some of which are fairly subtle\n+        // and which cost me (nmatsakis) an hour or two debugging to remember,\n+        // so I thought I'd write them down this time.\n+        //\n+        // 1. There is no loss of expressiveness here, though it does\n+        // cause some inconvenience. What we are saying is that the type\n+        // of `x` becomes *exactly* what is expected. This can cause unnecessary\n+        // errors in some cases, such as this one:\n+        //\n+        // ```\n+        // fn foo<'x>(x: &'x int) {\n+        //    let a = 1;\n+        //    let mut z = x;\n+        //    z = &a;\n+        // }\n+        // ```\n+        //\n+        // The reason we might get an error is that `z` might be\n+        // assigned a type like `&'x int`, and then we would have\n+        // a problem when we try to assign `&a` to `z`, because\n+        // the lifetime of `&a` (i.e., the enclosing block) is\n+        // shorter than `'x`.\n+        //\n+        // HOWEVER, this code works fine. The reason is that the\n+        // expected type here is whatever type the user wrote, not\n+        // the initializer's type. In this case the user wrote\n+        // nothing, so we are going to create a type variable `Z`.\n+        // Then we will assign the type of the initializer (`&'x\n+        // int`) as a subtype of `Z`: `&'x int <: Z`. And hence we\n+        // will instantiate `Z` as a type `&'0 int` where `'0` is\n+        // a fresh region variable, with the constraint that `'x :\n+        // '0`.  So basically we're all set.\n+        //\n+        // Note that there are two tests to check that this remains true\n+        // (`regions-reassign-{match,let}-bound-pointer.rs`).\n+        //\n+        // 2. Things go horribly wrong if we use subtype. The reason for\n+        // THIS is a fairly subtle case involving bound regions. See the\n+        // `givens` field in `region_constraints`, as well as the test\n+        // `regions-relate-bound-regions-on-closures-to-inference-variables.rs`,\n+        // for details. Short version is that we must sometimes detect\n+        // relationships between specific region variables and regions\n+        // bound in a closure signature, and that detection gets thrown\n+        // off when we substitute fresh region variables here to enable\n+        // subtyping.\n+    }\n+\n+    /// Compute the new expected type and default binding mode from the old ones\n+    /// as well as the pattern form we are currently checking.\n+    fn calc_default_binding_mode(\n+        &self,\n+        pat: &'tcx Pat,\n+        expected: Ty<'tcx>,\n+        def_bm: BindingMode,\n+        is_non_ref_pat: bool,\n+    ) -> (Ty<'tcx>, BindingMode) {\n+        if is_non_ref_pat {\n+            debug!(\"pattern is non reference pattern\");\n+            self.peel_off_references(pat, expected, def_bm)\n+        } else {\n+            // When you encounter a `&pat` pattern, reset to \"by\n+            // value\". This is so that `x` and `y` here are by value,\n+            // as they appear to be:\n+            //\n+            // ```\n+            // match &(&22, &44) {\n+            //   (&x, &y) => ...\n+            // }\n+            // ```\n+            //\n+            // See issue #46688.\n+            let def_bm = match pat.node {\n+                PatKind::Ref(..) => ty::BindByValue(hir::MutImmutable),\n+                _ => def_bm,\n+            };\n+            (expected, def_bm)\n+        }\n+    }\n+\n+    /// Is the pattern a \"non reference pattern\"?\n+    /// When the pattern is a path pattern, `opt_path_res` must be `Some(res)`.\n+    fn is_non_ref_pat(&self, pat: &'tcx Pat, opt_path_res: Option<Res>) -> bool {\n+        match pat.node {\n+            PatKind::Struct(..) |\n+            PatKind::TupleStruct(..) |\n+            PatKind::Or(_) |\n+            PatKind::Tuple(..) |\n+            PatKind::Box(_) |\n+            PatKind::Range(..) |\n+            PatKind::Slice(..) => true,\n+            PatKind::Lit(ref lt) => {\n+                let ty = self.check_expr(lt);\n+                match ty.sty {\n+                    ty::Ref(..) => false,\n+                    _ => true,\n+                }\n+            }\n+            PatKind::Path(_) => {\n+                match opt_path_res.unwrap() {\n+                    Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) => false,\n+                    _ => true,\n+                }\n+            }\n+            PatKind::Wild |\n+            PatKind::Binding(..) |\n+            PatKind::Ref(..) => false,\n+        }\n+    }\n+\n+    /// Peel off as many immediately nested `& mut?` from the expected type as possible\n+    /// and return the new expected type and binding default binding mode.\n+    /// The adjustments vector, if non-empty is stored in a table.\n+    fn peel_off_references(\n+        &self,\n+        pat: &'tcx Pat,\n+        expected: Ty<'tcx>,\n+        mut def_bm: BindingMode,\n+    ) -> (Ty<'tcx>, BindingMode) {\n+        let mut expected = self.resolve_type_vars_with_obligations(&expected);\n+\n+        // Peel off as many `&` or `&mut` from the scrutinee type as possible. For example,\n+        // for `match &&&mut Some(5)` the loop runs three times, aborting when it reaches\n+        // the `Some(5)` which is not of type Ref.\n+        //\n+        // For each ampersand peeled off, update the binding mode and push the original\n+        // type into the adjustments vector.\n+        //\n+        // See the examples in `ui/match-defbm*.rs`.\n+        let mut pat_adjustments = vec![];\n+        while let ty::Ref(_, inner_ty, inner_mutability) = expected.sty {\n+            debug!(\"inspecting {:?}\", expected);\n+\n+            debug!(\"current discriminant is Ref, inserting implicit deref\");\n+            // Preserve the reference type. We'll need it later during HAIR lowering.\n+            pat_adjustments.push(expected);\n+\n+            expected = inner_ty;\n+            def_bm = ty::BindByReference(match def_bm {\n+                // If default binding mode is by value, make it `ref` or `ref mut`\n+                // (depending on whether we observe `&` or `&mut`).\n+                ty::BindByValue(_) |\n+                // When `ref mut`, stay a `ref mut` (on `&mut`) or downgrade to `ref` (on `&`).\n+                ty::BindByReference(hir::Mutability::MutMutable) => inner_mutability,\n+                // Once a `ref`, always a `ref`.\n+                // This is because a `& &mut` cannot mutate the underlying value.\n+                ty::BindByReference(m @ hir::Mutability::MutImmutable) => m,\n+            });\n+        }\n+\n+        if pat_adjustments.len() > 0 {\n+            debug!(\"default binding mode is now {:?}\", def_bm);\n+            self.inh.tables.borrow_mut()\n+                .pat_adjustments_mut()\n+                .insert(pat.hir_id, pat_adjustments);\n+        }\n+\n+        (expected, def_bm)\n+    }\n+\n+    fn check_pat_lit(\n+        &self,\n+        span: Span,\n+        lt: &hir::Expr,\n+        expected: Ty<'tcx>,\n+        discrim_span: Option<Span>,\n+    ) -> Ty<'tcx> {\n+        // We've already computed the type above (when checking for a non-ref pat),\n+        // so avoid computing it again.\n+        let ty = self.node_ty(lt.hir_id);\n+\n+        // Byte string patterns behave the same way as array patterns\n+        // They can denote both statically and dynamically-sized byte arrays.\n+        let mut pat_ty = ty;\n+        if let hir::ExprKind::Lit(ref lt) = lt.node {\n+            if let ast::LitKind::ByteStr(_) = lt.node {\n+                let expected_ty = self.structurally_resolved_type(span, expected);\n+                if let ty::Ref(_, r_ty, _) = expected_ty.sty {\n+                    if let ty::Slice(_) = r_ty.sty {\n+                        let tcx = self.tcx;\n+                        pat_ty = tcx.mk_imm_ref(\n+                            tcx.lifetimes.re_static,\n+                            tcx.mk_slice(tcx.types.u8),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Somewhat surprising: in this case, the subtyping relation goes the\n+        // opposite way as the other cases. Actually what we really want is not\n+        // a subtyping relation at all but rather that there exists a LUB\n+        // (so that they can be compared). However, in practice, constants are\n+        // always scalars or strings. For scalars subtyping is irrelevant,\n+        // and for strings `ty` is type is `&'static str`, so if we say that\n+        //\n+        //     &'static str <: expected\n+        //\n+        // then that's equivalent to there existing a LUB.\n+        if let Some(mut err) = self.demand_suptype_diag(span, expected, pat_ty) {\n+            err.emit_unless(discrim_span\n+                .filter(|&s| {\n+                    // In the case of `if`- and `while`-expressions we've already checked\n+                    // that `scrutinee: bool`. We know that the pattern is `true`,\n+                    // so an error here would be a duplicate and from the wrong POV.\n+                    s.is_desugaring(DesugaringKind::CondTemporary)\n+                })\n+                .is_some());\n+        }\n+\n+        pat_ty\n+    }\n+\n+    fn check_pat_range(\n+        &self,\n+        span: Span,\n+        begin: &'tcx hir::Expr,\n+        end: &'tcx hir::Expr,\n+        expected: Ty<'tcx>,\n+        discrim_span: Option<Span>,\n+    ) -> Option<Ty<'tcx>> {\n+        let lhs_ty = self.check_expr(begin);\n+        let rhs_ty = self.check_expr(end);\n+\n+        // Check that both end-points are of numeric or char type.\n+        let numeric_or_char = |ty: Ty<'_>| {\n+            ty.is_numeric()\n+            || ty.is_char()\n+            || ty.references_error()\n+        };\n+        let lhs_compat = numeric_or_char(lhs_ty);\n+        let rhs_compat = numeric_or_char(rhs_ty);\n+\n+        if !lhs_compat || !rhs_compat {\n+            let span = if !lhs_compat && !rhs_compat {\n+                span\n+            } else if !lhs_compat {\n+                begin.span\n+            } else {\n+                end.span\n+            };\n+\n+            let mut err = struct_span_err!(\n+                self.tcx.sess,\n+                span,\n+                E0029,\n+                \"only char and numeric types are allowed in range patterns\"\n+            );\n+            err.span_label(span, \"ranges require char or numeric types\");\n+            err.note(&format!(\"start type: {}\", self.ty_to_string(lhs_ty)));\n+            err.note(&format!(\"end type: {}\", self.ty_to_string(rhs_ty)));\n+            if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                err.note(\n+                    \"In a match expression, only numbers and characters can be matched \\\n+                        against a range. This is because the compiler checks that the range \\\n+                        is non-empty at compile-time, and is unable to evaluate arbitrary \\\n+                        comparison functions. If you want to capture values of an orderable \\\n+                        type between two end-points, you can use a guard.\"\n+                    );\n+            }\n+            err.emit();\n+            return None;\n+        }\n+\n+        // Now that we know the types can be unified we find the unified type and use\n+        // it to type the entire expression.\n+        let common_type = self.resolve_vars_if_possible(&lhs_ty);\n+\n+        // Subtyping doesn't matter here, as the value is some kind of scalar.\n+        self.demand_eqtype_pat(span, expected, lhs_ty, discrim_span);\n+        self.demand_eqtype_pat(span, expected, rhs_ty, discrim_span);\n+        Some(common_type)\n+    }\n+\n+    fn check_pat_ident(\n+        &self,\n+        pat: &Pat,\n+        ba: hir::BindingAnnotation,\n+        var_id: HirId,\n+        sub: Option<&'tcx Pat>,\n+        expected: Ty<'tcx>,\n+        def_bm: BindingMode,\n+        discrim_span: Option<Span>,\n+    ) -> Ty<'tcx> {\n+        // Determine the binding mode...\n+        let bm = match ba {\n+            hir::BindingAnnotation::Unannotated => def_bm,\n+            _ => BindingMode::convert(ba),\n+        };\n+        // ...and store it in a side table:\n+        self.inh\n+            .tables\n+            .borrow_mut()\n+            .pat_binding_modes_mut()\n+            .insert(pat.hir_id, bm);\n+\n+        debug!(\"check_pat_ident: pat.hir_id={:?} bm={:?}\", pat.hir_id, bm);\n+\n+        let local_ty = self.local_ty(pat.span, pat.hir_id).decl_ty;\n+        let eq_ty = match bm {\n+            ty::BindByReference(mutbl) => {\n+                // If the binding is like `ref x | ref const x | ref mut x`\n+                // then `x` is assigned a value of type `&M T` where M is the\n+                // mutability and T is the expected type.\n+                let region_ty = self.new_ref_ty(pat.span, mutbl, expected);\n+\n+                // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)`\n+                // is required. However, we use equality, which is stronger.\n+                // See (note_1) for an explanation.\n+                region_ty\n+            }\n+            // Otherwise, the type of x is the expected type `T`.\n+            ty::BindByValue(_) => {\n+                // As above, `T <: typeof(x)` is required, but we use equality, see (note_1).\n+                expected\n+            }\n+        };\n+        self.demand_eqtype_pat(pat.span, eq_ty, local_ty, discrim_span);\n+\n+        // If there are multiple arms, make sure they all agree on\n+        // what the type of the binding `x` ought to be.\n+        if var_id != pat.hir_id {\n+            let vt = self.local_ty(pat.span, var_id).decl_ty;\n+            self.demand_eqtype_pat(pat.span, vt, local_ty, discrim_span);\n+        }\n+\n+        if let Some(p) = sub {\n+            self.check_pat(&p, expected, def_bm, discrim_span);\n+        }\n+\n+        local_ty\n+    }\n+\n+    fn borrow_pat_suggestion(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        pat: &Pat,\n+        inner: &Pat,\n+        expected: Ty<'tcx>,\n+    ) {\n+        let tcx = self.tcx;\n+        if let PatKind::Binding(..) = inner.node {\n+            let binding_parent_id = tcx.hir().get_parent_node(pat.hir_id);\n+            let binding_parent = tcx.hir().get(binding_parent_id);\n+            debug!(\"inner {:?} pat {:?} parent {:?}\", inner, pat, binding_parent);\n+            match binding_parent {\n+                hir::Node::Arg(hir::Arg { span, .. }) => {\n+                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(inner.span) {\n+                        err.span_suggestion(\n+                            *span,\n+                            &format!(\"did you mean `{}`\", snippet),\n+                            format!(\" &{}\", expected),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                }\n+                hir::Node::Arm(_) |\n+                hir::Node::Pat(_) => {\n+                    // rely on match ergonomics or it might be nested `&&pat`\n+                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(inner.span) {\n+                        err.span_suggestion(\n+                            pat.span,\n+                            \"you can probably remove the explicit borrow\",\n+                            snippet,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+                _ => {} // don't provide suggestions in other cases #55175\n+            }\n+        }\n+    }\n+\n+    pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &Pat) -> bool {\n+        if let PatKind::Binding(..) = inner.node {\n+            if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true) {\n+                if let ty::Dynamic(..) = mt.ty.sty {\n+                    // This is \"x = SomeTrait\" being reduced from\n+                    // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n+                    let type_str = self.ty_to_string(expected);\n+                    let mut err = struct_span_err!(\n+                        self.tcx.sess,\n+                        span,\n+                        E0033,\n+                        \"type `{}` cannot be dereferenced\",\n+                        type_str\n+                    );\n+                    err.span_label(span, format!(\"type `{}` cannot be dereferenced\", type_str));\n+                    if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                        err.note(CANNOT_IMPLICITLY_DEREF_POINTER_TRAIT_OBJ);\n+                    }\n+                    err.emit();\n+                    return false\n+                }\n+            }\n+        }\n+        true\n+    }\n+\n+    fn check_pat_struct(\n+        &self,\n+        pat: &'tcx Pat,\n+        qpath: &hir::QPath,\n+        fields: &'tcx [hir::FieldPat],\n+        etc: bool,\n+        expected: Ty<'tcx>,\n+        def_bm: BindingMode,\n+        discrim_span: Option<Span>,\n+    ) -> Ty<'tcx> {\n+        // Resolve the path and check the definition for errors.\n+        let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(qpath, pat.hir_id)\n+        {\n+            variant_ty\n+        } else {\n+            for field in fields {\n+                self.check_pat(&field.pat, self.tcx.types.err, def_bm, discrim_span);\n+            }\n+            return self.tcx.types.err;\n+        };\n+\n+        // Type-check the path.\n+        self.demand_eqtype_pat(pat.span, expected, pat_ty, discrim_span);\n+\n+        // Type-check subpatterns.\n+        if self.check_struct_pat_fields(pat_ty, pat.hir_id, pat.span, variant, fields, etc, def_bm)\n+        {\n+            pat_ty\n+        } else {\n+            self.tcx.types.err\n+        }\n+    }\n+\n+    fn check_pat_path(\n+        &self,\n+        pat: &Pat,\n+        path_resolution: (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment]),\n+        qpath: &hir::QPath,\n+        expected: Ty<'tcx>,\n+    ) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+\n+        // We have already resolved the path.\n+        let (res, opt_ty, segments) = path_resolution;\n+        match res {\n+            Res::Err => {\n+                self.set_tainted_by_errors();\n+                return tcx.types.err;\n+            }\n+            Res::Def(DefKind::Method, _) |\n+            Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _) |\n+            Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) => {\n+                report_unexpected_variant_res(tcx, res, pat.span, qpath);\n+                return tcx.types.err;\n+            }\n+            Res::Def(DefKind::Ctor(_, CtorKind::Const), _) | Res::SelfCtor(..) |\n+            Res::Def(DefKind::Const, _) | Res::Def(DefKind::AssocConst, _) => {} // OK\n+            _ => bug!(\"unexpected pattern resolution: {:?}\", res)\n+        }\n+\n+        // Type-check the path.\n+        let pat_ty = self.instantiate_value_path(segments, opt_ty, res, pat.span, pat.hir_id).0;\n+        self.demand_suptype(pat.span, expected, pat_ty);\n+        pat_ty\n+    }\n+\n+    fn check_pat_tuple_struct(\n+        &self,\n+        pat: &Pat,\n+        qpath: &hir::QPath,\n+        subpats: &'tcx [P<Pat>],\n+        ddpos: Option<usize>,\n+        expected: Ty<'tcx>,\n+        def_bm: BindingMode,\n+        match_arm_pat_span: Option<Span>,\n+    ) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+        let on_error = || {\n+            for pat in subpats {\n+                self.check_pat(&pat, tcx.types.err, def_bm, match_arm_pat_span);\n+            }\n+        };\n+        let report_unexpected_res = |res: Res| {\n+            let msg = format!(\"expected tuple struct/variant, found {} `{}`\",\n+                              res.descr(),\n+                              hir::print::to_string(tcx.hir(), |s| s.print_qpath(qpath, false)));\n+            let mut err = struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg);\n+            match (res, &pat.node) {\n+                (Res::Def(DefKind::Fn, _), _) | (Res::Def(DefKind::Method, _), _) => {\n+                    err.span_label(pat.span, \"`fn` calls are not allowed in patterns\");\n+                    err.help(\"for more information, visit \\\n+                              https://doc.rust-lang.org/book/ch18-00-patterns.html\");\n+                }\n+                _ => {\n+                    err.span_label(pat.span, \"not a tuple variant or struct\");\n+                }\n+            }\n+            err.emit();\n+            on_error();\n+        };\n+\n+        // Resolve the path and check the definition for errors.\n+        let (res, opt_ty, segments) = self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span);\n+        if res == Res::Err {\n+            self.set_tainted_by_errors();\n+            on_error();\n+            return self.tcx.types.err;\n+        }\n+\n+        // Type-check the path.\n+        let (pat_ty, res) = self.instantiate_value_path(segments, opt_ty, res, pat.span,\n+            pat.hir_id);\n+        if !pat_ty.is_fn() {\n+            report_unexpected_res(res);\n+            return tcx.types.err;\n+        }\n+\n+        let variant = match res {\n+            Res::Err => {\n+                self.set_tainted_by_errors();\n+                on_error();\n+                return tcx.types.err;\n+            }\n+            Res::Def(DefKind::AssocConst, _) | Res::Def(DefKind::Method, _) => {\n+                report_unexpected_res(res);\n+                return tcx.types.err;\n+            }\n+            Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) => {\n+                tcx.expect_variant_res(res)\n+            }\n+            _ => bug!(\"unexpected pattern resolution: {:?}\", res)\n+        };\n+\n+        // Replace constructor type with constructed type for tuple struct patterns.\n+        let pat_ty = pat_ty.fn_sig(tcx).output();\n+        let pat_ty = pat_ty.no_bound_vars().expect(\"expected fn type\");\n+\n+        self.demand_eqtype_pat(pat.span, expected, pat_ty, match_arm_pat_span);\n+\n+        // Type-check subpatterns.\n+        if subpats.len() == variant.fields.len()\n+            || subpats.len() < variant.fields.len() && ddpos.is_some()\n+        {\n+            let substs = match pat_ty.sty {\n+                ty::Adt(_, substs) => substs,\n+                _ => bug!(\"unexpected pattern type {:?}\", pat_ty),\n+            };\n+            for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n+                let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n+                self.check_pat(&subpat, field_ty, def_bm, match_arm_pat_span);\n+\n+                self.tcx.check_stability(variant.fields[i].did, Some(pat.hir_id), subpat.span);\n+            }\n+        } else {\n+            let subpats_ending = if subpats.len() == 1 { \"\" } else { \"s\" };\n+            let fields_ending = if variant.fields.len() == 1 { \"\" } else { \"s\" };\n+            struct_span_err!(tcx.sess, pat.span, E0023,\n+                             \"this pattern has {} field{}, but the corresponding {} has {} field{}\",\n+                             subpats.len(), subpats_ending, res.descr(),\n+                             variant.fields.len(),  fields_ending)\n+                .span_label(pat.span, format!(\"expected {} field{}, found {}\",\n+                                              variant.fields.len(), fields_ending, subpats.len()))\n+                .emit();\n+            on_error();\n+            return tcx.types.err;\n+        }\n+        pat_ty\n+    }\n+\n+    fn check_pat_tuple(\n+        &self,\n+        span: Span,\n+        elements: &'tcx [P<Pat>],\n+        ddpos: Option<usize>,\n+        expected: Ty<'tcx>,\n+        def_bm: BindingMode,\n+        discrim_span: Option<Span>,\n+    ) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+        let mut expected_len = elements.len();\n+        if ddpos.is_some() {\n+            // Require known type only when `..` is present.\n+            if let ty::Tuple(ref tys) = self.structurally_resolved_type(span, expected).sty {\n+                expected_len = tys.len();\n+            }\n+        }\n+        let max_len = cmp::max(expected_len, elements.len());\n+\n+        let element_tys_iter = (0..max_len).map(|_| {\n+            Kind::from(self.next_ty_var(\n+                // FIXME: `MiscVariable` for now -- obtaining the span and name information\n+                // from all tuple elements isn't trivial.\n+                TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::TypeInference,\n+                    span,\n+                },\n+            ))\n+        });\n+        let element_tys = tcx.mk_substs(element_tys_iter);\n+        let pat_ty = tcx.mk_ty(ty::Tuple(element_tys));\n+        if let Some(mut err) = self.demand_eqtype_diag(span, expected, pat_ty) {\n+            err.emit();\n+            // Walk subpatterns with an expected type of `err` in this case to silence\n+            // further errors being emitted when using the bindings. #50333\n+            let element_tys_iter = (0..max_len).map(|_| tcx.types.err);\n+            for (_, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n+                self.check_pat(elem, &tcx.types.err, def_bm, discrim_span);\n+            }\n+            tcx.mk_tup(element_tys_iter)\n+        } else {\n+            for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n+                self.check_pat(elem, &element_tys[i].expect_ty(), def_bm, discrim_span);\n+            }\n+            pat_ty\n+        }\n+    }\n+\n+    fn check_struct_pat_fields(\n+        &self,\n+        adt_ty: Ty<'tcx>,\n+        pat_id: HirId,\n+        span: Span,\n+        variant: &'tcx ty::VariantDef,\n+        fields: &'tcx [hir::FieldPat],\n+        etc: bool,\n+        def_bm: BindingMode,\n+    ) -> bool {\n+        let tcx = self.tcx;\n+\n+        let (substs, adt) = match adt_ty.sty {\n+            ty::Adt(adt, substs) => (substs, adt),\n+            _ => span_bug!(span, \"struct pattern is not an ADT\")\n+        };\n+        let kind_name = adt.variant_descr();\n+\n+        // Index the struct fields' types.\n+        let field_map = variant.fields\n+            .iter()\n+            .enumerate()\n+            .map(|(i, field)| (field.ident.modern(), (i, field)))\n+            .collect::<FxHashMap<_, _>>();\n+\n+        // Keep track of which fields have already appeared in the pattern.\n+        let mut used_fields = FxHashMap::default();\n+        let mut no_field_errors = true;\n+\n+        let mut inexistent_fields = vec![];\n+        // Typecheck each field.\n+        for field in fields {\n+            let span = field.span;\n+            let ident = tcx.adjust_ident(field.ident, variant.def_id);\n+            let field_ty = match used_fields.entry(ident) {\n+                Occupied(occupied) => {\n+                    self.error_field_already_bound(span, field.ident, *occupied.get());\n+                    no_field_errors = false;\n+                    tcx.types.err\n+                }\n+                Vacant(vacant) => {\n+                    vacant.insert(span);\n+                    field_map.get(&ident)\n+                        .map(|(i, f)| {\n+                            self.write_field_index(field.hir_id, *i);\n+                            self.tcx.check_stability(f.did, Some(pat_id), span);\n+                            self.field_ty(span, f, substs)\n+                        })\n+                        .unwrap_or_else(|| {\n+                            inexistent_fields.push(field.ident);\n+                            no_field_errors = false;\n+                            tcx.types.err\n+                        })\n+                }\n+            };\n+\n+            self.check_pat(&field.pat, field_ty, def_bm, None);\n+        }\n+\n+        let mut unmentioned_fields = variant.fields\n+                .iter()\n+                .map(|field| field.ident.modern())\n+                .filter(|ident| !used_fields.contains_key(&ident))\n+                .collect::<Vec<_>>();\n+\n+        if inexistent_fields.len() > 0 && !variant.recovered {\n+            self.error_inexistent_fields(\n+                kind_name,\n+                &inexistent_fields,\n+                &mut unmentioned_fields,\n+                variant\n+            );\n+        }\n+\n+        // Require `..` if struct has non_exhaustive attribute.\n+        if variant.is_field_list_non_exhaustive() && !adt.did.is_local() && !etc {\n+            span_err!(tcx.sess, span, E0638,\n+                      \"`..` required with {} marked as non-exhaustive\",\n+                      kind_name);\n+        }\n+\n+        // Report an error if incorrect number of the fields were specified.\n+        if kind_name == \"union\" {\n+            if fields.len() != 1 {\n+                tcx.sess.span_err(span, \"union patterns should have exactly one field\");\n+            }\n+            if etc {\n+                tcx.sess.span_err(span, \"`..` cannot be used in union patterns\");\n+            }\n+        } else if !etc && unmentioned_fields.len() > 0 {\n+            self.error_unmentioned_fields(span, &unmentioned_fields, variant);\n+        }\n+        no_field_errors\n+    }\n+\n+    fn error_field_already_bound(&self, span: Span, ident: ast::Ident, other_field: Span) {\n+        struct_span_err!(\n+            self.tcx.sess, span, E0025,\n+            \"field `{}` bound multiple times in the pattern\",\n+            ident\n+        )\n+        .span_label(span, format!(\"multiple uses of `{}` in pattern\", ident))\n+        .span_label(other_field, format!(\"first use of `{}`\", ident))\n+        .emit();\n+    }\n+\n+    fn error_inexistent_fields(\n+        &self,\n+        kind_name: &str,\n+        inexistent_fields: &[ast::Ident],\n+        unmentioned_fields: &mut Vec<ast::Ident>,\n+        variant: &ty::VariantDef,\n+    ) {\n+        let tcx = self.tcx;\n+        let (field_names, t, plural) = if inexistent_fields.len() == 1 {\n+            (format!(\"a field named `{}`\", inexistent_fields[0]), \"this\", \"\")\n+        } else {\n+            (format!(\"fields named {}\",\n+                        inexistent_fields.iter()\n+                        .map(|ident| format!(\"`{}`\", ident))\n+                        .collect::<Vec<String>>()\n+                        .join(\", \")), \"these\", \"s\")\n+        };\n+        let spans = inexistent_fields.iter().map(|ident| ident.span).collect::<Vec<_>>();\n+        let mut err = struct_span_err!(tcx.sess,\n+                                        spans,\n+                                        E0026,\n+                                        \"{} `{}` does not have {}\",\n+                                        kind_name,\n+                                        tcx.def_path_str(variant.def_id),\n+                                        field_names);\n+        if let Some(ident) = inexistent_fields.last() {\n+            err.span_label(ident.span,\n+                            format!(\"{} `{}` does not have {} field{}\",\n+                                    kind_name,\n+                                    tcx.def_path_str(variant.def_id),\n+                                    t,\n+                                    plural));\n+            if plural == \"\" {\n+                let input = unmentioned_fields.iter().map(|field| &field.name);\n+                let suggested_name =\n+                    find_best_match_for_name(input, &ident.as_str(), None);\n+                if let Some(suggested_name) = suggested_name {\n+                    err.span_suggestion(\n+                        ident.span,\n+                        \"a field with a similar name exists\",\n+                        suggested_name.to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+\n+                    // we don't want to throw `E0027` in case we have thrown `E0026` for them\n+                    unmentioned_fields.retain(|&x| x.as_str() != suggested_name.as_str());\n+                }\n+            }\n+        }\n+        if tcx.sess.teach(&err.get_code().unwrap()) {\n+            err.note(\n+                \"This error indicates that a struct pattern attempted to \\\n+                    extract a non-existent field from a struct. Struct fields \\\n+                    are identified by the name used before the colon : so struct \\\n+                    patterns should resemble the declaration of the struct type \\\n+                    being matched.\\n\\n\\\n+                    If you are using shorthand field patterns but want to refer \\\n+                    to the struct field by a different name, you should rename \\\n+                    it explicitly.\"\n+            );\n+        }\n+        err.emit();\n+    }\n+\n+    fn error_unmentioned_fields(\n+        &self,\n+        span: Span,\n+        unmentioned_fields: &[ast::Ident],\n+        variant: &ty::VariantDef,\n+    ) {\n+        let field_names = if unmentioned_fields.len() == 1 {\n+            format!(\"field `{}`\", unmentioned_fields[0])\n+        } else {\n+            let fields = unmentioned_fields.iter()\n+                .map(|name| format!(\"`{}`\", name))\n+                .collect::<Vec<String>>()\n+                .join(\", \");\n+            format!(\"fields {}\", fields)\n+        };\n+        let mut diag = struct_span_err!(\n+            self.tcx.sess, span, E0027,\n+            \"pattern does not mention {}\",\n+            field_names\n+        );\n+        diag.span_label(span, format!(\"missing {}\", field_names));\n+        if variant.ctor_kind == CtorKind::Fn {\n+            diag.note(\"trying to match a tuple variant with a struct variant pattern\");\n+        }\n+        if self.tcx.sess.teach(&diag.get_code().unwrap()) {\n+            diag.note(\n+                \"This error indicates that a pattern for a struct fails to specify a \\\n+                    sub-pattern for every one of the struct's fields. Ensure that each field \\\n+                    from the struct's definition is mentioned in the pattern, or use `..` to \\\n+                    ignore unwanted fields.\"\n+            );\n+        }\n+        diag.emit();\n+    }\n+\n+    fn check_pat_box(\n+        &self,\n+        span: Span,\n+        inner: &'tcx Pat,\n+        expected: Ty<'tcx>,\n+        def_bm: BindingMode,\n+        discrim_span: Option<Span>,\n+    ) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+        let (box_ty, inner_ty) = if self.check_dereferencable(span, expected, &inner) {\n+            // Here, `demand::subtype` is good enough, but I don't\n+            // think any errors can be introduced by using `demand::eqtype`.\n+            let inner_ty = self.next_ty_var(TypeVariableOrigin {\n+                kind: TypeVariableOriginKind::TypeInference,\n+                span: inner.span,\n+            });\n+            let box_ty = tcx.mk_box(inner_ty);\n+            self.demand_eqtype_pat(span, expected, box_ty, discrim_span);\n+            (box_ty, inner_ty)\n+        } else {\n+            (tcx.types.err, tcx.types.err)\n+        };\n+        self.check_pat(&inner, inner_ty, def_bm, discrim_span);\n+        box_ty\n+    }\n+\n+    fn check_pat_ref(\n+        &self,\n+        pat: &Pat,\n+        inner: &'tcx Pat,\n+        mutbl: hir::Mutability,\n+        expected: Ty<'tcx>,\n+        def_bm: BindingMode,\n+        discrim_span: Option<Span>,\n+    ) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+        let expected = self.shallow_resolve(expected);\n+        let (rptr_ty, inner_ty) = if self.check_dereferencable(pat.span, expected, &inner) {\n+            // `demand::subtype` would be good enough, but using `eqtype` turns\n+            // out to be equally general. See (note_1) for details.\n+\n+            // Take region, inner-type from expected type if we can,\n+            // to avoid creating needless variables. This also helps with\n+            // the bad  interactions of the given hack detailed in (note_1).\n+            debug!(\"check_pat_ref: expected={:?}\", expected);\n+            match expected.sty {\n+                ty::Ref(_, r_ty, r_mutbl) if r_mutbl == mutbl => (expected, r_ty),\n+                _ => {\n+                    let inner_ty = self.next_ty_var(\n+                        TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::TypeInference,\n+                            span: inner.span,\n+                        }\n+                    );\n+                    let rptr_ty = self.new_ref_ty(pat.span, mutbl, inner_ty);\n+                    debug!(\"check_pat_ref: demanding {:?} = {:?}\", expected, rptr_ty);\n+                    let err = self.demand_eqtype_diag(pat.span, expected, rptr_ty);\n+\n+                    // Look for a case like `fn foo(&foo: u32)` and suggest\n+                    // `fn foo(foo: &u32)`\n+                    if let Some(mut err) = err {\n+                        self.borrow_pat_suggestion(&mut err, &pat, &inner, &expected);\n+                        err.emit();\n+                    }\n+                    (rptr_ty, inner_ty)\n+                }\n+            }\n+        } else {\n+            (tcx.types.err, tcx.types.err)\n+        };\n+        self.check_pat(&inner, inner_ty, def_bm, discrim_span);\n+        rptr_ty\n+    }\n+\n+    /// Create a reference type with a fresh region variable.\n+    fn new_ref_ty(&self, span: Span, mutbl: hir::Mutability, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        let region = self.next_region_var(infer::PatternRegion(span));\n+        let mt = ty::TypeAndMut { ty, mutbl };\n+        self.tcx.mk_ref(region, mt)\n+    }\n+\n+    fn check_pat_slice(\n+        &self,\n+        span: Span,\n+        before: &'tcx [P<Pat>],\n+        slice: Option<&'tcx Pat>,\n+        after: &'tcx [P<Pat>],\n+        expected: Ty<'tcx>,\n+        def_bm: BindingMode,\n+        discrim_span: Option<Span>,\n+    ) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+        let expected_ty = self.structurally_resolved_type(span, expected);\n+        let (inner_ty, slice_ty) = match expected_ty.sty {\n+            ty::Array(inner_ty, size) => {\n+                let slice_ty = if let Some(size) = size.try_eval_usize(tcx, self.param_env) {\n+                    let min_len = before.len() as u64 + after.len() as u64;\n+                    if slice.is_none() {\n+                        if min_len != size {\n+                            self.error_scrutinee_inconsistent_length(span, min_len, size)\n+                        }\n+                        tcx.types.err\n+                    } else if let Some(rest) = size.checked_sub(min_len) {\n+                        tcx.mk_array(inner_ty, rest)\n+                    } else {\n+                        self.error_scrutinee_with_rest_inconsistent_length(span, min_len, size);\n+                        tcx.types.err\n+                    }\n+                } else {\n+                    self.error_scrutinee_unfixed_length(span);\n+                    tcx.types.err\n+                };\n+                (inner_ty, slice_ty)\n+            }\n+            ty::Slice(inner_ty) => (inner_ty, expected_ty),\n+            _ => {\n+                if !expected_ty.references_error() {\n+                    self.error_expected_array_or_slice(span, expected_ty);\n+                }\n+                (tcx.types.err, tcx.types.err)\n+            }\n+        };\n+\n+        for elt in before {\n+            self.check_pat(&elt, inner_ty, def_bm, discrim_span);\n+        }\n+        if let Some(slice) = slice {\n+            self.check_pat(&slice, slice_ty, def_bm, discrim_span);\n+        }\n+        for elt in after {\n+            self.check_pat(&elt, inner_ty, def_bm, discrim_span);\n+        }\n+        expected_ty\n+    }\n+\n+    fn error_scrutinee_inconsistent_length(&self, span: Span, min_len: u64, size: u64) {\n+        struct_span_err!(\n+            self.tcx.sess, span, E0527,\n+            \"pattern requires {} elements but array has {}\",\n+            min_len, size\n+        )\n+        .span_label(span, format!(\"expected {} elements\", size))\n+        .emit();\n+    }\n+\n+    fn error_scrutinee_with_rest_inconsistent_length(&self, span: Span, min_len: u64, size: u64) {\n+        struct_span_err!(\n+            self.tcx.sess, span, E0528,\n+            \"pattern requires at least {} elements but array has {}\",\n+            min_len, size\n+        )\n+        .span_label(span, format!(\"pattern cannot match array of {} elements\", size))\n+        .emit();\n+    }\n+\n+    fn error_scrutinee_unfixed_length(&self, span: Span) {\n+        struct_span_err!(\n+            self.tcx.sess, span, E0730,\n+            \"cannot pattern-match on an array without a fixed length\",\n+        )\n+        .emit();\n+    }\n+\n+    fn error_expected_array_or_slice(&self, span: Span, expected_ty: Ty<'tcx>) {\n+        let mut err = struct_span_err!(\n+            self.tcx.sess, span, E0529,\n+            \"expected an array or slice, found `{}`\",\n+            expected_ty\n+        );\n+        if let ty::Ref(_, ty, _) = expected_ty.sty {\n+            if let ty::Array(..) | ty::Slice(..) = ty.sty {\n+                err.help(\"the semantics of slice patterns changed recently; see issue #62254\");\n+            }\n+        }\n+        err.span_label(span, format!(\"pattern cannot match with input type `{}`\", expected_ty));\n+        err.emit();\n+    }\n+}"}]}