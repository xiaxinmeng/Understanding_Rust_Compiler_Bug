{"sha": "d7e01b5809cd600a30bab29da698acb3d1b52409", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZTAxYjU4MDljZDYwMGEzMGJhYjI5ZGE2OThhY2IzZDFiNTI0MDk=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2014-06-07T14:32:01Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2014-06-17T21:43:18Z"}, "message": "Add a b\"xx\" byte string literal of type &'static [u8].", "tree": {"sha": "286205104bc60273b9dae149b21c10a4b94a1764", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/286205104bc60273b9dae149b21c10a4b94a1764"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7e01b5809cd600a30bab29da698acb3d1b52409", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7e01b5809cd600a30bab29da698acb3d1b52409", "html_url": "https://github.com/rust-lang/rust/commit/d7e01b5809cd600a30bab29da698acb3d1b52409", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7e01b5809cd600a30bab29da698acb3d1b52409/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bccdba02960b3cd428addbc2c856065ebb81eb04", "url": "https://api.github.com/repos/rust-lang/rust/commits/bccdba02960b3cd428addbc2c856065ebb81eb04", "html_url": "https://github.com/rust-lang/rust/commit/bccdba02960b3cd428addbc2c856065ebb81eb04"}], "stats": {"total": 257, "additions": 186, "deletions": 71}, "files": [{"sha": "84ffb7fb20e744535d1333cabd9b21f00d770535", "filename": "src/libcore/str.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7e01b5809cd600a30bab29da698acb3d1b52409/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e01b5809cd600a30bab29da698acb3d1b52409/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=d7e01b5809cd600a30bab29da698acb3d1b52409", "patch": "@@ -560,6 +560,8 @@ Section: Comparing strings\n \n // share the implementation of the lang-item vs. non-lang-item\n // eq_slice.\n+/// NOTE: This function is (ab)used in rustc::middle::trans::_match\n+/// to compare &[u8] byte slices that are not necessarily valid UTF-8.\n #[inline]\n fn eq_slice_(a: &str, b: &str) -> bool {\n     #[allow(ctypes)]\n@@ -572,6 +574,8 @@ fn eq_slice_(a: &str, b: &str) -> bool {\n }\n \n /// Bytewise slice equality\n+/// NOTE: This function is (ab)used in rustc::middle::trans::_match\n+/// to compare &[u8] byte slices that are not necessarily valid UTF-8.\n #[cfg(not(test))]\n #[lang=\"str_eq\"]\n #[inline]"}, {"sha": "ff5cada05ea2e18adbc63282cbbdf86d075d5567", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7e01b5809cd600a30bab29da698acb3d1b52409/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e01b5809cd600a30bab29da698acb3d1b52409/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=d7e01b5809cd600a30bab29da698acb3d1b52409", "patch": "@@ -182,7 +182,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n         #[allow(unused_variable)]\n         fn run(&mut self, start: uint, end: uint) -> Vec<Option<uint>> {\n             let mut matched = false;\n-            let prefix_bytes: &[u8] = &$prefix_bytes;\n+            let prefix_bytes: &[u8] = $prefix_bytes;\n             let mut clist = &mut Threads::new(self.which);\n             let mut nlist = &mut Threads::new(self.which);\n "}, {"sha": "72def2c10da32faa38e281b50f42e939256c5c04", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d7e01b5809cd600a30bab29da698acb3d1b52409/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e01b5809cd600a30bab29da698acb3d1b52409/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=d7e01b5809cd600a30bab29da698acb3d1b52409", "patch": "@@ -529,6 +529,7 @@ pub fn compare_const_vals(a: &const_val, b: &const_val) -> Option<int> {\n         (&const_float(a), &const_float(b)) => compare_vals(a, b),\n         (&const_str(ref a), &const_str(ref b)) => compare_vals(a, b),\n         (&const_bool(a), &const_bool(b)) => compare_vals(a, b),\n+        (&const_binary(ref a), &const_binary(ref b)) => compare_vals(a, b),\n         _ => None\n     }\n }"}, {"sha": "808d894be43869234976875d2c3ce2f6b32125be", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d7e01b5809cd600a30bab29da698acb3d1b52409/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e01b5809cd600a30bab29da698acb3d1b52409/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=d7e01b5809cd600a30bab29da698acb3d1b52409", "patch": "@@ -1273,13 +1273,24 @@ fn compare_values<'a>(\n                     val: bool_to_i1(result.bcx, result.val)\n                 }\n             }\n-            _ => cx.sess().bug(\"only scalars and strings supported in compare_values\"),\n+            _ => cx.sess().bug(\"only strings supported in compare_values\"),\n         },\n         ty::ty_rptr(_, mt) => match ty::get(mt.ty).sty {\n             ty::ty_str => compare_str(cx, lhs, rhs, rhs_t),\n-            _ => cx.sess().bug(\"only scalars and strings supported in compare_values\"),\n+            ty::ty_vec(mt, _) => match ty::get(mt.ty).sty {\n+                ty::ty_uint(ast::TyU8) => {\n+                    // NOTE: cast &[u8] to &str and abuse the str_eq lang item,\n+                    // which calls memcmp().\n+                    let t = ty::mk_str_slice(cx.tcx(), ty::ReStatic, ast::MutImmutable);\n+                    let lhs = BitCast(cx, lhs, type_of::type_of(cx.ccx(), t).ptr_to());\n+                    let rhs = BitCast(cx, rhs, type_of::type_of(cx.ccx(), t).ptr_to());\n+                    compare_str(cx, lhs, rhs, rhs_t)\n+                },\n+                _ => cx.sess().bug(\"only byte strings supported in compare_values\"),\n+            },\n+            _ => cx.sess().bug(\"on string and byte strings supported in compare_values\"),\n         },\n-        _ => cx.sess().bug(\"only scalars and strings supported in compare_values\"),\n+        _ => cx.sess().bug(\"only scalars, byte strings, and strings supported in compare_values\"),\n     }\n }\n "}, {"sha": "172a1be7b4e5ba0cf6ec96cced6ac2a2603b939b", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d7e01b5809cd600a30bab29da698acb3d1b52409/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e01b5809cd600a30bab29da698acb3d1b52409/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=d7e01b5809cd600a30bab29da698acb3d1b52409", "patch": "@@ -140,7 +140,8 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n             }\n \n             // text literals\n-            t::LIT_BYTE(..) | t::LIT_CHAR(..) | t::LIT_STR(..) | t::LIT_STR_RAW(..) => \"string\",\n+            t::LIT_BYTE(..) | t::LIT_BINARY(..) |\n+                t::LIT_CHAR(..) | t::LIT_STR(..) | t::LIT_STR_RAW(..) => \"string\",\n \n             // number literals\n             t::LIT_INT(..) | t::LIT_UINT(..) | t::LIT_INT_UNSUFFIXED(..) |"}, {"sha": "59bcf059fcd3d367d4d92a833e48ef191bb43de6", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 111, "deletions": 48, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/d7e01b5809cd600a30bab29da698acb3d1b52409/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e01b5809cd600a30bab29da698acb3d1b52409/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=d7e01b5809cd600a30bab29da698acb3d1b52409", "patch": "@@ -654,7 +654,8 @@ impl<'a> StringReader<'a> {\n             // Note: r as in r\" or r#\" is part of a raw string literal,\n             // b as in b' is part of a byte literal.\n             // They are not identifiers, and are handled further down.\n-           ('r', Some('\"')) | ('r', Some('#')) | ('b', Some('\\'')) => false,\n+           ('r', Some('\"')) | ('r', Some('#')) |\n+           ('b', Some('\"')) | ('b', Some('\\'')) => false,\n            _ => true\n         } {\n             let start = self.last_pos;\n@@ -859,62 +860,124 @@ impl<'a> StringReader<'a> {\n           }\n           'b' => {\n             self.bump();\n-            assert!(self.curr_is('\\''), \"Should have been a token::IDENT\");\n-            self.bump();\n-            let start = self.last_pos;\n-\n-            // the eof will be picked up by the final `'` check below\n-            let mut c2 = self.curr.unwrap_or('\\x00');\n-            self.bump();\n+            return match self.curr {\n+                Some('\\'') => parse_byte(self),\n+                Some('\"') => parse_byte_string(self),\n+                _ => unreachable!()  // Should have been a token::IDENT above.\n+            };\n \n-            match c2 {\n-                '\\\\' => {\n-                    // '\\X' for some X must be a character constant:\n-                    let escaped = self.curr;\n-                    let escaped_pos = self.last_pos;\n-                    self.bump();\n-                    match escaped {\n-                        None => {}\n-                        Some(e) => {\n-                            c2 = match e {\n-                                'n' => '\\n',\n-                                'r' => '\\r',\n-                                't' => '\\t',\n-                                '\\\\' => '\\\\',\n-                                '\\'' => '\\'',\n-                                '\"' => '\"',\n-                                '0' => '\\x00',\n-                                'x' => self.scan_numeric_escape(2u, '\\''),\n-                                c2 => {\n-                                    self.err_span_char(escaped_pos, self.last_pos,\n-                                                       \"unknown byte escape\", c2);\n-                                    c2\n+            fn parse_byte(self_: &mut StringReader) -> token::Token {\n+                self_.bump();\n+                let start = self_.last_pos;\n+\n+                // the eof will be picked up by the final `'` check below\n+                let mut c2 = self_.curr.unwrap_or('\\x00');\n+                self_.bump();\n+\n+                match c2 {\n+                    '\\\\' => {\n+                        // '\\X' for some X must be a character constant:\n+                        let escaped = self_.curr;\n+                        let escaped_pos = self_.last_pos;\n+                        self_.bump();\n+                        match escaped {\n+                            None => {}\n+                            Some(e) => {\n+                                c2 = match e {\n+                                    'n' => '\\n',\n+                                    'r' => '\\r',\n+                                    't' => '\\t',\n+                                    '\\\\' => '\\\\',\n+                                    '\\'' => '\\'',\n+                                    '\"' => '\"',\n+                                    '0' => '\\x00',\n+                                    'x' => self_.scan_numeric_escape(2u, '\\''),\n+                                    c2 => {\n+                                        self_.err_span_char(\n+                                            escaped_pos, self_.last_pos,\n+                                            \"unknown byte escape\", c2);\n+                                        c2\n+                                    }\n                                 }\n                             }\n                         }\n                     }\n+                    '\\t' | '\\n' | '\\r' | '\\'' => {\n+                        self_.err_span_char( start, self_.last_pos,\n+                            \"byte constant must be escaped\", c2);\n+                    }\n+                    _ => if c2 > '\\x7F' {\n+                        self_.err_span_char( start, self_.last_pos,\n+                            \"byte constant must be ASCII. \\\n+                             Use a \\\\xHH escape for a non-ASCII byte\", c2);\n+                    }\n                 }\n-                '\\t' | '\\n' | '\\r' | '\\'' => {\n-                    self.err_span_char( start, self.last_pos,\n-                        \"byte constant must be escaped\", c2);\n-                }\n-                _ if c2 > '\\x7F' => {\n-                    self.err_span_char( start, self.last_pos,\n-                        \"byte constant must be ASCII. \\\n-                         Use a \\\\xHH escape for a non-ASCII byte\", c2);\n+                if !self_.curr_is('\\'') {\n+                    // Byte offsetting here is okay because the\n+                    // character before position `start` are an\n+                    // ascii single quote and ascii 'b'.\n+                    self_.fatal_span_verbose(\n+                        start - BytePos(2), self_.last_pos,\n+                        \"unterminated byte constant\".to_string());\n                 }\n-                _ => {}\n+                self_.bump(); // advance curr past token\n+                return token::LIT_BYTE(c2 as u8);\n             }\n-            if !self.curr_is('\\'') {\n-                self.fatal_span_verbose(\n-                                   // Byte offsetting here is okay because the\n-                                   // character before position `start` are an\n-                                   // ascii single quote and ascii 'b'.\n-                                   start - BytePos(2), self.last_pos,\n-                                   \"unterminated byte constant\".to_string());\n+\n+            fn parse_byte_string(self_: &mut StringReader) -> token::Token {\n+                self_.bump();\n+                let start = self_.last_pos;\n+                let mut value = Vec::new();\n+                while !self_.curr_is('\"') {\n+                    if self_.is_eof() {\n+                        self_.fatal_span(start, self_.last_pos,\n+                                         \"unterminated double quote byte string\");\n+                    }\n+\n+                    let ch = self_.curr.unwrap();\n+                    self_.bump();\n+                    match ch {\n+                      '\\\\' => {\n+                        if self_.is_eof() {\n+                            self_.fatal_span(start, self_.last_pos,\n+                                             \"unterminated double quote byte string\");\n+                        }\n+\n+                        let escaped = self_.curr.unwrap();\n+                        let escaped_pos = self_.last_pos;\n+                        self_.bump();\n+                        match escaped {\n+                          'n' => value.push('\\n' as u8),\n+                          'r' => value.push('\\r' as u8),\n+                          't' => value.push('\\t' as u8),\n+                          '\\\\' => value.push('\\\\' as u8),\n+                          '\\'' => value.push('\\'' as u8),\n+                          '\"' => value.push('\"' as u8),\n+                          '\\n' => self_.consume_whitespace(),\n+                          '0' => value.push(0),\n+                          'x' => {\n+                            value.push(self_.scan_numeric_escape(2u, '\"') as u8);\n+                          }\n+                          c2 => {\n+                            self_.err_span_char(escaped_pos, self_.last_pos,\n+                                                \"unknown byte string escape\", c2);\n+                          }\n+                        }\n+                      }\n+                      _ => {\n+                        if ch <= '\\x7F' {\n+                            value.push(ch as u8)\n+                        } else {\n+                            self_.err_span_char(self_.last_pos, self_.last_pos,\n+                                \"byte string must be ASCII. \\\n+                                 Use a \\\\xHH escape for a non-ASCII byte\", ch);\n+                        }\n+                      }\n+                    }\n+                }\n+                self_.bump();\n+                return token::LIT_BINARY(Rc::new(value));\n             }\n-            self.bump(); // advance curr past token\n-            return token::LIT_BYTE(c2 as u8);\n           }\n           '\"' => {\n             let mut accum_str = String::new();"}, {"sha": "826d28ef3ff88ed252e7bc909a72c5c9ec29d8d4", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d7e01b5809cd600a30bab29da698acb3d1b52409/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e01b5809cd600a30bab29da698acb3d1b52409/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d7e01b5809cd600a30bab29da698acb3d1b52409", "patch": "@@ -33,7 +33,7 @@ use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod};\n use ast::{Ident, NormalFn, Inherited, Item, Item_, ItemStatic};\n use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl};\n use ast::{ItemMac, ItemMod, ItemStruct, ItemTrait, ItemTy, Lit, Lit_};\n-use ast::{LitBool, LitFloat, LitFloatUnsuffixed, LitInt, LitChar, LitByte};\n+use ast::{LitBool, LitFloat, LitFloatUnsuffixed, LitInt, LitChar, LitByte, LitBinary};\n use ast::{LitIntUnsuffixed, LitNil, LitStr, LitUint, Local, LocalLet};\n use ast::{MutImmutable, MutMutable, Mac_, MacInvocTT, Matcher, MatchNonterminal};\n use ast::{MatchSeq, MatchTok, Method, MutTy, BiMul, Mutability};\n@@ -1529,6 +1529,7 @@ impl<'a> Parser<'a> {\n             token::LIT_STR_RAW(s, n) => {\n                 LitStr(self.id_to_interned_str(s), ast::RawStr(n))\n             }\n+            token::LIT_BINARY(ref v) => LitBinary(v.clone()),\n             token::LPAREN => { self.expect(&token::RPAREN); LitNil },\n             _ => { self.unexpected_last(tok); }\n         }"}, {"sha": "b76dcaf0b94c645099551e31694ef906af4a18b8", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d7e01b5809cd600a30bab29da698acb3d1b52409/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e01b5809cd600a30bab29da698acb3d1b52409/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=d7e01b5809cd600a30bab29da698acb3d1b52409", "patch": "@@ -87,6 +87,7 @@ pub enum Token {\n     LIT_FLOAT_UNSUFFIXED(ast::Ident),\n     LIT_STR(ast::Ident),\n     LIT_STR_RAW(ast::Ident, uint), /* raw str delimited by n hash symbols */\n+    LIT_BINARY(Rc<Vec<u8>>),\n \n     /* Name components */\n     // an identifier contains an \"is_mod_name\" boolean,\n@@ -231,17 +232,22 @@ pub fn to_str(t: &Token) -> String {\n         body\n       }\n       LIT_STR(s) => {\n-          (format!(\"\\\"{}\\\"\", get_ident(s).get().escape_default())).to_string()\n+          format!(\"\\\"{}\\\"\", get_ident(s).get().escape_default())\n       }\n       LIT_STR_RAW(s, n) => {\n-          (format!(\"r{delim}\\\"{string}\\\"{delim}\",\n-                  delim=\"#\".repeat(n), string=get_ident(s))).to_string()\n+        format!(\"r{delim}\\\"{string}\\\"{delim}\",\n+                 delim=\"#\".repeat(n), string=get_ident(s))\n+      }\n+      LIT_BINARY(ref v) => {\n+          format!(\n+            \"b\\\"{}\\\"\",\n+            v.iter().map(|&b| b as char).collect::<String>().escape_default())\n       }\n \n       /* Name components */\n       IDENT(s, _) => get_ident(s).get().to_string(),\n       LIFETIME(s) => {\n-          (format!(\"{}\", get_ident(s))).to_string()\n+          format!(\"{}\", get_ident(s))\n       }\n       UNDERSCORE => \"_\".to_string(),\n \n@@ -291,6 +297,7 @@ pub fn can_begin_expr(t: &Token) -> bool {\n       LIT_FLOAT_UNSUFFIXED(_) => true,\n       LIT_STR(_) => true,\n       LIT_STR_RAW(_, _) => true,\n+      LIT_BINARY(_) => true,\n       POUND => true,\n       AT => true,\n       NOT => true,\n@@ -330,6 +337,7 @@ pub fn is_lit(t: &Token) -> bool {\n       LIT_FLOAT_UNSUFFIXED(_) => true,\n       LIT_STR(_) => true,\n       LIT_STR_RAW(_, _) => true,\n+      LIT_BINARY(_) => true,\n       _ => false\n     }\n }"}, {"sha": "fafebd3c5dc3e13731d5de7d4bfc948b01d11be9", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d7e01b5809cd600a30bab29da698acb3d1b52409/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e01b5809cd600a30bab29da698acb3d1b52409/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d7e01b5809cd600a30bab29da698acb3d1b52409", "patch": "@@ -2342,19 +2342,9 @@ impl<'a> State<'a> {\n             ast::LitBool(val) => {\n                 if val { word(&mut self.s, \"true\") } else { word(&mut self.s, \"false\") }\n             }\n-            ast::LitBinary(ref arr) => {\n-                try!(self.ibox(indent_unit));\n-                try!(word(&mut self.s, \"[\"));\n-                try!(self.commasep_cmnt(Inconsistent,\n-                                        arr.as_slice(),\n-                                        |s, u| {\n-                                            word(&mut s.s,\n-                                                 format!(\"{}\",\n-                                                         *u).as_slice())\n-                                        },\n-                                        |_| lit.span));\n-                try!(word(&mut self.s, \"]\"));\n-                self.end()\n+            ast::LitBinary(ref v) => {\n+                let escaped: String = v.iter().map(|&b| b as char).collect();\n+                word(&mut self.s, format!(\"b\\\"{}\\\"\", escaped.escape_default()).as_slice())\n             }\n         }\n     }"}, {"sha": "ec67cdd77e19fa755f81d250e5fac4e2ae88acab", "filename": "src/test/compile-fail/byte-string-literals.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d7e01b5809cd600a30bab29da698acb3d1b52409/src%2Ftest%2Fcompile-fail%2Fbyte-string-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e01b5809cd600a30bab29da698acb3d1b52409/src%2Ftest%2Fcompile-fail%2Fbyte-string-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbyte-string-literals.rs?ref=d7e01b5809cd600a30bab29da698acb3d1b52409", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// ignore-tidy-tab\n+\n+static FOO: &'static [u8] = b\"\\f\";  //~ ERROR unknown byte escape\n+\n+pub fn main() {\n+    b\"\\f\";  //~ ERROR unknown byte escape\n+    b\"\\x0Z\";  //~ ERROR illegal character in numeric character escape: Z\n+    b\"\u00e9\";  //~ ERROR byte constant must be ASCII\n+    b\"a  //~ ERROR unterminated double quote byte string\n+}\n+\n+"}, {"sha": "dc31126e6d6e34108309b2f59a10b506032b7c5c", "filename": "src/test/compile-fail/concat.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d7e01b5809cd600a30bab29da698acb3d1b52409/src%2Ftest%2Fcompile-fail%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e01b5809cd600a30bab29da698acb3d1b52409/src%2Ftest%2Fcompile-fail%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconcat.rs?ref=d7e01b5809cd600a30bab29da698acb3d1b52409", "patch": "@@ -10,6 +10,7 @@\n \n fn main() {\n     concat!(b'f');  //~ ERROR: cannot concatenate a binary literal\n+    concat!(b\"foo\");  //~ ERROR: cannot concatenate a binary literal\n     concat!(foo);   //~ ERROR: expected a literal\n     concat!(foo()); //~ ERROR: expected a literal\n }"}, {"sha": "58df7dc8efd251bec0b44a9a444ff03496c4ac69", "filename": "src/test/run-pass/byte-literals.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7e01b5809cd600a30bab29da698acb3d1b52409/src%2Ftest%2Frun-pass%2Fbyte-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7e01b5809cd600a30bab29da698acb3d1b52409/src%2Ftest%2Frun-pass%2Fbyte-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbyte-literals.rs?ref=d7e01b5809cd600a30bab29da698acb3d1b52409", "patch": "@@ -10,6 +10,7 @@\n \n \n static FOO: u8 = b'\\xF0';\n+static BAR: &'static [u8] = b\"a\\xF0\\t\";\n \n pub fn main() {\n     assert_eq!(b'a', 97u8);\n@@ -35,4 +36,15 @@ pub fn main() {\n         b'a' .. b'z' => {},\n         _ => fail!()\n     }\n+\n+    assert_eq!(b\"a\\n\\r\\t\\\\\\'\\\"\\0\\xF0\",\n+               &[97u8, 10u8, 13u8, 9u8, 92u8, 39u8, 34u8, 0u8, 240u8]);\n+    assert_eq!(b\"a\\\n+                 b\", &[97u8, 98u8]);\n+    assert_eq!(BAR, &[97u8, 240u8, 9u8]);\n+\n+    match &[97u8, 10u8] {\n+        b\"a\\n\" => {},\n+        _ => fail!(),\n+    }\n }"}]}