{"sha": "6cad8f4f14da1dd529100779db74b03d6db20faf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjYWQ4ZjRmMTRkYTFkZDUyOTEwMDc3OWRiNzRiMDNkNmRiMjBmYWY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-18T17:57:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-26T07:10:46Z"}, "message": "Test fixes and rebase conflicts\n\n* vec::raw::to_ptr is gone\n* Pausible => Pausable\n* Removing @\n* Calling the main task \"<main>\"\n* Removing unused imports\n* Removing unused mut\n* Bringing some libextra tests up to date\n* Allowing compiletest to work at stage0\n* Fixing the bootstrap-from-c rmake tests\n* assert => rtassert in a few cases\n* printing to stderr instead of stdout in fail!()", "tree": {"sha": "f3610bdf15fbe38e248a1d92b37919ed8d5a6219", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3610bdf15fbe38e248a1d92b37919ed8d5a6219"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cad8f4f14da1dd529100779db74b03d6db20faf", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cad8f4f14da1dd529100779db74b03d6db20faf", "html_url": "https://github.com/rust-lang/rust/commit/6cad8f4f14da1dd529100779db74b03d6db20faf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cad8f4f14da1dd529100779db74b03d6db20faf/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b47ff23673559ee9a5b91221e0212fd6a57d9802", "url": "https://api.github.com/repos/rust-lang/rust/commits/b47ff23673559ee9a5b91221e0212fd6a57d9802", "html_url": "https://github.com/rust-lang/rust/commit/b47ff23673559ee9a5b91221e0212fd6a57d9802"}], "stats": {"total": 465, "additions": 274, "deletions": 191}, "files": [{"sha": "ae7d1a30a841d036413cc73419221f82dda29f3f", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -13,6 +13,7 @@\n #[allow(non_camel_case_types)];\n #[deny(warnings)];\n \n+#[cfg(stage0)] extern mod green;\n extern mod extra;\n \n use std::os;"}, {"sha": "52b5bedb7ea4917cdf111d84d097ef5c285f1e52", "filename": "src/libextra/comm.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibextra%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibextra%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcomm.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -96,7 +96,6 @@ pub fn rendezvous<T: Send>() -> (SyncPort<T>, SyncChan<T>) {\n #[cfg(test)]\n mod test {\n     use comm::{DuplexStream, rendezvous};\n-    use std::rt::test::run_in_uv_task;\n \n \n     #[test]\n@@ -124,13 +123,11 @@ mod test {\n     #[test]\n     fn recv_a_lot() {\n         // Rendezvous streams should be able to handle any number of messages being sent\n-        do run_in_uv_task {\n-            let (port, chan) = rendezvous();\n-            do spawn {\n-                1000000.times(|| { chan.send(()) })\n-            }\n-            1000000.times(|| { port.recv() })\n+        let (port, chan) = rendezvous();\n+        do spawn {\n+            1000000.times(|| { chan.send(()) })\n         }\n+        1000000.times(|| { port.recv() })\n     }\n \n     #[test]"}, {"sha": "f43329076c8b8c9544270c06e317db0ccd6cee00", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -761,23 +761,21 @@ mod tests {\n     fn test_sem_runtime_friendly_blocking() {\n         // Force the runtime to schedule two threads on the same sched_loop.\n         // When one blocks, it should schedule the other one.\n-        do task::spawn_sched(task::SingleThreaded) {\n-            let s = Semaphore::new(1);\n-            let s2 = s.clone();\n-            let (p, c) = Chan::new();\n-            let mut child_data = Some((s2, c));\n-            s.access(|| {\n-                let (s2, c) = child_data.take_unwrap();\n-                do task::spawn {\n-                    c.send(());\n-                    s2.access(|| { });\n-                    c.send(());\n-                }\n-                let _ = p.recv(); // wait for child to come alive\n-                5.times(|| { task::deschedule(); }); // let the child contend\n-            });\n-            let _ = p.recv(); // wait for child to be done\n-        }\n+        let s = Semaphore::new(1);\n+        let s2 = s.clone();\n+        let (p, c) = Chan::new();\n+        let mut child_data = Some((s2, c));\n+        s.access(|| {\n+            let (s2, c) = child_data.take_unwrap();\n+            do task::spawn {\n+                c.send(());\n+                s2.access(|| { });\n+                c.send(());\n+            }\n+            let _ = p.recv(); // wait for child to come alive\n+            5.times(|| { task::deschedule(); }); // let the child contend\n+        });\n+        let _ = p.recv(); // wait for child to be done\n     }\n     /************************************************************************\n      * Mutex tests"}, {"sha": "ba38f8762873120c69a53419375bdea054268b92", "filename": "src/libextra/task_pool.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibextra%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibextra%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftask_pool.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -17,8 +17,6 @@\n use std::task;\n use std::vec;\n \n-#[cfg(test)] use std::task::SingleThreaded;\n-\n enum Msg<T> {\n     Execute(proc(&T)),\n     Quit"}, {"sha": "0574792c18da8b7e475b789a08b375d08128fedc", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -16,7 +16,7 @@\n //! loop if no other one is provided (and M:N scheduling is desired).\n \n use std::cast;\n-use std::rt::rtio::{EventLoop, IoFactory, RemoteCallback, PausibleIdleCallback,\n+use std::rt::rtio::{EventLoop, IoFactory, RemoteCallback, PausableIdleCallback,\n                     Callback};\n use std::unstable::sync::Exclusive;\n use std::util;"}, {"sha": "3a2e8a2b36cf54cadd3799c95338c368b643fccd", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -18,12 +18,7 @@\n //! functionality inside of 1:1 programs.\n \n #[pkgid = \"green#0.9-pre\"];\n-#[link(name = \"green\",\n-       package_id = \"green\",\n-       vers = \"0.9-pre\",\n-       uuid = \"20c38f8c-bfea-83ed-a068-9dc05277be26\",\n-       url = \"https://github.com/mozilla/rust/tree/master/src/libgreen\")];\n-\n+#[crate_id = \"green#0.9-pre\"];\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"rlib\"];\n #[crate_type = \"dylib\"];\n@@ -61,16 +56,13 @@ pub mod stack;\n pub mod task;\n \n #[lang = \"start\"]\n+#[cfg(not(test))]\n pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {\n     use std::cast;\n-    let mut ret = None;\n-    simple::task().run(|| {\n-        ret = Some(do start(argc, argv) {\n-            let main: extern \"Rust\" fn() = unsafe { cast::transmute(main) };\n-            main();\n-        })\n-    });\n-    ret.unwrap()\n+    do start(argc, argv) {\n+        let main: extern \"Rust\" fn() = unsafe { cast::transmute(main) };\n+        main();\n+    }\n }\n \n /// Set up a default runtime configuration, given compiler-supplied arguments.\n@@ -93,10 +85,14 @@ pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {\n /// error.\n pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n     rt::init(argc, argv);\n-    let exit_code = run(main);\n+    let mut main = Some(main);\n+    let mut ret = None;\n+    simple::task().run(|| {\n+        ret = Some(run(main.take_unwrap()));\n+    });\n     // unsafe is ok b/c we're sure that the runtime is gone\n     unsafe { rt::cleanup() }\n-    exit_code\n+    ret.unwrap()\n }\n \n /// Execute the main function in a pool of M:N schedulers.\n@@ -114,6 +110,7 @@ pub fn run(main: proc()) -> int {\n     let (port, chan) = Chan::new();\n     let mut opts = TaskOpts::new();\n     opts.notify_chan = Some(chan);\n+    opts.name = Some(SendStrStatic(\"<main>\"));\n     pool.spawn(opts, main);\n \n     // Wait for the main task to return, and set the process error code"}, {"sha": "56dc3204da86e1ad391db59f7e35c2eb812c675f", "filename": "src/libgreen/macros.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibgreen%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibgreen%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fmacros.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -54,14 +54,13 @@ macro_rules! rtabort (\n pub fn dumb_println(args: &fmt::Arguments) {\n     use std::io;\n     use std::libc;\n-    use std::vec;\n \n     struct Stderr;\n     impl io::Writer for Stderr {\n         fn write(&mut self, data: &[u8]) {\n             unsafe {\n                 libc::write(libc::STDERR_FILENO,\n-                            vec::raw::to_ptr(data) as *libc::c_void,\n+                            data.as_ptr() as *libc::c_void,\n                             data.len() as libc::size_t);\n             }\n         }"}, {"sha": "ef62f654ddf487bcb42573816b98f41daa3b9447", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -11,7 +11,7 @@\n use std::cast;\n use std::rand::{XorShiftRng, Rng, Rand};\n use std::rt::local::Local;\n-use std::rt::rtio::{RemoteCallback, PausibleIdleCallback, Callback, EventLoop};\n+use std::rt::rtio::{RemoteCallback, PausableIdleCallback, Callback, EventLoop};\n use std::rt::task::BlockedTask;\n use std::rt::task::Task;\n use std::sync::deque;\n@@ -779,6 +779,9 @@ impl Scheduler {\n     /// randomness is a result of performing a round of work stealing (which\n     /// may end up stealing from the current scheduler).\n     pub fn yield_now(mut ~self, cur: ~GreenTask) {\n+        // Async handles trigger the scheduler by calling yield_now on the local\n+        // task, which eventually gets us to here. See comments in SchedRunner\n+        // for more info on this.\n         if cur.is_sched() {\n             assert!(self.sched_task.is_none());\n             self.run_sched_once(cur);\n@@ -1345,7 +1348,7 @@ mod test {\n \n             impl Drop for S {\n                 fn drop(&mut self) {\n-                    let _foo = @0;\n+                    let _foo = ~0;\n                 }\n             }\n "}, {"sha": "64ce9d7e3482d395af15d8116ba79e7c927590bc", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cast;\n use std::io;\n use std::libc::{pid_t, c_void, c_int};\n use std::libc;\n@@ -17,6 +16,8 @@ use std::ptr;\n use std::rt::rtio;\n use p = std::io::process;\n \n+#[cfg(windows)] use std::cast;\n+\n use super::file;\n \n /**"}, {"sha": "e0666592651490addd7335032ce4e7f919896b4d", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -15,12 +15,7 @@\n //! version of I/O.\n \n #[pkgid = \"native#0.9-pre\"];\n-#[link(name = \"native\",\n-       package_id = \"native\",\n-       vers = \"0.9-pre\",\n-       uuid = \"535344a7-890f-5a23-e1f3-e0d118805141\",\n-       url = \"https://github.com/mozilla/rust/tree/master/src/native\")];\n-\n+#[crate_id = \"native#0.9-pre\"];\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"rlib\"];\n #[crate_type = \"dylib\"];\n@@ -46,7 +41,7 @@ pub mod task;\n #[lang = \"start\"]\n pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {\n     use std::cast;\n-    use std::task::try;\n+    use std::task;\n \n     do start(argc, argv) {\n         // Instead of invoking main directly on this thread, invoke it on\n@@ -55,7 +50,9 @@ pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {\n         // of the main thread's stack, so for stack overflow detection to work\n         // we must spawn the task in a subtask which we know the stack size of.\n         let main: extern \"Rust\" fn() = unsafe { cast::transmute(main) };\n-        match do try { main() } {\n+        let mut task = task::task();\n+        task.name(\"<main>\");\n+        match do task.try { main() } {\n             Ok(()) => { os::set_exit_status(0); }\n             Err(..) => { os::set_exit_status(rt::DEFAULT_ERROR_CODE); }\n         }"}, {"sha": "214f60291feaec423ce1d937892eac26309c7bea", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -333,6 +333,10 @@ pub mod write {\n     }\n \n     unsafe fn configure_llvm(sess: Session) {\n+        use std::unstable::mutex::{MUTEX_INIT, Mutex};\n+        static mut LOCK: Mutex = MUTEX_INIT;\n+        static mut CONFIGURED: bool = false;\n+\n         // Copy what clan does by turning on loop vectorization at O2 and\n         // slp vectorization at O3\n         let vectorize_loop = !sess.no_vectorize_loops() &&\n@@ -360,7 +364,13 @@ pub mod write {\n             add(*arg);\n         }\n \n-        llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int, llvm_args.as_ptr());\n+        LOCK.lock();\n+        if !CONFIGURED {\n+            llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int,\n+                                         llvm_args.as_ptr());\n+            CONFIGURED = true;\n+        }\n+        LOCK.unlock();\n     }\n \n     unsafe fn populate_llvm_passes(fpm: lib::llvm::PassManagerRef,"}, {"sha": "21f18eda1409d648d1a70fc491433dc3d358dce5", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -487,8 +487,9 @@ fn lib_output_file_name(workspace: &Path, short_name: &str) -> Path {\n }\n \n fn output_file_name(workspace: &Path, short_name: ~str) -> Path {\n-    target_build_dir(workspace).join(short_name.as_slice()).join(format!(\"{}{}\", short_name,\n-                                                                         os::EXE_SUFFIX))\n+    target_build_dir(workspace).join(short_name.as_slice())\n+                               .join(format!(\"{}{}\", short_name,\n+                                             os::consts::EXE_SUFFIX))\n }\n \n #[cfg(target_os = \"linux\")]\n@@ -1353,7 +1354,7 @@ fn test_import_rustpkg() {\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n     debug!(\"workspace = {}\", workspace.display());\n     assert!(target_build_dir(workspace).join(\"foo\").join(format!(\"pkg{}\",\n-        os::EXE_SUFFIX)).exists());\n+        os::consts::EXE_SUFFIX)).exists());\n }\n \n #[test]\n@@ -1366,7 +1367,7 @@ fn test_macro_pkg_script() {\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n     debug!(\"workspace = {}\", workspace.display());\n     assert!(target_build_dir(workspace).join(\"foo\").join(format!(\"pkg{}\",\n-        os::EXE_SUFFIX)).exists());\n+        os::consts::EXE_SUFFIX)).exists());\n }\n \n #[test]"}, {"sha": "82d0fd823a32078d56ccf2a683ecb9759c579884", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -18,7 +18,6 @@ use std::rt::task::BlockedTask;\n use std::io::{FileStat, IoError};\n use std::io;\n use std::rt::rtio;\n-use std::vec;\n \n use homing::{HomingIO, HomeHandle};\n use super::{Loop, UvError, uv_error_to_io_error, wait_until_woken_after, wakeup};"}, {"sha": "80d21404e4bcb4ff3aeba9309f56f5edbb12d501", "filename": "src/librustuv/idle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibrustuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibrustuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fidle.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -100,7 +100,7 @@ mod test {\n     use std::cast;\n     use std::cell::RefCell;\n     use std::rc::Rc;\n-    use std::rt::rtio::{Callback, PausibleIdleCallback};\n+    use std::rt::rtio::{Callback, PausableIdleCallback};\n     use std::rt::task::{BlockedTask, Task};\n     use std::rt::local::Local;\n     use super::IdleWatcher;"}, {"sha": "6c8c16784a12bf21074a056048c98765777ee7f0", "filename": "src/librustuv/macros.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibrustuv%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibrustuv%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fmacros.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -30,14 +30,13 @@ macro_rules! uvdebug (\n pub fn dumb_println(args: &fmt::Arguments) {\n     use std::io;\n     use std::libc;\n-    use std::vec;\n \n     struct Stderr;\n     impl io::Writer for Stderr {\n         fn write(&mut self, data: &[u8]) {\n             unsafe {\n                 libc::write(libc::STDERR_FILENO,\n-                            vec::raw::to_ptr(data) as *libc::c_void,\n+                            data.as_ptr() as *libc::c_void,\n                             data.len() as libc::size_t);\n             }\n         }"}, {"sha": "6772c6d19361447a63b574a432c37281164792ed", "filename": "src/librustuv/signal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -68,7 +68,7 @@ impl RtioSignal for SignalWatcher {}\n impl Drop for SignalWatcher {\n     fn drop(&mut self) {\n         let _m = self.fire_homing_missile();\n-        self.close_async_();\n+        self.close();\n     }\n }\n "}, {"sha": "4a0ad44d311476212545183411d6d9dc4e945c00", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -169,7 +169,7 @@ impl Drop for TimerWatcher {\n         let _action = {\n             let _m = self.fire_homing_missile();\n             self.stop();\n-            self.close_async_();\n+            self.close();\n             self.action.take()\n         };\n     }"}, {"sha": "dbf129d0b699c81ee7f6785b0498b2f9f6503838", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -86,10 +86,10 @@ impl rtio::EventLoop for UvEventLoop {\n         IdleWatcher::onetime(&mut self.uvio.loop_, f);\n     }\n \n-    fn pausible_idle_callback(&mut self, cb: ~rtio::Callback)\n-        -> ~rtio::PausibleIdleCallback\n+    fn pausable_idle_callback(&mut self, cb: ~rtio::Callback)\n+        -> ~rtio::PausableIdleCallback\n     {\n-        IdleWatcher::new(&mut self.uvio.loop_, cb) as ~rtio::PausibleIdleCallback\n+        IdleWatcher::new(&mut self.uvio.loop_, cb) as ~rtio::PausableIdleCallback\n     }\n \n     fn remote_callback(&mut self, f: ~rtio::Callback) -> ~rtio::RemoteCallback {"}, {"sha": "01b409d43163ad0971a6801edbf938bf4a53eaa7", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -175,7 +175,8 @@ mod tests {\n     fn connect_error() {\n         let mut called = false;\n         io_error::cond.trap(|e| {\n-            assert_eq!(e.kind, OtherIoError);\n+            assert_eq!(e.kind,\n+                       if cfg!(windows) {OtherIoError} else {FileNotFound});\n             called = true;\n         }).inside(|| {\n             let stream = UnixStream::connect(&(\"path/to/nowhere\"));"}, {"sha": "1e4fa7968dc421399df2d5d052b97b137f7353de", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -34,7 +34,6 @@ use libc;\n use option::{Option, Some, None};\n use result::{Ok, Err};\n use rt::rtio::{DontClose, IoFactory, LocalIo, RtioFileStream, RtioTTY};\n-use vec;\n \n // And so begins the tale of acquiring a uv handle to a stdio stream on all\n // platforms in all situations. Our story begins by splitting the world into two\n@@ -137,7 +136,7 @@ fn with_task_stdout(f: |&mut Writer|) {\n                     fn write(&mut self, data: &[u8]) {\n                         unsafe {\n                             libc::write(libc::STDOUT_FILENO,\n-                                        vec::raw::to_ptr(data) as *libc::c_void,\n+                                        data.as_ptr() as *libc::c_void,\n                                         data.len() as libc::size_t);\n                         }\n                     }"}, {"sha": "4be1122796584c6a09a261530678b05b00a0ee71", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -31,6 +31,7 @@ macro_rules! iotest (\n             use io::net::tcp::*;\n             use io::net::ip::*;\n             use io::net::udp::*;\n+            #[cfg(unix)]\n             use io::net::unix::*;\n             use str;\n             use util;"}, {"sha": "42cce272e4430807d437cebf90d69f235c5e9099", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -42,7 +42,7 @@ impl<T> Drop for Borrowed<T> {\n             }\n             let val: ~T = cast::transmute(self.val);\n             put::<T>(val);\n-            assert!(exists());\n+            rtassert!(exists());\n         }\n     }\n }\n@@ -110,7 +110,7 @@ pub mod compiled {\n     #[inline]\n     pub unsafe fn take<T>() -> ~T {\n         let ptr = RT_TLS_PTR;\n-        assert!(!ptr.is_null());\n+        rtassert!(!ptr.is_null());\n         let ptr: ~T = cast::transmute(ptr);\n         // can't use `as`, due to type not matching with `cfg(test)`\n         RT_TLS_PTR = cast::transmute(0);\n@@ -180,7 +180,7 @@ pub mod native {\n     }\n \n     pub unsafe fn cleanup() {\n-        assert!(INITIALIZED);\n+        rtassert!(INITIALIZED);\n         tls::destroy(RT_TLS_KEY);\n         LOCK.destroy();\n         INITIALIZED = false;"}, {"sha": "0dd6c883d5b47affb4142130cc8d9c004fd2ff59", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -176,6 +176,7 @@ pub fn init(argc: int, argv: **u8) {\n         args::init(argc, argv);\n         env::init();\n         logging::init();\n+        local_ptr::init();\n     }\n }\n "}, {"sha": "6b3d50a76ac8fce9151b09259b296e37e8aec424", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -95,14 +95,16 @@ impl<'a> LocalIo<'a> {\n     /// Returns the local I/O: either the local scheduler's I/O services or\n     /// the native I/O services.\n     pub fn borrow() -> Option<LocalIo> {\n-        // XXX: This is currently very unsafely implemented. We don't actually\n-        //      *take* the local I/O so there's a very real possibility that we\n-        //      can have two borrows at once. Currently there is not a clear way\n-        //      to actually borrow the local I/O factory safely because even if\n-        //      ownership were transferred down to the functions that the I/O\n-        //      factory implements it's just too much of a pain to know when to\n-        //      relinquish ownership back into the local task (but that would be\n-        //      the safe way of implementing this function).\n+        // FIXME(#11053): bad\n+        //\n+        // This is currently very unsafely implemented. We don't actually\n+        // *take* the local I/O so there's a very real possibility that we\n+        // can have two borrows at once. Currently there is not a clear way\n+        // to actually borrow the local I/O factory safely because even if\n+        // ownership were transferred down to the functions that the I/O\n+        // factory implements it's just too much of a pain to know when to\n+        // relinquish ownership back into the local task (but that would be\n+        // the safe way of implementing this function).\n         //\n         // In order to get around this, we just transmute a copy out of the task\n         // in order to have what is likely a static lifetime (bad)."}, {"sha": "e6ab159a769528d03339347d55fc52d754886b32", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -15,9 +15,10 @@\n \n use any::AnyOwnExt;\n use borrow;\n+use cast;\n use cleanup;\n use io::Writer;\n-use libc::{c_char, size_t};\n+use iter::{Iterator, Take};\n use local_data;\n use ops::Drop;\n use option::{Option, Some, None};\n@@ -488,7 +489,10 @@ mod test {\n \n     #[test]\n     #[should_fail]\n-    fn test_begin_unwind() { begin_unwind(\"cause\", file!(), line!()) }\n+    fn test_begin_unwind() {\n+        use rt::unwind::begin_unwind;\n+        begin_unwind(\"cause\", file!(), line!())\n+    }\n \n     // Task blocking tests\n "}, {"sha": "f4f4aaa276524231e34a3efdfe95c6bc11010fa4", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -144,15 +144,11 @@ impl<T: Send> Drop for Thread<T> {\n \n #[cfg(windows)]\n mod imp {\n-    use super::DEFAULT_STACK_SIZE;\n-\n     use cast;\n     use libc;\n     use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, SIZE_T, BOOL,\n                                        LPVOID, DWORD, LPDWORD, HANDLE};\n     use ptr;\n-    use libc;\n-    use cast;\n \n     pub type rust_thread = HANDLE;\n     pub type rust_thread_return = DWORD;"}, {"sha": "9706dbae4c61b8f095735090fa5a3d78bc69dae6", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 116, "deletions": 86, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -10,8 +10,9 @@\n \n // Implementation of Rust stack unwinding\n //\n-// For background on exception handling and stack unwinding please see \"Exception Handling in LLVM\"\n-// (llvm.org/docs/ExceptionHandling.html) and documents linked from it.\n+// For background on exception handling and stack unwinding please see\n+// \"Exception Handling in LLVM\" (llvm.org/docs/ExceptionHandling.html) and\n+// documents linked from it.\n // These are also good reads:\n //     http://theofilos.cs.columbia.edu/blog/2013/09/22/base_abi/\n //     http://monoinfinito.wordpress.com/series/exception-handling-in-c/\n@@ -20,41 +21,55 @@\n // ~~~ A brief summary ~~~\n // Exception handling happens in two phases: a search phase and a cleanup phase.\n //\n-// In both phases the unwinder walks stack frames from top to bottom using information from\n-// the stack frame unwind sections of the current process's modules (\"module\" here refers to\n-// an OS module, i.e. an executable or a dynamic library).\n+// In both phases the unwinder walks stack frames from top to bottom using\n+// information from the stack frame unwind sections of the current process's\n+// modules (\"module\" here refers to an OS module, i.e. an executable or a\n+// dynamic library).\n //\n-// For each stack frame, it invokes the associated \"personality routine\", whose address is also\n-// stored in the unwind info section.\n+// For each stack frame, it invokes the associated \"personality routine\", whose\n+// address is also stored in the unwind info section.\n //\n-// In the search phase, the job of a personality routine is to examine exception object being\n-// thrown, and to decide whether it should be caught at that stack frame.  Once the handler frame\n-// has been identified, cleanup phase begins.\n+// In the search phase, the job of a personality routine is to examine exception\n+// object being thrown, and to decide whether it should be caught at that stack\n+// frame.  Once the handler frame has been identified, cleanup phase begins.\n //\n-// In the cleanup phase, personality routines invoke cleanup code associated with their\n-// stack frames (i.e. destructors).  Once stack has been unwound down to the handler frame level,\n-// unwinding stops and the last personality routine transfers control to its' catch block.\n+// In the cleanup phase, personality routines invoke cleanup code associated\n+// with their stack frames (i.e. destructors).  Once stack has been unwound down\n+// to the handler frame level, unwinding stops and the last personality routine\n+// transfers control to its' catch block.\n //\n // ~~~ Frame unwind info registration ~~~\n-// Each module has its' own frame unwind info section (usually \".eh_frame\"), and unwinder needs\n-// to know about all of them in order for unwinding to be able to cross module boundaries.\n+// Each module has its' own frame unwind info section (usually \".eh_frame\"), and\n+// unwinder needs to know about all of them in order for unwinding to be able to\n+// cross module boundaries.\n //\n-// On some platforms, like Linux, this is achieved by dynamically enumerating currently loaded\n-// modules via the dl_iterate_phdr() API and finding all .eh_frame sections.\n+// On some platforms, like Linux, this is achieved by dynamically enumerating\n+// currently loaded modules via the dl_iterate_phdr() API and finding all\n+// .eh_frame sections.\n //\n-// Others, like Windows, require modules to actively register their unwind info sections by calling\n-// __register_frame_info() API at startup.\n-// In the latter case it is essential that there is only one copy of the unwinder runtime\n-// in the process.  This is usually achieved by linking to the dynamic version of the unwind\n-// runtime.\n+// Others, like Windows, require modules to actively register their unwind info\n+// sections by calling __register_frame_info() API at startup.  In the latter\n+// case it is essential that there is only one copy of the unwinder runtime in\n+// the process.  This is usually achieved by linking to the dynamic version of\n+// the unwind runtime.\n //\n // Currently Rust uses unwind runtime provided by libgcc.\n \n-use prelude::*;\n-use cast::transmute;\n-use task::TaskResult;\n+use any::{Any, AnyRefExt};\n+use c_str::CString;\n+use cast;\n+use kinds::Send;\n+use libc::{c_char, size_t};\n use libc::{c_void, c_int};\n-use self::libunwind::*;\n+use option::{Some, None, Option};\n+use result::{Err, Ok};\n+use rt::local::Local;\n+use rt::task::Task;\n+use str::Str;\n+use task::TaskResult;\n+use unstable::intrinsics;\n+\n+use uw = self::libunwind;\n \n mod libunwind {\n     //! Unwind library interface\n@@ -109,45 +124,53 @@ mod libunwind {\n }\n \n pub struct Unwinder {\n-    unwinding: bool,\n-    cause: Option<~Any>\n+    priv unwinding: bool,\n+    priv cause: Option<~Any>\n }\n \n impl Unwinder {\n+    pub fn new() -> Unwinder {\n+        Unwinder {\n+            unwinding: false,\n+            cause: None,\n+        }\n+    }\n+\n+    pub fn unwinding(&self) -> bool {\n+        self.unwinding\n+    }\n \n     pub fn try(&mut self, f: ||) {\n         use unstable::raw::Closure;\n \n         unsafe {\n-            let closure: Closure = transmute(f);\n-            let code = transmute(closure.code);\n-            let env = transmute(closure.env);\n-\n-            let ep = rust_try(try_fn, code, env);\n+            let closure: Closure = cast::transmute(f);\n+            let ep = rust_try(try_fn, closure.code as *c_void,\n+                              closure.env as *c_void);\n             if !ep.is_null() {\n                 rtdebug!(\"Caught {}\", (*ep).exception_class);\n-                _Unwind_DeleteException(ep);\n+                uw::_Unwind_DeleteException(ep);\n             }\n         }\n \n         extern fn try_fn(code: *c_void, env: *c_void) {\n             unsafe {\n-                let closure: Closure = Closure {\n-                    code: transmute(code),\n-                    env: transmute(env),\n-                };\n-                let closure: || = transmute(closure);\n+                let closure: || = cast::transmute(Closure {\n+                    code: code as *(),\n+                    env: env as *(),\n+                });\n                 closure();\n             }\n         }\n \n         extern {\n             // Rust's try-catch\n             // When f(...) returns normally, the return value is null.\n-            // When f(...) throws, the return value is a pointer to the caught exception object.\n+            // When f(...) throws, the return value is a pointer to the caught\n+            // exception object.\n             fn rust_try(f: extern \"C\" fn(*c_void, *c_void),\n                         code: *c_void,\n-                        data: *c_void) -> *_Unwind_Exception;\n+                        data: *c_void) -> *uw::_Unwind_Exception;\n         }\n     }\n \n@@ -158,21 +181,21 @@ impl Unwinder {\n         self.cause = Some(cause);\n \n         unsafe {\n-            let exception = ~_Unwind_Exception {\n+            let exception = ~uw::_Unwind_Exception {\n                 exception_class: rust_exception_class(),\n                 exception_cleanup: exception_cleanup,\n                 private_1: 0,\n                 private_2: 0\n             };\n-            let error = _Unwind_RaiseException(transmute(exception));\n+            let error = uw::_Unwind_RaiseException(cast::transmute(exception));\n             rtabort!(\"Could not unwind stack, error = {}\", error as int)\n         }\n \n-        extern \"C\" fn exception_cleanup(_unwind_code: _Unwind_Reason_Code,\n-                                        exception: *_Unwind_Exception) {\n+        extern \"C\" fn exception_cleanup(_unwind_code: uw::_Unwind_Reason_Code,\n+                                        exception: *uw::_Unwind_Exception) {\n             rtdebug!(\"exception_cleanup()\");\n             unsafe {\n-                let _: ~_Unwind_Exception = transmute(exception);\n+                let _: ~uw::_Unwind_Exception = cast::transmute(exception);\n             }\n         }\n     }\n@@ -188,68 +211,75 @@ impl Unwinder {\n \n // Rust's exception class identifier.  This is used by personality routines to\n // determine whether the exception was thrown by their own runtime.\n-fn rust_exception_class() -> _Unwind_Exception_Class {\n-    let bytes = bytes!(\"MOZ\\0RUST\"); // vendor, language\n-    unsafe {\n-        let ptr: *_Unwind_Exception_Class = transmute(bytes.as_ptr());\n-        *ptr\n-    }\n+fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n+    // M O Z \\0  R U S T -- vendor, language\n+    0x4d4f5a_00_52555354\n }\n \n-\n-// We could implement our personality routine in pure Rust, however exception info decoding\n-// is tedious.  More importantly, personality routines have to handle various platform\n-// quirks, which are not fun to maintain.  For this reason, we attempt to reuse personality\n-// routine of the C language: __gcc_personality_v0.\n+// We could implement our personality routine in pure Rust, however exception\n+// info decoding is tedious.  More importantly, personality routines have to\n+// handle various platform quirks, which are not fun to maintain.  For this\n+// reason, we attempt to reuse personality routine of the C language:\n+// __gcc_personality_v0.\n //\n-// Since C does not support exception catching, __gcc_personality_v0 simply always\n-// returns _URC_CONTINUE_UNWIND in search phase, and always returns _URC_INSTALL_CONTEXT\n-// (i.e. \"invoke cleanup code\") in cleanup phase.\n+// Since C does not support exception catching, __gcc_personality_v0 simply\n+// always returns _URC_CONTINUE_UNWIND in search phase, and always returns\n+// _URC_INSTALL_CONTEXT (i.e. \"invoke cleanup code\") in cleanup phase.\n //\n-// This is pretty close to Rust's exception handling approach, except that Rust does have\n-// a single \"catch-all\" handler at the bottom of each task's stack.\n+// This is pretty close to Rust's exception handling approach, except that Rust\n+// does have a single \"catch-all\" handler at the bottom of each task's stack.\n // So we have two versions:\n-// - rust_eh_personality, used by all cleanup landing pads, which never catches, so\n-//   the behavior of __gcc_personality_v0 is perfectly adequate there, and\n-// - rust_eh_personality_catch, used only by rust_try(), which always catches.  This is\n-//   achieved by overriding the return value in search phase to always say \"catch!\".\n+// - rust_eh_personality, used by all cleanup landing pads, which never catches,\n+//   so the behavior of __gcc_personality_v0 is perfectly adequate there, and\n+// - rust_eh_personality_catch, used only by rust_try(), which always catches.\n+//   This is achieved by overriding the return value in search phase to always\n+//   say \"catch!\".\n \n extern \"C\" {\n     fn __gcc_personality_v0(version: c_int,\n-                            actions: _Unwind_Action,\n-                            exception_class: _Unwind_Exception_Class,\n-                            ue_header: *_Unwind_Exception,\n-                            context: *_Unwind_Context) -> _Unwind_Reason_Code;\n+                            actions: uw::_Unwind_Action,\n+                            exception_class: uw::_Unwind_Exception_Class,\n+                            ue_header: *uw::_Unwind_Exception,\n+                            context: *uw::_Unwind_Context)\n+        -> uw::_Unwind_Reason_Code;\n }\n \n #[lang=\"eh_personality\"]\n #[no_mangle] // so we can reference it by name from middle/trans/base.rs\n #[doc(hidden)]\n #[cfg(not(test))]\n-pub extern \"C\" fn rust_eh_personality(version: c_int,\n-                                      actions: _Unwind_Action,\n-                                      exception_class: _Unwind_Exception_Class,\n-                                      ue_header: *_Unwind_Exception,\n-                                      context: *_Unwind_Context) -> _Unwind_Reason_Code {\n+pub extern \"C\" fn rust_eh_personality(\n+    version: c_int,\n+    actions: uw::_Unwind_Action,\n+    exception_class: uw::_Unwind_Exception_Class,\n+    ue_header: *uw::_Unwind_Exception,\n+    context: *uw::_Unwind_Context\n+) -> uw::_Unwind_Reason_Code\n+{\n     unsafe {\n-        __gcc_personality_v0(version, actions, exception_class, ue_header, context)\n+        __gcc_personality_v0(version, actions, exception_class, ue_header,\n+                             context)\n     }\n }\n \n #[no_mangle] // referenced from rust_try.ll\n #[doc(hidden)]\n #[cfg(not(test))]\n-pub extern \"C\" fn rust_eh_personality_catch(version: c_int,\n-                                            actions: _Unwind_Action,\n-                                            exception_class: _Unwind_Exception_Class,\n-                                            ue_header: *_Unwind_Exception,\n-                                            context: *_Unwind_Context) -> _Unwind_Reason_Code {\n-    if (actions as c_int & _UA_SEARCH_PHASE as c_int) != 0 { // search phase\n-        _URC_HANDLER_FOUND // catch!\n+pub extern \"C\" fn rust_eh_personality_catch(\n+    version: c_int,\n+    actions: uw::_Unwind_Action,\n+    exception_class: uw::_Unwind_Exception_Class,\n+    ue_header: *uw::_Unwind_Exception,\n+    context: *uw::_Unwind_Context\n+) -> uw::_Unwind_Reason_Code\n+{\n+    if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n+        uw::_URC_HANDLER_FOUND // catch!\n     }\n     else { // cleanup phase\n         unsafe {\n-             __gcc_personality_v0(version, actions, exception_class, ue_header, context)\n+             __gcc_personality_v0(version, actions, exception_class, ue_header,\n+                                  context)\n         }\n     }\n }\n@@ -307,11 +337,11 @@ pub fn begin_unwind<M: Any + Send>(msg: M, file: &'static str, line: uint) -> !\n                     let n = (*task).name.as_ref()\n                                    .map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n \n-                    println!(\"task '{}' failed at '{}', {}:{}\", n, msg_s,\n+                    rterrln!(\"task '{}' failed at '{}', {}:{}\", n, msg_s,\n                              file, line);\n                 }\n                 None => {\n-                    println!(\"failed at '{}', {}:{}\", msg_s, file, line);\n+                    rterrln!(\"failed at '{}', {}:{}\", msg_s, file, line);\n                     intrinsics::abort();\n                 }\n             }"}, {"sha": "730a38ce8867d86c29254646d57462c3983d3bde", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -69,14 +69,13 @@ pub fn default_sched_threads() -> uint {\n pub fn dumb_println(args: &fmt::Arguments) {\n     use io;\n     use libc;\n-    use vec;\n \n     struct Stderr;\n     impl io::Writer for Stderr {\n         fn write(&mut self, data: &[u8]) {\n             unsafe {\n                 libc::write(libc::STDERR_FILENO,\n-                            vec::raw::to_ptr(data) as *libc::c_void,\n+                            data.as_ptr() as *libc::c_void,\n                             data.len() as libc::size_t);\n             }\n         }"}, {"sha": "7b94a3acc2b7dac27a06ded944c800f11d54edda", "filename": "src/libstd/sync/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibstd%2Fsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibstd%2Fsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Farc.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -32,7 +32,7 @@ use vec;\n /// An atomically reference counted pointer.\n ///\n /// Enforces no shared-memory safety.\n-//#[unsafe_no_drop_flag] FIXME: #9758\n+#[unsafe_no_drop_flag]\n pub struct UnsafeArc<T> {\n     priv data: *mut ArcData<T>,\n }"}, {"sha": "d6cd690eaa9db9b567b7e369e86be653148f2cf9", "filename": "src/libstd/unstable/stack.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibstd%2Funstable%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Flibstd%2Funstable%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fstack.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -192,6 +192,7 @@ pub unsafe fn record_sp_limit(limit: uint) {\n     #[cfg(target_arch = \"mips\")]\n     #[cfg(target_arch = \"arm\")] #[inline(always)]\n     unsafe fn target_record_sp_limit(limit: uint) {\n+        use libc::c_void;\n         return record_sp_limit(limit as *c_void);\n         extern {\n             fn record_sp_limit(limit: *c_void);\n@@ -265,6 +266,7 @@ pub unsafe fn get_sp_limit() -> uint {\n     #[cfg(target_arch = \"mips\")]\n     #[cfg(target_arch = \"arm\")] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n+        use libc::c_void;\n         return get_sp_limit() as uint;\n         extern {\n             fn get_sp_limit() -> *c_void;"}, {"sha": "6eef71622c5c6232b656d13dc142e295e9af278e", "filename": "src/test/bench/rt-messaging-ping-pong.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -1,4 +1,3 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -12,7 +11,6 @@ extern mod extra;\n \n use std::os;\n use std::uint;\n-use std::rt::test::spawntask_later;\n \n // This is a simple bench that creates M pairs of of tasks. These\n // tasks ping-pong back and forth over a pair of streams. This is a\n@@ -28,7 +26,7 @@ fn ping_pong_bench(n: uint, m: uint) {\n         // Create a stream B->A\n         let (pb,cb) = Chan::<()>::new();\n \n-        do spawntask_later() || {\n+        do spawn() || {\n             let chan = ca;\n             let port = pb;\n             n.times(|| {\n@@ -37,7 +35,7 @@ fn ping_pong_bench(n: uint, m: uint) {\n             })\n         }\n \n-        do spawntask_later() || {\n+        do spawn() || {\n             let chan = cb;\n             let port = pa;\n             n.times(|| {"}, {"sha": "6e3c42f2a4dea031194717995a7cfd31e626f7ae", "filename": "src/test/bench/rt-parfib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Ftest%2Fbench%2Frt-parfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Ftest%2Fbench%2Frt-parfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-parfib.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -12,7 +12,6 @@ extern mod extra;\n \n use std::os;\n use std::uint;\n-use std::rt::test::spawntask_later;\n \n // A simple implementation of parfib. One subtree is found in a new\n // task and communicated over a oneshot pipe, the other is found\n@@ -24,7 +23,7 @@ fn parfib(n: uint) -> uint {\n     }\n \n     let (port,chan) = Chan::new();\n-    do spawntask_later {\n+    do spawn {\n         chan.send(parfib(n-1));\n     };\n     let m2 = parfib(n-2);"}, {"sha": "8174347e3869e1fb38ee14ca546df91e4c3d8fc1", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-test arcs no longer unwrap\n+\n extern mod extra;\n \n use std::from_str::FromStr;"}, {"sha": "57c66974fcd01f8f1db9bd48c604d6db283c971b", "filename": "src/test/compile-fail/std-uncopyable-atomics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstd-uncopyable-atomics.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -12,7 +12,7 @@\n \n #[feature(globs)];\n \n-use std::unstable::atomics::*;\n+use std::sync::atomics::*;\n use std::ptr;\n \n fn main() {"}, {"sha": "7f466573da73087c0b72de342dd54fdadde6cdb4", "filename": "src/test/run-make/bootstrap-from-c-with-green/Makefile", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2FMakefile?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "previous_filename": "src/test/run-make/bootstrap-from-c-with-uvio/Makefile"}, {"sha": "9a03c772f3a3fef5d713d6af26754e0fc2de8e5c", "filename": "src/test/run-make/bootstrap-from-c-with-green/lib.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2Flib.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[crate_id=\"boot#0.1\"];\n+#[crate_type=\"lib\"];\n+#[no_uv];\n+\n+extern mod rustuv;\n+extern mod green;\n+\n+#[no_mangle] // this needs to get called from C\n+pub extern \"C\" fn foo(argc: int, argv: **u8) -> int {\n+    do green::start(argc, argv) {\n+        do spawn {\n+            println!(\"hello\");\n+        }\n+    }\n+}"}, {"sha": "1872c1ea43b1139cfaf90e728d6f11d8c07c2c52", "filename": "src/test/run-make/bootstrap-from-c-with-green/main.c", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2Fmain.c", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2Fmain.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2Fmain.c?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "previous_filename": "src/test/run-make/bootstrap-from-c-with-uvio/main.c"}, {"sha": "7f466573da73087c0b72de342dd54fdadde6cdb4", "filename": "src/test/run-make/bootstrap-from-c-with-native/Makefile", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2FMakefile?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -0,0 +1,9 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) lib.rs -Z gen-crate-map\n+\tln -nsf $(call DYLIB,boot-*) $(call DYLIB,boot)\n+\t$(CC) main.c -o $(call RUN,main) -lboot -Wl,-rpath,$(TMPDIR)\n+\t$(call RUN,main)\n+\trm $(call DYLIB,boot)\n+\t$(call FAIL,main)"}, {"sha": "d0639d45fa569895aa16f02f8f8c9f7a34803a95", "filename": "src/test/run-make/bootstrap-from-c-with-native/lib.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -10,14 +10,13 @@\n \n #[crate_id=\"boot#0.1\"];\n #[crate_type=\"lib\"];\n+#[no_uv];\n \n-extern mod rustuv; // pull in uvio\n-\n-use std::rt;\n+extern mod native;\n \n #[no_mangle] // this needs to get called from C\n pub extern \"C\" fn foo(argc: int, argv: **u8) -> int {\n-    do rt::start(argc, argv) {\n+    do native::start(argc, argv) {\n         do spawn {\n             println!(\"hello\");\n         }", "previous_filename": "src/test/run-make/bootstrap-from-c-with-uvio/lib.rs"}, {"sha": "1872c1ea43b1139cfaf90e728d6f11d8c07c2c52", "filename": "src/test/run-make/bootstrap-from-c-with-native/main.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Fmain.c", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Fmain.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Fmain.c?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// this is the rust entry point that we're going to call.\n+int foo(int argc, char *argv[]);\n+\n+int main(int argc, char *argv[]) {\n+  return foo(argc, argv);\n+}"}, {"sha": "013487e5803813ff18ebf925cd9ad72a589cb62c", "filename": "src/test/run-pass/use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Ftest%2Frun-pass%2Fuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cad8f4f14da1dd529100779db74b03d6db20faf/src%2Ftest%2Frun-pass%2Fuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuse.rs?ref=6cad8f4f14da1dd529100779db74b03d6db20faf", "patch": "@@ -28,4 +28,4 @@ mod baz {\n }\n \n #[start]\n-pub fn start(_: int, _: **u8) -> int { 3 }\n+pub fn start(_: int, _: **u8) -> int { 0 }"}]}