{"sha": "a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5OWFlOTVjNzIyZDRkYzhkMWVlZjA5YWFhNGU3MmQ1MGQ0OTZlNzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-02T16:06:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-02T16:06:54Z"}, "message": "Auto merge of #75060 - JohnTitor:rollup-aq8sfxf, r=JohnTitor\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #74686 (BTreeMap: remove into_slices and its unsafe block)\n - #74762 (BTreeMap::drain_filter should not touch the root during iteration)\n - #74781 (Clean up E0733 explanation)\n - #74874 (BTreeMap: define forget_type only when relevant)\n - #74974 (Make tests faster in Miri)\n - #75010 (Update elasticlunr-rs and ammonia transitive deps)\n - #75041 (Replaced log with tracing crate)\n - #75044 (Clean up E0744 explanation)\n - #75054 (Rename rustc_middle::cstore::DepKind to CrateDepKind)\n - #75057 (Avoid dumping rustc invocations to stdout)\n\nFailed merges:\n\n - #74827 (Move bulk of BTreeMap::insert method down to new method on handle)\n\nr? @ghost", "tree": {"sha": "fec5a53cc6a046a4dc69d53aca053768380e27e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fec5a53cc6a046a4dc69d53aca053768380e27e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "html_url": "https://github.com/rust-lang/rust/commit/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8876ae2c11f341565059b900eeae1254a9accf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8876ae2c11f341565059b900eeae1254a9accf1", "html_url": "https://github.com/rust-lang/rust/commit/e8876ae2c11f341565059b900eeae1254a9accf1"}, {"sha": "50f2b5d9a02a95d0e3d2183ea58958a5a16a7177", "url": "https://api.github.com/repos/rust-lang/rust/commits/50f2b5d9a02a95d0e3d2183ea58958a5a16a7177", "html_url": "https://github.com/rust-lang/rust/commit/50f2b5d9a02a95d0e3d2183ea58958a5a16a7177"}], "stats": {"total": 992, "additions": 642, "deletions": 350}, "files": [{"sha": "142ac9eceebcc54cc8e1da9883e546602f67920f", "filename": "Cargo.lock", "status": "modified", "additions": 140, "deletions": 215, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -37,19 +37,20 @@ version = \"0.0.0\"\n dependencies = [\n  \"compiler_builtins\",\n  \"core\",\n- \"rand 0.7.3\",\n- \"rand_xorshift 0.2.0\",\n+ \"rand\",\n+ \"rand_xorshift\",\n ]\n \n [[package]]\n name = \"ammonia\"\n-version = \"3.0.0\"\n+version = \"3.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9e266e1f4be5ffa05309f650e2586fe1d3ae6034eb24025a7ae1dfecc330823a\"\n+checksum = \"89eac85170f4b3fb3dc5e442c1cfb036cb8eecf9dbbd431a161ffad15d90ea3b\"\n dependencies = [\n  \"html5ever\",\n  \"lazy_static\",\n  \"maplit\",\n+ \"markup5ever_rcdom\",\n  \"matches\",\n  \"tendril\",\n  \"url 2.1.0\",\n@@ -343,7 +344,7 @@ dependencies = [\n  \"termcolor\",\n  \"toml\",\n  \"unicode-width\",\n- \"unicode-xid 0.2.0\",\n+ \"unicode-xid\",\n  \"url 2.1.0\",\n  \"walkdir\",\n  \"winapi 0.3.8\",\n@@ -444,9 +445,9 @@ version = \"0.14.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d463e01905d607e181de72e8608721d3269f29176c9a14ce037011316ae7131d\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n  \"synstructure\",\n ]\n \n@@ -547,12 +548,12 @@ dependencies = [\n  \"lazy_static\",\n  \"pulldown-cmark\",\n  \"quine-mc_cluskey\",\n- \"quote 1.0.2\",\n+ \"quote\",\n  \"regex-syntax\",\n  \"semver 0.9.0\",\n  \"serde\",\n  \"smallvec 1.4.0\",\n- \"syn 1.0.11\",\n+ \"syn\",\n  \"toml\",\n  \"unicode-normalization\",\n  \"url 2.1.0\",\n@@ -667,7 +668,7 @@ checksum = \"8ff012e225ce166d4422e0e78419d901719760f62ae2b7969ca6b564d1b54a9e\"\n name = \"core\"\n version = \"0.0.0\"\n dependencies = [\n- \"rand 0.7.3\",\n+ \"rand\",\n ]\n \n [[package]]\n@@ -788,8 +789,8 @@ version = \"0.1.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"47c5e5ac752e18207b12e16b10631ae5f7f68f8805f335f9b817ead83d9ffce1\"\n dependencies = [\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -835,9 +836,9 @@ version = \"0.5.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"71f31892cd5c62e414316f2963c5689242c43d8e7bbcaaeca97e5e28c95d91d9\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -846,9 +847,9 @@ version = \"0.99.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"2159be042979966de68315bce7034bb000c775f22e3e834e1c52ff78f041cae8\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -923,9 +924,9 @@ checksum = \"3be565ca5c557d7f59e7cfcf1844f9e3033650c929c6566f511e8005f205c1d0\"\n \n [[package]]\n name = \"elasticlunr-rs\"\n-version = \"2.3.4\"\n+version = \"2.3.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a99a310cd1f9770e7bf8e48810c7bcbb0e078c8fb23a8c7bcf0da4c2bf61a455\"\n+checksum = \"35622eb004c8f0c5e7e2032815f3314a93df0db30a1ce5c94e62c1ecc81e22b9\"\n dependencies = [\n  \"lazy_static\",\n  \"regex\",\n@@ -1003,9 +1004,9 @@ version = \"0.1.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"aa4da3c766cd7a0db8242e326e9e4e081edd567072893ed320008189715366a4\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n  \"synstructure\",\n ]\n \n@@ -1298,16 +1299,16 @@ dependencies = [\n \n [[package]]\n name = \"html5ever\"\n-version = \"0.24.1\"\n+version = \"0.25.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"025483b0a1e4577bb28578318c886ee5f817dda6eb62473269349044406644cb\"\n+checksum = \"aafcf38a1a36118242d29b92e1b08ef84e67e4a5ed06e0a80be20e6a32bfed6b\"\n dependencies = [\n  \"log\",\n  \"mac\",\n  \"markup5ever\",\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -1515,9 +1516,9 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8609af8f63b626e8e211f52441fcdb6ec54f1a446606b10d5c89ae9bf8a20058\"\n dependencies = [\n  \"proc-macro-crate\",\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -1735,9 +1736,9 @@ checksum = \"08cbb6b4fef96b6d77bfc40ec491b1690c779e77b05cd9f07f787ed376fd4c43\"\n \n [[package]]\n name = \"markup5ever\"\n-version = \"0.9.0\"\n+version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"65381d9d47506b8592b97c4efd936afcf673b09b059f2bef39c7211ee78b9d03\"\n+checksum = \"aae38d669396ca9b707bfc3db254bc382ddb94f57cc5c235f34623a669a01dab\"\n dependencies = [\n  \"log\",\n  \"phf\",\n@@ -1750,6 +1751,18 @@ dependencies = [\n  \"tendril\",\n ]\n \n+[[package]]\n+name = \"markup5ever_rcdom\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f015da43bcd8d4f144559a3423f4591d69b8ce0652c905374da7205df336ae2b\"\n+dependencies = [\n+ \"html5ever\",\n+ \"markup5ever\",\n+ \"tendril\",\n+ \"xml5ever\",\n+]\n+\n [[package]]\n name = \"matchers\"\n version = \"0.0.1\"\n@@ -1937,7 +1950,7 @@ dependencies = [\n  \"hex 0.4.0\",\n  \"libc\",\n  \"log\",\n- \"rand 0.7.3\",\n+ \"rand\",\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n  \"shell-escape\",\n@@ -2131,7 +2144,7 @@ dependencies = [\n  \"log\",\n  \"mio-named-pipes\",\n  \"miow 0.3.3\",\n- \"rand 0.7.3\",\n+ \"rand\",\n  \"tokio\",\n  \"tokio-named-pipes\",\n  \"tokio-uds\",\n@@ -2233,9 +2246,9 @@ checksum = \"99b8db626e31e5b81787b9783425769681b347011cc59471e33ea46d2ea0cf55\"\n dependencies = [\n  \"pest\",\n  \"pest_meta\",\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -2261,38 +2274,38 @@ dependencies = [\n \n [[package]]\n name = \"phf\"\n-version = \"0.7.24\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b3da44b85f8e8dfaec21adae67f95d93244b2ecf6ad2a692320598dcc8e6dd18\"\n+checksum = \"3dfb61232e34fcb633f43d12c58f83c1df82962dcdfa565a4e866ffc17dafe12\"\n dependencies = [\n  \"phf_shared\",\n ]\n \n [[package]]\n name = \"phf_codegen\"\n-version = \"0.7.24\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b03e85129e324ad4166b06b2c7491ae27fe3ec353af72e72cd1654c7225d517e\"\n+checksum = \"cbffee61585b0411840d3ece935cce9cb6321f01c45477d30066498cd5e1a815\"\n dependencies = [\n  \"phf_generator\",\n  \"phf_shared\",\n ]\n \n [[package]]\n name = \"phf_generator\"\n-version = \"0.7.24\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"09364cc93c159b8b06b1f4dd8a4398984503483891b0c26b867cf431fb132662\"\n+checksum = \"17367f0cc86f2d25802b2c26ee58a7b23faeccf78a396094c13dced0d0182526\"\n dependencies = [\n  \"phf_shared\",\n- \"rand 0.6.1\",\n+ \"rand\",\n ]\n \n [[package]]\n name = \"phf_shared\"\n-version = \"0.7.24\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"234f71a15de2288bcb7e3b6515828d22af7ec8598ee6d24c3b526fa0a80b67a0\"\n+checksum = \"c00cf8b9eafe68dde5e9eaa2cef8ee84a9336a47d566ec55ca16589633b65af7\"\n dependencies = [\n  \"siphasher\",\n ]\n@@ -2363,18 +2376,9 @@ version = \"0.2.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"aeccfe4d5d8ea175d5f0e4a2ad0637e0f4121d63bd99d356fb1f39ab2e7c6097\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n-]\n-\n-[[package]]\n-name = \"proc-macro2\"\n-version = \"0.4.30\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cf3d2011ab5c909338f7887f4fc896d35932e29146c12c8d01da6b22a80ba759\"\n-dependencies = [\n- \"unicode-xid 0.1.0\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -2383,7 +2387,7 @@ version = \"1.0.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e98a83a9f9b331f54b924e68a66acb1bb35cb01fb0a23645139967abefb697e8\"\n dependencies = [\n- \"unicode-xid 0.2.0\",\n+ \"unicode-xid\",\n ]\n \n [[package]]\n@@ -2441,22 +2445,13 @@ version = \"0.2.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"07589615d719a60c8dd8a4622e7946465dfef20d1a428f969e3443e7386d5f45\"\n \n-[[package]]\n-name = \"quote\"\n-version = \"0.6.12\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"faf4799c5d274f3868a4aae320a0a182cbd2baee377b378f080e16a23e9d80db\"\n-dependencies = [\n- \"proc-macro2 0.4.30\",\n-]\n-\n [[package]]\n name = \"quote\"\n version = \"1.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"053a8c8bcc71fcce321828dc897a98ab9760bef03a4fc36693c231e5b3216cfe\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n+ \"proc-macro2\",\n ]\n \n [[package]]\n@@ -2482,25 +2477,6 @@ dependencies = [\n  \"rustc-ap-rustc_span\",\n ]\n \n-[[package]]\n-name = \"rand\"\n-version = \"0.6.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ae9d223d52ae411a33cf7e54ec6034ec165df296ccd23533d671a28252b6f66a\"\n-dependencies = [\n- \"cloudabi\",\n- \"fuchsia-zircon\",\n- \"libc\",\n- \"rand_chacha 0.1.0\",\n- \"rand_core 0.3.0\",\n- \"rand_hc 0.1.0\",\n- \"rand_isaac\",\n- \"rand_pcg\",\n- \"rand_xorshift 0.1.0\",\n- \"rustc_version\",\n- \"winapi 0.3.8\",\n-]\n-\n [[package]]\n name = \"rand\"\n version = \"0.7.3\"\n@@ -2509,19 +2485,10 @@ checksum = \"6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03\"\n dependencies = [\n  \"getrandom\",\n  \"libc\",\n- \"rand_chacha 0.2.2\",\n+ \"rand_chacha\",\n  \"rand_core 0.5.1\",\n- \"rand_hc 0.2.0\",\n-]\n-\n-[[package]]\n-name = \"rand_chacha\"\n-version = \"0.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"771b009e3a508cb67e8823dda454aaa5368c7bc1c16829fb77d3e980440dd34a\"\n-dependencies = [\n- \"rand_core 0.3.0\",\n- \"rustc_version\",\n+ \"rand_hc\",\n+ \"rand_pcg\",\n ]\n \n [[package]]\n@@ -2555,15 +2522,6 @@ dependencies = [\n  \"getrandom\",\n ]\n \n-[[package]]\n-name = \"rand_hc\"\n-version = \"0.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7b40677c7be09ae76218dc623efbf7b18e34bced3f38883af07bb75630a21bc4\"\n-dependencies = [\n- \"rand_core 0.3.0\",\n-]\n-\n [[package]]\n name = \"rand_hc\"\n version = \"0.2.0\"\n@@ -2573,15 +2531,6 @@ dependencies = [\n  \"rand_core 0.5.1\",\n ]\n \n-[[package]]\n-name = \"rand_isaac\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ded997c9d5f13925be2a6fd7e66bf1872597f759fd9dd93513dd7e92e5a5ee08\"\n-dependencies = [\n- \"rand_core 0.3.0\",\n-]\n-\n [[package]]\n name = \"rand_os\"\n version = \"0.1.3\"\n@@ -2598,21 +2547,11 @@ dependencies = [\n \n [[package]]\n name = \"rand_pcg\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"086bd09a33c7044e56bb44d5bdde5a60e7f119a9e95b0775f545de759a32fe05\"\n-dependencies = [\n- \"rand_core 0.3.0\",\n- \"rustc_version\",\n-]\n-\n-[[package]]\n-name = \"rand_xorshift\"\n-version = \"0.1.0\"\n+version = \"0.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"effa3fcaa47e18db002bdde6060944b6d2f9cfd8db471c30e873448ad9187be3\"\n+checksum = \"16abd0c1b639e9eb4d7c50c0b8100b0d0f849be2349829c740fe8e6eb4816429\"\n dependencies = [\n- \"rand_core 0.3.0\",\n+ \"rand_core 0.5.1\",\n ]\n \n [[package]]\n@@ -2752,7 +2691,7 @@ dependencies = [\n  \"num_cpus\",\n  \"ordslice\",\n  \"racer\",\n- \"rand 0.7.3\",\n+ \"rand\",\n  \"rayon\",\n  \"regex\",\n  \"rls-analysis\",\n@@ -2824,7 +2763,7 @@ dependencies = [\n  \"env_logger 0.7.1\",\n  \"futures\",\n  \"log\",\n- \"rand 0.7.3\",\n+ \"rand\",\n  \"rls-data\",\n  \"rls-ipc\",\n  \"serde\",\n@@ -3051,7 +2990,7 @@ version = \"669.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"456af5f09c006cf6c22c1a433ee0232c4bb74bdc6c647a010166a47c94ed2a63\"\n dependencies = [\n- \"unicode-xid 0.2.0\",\n+ \"unicode-xid\",\n ]\n \n [[package]]\n@@ -3060,9 +2999,9 @@ version = \"669.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"64f6acd192f313047759a346b892998b626466b93fe04f415da5f38906bb3b4c\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n  \"synstructure\",\n ]\n \n@@ -3224,13 +3163,13 @@ name = \"rustc-workspace-hack\"\n version = \"1.0.0\"\n dependencies = [\n  \"crossbeam-utils 0.7.2\",\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n+ \"proc-macro2\",\n+ \"quote\",\n  \"serde\",\n  \"serde_json\",\n  \"smallvec 0.6.10\",\n  \"smallvec 1.4.0\",\n- \"syn 1.0.11\",\n+ \"syn\",\n  \"url 2.1.0\",\n  \"winapi 0.3.8\",\n ]\n@@ -3555,7 +3494,7 @@ dependencies = [\n name = \"rustc_incremental\"\n version = \"0.0.0\"\n dependencies = [\n- \"rand 0.7.3\",\n+ \"rand\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_fs_util\",\n@@ -3644,7 +3583,7 @@ dependencies = [\n name = \"rustc_lexer\"\n version = \"0.1.0\"\n dependencies = [\n- \"unicode-xid 0.2.0\",\n+ \"unicode-xid\",\n ]\n \n [[package]]\n@@ -3681,9 +3620,9 @@ dependencies = [\n name = \"rustc_macros\"\n version = \"0.1.0\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n  \"synstructure\",\n ]\n \n@@ -4135,10 +4074,10 @@ dependencies = [\n name = \"rustfmt-config_proc_macro\"\n version = \"0.2.0\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n+ \"proc-macro2\",\n+ \"quote\",\n  \"serde\",\n- \"syn 1.0.11\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -4265,9 +4204,9 @@ version = \"1.0.106\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9e549e3abf4fb8621bd1609f11dfc9f5e50320802273b12f3811a67e6716ea6c\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -4296,9 +4235,9 @@ version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"cd02c7587ec314570041b2754829f84d873ced14a96d1fd1823531e11db40573\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -4346,9 +4285,9 @@ dependencies = [\n \n [[package]]\n name = \"siphasher\"\n-version = \"0.2.2\"\n+version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0df90a788073e8d0235a67e50441d47db7c8ad9debd91cbf43736a2a92d36537\"\n+checksum = \"fa8f3741c7372e75519bd9346068370c9cdaabcc1f9599cbcf2a2719352286b7\"\n \n [[package]]\n name = \"sized-chunks\"\n@@ -4428,46 +4367,37 @@ dependencies = [\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"profiler_builtins\",\n- \"rand 0.7.3\",\n+ \"rand\",\n  \"rustc-demangle\",\n  \"unwind\",\n  \"wasi\",\n ]\n \n [[package]]\n name = \"string_cache\"\n-version = \"0.7.3\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"25d70109977172b127fe834e5449e5ab1740b9ba49fa18a2020f509174f25423\"\n+checksum = \"2940c75beb4e3bf3a494cef919a747a2cb81e52571e212bfbd185074add7208a\"\n dependencies = [\n  \"lazy_static\",\n  \"new_debug_unreachable\",\n  \"phf_shared\",\n  \"precomputed-hash\",\n  \"serde\",\n- \"string_cache_codegen\",\n- \"string_cache_shared\",\n ]\n \n [[package]]\n name = \"string_cache_codegen\"\n-version = \"0.4.2\"\n+version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1eea1eee654ef80933142157fdad9dd8bc43cf7c74e999e369263496f04ff4da\"\n+checksum = \"f24c8e5e19d22a726626f1a5e16fe15b132dcf21d10177fa5a45ce7962996b97\"\n dependencies = [\n  \"phf_generator\",\n  \"phf_shared\",\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"string_cache_shared\",\n+ \"proc-macro2\",\n+ \"quote\",\n ]\n \n-[[package]]\n-name = \"string_cache_shared\"\n-version = \"0.3.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b1884d1bc09741d466d9b14e6d37ac89d6909cbcac41dd9ae982d4d063bbedfc\"\n-\n [[package]]\n name = \"strip-ansi-escapes\"\n version = \"0.1.0\"\n@@ -4501,38 +4431,27 @@ checksum = \"2ae9e5165d463a0dea76967d021f8d0f9316057bf5163aa2a4843790e842ff37\"\n dependencies = [\n  \"heck\",\n  \"proc-macro-error\",\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n name = \"strum\"\n-version = \"0.11.0\"\n+version = \"0.18.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f6c3a2071519ab6a48f465808c4c1ffdd00dfc8e93111d02b4fc5abab177676e\"\n+checksum = \"57bd81eb48f4c437cadc685403cad539345bf703d78e63707418431cecd4522b\"\n \n [[package]]\n name = \"strum_macros\"\n-version = \"0.11.0\"\n+version = \"0.18.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8baacebd7b7c9b864d83a6ba7a246232983e277b86fa5cdec77f565715a4b136\"\n+checksum = \"87c85aa3f8ea653bfd3ddf25f7ee357ee4d204731f6aa9ad04002306f6e2774c\"\n dependencies = [\n  \"heck\",\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n-]\n-\n-[[package]]\n-name = \"syn\"\n-version = \"0.15.35\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"641e117d55514d6d918490e47102f7e08d096fdde360247e4a10f7a91a8478d3\"\n-dependencies = [\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"unicode-xid 0.1.0\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -4541,9 +4460,9 @@ version = \"1.0.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"dff0acdb207ae2fe6d5976617f887eb1e35a2ba52c13c7234c790960cdad9238\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"unicode-xid 0.2.0\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"unicode-xid\",\n ]\n \n [[package]]\n@@ -4552,10 +4471,10 @@ version = \"0.12.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3f085a5855930c0441ca1288cf044ea4aecf4f43a91668abdb870b4ba546a203\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n- \"unicode-xid 0.2.0\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+ \"unicode-xid\",\n ]\n \n [[package]]\n@@ -4578,7 +4497,7 @@ checksum = \"7a6e24d9338a0a5be79593e2fa15a648add6138caa803e2d5bc782c371732ca9\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n- \"rand 0.7.3\",\n+ \"rand\",\n  \"redox_syscall\",\n  \"remove_dir_all\",\n  \"winapi 0.3.8\",\n@@ -4683,9 +4602,9 @@ version = \"1.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"24069c0ba08aab54289d6a25f5036d94afc61e1538bbc42ae5501df141c9027d\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -4984,9 +4903,9 @@ version = \"0.1.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f0693bf8d6f2bf22c690fc61a9d21ac69efdbb894a17ed596b9af0f01e64b84b\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -5103,12 +5022,6 @@ dependencies = [\n  \"rustc-std-workspace-std\",\n ]\n \n-[[package]]\n-name = \"unicode-xid\"\n-version = \"0.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fc72304796d0818e357ead4e000d19c9c174ab23dc11093ac919054d20a6a7fc\"\n-\n [[package]]\n name = \"unicode-xid\"\n version = \"0.2.0\"\n@@ -5296,6 +5209,18 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"xml5ever\"\n+version = \"0.16.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0b1b52e6e8614d4a58b8e70cf51ec0cc21b256ad8206708bcff8139b5bbd6a59\"\n+dependencies = [\n+ \"log\",\n+ \"mac\",\n+ \"markup5ever\",\n+ \"time\",\n+]\n+\n [[package]]\n name = \"xz2\"\n version = \"0.1.5\""}, {"sha": "7c2e5694a62fc4249859748c47d16499752ad066", "filename": "library/alloc/benches/btree/map.rs", "status": "modified", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -282,3 +282,305 @@ pub fn iter_10k(b: &mut Bencher) {\n pub fn iter_1m(b: &mut Bencher) {\n     bench_iter(b, 1_000, 1_000_000);\n }\n+\n+const FAT: usize = 256;\n+\n+// The returned map has small keys and values.\n+// Benchmarks on it have a counterpart in set.rs with the same keys and no values at all.\n+fn slim_map(n: usize) -> BTreeMap<usize, usize> {\n+    (0..n).map(|i| (i, i)).collect::<BTreeMap<_, _>>()\n+}\n+\n+// The returned map has small keys and large values.\n+fn fat_val_map(n: usize) -> BTreeMap<usize, [usize; FAT]> {\n+    (0..n).map(|i| (i, [i; FAT])).collect::<BTreeMap<_, _>>()\n+}\n+\n+// The returned map has large keys and values.\n+fn fat_map(n: usize) -> BTreeMap<[usize; FAT], [usize; FAT]> {\n+    (0..n).map(|i| ([i; FAT], [i; FAT])).collect::<BTreeMap<_, _>>()\n+}\n+\n+#[bench]\n+pub fn clone_slim_100(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| src.clone())\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_clear(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| src.clone().clear())\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_drain_all(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| src.clone().drain_filter(|_, _| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_drain_half(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        assert_eq!(map.drain_filter(|i, _| i % 2 == 0).count(), 100 / 2);\n+        assert_eq!(map.len(), 100 / 2);\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_into_iter(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| src.clone().into_iter().count())\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_pop_all(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while map.pop_first().is_some() {}\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_remove_all(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while let Some(elt) = map.iter().map(|(&i, _)| i).next() {\n+            let v = map.remove(&elt);\n+            debug_assert!(v.is_some());\n+        }\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_remove_half(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        for i in (0..100).step_by(2) {\n+            let v = map.remove(&i);\n+            debug_assert!(v.is_some());\n+        }\n+        assert_eq!(map.len(), 100 / 2);\n+        map\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| src.clone())\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_clear(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| src.clone().clear())\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_drain_all(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| src.clone().drain_filter(|_, _| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_drain_half(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        assert_eq!(map.drain_filter(|i, _| i % 2 == 0).count(), 10_000 / 2);\n+        assert_eq!(map.len(), 10_000 / 2);\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_into_iter(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| src.clone().into_iter().count())\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_pop_all(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while map.pop_first().is_some() {}\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_remove_all(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while let Some(elt) = map.iter().map(|(&i, _)| i).next() {\n+            let v = map.remove(&elt);\n+            debug_assert!(v.is_some());\n+        }\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_remove_half(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        for i in (0..10_000).step_by(2) {\n+            let v = map.remove(&i);\n+            debug_assert!(v.is_some());\n+        }\n+        assert_eq!(map.len(), 10_000 / 2);\n+        map\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| src.clone())\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_clear(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| src.clone().clear())\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_drain_all(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| src.clone().drain_filter(|_, _| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_drain_half(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        assert_eq!(map.drain_filter(|i, _| i % 2 == 0).count(), 100 / 2);\n+        assert_eq!(map.len(), 100 / 2);\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_into_iter(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| src.clone().into_iter().count())\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_pop_all(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while map.pop_first().is_some() {}\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_remove_all(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while let Some(elt) = map.iter().map(|(&i, _)| i).next() {\n+            let v = map.remove(&elt);\n+            debug_assert!(v.is_some());\n+        }\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_remove_half(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        for i in (0..100).step_by(2) {\n+            let v = map.remove(&i);\n+            debug_assert!(v.is_some());\n+        }\n+        assert_eq!(map.len(), 100 / 2);\n+        map\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_fat_100(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| src.clone())\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_clear(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| src.clone().clear())\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_drain_all(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| src.clone().drain_filter(|_, _| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_drain_half(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        assert_eq!(map.drain_filter(|i, _| i[0] % 2 == 0).count(), 100 / 2);\n+        assert_eq!(map.len(), 100 / 2);\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_into_iter(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| src.clone().into_iter().count())\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_pop_all(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while map.pop_first().is_some() {}\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_remove_all(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while let Some(elt) = map.iter().map(|(&i, _)| i).next() {\n+            let v = map.remove(&elt);\n+            debug_assert!(v.is_some());\n+        }\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_remove_half(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        for i in (0..100).step_by(2) {\n+            let v = map.remove(&[i; FAT]);\n+            debug_assert!(v.is_some());\n+        }\n+        assert_eq!(map.len(), 100 / 2);\n+        map\n+    })\n+}"}, {"sha": "07bf5093727c04b4589f7260416a1e275f0ce717", "filename": "library/alloc/benches/btree/set.rs", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/library%2Falloc%2Fbenches%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/library%2Falloc%2Fbenches%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fbtree%2Fset.rs?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -50,27 +50,31 @@ macro_rules! set_bench {\n     };\n }\n \n+fn slim_set(n: usize) -> BTreeSet<usize> {\n+    (0..n).collect::<BTreeSet<_>>()\n+}\n+\n #[bench]\n pub fn clone_100(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| src.clone())\n }\n \n #[bench]\n pub fn clone_100_and_clear(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| src.clone().clear())\n }\n \n #[bench]\n pub fn clone_100_and_drain_all(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| src.clone().drain_filter(|_| true).count())\n }\n \n #[bench]\n pub fn clone_100_and_drain_half(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| {\n         let mut set = src.clone();\n         assert_eq!(set.drain_filter(|i| i % 2 == 0).count(), 100 / 2);\n@@ -80,13 +84,13 @@ pub fn clone_100_and_drain_half(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_100_and_into_iter(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| src.clone().into_iter().count())\n }\n \n #[bench]\n pub fn clone_100_and_pop_all(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| {\n         let mut set = src.clone();\n         while set.pop_first().is_some() {}\n@@ -96,23 +100,25 @@ pub fn clone_100_and_pop_all(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_100_and_remove_all(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| {\n         let mut set = src.clone();\n         while let Some(elt) = set.iter().copied().next() {\n-            set.remove(&elt);\n+            let ok = set.remove(&elt);\n+            debug_assert!(ok);\n         }\n         set\n     });\n }\n \n #[bench]\n pub fn clone_100_and_remove_half(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| {\n         let mut set = src.clone();\n-        for i in (2..=100 as i32).step_by(2) {\n-            set.remove(&i);\n+        for i in (0..100).step_by(2) {\n+            let ok = set.remove(&i);\n+            debug_assert!(ok);\n         }\n         assert_eq!(set.len(), 100 / 2);\n         set\n@@ -121,25 +127,25 @@ pub fn clone_100_and_remove_half(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_10k(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| src.clone())\n }\n \n #[bench]\n pub fn clone_10k_and_clear(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| src.clone().clear())\n }\n \n #[bench]\n pub fn clone_10k_and_drain_all(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| src.clone().drain_filter(|_| true).count())\n }\n \n #[bench]\n pub fn clone_10k_and_drain_half(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| {\n         let mut set = src.clone();\n         assert_eq!(set.drain_filter(|i| i % 2 == 0).count(), 10_000 / 2);\n@@ -149,13 +155,13 @@ pub fn clone_10k_and_drain_half(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_10k_and_into_iter(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| src.clone().into_iter().count())\n }\n \n #[bench]\n pub fn clone_10k_and_pop_all(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| {\n         let mut set = src.clone();\n         while set.pop_first().is_some() {}\n@@ -165,23 +171,25 @@ pub fn clone_10k_and_pop_all(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_10k_and_remove_all(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| {\n         let mut set = src.clone();\n         while let Some(elt) = set.iter().copied().next() {\n-            set.remove(&elt);\n+            let ok = set.remove(&elt);\n+            debug_assert!(ok);\n         }\n         set\n     });\n }\n \n #[bench]\n pub fn clone_10k_and_remove_half(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| {\n         let mut set = src.clone();\n-        for i in (2..=10_000 as i32).step_by(2) {\n-            set.remove(&i);\n+        for i in (0..10_000).step_by(2) {\n+            let ok = set.remove(&i);\n+            debug_assert!(ok);\n         }\n         assert_eq!(set.len(), 10_000 / 2);\n         set"}, {"sha": "6184051316ef801584398bd5083d8d2b02229967", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 64, "deletions": 23, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -174,7 +174,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n \n                     {\n                         let out_root = BTreeMap::ensure_is_owned(&mut out_tree.root);\n-                        let mut out_node = out_root.push_level();\n+                        let mut out_node = out_root.push_internal_level();\n                         let mut in_edge = internal.first_edge();\n                         while let Ok(kv) = in_edge.right_kv() {\n                             let (k, v) = kv.into_kv();\n@@ -1080,9 +1080,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                                 test_node = parent.forget_type();\n                             }\n                         }\n-                        Err(node) => {\n+                        Err(_) => {\n                             // We are at the top, create a new root node and push there.\n-                            open_node = node.into_root_mut().push_level();\n+                            open_node = root.push_internal_level();\n                             break;\n                         }\n                     }\n@@ -1092,7 +1092,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                 let tree_height = open_node.height() - 1;\n                 let mut right_tree = node::Root::new_leaf();\n                 for _ in 0..tree_height {\n-                    right_tree.push_level();\n+                    right_tree.push_internal_level();\n                 }\n                 open_node.push(key, value, right_tree);\n \n@@ -1171,7 +1171,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         let mut right = Self::new();\n         let right_root = Self::ensure_is_owned(&mut right.root);\n         for _ in 0..left_root.height() {\n-            right_root.push_level();\n+            right_root.push_internal_level();\n         }\n \n         {\n@@ -1255,7 +1255,11 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     }\n     pub(super) fn drain_filter_inner(&mut self) -> DrainFilterInner<'_, K, V> {\n         let front = self.root.as_mut().map(|r| r.as_mut().first_leaf_edge());\n-        DrainFilterInner { length: &mut self.length, cur_leaf_edge: front }\n+        DrainFilterInner {\n+            length: &mut self.length,\n+            cur_leaf_edge: front,\n+            emptied_internal_root: false,\n+        }\n     }\n \n     /// Calculates the number of elements if it is incorrect.\n@@ -1625,6 +1629,7 @@ where\n pub(super) struct DrainFilterInner<'a, K: 'a, V: 'a> {\n     length: &'a mut usize,\n     cur_leaf_edge: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n+    emptied_internal_root: bool,\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n@@ -1665,6 +1670,17 @@ where\n     }\n }\n \n+impl<K, V> Drop for DrainFilterInner<'_, K, V> {\n+    fn drop(&mut self) {\n+        if self.emptied_internal_root {\n+            if let Some(handle) = self.cur_leaf_edge.take() {\n+                let root = handle.into_node().into_root_mut();\n+                root.pop_internal_level();\n+            }\n+        }\n+    }\n+}\n+\n impl<'a, K: 'a, V: 'a> DrainFilterInner<'a, K, V> {\n     /// Allow Debug implementations to predict the next element.\n     pub(super) fn peek(&self) -> Option<(&K, &V)> {\n@@ -1681,9 +1697,10 @@ impl<'a, K: 'a, V: 'a> DrainFilterInner<'a, K, V> {\n             let (k, v) = kv.kv_mut();\n             if pred(k, v) {\n                 *self.length -= 1;\n-                let (k, v, leaf_edge_location) = kv.remove_kv_tracking();\n-                self.cur_leaf_edge = Some(leaf_edge_location);\n-                return Some((k, v));\n+                let RemoveResult { old_kv, pos, emptied_internal_root } = kv.remove_kv_tracking();\n+                self.cur_leaf_edge = Some(pos);\n+                self.emptied_internal_root |= emptied_internal_root;\n+                return Some(old_kv);\n             }\n             self.cur_leaf_edge = Some(kv.next_leaf_edge());\n         }\n@@ -2477,7 +2494,7 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n                     }\n                 },\n                 Err(root) => {\n-                    root.push_level().push(ins_k, ins_v, ins_edge);\n+                    root.push_internal_level().push(ins_k, ins_v, ins_edge);\n                     return unsafe { &mut *out_ptr };\n                 }\n             }\n@@ -2647,20 +2664,35 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n         self.remove_kv().1\n     }\n \n+    // Body of `remove_entry`, separate to keep the above implementations short.\n     fn remove_kv(self) -> (K, V) {\n         *self.length -= 1;\n \n-        let (old_key, old_val, _) = self.handle.remove_kv_tracking();\n-        (old_key, old_val)\n+        let RemoveResult { old_kv, pos, emptied_internal_root } = self.handle.remove_kv_tracking();\n+        let root = pos.into_node().into_root_mut();\n+        if emptied_internal_root {\n+            root.pop_internal_level();\n+        }\n+        old_kv\n     }\n }\n \n+struct RemoveResult<'a, K, V> {\n+    // Key and value removed.\n+    old_kv: (K, V),\n+    // Unique location at the leaf level that the removed KV lopgically collapsed into.\n+    pos: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+    // Whether the remove left behind and empty internal root node, that should be removed\n+    // using `pop_internal_level`.\n+    emptied_internal_root: bool,\n+}\n+\n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n-    /// Removes a key/value-pair from the map, and returns that pair, as well as\n-    /// the leaf edge corresponding to that former pair.\n-    fn remove_kv_tracking(\n-        self,\n-    ) -> (K, V, Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n+    /// Removes a key/value-pair from the tree, and returns that pair, as well as\n+    /// the leaf edge corresponding to that former pair. It's possible this leaves\n+    /// an empty internal root node, which the caller should subsequently pop from\n+    /// the map holding the tree. The caller should also decrement the map's length.\n+    fn remove_kv_tracking(self) -> RemoveResult<'a, K, V> {\n         let (mut pos, old_key, old_val, was_internal) = match self.force() {\n             Leaf(leaf) => {\n                 let (hole, old_key, old_val) = leaf.remove();\n@@ -2689,6 +2721,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n         };\n \n         // Handle underflow\n+        let mut emptied_internal_root = false;\n         let mut cur_node = unsafe { ptr::read(&pos).into_node().forget_type() };\n         let mut at_leaf = true;\n         while cur_node.len() < node::MIN_LEN {\n@@ -2709,8 +2742,8 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n \n                     let parent = edge.into_node();\n                     if parent.len() == 0 {\n-                        // We must be at the root\n-                        parent.into_root_mut().pop_level();\n+                        // This empty parent must be the root, and should be popped off the tree.\n+                        emptied_internal_root = true;\n                         break;\n                     } else {\n                         cur_node = parent.forget_type();\n@@ -2737,15 +2770,15 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n             pos = unsafe { unwrap_unchecked(pos.next_kv().ok()).next_leaf_edge() };\n         }\n \n-        (old_key, old_val, pos)\n+        RemoveResult { old_kv: (old_key, old_val), pos, emptied_internal_root }\n     }\n }\n \n impl<K, V> node::Root<K, V> {\n     /// Removes empty levels on the top, but keep an empty leaf if the entire tree is empty.\n     fn fix_top(&mut self) {\n         while self.height() > 0 && self.as_ref().len() == 0 {\n-            self.pop_level();\n+            self.pop_internal_level();\n         }\n     }\n \n@@ -2817,8 +2850,16 @@ fn handle_underfull_node<K, V>(\n     let (is_left, mut handle) = match parent.left_kv() {\n         Ok(left) => (true, left),\n         Err(parent) => {\n-            let right = unsafe { unwrap_unchecked(parent.right_kv().ok()) };\n-            (false, right)\n+            match parent.right_kv() {\n+                Ok(right) => (false, right),\n+                Err(_) => {\n+                    // The underfull node has an empty parent, so it is the only child\n+                    // of an empty root. It is destined to become the new root, thus\n+                    // allowed to be underfull. The empty parent should be removed later\n+                    // by `pop_internal_level`.\n+                    return AtRoot;\n+                }\n+            }\n         }\n     };\n "}, {"sha": "0dcb593096467be93aa45c28839f86d143939fc3", "filename": "library/alloc/src/collections/btree/navigate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -19,7 +19,7 @@ impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::E\n                 Ok(internal_kv) => return Ok(internal_kv),\n                 Err(last_edge) => match last_edge.into_node().ascend() {\n                     Ok(parent_edge) => parent_edge.forget_node_type(),\n-                    Err(root) => return Err(root.forget_type()),\n+                    Err(root) => return Err(root),\n                 },\n             }\n         }\n@@ -40,7 +40,7 @@ impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::E\n                 Ok(internal_kv) => return Ok(internal_kv),\n                 Err(last_edge) => match last_edge.into_node().ascend() {\n                     Ok(parent_edge) => parent_edge.forget_node_type(),\n-                    Err(root) => return Err(root.forget_type()),\n+                    Err(root) => return Err(root),\n                 },\n             }\n         }"}, {"sha": "b767d9ebed72303cdfc03d05542d5caa519bfb15", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -191,8 +191,9 @@ impl<K, V> Root<K, V> {\n     }\n \n     /// Adds a new internal node with a single edge, pointing to the previous root, and make that\n-    /// new node the root. This increases the height by 1 and is the opposite of `pop_level`.\n-    pub fn push_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n+    /// new node the root. This increases the height by 1 and is the opposite of\n+    /// `pop_internal_level`.\n+    pub fn push_internal_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n         let mut new_node = Box::new(unsafe { InternalNode::new() });\n         new_node.edges[0].write(unsafe { BoxedNode::from_ptr(self.node.as_ptr()) });\n \n@@ -213,11 +214,12 @@ impl<K, V> Root<K, V> {\n         ret\n     }\n \n-    /// Removes the root node, using its first child as the new root. This cannot be called when\n-    /// the tree consists only of a leaf node. As it is intended only to be called when the root\n-    /// has only one edge, no cleanup is done on any of the other children of the root.\n-    /// This decreases the height by 1 and is the opposite of `push_level`.\n-    pub fn pop_level(&mut self) {\n+    /// Removes the internal root node, using its first child as the new root.\n+    /// As it is intended only to be called when the root has only one child,\n+    /// no cleanup is done on any of the other children of the root.\n+    /// This decreases the height by 1 and is the opposite of `push_internal_level`.\n+    /// Panics if there is no internal level, i.e. if the root is a leaf.\n+    pub fn pop_internal_level(&mut self) {\n         assert!(self.height > 0);\n \n         let top = self.node.ptr;\n@@ -305,12 +307,6 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         self.height\n     }\n \n-    /// Removes any static information about whether this node is a `Leaf` or an\n-    /// `Internal` node.\n-    pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n-        NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n-    }\n-\n     /// Temporarily takes out another, immutable reference to the same node.\n     fn reborrow(&self) -> NodeRef<marker::Immut<'_>, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n@@ -466,12 +462,6 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n     fn into_val_slice(self) -> &'a [V] {\n         unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len()) }\n     }\n-\n-    fn into_slices(self) -> (&'a [K], &'a [V]) {\n-        // SAFETY: equivalent to reborrow() except not requiring Type: 'a\n-        let k = unsafe { ptr::read(&self) };\n-        (k.into_key_slice(), self.into_val_slice())\n-    }\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n@@ -980,10 +970,9 @@ impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marke\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Immut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn into_kv(self) -> (&'a K, &'a V) {\n-        unsafe {\n-            let (keys, vals) = self.node.into_slices();\n-            (keys.get_unchecked(self.idx), vals.get_unchecked(self.idx))\n-        }\n+        let keys = self.node.into_key_slice();\n+        let vals = self.node.into_val_slice();\n+        unsafe { (keys.get_unchecked(self.idx), vals.get_unchecked(self.idx)) }\n     }\n }\n \n@@ -1362,6 +1351,20 @@ unsafe fn move_edges<K, V>(\n     }\n }\n \n+impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Leaf> {\n+    /// Removes any static information asserting that this node is a `Leaf` node.\n+    pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+        NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n+    }\n+}\n+\n+impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n+    /// Removes any static information asserting that this node is an `Internal` node.\n+    pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+        NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n+    }\n+}\n+\n impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n     pub fn forget_node_type(\n         self,"}, {"sha": "d74f91c752c0407778b18520da2a7d335764df54", "filename": "library/alloc/src/collections/vec_deque/tests.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -107,7 +107,8 @@ fn test_insert() {\n     let cap = tester.capacity();\n \n     // len is the length *after* insertion\n-    for len in 1..cap {\n+    let minlen = if cfg!(miri) { cap - 1 } else { 1 }; // Miri is too slow\n+    for len in minlen..cap {\n         // 0, 1, 2, .., len - 1\n         let expected = (0..).take(len).collect::<VecDeque<_>>();\n         for tail_pos in 0..cap {\n@@ -221,7 +222,8 @@ fn test_remove() {\n     let cap = tester.capacity();\n \n     // len is the length *after* removal\n-    for len in 0..cap - 1 {\n+    let minlen = if cfg!(miri) { cap - 2 } else { 0 }; // Miri is too slow\n+    for len in minlen..cap - 1 {\n         // 0, 1, 2, .., len - 1\n         let expected = (0..).take(len).collect::<VecDeque<_>>();\n         for tail_pos in 0..cap {\n@@ -251,7 +253,8 @@ fn test_range() {\n     let mut tester: VecDeque<usize> = VecDeque::with_capacity(7);\n \n     let cap = tester.capacity();\n-    for len in 0..=cap {\n+    let minlen = if cfg!(miri) { cap - 1 } else { 0 }; // Miri is too slow\n+    for len in minlen..=cap {\n         for tail in 0..=cap {\n             for start in 0..=len {\n                 for end in start..=len {\n@@ -384,7 +387,8 @@ fn test_split_off() {\n     let cap = tester.capacity();\n \n     // len is the length *before* splitting\n-    for len in 0..cap {\n+    let minlen = if cfg!(miri) { cap - 1 } else { 0 }; // Miri is too slow\n+    for len in minlen..cap {\n         // index to split at\n         for at in 0..=len {\n             // 0, 1, 2, .., at - 1 (may be empty)\n@@ -495,8 +499,9 @@ fn test_vec_from_vecdeque() {\n fn test_clone_from() {\n     let m = vec![1; 8];\n     let n = vec![2; 12];\n-    for pfv in 0..8 {\n-        for pfu in 0..8 {\n+    let limit = if cfg!(miri) { 4 } else { 8 }; // Miri is too slow\n+    for pfv in 0..limit {\n+        for pfu in 0..limit {\n             for longer in 0..2 {\n                 let (vr, ur) = if longer == 0 { (&m, &n) } else { (&n, &m) };\n                 let mut v = VecDeque::from(vr.clone());"}, {"sha": "147f7f7d0c72956156c39fbaea656556ddb62994", "filename": "library/alloc/tests/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/library%2Falloc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/library%2Falloc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fslice.rs?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -1721,8 +1721,8 @@ fn panic_safe() {\n \n     let mut rng = thread_rng();\n \n-    // Miri is too slow\n-    let lens = if cfg!(miri) { (1..10).chain(20..21) } else { (1..20).chain(70..MAX_LEN) };\n+    // Miri is too slow (but still need to `chain` to make the types match)\n+    let lens = if cfg!(miri) { (1..10).chain(0..0) } else { (1..20).chain(70..MAX_LEN) };\n     let moduli: &[u32] = if cfg!(miri) { &[5] } else { &[5, 20, 50] };\n \n     for len in lens {"}, {"sha": "e5656eb204c733ab8933f0ddd21be3463e0b75d8", "filename": "library/core/tests/num/flt2dec/random.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -188,7 +188,7 @@ fn exact_f32_random_equivalence_test() {\n fn exact_f64_random_equivalence_test() {\n     use core::num::flt2dec::strategy::dragon::format_exact as fallback;\n     // Miri is too slow\n-    let n = if cfg!(miri) { 3 } else { 1_000 };\n+    let n = if cfg!(miri) { 2 } else { 1_000 };\n \n     for k in 1..21 {\n         f64_random_equivalence_test("}, {"sha": "7e6c8add3339d2d0052fc800fbbb7ce5e2eeda61", "filename": "library/core/tests/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -2,6 +2,7 @@ use super::super::*;\n use core::num::flt2dec::strategy::grisu::*;\n \n #[test]\n+#[cfg_attr(miri, ignore)] // Miri is too slow\n fn test_cached_power() {\n     assert_eq!(CACHED_POW10.first().unwrap().1, CACHED_POW10_FIRST_E);\n     assert_eq!(CACHED_POW10.last().unwrap().1, CACHED_POW10_LAST_E);"}, {"sha": "42b483f33ba44a2dc1c123d5a070697589bcb8f1", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -1358,15 +1358,15 @@ fn sort_unstable() {\n     use core::slice::heapsort;\n     use rand::{rngs::StdRng, seq::SliceRandom, Rng, SeedableRng};\n \n-    // Miri is too slow\n-    let large_range = if cfg!(miri) { 0..0 } else { 500..510 };\n+    // Miri is too slow (but still need to `chain` to make the types match)\n+    let lens = if cfg!(miri) { (2..20).chain(0..0) } else { (2..25).chain(500..510) };\n     let rounds = if cfg!(miri) { 1 } else { 100 };\n \n     let mut v = [0; 600];\n     let mut tmp = [0; 600];\n     let mut rng = StdRng::from_entropy();\n \n-    for len in (2..25).chain(large_range) {\n+    for len in lens {\n         let v = &mut v[0..len];\n         let tmp = &mut tmp[0..len];\n "}, {"sha": "4dd71ebade1a416a54f643bd248ccaa530ef2467", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -171,7 +171,9 @@ fn main() {\n         // note: everything below here is unreachable. do not put code that\n         // should run on success, after this block.\n     }\n-    println!(\"\\nDid not run successfully: {}\\n{:?}\\n-------------\", status, cmd);\n+    if verbose > 0 {\n+        println!(\"\\nDid not run successfully: {}\\n{:?}\\n-------------\", status, cmd);\n+    }\n \n     if let Some(mut on_fail) = on_fail {\n         on_fail.status().expect(\"Could not run the on_fail command\");"}, {"sha": "bf7e69a31abcba446d7238ff3e7c310ef7941332", "filename": "src/librustc_ast_lowering/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_ast_lowering%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_ast_lowering%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2FCargo.toml?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -11,7 +11,7 @@ doctest = false\n \n [dependencies]\n rustc_arena = { path = \"../librustc_arena\" }\n-log = { package = \"tracing\", version = \"0.1\" }\n+tracing = \"0.1\"\n rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_target = { path = \"../librustc_target\" }"}, {"sha": "5414e5842904726f8d5a32746425d56236553789", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -17,9 +17,9 @@ use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n use rustc_target::spec::abi;\n \n-use log::debug;\n use smallvec::{smallvec, SmallVec};\n use std::collections::BTreeSet;\n+use tracing::debug;\n \n pub(super) struct ItemLowerer<'a, 'lowering, 'hir> {\n     pub(super) lctx: &'a mut LoweringContext<'lowering, 'hir>,"}, {"sha": "9df7ad2a9acf47d22e2c72c948a6b0c4ce4254bd", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -64,10 +64,10 @@ use rustc_span::source_map::{respan, DesugaringKind, ExpnData, ExpnKind};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n \n-use log::{debug, trace};\n use smallvec::{smallvec, SmallVec};\n use std::collections::BTreeMap;\n use std::mem;\n+use tracing::{debug, trace};\n \n macro_rules! arena_vec {\n     ($this:expr; $($x:expr),*) => ({"}, {"sha": "2541d6824fec4e66331ca93d7915dc347b3a59c3", "filename": "src/librustc_ast_lowering/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_ast_lowering%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_ast_lowering%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpath.rs?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -12,8 +12,8 @@ use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n-use log::debug;\n use smallvec::smallvec;\n+use tracing::debug;\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     crate fn lower_qpath("}, {"sha": "6db9bce3164bb120579594334a151b12f55d220d", "filename": "src/librustc_ast_passes/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_ast_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_ast_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2FCargo.toml?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -10,7 +10,7 @@ path = \"lib.rs\"\n \n [dependencies]\n itertools = \"0.8\"\n-log = { package = \"tracing\", version = \"0.1\" }\n+tracing = \"0.1\"\n rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_attr = { path = \"../librustc_attr\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "2fe208c3ce68caf5cb02d2f0aef4466496ec827f", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -10,7 +10,7 @@ use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n \n-use log::debug;\n+use tracing::debug;\n \n macro_rules! gate_feature_fn {\n     ($cx: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr) => {{"}, {"sha": "d26205c791dc0f67c70d366de2c43ee301de57c5", "filename": "src/librustc_ast_pretty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_ast_pretty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_ast_pretty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2FCargo.toml?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -10,7 +10,7 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-log = { package = \"tracing\", version = \"0.1\" }\n+tracing = \"0.1\"\n rustc_span = { path = \"../librustc_span\" }\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_target = { path = \"../librustc_target\" }"}, {"sha": "ca7f127ced60d4c5111e24ee4ce8b3b2ea7f719b", "filename": "src/librustc_ast_pretty/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_ast_pretty%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_ast_pretty%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpp.rs?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -132,10 +132,10 @@\n //! methods called `Printer::scan_*`, and the 'PRINT' process is the\n //! method called `Printer::print`.\n \n-use log::debug;\n use std::borrow::Cow;\n use std::collections::VecDeque;\n use std::fmt;\n+use tracing::debug;\n \n /// How to break. Described in more detail in the module docs.\n #[derive(Clone, Copy, PartialEq)]"}, {"sha": "051b75148e5095df27ca39b1dd4f96b345e9b120", "filename": "src/librustc_error_codes/error_codes/E0733.md", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_error_codes%2Ferror_codes%2FE0733.md", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_error_codes%2Ferror_codes%2FE0733.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0733.md?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -1,4 +1,6 @@\n-Recursion in an `async fn` requires boxing. For example, this will not compile:\n+An [`async`] function used recursion without boxing.\n+\n+Erroneous code example:\n \n ```edition2018,compile_fail,E0733\n async fn foo(n: usize) {\n@@ -8,8 +10,8 @@ async fn foo(n: usize) {\n }\n ```\n \n-To achieve async recursion, the `async fn` needs to be desugared\n-such that the `Future` is explicit in the return type:\n+To perform async recursion, the `async fn` needs to be desugared such that the\n+`Future` is explicit in the return type:\n \n ```edition2018,compile_fail,E0720\n use std::future::Future;\n@@ -36,5 +38,7 @@ fn foo_recursive(n: usize) -> Pin<Box<dyn Future<Output = ()>>> {\n }\n ```\n \n-The `Box<...>` ensures that the result is of known size,\n-and the pin is required to keep it in the same place in memory.\n+The `Box<...>` ensures that the result is of known size, and the pin is\n+required to keep it in the same place in memory.\n+\n+[`async`]: https://doc.rust-lang.org/std/keyword.async.html"}, {"sha": "14cff3613e02394acfe42a93b269013e6cf82f4b", "filename": "src/librustc_error_codes/error_codes/E0744.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_error_codes%2Ferror_codes%2FE0744.md", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_error_codes%2Ferror_codes%2FE0744.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0744.md?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -1,7 +1,6 @@\n-Control-flow expressions are not allowed inside a const context.\n+A control-flow expression was used inside a const context.\n \n-At the moment, `if` and `match`, as well as the looping constructs `for`,\n-`while`, and `loop`, are forbidden inside a `const`, `static`, or `const fn`.\n+Erroneous code example:\n \n ```compile_fail,E0744\n const _: i32 = {\n@@ -13,6 +12,9 @@ const _: i32 = {\n };\n ```\n \n+At the moment, `if` and `match`, as well as the looping constructs `for`,\n+`while`, and `loop`, are forbidden inside a `const`, `static`, or `const fn`.\n+\n This will be allowed at some point in the future, but the implementation is not\n yet complete. See the tracking issue for [conditionals] or [loops] in a const\n context for the current status."}, {"sha": "9bc6c054e4d018840cc20987e946dfeb6cbf0561", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -13,7 +13,7 @@ use rustc_expand::base::SyntaxExtension;\n use rustc_hir::def_id::{CrateNum, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::middle::cstore::{CrateSource, DepKind, ExternCrate};\n+use rustc_middle::middle::cstore::{CrateDepKind, CrateSource, ExternCrate};\n use rustc_middle::middle::cstore::{ExternCrateSource, MetadataLoaderDyn};\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::{self, CrateType, ExternLocation};\n@@ -306,7 +306,7 @@ impl<'a> CrateLoader<'a> {\n         host_lib: Option<Library>,\n         root: Option<&CratePaths>,\n         lib: Library,\n-        dep_kind: DepKind,\n+        dep_kind: CrateDepKind,\n         name: Symbol,\n     ) -> Result<CrateNum, CrateError> {\n         let _prof_timer = self.sess.prof.generic_activity(\"metadata_register_crate\");\n@@ -437,7 +437,7 @@ impl<'a> CrateLoader<'a> {\n         &'b mut self,\n         name: Symbol,\n         span: Span,\n-        dep_kind: DepKind,\n+        dep_kind: CrateDepKind,\n         dep: Option<(&'b CratePaths, &'b CrateDep)>,\n     ) -> CrateNum {\n         if dep.is_none() {\n@@ -450,7 +450,7 @@ impl<'a> CrateLoader<'a> {\n     fn maybe_resolve_crate<'b>(\n         &'b mut self,\n         name: Symbol,\n-        mut dep_kind: DepKind,\n+        mut dep_kind: CrateDepKind,\n         dep: Option<(&'b CratePaths, &'b CrateDep)>,\n     ) -> Result<CrateNum, CrateError> {\n         info!(\"resolving crate `{}`\", name);\n@@ -487,7 +487,7 @@ impl<'a> CrateLoader<'a> {\n             match self.load(&mut locator)? {\n                 Some(res) => (res, None),\n                 None => {\n-                    dep_kind = DepKind::MacrosOnly;\n+                    dep_kind = CrateDepKind::MacrosOnly;\n                     match self.load_proc_macro(&mut locator, path_kind)? {\n                         Some(res) => res,\n                         None => return Err(locator.into_error()),\n@@ -500,7 +500,7 @@ impl<'a> CrateLoader<'a> {\n             (LoadResult::Previous(cnum), None) => {\n                 let data = self.cstore.get_crate_data(cnum);\n                 if data.is_proc_macro_crate() {\n-                    dep_kind = DepKind::MacrosOnly;\n+                    dep_kind = CrateDepKind::MacrosOnly;\n                 }\n                 data.update_dep_kind(|data_dep_kind| cmp::max(data_dep_kind, dep_kind));\n                 Ok(cnum)\n@@ -560,7 +560,7 @@ impl<'a> CrateLoader<'a> {\n         crate_root: &CrateRoot<'_>,\n         metadata: &MetadataBlob,\n         krate: CrateNum,\n-        dep_kind: DepKind,\n+        dep_kind: CrateDepKind,\n     ) -> Result<CrateNumMap, CrateError> {\n         debug!(\"resolving deps of external crate\");\n         if crate_root.is_proc_macro_crate() {\n@@ -579,7 +579,7 @@ impl<'a> CrateLoader<'a> {\n                 dep.name, dep.hash, dep.extra_filename\n             );\n             let dep_kind = match dep_kind {\n-                DepKind::MacrosOnly => DepKind::MacrosOnly,\n+                CrateDepKind::MacrosOnly => CrateDepKind::MacrosOnly,\n                 _ => dep.kind,\n             };\n             let cnum = self.maybe_resolve_crate(dep.name, dep_kind, Some((root, &dep)))?;\n@@ -646,7 +646,7 @@ impl<'a> CrateLoader<'a> {\n                 self.inject_dependency_if(cnum, \"a panic runtime\", &|data| {\n                     data.needs_panic_runtime()\n                 });\n-                runtime_found = runtime_found || data.dep_kind() == DepKind::Explicit;\n+                runtime_found = runtime_found || data.dep_kind() == CrateDepKind::Explicit;\n             }\n         });\n \n@@ -675,7 +675,7 @@ impl<'a> CrateLoader<'a> {\n         };\n         info!(\"panic runtime not found -- loading {}\", name);\n \n-        let cnum = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None);\n+        let cnum = self.resolve_crate(name, DUMMY_SP, CrateDepKind::Implicit, None);\n         let data = self.cstore.get_crate_data(cnum);\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n@@ -705,7 +705,7 @@ impl<'a> CrateLoader<'a> {\n             info!(\"loading profiler\");\n \n             let name = sym::profiler_builtins;\n-            let cnum = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None);\n+            let cnum = self.resolve_crate(name, DUMMY_SP, CrateDepKind::Implicit, None);\n             let data = self.cstore.get_crate_data(cnum);\n \n             // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n@@ -901,9 +901,9 @@ impl<'a> CrateLoader<'a> {\n                     None => item.ident.name,\n                 };\n                 let dep_kind = if attr::contains_name(&item.attrs, sym::no_link) {\n-                    DepKind::MacrosOnly\n+                    CrateDepKind::MacrosOnly\n                 } else {\n-                    DepKind::Explicit\n+                    CrateDepKind::Explicit\n                 };\n \n                 let cnum = self.resolve_crate(name, item.span, dep_kind, None);\n@@ -925,7 +925,7 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     pub fn process_path_extern(&mut self, name: Symbol, span: Span) -> CrateNum {\n-        let cnum = self.resolve_crate(name, span, DepKind::Explicit, None);\n+        let cnum = self.resolve_crate(name, span, CrateDepKind::Explicit, None);\n \n         self.update_extern_crate(\n             cnum,\n@@ -942,6 +942,6 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     pub fn maybe_process_path_extern(&mut self, name: Symbol) -> Option<CrateNum> {\n-        self.maybe_resolve_crate(name, DepKind::Explicit, None).ok()\n+        self.maybe_resolve_crate(name, CrateDepKind::Explicit, None).ok()\n     }\n }"}, {"sha": "bb5ae4d0557c9866a221ae6d7053b519c2397f9b", "filename": "src/librustc_metadata/dependency_format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_metadata%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_metadata%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdependency_format.rs?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -56,7 +56,7 @@ use crate::creader::CStore;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::CrateNum;\n use rustc_middle::middle::cstore::LinkagePreference::{self, RequireDynamic, RequireStatic};\n-use rustc_middle::middle::cstore::{self, DepKind};\n+use rustc_middle::middle::cstore::{self, CrateDepKind};\n use rustc_middle::middle::dependency_format::{Dependencies, DependencyList, Linkage};\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::CrateType;\n@@ -188,7 +188,7 @@ fn calculate_type(tcx: TyCtxt<'_>, ty: CrateType) -> DependencyList {\n         let src = tcx.used_crate_source(cnum);\n         if src.dylib.is_none()\n             && !formats.contains_key(&cnum)\n-            && tcx.dep_kind(cnum) == DepKind::Explicit\n+            && tcx.dep_kind(cnum) == CrateDepKind::Explicit\n         {\n             assert!(src.rlib.is_some() || src.rmeta.is_some());\n             log::info!(\"adding staticlib: {}\", tcx.crate_name(cnum));\n@@ -284,7 +284,7 @@ fn attempt_static(tcx: TyCtxt<'_>) -> Option<DependencyList> {\n     let last_crate = tcx.crates().len();\n     let mut ret = (1..last_crate + 1)\n         .map(|cnum| {\n-            if tcx.dep_kind(CrateNum::new(cnum)) == DepKind::Explicit {\n+            if tcx.dep_kind(CrateNum::new(cnum)) == CrateDepKind::Explicit {\n                 Linkage::Static\n             } else {\n                 Linkage::NotLinked"}, {"sha": "3c045df45da161a35daf4ee15a2e80b022b220b6", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -100,7 +100,7 @@ crate struct CrateMetadata {\n     /// Same ID set as `cnum_map` plus maybe some injected crates like panic runtime.\n     dependencies: Lock<Vec<CrateNum>>,\n     /// How to link (or not link) this crate to the currently compiled crate.\n-    dep_kind: Lock<DepKind>,\n+    dep_kind: Lock<CrateDepKind>,\n     /// Filesystem location of this crate.\n     source: CrateSource,\n     /// Whether or not this crate should be consider a private dependency\n@@ -1669,7 +1669,7 @@ impl CrateMetadata {\n         raw_proc_macros: Option<&'static [ProcMacro]>,\n         cnum: CrateNum,\n         cnum_map: CrateNumMap,\n-        dep_kind: DepKind,\n+        dep_kind: CrateDepKind,\n         source: CrateSource,\n         private_dep: bool,\n         host_hash: Option<Svh>,\n@@ -1727,11 +1727,11 @@ impl CrateMetadata {\n         &self.source\n     }\n \n-    crate fn dep_kind(&self) -> DepKind {\n+    crate fn dep_kind(&self) -> CrateDepKind {\n         *self.dep_kind.lock()\n     }\n \n-    crate fn update_dep_kind(&self, f: impl FnOnce(DepKind) -> DepKind) {\n+    crate fn update_dep_kind(&self, f: impl FnOnce(CrateDepKind) -> CrateDepKind) {\n         self.dep_kind.with_lock(|dep_kind| *dep_kind = f(*dep_kind))\n     }\n "}, {"sha": "12d2f50363c1a85e343e7fbccfd6e196c65b0d1d", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -11,7 +11,7 @@ use rustc_hir::def_id::{DefId, DefIndex};\n use rustc_hir::lang_items;\n use rustc_index::{bit_set::FiniteBitSet, vec::IndexVec};\n use rustc_middle::hir::exports::Export;\n-use rustc_middle::middle::cstore::{DepKind, ForeignModule, LinkagePreference, NativeLib};\n+use rustc_middle::middle::cstore::{CrateDepKind, ForeignModule, LinkagePreference, NativeLib};\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc_middle::mir;\n use rustc_middle::ty::{self, ReprOptions, Ty};\n@@ -226,7 +226,7 @@ crate struct CrateDep {\n     pub name: Symbol,\n     pub hash: Svh,\n     pub host_hash: Option<Svh>,\n-    pub kind: DepKind,\n+    pub kind: CrateDepKind,\n     pub extra_filename: String,\n }\n "}, {"sha": "0a34c06adf063bae570f3c72b4b1c98d2bd15ddd", "filename": "src/librustc_middle/middle/cstore.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_middle%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_middle%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fcstore.rs?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -40,7 +40,7 @@ impl CrateSource {\n \n #[derive(RustcEncodable, RustcDecodable, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Debug)]\n #[derive(HashStable)]\n-pub enum DepKind {\n+pub enum CrateDepKind {\n     /// A dependency that is only used for its macros.\n     MacrosOnly,\n     /// A dependency that is always injected into the dependency list and so\n@@ -51,11 +51,11 @@ pub enum DepKind {\n     Explicit,\n }\n \n-impl DepKind {\n+impl CrateDepKind {\n     pub fn macros_only(self) -> bool {\n         match self {\n-            DepKind::MacrosOnly => true,\n-            DepKind::Implicit | DepKind::Explicit => false,\n+            CrateDepKind::MacrosOnly => true,\n+            CrateDepKind::Implicit | CrateDepKind::Explicit => false,\n         }\n     }\n }"}, {"sha": "862c046358b8418f539c12c44158ae46127fab79", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -1186,7 +1186,7 @@ rustc_queries! {\n     }\n \n     Other {\n-        query dep_kind(_: CrateNum) -> DepKind {\n+        query dep_kind(_: CrateNum) -> CrateDepKind {\n             eval_always\n             desc { \"fetching what a dependency looks like\" }\n         }"}, {"sha": "b39c0b5190a6d951c59cae210ccbd49dcee06544", "filename": "src/librustc_middle/ty/query/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -1,10 +1,10 @@\n-use crate::dep_graph::{self, DepNode, DepNodeParams};\n+use crate::dep_graph::{self, DepKind, DepNode, DepNodeParams};\n use crate::hir::exports::Export;\n use crate::hir::map;\n use crate::infer::canonical::{self, Canonical};\n use crate::lint::LintLevelMap;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n-use crate::middle::cstore::{CrateSource, DepKind};\n+use crate::middle::cstore::{CrateDepKind, CrateSource};\n use crate::middle::cstore::{ExternCrate, ForeignModule, LinkagePreference, NativeLib};\n use crate::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use crate::middle::lib_features::LibFeatures;\n@@ -161,7 +161,7 @@ pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool\n     // hit the cache instead of having to go through `force_from_dep_node`.\n     // This assertion makes sure, we actually keep applying the solution above.\n     debug_assert!(\n-        dep_node.kind != crate::dep_graph::DepKind::codegen_unit,\n+        dep_node.kind != DepKind::codegen_unit,\n         \"calling force_from_dep_node() on DepKind::codegen_unit\"\n     );\n \n@@ -172,14 +172,14 @@ pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool\n     rustc_dep_node_force!([dep_node, tcx]\n         // These are inputs that are expected to be pre-allocated and that\n         // should therefore always be red or green already.\n-        crate::dep_graph::DepKind::CrateMetadata |\n+        DepKind::CrateMetadata |\n \n         // These are anonymous nodes.\n-        crate::dep_graph::DepKind::TraitSelect |\n+        DepKind::TraitSelect |\n \n         // We don't have enough information to reconstruct the query key of\n         // these.\n-        crate::dep_graph::DepKind::CompileCodegenUnit => {\n+        DepKind::CompileCodegenUnit => {\n             bug!(\"force_from_dep_node: encountered {:?}\", dep_node)\n         }\n     );"}, {"sha": "1f988f7d81b725bbf39c7a48ea3551c86fec4ac0", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "patch": "@@ -138,7 +138,6 @@ const PERMITTED_DEPENDENCIES: &[&str] = &[\n     \"rand_chacha\",\n     \"rand_core\",\n     \"rand_hc\",\n-    \"rand_isaac\",\n     \"rand_pcg\",\n     \"rand_xorshift\",\n     \"redox_syscall\","}]}