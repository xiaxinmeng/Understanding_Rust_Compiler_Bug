{"sha": "8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyMTZiMzU5ZTU0MmQ2ZDg0MmJjM2VkM2ZiYTNjNjdkZTVhZDYwZmE=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-11-19T22:58:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-19T22:58:42Z"}, "message": "Rollup merge of #79185 - petrochenkov:derattr2, r=Aaron1011\n\nexpand/resolve: Pre-requisites to \"Turn `#[derive]` into a regular macro attribute\"\n\nMiscellaneous refactorings and error reporting changes extracted from https://github.com/rust-lang/rust/pull/79078.\n\nUnlike https://github.com/rust-lang/rust/pull/79078 this PR doesn't make any observable changes to the language or library.\nr? ```@Aaron1011```", "tree": {"sha": "2a600321f93e27da52723d7250b1c371e17b1150", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a600321f93e27da52723d7250b1c371e17b1150"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJftviiCRBK7hj4Ov3rIwAAdHIIAGs9zDUpN+7BPO4B3kHjcHjt\nI+orhYUjXw+k49lylfQ5mN0gqPAKC+JRczipSM3xntv8goxXj/Ac1gT33mD8B2X3\ne7qlGd+AHMBEGNCvczWpbfIv8M5qUezKGZCshmG9rFb9Nhn0DAAfdXGJxFNy69Oa\ni0VcFxCgmF+00U/0lNGNCsvjqdgxUKH6AXO3kpxlDXbDfJWaMw9R/B2J9t1mLbJI\n4p2ava6IZjE3kHmu92lbFAoWYUsNTNDTVuA3GAlxrXfAgQjaeeJHN9SvscbBJyhh\n94cTadF+ayajkNTTH5GMlA3XFfcDwQ6hXbrhx1EVWOAe0/c+zRDVh68M6Q+v5H4=\n=nzTM\n-----END PGP SIGNATURE-----\n", "payload": "tree 2a600321f93e27da52723d7250b1c371e17b1150\nparent d5ee4edee10e1d39e205341eeace4f9ba26d389a\nparent d575aa4d580676eac7c02092ca94e5cfa421b288\nauthor Dylan DPC <dylan.dpc@gmail.com> 1605826722 +0100\ncommitter GitHub <noreply@github.com> 1605826722 +0100\n\nRollup merge of #79185 - petrochenkov:derattr2, r=Aaron1011\n\nexpand/resolve: Pre-requisites to \"Turn `#[derive]` into a regular macro attribute\"\n\nMiscellaneous refactorings and error reporting changes extracted from https://github.com/rust-lang/rust/pull/79078.\n\nUnlike https://github.com/rust-lang/rust/pull/79078 this PR doesn't make any observable changes to the language or library.\nr? ```@Aaron1011```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "html_url": "https://github.com/rust-lang/rust/commit/8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5ee4edee10e1d39e205341eeace4f9ba26d389a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5ee4edee10e1d39e205341eeace4f9ba26d389a", "html_url": "https://github.com/rust-lang/rust/commit/d5ee4edee10e1d39e205341eeace4f9ba26d389a"}, {"sha": "d575aa4d580676eac7c02092ca94e5cfa421b288", "url": "https://api.github.com/repos/rust-lang/rust/commits/d575aa4d580676eac7c02092ca94e5cfa421b288", "html_url": "https://github.com/rust-lang/rust/commit/d575aa4d580676eac7c02092ca94e5cfa421b288"}], "stats": {"total": 1135, "additions": 481, "deletions": 654}, "files": [{"sha": "09ed1af345675befdf9ed2678922cbeeafb30153", "filename": "compiler/rustc_builtin_macros/src/cfg_accessible.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_accessible.rs?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -1,7 +1,7 @@\n //! Implementation of the `#[cfg_accessible(path)]` attribute macro.\n \n use rustc_ast as ast;\n-use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, MultiItemModifier};\n+use rustc_expand::base::{Annotatable, ExpandResult, ExtCtxt, Indeterminate, MultiItemModifier};\n use rustc_feature::AttributeTemplate;\n use rustc_parse::validate_attr;\n use rustc_span::symbol::sym;\n@@ -31,7 +31,7 @@ impl MultiItemModifier for Expander {\n     fn expand(\n         &self,\n         ecx: &mut ExtCtxt<'_>,\n-        _span: Span,\n+        span: Span,\n         meta_item: &ast::MetaItem,\n         item: Annotatable,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n@@ -49,11 +49,14 @@ impl MultiItemModifier for Expander {\n             None => return ExpandResult::Ready(Vec::new()),\n         };\n \n-        let failure_msg = \"cannot determine whether the path is accessible or not\";\n         match ecx.resolver.cfg_accessible(ecx.current_expansion.id, path) {\n             Ok(true) => ExpandResult::Ready(vec![item]),\n             Ok(false) => ExpandResult::Ready(Vec::new()),\n-            Err(_) => ExpandResult::Retry(item, failure_msg.into()),\n+            Err(Indeterminate) if ecx.force_mode => {\n+                ecx.span_err(span, \"cannot determine whether the path is accessible or not\");\n+                ExpandResult::Ready(vec![item])\n+            }\n+            Err(Indeterminate) => ExpandResult::Retry(item),\n         }\n     }\n }"}, {"sha": "a767de53dae1fcad387ff1e3dc48afbc6f24f3a1", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -407,13 +407,7 @@ impl<'a> TraitDef<'a> {\n                             _ => false,\n                         })\n                     }\n-                    _ => {\n-                        // Non-ADT derive is an error, but it should have been\n-                        // set earlier; see\n-                        // librustc_expand/expand.rs:MacroExpander::fully_expand_fragment()\n-                        // librustc_expand/base.rs:Annotatable::derive_allowed()\n-                        return;\n-                    }\n+                    _ => unreachable!(),\n                 };\n                 let container_id = cx.current_expansion.id.expn_data().parent;\n                 let always_copy = has_no_type_params && cx.resolver.has_derive_copy(container_id);\n@@ -475,12 +469,7 @@ impl<'a> TraitDef<'a> {\n                 );\n                 push(Annotatable::Item(P(ast::Item { attrs, ..(*newitem).clone() })))\n             }\n-            _ => {\n-                // Non-Item derive is an error, but it should have been\n-                // set earlier; see\n-                // librustc_expand/expand.rs:MacroExpander::fully_expand_fragment()\n-                // librustc_expand/base.rs:Annotatable::derive_allowed()\n-            }\n+            _ => unreachable!(),\n         }\n     }\n "}, {"sha": "72d94af4694abf477ead0f110f9a47b3e8a70d89", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -98,13 +98,7 @@ fn inject_impl_of_structural_trait(\n ) {\n     let item = match *item {\n         Annotatable::Item(ref item) => item,\n-        _ => {\n-            // Non-Item derive is an error, but it should have been\n-            // set earlier; see\n-            // librustc_expand/expand.rs:MacroExpander::fully_expand_fragment()\n-            // librustc_expand/base.rs:Annotatable::derive_allowed()\n-            return;\n-        }\n+        _ => unreachable!(),\n     };\n \n     let generics = match item.kind {"}, {"sha": "1c76c31e1a7ff9131311928e181e41bbef1679b0", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -251,8 +251,7 @@ pub enum ExpandResult<T, U> {\n     /// Expansion produced a result (possibly dummy).\n     Ready(T),\n     /// Expansion could not produce a result and needs to be retried.\n-    /// The string is an explanation that will be printed if we are stuck in an infinite retry loop.\n-    Retry(U, String),\n+    Retry(U),\n }\n \n // `meta_item` is the attribute, and `item` is the item being modified.\n@@ -889,8 +888,10 @@ pub trait ResolverExpand {\n     /// Some parent node that is close enough to the given macro call.\n     fn lint_node_id(&mut self, expn_id: ExpnId) -> NodeId;\n \n+    // Resolver interfaces for specific built-in macros.\n+    /// Does `#[derive(...)]` attribute with the given `ExpnId` have built-in `Copy` inside it?\n     fn has_derive_copy(&self, expn_id: ExpnId) -> bool;\n-    fn add_derive_copy(&mut self, expn_id: ExpnId);\n+    /// Path resolution logic for `#[cfg_accessible(path)]`.\n     fn cfg_accessible(&mut self, expn_id: ExpnId, path: &ast::Path) -> Result<bool, Indeterminate>;\n }\n \n@@ -919,6 +920,9 @@ pub struct ExtCtxt<'a> {\n     pub root_path: PathBuf,\n     pub resolver: &'a mut dyn ResolverExpand,\n     pub current_expansion: ExpansionData,\n+    /// Error recovery mode entered when expansion is stuck\n+    /// (or during eager expansion, but that's a hack).\n+    pub force_mode: bool,\n     pub expansions: FxHashMap<Span, Vec<String>>,\n     /// Called directly after having parsed an external `mod foo;` in expansion.\n     pub(super) extern_mod_loaded: Option<&'a dyn Fn(&ast::Crate)>,\n@@ -945,6 +949,7 @@ impl<'a> ExtCtxt<'a> {\n                 directory_ownership: DirectoryOwnership::Owned { relative: None },\n                 prior_type_ascription: None,\n             },\n+            force_mode: false,\n             expansions: FxHashMap::default(),\n         }\n     }"}, {"sha": "563783c5b795db575cf37bf1061798d1dfbd15a9", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -1,5 +1,7 @@\n //! Conditional compilation stripping.\n \n+use crate::base::Annotatable;\n+\n use rustc_ast::attr::HasAttrs;\n use rustc_ast::mut_visit::*;\n use rustc_ast::ptr::P;\n@@ -496,6 +498,49 @@ impl<'a> StripUnconfigured<'a> {\n     pub fn configure_fn_decl(&mut self, fn_decl: &mut ast::FnDecl) {\n         fn_decl.inputs.flat_map_in_place(|arg| self.configure(arg));\n     }\n+\n+    pub fn fully_configure(&mut self, item: Annotatable) -> Annotatable {\n+        // Since the item itself has already been configured by the InvocationCollector,\n+        // we know that fold result vector will contain exactly one element\n+        match item {\n+            Annotatable::Item(item) => Annotatable::Item(self.flat_map_item(item).pop().unwrap()),\n+            Annotatable::TraitItem(item) => {\n+                Annotatable::TraitItem(self.flat_map_trait_item(item).pop().unwrap())\n+            }\n+            Annotatable::ImplItem(item) => {\n+                Annotatable::ImplItem(self.flat_map_impl_item(item).pop().unwrap())\n+            }\n+            Annotatable::ForeignItem(item) => {\n+                Annotatable::ForeignItem(self.flat_map_foreign_item(item).pop().unwrap())\n+            }\n+            Annotatable::Stmt(stmt) => {\n+                Annotatable::Stmt(stmt.map(|stmt| self.flat_map_stmt(stmt).pop().unwrap()))\n+            }\n+            Annotatable::Expr(mut expr) => Annotatable::Expr({\n+                self.visit_expr(&mut expr);\n+                expr\n+            }),\n+            Annotatable::Arm(arm) => Annotatable::Arm(self.flat_map_arm(arm).pop().unwrap()),\n+            Annotatable::Field(field) => {\n+                Annotatable::Field(self.flat_map_field(field).pop().unwrap())\n+            }\n+            Annotatable::FieldPat(fp) => {\n+                Annotatable::FieldPat(self.flat_map_field_pattern(fp).pop().unwrap())\n+            }\n+            Annotatable::GenericParam(param) => {\n+                Annotatable::GenericParam(self.flat_map_generic_param(param).pop().unwrap())\n+            }\n+            Annotatable::Param(param) => {\n+                Annotatable::Param(self.flat_map_param(param).pop().unwrap())\n+            }\n+            Annotatable::StructField(sf) => {\n+                Annotatable::StructField(self.flat_map_struct_field(sf).pop().unwrap())\n+            }\n+            Annotatable::Variant(v) => {\n+                Annotatable::Variant(self.flat_map_variant(v).pop().unwrap())\n+            }\n+        }\n+    }\n }\n \n impl<'a> MutVisitor for StripUnconfigured<'a> {"}, {"sha": "5be2fee8b38fa8074505a3e7c8aed90060c8625a", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 126, "deletions": 257, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -209,6 +209,28 @@ impl AstFragmentKind {\n         self.make_from(DummyResult::any(span)).expect(\"couldn't create a dummy AST fragment\")\n     }\n \n+    /// Fragment supports macro expansion and not just inert attributes, `cfg` and `cfg_attr`.\n+    pub fn supports_macro_expansion(self) -> bool {\n+        match self {\n+            AstFragmentKind::OptExpr\n+            | AstFragmentKind::Expr\n+            | AstFragmentKind::Pat\n+            | AstFragmentKind::Ty\n+            | AstFragmentKind::Stmts\n+            | AstFragmentKind::Items\n+            | AstFragmentKind::TraitItems\n+            | AstFragmentKind::ImplItems\n+            | AstFragmentKind::ForeignItems => true,\n+            AstFragmentKind::Arms\n+            | AstFragmentKind::Fields\n+            | AstFragmentKind::FieldPats\n+            | AstFragmentKind::GenericParams\n+            | AstFragmentKind::Params\n+            | AstFragmentKind::StructFields\n+            | AstFragmentKind::Variants => false,\n+        }\n+    }\n+\n     fn expect_from_annotatables<I: IntoIterator<Item = Annotatable>>(\n         self,\n         items: I,\n@@ -404,6 +426,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     // Recursively expand all macro invocations in this AST fragment.\n     pub fn fully_expand_fragment(&mut self, input_fragment: AstFragment) -> AstFragment {\n         let orig_expansion_data = self.cx.current_expansion.clone();\n+        let orig_force_mode = self.cx.force_mode;\n         self.cx.current_expansion.depth = 0;\n \n         // Collect all macro invocations and replace them with placeholders.\n@@ -432,6 +455,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n                 invocations = mem::take(&mut undetermined_invocations);\n                 force = !mem::replace(&mut progress, false);\n+                if force && self.monotonic {\n+                    self.cx.sess.delay_span_bug(\n+                        invocations.last().unwrap().0.span(),\n+                        \"expansion entered force mode without producing any errors\",\n+                    );\n+                }\n                 continue;\n             };\n \n@@ -460,18 +489,19 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n             let ExpansionData { depth, id: expn_id, .. } = invoc.expansion_data;\n             self.cx.current_expansion = invoc.expansion_data.clone();\n+            self.cx.force_mode = force;\n \n             // FIXME(jseyfried): Refactor out the following logic\n+            let fragment_kind = invoc.fragment_kind;\n             let (expanded_fragment, new_invocations) = match res {\n                 InvocationRes::Single(ext) => match self.expand_invoc(invoc, &ext.kind) {\n                     ExpandResult::Ready(fragment) => self.collect_invocations(fragment, &[]),\n-                    ExpandResult::Retry(invoc, explanation) => {\n+                    ExpandResult::Retry(invoc) => {\n                         if force {\n-                            // We are stuck, stop retrying and produce a dummy fragment.\n-                            let span = invoc.span();\n-                            self.cx.span_err(span, &explanation);\n-                            let fragment = invoc.fragment_kind.dummy(span);\n-                            self.collect_invocations(fragment, &[])\n+                            self.cx.span_bug(\n+                                invoc.span(),\n+                                \"expansion entered force mode but is still stuck\",\n+                            );\n                         } else {\n                             // Cannot expand, will retry this invocation later.\n                             undetermined_invocations\n@@ -483,36 +513,45 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 InvocationRes::DeriveContainer(_exts) => {\n                     // FIXME: Consider using the derive resolutions (`_exts`) immediately,\n                     // instead of enqueuing the derives to be resolved again later.\n-                    let (derives, item) = match invoc.kind {\n+                    let (derives, mut item) = match invoc.kind {\n                         InvocationKind::DeriveContainer { derives, item } => (derives, item),\n                         _ => unreachable!(),\n                     };\n-                    if !item.derive_allowed() {\n+                    let (item, derive_placeholders) = if !item.derive_allowed() {\n                         self.error_derive_forbidden_on_non_adt(&derives, &item);\n-                    }\n+                        item.visit_attrs(|attrs| attrs.retain(|a| !a.has_name(sym::derive)));\n+                        (item, Vec::new())\n+                    } else {\n+                        let mut item = StripUnconfigured {\n+                            sess: self.cx.sess,\n+                            features: self.cx.ecfg.features,\n+                        }\n+                        .fully_configure(item);\n+                        item.visit_attrs(|attrs| attrs.retain(|a| !a.has_name(sym::derive)));\n+\n+                        invocations.reserve(derives.len());\n+                        let derive_placeholders = derives\n+                            .into_iter()\n+                            .map(|path| {\n+                                let expn_id = ExpnId::fresh(None);\n+                                invocations.push((\n+                                    Invocation {\n+                                        kind: InvocationKind::Derive { path, item: item.clone() },\n+                                        fragment_kind,\n+                                        expansion_data: ExpansionData {\n+                                            id: expn_id,\n+                                            ..self.cx.current_expansion.clone()\n+                                        },\n+                                    },\n+                                    None,\n+                                ));\n+                                NodeId::placeholder_from_expn_id(expn_id)\n+                            })\n+                            .collect::<Vec<_>>();\n+                        (item, derive_placeholders)\n+                    };\n \n-                    let mut item = self.fully_configure(item);\n-                    item.visit_attrs(|attrs| attrs.retain(|a| !a.has_name(sym::derive)));\n-\n-                    let mut derive_placeholders = Vec::with_capacity(derives.len());\n-                    invocations.reserve(derives.len());\n-                    for path in derives {\n-                        let expn_id = ExpnId::fresh(None);\n-                        derive_placeholders.push(NodeId::placeholder_from_expn_id(expn_id));\n-                        invocations.push((\n-                            Invocation {\n-                                kind: InvocationKind::Derive { path, item: item.clone() },\n-                                fragment_kind: invoc.fragment_kind,\n-                                expansion_data: ExpansionData {\n-                                    id: expn_id,\n-                                    ..invoc.expansion_data.clone()\n-                                },\n-                            },\n-                            None,\n-                        ));\n-                    }\n-                    let fragment =\n-                        invoc.fragment_kind.expect_from_annotatables(::std::iter::once(item));\n+                    let fragment = fragment_kind.expect_from_annotatables(::std::iter::once(item));\n                     self.collect_invocations(fragment, &derive_placeholders)\n                 }\n             };\n@@ -526,6 +565,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n \n         self.cx.current_expansion = orig_expansion_data;\n+        self.cx.force_mode = orig_force_mode;\n \n         // Finally incorporate all the expanded macros into the input AST fragment.\n         let mut placeholder_expander = PlaceholderExpander::new(self.cx, self.monotonic);\n@@ -601,48 +641,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         (fragment, invocations)\n     }\n \n-    fn fully_configure(&mut self, item: Annotatable) -> Annotatable {\n-        let mut cfg = StripUnconfigured { sess: &self.cx.sess, features: self.cx.ecfg.features };\n-        // Since the item itself has already been configured by the InvocationCollector,\n-        // we know that fold result vector will contain exactly one element\n-        match item {\n-            Annotatable::Item(item) => Annotatable::Item(cfg.flat_map_item(item).pop().unwrap()),\n-            Annotatable::TraitItem(item) => {\n-                Annotatable::TraitItem(cfg.flat_map_trait_item(item).pop().unwrap())\n-            }\n-            Annotatable::ImplItem(item) => {\n-                Annotatable::ImplItem(cfg.flat_map_impl_item(item).pop().unwrap())\n-            }\n-            Annotatable::ForeignItem(item) => {\n-                Annotatable::ForeignItem(cfg.flat_map_foreign_item(item).pop().unwrap())\n-            }\n-            Annotatable::Stmt(stmt) => {\n-                Annotatable::Stmt(stmt.map(|stmt| cfg.flat_map_stmt(stmt).pop().unwrap()))\n-            }\n-            Annotatable::Expr(mut expr) => Annotatable::Expr({\n-                cfg.visit_expr(&mut expr);\n-                expr\n-            }),\n-            Annotatable::Arm(arm) => Annotatable::Arm(cfg.flat_map_arm(arm).pop().unwrap()),\n-            Annotatable::Field(field) => {\n-                Annotatable::Field(cfg.flat_map_field(field).pop().unwrap())\n-            }\n-            Annotatable::FieldPat(fp) => {\n-                Annotatable::FieldPat(cfg.flat_map_field_pattern(fp).pop().unwrap())\n-            }\n-            Annotatable::GenericParam(param) => {\n-                Annotatable::GenericParam(cfg.flat_map_generic_param(param).pop().unwrap())\n-            }\n-            Annotatable::Param(param) => {\n-                Annotatable::Param(cfg.flat_map_param(param).pop().unwrap())\n-            }\n-            Annotatable::StructField(sf) => {\n-                Annotatable::StructField(cfg.flat_map_struct_field(sf).pop().unwrap())\n-            }\n-            Annotatable::Variant(v) => Annotatable::Variant(cfg.flat_map_variant(v).pop().unwrap()),\n-        }\n-    }\n-\n     fn error_recursion_limit_reached(&mut self) {\n         let expn_data = self.cx.current_expansion.id.expn_data();\n         let suggested_limit = self.cx.ecfg.recursion_limit * 2;\n@@ -735,20 +733,17 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         Ok(meta) => {\n                             let items = match expander.expand(self.cx, span, &meta, item) {\n                                 ExpandResult::Ready(items) => items,\n-                                ExpandResult::Retry(item, explanation) => {\n+                                ExpandResult::Retry(item) => {\n                                     // Reassemble the original invocation for retrying.\n-                                    return ExpandResult::Retry(\n-                                        Invocation {\n-                                            kind: InvocationKind::Attr {\n-                                                attr,\n-                                                item,\n-                                                derives,\n-                                                after_derive,\n-                                            },\n-                                            ..invoc\n+                                    return ExpandResult::Retry(Invocation {\n+                                        kind: InvocationKind::Attr {\n+                                            attr,\n+                                            item,\n+                                            derives,\n+                                            after_derive,\n                                         },\n-                                        explanation,\n-                                    );\n+                                        ..invoc\n+                                    });\n                                 }\n                             };\n                             fragment_kind.expect_from_annotatables(items)\n@@ -772,24 +767,18 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             InvocationKind::Derive { path, item } => match ext {\n                 SyntaxExtensionKind::Derive(expander)\n                 | SyntaxExtensionKind::LegacyDerive(expander) => {\n-                    if !item.derive_allowed() {\n-                        return ExpandResult::Ready(fragment_kind.dummy(span));\n-                    }\n                     if let SyntaxExtensionKind::Derive(..) = ext {\n                         self.gate_proc_macro_input(&item);\n                     }\n                     let meta = ast::MetaItem { kind: ast::MetaItemKind::Word, span, path };\n                     let items = match expander.expand(self.cx, span, &meta, item) {\n                         ExpandResult::Ready(items) => items,\n-                        ExpandResult::Retry(item, explanation) => {\n+                        ExpandResult::Retry(item) => {\n                             // Reassemble the original invocation for retrying.\n-                            return ExpandResult::Retry(\n-                                Invocation {\n-                                    kind: InvocationKind::Derive { path: meta.path, item },\n-                                    ..invoc\n-                                },\n-                                explanation,\n-                            );\n+                            return ExpandResult::Retry(Invocation {\n+                                kind: InvocationKind::Derive { path: meta.path, item },\n+                                ..invoc\n+                            });\n                         }\n                     };\n                     fragment_kind.expect_from_annotatables(items)\n@@ -1034,11 +1023,9 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n \n     fn collect_attr(\n         &mut self,\n-        attr: Option<ast::Attribute>,\n-        derives: Vec<Path>,\n+        (attr, derives, after_derive): (Option<ast::Attribute>, Vec<Path>, bool),\n         item: Annotatable,\n         kind: AstFragmentKind,\n-        after_derive: bool,\n     ) -> AstFragment {\n         self.collect(\n             kind,\n@@ -1054,61 +1041,46 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         attrs: &mut Vec<ast::Attribute>,\n         after_derive: &mut bool,\n     ) -> Option<ast::Attribute> {\n-        let attr = attrs\n+        attrs\n             .iter()\n             .position(|a| {\n                 if a.has_name(sym::derive) {\n                     *after_derive = true;\n                 }\n                 !self.cx.sess.is_attr_known(a) && !is_builtin_attr(a)\n             })\n-            .map(|i| attrs.remove(i));\n-        if let Some(attr) = &attr {\n-            if !self.cx.ecfg.custom_inner_attributes()\n-                && attr.style == ast::AttrStyle::Inner\n-                && !attr.has_name(sym::test)\n-            {\n-                feature_err(\n-                    &self.cx.sess.parse_sess,\n-                    sym::custom_inner_attributes,\n-                    attr.span,\n-                    \"non-builtin inner attributes are unstable\",\n-                )\n-                .emit();\n-            }\n-        }\n-        attr\n+            .map(|i| attrs.remove(i))\n     }\n \n     /// If `item` is an attr invocation, remove and return the macro attribute and derive traits.\n-    fn classify_item(\n+    fn take_first_attr(\n         &mut self,\n         item: &mut impl HasAttrs,\n-    ) -> (Option<ast::Attribute>, Vec<Path>, /* after_derive */ bool) {\n+    ) -> Option<(Option<ast::Attribute>, Vec<Path>, /* after_derive */ bool)> {\n         let (mut attr, mut traits, mut after_derive) = (None, Vec::new(), false);\n \n         item.visit_attrs(|mut attrs| {\n             attr = self.find_attr_invoc(&mut attrs, &mut after_derive);\n             traits = collect_derives(&mut self.cx, &mut attrs);\n         });\n \n-        (attr, traits, after_derive)\n+        if attr.is_some() || !traits.is_empty() { Some((attr, traits, after_derive)) } else { None }\n     }\n \n-    /// Alternative to `classify_item()` that ignores `#[derive]` so invocations fallthrough\n+    /// Alternative to `take_first_attr()` that ignores `#[derive]` so invocations fallthrough\n     /// to the unused-attributes lint (making it an error on statements and expressions\n     /// is a breaking change)\n-    fn classify_nonitem(\n+    fn take_first_attr_no_derive(\n         &mut self,\n         nonitem: &mut impl HasAttrs,\n-    ) -> (Option<ast::Attribute>, /* after_derive */ bool) {\n+    ) -> Option<(Option<ast::Attribute>, Vec<Path>, /* after_derive */ bool)> {\n         let (mut attr, mut after_derive) = (None, false);\n \n         nonitem.visit_attrs(|mut attrs| {\n             attr = self.find_attr_invoc(&mut attrs, &mut after_derive);\n         });\n \n-        (attr, after_derive)\n+        attr.map(|attr| (Some(attr), Vec::new(), after_derive))\n     }\n \n     fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n@@ -1152,23 +1124,14 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         visit_clobber(expr.deref_mut(), |mut expr| {\n             self.cfg.configure_expr_kind(&mut expr.kind);\n \n-            // ignore derives so they remain unused\n-            let (attr, after_derive) = self.classify_nonitem(&mut expr);\n-\n-            if let Some(ref attr_value) = attr {\n+            if let Some(attr) = self.take_first_attr_no_derive(&mut expr) {\n                 // Collect the invoc regardless of whether or not attributes are permitted here\n                 // expansion will eat the attribute so it won't error later.\n-                self.cfg.maybe_emit_expr_attr_err(attr_value);\n+                attr.0.as_ref().map(|attr| self.cfg.maybe_emit_expr_attr_err(attr));\n \n                 // AstFragmentKind::Expr requires the macro to emit an expression.\n                 return self\n-                    .collect_attr(\n-                        attr,\n-                        vec![],\n-                        Annotatable::Expr(P(expr)),\n-                        AstFragmentKind::Expr,\n-                        after_derive,\n-                    )\n+                    .collect_attr(attr, Annotatable::Expr(P(expr)), AstFragmentKind::Expr)\n                     .make_expr()\n                     .into_inner();\n             }\n@@ -1186,16 +1149,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_arm(&mut self, arm: ast::Arm) -> SmallVec<[ast::Arm; 1]> {\n         let mut arm = configure!(self, arm);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut arm);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut arm) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::Arm(arm),\n-                    AstFragmentKind::Arms,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::Arm(arm), AstFragmentKind::Arms)\n                 .make_arms();\n         }\n \n@@ -1205,16 +1161,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_field(&mut self, field: ast::Field) -> SmallVec<[ast::Field; 1]> {\n         let mut field = configure!(self, field);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut field);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut field) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::Field(field),\n-                    AstFragmentKind::Fields,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::Field(field), AstFragmentKind::Fields)\n                 .make_fields();\n         }\n \n@@ -1224,16 +1173,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_field_pattern(&mut self, fp: ast::FieldPat) -> SmallVec<[ast::FieldPat; 1]> {\n         let mut fp = configure!(self, fp);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut fp);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut fp) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::FieldPat(fp),\n-                    AstFragmentKind::FieldPats,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::FieldPat(fp), AstFragmentKind::FieldPats)\n                 .make_field_patterns();\n         }\n \n@@ -1243,16 +1185,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_param(&mut self, p: ast::Param) -> SmallVec<[ast::Param; 1]> {\n         let mut p = configure!(self, p);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut p);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut p) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::Param(p),\n-                    AstFragmentKind::Params,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::Param(p), AstFragmentKind::Params)\n                 .make_params();\n         }\n \n@@ -1262,16 +1197,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_struct_field(&mut self, sf: ast::StructField) -> SmallVec<[ast::StructField; 1]> {\n         let mut sf = configure!(self, sf);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut sf);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut sf) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::StructField(sf),\n-                    AstFragmentKind::StructFields,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::StructField(sf), AstFragmentKind::StructFields)\n                 .make_struct_fields();\n         }\n \n@@ -1281,16 +1209,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_variant(&mut self, variant: ast::Variant) -> SmallVec<[ast::Variant; 1]> {\n         let mut variant = configure!(self, variant);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut variant);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut variant) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::Variant(variant),\n-                    AstFragmentKind::Variants,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::Variant(variant), AstFragmentKind::Variants)\n                 .make_variants();\n         }\n \n@@ -1302,20 +1223,11 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         expr.filter_map(|mut expr| {\n             self.cfg.configure_expr_kind(&mut expr.kind);\n \n-            // Ignore derives so they remain unused.\n-            let (attr, after_derive) = self.classify_nonitem(&mut expr);\n-\n-            if let Some(ref attr_value) = attr {\n-                self.cfg.maybe_emit_expr_attr_err(attr_value);\n+            if let Some(attr) = self.take_first_attr_no_derive(&mut expr) {\n+                attr.0.as_ref().map(|attr| self.cfg.maybe_emit_expr_attr_err(attr));\n \n                 return self\n-                    .collect_attr(\n-                        attr,\n-                        vec![],\n-                        Annotatable::Expr(P(expr)),\n-                        AstFragmentKind::OptExpr,\n-                        after_derive,\n-                    )\n+                    .collect_attr(attr, Annotatable::Expr(P(expr)), AstFragmentKind::OptExpr)\n                     .make_opt_expr()\n                     .map(|expr| expr.into_inner());\n             }\n@@ -1354,25 +1266,13 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n \n         // we'll expand attributes on expressions separately\n         if !stmt.is_expr() {\n-            let (attr, derives, after_derive) = if stmt.is_item() {\n-                // FIXME: Handle custom attributes on statements (#15701)\n-                (None, vec![], false)\n-            } else {\n-                // ignore derives on non-item statements so it falls through\n-                // to the unused-attributes lint\n-                let (attr, after_derive) = self.classify_nonitem(&mut stmt);\n-                (attr, vec![], after_derive)\n-            };\n+            // FIXME: Handle custom attributes on statements (#15701).\n+            let attr =\n+                if stmt.is_item() { None } else { self.take_first_attr_no_derive(&mut stmt) };\n \n-            if attr.is_some() || !derives.is_empty() {\n+            if let Some(attr) = attr {\n                 return self\n-                    .collect_attr(\n-                        attr,\n-                        derives,\n-                        Annotatable::Stmt(P(stmt)),\n-                        AstFragmentKind::Stmts,\n-                        after_derive,\n-                    )\n+                    .collect_attr(attr, Annotatable::Stmt(P(stmt)), AstFragmentKind::Stmts)\n                     .make_stmts();\n             }\n         }\n@@ -1412,16 +1312,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n         let mut item = configure!(self, item);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut item);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut item) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::Item(item),\n-                    AstFragmentKind::Items,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::Item(item), AstFragmentKind::Items)\n                 .make_items();\n         }\n \n@@ -1515,16 +1408,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_trait_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n         let mut item = configure!(self, item);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut item);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut item) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::TraitItem(item),\n-                    AstFragmentKind::TraitItems,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::TraitItem(item), AstFragmentKind::TraitItems)\n                 .make_trait_items();\n         }\n \n@@ -1545,16 +1431,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn flat_map_impl_item(&mut self, item: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n         let mut item = configure!(self, item);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut item);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut item) {\n             return self\n-                .collect_attr(\n-                    attr,\n-                    traits,\n-                    Annotatable::ImplItem(item),\n-                    AstFragmentKind::ImplItems,\n-                    after_derive,\n-                )\n+                .collect_attr(attr, Annotatable::ImplItem(item), AstFragmentKind::ImplItems)\n                 .make_impl_items();\n         }\n \n@@ -1595,16 +1474,12 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         &mut self,\n         mut foreign_item: P<ast::ForeignItem>,\n     ) -> SmallVec<[P<ast::ForeignItem>; 1]> {\n-        let (attr, traits, after_derive) = self.classify_item(&mut foreign_item);\n-\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut foreign_item) {\n             return self\n                 .collect_attr(\n                     attr,\n-                    traits,\n                     Annotatable::ForeignItem(foreign_item),\n                     AstFragmentKind::ForeignItems,\n-                    after_derive,\n                 )\n                 .make_foreign_items();\n         }\n@@ -1639,15 +1514,12 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     ) -> SmallVec<[ast::GenericParam; 1]> {\n         let mut param = configure!(self, param);\n \n-        let (attr, traits, after_derive) = self.classify_item(&mut param);\n-        if attr.is_some() || !traits.is_empty() {\n+        if let Some(attr) = self.take_first_attr(&mut param) {\n             return self\n                 .collect_attr(\n                     attr,\n-                    traits,\n                     Annotatable::GenericParam(param),\n                     AstFragmentKind::GenericParams,\n-                    after_derive,\n                 )\n                 .make_generic_params();\n         }\n@@ -1830,7 +1702,4 @@ impl<'feat> ExpansionConfig<'feat> {\n     fn proc_macro_hygiene(&self) -> bool {\n         self.features.map_or(false, |features| features.proc_macro_hygiene)\n     }\n-    fn custom_inner_attributes(&self) -> bool {\n-        self.features.map_or(false, |features| features.custom_inner_attributes)\n-    }\n }"}, {"sha": "dea167740edca5611dced8456d7a7b1a0e962784", "filename": "compiler/rustc_expand/src/proc_macro.rs", "status": "modified", "additions": 2, "deletions": 31, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -75,38 +75,9 @@ impl MultiItemModifier for ProcMacroDerive {\n         item: Annotatable,\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         let item = match item {\n-            Annotatable::Arm(..)\n-            | Annotatable::Field(..)\n-            | Annotatable::FieldPat(..)\n-            | Annotatable::GenericParam(..)\n-            | Annotatable::Param(..)\n-            | Annotatable::StructField(..)\n-            | Annotatable::Variant(..) => panic!(\"unexpected annotatable\"),\n-            Annotatable::Item(item) => item,\n-            Annotatable::ImplItem(_)\n-            | Annotatable::TraitItem(_)\n-            | Annotatable::ForeignItem(_)\n-            | Annotatable::Stmt(_)\n-            | Annotatable::Expr(_) => {\n-                ecx.span_err(\n-                    span,\n-                    \"proc-macro derives may only be applied to a struct, enum, or union\",\n-                );\n-                return ExpandResult::Ready(Vec::new());\n-            }\n+            Annotatable::Item(item) => token::NtItem(item),\n+            _ => unreachable!(),\n         };\n-        match item.kind {\n-            ItemKind::Struct(..) | ItemKind::Enum(..) | ItemKind::Union(..) => {}\n-            _ => {\n-                ecx.span_err(\n-                    span,\n-                    \"proc-macro derives may only be applied to a struct, enum, or union\",\n-                );\n-                return ExpandResult::Ready(Vec::new());\n-            }\n-        }\n-\n-        let item = token::NtItem(item);\n         let input = if item.pretty_printing_compatibility_hack() {\n             TokenTree::token(token::Interpolated(Lrc::new(item)), DUMMY_SP).into()\n         } else {"}, {"sha": "4ede9d67b741f0b4841b2d4d27b17f6000ee44a5", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -39,6 +39,9 @@ pub enum NonMacroAttrKind {\n     Tool,\n     /// Single-segment custom attribute registered by a derive macro (`#[serde(default)]`).\n     DeriveHelper,\n+    /// Single-segment custom attribute registered by a derive macro\n+    /// but used before that derive macro was expanded (deprecated).\n+    DeriveHelperCompat,\n     /// Single-segment custom attribute registered with `#[register_attr]`.\n     Registered,\n }\n@@ -370,7 +373,9 @@ impl NonMacroAttrKind {\n         match self {\n             NonMacroAttrKind::Builtin => \"built-in attribute\",\n             NonMacroAttrKind::Tool => \"tool attribute\",\n-            NonMacroAttrKind::DeriveHelper => \"derive helper attribute\",\n+            NonMacroAttrKind::DeriveHelper | NonMacroAttrKind::DeriveHelperCompat => {\n+                \"derive helper attribute\"\n+            }\n             NonMacroAttrKind::Registered => \"explicitly registered attribute\",\n         }\n     }\n@@ -385,7 +390,9 @@ impl NonMacroAttrKind {\n     /// Users of some attributes cannot mark them as used, so they are considered always used.\n     pub fn is_used(self) -> bool {\n         match self {\n-            NonMacroAttrKind::Tool | NonMacroAttrKind::DeriveHelper => true,\n+            NonMacroAttrKind::Tool\n+            | NonMacroAttrKind::DeriveHelper\n+            | NonMacroAttrKind::DeriveHelperCompat => true,\n             NonMacroAttrKind::Builtin | NonMacroAttrKind::Registered => false,\n         }\n     }"}, {"sha": "41985757b57af4906812c7682b8774f31cd2c63b", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -312,14 +312,13 @@ impl<'a> Parser<'a> {\n }\n \n pub fn maybe_needs_tokens(attrs: &[ast::Attribute]) -> bool {\n+    // One of the attributes may either itself be a macro, or apply derive macros (`derive`),\n+    // or expand to macro attributes (`cfg_attr`).\n     attrs.iter().any(|attr| {\n-        if let Some(ident) = attr.ident() {\n+        attr.ident().map_or(true, |ident| {\n             ident.name == sym::derive\n-            // This might apply a custom attribute/derive\n-            || ident.name == sym::cfg_attr\n-            || !rustc_feature::is_builtin_attr_name(ident.name)\n-        } else {\n-            true\n-        }\n+                || ident.name == sym::cfg_attr\n+                || !rustc_feature::is_builtin_attr_name(ident.name)\n+        })\n     })\n }"}, {"sha": "2cca1a6ee5979eb0ae065e8923b79509cdb0c0c1", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -609,7 +609,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n                 Scope::DeriveHelpersCompat => {\n-                    let res = Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n+                    let res = Res::NonMacroAttr(NonMacroAttrKind::DeriveHelperCompat);\n                     if filter_fn(res) {\n                         for derive in parent_scope.derives {\n                             let parent_scope = &ParentScope { derives: &[], ..*parent_scope };"}, {"sha": "1ee96f81e4fabcb2e6c0495f61a19c6b36aa2400", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 70, "deletions": 62, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -12,24 +12,24 @@ use rustc_ast_pretty::pprust;\n use rustc_attr::StabilityLevel;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::ptr_key::PtrKey;\n+use rustc_data_structures::sync::Lrc;\n use rustc_errors::struct_span_err;\n use rustc_expand::base::{Indeterminate, InvocationRes, ResolverExpand, SyntaxExtension};\n use rustc_expand::compile_declarative_macro;\n-use rustc_expand::expand::{AstFragment, AstFragmentKind, Invocation, InvocationKind};\n+use rustc_expand::expand::{AstFragment, Invocation, InvocationKind};\n use rustc_feature::is_builtin_attr_name;\n use rustc_hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc_hir::def_id;\n use rustc_middle::middle::stability;\n use rustc_middle::ty;\n use rustc_session::lint::builtin::UNUSED_MACROS;\n+use rustc_session::parse::feature_err;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::{self, ExpnData, ExpnId, ExpnKind};\n+use rustc_span::hygiene::{AstPass, MacroKind};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n-\n-use rustc_data_structures::sync::Lrc;\n-use rustc_span::hygiene::{AstPass, MacroKind};\n use std::cell::Cell;\n use std::{mem, ptr};\n \n@@ -241,15 +241,20 @@ impl<'a> ResolverExpand for Resolver<'a> {\n             }\n         };\n \n-        let (path, kind, derives, after_derive) = match invoc.kind {\n+        let (path, kind, inner_attr, derives, after_derive) = match invoc.kind {\n             InvocationKind::Attr { ref attr, ref derives, after_derive, .. } => (\n                 &attr.get_normal_item().path,\n                 MacroKind::Attr,\n+                attr.style == ast::AttrStyle::Inner,\n                 self.arenas.alloc_ast_paths(derives),\n                 after_derive,\n             ),\n-            InvocationKind::Bang { ref mac, .. } => (&mac.path, MacroKind::Bang, &[][..], false),\n-            InvocationKind::Derive { ref path, .. } => (path, MacroKind::Derive, &[][..], false),\n+            InvocationKind::Bang { ref mac, .. } => {\n+                (&mac.path, MacroKind::Bang, false, &[][..], false)\n+            }\n+            InvocationKind::Derive { ref path, .. } => {\n+                (path, MacroKind::Derive, false, &[][..], false)\n+            }\n             InvocationKind::DeriveContainer { ref derives, .. } => {\n                 // Block expansion of the container until we resolve all derives in it.\n                 // This is required for two reasons:\n@@ -281,7 +286,7 @@ impl<'a> ResolverExpand for Resolver<'a> {\n                                     ext.helper_attrs.iter().map(|name| Ident::new(*name, span)),\n                                 );\n                                 if ext.is_derive_copy {\n-                                    self.add_derive_copy(invoc_id);\n+                                    self.containers_deriving_copy.insert(invoc_id);\n                                 }\n                                 ext\n                             }\n@@ -299,8 +304,17 @@ impl<'a> ResolverExpand for Resolver<'a> {\n \n         // Derives are not included when `invocations` are collected, so we have to add them here.\n         let parent_scope = &ParentScope { derives, ..parent_scope };\n+        let require_inert = !invoc.fragment_kind.supports_macro_expansion();\n         let node_id = self.lint_node_id(eager_expansion_root);\n-        let (ext, res) = self.smart_resolve_macro_path(path, kind, parent_scope, node_id, force)?;\n+        let (ext, res) = self.smart_resolve_macro_path(\n+            path,\n+            kind,\n+            require_inert,\n+            inner_attr,\n+            parent_scope,\n+            node_id,\n+            force,\n+        )?;\n \n         let span = invoc.span();\n         invoc_id.set_expn_data(ext.expn_data(\n@@ -318,29 +332,6 @@ impl<'a> ResolverExpand for Resolver<'a> {\n             self.definitions.add_parent_module_of_macro_def(invoc_id, normal_module_def_id);\n         }\n \n-        match invoc.fragment_kind {\n-            AstFragmentKind::Arms\n-            | AstFragmentKind::Fields\n-            | AstFragmentKind::FieldPats\n-            | AstFragmentKind::GenericParams\n-            | AstFragmentKind::Params\n-            | AstFragmentKind::StructFields\n-            | AstFragmentKind::Variants => {\n-                if let Res::Def(..) = res {\n-                    self.session.span_err(\n-                        span,\n-                        &format!(\n-                            \"expected an inert attribute, found {} {}\",\n-                            res.article(),\n-                            res.descr()\n-                        ),\n-                    );\n-                    return Ok(InvocationRes::Single(self.dummy_ext(kind)));\n-                }\n-            }\n-            _ => {}\n-        }\n-\n         Ok(InvocationRes::Single(ext))\n     }\n \n@@ -360,10 +351,6 @@ impl<'a> ResolverExpand for Resolver<'a> {\n         self.containers_deriving_copy.contains(&expn_id)\n     }\n \n-    fn add_derive_copy(&mut self, expn_id: ExpnId) {\n-        self.containers_deriving_copy.insert(expn_id);\n-    }\n-\n     // The function that implements the resolution logic of `#[cfg_accessible(path)]`.\n     // Returns true if the path can certainly be resolved in one of three namespaces,\n     // returns false if the path certainly cannot be resolved in any of the three namespaces.\n@@ -403,18 +390,21 @@ impl<'a> ResolverExpand for Resolver<'a> {\n \n impl<'a> Resolver<'a> {\n     /// Resolve macro path with error reporting and recovery.\n+    /// Uses dummy syntax extensions for unresolved macros or macros with unexpected resolutions\n+    /// for better error recovery.\n     fn smart_resolve_macro_path(\n         &mut self,\n         path: &ast::Path,\n         kind: MacroKind,\n+        require_inert: bool,\n+        inner_attr: bool,\n         parent_scope: &ParentScope<'a>,\n         node_id: NodeId,\n         force: bool,\n     ) -> Result<(Lrc<SyntaxExtension>, Res), Indeterminate> {\n         let (ext, res) = match self.resolve_macro_path(path, Some(kind), parent_scope, true, force)\n         {\n             Ok((Some(ext), res)) => (ext, res),\n-            // Use dummy syntax extensions for unresolved macros for better recovery.\n             Ok((None, res)) => (self.dummy_ext(kind), res),\n             Err(Determinacy::Determined) => (self.dummy_ext(kind), Res::Err),\n             Err(Determinacy::Undetermined) => return Err(Indeterminate),\n@@ -451,19 +441,43 @@ impl<'a> Resolver<'a> {\n \n         self.check_stability_and_deprecation(&ext, path, node_id);\n \n-        Ok(if ext.macro_kind() != kind {\n-            let expected = kind.descr_expected();\n+        let unexpected_res = if ext.macro_kind() != kind {\n+            Some((kind.article(), kind.descr_expected()))\n+        } else if require_inert && matches!(res, Res::Def(..)) {\n+            Some((\"a\", \"non-macro attribute\"))\n+        } else {\n+            None\n+        };\n+        if let Some((article, expected)) = unexpected_res {\n             let path_str = pprust::path_to_string(path);\n             let msg = format!(\"expected {}, found {} `{}`\", expected, res.descr(), path_str);\n             self.session\n                 .struct_span_err(path.span, &msg)\n-                .span_label(path.span, format!(\"not {} {}\", kind.article(), expected))\n+                .span_label(path.span, format!(\"not {} {}\", article, expected))\n                 .emit();\n-            // Use dummy syntax extensions for unexpected macro kinds for better recovery.\n-            (self.dummy_ext(kind), Res::Err)\n-        } else {\n-            (ext, res)\n-        })\n+            return Ok((self.dummy_ext(kind), Res::Err));\n+        }\n+\n+        // We are trying to avoid reporting this error if other related errors were reported.\n+        if inner_attr\n+            && !self.session.features_untracked().custom_inner_attributes\n+            && path != &sym::test\n+            && res != Res::Err\n+        {\n+            feature_err(\n+                &self.session.parse_sess,\n+                sym::custom_inner_attributes,\n+                path.span,\n+                match res {\n+                    Res::Def(..) => \"inner macro attributes are unstable\",\n+                    Res::NonMacroAttr(..) => \"custom inner attributes are unstable\",\n+                    _ => unreachable!(),\n+                },\n+            )\n+            .emit();\n+        }\n+\n+        Ok((ext, res))\n     }\n \n     pub fn resolve_macro_path(\n@@ -568,10 +582,9 @@ impl<'a> Resolver<'a> {\n             struct Flags: u8 {\n                 const MACRO_RULES          = 1 << 0;\n                 const MODULE               = 1 << 1;\n-                const DERIVE_HELPER_COMPAT = 1 << 2;\n-                const MISC_SUGGEST_CRATE   = 1 << 3;\n-                const MISC_SUGGEST_SELF    = 1 << 4;\n-                const MISC_FROM_PRELUDE    = 1 << 5;\n+                const MISC_SUGGEST_CRATE   = 1 << 2;\n+                const MISC_SUGGEST_SELF    = 1 << 3;\n+                const MISC_FROM_PRELUDE    = 1 << 4;\n             }\n         }\n \n@@ -646,14 +659,11 @@ impl<'a> Resolver<'a> {\n                             ) {\n                                 Ok((Some(ext), _)) => {\n                                     if ext.helper_attrs.contains(&ident.name) {\n-                                        let binding = (\n-                                            Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n-                                            ty::Visibility::Public,\n+                                        result = ok(\n+                                            Res::NonMacroAttr(NonMacroAttrKind::DeriveHelperCompat),\n                                             derive.span,\n-                                            ExpnId::root(),\n-                                        )\n-                                            .to_name_binding(this.arenas);\n-                                        result = Ok((binding, Flags::DERIVE_HELPER_COMPAT));\n+                                            this.arenas,\n+                                        );\n                                         break;\n                                     }\n                                 }\n@@ -799,17 +809,15 @@ impl<'a> Resolver<'a> {\n                             let (res, innermost_res) = (binding.res(), innermost_binding.res());\n                             if res != innermost_res {\n                                 let builtin = Res::NonMacroAttr(NonMacroAttrKind::Builtin);\n-                                let is_derive_helper_compat = |res, flags: Flags| {\n-                                    res == Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper)\n-                                        && flags.contains(Flags::DERIVE_HELPER_COMPAT)\n-                                };\n+                                let derive_helper_compat =\n+                                    Res::NonMacroAttr(NonMacroAttrKind::DeriveHelperCompat);\n \n                                 let ambiguity_error_kind = if is_import {\n                                     Some(AmbiguityKind::Import)\n                                 } else if innermost_res == builtin || res == builtin {\n                                     Some(AmbiguityKind::BuiltinAttr)\n-                                } else if is_derive_helper_compat(innermost_res, innermost_flags)\n-                                    || is_derive_helper_compat(res, flags)\n+                                } else if innermost_res == derive_helper_compat\n+                                    || res == derive_helper_compat\n                                 {\n                                     Some(AmbiguityKind::DeriveHelper)\n                                 } else if innermost_flags.contains(Flags::MACRO_RULES)"}, {"sha": "8770fb1ded8eba4214175209601c9a9e18494e40", "filename": "src/test/ui/attrs-resolution-errors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fattrs-resolution-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fattrs-resolution-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattrs-resolution-errors.rs?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -1,12 +1,12 @@\n enum FooEnum {\n     #[test]\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n     Bar(i32),\n }\n \n struct FooStruct {\n     #[test]\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n     bar: i32,\n }\n \n@@ -21,20 +21,20 @@ fn main() {\n     match foo_struct {\n         FooStruct {\n             #[test] bar\n-            //~^ ERROR expected an inert attribute, found an attribute macro\n+            //~^ ERROR expected non-macro attribute, found attribute macro\n         } => {}\n     }\n \n     match 1 {\n         0 => {}\n         #[test]\n-        //~^ ERROR expected an inert attribute, found an attribute macro\n+        //~^ ERROR expected non-macro attribute, found attribute macro\n         _ => {}\n     }\n \n     let _another_foo_strunct = FooStruct {\n         #[test]\n-        //~^ ERROR expected an inert attribute, found an attribute macro\n+        //~^ ERROR expected non-macro attribute, found attribute macro\n         bar: 1,\n     };\n }"}, {"sha": "883f96e5c193163ac2311d5bfbf1e41be3ad8729", "filename": "src/test/ui/attrs-resolution-errors.stderr", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fattrs-resolution-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fattrs-resolution-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattrs-resolution-errors.stderr?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -1,32 +1,32 @@\n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/attrs-resolution-errors.rs:2:5\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/attrs-resolution-errors.rs:2:7\n    |\n LL |     #[test]\n-   |     ^^^^^^^\n+   |       ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/attrs-resolution-errors.rs:8:5\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/attrs-resolution-errors.rs:8:7\n    |\n LL |     #[test]\n-   |     ^^^^^^^\n+   |       ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/attrs-resolution-errors.rs:23:13\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/attrs-resolution-errors.rs:23:15\n    |\n LL |             #[test] bar\n-   |             ^^^^^^^\n+   |               ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/attrs-resolution-errors.rs:30:9\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/attrs-resolution-errors.rs:30:11\n    |\n LL |         #[test]\n-   |         ^^^^^^^\n+   |           ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/attrs-resolution-errors.rs:36:9\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/attrs-resolution-errors.rs:36:11\n    |\n LL |         #[test]\n-   |         ^^^^^^^\n+   |           ^^^^ not a non-macro attribute\n \n error: aborting due to 5 previous errors\n "}, {"sha": "50504a44c95183b78de472e16b1bd886fb5869ed", "filename": "src/test/ui/conditional-compilation/cfg_accessible-stuck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.rs?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -1,6 +1,6 @@\n #![feature(cfg_accessible)]\n \n-#[cfg_accessible(Z)] //~ ERROR cannot determine whether the path is accessible or not\n+#[cfg_accessible(Z)] // OK, recovered after the other `cfg_accessible` produces an error.\n struct S;\n \n #[cfg_accessible(S)] //~ ERROR cannot determine whether the path is accessible or not"}, {"sha": "33af7d62548ec2687b4bb0bb58459f0df6a86763", "filename": "src/test/ui/conditional-compilation/cfg_accessible-stuck.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg_accessible-stuck.stderr?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -4,11 +4,5 @@ error: cannot determine whether the path is accessible or not\n LL | #[cfg_accessible(S)]\n    | ^^^^^^^^^^^^^^^^^^^^\n \n-error: cannot determine whether the path is accessible or not\n-  --> $DIR/cfg_accessible-stuck.rs:3:1\n-   |\n-LL | #[cfg_accessible(Z)]\n-   | ^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "1102f3c4640a188a3b0adb5785b4a11cc25cdb60", "filename": "src/test/ui/issues/issue-36617.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fissues%2Fissue-36617.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fissues%2Fissue-36617.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-36617.rs?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -1,5 +1,4 @@\n #![derive(Copy)] //~ ERROR `derive` may only be applied to structs, enums and unions\n                  //~| ERROR cannot determine resolution for the derive macro `Copy`\n-                 //~| ERROR cannot determine resolution for the derive macro `Copy`\n \n fn main() {}"}, {"sha": "dc6ef1692591382f51290e50c1d22e05a9acd775", "filename": "src/test/ui/issues/issue-36617.stderr", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fissues%2Fissue-36617.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fissues%2Fissue-36617.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-36617.stderr?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -12,14 +12,6 @@ LL | #![derive(Copy)]\n    |\n    = note: import resolution is stuck, try simplifying macro imports\n \n-error: cannot determine resolution for the derive macro `Copy`\n-  --> $DIR/issue-36617.rs:1:11\n-   |\n-LL | #![derive(Copy)]\n-   |           ^^^^\n-   |\n-   = note: import resolution is stuck, try simplifying macro imports\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0774`."}, {"sha": "bf95f8fa7e1ec8fbcfb388efed713b96be520c49", "filename": "src/test/ui/issues/issue-49934-errors.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fissues%2Fissue-49934-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fissues%2Fissue-49934-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-49934-errors.rs?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -1,10 +1,8 @@\n fn foo<#[derive(Debug)] T>() {\n //~^ ERROR `derive` may only be applied to structs, enums and unions\n-//~| ERROR expected an inert attribute, found a derive macro\n     match 0 {\n         #[derive(Debug)]\n         //~^ ERROR `derive` may only be applied to structs, enums and unions\n-        //~| ERROR expected an inert attribute, found a derive macro\n         _ => (),\n     }\n }"}, {"sha": "71cd2d30342438c5a713e5bbf3b84669c7bd0ab8", "filename": "src/test/ui/issues/issue-49934-errors.stderr", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fissues%2Fissue-49934-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fissues%2Fissue-49934-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-49934-errors.stderr?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -4,24 +4,12 @@ error[E0774]: `derive` may only be applied to structs, enums and unions\n LL | fn foo<#[derive(Debug)] T>() {\n    |        ^^^^^^^^^^^^^^^^\n \n-error: expected an inert attribute, found a derive macro\n-  --> $DIR/issue-49934-errors.rs:1:17\n-   |\n-LL | fn foo<#[derive(Debug)] T>() {\n-   |                 ^^^^^\n-\n error[E0774]: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-49934-errors.rs:5:9\n+  --> $DIR/issue-49934-errors.rs:4:9\n    |\n LL |         #[derive(Debug)]\n    |         ^^^^^^^^^^^^^^^^\n \n-error: expected an inert attribute, found a derive macro\n-  --> $DIR/issue-49934-errors.rs:5:18\n-   |\n-LL |         #[derive(Debug)]\n-   |                  ^^^^^\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0774`."}, {"sha": "1fd7cddc7c937b6c007396d9271938494af6a145", "filename": "src/test/ui/malformed/issue-69341-malformed-derive-inert.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fmalformed%2Fissue-69341-malformed-derive-inert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fmalformed%2Fissue-69341-malformed-derive-inert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fissue-69341-malformed-derive-inert.rs?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -4,7 +4,6 @@ struct CLI {\n     #[derive(parse())]\n     //~^ ERROR traits in `#[derive(...)]` don't accept arguments\n     //~| ERROR cannot find derive macro `parse` in this scope\n-    //~| ERROR cannot find derive macro `parse` in this scope\n     path: (),\n     //~^ ERROR `derive` may only be applied to structs, enums and unions\n }"}, {"sha": "db40ce07530450db1c91cd47642a21dae4d26873", "filename": "src/test/ui/malformed/issue-69341-malformed-derive-inert.stderr", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fmalformed%2Fissue-69341-malformed-derive-inert.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fmalformed%2Fissue-69341-malformed-derive-inert.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fissue-69341-malformed-derive-inert.stderr?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -5,7 +5,7 @@ LL |     #[derive(parse())]\n    |                   ^^ help: remove the arguments\n \n error[E0774]: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-69341-malformed-derive-inert.rs:8:5\n+  --> $DIR/issue-69341-malformed-derive-inert.rs:7:5\n    |\n LL |     path: (),\n    |     ^^^^^^^^\n@@ -16,12 +16,6 @@ error: cannot find derive macro `parse` in this scope\n LL |     #[derive(parse())]\n    |              ^^^^^\n \n-error: cannot find derive macro `parse` in this scope\n-  --> $DIR/issue-69341-malformed-derive-inert.rs:4:14\n-   |\n-LL |     #[derive(parse())]\n-   |              ^^^^^\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0774`."}, {"sha": "4c72ecbfc03a8b109178df6439fba627802ecab4", "filename": "src/test/ui/proc-macro/proc-macro-gates.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.rs?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -7,11 +7,11 @@\n extern crate test_macros;\n \n fn _test_inner() {\n-    #![empty_attr] //~ ERROR: non-builtin inner attributes are unstable\n+    #![empty_attr] //~ ERROR: inner macro attributes are unstable\n }\n \n mod _test2_inner {\n-    #![empty_attr] //~ ERROR: non-builtin inner attributes are unstable\n+    #![empty_attr] //~ ERROR: inner macro attributes are unstable\n }\n \n #[empty_attr = \"y\"] //~ ERROR: key-value macro attributes are not supported"}, {"sha": "33a808037eea56d1fff6ad1c97bcf2914cce7ee2", "filename": "src/test/ui/proc-macro/proc-macro-gates.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.stderr?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -1,17 +1,17 @@\n-error[E0658]: non-builtin inner attributes are unstable\n-  --> $DIR/proc-macro-gates.rs:10:5\n+error[E0658]: inner macro attributes are unstable\n+  --> $DIR/proc-macro-gates.rs:10:8\n    |\n LL |     #![empty_attr]\n-   |     ^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^\n    |\n    = note: see issue #54726 <https://github.com/rust-lang/rust/issues/54726> for more information\n    = help: add `#![feature(custom_inner_attributes)]` to the crate attributes to enable\n \n-error[E0658]: non-builtin inner attributes are unstable\n-  --> $DIR/proc-macro-gates.rs:14:5\n+error[E0658]: inner macro attributes are unstable\n+  --> $DIR/proc-macro-gates.rs:14:8\n    |\n LL |     #![empty_attr]\n-   |     ^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^\n    |\n    = note: see issue #54726 <https://github.com/rust-lang/rust/issues/54726> for more information\n    = help: add `#![feature(custom_inner_attributes)]` to the crate attributes to enable"}, {"sha": "38fbd4733d5cbe8a59935fc003fe3d6d750af12b", "filename": "src/test/ui/proc-macro/proc-macro-gates2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates2.rs?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -10,11 +10,11 @@ extern crate test_macros;\n // should either require a feature gate or not be allowed on stable.\n \n fn _test6<#[empty_attr] T>() {}\n-//~^ ERROR: expected an inert attribute, found an attribute macro\n+//~^ ERROR: expected non-macro attribute, found attribute macro\n \n fn _test7() {\n     match 1 {\n-        #[empty_attr] //~ ERROR: expected an inert attribute, found an attribute macro\n+        #[empty_attr] //~ ERROR: expected non-macro attribute, found attribute macro\n         0 => {}\n         _ => {}\n     }"}, {"sha": "64df34e7ce390b1a581beaa1f7c75c18cca3f0eb", "filename": "src/test/ui/proc-macro/proc-macro-gates2.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates2.stderr?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -1,14 +1,14 @@\n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-gates2.rs:12:11\n+error: expected non-macro attribute, found attribute macro `empty_attr`\n+  --> $DIR/proc-macro-gates2.rs:12:13\n    |\n LL | fn _test6<#[empty_attr] T>() {}\n-   |           ^^^^^^^^^^^^^\n+   |             ^^^^^^^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-gates2.rs:17:9\n+error: expected non-macro attribute, found attribute macro `empty_attr`\n+  --> $DIR/proc-macro-gates2.rs:17:11\n    |\n LL |         #[empty_attr]\n-   |         ^^^^^^^^^^^^^\n+   |           ^^^^^^^^^^ not a non-macro attribute\n \n error: aborting due to 2 previous errors\n "}, {"sha": "6403b3f55c40ccf714e927b592ae41bd44dfbe12", "filename": "src/test/ui/rfc-2565-param-attrs/param-attrs-builtin-attrs.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-builtin-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-builtin-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-builtin-attrs.rs?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -3,7 +3,7 @@ extern \"C\" {\n         /// Foo\n         //~^ ERROR documentation comments cannot be applied to function\n         #[test] a: i32,\n-        //~^ ERROR expected an inert attribute, found an attribute macro\n+        //~^ ERROR expected non-macro attribute, found attribute macro\n         /// Bar\n         //~^ ERROR documentation comments cannot be applied to function\n         #[must_use]\n@@ -19,7 +19,7 @@ type FnType = fn(\n     /// Foo\n     //~^ ERROR documentation comments cannot be applied to function\n     #[test] a: u32,\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n     /// Bar\n     //~^ ERROR documentation comments cannot be applied to function\n     #[must_use]\n@@ -34,7 +34,7 @@ pub fn foo(\n     /// Foo\n     //~^ ERROR documentation comments cannot be applied to function\n     #[test] a: u32,\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n     /// Bar\n     //~^ ERROR documentation comments cannot be applied to function\n     #[must_use]\n@@ -54,7 +54,7 @@ impl SelfStruct {\n         /// Bar\n         //~^ ERROR documentation comments cannot be applied to function\n         #[test] a: i32,\n-        //~^ ERROR expected an inert attribute, found an attribute macro\n+        //~^ ERROR expected non-macro attribute, found attribute macro\n         /// Baz\n         //~^ ERROR documentation comments cannot be applied to function\n         #[must_use]\n@@ -69,7 +69,7 @@ impl SelfStruct {\n         /// Foo\n         //~^ ERROR documentation comments cannot be applied to function\n         #[test] a: i32,\n-        //~^ ERROR expected an inert attribute, found an attribute macro\n+        //~^ ERROR expected non-macro attribute, found attribute macro\n         /// Baz\n         //~^ ERROR documentation comments cannot be applied to function\n         #[must_use]\n@@ -90,7 +90,7 @@ impl RefStruct {\n         /// Bar\n         //~^ ERROR documentation comments cannot be applied to function\n         #[test] a: i32,\n-        //~^ ERROR expected an inert attribute, found an attribute macro\n+        //~^ ERROR expected non-macro attribute, found attribute macro\n         /// Baz\n         //~^ ERROR documentation comments cannot be applied to function\n         #[must_use]\n@@ -109,7 +109,7 @@ trait RefTrait {\n         /// Bar\n         //~^ ERROR documentation comments cannot be applied to function\n         #[test] a: i32,\n-        //~^ ERROR expected an inert attribute, found an attribute macro\n+        //~^ ERROR expected non-macro attribute, found attribute macro\n         /// Baz\n         //~^ ERROR documentation comments cannot be applied to function\n         #[must_use]\n@@ -124,7 +124,7 @@ trait RefTrait {\n         /// Foo\n         //~^ ERROR documentation comments cannot be applied to function\n         #[test] a: i32,\n-        //~^ ERROR expected an inert attribute, found an attribute macro\n+        //~^ ERROR expected non-macro attribute, found attribute macro\n         /// Baz\n         //~^ ERROR documentation comments cannot be applied to function\n         #[must_use]\n@@ -144,7 +144,7 @@ impl RefTrait for RefStruct {\n         /// Bar\n         //~^ ERROR documentation comments cannot be applied to function\n         #[test] a: i32,\n-        //~^ ERROR expected an inert attribute, found an attribute macro\n+        //~^ ERROR expected non-macro attribute, found attribute macro\n         /// Baz\n         //~^ ERROR documentation comments cannot be applied to function\n         #[must_use]\n@@ -161,7 +161,7 @@ fn main() {\n         /// Foo\n         //~^ ERROR documentation comments cannot be applied to function\n         #[test] a: u32,\n-        //~^ ERROR expected an inert attribute, found an attribute macro\n+        //~^ ERROR expected non-macro attribute, found attribute macro\n         /// Bar\n         //~^ ERROR documentation comments cannot be applied to function\n         #[must_use]"}, {"sha": "edca8cea68d72a9cc7c8d56d27a8d26b6f5891fe", "filename": "src/test/ui/rfc-2565-param-attrs/param-attrs-builtin-attrs.stderr", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-builtin-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-builtin-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fparam-attrs-builtin-attrs.stderr?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -1,62 +1,62 @@\n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/param-attrs-builtin-attrs.rs:5:9\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/param-attrs-builtin-attrs.rs:5:11\n    |\n LL |         #[test] a: i32,\n-   |         ^^^^^^^\n+   |           ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/param-attrs-builtin-attrs.rs:21:5\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/param-attrs-builtin-attrs.rs:21:7\n    |\n LL |     #[test] a: u32,\n-   |     ^^^^^^^\n+   |       ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/param-attrs-builtin-attrs.rs:36:5\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/param-attrs-builtin-attrs.rs:36:7\n    |\n LL |     #[test] a: u32,\n-   |     ^^^^^^^\n+   |       ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/param-attrs-builtin-attrs.rs:56:9\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/param-attrs-builtin-attrs.rs:56:11\n    |\n LL |         #[test] a: i32,\n-   |         ^^^^^^^\n+   |           ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/param-attrs-builtin-attrs.rs:71:9\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/param-attrs-builtin-attrs.rs:71:11\n    |\n LL |         #[test] a: i32,\n-   |         ^^^^^^^\n+   |           ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/param-attrs-builtin-attrs.rs:92:9\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/param-attrs-builtin-attrs.rs:92:11\n    |\n LL |         #[test] a: i32,\n-   |         ^^^^^^^\n+   |           ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/param-attrs-builtin-attrs.rs:111:9\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/param-attrs-builtin-attrs.rs:111:11\n    |\n LL |         #[test] a: i32,\n-   |         ^^^^^^^\n+   |           ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/param-attrs-builtin-attrs.rs:126:9\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/param-attrs-builtin-attrs.rs:126:11\n    |\n LL |         #[test] a: i32,\n-   |         ^^^^^^^\n+   |           ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/param-attrs-builtin-attrs.rs:146:9\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/param-attrs-builtin-attrs.rs:146:11\n    |\n LL |         #[test] a: i32,\n-   |         ^^^^^^^\n+   |           ^^^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/param-attrs-builtin-attrs.rs:163:9\n+error: expected non-macro attribute, found attribute macro `test`\n+  --> $DIR/param-attrs-builtin-attrs.rs:163:11\n    |\n LL |         #[test] a: u32,\n-   |         ^^^^^^^\n+   |           ^^^^ not a non-macro attribute\n \n error: documentation comments cannot be applied to function parameters\n   --> $DIR/param-attrs-builtin-attrs.rs:3:9"}, {"sha": "fcfa610ec8554e438e833c0589c15c810a08cc60", "filename": "src/test/ui/rfc-2565-param-attrs/proc-macro-cannot-be-used.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fproc-macro-cannot-be-used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fproc-macro-cannot-be-used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fproc-macro-cannot-be-used.rs?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -8,58 +8,58 @@ use ident_mac::id;\n struct W(u8);\n \n extern \"C\" { fn ffi(#[id] arg1: i32, #[id] ...); }\n-//~^ ERROR expected an inert attribute, found an attribute macro\n-//~| ERROR expected an inert attribute, found an attribute macro\n+//~^ ERROR expected non-macro attribute, found attribute macro\n+//~| ERROR expected non-macro attribute, found attribute macro\n \n unsafe extern \"C\" fn cvar(arg1: i32, #[id] mut args: ...) {}\n-//~^ ERROR expected an inert attribute, found an attribute macro\n+//~^ ERROR expected non-macro attribute, found attribute macro\n \n type Alias = extern \"C\" fn(#[id] u8, #[id] ...);\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n \n fn free(#[id] arg1: u8) {\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n     let lam = |#[id] W(x), #[id] y: usize| ();\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n }\n \n impl W {\n     fn inherent1(#[id] self, #[id] arg1: u8) {}\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n     fn inherent2(#[id] &self, #[id] arg1: u8) {}\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n     fn inherent3<'a>(#[id] &'a mut self, #[id] arg1: u8) {}\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n     fn inherent4<'a>(#[id] self: Box<Self>, #[id] arg1: u8) {}\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n     fn issue_64682_associated_fn<'a>(#[id] arg1: u8, #[id] arg2: u8) {}\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n }\n \n trait A {\n     fn trait1(#[id] self, #[id] arg1: u8);\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n     fn trait2(#[id] &self, #[id] arg1: u8);\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n     fn trait3<'a>(#[id] &'a mut self, #[id] arg1: u8);\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n     fn trait4<'a>(#[id] self: Box<Self>, #[id] arg1: u8, #[id] Vec<u8>);\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n     fn issue_64682_associated_fn<'a>(#[id] arg1: u8, #[id] arg2: u8);\n-    //~^ ERROR expected an inert attribute, found an attribute macro\n-    //~| ERROR expected an inert attribute, found an attribute macro\n+    //~^ ERROR expected non-macro attribute, found attribute macro\n+    //~| ERROR expected non-macro attribute, found attribute macro\n }\n \n fn main() {}"}, {"sha": "38c5050f3428dd932e2cd9e30bdf6b3c3573e121", "filename": "src/test/ui/rfc-2565-param-attrs/proc-macro-cannot-be-used.stderr", "status": "modified", "additions": 87, "deletions": 87, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fproc-macro-cannot-be-used.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fproc-macro-cannot-be-used.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fproc-macro-cannot-be-used.stderr?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -1,176 +1,176 @@\n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:10:21\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:10:23\n    |\n LL | extern \"C\" { fn ffi(#[id] arg1: i32, #[id] ...); }\n-   |                     ^^^^^\n+   |                       ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:10:38\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:10:40\n    |\n LL | extern \"C\" { fn ffi(#[id] arg1: i32, #[id] ...); }\n-   |                                      ^^^^^\n+   |                                        ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:14:38\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:14:40\n    |\n LL | unsafe extern \"C\" fn cvar(arg1: i32, #[id] mut args: ...) {}\n-   |                                      ^^^^^\n+   |                                        ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:17:28\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:17:30\n    |\n LL | type Alias = extern \"C\" fn(#[id] u8, #[id] ...);\n-   |                            ^^^^^\n+   |                              ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:17:38\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:17:40\n    |\n LL | type Alias = extern \"C\" fn(#[id] u8, #[id] ...);\n-   |                                      ^^^^^\n+   |                                        ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:21:9\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:21:11\n    |\n LL | fn free(#[id] arg1: u8) {\n-   |         ^^^^^\n+   |           ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:23:16\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:23:18\n    |\n LL |     let lam = |#[id] W(x), #[id] y: usize| ();\n-   |                ^^^^^\n+   |                  ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:23:28\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:23:30\n    |\n LL |     let lam = |#[id] W(x), #[id] y: usize| ();\n-   |                            ^^^^^\n+   |                              ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:29:18\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:29:20\n    |\n LL |     fn inherent1(#[id] self, #[id] arg1: u8) {}\n-   |                  ^^^^^\n+   |                    ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:29:30\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:29:32\n    |\n LL |     fn inherent1(#[id] self, #[id] arg1: u8) {}\n-   |                              ^^^^^\n+   |                                ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:32:18\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:32:20\n    |\n LL |     fn inherent2(#[id] &self, #[id] arg1: u8) {}\n-   |                  ^^^^^\n+   |                    ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:32:31\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:32:33\n    |\n LL |     fn inherent2(#[id] &self, #[id] arg1: u8) {}\n-   |                               ^^^^^\n+   |                                 ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:35:22\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:35:24\n    |\n LL |     fn inherent3<'a>(#[id] &'a mut self, #[id] arg1: u8) {}\n-   |                      ^^^^^\n+   |                        ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:35:42\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:35:44\n    |\n LL |     fn inherent3<'a>(#[id] &'a mut self, #[id] arg1: u8) {}\n-   |                                          ^^^^^\n+   |                                            ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:38:22\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:38:24\n    |\n LL |     fn inherent4<'a>(#[id] self: Box<Self>, #[id] arg1: u8) {}\n-   |                      ^^^^^\n+   |                        ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:38:45\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:38:47\n    |\n LL |     fn inherent4<'a>(#[id] self: Box<Self>, #[id] arg1: u8) {}\n-   |                                             ^^^^^\n+   |                                               ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:41:38\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:41:40\n    |\n LL |     fn issue_64682_associated_fn<'a>(#[id] arg1: u8, #[id] arg2: u8) {}\n-   |                                      ^^^^^\n+   |                                        ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:41:54\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:41:56\n    |\n LL |     fn issue_64682_associated_fn<'a>(#[id] arg1: u8, #[id] arg2: u8) {}\n-   |                                                      ^^^^^\n+   |                                                        ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:47:15\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:47:17\n    |\n LL |     fn trait1(#[id] self, #[id] arg1: u8);\n-   |               ^^^^^\n+   |                 ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:47:27\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:47:29\n    |\n LL |     fn trait1(#[id] self, #[id] arg1: u8);\n-   |                           ^^^^^\n+   |                             ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:50:15\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:50:17\n    |\n LL |     fn trait2(#[id] &self, #[id] arg1: u8);\n-   |               ^^^^^\n+   |                 ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:50:28\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:50:30\n    |\n LL |     fn trait2(#[id] &self, #[id] arg1: u8);\n-   |                            ^^^^^\n+   |                              ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:53:19\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:53:21\n    |\n LL |     fn trait3<'a>(#[id] &'a mut self, #[id] arg1: u8);\n-   |                   ^^^^^\n+   |                     ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:53:39\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:53:41\n    |\n LL |     fn trait3<'a>(#[id] &'a mut self, #[id] arg1: u8);\n-   |                                       ^^^^^\n+   |                                         ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:56:19\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:56:21\n    |\n LL |     fn trait4<'a>(#[id] self: Box<Self>, #[id] arg1: u8, #[id] Vec<u8>);\n-   |                   ^^^^^\n+   |                     ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:56:42\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:56:44\n    |\n LL |     fn trait4<'a>(#[id] self: Box<Self>, #[id] arg1: u8, #[id] Vec<u8>);\n-   |                                          ^^^^^\n+   |                                            ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:56:58\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:56:60\n    |\n LL |     fn trait4<'a>(#[id] self: Box<Self>, #[id] arg1: u8, #[id] Vec<u8>);\n-   |                                                          ^^^^^\n+   |                                                            ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:60:38\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:60:40\n    |\n LL |     fn issue_64682_associated_fn<'a>(#[id] arg1: u8, #[id] arg2: u8);\n-   |                                      ^^^^^\n+   |                                        ^^ not a non-macro attribute\n \n-error: expected an inert attribute, found an attribute macro\n-  --> $DIR/proc-macro-cannot-be-used.rs:60:54\n+error: expected non-macro attribute, found attribute macro `id`\n+  --> $DIR/proc-macro-cannot-be-used.rs:60:56\n    |\n LL |     fn issue_64682_associated_fn<'a>(#[id] arg1: u8, #[id] arg2: u8);\n-   |                                                      ^^^^^\n+   |                                                        ^^ not a non-macro attribute\n \n error: aborting due to 29 previous errors\n "}, {"sha": "70e04bf7ee6e81216918bf504e5925ef0596fb1d", "filename": "src/test/ui/span/issue-36530.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fspan%2Fissue-36530.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fspan%2Fissue-36530.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-36530.rs?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -6,7 +6,7 @@\n \n #[foo]\n mod foo {\n-    #![foo] //~ ERROR non-builtin inner attributes are unstable\n+    #![foo] //~ ERROR custom inner attributes are unstable\n }\n \n fn main() {}"}, {"sha": "a998d7217a13f563322a74698f5f29addd1c408c", "filename": "src/test/ui/span/issue-36530.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fspan%2Fissue-36530.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fspan%2Fissue-36530.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-36530.stderr?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -1,8 +1,8 @@\n-error[E0658]: non-builtin inner attributes are unstable\n-  --> $DIR/issue-36530.rs:9:5\n+error[E0658]: custom inner attributes are unstable\n+  --> $DIR/issue-36530.rs:9:8\n    |\n LL |     #![foo]\n-   |     ^^^^^^^\n+   |        ^^^\n    |\n    = note: see issue #54726 <https://github.com/rust-lang/rust/issues/54726> for more information\n    = help: add `#![feature(custom_inner_attributes)]` to the crate attributes to enable"}, {"sha": "8f1599a5abcb0fbf98e965e8cf84dcff70d9f108", "filename": "src/test/ui/span/issue-43927-non-ADT-derive.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.rs?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -5,9 +5,6 @@\n //~| ERROR cannot determine resolution for the derive macro `Debug`\n //~| ERROR cannot determine resolution for the derive macro `PartialEq`\n //~| ERROR cannot determine resolution for the derive macro `Eq`\n-//~| ERROR cannot determine resolution for the derive macro `Debug`\n-//~| ERROR cannot determine resolution for the derive macro `PartialEq`\n-//~| ERROR cannot determine resolution for the derive macro `Eq`\n struct DerivedOn;\n \n fn main() {}"}, {"sha": "85beac535c965616031408ae8c2d8b1938fc992e", "filename": "src/test/ui/span/issue-43927-non-ADT-derive.stderr", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8216b359e542d6d842bc3ed3fba3c67de5ad60fa/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.stderr?ref=8216b359e542d6d842bc3ed3fba3c67de5ad60fa", "patch": "@@ -28,30 +28,6 @@ LL | #![derive(Debug, PartialEq, Eq)] // should be an outer attribute!\n    |\n    = note: import resolution is stuck, try simplifying macro imports\n \n-error: cannot determine resolution for the derive macro `Eq`\n-  --> $DIR/issue-43927-non-ADT-derive.rs:3:29\n-   |\n-LL | #![derive(Debug, PartialEq, Eq)] // should be an outer attribute!\n-   |                             ^^\n-   |\n-   = note: import resolution is stuck, try simplifying macro imports\n-\n-error: cannot determine resolution for the derive macro `PartialEq`\n-  --> $DIR/issue-43927-non-ADT-derive.rs:3:18\n-   |\n-LL | #![derive(Debug, PartialEq, Eq)] // should be an outer attribute!\n-   |                  ^^^^^^^^^\n-   |\n-   = note: import resolution is stuck, try simplifying macro imports\n-\n-error: cannot determine resolution for the derive macro `Debug`\n-  --> $DIR/issue-43927-non-ADT-derive.rs:3:11\n-   |\n-LL | #![derive(Debug, PartialEq, Eq)] // should be an outer attribute!\n-   |           ^^^^^\n-   |\n-   = note: import resolution is stuck, try simplifying macro imports\n-\n-error: aborting due to 7 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0774`."}]}