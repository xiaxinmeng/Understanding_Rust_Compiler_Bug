{"sha": "5751179dc636d53b0f2368e81f548c1c04a7b4f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3NTExNzlkYzYzNmQ1M2IwZjIzNjhlODFmNTQ4YzFjMDRhN2I0ZjI=", "commit": {"author": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2021-04-26T16:05:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-26T16:05:34Z"}, "message": "Merge pull request #107 from rust-lang/feat/simd-round\n\nAdd SIMD rounding intrinsics", "tree": {"sha": "d4fcb50901a03a635c2107d19e25b4b51eaecfc9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4fcb50901a03a635c2107d19e25b4b51eaecfc9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5751179dc636d53b0f2368e81f548c1c04a7b4f2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJghuTOCRBK7hj4Ov3rIwAAvDYIADAB9TVGlwVGrp0Rk7iMjCO7\ntjea7UGE2maBceLWMt5EAdQVEgtM+nsO4YVZzjQMO3beMryyCUlV3VpVN2amRBoi\nR9xw6P51QPVGM56SYZ4wAzZNAXQZFQZwfaNQFurA/jHncKNxW4UqoUJjzbgYUhsD\nGIgUqPMoukLRZht5gN5Exb5C0Nt0Y+TAmWqcTvGz0fhMAx3t0BZZcXiscaZxfUpx\nhAeKZjOy2EWqApDYS3xlKO1zZ8580RhvKaYZIoUZ9DsqXOWz+aJOMU5OIpByeyRL\nJVgif13CiGQHbOe8Zm8yzNq+dV7jNwaQbMQjWjyLDE4FYCfkYc+C0SAQFyXRBaU=\n=BLR4\n-----END PGP SIGNATURE-----\n", "payload": "tree d4fcb50901a03a635c2107d19e25b4b51eaecfc9\nparent a9a1c9dbb727fc7693147e20b13ffbe4f565ecb8\nparent 6ea08d8d5fd207bdd6ebd8b26b1a552a708f36b5\nauthor Jubilee <46493976+workingjubilee@users.noreply.github.com> 1619453134 -0700\ncommitter GitHub <noreply@github.com> 1619453134 -0700\n\nMerge pull request #107 from rust-lang/feat/simd-round\n\nAdd SIMD rounding intrinsics"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5751179dc636d53b0f2368e81f548c1c04a7b4f2", "html_url": "https://github.com/rust-lang/rust/commit/5751179dc636d53b0f2368e81f548c1c04a7b4f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5751179dc636d53b0f2368e81f548c1c04a7b4f2/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9a1c9dbb727fc7693147e20b13ffbe4f565ecb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9a1c9dbb727fc7693147e20b13ffbe4f565ecb8", "html_url": "https://github.com/rust-lang/rust/commit/a9a1c9dbb727fc7693147e20b13ffbe4f565ecb8"}, {"sha": "6ea08d8d5fd207bdd6ebd8b26b1a552a708f36b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ea08d8d5fd207bdd6ebd8b26b1a552a708f36b5", "html_url": "https://github.com/rust-lang/rust/commit/6ea08d8d5fd207bdd6ebd8b26b1a552a708f36b5"}], "stats": {"total": 203, "additions": 136, "deletions": 67}, "files": [{"sha": "665dc1a51d7418a544ff0004df6b8b698672477a", "filename": "crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5751179dc636d53b0f2368e81f548c1c04a7b4f2/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5751179dc636d53b0f2368e81f548c1c04a7b4f2/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=5751179dc636d53b0f2368e81f548c1c04a7b4f2", "patch": "@@ -43,14 +43,6 @@ extern \"platform-intrinsic\" {\n     /// neg/fneg\n     pub(crate) fn simd_neg<T>(x: T) -> T;\n \n-    // floor\n-    #[cfg(feature = \"std\")]\n-    pub(crate) fn simd_floor<T>(x: T) -> T;\n-\n-    // ceil\n-    #[cfg(feature = \"std\")]\n-    pub(crate) fn simd_ceil<T>(x: T) -> T;\n-\n     /// fabs\n     pub(crate) fn simd_fabs<T>(x: T) -> T;\n \n@@ -85,3 +77,23 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_reduce_or<T, U>(x: T) -> U;\n     pub(crate) fn simd_reduce_xor<T, U>(x: T) -> U;\n }\n+\n+#[cfg(feature = \"std\")]\n+mod std {\n+    extern \"platform-intrinsic\" {\n+        // ceil\n+        pub(crate) fn simd_ceil<T>(x: T) -> T;\n+\n+        // floor\n+        pub(crate) fn simd_floor<T>(x: T) -> T;\n+\n+        // round\n+        pub(crate) fn simd_round<T>(x: T) -> T;\n+\n+        // trunc\n+        pub(crate) fn simd_trunc<T>(x: T) -> T;\n+    }\n+}\n+\n+#[cfg(feature = \"std\")]\n+pub(crate) use crate::intrinsics::std::*;"}, {"sha": "281851c68acebcf2c1599f9388b7418541ba731e", "filename": "crates/core_simd/src/round.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5751179dc636d53b0f2368e81f548c1c04a7b4f2/crates%2Fcore_simd%2Fsrc%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5751179dc636d53b0f2368e81f548c1c04a7b4f2/crates%2Fcore_simd%2Fsrc%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fround.rs?ref=5751179dc636d53b0f2368e81f548c1c04a7b4f2", "patch": "@@ -2,24 +2,44 @@ macro_rules! implement {\n     {\n         $type:ident, $int_type:ident\n     } => {\n+        #[cfg(feature = \"std\")]\n         impl<const LANES: usize> crate::$type<LANES>\n         where\n             Self: crate::LanesAtMost32,\n         {\n-            /// Returns the largest integer less than or equal to each lane.\n-            #[cfg(feature = \"std\")]\n+            /// Returns the smallest integer greater than or equal to each lane.\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+            #[inline]\n+            pub fn ceil(self) -> Self {\n+                unsafe { crate::intrinsics::simd_ceil(self) }\n+            }\n+\n+            /// Returns the largest integer value less than or equal to each lane.\n             #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             #[inline]\n             pub fn floor(self) -> Self {\n                 unsafe { crate::intrinsics::simd_floor(self) }\n             }\n \n-            /// Returns the smallest integer greater than or equal to each lane.\n-            #[cfg(feature = \"std\")]\n+            /// Rounds to the nearest integer value. Ties round toward zero.\n             #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             #[inline]\n-            pub fn ceil(self) -> Self {\n-                unsafe { crate::intrinsics::simd_ceil(self) }\n+            pub fn round(self) -> Self {\n+                unsafe { crate::intrinsics::simd_round(self) }\n+            }\n+\n+            /// Returns the floating point's integer value, with its fractional part removed.\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+            #[inline]\n+            pub fn trunc(self) -> Self {\n+                unsafe { crate::intrinsics::simd_trunc(self) }\n+            }\n+\n+            /// Returns the floating point's fractional value, with its integer part removed.\n+            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+            #[inline]\n+            pub fn fract(self) -> Self {\n+                self - self.trunc()\n             }\n         }\n "}, {"sha": "9f9992258770166038e83aa73d611f7275fb2298", "filename": "crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5751179dc636d53b0f2368e81f548c1c04a7b4f2/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5751179dc636d53b0f2368e81f548c1c04a7b4f2/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=5751179dc636d53b0f2368e81f548c1c04a7b4f2", "patch": "@@ -353,7 +353,6 @@ macro_rules! impl_float_tests {\n         mod $scalar {\n             type Vector<const LANES: usize> = core_simd::$vector<LANES>;\n             type Scalar = $scalar;\n-            type IntScalar = $int_scalar;\n \n             impl_unary_op_test!(Vector<LANES>, Scalar, Neg::neg);\n             impl_binary_op_test!(Vector<LANES>, Scalar, Add::add, AddAssign::add_assign);\n@@ -362,25 +361,6 @@ macro_rules! impl_float_tests {\n             impl_binary_op_test!(Vector<LANES>, Scalar, Div::div, DivAssign::div_assign);\n             impl_binary_op_test!(Vector<LANES>, Scalar, Rem::rem, RemAssign::rem_assign);\n \n-            #[cfg(feature = \"std\")]\n-            test_helpers::test_lanes! {\n-                fn ceil<const LANES: usize>() {\n-                    test_helpers::test_unary_elementwise(\n-                        &Vector::<LANES>::ceil,\n-                        &Scalar::ceil,\n-                        &|_| true,\n-                    )\n-                }\n-\n-                fn floor<const LANES: usize>() {\n-                    test_helpers::test_unary_elementwise(\n-                        &Vector::<LANES>::floor,\n-                        &Scalar::floor,\n-                        &|_| true,\n-                    )\n-                }\n-            }\n-\n             test_helpers::test_lanes! {\n                 fn is_sign_positive<const LANES: usize>() {\n                     test_helpers::test_unary_mask_elementwise(\n@@ -446,39 +426,6 @@ macro_rules! impl_float_tests {\n                     )\n                 }\n \n-                fn round_from_int<const LANES: usize>() {\n-                    test_helpers::test_unary_elementwise(\n-                        &Vector::<LANES>::round_from_int,\n-                        &|x| x as Scalar,\n-                        &|_| true,\n-                    )\n-                }\n-\n-                fn to_int_unchecked<const LANES: usize>() {\n-                    // The maximum integer that can be represented by the equivalently sized float has\n-                    // all of the mantissa digits set to 1, pushed up to the MSB.\n-                    const ALL_MANTISSA_BITS: IntScalar = ((1 << <Scalar>::MANTISSA_DIGITS) - 1);\n-                    const MAX_REPRESENTABLE_VALUE: Scalar =\n-                        (ALL_MANTISSA_BITS << (core::mem::size_of::<Scalar>() * 8 - <Scalar>::MANTISSA_DIGITS as usize - 1)) as Scalar;\n-\n-                    let mut runner = proptest::test_runner::TestRunner::default();\n-                    runner.run(\n-                        &test_helpers::array::UniformArrayStrategy::new(-MAX_REPRESENTABLE_VALUE..MAX_REPRESENTABLE_VALUE),\n-                        |x| {\n-                            let result_1 = unsafe { Vector::from_array(x).to_int_unchecked().to_array() };\n-                            let result_2 = {\n-                                let mut result = [0; LANES];\n-                                for (i, o) in x.iter().zip(result.iter_mut()) {\n-                                    *o = unsafe { i.to_int_unchecked() };\n-                                }\n-                                result\n-                            };\n-                            test_helpers::prop_assert_biteq!(result_1, result_2);\n-                            Ok(())\n-                        },\n-                    ).unwrap();\n-                }\n-\n                 fn horizontal_sum<const LANES: usize>() {\n                     test_helpers::test_1(&|x| {\n                         test_helpers::prop_assert_biteq! ("}, {"sha": "85853c0e8778cdeb8f392990fb6eedab6384df0b", "filename": "crates/core_simd/tests/round.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/5751179dc636d53b0f2368e81f548c1c04a7b4f2/crates%2Fcore_simd%2Ftests%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5751179dc636d53b0f2368e81f548c1c04a7b4f2/crates%2Fcore_simd%2Ftests%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fround.rs?ref=5751179dc636d53b0f2368e81f548c1c04a7b4f2", "patch": "@@ -0,0 +1,90 @@\n+macro_rules! float_rounding_test {\n+    { $vector:ident, $scalar:tt, $int_scalar:tt } => {\n+        mod $scalar {\n+            type Vector<const LANES: usize> = core_simd::$vector<LANES>;\n+            type Scalar = $scalar;\n+            type IntScalar = $int_scalar;\n+\n+            #[cfg(feature = \"std\")]\n+            test_helpers::test_lanes! {\n+                fn ceil<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::ceil,\n+                        &Scalar::ceil,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn floor<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::floor,\n+                        &Scalar::floor,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn round<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::round,\n+                        &Scalar::round,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn trunc<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::trunc,\n+                        &Scalar::trunc,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn fract<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::fract,\n+                        &Scalar::fract,\n+                        &|_| true,\n+                    )\n+                }\n+            }\n+\n+            test_helpers::test_lanes! {\n+                fn from_int<const LANES: usize>() {\n+                    test_helpers::test_unary_elementwise(\n+                        &Vector::<LANES>::round_from_int,\n+                        &|x| x as Scalar,\n+                        &|_| true,\n+                    )\n+                }\n+\n+                fn to_int_unchecked<const LANES: usize>() {\n+                    // The maximum integer that can be represented by the equivalently sized float has\n+                    // all of the mantissa digits set to 1, pushed up to the MSB.\n+                    const ALL_MANTISSA_BITS: IntScalar = ((1 << <Scalar>::MANTISSA_DIGITS) - 1);\n+                    const MAX_REPRESENTABLE_VALUE: Scalar =\n+                        (ALL_MANTISSA_BITS << (core::mem::size_of::<Scalar>() * 8 - <Scalar>::MANTISSA_DIGITS as usize - 1)) as Scalar;\n+\n+                    let mut runner = proptest::test_runner::TestRunner::default();\n+                    runner.run(\n+                        &test_helpers::array::UniformArrayStrategy::new(-MAX_REPRESENTABLE_VALUE..MAX_REPRESENTABLE_VALUE),\n+                        |x| {\n+                            let result_1 = unsafe { Vector::from_array(x).to_int_unchecked().to_array() };\n+                            let result_2 = {\n+                                let mut result = [0; LANES];\n+                                for (i, o) in x.iter().zip(result.iter_mut()) {\n+                                    *o = unsafe { i.to_int_unchecked() };\n+                                }\n+                                result\n+                            };\n+                            test_helpers::prop_assert_biteq!(result_1, result_2);\n+                            Ok(())\n+                        },\n+                    ).unwrap();\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+float_rounding_test! { SimdF32, f32, i32 }\n+float_rounding_test! { SimdF64, f64, i64 }"}]}