{"sha": "ec82174fad385882798b6c223dc1b8ac44f58332", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjODIxNzRmYWQzODU4ODI3OThiNmMyMjNkYzFiOGFjNDRmNTgzMzI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-20T16:22:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-20T16:22:19Z"}, "message": "Rollup merge of #67131 - Centril:item-merge, r=petrochenkov\n\nMerge `TraitItem` & `ImplItem into `AssocItem`\n\nIn this PR we:\n\n- Merge `{Trait,Impl}Item{Kind?}` into `AssocItem{Kind?}` as discussed in https://github.com/rust-lang/rust/issues/65041#issuecomment-538105286.\n\n   - This is done by using the cover grammar of both forms.\n\n   - In particular, it requires that we syntactically allow (under `#[cfg(FALSE)]`):\n\n      - `default`ness on `trait` items,\n\n      - `impl` items without a body / definition (`const`, `type`, and `fn`),\n\n      - and associated `type`s in `impl`s with bounds, e.g., `type Foo: Ord;`.\n\n   - The syntactic restrictions are replaced by semantic ones in `ast_validation`.\n\n- Move syntactic restrictions around C-variadic parameters from the parser into `ast_validation`:\n\n    - `fn`s in all contexts now syntactically allow `...`,\n\n    - `...` can occur anywhere in the list syntactically (`fn foo(..., x: usize) {}`),\n\n    - and `...` can be the sole parameter (`fn foo(...) {}`.\n\nr? @petrochenkov", "tree": {"sha": "0602c23ea16b14f9f76377c3506143575df88c3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0602c23ea16b14f9f76377c3506143575df88c3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec82174fad385882798b6c223dc1b8ac44f58332", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd/PU7CRBK7hj4Ov3rIwAAdHIIAGYSTaxceUxXxaaVrs0hyslS\nC8SV+5PGLTlKZYpPCcmbeW0ByD6qWENcQWHuZyaQso2qGiO5FHvkXqlEJLieteUA\n+qjOV+dS16cVhd6Q5C7U1FKH1ZNzZiVrIuY54dtOiVn0Tna6UAxgtml/Db8Tbmwo\nRJtItl54Jr1roNSfhWukAS+AnWoizDwAqUyVZYkAr3m6FyMBCjfI7ZcBjjKCzKQ3\nMcAbmutw6iU4m1t7z0RdoGxZfSUtgwLr5SAYquAFA5fMZp7mHStGrbA4jVbhhvNJ\n9IfJmhgF7tYBKDWeHBwaSRBdzuZvZr+TM+4ttqc5H/3m0ITUplD+ackV6jRg6iU=\n=KsSc\n-----END PGP SIGNATURE-----\n", "payload": "tree 0602c23ea16b14f9f76377c3506143575df88c3c\nparent ba1a4882514c3262caff38deabc30b669c709b95\nparent 054458b48db87ce767d7cc3d2dd86846ada3e3da\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1576858939 +0100\ncommitter GitHub <noreply@github.com> 1576858939 +0100\n\nRollup merge of #67131 - Centril:item-merge, r=petrochenkov\n\nMerge `TraitItem` & `ImplItem into `AssocItem`\n\nIn this PR we:\n\n- Merge `{Trait,Impl}Item{Kind?}` into `AssocItem{Kind?}` as discussed in https://github.com/rust-lang/rust/issues/65041#issuecomment-538105286.\n\n   - This is done by using the cover grammar of both forms.\n\n   - In particular, it requires that we syntactically allow (under `#[cfg(FALSE)]`):\n\n      - `default`ness on `trait` items,\n\n      - `impl` items without a body / definition (`const`, `type`, and `fn`),\n\n      - and associated `type`s in `impl`s with bounds, e.g., `type Foo: Ord;`.\n\n   - The syntactic restrictions are replaced by semantic ones in `ast_validation`.\n\n- Move syntactic restrictions around C-variadic parameters from the parser into `ast_validation`:\n\n    - `fn`s in all contexts now syntactically allow `...`,\n\n    - `...` can occur anywhere in the list syntactically (`fn foo(..., x: usize) {}`),\n\n    - and `...` can be the sole parameter (`fn foo(...) {}`.\n\nr? @petrochenkov\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec82174fad385882798b6c223dc1b8ac44f58332", "html_url": "https://github.com/rust-lang/rust/commit/ec82174fad385882798b6c223dc1b8ac44f58332", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec82174fad385882798b6c223dc1b8ac44f58332/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba1a4882514c3262caff38deabc30b669c709b95", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba1a4882514c3262caff38deabc30b669c709b95", "html_url": "https://github.com/rust-lang/rust/commit/ba1a4882514c3262caff38deabc30b669c709b95"}, {"sha": "054458b48db87ce767d7cc3d2dd86846ada3e3da", "url": "https://api.github.com/repos/rust-lang/rust/commits/054458b48db87ce767d7cc3d2dd86846ada3e3da", "html_url": "https://github.com/rust-lang/rust/commit/054458b48db87ce767d7cc3d2dd86846ada3e3da"}], "stats": {"total": 2128, "additions": 1279, "deletions": 849}, "files": [{"sha": "3f8085f2344b3228ed57c659da4d831ddc013a94", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 36, "deletions": 47, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -477,11 +477,11 @@ impl<'a> LoweringContext<'a> {\n                 });\n             }\n \n-            fn visit_trait_item(&mut self, item: &'tcx TraitItem) {\n+            fn visit_trait_item(&mut self, item: &'tcx AssocItem) {\n                 self.lctx.allocate_hir_id_counter(item.id);\n \n                 match item.kind {\n-                    TraitItemKind::Method(_, None) => {\n+                    AssocItemKind::Fn(_, None) => {\n                         // Ignore patterns in trait methods without bodies\n                         self.with_hir_id_owner(None, |this| {\n                             visit::walk_trait_item(this, item)\n@@ -493,7 +493,7 @@ impl<'a> LoweringContext<'a> {\n                 }\n             }\n \n-            fn visit_impl_item(&mut self, item: &'tcx ImplItem) {\n+            fn visit_impl_item(&mut self, item: &'tcx AssocItem) {\n                 self.lctx.allocate_hir_id_counter(item.id);\n                 self.with_hir_id_owner(Some(item.id), |this| {\n                     visit::walk_impl_item(this, item);\n@@ -1211,7 +1211,7 @@ impl<'a> LoweringContext<'a> {\n                             let ct = self.with_new_scopes(|this| {\n                                 hir::AnonConst {\n                                     hir_id: this.lower_node_id(node_id),\n-                                    body: this.lower_const_body(&path_expr),\n+                                    body: this.lower_const_body(path_expr.span, Some(&path_expr)),\n                                 }\n                             });\n                             return GenericArg::Const(ConstArg {\n@@ -1253,6 +1253,14 @@ impl<'a> LoweringContext<'a> {\n         ty\n     }\n \n+    fn ty(&mut self, span: Span, kind: hir::TyKind) -> hir::Ty {\n+        hir::Ty { hir_id: self.next_id(), kind, span }\n+    }\n+\n+    fn ty_tup(&mut self, span: Span, tys: HirVec<hir::Ty>) -> hir::Ty {\n+        self.ty(span, hir::TyKind::Tup(tys))\n+    }\n+\n     fn lower_ty_direct(&mut self, t: &Ty, mut itctx: ImplTraitContext<'_>) -> hir::Ty {\n         let kind = match t.kind {\n             TyKind::Infer => hir::TyKind::Infer,\n@@ -1418,7 +1426,13 @@ impl<'a> LoweringContext<'a> {\n                 }\n             }\n             TyKind::Mac(_) => bug!(\"`TyKind::Mac` should have been expanded by now\"),\n-            TyKind::CVarArgs => bug!(\"`TyKind::CVarArgs` should have been handled elsewhere\"),\n+            TyKind::CVarArgs => {\n+                self.sess.delay_span_bug(\n+                    t.span,\n+                    \"`TyKind::CVarArgs` should have been handled elsewhere\",\n+                );\n+                hir::TyKind::Err\n+            }\n         };\n \n         hir::Ty {\n@@ -2084,32 +2098,19 @@ impl<'a> LoweringContext<'a> {\n                     .iter()\n                     .map(|ty| this.lower_ty_direct(ty, ImplTraitContext::disallowed()))\n                     .collect();\n-                let mk_tup = |this: &mut Self, tys, span| {\n-                    hir::Ty { kind: hir::TyKind::Tup(tys), hir_id: this.next_id(), span }\n+                let output_ty = match output {\n+                    FunctionRetTy::Ty(ty) => this.lower_ty(&ty, ImplTraitContext::disallowed()),\n+                    FunctionRetTy::Default(_) => P(this.ty_tup(span, hir::HirVec::new())),\n+                };\n+                let args = hir_vec![GenericArg::Type(this.ty_tup(span, inputs))];\n+                let binding = hir::TypeBinding {\n+                    hir_id: this.next_id(),\n+                    ident: Ident::with_dummy_span(FN_OUTPUT_NAME),\n+                    span: output_ty.span,\n+                    kind: hir::TypeBindingKind::Equality { ty: output_ty },\n                 };\n                 (\n-                    hir::GenericArgs {\n-                        args: hir_vec![GenericArg::Type(mk_tup(this, inputs, span))],\n-                        bindings: hir_vec![\n-                            hir::TypeBinding {\n-                                hir_id: this.next_id(),\n-                                ident: Ident::with_dummy_span(FN_OUTPUT_NAME),\n-                                kind: hir::TypeBindingKind::Equality {\n-                                    ty: output\n-                                        .as_ref()\n-                                        .map(|ty| this.lower_ty(\n-                                            &ty,\n-                                            ImplTraitContext::disallowed()\n-                                        ))\n-                                        .unwrap_or_else(||\n-                                            P(mk_tup(this, hir::HirVec::new(), span))\n-                                        ),\n-                                },\n-                                span: output.as_ref().map_or(span, |ty| ty.span),\n-                            }\n-                        ],\n-                        parenthesized: true,\n-                    },\n+                    hir::GenericArgs { args, bindings: hir_vec![binding], parenthesized: true },\n                     false,\n                 )\n             }\n@@ -2474,17 +2475,13 @@ impl<'a> LoweringContext<'a> {\n             })\n         );\n \n-        // Create the `Foo<...>` refernece itself. Note that the `type\n+        // Create the `Foo<...>` reference itself. Note that the `type\n         // Foo = impl Trait` is, internally, created as a child of the\n         // async fn, so the *type parameters* are inherited.  It's\n         // only the lifetime parameters that we must supply.\n         let opaque_ty_ref = hir::TyKind::Def(hir::ItemId { id: opaque_ty_id }, generic_args.into());\n-\n-        hir::FunctionRetTy::Return(P(hir::Ty {\n-            kind: opaque_ty_ref,\n-            span: opaque_ty_span,\n-            hir_id: self.next_id(),\n-        }))\n+        let opaque_ty = self.ty(opaque_ty_span, opaque_ty_ref);\n+        hir::FunctionRetTy::Return(P(opaque_ty))\n     }\n \n     /// Transforms `-> T` into `Future<Output = T>`\n@@ -2496,16 +2493,8 @@ impl<'a> LoweringContext<'a> {\n     ) -> hir::GenericBound {\n         // Compute the `T` in `Future<Output = T>` from the return type.\n         let output_ty = match output {\n-            FunctionRetTy::Ty(ty) => {\n-                self.lower_ty(ty, ImplTraitContext::OpaqueTy(Some(fn_def_id)))\n-            }\n-            FunctionRetTy::Default(ret_ty_span) => {\n-                P(hir::Ty {\n-                    hir_id: self.next_id(),\n-                    kind: hir::TyKind::Tup(hir_vec![]),\n-                    span: *ret_ty_span,\n-                })\n-            }\n+            FunctionRetTy::Ty(ty) => self.lower_ty(ty, ImplTraitContext::OpaqueTy(Some(fn_def_id))),\n+            FunctionRetTy::Default(ret_ty_span) => P(self.ty_tup(*ret_ty_span, hir_vec![])),\n         };\n \n         // \"<Output = T>\"\n@@ -3017,7 +3006,7 @@ impl<'a> LoweringContext<'a> {\n         self.with_new_scopes(|this| {\n             hir::AnonConst {\n                 hir_id: this.lower_node_id(c.id),\n-                body: this.lower_const_body(&c.value),\n+                body: this.lower_const_body(c.value.span, Some(&c.value)),\n             }\n         })\n     }"}, {"sha": "46c944fa67881c4ae46546887f29bb07575727aa", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 85, "deletions": 46, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -86,7 +86,7 @@ impl<'tcx, 'interner> Visitor<'tcx> for ItemLowerer<'tcx, 'interner> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, item: &'tcx TraitItem) {\n+    fn visit_trait_item(&mut self, item: &'tcx AssocItem) {\n         self.lctx.with_hir_id_owner(item.id, |lctx| {\n             let hir_item = lctx.lower_trait_item(item);\n             let id = hir::TraitItemId { hir_id: hir_item.hir_id };\n@@ -97,7 +97,7 @@ impl<'tcx, 'interner> Visitor<'tcx> for ItemLowerer<'tcx, 'interner> {\n         visit::walk_trait_item(self, item);\n     }\n \n-    fn visit_impl_item(&mut self, item: &'tcx ImplItem) {\n+    fn visit_impl_item(&mut self, item: &'tcx AssocItem) {\n         self.lctx.with_hir_id_owner(item.id, |lctx| {\n             let hir_item = lctx.lower_impl_item(item);\n             let id = hir::ImplItemId { hir_id: hir_item.hir_id };\n@@ -250,7 +250,7 @@ impl LoweringContext<'_> {\n             return None;\n         }\n \n-        let kind = self.lower_item_kind(i.id, &mut ident, &attrs, &mut vis, &i.kind);\n+        let kind = self.lower_item_kind(i.span, i.id, &mut ident, &attrs, &mut vis, &i.kind);\n \n         Some(hir::Item {\n             hir_id: self.lower_node_id(i.id),\n@@ -264,6 +264,7 @@ impl LoweringContext<'_> {\n \n     fn lower_item_kind(\n         &mut self,\n+        span: Span,\n         id: NodeId,\n         ident: &mut Ident,\n         attrs: &hir::HirVec<Attribute>,\n@@ -292,7 +293,7 @@ impl LoweringContext<'_> {\n                         }\n                     ),\n                     m,\n-                    self.lower_const_body(e),\n+                    self.lower_const_body(span, Some(e)),\n                 )\n             }\n             ItemKind::Const(ref t, ref e) => {\n@@ -305,7 +306,7 @@ impl LoweringContext<'_> {\n                             ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n                         }\n                     ),\n-                    self.lower_const_body(e)\n+                    self.lower_const_body(span, Some(e))\n                 )\n             }\n             ItemKind::Fn(FnSig { ref decl, header }, ref generics, ref body) => {\n@@ -317,7 +318,12 @@ impl LoweringContext<'_> {\n                     // `impl Future<Output = T>` here because lower_body\n                     // only cares about the input argument patterns in the function\n                     // declaration (decl), not the return types.\n-                    let body_id = this.lower_maybe_async_body(&decl, header.asyncness.node, body);\n+                    let body_id = this.lower_maybe_async_body(\n+                        span,\n+                        &decl,\n+                        header.asyncness.node,\n+                        Some(body),\n+                    );\n \n                     let (generics, decl) = this.add_in_band_defs(\n                         generics,\n@@ -807,20 +813,20 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    fn lower_trait_item(&mut self, i: &TraitItem) -> hir::TraitItem {\n+    fn lower_trait_item(&mut self, i: &AssocItem) -> hir::TraitItem {\n         let trait_item_def_id = self.resolver.definitions().local_def_id(i.id);\n \n         let (generics, kind) = match i.kind {\n-            TraitItemKind::Const(ref ty, ref default) => (\n+            AssocItemKind::Const(ref ty, ref default) => (\n                 self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n                 hir::TraitItemKind::Const(\n                     self.lower_ty(ty, ImplTraitContext::disallowed()),\n                     default\n                         .as_ref()\n-                        .map(|x| self.lower_const_body(x)),\n+                        .map(|x| self.lower_const_body(i.span, Some(x))),\n                 ),\n             ),\n-            TraitItemKind::Method(ref sig, None) => {\n+            AssocItemKind::Fn(ref sig, None) => {\n                 let names = self.lower_fn_params_to_names(&sig.decl);\n                 let (generics, sig) = self.lower_method_sig(\n                     &i.generics,\n@@ -831,8 +837,8 @@ impl LoweringContext<'_> {\n                 );\n                 (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Required(names)))\n             }\n-            TraitItemKind::Method(ref sig, Some(ref body)) => {\n-                let body_id = self.lower_fn_body_block(&sig.decl, body);\n+            AssocItemKind::Fn(ref sig, Some(ref body)) => {\n+                let body_id = self.lower_fn_body_block(i.span, &sig.decl, Some(body));\n                 let (generics, sig) = self.lower_method_sig(\n                     &i.generics,\n                     sig,\n@@ -842,7 +848,7 @@ impl LoweringContext<'_> {\n                 );\n                 (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Provided(body_id)))\n             }\n-            TraitItemKind::Type(ref bounds, ref default) => {\n+            AssocItemKind::TyAlias(ref bounds, ref default) => {\n                 let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n                 let kind = hir::TraitItemKind::Type(\n                     self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n@@ -853,7 +859,7 @@ impl LoweringContext<'_> {\n \n                 (generics, kind)\n             },\n-            TraitItemKind::Macro(..) => bug!(\"macro item shouldn't exist at this point\"),\n+            AssocItemKind::Macro(..) => bug!(\"macro item shouldn't exist at this point\"),\n         };\n \n         hir::TraitItem {\n@@ -866,21 +872,21 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    fn lower_trait_item_ref(&mut self, i: &TraitItem) -> hir::TraitItemRef {\n+    fn lower_trait_item_ref(&mut self, i: &AssocItem) -> hir::TraitItemRef {\n         let (kind, has_default) = match i.kind {\n-            TraitItemKind::Const(_, ref default) => {\n+            AssocItemKind::Const(_, ref default) => {\n                 (hir::AssocItemKind::Const, default.is_some())\n             }\n-            TraitItemKind::Type(_, ref default) => {\n+            AssocItemKind::TyAlias(_, ref default) => {\n                 (hir::AssocItemKind::Type, default.is_some())\n             }\n-            TraitItemKind::Method(ref sig, ref default) => (\n+            AssocItemKind::Fn(ref sig, ref default) => (\n                 hir::AssocItemKind::Method {\n                     has_self: sig.decl.has_self(),\n                 },\n                 default.is_some(),\n             ),\n-            TraitItemKind::Macro(..) => unimplemented!(),\n+            AssocItemKind::Macro(..) => unimplemented!(),\n         };\n         hir::TraitItemRef {\n             id: hir::TraitItemId { hir_id: self.lower_node_id(i.id) },\n@@ -891,21 +897,29 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    fn lower_impl_item(&mut self, i: &ImplItem) -> hir::ImplItem {\n+    /// Construct `ExprKind::Err` for the given `span`.\n+    fn expr_err(&mut self, span: Span) -> hir::Expr {\n+        self.expr(span, hir::ExprKind::Err, ThinVec::new())\n+    }\n+\n+    fn lower_impl_item(&mut self, i: &AssocItem) -> hir::ImplItem {\n         let impl_item_def_id = self.resolver.definitions().local_def_id(i.id);\n \n         let (generics, kind) = match i.kind {\n-            ImplItemKind::Const(ref ty, ref expr) => (\n+            AssocItemKind::Const(ref ty, ref expr) => (\n                 self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n                 hir::ImplItemKind::Const(\n                     self.lower_ty(ty, ImplTraitContext::disallowed()),\n-                    self.lower_const_body(expr),\n+                    self.lower_const_body(i.span, expr.as_deref()),\n                 ),\n             ),\n-            ImplItemKind::Method(ref sig, ref body) => {\n+            AssocItemKind::Fn(ref sig, ref body) => {\n                 self.current_item = Some(i.span);\n                 let body_id = self.lower_maybe_async_body(\n-                    &sig.decl, sig.header.asyncness.node, body\n+                    i.span,\n+                    &sig.decl,\n+                    sig.header.asyncness.node,\n+                    body.as_deref(),\n                 );\n                 let impl_trait_return_allow = !self.is_in_trait_impl;\n                 let (generics, sig) = self.lower_method_sig(\n@@ -918,21 +932,26 @@ impl LoweringContext<'_> {\n \n                 (generics, hir::ImplItemKind::Method(sig, body_id))\n             }\n-            ImplItemKind::TyAlias(ref ty) => {\n+            AssocItemKind::TyAlias(_, ref ty) => {\n                 let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n-                let kind = match ty.kind.opaque_top_hack() {\n+                let kind = match ty {\n                     None => {\n-                        let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n-                        hir::ImplItemKind::TyAlias(ty)\n+                        hir::ImplItemKind::TyAlias(P(self.ty(i.span, hir::TyKind::Err)))\n                     }\n-                    Some(bs) => {\n-                        let bounds = self.lower_param_bounds(bs, ImplTraitContext::disallowed());\n-                        hir::ImplItemKind::OpaqueTy(bounds)\n+                    Some(ty) => match ty.kind.opaque_top_hack() {\n+                        None => {\n+                            let ty = self.lower_ty(ty, ImplTraitContext::disallowed());\n+                            hir::ImplItemKind::TyAlias(ty)\n+                        }\n+                        Some(bs) => {\n+                            let bs = self.lower_param_bounds(bs, ImplTraitContext::disallowed());\n+                            hir::ImplItemKind::OpaqueTy(bs)\n+                        }\n                     }\n                 };\n                 (generics, kind)\n             },\n-            ImplItemKind::Macro(..) => bug!(\"`TyMac` should have been expanded by now\"),\n+            AssocItemKind::Macro(..) => bug!(\"`TyMac` should have been expanded by now\"),\n         };\n \n         hir::ImplItem {\n@@ -949,23 +968,26 @@ impl LoweringContext<'_> {\n         // [1] since `default impl` is not yet implemented, this is always true in impls\n     }\n \n-    fn lower_impl_item_ref(&mut self, i: &ImplItem) -> hir::ImplItemRef {\n+    fn lower_impl_item_ref(&mut self, i: &AssocItem) -> hir::ImplItemRef {\n         hir::ImplItemRef {\n             id: hir::ImplItemId { hir_id: self.lower_node_id(i.id) },\n             ident: i.ident,\n             span: i.span,\n             vis: self.lower_visibility(&i.vis, Some(i.id)),\n             defaultness: self.lower_defaultness(i.defaultness, true /* [1] */),\n             kind: match &i.kind {\n-                ImplItemKind::Const(..) => hir::AssocItemKind::Const,\n-                ImplItemKind::TyAlias(ty) => match ty.kind.opaque_top_hack() {\n+                AssocItemKind::Const(..) => hir::AssocItemKind::Const,\n+                AssocItemKind::TyAlias(_, ty) => match ty\n+                    .as_deref()\n+                    .and_then(|ty| ty.kind.opaque_top_hack())\n+                {\n                     None => hir::AssocItemKind::Type,\n                     Some(_) => hir::AssocItemKind::OpaqueTy,\n                 },\n-                ImplItemKind::Method(sig, _) => hir::AssocItemKind::Method {\n+                AssocItemKind::Fn(sig, _) => hir::AssocItemKind::Method {\n                     has_self: sig.decl.has_self(),\n                 },\n-                ImplItemKind::Macro(..) => unimplemented!(),\n+                AssocItemKind::Macro(..) => unimplemented!(),\n             },\n         }\n \n@@ -1063,23 +1085,39 @@ impl LoweringContext<'_> {\n         ))\n     }\n \n-    fn lower_fn_body_block(&mut self, decl: &FnDecl, body: &Block) -> hir::BodyId {\n-        self.lower_fn_body(decl, |this| this.lower_block_expr(body))\n+    fn lower_fn_body_block(\n+        &mut self,\n+        span: Span,\n+        decl: &FnDecl,\n+        body: Option<&Block>,\n+    ) -> hir::BodyId {\n+        self.lower_fn_body(decl, |this| this.lower_block_expr_opt(span, body))\n+    }\n+\n+    fn lower_block_expr_opt(&mut self, span: Span, block: Option<&Block>) -> hir::Expr {\n+        match block {\n+            Some(block) => self.lower_block_expr(block),\n+            None => self.expr_err(span),\n+        }\n     }\n \n-    pub(super) fn lower_const_body(&mut self, expr: &Expr) -> hir::BodyId {\n-        self.lower_body(|this| (hir_vec![], this.lower_expr(expr)))\n+    pub(super) fn lower_const_body(&mut self, span: Span, expr: Option<&Expr>) -> hir::BodyId {\n+        self.lower_body(|this| (hir_vec![], match expr {\n+            Some(expr) => this.lower_expr(expr),\n+            None => this.expr_err(span),\n+        }))\n     }\n \n     fn lower_maybe_async_body(\n         &mut self,\n+        span: Span,\n         decl: &FnDecl,\n         asyncness: IsAsync,\n-        body: &Block,\n+        body: Option<&Block>,\n     ) -> hir::BodyId {\n         let closure_id = match asyncness {\n             IsAsync::Async { closure_id, .. } => closure_id,\n-            IsAsync::NotAsync => return self.lower_fn_body_block(decl, body),\n+            IsAsync::NotAsync => return self.lower_fn_body_block(span, decl, body),\n         };\n \n         self.lower_body(|this| {\n@@ -1213,15 +1251,16 @@ impl LoweringContext<'_> {\n                 parameters.push(new_parameter);\n             }\n \n+            let body_span = body.map_or(span, |b| b.span);\n             let async_expr = this.make_async_expr(\n                 CaptureBy::Value,\n                 closure_id,\n                 None,\n-                body.span,\n+                body_span,\n                 hir::AsyncGeneratorKind::Fn,\n                 |this| {\n                     // Create a block from the user's function body:\n-                    let user_body = this.lower_block_expr(body);\n+                    let user_body = this.lower_block_expr_opt(body_span, body);\n \n                     // Transform into `drop-temps { <user-body> }`, an expression:\n                     let desugared_span = this.mark_span_with_reason(\n@@ -1251,7 +1290,7 @@ impl LoweringContext<'_> {\n                     );\n                     this.expr_block(P(body), ThinVec::new())\n                 });\n-            (HirVec::from(parameters), this.expr(body.span, async_expr, ThinVec::new()))\n+            (HirVec::from(parameters), this.expr(body_span, async_expr, ThinVec::new()))\n         })\n     }\n "}, {"sha": "0fdd509a0bbec6c79b87977e5cad5b639bf9e12c", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -1249,15 +1249,15 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         ast_visit::walk_poly_trait_ref(self, t, m);\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &'a ast::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &'a ast::AssocItem) {\n         self.with_lint_attrs(trait_item.id, &trait_item.attrs, |cx| {\n             run_early_pass!(cx, check_trait_item, trait_item);\n             ast_visit::walk_trait_item(cx, trait_item);\n             run_early_pass!(cx, check_trait_item_post, trait_item);\n         });\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &'a ast::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &'a ast::AssocItem) {\n         self.with_lint_attrs(impl_item.id, &impl_item.attrs, |cx| {\n             run_early_pass!(cx, check_impl_item, impl_item);\n             ast_visit::walk_impl_item(cx, impl_item);"}, {"sha": "0054f149f8c2753fde9ef532ddfd73c20a8d05c3", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -258,10 +258,10 @@ macro_rules! early_lint_methods {\n                 c: Span,\n                 d: ast::NodeId\n             );\n-            fn check_trait_item(a: &ast::TraitItem);\n-            fn check_trait_item_post(a: &ast::TraitItem);\n-            fn check_impl_item(a: &ast::ImplItem);\n-            fn check_impl_item_post(a: &ast::ImplItem);\n+            fn check_trait_item(a: &ast::AssocItem);\n+            fn check_trait_item_post(a: &ast::AssocItem);\n+            fn check_impl_item(a: &ast::AssocItem);\n+            fn check_impl_item_post(a: &ast::AssocItem);\n             fn check_struct_def(a: &ast::VariantData);\n             fn check_struct_def_post(a: &ast::VariantData);\n             fn check_struct_field(a: &ast::StructField);"}, {"sha": "1780fe59cbd69a2dde28a25f873071c9ddbd35f0", "filename": "src/librustc_error_codes/error_codes/E0743.md", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_error_codes%2Ferror_codes%2FE0743.md", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_error_codes%2Ferror_codes%2FE0743.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0743.md?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -1,11 +1,17 @@\n-C-variadic has been used on a non-foreign function.\n+The C-variadic type `...` has been nested inside another type.\n \n Erroneous code example:\n \n ```compile_fail,E0743\n-fn foo2(x: u8, ...) {} // error!\n+#![feature(c_variadic)]\n+\n+fn foo2(x: u8, y: &...) {} // error!\n ```\n \n-Only foreign functions can use C-variadic (`...`). It is used to give an\n-undefined number of parameters to a given function (like `printf` in C). The\n-equivalent in Rust would be to use macros directly.\n+Only foreign functions can use the C-variadic type (`...`).\n+In such functions, `...` may only occur non-nested.\n+That is, `y: &'a ...` is not allowed.\n+\n+A C-variadic type is used to give an undefined number\n+of parameters to a given function (like `printf` in C).\n+The equivalent in Rust would be to use macros directly."}, {"sha": "4d686fc310f4ae25409588f07ed3e09be60cd16e", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -643,8 +643,8 @@ impl<'a, 'b> ReplaceBodyWithLoop<'a, 'b> {\n         ret\n     }\n \n-    fn should_ignore_fn(ret_ty: &ast::FnDecl) -> bool {\n-        if let ast::FunctionRetTy::Ty(ref ty) = ret_ty.output {\n+    fn should_ignore_fn(ret_ty: &ast::FunctionRetTy) -> bool {\n+        if let ast::FunctionRetTy::Ty(ref ty) = ret_ty {\n             fn involves_impl_trait(ty: &ast::Ty) -> bool {\n                 match ty.kind {\n                     ast::TyKind::ImplTrait(..) => true,\n@@ -673,7 +673,7 @@ impl<'a, 'b> ReplaceBodyWithLoop<'a, 'b> {\n                             },\n                             Some(&ast::GenericArgs::Parenthesized(ref data)) => {\n                                 any_involves_impl_trait(data.inputs.iter()) ||\n-                                any_involves_impl_trait(data.output.iter())\n+                                ReplaceBodyWithLoop::should_ignore_fn(&data.output)\n                             }\n                         }\n                     }),\n@@ -693,7 +693,7 @@ impl<'a, 'b> ReplaceBodyWithLoop<'a, 'b> {\n \n     fn is_sig_const(sig: &ast::FnSig) -> bool {\n         sig.header.constness.node == ast::Constness::Const ||\n-            ReplaceBodyWithLoop::should_ignore_fn(&sig.decl)\n+            ReplaceBodyWithLoop::should_ignore_fn(&sig.decl.output)\n     }\n }\n \n@@ -707,22 +707,17 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a, '_> {\n         self.run(is_const, |s| noop_visit_item_kind(i, s))\n     }\n \n-    fn flat_map_trait_item(&mut self, i: ast::TraitItem) -> SmallVec<[ast::TraitItem; 1]> {\n+    fn flat_map_trait_item(&mut self, i: ast::AssocItem) -> SmallVec<[ast::AssocItem; 1]> {\n         let is_const = match i.kind {\n-            ast::TraitItemKind::Const(..) => true,\n-            ast::TraitItemKind::Method(ref sig, _) => Self::is_sig_const(sig),\n+            ast::AssocItemKind::Const(..) => true,\n+            ast::AssocItemKind::Fn(ref sig, _) => Self::is_sig_const(sig),\n             _ => false,\n         };\n-        self.run(is_const, |s| noop_flat_map_trait_item(i, s))\n+        self.run(is_const, |s| noop_flat_map_assoc_item(i, s))\n     }\n \n-    fn flat_map_impl_item(&mut self, i: ast::ImplItem) -> SmallVec<[ast::ImplItem; 1]> {\n-        let is_const = match i.kind {\n-            ast::ImplItemKind::Const(..) => true,\n-            ast::ImplItemKind::Method(ref sig, _) => Self::is_sig_const(sig),\n-            _ => false,\n-        };\n-        self.run(is_const, |s| noop_flat_map_impl_item(i, s))\n+    fn flat_map_impl_item(&mut self, i: ast::AssocItem) -> SmallVec<[ast::AssocItem; 1]> {\n+        self.flat_map_trait_item(i)\n     }\n \n     fn visit_anon_const(&mut self, c: &mut ast::AnonConst) {"}, {"sha": "1fc89961889f1ba9fe51f0d86851e374e7531619", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -268,8 +268,8 @@ impl EarlyLintPass for UnsafeCode {\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &EarlyContext<'_>, item: &ast::TraitItem) {\n-        if let ast::TraitItemKind::Method(ref sig, None) = item.kind {\n+    fn check_trait_item(&mut self, cx: &EarlyContext<'_>, item: &ast::AssocItem) {\n+        if let ast::AssocItemKind::Fn(ref sig, None) = item.kind {\n             if sig.header.unsafety == ast::Unsafety::Unsafe {\n                 self.report_unsafe(cx, item.span, \"declaration of an `unsafe` method\")\n             }\n@@ -615,9 +615,9 @@ declare_lint_pass!(\n );\n \n impl EarlyLintPass for AnonymousParameters {\n-    fn check_trait_item(&mut self, cx: &EarlyContext<'_>, it: &ast::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &EarlyContext<'_>, it: &ast::AssocItem) {\n         match it.kind {\n-            ast::TraitItemKind::Method(ref sig, _) => {\n+            ast::AssocItemKind::Fn(ref sig, _) => {\n                 for arg in sig.decl.inputs.iter() {\n                     match arg.pat.kind {\n                         ast::PatKind::Ident(_, ident, None) => {"}, {"sha": "38ae7050abe48fa60f78a84ff4ece436142c683a", "filename": "src/librustc_parse/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_parse%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_parse%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fconfig.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -344,12 +344,12 @@ impl<'a> MutVisitor for StripUnconfigured<'a> {\n         noop_flat_map_item(configure!(self, item), self)\n     }\n \n-    fn flat_map_impl_item(&mut self, item: ast::ImplItem) -> SmallVec<[ast::ImplItem; 1]> {\n-        noop_flat_map_impl_item(configure!(self, item), self)\n+    fn flat_map_impl_item(&mut self, item: ast::AssocItem) -> SmallVec<[ast::AssocItem; 1]> {\n+        noop_flat_map_assoc_item(configure!(self, item), self)\n     }\n \n-    fn flat_map_trait_item(&mut self, item: ast::TraitItem) -> SmallVec<[ast::TraitItem; 1]> {\n-        noop_flat_map_trait_item(configure!(self, item), self)\n+    fn flat_map_trait_item(&mut self, item: ast::AssocItem) -> SmallVec<[ast::AssocItem; 1]> {\n+        noop_flat_map_assoc_item(configure!(self, item), self)\n     }\n \n     fn visit_mac(&mut self, _mac: &mut ast::Mac) {"}, {"sha": "58c365243805752ab5169b73b31311dc9d450829", "filename": "src/librustc_parse/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -305,10 +305,7 @@ pub fn nt_to_tokenstream(nt: &Nonterminal, sess: &ParseSess, span: Span) -> Toke\n         Nonterminal::NtItem(ref item) => {\n             prepend_attrs(sess, &item.attrs, item.tokens.as_ref(), span)\n         }\n-        Nonterminal::NtTraitItem(ref item) => {\n-            prepend_attrs(sess, &item.attrs, item.tokens.as_ref(), span)\n-        }\n-        Nonterminal::NtImplItem(ref item) => {\n+        Nonterminal::NtTraitItem(ref item) | Nonterminal::NtImplItem(ref item) => {\n             prepend_attrs(sess, &item.attrs, item.tokens.as_ref(), span)\n         }\n         Nonterminal::NtIdent(ident, is_raw) => {"}, {"sha": "e4dff07e92cb89518a164cada5e9a837b790641d", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -1381,7 +1381,7 @@ impl<'a> Parser<'a> {\n                 args\n             }\n         };\n-        let output = self.parse_ret_ty(true)?;\n+        let output = self.parse_ret_ty(true, true)?;\n \n         Ok(P(FnDecl {\n             inputs: inputs_captures,"}, {"sha": "0840a1551dbf4fd1da7c909b365efca5d2b07273", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 78, "deletions": 193, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -6,7 +6,7 @@ use crate::maybe_whole;\n use rustc_errors::{PResult, Applicability, DiagnosticBuilder, StashKey};\n use rustc_error_codes::*;\n use syntax::ast::{self, DUMMY_NODE_ID, Ident, Attribute, AttrKind, AttrStyle, AnonConst, Item};\n-use syntax::ast::{ItemKind, ImplItem, ImplItemKind, TraitItem, TraitItemKind, UseTree, UseTreeKind};\n+use syntax::ast::{AssocItem, AssocItemKind, ItemKind, UseTree, UseTreeKind};\n use syntax::ast::{PathSegment, IsAuto, Constness, IsAsync, Unsafety, Defaultness, Extern, StrLit};\n use syntax::ast::{Visibility, VisibilityKind, Mutability, FnHeader, ForeignItem, ForeignItemKind};\n use syntax::ast::{Ty, TyKind, Generics, TraitRef, EnumDef, Variant, VariantData, StructField};\n@@ -648,7 +648,7 @@ impl<'a> Parser<'a> {\n         Ok((Ident::invalid(), item_kind, Some(attrs)))\n     }\n \n-    fn parse_impl_body(&mut self) -> PResult<'a, (Vec<ImplItem>, Vec<Attribute>)> {\n+    fn parse_impl_body(&mut self) -> PResult<'a, (Vec<AssocItem>, Vec<Attribute>)> {\n         self.expect(&token::OpenDelim(token::Brace))?;\n         let attrs = self.parse_inner_attributes()?;\n \n@@ -669,60 +669,6 @@ impl<'a> Parser<'a> {\n         Ok((impl_items, attrs))\n     }\n \n-    /// Parses an impl item.\n-    pub fn parse_impl_item(&mut self, at_end: &mut bool) -> PResult<'a, ImplItem> {\n-        maybe_whole!(self, NtImplItem, |x| x);\n-        let attrs = self.parse_outer_attributes()?;\n-        let mut unclosed_delims = vec![];\n-        let (mut item, tokens) = self.collect_tokens(|this| {\n-            let item = this.parse_impl_item_(at_end, attrs);\n-            unclosed_delims.append(&mut this.unclosed_delims);\n-            item\n-        })?;\n-        self.unclosed_delims.append(&mut unclosed_delims);\n-\n-        // See `parse_item` for why this clause is here.\n-        if !item.attrs.iter().any(|attr| attr.style == AttrStyle::Inner) {\n-            item.tokens = Some(tokens);\n-        }\n-        Ok(item)\n-    }\n-\n-    fn parse_impl_item_(\n-        &mut self,\n-        at_end: &mut bool,\n-        mut attrs: Vec<Attribute>,\n-    ) -> PResult<'a, ImplItem> {\n-        let lo = self.token.span;\n-        let vis = self.parse_visibility(FollowedByType::No)?;\n-        let defaultness = self.parse_defaultness();\n-        let (name, kind, generics) = if self.eat_keyword(kw::Type) {\n-            let (name, ty, generics) = self.parse_type_alias()?;\n-            (name, ast::ImplItemKind::TyAlias(ty), generics)\n-        } else if self.is_const_item() {\n-            self.parse_impl_const()?\n-        } else if let Some(mac) = self.parse_assoc_macro_invoc(\"impl\", Some(&vis), at_end)? {\n-            // FIXME: code copied from `parse_macro_use_or_failure` -- use abstraction!\n-            (Ident::invalid(), ast::ImplItemKind::Macro(mac), Generics::default())\n-        } else {\n-            let (name, inner_attrs, generics, kind) = self.parse_impl_method(at_end)?;\n-            attrs.extend(inner_attrs);\n-            (name, kind, generics)\n-        };\n-\n-        Ok(ImplItem {\n-            id: DUMMY_NODE_ID,\n-            span: lo.to(self.prev_span),\n-            ident: name,\n-            vis,\n-            defaultness,\n-            attrs,\n-            generics,\n-            kind,\n-            tokens: None,\n-        })\n-    }\n-\n     /// Parses defaultness (i.e., `default` or nothing).\n     fn parse_defaultness(&mut self) -> Defaultness {\n         // `pub` is included for better error messages\n@@ -745,26 +691,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Returns `true` if we are looking at `const ID`\n-    /// (returns `false` for things like `const fn`, etc.).\n-    fn is_const_item(&self) -> bool {\n-        self.token.is_keyword(kw::Const) &&\n-            !self.is_keyword_ahead(1, &[kw::Fn, kw::Unsafe])\n-    }\n-\n-    /// This parses the grammar:\n-    ///     ImplItemConst = \"const\" Ident \":\" Ty \"=\" Expr \";\"\n-    fn parse_impl_const(&mut self) -> PResult<'a, (Ident, ImplItemKind, Generics)> {\n-        self.expect_keyword(kw::Const)?;\n-        let name = self.parse_ident()?;\n-        self.expect(&token::Colon)?;\n-        let typ = self.parse_ty()?;\n-        self.expect(&token::Eq)?;\n-        let expr = self.parse_expr()?;\n-        self.expect_semi()?;\n-        Ok((name, ImplItemKind::Const(typ, expr), Generics::default()))\n-    }\n-\n     /// Parses `auto? trait Foo { ... }` or `trait Foo = Bar;`.\n     fn parse_item_trait(&mut self, lo: Span, unsafety: Unsafety) -> PResult<'a, ItemInfo> {\n         // Parse optional `auto` prefix.\n@@ -857,13 +783,30 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parses the items in a trait declaration.\n-    pub fn parse_trait_item(&mut self, at_end: &mut bool) -> PResult<'a, TraitItem> {\n+    pub fn parse_impl_item(&mut self, at_end: &mut bool) -> PResult<'a, AssocItem> {\n+        maybe_whole!(self, NtImplItem, |x| x);\n+        self.parse_assoc_item(at_end, |_| true)\n+    }\n+\n+    pub fn parse_trait_item(&mut self, at_end: &mut bool) -> PResult<'a, AssocItem> {\n         maybe_whole!(self, NtTraitItem, |x| x);\n+        // This is somewhat dubious; We don't want to allow\n+        // param names to be left off if there is a definition...\n+        //\n+        // We don't allow param names to be left off in edition 2018.\n+        self.parse_assoc_item(at_end, |t| t.span.rust_2018())\n+    }\n+\n+    /// Parses associated items.\n+    fn parse_assoc_item(\n+        &mut self,\n+        at_end: &mut bool,\n+        is_name_required: fn(&token::Token) -> bool,\n+    ) -> PResult<'a, AssocItem> {\n         let attrs = self.parse_outer_attributes()?;\n         let mut unclosed_delims = vec![];\n         let (mut item, tokens) = self.collect_tokens(|this| {\n-            let item = this.parse_trait_item_(at_end, attrs);\n+            let item = this.parse_assoc_item_(at_end, attrs, is_name_required);\n             unclosed_delims.append(&mut this.unclosed_delims);\n             item\n         })?;\n@@ -875,54 +818,66 @@ impl<'a> Parser<'a> {\n         Ok(item)\n     }\n \n-    fn parse_trait_item_(\n+    fn parse_assoc_item_(\n         &mut self,\n         at_end: &mut bool,\n         mut attrs: Vec<Attribute>,\n-    ) -> PResult<'a, TraitItem> {\n+        is_name_required: fn(&token::Token) -> bool,\n+    ) -> PResult<'a, AssocItem> {\n         let lo = self.token.span;\n         let vis = self.parse_visibility(FollowedByType::No)?;\n+        let defaultness = self.parse_defaultness();\n         let (name, kind, generics) = if self.eat_keyword(kw::Type) {\n-            self.parse_trait_item_assoc_ty()?\n+            self.parse_assoc_ty()?\n         } else if self.is_const_item() {\n-            self.parse_trait_item_const()?\n-        } else if let Some(mac) = self.parse_assoc_macro_invoc(\"trait\", None, &mut false)? {\n-            // trait item macro.\n-            (Ident::invalid(), TraitItemKind::Macro(mac), Generics::default())\n+            self.parse_assoc_const()?\n+        } else if let Some(mac) = self.parse_assoc_macro_invoc(\"associated\", Some(&vis), at_end)? {\n+            (Ident::invalid(), AssocItemKind::Macro(mac), Generics::default())\n         } else {\n-            self.parse_trait_item_method(at_end, &mut attrs)?\n+            self.parse_assoc_fn(at_end, &mut attrs, is_name_required)?\n         };\n \n-        Ok(TraitItem {\n+        Ok(AssocItem {\n             id: DUMMY_NODE_ID,\n+            span: lo.to(self.prev_span),\n             ident: name,\n             attrs,\n             vis,\n+            defaultness,\n             generics,\n             kind,\n-            span: lo.to(self.prev_span),\n             tokens: None,\n         })\n     }\n \n-    fn parse_trait_item_const(&mut self) -> PResult<'a, (Ident, TraitItemKind, Generics)> {\n+    /// Returns `true` if we are looking at `const ID`\n+    /// (returns `false` for things like `const fn`, etc.).\n+    fn is_const_item(&self) -> bool {\n+        self.token.is_keyword(kw::Const) &&\n+            !self.is_keyword_ahead(1, &[kw::Fn, kw::Unsafe])\n+    }\n+\n+    /// This parses the grammar:\n+    ///\n+    ///     AssocConst = \"const\" Ident \":\" Ty \"=\" Expr \";\"\n+    fn parse_assoc_const(&mut self) -> PResult<'a, (Ident, AssocItemKind, Generics)> {\n         self.expect_keyword(kw::Const)?;\n         let ident = self.parse_ident()?;\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n-        let default = if self.eat(&token::Eq) {\n+        let expr = if self.eat(&token::Eq) {\n             Some(self.parse_expr()?)\n         } else {\n             None\n         };\n         self.expect_semi()?;\n-        Ok((ident, TraitItemKind::Const(ty, default), Generics::default()))\n+        Ok((ident, AssocItemKind::Const(ty, expr), Generics::default()))\n     }\n \n     /// Parses the following grammar:\n     ///\n-    ///     TraitItemAssocTy = Ident [\"<\"...\">\"] [\":\" [GenericBounds]] [\"where\" ...] [\"=\" Ty]\n-    fn parse_trait_item_assoc_ty(&mut self) -> PResult<'a, (Ident, TraitItemKind, Generics)> {\n+    ///     AssocTy = Ident [\"<\"...\">\"] [\":\" [GenericBounds]] [\"where\" ...] [\"=\" Ty]\n+    fn parse_assoc_ty(&mut self) -> PResult<'a, (Ident, AssocItemKind, Generics)> {\n         let ident = self.parse_ident()?;\n         let mut generics = self.parse_generics()?;\n \n@@ -941,7 +896,7 @@ impl<'a> Parser<'a> {\n         };\n         self.expect_semi()?;\n \n-        Ok((ident, TraitItemKind::Type(bounds, default), generics))\n+        Ok((ident, AssocItemKind::TyAlias(bounds, default), generics))\n     }\n \n     /// Parses a `UseTree`.\n@@ -1772,8 +1727,6 @@ impl<'a> Parser<'a> {\n pub(super) struct ParamCfg {\n     /// Is `self` is allowed as the first parameter?\n     pub is_self_allowed: bool,\n-    /// Is `...` allowed as the tail of the parameter list?\n-    pub allow_c_variadic: bool,\n     /// `is_name_required` decides if, per-parameter,\n     /// the parameter must have a pattern or just a type.\n     pub is_name_required: fn(&token::Token) -> bool,\n@@ -1789,16 +1742,8 @@ impl<'a> Parser<'a> {\n         attrs: Vec<Attribute>,\n         header: FnHeader,\n     ) -> PResult<'a, Option<P<Item>>> {\n-        let is_c_abi = match header.ext {\n-            ast::Extern::None => false,\n-            ast::Extern::Implicit => true,\n-            ast::Extern::Explicit(abi) => abi.symbol_unescaped == sym::C,\n-        };\n         let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n             is_self_allowed: false,\n-            // FIXME: Parsing should not depend on ABI or unsafety and\n-            // the variadic parameter should always be parsed.\n-            allow_c_variadic: is_c_abi && header.unsafety == Unsafety::Unsafe,\n             is_name_required: |_| true,\n         })?;\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n@@ -1817,7 +1762,6 @@ impl<'a> Parser<'a> {\n         self.expect_keyword(kw::Fn)?;\n         let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n             is_self_allowed: false,\n-            allow_c_variadic: true,\n             is_name_required: |_| true,\n         })?;\n         let span = lo.to(self.token.span);\n@@ -1833,48 +1777,39 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    /// Parses a method or a macro invocation in a trait impl.\n-    fn parse_impl_method(\n-        &mut self,\n-        at_end: &mut bool,\n-    ) -> PResult<'a, (Ident, Vec<Attribute>, Generics, ImplItemKind)> {\n-        let (ident, sig, generics) = self.parse_method_sig(|_| true)?;\n-        *at_end = true;\n-        let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n-        Ok((ident, inner_attrs, generics, ast::ImplItemKind::Method(sig, body)))\n-    }\n-\n-    fn parse_trait_item_method(\n+    fn parse_assoc_fn(\n         &mut self,\n         at_end: &mut bool,\n         attrs: &mut Vec<Attribute>,\n-    ) -> PResult<'a, (Ident, TraitItemKind, Generics)> {\n-        // This is somewhat dubious; We don't want to allow\n-        // argument names to be left off if there is a definition...\n-        //\n-        // We don't allow argument names to be left off in edition 2018.\n-        let (ident, sig, generics) = self.parse_method_sig(|t| t.span.rust_2018())?;\n-        let body = self.parse_trait_method_body(at_end, attrs)?;\n-        Ok((ident, TraitItemKind::Method(sig, body), generics))\n+        is_name_required: fn(&token::Token) -> bool,\n+    ) -> PResult<'a, (Ident, AssocItemKind, Generics)> {\n+        let header = self.parse_fn_front_matter()?;\n+        let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n+            is_self_allowed: true,\n+            is_name_required,\n+        })?;\n+        let sig = FnSig { header, decl };\n+        let body = self.parse_assoc_fn_body(at_end, attrs)?;\n+        Ok((ident, AssocItemKind::Fn(sig, body), generics))\n     }\n \n-    /// Parse the \"body\" of a method in a trait item definition.\n+    /// Parse the \"body\" of a method in an associated item definition.\n     /// This can either be `;` when there's no body,\n     /// or e.g. a block when the method is a provided one.\n-    fn parse_trait_method_body(\n+    fn parse_assoc_fn_body(\n         &mut self,\n         at_end: &mut bool,\n         attrs: &mut Vec<Attribute>,\n     ) -> PResult<'a, Option<P<Block>>> {\n         Ok(match self.token.kind {\n             token::Semi => {\n-                debug!(\"parse_trait_method_body(): parsing required method\");\n+                debug!(\"parse_assoc_fn_body(): parsing required method\");\n                 self.bump();\n                 *at_end = true;\n                 None\n             }\n             token::OpenDelim(token::Brace) => {\n-                debug!(\"parse_trait_method_body(): parsing provided method\");\n+                debug!(\"parse_assoc_fn_body(): parsing provided method\");\n                 *at_end = true;\n                 let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n                 attrs.extend(inner_attrs.iter().cloned());\n@@ -1895,21 +1830,6 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    /// Parse the \"signature\", including the identifier, parameters, and generics\n-    /// of a method. The body is not parsed as that differs between `trait`s and `impl`s.\n-    fn parse_method_sig(\n-        &mut self,\n-        is_name_required: fn(&token::Token) -> bool,\n-    ) -> PResult<'a, (Ident, FnSig, Generics)> {\n-        let header = self.parse_fn_front_matter()?;\n-        let (ident, decl, generics) = self.parse_fn_sig(ParamCfg {\n-            is_self_allowed: true,\n-            allow_c_variadic: false,\n-            is_name_required,\n-        })?;\n-        Ok((ident, FnSig { header, decl }, generics))\n-    }\n-\n     /// Parses all the \"front matter\" for a `fn` declaration, up to\n     /// and including the `fn` keyword:\n     ///\n@@ -1959,64 +1879,29 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, P<FnDecl>> {\n         Ok(P(FnDecl {\n             inputs: self.parse_fn_params(cfg)?,\n-            output: self.parse_ret_ty(ret_allow_plus)?,\n+            output: self.parse_ret_ty(ret_allow_plus, true)?,\n         }))\n     }\n \n     /// Parses the parameter list of a function, including the `(` and `)` delimiters.\n     fn parse_fn_params(&mut self, mut cfg: ParamCfg) -> PResult<'a, Vec<Param>> {\n-        let sp = self.token.span;\n         let is_trait_item = cfg.is_self_allowed;\n-        let mut c_variadic = false;\n         // Parse the arguments, starting out with `self` being possibly allowed...\n-        let (params, _) = self.parse_paren_comma_seq(|p| {\n-            let param = p.parse_param_general(&cfg, is_trait_item);\n+        let (mut params, _) = self.parse_paren_comma_seq(|p| {\n+            let param = p.parse_param_general(&cfg, is_trait_item).or_else(|mut e| {\n+                e.emit();\n+                let lo = p.prev_span;\n+                // Skip every token until next possible arg or end.\n+                p.eat_to_tokens(&[&token::Comma, &token::CloseDelim(token::Paren)]);\n+                // Create a placeholder argument for proper arg count (issue #34264).\n+                Ok(dummy_arg(Ident::new(kw::Invalid, lo.to(p.prev_span))))\n+            });\n             // ...now that we've parsed the first argument, `self` is no longer allowed.\n             cfg.is_self_allowed = false;\n-\n-            match param {\n-                Ok(param) => Ok(\n-                    if let TyKind::CVarArgs = param.ty.kind {\n-                        c_variadic = true;\n-                        if p.token != token::CloseDelim(token::Paren) {\n-                            p.span_err(\n-                                p.token.span,\n-                                \"`...` must be the last argument of a C-variadic function\",\n-                            );\n-                            // FIXME(eddyb) this should probably still push `CVarArgs`.\n-                            // Maybe AST validation/HIR lowering should emit the above error?\n-                            None\n-                        } else {\n-                            Some(param)\n-                        }\n-                    } else {\n-                        Some(param)\n-                    }\n-                ),\n-                Err(mut e) => {\n-                    e.emit();\n-                    let lo = p.prev_span;\n-                    // Skip every token until next possible arg or end.\n-                    p.eat_to_tokens(&[&token::Comma, &token::CloseDelim(token::Paren)]);\n-                    // Create a placeholder argument for proper arg count (issue #34264).\n-                    let span = lo.to(p.prev_span);\n-                    Ok(Some(dummy_arg(Ident::new(kw::Invalid, span))))\n-                }\n-            }\n+            param\n         })?;\n-\n-        let mut params: Vec<_> = params.into_iter().filter_map(|x| x).collect();\n-\n         // Replace duplicated recovered params with `_` pattern to avoid unnecessary errors.\n         self.deduplicate_recovered_params_names(&mut params);\n-\n-        if c_variadic && params.len() <= 1 {\n-            self.span_err(\n-                sp,\n-                \"C-variadic function must be declared with at least one named argument\",\n-            );\n-        }\n-\n         Ok(params)\n     }\n \n@@ -2061,12 +1946,12 @@ impl<'a> Parser<'a> {\n             }\n \n             self.eat_incorrect_doc_comment_for_param_type();\n-            (pat, self.parse_ty_common(true, true, cfg.allow_c_variadic)?)\n+            (pat, self.parse_ty_for_param()?)\n         } else {\n             debug!(\"parse_param_general ident_to_pat\");\n             let parser_snapshot_before_ty = self.clone();\n             self.eat_incorrect_doc_comment_for_param_type();\n-            let mut ty = self.parse_ty_common(true, true, cfg.allow_c_variadic);\n+            let mut ty = self.parse_ty_for_param();\n             if ty.is_ok() && self.token != token::Comma &&\n                self.token != token::CloseDelim(token::Paren) {\n                 // This wasn't actually a type, but a pattern looking like a type,"}, {"sha": "aeba6dd2f67c57fe5e5fd3cbe22a88da599c24d9", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -182,11 +182,7 @@ impl<'a> Parser<'a> {\n                 // `(T, U) -> R`\n                 let (inputs, _) = self.parse_paren_comma_seq(|p| p.parse_ty())?;\n                 let span = ident.span.to(self.prev_span);\n-                let output = if self.eat(&token::RArrow) {\n-                    Some(self.parse_ty_common(false, false, false)?)\n-                } else {\n-                    None\n-                };\n+                let output = self.parse_ret_ty(false, false)?;\n                 ParenthesizedArgs { inputs, output, span }.into()\n             };\n "}, {"sha": "6f7ab0542d5fab75aa482f633150e32ec8541d2b", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -10,7 +10,7 @@ use syntax::ast::{self, Ty, TyKind, MutTy, BareFnTy, FunctionRetTy, GenericParam\n use syntax::ast::{TraitBoundModifier, TraitObjectSyntax, GenericBound, GenericBounds, PolyTraitRef};\n use syntax::ast::{Mutability, AnonConst, Mac};\n use syntax::token::{self, Token};\n-use syntax::struct_span_fatal;\n+use syntax::struct_span_err;\n use syntax_pos::source_map::Span;\n use syntax_pos::symbol::kw;\n \n@@ -30,6 +30,13 @@ impl<'a> Parser<'a> {\n         self.parse_ty_common(true, true, false)\n     }\n \n+    /// Parse a type suitable for a function or function pointer parameter.\n+    /// The difference from `parse_ty` is that this version allows `...`\n+    /// (`CVarArgs`) at the top level of the the type.\n+    pub(super) fn parse_ty_for_param(&mut self) -> PResult<'a, P<Ty>> {\n+        self.parse_ty_common(true, true, true)\n+    }\n+\n     /// Parses a type in restricted contexts where `+` is not permitted.\n     ///\n     /// Example 1: `&'a TYPE`\n@@ -41,16 +48,26 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses an optional return type `[ -> TY ]` in a function declaration.\n-    pub(super) fn parse_ret_ty(&mut self, allow_plus: bool) -> PResult<'a, FunctionRetTy> {\n-        if self.eat(&token::RArrow) {\n-            Ok(FunctionRetTy::Ty(self.parse_ty_common(allow_plus, true, false)?))\n+    pub(super) fn parse_ret_ty(\n+        &mut self,\n+        allow_plus: bool,\n+        allow_qpath_recovery: bool,\n+    ) -> PResult<'a, FunctionRetTy> {\n+        Ok(if self.eat(&token::RArrow) {\n+            // FIXME(Centril): Can we unconditionally `allow_plus`?\n+            FunctionRetTy::Ty(self.parse_ty_common(allow_plus, allow_qpath_recovery, false)?)\n         } else {\n-            Ok(FunctionRetTy::Default(self.token.span.shrink_to_lo()))\n-        }\n+            FunctionRetTy::Default(self.token.span.shrink_to_lo())\n+        })\n     }\n \n-    pub(super) fn parse_ty_common(&mut self, allow_plus: bool, allow_qpath_recovery: bool,\n-                       allow_c_variadic: bool) -> PResult<'a, P<Ty>> {\n+    fn parse_ty_common(\n+        &mut self,\n+        allow_plus: bool,\n+        allow_qpath_recovery: bool,\n+        // Is `...` (`CVarArgs`) legal in the immediate top level call?\n+        allow_c_variadic: bool,\n+    ) -> PResult<'a, P<Ty>> {\n         maybe_recover_from_interpolated_ty_qpath!(self, allow_qpath_recovery);\n         maybe_whole!(self, NtTy, |x| x);\n \n@@ -192,17 +209,21 @@ impl<'a> Parser<'a> {\n                     TyKind::Path(None, path)\n                 }\n             }\n-        } else if self.check(&token::DotDotDot) {\n+        } else if self.eat(&token::DotDotDot) {\n             if allow_c_variadic {\n-                self.eat(&token::DotDotDot);\n                 TyKind::CVarArgs\n             } else {\n-                return Err(struct_span_fatal!(\n+                // FIXME(Centril): Should we just allow `...` syntactically\n+                // anywhere in a type and use semantic restrictions instead?\n+                struct_span_err!(\n                     self.sess.span_diagnostic,\n-                    self.token.span,\n+                    lo.to(self.prev_span),\n                     E0743,\n-                    \"only foreign functions are allowed to be C-variadic\",\n-                ));\n+                    \"C-variadic type `...` may not be nested inside another type\",\n+                )\n+                .emit();\n+\n+                TyKind::Err\n             }\n         } else {\n             let msg = format!(\"expected type, found {}\", self.this_token_descr());\n@@ -287,7 +308,6 @@ impl<'a> Parser<'a> {\n         self.expect_keyword(kw::Fn)?;\n         let cfg = ParamCfg {\n             is_self_allowed: false,\n-            allow_c_variadic: true,\n             is_name_required: |_| false,\n         };\n         let decl = self.parse_fn_decl(cfg, false)?;"}, {"sha": "e90231f984b1f8a020a78a31e8378c2929cf3226", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 128, "deletions": 33, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -250,6 +250,26 @@ impl<'a> AstValidator<'a> {\n     }\n \n     fn check_fn_decl(&self, fn_decl: &FnDecl) {\n+        match &*fn_decl.inputs {\n+            [Param { ty, span, .. }] => if let TyKind::CVarArgs = ty.kind {\n+                self.err_handler()\n+                    .span_err(\n+                        *span,\n+                        \"C-variadic function must be declared with at least one named argument\",\n+                    );\n+            },\n+            [ps @ .., _] => for Param { ty, span, .. } in ps {\n+                if let TyKind::CVarArgs = ty.kind {\n+                    self.err_handler()\n+                        .span_err(\n+                            *span,\n+                            \"`...` must be the last argument of a C-variadic function\",\n+                        );\n+                }\n+            }\n+            _ => {}\n+        }\n+\n         fn_decl\n             .inputs\n             .iter()\n@@ -259,18 +279,65 @@ impl<'a> AstValidator<'a> {\n                 !arr.contains(&attr.name_or_empty()) && attr::is_builtin_attr(attr)\n             })\n             .for_each(|attr| if attr.is_doc_comment() {\n-                let mut err = self.err_handler().struct_span_err(\n+                self.err_handler().struct_span_err(\n                     attr.span,\n                     \"documentation comments cannot be applied to function parameters\"\n-                );\n-                err.span_label(attr.span, \"doc comments are not allowed here\");\n-                err.emit();\n-            }\n-            else {\n+                )\n+                .span_label(attr.span, \"doc comments are not allowed here\")\n+                .emit();\n+            } else {\n                 self.err_handler().span_err(attr.span, \"allow, cfg, cfg_attr, deny, \\\n                 forbid, and warn are the only allowed built-in attributes in function parameters\")\n             });\n     }\n+\n+    fn check_defaultness(&self, span: Span, defaultness: Defaultness) {\n+        if let Defaultness::Default = defaultness {\n+            self.err_handler()\n+                .struct_span_err(span, \"`default` is only allowed on items in `impl` definitions\")\n+                .emit();\n+        }\n+    }\n+\n+    fn check_impl_item_provided<T>(&self, sp: Span, body: &Option<T>, ctx: &str, sugg: &str) {\n+        if body.is_some() {\n+            return;\n+        }\n+\n+        self.err_handler()\n+            .struct_span_err(sp, &format!(\"associated {} in `impl` without body\", ctx))\n+            .span_suggestion(\n+                self.session.source_map().end_point(sp),\n+                &format!(\"provide a definition for the {}\", ctx),\n+                sugg.to_string(),\n+                Applicability::HasPlaceholders,\n+            )\n+            .emit();\n+    }\n+\n+    fn check_impl_assoc_type_no_bounds(&self, bounds: &[GenericBound]) {\n+        let span = match bounds {\n+            [] => return,\n+            [b0] => b0.span(),\n+            [b0, .., bl] => b0.span().to(bl.span()),\n+        };\n+        self.err_handler()\n+            .struct_span_err(span, \"bounds on associated `type`s in `impl`s have no effect\")\n+            .emit();\n+    }\n+\n+    fn check_c_varadic_type(&self, decl: &FnDecl) {\n+        for Param { ty, span, .. } in &decl.inputs {\n+            if let TyKind::CVarArgs = ty.kind {\n+                self.err_handler()\n+                    .struct_span_err(\n+                        *span,\n+                        \"only foreign or `unsafe extern \\\"C\\\" functions may be C-variadic\",\n+                    )\n+                    .emit();\n+            }\n+        }\n+    }\n }\n \n enum GenericPosition {\n@@ -477,7 +544,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 }\n                 for impl_item in impl_items {\n                     self.invalid_visibility(&impl_item.vis, None);\n-                    if let ImplItemKind::Method(ref sig, _) = impl_item.kind {\n+                    if let AssocItemKind::Fn(ref sig, _) = impl_item.kind {\n                         self.check_trait_fn_not_const(sig.header.constness);\n                         self.check_trait_fn_not_async(impl_item.span, sig.header.asyncness.node);\n                     }\n@@ -519,6 +586,12 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         }\n                     }\n                 }\n+                // Reject C-varadic type unless the function is `unsafe extern \"C\"` semantically.\n+                match sig.header.ext {\n+                    Extern::Explicit(StrLit { symbol_unescaped: sym::C, .. }) |\n+                    Extern::Implicit if sig.header.unsafety == Unsafety::Unsafe => {}\n+                    _ => self.check_c_varadic_type(&sig.decl),\n+                }\n             }\n             ItemKind::ForeignMod(..) => {\n                 self.invalid_visibility(\n@@ -554,26 +627,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     }\n                 }\n                 self.no_questions_in_bounds(bounds, \"supertraits\", true);\n-                for trait_item in trait_items {\n-                    if let TraitItemKind::Method(ref sig, ref block) = trait_item.kind {\n-                        self.check_fn_decl(&sig.decl);\n-                        self.check_trait_fn_not_async(trait_item.span, sig.header.asyncness.node);\n-                        self.check_trait_fn_not_const(sig.header.constness);\n-                        if block.is_none() {\n-                            Self::check_decl_no_pat(&sig.decl, |span, mut_ident| {\n-                                if mut_ident {\n-                                    self.lint_buffer.buffer_lint(\n-                                        lint::builtin::PATTERNS_IN_FNS_WITHOUT_BODY,\n-                                        trait_item.id, span,\n-                                        \"patterns aren't allowed in methods without bodies\");\n-                                } else {\n-                                    struct_span_err!(self.session, span, E0642,\n-                                        \"patterns aren't allowed in methods without bodies\").emit();\n-                                }\n-                            });\n-                        }\n-                    }\n-                }\n             }\n             ItemKind::Mod(_) => {\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n@@ -639,10 +692,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             GenericArgs::Parenthesized(ref data) => {\n                 walk_list!(self, visit_ty, &data.inputs);\n-                if let Some(ref type_) = data.output {\n+                if let FunctionRetTy::Ty(ty) = &data.output {\n                     // `-> Foo` syntax is essentially an associated type binding,\n                     // so it is also allowed to contain nested `impl Trait`.\n-                    self.with_impl_trait(None, |this| this.visit_ty(type_));\n+                    self.with_impl_trait(None, |this| this.visit_ty(ty));\n                 }\n             }\n         }\n@@ -737,17 +790,59 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             |this| visit::walk_enum_def(this, enum_definition, generics, item_id))\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n-        if let ImplItemKind::Method(ref sig, _) = ii.kind {\n-            self.check_fn_decl(&sig.decl);\n+    fn visit_impl_item(&mut self, ii: &'a AssocItem) {\n+        match &ii.kind {\n+            AssocItemKind::Const(_, body) => {\n+                self.check_impl_item_provided(ii.span, body, \"constant\", \" = <expr>;\");\n+            }\n+            AssocItemKind::Fn(sig, body) => {\n+                self.check_impl_item_provided(ii.span, body, \"function\", \" { <body> }\");\n+                self.check_fn_decl(&sig.decl);\n+            }\n+            AssocItemKind::TyAlias(bounds, body) => {\n+                self.check_impl_item_provided(ii.span, body, \"type\", \" = <type>;\");\n+                self.check_impl_assoc_type_no_bounds(bounds);\n+            }\n+            _ => {}\n         }\n         visit::walk_impl_item(self, ii);\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'a AssocItem) {\n         self.invalid_visibility(&ti.vis, None);\n+        self.check_defaultness(ti.span, ti.defaultness);\n+\n+        if let AssocItemKind::Fn(sig, block) = &ti.kind {\n+            self.check_fn_decl(&sig.decl);\n+            self.check_trait_fn_not_async(ti.span, sig.header.asyncness.node);\n+            self.check_trait_fn_not_const(sig.header.constness);\n+            if block.is_none() {\n+                Self::check_decl_no_pat(&sig.decl, |span, mut_ident| {\n+                    if mut_ident {\n+                        self.lint_buffer.buffer_lint(\n+                            lint::builtin::PATTERNS_IN_FNS_WITHOUT_BODY,\n+                            ti.id, span,\n+                            \"patterns aren't allowed in methods without bodies\"\n+                        );\n+                    } else {\n+                        struct_span_err!(\n+                            self.session, span, E0642,\n+                            \"patterns aren't allowed in methods without bodies\"\n+                        ).emit();\n+                    }\n+                });\n+            }\n+        }\n+\n         visit::walk_trait_item(self, ti);\n     }\n+\n+    fn visit_assoc_item(&mut self, item: &'a AssocItem) {\n+        if let AssocItemKind::Fn(sig, _) = &item.kind {\n+            self.check_c_varadic_type(&sig.decl);\n+        }\n+        visit::walk_assoc_item(self, item);\n+    }\n }\n \n pub fn check_crate(session: &Session, krate: &Crate, lints: &mut lint::LintBuffer) -> bool {"}, {"sha": "66ceb4212c8aca9423e0a6505567420334613408", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -314,12 +314,12 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n         ast_visit::walk_fn(self, fk, fd, s)\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'v ast::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'v ast::AssocItem) {\n         self.record(\"TraitItem\", Id::None, ti);\n         ast_visit::walk_trait_item(self, ti)\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'v ast::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'v ast::AssocItem) {\n         self.record(\"ImplItem\", Id::None, ii);\n         ast_visit::walk_impl_item(self, ii)\n     }"}, {"sha": "e94e0dc695cd605abe8fcb673dff3fa8e36402fb", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -30,7 +30,7 @@ use errors::Applicability;\n use syntax::ast::{Name, Ident};\n use syntax::attr;\n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind, NodeId};\n-use syntax::ast::{MetaItemKind, StmtKind, TraitItem, TraitItemKind};\n+use syntax::ast::{MetaItemKind, StmtKind, AssocItem, AssocItemKind};\n use syntax::token::{self, Token};\n use syntax::span_err;\n use syntax::source_map::{respan, Spanned};\n@@ -1164,26 +1164,26 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n         self.parent_scope.legacy = orig_current_legacy_scope;\n     }\n \n-    fn visit_trait_item(&mut self, item: &'b TraitItem) {\n+    fn visit_trait_item(&mut self, item: &'b AssocItem) {\n         let parent = self.parent_scope.module;\n \n-        if let TraitItemKind::Macro(_) = item.kind {\n+        if let AssocItemKind::Macro(_) = item.kind {\n             self.visit_invoc(item.id);\n             return\n         }\n \n         // Add the item to the trait info.\n         let item_def_id = self.r.definitions.local_def_id(item.id);\n         let (res, ns) = match item.kind {\n-            TraitItemKind::Const(..) => (Res::Def(DefKind::AssocConst, item_def_id), ValueNS),\n-            TraitItemKind::Method(ref sig, _) => {\n+            AssocItemKind::Const(..) => (Res::Def(DefKind::AssocConst, item_def_id), ValueNS),\n+            AssocItemKind::Fn(ref sig, _) => {\n                 if sig.decl.has_self() {\n                     self.r.has_self.insert(item_def_id);\n                 }\n                 (Res::Def(DefKind::Method, item_def_id), ValueNS)\n             }\n-            TraitItemKind::Type(..) => (Res::Def(DefKind::AssocTy, item_def_id), TypeNS),\n-            TraitItemKind::Macro(_) => bug!(),  // handled above\n+            AssocItemKind::TyAlias(..) => (Res::Def(DefKind::AssocTy, item_def_id), TypeNS),\n+            AssocItemKind::Macro(_) => bug!(),  // handled above\n         };\n \n         let vis = ty::Visibility::Public;\n@@ -1193,8 +1193,8 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n         visit::walk_trait_item(self, item);\n     }\n \n-    fn visit_impl_item(&mut self, item: &'b ast::ImplItem) {\n-        if let ast::ImplItemKind::Macro(..) = item.kind {\n+    fn visit_impl_item(&mut self, item: &'b ast::AssocItem) {\n+        if let ast::AssocItemKind::Macro(..) = item.kind {\n             self.visit_invoc(item.id);\n         } else {\n             self.resolve_visibility(&item.vis);"}, {"sha": "9bae339f80ea4e1d4b1571215225df3fe0eadc17", "filename": "src/librustc_resolve/def_collector.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_resolve%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_resolve%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdef_collector.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -50,7 +50,7 @@ impl<'a> DefCollector<'a> {\n         header: &FnHeader,\n         generics: &'a Generics,\n         decl: &'a FnDecl,\n-        body: &'a Block,\n+        body: Option<&'a Block>,\n     ) {\n         let (closure_id, return_impl_trait_id) = match header.asyncness.node {\n             IsAsync::Async {\n@@ -74,7 +74,9 @@ impl<'a> DefCollector<'a> {\n                 closure_id, DefPathData::ClosureExpr, span,\n             );\n             this.with_parent(closure_def, |this| {\n-                visit::walk_block(this, body);\n+                if let Some(body) = body {\n+                    visit::walk_block(this, body);\n+                }\n             })\n         })\n     }\n@@ -123,7 +125,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     &sig.header,\n                     generics,\n                     &sig.decl,\n-                    body,\n+                    Some(body),\n                 )\n             }\n             ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n@@ -210,23 +212,20 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         visit::walk_generic_param(self, param);\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'a AssocItem) {\n         let def_data = match ti.kind {\n-            TraitItemKind::Method(..) | TraitItemKind::Const(..) =>\n-                DefPathData::ValueNs(ti.ident.name),\n-            TraitItemKind::Type(..) => {\n-                DefPathData::TypeNs(ti.ident.name)\n-            },\n-            TraitItemKind::Macro(..) => return self.visit_macro_invoc(ti.id),\n+            AssocItemKind::Fn(..) | AssocItemKind::Const(..) => DefPathData::ValueNs(ti.ident.name),\n+            AssocItemKind::TyAlias(..) => DefPathData::TypeNs(ti.ident.name),\n+            AssocItemKind::Macro(..) => return self.visit_macro_invoc(ti.id),\n         };\n \n         let def = self.create_def(ti.id, def_data, ti.span);\n         self.with_parent(def, |this| visit::walk_trait_item(this, ti));\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'a AssocItem) {\n         let def_data = match ii.kind {\n-            ImplItemKind::Method(FnSig {\n+            AssocItemKind::Fn(FnSig {\n                 ref header,\n                 ref decl,\n             }, ref body) if header.asyncness.node.is_async() => {\n@@ -237,13 +236,13 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     header,\n                     &ii.generics,\n                     decl,\n-                    body,\n+                    body.as_deref(),\n                 )\n             }\n-            ImplItemKind::Method(..) |\n-            ImplItemKind::Const(..) => DefPathData::ValueNs(ii.ident.name),\n-            ImplItemKind::TyAlias(..) => DefPathData::TypeNs(ii.ident.name),\n-            ImplItemKind::Macro(..) => return self.visit_macro_invoc(ii.id),\n+            AssocItemKind::Fn(..) |\n+            AssocItemKind::Const(..) => DefPathData::ValueNs(ii.ident.name),\n+            AssocItemKind::TyAlias(..) => DefPathData::TypeNs(ii.ident.name),\n+            AssocItemKind::Macro(..) => return self.visit_macro_invoc(ii.id),\n         };\n \n         let def = self.create_def(ii.id, def_data, ii.span);"}, {"sha": "4321f62e03bc841b39f7247a6a2e7a276ebeafce", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -806,7 +806,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                                 this.with_generic_param_rib(&trait_item.generics, AssocItemRibKind,\n                                     |this| {\n                                         match trait_item.kind {\n-                                            TraitItemKind::Const(ref ty, ref default) => {\n+                                            AssocItemKind::Const(ref ty, ref default) => {\n                                                 this.visit_ty(ty);\n \n                                                 // Only impose the restrictions of\n@@ -818,13 +818,13 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                                                     });\n                                                 }\n                                             }\n-                                            TraitItemKind::Method(_, _) => {\n+                                            AssocItemKind::Fn(_, _) => {\n                                                 visit::walk_trait_item(this, trait_item)\n                                             }\n-                                            TraitItemKind::Type(..) => {\n+                                            AssocItemKind::TyAlias(..) => {\n                                                 visit::walk_trait_item(this, trait_item)\n                                             }\n-                                            TraitItemKind::Macro(_) => {\n+                                            AssocItemKind::Macro(_) => {\n                                                 panic!(\"unexpanded macro in resolve!\")\n                                             }\n                                         };\n@@ -989,13 +989,13 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n     /// When evaluating a `trait` use its associated types' idents for suggestionsa in E0412.\n     fn with_trait_items<T>(\n         &mut self,\n-        trait_items: &Vec<TraitItem>,\n+        trait_items: &Vec<AssocItem>,\n         f: impl FnOnce(&mut Self) -> T,\n     ) -> T {\n         let trait_assoc_types = replace(\n             &mut self.diagnostic_metadata.current_trait_assoc_types,\n             trait_items.iter().filter_map(|item| match &item.kind {\n-                TraitItemKind::Type(bounds, _) if bounds.len() == 0 => Some(item.ident),\n+                AssocItemKind::TyAlias(bounds, _) if bounds.len() == 0 => Some(item.ident),\n                 _ => None,\n             }).collect(),\n         );\n@@ -1063,7 +1063,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                               opt_trait_reference: &Option<TraitRef>,\n                               self_type: &Ty,\n                               item_id: NodeId,\n-                              impl_items: &[ImplItem]) {\n+                              impl_items: &[AssocItem]) {\n         debug!(\"resolve_implementation\");\n         // If applicable, create a rib for the type parameters.\n         self.with_generic_param_rib(generics, ItemRibKind(HasGenericParams::Yes), |this| {\n@@ -1092,9 +1092,9 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                                                                 |this| {\n                                         use crate::ResolutionError::*;\n                                         match impl_item.kind {\n-                                            ImplItemKind::Const(..) => {\n+                                            AssocItemKind::Const(..) => {\n                                                 debug!(\n-                                                    \"resolve_implementation ImplItemKind::Const\",\n+                                                    \"resolve_implementation AssocItemKind::Const\",\n                                                 );\n                                                 // If this is a trait impl, ensure the const\n                                                 // exists in trait\n@@ -1109,7 +1109,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                                                     visit::walk_impl_item(this, impl_item)\n                                                 });\n                                             }\n-                                            ImplItemKind::Method(..) => {\n+                                            AssocItemKind::Fn(..) => {\n                                                 // If this is a trait impl, ensure the method\n                                                 // exists in trait\n                                                 this.check_trait_item(impl_item.ident,\n@@ -1119,7 +1119,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n                                                 visit::walk_impl_item(this, impl_item);\n                                             }\n-                                            ImplItemKind::TyAlias(ref ty) => {\n+                                            AssocItemKind::TyAlias(_, Some(ref ty)) => {\n                                                 // If this is a trait impl, ensure the type\n                                                 // exists in trait\n                                                 this.check_trait_item(impl_item.ident,\n@@ -1129,7 +1129,8 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n \n                                                 this.visit_ty(ty);\n                                             }\n-                                            ImplItemKind::Macro(_) =>\n+                                            AssocItemKind::TyAlias(_, None) => {}\n+                                            AssocItemKind::Macro(_) =>\n                                                 panic!(\"unexpanded macro in resolve!\"),\n                                         }\n                                     });"}, {"sha": "df6ad51d1045b9c54bacdff460a0a4b614b3fc63", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -676,7 +676,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         generics: &'l ast::Generics,\n         trait_ref: &'l Option<ast::TraitRef>,\n         typ: &'l ast::Ty,\n-        impl_items: &'l [ast::ImplItem],\n+        impl_items: &'l [ast::AssocItem],\n     ) {\n         if let Some(impl_data) = self.save_ctxt.get_item_data(item) {\n             if !self.span.filter_generated(item.span) {\n@@ -707,7 +707,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         item: &'l ast::Item,\n         generics: &'l ast::Generics,\n         trait_refs: &'l ast::GenericBounds,\n-        methods: &'l [ast::TraitItem],\n+        methods: &'l [ast::AssocItem],\n     ) {\n         let name = item.ident.to_string();\n         let qualname = format!(\"::{}\",\n@@ -811,18 +811,17 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                 match **generic_args {\n                     ast::GenericArgs::AngleBracketed(ref data) => {\n                         for arg in &data.args {\n-                            match arg {\n-                                ast::GenericArg::Type(ty) => self.visit_ty(ty),\n-                                _ => {}\n+                            if let ast::GenericArg::Type(ty) = arg {\n+                                self.visit_ty(ty);\n                             }\n                         }\n                     }\n                     ast::GenericArgs::Parenthesized(ref data) => {\n                         for t in &data.inputs {\n                             self.visit_ty(t);\n                         }\n-                        if let Some(ref t) = data.output {\n-                            self.visit_ty(t);\n+                        if let ast::FunctionRetTy::Ty(ty) = &data.output {\n+                            self.visit_ty(ty);\n                         }\n                     }\n                 }\n@@ -1030,11 +1029,11 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         // }\n     }\n \n-    fn process_trait_item(&mut self, trait_item: &'l ast::TraitItem, trait_id: DefId) {\n+    fn process_trait_item(&mut self, trait_item: &'l ast::AssocItem, trait_id: DefId) {\n         self.process_macro_use(trait_item.span);\n         let vis_span = trait_item.span.shrink_to_lo();\n         match trait_item.kind {\n-            ast::TraitItemKind::Const(ref ty, ref expr) => {\n+            ast::AssocItemKind::Const(ref ty, ref expr) => {\n                 self.process_assoc_const(\n                     trait_item.id,\n                     trait_item.ident,\n@@ -1045,7 +1044,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     &trait_item.attrs,\n                 );\n             }\n-            ast::TraitItemKind::Method(ref sig, ref body) => {\n+            ast::AssocItemKind::Fn(ref sig, ref body) => {\n                 self.process_method(\n                     sig,\n                     body.as_ref().map(|x| &**x),\n@@ -1056,7 +1055,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     trait_item.span,\n                 );\n             }\n-            ast::TraitItemKind::Type(ref bounds, ref default_ty) => {\n+            ast::AssocItemKind::TyAlias(ref bounds, ref default_ty) => {\n                 // FIXME do something with _bounds (for type refs)\n                 let name = trait_item.ident.name.to_string();\n                 let qualname = format!(\"::{}\",\n@@ -1098,42 +1097,43 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     self.visit_ty(default_ty)\n                 }\n             }\n-            ast::TraitItemKind::Macro(_) => {}\n+            ast::AssocItemKind::Macro(_) => {}\n         }\n     }\n \n-    fn process_impl_item(&mut self, impl_item: &'l ast::ImplItem, impl_id: DefId) {\n+    fn process_impl_item(&mut self, impl_item: &'l ast::AssocItem, impl_id: DefId) {\n         self.process_macro_use(impl_item.span);\n         match impl_item.kind {\n-            ast::ImplItemKind::Const(ref ty, ref expr) => {\n+            ast::AssocItemKind::Const(ref ty, ref expr) => {\n                 self.process_assoc_const(\n                     impl_item.id,\n                     impl_item.ident,\n                     &ty,\n-                    Some(expr),\n+                    expr.as_deref(),\n                     impl_id,\n                     impl_item.vis.clone(),\n                     &impl_item.attrs,\n                 );\n             }\n-            ast::ImplItemKind::Method(ref sig, ref body) => {\n+            ast::AssocItemKind::Fn(ref sig, ref body) => {\n                 self.process_method(\n                     sig,\n-                    Some(body),\n+                    body.as_deref(),\n                     impl_item.id,\n                     impl_item.ident,\n                     &impl_item.generics,\n                     impl_item.vis.clone(),\n                     impl_item.span,\n                 );\n             }\n-            ast::ImplItemKind::TyAlias(ref ty) => {\n+            ast::AssocItemKind::TyAlias(_, None) => {}\n+            ast::AssocItemKind::TyAlias(_, Some(ref ty)) => {\n                 // FIXME: uses of the assoc type should ideally point to this\n                 // 'def' and the name here should be a ref to the def in the\n                 // trait.\n                 self.visit_ty(ty)\n             }\n-            ast::ImplItemKind::Macro(_) => {}\n+            ast::AssocItemKind::Macro(_) => {}\n         }\n     }\n "}, {"sha": "cf54fd2887af6018b5382da120e4b2581ad33051", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 25, "deletions": 36, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -254,7 +254,7 @@ pub struct ParenthesizedArgs {\n     pub inputs: Vec<P<Ty>>,\n \n     /// `C`\n-    pub output: Option<P<Ty>>,\n+    pub output: FunctionRetTy,\n }\n \n impl ParenthesizedArgs {\n@@ -1603,54 +1603,43 @@ pub struct FnSig {\n     pub decl: P<FnDecl>,\n }\n \n-/// Represents an item declaration within a trait declaration,\n-/// possibly including a default implementation. A trait item is\n-/// either required (meaning it doesn't have an implementation, just a\n-/// signature) or provided (meaning it has a default implementation).\n+/// Represents associated items.\n+/// These include items in `impl` and `trait` definitions.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub struct TraitItem {\n+pub struct AssocItem {\n     pub attrs: Vec<Attribute>,\n     pub id: NodeId,\n     pub span: Span,\n     pub vis: Visibility,\n     pub ident: Ident,\n \n+    pub defaultness: Defaultness,\n     pub generics: Generics,\n-    pub kind: TraitItemKind,\n+    pub kind: AssocItemKind,\n     /// See `Item::tokens` for what this is.\n     pub tokens: Option<TokenStream>,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum TraitItemKind {\n+/// Represents various kinds of content within an `impl`.\n+///\n+/// The term \"provided\" in the variants below refers to the item having a default\n+/// definition / body. Meanwhile, a \"required\" item lacks a definition / body.\n+/// In an implementation, all items must be provided.\n+/// The `Option`s below denote the bodies, where `Some(_)`\n+/// means \"provided\" and conversely `None` means \"required\".\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub enum AssocItemKind  {\n+    /// An associated constant, `const $ident: $ty $def?;` where `def ::= \"=\" $expr? ;`.\n+    /// If `def` is parsed, then the associated constant is provided, and otherwise required.\n     Const(P<Ty>, Option<P<Expr>>),\n-    Method(FnSig, Option<P<Block>>),\n-    Type(GenericBounds, Option<P<Ty>>),\n-    Macro(Mac),\n-}\n \n-/// Represents anything within an `impl` block.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub struct ImplItem {\n-    pub attrs: Vec<Attribute>,\n-    pub id: NodeId,\n-    pub span: Span,\n-    pub vis: Visibility,\n-    pub ident: Ident,\n+    /// An associated function.\n+    Fn(FnSig, Option<P<Block>>),\n \n-    pub defaultness: Defaultness,\n-    pub generics: Generics,\n-    pub kind: ImplItemKind,\n-    /// See `Item::tokens` for what this is.\n-    pub tokens: Option<TokenStream>,\n-}\n+    /// An associated type.\n+    TyAlias(GenericBounds, Option<P<Ty>>),\n \n-/// Represents various kinds of content within an `impl`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum ImplItemKind {\n-    Const(P<Ty>, P<Expr>),\n-    Method(FnSig, P<Block>),\n-    TyAlias(P<Ty>),\n+    /// A macro expanding to an associated item.\n     Macro(Mac),\n }\n \n@@ -2189,7 +2178,7 @@ impl fmt::Debug for ImplPolarity {\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum FunctionRetTy {\n+pub enum FunctionRetTy { // FIXME(Centril): Rename to `FnRetTy` and in HIR also.\n     /// Returns type is not specified.\n     ///\n     /// Functions default to `()` and closures default to inference.\n@@ -2602,7 +2591,7 @@ pub enum ItemKind {\n     /// A trait declaration (`trait`).\n     ///\n     /// E.g., `trait Foo { .. }`, `trait Foo<T> { .. }` or `auto trait Foo {}`.\n-    Trait(IsAuto, Unsafety, Generics, GenericBounds, Vec<TraitItem>),\n+    Trait(IsAuto, Unsafety, Generics, GenericBounds, Vec<AssocItem>),\n     /// Trait alias\n     ///\n     /// E.g., `trait Foo = Bar + Quux;`.\n@@ -2617,7 +2606,7 @@ pub enum ItemKind {\n         Generics,\n         Option<TraitRef>, // (optional) trait this impl implements\n         P<Ty>,            // self\n-        Vec<ImplItem>,\n+        Vec<AssocItem>,\n     ),\n     /// A macro invocation.\n     ///"}, {"sha": "13a9ed5f215d239a3658b368c3fa9f0081be4222", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -749,6 +749,6 @@ macro_rules! derive_has_attrs {\n }\n \n derive_has_attrs! {\n-    Item, Expr, Local, ast::ForeignItem, ast::StructField, ast::ImplItem, ast::TraitItem, ast::Arm,\n+    Item, Expr, Local, ast::ForeignItem, ast::StructField, ast::AssocItem, ast::Arm,\n     ast::Field, ast::FieldPat, ast::Variant, ast::Param\n }"}, {"sha": "aacd14c3af759908bce0f0347a2165ba2a64c3c2", "filename": "src/libsyntax/feature_gate/check.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -589,54 +589,52 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         visit::walk_assoc_ty_constraint(self, constraint)\n     }\n \n-    fn visit_trait_item(&mut self, ti: &'a ast::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'a ast::AssocItem) {\n         match ti.kind {\n-            ast::TraitItemKind::Method(ref sig, ref block) => {\n+            ast::AssocItemKind::Fn(ref sig, ref block) => {\n                 if block.is_none() {\n                     self.check_extern(sig.header.ext);\n                 }\n-                if sig.decl.c_variadic() {\n-                    gate_feature_post!(&self, c_variadic, ti.span,\n-                                       \"C-variadic functions are unstable\");\n-                }\n                 if sig.header.constness.node == ast::Constness::Const {\n                     gate_feature_post!(&self, const_fn, ti.span, \"const fn is unstable\");\n                 }\n             }\n-            ast::TraitItemKind::Type(_, ref default) => {\n-                if let Some(ty) = default {\n-                    self.check_impl_trait(ty);\n-                    gate_feature_post!(&self, associated_type_defaults, ti.span,\n-                                       \"associated type defaults are unstable\");\n+            ast::AssocItemKind::TyAlias(_, ref default) => {\n+                if let Some(_) = default {\n+                    gate_feature_post!(\n+                        &self, associated_type_defaults, ti.span,\n+                        \"associated type defaults are unstable\"\n+                    );\n                 }\n-                self.check_gat(&ti.generics, ti.span);\n             }\n             _ => {}\n         }\n         visit::walk_trait_item(self, ti)\n     }\n \n-    fn visit_impl_item(&mut self, ii: &'a ast::ImplItem) {\n+    fn visit_assoc_item(&mut self, ii: &'a ast::AssocItem) {\n         if ii.defaultness == ast::Defaultness::Default {\n-            gate_feature_post!(&self, specialization,\n-                              ii.span,\n-                              \"specialization is unstable\");\n+            gate_feature_post!(&self, specialization, ii.span, \"specialization is unstable\");\n         }\n \n         match ii.kind {\n-            ast::ImplItemKind::Method(ref sig, _) => {\n+            ast::AssocItemKind::Fn(ref sig, _) => {\n                 if sig.decl.c_variadic() {\n-                    gate_feature_post!(&self, c_variadic, ii.span,\n-                                       \"C-variadic functions are unstable\");\n+                    gate_feature_post!(\n+                        &self, c_variadic, ii.span,\n+                        \"C-variadic functions are unstable\"\n+                    );\n                 }\n             }\n-            ast::ImplItemKind::TyAlias(ref ty) => {\n-                self.check_impl_trait(ty);\n+            ast::AssocItemKind::TyAlias(_, ref ty) => {\n+                if let Some(ty) = ty {\n+                    self.check_impl_trait(ty);\n+                }\n                 self.check_gat(&ii.generics, ii.span);\n             }\n             _ => {}\n         }\n-        visit::walk_impl_item(self, ii)\n+        visit::walk_assoc_item(self, ii)\n     }\n \n     fn visit_vis(&mut self, vis: &'a ast::Visibility) {"}, {"sha": "2a6cff5971c57e0b8c5629f9750b613d2ddb1028", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 21, "deletions": 45, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -103,12 +103,12 @@ pub trait MutVisitor: Sized {\n         noop_visit_item_kind(i, self);\n     }\n \n-    fn flat_map_trait_item(&mut self, i: TraitItem) -> SmallVec<[TraitItem; 1]> {\n-        noop_flat_map_trait_item(i, self)\n+    fn flat_map_trait_item(&mut self, i: AssocItem) -> SmallVec<[AssocItem; 1]> {\n+        noop_flat_map_assoc_item(i, self)\n     }\n \n-    fn flat_map_impl_item(&mut self, i: ImplItem) -> SmallVec<[ImplItem; 1]> {\n-        noop_flat_map_impl_item(i, self)\n+    fn flat_map_impl_item(&mut self, i: AssocItem) -> SmallVec<[AssocItem; 1]> {\n+        noop_flat_map_assoc_item(i, self)\n     }\n \n     fn visit_fn_decl(&mut self, d: &mut P<FnDecl>) {\n@@ -553,7 +553,7 @@ pub fn noop_visit_parenthesized_parameter_data<T: MutVisitor>(args: &mut Parenth\n                                                               vis: &mut T) {\n     let ParenthesizedArgs { inputs, output, span } = args;\n     visit_vec(inputs, |input| vis.visit_ty(input));\n-    visit_opt(output, |output| vis.visit_ty(output));\n+    noop_visit_fn_ret_ty(output, vis);\n     vis.visit_span(span);\n }\n \n@@ -742,7 +742,11 @@ pub fn noop_visit_asyncness<T: MutVisitor>(asyncness: &mut IsAsync, vis: &mut T)\n pub fn noop_visit_fn_decl<T: MutVisitor>(decl: &mut P<FnDecl>, vis: &mut T) {\n     let FnDecl { inputs, output } = decl.deref_mut();\n     inputs.flat_map_in_place(|param| vis.flat_map_param(param));\n-    match output {\n+    noop_visit_fn_ret_ty(output, vis);\n+}\n+\n+pub fn noop_visit_fn_ret_ty<T: MutVisitor>(fn_ret_ty: &mut FunctionRetTy, vis: &mut T) {\n+    match fn_ret_ty {\n         FunctionRetTy::Default(span) => vis.visit_span(span),\n         FunctionRetTy::Ty(ty) => vis.visit_ty(ty),\n     }\n@@ -936,58 +940,30 @@ pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n     }\n }\n \n-pub fn noop_flat_map_trait_item<T: MutVisitor>(mut item: TraitItem, visitor: &mut T)\n-    -> SmallVec<[TraitItem; 1]>\n+pub fn noop_flat_map_assoc_item<T: MutVisitor>(mut item: AssocItem, visitor: &mut T)\n+    -> SmallVec<[AssocItem; 1]>\n {\n-    let TraitItem { id, ident, vis, attrs, generics, kind, span, tokens: _ } = &mut item;\n+    let AssocItem { id, ident, vis, defaultness: _, attrs, generics, kind, span, tokens: _ } =\n+        &mut item;\n     visitor.visit_id(id);\n     visitor.visit_ident(ident);\n     visitor.visit_vis(vis);\n     visit_attrs(attrs, visitor);\n     visitor.visit_generics(generics);\n-    match kind {\n-        TraitItemKind::Const(ty, default) => {\n+    match kind  {\n+        AssocItemKind::Const(ty, expr) => {\n             visitor.visit_ty(ty);\n-            visit_opt(default, |default| visitor.visit_expr(default));\n+            visit_opt(expr, |expr| visitor.visit_expr(expr));\n         }\n-        TraitItemKind::Method(sig, body) => {\n+        AssocItemKind::Fn(sig, body) => {\n             visit_fn_sig(sig, visitor);\n             visit_opt(body, |body| visitor.visit_block(body));\n         }\n-        TraitItemKind::Type(bounds, default) => {\n+        AssocItemKind::TyAlias(bounds, ty) => {\n             visit_bounds(bounds, visitor);\n-            visit_opt(default, |default| visitor.visit_ty(default));\n-        }\n-        TraitItemKind::Macro(mac) => {\n-            visitor.visit_mac(mac);\n-        }\n-    }\n-    visitor.visit_span(span);\n-\n-    smallvec![item]\n-}\n-\n-pub fn noop_flat_map_impl_item<T: MutVisitor>(mut item: ImplItem, visitor: &mut T)\n-                                              -> SmallVec<[ImplItem; 1]>\n-{\n-    let ImplItem { id, ident, vis, defaultness: _, attrs, generics, kind, span, tokens: _ } =\n-        &mut item;\n-    visitor.visit_id(id);\n-    visitor.visit_ident(ident);\n-    visitor.visit_vis(vis);\n-    visit_attrs(attrs, visitor);\n-    visitor.visit_generics(generics);\n-    match kind  {\n-        ImplItemKind::Const(ty, expr) => {\n-            visitor.visit_ty(ty);\n-            visitor.visit_expr(expr);\n-        }\n-        ImplItemKind::Method(sig, body) => {\n-            visit_fn_sig(sig, visitor);\n-            visitor.visit_block(body);\n+            visit_opt(ty, |ty| visitor.visit_ty(ty));\n         }\n-        ImplItemKind::TyAlias(ty) => visitor.visit_ty(ty),\n-        ImplItemKind::Macro(mac) => visitor.visit_mac(mac),\n+        AssocItemKind::Macro(mac) => visitor.visit_mac(mac),\n     }\n     visitor.visit_span(span);\n "}, {"sha": "87f6ae85b6970a2a1ed0dca4e5d28783674dfa02", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 47, "deletions": 143, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -335,8 +335,8 @@ pub fn nonterminal_to_string(nt: &Nonterminal) -> String {\n         token::NtLifetime(e)        => e.to_string(),\n         token::NtLiteral(ref e)     => expr_to_string(e),\n         token::NtTT(ref tree)       => tt_to_string(tree.clone()),\n-        token::NtImplItem(ref e)    => impl_item_to_string(e),\n-        token::NtTraitItem(ref e)   => trait_item_to_string(e),\n+        // FIXME(Centril): merge these variants.\n+        token::NtImplItem(ref e) | token::NtTraitItem(ref e) => assoc_item_to_string(e),\n         token::NtVis(ref e)         => vis_to_string(e),\n         token::NtForeignItem(ref e) => foreign_item_to_string(e),\n     }\n@@ -374,12 +374,8 @@ pub fn item_to_string(i: &ast::Item) -> String {\n     to_string(|s| s.print_item(i))\n }\n \n-fn impl_item_to_string(i: &ast::ImplItem) -> String {\n-    to_string(|s| s.print_impl_item(i))\n-}\n-\n-fn trait_item_to_string(i: &ast::TraitItem) -> String {\n-    to_string(|s| s.print_trait_item(i))\n+fn assoc_item_to_string(i: &ast::AssocItem) -> String {\n+    to_string(|s| s.print_assoc_item(i))\n }\n \n pub fn generic_params_to_string(generic_params: &[ast::GenericParam]) -> String {\n@@ -887,17 +883,9 @@ impl<'a> PrintState<'a> for State<'a> {\n \n             ast::GenericArgs::Parenthesized(ref data) => {\n                 self.s.word(\"(\");\n-                self.commasep(\n-                    Inconsistent,\n-                    &data.inputs,\n-                    |s, ty| s.print_type(ty));\n+                self.commasep(Inconsistent, &data.inputs, |s, ty| s.print_type(ty));\n                 self.s.word(\")\");\n-\n-                if let Some(ref ty) = data.output {\n-                    self.space_if_not_bol();\n-                    self.word_space(\"->\");\n-                    self.print_type(ty);\n-                }\n+                self.print_fn_ret_ty(&data.output);\n             }\n         }\n     }\n@@ -1128,16 +1116,15 @@ impl<'a> State<'a> {\n         self.s.word(\";\")\n     }\n \n-    fn print_associated_type(&mut self,\n-                             ident: ast::Ident,\n-                             bounds: Option<&ast::GenericBounds>,\n-                             ty: Option<&ast::Ty>)\n-                             {\n+    fn print_associated_type(\n+        &mut self,\n+        ident: ast::Ident,\n+        bounds: &ast::GenericBounds,\n+        ty: Option<&ast::Ty>,\n+    ) {\n         self.word_space(\"type\");\n         self.print_ident(ident);\n-        if let Some(bounds) = bounds {\n-            self.print_type_bounds(\":\", bounds);\n-        }\n+        self.print_type_bounds(\":\", bounds);\n         if let Some(ty) = ty {\n             self.s.space();\n             self.word_space(\"=\");\n@@ -1310,7 +1297,7 @@ impl<'a> State<'a> {\n                 self.bopen();\n                 self.print_inner_attributes(&item.attrs);\n                 for impl_item in impl_items {\n-                    self.print_impl_item(impl_item);\n+                    self.print_assoc_item(impl_item);\n                 }\n                 self.bclose(item.span);\n             }\n@@ -1337,7 +1324,7 @@ impl<'a> State<'a> {\n                 self.s.word(\" \");\n                 self.bopen();\n                 for trait_item in trait_items {\n-                    self.print_trait_item(trait_item);\n+                    self.print_assoc_item(trait_item);\n                 }\n                 self.bclose(item.span);\n             }\n@@ -1531,92 +1518,39 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_method_sig(&mut self,\n-                            ident: ast::Ident,\n-                            generics: &ast::Generics,\n-                            m: &ast::FnSig,\n-                            vis: &ast::Visibility)\n-                            {\n-        self.print_fn(&m.decl,\n-                      m.header,\n-                      Some(ident),\n-                      &generics,\n-                      vis)\n-    }\n-\n-    crate fn print_trait_item(&mut self, ti: &ast::TraitItem)\n-                            {\n-        self.ann.pre(self, AnnNode::SubItem(ti.id));\n+    crate fn print_assoc_item(&mut self, item: &ast::AssocItem) {\n+        self.ann.pre(self, AnnNode::SubItem(item.id));\n         self.hardbreak_if_not_bol();\n-        self.maybe_print_comment(ti.span.lo());\n-        self.print_outer_attributes(&ti.attrs);\n-        match ti.kind {\n-            ast::TraitItemKind::Const(ref ty, ref default) => {\n-                self.print_associated_const(\n-                    ti.ident,\n-                    ty,\n-                    default.as_ref().map(|expr| &**expr),\n-                    &source_map::respan(ti.span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n-                );\n+        self.maybe_print_comment(item.span.lo());\n+        self.print_outer_attributes(&item.attrs);\n+        self.print_defaultness(item.defaultness);\n+        match &item.kind {\n+            ast::AssocItemKind::Const(ty, expr) => {\n+                self.print_associated_const(item.ident, ty, expr.as_deref(), &item.vis);\n             }\n-            ast::TraitItemKind::Method(ref sig, ref body) => {\n+            ast::AssocItemKind::Fn(sig, body) => {\n                 if body.is_some() {\n                     self.head(\"\");\n                 }\n-                self.print_method_sig(\n-                    ti.ident,\n-                    &ti.generics,\n-                    sig,\n-                    &source_map::respan(ti.span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n-                );\n-                if let Some(ref body) = *body {\n+                self.print_fn(&sig.decl, sig.header, Some(item.ident), &item.generics, &item.vis);\n+                if let Some(body) = body {\n                     self.nbsp();\n-                    self.print_block_with_attrs(body, &ti.attrs);\n+                    self.print_block_with_attrs(body, &item.attrs);\n                 } else {\n                     self.s.word(\";\");\n                 }\n             }\n-            ast::TraitItemKind::Type(ref bounds, ref default) => {\n-                self.print_associated_type(ti.ident, Some(bounds),\n-                                           default.as_ref().map(|ty| &**ty));\n+            ast::AssocItemKind::TyAlias(bounds, ty) => {\n+                self.print_associated_type(item.ident, bounds, ty.as_deref());\n             }\n-            ast::TraitItemKind::Macro(ref mac) => {\n+            ast::AssocItemKind::Macro(mac) => {\n                 self.print_mac(mac);\n                 if mac.args.need_semicolon() {\n                     self.s.word(\";\");\n                 }\n             }\n         }\n-        self.ann.post(self, AnnNode::SubItem(ti.id))\n-    }\n-\n-    crate fn print_impl_item(&mut self, ii: &ast::ImplItem) {\n-        self.ann.pre(self, AnnNode::SubItem(ii.id));\n-        self.hardbreak_if_not_bol();\n-        self.maybe_print_comment(ii.span.lo());\n-        self.print_outer_attributes(&ii.attrs);\n-        self.print_defaultness(ii.defaultness);\n-        match ii.kind {\n-            ast::ImplItemKind::Const(ref ty, ref expr) => {\n-                self.print_associated_const(ii.ident, ty, Some(expr), &ii.vis);\n-            }\n-            ast::ImplItemKind::Method(ref sig, ref body) => {\n-                self.head(\"\");\n-                self.print_method_sig(ii.ident, &ii.generics, sig, &ii.vis);\n-                self.nbsp();\n-                self.print_block_with_attrs(body, &ii.attrs);\n-            }\n-            ast::ImplItemKind::TyAlias(ref ty) => {\n-                self.print_associated_type(ii.ident, None, Some(ty));\n-            }\n-            ast::ImplItemKind::Macro(ref mac) => {\n-                self.print_mac(mac);\n-                if mac.args.need_semicolon() {\n-                    self.s.word(\";\");\n-                }\n-            }\n-        }\n-        self.ann.post(self, AnnNode::SubItem(ii.id))\n+        self.ann.post(self, AnnNode::SubItem(item.id))\n     }\n \n     crate fn print_stmt(&mut self, st: &ast::Stmt) {\n@@ -2109,7 +2043,7 @@ impl<'a> State<'a> {\n                 self.print_asyncness(asyncness);\n                 self.print_capture_clause(capture_clause);\n \n-                self.print_fn_block_params(decl);\n+                self.print_fn_params_and_ret(decl, true);\n                 self.s.space();\n                 self.print_expr(body);\n                 self.end(); // need to close a box\n@@ -2540,36 +2474,16 @@ impl<'a> State<'a> {\n             self.print_ident(name);\n         }\n         self.print_generic_params(&generics.params);\n-        self.print_fn_params_and_ret(decl);\n+        self.print_fn_params_and_ret(decl, false);\n         self.print_where_clause(&generics.where_clause)\n     }\n \n-    crate fn print_fn_params_and_ret(&mut self, decl: &ast::FnDecl) {\n-        self.popen();\n-        self.commasep(Inconsistent, &decl.inputs, |s, param| s.print_param(param, false));\n-        self.pclose();\n-\n-        self.print_fn_output(decl)\n-    }\n-\n-    crate fn print_fn_block_params(&mut self, decl: &ast::FnDecl) {\n-        self.s.word(\"|\");\n-        self.commasep(Inconsistent, &decl.inputs, |s, param| s.print_param(param, true));\n-        self.s.word(\"|\");\n-\n-        if let ast::FunctionRetTy::Default(..) = decl.output {\n-            return;\n-        }\n-\n-        self.space_if_not_bol();\n-        self.word_space(\"->\");\n-        match decl.output {\n-            ast::FunctionRetTy::Ty(ref ty) => {\n-                self.print_type(ty);\n-                self.maybe_print_comment(ty.span.lo())\n-            }\n-            ast::FunctionRetTy::Default(..) => unreachable!(),\n-        }\n+    crate fn print_fn_params_and_ret(&mut self, decl: &ast::FnDecl, is_closure: bool) {\n+        let (open, close) = if is_closure { (\"|\", \"|\") } else { (\"(\", \")\") };\n+        self.word(open);\n+        self.commasep(Inconsistent, &decl.inputs, |s, param| s.print_param(param, is_closure));\n+        self.word(close);\n+        self.print_fn_ret_ty(&decl.output)\n     }\n \n     crate fn print_movability(&mut self, movability: ast::Movability) {\n@@ -2791,24 +2705,14 @@ impl<'a> State<'a> {\n         self.end();\n     }\n \n-    crate fn print_fn_output(&mut self, decl: &ast::FnDecl) {\n-        if let ast::FunctionRetTy::Default(..) = decl.output {\n-            return;\n-        }\n-\n-        self.space_if_not_bol();\n-        self.ibox(INDENT_UNIT);\n-        self.word_space(\"->\");\n-        match decl.output {\n-            ast::FunctionRetTy::Default(..) => unreachable!(),\n-            ast::FunctionRetTy::Ty(ref ty) =>\n-                self.print_type(ty),\n-        }\n-        self.end();\n-\n-        match decl.output {\n-            ast::FunctionRetTy::Ty(ref output) => self.maybe_print_comment(output.span.lo()),\n-            _ => {}\n+    crate fn print_fn_ret_ty(&mut self, fn_ret_ty: &ast::FunctionRetTy) {\n+        if let ast::FunctionRetTy::Ty(ty) = fn_ret_ty {\n+            self.space_if_not_bol();\n+            self.ibox(INDENT_UNIT);\n+            self.word_space(\"->\");\n+            self.print_type(ty);\n+            self.end();\n+            self.maybe_print_comment(ty.span.lo());\n         }\n     }\n "}, {"sha": "263f8192241f2e728fcdafb8ed2272dc5f28a522", "filename": "src/libsyntax/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibsyntax%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibsyntax%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftoken.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -685,8 +685,8 @@ pub enum Nonterminal {\n     // Used only for passing items to proc macro attributes (they are not\n     // strictly necessary for that, `Annotatable` can be converted into\n     // tokens directly, but doing that naively regresses pretty-printing).\n-    NtTraitItem(ast::TraitItem),\n-    NtImplItem(ast::ImplItem),\n+    NtTraitItem(ast::AssocItem),\n+    NtImplItem(ast::AssocItem),\n     NtForeignItem(ast::ForeignItem),\n }\n "}, {"sha": "3db9955d304a392249a311d069e3c12ff2cbeb2b", "filename": "src/libsyntax/util/node_count.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnode_count.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -73,13 +73,9 @@ impl<'ast> Visitor<'ast> for NodeCounter {\n         self.count += 1;\n         walk_fn(self, fk, fd, s)\n     }\n-    fn visit_trait_item(&mut self, ti: &TraitItem) {\n+    fn visit_assoc_item(&mut self, ti: &AssocItem) {\n         self.count += 1;\n-        walk_trait_item(self, ti)\n-    }\n-    fn visit_impl_item(&mut self, ii: &ImplItem) {\n-        self.count += 1;\n-        walk_impl_item(self, ii)\n+        walk_assoc_item(self, ti)\n     }\n     fn visit_trait_ref(&mut self, t: &TraitRef) {\n         self.count += 1;"}, {"sha": "51e7fa1eb38b49bd94546e9f34cf597f287912ab", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 28, "deletions": 42, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -25,7 +25,7 @@ pub enum FnKind<'a> {\n     ItemFn(Ident, &'a FnHeader, &'a Visibility, &'a Block),\n \n     /// E.g., `fn foo(&self)`.\n-    Method(Ident, &'a FnSig, Option<&'a Visibility>, &'a Block),\n+    Method(Ident, &'a FnSig, &'a Visibility, &'a Block),\n \n     /// E.g., `|x, y| body`.\n     Closure(&'a Expr),\n@@ -83,8 +83,9 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_fn(&mut self, fk: FnKind<'ast>, fd: &'ast FnDecl, s: Span, _: NodeId) {\n         walk_fn(self, fk, fd, s)\n     }\n-    fn visit_trait_item(&mut self, ti: &'ast TraitItem) { walk_trait_item(self, ti) }\n-    fn visit_impl_item(&mut self, ii: &'ast ImplItem) { walk_impl_item(self, ii) }\n+    fn visit_trait_item(&mut self, i: &'ast AssocItem) { walk_trait_item(self, i) }\n+    fn visit_impl_item(&mut self, i: &'ast AssocItem) { walk_impl_item(self, i) }\n+    fn visit_assoc_item(&mut self, i: &'ast AssocItem) { walk_assoc_item(self, i) }\n     fn visit_trait_ref(&mut self, t: &'ast TraitRef) { walk_trait_ref(self, t) }\n     fn visit_param_bound(&mut self, bounds: &'ast GenericBound) {\n         walk_param_bound(self, bounds)\n@@ -420,7 +421,7 @@ pub fn walk_generic_args<'a, V>(visitor: &mut V,\n         }\n         GenericArgs::Parenthesized(ref data) => {\n             walk_list!(visitor, visit_ty, &data.inputs);\n-            walk_list!(visitor, visit_ty, &data.output);\n+            walk_fn_ret_ty(visitor, &data.output);\n         }\n     }\n }\n@@ -581,52 +582,37 @@ pub fn walk_fn<'a, V>(visitor: &mut V, kind: FnKind<'a>, declaration: &'a FnDecl\n     }\n }\n \n-pub fn walk_trait_item<'a, V: Visitor<'a>>(visitor: &mut V, trait_item: &'a TraitItem) {\n-    visitor.visit_vis(&trait_item.vis);\n-    visitor.visit_ident(trait_item.ident);\n-    walk_list!(visitor, visit_attribute, &trait_item.attrs);\n-    visitor.visit_generics(&trait_item.generics);\n-    match trait_item.kind {\n-        TraitItemKind::Const(ref ty, ref default) => {\n+pub fn walk_impl_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a AssocItem) {\n+    visitor.visit_assoc_item(item);\n+}\n+\n+pub fn walk_trait_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a AssocItem) {\n+    visitor.visit_assoc_item(item);\n+}\n+\n+pub fn walk_assoc_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a AssocItem) {\n+    visitor.visit_vis(&item.vis);\n+    visitor.visit_ident(item.ident);\n+    walk_list!(visitor, visit_attribute, &item.attrs);\n+    visitor.visit_generics(&item.generics);\n+    match item.kind {\n+        AssocItemKind::Const(ref ty, ref expr) => {\n             visitor.visit_ty(ty);\n-            walk_list!(visitor, visit_expr, default);\n+            walk_list!(visitor, visit_expr, expr);\n         }\n-        TraitItemKind::Method(ref sig, None) => {\n+        AssocItemKind::Fn(ref sig, None) => {\n             visitor.visit_fn_header(&sig.header);\n             walk_fn_decl(visitor, &sig.decl);\n         }\n-        TraitItemKind::Method(ref sig, Some(ref body)) => {\n-            visitor.visit_fn(FnKind::Method(trait_item.ident, sig, None, body),\n-                             &sig.decl, trait_item.span, trait_item.id);\n+        AssocItemKind::Fn(ref sig, Some(ref body)) => {\n+            visitor.visit_fn(FnKind::Method(item.ident, sig, &item.vis, body),\n+                             &sig.decl, item.span, item.id);\n         }\n-        TraitItemKind::Type(ref bounds, ref default) => {\n+        AssocItemKind::TyAlias(ref bounds, ref ty) => {\n             walk_list!(visitor, visit_param_bound, bounds);\n-            walk_list!(visitor, visit_ty, default);\n-        }\n-        TraitItemKind::Macro(ref mac) => {\n-            visitor.visit_mac(mac);\n-        }\n-    }\n-}\n-\n-pub fn walk_impl_item<'a, V: Visitor<'a>>(visitor: &mut V, impl_item: &'a ImplItem) {\n-    visitor.visit_vis(&impl_item.vis);\n-    visitor.visit_ident(impl_item.ident);\n-    walk_list!(visitor, visit_attribute, &impl_item.attrs);\n-    visitor.visit_generics(&impl_item.generics);\n-    match impl_item.kind {\n-        ImplItemKind::Const(ref ty, ref expr) => {\n-            visitor.visit_ty(ty);\n-            visitor.visit_expr(expr);\n-        }\n-        ImplItemKind::Method(ref sig, ref body) => {\n-            visitor.visit_fn(FnKind::Method(impl_item.ident, sig, Some(&impl_item.vis), body),\n-                             &sig.decl, impl_item.span, impl_item.id);\n-        }\n-        ImplItemKind::TyAlias(ref ty) => {\n-            visitor.visit_ty(ty);\n+            walk_list!(visitor, visit_ty, ty);\n         }\n-        ImplItemKind::Macro(ref mac) => {\n+        AssocItemKind::Macro(ref mac) => {\n             visitor.visit_mac(mac);\n         }\n     }"}, {"sha": "75066a006bf3aaa0d7dbbbbf35f80f94b5f86900", "filename": "src/libsyntax_expand/base.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibsyntax_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibsyntax_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fbase.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -31,8 +31,8 @@ crate use syntax_pos::hygiene::MacroKind;\n #[derive(Debug,Clone)]\n pub enum Annotatable {\n     Item(P<ast::Item>),\n-    TraitItem(P<ast::TraitItem>),\n-    ImplItem(P<ast::ImplItem>),\n+    TraitItem(P<ast::AssocItem>),\n+    ImplItem(P<ast::AssocItem>),\n     ForeignItem(P<ast::ForeignItem>),\n     Stmt(P<ast::Stmt>),\n     Expr(P<ast::Expr>),\n@@ -137,14 +137,14 @@ impl Annotatable {\n         }\n     }\n \n-    pub fn expect_trait_item(self) -> ast::TraitItem {\n+    pub fn expect_trait_item(self) -> ast::AssocItem {\n         match self {\n             Annotatable::TraitItem(i) => i.into_inner(),\n             _ => panic!(\"expected Item\")\n         }\n     }\n \n-    pub fn expect_impl_item(self) -> ast::ImplItem {\n+    pub fn expect_impl_item(self) -> ast::AssocItem {\n         match self {\n             Annotatable::ImplItem(i) => i.into_inner(),\n             _ => panic!(\"expected Item\")\n@@ -382,12 +382,12 @@ pub trait MacResult {\n     }\n \n     /// Creates zero or more impl items.\n-    fn make_impl_items(self: Box<Self>) -> Option<SmallVec<[ast::ImplItem; 1]>> {\n+    fn make_impl_items(self: Box<Self>) -> Option<SmallVec<[ast::AssocItem; 1]>> {\n         None\n     }\n \n     /// Creates zero or more trait items.\n-    fn make_trait_items(self: Box<Self>) -> Option<SmallVec<[ast::TraitItem; 1]>> {\n+    fn make_trait_items(self: Box<Self>) -> Option<SmallVec<[ast::AssocItem; 1]>> {\n         None\n     }\n \n@@ -468,8 +468,8 @@ make_MacEager! {\n     expr: P<ast::Expr>,\n     pat: P<ast::Pat>,\n     items: SmallVec<[P<ast::Item>; 1]>,\n-    impl_items: SmallVec<[ast::ImplItem; 1]>,\n-    trait_items: SmallVec<[ast::TraitItem; 1]>,\n+    impl_items: SmallVec<[ast::AssocItem; 1]>,\n+    trait_items: SmallVec<[ast::AssocItem; 1]>,\n     foreign_items: SmallVec<[ast::ForeignItem; 1]>,\n     stmts: SmallVec<[ast::Stmt; 1]>,\n     ty: P<ast::Ty>,\n@@ -484,11 +484,11 @@ impl MacResult for MacEager {\n         self.items\n     }\n \n-    fn make_impl_items(self: Box<Self>) -> Option<SmallVec<[ast::ImplItem; 1]>> {\n+    fn make_impl_items(self: Box<Self>) -> Option<SmallVec<[ast::AssocItem; 1]>> {\n         self.impl_items\n     }\n \n-    fn make_trait_items(self: Box<Self>) -> Option<SmallVec<[ast::TraitItem; 1]>> {\n+    fn make_trait_items(self: Box<Self>) -> Option<SmallVec<[ast::AssocItem; 1]>> {\n         self.trait_items\n     }\n \n@@ -588,11 +588,11 @@ impl MacResult for DummyResult {\n         Some(SmallVec::new())\n     }\n \n-    fn make_impl_items(self: Box<DummyResult>) -> Option<SmallVec<[ast::ImplItem; 1]>> {\n+    fn make_impl_items(self: Box<DummyResult>) -> Option<SmallVec<[ast::AssocItem; 1]>> {\n         Some(SmallVec::new())\n     }\n \n-    fn make_trait_items(self: Box<DummyResult>) -> Option<SmallVec<[ast::TraitItem; 1]>> {\n+    fn make_trait_items(self: Box<DummyResult>) -> Option<SmallVec<[ast::AssocItem; 1]>> {\n         Some(SmallVec::new())\n     }\n "}, {"sha": "25c6c287120e94a538a295c496fe3d2e5b05ee8d", "filename": "src/libsyntax_expand/expand.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibsyntax_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibsyntax_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fexpand.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -154,10 +154,10 @@ ast_fragments! {\n     Items(SmallVec<[P<ast::Item>; 1]>) {\n         \"item\"; many fn flat_map_item; fn visit_item; fn make_items;\n     }\n-    TraitItems(SmallVec<[ast::TraitItem; 1]>) {\n+    TraitItems(SmallVec<[ast::AssocItem; 1]>) {\n         \"trait item\"; many fn flat_map_trait_item; fn visit_trait_item; fn make_trait_items;\n     }\n-    ImplItems(SmallVec<[ast::ImplItem; 1]>) {\n+    ImplItems(SmallVec<[ast::AssocItem; 1]>) {\n         \"impl item\"; many fn flat_map_impl_item; fn visit_impl_item; fn make_impl_items;\n     }\n     ForeignItems(SmallVec<[ast::ForeignItem; 1]>) {\n@@ -1316,7 +1316,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         }\n     }\n \n-    fn flat_map_trait_item(&mut self, item: ast::TraitItem) -> SmallVec<[ast::TraitItem; 1]> {\n+    fn flat_map_trait_item(&mut self, item: ast::AssocItem) -> SmallVec<[ast::AssocItem; 1]> {\n         let mut item = configure!(self, item);\n \n         let (attr, traits, after_derive) = self.classify_item(&mut item);\n@@ -1326,16 +1326,16 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         }\n \n         match item.kind {\n-            ast::TraitItemKind::Macro(mac) => {\n-                let ast::TraitItem { attrs, span, .. } = item;\n+            ast::AssocItemKind::Macro(mac) => {\n+                let ast::AssocItem { attrs, span, .. } = item;\n                 self.check_attributes(&attrs);\n                 self.collect_bang(mac, span, AstFragmentKind::TraitItems).make_trait_items()\n             }\n-            _ => noop_flat_map_trait_item(item, self),\n+            _ => noop_flat_map_assoc_item(item, self),\n         }\n     }\n \n-    fn flat_map_impl_item(&mut self, item: ast::ImplItem) -> SmallVec<[ast::ImplItem; 1]> {\n+    fn flat_map_impl_item(&mut self, item: ast::AssocItem) -> SmallVec<[ast::AssocItem; 1]> {\n         let mut item = configure!(self, item);\n \n         let (attr, traits, after_derive) = self.classify_item(&mut item);\n@@ -1345,12 +1345,12 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         }\n \n         match item.kind {\n-            ast::ImplItemKind::Macro(mac) => {\n-                let ast::ImplItem { attrs, span, .. } = item;\n+            ast::AssocItemKind::Macro(mac) => {\n+                let ast::AssocItem { attrs, span, .. } = item;\n                 self.check_attributes(&attrs);\n                 self.collect_bang(mac, span, AstFragmentKind::ImplItems).make_impl_items()\n             }\n-            _ => noop_flat_map_impl_item(item, self),\n+            _ => noop_flat_map_assoc_item(item, self),\n         }\n     }\n "}, {"sha": "22e99baae5be0e9289e260cdaabd9fef7ae3adfd", "filename": "src/libsyntax_expand/placeholders.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibsyntax_expand%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibsyntax_expand%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fplaceholders.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -50,14 +50,15 @@ pub fn placeholder(kind: AstFragmentKind, id: ast::NodeId, vis: Option<ast::Visi\n             kind: ast::ItemKind::Mac(mac_placeholder()),\n             tokens: None,\n         })]),\n-        AstFragmentKind::TraitItems => AstFragment::TraitItems(smallvec![ast::TraitItem {\n+        AstFragmentKind::TraitItems => AstFragment::TraitItems(smallvec![ast::AssocItem {\n             id, span, ident, vis, attrs, generics,\n-            kind: ast::TraitItemKind::Macro(mac_placeholder()),\n+            kind: ast::AssocItemKind::Macro(mac_placeholder()),\n+            defaultness: ast::Defaultness::Final,\n             tokens: None,\n         }]),\n-        AstFragmentKind::ImplItems => AstFragment::ImplItems(smallvec![ast::ImplItem {\n+        AstFragmentKind::ImplItems => AstFragment::ImplItems(smallvec![ast::AssocItem {\n             id, span, ident, vis, attrs, generics,\n-            kind: ast::ImplItemKind::Macro(mac_placeholder()),\n+            kind: ast::AssocItemKind::Macro(mac_placeholder()),\n             defaultness: ast::Defaultness::Final,\n             tokens: None,\n         }]),\n@@ -252,17 +253,17 @@ impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n         noop_flat_map_item(item, self)\n     }\n \n-    fn flat_map_trait_item(&mut self, item: ast::TraitItem) -> SmallVec<[ast::TraitItem; 1]> {\n+    fn flat_map_trait_item(&mut self, item: ast::AssocItem) -> SmallVec<[ast::AssocItem; 1]> {\n         match item.kind {\n-            ast::TraitItemKind::Macro(_) => self.remove(item.id).make_trait_items(),\n-            _ => noop_flat_map_trait_item(item, self),\n+            ast::AssocItemKind::Macro(_) => self.remove(item.id).make_trait_items(),\n+            _ => noop_flat_map_assoc_item(item, self),\n         }\n     }\n \n-    fn flat_map_impl_item(&mut self, item: ast::ImplItem) -> SmallVec<[ast::ImplItem; 1]> {\n+    fn flat_map_impl_item(&mut self, item: ast::AssocItem) -> SmallVec<[ast::AssocItem; 1]> {\n         match item.kind {\n-            ast::ImplItemKind::Macro(_) => self.remove(item.id).make_impl_items(),\n-            _ => noop_flat_map_impl_item(item, self),\n+            ast::AssocItemKind::Macro(_) => self.remove(item.id).make_impl_items(),\n+            _ => noop_flat_map_assoc_item(item, self),\n         }\n     }\n "}, {"sha": "b7707bfb8e5fbd95f6f536ecf56811e54c708ac3", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -504,22 +504,24 @@ impl<'a> TraitDef<'a> {\n                            type_ident: Ident,\n                            generics: &Generics,\n                            field_tys: Vec<P<ast::Ty>>,\n-                           methods: Vec<ast::ImplItem>)\n+                           methods: Vec<ast::AssocItem>)\n                            -> P<ast::Item> {\n         let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n \n-        // Transform associated types from `deriving::ty::Ty` into `ast::ImplItem`\n+        // Transform associated types from `deriving::ty::Ty` into `ast::AssocItem`\n         let associated_types = self.associated_types.iter().map(|&(ident, ref type_def)| {\n-            ast::ImplItem {\n+            ast::AssocItem {\n                 id: ast::DUMMY_NODE_ID,\n                 span: self.span,\n                 ident,\n                 vis: respan(self.span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n                 defaultness: ast::Defaultness::Final,\n                 attrs: Vec::new(),\n                 generics: Generics::default(),\n-                kind: ast::ImplItemKind::TyAlias(\n-                    type_def.to_ty(cx, self.span, type_ident, generics)),\n+                kind: ast::AssocItemKind::TyAlias(\n+                    Vec::new(),\n+                    Some(type_def.to_ty(cx, self.span, type_ident, generics)),\n+                ),\n                 tokens: None,\n             }\n         });\n@@ -910,7 +912,7 @@ impl<'a> MethodDef<'a> {\n                      explicit_self: Option<ast::ExplicitSelf>,\n                      arg_types: Vec<(Ident, P<ast::Ty>)>,\n                      body: P<Expr>)\n-                     -> ast::ImplItem {\n+                     -> ast::AssocItem {\n         // Create the generics that aren't for `Self`.\n         let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n \n@@ -948,15 +950,15 @@ impl<'a> MethodDef<'a> {\n         };\n \n         // Create the method.\n-        ast::ImplItem {\n+        ast::AssocItem {\n             id: ast::DUMMY_NODE_ID,\n             attrs: self.attributes.clone(),\n             generics: fn_generics,\n             span: trait_.span,\n             vis: respan(trait_lo_sp, ast::VisibilityKind::Inherited),\n             defaultness: ast::Defaultness::Final,\n             ident: method_ident,\n-            kind: ast::ImplItemKind::Method(sig, body_block),\n+            kind: ast::AssocItemKind::Fn(sig, Some(body_block)),\n             tokens: None,\n         }\n     }"}, {"sha": "7af38c88f4334c6eb4c2f22f774bf5fbdbaf0d64", "filename": "src/test/ui/c-variadic/variadic-ffi-no-fixed-args.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-no-fixed-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-no-fixed-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-no-fixed-args.stderr?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -1,8 +1,8 @@\n error: C-variadic function must be declared with at least one named argument\n-  --> $DIR/variadic-ffi-no-fixed-args.rs:2:11\n+  --> $DIR/variadic-ffi-no-fixed-args.rs:2:12\n    |\n LL |     fn foo(...);\n-   |           ^\n+   |            ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "ea21592997bfeed95d67a69a5ac36ac2ebc4a481", "filename": "src/test/ui/did_you_mean/issue-40006.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -18,10 +18,10 @@ trait A { //~ ERROR missing\n trait B {\n     fn xxx() { ### } //~ ERROR expected\n }\n-trait C { //~ ERROR missing `fn`, `type`, or `const` for trait-item declaration\n+trait C { //~ ERROR missing `fn`, `type`, or `const` for associated-item declaration\n     L = M;\n }\n-trait D { //~ ERROR missing `fn`, `type`, or `const` for trait-item declaration\n+trait D { //~ ERROR missing `fn`, `type`, or `const` for associated-item declaration\n     Z = { 2 + 3 };\n }\n trait E {"}, {"sha": "d1e995013cb93708fdf345f1c18a5c08fe6f458a", "filename": "src/test/ui/did_you_mean/issue-40006.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40006.stderr?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -1,20 +1,20 @@\n-error: missing `fn`, `type`, or `const` for impl-item declaration\n+error: missing `fn`, `type`, or `const` for associated-item declaration\n   --> $DIR/issue-40006.rs:1:13\n    |\n LL |   impl dyn A {\n    |  _____________^\n LL | |     Y\n    | |____^ missing `fn`, `type`, or `const`\n \n-error: missing `fn`, `type`, or `const` for trait-item declaration\n+error: missing `fn`, `type`, or `const` for associated-item declaration\n   --> $DIR/issue-40006.rs:7:10\n    |\n LL |   trait X {\n    |  __________^\n LL | |     X() {}\n    | |____^ missing `fn`, `type`, or `const`\n \n-error: missing `fn`, `type`, or `const` for trait-item declaration\n+error: missing `fn`, `type`, or `const` for associated-item declaration\n   --> $DIR/issue-40006.rs:15:10\n    |\n LL |   trait A {\n@@ -28,15 +28,15 @@ error: expected `[`, found `#`\n LL |     fn xxx() { ### }\n    |                 ^ expected `[`\n \n-error: missing `fn`, `type`, or `const` for trait-item declaration\n+error: missing `fn`, `type`, or `const` for associated-item declaration\n   --> $DIR/issue-40006.rs:21:10\n    |\n LL |   trait C {\n    |  __________^\n LL | |     L = M;\n    | |____^ missing `fn`, `type`, or `const`\n \n-error: missing `fn`, `type`, or `const` for trait-item declaration\n+error: missing `fn`, `type`, or `const` for associated-item declaration\n   --> $DIR/issue-40006.rs:24:10\n    |\n LL |   trait D {\n@@ -50,7 +50,7 @@ error: expected one of `!` or `::`, found `(`\n LL |     ::Y ();\n    |         ^ expected one of `!` or `::`\n \n-error: missing `fn`, `type`, or `const` for impl-item declaration\n+error: missing `fn`, `type`, or `const` for associated-item declaration\n   --> $DIR/issue-40006.rs:32:8\n    |\n LL |     pub hello_method(&self) {"}, {"sha": "1f61473c9d2f49a90a4ca6cb26da85c05883baba", "filename": "src/test/ui/feature-gates/feature-gate-type_alias_impl_trait.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_impl_trait.stderr?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -16,15 +16,6 @@ LL |     type Baa = impl Debug;\n    = note: for more information, see https://github.com/rust-lang/rust/issues/63063\n    = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n \n-error[E0658]: `impl Trait` in type aliases is unstable\n-  --> $DIR/feature-gate-type_alias_impl_trait.rs:18:18\n-   |\n-LL |     type Assoc = impl Debug;\n-   |                  ^^^^^^^^^^\n-   |\n-   = note: for more information, see https://github.com/rust-lang/rust/issues/63063\n-   = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n-\n error[E0658]: associated type defaults are unstable\n   --> $DIR/feature-gate-type_alias_impl_trait.rs:18:5\n    |\n@@ -34,6 +25,15 @@ LL |     type Assoc = impl Debug;\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29661\n    = help: add `#![feature(associated_type_defaults)]` to the crate attributes to enable\n \n+error[E0658]: `impl Trait` in type aliases is unstable\n+  --> $DIR/feature-gate-type_alias_impl_trait.rs:18:18\n+   |\n+LL |     type Assoc = impl Debug;\n+   |                  ^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/63063\n+   = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n+\n error[E0658]: `impl Trait` in type aliases is unstable\n   --> $DIR/feature-gate-type_alias_impl_trait.rs:24:24\n    |"}, {"sha": "8d23f0e477077676cb2e2b4773f8d8a98bc5d22a", "filename": "src/test/ui/invalid/invalid-variadic-function.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba1a4882514c3262caff38deabc30b669c709b95/src%2Ftest%2Fui%2Finvalid%2Finvalid-variadic-function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1a4882514c3262caff38deabc30b669c709b95/src%2Ftest%2Fui%2Finvalid%2Finvalid-variadic-function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid%2Finvalid-variadic-function.rs?ref=ba1a4882514c3262caff38deabc30b669c709b95", "patch": "@@ -1,3 +0,0 @@\n-extern \"C\" fn foo(x: u8, ...);\n-//~^ ERROR only foreign functions are allowed to be C-variadic\n-//~| ERROR expected one of `->`, `where`, or `{`, found `;`"}, {"sha": "7e58b17e7db749af5fc0eec1b217c73ce011a89d", "filename": "src/test/ui/invalid/invalid-variadic-function.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ba1a4882514c3262caff38deabc30b669c709b95/src%2Ftest%2Fui%2Finvalid%2Finvalid-variadic-function.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ba1a4882514c3262caff38deabc30b669c709b95/src%2Ftest%2Fui%2Finvalid%2Finvalid-variadic-function.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid%2Finvalid-variadic-function.stderr?ref=ba1a4882514c3262caff38deabc30b669c709b95", "patch": "@@ -1,15 +0,0 @@\n-error[E0743]: only foreign functions are allowed to be C-variadic\n-  --> $DIR/invalid-variadic-function.rs:1:26\n-   |\n-LL | extern \"C\" fn foo(x: u8, ...);\n-   |                          ^^^\n-\n-error: expected one of `->`, `where`, or `{`, found `;`\n-  --> $DIR/invalid-variadic-function.rs:1:30\n-   |\n-LL | extern \"C\" fn foo(x: u8, ...);\n-   |                              ^ expected one of `->`, `where`, or `{`\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0743`."}, {"sha": "8b1a39a94e67af4a3220c266066a2da857e5b14d", "filename": "src/test/ui/issues/issue-58856-1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fissues%2Fissue-58856-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fissues%2Fissue-58856-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58856-1.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -1,6 +1,8 @@\n impl A {\n+    //~^ ERROR cannot find type `A` in this scope\n     fn b(self>\n     //~^ ERROR expected one of `)`, `,`, or `:`, found `>`\n+    //~| ERROR expected `;` or `{`, found `>`\n }\n \n fn main() {}"}, {"sha": "0ea6b0175489045258f49d2446a5a4b1bf85de9c", "filename": "src/test/ui/issues/issue-58856-1.stderr", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fissues%2Fissue-58856-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fissues%2Fissue-58856-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-58856-1.stderr?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -1,10 +1,23 @@\n error: expected one of `)`, `,`, or `:`, found `>`\n-  --> $DIR/issue-58856-1.rs:2:14\n+  --> $DIR/issue-58856-1.rs:3:14\n    |\n LL |     fn b(self>\n    |         -    ^ help: `)` may belong here\n    |         |\n    |         unclosed delimiter\n \n-error: aborting due to previous error\n+error: expected `;` or `{`, found `>`\n+  --> $DIR/issue-58856-1.rs:3:14\n+   |\n+LL |     fn b(self>\n+   |              ^ expected `;` or `{`\n+\n+error[E0412]: cannot find type `A` in this scope\n+  --> $DIR/issue-58856-1.rs:1:6\n+   |\n+LL | impl A {\n+   |      ^ not found in this scope\n+\n+error: aborting due to 3 previous errors\n \n+For more information about this error, try `rustc --explain E0412`."}, {"sha": "e8ef981f515fc669305ba0d3d778a3bc972556c4", "filename": "src/test/ui/issues/issue-60075.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fissues%2Fissue-60075.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fissues%2Fissue-60075.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60075.stderr?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -4,7 +4,7 @@ error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n LL |         });\n    |          ^ expected one of `.`, `;`, `?`, `else`, or an operator\n \n-error: expected one of `async`, `const`, `crate`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found `;`\n+error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found `;`\n   --> $DIR/issue-60075.rs:6:11\n    |\n LL |     fn qux() -> Option<usize> {"}, {"sha": "d1124561374a52b565c66b97d91139e04bdfa98f", "filename": "src/test/ui/parser/impl-item-const-pass.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fimpl-item-const-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fimpl-item-const-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fimpl-item-const-pass.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -0,0 +1,8 @@\n+// check-pass\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+impl X {\n+    const Y: u8;\n+}"}, {"sha": "5d4692f9f14acdcce4fdafffc9ae163cfa3ae839", "filename": "src/test/ui/parser/impl-item-const-semantic-fail.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fimpl-item-const-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fimpl-item-const-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fimpl-item-const-semantic-fail.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -0,0 +1,7 @@\n+fn main() {}\n+\n+struct X;\n+\n+impl X {\n+    const Y: u8; //~ ERROR associated constant in `impl` without body\n+}"}, {"sha": "ec3bee0ce682485c23d66e4a56136a8ae57f8926", "filename": "src/test/ui/parser/impl-item-const-semantic-fail.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fimpl-item-const-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fimpl-item-const-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fimpl-item-const-semantic-fail.stderr?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -0,0 +1,10 @@\n+error: associated constant in `impl` without body\n+  --> $DIR/impl-item-const-semantic-fail.rs:6:5\n+   |\n+LL |     const Y: u8;\n+   |     ^^^^^^^^^^^-\n+   |                |\n+   |                help: provide a definition for the constant: `= <expr>;`\n+\n+error: aborting due to previous error\n+"}, {"sha": "16b09d64e8c1786c96500da3c83512eb42fc9321", "filename": "src/test/ui/parser/impl-item-fn-no-body-pass.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fimpl-item-fn-no-body-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fimpl-item-fn-no-body-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fimpl-item-fn-no-body-pass.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -0,0 +1,8 @@\n+// check-pass\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+impl X {\n+    fn f();\n+}"}, {"sha": "cb183db59643e454d136b6458b6a46fcab14b25b", "filename": "src/test/ui/parser/impl-item-fn-no-body-semantic-fail.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fimpl-item-fn-no-body-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fimpl-item-fn-no-body-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fimpl-item-fn-no-body-semantic-fail.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -0,0 +1,7 @@\n+fn main() {}\n+\n+struct X;\n+\n+impl X {\n+    fn f(); //~ ERROR associated function in `impl` without body\n+}"}, {"sha": "1acb727368bce2513b836228dd9f953d62dd47ba", "filename": "src/test/ui/parser/impl-item-fn-no-body-semantic-fail.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fimpl-item-fn-no-body-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fimpl-item-fn-no-body-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fimpl-item-fn-no-body-semantic-fail.stderr?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -0,0 +1,10 @@\n+error: associated function in `impl` without body\n+  --> $DIR/impl-item-fn-no-body-semantic-fail.rs:6:5\n+   |\n+LL |     fn f();\n+   |     ^^^^^^-\n+   |           |\n+   |           help: provide a definition for the function: `{ <body> }`\n+\n+error: aborting due to previous error\n+"}, {"sha": "74a9c6ab7e8a63c38255ac17ffa35d4f7e20ebba", "filename": "src/test/ui/parser/impl-item-type-no-body-pass.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fimpl-item-type-no-body-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fimpl-item-type-no-body-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fimpl-item-type-no-body-pass.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+impl X {\n+    type Y;\n+    type Z: Ord;\n+    type W: Ord where Self: Eq;\n+    type W where Self: Eq;\n+}"}, {"sha": "71c7d4ba21db62573f5b93d60a7a7a910fee9ded", "filename": "src/test/ui/parser/impl-item-type-no-body-semantic-fail.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fimpl-item-type-no-body-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fimpl-item-type-no-body-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fimpl-item-type-no-body-semantic-fail.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -0,0 +1,22 @@\n+#![feature(generic_associated_types)]\n+//~^ WARN the feature `generic_associated_types` is incomplete\n+\n+fn main() {}\n+\n+struct X;\n+\n+impl X {\n+    type Y;\n+    //~^ ERROR associated type in `impl` without body\n+    //~| ERROR associated types are not yet supported in inherent impls\n+    type Z: Ord;\n+    //~^ ERROR associated type in `impl` without body\n+    //~| ERROR bounds on associated `type`s in `impl`s have no effect\n+    //~| ERROR associated types are not yet supported in inherent impls\n+    type W: Ord where Self: Eq;\n+    //~^ ERROR associated type in `impl` without body\n+    //~| ERROR bounds on associated `type`s in `impl`s have no effect\n+    //~| ERROR associated types are not yet supported in inherent impls\n+    type W where Self: Eq;\n+    //~^ ERROR associated type in `impl` without body\n+}"}, {"sha": "6f1439c8f0b293bceb69c6c4a432d2e9d3305a7b", "filename": "src/test/ui/parser/impl-item-type-no-body-semantic-fail.stderr", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fimpl-item-type-no-body-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fimpl-item-type-no-body-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fimpl-item-type-no-body-semantic-fail.stderr?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -0,0 +1,73 @@\n+error: associated type in `impl` without body\n+  --> $DIR/impl-item-type-no-body-semantic-fail.rs:9:5\n+   |\n+LL |     type Y;\n+   |     ^^^^^^-\n+   |           |\n+   |           help: provide a definition for the type: `= <type>;`\n+\n+error: associated type in `impl` without body\n+  --> $DIR/impl-item-type-no-body-semantic-fail.rs:12:5\n+   |\n+LL |     type Z: Ord;\n+   |     ^^^^^^^^^^^-\n+   |                |\n+   |                help: provide a definition for the type: `= <type>;`\n+\n+error: bounds on associated `type`s in `impl`s have no effect\n+  --> $DIR/impl-item-type-no-body-semantic-fail.rs:12:13\n+   |\n+LL |     type Z: Ord;\n+   |             ^^^\n+\n+error: associated type in `impl` without body\n+  --> $DIR/impl-item-type-no-body-semantic-fail.rs:16:5\n+   |\n+LL |     type W: Ord where Self: Eq;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^-\n+   |                               |\n+   |                               help: provide a definition for the type: `= <type>;`\n+\n+error: bounds on associated `type`s in `impl`s have no effect\n+  --> $DIR/impl-item-type-no-body-semantic-fail.rs:16:13\n+   |\n+LL |     type W: Ord where Self: Eq;\n+   |             ^^^\n+\n+error: associated type in `impl` without body\n+  --> $DIR/impl-item-type-no-body-semantic-fail.rs:20:5\n+   |\n+LL |     type W where Self: Eq;\n+   |     ^^^^^^^^^^^^^^^^^^^^^-\n+   |                          |\n+   |                          help: provide a definition for the type: `= <type>;`\n+\n+warning: the feature `generic_associated_types` is incomplete and may cause the compiler to crash\n+  --> $DIR/impl-item-type-no-body-semantic-fail.rs:1:12\n+   |\n+LL | #![feature(generic_associated_types)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0202]: associated types are not yet supported in inherent impls (see #8995)\n+  --> $DIR/impl-item-type-no-body-semantic-fail.rs:9:5\n+   |\n+LL |     type Y;\n+   |     ^^^^^^^\n+\n+error[E0202]: associated types are not yet supported in inherent impls (see #8995)\n+  --> $DIR/impl-item-type-no-body-semantic-fail.rs:12:5\n+   |\n+LL |     type Z: Ord;\n+   |     ^^^^^^^^^^^^\n+\n+error[E0202]: associated types are not yet supported in inherent impls (see #8995)\n+  --> $DIR/impl-item-type-no-body-semantic-fail.rs:16:5\n+   |\n+LL |     type W: Ord where Self: Eq;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 9 previous errors\n+\n+For more information about this error, try `rustc --explain E0202`."}, {"sha": "6e20a9ce3c432758dce2169fae1565662c1de912", "filename": "src/test/ui/parser/issue-21153.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fissue-21153.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fissue-21153.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-21153.stderr?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -1,4 +1,4 @@\n-error: missing `fn`, `type`, or `const` for trait-item declaration\n+error: missing `fn`, `type`, or `const` for associated-item declaration\n   --> $DIR/issue-21153.rs:1:29\n    |\n LL |   trait MyTrait<T>: Iterator {"}, {"sha": "1a97f54160b24bfed843ac35de5402f6d66965eb", "filename": "src/test/ui/parser/issue-32446.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fissue-32446.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fissue-32446.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-32446.stderr?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `async`, `const`, `crate`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found `...`\n+error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, `unsafe`, or `}`, found `...`\n   --> $DIR/issue-32446.rs:4:11\n    |\n LL | trait T { ... }\n-   |           ^^^ expected one of 9 possible tokens\n+   |           ^^^ expected one of 10 possible tokens\n \n error: aborting due to previous error\n "}, {"sha": "7647ba500e03a9e99d345d14f38f6a0006c9aa90", "filename": "src/test/ui/parser/macro/trait-non-item-macros.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-non-item-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-non-item-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Ftrait-non-item-macros.stderr?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -1,8 +1,8 @@\n-error: expected one of `async`, `const`, `crate`, `extern`, `fn`, `pub`, `type`, or `unsafe`, found `2`\n+error: expected one of `async`, `const`, `crate`, `default`, `extern`, `fn`, `pub`, `type`, or `unsafe`, found `2`\n   --> $DIR/trait-non-item-macros.rs:2:19\n    |\n LL |     ($a:expr) => ($a)\n-   |                   ^^ expected one of 8 possible tokens\n+   |                   ^^ expected one of 9 possible tokens\n ...\n LL |     bah!(2);\n    |     -------- in this macro invocation"}, {"sha": "7e8abf22d55ab4b535950c88ea83ef9ba0cb6557", "filename": "src/test/ui/parser/mismatched-braces/missing-close-brace-in-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmismatched-braces%2Fmissing-close-brace-in-trait.stderr?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -7,11 +7,11 @@ LL | trait T {\n LL | fn main() {}\n    |                                                                  ^\n \n-error: expected one of `async`, `const`, `extern`, `fn`, `type`, or `unsafe`, found keyword `struct`\n+error: expected one of `async`, `const`, `default`, `extern`, `fn`, `type`, or `unsafe`, found keyword `struct`\n   --> $DIR/missing-close-brace-in-trait.rs:5:12\n    |\n LL | pub(crate) struct Bar<T>();\n-   |            ^^^^^^ expected one of `async`, `const`, `extern`, `fn`, `type`, or `unsafe`\n+   |            ^^^^^^ expected one of 7 possible tokens\n \n error[E0601]: `main` function not found in crate `missing_close_brace_in_trait`\n   --> $DIR/missing-close-brace-in-trait.rs:1:1"}, {"sha": "09f967f161ede7b2ee5cad3375d6959085292fa5", "filename": "src/test/ui/parser/trait-item-with-defaultness-fail-semantic.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Ftrait-item-with-defaultness-fail-semantic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Ftrait-item-with-defaultness-fail-semantic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ftrait-item-with-defaultness-fail-semantic.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -0,0 +1,12 @@\n+#![feature(specialization)]\n+\n+fn main() {}\n+\n+trait X {\n+    default const A: u8; //~ ERROR `default` is only allowed on items in `impl` definitions\n+    default const B: u8 = 0;  //~ ERROR `default` is only allowed on items in `impl` definitions\n+    default type D; //~ ERROR `default` is only allowed on items in `impl` definitions\n+    default type C: Ord; //~ ERROR `default` is only allowed on items in `impl` definitions\n+    default fn f1(); //~ ERROR `default` is only allowed on items in `impl` definitions\n+    default fn f2() {} //~ ERROR `default` is only allowed on items in `impl` definitions\n+}"}, {"sha": "54111df342343751c8c303186bd4be5b9b066c2b", "filename": "src/test/ui/parser/trait-item-with-defaultness-fail-semantic.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Ftrait-item-with-defaultness-fail-semantic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Ftrait-item-with-defaultness-fail-semantic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ftrait-item-with-defaultness-fail-semantic.stderr?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -0,0 +1,38 @@\n+error: `default` is only allowed on items in `impl` definitions\n+  --> $DIR/trait-item-with-defaultness-fail-semantic.rs:6:5\n+   |\n+LL |     default const A: u8;\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: `default` is only allowed on items in `impl` definitions\n+  --> $DIR/trait-item-with-defaultness-fail-semantic.rs:7:5\n+   |\n+LL |     default const B: u8 = 0;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `default` is only allowed on items in `impl` definitions\n+  --> $DIR/trait-item-with-defaultness-fail-semantic.rs:8:5\n+   |\n+LL |     default type D;\n+   |     ^^^^^^^^^^^^^^^\n+\n+error: `default` is only allowed on items in `impl` definitions\n+  --> $DIR/trait-item-with-defaultness-fail-semantic.rs:9:5\n+   |\n+LL |     default type C: Ord;\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: `default` is only allowed on items in `impl` definitions\n+  --> $DIR/trait-item-with-defaultness-fail-semantic.rs:10:5\n+   |\n+LL |     default fn f1();\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: `default` is only allowed on items in `impl` definitions\n+  --> $DIR/trait-item-with-defaultness-fail-semantic.rs:11:5\n+   |\n+LL |     default fn f2() {}\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "a6318bd99e2f6810fd34bd13ca72557239f12dec", "filename": "src/test/ui/parser/trait-item-with-defaultness-pass.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Ftrait-item-with-defaultness-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Ftrait-item-with-defaultness-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ftrait-item-with-defaultness-pass.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+trait X {\n+    default const A: u8;\n+    default const B: u8 = 0;\n+    default type D;\n+    default type C: Ord;\n+    default fn f1();\n+    default fn f2() {}\n+}"}, {"sha": "ce83cc87abe00f937b45e97d4d4c60a6a29a62d3", "filename": "src/test/ui/parser/variadic-ffi-3.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ba1a4882514c3262caff38deabc30b669c709b95/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1a4882514c3262caff38deabc30b669c709b95/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-3.rs?ref=ba1a4882514c3262caff38deabc30b669c709b95", "patch": "@@ -1,5 +0,0 @@\n-fn foo(x: isize, ...) {\n-    //~^ ERROR: only foreign functions are allowed to be C-variadic\n-}\n-\n-fn main() {}"}, {"sha": "aeeebdb991483ddcb68249df2f32ee1317431b39", "filename": "src/test/ui/parser/variadic-ffi-3.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ba1a4882514c3262caff38deabc30b669c709b95/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ba1a4882514c3262caff38deabc30b669c709b95/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-3.stderr?ref=ba1a4882514c3262caff38deabc30b669c709b95", "patch": "@@ -1,9 +0,0 @@\n-error[E0743]: only foreign functions are allowed to be C-variadic\n-  --> $DIR/variadic-ffi-3.rs:1:18\n-   |\n-LL | fn foo(x: isize, ...) {\n-   |                  ^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0743`."}, {"sha": "5f8b3f8f539b8df463f457d8ae7ac8724bdc84ed", "filename": "src/test/ui/parser/variadic-ffi-4.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ba1a4882514c3262caff38deabc30b669c709b95/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba1a4882514c3262caff38deabc30b669c709b95/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-4.rs?ref=ba1a4882514c3262caff38deabc30b669c709b95", "patch": "@@ -1,5 +0,0 @@\n-extern \"C\" fn foo(x: isize, ...) {\n-    //~^ ERROR: only foreign functions are allowed to be C-variadic\n-}\n-\n-fn main() {}"}, {"sha": "da83276c72dd109f682c5224a20a23e5e64754d9", "filename": "src/test/ui/parser/variadic-ffi-4.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ba1a4882514c3262caff38deabc30b669c709b95/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ba1a4882514c3262caff38deabc30b669c709b95/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-4.stderr?ref=ba1a4882514c3262caff38deabc30b669c709b95", "patch": "@@ -1,9 +0,0 @@\n-error[E0743]: only foreign functions are allowed to be C-variadic\n-  --> $DIR/variadic-ffi-4.rs:1:29\n-   |\n-LL | extern \"C\" fn foo(x: isize, ...) {\n-   |                             ^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0743`."}, {"sha": "9eeee195e56e437e10be0d5b3b25e52fd6a4b8bb", "filename": "src/test/ui/parser/variadic-ffi-nested-syntactic-fail.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-nested-syntactic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-nested-syntactic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-nested-syntactic-fail.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -0,0 +1,9 @@\n+fn f1<'a>(x: u8, y: &'a ...) {}\n+//~^ ERROR C-variadic type `...` may not be nested inside another type\n+\n+fn f2<'a>(x: u8, y: Vec<&'a ...>) {}\n+//~^ ERROR C-variadic type `...` may not be nested inside another type\n+\n+fn main() {\n+    let _recovery_witness: () = 0; //~ ERROR mismatched types\n+}"}, {"sha": "8b9d676a45daed79305de7cf3961562c810cc44d", "filename": "src/test/ui/parser/variadic-ffi-nested-syntactic-fail.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-nested-syntactic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-nested-syntactic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-nested-syntactic-fail.stderr?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -0,0 +1,24 @@\n+error[E0743]: C-variadic type `...` may not be nested inside another type\n+  --> $DIR/variadic-ffi-nested-syntactic-fail.rs:1:25\n+   |\n+LL | fn f1<'a>(x: u8, y: &'a ...) {}\n+   |                         ^^^\n+\n+error[E0743]: C-variadic type `...` may not be nested inside another type\n+  --> $DIR/variadic-ffi-nested-syntactic-fail.rs:4:29\n+   |\n+LL | fn f2<'a>(x: u8, y: Vec<&'a ...>) {}\n+   |                             ^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/variadic-ffi-nested-syntactic-fail.rs:8:33\n+   |\n+LL |     let _recovery_witness: () = 0;\n+   |                            --   ^ expected `()`, found integer\n+   |                            |\n+   |                            expected due to this\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0308, E0743.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "aa85f6d6b522b25566f6c152d48b062ad210e54f", "filename": "src/test/ui/parser/variadic-ffi-semantic-restrictions.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-semantic-restrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-semantic-restrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-semantic-restrictions.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -0,0 +1,76 @@\n+#![feature(c_variadic)]\n+\n+fn main() {}\n+\n+fn f1_1(x: isize, ...) {}\n+//~^ ERROR only foreign or `unsafe extern \"C\" functions may be C-variadic\n+\n+fn f1_2(...) {}\n+//~^ ERROR only foreign or `unsafe extern \"C\" functions may be C-variadic\n+//~| ERROR C-variadic function must be declared with at least one named argument\n+\n+extern \"C\" fn f2_1(x: isize, ...) {}\n+//~^ ERROR only foreign or `unsafe extern \"C\" functions may be C-variadic\n+\n+extern \"C\" fn f2_2(...) {}\n+//~^ ERROR only foreign or `unsafe extern \"C\" functions may be C-variadic\n+//~| ERROR C-variadic function must be declared with at least one named argument\n+\n+extern \"C\" fn f2_3(..., x: isize) {}\n+//~^ ERROR only foreign or `unsafe extern \"C\" functions may be C-variadic\n+//~| ERROR `...` must be the last argument of a C-variadic function\n+\n+extern fn f3_1(x: isize, ...) {}\n+//~^ ERROR only foreign or `unsafe extern \"C\" functions may be C-variadic\n+\n+extern fn f3_2(...) {}\n+//~^ ERROR only foreign or `unsafe extern \"C\" functions may be C-variadic\n+//~| ERROR C-variadic function must be declared with at least one named argument\n+\n+extern fn f3_3(..., x: isize) {}\n+//~^ ERROR only foreign or `unsafe extern \"C\" functions may be C-variadic\n+//~| ERROR `...` must be the last argument of a C-variadic function\n+\n+extern {\n+    fn e_f1(...);\n+    //~^ ERROR C-variadic function must be declared with at least one named argument\n+    fn e_f2(..., x: isize);\n+    //~^ ERROR `...` must be the last argument of a C-variadic function\n+}\n+\n+struct X;\n+\n+impl X {\n+    fn i_f1(x: isize, ...) {}\n+    //~^ ERROR only foreign or `unsafe extern \"C\" functions may be C-variadic\n+    fn i_f2(...) {}\n+    //~^ ERROR only foreign or `unsafe extern \"C\" functions may be C-variadic\n+    //~| ERROR C-variadic function must be declared with at least one named argument\n+    fn i_f3(..., x: isize, ...) {}\n+    //~^ ERROR only foreign or `unsafe extern \"C\" functions may be C-variadic\n+    //~| ERROR only foreign or `unsafe extern \"C\" functions may be C-variadic\n+    //~| ERROR `...` must be the last argument of a C-variadic function\n+    fn i_f4(..., x: isize, ...) {}\n+    //~^ ERROR only foreign or `unsafe extern \"C\" functions may be C-variadic\n+    //~| ERROR only foreign or `unsafe extern \"C\" functions may be C-variadic\n+    //~| ERROR `...` must be the last argument of a C-variadic function\n+}\n+\n+trait T {\n+    fn t_f1(x: isize, ...) {}\n+    //~^ ERROR only foreign or `unsafe extern \"C\" functions may be C-variadic\n+    fn t_f2(x: isize, ...);\n+    //~^ ERROR only foreign or `unsafe extern \"C\" functions may be C-variadic\n+    fn t_f3(...) {}\n+    //~^ ERROR only foreign or `unsafe extern \"C\" functions may be C-variadic\n+    //~| ERROR C-variadic function must be declared with at least one named argument\n+    fn t_f4(...);\n+    //~^ ERROR only foreign or `unsafe extern \"C\" functions may be C-variadic\n+    //~| ERROR C-variadic function must be declared with at least one named argument\n+    fn t_f5(..., x: isize) {}\n+    //~^ ERROR only foreign or `unsafe extern \"C\" functions may be C-variadic\n+    //~| ERROR `...` must be the last argument of a C-variadic function\n+    fn t_f6(..., x: isize);\n+    //~^ ERROR only foreign or `unsafe extern \"C\" functions may be C-variadic\n+    //~| ERROR `...` must be the last argument of a C-variadic function\n+}"}, {"sha": "21992a29670c9bcfd33b2950f471ded48e26d0aa", "filename": "src/test/ui/parser/variadic-ffi-semantic-restrictions.stderr", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-semantic-restrictions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-semantic-restrictions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-semantic-restrictions.stderr?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -0,0 +1,206 @@\n+error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:5:19\n+   |\n+LL | fn f1_1(x: isize, ...) {}\n+   |                   ^^^^\n+\n+error: C-variadic function must be declared with at least one named argument\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:8:9\n+   |\n+LL | fn f1_2(...) {}\n+   |         ^^^^\n+\n+error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:8:9\n+   |\n+LL | fn f1_2(...) {}\n+   |         ^^^^\n+\n+error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:12:30\n+   |\n+LL | extern \"C\" fn f2_1(x: isize, ...) {}\n+   |                              ^^^^\n+\n+error: C-variadic function must be declared with at least one named argument\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:15:20\n+   |\n+LL | extern \"C\" fn f2_2(...) {}\n+   |                    ^^^^\n+\n+error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:15:20\n+   |\n+LL | extern \"C\" fn f2_2(...) {}\n+   |                    ^^^^\n+\n+error: `...` must be the last argument of a C-variadic function\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:19:20\n+   |\n+LL | extern \"C\" fn f2_3(..., x: isize) {}\n+   |                    ^^^^\n+\n+error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:19:20\n+   |\n+LL | extern \"C\" fn f2_3(..., x: isize) {}\n+   |                    ^^^^\n+\n+error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:23:26\n+   |\n+LL | extern fn f3_1(x: isize, ...) {}\n+   |                          ^^^^\n+\n+error: C-variadic function must be declared with at least one named argument\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:26:16\n+   |\n+LL | extern fn f3_2(...) {}\n+   |                ^^^^\n+\n+error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:26:16\n+   |\n+LL | extern fn f3_2(...) {}\n+   |                ^^^^\n+\n+error: `...` must be the last argument of a C-variadic function\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:30:16\n+   |\n+LL | extern fn f3_3(..., x: isize) {}\n+   |                ^^^^\n+\n+error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:30:16\n+   |\n+LL | extern fn f3_3(..., x: isize) {}\n+   |                ^^^^\n+\n+error: C-variadic function must be declared with at least one named argument\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:35:13\n+   |\n+LL |     fn e_f1(...);\n+   |             ^^^^\n+\n+error: `...` must be the last argument of a C-variadic function\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:37:13\n+   |\n+LL |     fn e_f2(..., x: isize);\n+   |             ^^^^\n+\n+error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:44:23\n+   |\n+LL |     fn i_f1(x: isize, ...) {}\n+   |                       ^^^^\n+\n+error: C-variadic function must be declared with at least one named argument\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:46:13\n+   |\n+LL |     fn i_f2(...) {}\n+   |             ^^^^\n+\n+error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:46:13\n+   |\n+LL |     fn i_f2(...) {}\n+   |             ^^^^\n+\n+error: `...` must be the last argument of a C-variadic function\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:49:13\n+   |\n+LL |     fn i_f3(..., x: isize, ...) {}\n+   |             ^^^^\n+\n+error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:49:13\n+   |\n+LL |     fn i_f3(..., x: isize, ...) {}\n+   |             ^^^^\n+\n+error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:49:28\n+   |\n+LL |     fn i_f3(..., x: isize, ...) {}\n+   |                            ^^^^\n+\n+error: `...` must be the last argument of a C-variadic function\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:53:13\n+   |\n+LL |     fn i_f4(..., x: isize, ...) {}\n+   |             ^^^^\n+\n+error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:53:13\n+   |\n+LL |     fn i_f4(..., x: isize, ...) {}\n+   |             ^^^^\n+\n+error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:53:28\n+   |\n+LL |     fn i_f4(..., x: isize, ...) {}\n+   |                            ^^^^\n+\n+error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:60:23\n+   |\n+LL |     fn t_f1(x: isize, ...) {}\n+   |                       ^^^^\n+\n+error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:62:23\n+   |\n+LL |     fn t_f2(x: isize, ...);\n+   |                       ^^^^\n+\n+error: C-variadic function must be declared with at least one named argument\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:64:13\n+   |\n+LL |     fn t_f3(...) {}\n+   |             ^^^^\n+\n+error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:64:13\n+   |\n+LL |     fn t_f3(...) {}\n+   |             ^^^^\n+\n+error: C-variadic function must be declared with at least one named argument\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:67:13\n+   |\n+LL |     fn t_f4(...);\n+   |             ^^^^\n+\n+error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:67:13\n+   |\n+LL |     fn t_f4(...);\n+   |             ^^^^\n+\n+error: `...` must be the last argument of a C-variadic function\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:70:13\n+   |\n+LL |     fn t_f5(..., x: isize) {}\n+   |             ^^^^\n+\n+error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:70:13\n+   |\n+LL |     fn t_f5(..., x: isize) {}\n+   |             ^^^^\n+\n+error: `...` must be the last argument of a C-variadic function\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:73:13\n+   |\n+LL |     fn t_f6(..., x: isize);\n+   |             ^^^^\n+\n+error: only foreign or `unsafe extern \"C\" functions may be C-variadic\n+  --> $DIR/variadic-ffi-semantic-restrictions.rs:73:13\n+   |\n+LL |     fn t_f6(..., x: isize);\n+   |             ^^^^\n+\n+error: aborting due to 34 previous errors\n+"}, {"sha": "3875d6af1371678549e3410a64b5b2c63df7e9a3", "filename": "src/test/ui/parser/variadic-ffi-syntactic-pass.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec82174fad385882798b6c223dc1b8ac44f58332/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fvariadic-ffi-syntactic-pass.rs?ref=ec82174fad385882798b6c223dc1b8ac44f58332", "patch": "@@ -0,0 +1,53 @@\n+// check-pass\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+fn f1_1(x: isize, ...) {}\n+\n+#[cfg(FALSE)]\n+fn f1_2(...) {}\n+\n+#[cfg(FALSE)]\n+extern \"C\" fn f2_1(x: isize, ...) {}\n+\n+#[cfg(FALSE)]\n+extern \"C\" fn f2_2(...) {}\n+\n+#[cfg(FALSE)]\n+extern \"C\" fn f2_3(..., x: isize) {}\n+\n+#[cfg(FALSE)]\n+extern fn f3_1(x: isize, ...) {}\n+\n+#[cfg(FALSE)]\n+extern fn f3_2(...) {}\n+\n+#[cfg(FALSE)]\n+extern fn f3_3(..., x: isize) {}\n+\n+#[cfg(FALSE)]\n+extern {\n+    fn e_f1(...);\n+    fn e_f2(..., x: isize);\n+}\n+\n+struct X;\n+\n+#[cfg(FALSE)]\n+impl X {\n+    fn i_f1(x: isize, ...) {}\n+    fn i_f2(...) {}\n+    fn i_f3(..., x: isize, ...) {}\n+    fn i_f4(..., x: isize, ...) {}\n+}\n+\n+#[cfg(FALSE)]\n+trait T {\n+    fn t_f1(x: isize, ...) {}\n+    fn t_f2(x: isize, ...);\n+    fn t_f3(...) {}\n+    fn t_f4(...);\n+    fn t_f5(..., x: isize) {}\n+    fn t_f6(..., x: isize);\n+}"}]}