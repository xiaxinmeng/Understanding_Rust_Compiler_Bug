{"sha": "52db6b9d02a22eb1f54ea5f045d3744c98edd50f", "node_id": "C_kwDOAAsO6NoAKDUyZGI2YjlkMDJhMjJlYjFmNTRlYTVmMDQ1ZDM3NDRjOThlZGQ1MGY", "commit": {"author": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2021-10-13T20:37:53Z"}, "committer": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2022-01-07T22:55:36Z"}, "message": "InferBorrowKind cleanup\n\n`adjust_upvar_deref` and friends are implemented so that they reuse\nexisting region so new region vars don't have to be generated.\nSince now we don't have to generate region vars in `InferBorrowKind`,\ncreating a new capture info would be cheap and we can just use\n`determine_capture_info`.\n\nsyn is updated so that let_else syntax can be used in fn with `#[instrument]` attribute.\n\n`restrict_repr_packed_field_ref_capture` is changed to take place by value\nsince cloning is needed anyway.", "tree": {"sha": "849d32fd3b5345f7f30bbb9096f1be9958d37611", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/849d32fd3b5345f7f30bbb9096f1be9958d37611"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52db6b9d02a22eb1f54ea5f045d3744c98edd50f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52db6b9d02a22eb1f54ea5f045d3744c98edd50f", "html_url": "https://github.com/rust-lang/rust/commit/52db6b9d02a22eb1f54ea5f045d3744c98edd50f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52db6b9d02a22eb1f54ea5f045d3744c98edd50f/comments", "author": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6", "url": "https://api.github.com/repos/rust-lang/rust/commits/48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6", "html_url": "https://github.com/rust-lang/rust/commit/48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6"}], "stats": {"total": 229, "additions": 52, "deletions": 177}, "files": [{"sha": "470405babb379219654ec071fd6a0a2af85c3a0b", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 52, "deletions": 177, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/52db6b9d02a22eb1f54ea5f045d3744c98edd50f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52db6b9d02a22eb1f54ea5f045d3744c98edd50f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=52db6b9d02a22eb1f54ea5f045d3744c98edd50f", "patch": "@@ -207,7 +207,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         assert_eq!(body_owner_def_id.to_def_id(), closure_def_id);\n         let mut delegate = InferBorrowKind {\n             fcx: self,\n-            closure_def_id,\n+            closure_def_id: local_def_id,\n             capture_information: Default::default(),\n             fake_reads: Default::default(),\n         };\n@@ -1648,7 +1648,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n fn restrict_repr_packed_field_ref_capture<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    place: &Place<'tcx>,\n+    mut place: Place<'tcx>,\n     mut curr_borrow_kind: ty::UpvarCapture,\n ) -> (Place<'tcx>, ty::UpvarCapture) {\n     let pos = place.projections.iter().enumerate().position(|(i, p)| {\n@@ -1681,8 +1681,6 @@ fn restrict_repr_packed_field_ref_capture<'tcx>(\n         }\n     });\n \n-    let mut place = place.clone();\n-\n     if let Some(pos) = pos {\n         truncate_place_to_len_and_update_capture_kind(&mut place, &mut curr_borrow_kind, pos);\n     }\n@@ -1729,7 +1727,7 @@ struct InferBorrowKind<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n \n     // The def-id of the closure whose kind and upvar accesses are being inferred.\n-    closure_def_id: DefId,\n+    closure_def_id: LocalDefId,\n \n     /// For each Place that is captured by the closure, we track the minimal kind of\n     /// access we need (ref, ref mut, move, etc) and the expression that resulted in such access.\n@@ -1762,170 +1760,51 @@ struct InferBorrowKind<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn adjust_upvar_borrow_kind_for_consume(\n-        &mut self,\n-        place_with_id: &PlaceWithHirId<'tcx>,\n-        diag_expr_id: hir::HirId,\n-    ) {\n-        let PlaceBase::Upvar(upvar_id) = place_with_id.place.base else {\n-            return;\n-        };\n-\n-        debug!(?upvar_id);\n-\n-        let capture_info = ty::CaptureInfo {\n-            capture_kind_expr_id: Some(diag_expr_id),\n-            path_expr_id: Some(diag_expr_id),\n-            capture_kind: ty::UpvarCapture::ByValue,\n-        };\n-\n-        let curr_info = self.capture_information[&place_with_id.place];\n-        let updated_info = determine_capture_info(curr_info, capture_info);\n-\n-        self.capture_information[&place_with_id.place] = updated_info;\n-    }\n-\n-    /// Indicates that `place_with_id` is being directly mutated (e.g., assigned\n-    /// to). If the place is based on a by-ref upvar, this implies that\n-    /// the upvar must be borrowed using an `&mut` borrow.\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn adjust_upvar_borrow_kind_for_mut(\n-        &mut self,\n-        place_with_id: &PlaceWithHirId<'tcx>,\n-        diag_expr_id: hir::HirId,\n-    ) {\n-        if let PlaceBase::Upvar(_) = place_with_id.place.base {\n-            // Raw pointers don't inherit mutability\n-            if place_with_id.place.deref_tys().any(ty::TyS::is_unsafe_ptr) {\n-                return;\n+    fn adjust_capture_info(&mut self, place: Place<'tcx>, capture_info: ty::CaptureInfo) {\n+        match self.capture_information.get_mut(&place) {\n+            Some(curr_info) => {\n+                *curr_info = determine_capture_info(*curr_info, capture_info);\n             }\n-            self.adjust_upvar_deref(place_with_id, diag_expr_id, ty::MutBorrow);\n-        }\n-    }\n-\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn adjust_upvar_borrow_kind_for_unique(\n-        &mut self,\n-        place_with_id: &PlaceWithHirId<'tcx>,\n-        diag_expr_id: hir::HirId,\n-    ) {\n-        if let PlaceBase::Upvar(_) = place_with_id.place.base {\n-            if place_with_id.place.deref_tys().any(ty::TyS::is_unsafe_ptr) {\n-                // Raw pointers don't inherit mutability.\n-                return;\n+            None => {\n+                debug!(\"Capturing new place {:?}, capture_info={:?}\", place, capture_info);\n+                self.capture_information.insert(place, capture_info);\n             }\n-            // for a borrowed pointer to be unique, its base must be unique\n-            self.adjust_upvar_deref(place_with_id, diag_expr_id, ty::UniqueImmBorrow);\n-        }\n-    }\n-\n-    fn adjust_upvar_deref(\n-        &mut self,\n-        place_with_id: &PlaceWithHirId<'tcx>,\n-        diag_expr_id: hir::HirId,\n-        borrow_kind: ty::BorrowKind,\n-    ) {\n-        assert!(match borrow_kind {\n-            ty::MutBorrow => true,\n-            ty::UniqueImmBorrow => true,\n-\n-            // imm borrows never require adjusting any kinds, so we don't wind up here\n-            ty::ImmBorrow => false,\n-        });\n-\n-        // if this is an implicit deref of an\n-        // upvar, then we need to modify the\n-        // borrow_kind of the upvar to make sure it\n-        // is inferred to mutable if necessary\n-        self.adjust_upvar_borrow_kind(place_with_id, diag_expr_id, borrow_kind);\n-    }\n-\n-    /// We infer the borrow_kind with which to borrow upvars in a stack closure.\n-    /// The borrow_kind basically follows a lattice of `imm < unique-imm < mut`,\n-    /// moving from left to right as needed (but never right to left).\n-    /// Here the argument `mutbl` is the borrow_kind that is required by\n-    /// some particular use.\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn adjust_upvar_borrow_kind(\n-        &mut self,\n-        place_with_id: &PlaceWithHirId<'tcx>,\n-        diag_expr_id: hir::HirId,\n-        kind: ty::BorrowKind,\n-    ) {\n-        let curr_capture_info = self.capture_information[&place_with_id.place];\n-\n-        debug!(?curr_capture_info);\n-\n-        if let ty::UpvarCapture::ByValue = curr_capture_info.capture_kind {\n-            // It's already captured by value, we don't need to do anything here\n-            return;\n-        } else if let ty::UpvarCapture::ByRef(_) = curr_capture_info.capture_kind {\n-            let capture_info = ty::CaptureInfo {\n-                capture_kind_expr_id: Some(diag_expr_id),\n-                path_expr_id: Some(diag_expr_id),\n-                capture_kind: ty::UpvarCapture::ByRef(kind),\n-            };\n-            let updated_info = determine_capture_info(curr_capture_info, capture_info);\n-            self.capture_information[&place_with_id.place] = updated_info;\n-        };\n-    }\n-\n-    #[instrument(skip(self, diag_expr_id), level = \"debug\")]\n-    fn init_capture_info_for_place(\n-        &mut self,\n-        place_with_id: &PlaceWithHirId<'tcx>,\n-        diag_expr_id: hir::HirId,\n-    ) {\n-        if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n-            assert_eq!(self.closure_def_id.expect_local(), upvar_id.closure_expr_id);\n-\n-            // Initialize to ImmBorrow\n-            // We will escalate the CaptureKind based on any uses we see or in `process_collected_capture_information`.\n-            let capture_kind = ty::UpvarCapture::ByRef(ty::ImmBorrow);\n-\n-            let expr_id = Some(diag_expr_id);\n-            let capture_info = ty::CaptureInfo {\n-                capture_kind_expr_id: expr_id,\n-                path_expr_id: expr_id,\n-                capture_kind,\n-            };\n-\n-            debug!(\"Capturing new place {:?}, capture_info={:?}\", place_with_id, capture_info);\n-\n-            self.capture_information.insert(place_with_id.place.clone(), capture_info);\n-        } else {\n-            debug!(\"Not upvar\");\n         }\n     }\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n     fn fake_read(&mut self, place: Place<'tcx>, cause: FakeReadCause, diag_expr_id: hir::HirId) {\n-        if let PlaceBase::Upvar(_) = place.base {\n-            // We need to restrict Fake Read precision to avoid fake reading unsafe code,\n-            // such as deref of a raw pointer.\n-            let dummy_capture_kind = ty::UpvarCapture::ByRef(ty::BorrowKind::ImmBorrow);\n-\n-            let (place, _) = restrict_capture_precision(place, dummy_capture_kind);\n-\n-            let (place, _) = restrict_repr_packed_field_ref_capture(\n-                self.fcx.tcx,\n-                self.fcx.param_env,\n-                &place,\n-                dummy_capture_kind,\n-            );\n-            self.fake_reads.push((place, cause, diag_expr_id));\n-        }\n+        let PlaceBase::Upvar(_) = place.base else { return };\n+\n+        // We need to restrict Fake Read precision to avoid fake reading unsafe code,\n+        // such as deref of a raw pointer.\n+        let dummy_capture_kind = ty::UpvarCapture::ByRef(ty::BorrowKind::ImmBorrow);\n+\n+        let (place, _) = restrict_capture_precision(place, dummy_capture_kind);\n+\n+        let (place, _) = restrict_repr_packed_field_ref_capture(\n+            self.fcx.tcx,\n+            self.fcx.param_env,\n+            place,\n+            dummy_capture_kind,\n+        );\n+        self.fake_reads.push((place, cause, diag_expr_id));\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n     fn consume(&mut self, place_with_id: &PlaceWithHirId<'tcx>, diag_expr_id: hir::HirId) {\n-        if !self.capture_information.contains_key(&place_with_id.place) {\n-            self.init_capture_info_for_place(place_with_id, diag_expr_id);\n-        }\n+        let PlaceBase::Upvar(upvar_id) = place_with_id.place.base else { return };\n+        assert_eq!(self.closure_def_id, upvar_id.closure_expr_id);\n \n-        self.adjust_upvar_borrow_kind_for_consume(place_with_id, diag_expr_id);\n+        self.adjust_capture_info(\n+            place_with_id.place.clone(),\n+            ty::CaptureInfo {\n+                capture_kind_expr_id: Some(diag_expr_id),\n+                path_expr_id: Some(diag_expr_id),\n+                capture_kind: ty::UpvarCapture::ByValue,\n+            },\n+        );\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n@@ -1935,39 +1814,35 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n         diag_expr_id: hir::HirId,\n         bk: ty::BorrowKind,\n     ) {\n+        let PlaceBase::Upvar(upvar_id) = place_with_id.place.base else { return };\n+        assert_eq!(self.closure_def_id, upvar_id.closure_expr_id);\n+\n         // The region here will get discarded/ignored\n-        let dummy_capture_kind = ty::UpvarCapture::ByRef(bk);\n+        let capture_kind = ty::UpvarCapture::ByRef(bk);\n \n         // We only want repr packed restriction to be applied to reading references into a packed\n         // struct, and not when the data is being moved. Therefore we call this method here instead\n         // of in `restrict_capture_precision`.\n-        let (place, updated_kind) = restrict_repr_packed_field_ref_capture(\n+        let (place, mut capture_kind) = restrict_repr_packed_field_ref_capture(\n             self.fcx.tcx,\n             self.fcx.param_env,\n-            &place_with_id.place,\n-            dummy_capture_kind,\n+            place_with_id.place.clone(),\n+            capture_kind,\n         );\n \n-        let place_with_id = PlaceWithHirId { place, ..*place_with_id };\n-\n-        if !self.capture_information.contains_key(&place_with_id.place) {\n-            self.init_capture_info_for_place(&place_with_id, diag_expr_id);\n+        // Raw pointers don't inherit mutability\n+        if place_with_id.place.deref_tys().any(ty::TyS::is_unsafe_ptr) {\n+            capture_kind = ty::UpvarCapture::ByRef(ty::BorrowKind::ImmBorrow);\n         }\n \n-        match updated_kind {\n-            ty::UpvarCapture::ByRef(kind) => match kind {\n-                ty::ImmBorrow => {}\n-                ty::UniqueImmBorrow => {\n-                    self.adjust_upvar_borrow_kind_for_unique(&place_with_id, diag_expr_id);\n-                }\n-                ty::MutBorrow => {\n-                    self.adjust_upvar_borrow_kind_for_mut(&place_with_id, diag_expr_id);\n-                }\n+        self.adjust_capture_info(\n+            place,\n+            ty::CaptureInfo {\n+                capture_kind_expr_id: Some(diag_expr_id),\n+                path_expr_id: Some(diag_expr_id),\n+                capture_kind,\n             },\n-\n-            // Just truncating the place will never cause capture kind to be updated to ByValue\n-            ty::UpvarCapture::ByValue => unreachable!(),\n-        }\n+        );\n     }\n \n     #[instrument(skip(self), level = \"debug\")]"}]}