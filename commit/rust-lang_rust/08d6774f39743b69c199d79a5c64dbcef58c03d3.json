{"sha": "08d6774f39743b69c199d79a5c64dbcef58c03d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZDY3NzRmMzk3NDNiNjljMTk5ZDc5YTVjNjRkYmNlZjU4YzAzZDM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-04T12:57:21Z"}, "committer": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-11-16T13:23:14Z"}, "message": "Try to remove ty_nil, some kind of error in exhaustiveness checking", "tree": {"sha": "1296ffa9f310773d4bbd5cdbf8ba5d1758a3bf1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1296ffa9f310773d4bbd5cdbf8ba5d1758a3bf1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08d6774f39743b69c199d79a5c64dbcef58c03d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08d6774f39743b69c199d79a5c64dbcef58c03d3", "html_url": "https://github.com/rust-lang/rust/commit/08d6774f39743b69c199d79a5c64dbcef58c03d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08d6774f39743b69c199d79a5c64dbcef58c03d3/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c7a3d6c167c4656e8d35a1d428d142993e0aaab", "html_url": "https://github.com/rust-lang/rust/commit/0c7a3d6c167c4656e8d35a1d428d142993e0aaab"}], "stats": {"total": 190, "additions": 76, "deletions": 114}, "files": [{"sha": "a5187283de18b1f7026d3348a2ab078bdabcd39a", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -735,7 +735,7 @@ impl LintPass for UnusedResults {\n         let t = ty::expr_ty(cx.tcx, expr);\n         let mut warned = false;\n         match ty::get(t).sty {\n-            ty::ty_nil | ty::ty_bool => return,\n+            ty::ty_bool => return,\n             ty::ty_struct(did, _) |\n             ty::ty_enum(did, _) => {\n                 if ast_util::is_local(did) {"}, {"sha": "50c9a4a2a52c72a31eb90ad932c404ad6604f781", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -360,7 +360,6 @@ fn parse_trait_ref(st: &mut PState, conv: conv_did) -> ty::TraitRef {\n \n fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n     match next(st) {\n-      'n' => return ty::mk_nil(),\n       'b' => return ty::mk_bool(),\n       'i' => return ty::mk_int(),\n       'u' => return ty::mk_uint(),"}, {"sha": "3242d3961467a153efd2fd0ad223a6dffe8c224d", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -199,7 +199,6 @@ pub fn enc_trait_store(w: &mut SeekableMemWriter, cx: &ctxt, s: ty::TraitStore)\n \n fn enc_sty(w: &mut SeekableMemWriter, cx: &ctxt, st: &ty::sty) {\n     match *st {\n-        ty::ty_nil => mywrite!(w, \"n\"),\n         ty::ty_bool => mywrite!(w, \"b\"),\n         ty::ty_char => mywrite!(w, \"c\"),\n         ty::ty_int(t) => {"}, {"sha": "a23889d9cab4e2249fadc876f753b4394b3556e3", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -402,7 +402,7 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n     let pats_len = pats.len();\n     let mut pats = pats.into_iter().map(|p| P((*p).clone()));\n     let pat = match ty::get(left_ty).sty {\n-        ty::ty_tup(_) => PatTup(pats.collect()),\n+        ty::ty_tup(ref tys) if !tys.is_empty() => PatTup(pats.collect()),\n \n         ty::ty_enum(cid, _) | ty::ty_struct(cid, _)  => {\n             let (vid, is_structure) = match ctor {\n@@ -497,7 +497,7 @@ fn all_constructors(cx: &MatchCheckCtxt, left_ty: ty::t,\n         ty::ty_bool =>\n             [true, false].iter().map(|b| ConstantValue(const_bool(*b))).collect(),\n \n-        ty::ty_nil =>\n+        ty::ty_tup(ref tys) if tys.is_empty() =>\n             vec!(ConstantValue(const_nil)),\n \n         ty::ty_rptr(_, ty::mt { ty, .. }) => match ty::get(ty).sty {\n@@ -552,7 +552,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n         None => v[0]\n     };\n     let left_ty = if real_pat.id == DUMMY_NODE_ID {\n-        ty::mk_nil()\n+        ty::mk_nil(cx.tcx)\n     } else {\n         ty::pat_ty(cx.tcx, &*real_pat)\n     };"}, {"sha": "be5a007c1ebde7f63b6f4ca293f5fcdc1f02b600", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -79,7 +79,6 @@ pub fn ty_is_local(tcx: &ty::ctxt,\n     debug!(\"ty_is_local({})\", ty.repr(tcx));\n \n     match ty::get(ty).sty {\n-        ty::ty_nil |\n         ty::ty_bool |\n         ty::ty_char |\n         ty::ty_int(..) |"}, {"sha": "b50956ec9dbaf588193463ede6ea1cefe6cdd541", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -1227,7 +1227,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::ty_infer(ty::FloatVar(_)) |\n             ty::ty_uint(_) |\n             ty::ty_int(_) |\n-            ty::ty_nil |\n             ty::ty_bool |\n             ty::ty_float(_) |\n             ty::ty_bare_fn(_) |"}, {"sha": "e4409777686f57fef6c3845eb5d78b6a24bb0d1c", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -1012,7 +1012,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                          .unwrap_or(DUMMY_NODE_ID);\n \n     let left_ty = if pat_id == DUMMY_NODE_ID {\n-        ty::mk_nil()\n+        ty::mk_nil(tcx)\n     } else {\n         node_id_type(bcx, pat_id)\n     };"}, {"sha": "d4d532c1c4401ca5085ce9ecb2f68a558c399801", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -47,7 +47,7 @@ use middle::trans::builder::{Builder, noname};\n use middle::trans::callee;\n use middle::trans::cleanup::{CleanupMethods, ScopeId};\n use middle::trans::cleanup;\n-use middle::trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_integral, C_nil};\n+use middle::trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_integral};\n use middle::trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_uint, C_undef};\n use middle::trans::common::{CrateContext, ExternMap, FunctionContext};\n use middle::trans::common::{NodeInfo, Result, SubstP};\n@@ -517,7 +517,7 @@ pub fn get_res_dtor(ccx: &CrateContext,\n         let class_ty = ty::lookup_item_type(tcx, parent_id).ty.subst(tcx, substs);\n         let llty = type_of_dtor(ccx, class_ty);\n         let dtor_ty = ty::mk_ctor_fn(ccx.tcx(), ast::DUMMY_NODE_ID,\n-                                     [glue::get_drop_glue_type(ccx, t)], ty::mk_nil());\n+                                     [glue::get_drop_glue_type(ccx, t)], ty::mk_nil(ccx.tcx()));\n         get_extern_fn(ccx,\n                       &mut *ccx.externs().borrow_mut(),\n                       name.as_slice(),\n@@ -551,7 +551,7 @@ pub fn compare_scalar_types<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     let f = |a| Result::new(cx, compare_scalar_values(cx, lhs, rhs, a, op));\n \n     match ty::get(t).sty {\n-        ty::ty_nil => f(nil_type),\n+        ty::ty_tup(ref tys) if tys.is_empty() => f(nil_type),\n         ty::ty_bool | ty::ty_uint(_) | ty::ty_char => f(unsigned_int),\n         ty::ty_ptr(mt) if ty::type_is_sized(cx.tcx(), mt.ty) => f(unsigned_int),\n         ty::ty_int(_) => f(signed_int),\n@@ -1578,12 +1578,6 @@ fn create_datums_for_fn_args_under_call_abi(\n                                                                 \"argtuple\"));\n                 result.push(tuple);\n             }\n-            ty::ty_nil => {\n-                let mode = datum::Rvalue::new(datum::ByValue);\n-                result.push(datum::Datum::new(C_nil(bcx.ccx()),\n-                                              ty::mk_nil(),\n-                                              mode))\n-            }\n             _ => {\n                 bcx.tcx().sess.bug(\"last argument of a function with \\\n                                     `rust-call` ABI isn't a tuple?!\")\n@@ -1647,10 +1641,8 @@ fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n                       arg_datum.to_lvalue_datum_in_scope(bcx,\n                                                          \"argtuple\",\n                                                          arg_scope_id));\n-    let empty = Vec::new();\n     let untupled_arg_types = match ty::get(monomorphized_arg_types[0]).sty {\n         ty::ty_tup(ref types) => types.as_slice(),\n-        ty::ty_nil => empty.as_slice(),\n         _ => {\n             bcx.tcx().sess.span_bug(args[0].pat.span,\n                                     \"first arg to `rust-call` ABI function \\\n@@ -1824,7 +1816,7 @@ pub fn trans_closure(ccx: &CrateContext,\n         NotUnboxedClosure => monomorphized_arg_types,\n \n         // Tuple up closure argument types for the \"rust-call\" ABI.\n-        IsUnboxedClosure => vec![ty::mk_tup_or_nil(ccx.tcx(), monomorphized_arg_types)]\n+        IsUnboxedClosure => vec![ty::mk_tup(ccx.tcx(), monomorphized_arg_types)]\n     };\n     for monomorphized_arg_type in monomorphized_arg_types.iter() {\n         debug!(\"trans_closure: monomorphized_arg_type: {}\",\n@@ -2380,7 +2372,6 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n             assert!(abi == RustCall);\n \n             match ty::get(fn_sig.inputs[0]).sty {\n-                ty::ty_nil => Vec::new(),\n                 ty::ty_tup(ref inputs) => inputs.clone(),\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n             }\n@@ -2389,7 +2380,6 @@ pub fn get_fn_llvm_attributes(ccx: &CrateContext, fn_ty: ty::t)\n             let mut inputs = vec![fn_sig.inputs[0]];\n \n             match ty::get(fn_sig.inputs[1]).sty {\n-                ty::ty_nil => inputs,\n                 ty::ty_tup(ref t_in) => {\n                     inputs.push_all(t_in.as_slice());\n                     inputs\n@@ -2532,7 +2522,7 @@ pub fn register_fn_llvmty(ccx: &CrateContext,\n                           llfty: Type) -> ValueRef {\n     debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n \n-    let llfn = decl_fn(ccx, sym.as_slice(), cc, llfty, ty::FnConverging(ty::mk_nil()));\n+    let llfn = decl_fn(ccx, sym.as_slice(), cc, llfty, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }\n@@ -2564,7 +2554,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n         let llfty = Type::func([ccx.int_type(), Type::i8p(ccx).ptr_to()],\n                                &ccx.int_type());\n \n-        let llfn = decl_cdecl_fn(ccx, \"main\", llfty, ty::mk_nil());\n+        let llfn = decl_cdecl_fn(ccx, \"main\", llfty, ty::mk_nil(ccx.tcx()));\n \n         // FIXME: #16581: Marking a symbol in the executable with `dllexport`\n         // linkage forces MinGW's linker to output a `.reloc` section for ASLR"}, {"sha": "f62159cd4902a6d682d5430dda105878db2c7a5c", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -764,7 +764,7 @@ pub fn trans_call_inner<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         expr::Ignore => {\n             let ret_ty = match ret_ty {\n                 ty::FnConverging(ret_ty) => ret_ty,\n-                ty::FnDiverging => ty::mk_nil()\n+                ty::FnDiverging => ty::mk_nil(ccx.tcx())\n             };\n             if !is_rust_fn ||\n               type_of::return_uses_outptr(ccx, ret_ty) ||\n@@ -957,7 +957,6 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n                 llargs.push(arg_datum.add_clean(bcx.fcx, arg_cleanup_scope));\n             }\n         }\n-        ty::ty_nil => {}\n         _ => {\n             bcx.sess().span_bug(tuple_expr.span,\n                                 \"argument to `.call()` wasn't a tuple?!\")\n@@ -1004,7 +1003,6 @@ fn trans_overloaded_call_args<'blk, 'tcx>(\n                 }))\n             }\n         }\n-        ty::ty_nil => {}\n         _ => {\n             bcx.sess().span_bug(arg_exprs[0].span,\n                                 \"argument to `.call()` wasn't a tuple?!\")"}, {"sha": "be712087e0b658639ca2179d6688e4fe802f29df", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -718,15 +718,15 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n     macro_rules! ifn (\n         ($name:expr fn() -> $ret:expr) => (\n             if *key == $name {\n-                let f = base::decl_cdecl_fn(ccx, $name, Type::func([], &$ret), ty::mk_nil());\n+                let f = base::decl_cdecl_fn(ccx, $name, Type::func([], &$ret), ty::mk_nil(ccx.tcx()));\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         );\n         ($name:expr fn($($arg:expr),*) -> $ret:expr) => (\n             if *key == $name {\n                 let f = base::decl_cdecl_fn(ccx, $name,\n-                                  Type::func([$($arg),*], &$ret), ty::mk_nil());\n+                                  Type::func([$($arg),*], &$ret), ty::mk_nil(ccx.tcx()));\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n@@ -863,7 +863,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n             } else if *key == $name {\n                 let f = base::decl_cdecl_fn(ccx, stringify!($cname),\n                                       Type::func([$($arg),*], &$ret),\n-                                      ty::mk_nil());\n+                                      ty::mk_nil(ccx.tcx()));\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }"}, {"sha": "be342c8afe9b79a40d66c49c6fd5af34657646e3", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -350,7 +350,6 @@ impl TypeMap {\n         unique_type_id.push('{');\n \n         match ty::get(type_).sty {\n-            ty::ty_nil      |\n             ty::ty_bool     |\n             ty::ty_char     |\n             ty::ty_str      |\n@@ -367,6 +366,9 @@ impl TypeMap {\n                 unique_type_id.push_str(\"struct \");\n                 from_def_id_and_substs(self, cx, def_id, substs, &mut unique_type_id);\n             },\n+            ty::ty_tup(ref component_types) if component_types.is_empty() => {\n+                push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n+            },\n             ty::ty_tup(ref component_types) => {\n                 unique_type_id.push_str(\"tuple \");\n                 for &component_type in component_types.iter() {\n@@ -1736,7 +1738,6 @@ fn basic_type_metadata(cx: &CrateContext, t: ty::t) -> DIType {\n     debug!(\"basic_type_metadata: {}\", ty::get(t));\n \n     let (name, encoding) = match ty::get(t).sty {\n-        ty::ty_nil => (\"()\".to_string(), DW_ATE_unsigned),\n         ty::ty_bool => (\"bool\".to_string(), DW_ATE_boolean),\n         ty::ty_char => (\"char\".to_string(), DW_ATE_unsigned_char),\n         ty::ty_int(int_ty) => match int_ty {\n@@ -2773,7 +2774,7 @@ fn subroutine_type_metadata(cx: &CrateContext,\n     // return type\n     signature_metadata.push(match signature.output {\n         ty::FnConverging(ret_ty) => match ty::get(ret_ty).sty {\n-            ty::ty_nil => ptr::null_mut(),\n+            ty::ty_tup(ref tys) if tys.is_empty() => ptr::null_mut(),\n             _ => type_metadata(cx, ret_ty, span)\n         },\n         ty::FnDiverging => diverging_type_metadata(cx)\n@@ -2880,7 +2881,6 @@ fn type_metadata(cx: &CrateContext,\n \n     let sty = &ty::get(t).sty;\n     let MetadataCreationResult { metadata, already_stored_in_typemap } = match *sty {\n-        ty::ty_nil      |\n         ty::ty_bool     |\n         ty::ty_char     |\n         ty::ty_int(_)   |\n@@ -3671,7 +3671,6 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n                             qualified: bool,\n                             output:&mut String) {\n     match ty::get(t).sty {\n-        ty::ty_nil               => output.push_str(\"()\"),\n         ty::ty_bool              => output.push_str(\"bool\"),\n         ty::ty_char              => output.push_str(\"char\"),\n         ty::ty_str               => output.push_str(\"str\"),"}, {"sha": "0b03163a02bab09627e0c64874680ad7ad787c6c", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -520,7 +520,7 @@ pub fn decl_rust_fn_with_foreign_abi(ccx: &CrateContext,\n         }\n         _ => panic!(\"expected bare fn in decl_rust_fn_with_foreign_abi\")\n     };\n-    let llfn = base::decl_fn(ccx, name, cconv, llfn_ty, ty::FnConverging(ty::mk_nil()));\n+    let llfn = base::decl_fn(ccx, name, cconv, llfn_ty, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n     add_argument_attributes(&tys, llfn);\n     debug!(\"decl_rust_fn_with_foreign_abi(llfn_ty={}, llfn={})\",\n            ccx.tn().type_to_string(llfn_ty), ccx.tn().val_to_string(llfn));"}, {"sha": "f5db3d418128b1f8b4d36fe024761b07ded2869b", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -159,7 +159,7 @@ pub fn get_drop_glue(ccx: &CrateContext, t: ty::t) -> ValueRef {\n \n     let (glue, new_sym) = match ccx.available_drop_glues().borrow().get(&t) {\n         Some(old_sym) => {\n-            let glue = decl_cdecl_fn(ccx, old_sym.as_slice(), llfnty, ty::mk_nil());\n+            let glue = decl_cdecl_fn(ccx, old_sym.as_slice(), llfnty, ty::mk_nil(ccx.tcx()));\n             (glue, None)\n         },\n         None => {\n@@ -288,7 +288,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n \n         let dtor_ty = ty::mk_ctor_fn(variant_cx.tcx(), ast::DUMMY_NODE_ID,\n-                                     [get_drop_glue_type(bcx.ccx(), t)], ty::mk_nil());\n+                                     [get_drop_glue_type(bcx.ccx(), t)], ty::mk_nil(bcx.tcx()));\n         let (_, variant_cx) = invoke(variant_cx, dtor_addr, args, dtor_ty, None, false);\n \n         variant_cx.fcx.pop_and_trans_custom_cleanup_scope(variant_cx, field_scope);\n@@ -520,7 +520,7 @@ fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n         ccx,\n         t,\n         format!(\"glue_{}\", name).as_slice());\n-    let llfn = decl_cdecl_fn(ccx, fn_nm.as_slice(), llfnty, ty::mk_nil());\n+    let llfn = decl_cdecl_fn(ccx, fn_nm.as_slice(), llfnty, ty::mk_nil(ccx.tcx()));\n     note_unique_llvm_symbol(ccx, fn_nm.clone());\n     return (fn_nm, llfn);\n }\n@@ -538,10 +538,11 @@ fn make_generic_glue(ccx: &CrateContext,\n \n     let arena = TypedArena::new();\n     let empty_param_substs = param_substs::empty();\n-    let fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false, ty::FnConverging(ty::mk_nil()),\n+    let fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false,\n+                          ty::FnConverging(ty::mk_nil(ccx.tcx())),\n                           &empty_param_substs, None, &arena);\n \n-    let bcx = init_function(&fcx, false, ty::FnConverging(ty::mk_nil()));\n+    let bcx = init_function(&fcx, false, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n \n     update_linkage(ccx, llfn, None, OriginalTranslation);\n \n@@ -556,7 +557,7 @@ fn make_generic_glue(ccx: &CrateContext,\n \n     let llrawptr0 = get_param(llfn, fcx.arg_pos(0) as c_uint);\n     let bcx = helper(bcx, llrawptr0, t);\n-    finish_fn(&fcx, bcx, ty::FnConverging(ty::mk_nil()));\n+    finish_fn(&fcx, bcx, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n \n     llfn\n }"}, {"sha": "f0af123221f92beb332339d08a57aef764199597", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -594,7 +594,6 @@ pub fn get_vtable(bcx: Block,\n                                             new_inputs.push(element.subst(bcx.tcx(), substs));\n                                         }\n                                     }\n-                                    ty::ty_nil => {}\n                                     _ => {\n                                         bcx.tcx().sess.bug(\"get_vtable(): closure \\\n                                                             type wasn't a tuple\")"}, {"sha": "379d1e85b8b856339f5320979f2e16f6c27bed56", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -83,7 +83,6 @@ pub fn untuple_arguments_if_necessary(ccx: &CrateContext,\n                 result.push(tupled_argument);\n             }\n         }\n-        ty::ty_nil => {}\n         _ => {\n             ccx.tcx().sess.bug(\"argument to function with \\\"rust-call\\\" ABI \\\n                                 is neither a tuple nor unit\")\n@@ -186,7 +185,6 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n                                   ppaux::ty_to_string(cx.tcx(), t)).as_slice())\n         }\n \n-        ty::ty_nil => Type::nil(cx),\n         ty::ty_bool => Type::bool(cx),\n         ty::ty_char => Type::char(cx),\n         ty::ty_int(t) => Type::int_from_ty(cx, t),\n@@ -211,6 +209,10 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n             Type::array(&llty, size)\n         }\n \n+        ty::ty_tup(ref tys) if tys.is_empty() => {\n+            Type::nil(cx)\n+        }\n+\n         ty::ty_tup(..) | ty::ty_enum(..) | ty::ty_unboxed_closure(..) => {\n             let repr = adt::represent_type(cx, t);\n             adt::sizing_type_of(cx, &*repr, false)\n@@ -298,7 +300,6 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n     }\n \n     let mut llty = match ty::get(t).sty {\n-      ty::ty_nil => Type::nil(cx),\n       ty::ty_bool => Type::bool(cx),\n       ty::ty_char => Type::char(cx),\n       ty::ty_int(t) => Type::int_from_ty(cx, t),\n@@ -365,6 +366,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n           let fn_ty = type_of_fn_from_ty(cx, t).ptr_to();\n           Type::struct_(cx, [fn_ty, Type::i8p(cx)], false)\n       }\n+      ty::ty_tup(ref tys) if tys.is_empty() => Type::nil(cx),\n       ty::ty_tup(..) => {\n           let repr = adt::represent_type(cx, t);\n           adt::type_of(cx, &*repr)"}, {"sha": "1e5b3c9ea7a19f6d1f6d3fe7b632c37c9fb87ca0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -906,7 +906,6 @@ mod primitives {\n         )\n     )\n \n-    def_prim_ty!(TY_NIL,    super::ty_nil)\n     def_prim_ty!(TY_BOOL,   super::ty_bool)\n     def_prim_ty!(TY_CHAR,   super::ty_char)\n     def_prim_ty!(TY_INT,    super::ty_int(ast::TyI))\n@@ -932,7 +931,6 @@ mod primitives {\n // AST structure in libsyntax/ast.rs as well.\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub enum sty {\n-    ty_nil,\n     ty_bool,\n     ty_char,\n     ty_int(ast::IntTy),\n@@ -1557,7 +1555,6 @@ pub fn mk_ctxt<'tcx>(s: Session,\n pub fn mk_t(cx: &ctxt, st: sty) -> t {\n     // Check for primitive types.\n     match st {\n-        ty_nil => return mk_nil(),\n         ty_err => return mk_err(),\n         ty_bool => return mk_bool(),\n         ty_int(i) => return mk_mach_int(i),\n@@ -1603,7 +1600,7 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n         rflags(bounds.region_bound)\n     }\n     match &st {\n-      &ty_nil | &ty_bool | &ty_char | &ty_int(_) | &ty_float(_) | &ty_uint(_) |\n+      &ty_bool | &ty_char | &ty_int(_) | &ty_float(_) | &ty_uint(_) |\n       &ty_str => {}\n       // You might think that we could just return ty_err for\n       // any type containing ty_err as a component, and get\n@@ -1689,9 +1686,6 @@ pub fn mk_prim_t(primitive: &'static t_box_) -> t {\n     }\n }\n \n-#[inline]\n-pub fn mk_nil() -> t { mk_prim_t(&primitives::TY_NIL) }\n-\n #[inline]\n pub fn mk_err() -> t { mk_prim_t(&primitives::TY_ERR) }\n \n@@ -1803,7 +1797,7 @@ pub fn mk_imm_ptr(cx: &ctxt, ty: t) -> t {\n }\n \n pub fn mk_nil_ptr(cx: &ctxt) -> t {\n-    mk_ptr(cx, mt {ty: mk_nil(), mutbl: ast::MutImmutable})\n+    mk_ptr(cx, mt {ty: mk_nil(cx), mutbl: ast::MutImmutable})\n }\n \n pub fn mk_vec(cx: &ctxt, t: t, sz: Option<uint>) -> t {\n@@ -1818,14 +1812,12 @@ pub fn mk_slice(cx: &ctxt, r: Region, tm: mt) -> t {\n             })\n }\n \n-pub fn mk_tup(cx: &ctxt, ts: Vec<t>) -> t { mk_t(cx, ty_tup(ts)) }\n+pub fn mk_tup(cx: &ctxt, ts: Vec<t>) -> t {\n+    mk_t(cx, ty_tup(ts))\n+}\n \n-pub fn mk_tup_or_nil(cx: &ctxt, ts: Vec<t>) -> t {\n-    if ts.len() == 0 {\n-        ty::mk_nil()\n-    } else {\n-        mk_t(cx, ty_tup(ts))\n-    }\n+pub fn mk_nil(cx: &ctxt) -> t {\n+    mk_tup(cx, Vec::new())\n }\n \n pub fn mk_closure(cx: &ctxt, fty: ClosureTy) -> t {\n@@ -1908,7 +1900,7 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n         return;\n     }\n     match get(ty).sty {\n-        ty_nil | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n+        ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n         ty_str | ty_infer(_) | ty_param(_) | ty_err => {}\n         ty_uniq(ty) | ty_vec(ty, _) | ty_open(ty) => maybe_walk_ty(ty, f),\n         ty_ptr(ref tm) | ty_rptr(_, ref tm) => {\n@@ -1996,7 +1988,10 @@ impl ParamBounds {\n // Type utilities\n \n pub fn type_is_nil(ty: t) -> bool {\n-    get(ty).sty == ty_nil\n+    match get(ty).sty {\n+        ty_tup(ref tys) => tys.is_empty(),\n+        _ => false\n+    }\n }\n \n pub fn type_is_error(ty: t) -> bool {\n@@ -2133,7 +2128,7 @@ pub fn type_is_fat_ptr(cx: &ctxt, ty: t) -> bool {\n */\n pub fn type_is_scalar(ty: t) -> bool {\n     match get(ty).sty {\n-      ty_nil | ty_bool | ty_char | ty_int(_) | ty_float(_) | ty_uint(_) |\n+      ty_bool | ty_char | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_infer(IntVar(_)) | ty_infer(FloatVar(_)) |\n       ty_bare_fn(..) | ty_ptr(_) => true,\n       _ => false\n@@ -2170,7 +2165,7 @@ pub fn type_needs_unwind_cleanup(cx: &ctxt, ty: t) -> bool {\n         let mut needs_unwind_cleanup = false;\n         maybe_walk_ty(ty, |ty| {\n             needs_unwind_cleanup |= match get(ty).sty {\n-                ty_nil | ty_bool | ty_int(_) | ty_uint(_) |\n+                ty_bool | ty_int(_) | ty_uint(_) |\n                 ty_float(_) | ty_tup(_) | ty_ptr(_) => false,\n \n                 ty_enum(did, ref substs) =>\n@@ -2429,7 +2424,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n \n             // Scalar and unique types are sendable, and durable\n             ty_infer(ty::SkolemizedIntTy(_)) |\n-            ty_nil | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n+            ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n             ty_bare_fn(_) | ty::ty_char => {\n                 TC::None\n             }\n@@ -2740,7 +2735,6 @@ pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n             ty_vec(_, Some(0)) => false, // don't need no contents\n             ty_vec(ty, Some(_)) => type_requires(cx, seen, r_ty, ty),\n \n-            ty_nil |\n             ty_bool |\n             ty_char |\n             ty_int(_) |\n@@ -3779,7 +3773,7 @@ pub fn impl_or_trait_item_idx(id: ast::Name, trait_items: &[ImplOrTraitItem])\n \n pub fn ty_sort_string(cx: &ctxt, t: t) -> String {\n     match get(t).sty {\n-        ty_nil | ty_bool | ty_char | ty_int(_) |\n+        ty_bool | ty_char | ty_int(_) |\n         ty_uint(_) | ty_float(_) | ty_str => {\n             ::util::ppaux::ty_to_string(cx, t)\n         }\n@@ -5141,7 +5135,6 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n     };\n     ty::walk_ty(t, |t| {\n         match ty::get(t).sty {\n-            ty_nil => byte!(0),\n             ty_bool => byte!(2),\n             ty_char => byte!(3),\n             ty_int(i) => {\n@@ -5512,7 +5505,6 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n                 accumulator.push(*region);\n                 accum_substs(accumulator, substs);\n             }\n-            ty_nil |\n             ty_bool |\n             ty_char |\n             ty_int(_) |"}, {"sha": "6d8d03aa0ab7af9c724593b935dfa14c174298d2", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -554,7 +554,7 @@ pub fn super_fold_sty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n         ty::ty_unboxed_closure(did, ref region, ref substs) => {\n             ty::ty_unboxed_closure(did, region.fold_with(this), substs.fold_with(this))\n         }\n-        ty::ty_nil | ty::ty_bool | ty::ty_char | ty::ty_str |\n+        ty::ty_bool | ty::ty_char | ty::ty_str |\n         ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n         ty::ty_err | ty::ty_infer(_) |\n         ty::ty_param(..) => {"}, {"sha": "9358904a78ce61030b29a4845d75a48c844a765e", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -389,7 +389,7 @@ fn ast_path_substs<'tcx,AC,RS>(\n \n         let output = match data.output {\n             Some(ref output_ty) => ast_ty_to_ty(this, &binding_rscope, &**output_ty),\n-            None => ty::mk_nil()\n+            None => ty::mk_nil(this.tcx())\n         };\n \n         (Vec::new(), vec![input_ty, output])\n@@ -824,7 +824,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n \n     let typ = ast_ty_to_builtin_ty(this, rscope, ast_ty).unwrap_or_else(|| {\n         match ast_ty.node {\n-            ast::TyNil => ty::mk_nil(),\n+            ast::TyNil => ty::mk_nil(this.tcx()),\n             ast::TyBot => unreachable!(),\n             ast::TyUniq(ref ty) => {\n                 mk_pointer(this, rscope, ast::MutImmutable, &**ty, Uniq,"}, {"sha": "a35bc502813ce935d8ef899f193b09ccea9ca286", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -1214,7 +1214,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             ty_bare_fn(..) | ty_uniq(..) | ty_rptr(..) |\n             ty_infer(IntVar(_)) |\n             ty_infer(FloatVar(_)) |\n-            ty_param(..) | ty_nil | ty_bool |\n+            ty_param(..) | ty_bool |\n             ty_char | ty_int(..) | ty_uint(..) |\n             ty_float(..) | ty_enum(..) | ty_ptr(..) | ty_struct(..) |\n             ty_unboxed_closure(..) | ty_tup(..) | ty_open(..) |"}, {"sha": "bb20475c0cf8bad86dac430cbd55648692e023c8", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 30, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -1569,7 +1569,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn default_diverging_type_variables_to_nil(&self) {\n         for (_, &ref ty) in self.inh.node_types.borrow_mut().iter_mut() {\n             if self.infcx().type_var_diverges(self.infcx().resolve_type_vars_if_possible(*ty)) {\n-                demand::eqtype(self, codemap::DUMMY_SP, *ty, ty::mk_nil());\n+                demand::eqtype(self, codemap::DUMMY_SP, *ty, ty::mk_nil(self.tcx()));\n             }\n         }\n     }\n@@ -1741,7 +1741,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn write_nil(&self, node_id: ast::NodeId) {\n-        self.write_ty(node_id, ty::mk_nil());\n+        self.write_ty(node_id, ty::mk_nil(self.tcx()));\n     }\n     pub fn write_error(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, ty::mk_err());\n@@ -2664,17 +2664,6 @@ fn check_argument_types<'a>(fcx: &FnCtxt,\n                     (*arg_types).clone()\n                 }\n             }\n-            ty::ty_nil => {\n-                if args.len() != 0 {\n-                    span_err!(tcx.sess, sp, E0058,\n-                        \"this function takes 0 parameters but {} parameter{} supplied\",\n-                        args.len(),\n-                        if args.len() == 1 {\" was\"} else {\"s were\"});\n-                    err_args(args.len())\n-                } else {\n-                    vec![]\n-                }\n-            }\n             _ => {\n                 span_err!(tcx.sess, sp, E0059,\n                     \"cannot use call notation; the first type parameter \\\n@@ -2865,7 +2854,7 @@ fn check_lit(fcx: &FnCtxt,\n             opt_ty.unwrap_or_else(\n                 || ty::mk_float_var(tcx, fcx.infcx().next_float_var_id()))\n         }\n-        ast::LitNil => ty::mk_nil(),\n+        ast::LitNil => ty::mk_nil(tcx),\n         ast::LitBool(_) => ty::mk_bool()\n     }\n }\n@@ -3179,7 +3168,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                         infer::IfExpressionWithNoElse(sp),\n                                         false,\n                                         then_ty,\n-                                        ty::mk_nil())\n+                                        ty::mk_nil(fcx.tcx()))\n             }\n         };\n \n@@ -3480,7 +3469,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n         // Tuple up the arguments and insert the resulting function type into\n         // the `unboxed_closures` table.\n-        fn_ty.sig.inputs = vec![ty::mk_tup_or_nil(fcx.tcx(), fn_ty.sig.inputs)];\n+        fn_ty.sig.inputs = vec![ty::mk_tup(fcx.tcx(), fn_ty.sig.inputs)];\n \n         let kind = match kind {\n             ast::FnUnboxedClosureKind => ty::FnUnboxedClosureKind,\n@@ -4148,7 +4137,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                 match *expr_opt {\n                     None =>\n                         if let Err(_) = fcx.mk_eqty(false, infer::Misc(expr.span),\n-                                                    result_type, ty::mk_nil()) {\n+                                                    result_type, ty::mk_nil(fcx.tcx())) {\n                             span_err!(tcx.sess, expr.span, E0069,\n                                 \"`return;` in function returning non-nil\");\n                         },\n@@ -4743,7 +4732,7 @@ pub fn check_stmt(fcx: &FnCtxt, stmt: &ast::Stmt)  {\n       ast::StmtExpr(ref expr, id) => {\n         node_id = id;\n         // Check with expected type of ()\n-        check_expr_has_type(fcx, &**expr, ty::mk_nil());\n+        check_expr_has_type(fcx, &**expr, ty::mk_nil(fcx.tcx()));\n         let expr_ty = fcx.expr_ty(&**expr);\n         saw_bot = saw_bot || fcx.infcx().type_var_diverges(expr_ty);\n         saw_err = saw_err || ty::type_is_error(expr_ty);\n@@ -4769,12 +4758,12 @@ pub fn check_stmt(fcx: &FnCtxt, stmt: &ast::Stmt)  {\n }\n \n pub fn check_block_no_value(fcx: &FnCtxt, blk: &ast::Block)  {\n-    check_block_with_expected(fcx, blk, ExpectHasType(ty::mk_nil()));\n+    check_block_with_expected(fcx, blk, ExpectHasType(ty::mk_nil(fcx.tcx())));\n     let blkty = fcx.node_ty(blk.id);\n     if ty::type_is_error(blkty) {\n         fcx.write_error(blk.id);\n     } else {\n-        let nilty = ty::mk_nil();\n+        let nilty = ty::mk_nil(fcx.tcx());\n         demand::suptype(fcx, blk.span, nilty, blkty);\n     }\n }\n@@ -5507,7 +5496,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n             data.output.as_ref().map(|ty| fcx.to_ty(&**ty));\n \n         let output_ty =\n-            output_ty.unwrap_or(ty::mk_nil());\n+            output_ty.unwrap_or(ty::mk_nil(fcx.tcx()));\n \n         if type_count >= 2 {\n             substs.types.push(space, output_ty);\n@@ -5727,15 +5716,15 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"load\" => (1, vec!(ty::mk_imm_ptr(tcx, param(ccx, 0))),\n                        param(ccx, 0)),\n             \"store\" => (1, vec!(ty::mk_mut_ptr(tcx, param(ccx, 0)), param(ccx, 0)),\n-                        ty::mk_nil()),\n+                        ty::mk_nil(tcx)),\n \n             \"xchg\" | \"xadd\" | \"xsub\" | \"and\"  | \"nand\" | \"or\" | \"xor\" | \"max\" |\n             \"min\"  | \"umax\" | \"umin\" => {\n                 (1, vec!(ty::mk_mut_ptr(tcx, param(ccx, 0)), param(ccx, 0)),\n                  param(ccx, 0))\n             }\n             \"fence\" => {\n-                (0, Vec::new(), ty::mk_nil())\n+                (0, Vec::new(), ty::mk_nil(tcx))\n             }\n             op => {\n                 span_err!(tcx.sess, it.span, E0092,\n@@ -5748,20 +5737,20 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n         (0, Vec::new(), ty::FnDiverging)\n     } else {\n         let (n_tps, inputs, output) = match name.get() {\n-            \"breakpoint\" => (0, Vec::new(), ty::mk_nil()),\n+            \"breakpoint\" => (0, Vec::new(), ty::mk_nil(tcx)),\n             \"size_of\" |\n             \"pref_align_of\" | \"min_align_of\" => (1u, Vec::new(), ty::mk_uint()),\n             \"init\" => (1u, Vec::new(), param(ccx, 0u)),\n             \"uninit\" => (1u, Vec::new(), param(ccx, 0u)),\n-            \"forget\" => (1u, vec!( param(ccx, 0) ), ty::mk_nil()),\n+            \"forget\" => (1u, vec!( param(ccx, 0) ), ty::mk_nil(tcx)),\n             \"transmute\" => (2, vec!( param(ccx, 0) ), param(ccx, 1)),\n             \"move_val_init\" => {\n                 (1u,\n                  vec!(\n                     ty::mk_mut_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)), param(ccx, 0)),\n                     param(ccx, 0u)\n                   ),\n-               ty::mk_nil())\n+               ty::mk_nil(tcx))\n             }\n             \"needs_drop\" => (1u, Vec::new(), ty::mk_bool()),\n             \"owns_managed\" => (1u, Vec::new(), ty::mk_bool()),\n@@ -5817,7 +5806,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                   }),\n                   ty::mk_uint()\n                ),\n-               ty::mk_nil())\n+               ty::mk_nil(tcx))\n             }\n             \"set_memory\" | \"volatile_set_memory\" => {\n               (1,\n@@ -5829,7 +5818,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                   ty::mk_u8(),\n                   ty::mk_uint()\n                ),\n-               ty::mk_nil())\n+               ty::mk_nil(tcx))\n             }\n             \"sqrtf32\" => (0, vec!( ty::mk_f32() ), ty::mk_f32()),\n             \"sqrtf64\" => (0, vec!( ty::mk_f64() ), ty::mk_f64()),\n@@ -5912,7 +5901,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"volatile_load\" =>\n                 (1, vec!( ty::mk_imm_ptr(tcx, param(ccx, 0)) ), param(ccx, 0)),\n             \"volatile_store\" =>\n-                (1, vec!( ty::mk_mut_ptr(tcx, param(ccx, 0)), param(ccx, 0) ), ty::mk_nil()),\n+                (1, vec!( ty::mk_mut_ptr(tcx, param(ccx, 0)), param(ccx, 0) ), ty::mk_nil(tcx)),\n \n             \"i8_add_with_overflow\" | \"i8_sub_with_overflow\" | \"i8_mul_with_overflow\" =>\n                 (0, vec!(ty::mk_i8(), ty::mk_i8()),\n@@ -5948,7 +5937,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n \n             \"return_address\" => (0, vec![], ty::mk_imm_ptr(tcx, ty::mk_u8())),\n \n-            \"assume\" => (0, vec![ty::mk_bool()], ty::mk_nil()),\n+            \"assume\" => (0, vec![ty::mk_bool()], ty::mk_nil(tcx)),\n \n             ref other => {\n                 span_err!(tcx.sess, it.span, E0093,"}, {"sha": "032b31b1f3874c572acf7b763e06d53b4f46ca7b", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -91,7 +91,6 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n                ty.repr(self.tcx));\n \n         match ty::get(ty).sty {\n-            ty::ty_nil |\n             ty::ty_bool |\n             ty::ty_char |\n             ty::ty_int(..) |"}, {"sha": "ca03e9d96e8c5414b34e8ddfd4bca0a3b3206322", "filename": "src/librustc/middle/typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -24,7 +24,7 @@ use middle::ty::get;\n use middle::ty::{ImplContainer, ImplOrTraitItemId, MethodTraitItemId};\n use middle::ty::{TypeTraitItemId, lookup_item_type};\n use middle::ty::{t, ty_bool, ty_char, ty_enum, ty_err};\n-use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_nil, ty_open};\n+use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_open};\n use middle::ty::{ty_param, Polytype, ty_ptr};\n use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n use middle::ty::{ty_uint, ty_unboxed_closure, ty_uniq, ty_bare_fn};\n@@ -82,7 +82,7 @@ fn get_base_type(inference_context: &InferCtxt,\n             Some(resolved_type)\n         }\n \n-        ty_nil | ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n+        ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n         ty_str(..) | ty_vec(..) | ty_bare_fn(..) | ty_closure(..) | ty_tup(..) |\n         ty_infer(..) | ty_param(..) | ty_err | ty_open(..) | ty_uniq(_) |\n         ty_ptr(_) | ty_rptr(_, _) => {"}, {"sha": "df25e5009c3e1af64f0e707362590858449b2b1d", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -433,7 +433,6 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<t\n         }\n \n       (&ty::ty_char, _) |\n-      (&ty::ty_nil, _) |\n       (&ty::ty_bool, _) |\n       (&ty::ty_int(_), _) |\n       (&ty::ty_uint(_), _) |"}, {"sha": "9458960156ea0be547c3d25c36e95798dee0639d", "filename": "src/librustc/middle/typeck/infer/skolemize.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -148,7 +148,6 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeSkolemizer<'a, 'tcx> {\n                 self.tcx().sess.bug(\"Cannot skolemize an open existential type\");\n             }\n \n-            ty::ty_nil |\n             ty::ty_bool |\n             ty::ty_char |\n             ty::ty_int(..) |"}, {"sha": "2c8d1ce3f4fc4d1e28286d97d948d200946d31f5", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -382,7 +382,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 sig: ty::FnSig {\n                     binder_id: main_id,\n                     inputs: Vec::new(),\n-                    output: ty::FnConverging(ty::mk_nil()),\n+                    output: ty::FnConverging(ty::mk_nil(tcx)),\n                     variadic: false\n                 }\n             });"}, {"sha": "97d7f9f18630aa0c9d2f1eab7b5230285ab3f760", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -728,7 +728,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         debug!(\"add_constraints_from_ty(ty={})\", ty.repr(self.tcx()));\n \n         match ty::get(ty).sty {\n-            ty::ty_nil | ty::ty_bool |\n+            ty::ty_bool |\n             ty::ty_char | ty::ty_int(_) | ty::ty_uint(_) |\n             ty::ty_float(_) | ty::ty_str => {\n                 /* leaf type -- noop */"}, {"sha": "bcd70510edd36e4a8dc71489d511b788a6a760b2", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d6774f39743b69c199d79a5c64dbcef58c03d3/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=08d6774f39743b69c199d79a5c64dbcef58c03d3", "patch": "@@ -19,7 +19,7 @@ use middle::ty::{ReSkolemized, ReVar, BrEnv};\n use middle::ty::{mt, t, ParamTy};\n use middle::ty::{ty_bool, ty_char, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_str, ty_vec, ty_float, ty_bare_fn, ty_closure};\n-use middle::ty::{ty_nil, ty_param, ty_ptr, ty_rptr, ty_tup, ty_open};\n+use middle::ty::{ty_param, ty_ptr, ty_rptr, ty_tup, ty_open};\n use middle::ty::{ty_unboxed_closure};\n use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_infer};\n use middle::ty;\n@@ -384,7 +384,6 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n \n     // pretty print the structural type representation:\n     match ty::get(typ).sty {\n-        ty_nil => \"()\".to_string(),\n         ty_bool => \"bool\".to_string(),\n         ty_char => \"char\".to_string(),\n         ty_int(t) => ast_util::int_ty_to_string(t, None).to_string(),"}]}