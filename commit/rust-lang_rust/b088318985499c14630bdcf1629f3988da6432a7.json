{"sha": "b088318985499c14630bdcf1629f3988da6432a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwODgzMTg5ODU0OTljMTQ2MzBiZGNmMTYyOWYzOTg4ZGE2NDMyYTc=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-05-07T06:20:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-07T06:20:25Z"}, "message": "Rollup merge of #84875 - richkadel:no-coverage-dont-check-unused, r=tmandry\n\nRemoves unneeded check of `#[no_coverage]` in mapgen\n\nThere is an anticipated feature request to support a compiler flag that\nonly adds coverage for specific files (or perhaps mods). As I thought\nabout where that change would need to be supported, I realized that\nchecking the attribute in mapgen (for unused functions) was unnecessary.\nThe unused functions are only synthesized if they have MIR coverage, and\nfunctions with the `no_coverage` attribute will not have been\ninstrumented with MIR coverage statements in the first place.\n\nNew tests confirm this.\n\nAlso, while adding tests, I updated resolved comments and FIXMEs in\nother tests, and expanded comments and tests on one remaining issue that\nis still not resolved.\n\nr? `@tmandry`\ncc: `@wesleywiser`", "tree": {"sha": "5f87921d56a99f235a530004e43d174c739036fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f87921d56a99f235a530004e43d174c739036fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b088318985499c14630bdcf1629f3988da6432a7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJglNwqCRBK7hj4Ov3rIwAAvV4IAHbBxldENKKX0dwAxLJ/bAkb\nrf2mkm1QgOm81T43FtJutpIQ+T+7hmbX6sXTiBTKNGSGWKOEIky3FZ/yVN+glPQK\nM9DztouzER3FmV5FvCOdyue7e+hgWx3fAIG66dnPwVNg4Z0VsA/dUBoC5gKzzM+4\nuit3Fd+RxfpWcR1Pu3ZWGxauPSxV/DY+VnvUOmqkpo4St4lt7SiDPH68oRUvdslW\nxWhbbKcHlZQpMLP1ZTyO+Ugck5Z6hopKl4AH3JNoNkem3lBGfvhxLgBhbIDzfKUj\nE7bf9PcQqJiTFmRjBUr8NTyp7Gaku2xUZPzRFjMKYWPs5RhUQF/3psf1Dfh5FJY=\n=ALa7\n-----END PGP SIGNATURE-----\n", "payload": "tree 5f87921d56a99f235a530004e43d174c739036fc\nparent 283ef8678461f8052d6ab74d0687c00b4f5c9f9d\nparent cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd\nauthor Yuki Okushi <jtitor@2k36.org> 1620368425 +0900\ncommitter GitHub <noreply@github.com> 1620368425 +0900\n\nRollup merge of #84875 - richkadel:no-coverage-dont-check-unused, r=tmandry\n\nRemoves unneeded check of `#[no_coverage]` in mapgen\n\nThere is an anticipated feature request to support a compiler flag that\nonly adds coverage for specific files (or perhaps mods). As I thought\nabout where that change would need to be supported, I realized that\nchecking the attribute in mapgen (for unused functions) was unnecessary.\nThe unused functions are only synthesized if they have MIR coverage, and\nfunctions with the `no_coverage` attribute will not have been\ninstrumented with MIR coverage statements in the first place.\n\nNew tests confirm this.\n\nAlso, while adding tests, I updated resolved comments and FIXMEs in\nother tests, and expanded comments and tests on one remaining issue that\nis still not resolved.\n\nr? `@tmandry`\ncc: `@wesleywiser`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b088318985499c14630bdcf1629f3988da6432a7", "html_url": "https://github.com/rust-lang/rust/commit/b088318985499c14630bdcf1629f3988da6432a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b088318985499c14630bdcf1629f3988da6432a7/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "283ef8678461f8052d6ab74d0687c00b4f5c9f9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/283ef8678461f8052d6ab74d0687c00b4f5c9f9d", "html_url": "https://github.com/rust-lang/rust/commit/283ef8678461f8052d6ab74d0687c00b4f5c9f9d"}, {"sha": "cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd", "html_url": "https://github.com/rust-lang/rust/commit/cd3a8c1b7f66f4f9109ba35534c8c7ae3a325dfd"}], "stats": {"total": 114, "additions": 56, "deletions": 58}, "files": [{"sha": "30f125ca3beaed6a90b907e121f583c792951f11", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b088318985499c14630bdcf1629f3988da6432a7/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b088318985499c14630bdcf1629f3988da6432a7/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=b088318985499c14630bdcf1629f3988da6432a7", "patch": "@@ -8,7 +8,6 @@ use rustc_codegen_ssa::traits::{ConstMethods, CoverageInfoMethods};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_hir::def_id::{DefId, DefIdSet, LOCAL_CRATE};\n use rustc_llvm::RustString;\n-use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::coverage::CodeRegion;\n use rustc_span::Symbol;\n \n@@ -281,11 +280,8 @@ fn add_unused_functions<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n \n     let mut unused_def_ids_by_file: FxHashMap<Symbol, Vec<DefId>> = FxHashMap::default();\n     for &non_codegenned_def_id in all_def_ids.difference(codegenned_def_ids) {\n-        let codegen_fn_attrs = tcx.codegen_fn_attrs(non_codegenned_def_id);\n-        if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NO_COVERAGE) {\n-            continue;\n-        }\n-        // Make sure the non-codegenned (unused) function has a file_name\n+        // Make sure the non-codegenned (unused) function has at least one MIR\n+        // `Coverage` statement with a code region, and return its file name.\n         if let Some(non_codegenned_file_name) = tcx.covered_file_name(non_codegenned_def_id) {\n             let def_ids =\n                 unused_def_ids_by_file.entry(*non_codegenned_file_name).or_insert_with(Vec::new);"}, {"sha": "322f5681b3fd9278243359047748a891ca46fe21", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.async2.txt", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b088318985499c14630bdcf1629f3988da6432a7/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async2.txt", "raw_url": "https://github.com/rust-lang/rust/raw/b088318985499c14630bdcf1629f3988da6432a7/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async2.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.async2.txt?ref=b088318985499c14630bdcf1629f3988da6432a7", "patch": "@@ -14,9 +14,9 @@\n    14|      1|    }\n    15|      1|}\n    16|       |\n-   17|       |// FIXME(#83985): The auto-generated closure in an async function is failing to include\n-   18|       |// the println!() and `let` assignment lines in the coverage code region(s), as it does in the\n-   19|       |// non-async function above, unless the `println!()` is inside a covered block.\n+   17|       |\n+   18|       |\n+   19|       |\n    20|      1|async fn async_func() {\n    21|      1|    println!(\"async_func was covered\");\n    22|      1|    let b = true;\n@@ -26,9 +26,9 @@\n                    ^0\n    26|      1|}\n    27|       |\n-   28|       |// FIXME(#83985): As above, this async function only has the `println!()` macro call, which is not\n-   29|       |// showing coverage, so the entire async closure _appears_ uncovered; but this is not exactly true.\n-   30|       |// It's only certain kinds of lines and/or their context that results in missing coverage.\n+   28|       |\n+   29|       |\n+   30|       |\n    31|      1|async fn async_func_just_println() {\n    32|      1|    println!(\"async_func_just_println was covered\");\n    33|      1|}"}, {"sha": "324b9138c4d9c10271c007767fbc080d9f061fb1", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.no_cov_crate.txt", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b088318985499c14630bdcf1629f3988da6432a7/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.no_cov_crate.txt", "raw_url": "https://github.com/rust-lang/rust/raw/b088318985499c14630bdcf1629f3988da6432a7/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.no_cov_crate.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.no_cov_crate.txt?ref=b088318985499c14630bdcf1629f3988da6432a7", "patch": "@@ -11,8 +11,27 @@\n    11|       |    println!(\"called but not covered\");\n    12|       |}\n    13|       |\n-   14|      1|fn main() {\n-   15|      1|    do_not_add_coverage_1();\n-   16|      1|    do_not_add_coverage_2();\n-   17|      1|}\n+   14|       |#[no_coverage]\n+   15|       |fn do_not_add_coverage_not_called() {\n+   16|       |    println!(\"not called and not covered\");\n+   17|       |}\n+   18|       |\n+   19|      1|fn add_coverage_1() {\n+   20|      1|    println!(\"called and covered\");\n+   21|      1|}\n+   22|       |\n+   23|      1|fn add_coverage_2() {\n+   24|      1|    println!(\"called and covered\");\n+   25|      1|}\n+   26|       |\n+   27|      0|fn add_coverage_not_called() {\n+   28|      0|    println!(\"not called but covered\");\n+   29|      0|}\n+   30|       |\n+   31|      1|fn main() {\n+   32|      1|    do_not_add_coverage_1();\n+   33|      1|    do_not_add_coverage_2();\n+   34|      1|    add_coverage_1();\n+   35|      1|    add_coverage_2();\n+   36|      1|}\n "}, {"sha": "114507dc9fd2add172507e4fbfeaa01083c792b1", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.panic_unwind.txt", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b088318985499c14630bdcf1629f3988da6432a7/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.panic_unwind.txt", "raw_url": "https://github.com/rust-lang/rust/raw/b088318985499c14630bdcf1629f3988da6432a7/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.panic_unwind.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.panic_unwind.txt?ref=b088318985499c14630bdcf1629f3988da6432a7", "patch": "@@ -29,22 +29,4 @@\n    29|       |//   2. Since the `panic_unwind.rs` test is allowed to unwind, it is also allowed to execute the\n    30|       |//      normal program exit cleanup, including writing out the current values of the coverage\n    31|       |//      counters.\n-   32|       |//   3. The coverage results show (interestingly) that the `panic!()` call did execute, but it does\n-   33|       |//      not show coverage of the `if countdown == 1` branch in `main()` that calls\n-   34|       |//      `might_panic(true)` (causing the call to `panic!()`).\n-   35|       |//   4. The reason `main()`s `if countdown == 1` branch, calling `might_panic(true)`, appears\n-   36|       |//      \"uncovered\" is, InstrumentCoverage (intentionally) treats `TerminatorKind::Call` terminators\n-   37|       |//      as non-branching, because when a program executes normally, they always are. Errors handled\n-   38|       |//      via the try `?` operator produce error handling branches that *are* treated as branches in\n-   39|       |//      coverage results. By treating calls without try `?` operators as non-branching (assumed to\n-   40|       |//      return normally and continue) the coverage graph can be simplified, producing smaller,\n-   41|       |//      faster binaries, and cleaner coverage results.\n-   42|       |//   5. The reason the coverage results actually show `panic!()` was called is most likely because\n-   43|       |//      `panic!()` is a macro, not a simple function call, and there are other `Statement`s and/or\n-   44|       |//      `Terminator`s that execute with a coverage counter before the panic and unwind occur.\n-   45|       |//   6. Since the common practice is not to use `panic!()` for error handling, the coverage\n-   46|       |//      implementation avoids incurring an additional cost (in program size and execution time) to\n-   47|       |//      improve coverage results for an event that is generally not \"supposed\" to happen.\n-   48|       |//   7. FIXME(#78544): This issue describes a feature request for a proposed option to enable\n-   49|       |//      more accurate coverage results for tests that intentionally panic.\n "}, {"sha": "959d48ce9db160540aa5fcfe86f55e9619d111f1", "filename": "src/test/run-make-fulldeps/coverage/async2.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b088318985499c14630bdcf1629f3988da6432a7/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b088318985499c14630bdcf1629f3988da6432a7/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fasync2.rs?ref=b088318985499c14630bdcf1629f3988da6432a7", "patch": "@@ -14,9 +14,9 @@ fn non_async_func() {\n     }\n }\n \n-// FIXME(#83985): The auto-generated closure in an async function is failing to include\n-// the println!() and `let` assignment lines in the coverage code region(s), as it does in the\n-// non-async function above, unless the `println!()` is inside a covered block.\n+\n+\n+\n async fn async_func() {\n     println!(\"async_func was covered\");\n     let b = true;\n@@ -25,9 +25,9 @@ async fn async_func() {\n     }\n }\n \n-// FIXME(#83985): As above, this async function only has the `println!()` macro call, which is not\n-// showing coverage, so the entire async closure _appears_ uncovered; but this is not exactly true.\n-// It's only certain kinds of lines and/or their context that results in missing coverage.\n+\n+\n+\n async fn async_func_just_println() {\n     println!(\"async_func_just_println was covered\");\n }"}, {"sha": "6f8586d9f5ca642ec63c25d8c2f99ad739e1c3c1", "filename": "src/test/run-make-fulldeps/coverage/no_cov_crate.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b088318985499c14630bdcf1629f3988da6432a7/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fno_cov_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b088318985499c14630bdcf1629f3988da6432a7/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fno_cov_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fno_cov_crate.rs?ref=b088318985499c14630bdcf1629f3988da6432a7", "patch": "@@ -11,7 +11,26 @@ fn do_not_add_coverage_2() {\n     println!(\"called but not covered\");\n }\n \n+#[no_coverage]\n+fn do_not_add_coverage_not_called() {\n+    println!(\"not called and not covered\");\n+}\n+\n+fn add_coverage_1() {\n+    println!(\"called and covered\");\n+}\n+\n+fn add_coverage_2() {\n+    println!(\"called and covered\");\n+}\n+\n+fn add_coverage_not_called() {\n+    println!(\"not called but covered\");\n+}\n+\n fn main() {\n     do_not_add_coverage_1();\n     do_not_add_coverage_2();\n+    add_coverage_1();\n+    add_coverage_2();\n }"}, {"sha": "03128c2cce6281160e6e67be0022c448825f7dc1", "filename": "src/test/run-make-fulldeps/coverage/panic_unwind.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b088318985499c14630bdcf1629f3988da6432a7/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fpanic_unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b088318985499c14630bdcf1629f3988da6432a7/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fpanic_unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fpanic_unwind.rs?ref=b088318985499c14630bdcf1629f3988da6432a7", "patch": "@@ -29,21 +29,3 @@ fn main() -> Result<(), u8> {\n //   2. Since the `panic_unwind.rs` test is allowed to unwind, it is also allowed to execute the\n //      normal program exit cleanup, including writing out the current values of the coverage\n //      counters.\n-//   3. The coverage results show (interestingly) that the `panic!()` call did execute, but it does\n-//      not show coverage of the `if countdown == 1` branch in `main()` that calls\n-//      `might_panic(true)` (causing the call to `panic!()`).\n-//   4. The reason `main()`s `if countdown == 1` branch, calling `might_panic(true)`, appears\n-//      \"uncovered\" is, InstrumentCoverage (intentionally) treats `TerminatorKind::Call` terminators\n-//      as non-branching, because when a program executes normally, they always are. Errors handled\n-//      via the try `?` operator produce error handling branches that *are* treated as branches in\n-//      coverage results. By treating calls without try `?` operators as non-branching (assumed to\n-//      return normally and continue) the coverage graph can be simplified, producing smaller,\n-//      faster binaries, and cleaner coverage results.\n-//   5. The reason the coverage results actually show `panic!()` was called is most likely because\n-//      `panic!()` is a macro, not a simple function call, and there are other `Statement`s and/or\n-//      `Terminator`s that execute with a coverage counter before the panic and unwind occur.\n-//   6. Since the common practice is not to use `panic!()` for error handling, the coverage\n-//      implementation avoids incurring an additional cost (in program size and execution time) to\n-//      improve coverage results for an event that is generally not \"supposed\" to happen.\n-//   7. FIXME(#78544): This issue describes a feature request for a proposed option to enable\n-//      more accurate coverage results for tests that intentionally panic."}]}