{"sha": "bf89b68a3702e10b18e84ef37c3aa19f13418731", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmODliNjhhMzcwMmUxMGIxOGU4NGVmMzdjM2FhMTlmMTM0MTg3MzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-20T18:16:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-20T18:16:30Z"}, "message": "auto merge of #11664 : bjz/rust/identities, r=alexcrichton\n\n`Zero` and `One` have precise definitions in mathematics as the identities of the `Add` and `Mul` operations respectively. As such, types that implement these identities are now also required to implement their respective operator traits. This should reduce their misuse whilst still enabling them to be used in generalized algebraic structures (not just numbers). Existing usages of `#[deriving(Zero)]` in client code could break under these new rules, but this is probably a sign that they should have been using something like `#[deriving(Default)]` in the first place.\r\n\r\nFor more information regarding the mathematical definitions of the additive and multiplicative identities, see the following Wikipedia articles:\r\n\r\n- http://wikipedia.org/wiki/Additive_identity\r\n- http://wikipedia.org/wiki/Multiplicative_identity\r\n\r\nNote that for floating point numbers the laws specified in the doc comments of `Zero::zero` and `One::one` may not always hold. This is true however for many other traits currently implemented by floating point numbers. What traits floating point numbers should and should not implement is an open question that is beyond the scope of this pull request.\r\n\r\nThe implementation of `std::num::pow` has been made more succinct and no longer requires `Clone`. The coverage of the associated unit test has also been increased to test for more combinations of bases, exponents, and expected results.", "tree": {"sha": "07477f37fb022086a050bfe99abcce0668f937c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07477f37fb022086a050bfe99abcce0668f937c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf89b68a3702e10b18e84ef37c3aa19f13418731", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf89b68a3702e10b18e84ef37c3aa19f13418731", "html_url": "https://github.com/rust-lang/rust/commit/bf89b68a3702e10b18e84ef37c3aa19f13418731", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf89b68a3702e10b18e84ef37c3aa19f13418731/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8efde148c05d0603f1a4ef60764c1910db20181", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8efde148c05d0603f1a4ef60764c1910db20181", "html_url": "https://github.com/rust-lang/rust/commit/f8efde148c05d0603f1a4ef60764c1910db20181"}, {"sha": "509283d149bb81cad728b2c1b81f7ab8ceb206e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/509283d149bb81cad728b2c1b81f7ab8ceb206e1", "html_url": "https://github.com/rust-lang/rust/commit/509283d149bb81cad728b2c1b81f7ab8ceb206e1"}], "stats": {"total": 309, "additions": 147, "deletions": 162}, "files": [{"sha": "02930dc9c4c6413530fcafac52679f573fc50ae7", "filename": "src/libextra/uuid.rs", "status": "modified", "additions": 14, "deletions": 31, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/bf89b68a3702e10b18e84ef37c3aa19f13418731/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf89b68a3702e10b18e84ef37c3aa19f13418731/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=bf89b68a3702e10b18e84ef37c3aa19f13418731", "patch": "@@ -57,7 +57,7 @@ Examples of string representations:\n \n use std::str;\n use std::vec;\n-use std::num::{FromStrRadix, Zero};\n+use std::num::FromStrRadix;\n use std::char::Char;\n use std::container::Container;\n use std::to_str::ToStr;\n@@ -158,9 +158,8 @@ static UuidGroupLens: [uint, ..5] = [8u, 4u, 4u, 4u, 12u];\n \n /// UUID support\n impl Uuid {\n-\n     /// Returns a nil or empty UUID (containing all zeroes)\n-    pub fn new_nil() -> Uuid {\n+    pub fn nil() -> Uuid {\n         let uuid = Uuid{ bytes: [0, .. 16] };\n         uuid\n     }\n@@ -423,24 +422,17 @@ impl Uuid {\n \n         Ok(Uuid::from_bytes(ub).unwrap())\n     }\n-}\n \n-impl Default for Uuid {\n-    /// Returns the nil UUID, which is all zeroes\n-    fn default() -> Uuid {\n-        Uuid::new_nil()\n+    /// Tests if the UUID is nil\n+    pub fn is_nil(&self) -> bool {\n+        return self.bytes.iter().all(|&b| b == 0);\n     }\n }\n \n-impl Zero for Uuid {\n+impl Default for Uuid {\n     /// Returns the nil UUID, which is all zeroes\n-    fn zero() -> Uuid {\n-        Uuid::new_nil()\n-    }\n-\n-    /// Tests if the UUID is nil or all zeroes\n-    fn is_zero(&self) -> bool {\n-        return self.bytes.iter().all(|&b| b == 0);\n+    fn default() -> Uuid {\n+        Uuid::nil()\n     }\n }\n \n@@ -521,24 +513,15 @@ mod test {\n     use super::*;\n     use std::str;\n     use std::rand;\n-    use std::num::Zero;\n     use std::io::MemWriter;\n \n     #[test]\n-    fn test_new_nil() {\n-        let nil = Uuid::new_nil();\n-        let nb = nil.to_bytes();\n-\n-        assert!(nb.iter().all(|&b| b == 0));\n-    }\n-\n-    #[test]\n-    fn test_zero() {\n-        let uz: Uuid = Zero::zero();\n-        let nz = Uuid::new_v4();\n+    fn test_nil() {\n+        let nil = Uuid::nil();\n+        let not_nil = Uuid::new_v4();\n \n-        assert!(uz.is_zero());\n-        assert!(! nz.is_zero());\n+        assert!(nil.is_nil());\n+        assert!(!not_nil.is_nil());\n     }\n \n     #[test]\n@@ -619,7 +602,7 @@ mod test {\n         assert!(Uuid::parse_string(\"urn:uuid:67e55044-10b1-426f-9247-bb680e5fe0c8\").is_ok());\n \n         // Nil\n-        let nil = Uuid::new_nil();\n+        let nil = Uuid::nil();\n         assert!(Uuid::parse_string(\"00000000000000000000000000000000\").unwrap()  == nil);\n         assert!(Uuid::parse_string(\"00000000-0000-0000-0000-000000000000\").unwrap() == nil);\n "}, {"sha": "af745f94fb519370c291ef82b6beb0fa200a5d11", "filename": "src/libstd/bool.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bf89b68a3702e10b18e84ef37c3aa19f13418731/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf89b68a3702e10b18e84ef37c3aa19f13418731/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=bf89b68a3702e10b18e84ef37c3aa19f13418731", "patch": "@@ -40,7 +40,6 @@ use num::FromPrimitive;\n #[cfg(not(test))] use cmp::{Eq, Ord, TotalOrd, Ordering};\n #[cfg(not(test))] use ops::{Not, BitAnd, BitOr, BitXor};\n #[cfg(not(test))] use default::Default;\n-#[cfg(not(test))] use num::Zero;\n \n /////////////////////////////////////////////////////////////////////////////\n // Freestanding functions\n@@ -309,12 +308,6 @@ impl Default for bool {\n     fn default() -> bool { false }\n }\n \n-#[cfg(not(test))]\n-impl Zero for bool {\n-    fn zero() -> bool { false }\n-    fn is_zero(&self) -> bool { *self == false }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::*;"}, {"sha": "71a297d71765e2f24b944fadd7d87e1d4e1c9c39", "filename": "src/libstd/char.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bf89b68a3702e10b18e84ef37c3aa19f13418731/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf89b68a3702e10b18e84ef37c3aa19f13418731/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=bf89b68a3702e10b18e84ef37c3aa19f13418731", "patch": "@@ -22,7 +22,6 @@ use str;\n \n #[cfg(not(test))] use cmp::{Eq, Ord};\n #[cfg(not(test))] use default::Default;\n-#[cfg(not(test))] use num::Zero;\n \n // UTF-8 ranges and tags for encoding characters\n static TAG_CONT: uint = 128u;\n@@ -449,15 +448,6 @@ impl Default for char {\n     fn default() -> char { '\\x00' }\n }\n \n-#[cfg(not(test))]\n-impl Zero for char {\n-    #[inline]\n-    fn zero() -> char { '\\x00' }\n-\n-    #[inline]\n-    fn is_zero(&self) -> bool { *self == '\\x00' }\n-}\n-\n #[test]\n fn test_is_lowercase() {\n     assert!('a'.is_lowercase());"}, {"sha": "8081c6ed8db51cad0937c5d10ac9edce6afdc633", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf89b68a3702e10b18e84ef37c3aa19f13418731/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf89b68a3702e10b18e84ef37c3aa19f13418731/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=bf89b68a3702e10b18e84ef37c3aa19f13418731", "patch": "@@ -2872,6 +2872,12 @@ mod tests {\n             }\n         }\n \n+        impl Mul<Foo, Foo> for Foo {\n+            fn mul(&self, _: &Foo) -> Foo {\n+                Foo\n+            }\n+        }\n+\n         impl num::One for Foo {\n             fn one() -> Foo {\n                 Foo"}, {"sha": "34dd313d4421f12a6a6d453c434ffa0e67c8f1f9", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 76, "deletions": 58, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/bf89b68a3702e10b18e84ef37c3aa19f13418731/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf89b68a3702e10b18e84ef37c3aa19f13418731/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=bf89b68a3702e10b18e84ef37c3aa19f13418731", "patch": "@@ -50,19 +50,59 @@ pub trait Orderable: Ord {\n /// Returns the number constrained within the range `mn <= self <= mx`.\n #[inline(always)] pub fn clamp<T: Orderable>(value: T, mn: T, mx: T) -> T { value.clamp(&mn, &mx) }\n \n-pub trait Zero {\n-    fn zero() -> Self;      // FIXME (#5527): This should be an associated constant\n+/// Defines an additive identity element for `Self`.\n+///\n+/// # Deriving\n+///\n+/// This trait can be automatically be derived using `#[deriving(Zero)]`\n+/// attribute. If you choose to use this, make sure that the laws outlined in\n+/// the documentation for `Zero::zero` still hold.\n+pub trait Zero: Add<Self, Self> {\n+    /// Returns the additive identity element of `Self`, `0`.\n+    ///\n+    /// # Laws\n+    ///\n+    /// ~~~\n+    /// a + 0 = a       \u2200 a \u2208 Self\n+    /// 0 + a = a       \u2200 a \u2208 Self\n+    /// ~~~\n+    ///\n+    /// # Purity\n+    ///\n+    /// This function should return the same result at all times regardless of\n+    /// external mutable state, for example values stored in TLS or in\n+    /// `static mut`s.\n+    // FIXME (#5527): This should be an associated constant\n+    fn zero() -> Self;\n+\n+    /// Returns `true` if `self` is equal to the additive identity.\n     fn is_zero(&self) -> bool;\n }\n \n-/// Returns `0` of appropriate type.\n+/// Returns the additive identity, `0`.\n #[inline(always)] pub fn zero<T: Zero>() -> T { Zero::zero() }\n \n-pub trait One {\n-    fn one() -> Self;       // FIXME (#5527): This should be an associated constant\n+/// Defines a multiplicative identity element for `Self`.\n+pub trait One: Mul<Self, Self> {\n+    /// Returns the multiplicative identity element of `Self`, `1`.\n+    ///\n+    /// # Laws\n+    ///\n+    /// ~~~\n+    /// a * 1 = a       \u2200 a \u2208 Self\n+    /// 1 * a = a       \u2200 a \u2208 Self\n+    /// ~~~\n+    ///\n+    /// # Purity\n+    ///\n+    /// This function should return the same result at all times regardless of\n+    /// external mutable state, for example values stored in TLS or in\n+    /// `static mut`s.\n+    // FIXME (#5527): This should be an associated constant\n+    fn one() -> Self;\n }\n \n-/// Returns `1` of appropriate type.\n+/// Returns the multiplicative identity, `1`.\n #[inline(always)] pub fn one<T: One>() -> T { One::one() }\n \n pub trait Signed: Num\n@@ -264,48 +304,29 @@ pub trait Real: Signed\n     fn to_radians(&self) -> Self;\n }\n \n-/// Raises a value to the power of exp, using\n-/// exponentiation by squaring.\n+/// Raises a value to the power of exp, using exponentiation by squaring.\n ///\n /// # Example\n ///\n /// ```rust\n /// use std::num;\n ///\n-/// let sixteen = num::pow(2, 4u);\n-/// assert_eq!(sixteen, 16);\n+/// assert_eq!(num::pow(2, 4), 16);\n /// ```\n #[inline]\n-pub fn pow<T: Clone+One+Mul<T, T>>(num: T, exp: uint) -> T {\n-    let one: uint = One::one();\n-    let num_one: T = One::one();\n-\n-    if exp.is_zero() { return num_one; }\n-    if exp == one { return num.clone(); }\n-\n-    let mut i: uint = exp;\n-    let mut v: T;\n-    let mut r: T = num_one;\n-\n-    // This if is to avoid cloning self.\n-    if (i & one) == one {\n-        r = r * num;\n-        i = i - one;\n-    }\n-\n-    i = i >> one;\n-    v = num * num;\n-\n-    while !i.is_zero() {\n-        if (i & one) == one {\n-            r = r * v;\n-            i = i - one;\n+pub fn pow<T: One + Mul<T, T>>(mut base: T, mut exp: uint) -> T {\n+    if exp == 1 { base }\n+    else {\n+        let mut acc = one::<T>();\n+        while exp > 0 {\n+            if (exp & 1) == 1 {\n+                acc = acc * base;\n+            }\n+            base = base * base;\n+            exp = exp >> 1;\n         }\n-        i = i >> one;\n-        v = v * v;\n+        acc\n     }\n-\n-    r\n }\n \n /// Raise a number to a power.\n@@ -993,16 +1014,6 @@ pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint) -> Option<T> {\n     FromStrRadix::from_str_radix(str, radix)\n }\n \n-impl<T: Zero + 'static> Zero for @T {\n-    fn zero() -> @T { @Zero::zero() }\n-    fn is_zero(&self) -> bool { (**self).is_zero() }\n-}\n-\n-impl<T: Zero> Zero for ~T {\n-    fn zero() -> ~T { ~Zero::zero() }\n-    fn is_zero(&self) -> bool { (**self).is_zero() }\n-}\n-\n /// Saturating math operations\n pub trait Saturating {\n     /// Saturating addition operator.\n@@ -1640,17 +1651,24 @@ mod tests {\n \n     #[test]\n     fn test_pow() {\n-        fn assert_pow<T: Eq+Clone+One+Mul<T, T>>(num: T, exp: uint) -> () {\n-            assert_eq!(num::pow(num.clone(), exp),\n-                       range(1u, exp).fold(num.clone(), |acc, _| acc * num));\n+        fn naive_pow<T: One + Mul<T, T>>(base: T, exp: uint) -> T {\n+            range(0, exp).fold(one::<T>(), |acc, _| acc * base)\n         }\n-\n-        assert_eq!(num::pow(3, 0), 1);\n-        assert_eq!(num::pow(5, 1), 5);\n-        assert_pow(-4, 2);\n-        assert_pow(8, 3);\n-        assert_pow(8, 5);\n-        assert_pow(2u64, 50);\n+        macro_rules! assert_pow(\n+            (($num:expr, $exp:expr) => $expected:expr) => {{\n+                let result = pow($num, $exp);\n+                assert_eq!(result, $expected);\n+                assert_eq!(result, naive_pow($num, $exp));\n+            }}\n+        )\n+        assert_pow!((3,    0 ) => 1);\n+        assert_pow!((5,    1 ) => 5);\n+        assert_pow!((-4,   2 ) => 16);\n+        assert_pow!((0.5,  5 ) => 0.03125);\n+        assert_pow!((8,    3 ) => 512);\n+        assert_pow!((8.0,  5 ) => 32768.0);\n+        assert_pow!((8.5,  5 ) => 44370.53125);\n+        assert_pow!((2u64, 50) => 1125899906842624);\n     }\n }\n "}, {"sha": "8e278aeb2eab557630aa5b861403d3ba3e43bb02", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bf89b68a3702e10b18e84ef37c3aa19f13418731/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf89b68a3702e10b18e84ef37c3aa19f13418731/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=bf89b68a3702e10b18e84ef37c3aa19f13418731", "patch": "@@ -15,7 +15,6 @@\n use clone::Clone;\n #[cfg(not(test))] use cmp::*;\n #[cfg(not(test))] use default::Default;\n-#[cfg(not(test))] use num::Zero;\n \n /// Method extensions to pairs where both types satisfy the `Clone` bound\n pub trait CopyableTuple<T, U> {\n@@ -177,18 +176,6 @@ macro_rules! tuple_impls {\n                     ($({ let x: $T = Default::default(); x},)+)\n                 }\n             }\n-\n-            #[cfg(not(test))]\n-            impl<$($T:Zero),+> Zero for ($($T,)+) {\n-                #[inline]\n-                fn zero() -> ($($T,)+) {\n-                    ($({ let x: $T = Zero::zero(); x},)+)\n-                }\n-                #[inline]\n-                fn is_zero(&self) -> bool {\n-                    $(self.$get_ref_fn().is_zero())&&+\n-                }\n-            }\n         )+\n     }\n }"}, {"sha": "786a7f42bb394c72998d8941e817c671eb0ef199", "filename": "src/libstd/unit.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bf89b68a3702e10b18e84ef37c3aa19f13418731/src%2Flibstd%2Funit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf89b68a3702e10b18e84ef37c3aa19f13418731/src%2Flibstd%2Funit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funit.rs?ref=bf89b68a3702e10b18e84ef37c3aa19f13418731", "patch": "@@ -12,8 +12,6 @@\n \n #[cfg(not(test))]\n use prelude::*;\n-#[cfg(not(test))]\n-use num::Zero;\n \n #[cfg(not(test))]\n impl Eq for () {\n@@ -46,11 +44,3 @@ impl Default for () {\n     #[inline]\n     fn default() -> () { () }\n }\n-\n-#[cfg(not(test))]\n-impl Zero for () {\n-    #[inline]\n-    fn zero() -> () { () }\n-    #[inline]\n-    fn is_zero(&self) -> bool { true }\n-}"}, {"sha": "9ae72038aa9d9fc13fac13c00e2a9555b56464fa", "filename": "src/test/run-pass/deriving-zero.rs", "status": "modified", "additions": 42, "deletions": 19, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/bf89b68a3702e10b18e84ef37c3aa19f13418731/src%2Ftest%2Frun-pass%2Fderiving-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf89b68a3702e10b18e84ef37c3aa19f13418731/src%2Ftest%2Frun-pass%2Fderiving-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-zero.rs?ref=bf89b68a3702e10b18e84ef37c3aa19f13418731", "patch": "@@ -10,32 +10,55 @@\n \n #[feature(managed_boxes)];\n \n-use std::util;\n use std::num::Zero;\n \n #[deriving(Zero)]\n-struct A;\n-#[deriving(Zero)]\n-struct B(int);\n-#[deriving(Zero)]\n-struct C(int, int);\n-#[deriving(Zero)]\n-struct D { a: int }\n+struct Vector2<T>(T, T);\n+\n+impl<T: Add<T, T>> Add<Vector2<T>, Vector2<T>> for Vector2<T> {\n+    fn add(&self, other: &Vector2<T>) -> Vector2<T> {\n+        match (self, other) {\n+            (&Vector2(ref x0, ref y0), &Vector2(ref x1, ref y1)) => {\n+                Vector2(*x0 + *x1, *y0 + *y1)\n+            }\n+        }\n+    }\n+}\n+\n #[deriving(Zero)]\n-struct E { a: int, b: int }\n+struct Vector3<T> {\n+    x: T, y: T, z: T,\n+}\n+\n+impl<T: Add<T, T>> Add<Vector3<T>, Vector3<T>> for Vector3<T> {\n+    fn add(&self, other: &Vector3<T>) -> Vector3<T> {\n+        Vector3 {\n+            x: self.x + other.x,\n+            y: self.y + other.y,\n+            z: self.z + other.z,\n+        }\n+    }\n+}\n \n #[deriving(Zero)]\n-struct Lots {\n-    d: u8,\n-    e: char,\n-    f: f64,\n-    g: (f32, char),\n-    h: @(int, int),\n-    i: bool,\n-    j: (),\n+struct Matrix3x2<T> {\n+    x: Vector2<T>,\n+    y: Vector2<T>,\n+    z: Vector2<T>,\n+}\n+\n+impl<T: Add<T, T>> Add<Matrix3x2<T>, Matrix3x2<T>> for Matrix3x2<T> {\n+    fn add(&self, other: &Matrix3x2<T>) -> Matrix3x2<T> {\n+        Matrix3x2 {\n+            x: self.x + other.x,\n+            y: self.y + other.y,\n+            z: self.z + other.z,\n+        }\n+    }\n }\n \n pub fn main() {\n-    let lots: Lots = Zero::zero();\n-    assert!(lots.is_zero());\n+    let _: Vector2<int> = Zero::zero();\n+    let _: Vector3<f64> = Zero::zero();\n+    let _: Matrix3x2<u8> = Zero::zero();\n }"}, {"sha": "25293c4dd1beac402a77ca6e92c094fcc12d887a", "filename": "src/test/run-pass/issue-5554.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bf89b68a3702e10b18e84ef37c3aa19f13418731/src%2Ftest%2Frun-pass%2Fissue-5554.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf89b68a3702e10b18e84ef37c3aa19f13418731/src%2Ftest%2Frun-pass%2Fissue-5554.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5554.rs?ref=bf89b68a3702e10b18e84ef37c3aa19f13418731", "patch": "@@ -10,30 +10,25 @@\n \n #[feature(macro_rules)];\n \n-use std::num::Zero;\n+use std::default::Default;\n \n pub struct X<T> {\n-  a: T\n+    a: T,\n }\n \n // reordering these bounds stops the ICE\n-impl<T: Zero + Eq + Zero>\n-  Zero for X<T> {\n-    fn zero() -> X<T> {\n-      X { a: Zero::zero() }\n-    }\n-    fn is_zero(&self) -> bool {\n-        self.a.is_zero()\n+impl<T: Default + Eq + Default> Default for X<T> {\n+    fn default() -> X<T> {\n+        X { a: Default::default() }\n     }\n }\n \n macro_rules! constants {\n-  () => {\n-    let _0 : X<int> = Zero::zero();\n-   }\n+    () => {\n+        let _ : X<int> = Default::default();\n+    }\n }\n \n-\n pub fn main() {\n-  constants!();\n+    constants!();\n }"}]}