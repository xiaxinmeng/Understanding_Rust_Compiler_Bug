{"sha": "870aea216bb6f6d6a238c03e186a01bff8820ac0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3MGFlYTIxNmJiNmY2ZDZhMjM4YzAzZTE4NmEwMWJmZjg4MjBhYzA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-01T11:07:52Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-01T11:13:07Z"}, "message": "Do not ICE when e.g. `call_mut()` is called on a closure whose kind is not yet known.", "tree": {"sha": "f08391834ca664acfdf63857915896fe2c90a9da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f08391834ca664acfdf63857915896fe2c90a9da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/870aea216bb6f6d6a238c03e186a01bff8820ac0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/870aea216bb6f6d6a238c03e186a01bff8820ac0", "html_url": "https://github.com/rust-lang/rust/commit/870aea216bb6f6d6a238c03e186a01bff8820ac0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/870aea216bb6f6d6a238c03e186a01bff8820ac0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9c3841a501691f36f98c47402d679885989637f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9c3841a501691f36f98c47402d679885989637f", "html_url": "https://github.com/rust-lang/rust/commit/a9c3841a501691f36f98c47402d679885989637f"}], "stats": {"total": 105, "additions": 77, "deletions": 28}, "files": [{"sha": "88455b3385a1e10a7fb98a855912850407850a46", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/870aea216bb6f6d6a238c03e186a01bff8820ac0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/870aea216bb6f6d6a238c03e186a01bff8820ac0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=870aea216bb6f6d6a238c03e186a01bff8820ac0", "patch": "@@ -44,6 +44,9 @@ pub enum MethodError {\n \n     // Multiple methods might apply.\n     Ambiguity(Vec<CandidateSource>),\n+\n+    // Using a `Fn`/`FnMut`/etc method on a raw closure type before we have inferred its kind.\n+    ClosureAmbiguity(/* DefId of fn trait */ ast::DefId),\n }\n \n // A pared down enum describing just the places from which a method\n@@ -65,9 +68,10 @@ pub fn exists<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         -> bool\n {\n     match probe::probe(fcx, span, method_name, self_ty, call_expr_id) {\n-        Ok(_) => true,\n-        Err(NoMatch(_, _)) => false,\n-        Err(Ambiguity(_)) => true,\n+        Ok(..) => true,\n+        Err(NoMatch(..)) => false,\n+        Err(Ambiguity(..)) => true,\n+        Err(ClosureAmbiguity(..)) => true,\n     }\n }\n "}, {"sha": "e9ea0921bc9e83dac2399e0d0c959c8c56e0e4a0", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 36, "deletions": 24, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/870aea216bb6f6d6a238c03e186a01bff8820ac0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/870aea216bb6f6d6a238c03e186a01bff8820ac0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=870aea216bb6f6d6a238c03e186a01bff8820ac0", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::{MethodError,Ambiguity,NoMatch};\n+use super::{MethodError};\n use super::MethodIndex;\n use super::{CandidateSource,ImplSource,TraitSource};\n use super::suggest;\n@@ -129,7 +129,7 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // take place in the `fcx.infcx().probe` below.\n     let steps = match create_steps(fcx, span, self_ty) {\n         Some(steps) => steps,\n-        None => return Err(NoMatch(Vec::new(), Vec::new())),\n+        None => return Err(MethodError::NoMatch(Vec::new(), Vec::new())),\n     };\n \n     // Create a list of simplified self types, if we can.\n@@ -158,7 +158,7 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         let (steps, opt_simplified_steps) = dummy.take().unwrap();\n         let mut probe_cx = ProbeContext::new(fcx, span, method_name, steps, opt_simplified_steps);\n         probe_cx.assemble_inherent_candidates();\n-        probe_cx.assemble_extension_candidates_for_traits_in_scope(call_expr_id);\n+        try!(probe_cx.assemble_extension_candidates_for_traits_in_scope(call_expr_id));\n         probe_cx.pick()\n     })\n }\n@@ -444,29 +444,34 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_extension_candidates_for_traits_in_scope(&mut self,\n                                                          expr_id: ast::NodeId)\n+                                                         -> Result<(),MethodError>\n     {\n         let mut duplicates = HashSet::new();\n         let opt_applicable_traits = self.fcx.ccx.trait_map.get(&expr_id);\n         for applicable_traits in opt_applicable_traits.into_iter() {\n             for &trait_did in applicable_traits.iter() {\n                 if duplicates.insert(trait_did) {\n-                    self.assemble_extension_candidates_for_trait(trait_did);\n+                    try!(self.assemble_extension_candidates_for_trait(trait_did));\n                 }\n             }\n         }\n+        Ok(())\n     }\n \n-    fn assemble_extension_candidates_for_all_traits(&mut self) {\n+    fn assemble_extension_candidates_for_all_traits(&mut self) -> Result<(),MethodError> {\n         let mut duplicates = HashSet::new();\n         for trait_info in suggest::all_traits(self.fcx.ccx) {\n             if duplicates.insert(trait_info.def_id) {\n-                self.assemble_extension_candidates_for_trait(trait_info.def_id)\n+                try!(self.assemble_extension_candidates_for_trait(trait_info.def_id));\n             }\n         }\n+        Ok(())\n     }\n \n     fn assemble_extension_candidates_for_trait(&mut self,\n-                                               trait_def_id: ast::DefId) {\n+                                               trait_def_id: ast::DefId)\n+                                               -> Result<(),MethodError>\n+    {\n         debug!(\"assemble_extension_candidates_for_trait(trait_def_id={})\",\n                trait_def_id.repr(self.tcx()));\n \n@@ -478,26 +483,27 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                        .position(|item| item.name() == self.method_name);\n         let matching_index = match matching_index {\n             Some(i) => i,\n-            None => { return; }\n+            None => { return Ok(()); }\n         };\n         let method = match (&*trait_items)[matching_index].as_opt_method() {\n             Some(m) => m,\n-            None => { return; }\n+            None => { return Ok(()); }\n         };\n \n         // Check whether `trait_def_id` defines a method with suitable name:\n         if !self.has_applicable_self(&*method) {\n             debug!(\"method has inapplicable self\");\n-            return self.record_static_candidate(TraitSource(trait_def_id));\n+            self.record_static_candidate(TraitSource(trait_def_id));\n+            return Ok(());\n         }\n \n         self.assemble_extension_candidates_for_trait_impls(trait_def_id,\n                                                            method.clone(),\n                                                            matching_index);\n \n-        self.assemble_closure_candidates(trait_def_id,\n-                                         method.clone(),\n-                                         matching_index);\n+        try!(self.assemble_closure_candidates(trait_def_id,\n+                                              method.clone(),\n+                                              matching_index));\n \n         self.assemble_projection_candidates(trait_def_id,\n                                             method.clone(),\n@@ -506,6 +512,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         self.assemble_where_clause_candidates(trait_def_id,\n                                               method,\n                                               matching_index);\n+\n+        Ok(())\n     }\n \n     fn assemble_extension_candidates_for_trait_impls(&mut self,\n@@ -576,6 +584,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                    trait_def_id: ast::DefId,\n                                    method_ty: Rc<ty::Method<'tcx>>,\n                                    method_index: uint)\n+                                   -> Result<(),MethodError>\n     {\n         // Check if this is one of the Fn,FnMut,FnOnce traits.\n         let tcx = self.tcx();\n@@ -586,7 +595,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         } else if Some(trait_def_id) == tcx.lang_items.fn_once_trait() {\n             ty::FnOnceClosureKind\n         } else {\n-            return;\n+            return Ok(());\n         };\n \n         // Check if there is an unboxed-closure self-type in the list of receivers.\n@@ -602,10 +611,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             let closure_kind = match closure_kinds.get(&closure_def_id) {\n                 Some(&k) => k,\n                 None => {\n-                    self.tcx().sess.span_bug(\n-                        self.span,\n-                        &format!(\"No entry for closure: {}\",\n-                                closure_def_id.repr(self.tcx()))[]);\n+                    return Err(MethodError::ClosureAmbiguity(trait_def_id));\n                 }\n             };\n \n@@ -630,6 +636,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 kind: ClosureCandidate(trait_def_id, method_index)\n             });\n         }\n+\n+        Ok(())\n     }\n \n     fn assemble_projection_candidates(&mut self,\n@@ -735,11 +743,11 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         let span = self.span;\n         let tcx = self.tcx();\n \n-        self.assemble_extension_candidates_for_all_traits();\n+        try!(self.assemble_extension_candidates_for_all_traits());\n \n         let out_of_scope_traits = match self.pick_core() {\n             Some(Ok(p)) => vec![p.method_ty.container.id()],\n-            Some(Err(Ambiguity(v))) => v.into_iter().map(|source| {\n+            Some(Err(MethodError::Ambiguity(v))) => v.into_iter().map(|source| {\n                 match source {\n                     TraitSource(id) => id,\n                     ImplSource(impl_id) => {\n@@ -752,14 +760,18 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                     }\n                 }\n             }).collect(),\n-            Some(Err(NoMatch(_, others))) => {\n+            Some(Err(MethodError::NoMatch(_, others))) => {\n                 assert!(others.is_empty());\n                 vec![]\n             }\n+            Some(Err(MethodError::ClosureAmbiguity(..))) => {\n+                // this error only occurs when assembling candidates\n+                tcx.sess.span_bug(span, \"encountered ClosureAmbiguity from pick_core\");\n+            }\n             None => vec![],\n         };\n-;\n-        Err(NoMatch(static_candidates, out_of_scope_traits))\n+\n+        Err(MethodError::NoMatch(static_candidates, out_of_scope_traits))\n     }\n \n     fn pick_core(&mut self) -> Option<PickResult<'tcx>> {\n@@ -895,7 +907,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         if applicable_candidates.len() > 1 {\n             let sources = probes.iter().map(|p| p.to_source()).collect();\n-            return Some(Err(Ambiguity(sources)));\n+            return Some(Err(MethodError::Ambiguity(sources)));\n         }\n \n         applicable_candidates.pop().map(|probe| {"}, {"sha": "bd5060c940e5025505e5ec8d4fe9c0700f211c88", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/870aea216bb6f6d6a238c03e186a01bff8820ac0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/870aea216bb6f6d6a238c03e186a01bff8820ac0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=870aea216bb6f6d6a238c03e186a01bff8820ac0", "patch": "@@ -22,6 +22,7 @@ use util::ppaux::UserString;\n \n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n+use syntax::print::pprust;\n \n use std::cell;\n use std::cmp::Ordering;\n@@ -32,6 +33,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                               span: Span,\n                               rcvr_ty: Ty<'tcx>,\n                               method_name: ast::Name,\n+                              callee_expr: &ast::Expr,\n                               error: MethodError)\n {\n     match error {\n@@ -84,6 +86,18 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n             report_candidates(fcx, span, method_name, sources);\n         }\n+\n+        MethodError::ClosureAmbiguity(trait_def_id) => {\n+            fcx.sess().span_err(\n+                span,\n+                &*format!(\"the `{}` method from the `{}` trait cannot be explicitly \\\n+                           invoked on this closure as we have not yet inferred what \\\n+                           kind of closure it is; use overloaded call notation instead \\\n+                           (e.g., `{}()`)\",\n+                          method_name.user_string(fcx.tcx()),\n+                          ty::item_path_str(fcx.tcx(), trait_def_id),\n+                          pprust::expr_to_string(callee_expr)));\n+        }\n     }\n \n     fn report_candidates(fcx: &FnCtxt,"}, {"sha": "c193e1ef48364814aa247428310927f3d0e9df24", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/870aea216bb6f6d6a238c03e186a01bff8820ac0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/870aea216bb6f6d6a238c03e186a01bff8820ac0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=870aea216bb6f6d6a238c03e186a01bff8820ac0", "patch": "@@ -2695,7 +2695,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 method_ty\n             }\n             Err(error) => {\n-                method::report_error(fcx, method_name.span, expr_t, method_name.node.name, error);\n+                method::report_error(fcx, method_name.span, expr_t,\n+                                     method_name.node.name, rcvr, error);\n                 fcx.write_error(expr.id);\n                 fcx.tcx().types.err\n             }"}, {"sha": "f993b8fa8c4d1ec92ade3857b6c6c7227a23170e", "filename": "src/test/compile-fail/unboxed-closures-infer-explicit-call-too-early.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/870aea216bb6f6d6a238c03e186a01bff8820ac0/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-explicit-call-too-early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/870aea216bb6f6d6a238c03e186a01bff8820ac0/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-explicit-call-too-early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-infer-explicit-call-too-early.rs?ref=870aea216bb6f6d6a238c03e186a01bff8820ac0", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+fn main() {\n+    let mut zero = || {};\n+    let () = zero.call_mut(());\n+    //~^ ERROR we have not yet inferred what kind of closure it is\n+}\n+"}]}