{"sha": "d529757515671d5826d8d2203ce0a4f82a3bdee5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1Mjk3NTc1MTU2NzFkNTgyNmQ4ZDIyMDNjZTBhNGY4MmEzYmRlZTU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-16T10:37:38Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-16T12:47:48Z"}, "message": "Make polymorphic impl methods work\n\nSomething will still have to be done to the AST to make it possible to\nsay `x.foo::<int>()`, since currently field access never allows type\nparameters.\n\nIssue #1227", "tree": {"sha": "1886bd880e0e912f1d962cd9a1fd1a0035634c66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1886bd880e0e912f1d962cd9a1fd1a0035634c66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d529757515671d5826d8d2203ce0a4f82a3bdee5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d529757515671d5826d8d2203ce0a4f82a3bdee5", "html_url": "https://github.com/rust-lang/rust/commit/d529757515671d5826d8d2203ce0a4f82a3bdee5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d529757515671d5826d8d2203ce0a4f82a3bdee5/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cff6bdd03616b6f20028ec8568d03363ccc3f9f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/cff6bdd03616b6f20028ec8568d03363ccc3f9f2", "html_url": "https://github.com/rust-lang/rust/commit/cff6bdd03616b6f20028ec8568d03363ccc3f9f2"}], "stats": {"total": 138, "additions": 82, "deletions": 56}, "files": [{"sha": "9fdba389c2445a461a03183b2c79fb2ad4da0404", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d529757515671d5826d8d2203ce0a4f82a3bdee5/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d529757515671d5826d8d2203ce0a4f82a3bdee5/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=d529757515671d5826d8d2203ce0a4f82a3bdee5", "patch": "@@ -751,10 +751,11 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n               ast::item_obj(ob, ty_params, _) {\n                 ret lookup_in_obj(name, ob, ty_params, ns, it.id);\n               }\n-              ast::item_impl(_, _, _) {\n+              ast::item_impl(ty_params, _, _) {\n                 if (name == \"self\" && ns == ns_value) {\n                     ret some(ast::def_self(local_def(it.id)));\n                 }\n+                if ns == ns_type { ret lookup_in_ty_params(name, ty_params); }\n               }\n               ast::item_tag(_, ty_params) {\n                 if ns == ns_type { ret lookup_in_ty_params(name, ty_params); }"}, {"sha": "37e35ee3efa7b114d82829581e2cd6f83733a60f", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d529757515671d5826d8d2203ce0a4f82a3bdee5/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d529757515671d5826d8d2203ce0a4f82a3bdee5/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=d529757515671d5826d8d2203ce0a4f82a3bdee5", "patch": "@@ -4353,15 +4353,19 @@ fn create_llargs_for_fn_args(cx: @fn_ctxt, ty_self: self_arg,\n     // way.\n     let arg_n = 2u;\n     alt ty_self {\n-      obj_self(tt) | impl_self(tt) { cx.llself = some({v: cx.llenv, t: tt}); }\n-      no_self. {\n-        let i = 0u;\n-        for tp: ast::ty_param in ty_params {\n+      obj_self(tt) | impl_self(tt) {\n+        cx.llself = some({v: cx.llenv, t: tt});\n+      }\n+      no_self. {}\n+    }\n+    alt ty_self {\n+      obj_self(_) {}\n+      _ {\n+        for tp in ty_params {\n             let llarg = llvm::LLVMGetParam(cx.llfn, arg_n);\n             assert (llarg as int != 0);\n             cx.lltydescs += [llarg];\n             arg_n += 1u;\n-            i += 1u;\n         }\n       }\n     }\n@@ -4659,14 +4663,14 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n }\n \n fn trans_impl(cx: @local_ctxt, name: ast::ident, methods: [@ast::method],\n-              id: ast::node_id) {\n+              id: ast::node_id, tps: [ast::ty_param]) {\n     let sub_cx = extend_path(cx, name);\n     for m in methods {\n         alt cx.ccx.item_ids.find(m.node.id) {\n           some(llfn) {\n             trans_fn(extend_path(sub_cx, m.node.ident), m.span, m.node.meth,\n                      llfn, impl_self(ty::node_id_to_monotype(cx.ccx.tcx, id)),\n-                     [], m.node.id);\n+                     tps + m.node.tps, m.node.id);\n           }\n         }\n     }\n@@ -4980,7 +4984,9 @@ fn trans_item(cx: @local_ctxt, item: ast::item) {\n                  with *extend_path(cx, item.ident)};\n         trans_obj(sub_cx, item.span, ob, ctor_id, tps);\n       }\n-      ast::item_impl(_, _, ms) { trans_impl(cx, item.ident, ms, item.id); }\n+      ast::item_impl(tps, _, ms) {\n+        trans_impl(cx, item.ident, ms, item.id, tps);\n+      }\n       ast::item_res(dtor, dtor_id, tps, ctor_id) {\n         trans_res_ctor(cx, item.span, dtor, ctor_id, tps);\n \n@@ -5304,11 +5310,11 @@ fn collect_item_2(ccx: @crate_ctxt, i: @ast::item, &&pt: [str],\n             ccx.obj_methods.insert(m.node.id, ());\n         }\n       }\n-      ast::item_impl(_, _, methods) {\n+      ast::item_impl(tps, _, methods) {\n         let name = ccx.names.next(i.ident);\n         for m in methods {\n             register_fn(ccx, i.span, pt + [name, m.node.ident],\n-                        \"impl_method\", [], m.node.id);\n+                        \"impl_method\", tps + m.node.tps, m.node.id);\n         }\n       }\n       ast::item_res(_, dtor_id, tps, ctor_id) {"}, {"sha": "d86215a14c05f4eca1fc0060a09e5f562c16ccaf", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 49, "deletions": 32, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d529757515671d5826d8d2203ce0a4f82a3bdee5/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d529757515671d5826d8d2203ce0a4f82a3bdee5/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=d529757515671d5826d8d2203ce0a4f82a3bdee5", "patch": "@@ -962,8 +962,7 @@ mod writeback {\n                                   typ) {\n           fix_ok(new_type) { ret some(new_type); }\n           fix_err(vid) {\n-            fcx.ccx.tcx.sess.span_err(sp,\n-                                      \"cannot determine a type \\\n+            fcx.ccx.tcx.sess.span_err(sp, \"cannot determine a type \\\n                                            for this expression\");\n             ret none;\n           }\n@@ -1461,6 +1460,42 @@ fn check_expr_with(fcx: @fn_ctxt, expr: @ast::expr, expected: ty::t) -> bool {\n     ret check_expr_with_unifier(fcx, expr, demand::simple, expected);\n }\n \n+// FIXME[impl] notice/resolve conflicts\n+fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n+                 name: ast::ident, ty: ty::t)\n+    -> option::t<{method: @ast::method, ids: [int]}> {\n+    let result = none;\n+    std::list::iter(isc) {|impls|\n+        for im in *impls {\n+            alt im.node {\n+              ast::item_impl(tps, slf, mthds) {\n+                let self_ty = ast_ty_to_ty_crate(fcx.ccx, slf);\n+                let tp_count = vec::len(tps);\n+                let {ids, ty: self_ty} = if tp_count > 0u {\n+                    bind_params_in_type(ast_util::dummy_sp(), fcx.ccx.tcx,\n+                                        bind next_ty_var_id(fcx), self_ty,\n+                                        tp_count)\n+                } else { {ids: [], ty: self_ty} };\n+                // FIXME[impl] Don't unify in the current fcx, use\n+                // scratch context\n+                alt unify::unify(fcx, ty, self_ty) {\n+                  ures_ok(_) {\n+                    for m in mthds {\n+                        if m.node.ident == name {\n+                            result = some({method: m, ids: ids});\n+                            ret;\n+                        }\n+                    }\n+                  }\n+                  _ {}\n+                }\n+              }\n+            }\n+        }\n+    }\n+    result\n+}\n+\n fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                            expected: ty::t) -> bool {\n     //log_err \"typechecking expr \" + syntax::print::pprust::expr_to_str(expr);\n@@ -2089,42 +2124,24 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         }\n       }\n       ast::expr_field(base, field) {\n-        // FIXME proper type compare, notice conflicts\n-        fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n-                         name: ast::ident, ty: ty::t)\n-            -> option::t<@ast::method> {\n-            let result = none;\n-            std::list::iter(isc) {|impls|\n-                for im in *impls {\n-                    alt im.node {\n-                      ast::item_impl(_, slf, mthds) {\n-                        let self_ty = ast_ty_to_ty_crate(fcx.ccx, slf);\n-                        alt unify::unify(fcx, ty, self_ty) {\n-                          ures_ok(_) {}\n-                          _ { cont; }\n-                        }\n-                        for m in mthds {\n-                            if m.node.ident == name {\n-                                result = some(m);\n-                                ret;\n-                            }\n-                        }\n-                      }\n-                    }\n-                }\n-            }\n-            result\n-        }\n-\n         bot |= check_expr(fcx, base);\n         let base_t = expr_ty(tcx, base);\n         let iscope = fcx.ccx.impl_map.get(expr.id);\n         alt lookup_method(fcx, iscope, field, base_t) {\n-          some(method) {\n-            let mt = ty_of_method(fcx.ccx.tcx, m_check, method);\n+          some({method, ids}) {\n+            let mt = ty_of_method(fcx.ccx.tcx, m_check, method), ids = ids;\n             let fty = ty::mk_fn(fcx.ccx.tcx, mt.proto, mt.inputs,\n                                 mt.output, mt.cf, mt.constrs);\n-            write::ty_only_fixup(fcx, id, fty);\n+            let tp_count = vec::len(method.node.tps);\n+            if tp_count > 0u {\n+                let b = bind_params_in_type(expr.span, tcx,\n+                                            bind next_ty_var_id(fcx),\n+                                            fty, tp_count);\n+                ids += b.ids;\n+                fty = b.ty;\n+            }\n+            let substs = vec::map({|id| ty::mk_var(tcx, id)}, ids);\n+            write::ty_fixup(fcx, id, {substs: some(substs), ty: fty});\n             fcx.ccx.method_map.insert(id, local_def(method.node.id));\n           }\n           _ {"}, {"sha": "d85849b257123751a8b43358cc557f21b7f067ce", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d529757515671d5826d8d2203ce0a4f82a3bdee5/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d529757515671d5826d8d2203ce0a4f82a3bdee5/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=d529757515671d5826d8d2203ce0a4f82a3bdee5", "patch": "@@ -423,7 +423,7 @@ tag ret_style {\n \n type _fn = {decl: fn_decl, proto: proto, body: blk};\n \n-type method_ = {ident: ident, meth: _fn, id: node_id};\n+type method_ = {ident: ident, meth: _fn, id: node_id, tps: [ty_param]};\n \n type method = spanned<method_>;\n "}, {"sha": "b3a48cc418ccd709f536710d9890bf99693964e4", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d529757515671d5826d8d2203ce0a4f82a3bdee5/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d529757515671d5826d8d2203ce0a4f82a3bdee5/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=d529757515671d5826d8d2203ce0a4f82a3bdee5", "patch": "@@ -246,7 +246,8 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n }\n \n fn noop_fold_method(m: method_, fld: ast_fold) -> method_ {\n-    ret {ident: fld.fold_ident(m.ident), meth: fld.fold_fn(m.meth), id: m.id};\n+    ret {ident: fld.fold_ident(m.ident), meth: fld.fold_fn(m.meth)\n+         with m};\n }\n \n "}, {"sha": "12df9ecd1ad493c03a42d95263f5addf9be4263a", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d529757515671d5826d8d2203ce0a4f82a3bdee5/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d529757515671d5826d8d2203ce0a4f82a3bdee5/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=d529757515671d5826d8d2203ce0a4f82a3bdee5", "patch": "@@ -854,7 +854,7 @@ fn parse_bottom_expr(p: parser) -> @ast::expr {\n         while p.peek() != token::RBRACE {\n             if eat_word(p, \"with\") {\n                 inner_obj = some(parse_expr(p));\n-            } else { meths += [parse_method(p)]; }\n+            } else { meths += [parse_method(p, false)]; }\n         }\n         hi = p.get_hi_pos();\n         expect(p, token::RBRACE);\n@@ -1832,12 +1832,13 @@ fn parse_anon_obj_field(p: parser) -> ast::anon_obj_field {\n     ret {mut: mut, ty: ty, expr: expr, ident: ident, id: p.get_id()};\n }\n \n-fn parse_method(p: parser) -> @ast::method {\n+fn parse_method(p: parser, allow_tps: bool) -> @ast::method {\n     let lo = p.get_lo_pos();\n     let proto = parse_method_proto(p);\n     let ident = parse_value_ident(p);\n+    let tps = allow_tps ? parse_ty_params(p) : [];\n     let f = parse_fn(p, proto, ast::impure_fn, ast::il_normal);\n-    let meth = {ident: ident, meth: f, id: p.get_id()};\n+    let meth = {ident: ident, meth: f, id: p.get_id(), tps: tps};\n     ret @spanned(lo, f.body.span.hi, meth);\n }\n \n@@ -1850,7 +1851,7 @@ fn parse_item_obj(p: parser, attrs: [ast::attribute]) -> @ast::item {\n                   parse_obj_field, p);\n     let meths: [@ast::method] = [];\n     expect(p, token::LBRACE);\n-    while p.peek() != token::RBRACE { meths += [parse_method(p)]; }\n+    while p.peek() != token::RBRACE { meths += [parse_method(p, false)]; }\n     let hi = p.get_hi_pos();\n     expect(p, token::RBRACE);\n     let ob: ast::_obj = {fields: fields.node, methods: meths};\n@@ -1864,7 +1865,7 @@ fn parse_item_impl(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     expect_word(p, \"for\");\n     let ty = parse_ty(p, false), meths = [];\n     expect(p, token::LBRACE);\n-    while !eat(p, token::RBRACE) { meths += [parse_method(p)]; }\n+    while !eat(p, token::RBRACE) { meths += [parse_method(p, true)]; }\n     ret mk_item(p, lo, p.get_last_hi_pos(), ident,\n                 ast::item_impl(tps, ty, meths), attrs);\n }"}, {"sha": "a1feec5bec9144a036859060142d4947f11a1a04", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d529757515671d5826d8d2203ce0a4f82a3bdee5/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d529757515671d5826d8d2203ce0a4f82a3bdee5/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=d529757515671d5826d8d2203ce0a4f82a3bdee5", "patch": "@@ -101,15 +101,15 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n       item_obj(ob, _, _) {\n         for f: obj_field in ob.fields { v.visit_ty(f.ty, e, v); }\n         for m: @method in ob.methods {\n-            v.visit_fn(m.node.meth, [], m.span, some(m.node.ident), m.node.id,\n-                       e, v);\n+            v.visit_fn(m.node.meth, m.node.tps, m.span, some(m.node.ident),\n+                       m.node.id, e, v);\n         }\n       }\n       item_impl(_, ty, methods) {\n         visit_ty(ty, e, v);\n         for m in methods {\n-            v.visit_fn(m.node.meth, [], m.span, some(m.node.ident), m.node.id,\n-                       e, v);\n+            v.visit_fn(m.node.meth, m.node.tps, m.span, some(m.node.ident),\n+                       m.node.id, e, v);\n         }\n       }\n     }\n@@ -321,8 +321,8 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n           some(ex) { v.visit_expr(ex, e, v); }\n         }\n         for m: @method in anon_obj.methods {\n-            v.visit_fn(m.node.meth, [], m.span, some(m.node.ident), m.node.id,\n-                       e, v);\n+            v.visit_fn(m.node.meth, m.node.tps, m.span, some(m.node.ident),\n+                       m.node.id, e, v);\n         }\n       }\n       expr_mac(mac) { visit_mac(mac, e, v); }"}]}