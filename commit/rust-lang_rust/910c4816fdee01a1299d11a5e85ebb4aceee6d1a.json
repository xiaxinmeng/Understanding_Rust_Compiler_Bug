{"sha": "910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxMGM0ODE2ZmRlZTAxYTEyOTlkMTFhNWU4NWViYjRhY2VlZTZkMWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-12T13:22:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-12T13:22:16Z"}, "message": "Auto merge of #41246 - TimNN:rollup, r=TimNN\n\nRollup of 9 pull requests\n\n- Successful merges: #41063, #41087, #41141, #41166, #41183, #41205, #41206, #41232, #41243\n- Failed merges:", "tree": {"sha": "5413288c2a03b64c62c03782b194d28e2de37739", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5413288c2a03b64c62c03782b194d28e2de37739"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "html_url": "https://github.com/rust-lang/rust/commit/910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1dca19ae3fd195fa517e326a39bfee729da7cadb", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dca19ae3fd195fa517e326a39bfee729da7cadb", "html_url": "https://github.com/rust-lang/rust/commit/1dca19ae3fd195fa517e326a39bfee729da7cadb"}, {"sha": "d4d35cfecc7df36d62a0e6dbc66106657667c92e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4d35cfecc7df36d62a0e6dbc66106657667c92e", "html_url": "https://github.com/rust-lang/rust/commit/d4d35cfecc7df36d62a0e6dbc66106657667c92e"}], "stats": {"total": 2773, "additions": 2049, "deletions": 724}, "files": [{"sha": "19559fa2950ea814798b5637d2eec2f1fd6292aa", "filename": "COPYRIGHT", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/COPYRIGHT", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/COPYRIGHT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/COPYRIGHT?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -197,28 +197,6 @@ their own copyright notices and license terms:\n     USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\n     OF SUCH DAMAGE.\n \n-* Hoedown, the markdown parser, under src/rt/hoedown, is\n-  licensed as follows.\n-\n-    Copyright (c) 2008, Natacha Port\u00e9\n-    Copyright (c) 2011, Vicent Mart\u00ed\n-    Copyright (c) 2013, Devin Torres and the Hoedown authors\n-\n-    Permission to use, copy, modify, and distribute this\n-    software for any purpose with or without fee is hereby\n-    granted, provided that the above copyright notice and\n-    this permission notice appear in all copies.\n-\n-    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR\n-    DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE\n-    INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n-    FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n-    SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR\n-    ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA\n-    OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n-    OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\n-    CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n-\n * libbacktrace, under src/libbacktrace:\n \n     Copyright (C) 2012-2014 Free Software Foundation, Inc."}, {"sha": "c416fb60b11ecfd2a1ba0fb8567c9a92590b5d28", "filename": "cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -1 +1 @@\n-Subproject commit 4729175045b41b688ab903120860866ce7a22ba9\n+Subproject commit c416fb60b11ecfd2a1ba0fb8567c9a92590b5d28"}, {"sha": "e3808248e22fe89f1778de9bd0564f04737643a1", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -325,8 +325,10 @@ impl str {\n \n     /// Returns a subslice of `str`.\n     ///\n-    /// This is the non-panicking alternative to indexing the `str`. Returns `None` whenever\n-    /// equivalent indexing operation would panic.\n+    /// This is the non-panicking alternative to indexing the `str`. Returns\n+    /// [`None`] whenever equivalent indexing operation would panic.\n+    ///\n+    /// [`None`]: option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n@@ -346,8 +348,10 @@ impl str {\n \n     /// Returns a mutable subslice of `str`.\n     ///\n-    /// This is the non-panicking alternative to indexing the `str`. Returns `None` whenever\n-    /// equivalent indexing operation would panic.\n+    /// This is the non-panicking alternative to indexing the `str`. Returns\n+    /// [`None`] whenever equivalent indexing operation would panic.\n+    ///\n+    /// [`None`]: option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n@@ -570,7 +574,7 @@ impl str {\n         core_str::StrExt::split_at_mut(self, mid)\n     }\n \n-    /// Returns an iterator over the `char`s of a string slice.\n+    /// Returns an iterator over the [`char`]s of a string slice.\n     ///\n     /// As a string slice consists of valid UTF-8, we can iterate through a\n     /// string slice by [`char`]. This method returns such an iterator.\n@@ -1657,13 +1661,13 @@ impl str {\n \n     /// Parses this string slice into another type.\n     ///\n-    /// Because `parse()` is so general, it can cause problems with type\n-    /// inference. As such, `parse()` is one of the few times you'll see\n+    /// Because `parse` is so general, it can cause problems with type\n+    /// inference. As such, `parse` is one of the few times you'll see\n     /// the syntax affectionately known as the 'turbofish': `::<>`. This\n     /// helps the inference algorithm understand specifically which type\n     /// you're trying to parse into.\n     ///\n-    /// `parse()` can parse any type that implements the [`FromStr`] trait.\n+    /// `parse` can parse any type that implements the [`FromStr`] trait.\n     ///\n     /// [`FromStr`]: str/trait.FromStr.html\n     ///\n@@ -1746,7 +1750,7 @@ impl str {\n     ///\n     /// `replacen` creates a new [`String`], and copies the data from this string slice into it.\n     /// While doing so, it attempts to find matches of a pattern. If it finds any, it\n-    /// replaces them with the replacement string slice at most `N` times.\n+    /// replaces them with the replacement string slice at most `count` times.\n     ///\n     /// [`String`]: string/struct.String.html\n     ///\n@@ -1892,33 +1896,40 @@ impl str {\n         return s;\n     }\n \n-    /// Escapes each char in `s` with `char::escape_debug`.\n+    /// Escapes each char in `s` with [`char::escape_debug`].\n+    ///\n+    /// [`char::escape_debug`]: primitive.char.html#method.escape_debug\n     #[unstable(feature = \"str_escape\",\n                reason = \"return type may change to be an iterator\",\n                issue = \"27791\")]\n     pub fn escape_debug(&self) -> String {\n         self.chars().flat_map(|c| c.escape_debug()).collect()\n     }\n \n-    /// Escapes each char in `s` with `char::escape_default`.\n+    /// Escapes each char in `s` with [`char::escape_default`].\n+    ///\n+    /// [`char::escape_default`]: primitive.char.html#method.escape_default\n     #[unstable(feature = \"str_escape\",\n                reason = \"return type may change to be an iterator\",\n                issue = \"27791\")]\n     pub fn escape_default(&self) -> String {\n         self.chars().flat_map(|c| c.escape_default()).collect()\n     }\n \n-    /// Escapes each char in `s` with `char::escape_unicode`.\n+    /// Escapes each char in `s` with [`char::escape_unicode`].\n+    ///\n+    /// [`char::escape_unicode`]: primitive.char.html#method.escape_unicode\n     #[unstable(feature = \"str_escape\",\n                reason = \"return type may change to be an iterator\",\n                issue = \"27791\")]\n     pub fn escape_unicode(&self) -> String {\n         self.chars().flat_map(|c| c.escape_unicode()).collect()\n     }\n \n-    /// Converts a `Box<str>` into a [`String`] without copying or allocating.\n+    /// Converts a [`Box<str>`] into a [`String`] without copying or allocating.\n     ///\n     /// [`String`]: string/struct.String.html\n+    /// [`Box<str>`]: boxed/struct.Box.html\n     ///\n     /// # Examples\n     ///"}, {"sha": "59d04ea8c771cc7ec1867e887b53e0fd6e2d38a7", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -57,17 +57,13 @@ pub enum DepNode<D: Clone + Debug> {\n \n     // Represents different phases in the compiler.\n     CollectLanguageItems,\n-    CheckStaticRecursion,\n     ResolveLifetimes,\n     RegionResolveCrate,\n-    CheckLoops,\n     PluginRegistrar,\n     StabilityIndex,\n     CollectItem(D),\n     CollectItemSig(D),\n     Coherence,\n-    EffectCheck,\n-    Liveness,\n     Resolve,\n     EntryPoint,\n     CheckEntryFn,\n@@ -216,15 +212,11 @@ impl<D: Clone + Debug> DepNode<D> {\n             MirKrate => Some(MirKrate),\n             TypeckBodiesKrate => Some(TypeckBodiesKrate),\n             CollectLanguageItems => Some(CollectLanguageItems),\n-            CheckStaticRecursion => Some(CheckStaticRecursion),\n             ResolveLifetimes => Some(ResolveLifetimes),\n             RegionResolveCrate => Some(RegionResolveCrate),\n-            CheckLoops => Some(CheckLoops),\n             PluginRegistrar => Some(PluginRegistrar),\n             StabilityIndex => Some(StabilityIndex),\n             Coherence => Some(Coherence),\n-            EffectCheck => Some(EffectCheck),\n-            Liveness => Some(Liveness),\n             Resolve => Some(Resolve),\n             EntryPoint => Some(EntryPoint),\n             CheckEntryFn => Some(CheckEntryFn),"}, {"sha": "cfafec00ae20def83507206f4855bc71b0a4cc53", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -442,6 +442,27 @@ impl<'hir> Map<'hir> {\n         self.local_def_id(self.body_owner(id))\n     }\n \n+    /// Given a body owner's id, returns the `BodyId` associated with it.\n+    pub fn body_owned_by(&self, id: NodeId) -> BodyId {\n+        if let Some(entry) = self.find_entry(id) {\n+            if let Some(body_id) = entry.associated_body() {\n+                // For item-like things and closures, the associated\n+                // body has its own distinct id, and that is returned\n+                // by `associated_body`.\n+                body_id\n+            } else {\n+                // For some expressions, the expression is its own body.\n+                if let EntryExpr(_, expr) = entry {\n+                    BodyId { node_id: expr.id }\n+                } else {\n+                    span_bug!(self.span(id), \"id `{}` has no associated body\", id);\n+                }\n+            }\n+        } else {\n+            bug!(\"no entry for id `{}`\", id)\n+        }\n+    }\n+\n     pub fn ty_param_owner(&self, id: NodeId) -> NodeId {\n         match self.get(id) {\n             NodeItem(&Item { node: ItemTrait(..), .. }) => id,"}, {"sha": "3a6367c353c1eec7cdcc32a756281ef81c8f528e", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -13,8 +13,10 @@ use hir::def_id::DefId;\n use ich::{self, CachingCodemapView};\n use session::config::DebugInfoLevel::NoDebugInfo;\n use ty;\n+use util::nodemap::NodeMap;\n \n use std::hash as std_hash;\n+use std::collections::{HashMap, HashSet};\n \n use syntax::ast;\n use syntax::attr;\n@@ -296,3 +298,53 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for Span {\n         }\n     }\n }\n+\n+pub fn hash_stable_hashmap<'a, 'tcx, K, V, R, SK, F, W>(hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                                        hasher: &mut StableHasher<W>,\n+                                                        map: &HashMap<K, V, R>,\n+                                                        extract_stable_key: F)\n+    where K: Eq + std_hash::Hash,\n+          V: HashStable<StableHashingContext<'a, 'tcx>>,\n+          R: std_hash::BuildHasher,\n+          SK: HashStable<StableHashingContext<'a, 'tcx>> + Ord + Clone,\n+          F: Fn(&mut StableHashingContext<'a, 'tcx>, &K) -> SK,\n+          W: StableHasherResult,\n+{\n+    let mut keys: Vec<_> = map.keys()\n+                              .map(|k| (extract_stable_key(hcx, k), k))\n+                              .collect();\n+    keys.sort_unstable_by_key(|&(ref stable_key, _)| stable_key.clone());\n+    keys.len().hash_stable(hcx, hasher);\n+    for (stable_key, key) in keys {\n+        stable_key.hash_stable(hcx, hasher);\n+        map[key].hash_stable(hcx, hasher);\n+    }\n+}\n+\n+pub fn hash_stable_hashset<'a, 'tcx, K, R, SK, F, W>(hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                                     hasher: &mut StableHasher<W>,\n+                                                     set: &HashSet<K, R>,\n+                                                     extract_stable_key: F)\n+    where K: Eq + std_hash::Hash,\n+          R: std_hash::BuildHasher,\n+          SK: HashStable<StableHashingContext<'a, 'tcx>> + Ord + Clone,\n+          F: Fn(&mut StableHashingContext<'a, 'tcx>, &K) -> SK,\n+          W: StableHasherResult,\n+{\n+    let mut keys: Vec<_> = set.iter()\n+                              .map(|k| extract_stable_key(hcx, k))\n+                              .collect();\n+    keys.sort_unstable();\n+    keys.hash_stable(hcx, hasher);\n+}\n+\n+pub fn hash_stable_nodemap<'a, 'tcx, V, W>(hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                           hasher: &mut StableHasher<W>,\n+                                           map: &NodeMap<V>)\n+    where V: HashStable<StableHashingContext<'a, 'tcx>>,\n+          W: StableHasherResult,\n+{\n+    hash_stable_hashmap(hcx, hasher, map, |hcx, node_id| {\n+        hcx.tcx.hir.definitions().node_to_hir_id(*node_id).local_id\n+    });\n+}"}, {"sha": "3ff8ffb35054ad4be9764f6c80ea5b4f8b1481a1", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -22,7 +22,8 @@ impl_stable_hash_for!(struct mir::SourceInfo { span, scope });\n impl_stable_hash_for!(enum mir::Mutability { Mut, Not });\n impl_stable_hash_for!(enum mir::BorrowKind { Shared, Unique, Mut });\n impl_stable_hash_for!(enum mir::LocalKind { Var, Temp, Arg, ReturnPointer });\n-impl_stable_hash_for!(struct mir::LocalDecl<'tcx> { mutability, ty, name, source_info });\n+impl_stable_hash_for!(struct mir::LocalDecl<'tcx> { mutability, ty, name, source_info,\n+is_user_variable});\n impl_stable_hash_for!(struct mir::UpvarDecl { debug_name, by_ref });\n impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator, is_cleanup });\n impl_stable_hash_for!(struct mir::Terminator<'tcx> { source_info, kind });"}, {"sha": "46d1e7ef0c7c474a26a40ceb1d923bc3ceb6d425", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 280, "deletions": 21, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -11,31 +11,22 @@\n //! This module contains `HashStable` implementations for various data types\n //! from rustc::ty in no particular order.\n \n-use ich::StableHashingContext;\n+use ich::{self, StableHashingContext, NodeIdHashingMode};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n use std::hash as std_hash;\n use std::mem;\n+use syntax_pos::symbol::InternedString;\n use ty;\n \n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Ty<'tcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let type_hash = hcx.tcx().type_id_hash(*self);\n-        type_hash.hash_stable(hcx, hasher);\n-    }\n-}\n-\n impl_stable_hash_for!(struct ty::ItemSubsts<'tcx> { substs });\n \n-impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>> for ty::Slice<T>\n+impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>> for &'tcx ty::Slice<T>\n     where T: HashStable<StableHashingContext<'a, 'tcx>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        (&**self).hash_stable(hcx, hasher);\n+        (&self[..]).hash_stable(hcx, hasher);\n     }\n }\n \n@@ -67,9 +58,13 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Region {\n                 index.hash_stable(hcx, hasher);\n                 name.hash_stable(hcx, hasher);\n             }\n+            ty::ReScope(code_extent) => {\n+                code_extent.hash_stable(hcx, hasher);\n+            }\n+            ty::ReFree(ref free_region) => {\n+                free_region.hash_stable(hcx, hasher);\n+            }\n             ty::ReLateBound(..) |\n-            ty::ReFree(..) |\n-            ty::ReScope(..) |\n             ty::ReVar(..) |\n             ty::ReSkolemized(..) => {\n                 bug!(\"TypeIdHasher: unexpected region {:?}\", *self)\n@@ -127,7 +122,6 @@ impl_stable_hash_for!(enum ty::BorrowKind {\n     MutBorrow\n });\n \n-\n impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::UpvarCapture<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'tcx>,\n@@ -223,7 +217,6 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::Predicate<'tcx\n     }\n }\n \n-\n impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::AdtFlags {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           _: &mut StableHashingContext<'a, 'tcx>,\n@@ -280,9 +273,14 @@ for ::middle::const_val::ConstVal<'tcx> {\n                 def_id.hash_stable(hcx, hasher);\n                 substs.hash_stable(hcx, hasher);\n             }\n-            ConstVal::Struct(ref _name_value_map) => {\n-                // BTreeMap<ast::Name, ConstVal<'tcx>>),\n-                panic!(\"Ordering still unstable\")\n+            ConstVal::Struct(ref name_value_map) => {\n+                let mut values: Vec<(InternedString, &ConstVal)> =\n+                    name_value_map.iter()\n+                                  .map(|(name, val)| (name.as_str(), val))\n+                                  .collect();\n+\n+                values.sort_unstable_by_key(|&(ref name, _)| name.clone());\n+                values.hash_stable(hcx, hasher);\n             }\n             ConstVal::Tuple(ref value) => {\n                 value.hash_stable(hcx, hasher);\n@@ -303,7 +301,6 @@ for ::middle::const_val::ConstVal<'tcx> {\n \n impl_stable_hash_for!(struct ty::ClosureSubsts<'tcx> { substs });\n \n-\n impl_stable_hash_for!(struct ty::GenericPredicates<'tcx> {\n     parent,\n     predicates\n@@ -413,3 +410,265 @@ impl_stable_hash_for!(struct ::middle::region::CallSiteScopeData {\n impl_stable_hash_for!(struct ty::DebruijnIndex {\n     depth\n });\n+\n+impl_stable_hash_for!(enum ty::cast::CastKind {\n+    CoercionCast,\n+    PtrPtrCast,\n+    PtrAddrCast,\n+    AddrPtrCast,\n+    NumericCast,\n+    EnumCast,\n+    PrimIntCast,\n+    U8CharCast,\n+    ArrayPtrCast,\n+    FnPtrPtrCast,\n+    FnPtrAddrCast\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::middle::region::CodeExtent\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            hcx.tcx().region_maps.code_extent_data(*self).hash_stable(hcx, hasher);\n+        });\n+    }\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::middle::region::CodeExtentData\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use middle::region::CodeExtentData;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            CodeExtentData::Misc(node_id) |\n+            CodeExtentData::DestructionScope(node_id) => {\n+                node_id.hash_stable(hcx, hasher);\n+            }\n+            CodeExtentData::CallSiteScope { fn_id, body_id } |\n+            CodeExtentData::ParameterScope { fn_id, body_id } => {\n+                fn_id.hash_stable(hcx, hasher);\n+                body_id.hash_stable(hcx, hasher);\n+            }\n+            CodeExtentData::Remainder(block_remainder) => {\n+                block_remainder.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ::middle::region::BlockRemainder {\n+    block,\n+    first_statement_index\n+});\n+\n+impl_stable_hash_for!(struct ty::adjustment::CoerceUnsizedInfo {\n+    custom_kind\n+});\n+\n+impl_stable_hash_for!(struct ty::FreeRegion {\n+    scope,\n+    bound_region\n+});\n+\n+impl_stable_hash_for!(enum ty::BoundRegion {\n+    BrAnon(index),\n+    BrNamed(def_id, name),\n+    BrFresh(index),\n+    BrEnv\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::TypeVariants<'tcx>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use ty::TypeVariants::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            TyBool  |\n+            TyChar  |\n+            TyStr   |\n+            TyNever => {\n+                // Nothing more to hash.\n+            }\n+            TyInt(int_ty) => {\n+                int_ty.hash_stable(hcx, hasher);\n+            }\n+            TyUint(uint_ty) => {\n+                uint_ty.hash_stable(hcx, hasher);\n+            }\n+            TyFloat(float_ty)  => {\n+                float_ty.hash_stable(hcx, hasher);\n+            }\n+            TyAdt(adt_def, substs) => {\n+                adt_def.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+            }\n+            TyArray(inner_ty, len) => {\n+                inner_ty.hash_stable(hcx, hasher);\n+                len.hash_stable(hcx, hasher);\n+            }\n+            TySlice(inner_ty) => {\n+                inner_ty.hash_stable(hcx, hasher);\n+            }\n+            TyRawPtr(pointee_ty) => {\n+                pointee_ty.hash_stable(hcx, hasher);\n+            }\n+            TyRef(region, pointee_ty) => {\n+                region.hash_stable(hcx, hasher);\n+                pointee_ty.hash_stable(hcx, hasher);\n+            }\n+            TyFnDef(def_id, substs, ref sig) => {\n+                def_id.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+                sig.hash_stable(hcx, hasher);\n+            }\n+            TyFnPtr(ref sig) => {\n+                sig.hash_stable(hcx, hasher);\n+            }\n+            TyDynamic(ref existential_predicates, region) => {\n+                existential_predicates.hash_stable(hcx, hasher);\n+                region.hash_stable(hcx, hasher);\n+            }\n+            TyClosure(def_id, closure_substs) => {\n+                def_id.hash_stable(hcx, hasher);\n+                closure_substs.hash_stable(hcx, hasher);\n+            }\n+            TyTuple(inner_tys, from_diverging_type_var) => {\n+                inner_tys.hash_stable(hcx, hasher);\n+                from_diverging_type_var.hash_stable(hcx, hasher);\n+            }\n+            TyProjection(ref projection_ty) => {\n+                projection_ty.hash_stable(hcx, hasher);\n+            }\n+            TyAnon(def_id, substs) => {\n+                def_id.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+            }\n+            TyParam(param_ty) => {\n+                param_ty.hash_stable(hcx, hasher);\n+            }\n+\n+            TyError     |\n+            TyInfer(..) => {\n+                bug!(\"ty::TypeVariants::hash_stable() - Unexpected variant.\")\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::ParamTy {\n+    idx,\n+    name\n+});\n+\n+impl_stable_hash_for!(struct ty::TypeAndMut<'tcx> {\n+    ty,\n+    mutbl\n+});\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::ExistentialPredicate<'tcx>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ty::ExistentialPredicate::Trait(ref trait_ref) => {\n+                trait_ref.hash_stable(hcx, hasher);\n+            }\n+            ty::ExistentialPredicate::Projection(ref projection) => {\n+                projection.hash_stable(hcx, hasher);\n+            }\n+            ty::ExistentialPredicate::AutoTrait(def_id) => {\n+                def_id.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::ExistentialTraitRef<'tcx> {\n+    def_id,\n+    substs\n+});\n+\n+impl_stable_hash_for!(struct ty::ExistentialProjection<'tcx> {\n+    trait_ref,\n+    item_name,\n+    ty\n+});\n+\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::TypeckTables<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::TypeckTables {\n+            ref type_relative_path_defs,\n+            ref node_types,\n+            ref item_substs,\n+            ref adjustments,\n+            ref method_map,\n+            ref upvar_capture_map,\n+            ref closure_tys,\n+            ref closure_kinds,\n+            ref liberated_fn_sigs,\n+            ref fru_field_types,\n+\n+            ref cast_kinds,\n+\n+            // FIXME(#41184): This is still ignored at the moment.\n+            lints: _,\n+            ref used_trait_imports,\n+            tainted_by_errors,\n+            ref free_region_map,\n+        } = *self;\n+\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            ich::hash_stable_nodemap(hcx, hasher, type_relative_path_defs);\n+            ich::hash_stable_nodemap(hcx, hasher, node_types);\n+            ich::hash_stable_nodemap(hcx, hasher, item_substs);\n+            ich::hash_stable_nodemap(hcx, hasher, adjustments);\n+\n+            ich::hash_stable_hashmap(hcx, hasher, method_map, |hcx, method_call| {\n+                let ty::MethodCall {\n+                    expr_id,\n+                    autoderef\n+                } = *method_call;\n+\n+                let def_id = hcx.tcx().hir.local_def_id(expr_id);\n+                (hcx.def_path_hash(def_id), autoderef)\n+            });\n+\n+            ich::hash_stable_hashmap(hcx, hasher, upvar_capture_map, |hcx, up_var_id| {\n+                let ty::UpvarId {\n+                    var_id,\n+                    closure_expr_id\n+                } = *up_var_id;\n+\n+                let var_def_id = hcx.tcx().hir.local_def_id(var_id);\n+                let closure_def_id = hcx.tcx().hir.local_def_id(closure_expr_id);\n+                (hcx.def_path_hash(var_def_id), hcx.def_path_hash(closure_def_id))\n+            });\n+\n+            ich::hash_stable_nodemap(hcx, hasher, closure_tys);\n+            ich::hash_stable_nodemap(hcx, hasher, closure_kinds);\n+            ich::hash_stable_nodemap(hcx, hasher, liberated_fn_sigs);\n+            ich::hash_stable_nodemap(hcx, hasher, fru_field_types);\n+            ich::hash_stable_nodemap(hcx, hasher, cast_kinds);\n+\n+            ich::hash_stable_hashset(hcx, hasher, used_trait_imports, |hcx, def_id| {\n+                hcx.def_path_hash(*def_id)\n+            });\n+\n+            tainted_by_errors.hash_stable(hcx, hasher);\n+            free_region_map.hash_stable(hcx, hasher);\n+        })\n+    }\n+}"}, {"sha": "d70ed051ac4107ad2d3b31ca3d8fc2c1ed6183ac", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -12,8 +12,8 @@\n \n pub use self::fingerprint::Fingerprint;\n pub use self::caching_codemap_view::CachingCodemapView;\n-pub use self::hcx::{StableHashingContext, NodeIdHashingMode};\n-\n+pub use self::hcx::{StableHashingContext, NodeIdHashingMode, hash_stable_hashmap,\n+                    hash_stable_hashset, hash_stable_nodemap};\n mod fingerprint;\n mod caching_codemap_view;\n mod hcx;"}, {"sha": "dcbe50de2e9b2ec8ac6ba66a6a56bb94faf3131e", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 279, "deletions": 9, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -70,7 +70,7 @@ use ty::{self, TyCtxt, TypeFoldable};\n use ty::{Region, Issue32330};\n use ty::error::TypeError;\n use syntax_pos::{Pos, Span};\n-use errors::DiagnosticBuilder;\n+use errors::{DiagnosticBuilder, DiagnosticStyledString};\n \n mod note;\n \n@@ -365,6 +365,262 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Given that `other_ty` is the same as a type argument for `name` in `sub`, populate `value`\n+    /// highlighting `name` and every type argument that isn't at `pos` (which is `other_ty`), and\n+    /// populate `other_value` with `other_ty`.\n+    ///\n+    /// ```text\n+    /// Foo<Bar<Qux>>\n+    /// ^^^^--------^ this is highlighted\n+    /// |   |\n+    /// |   this type argument is exactly the same as the other type, not highlighted\n+    /// this is highlighted\n+    /// Bar<Qux>\n+    /// -------- this type is the same as a type argument in the other type, not highlighted\n+    /// ```\n+    fn highlight_outer(&self,\n+                       mut value: &mut DiagnosticStyledString,\n+                       mut other_value: &mut DiagnosticStyledString,\n+                       name: String,\n+                       sub: &ty::subst::Substs<'tcx>,\n+                       pos: usize,\n+                       other_ty: &ty::Ty<'tcx>) {\n+        // `value` and `other_value` hold two incomplete type representation for display.\n+        // `name` is the path of both types being compared. `sub`\n+        value.push_highlighted(name);\n+        let len = sub.len();\n+        if len > 0 {\n+            value.push_highlighted(\"<\");\n+        }\n+\n+        // Output the lifetimes fot the first type\n+        let lifetimes = sub.regions().map(|lifetime| {\n+            let s = format!(\"{}\", lifetime);\n+            if s.is_empty() {\n+                \"'_\".to_string()\n+            } else {\n+                s\n+            }\n+        }).collect::<Vec<_>>().join(\", \");\n+        if !lifetimes.is_empty() {\n+            if sub.regions().count() < len {\n+                value.push_normal(lifetimes + &\", \");\n+            } else {\n+                value.push_normal(lifetimes);\n+            }\n+        }\n+\n+        // Highlight all the type arguments that aren't at `pos` and compare the type argument at\n+        // `pos` and `other_ty`.\n+        for (i, type_arg) in sub.types().enumerate() {\n+            if i == pos {\n+                let values = self.cmp(type_arg, other_ty);\n+                value.0.extend((values.0).0);\n+                other_value.0.extend((values.1).0);\n+            } else {\n+                value.push_highlighted(format!(\"{}\", type_arg));\n+            }\n+\n+            if len > 0 && i != len - 1 {\n+                value.push_normal(\", \");\n+            }\n+            //self.push_comma(&mut value, &mut other_value, len, i);\n+        }\n+        if len > 0 {\n+            value.push_highlighted(\">\");\n+        }\n+    }\n+\n+    /// If `other_ty` is the same as a type argument present in `sub`, highlight `path` in `t1_out`,\n+    /// as that is the difference to the other type.\n+    ///\n+    /// For the following code:\n+    ///\n+    /// ```norun\n+    /// let x: Foo<Bar<Qux>> = foo::<Bar<Qux>>();\n+    /// ```\n+    ///\n+    /// The type error output will behave in the following way:\n+    ///\n+    /// ```text\n+    /// Foo<Bar<Qux>>\n+    /// ^^^^--------^ this is highlighted\n+    /// |   |\n+    /// |   this type argument is exactly the same as the other type, not highlighted\n+    /// this is highlighted\n+    /// Bar<Qux>\n+    /// -------- this type is the same as a type argument in the other type, not highlighted\n+    /// ```\n+    fn cmp_type_arg(&self,\n+                    mut t1_out: &mut DiagnosticStyledString,\n+                    mut t2_out: &mut DiagnosticStyledString,\n+                    path: String,\n+                    sub: &ty::subst::Substs<'tcx>,\n+                    other_path: String,\n+                    other_ty: &ty::Ty<'tcx>) -> Option<()> {\n+        for (i, ta) in sub.types().enumerate() {\n+            if &ta == other_ty {\n+                self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, &other_ty);\n+                return Some(());\n+            }\n+            if let &ty::TyAdt(def, _) = &ta.sty {\n+                let path_ = self.tcx.item_path_str(def.did.clone());\n+                if path_ == other_path {\n+                    self.highlight_outer(&mut t1_out, &mut t2_out, path, sub, i, &other_ty);\n+                    return Some(());\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n+    /// Add a `,` to the type representation only if it is appropriate.\n+    fn push_comma(&self,\n+                  value: &mut DiagnosticStyledString,\n+                  other_value: &mut DiagnosticStyledString,\n+                  len: usize,\n+                  pos: usize) {\n+        if len > 0 && pos != len - 1 {\n+            value.push_normal(\", \");\n+            other_value.push_normal(\", \");\n+        }\n+    }\n+\n+    /// Compare two given types, eliding parts that are the same between them and highlighting\n+    /// relevant differences, and return two representation of those types for highlighted printing.\n+    fn cmp(&self, t1: ty::Ty<'tcx>, t2: ty::Ty<'tcx>)\n+        -> (DiagnosticStyledString, DiagnosticStyledString)\n+    {\n+        match (&t1.sty, &t2.sty) {\n+            (&ty::TyAdt(def1, sub1), &ty::TyAdt(def2, sub2)) => {\n+                let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n+                let path1 = self.tcx.item_path_str(def1.did.clone());\n+                let path2 = self.tcx.item_path_str(def2.did.clone());\n+                if def1.did == def2.did {\n+                    // Easy case. Replace same types with `_` to shorten the output and highlight\n+                    // the differing ones.\n+                    //     let x: Foo<Bar, Qux> = y::<Foo<Quz, Qux>>();\n+                    //     Foo<Bar, _>\n+                    //     Foo<Quz, _>\n+                    //         ---  ^ type argument elided\n+                    //         |\n+                    //         highlighted in output\n+                    values.0.push_normal(path1);\n+                    values.1.push_normal(path2);\n+\n+                    // Only draw `<...>` if there're lifetime/type arguments.\n+                    let len = sub1.len();\n+                    if len > 0 {\n+                        values.0.push_normal(\"<\");\n+                        values.1.push_normal(\"<\");\n+                    }\n+\n+                    fn lifetime_display(lifetime: &Region) -> String {\n+                        let s = format!(\"{}\", lifetime);\n+                        if s.is_empty() {\n+                            \"'_\".to_string()\n+                        } else {\n+                            s\n+                        }\n+                    }\n+                    // At one point we'd like to elide all lifetimes here, they are irrelevant for\n+                    // all diagnostics that use this output\n+                    //\n+                    //     Foo<'x, '_, Bar>\n+                    //     Foo<'y, '_, Qux>\n+                    //         ^^  ^^  --- type arguments are not elided\n+                    //         |   |\n+                    //         |   elided as they were the same\n+                    //         not elided, they were different, but irrelevant\n+                    let lifetimes = sub1.regions().zip(sub2.regions());\n+                    for (i, lifetimes) in lifetimes.enumerate() {\n+                        let l1 = lifetime_display(lifetimes.0);\n+                        let l2 = lifetime_display(lifetimes.1);\n+                        if l1 == l2 {\n+                            values.0.push_normal(\"'_\");\n+                            values.1.push_normal(\"'_\");\n+                        } else {\n+                            values.0.push_highlighted(l1);\n+                            values.1.push_highlighted(l2);\n+                        }\n+                        self.push_comma(&mut values.0, &mut values.1, len, i);\n+                    }\n+\n+                    // We're comparing two types with the same path, so we compare the type\n+                    // arguments for both. If they are the same, do not highlight and elide from the\n+                    // output.\n+                    //     Foo<_, Bar>\n+                    //     Foo<_, Qux>\n+                    //         ^ elided type as this type argument was the same in both sides\n+                    let type_arguments = sub1.types().zip(sub2.types());\n+                    let regions_len = sub1.regions().collect::<Vec<_>>().len();\n+                    for (i, (ta1, ta2)) in type_arguments.enumerate() {\n+                        let i = i + regions_len;\n+                        if ta1 == ta2 {\n+                            values.0.push_normal(\"_\");\n+                            values.1.push_normal(\"_\");\n+                        } else {\n+                            let (x1, x2) = self.cmp(ta1, ta2);\n+                            (values.0).0.extend(x1.0);\n+                            (values.1).0.extend(x2.0);\n+                        }\n+                        self.push_comma(&mut values.0, &mut values.1, len, i);\n+                    }\n+\n+                    // Close the type argument bracket.\n+                    // Only draw `<...>` if there're lifetime/type arguments.\n+                    if len > 0 {\n+                        values.0.push_normal(\">\");\n+                        values.1.push_normal(\">\");\n+                    }\n+                    values\n+                } else {\n+                    // Check for case:\n+                    //     let x: Foo<Bar<Qux> = foo::<Bar<Qux>>();\n+                    //     Foo<Bar<Qux>\n+                    //         ------- this type argument is exactly the same as the other type\n+                    //     Bar<Qux>\n+                    if self.cmp_type_arg(&mut values.0,\n+                                         &mut values.1,\n+                                         path1.clone(),\n+                                         sub1,\n+                                         path2.clone(),\n+                                         &t2).is_some() {\n+                        return values;\n+                    }\n+                    // Check for case:\n+                    //     let x: Bar<Qux> = y:<Foo<Bar<Qux>>>();\n+                    //     Bar<Qux>\n+                    //     Foo<Bar<Qux>>\n+                    //         ------- this type argument is exactly the same as the other type\n+                    if self.cmp_type_arg(&mut values.1,\n+                                         &mut values.0,\n+                                         path2,\n+                                         sub2,\n+                                         path1,\n+                                         &t1).is_some() {\n+                        return values;\n+                    }\n+\n+                    // We couldn't find anything in common, highlight everything.\n+                    //     let x: Bar<Qux> = y::<Foo<Zar>>();\n+                    (DiagnosticStyledString::highlighted(format!(\"{}\", t1)),\n+                     DiagnosticStyledString::highlighted(format!(\"{}\", t2)))\n+                }\n+            }\n+            _ => {\n+                if t1 == t2 {\n+                    // The two types are the same, elide and don't highlight.\n+                    (DiagnosticStyledString::normal(\"_\"), DiagnosticStyledString::normal(\"_\"))\n+                } else {\n+                    // We couldn't find anything in common, highlight everything.\n+                    (DiagnosticStyledString::highlighted(format!(\"{}\", t1)),\n+                     DiagnosticStyledString::highlighted(format!(\"{}\", t2)))\n+                }\n+            }\n+        }\n+    }\n+\n     pub fn note_type_err(&self,\n                          diag: &mut DiagnosticBuilder<'tcx>,\n                          cause: &ObligationCause<'tcx>,\n@@ -397,14 +653,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some((expected, found)) = expected_found {\n             match (terr, is_simple_error, expected == found) {\n-                (&TypeError::Sorts(ref values), false,  true) => {\n+                (&TypeError::Sorts(ref values), false, true) => {\n                     diag.note_expected_found_extra(\n-                        &\"type\", &expected, &found,\n+                        &\"type\", expected, found,\n                         &format!(\" ({})\", values.expected.sort_string(self.tcx)),\n                         &format!(\" ({})\", values.found.sort_string(self.tcx)));\n                 }\n                 (_, false,  _) => {\n-                    diag.note_expected_found(&\"type\", &expected, &found);\n+                    diag.note_expected_found(&\"type\", expected, found);\n                 }\n                 _ => (),\n             }\n@@ -472,26 +728,40 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         diag\n     }\n \n-    /// Returns a string of the form \"expected `{}`, found `{}`\".\n-    fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<(String, String)> {\n+    fn values_str(&self, values: &ValuePairs<'tcx>)\n+        -> Option<(DiagnosticStyledString, DiagnosticStyledString)>\n+    {\n         match *values {\n-            infer::Types(ref exp_found) => self.expected_found_str(exp_found),\n+            infer::Types(ref exp_found) => self.expected_found_str_ty(exp_found),\n             infer::TraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n             infer::PolyTraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n         }\n     }\n \n+    fn expected_found_str_ty(&self,\n+                             exp_found: &ty::error::ExpectedFound<ty::Ty<'tcx>>)\n+                             -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n+        let exp_found = self.resolve_type_vars_if_possible(exp_found);\n+        if exp_found.references_error() {\n+            return None;\n+        }\n+\n+        Some(self.cmp(exp_found.expected, exp_found.found))\n+    }\n+\n+    /// Returns a string of the form \"expected `{}`, found `{}`\".\n     fn expected_found_str<T: fmt::Display + TypeFoldable<'tcx>>(\n         &self,\n         exp_found: &ty::error::ExpectedFound<T>)\n-        -> Option<(String, String)>\n+        -> Option<(DiagnosticStyledString, DiagnosticStyledString)>\n     {\n         let exp_found = self.resolve_type_vars_if_possible(exp_found);\n         if exp_found.references_error() {\n             return None;\n         }\n \n-        Some((format!(\"{}\", exp_found.expected), format!(\"{}\", exp_found.found)))\n+        Some((DiagnosticStyledString::highlighted(format!(\"{}\", exp_found.expected)),\n+              DiagnosticStyledString::highlighted(format!(\"{}\", exp_found.found))))\n     }\n \n     fn report_generic_bound_failure(&self,"}, {"sha": "8b753e0d22be7c4bf2b37a7beed1e0e507b620ac", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -20,6 +20,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         match *origin {\n             infer::Subtype(ref trace) => {\n                 if let Some((expected, found)) = self.values_str(&trace.values) {\n+                    let expected = expected.content();\n+                    let found = found.content();\n                     // FIXME: do we want a \"the\" here?\n                     err.span_note(trace.cause.span,\n                                   &format!(\"...so that {} (expected {}, found {})\","}, {"sha": "1f96330d51da556241475daac6875ba2f84b9324", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -42,6 +42,7 @@\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(discriminant_value)]\n+#![feature(sort_unstable)]\n \n extern crate arena;\n extern crate core;"}, {"sha": "81cf24e58dda4f52bbf3394bee721eae3358570a", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -27,6 +27,7 @@ use hir::def_id::{CrateNum, DefId, DefIndex};\n use hir::map as hir_map;\n use hir::map::definitions::{Definitions, DefKey, DisambiguatedDefPathData};\n use hir::svh::Svh;\n+use ich;\n use middle::lang_items;\n use ty::{self, TyCtxt};\n use session::Session;\n@@ -161,6 +162,20 @@ pub struct ExternCrate {\n     pub path_len: usize,\n }\n \n+pub struct EncodedMetadata {\n+    pub raw_data: Vec<u8>,\n+    pub hashes: Vec<EncodedMetadataHash>,\n+}\n+\n+/// The hash for some metadata that (when saving) will be exported\n+/// from this crate, or which (when importing) was exported by an\n+/// upstream crate.\n+#[derive(Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n+pub struct EncodedMetadataHash {\n+    pub def_index: DefIndex,\n+    pub hash: ich::Fingerprint,\n+}\n+\n /// A store of Rust crates, through with their metadata\n /// can be accessed.\n pub trait CrateStore {\n@@ -258,7 +273,8 @@ pub trait CrateStore {\n     fn encode_metadata<'a, 'tcx>(&self,\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  link_meta: &LinkMeta,\n-                                 reachable: &NodeSet) -> Vec<u8>;\n+                                 reachable: &NodeSet)\n+                                 -> EncodedMetadata;\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n \n@@ -417,7 +433,10 @@ impl CrateStore for DummyCrateStore {\n     fn encode_metadata<'a, 'tcx>(&self,\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  link_meta: &LinkMeta,\n-                                 reachable: &NodeSet) -> Vec<u8> { vec![] }\n+                                 reachable: &NodeSet)\n+                                 -> EncodedMetadata {\n+        bug!(\"encode_metadata\")\n+    }\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n }\n "}, {"sha": "d2b8ed8c2970770250d35fe78699d06d548d4316", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -12,7 +12,6 @@\n //! `unsafe`.\n use self::RootUnsafeContext::*;\n \n-use dep_graph::DepNode;\n use ty::{self, Ty, TyCtxt};\n use ty::MethodCall;\n use lint;\n@@ -241,8 +240,6 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let _task = tcx.dep_graph.in_task(DepNode::EffectCheck);\n-\n     let mut visitor = EffectCheckVisitor {\n         tcx: tcx,\n         tables: &ty::TypeckTables::empty(),"}, {"sha": "a8eb6a1074383a5ece01e6fcdd7995c9629e89ef", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -180,3 +180,7 @@ fn lub() {\n     map.relate_free_regions(frs[1], frs[2]);\n     assert_eq!(map.lub_free_regions(frs[0], frs[1]), ty::ReFree(frs[2]));\n }\n+\n+impl_stable_hash_for!(struct FreeRegionMap {\n+    relation\n+});"}, {"sha": "b7da8480c1cefdf6cf740699ff6e6249b442edd8", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -109,7 +109,6 @@ use self::LoopKind::*;\n use self::LiveNodeKind::*;\n use self::VarKind::*;\n \n-use dep_graph::DepNode;\n use hir::def::*;\n use ty::{self, TyCtxt, ParameterEnvironment};\n use traits::{self, Reveal};\n@@ -196,7 +195,6 @@ impl<'a, 'tcx> Visitor<'tcx> for IrMaps<'a, 'tcx> {\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let _task = tcx.dep_graph.in_task(DepNode::Liveness);\n     tcx.hir.krate().visit_all_item_likes(&mut IrMaps::new(tcx).as_deep_visitor());\n     tcx.sess.abort_if_errors();\n }"}, {"sha": "9ff64b295b765ee8a5f67026f15312c2938cadc0", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -197,10 +197,10 @@ impl<'tcx> Mir<'tcx> {\n     pub fn temps_iter<'a>(&'a self) -> impl Iterator<Item=Local> + 'a {\n         (self.arg_count+1..self.local_decls.len()).filter_map(move |index| {\n             let local = Local::new(index);\n-            if self.local_decls[local].source_info.is_none() {\n-                Some(local)\n-            } else {\n+            if self.local_decls[local].is_user_variable {\n                 None\n+            } else {\n+                Some(local)\n             }\n         })\n     }\n@@ -210,10 +210,10 @@ impl<'tcx> Mir<'tcx> {\n     pub fn vars_iter<'a>(&'a self) -> impl Iterator<Item=Local> + 'a {\n         (self.arg_count+1..self.local_decls.len()).filter_map(move |index| {\n             let local = Local::new(index);\n-            if self.local_decls[local].source_info.is_none() {\n-                None\n-            } else {\n+            if self.local_decls[local].is_user_variable {\n                 Some(local)\n+            } else {\n+                None\n             }\n         })\n     }\n@@ -370,6 +370,9 @@ pub struct LocalDecl<'tcx> {\n     /// Temporaries and the return pointer are always mutable.\n     pub mutability: Mutability,\n \n+    /// True if this corresponds to a user-declared local variable.\n+    pub is_user_variable: bool,\n+\n     /// Type of this local.\n     pub ty: Ty<'tcx>,\n \n@@ -379,37 +382,40 @@ pub struct LocalDecl<'tcx> {\n     /// to generate better debuginfo.\n     pub name: Option<Name>,\n \n-    /// For user-declared variables, stores their source information.\n-    ///\n-    /// For temporaries, this is `None`.\n-    ///\n-    /// This is the primary way to differentiate between user-declared\n-    /// variables and compiler-generated temporaries.\n-    pub source_info: Option<SourceInfo>,\n+    /// Source info of the local.\n+    pub source_info: SourceInfo,\n }\n \n impl<'tcx> LocalDecl<'tcx> {\n     /// Create a new `LocalDecl` for a temporary.\n     #[inline]\n-    pub fn new_temp(ty: Ty<'tcx>) -> Self {\n+    pub fn new_temp(ty: Ty<'tcx>, span: Span) -> Self {\n         LocalDecl {\n             mutability: Mutability::Mut,\n             ty: ty,\n             name: None,\n-            source_info: None,\n+            source_info: SourceInfo {\n+                span: span,\n+                scope: ARGUMENT_VISIBILITY_SCOPE\n+            },\n+            is_user_variable: false\n         }\n     }\n \n     /// Builds a `LocalDecl` for the return pointer.\n     ///\n     /// This must be inserted into the `local_decls` list as the first local.\n     #[inline]\n-    pub fn new_return_pointer(return_ty: Ty) -> LocalDecl {\n+    pub fn new_return_pointer(return_ty: Ty, span: Span) -> LocalDecl {\n         LocalDecl {\n             mutability: Mutability::Mut,\n             ty: return_ty,\n-            source_info: None,\n+            source_info: SourceInfo {\n+                span: span,\n+                scope: ARGUMENT_VISIBILITY_SCOPE\n+            },\n             name: None,     // FIXME maybe we do want some name here?\n+            is_user_variable: false\n         }\n     }\n }"}, {"sha": "83963de8b0014e69df865ebad04a3db22be49328", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -630,12 +630,11 @@ macro_rules! make_mir_visitor {\n                     ref $($mutability)* ty,\n                     name: _,\n                     ref $($mutability)* source_info,\n+                    is_user_variable: _,\n                 } = *local_decl;\n \n                 self.visit_ty(ty);\n-                if let Some(ref $($mutability)* info) = *source_info {\n-                    self.visit_source_info(info);\n-                }\n+                self.visit_source_info(source_info);\n             }\n \n             fn super_visibility_scope(&mut self,"}, {"sha": "868ccad8a3a90618078a7528c2c9488076ce8aaf", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -429,6 +429,8 @@ define_maps! { <'tcx>\n \n     pub coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n \n+    pub borrowck: BorrowCheck(DefId) -> (),\n+\n     /// Gets a complete map from all types to their inherent impls.\n     /// Not meant to be used directly outside of coherence.\n     /// (Defined only for LOCAL_CRATE)"}, {"sha": "bbeb1f1fe5f12d27d533679d01bd65c554adf073", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -452,6 +452,23 @@ impl<'tcx> Hash for TyS<'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::TyS<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::TyS {\n+            ref sty,\n+\n+            // The other fields just provide fast access to information that is\n+            // also contained in `sty`, so no need to hash them.\n+            flags: _,\n+            region_depth: _,\n+        } = *self;\n+\n+        sty.hash_stable(hcx, hasher);\n+    }\n+}\n+\n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n impl<'tcx> serialize::UseSpecializedEncodable for Ty<'tcx> {}\n@@ -2224,7 +2241,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// `DefId` is really just an interned def-path).\n     ///\n     /// Note that if `id` is not local to this crate, the result will\n-    //  be a non-local `DefPath`.\n+    ///  be a non-local `DefPath`.\n     pub fn def_path(self, id: DefId) -> hir_map::DefPath {\n         if id.is_local() {\n             self.hir.def_path(id)"}, {"sha": "c650ffe302762a1f39bab14f24e9feb429b81d4b", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -13,7 +13,7 @@\n use hir::def_id::{DefId, LOCAL_CRATE};\n use hir::map::DefPathData;\n use infer::InferCtxt;\n-// use hir::map as hir_map;\n+use ich::{StableHashingContext, NodeIdHashingMode};\n use traits::{self, Reveal};\n use ty::{self, Ty, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n use ty::ParameterEnvironment;\n@@ -25,8 +25,8 @@ use util::nodemap::FxHashMap;\n use middle::lang_items;\n \n use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n-use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult};\n-\n+use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n+                                           HashStable};\n use std::cell::RefCell;\n use std::cmp;\n use std::hash::Hash;\n@@ -187,6 +187,22 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+    /// Creates a hash of the type `Ty` which will be the same no matter what crate\n+    /// context it's calculated within. This is used by the `type_id` intrinsic.\n+    pub fn type_id_hash(self, ty: Ty<'tcx>) -> u64 {\n+        let mut hasher = StableHasher::new();\n+        let mut hcx = StableHashingContext::new(self);\n+\n+        hcx.while_hashing_spans(false, |hcx| {\n+            hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+                ty.hash_stable(hcx, &mut hasher);\n+            });\n+        });\n+        hasher.finish()\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn has_error_field(self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n@@ -339,14 +355,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             .collect()\n     }\n \n-    /// Creates a hash of the type `Ty` which will be the same no matter what crate\n-    /// context it's calculated within. This is used by the `type_id` intrinsic.\n-    pub fn type_id_hash(self, ty: Ty<'tcx>) -> u64 {\n-        let mut hasher = TypeIdHasher::new(self);\n-        hasher.visit_ty(ty);\n-        hasher.finish()\n-    }\n-\n     /// Calculate the destructor of a given type.\n     pub fn calculate_dtor(\n         self,"}, {"sha": "ca313622a3afd1928e5f2ffd1210d6a119f0fbc0", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -307,12 +307,12 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         data\n     }\n \n-    fn create_drop_flag(&mut self, index: MovePathIndex) {\n+    fn create_drop_flag(&mut self, index: MovePathIndex, span: Span) {\n         let tcx = self.tcx;\n         let patch = &mut self.patch;\n         debug!(\"create_drop_flag({:?})\", self.mir.span);\n         self.drop_flags.entry(index).or_insert_with(|| {\n-            patch.new_temp(tcx.types.bool)\n+            patch.new_temp(tcx.types.bool, span)\n         });\n     }\n \n@@ -374,7 +374,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 debug!(\"collect_drop_flags: collecting {:?} from {:?}@{:?} - {:?}\",\n                        child, location, path, (maybe_live, maybe_dead));\n                 if maybe_live && maybe_dead {\n-                    self.create_drop_flag(child)\n+                    self.create_drop_flag(child, terminator.source_info.span)\n                 }\n             });\n         }"}, {"sha": "142286bd834d04d0560d17e53d4fedacf4690b0f", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -22,7 +22,6 @@ pub use self::mir::elaborate_drops::ElaborateDrops;\n \n use self::InteriorKind::*;\n \n-use rustc::dep_graph::DepNode;\n use rustc::hir::map as hir_map;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::cfg;\n@@ -37,12 +36,13 @@ use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::mem_categorization::ImmutabilityBlame;\n use rustc::middle::region;\n use rustc::ty::{self, TyCtxt};\n+use rustc::ty::maps::Providers;\n \n use std::fmt;\n use std::rc::Rc;\n use std::hash::{Hash, Hasher};\n use syntax::ast;\n-use syntax_pos::{MultiSpan, Span};\n+use syntax_pos::{DUMMY_SP, MultiSpan, Span};\n use errors::DiagnosticBuilder;\n \n use rustc::hir;\n@@ -62,16 +62,16 @@ pub struct LoanDataFlowOperator;\n pub type LoanDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, LoanDataFlowOperator>;\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    tcx.dep_graph.with_task(DepNode::BorrowCheckKrate, tcx, (), check_crate_task);\n-\n-    fn check_crate_task<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, (): ()) {\n-        tcx.visit_all_bodies_in_krate(|body_owner_def_id, body_id| {\n-            tcx.dep_graph.with_task(DepNode::BorrowCheck(body_owner_def_id),\n-                                    tcx,\n-                                    body_id,\n-                                    borrowck_fn);\n-        });\n-    }\n+    tcx.visit_all_bodies_in_krate(|body_owner_def_id, _body_id| {\n+        ty::queries::borrowck::get(tcx, DUMMY_SP, body_owner_def_id);\n+    });\n+}\n+\n+pub fn provide(providers: &mut Providers) {\n+    *providers = Providers {\n+        borrowck,\n+        ..*providers\n+    };\n }\n \n /// Collection of conclusions determined via borrow checker analyses.\n@@ -81,11 +81,11 @@ pub struct AnalysisData<'a, 'tcx: 'a> {\n     pub move_data: move_data::FlowedMoveData<'a, 'tcx>,\n }\n \n-fn borrowck_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, body_id: hir::BodyId) {\n-    debug!(\"borrowck_fn(body_id={:?})\", body_id);\n+fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n+    debug!(\"borrowck(body_owner_def_id={:?})\", owner_def_id);\n \n-    let owner_id = tcx.hir.body_owner(body_id);\n-    let owner_def_id = tcx.hir.local_def_id(owner_id);\n+    let owner_id = tcx.hir.as_local_node_id(owner_def_id).unwrap();\n+    let body_id = tcx.hir.body_owned_by(owner_id);\n     let attributes = tcx.get_attrs(owner_def_id);\n     let tables = tcx.item_tables(owner_def_id);\n "}, {"sha": "a1d3357faf56684931ee9e2899c59e93bb665555", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -51,4 +51,6 @@ mod borrowck;\n \n pub mod graphviz;\n \n+pub use borrowck::provide;\n+\n __build_diagnostic_array! { librustc_borrowck, DIAGNOSTICS }"}, {"sha": "848e5a076bb9a3fee2b12dad3dbd8b61d8418962", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -40,6 +40,12 @@ unsafe impl<T> Array for [T; 8] {\n     const LEN: usize = 8;\n }\n \n+unsafe impl<T> Array for [T; 32] {\n+    type Element = T;\n+    type PartialStorage = [ManuallyDrop<T>; 32];\n+    const LEN: usize = 32;\n+}\n+\n pub struct ArrayVec<A: Array> {\n     count: usize,\n     values: A::PartialStorage"}, {"sha": "bdef9fefd41e4ab07535ab83a00c466eac1c5d0f", "filename": "src/librustc_data_structures/blake2b.rs", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_data_structures%2Fblake2b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_data_structures%2Fblake2b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fblake2b.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -29,16 +29,23 @@ pub struct Blake2bCtx {\n     t: [u64; 2],\n     c: usize,\n     outlen: u16,\n-    finalized: bool\n+    finalized: bool,\n+\n+    #[cfg(debug_assertions)]\n+    fnv_hash: u64,\n }\n \n+#[cfg(debug_assertions)]\n impl ::std::fmt::Debug for Blake2bCtx {\n-    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n-        try!(write!(fmt, \"hash: \"));\n-        for v in &self.h {\n-            try!(write!(fmt, \"{:x}\", v));\n-        }\n-        Ok(())\n+    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+        write!(fmt, \"{:x}\", self.fnv_hash)\n+    }\n+}\n+\n+#[cfg(not(debug_assertions))]\n+impl ::std::fmt::Debug for Blake2bCtx {\n+    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+        write!(fmt, \"Enable debug_assertions() for more info.\")\n     }\n }\n \n@@ -157,6 +164,9 @@ fn blake2b_new(outlen: usize, key: &[u8]) -> Blake2bCtx {\n         c: 0,\n         outlen: outlen as u16,\n         finalized: false,\n+\n+        #[cfg(debug_assertions)]\n+        fnv_hash: 0xcbf29ce484222325,\n     };\n \n     ctx.h[0] ^= 0x01010000 ^ ((key.len() << 8) as u64) ^ (outlen as u64);\n@@ -194,6 +204,16 @@ fn blake2b_update(ctx: &mut Blake2bCtx, mut data: &[u8]) {\n         checked_mem_copy(data, &mut ctx.b[ctx.c .. ], bytes_to_copy);\n         ctx.c += bytes_to_copy;\n     }\n+\n+    #[cfg(debug_assertions)]\n+    {\n+        // compute additional FNV hash for simpler to read debug output\n+        const MAGIC_PRIME: u64 = 0x00000100000001b3;\n+\n+        for &byte in data {\n+            ctx.fnv_hash = (ctx.fnv_hash ^ byte as u64).wrapping_mul(MAGIC_PRIME);\n+        }\n+    }\n }\n \n fn blake2b_final(ctx: &mut Blake2bCtx)"}, {"sha": "00c46d992bfd5a05498e6b58b5c84f40b1952a0a", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -40,6 +40,7 @@\n #![feature(discriminant_value)]\n #![feature(specialization)]\n #![feature(manually_drop)]\n+#![feature(struct_field_attributes)]\n \n #![cfg_attr(unix, feature(libc))]\n #![cfg_attr(test, feature(test))]"}, {"sha": "95f063976d491018a44cc55c149d40dec931a1ed", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -40,13 +40,18 @@ fn write_signed_leb128_to_buf(buf: &mut [u8; 16], value: i64) -> usize {\n /// This hasher currently always uses the stable Blake2b algorithm\n /// and allows for variable output lengths through its type\n /// parameter.\n-#[derive(Debug)]\n pub struct StableHasher<W> {\n     state: Blake2bHasher,\n     bytes_hashed: u64,\n     width: PhantomData<W>,\n }\n \n+impl<W: StableHasherResult> ::std::fmt::Debug for StableHasher<W> {\n+    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+        write!(f, \"{:?}\", self.state)\n+    }\n+}\n+\n pub trait StableHasherResult: Sized {\n     fn finish(hasher: StableHasher<Self>) -> Self;\n }"}, {"sha": "2631108aeb5fa3563c6f004d791927b8a2d080c5", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -9,11 +9,14 @@\n // except according to those terms.\n \n use bitvec::BitMatrix;\n+use stable_hasher::{HashStable, StableHasher, StableHasherResult};\n use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n use std::cell::RefCell;\n use std::fmt::Debug;\n use std::mem;\n \n+\n+\n #[derive(Clone)]\n pub struct TransitiveRelation<T: Debug + PartialEq> {\n     // List of elements. This is used to map from a T to a usize.  We\n@@ -334,6 +337,49 @@ impl<T> Decodable for TransitiveRelation<T>\n     }\n }\n \n+impl<CTX, T> HashStable<CTX> for TransitiveRelation<T>\n+    where T: HashStable<CTX> + PartialEq + Debug\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        // We are assuming here that the relation graph has been built in a\n+        // deterministic way and we can just hash it the way it is.\n+        let TransitiveRelation {\n+            ref elements,\n+            ref edges,\n+            // \"closure\" is just a copy of the data above\n+            closure: _\n+        } = *self;\n+\n+        elements.hash_stable(hcx, hasher);\n+        edges.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for Edge {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        let Edge {\n+            ref source,\n+            ref target,\n+        } = *self;\n+\n+        source.hash_stable(hcx, hasher);\n+        target.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for Index {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        let Index(idx) = *self;\n+        idx.hash_stable(hcx, hasher);\n+    }\n+}\n+\n #[test]\n fn test_one_step() {\n     let mut relation = TransitiveRelation::new();"}, {"sha": "20ae561431b5491151c7fca1236cd61334b14b3a", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -35,7 +35,7 @@ use rustc_typeck as typeck;\n use rustc_privacy;\n use rustc_plugin::registry::Registry;\n use rustc_plugin as plugin;\n-use rustc_passes::{ast_validation, no_asm, loops, consts, rvalues,\n+use rustc_passes::{ast_validation, no_asm, loops, consts,\n                    static_recursion, hir_stats, mir_stats};\n use rustc_const_eval::check_match;\n use super::Compilation;\n@@ -891,6 +891,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     let mut local_providers = ty::maps::Providers::default();\n     mir::provide(&mut local_providers);\n     rustc_privacy::provide(&mut local_providers);\n+    borrowck::provide(&mut local_providers);\n     typeck::provide(&mut local_providers);\n     ty::provide(&mut local_providers);\n     reachable::provide(&mut local_providers);\n@@ -957,10 +958,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"liveness checking\",\n              || middle::liveness::check_crate(tcx));\n \n-        time(time_passes,\n-             \"rvalue checking\",\n-             || rvalues::check_crate(tcx));\n-\n         time(time_passes,\n              \"MIR dump\",\n              || mir::mir_map::build_mir_for_crate(tcx));\n@@ -976,8 +973,8 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n             // in stage 4 below.\n             passes.push_hook(box mir::transform::dump_mir::DumpMir);\n             passes.push_pass(box mir::transform::simplify::SimplifyCfg::new(\"initial\"));\n-            passes.push_pass(box mir::transform::qualify_consts::QualifyAndPromoteConstants);\n             passes.push_pass(box mir::transform::type_check::TypeckMir);\n+            passes.push_pass(box mir::transform::qualify_consts::QualifyAndPromoteConstants);\n             passes.push_pass(\n                 box mir::transform::simplify_branches::SimplifyBranches::new(\"initial\"));\n             passes.push_pass(box mir::transform::simplify::SimplifyCfg::new(\"qualify-consts\"));\n@@ -1083,6 +1080,7 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n          \"serialize dep graph\",\n          || rustc_incremental::save_dep_graph(tcx,\n                                               &incremental_hashes_map,\n+                                              &translation.metadata.hashes,\n                                               translation.link.crate_hash));\n     translation\n }"}, {"sha": "9715ace3e2e2e5a6eb43f32d725c98a68ce15c1e", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 60, "deletions": 12, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -35,6 +35,46 @@ pub struct SubDiagnostic {\n     pub render_span: Option<RenderSpan>,\n }\n \n+#[derive(PartialEq, Eq)]\n+pub struct DiagnosticStyledString(pub Vec<StringPart>);\n+\n+impl DiagnosticStyledString {\n+    pub fn new() -> DiagnosticStyledString {\n+        DiagnosticStyledString(vec![])\n+    }\n+    pub fn push_normal<S: Into<String>>(&mut self, t: S) {\n+        self.0.push(StringPart::Normal(t.into()));\n+    }\n+    pub fn push_highlighted<S: Into<String>>(&mut self, t: S) {\n+        self.0.push(StringPart::Highlighted(t.into()));\n+    }\n+    pub fn normal<S: Into<String>>(t: S) -> DiagnosticStyledString {\n+        DiagnosticStyledString(vec![StringPart::Normal(t.into())])\n+    }\n+\n+    pub fn highlighted<S: Into<String>>(t: S) -> DiagnosticStyledString {\n+        DiagnosticStyledString(vec![StringPart::Highlighted(t.into())])\n+    }\n+\n+    pub fn content(&self) -> String {\n+        self.0.iter().map(|x| x.content()).collect::<String>()\n+    }\n+}\n+\n+#[derive(PartialEq, Eq)]\n+pub enum StringPart {\n+    Normal(String),\n+    Highlighted(String),\n+}\n+\n+impl StringPart {\n+    pub fn content(&self) -> String {\n+        match self {\n+            &StringPart::Normal(ref s) | & StringPart::Highlighted(ref s) => s.to_owned()\n+        }\n+    }\n+}\n+\n impl Diagnostic {\n     pub fn new(level: Level, message: &str) -> Self {\n         Diagnostic::new_with_code(level, None, message)\n@@ -81,30 +121,38 @@ impl Diagnostic {\n \n     pub fn note_expected_found(&mut self,\n                                label: &fmt::Display,\n-                               expected: &fmt::Display,\n-                               found: &fmt::Display)\n+                               expected: DiagnosticStyledString,\n+                               found: DiagnosticStyledString)\n                                -> &mut Self\n     {\n         self.note_expected_found_extra(label, expected, found, &\"\", &\"\")\n     }\n \n     pub fn note_expected_found_extra(&mut self,\n                                      label: &fmt::Display,\n-                                     expected: &fmt::Display,\n-                                     found: &fmt::Display,\n+                                     expected: DiagnosticStyledString,\n+                                     found: DiagnosticStyledString,\n                                      expected_extra: &fmt::Display,\n                                      found_extra: &fmt::Display)\n                                      -> &mut Self\n     {\n+        let mut msg: Vec<_> = vec![(format!(\"expected {} `\", label), Style::NoStyle)];\n+        msg.extend(expected.0.iter()\n+                   .map(|x| match *x {\n+                       StringPart::Normal(ref s) => (s.to_owned(), Style::NoStyle),\n+                       StringPart::Highlighted(ref s) => (s.to_owned(), Style::Highlight),\n+                   }));\n+        msg.push((format!(\"`{}\\n\", expected_extra), Style::NoStyle));\n+        msg.push((format!(\"   found {} `\", label), Style::NoStyle));\n+        msg.extend(found.0.iter()\n+                   .map(|x| match *x {\n+                       StringPart::Normal(ref s) => (s.to_owned(), Style::NoStyle),\n+                       StringPart::Highlighted(ref s) => (s.to_owned(), Style::Highlight),\n+                   }));\n+        msg.push((format!(\"`{}\", found_extra), Style::NoStyle));\n+\n         // For now, just attach these as notes\n-        self.highlighted_note(vec![\n-            (format!(\"expected {} `\", label), Style::NoStyle),\n-            (format!(\"{}\", expected), Style::Highlight),\n-            (format!(\"`{}\\n\", expected_extra), Style::NoStyle),\n-            (format!(\"   found {} `\", label), Style::NoStyle),\n-            (format!(\"{}\", found), Style::Highlight),\n-            (format!(\"`{}\", found_extra), Style::NoStyle),\n-        ]);\n+        self.highlighted_note(msg);\n         self\n     }\n "}, {"sha": "7b27f13951b61b5babf4bc9c32ab37c71f5d8f10", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n use Diagnostic;\n+use DiagnosticStyledString;\n+\n use Level;\n use Handler;\n use std::fmt::{self, Debug};\n@@ -115,14 +117,14 @@ impl<'a> DiagnosticBuilder<'a> {\n \n     forward!(pub fn note_expected_found(&mut self,\n                                         label: &fmt::Display,\n-                                        expected: &fmt::Display,\n-                                        found: &fmt::Display)\n+                                        expected: DiagnosticStyledString,\n+                                        found: DiagnosticStyledString)\n                                         -> &mut Self);\n \n     forward!(pub fn note_expected_found_extra(&mut self,\n                                               label: &fmt::Display,\n-                                              expected: &fmt::Display,\n-                                              found: &fmt::Display,\n+                                              expected: DiagnosticStyledString,\n+                                              found: DiagnosticStyledString,\n                                               expected_extra: &fmt::Display,\n                                               found_extra: &fmt::Display)\n                                               -> &mut Self);"}, {"sha": "da29e354a7014eeae31e26f438f63fac7dad4d74", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -203,7 +203,7 @@ impl error::Error for ExplicitBug {\n     }\n }\n \n-pub use diagnostic::{Diagnostic, SubDiagnostic};\n+pub use diagnostic::{Diagnostic, SubDiagnostic, DiagnosticStyledString, StringPart};\n pub use diagnostic_builder::DiagnosticBuilder;\n \n /// A handler deals with errors; certain errors"}, {"sha": "8a1af5dd08d74d7dfb85dac9ff9d94e5acbbcd9b", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -13,6 +13,7 @@\n use rustc::dep_graph::{DepNode, WorkProduct, WorkProductId};\n use rustc::hir::def_id::DefIndex;\n use rustc::ich::Fingerprint;\n+use rustc::middle::cstore::EncodedMetadataHash;\n use std::sync::Arc;\n use rustc_data_structures::fx::FxHashMap;\n \n@@ -98,7 +99,7 @@ pub struct SerializedMetadataHashes {\n     /// where `X` refers to some item in this crate. That `X` will be\n     /// a `DefPathIndex` that gets retracted to the current `DefId`\n     /// (matching the one found in this structure).\n-    pub hashes: Vec<SerializedMetadataHash>,\n+    pub hashes: Vec<EncodedMetadataHash>,\n \n     /// For each DefIndex (as it occurs in SerializedMetadataHash), this\n     /// map stores the DefPathIndex (as it occurs in DefIdDirectory), so\n@@ -112,14 +113,3 @@ pub struct SerializedMetadataHashes {\n     /// the DefIndex.\n     pub index_map: FxHashMap<DefIndex, DefPathIndex>\n }\n-\n-/// The hash for some metadata that (when saving) will be exported\n-/// from this crate, or which (when importing) was exported by an\n-/// upstream crate.\n-#[derive(Debug, RustcEncodable, RustcDecodable)]\n-pub struct SerializedMetadataHash {\n-    pub def_index: DefIndex,\n-\n-    /// the hash itself, computed by `calculate_item_hash`\n-    pub hash: Fingerprint,\n-}"}, {"sha": "af5c1f05bd1fcdd82ad0393b6c93b9b46e3cf4cc", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 48, "deletions": 16, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -215,9 +215,11 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_dirty_clean_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  prev_metadata_hashes: &FxHashMap<DefId, Fingerprint>,\n-                                  current_metadata_hashes: &FxHashMap<DefId, Fingerprint>) {\n+pub fn check_dirty_clean_metadata<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    prev_metadata_hashes: &FxHashMap<DefId, Fingerprint>,\n+    current_metadata_hashes: &FxHashMap<DefId, Fingerprint>)\n+{\n     if !tcx.sess.opts.debugging_opts.query_dep_graph {\n         return;\n     }\n@@ -230,7 +232,7 @@ pub fn check_dirty_clean_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             current_metadata_hashes: current_metadata_hashes,\n             checked_attrs: FxHashSet(),\n         };\n-        krate.visit_all_item_likes(&mut dirty_clean_visitor);\n+        intravisit::walk_crate(&mut dirty_clean_visitor, krate);\n \n         let mut all_attrs = FindAllAttrs {\n             tcx: tcx,\n@@ -246,30 +248,58 @@ pub fn check_dirty_clean_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     });\n }\n \n-pub struct DirtyCleanMetadataVisitor<'a, 'tcx:'a, 'm> {\n+pub struct DirtyCleanMetadataVisitor<'a, 'tcx: 'a, 'm> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     prev_metadata_hashes: &'m FxHashMap<DefId, Fingerprint>,\n     current_metadata_hashes: &'m FxHashMap<DefId, Fingerprint>,\n     checked_attrs: FxHashSet<ast::AttrId>,\n }\n \n-impl<'a, 'tcx, 'm> ItemLikeVisitor<'tcx> for DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {\n+impl<'a, 'tcx, 'm> intravisit::Visitor<'tcx> for DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n+        intravisit::NestedVisitorMap::All(&self.tcx.hir)\n+    }\n+\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         self.check_item(item.id, item.span);\n+        intravisit::walk_item(self, item);\n+    }\n \n-        if let hir::ItemEnum(ref def, _) = item.node {\n-            for v in &def.variants {\n-                self.check_item(v.node.data.id(), v.span);\n-            }\n+    fn visit_variant_data(&mut self,\n+                          variant_data: &'tcx hir::VariantData,\n+                          _: ast::Name,\n+                          _: &'tcx hir::Generics,\n+                          _parent_id: ast::NodeId,\n+                          span: Span) {\n+        if self.tcx.hir.find(variant_data.id()).is_some() {\n+            // VariantData that represent structs or tuples don't have a\n+            // separate entry in the HIR map and checking them would error,\n+            // so only check if this is an enum or union variant.\n+            self.check_item(variant_data.id(), span);\n         }\n+\n+        intravisit::walk_struct_def(self, variant_data);\n     }\n \n-    fn visit_trait_item(&mut self, item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n         self.check_item(item.id, item.span);\n+        intravisit::walk_trait_item(self, item);\n     }\n \n-    fn visit_impl_item(&mut self, item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n         self.check_item(item.id, item.span);\n+        intravisit::walk_impl_item(self, item);\n+    }\n+\n+    fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem) {\n+        self.check_item(i.id, i.span);\n+        intravisit::walk_foreign_item(self, i);\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n+        self.check_item(s.id, s.span);\n+        intravisit::walk_struct_field(self, s);\n     }\n }\n \n@@ -281,13 +311,15 @@ impl<'a, 'tcx, 'm> DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {\n         for attr in self.tcx.get_attrs(def_id).iter() {\n             if attr.check_name(ATTR_DIRTY_METADATA) {\n                 if check_config(self.tcx, attr) {\n-                    self.checked_attrs.insert(attr.id);\n-                    self.assert_state(false, def_id, item_span);\n+                    if self.checked_attrs.insert(attr.id) {\n+                        self.assert_state(false, def_id, item_span);\n+                    }\n                 }\n             } else if attr.check_name(ATTR_CLEAN_METADATA) {\n                 if check_config(self.tcx, attr) {\n-                    self.checked_attrs.insert(attr.id);\n-                    self.assert_state(true, def_id, item_span);\n+                    if self.checked_attrs.insert(attr.id) {\n+                        self.assert_state(true, def_id, item_span);\n+                    }\n                 }\n             }\n         }"}, {"sha": "e769641a4cadf2094e42e6fc14fc3004667e014d", "filename": "src/librustc_incremental/persist/preds/mod.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -44,16 +44,18 @@ impl<'q> Predecessors<'q> {\n     pub fn new(query: &'q DepGraphQuery<DefId>, hcx: &mut HashContext) -> Self {\n         let tcx = hcx.tcx;\n \n-        let collect_for_metadata = tcx.sess.opts.debugging_opts.incremental_cc ||\n-            tcx.sess.opts.debugging_opts.query_dep_graph;\n-\n         // Find the set of \"start nodes\". These are nodes that we will\n         // possibly query later.\n         let is_output = |node: &DepNode<DefId>| -> bool {\n             match *node {\n                 DepNode::WorkProduct(_) => true,\n-                DepNode::MetaData(ref def_id) => collect_for_metadata && def_id.is_local(),\n-\n+                DepNode::MetaData(ref def_id) => {\n+                    // We do *not* create dep-nodes for the current crate's\n+                    // metadata anymore, just for metadata that we import/read\n+                    // from other crates.\n+                    debug_assert!(!def_id.is_local());\n+                    false\n+                }\n                 // if -Z query-dep-graph is passed, save more extended data\n                 // to enable better unit testing\n                 DepNode::TypeckTables(_) |\n@@ -75,6 +77,22 @@ impl<'q> Predecessors<'q> {\n                   .or_insert_with(|| hcx.hash(input).unwrap());\n         }\n \n+        if tcx.sess.opts.debugging_opts.query_dep_graph {\n+            // Not all inputs might have been reachable from an output node,\n+            // but we still want their hash for our unit tests.\n+            let hir_nodes = query.graph.all_nodes().iter().filter_map(|node| {\n+                match node.data {\n+                    DepNode::Hir(_) => Some(&node.data),\n+                    _ => None,\n+                }\n+            });\n+\n+            for node in hir_nodes {\n+                hashes.entry(node)\n+                      .or_insert_with(|| hcx.hash(node).unwrap());\n+            }\n+        }\n+\n         let bootstrap_outputs: Vec<&'q DepNode<DefId>> =\n             (0 .. graph.len_nodes())\n             .map(NodeIndex)"}, {"sha": "1864009fbdf21f119b2ff80dec63f02c2118ea19", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 8, "deletions": 73, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -12,13 +12,12 @@ use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n use rustc::hir::svh::Svh;\n use rustc::ich::Fingerprint;\n+use rustc::middle::cstore::EncodedMetadataHash;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::graph::{NodeIndex, INCOMING};\n use rustc_serialize::Encodable as RustcEncodable;\n use rustc_serialize::opaque::Encoder;\n-use std::hash::Hash;\n use std::io::{self, Cursor, Write};\n use std::fs::{self, File};\n use std::path::PathBuf;\n@@ -32,10 +31,10 @@ use super::fs::*;\n use super::dirty_clean;\n use super::file_format;\n use super::work_product;\n-use calculate_svh::IchHasher;\n \n pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 incremental_hashes_map: &IncrementalHashesMap,\n+                                metadata_hashes: &[EncodedMetadataHash],\n                                 svh: Svh) {\n     debug!(\"save_dep_graph()\");\n     let _ignore = tcx.dep_graph.in_ignore();\n@@ -56,16 +55,16 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let preds = Predecessors::new(&query, &mut hcx);\n     let mut current_metadata_hashes = FxHashMap();\n \n+    // IMPORTANT: We are saving the metadata hashes *before* the dep-graph,\n+    //            since metadata-encoding might add new entries to the\n+    //            DefIdDirectory (which is saved in the dep-graph file).\n     if sess.opts.debugging_opts.incremental_cc ||\n        sess.opts.debugging_opts.query_dep_graph {\n-        // IMPORTANT: We are saving the metadata hashes *before* the dep-graph,\n-        //            since metadata-encoding might add new entries to the\n-        //            DefIdDirectory (which is saved in the dep-graph file).\n         save_in(sess,\n                 metadata_hash_export_path(sess),\n                 |e| encode_metadata_hashes(tcx,\n                                            svh,\n-                                           &preds,\n+                                           metadata_hashes,\n                                            &mut builder,\n                                            &mut current_metadata_hashes,\n                                            e));\n@@ -241,80 +240,16 @@ pub fn encode_dep_graph(preds: &Predecessors,\n \n pub fn encode_metadata_hashes(tcx: TyCtxt,\n                               svh: Svh,\n-                              preds: &Predecessors,\n+                              metadata_hashes: &[EncodedMetadataHash],\n                               builder: &mut DefIdDirectoryBuilder,\n                               current_metadata_hashes: &mut FxHashMap<DefId, Fingerprint>,\n                               encoder: &mut Encoder)\n                               -> io::Result<()> {\n-    // For each `MetaData(X)` node where `X` is local, accumulate a\n-    // hash.  These are the metadata items we export. Downstream\n-    // crates will want to see a hash that tells them whether we might\n-    // have changed the metadata for a given item since they last\n-    // compiled.\n-    //\n-    // (I initially wrote this with an iterator, but it seemed harder to read.)\n     let mut serialized_hashes = SerializedMetadataHashes {\n-        hashes: vec![],\n+        hashes: metadata_hashes.to_vec(),\n         index_map: FxHashMap()\n     };\n \n-    for (index, target) in preds.reduced_graph.all_nodes().iter().enumerate() {\n-        let index = NodeIndex(index);\n-        let def_id = match *target.data {\n-            DepNode::MetaData(def_id) if def_id.is_local() => def_id,\n-            _ => continue,\n-        };\n-\n-        // To create the hash for each item `X`, we don't hash the raw\n-        // bytes of the metadata (though in principle we\n-        // could). Instead, we walk the predecessors of `MetaData(X)`\n-        // from the dep-graph. This corresponds to all the inputs that\n-        // were read to construct the metadata. To create the hash for\n-        // the metadata, we hash (the hash of) all of those inputs.\n-        debug!(\"save: computing metadata hash for {:?}\", def_id);\n-\n-        // Create a vector containing a pair of (source-id, hash).\n-        // The source-id is stored as a `DepNode<u64>`, where the u64\n-        // is the det. hash of the def-path. This is convenient\n-        // because we can sort this to get a stable ordering across\n-        // compilations, even if the def-ids themselves have changed.\n-        let mut hashes: Vec<(DepNode<u64>, Fingerprint)> =\n-            preds.reduced_graph\n-                 .depth_traverse(index, INCOMING)\n-                 .map(|index| preds.reduced_graph.node_data(index))\n-                 .filter(|dep_node| HashContext::is_hashable(dep_node))\n-                 .map(|dep_node| {\n-                     let hash_dep_node = dep_node.map_def(|&def_id| Some(tcx.def_path_hash(def_id)))\n-                                                 .unwrap();\n-                     let hash = preds.hashes[dep_node];\n-                     (hash_dep_node, hash)\n-                 })\n-                 .collect();\n-\n-        hashes.sort();\n-        let mut state = IchHasher::new();\n-        hashes.hash(&mut state);\n-        let hash = state.finish();\n-\n-        debug!(\"save: metadata hash for {:?} is {}\", def_id, hash);\n-\n-        if tcx.sess.opts.debugging_opts.incremental_dump_hash {\n-            println!(\"metadata hash for {:?} is {}\", def_id, hash);\n-            for pred_index in preds.reduced_graph.depth_traverse(index, INCOMING) {\n-                let dep_node = preds.reduced_graph.node_data(pred_index);\n-                if HashContext::is_hashable(&dep_node) {\n-                    println!(\"metadata hash for {:?} depends on {:?} with hash {}\",\n-                             def_id, dep_node, preds.hashes[dep_node]);\n-                }\n-            }\n-        }\n-\n-        serialized_hashes.hashes.push(SerializedMetadataHash {\n-            def_index: def_id.index,\n-            hash: hash,\n-        });\n-    }\n-\n     if tcx.sess.opts.debugging_opts.query_dep_graph {\n         for serialized_hash in &serialized_hashes.hashes {\n             let def_id = DefId::local(serialized_hash.def_index);"}, {"sha": "d9008ce555cc17afa48a0e4924f3dba299450dc9", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -10,14 +10,12 @@\n \n use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n \n-use encoder::EncodeContext;\n+use index_builder::EntryBuilder;\n use schema::*;\n \n use rustc::hir;\n use rustc::ty;\n \n-use rustc_serialize::Encodable;\n-\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Ast<'tcx> {\n     pub body: Lazy<hir::Body>,\n@@ -26,51 +24,53 @@ pub struct Ast<'tcx> {\n     pub rvalue_promotable_to_static: bool,\n }\n \n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n+impl_stable_hash_for!(struct Ast<'tcx> {\n+    body,\n+    tables,\n+    nested_bodies,\n+    rvalue_promotable_to_static\n+});\n+\n+impl<'a, 'b, 'tcx> EntryBuilder<'a, 'b, 'tcx> {\n     pub fn encode_body(&mut self, body_id: hir::BodyId) -> Lazy<Ast<'tcx>> {\n         let body = self.tcx.hir.body(body_id);\n         let lazy_body = self.lazy(body);\n \n         let tables = self.tcx.body_tables(body_id);\n         let lazy_tables = self.lazy(tables);\n \n-        let nested_pos = self.position();\n-        let nested_count = {\n-            let mut visitor = NestedBodyEncodingVisitor {\n-                ecx: self,\n-                count: 0,\n-            };\n-            visitor.visit_body(body);\n-            visitor.count\n+        let mut visitor = NestedBodyCollector {\n+            tcx: self.tcx,\n+            bodies_found: Vec::new(),\n         };\n+        visitor.visit_body(body);\n+        let lazy_nested_bodies = self.lazy_seq_ref_from_slice(&visitor.bodies_found);\n \n         let rvalue_promotable_to_static =\n             self.tcx.rvalue_promotable_to_static.borrow()[&body.value.id];\n \n         self.lazy(&Ast {\n             body: lazy_body,\n             tables: lazy_tables,\n-            nested_bodies: LazySeq::with_position_and_length(nested_pos, nested_count),\n+            nested_bodies: lazy_nested_bodies,\n             rvalue_promotable_to_static: rvalue_promotable_to_static\n         })\n     }\n }\n \n-struct NestedBodyEncodingVisitor<'a, 'b: 'a, 'tcx: 'b> {\n-    ecx: &'a mut EncodeContext<'b, 'tcx>,\n-    count: usize,\n+struct NestedBodyCollector<'a, 'tcx: 'a> {\n+    tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+    bodies_found: Vec<&'tcx hir::Body>,\n }\n \n-impl<'a, 'b, 'tcx> Visitor<'tcx> for NestedBodyEncodingVisitor<'a, 'b, 'tcx> {\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for NestedBodyCollector<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let body = self.ecx.tcx.hir.body(body);\n-        body.encode(self.ecx).unwrap();\n-        self.count += 1;\n-\n+        let body = self.tcx.hir.body(body);\n+        self.bodies_found.push(body);\n         self.visit_body(body);\n     }\n }"}, {"sha": "3239dfb937b5e79bd170036a0d232252d159f450", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -14,8 +14,9 @@ use locator;\n use schema;\n \n use rustc::dep_graph::DepTrackingMapConfig;\n-use rustc::middle::cstore::{CrateStore, CrateSource, LibSource, DepKind, ExternCrate};\n-use rustc::middle::cstore::{NativeLibrary, LinkMeta, LinkagePreference, LoadedMacro};\n+use rustc::middle::cstore::{CrateStore, CrateSource, LibSource, DepKind,\n+                            ExternCrate, NativeLibrary, LinkMeta,\n+                            LinkagePreference, LoadedMacro, EncodedMetadata};\n use rustc::hir::def::{self, Def};\n use rustc::middle::lang_items;\n use rustc::session::Session;\n@@ -498,7 +499,8 @@ impl CrateStore for cstore::CStore {\n     fn encode_metadata<'a, 'tcx>(&self,\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  link_meta: &LinkMeta,\n-                                 reachable: &NodeSet) -> Vec<u8>\n+                                 reachable: &NodeSet)\n+                                 -> EncodedMetadata\n     {\n         encoder::encode_metadata(tcx, self, link_meta, reachable)\n     }"}, {"sha": "ffe68094c6afc0d46b130e82a23e71333af414f7", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 71, "deletions": 33, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -12,7 +12,8 @@ use cstore;\n use index::Index;\n use schema::*;\n \n-use rustc::middle::cstore::{LinkMeta, LinkagePreference, NativeLibrary};\n+use rustc::middle::cstore::{LinkMeta, LinkagePreference, NativeLibrary,\n+                            EncodedMetadata, EncodedMetadataHash};\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefIndex, DefId};\n use rustc::hir::map::definitions::DefPathTable;\n use rustc::middle::dependency_format::Linkage;\n@@ -42,7 +43,7 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n use rustc::hir::intravisit;\n \n-use super::index_builder::{FromId, IndexBuilder, Untracked};\n+use super::index_builder::{FromId, IndexBuilder, Untracked, EntryBuilder};\n \n pub struct EncodeContext<'a, 'tcx: 'a> {\n     opaque: opaque::Encoder<'a>,\n@@ -54,6 +55,8 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     lazy_state: LazyState,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n+\n+    pub metadata_hashes: Vec<EncodedMetadataHash>,\n }\n \n macro_rules! encoder_methods {\n@@ -172,7 +175,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         })\n     }\n \n-    fn lazy_seq<I, T>(&mut self, iter: I) -> LazySeq<T>\n+    pub fn lazy_seq<I, T>(&mut self, iter: I) -> LazySeq<T>\n         where I: IntoIterator<Item = T>,\n               T: Encodable\n     {\n@@ -184,7 +187,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         })\n     }\n \n-    fn lazy_seq_ref<'b, I, T>(&mut self, iter: I) -> LazySeq<T>\n+    pub fn lazy_seq_ref<'b, I, T>(&mut self, iter: I) -> LazySeq<T>\n         where I: IntoIterator<Item = &'b T>,\n               T: 'b + Encodable\n     {\n@@ -233,15 +236,20 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         Ok(())\n     }\n+}\n \n+impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     fn encode_item_variances(&mut self, def_id: DefId) -> LazySeq<ty::Variance> {\n+        debug!(\"EntryBuilder::encode_item_variances({:?})\", def_id);\n         let tcx = self.tcx;\n-        self.lazy_seq(tcx.item_variances(def_id).iter().cloned())\n+        self.lazy_seq_from_slice(&tcx.item_variances(def_id))\n     }\n \n     fn encode_item_type(&mut self, def_id: DefId) -> Lazy<Ty<'tcx>> {\n         let tcx = self.tcx;\n-        self.lazy(&tcx.item_type(def_id))\n+        let ty = tcx.item_type(def_id);\n+        debug!(\"EntryBuilder::encode_item_type({:?}) => {:?}\", def_id, ty);\n+        self.lazy(&ty)\n     }\n \n     /// Encode data for the given variant of the given ADT. The\n@@ -256,6 +264,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let def = tcx.lookup_adt_def(enum_did);\n         let variant = &def.variants[index];\n         let def_id = variant.did;\n+        debug!(\"EntryBuilder::encode_enum_variant_info({:?})\", def_id);\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n@@ -302,10 +311,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                            -> Entry<'tcx> {\n         let tcx = self.tcx;\n         let def_id = tcx.hir.local_def_id(id);\n+        debug!(\"EntryBuilder::encode_info_for_mod({:?})\", def_id);\n \n         let data = ModData {\n             reexports: match tcx.export_map.get(&id) {\n-                Some(exports) if *vis == hir::Public => self.lazy_seq_ref(exports),\n+                Some(exports) if *vis == hir::Public => {\n+                    self.lazy_seq_from_slice(exports.as_slice())\n+                }\n                 _ => LazySeq::empty(),\n             },\n         };\n@@ -339,14 +351,14 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n         for (variant_index, variant) in def.variants.iter().enumerate() {\n             for (field_index, field) in variant.fields.iter().enumerate() {\n                 self.record(field.did,\n-                            EncodeContext::encode_field,\n+                            EntryBuilder::encode_field,\n                             (adt_def_id, Untracked((variant_index, field_index))));\n             }\n         }\n     }\n }\n \n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n+impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     /// Encode data for the given field of the given variant of the\n     /// given ADT. The indices of the variant/field are untracked:\n     /// this is ok because we will have to lookup the adt-def by its\n@@ -363,6 +375,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let field = &variant.fields[field_index];\n \n         let def_id = field.did;\n+        debug!(\"EntryBuilder::encode_field({:?})\", def_id);\n+\n         let variant_id = tcx.hir.as_local_node_id(variant.did).unwrap();\n         let variant_data = tcx.hir.expect_variant_data(variant_id);\n \n@@ -387,6 +401,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_struct_ctor(&mut self, (adt_def_id, def_id): (DefId, DefId)) -> Entry<'tcx> {\n+        debug!(\"EntryBuilder::encode_struct_ctor({:?})\", def_id);\n         let tcx = self.tcx;\n         let variant = tcx.lookup_adt_def(adt_def_id).struct_variant();\n \n@@ -429,16 +444,19 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_generics(&mut self, def_id: DefId) -> Lazy<ty::Generics> {\n+        debug!(\"EntryBuilder::encode_generics({:?})\", def_id);\n         let tcx = self.tcx;\n         self.lazy(tcx.item_generics(def_id))\n     }\n \n     fn encode_predicates(&mut self, def_id: DefId) -> Lazy<ty::GenericPredicates<'tcx>> {\n+        debug!(\"EntryBuilder::encode_predicates({:?})\", def_id);\n         let tcx = self.tcx;\n         self.lazy(&tcx.item_predicates(def_id))\n     }\n \n     fn encode_info_for_trait_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n+        debug!(\"EntryBuilder::encode_info_for_trait_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n         let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n@@ -521,6 +539,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_info_for_impl_item(&mut self, def_id: DefId) -> Entry<'tcx> {\n+        debug!(\"EntryBuilder::encode_info_for_impl_item({:?})\", def_id);\n         let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n         let ast_item = self.tcx.hir.expect_impl_item(node_id);\n         let impl_item = self.tcx.associated_item(def_id);\n@@ -607,11 +626,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_mir(&mut self, def_id: DefId) -> Option<Lazy<mir::Mir<'tcx>>> {\n+        debug!(\"EntryBuilder::encode_mir({:?})\", def_id);\n         self.tcx.maps.mir.borrow().get(&def_id).map(|mir| self.lazy(&*mir.borrow()))\n     }\n \n     // Encodes the inherent implementations of a structure, enumeration, or trait.\n     fn encode_inherent_implementations(&mut self, def_id: DefId) -> LazySeq<DefIndex> {\n+        debug!(\"EntryBuilder::encode_inherent_implementations({:?})\", def_id);\n         match self.tcx.maps.inherent_impls.borrow().get(&def_id) {\n             None => LazySeq::empty(),\n             Some(implementations) => {\n@@ -624,18 +645,19 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_stability(&mut self, def_id: DefId) -> Option<Lazy<attr::Stability>> {\n+        debug!(\"EntryBuilder::encode_stability({:?})\", def_id);\n         self.tcx.lookup_stability(def_id).map(|stab| self.lazy(stab))\n     }\n \n     fn encode_deprecation(&mut self, def_id: DefId) -> Option<Lazy<attr::Deprecation>> {\n+        debug!(\"EntryBuilder::encode_deprecation({:?})\", def_id);\n         self.tcx.lookup_deprecation(def_id).map(|depr| self.lazy(&depr))\n     }\n \n     fn encode_info_for_item(&mut self, (def_id, item): (DefId, &'tcx hir::Item)) -> Entry<'tcx> {\n         let tcx = self.tcx;\n \n-        debug!(\"encoding info for item at {}\",\n-               tcx.sess.codemap().span_to_string(item.span));\n+        debug!(\"EntryBuilder::encode_info_for_item({:?})\", def_id);\n \n         let kind = match item.node {\n             hir::ItemStatic(_, hir::MutMutable, _) => EntryKind::MutStatic,\n@@ -907,7 +929,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                 let def = self.tcx.lookup_adt_def(def_id);\n                 for (i, variant) in def.variants.iter().enumerate() {\n                     self.record(variant.did,\n-                                EncodeContext::encode_enum_variant_info,\n+                                EntryBuilder::encode_enum_variant_info,\n                                 (def_id, Untracked(i)));\n                 }\n             }\n@@ -918,7 +940,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                 if !struct_def.is_struct() {\n                     let ctor_def_id = self.tcx.hir.local_def_id(struct_def.id());\n                     self.record(ctor_def_id,\n-                                EncodeContext::encode_struct_ctor,\n+                                EntryBuilder::encode_struct_ctor,\n                                 (def_id, ctor_def_id));\n                 }\n             }\n@@ -928,28 +950,28 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n             hir::ItemImpl(..) => {\n                 for &trait_item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n                     self.record(trait_item_def_id,\n-                                EncodeContext::encode_info_for_impl_item,\n+                                EntryBuilder::encode_info_for_impl_item,\n                                 trait_item_def_id);\n                 }\n             }\n             hir::ItemTrait(..) => {\n                 for &item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n                     self.record(item_def_id,\n-                                EncodeContext::encode_info_for_trait_item,\n+                                EntryBuilder::encode_info_for_trait_item,\n                                 item_def_id);\n                 }\n             }\n         }\n     }\n }\n \n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n+impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     fn encode_info_for_foreign_item(&mut self,\n                                     (def_id, nitem): (DefId, &hir::ForeignItem))\n                                     -> Entry<'tcx> {\n         let tcx = self.tcx;\n \n-        debug!(\"writing foreign item {}\", tcx.node_path_str(nitem.id));\n+        debug!(\"EntryBuilder::encode_info_for_foreign_item({:?})\", def_id);\n \n         let kind = match nitem.node {\n             hir::ForeignItemFn(_, ref names, _) => {\n@@ -1002,15 +1024,15 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n         match item.node {\n             hir::ItemExternCrate(_) |\n             hir::ItemUse(..) => (), // ignore these\n-            _ => self.index.record(def_id, EncodeContext::encode_info_for_item, (def_id, item)),\n+            _ => self.index.record(def_id, EntryBuilder::encode_info_for_item, (def_id, item)),\n         }\n         self.index.encode_addl_info_for_item(item);\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem) {\n         intravisit::walk_foreign_item(self, ni);\n         let def_id = self.index.tcx.hir.local_def_id(ni.id);\n         self.index.record(def_id,\n-                          EncodeContext::encode_info_for_foreign_item,\n+                          EntryBuilder::encode_info_for_foreign_item,\n                           (def_id, ni));\n     }\n     fn visit_generics(&mut self, generics: &'tcx hir::Generics) {\n@@ -1023,7 +1045,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n     }\n     fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef) {\n         let def_id = self.index.tcx.hir.local_def_id(macro_def.id);\n-        self.index.record(def_id, EncodeContext::encode_info_for_macro_def, macro_def);\n+        self.index.record(def_id, EntryBuilder::encode_info_for_macro_def, macro_def);\n     }\n }\n \n@@ -1032,32 +1054,33 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n         for ty_param in &generics.ty_params {\n             let def_id = self.tcx.hir.local_def_id(ty_param.id);\n             let has_default = Untracked(ty_param.default.is_some());\n-            self.record(def_id, EncodeContext::encode_info_for_ty_param, (def_id, has_default));\n+            self.record(def_id, EntryBuilder::encode_info_for_ty_param, (def_id, has_default));\n         }\n     }\n \n     fn encode_info_for_ty(&mut self, ty: &hir::Ty) {\n         if let hir::TyImplTrait(_) = ty.node {\n             let def_id = self.tcx.hir.local_def_id(ty.id);\n-            self.record(def_id, EncodeContext::encode_info_for_anon_ty, def_id);\n+            self.record(def_id, EntryBuilder::encode_info_for_anon_ty, def_id);\n         }\n     }\n \n     fn encode_info_for_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n             hir::ExprClosure(..) => {\n                 let def_id = self.tcx.hir.local_def_id(expr.id);\n-                self.record(def_id, EncodeContext::encode_info_for_closure, def_id);\n+                self.record(def_id, EntryBuilder::encode_info_for_closure, def_id);\n             }\n             _ => {}\n         }\n     }\n }\n \n-impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n+impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n     fn encode_info_for_ty_param(&mut self,\n                                 (def_id, Untracked(has_default)): (DefId, Untracked<bool>))\n                                 -> Entry<'tcx> {\n+        debug!(\"EntryBuilder::encode_info_for_ty_param({:?})\", def_id);\n         let tcx = self.tcx;\n         Entry {\n             kind: EntryKind::Type,\n@@ -1084,6 +1107,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_info_for_anon_ty(&mut self, def_id: DefId) -> Entry<'tcx> {\n+        debug!(\"EntryBuilder::encode_info_for_anon_ty({:?})\", def_id);\n         let tcx = self.tcx;\n         Entry {\n             kind: EntryKind::Type,\n@@ -1106,6 +1130,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_info_for_closure(&mut self, def_id: DefId) -> Entry<'tcx> {\n+        debug!(\"EntryBuilder::encode_info_for_closure({:?})\", def_id);\n         let tcx = self.tcx;\n \n         let data = ClosureData {\n@@ -1133,11 +1158,20 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n+    fn encode_attributes(&mut self, attrs: &[ast::Attribute]) -> LazySeq<ast::Attribute> {\n+        // NOTE: This must use lazy_seq_from_slice(), not lazy_seq() because\n+        //       we really on the HashStable specialization for [Attribute]\n+        //       to properly filter things out.\n+        self.lazy_seq_from_slice(attrs)\n+    }\n+}\n+\n+impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_info_for_items(&mut self) -> Index {\n         let krate = self.tcx.hir.krate();\n         let mut index = IndexBuilder::new(self);\n         index.record(DefId::local(CRATE_DEF_INDEX),\n-                     EncodeContext::encode_info_for_mod,\n+                     EntryBuilder::encode_info_for_mod,\n                      FromId(CRATE_NODE_ID, (&krate.module, &krate.attrs, &hir::Public)));\n         let mut visitor = EncodeVisitor { index: index };\n         krate.visit_all_item_likes(&mut visitor.as_deep_visitor());\n@@ -1147,10 +1181,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         visitor.index.into_items()\n     }\n \n-    fn encode_attributes(&mut self, attrs: &[ast::Attribute]) -> LazySeq<ast::Attribute> {\n-        self.lazy_seq_ref(attrs)\n-    }\n-\n     fn encode_crate_deps(&mut self) -> LazySeq<CrateDep> {\n         fn get_ordered_deps(cstore: &cstore::CStore) -> Vec<(CrateNum, Rc<cstore::CrateMetadata>)> {\n             // Pull the cnums and name,vers,hash out of cstore\n@@ -1298,7 +1328,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             None => LazySeq::empty(),\n         }\n     }\n+}\n \n+impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_crate_root(&mut self) -> Lazy<CrateRoot> {\n         let mut i = self.position();\n         let crate_deps = self.encode_crate_deps();\n@@ -1431,14 +1463,15 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  cstore: &cstore::CStore,\n                                  link_meta: &LinkMeta,\n                                  exported_symbols: &NodeSet)\n-                                 -> Vec<u8> {\n+                                 -> EncodedMetadata\n+{\n     let mut cursor = Cursor::new(vec![]);\n     cursor.write_all(METADATA_HEADER).unwrap();\n \n     // Will be filed with the root position after encoding everything.\n     cursor.write_all(&[0, 0, 0, 0]).unwrap();\n \n-    let root = {\n+    let (root, metadata_hashes) = {\n         let mut ecx = EncodeContext {\n             opaque: opaque::Encoder::new(&mut cursor),\n             tcx: tcx,\n@@ -1448,14 +1481,16 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             lazy_state: LazyState::NoNode,\n             type_shorthands: Default::default(),\n             predicate_shorthands: Default::default(),\n+            metadata_hashes: Vec::new(),\n         };\n \n         // Encode the rustc version string in a predictable location.\n         rustc_version().encode(&mut ecx).unwrap();\n \n         // Encode all the entries and extra information in the crate,\n         // culminating in the `CrateRoot` which points to all of it.\n-        ecx.encode_crate_root()\n+        let root = ecx.encode_crate_root();\n+        (root, ecx.metadata_hashes)\n     };\n     let mut result = cursor.into_inner();\n \n@@ -1467,7 +1502,10 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     result[header + 2] = (pos >> 8) as u8;\n     result[header + 3] = (pos >> 0) as u8;\n \n-    result\n+    EncodedMetadata {\n+        raw_data: result,\n+        hashes: metadata_hashes,\n+    }\n }\n \n pub fn get_repr_options<'a, 'tcx, 'gcx>(tcx: &TyCtxt<'a, 'tcx, 'gcx>, did: DefId) -> ReprOptions {"}, {"sha": "01f948866b85081b8ba42889f7bcdf3598d5c270", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 131, "deletions": 9, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -59,14 +59,19 @@ use encoder::EncodeContext;\n use index::Index;\n use schema::*;\n \n-use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n+use rustc::ich::{StableHashingContext, Fingerprint};\n+use rustc::middle::cstore::EncodedMetadataHash;\n use rustc::ty::TyCtxt;\n use syntax::ast;\n \n use std::ops::{Deref, DerefMut};\n \n+use rustc_data_structures::accumulate_vec::AccumulateVec;\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n+use rustc_serialize::Encodable;\n+\n /// Builder that can encode new items, adding them into the index.\n /// Item encoding cannot be nested.\n pub struct IndexBuilder<'a, 'b: 'a, 'tcx: 'b> {\n@@ -112,16 +117,45 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     /// holds, and that it is therefore not gaining \"secret\" access to\n     /// bits of HIR or other state that would not be trackd by the\n     /// content system.\n-    pub fn record<DATA>(&mut self,\n-                        id: DefId,\n-                        op: fn(&mut EncodeContext<'b, 'tcx>, DATA) -> Entry<'tcx>,\n-                        data: DATA)\n+    pub fn record<'x, DATA>(&'x mut self,\n+                            id: DefId,\n+                            op: fn(&mut EntryBuilder<'x, 'b, 'tcx>, DATA) -> Entry<'tcx>,\n+                            data: DATA)\n         where DATA: DepGraphRead\n     {\n-        let _task = self.tcx.dep_graph.in_task(DepNode::MetaData(id));\n-        data.read(self.tcx);\n-        let entry = op(&mut self.ecx, data);\n-        self.items.record(id, self.ecx.lazy(&entry));\n+        assert!(id.is_local());\n+        let tcx: TyCtxt<'b, 'tcx, 'tcx> = self.ecx.tcx;\n+\n+        // We don't track this since we are explicitly computing the incr. comp.\n+        // hashes anyway. In theory we could do some tracking here and use it to\n+        // avoid rehashing things (and instead cache the hashes) but it's\n+        // unclear whether that would be a win since hashing is cheap enough.\n+        let _task = tcx.dep_graph.in_ignore();\n+\n+        let compute_ich = (tcx.sess.opts.debugging_opts.query_dep_graph ||\n+                           tcx.sess.opts.debugging_opts.incremental_cc) &&\n+                           tcx.sess.opts.build_dep_graph();\n+\n+        let ecx: &'x mut EncodeContext<'b, 'tcx> = &mut *self.ecx;\n+        let mut entry_builder = EntryBuilder {\n+            tcx: tcx,\n+            ecx: ecx,\n+            hcx: if compute_ich {\n+                Some((StableHashingContext::new(tcx), StableHasher::new()))\n+            } else {\n+                None\n+            }\n+        };\n+\n+        let entry = op(&mut entry_builder, data);\n+\n+        if let Some((ref mut hcx, ref mut hasher)) = entry_builder.hcx {\n+            entry.hash_stable(hcx, hasher);\n+        }\n+\n+        let entry = entry_builder.ecx.lazy(&entry);\n+        entry_builder.finish(id);\n+        self.items.record(id, entry);\n     }\n \n     pub fn into_items(self) -> Index {\n@@ -223,3 +257,91 @@ impl<T> DepGraphRead for FromId<T> {\n         tcx.hir.read(self.0);\n     }\n }\n+\n+pub struct EntryBuilder<'a, 'b: 'a, 'tcx: 'b> {\n+    pub tcx: TyCtxt<'b, 'tcx, 'tcx>,\n+    ecx: &'a mut EncodeContext<'b, 'tcx>,\n+    hcx: Option<(StableHashingContext<'b, 'tcx>, StableHasher<Fingerprint>)>,\n+}\n+\n+impl<'a, 'b: 'a, 'tcx: 'b> EntryBuilder<'a, 'b, 'tcx> {\n+\n+    pub fn finish(self, def_id: DefId) {\n+        if let Some((_, hasher)) = self.hcx {\n+            let hash = hasher.finish();\n+            self.ecx.metadata_hashes.push(EncodedMetadataHash {\n+                def_index: def_id.index,\n+                hash: hash,\n+            });\n+        }\n+    }\n+\n+    pub fn lazy<T>(&mut self, value: &T) -> Lazy<T>\n+        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+    {\n+        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n+            value.hash_stable(hcx, hasher);\n+            debug!(\"metadata-hash: {:?}\", hasher);\n+        }\n+        self.ecx.lazy(value)\n+    }\n+\n+    pub fn lazy_seq<I, T>(&mut self, iter: I) -> LazySeq<T>\n+        where I: IntoIterator<Item = T>,\n+              T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+    {\n+        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n+            let iter = iter.into_iter();\n+            let (lower_bound, upper_bound) = iter.size_hint();\n+\n+            if upper_bound == Some(lower_bound) {\n+                lower_bound.hash_stable(hcx, hasher);\n+                let mut num_items_hashed = 0;\n+                let ret = self.ecx.lazy_seq(iter.inspect(|item| {\n+                    item.hash_stable(hcx, hasher);\n+                    num_items_hashed += 1;\n+                }));\n+\n+                // Sometimes items in a sequence are filtered out without being\n+                // hashed (e.g. for &[ast::Attribute]) and this code path cannot\n+                // handle that correctly, so we want to make sure we didn't hit\n+                // it by accident.\n+                if lower_bound != num_items_hashed {\n+                    bug!(\"Hashed a different number of items ({}) than expected ({})\",\n+                         num_items_hashed,\n+                         lower_bound);\n+                }\n+                debug!(\"metadata-hash: {:?}\", hasher);\n+                ret\n+            } else {\n+                // Collect into a vec so we know the length of the sequence\n+                let items: AccumulateVec<[T; 32]> = iter.collect();\n+                items.hash_stable(hcx, hasher);\n+                debug!(\"metadata-hash: {:?}\", hasher);\n+                self.ecx.lazy_seq(items)\n+            }\n+        } else {\n+            self.ecx.lazy_seq(iter)\n+        }\n+    }\n+\n+    pub fn lazy_seq_from_slice<T>(&mut self, slice: &[T]) -> LazySeq<T>\n+        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+    {\n+        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n+            slice.hash_stable(hcx, hasher);\n+            debug!(\"metadata-hash: {:?}\", hasher);\n+        }\n+        self.ecx.lazy_seq_ref(slice.iter())\n+    }\n+\n+    pub fn lazy_seq_ref_from_slice<T>(&mut self, slice: &[&T]) -> LazySeq<T>\n+        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx>>\n+    {\n+        if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n+            slice.hash_stable(hcx, hasher);\n+            debug!(\"metadata-hash: {:?}\", hasher);\n+        }\n+        self.ecx.lazy_seq_ref(slice.iter().map(|x| *x))\n+    }\n+}"}, {"sha": "b9e142ac65072e18dd2c256a4a418067700d0553", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -27,6 +27,7 @@\n #![feature(rustc_private)]\n #![feature(specialization)]\n #![feature(staged_api)]\n+#![feature(discriminant_value)]\n \n #[macro_use]\n extern crate log;"}, {"sha": "53d6a9ec10df2fca11c8cef3f8a0b5ffe89379b0", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -14,6 +14,7 @@ use index;\n use rustc::hir;\n use rustc::hir::def::{self, CtorKind};\n use rustc::hir::def_id::{DefIndex, DefId};\n+use rustc::ich::StableHashingContext;\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibrary};\n use rustc::middle::lang_items;\n@@ -27,6 +28,10 @@ use syntax::symbol::Symbol;\n use syntax_pos::{self, Span};\n \n use std::marker::PhantomData;\n+use std::mem;\n+\n+use rustc_data_structures::stable_hasher::{StableHasher, HashStable,\n+                                           StableHasherResult};\n \n pub fn rustc_version() -> String {\n     format!(\"rustc {}\",\n@@ -100,6 +105,15 @@ impl<T> Clone for Lazy<T> {\n impl<T> serialize::UseSpecializedEncodable for Lazy<T> {}\n impl<T> serialize::UseSpecializedDecodable for Lazy<T> {}\n \n+impl<CTX, T> HashStable<CTX> for Lazy<T> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          _: &mut CTX,\n+                                          _: &mut StableHasher<W>) {\n+        // There's nothing to do. Whatever got encoded within this Lazy<>\n+        // wrapper has already been hashed.\n+    }\n+}\n+\n /// A sequence of type T referred to by its absolute position\n /// in the metadata and length, and which can be decoded lazily.\n /// The sequence is a single node for the purposes of `Lazy`.\n@@ -148,6 +162,15 @@ impl<T> Clone for LazySeq<T> {\n impl<T> serialize::UseSpecializedEncodable for LazySeq<T> {}\n impl<T> serialize::UseSpecializedDecodable for LazySeq<T> {}\n \n+impl<CTX, T> HashStable<CTX> for LazySeq<T> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          _: &mut CTX,\n+                                          _: &mut StableHasher<W>) {\n+        // There's nothing to do. Whatever got encoded within this Lazy<>\n+        // wrapper has already been hashed.\n+    }\n+}\n+\n /// Encoding / decoding state for `Lazy` and `LazySeq`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum LazyState {\n@@ -219,6 +242,23 @@ pub struct Entry<'tcx> {\n     pub mir: Option<Lazy<mir::Mir<'tcx>>>,\n }\n \n+impl_stable_hash_for!(struct Entry<'tcx> {\n+    kind,\n+    visibility,\n+    span,\n+    attributes,\n+    children,\n+    stability,\n+    deprecation,\n+    ty,\n+    inherent_impls,\n+    variances,\n+    generics,\n+    predicates,\n+    ast,\n+    mir\n+});\n+\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub enum EntryKind<'tcx> {\n     Const(u8),\n@@ -246,22 +286,91 @@ pub enum EntryKind<'tcx> {\n     AssociatedConst(AssociatedContainer, u8),\n }\n \n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for EntryKind<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            EntryKind::ImmStatic        |\n+            EntryKind::MutStatic        |\n+            EntryKind::ForeignImmStatic |\n+            EntryKind::ForeignMutStatic |\n+            EntryKind::ForeignMod       |\n+            EntryKind::Field |\n+            EntryKind::Type => {\n+                // Nothing else to hash here.\n+            }\n+            EntryKind::Const(qualif) => {\n+                qualif.hash_stable(hcx, hasher);\n+            }\n+            EntryKind::Enum(ref repr_options) => {\n+                repr_options.hash_stable(hcx, hasher);\n+            }\n+            EntryKind::Variant(ref variant_data) => {\n+                variant_data.hash_stable(hcx, hasher);\n+            }\n+            EntryKind::Struct(ref variant_data, ref repr_options) |\n+            EntryKind::Union(ref variant_data, ref repr_options)  => {\n+                variant_data.hash_stable(hcx, hasher);\n+                repr_options.hash_stable(hcx, hasher);\n+            }\n+            EntryKind::Fn(ref fn_data) |\n+            EntryKind::ForeignFn(ref fn_data) => {\n+                fn_data.hash_stable(hcx, hasher);\n+            }\n+            EntryKind::Mod(ref mod_data) => {\n+                mod_data.hash_stable(hcx, hasher);\n+            }\n+            EntryKind::MacroDef(ref macro_def) => {\n+                macro_def.hash_stable(hcx, hasher);\n+            }\n+            EntryKind::Closure(closure_data) => {\n+                closure_data.hash_stable(hcx, hasher);\n+            }\n+            EntryKind::Trait(ref trait_data) => {\n+                trait_data.hash_stable(hcx, hasher);\n+            }\n+            EntryKind::DefaultImpl(ref impl_data) |\n+            EntryKind::Impl(ref impl_data) => {\n+                impl_data.hash_stable(hcx, hasher);\n+            }\n+            EntryKind::Method(ref method_data) => {\n+                method_data.hash_stable(hcx, hasher);\n+            }\n+            EntryKind::AssociatedType(associated_container) => {\n+                associated_container.hash_stable(hcx, hasher);\n+            }\n+            EntryKind::AssociatedConst(associated_container, qualif) => {\n+                associated_container.hash_stable(hcx, hasher);\n+                qualif.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ModData {\n     pub reexports: LazySeq<def::Export>,\n }\n \n+impl_stable_hash_for!(struct ModData { reexports });\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct MacroDef {\n     pub body: String,\n }\n \n+impl_stable_hash_for!(struct MacroDef { body });\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct FnData {\n     pub constness: hir::Constness,\n     pub arg_names: LazySeq<ast::Name>,\n }\n \n+impl_stable_hash_for!(struct FnData { constness, arg_names });\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct VariantData<'tcx> {\n     pub ctor_kind: CtorKind,\n@@ -273,6 +382,13 @@ pub struct VariantData<'tcx> {\n     pub struct_ctor: Option<DefIndex>,\n }\n \n+impl_stable_hash_for!(struct VariantData<'tcx> {\n+    ctor_kind,\n+    discr,\n+    evaluated_discr,\n+    struct_ctor\n+});\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct TraitData<'tcx> {\n     pub unsafety: hir::Unsafety,\n@@ -281,6 +397,13 @@ pub struct TraitData<'tcx> {\n     pub super_predicates: Lazy<ty::GenericPredicates<'tcx>>,\n }\n \n+impl_stable_hash_for!(struct TraitData<'tcx> {\n+    unsafety,\n+    paren_sugar,\n+    has_default_impl,\n+    super_predicates\n+});\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ImplData<'tcx> {\n     pub polarity: hir::ImplPolarity,\n@@ -291,6 +414,14 @@ pub struct ImplData<'tcx> {\n     pub trait_ref: Option<Lazy<ty::TraitRef<'tcx>>>,\n }\n \n+impl_stable_hash_for!(struct ImplData<'tcx> {\n+    polarity,\n+    parent_impl,\n+    coerce_unsized_info,\n+    trait_ref\n+});\n+\n+\n /// Describes whether the container of an associated item\n /// is a trait or an impl and whether, in a trait, it has\n /// a default, or an in impl, whether it's marked \"default\".\n@@ -302,6 +433,13 @@ pub enum AssociatedContainer {\n     ImplFinal,\n }\n \n+impl_stable_hash_for!(enum ::schema::AssociatedContainer {\n+    TraitRequired,\n+    TraitWithDefault,\n+    ImplDefault,\n+    ImplFinal\n+});\n+\n impl AssociatedContainer {\n     pub fn with_def_id(&self, def_id: DefId) -> ty::AssociatedItemContainer {\n         match *self {\n@@ -335,9 +473,11 @@ pub struct MethodData {\n     pub container: AssociatedContainer,\n     pub has_self: bool,\n }\n+impl_stable_hash_for!(struct MethodData { fn_data, container, has_self });\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct ClosureData<'tcx> {\n     pub kind: ty::ClosureKind,\n     pub ty: Lazy<ty::PolyFnSig<'tcx>>,\n }\n+impl_stable_hash_for!(struct ClosureData<'tcx> { kind, ty });"}, {"sha": "df2841a66826980d6cd1ae96739c3ed4cba53b05", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -62,7 +62,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let idx = unpack!(block = this.as_operand(block, None, index));\n \n                 // bounds check:\n-                let (len, lt) = (this.temp(usize_ty.clone()), this.temp(bool_ty));\n+                let (len, lt) = (this.temp(usize_ty.clone(), expr_span),\n+                                 this.temp(bool_ty, expr_span));\n                 this.cfg.push_assign(block, source_info, // len = len(slice)\n                                      &len, Rvalue::Len(slice.clone()));\n                 this.cfg.push_assign(block, source_info, // lt = idx < len"}, {"sha": "fb547332c5f58b79bffe08dd478bdcc26d9c4a32", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -82,7 +82,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let bool_ty = this.hir.bool_ty();\n \n                     let minval = this.minval_literal(expr_span, expr.ty);\n-                    let is_min = this.temp(bool_ty);\n+                    let is_min = this.temp(bool_ty, expr_span);\n \n                     this.cfg.push_assign(block, source_info, &is_min,\n                                          Rvalue::BinaryOp(BinOp::Eq, arg.clone(), minval));\n@@ -95,7 +95,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n             ExprKind::Box { value, value_extents } => {\n                 let value = this.hir.mirror(value);\n-                let result = this.temp(expr.ty);\n+                let result = this.temp(expr.ty, expr_span);\n                 // to start, malloc some memory of suitable type (thus far, uninitialized):\n                 this.cfg.push_assign(block, source_info, &result, Rvalue::Box(value.ty));\n                 this.in_scope(value_extents, block, |this| {\n@@ -260,7 +260,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let bool_ty = self.hir.bool_ty();\n         if self.hir.check_overflow() && op.is_checkable() && ty.is_integral() {\n             let result_tup = self.hir.tcx().intern_tup(&[ty, bool_ty], false);\n-            let result_value = self.temp(result_tup);\n+            let result_value = self.temp(result_tup, span);\n \n             self.cfg.push_assign(block, source_info,\n                                  &result_value, Rvalue::CheckedBinaryOp(op,\n@@ -301,7 +301,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 };\n \n                 // Check for / 0\n-                let is_zero = self.temp(bool_ty);\n+                let is_zero = self.temp(bool_ty, span);\n                 let zero = self.zero_literal(span, ty);\n                 self.cfg.push_assign(block, source_info, &is_zero,\n                                      Rvalue::BinaryOp(BinOp::Eq, rhs.clone(), zero));\n@@ -315,9 +315,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let neg_1 = self.neg_1_literal(span, ty);\n                     let min = self.minval_literal(span, ty);\n \n-                    let is_neg_1 = self.temp(bool_ty);\n-                    let is_min   = self.temp(bool_ty);\n-                    let of       = self.temp(bool_ty);\n+                    let is_neg_1 = self.temp(bool_ty, span);\n+                    let is_min   = self.temp(bool_ty, span);\n+                    let of       = self.temp(bool_ty, span);\n \n                     // this does (rhs == -1) & (lhs == MIN). It could short-circuit instead\n "}, {"sha": "e4598b4143871e2bc3a6f059ab7188f61d8c2b83", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -44,8 +44,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n \n         let expr_ty = expr.ty.clone();\n-        let temp = this.temp(expr_ty.clone());\n         let expr_span = expr.span;\n+        let temp = this.temp(expr_ty.clone(), expr_span);\n         let source_info = this.source_info(expr_span);\n \n         if expr.temp_lifetime_was_shrunk && this.hir.needs_drop(expr_ty) {"}, {"sha": "c03432312b0ab6c4adc235e2a3036603c6f3854b", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -138,7 +138,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n             _ => {\n                 let expr_ty = expr.ty;\n-                let temp = this.temp(expr.ty.clone());\n+                let temp = this.temp(expr.ty.clone(), expr_span);\n                 unpack!(block = this.into(&temp, block, expr));\n                 unpack!(block = this.build_drop(block, expr_span, temp, expr_ty));\n                 block.unit()"}, {"sha": "ddeec1fe6d0bae009c53f07e9896dd31da33f93c", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -710,7 +710,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             mutability: mutability,\n             ty: var_ty.clone(),\n             name: Some(name),\n-            source_info: Some(source_info),\n+            source_info: source_info,\n+            is_user_variable: true,\n         });\n         self.var_indices.insert(var_id, var);\n "}, {"sha": "5fece4d6a5d2387aae043ceb46cd070b98ea66e5", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -210,7 +210,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 debug!(\"num_enum_variants: {}, tested variants: {:?}, variants: {:?}\",\n                        num_enum_variants, values, variants);\n                 let discr_ty = adt_def.repr.discr_type().to_ty(tcx);\n-                let discr = self.temp(discr_ty);\n+                let discr = self.temp(discr_ty, test.span);\n                 self.cfg.push_assign(block, source_info, &discr,\n                                      Rvalue::Discriminant(lvalue.clone()));\n                 assert_eq!(values.len() + 1, targets.len());\n@@ -270,7 +270,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     if let ty::TyRef(region, mt) = ty.sty {\n                         if let ty::TyArray(_, _) = mt.ty.sty {\n                             ty = tcx.mk_imm_ref(region, tcx.mk_slice(tcx.types.u8));\n-                            let val_slice = self.temp(ty);\n+                            let val_slice = self.temp(ty, test.span);\n                             self.cfg.push_assign(block, source_info, &val_slice,\n                                                  Rvalue::Cast(CastKind::Unsize, val, ty));\n                             val = Operand::Consume(val_slice);\n@@ -285,7 +285,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         value: value.clone()\n                     });\n \n-                    let slice = self.temp(ty);\n+                    let slice = self.temp(ty, test.span);\n                     self.cfg.push_assign(block, source_info, &slice,\n                                          Rvalue::Cast(CastKind::Unsize, array, ty));\n                     Operand::Consume(slice)\n@@ -304,7 +304,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let (mty, method) = self.hir.trait_method(eq_def_id, \"eq\", ty, &[ty]);\n \n                     let bool_ty = self.hir.bool_ty();\n-                    let eq_result = self.temp(bool_ty);\n+                    let eq_result = self.temp(bool_ty, test.span);\n                     let eq_block = self.cfg.start_new_block();\n                     let cleanup = self.diverge_cleanup();\n                     self.cfg.terminate(block, source_info, TerminatorKind::Call {\n@@ -349,7 +349,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             TestKind::Len { len, op } => {\n                 let (usize_ty, bool_ty) = (self.hir.usize_ty(), self.hir.bool_ty());\n-                let (actual, result) = (self.temp(usize_ty), self.temp(bool_ty));\n+                let (actual, result) = (self.temp(usize_ty, test.span),\n+                                        self.temp(bool_ty, test.span));\n \n                 // actual = len(lvalue)\n                 self.cfg.push_assign(block, source_info,\n@@ -383,7 +384,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                left: Operand<'tcx>,\n                right: Operand<'tcx>) -> BasicBlock {\n         let bool_ty = self.hir.bool_ty();\n-        let result = self.temp(bool_ty);\n+        let result = self.temp(bool_ty, span);\n \n         // result = op(left, right)\n         let source_info = self.source_info(span);"}, {"sha": "35a8b245f2bb64203a7e19e14d8c891015e02821", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -27,8 +27,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     ///\n     /// NB: **No cleanup is scheduled for this temporary.** You should\n     /// call `schedule_drop` once the temporary is initialized.\n-    pub fn temp(&mut self, ty: Ty<'tcx>) -> Lvalue<'tcx> {\n-        let temp = self.local_decls.push(LocalDecl::new_temp(ty));\n+    pub fn temp(&mut self, ty: Ty<'tcx>, span: Span) -> Lvalue<'tcx> {\n+        let temp = self.local_decls.push(LocalDecl::new_temp(ty, span));\n         let lvalue = Lvalue::Local(temp);\n         debug!(\"temp: created temp {:?} with type {:?}\",\n                lvalue, self.local_decls[temp].ty);\n@@ -106,7 +106,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                       value: u64)\n                       -> Lvalue<'tcx> {\n         let usize_ty = self.hir.usize_ty();\n-        let temp = self.temp(usize_ty);\n+        let temp = self.temp(usize_ty, source_info.span);\n         self.cfg.push_assign_constant(\n             block, source_info, &temp,\n             Constant {"}, {"sha": "ef3fa23500b34395b9f79ce79fc841beac3d75ad", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -249,7 +249,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             visibility_scopes: IndexVec::new(),\n             visibility_scope: ARGUMENT_VISIBILITY_SCOPE,\n             breakable_scopes: vec![],\n-            local_decls: IndexVec::from_elem_n(LocalDecl::new_return_pointer(return_ty), 1),\n+            local_decls: IndexVec::from_elem_n(LocalDecl::new_return_pointer(return_ty,\n+                                                                             span), 1),\n             var_indices: NodeMap(),\n             unit_temp: None,\n             cached_resume_block: None,\n@@ -304,8 +305,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             self.local_decls.push(LocalDecl {\n                 mutability: Mutability::Not,\n                 ty: ty,\n-                source_info: None,\n+                source_info: SourceInfo {\n+                    scope: ARGUMENT_VISIBILITY_SCOPE,\n+                    span: pattern.map_or(self.fn_span, |pat| pat.span)\n+                },\n                 name: name,\n+                is_user_variable: false,\n             });\n         }\n \n@@ -341,7 +346,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             Some(ref tmp) => tmp.clone(),\n             None => {\n                 let ty = self.hir.unit_ty();\n-                let tmp = self.temp(ty);\n+                let fn_span = self.fn_span;\n+                let tmp = self.temp(ty, fn_span);\n                 self.unit_temp = Some(tmp.clone());\n                 tmp\n             }"}, {"sha": "bb07081fe433b74dab3ccf6ae1fbce3480616218", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -244,6 +244,39 @@ let baz: bool = { (&FOO as *const i32) == (&BAR as *const i32) };\n ```\n \"##,\n \n+E0161: r##\"\n+A value was moved. However, its size was not known at compile time, and only\n+values of a known size can be moved.\n+\n+Erroneous code example:\n+\n+```compile_fail\n+#![feature(box_syntax)]\n+\n+fn main() {\n+    let array: &[isize] = &[1, 2, 3];\n+    let _x: Box<[isize]> = box *array;\n+    // error: cannot move a value of type [isize]: the size of [isize] cannot\n+    //        be statically determined\n+}\n+```\n+\n+In Rust, you can only move a value when its size is known at compile time.\n+\n+To work around this restriction, consider \"hiding\" the value behind a reference:\n+either `&x` or `&mut x`. Since a reference has a fixed size, this lets you move\n+it around as usual. Example:\n+\n+```\n+#![feature(box_syntax)]\n+\n+fn main() {\n+    let array: &[isize] = &[1, 2, 3];\n+    let _x: Box<&[isize]> = box array; // ok!\n+}\n+```\n+\"##,\n+\n E0396: r##\"\n The value behind a raw pointer can't be determined at compile-time\n (or even link-time), which means it can't be used in a constant"}, {"sha": "0cec84d16a81c44740e5b0399c73351c28f01cd7", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -137,16 +137,20 @@ enum CallKind {\n     Direct(DefId),\n }\n \n-fn temp_decl(mutability: Mutability, ty: Ty) -> LocalDecl {\n-    LocalDecl { mutability, ty, name: None, source_info: None }\n+fn temp_decl(mutability: Mutability, ty: Ty, span: Span) -> LocalDecl {\n+    LocalDecl {\n+        mutability, ty, name: None,\n+        source_info: SourceInfo { scope: ARGUMENT_VISIBILITY_SCOPE, span },\n+        is_user_variable: false\n+    }\n }\n \n-fn local_decls_for_sig<'tcx>(sig: &ty::FnSig<'tcx>)\n+fn local_decls_for_sig<'tcx>(sig: &ty::FnSig<'tcx>, span: Span)\n     -> IndexVec<Local, LocalDecl<'tcx>>\n {\n-    iter::once(temp_decl(Mutability::Mut, sig.output()))\n+    iter::once(temp_decl(Mutability::Mut, sig.output(), span))\n         .chain(sig.inputs().iter().map(\n-            |ity| temp_decl(Mutability::Not, ity)))\n+            |ity| temp_decl(Mutability::Not, ity, span)))\n         .collect()\n }\n \n@@ -188,7 +192,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n         ),\n         IndexVec::new(),\n         sig.output(),\n-        local_decls_for_sig(&sig),\n+        local_decls_for_sig(&sig, span),\n         sig.inputs().len(),\n         vec![],\n         span\n@@ -297,7 +301,7 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n \n     debug!(\"build_call_shim: sig={:?}\", sig);\n \n-    let mut local_decls = local_decls_for_sig(&sig);\n+    let mut local_decls = local_decls_for_sig(&sig, span);\n     let source_info = SourceInfo { span, scope: ARGUMENT_VISIBILITY_SCOPE };\n \n     let rcvr_arg = Local::new(1+0);\n@@ -317,7 +321,8 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n                 tcx.mk_ref(re_erased, ty::TypeAndMut {\n                     ty: sig.inputs()[0],\n                     mutbl: hir::Mutability::MutMutable\n-                })\n+                }),\n+                span\n             ));\n             statements.push(Statement {\n                 source_info: source_info,\n@@ -442,7 +447,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n \n     debug!(\"build_ctor: def_id={:?} sig={:?} fields={:?}\", def_id, sig, fields);\n \n-    let local_decls = local_decls_for_sig(&sig);\n+    let local_decls = local_decls_for_sig(&sig, span);\n \n     let source_info = SourceInfo {\n         span: span,"}, {"sha": "ac2bdaad24f766a397d2f5c53da0b3bc0bf877f1", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -461,11 +461,8 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 for loc in callee_mir.vars_and_temps_iter() {\n                     let mut local = callee_mir.local_decls[loc].clone();\n \n-                    if let Some(ref mut source_info) = local.source_info {\n-                        source_info.scope = scope_map[source_info.scope];\n-\n-                        source_info.span = callsite.location.span;\n-                    }\n+                    local.source_info.scope = scope_map[local.source_info.scope];\n+                    local.source_info.span = callsite.location.span;\n \n                     let idx = caller_mir.local_decls.push(local);\n                     local_map.push(idx);\n@@ -506,7 +503,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n                     let ty = dest.ty(caller_mir, self.tcx);\n \n-                    let temp = LocalDecl::new_temp(ty);\n+                    let temp = LocalDecl::new_temp(ty, callsite.location.span);\n \n                     let tmp = caller_mir.local_decls.push(temp);\n                     let tmp = Lvalue::Local(tmp);\n@@ -590,7 +587,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             arg.deref());\n \n         let ty = arg.ty(caller_mir, self.tcx);\n-        let ref_tmp = LocalDecl::new_temp(ty);\n+        let ref_tmp = LocalDecl::new_temp(ty, callsite.location.span);\n         let ref_tmp = caller_mir.local_decls.push(ref_tmp);\n         let ref_tmp = Lvalue::Local(ref_tmp);\n \n@@ -611,7 +608,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n         let raw_ptr = Rvalue::Cast(CastKind::Misc, Operand::Consume(ref_tmp), ptr_ty);\n \n-        let cast_tmp = LocalDecl::new_temp(ptr_ty);\n+        let cast_tmp = LocalDecl::new_temp(ptr_ty, callsite.location.span);\n         let cast_tmp = caller_mir.local_decls.push(cast_tmp);\n         let cast_tmp = Lvalue::Local(cast_tmp);\n \n@@ -645,7 +642,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n             let ty = arg.ty(caller_mir, tcx);\n \n-            let arg_tmp = LocalDecl::new_temp(ty);\n+            let arg_tmp = LocalDecl::new_temp(ty, callsite.location.span);\n             let arg_tmp = caller_mir.local_decls.push(arg_tmp);\n             let arg_tmp = Lvalue::Local(arg_tmp);\n "}, {"sha": "ed9a0d3809f245886e0aa6e41bee1c7f76ba3d7f", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -208,7 +208,8 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n \n         let no_stmts = self.source[loc.block].statements.len();\n         let new_temp = self.promoted.local_decls.push(\n-            LocalDecl::new_temp(self.source.local_decls[temp].ty));\n+            LocalDecl::new_temp(self.source.local_decls[temp].ty,\n+                                self.source.local_decls[temp].source_info.span));\n \n         debug!(\"promote({:?} @ {:?}/{:?}, {:?})\",\n                temp, loc, no_stmts, self.keep_original);\n@@ -379,7 +380,8 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n         };\n \n         // Declare return pointer local\n-        let initial_locals = iter::once(LocalDecl::new_return_pointer(ty)).collect();\n+        let initial_locals = iter::once(LocalDecl::new_return_pointer(ty, span))\n+            .collect();\n \n         let mut promoter = Promoter {\n             promoted: Mir::new("}, {"sha": "1313b24fa74f5eecc5311586c9f12e10f406b51c", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -881,7 +881,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 // Avoid a generic error for other uses of arguments.\n                 if self.qualif.intersects(Qualif::FN_ARGUMENT) {\n                     let decl = &self.mir.local_decls[index];\n-                    span_err!(self.tcx.sess, decl.source_info.unwrap().span, E0022,\n+                    span_err!(self.tcx.sess, decl.source_info.span, E0022,\n                               \"arguments of constant functions can only \\\n                                be immutable by-value bindings\");\n                     return;"}, {"sha": "bfb08de56d8bb899b15509b8f4d849992851bd62", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 48, "deletions": 4, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -24,6 +24,7 @@ use std::fmt;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n+use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n \n fn mirbug(tcx: TyCtxt, span: Span, msg: &str) {\n@@ -87,6 +88,11 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         self.sanitize_type(rvalue, rval_ty);\n     }\n \n+    fn visit_local_decl(&mut self, local_decl: &LocalDecl<'tcx>) {\n+        self.super_local_decl(local_decl);\n+        self.sanitize_type(local_decl, local_decl.ty);\n+    }\n+\n     fn visit_mir(&mut self, mir: &Mir<'tcx>) {\n         self.sanitize_type(&\"return type\", mir.return_ty);\n         for local_decl in &mir.local_decls {\n@@ -317,6 +323,7 @@ pub struct TypeChecker<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fulfillment_cx: traits::FulfillmentContext<'tcx>,\n     last_span: Span,\n     body_id: ast::NodeId,\n+    reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n }\n \n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n@@ -326,6 +333,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             fulfillment_cx: traits::FulfillmentContext::new(),\n             last_span: DUMMY_SP,\n             body_id: body_id,\n+            reported_errors: FxHashSet(),\n         }\n     }\n \n@@ -641,9 +649,43 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn typeck_mir(&mut self, mir: &Mir<'tcx>) {\n+    fn check_local(&mut self, mir: &Mir<'gcx>, local: Local, local_decl: &LocalDecl<'gcx>) {\n+        match mir.local_kind(local) {\n+            LocalKind::ReturnPointer | LocalKind::Arg => {\n+                // return values of normal functions are required to be\n+                // sized by typeck, but return values of ADT constructors are\n+                // not because we don't include a `Self: Sized` bounds on them.\n+                //\n+                // Unbound parts of arguments were never required to be Sized\n+                // - maybe we should make that a warning.\n+                return\n+            }\n+            LocalKind::Var | LocalKind::Temp => {}\n+        }\n+\n+        let span = local_decl.source_info.span;\n+        let ty = local_decl.ty;\n+        if !ty.is_sized(self.tcx().global_tcx(), self.infcx.param_env(), span) {\n+            // in current MIR construction, all non-control-flow rvalue\n+            // expressions evaluate through `as_temp` or `into` a return\n+            // slot or local, so to find all unsized rvalues it is enough\n+            // to check all temps, return slots and locals.\n+            if let None = self.reported_errors.replace((ty, span)) {\n+                span_err!(self.tcx().sess, span, E0161,\n+                          \"cannot move a value of type {0}: the size of {0} \\\n+                           cannot be statically determined\", ty);\n+            }\n+        }\n+    }\n+\n+    fn typeck_mir(&mut self, mir: &Mir<'gcx>) {\n         self.last_span = mir.span;\n         debug!(\"run_on_mir: {:?}\", mir.span);\n+\n+        for (local, local_decl) in mir.local_decls.iter_enumerated() {\n+            self.check_local(mir, local, local_decl);\n+        }\n+\n         for block in mir.basic_blocks() {\n             for stmt in &block.statements {\n                 if stmt.source_info.span != DUMMY_SP {\n@@ -698,16 +740,18 @@ impl TypeckMir {\n impl<'tcx> MirPass<'tcx> for TypeckMir {\n     fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     src: MirSource, mir: &mut Mir<'tcx>) {\n-        debug!(\"run_pass: {}\", tcx.node_path_str(src.item_id()));\n+        let item_id = src.item_id();\n+        let def_id = tcx.hir.local_def_id(item_id);\n+        debug!(\"run_pass: {}\", tcx.item_path_str(def_id));\n \n         if tcx.sess.err_count() > 0 {\n             // compiling a broken program can obviously result in a\n             // broken MIR, so try not to report duplicate errors.\n             return;\n         }\n-        let param_env = ty::ParameterEnvironment::for_item(tcx, src.item_id());\n+        let param_env = ty::ParameterEnvironment::for_item(tcx, item_id);\n         tcx.infer_ctxt(param_env, Reveal::UserFacing).enter(|infcx| {\n-            let mut checker = TypeChecker::new(&infcx, src.item_id());\n+            let mut checker = TypeChecker::new(&infcx, item_id);\n             {\n                 let mut verifier = TypeVerifier::new(&mut checker, mir);\n                 verifier.visit_mir(mir);"}, {"sha": "04a1fc891cf1e582e2ef50d2b4271bf8df16bd6c", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -686,7 +686,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     }\n \n     fn new_temp(&mut self, ty: Ty<'tcx>) -> Local {\n-        self.elaborator.patch().new_temp(ty)\n+        self.elaborator.patch().new_temp(ty, self.source_info.span)\n     }\n \n     fn terminator_loc(&mut self, bb: BasicBlock) -> Location {"}, {"sha": "7898d93c22e3b7cec2b167b0a06afa5f30d592fd", "filename": "src/librustc_mir/util/patch.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpatch.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -11,6 +11,7 @@\n use rustc::ty::Ty;\n use rustc::mir::*;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use syntax_pos::Span;\n \n /// This struct represents a patch to MIR, which can add\n /// new statements and basic blocks and patch over block\n@@ -92,10 +93,10 @@ impl<'tcx> MirPatch<'tcx> {\n         }\n     }\n \n-    pub fn new_temp(&mut self, ty: Ty<'tcx>) -> Local {\n+    pub fn new_temp(&mut self, ty: Ty<'tcx>, span: Span) -> Local {\n         let index = self.next_local;\n         self.next_local += 1;\n-        self.new_locals.push(LocalDecl::new_temp(ty));\n+        self.new_locals.push(LocalDecl::new_temp(ty, span));\n         Local::new(index as usize)\n     }\n "}, {"sha": "b202e1495104e52f82973fe2015940e2d4e8340a", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -196,8 +196,8 @@ fn write_scope_tree(tcx: TyCtxt,\n         // User variable types (including the user's name in a comment).\n         for local in mir.vars_iter() {\n             let var = &mir.local_decls[local];\n-            let (name, source_info) = if var.source_info.unwrap().scope == child {\n-                (var.name.unwrap(), var.source_info.unwrap())\n+            let (name, source_info) = if var.source_info.scope == child {\n+                (var.name.unwrap(), var.source_info)\n             } else {\n                 // Not a variable or not declared in this scope.\n                 continue;"}, {"sha": "036a52d5a3db3491e4ff8a8f1e52bd18b5d200b6", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -82,39 +82,6 @@ extern {\n ```\n \"##,\n \n-E0161: r##\"\n-A value was moved. However, its size was not known at compile time, and only\n-values of a known size can be moved.\n-\n-Erroneous code example:\n-\n-```compile_fail\n-#![feature(box_syntax)]\n-\n-fn main() {\n-    let array: &[isize] = &[1, 2, 3];\n-    let _x: Box<[isize]> = box *array;\n-    // error: cannot move a value of type [isize]: the size of [isize] cannot\n-    //        be statically determined\n-}\n-```\n-\n-In Rust, you can only move a value when its size is known at compile time.\n-\n-To work around this restriction, consider \"hiding\" the value behind a reference:\n-either `&x` or `&mut x`. Since a reference has a fixed size, this lets you move\n-it around as usual. Example:\n-\n-```\n-#![feature(box_syntax)]\n-\n-fn main() {\n-    let array: &[isize] = &[1, 2, 3];\n-    let _x: Box<&[isize]> = box array; // ok!\n-}\n-```\n-\"##,\n-\n E0265: r##\"\n This error indicates that a static or constant references itself.\n All statics and constants need to resolve to a value in an acyclic manner."}, {"sha": "22566c813d86ae4da36bd7ed0994e989a566277a", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -47,5 +47,4 @@ pub mod hir_stats;\n pub mod loops;\n pub mod mir_stats;\n pub mod no_asm;\n-pub mod rvalues;\n pub mod static_recursion;"}, {"sha": "2ea235af103788b0f9de6e09b5f3a36b139ffbdd", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -11,7 +11,6 @@ use self::Context::*;\n \n use rustc::session::Session;\n \n-use rustc::dep_graph::DepNode;\n use rustc::hir::map::Map;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir;\n@@ -50,7 +49,6 @@ struct CheckLoopVisitor<'a, 'hir: 'a> {\n }\n \n pub fn check_crate(sess: &Session, map: &Map) {\n-    let _task = map.dep_graph.in_task(DepNode::CheckLoops);\n     let krate = map.krate();\n     krate.visit_all_item_likes(&mut CheckLoopVisitor {\n         sess: sess,"}, {"sha": "c367e71fcd24619417dd41e20e2077739503b535", "filename": "src/librustc_passes/rvalues.rs", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/1dca19ae3fd195fa517e326a39bfee729da7cadb/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1dca19ae3fd195fa517e326a39bfee729da7cadb/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=1dca19ae3fd195fa517e326a39bfee729da7cadb", "patch": "@@ -1,103 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Checks that all rvalues in a crate have statically known size. check_crate\n-// is the public starting point.\n-\n-use rustc::dep_graph::DepNode;\n-use rustc::middle::expr_use_visitor as euv;\n-use rustc::middle::mem_categorization as mc;\n-use rustc::ty::{self, TyCtxt};\n-use rustc::traits::Reveal;\n-\n-use rustc::hir;\n-use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n-use syntax::ast;\n-use syntax_pos::Span;\n-\n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let mut rvcx = RvalueContext { tcx: tcx };\n-    tcx.visit_all_item_likes_in_krate(DepNode::RvalueCheck, &mut rvcx.as_deep_visitor());\n-}\n-\n-struct RvalueContext<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for RvalueContext<'a, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n-        let body = self.tcx.hir.body(body_id);\n-        self.tcx.infer_ctxt(body_id, Reveal::UserFacing).enter(|infcx| {\n-            let mut delegate = RvalueContextDelegate {\n-                tcx: infcx.tcx,\n-                param_env: &infcx.parameter_environment\n-            };\n-            euv::ExprUseVisitor::new(&mut delegate, &infcx).consume_body(body);\n-        });\n-        self.visit_body(body);\n-    }\n-}\n-\n-struct RvalueContextDelegate<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    param_env: &'a ty::ParameterEnvironment<'gcx>,\n-}\n-\n-impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for RvalueContextDelegate<'a, 'gcx, 'tcx> {\n-    fn consume(&mut self,\n-               _: ast::NodeId,\n-               span: Span,\n-               cmt: mc::cmt<'tcx>,\n-               _: euv::ConsumeMode) {\n-        debug!(\"consume; cmt: {:?}; type: {:?}\", *cmt, cmt.ty);\n-        let ty = self.tcx.lift_to_global(&cmt.ty).unwrap();\n-        if !ty.is_sized(self.tcx.global_tcx(), self.param_env, span) {\n-            span_err!(self.tcx.sess, span, E0161,\n-                \"cannot move a value of type {0}: the size of {0} cannot be statically determined\",\n-                ty);\n-        }\n-    }\n-\n-    fn matched_pat(&mut self,\n-                   _matched_pat: &hir::Pat,\n-                   _cmt: mc::cmt,\n-                   _mode: euv::MatchMode) {}\n-\n-    fn consume_pat(&mut self,\n-                   _consume_pat: &hir::Pat,\n-                   _cmt: mc::cmt,\n-                   _mode: euv::ConsumeMode) {\n-    }\n-\n-    fn borrow(&mut self,\n-              _borrow_id: ast::NodeId,\n-              _borrow_span: Span,\n-              _cmt: mc::cmt,\n-              _loan_region: &'tcx ty::Region,\n-              _bk: ty::BorrowKind,\n-              _loan_cause: euv::LoanCause) {\n-    }\n-\n-    fn decl_without_init(&mut self,\n-                         _id: ast::NodeId,\n-                         _span: Span) {\n-    }\n-\n-    fn mutate(&mut self,\n-              _assignment_id: ast::NodeId,\n-              _assignment_span: Span,\n-              _assignee_cmt: mc::cmt,\n-              _mode: euv::MutateMode) {\n-    }\n-}"}, {"sha": "d0bf49b7b337d17fff8910c0f17a82602fdc2962", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -11,7 +11,6 @@\n // This compiler pass detects constants that refer to themselves\n // recursively.\n \n-use rustc::dep_graph::DepNode;\n use rustc::hir::map as hir_map;\n use rustc::session::{CompileResult, Session};\n use rustc::hir::def::{Def, CtorKind};\n@@ -88,8 +87,6 @@ impl<'a, 'hir: 'a> Visitor<'hir> for CheckCrateVisitor<'a, 'hir> {\n }\n \n pub fn check_crate<'hir>(sess: &Session, hir_map: &hir_map::Map<'hir>) -> CompileResult {\n-    let _task = hir_map.dep_graph.in_task(DepNode::CheckStaticRecursion);\n-\n     let mut visitor = CheckCrateVisitor {\n         sess: sess,\n         hir_map: hir_map,"}, {"sha": "c4fdc46d030c9e163d2b0a9d8d2f4637f8f5ef58", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -283,7 +283,7 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n \n             Layout::Vector { .. } => {\n                 Some(Reg {\n-                    kind: RegKind::Integer,\n+                    kind: RegKind::Vector,\n                     size: self.size(ccx)\n                 })\n             }"}, {"sha": "0ffa7a79408e12913acbd02a7fbbb920ebba500e", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -443,7 +443,10 @@ fn archive_config<'a>(sess: &'a Session,\n }\n \n fn emit_metadata<'a>(sess: &'a Session, trans: &CrateTranslation, out_filename: &Path) {\n-    let result = fs::File::create(out_filename).and_then(|mut f| f.write_all(&trans.metadata));\n+    let result = fs::File::create(out_filename).and_then(|mut f| {\n+        f.write_all(&trans.metadata.raw_data)\n+    });\n+\n     if let Err(e) = result {\n         sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n     }"}, {"sha": "f76e816bcf0c9580a18aa81d4b3646905db77521", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -36,6 +36,7 @@ use llvm::{Linkage, ValueRef, Vector, get_param};\n use llvm;\n use rustc::hir::def_id::LOCAL_CRATE;\n use middle::lang_items::StartFnLangItem;\n+use middle::cstore::EncodedMetadata;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::dep_graph::{AssertDepGraphSafe, DepNode, WorkProduct};\n use rustc::hir::map as hir_map;\n@@ -724,7 +725,8 @@ fn contains_null(s: &str) -> bool {\n }\n \n fn write_metadata(cx: &SharedCrateContext,\n-                  exported_symbols: &NodeSet) -> Vec<u8> {\n+                  exported_symbols: &NodeSet)\n+                  -> EncodedMetadata {\n     use flate;\n \n     #[derive(PartialEq, Eq, PartialOrd, Ord)]\n@@ -748,7 +750,10 @@ fn write_metadata(cx: &SharedCrateContext,\n     }).max().unwrap();\n \n     if kind == MetadataKind::None {\n-        return Vec::new();\n+        return EncodedMetadata {\n+            raw_data: vec![],\n+            hashes: vec![],\n+        };\n     }\n \n     let cstore = &cx.tcx().sess.cstore;\n@@ -761,7 +766,7 @@ fn write_metadata(cx: &SharedCrateContext,\n \n     assert!(kind == MetadataKind::Compressed);\n     let mut compressed = cstore.metadata_encoding_version().to_vec();\n-    compressed.extend_from_slice(&flate::deflate_bytes(&metadata));\n+    compressed.extend_from_slice(&flate::deflate_bytes(&metadata.raw_data));\n \n     let llmeta = C_bytes_in_context(cx.metadata_llcx(), &compressed);\n     let llconst = C_struct_in_context(cx.metadata_llcx(), &[llmeta], false);"}, {"sha": "2daebf5cf3d6b191efeca18907acf854eb359aff", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -173,14 +173,15 @@ fn reg_component(cls: &[Class], i: &mut usize, size: u64) -> Option<Reg> {\n         Class::Sse => {\n             let vec_len = 1 + cls[*i+1..].iter().take_while(|&&c| c == Class::SseUp).count();\n             *i += vec_len;\n-            Some(match size {\n-                4 => Reg::f32(),\n-                8 => Reg::f64(),\n-                _ => {\n-                    Reg {\n-                        kind: RegKind::Vector,\n-                        size: Size::from_bytes(vec_len as u64 * 8)\n-                    }\n+            Some(if vec_len == 1 {\n+                match size {\n+                    4 => Reg::f32(),\n+                    _ => Reg::f64()\n+                }\n+            } else {\n+                Reg {\n+                    kind: RegKind::Vector,\n+                    size: Size::from_bytes(vec_len as u64 * 8)\n                 }\n             })\n         }"}, {"sha": "3d074c31c8a32f23c215dbb061b25330083272e3", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -65,7 +65,7 @@ pub fn create_mir_scopes(ccx: &CrateContext, mir: &Mir, debug_context: &Function\n     let mut has_variables = BitVector::new(mir.visibility_scopes.len());\n     for var in mir.vars_iter() {\n         let decl = &mir.local_decls[var];\n-        has_variables.insert(decl.source_info.unwrap().scope.index());\n+        has_variables.insert(decl.source_info.scope.index());\n     }\n \n     // Instantiate all scopes."}, {"sha": "628d46f8e7059f27317e247af2cfe449b2f128e4", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -168,7 +168,7 @@ pub struct CrateTranslation {\n     pub modules: Vec<ModuleTranslation>,\n     pub metadata_module: ModuleTranslation,\n     pub link: middle::cstore::LinkMeta,\n-    pub metadata: Vec<u8>,\n+    pub metadata: middle::cstore::EncodedMetadata,\n     pub exported_symbols: back::symbol_export::ExportedSymbols,\n     pub no_builtins: bool,\n     pub windows_subsystem: Option<String>,"}, {"sha": "c51e1fb0028038862d935281435eaf6c857a8819", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -255,8 +255,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n \n             if let Some(name) = decl.name {\n                 // User variable\n-                let source_info = decl.source_info.unwrap();\n-                let debug_scope = mircx.scopes[source_info.scope];\n+                let debug_scope = mircx.scopes[decl.source_info.scope];\n                 let dbg = debug_scope.is_valid() && bcx.sess().opts.debuginfo == FullDebugInfo;\n \n                 if !lvalue_locals.contains(local.index()) && !dbg {\n@@ -268,7 +267,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n                 assert!(!ty.has_erasable_regions());\n                 let lvalue = LvalueRef::alloca(&bcx, ty, &name.as_str());\n                 if dbg {\n-                    let (scope, span) = mircx.debug_loc(source_info);\n+                    let (scope, span) = mircx.debug_loc(decl.source_info);\n                     declare_local(&bcx, &mircx.debug_context, name, ty, scope,\n                         VariableAccess::DirectVariable { alloca: lvalue.llval },\n                         VariableKind::LocalVariable, span);"}, {"sha": "61ff8daddf0a67fbd3e4661ef3f063bf97002eec", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -406,7 +406,7 @@ mod prim_slice { }\n ///\n /// This documentation describes a number of methods and trait implementations\n /// on the `str` type. For technical reasons, there is additional, separate\n-/// documentation in [the `std::str` module](str/index.html) as well.\n+/// documentation in the [`std::str`](str/index.html) module as well.\n ///\n /// # Examples\n ///\n@@ -425,7 +425,7 @@ mod prim_slice { }\n /// # Representation\n ///\n /// A `&str` is made up of two components: a pointer to some bytes, and a\n-/// length. You can look at these with the [`.as_ptr`] and [`len`] methods:\n+/// length. You can look at these with the [`as_ptr`] and [`len`] methods:\n ///\n /// ```\n /// use std::slice;\n@@ -452,11 +452,11 @@ mod prim_slice { }\n /// assert_eq!(s, Ok(story));\n /// ```\n ///\n-/// [`.as_ptr`]: #method.as_ptr\n+/// [`as_ptr`]: #method.as_ptr\n /// [`len`]: #method.len\n ///\n /// Note: This example shows the internals of `&str`. `unsafe` should not be\n-/// used to get a string slice under normal circumstances. Use `.as_slice()`\n+/// used to get a string slice under normal circumstances. Use `as_slice`\n /// instead.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_str { }"}, {"sha": "3b928ea93c78aef2fe8bdfff94f208bcd3d0b1d0", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -2552,10 +2552,10 @@ impl<'a> Parser<'a> {\n                   }\n                   token::Literal(token::Float(n), _suf) => {\n                     self.bump();\n-                    let prev_span = self.prev_span;\n                     let fstr = n.as_str();\n-                    let mut err = self.diagnostic().struct_span_err(prev_span,\n+                    let mut err = self.diagnostic().struct_span_err(self.prev_span,\n                         &format!(\"unexpected token: `{}`\", n));\n+                    err.span_label(self.prev_span, &\"unexpected token\");\n                     if fstr.chars().all(|x| \"0123456789.\".contains(x)) {\n                         let float = match fstr.parse::<f64>().ok() {\n                             Some(f) => f,\n@@ -2573,7 +2573,7 @@ impl<'a> Parser<'a> {\n                             word(&mut s.s, fstr.splitn(2, \".\").last().unwrap())\n                         });\n                         err.span_suggestion(\n-                            prev_span,\n+                            lo.to(self.prev_span),\n                             \"try parenthesizing the first index\",\n                             sugg);\n                     }"}, {"sha": "15ca151c49a79b5079763d6b8029af21c17d88f8", "filename": "src/test/compile-fail/issue-41139.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fcompile-fail%2Fissue-41139.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fcompile-fail%2Fissue-41139.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-41139.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Trait {}\n+\n+fn get_function<'a>() -> &'a Fn() -> Trait { panic!(\"\") }\n+\n+fn main() {\n+    let t : &Trait = &get_function()();\n+    //~^ ERROR cannot move a value of type Trait + 'static\n+}"}, {"sha": "37c6ef58f5e56bf680c07ca33d956b044f7917ac", "filename": "src/test/incremental/hashes/enum_defs.rs", "status": "modified", "additions": 75, "deletions": 17, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fenum_defs.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -38,8 +38,13 @@ enum EnumVisibility { A }\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n-pub enum EnumVisibility { A }\n+pub enum EnumVisibility {\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    A\n+}\n \n \n \n@@ -56,7 +61,10 @@ enum EnumChangeNameCStyleVariant {\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumChangeNameCStyleVariant {\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     Variant1,\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     Variant2Changed,\n }\n \n@@ -259,10 +267,13 @@ enum EnumChangeFieldTypeTupleStyleVariant {\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumChangeFieldTypeTupleStyleVariant {\n-    Variant1(u32, u64),\n+    Variant1(u32,\n+        #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+        #[rustc_metadata_clean(cfg=\"cfail3\")]\n+        u64),\n }\n \n \n@@ -277,11 +288,16 @@ enum EnumChangeFieldTypeStructStyleVariant {\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumChangeFieldTypeStructStyleVariant {\n     Variant1,\n-    Variant2 { a: u32, b: u64 },\n+    Variant2 {\n+        a: u32,\n+        #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+        #[rustc_metadata_clean(cfg=\"cfail3\")]\n+        b: u64\n+    },\n }\n \n \n@@ -312,10 +328,16 @@ enum EnumChangeOrderTupleStyleVariant {\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumChangeOrderTupleStyleVariant {\n-    Variant1(u64, u32),\n+    Variant1(\n+        #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+        #[rustc_metadata_clean(cfg=\"cfail3\")]\n+        u64,\n+        #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+        #[rustc_metadata_clean(cfg=\"cfail3\")]\n+        u32),\n }\n \n \n@@ -611,11 +633,23 @@ enum EnumSwapUsageTypeParameters<A, B> {\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumSwapUsageTypeParameters<A, B> {\n-    Variant1 { a: B },\n-    Variant2 { a: A },\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    Variant1 {\n+        #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+        #[rustc_metadata_clean(cfg=\"cfail3\")]\n+        a: B\n+    },\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    Variant2 {\n+        #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+        #[rustc_metadata_clean(cfg=\"cfail3\")]\n+        a: A\n+    },\n }\n \n \n@@ -630,11 +664,23 @@ enum EnumSwapUsageLifetimeParameters<'a, 'b> {\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n enum EnumSwapUsageLifetimeParameters<'a, 'b> {\n-    Variant1 { a: &'b u32 },\n-    Variant2 { b: &'a u32 },\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    Variant1 {\n+        #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+        #[rustc_metadata_clean(cfg=\"cfail3\")]\n+        a: &'b u32\n+    },\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    Variant2 {\n+        #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+        #[rustc_metadata_clean(cfg=\"cfail3\")]\n+        b: &'a u32\n+    },\n }\n \n \n@@ -653,10 +699,16 @@ mod change_field_type_indirectly_tuple_style {\n \n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     enum TupleStyle {\n-        Variant1(FieldType)\n+        #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+        #[rustc_metadata_clean(cfg=\"cfail3\")]\n+        Variant1(\n+            #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+            #[rustc_metadata_clean(cfg=\"cfail3\")]\n+            FieldType\n+        )\n     }\n }\n \n@@ -671,10 +723,16 @@ mod change_field_type_indirectly_struct_style {\n \n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     enum StructStyle {\n-        Variant1 { a: FieldType }\n+        #[rustc_metadata_clean(cfg=\"cfail2\")]\n+        #[rustc_metadata_clean(cfg=\"cfail3\")]\n+        Variant1 {\n+            #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+            #[rustc_metadata_clean(cfg=\"cfail3\")]\n+            a: FieldType\n+        }\n     }\n }\n "}, {"sha": "1d26e6c07d15bc9ab081d7f57a33053dfd7f5800", "filename": "src/test/incremental/hashes/extern_mods.rs", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fincremental%2Fhashes%2Fextern_mods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fincremental%2Fhashes%2Fextern_mods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fextern_mods.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -53,9 +53,11 @@ extern {\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n extern {\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn change_parameter_name(d: i64) -> i32;\n }\n \n@@ -70,9 +72,11 @@ extern {\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n extern {\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn change_parameter_type(c: i32) -> i32;\n }\n \n@@ -87,9 +91,11 @@ extern {\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n extern {\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn change_return_type(c: i32) -> i8;\n }\n \n@@ -104,9 +110,11 @@ extern {\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n extern {\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn add_parameter(c: i32, d: i32) -> i32;\n }\n \n@@ -121,9 +129,11 @@ extern {\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n extern {\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn add_return_type(c: i32) -> i32;\n }\n \n@@ -138,9 +148,11 @@ extern {\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n extern {\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn make_function_variadic(c: i32, ...);\n }\n \n@@ -155,9 +167,11 @@ extern \"C\" {\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n extern \"rust-call\" {\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn change_calling_convention(c: i32);\n }\n \n@@ -172,9 +186,11 @@ extern {\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n extern {\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn make_function_public(c: i32);\n }\n \n@@ -246,9 +262,11 @@ mod indirectly_change_parameter_type {\n \n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     extern {\n+        #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+        #[rustc_metadata_clean(cfg=\"cfail3\")]\n         pub fn indirectly_change_parameter_type(c: c_int);\n     }\n }\n@@ -264,9 +282,11 @@ mod indirectly_change_return_type {\n \n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     extern {\n+        #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+        #[rustc_metadata_clean(cfg=\"cfail3\")]\n         pub fn indirectly_change_return_type() -> c_int;\n     }\n }"}, {"sha": "2fe3f0d5d1fe03911aaa08cd7e87874665c89ffc", "filename": "src/test/incremental/hashes/function_interfaces.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -50,7 +50,7 @@ fn add_return_type() {}\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")] // The type doesn't change, so metadata is the same\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn add_return_type() -> () {}\n \n@@ -154,7 +154,7 @@ fn lifetime_parameter() {}\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+// #[rustc_metadata_dirty(cfg=\"cfail2\")] -- Unused lifetime params don't show up in the type?\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn lifetime_parameter<'a>() {}\n \n@@ -315,16 +315,16 @@ fn return_impl_trait() -> impl Clone {\n \n #[cfg(cfail1)]\n fn change_return_impl_trait() -> impl Clone {\n-    0\n+    0u32\n }\n \n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")] // The actual type is the same, so: clean\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n fn change_return_impl_trait() -> impl Copy {\n-    0\n+    0u32\n }\n \n "}, {"sha": "899aefa24a033b0e3d4eeeb666b96c7e3b9c86d2", "filename": "src/test/incremental/hashes/inherent_impls.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -107,7 +107,7 @@ impl Foo {\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -126,7 +126,7 @@ impl Foo {\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl Foo {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -171,7 +171,7 @@ impl Foo {\n impl Foo {\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn add_method_to_impl1(&self) { }\n \n@@ -219,9 +219,7 @@ impl Foo {\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n     #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-    // At the moment we explicitly ignore argument names in metadata, since they\n-    // are not used in downstream crates (except in rustdoc)\n-    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn change_method_parameter_name(&self, b: i64) { }\n }\n@@ -287,9 +285,7 @@ impl Foo {\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n     #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"HirBody\", cfg=\"cfail3\")]\n-    // At the moment we explicitly ignore argument names in metadata, since they\n-    // are not used in downstream crates (except in rustdoc)\n-    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn change_method_parameter_order(&self, b: i64, a: i64) { }\n }\n@@ -373,7 +369,7 @@ impl Foo {\n impl Foo {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")] // Apparently unused lifetimes don't show up in the type.\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn add_lifetime_parameter_to_method<'a>(&self) { }\n }\n@@ -544,7 +540,7 @@ impl<T> Bar<T> {\n impl<T: 'static> Bar<T> {\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn add_lifetime_bound_to_impl_parameter(&self) { }\n }\n@@ -565,7 +561,7 @@ impl<T> Bar<T> {\n impl<T: Clone> Bar<T> {\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     pub fn add_trait_bound_to_impl_parameter(&self) { }\n }"}, {"sha": "17a5dc16783678fe8326ade18b0d643f035d08e3", "filename": "src/test/incremental/hashes/struct_defs.rs", "status": "modified", "additions": 75, "deletions": 15, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_defs.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -62,9 +62,13 @@ struct TupleStructFieldType(i32);\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n-struct TupleStructFieldType(u32);\n+struct TupleStructFieldType(\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    u32\n+);\n \n \n // Tuple Struct Add Field ------------------------------------------------------\n@@ -77,7 +81,13 @@ struct TupleStructAddField(i32);\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n-struct TupleStructAddField(i32, u32);\n+struct TupleStructAddField(\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    i32,\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    u32\n+);\n \n \n // Tuple Struct Field Visibility -----------------------------------------------\n@@ -101,9 +111,13 @@ struct RecordStructFieldType { x: f32 }\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n-struct RecordStructFieldType { x: u64 }\n+struct RecordStructFieldType {\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    x: u64\n+}\n \n \n // Record Struct Field Name ----------------------------------------------------\n@@ -129,7 +143,12 @@ struct RecordStructAddField { x: f32 }\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n-struct RecordStructAddField { x: f32, y: () }\n+struct RecordStructAddField {\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    x: f32,\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    y: () }\n \n \n // Record Struct Field Visibility ----------------------------------------------\n@@ -142,7 +161,11 @@ struct RecordStructFieldVisibility { x: f32 }\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n-struct RecordStructFieldVisibility { pub x: f32 }\n+struct RecordStructFieldVisibility {\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    pub x: f32\n+}\n \n \n // Add Lifetime Parameter ------------------------------------------------------\n@@ -168,7 +191,14 @@ struct AddLifetimeParameterBound<'a, 'b>(&'a f32, &'b f64);\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n-struct AddLifetimeParameterBound<'a, 'b: 'a>(&'a f32, &'b f64);\n+struct AddLifetimeParameterBound<'a, 'b: 'a>(\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    &'a f32,\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    &'b f64\n+);\n \n #[cfg(cfail1)]\n struct AddLifetimeParameterBoundWhereClause<'a, 'b>(&'a f32, &'b f64);\n@@ -178,7 +208,13 @@ struct AddLifetimeParameterBoundWhereClause<'a, 'b>(&'a f32, &'b f64);\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n-struct AddLifetimeParameterBoundWhereClause<'a, 'b>(&'a f32, &'b f64)\n+struct AddLifetimeParameterBoundWhereClause<'a, 'b>(\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    &'a f32,\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    &'b f64)\n     where 'b: 'a;\n \n \n@@ -192,7 +228,16 @@ struct AddTypeParameter<T1>(T1, T1);\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n-struct AddTypeParameter<T1, T2>(T1, T2);\n+struct AddTypeParameter<T1, T2>(\n+     // The field contains the parent's Generics, so it's dirty even though its\n+     // type hasn't changed.\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    T1,\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    T2\n+);\n \n \n // Add Type Parameter Bound ----------------------------------------------------\n@@ -205,7 +250,11 @@ struct AddTypeParameterBound<T>(T);\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n-struct AddTypeParameterBound<T: Send>(T);\n+struct AddTypeParameterBound<T: Send>(\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    T\n+);\n \n \n #[cfg(cfail1)]\n@@ -216,7 +265,11 @@ struct AddTypeParameterBoundWhereClause<T>(T);\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n #[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n-struct AddTypeParameterBoundWhereClause<T>(T) where T: Sync;\n+struct AddTypeParameterBoundWhereClause<T>(\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    T\n+) where T: Sync;\n \n \n // Empty struct ----------------------------------------------------------------\n@@ -234,6 +287,7 @@ struct Visibility;\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub struct Visibility;\n \n@@ -252,9 +306,13 @@ mod tuple_struct_change_field_type_indirectly {\n \n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n-    struct TupleStruct(FieldType);\n+    struct TupleStruct(\n+        #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+        #[rustc_metadata_clean(cfg=\"cfail3\")]\n+        FieldType\n+    );\n }\n \n \n@@ -267,9 +325,11 @@ mod record_struct_change_field_type_indirectly {\n \n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     struct RecordStruct {\n+        #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+        #[rustc_metadata_clean(cfg=\"cfail3\")]\n         _x: FieldType\n     }\n }"}, {"sha": "61a2be054a51a61e8758f837d3d67a3344b235b9", "filename": "src/test/incremental/hashes/trait_defs.rs", "status": "modified", "additions": 73, "deletions": 48, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_defs.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -100,7 +100,7 @@ trait TraitAddReturnType {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddReturnType {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -121,7 +121,7 @@ trait TraitChangeReturnType {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitChangeReturnType {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -142,7 +142,7 @@ trait TraitAddParameterToMethod {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddParameterToMethod {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -164,7 +164,7 @@ trait TraitChangeMethodParameterName {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitChangeMethodParameterName {\n     // FIXME(#38501) This should preferably always be clean.\n@@ -194,7 +194,7 @@ trait TraitChangeMethodParameterType {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitChangeMethodParameterType {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -215,7 +215,7 @@ trait TraitChangeMethodParameterTypeRef {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitChangeMethodParameterTypeRef {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -236,7 +236,7 @@ trait TraitChangeMethodParametersOrder {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitChangeMethodParametersOrder {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -257,9 +257,13 @@ trait TraitAddMethodDefaultImplementation {\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddMethodDefaultImplementation {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method() { }\n }\n \n@@ -293,7 +297,7 @@ trait TraitChangeModeSelfRefToMut {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitChangeModeSelfRefToMut {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -335,7 +339,7 @@ trait TraitChangeModeSelfOwnToRef {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitChangeModeSelfOwnToRef {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -356,7 +360,7 @@ trait TraitAddUnsafeModifier {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddUnsafeModifier {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -377,7 +381,7 @@ trait TraitAddExternModifier {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddExternModifier {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -398,7 +402,7 @@ trait TraitChangeExternCToRustIntrinsic {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitChangeExternCToRustIntrinsic {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -419,7 +423,7 @@ trait TraitAddTypeParameterToMethod {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddTypeParameterToMethod {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -440,12 +444,12 @@ trait TraitAddLifetimeParameterToMethod {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddLifetimeParameterToMethod {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")] // Unused lifetimes don't seem to show up in type?\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method<'a>();\n }\n@@ -465,7 +469,7 @@ trait TraitAddTraitBoundToMethodTypeParameter {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddTraitBoundToMethodTypeParameter {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -486,7 +490,7 @@ trait TraitAddBuiltinBoundToMethodTypeParameter {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddBuiltinBoundToMethodTypeParameter {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -507,7 +511,7 @@ trait TraitAddLifetimeBoundToMethodLifetimeParameter {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddLifetimeBoundToMethodLifetimeParameter {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -528,7 +532,7 @@ trait TraitAddSecondTraitBoundToMethodTypeParameter {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddSecondTraitBoundToMethodTypeParameter {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -549,7 +553,7 @@ trait TraitAddSecondBuiltinBoundToMethodTypeParameter {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddSecondBuiltinBoundToMethodTypeParameter {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -570,7 +574,7 @@ trait TraitAddSecondLifetimeBoundToMethodLifetimeParameter {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddSecondLifetimeBoundToMethodLifetimeParameter {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -585,7 +589,12 @@ trait TraitAddSecondLifetimeBoundToMethodLifetimeParameter {\n // Add associated type ------------------------------------------------------------\n #[cfg(cfail1)]\n trait TraitAddAssociatedType {\n-    fn mathod();\n+\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn method();\n }\n \n #[cfg(not(cfail1))]\n@@ -596,7 +605,7 @@ trait TraitAddAssociatedType {\n trait TraitAddAssociatedType {\n     type Associated;\n \n-    fn mathod();\n+    fn method();\n }\n \n \n@@ -606,9 +615,12 @@ trait TraitAddAssociatedType {\n trait TraitAddTraitBoundToAssociatedType {\n     type Associated;\n \n-    fn mathod();\n+    fn method();\n }\n \n+\n+// Apparently the type bound contributes to the predicates of the trait, but\n+// does not change the associated item itself.\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n@@ -617,11 +629,11 @@ trait TraitAddTraitBoundToAssociatedType {\n trait TraitAddTraitBoundToAssociatedType {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     type Associated: ReferencedTrait0;\n \n-    fn mathod();\n+    fn method();\n }\n \n \n@@ -631,7 +643,7 @@ trait TraitAddTraitBoundToAssociatedType {\n trait TraitAddLifetimeBoundToAssociatedType<'a> {\n     type Associated;\n \n-    fn mathod();\n+    fn method();\n }\n \n #[cfg(not(cfail1))]\n@@ -642,11 +654,11 @@ trait TraitAddLifetimeBoundToAssociatedType<'a> {\n trait TraitAddLifetimeBoundToAssociatedType<'a> {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     type Associated: 'a;\n \n-    fn mathod();\n+    fn method();\n }\n \n \n@@ -656,26 +668,30 @@ trait TraitAddLifetimeBoundToAssociatedType<'a> {\n trait TraitAddDefaultToAssociatedType {\n     type Associated;\n \n-    fn mathod();\n+    fn method();\n }\n \n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddDefaultToAssociatedType {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     type Associated = ReferenceType0;\n \n-    fn mathod();\n+    fn method();\n }\n \n \n \n // Add associated constant --------------------------------------------------------\n #[cfg(cfail1)]\n trait TraitAddAssociatedConstant {\n-    fn mathod();\n+    fn method();\n }\n \n #[cfg(not(cfail1))]\n@@ -686,7 +702,7 @@ trait TraitAddAssociatedConstant {\n trait TraitAddAssociatedConstant {\n     const Value: u32;\n \n-    fn mathod();\n+    fn method();\n }\n \n \n@@ -696,18 +712,26 @@ trait TraitAddAssociatedConstant {\n trait TraitAddInitializerToAssociatedConstant {\n     const Value: u32;\n \n-    fn mathod();\n+    fn method();\n }\n \n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitAddInitializerToAssociatedConstant {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     const Value: u32 = 1;\n \n-    fn mathod();\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn method();\n }\n \n \n@@ -717,13 +741,13 @@ trait TraitAddInitializerToAssociatedConstant {\n trait TraitChangeTypeOfAssociatedConstant {\n     const Value: u32;\n \n-    fn mathod();\n+    fn method();\n }\n \n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n trait TraitChangeTypeOfAssociatedConstant {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -732,7 +756,11 @@ trait TraitChangeTypeOfAssociatedConstant {\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     const Value: f64;\n \n-    fn mathod();\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n+    fn method();\n }\n \n \n@@ -1111,9 +1139,6 @@ trait TraitAddSecondBuiltinBoundToTypeParameterOfTraitWhere<T> where T: Send { }\n trait TraitAddSecondBuiltinBoundToTypeParameterOfTraitWhere<T> where T: Send + Sync { }\n \n \n-\n-// EDIT: Some more cases ----------------------------------------------------------\n-\n // Change return type of method indirectly by modifying a use statement------------\n mod change_return_type_of_method_indirectly_use {\n     #[cfg(cfail1)]\n@@ -1123,7 +1148,7 @@ mod change_return_type_of_method_indirectly_use {\n \n     #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     trait TraitChangeReturnType {\n         #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -1145,7 +1170,7 @@ mod change_method_parameter_type_indirectly_by_use {\n \n     #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     trait TraitChangeArgType {\n         #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -1167,7 +1192,7 @@ mod change_method_parameter_type_bound_indirectly_by_use {\n \n     #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     trait TraitChangeBoundOfMethodTypeParameter {\n         #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -1190,7 +1215,7 @@ mod change_method_parameter_type_bound_indirectly_by_use_where {\n \n     #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     trait TraitChangeBoundOfMethodTypeParameterWhere {\n         #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]"}, {"sha": "06c8eb6a878f06e96a88451a87cbb9ad69a9f8de", "filename": "src/test/incremental/hashes/trait_impls.rs", "status": "modified", "additions": 21, "deletions": 37, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ftrait_impls.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -120,7 +120,7 @@ impl ChangeMethodBodyTraitInlined for Foo {\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     #[inline]\n     fn method_name() {\n-        ()\n+        panic!()\n     }\n }\n \n@@ -144,7 +144,7 @@ pub trait ChangeMethodSelfnessTrait {\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl ChangeMethodSelfnessTrait for Foo {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -176,16 +176,14 @@ pub trait RemoveMethodSelfnessTrait {\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl RemoveMethodSelfnessTrait for Foo {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n-    fn method_name() {\n-        ()\n-    }\n+    fn method_name() {}\n }\n \n // Change Method Selfmutness -----------------------------------------------------------\n@@ -208,16 +206,14 @@ pub trait ChangeMethodSelfmutnessTrait {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl ChangeMethodSelfmutnessTrait for Foo {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n     #[rustc_metadata_dirty(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n-    fn method_name(&mut self) {\n-        ()\n-    }\n+    fn method_name(&mut self) {}\n }\n \n // Change item kind -----------------------------------------------------------\n@@ -317,16 +313,20 @@ impl ChangeHasValueTrait for Foo {\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n pub trait ChangeHasValueTrait {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn method_name() { }\n }\n \n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl ChangeHasValueTrait for Foo {\n     fn method_name() { }\n@@ -346,32 +346,16 @@ impl AddDefaultTrait for Foo {\n #[cfg(not(cfail1))]\n #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl AddDefaultTrait for Foo {\n+    #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail3\")]\n     default fn method_name() { }\n }\n \n-// Remove default\n-\n-pub trait RemoveDefaultTrait {\n-    fn method_name();\n-}\n-\n-#[cfg(cfail1)]\n-impl RemoveDefaultTrait for Foo {\n-    default fn method_name() { }\n-}\n-\n-#[cfg(not(cfail1))]\n-#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n-#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n-#[rustc_metadata_clean(cfg=\"cfail3\")]\n-impl RemoveDefaultTrait for Foo {\n-    fn method_name() { }\n-}\n-\n // Add arguments\n \n #[cfg(cfail1)]\n@@ -392,7 +376,7 @@ pub trait AddArgumentTrait {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl AddArgumentTrait for Foo {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -422,7 +406,7 @@ pub trait ChangeArgumentTypeTrait {\n #[cfg(not(cfail1))]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n #[rustc_metadata_clean(cfg=\"cfail3\")]\n impl ChangeArgumentTypeTrait for Foo {\n     #[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n@@ -504,7 +488,7 @@ impl<T> AddLifetimeBoundToImplParameter for T {\n impl<T: 'static> AddLifetimeBoundToImplParameter for T {\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn id(self) -> Self { self }\n }\n@@ -529,7 +513,7 @@ impl<T> AddTraitBoundToImplParameter for T {\n impl<T: Clone> AddTraitBoundToImplParameter for T {\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n     #[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n+    #[rustc_metadata_clean(cfg=\"cfail2\")]\n     #[rustc_metadata_clean(cfg=\"cfail3\")]\n     fn id(self) -> Self { self }\n }"}, {"sha": "917c2c9dbce4f10434ebb49e6b7984d7414785f9", "filename": "src/test/incremental/unchecked_dirty_clean_metadata.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fincremental%2Funchecked_dirty_clean_metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fincremental%2Funchecked_dirty_clean_metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Funchecked_dirty_clean_metadata.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -33,13 +33,3 @@ fn main() {\n     }\n }\n \n-struct _Struct {\n-    #[rustc_metadata_dirty(cfg=\"cfail2\")]\n-    //[cfail2]~^ ERROR found unchecked #[rustc_dirty]/#[rustc_clean] attribute\n-    _field1: i32,\n-\n-    #[rustc_metadata_clean(cfg=\"cfail2\")]\n-    //[cfail2]~^ ERROR found unchecked #[rustc_dirty]/#[rustc_clean] attribute\n-    _field2: i32,\n-}\n-"}, {"sha": "4e09928edc6d1c7972fd6629f69b1a4fd982b159", "filename": "src/test/run-make/extern-fn-struct-passing-abi/test.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Frun-make%2Fextern-fn-struct-passing-abi%2Ftest.c", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Frun-make%2Fextern-fn-struct-passing-abi%2Ftest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-fn-struct-passing-abi%2Ftest.c?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -38,6 +38,11 @@ struct Huge {\n     int32_t e;\n };\n \n+struct FloatPoint {\n+    double x;\n+    double y;\n+};\n+\n // System V x86_64 ABI:\n // a, b, c, d, e should be in registers\n // s should be byval pointer\n@@ -258,3 +263,17 @@ struct Huge huge_struct(struct Huge s) {\n \n     return s;\n }\n+\n+// System V x86_64 ABI:\n+// p should be in registers\n+// return should be in registers\n+//\n+// Win64 ABI:\n+// p should be a byval pointer\n+// return should be in a hidden sret pointer\n+struct FloatPoint float_point(struct FloatPoint p) {\n+    assert(p.x == 5.);\n+    assert(p.y == -3.);\n+\n+    return p;\n+}"}, {"sha": "ff845a644b11441beedabbac2666a078d891385b", "filename": "src/test/run-make/extern-fn-struct-passing-abi/test.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Frun-make%2Fextern-fn-struct-passing-abi%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Frun-make%2Fextern-fn-struct-passing-abi%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-fn-struct-passing-abi%2Ftest.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -46,6 +46,13 @@ struct Huge {\n     e: i32\n }\n \n+#[derive(Clone, Copy, Debug, PartialEq)]\n+#[repr(C)]\n+struct FloatPoint {\n+    x: f64,\n+    y: f64\n+}\n+\n #[link(name = \"test\", kind = \"static\")]\n extern {\n     fn byval_rect(a: i32, b: i32, c: i32, d: i32, e: i32, s: Rect);\n@@ -72,13 +79,16 @@ extern {\n     fn sret_split_struct(a: i32, b: i32, s: Rect) -> BiggerRect;\n \n     fn huge_struct(s: Huge) -> Huge;\n+\n+    fn float_point(p: FloatPoint) -> FloatPoint;\n }\n \n fn main() {\n     let s = Rect { a: 553, b: 554, c: 555, d: 556 };\n     let t = BiggerRect { s: s, a: 27834, b: 7657 };\n     let u = FloatRect { a: 3489, b: 3490, c: 8. };\n     let v = Huge { a: 5647, b: 5648, c: 5649, d: 5650, e: 5651 };\n+    let p = FloatPoint { x: 5., y: -3. };\n \n     unsafe {\n         byval_rect(1, 2, 3, 4, 5, s);\n@@ -94,5 +104,6 @@ fn main() {\n         assert_eq!(split_ret_byval_struct(1, 2, s), s);\n         assert_eq!(sret_byval_struct(1, 2, 3, 4, s), t);\n         assert_eq!(sret_split_struct(1, 2, s), t);\n+        assert_eq!(float_point(p), p);\n     }\n }"}, {"sha": "6956a043cc694a4a8ee04375b23c0e658948e10c", "filename": "src/test/ui/lifetime-errors/ex2a-push-one-existing-name.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -4,8 +4,8 @@ error[E0308]: mismatched types\n 16 |     x.push(y);\n    |            ^ lifetime mismatch\n    |\n-   = note: expected type `Ref<'a, i32>`\n-              found type `Ref<'_, i32>`\n+   = note: expected type `Ref<'a, _>`\n+              found type `Ref<'_, _>`\n note: the anonymous lifetime #2 defined on the body at 15:51...\n   --> $DIR/ex2a-push-one-existing-name.rs:15:52\n    |"}, {"sha": "990ae65ba9854193bfcf0f0d3918b60bcae13000", "filename": "src/test/ui/lifetime-errors/ex2b-push-no-existing-names.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -4,8 +4,8 @@ error[E0308]: mismatched types\n 16 |     x.push(y);\n    |            ^ lifetime mismatch\n    |\n-   = note: expected type `Ref<'_, i32>`\n-              found type `Ref<'_, i32>`\n+   = note: expected type `Ref<'_, _>`\n+              found type `Ref<'_, _>`\n note: the anonymous lifetime #3 defined on the body at 15:43...\n   --> $DIR/ex2b-push-no-existing-names.rs:15:44\n    |"}, {"sha": "82f6c71ec1c2eb36314a56c70547593c393920d6", "filename": "src/test/ui/lifetime-errors/ex2c-push-inference-variable.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -27,7 +27,7 @@ note: but, the lifetime must be valid for the lifetime 'b as defined on the body\n 17 | |     x.push(z);\n 18 | | }\n    | |_^ ...ending here\n-note: ...so that expression is assignable (expected Ref<'b, i32>, found Ref<'_, i32>)\n+note: ...so that expression is assignable (expected Ref<'b, _>, found Ref<'_, _>)\n   --> $DIR/ex2c-push-inference-variable.rs:17:12\n    |\n 17 |     x.push(z);"}, {"sha": "c448ad955fab4ec7e360a52f80a45d2f2bdd39fb", "filename": "src/test/ui/mismatched_types/abridged.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Bar {\n+    Qux,\n+    Zar,\n+}\n+\n+struct Foo {\n+    bar: usize,\n+}\n+\n+struct X<T1, T2> {\n+    x: T1,\n+    y: T2,\n+}\n+\n+fn a() -> Foo {\n+    Some(Foo { bar: 1 })\n+}\n+\n+fn a2() -> Foo {\n+    Ok(Foo { bar: 1})\n+}\n+\n+fn b() -> Option<Foo> {\n+    Foo { bar: 1 }\n+}\n+\n+fn c() -> Result<Foo, Bar> {\n+    Foo { bar: 1 }\n+}\n+\n+fn d() -> X<X<String, String>, String> {\n+    X {\n+        x: X {\n+            x: \"\".to_string(),\n+            y: 2,\n+        },\n+        y: 3,\n+    }\n+}\n+\n+fn e() -> X<X<String, String>, String> {\n+    X {\n+        x: X {\n+            x: \"\".to_string(),\n+            y: 2,\n+        },\n+        y: \"\".to_string(),\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "c67c6113d17c54c0aab0dda783643e25158b69bb", "filename": "src/test/ui/mismatched_types/abridged.stderr", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fabridged.stderr?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -0,0 +1,70 @@\n+error[E0308]: mismatched types\n+  --> $DIR/abridged.rs:26:5\n+   |\n+26 |     Some(Foo { bar: 1 })\n+   |     ^^^^^^^^^^^^^^^^^^^^ expected struct `Foo`, found enum `std::option::Option`\n+   |\n+   = note: expected type `Foo`\n+              found type `std::option::Option<Foo>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/abridged.rs:30:5\n+   |\n+30 |     Ok(Foo { bar: 1})\n+   |     ^^^^^^^^^^^^^^^^^ expected struct `Foo`, found enum `std::result::Result`\n+   |\n+   = note: expected type `Foo`\n+              found type `std::result::Result<Foo, _>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/abridged.rs:34:5\n+   |\n+34 |     Foo { bar: 1 }\n+   |     ^^^^^^^^^^^^^^ expected enum `std::option::Option`, found struct `Foo`\n+   |\n+   = note: expected type `std::option::Option<Foo>`\n+              found type `Foo`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/abridged.rs:38:5\n+   |\n+38 |     Foo { bar: 1 }\n+   |     ^^^^^^^^^^^^^^ expected enum `std::result::Result`, found struct `Foo`\n+   |\n+   = note: expected type `std::result::Result<Foo, Bar>`\n+              found type `Foo`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/abridged.rs:42:5\n+   |\n+42 |       X {\n+   |  _____^ starting here...\n+43 | |         x: X {\n+44 | |             x: \"\".to_string(),\n+45 | |             y: 2,\n+46 | |         },\n+47 | |         y: 3,\n+48 | |     }\n+   | |_____^ ...ending here: expected struct `std::string::String`, found integral variable\n+   |\n+   = note: expected type `X<X<_, std::string::String>, std::string::String>`\n+              found type `X<X<_, {integer}>, {integer}>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/abridged.rs:52:5\n+   |\n+52 |       X {\n+   |  _____^ starting here...\n+53 | |         x: X {\n+54 | |             x: \"\".to_string(),\n+55 | |             y: 2,\n+56 | |         },\n+57 | |         y: \"\".to_string(),\n+58 | |     }\n+   | |_____^ ...ending here: expected struct `std::string::String`, found integral variable\n+   |\n+   = note: expected type `X<X<_, std::string::String>, _>`\n+              found type `X<X<_, {integer}>, _>`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "8bfbd0e74db228a4739c570a0b607920820cb5df", "filename": "src/test/ui/suggestions/tuple-float-index.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fui%2Fsuggestions%2Ftuple-float-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fui%2Fsuggestions%2Ftuple-float-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftuple-float-index.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -11,7 +11,5 @@\n // compile-flags: -Z parse-only\n \n fn main () {\n-    (1, (2, 3)).1.1; //~ ERROR unexpected token\n-                     //~^ HELP try parenthesizing the first index\n-                     //~| SUGGESTION ((1, (2, 3)).1).1\n+    (1, (2, 3)).1.1;\n }", "previous_filename": "src/test/parse-fail/tuple-float-index.rs"}, {"sha": "abe04dc1aa210738867a6ee164c51828711f02c9", "filename": "src/test/ui/suggestions/tuple-float-index.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fui%2Fsuggestions%2Ftuple-float-index.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftest%2Fui%2Fsuggestions%2Ftuple-float-index.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftuple-float-index.stderr?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -0,0 +1,11 @@\n+error: unexpected token: `1.1`\n+  --> $DIR/tuple-float-index.rs:14:17\n+   |\n+14 |     (1, (2, 3)).1.1;\n+   |                 ^^^ unexpected token\n+   |\n+help: try parenthesizing the first index\n+   |     ((1, (2, 3)).1).1;\n+\n+error: aborting due to previous error\n+"}, {"sha": "7fb296c19f6ed9183e758e21f6c5b0e28c0c592c", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -1589,8 +1589,14 @@ actual:\\n\\\n     }\n \n     fn dump_output(&self, out: &str, err: &str) {\n-        self.dump_output_file(out, \"out\");\n-        self.dump_output_file(err, \"err\");\n+        let revision = if let Some(r) = self.revision {\n+            format!(\"{}.\", r)\n+        } else {\n+            String::new()\n+        };\n+\n+        self.dump_output_file(out, &format!(\"{}out\", revision));\n+        self.dump_output_file(err, &format!(\"{}err\", revision));\n         self.maybe_dump_to_stdout(out, err);\n     }\n "}, {"sha": "17f8b62117ad4faebbd58d5dde54d5d32cf64a46", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/910c4816fdee01a1299d11a5e85ebb4aceee6d1a/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=910c4816fdee01a1299d11a5e85ebb4aceee6d1a", "patch": "@@ -82,11 +82,9 @@ fn filter_dirs(path: &Path) -> bool {\n         \"src/llvm\",\n         \"src/libbacktrace\",\n         \"src/compiler-rt\",\n-        \"src/rt/hoedown\",\n         \"src/rustllvm\",\n         \"src/rust-installer\",\n         \"src/liblibc\",\n-        \"src/tools/cargo\",\n         \"src/vendor\",\n     ];\n     skip.iter().any(|p| path.ends_with(p))"}]}