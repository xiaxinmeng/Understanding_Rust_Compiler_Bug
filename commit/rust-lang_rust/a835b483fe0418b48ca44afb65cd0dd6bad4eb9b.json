{"sha": "a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4MzViNDgzZmUwNDE4YjQ4Y2E0NGFmYjY1Y2QwZGQ2YmFkNGViOWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-04T13:49:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-04T13:49:36Z"}, "message": "Auto merge of #77527 - jonas-schievink:rollup-szgq5he, r=jonas-schievink\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #77072 (Minor `hash_map` doc adjustments + item attribute orderings)\n - #77368 (Backport LLVM apfloat commit to rustc_apfloat)\n - #77445 (BTreeMap: complete the compile-time test_variance test case)\n - #77504 (Support vectors with fewer than 8 elements for simd_select_bitmask)\n - #77513 (Change DocFragments from enum variant fields to structs with a nested enum)\n - #77518 (Only use Fira Sans for the first `td` in item lists)\n - #77521 (Move target feature whitelist from cg_llvm to cg_ssa)\n - #77525 (Enable RenameReturnPlace MIR optimization on mir-opt-level >= 2)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "e5259afd7476af32e8bb7b8f41ea22a4a1f40e07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5259afd7476af32e8bb7b8f41ea22a4a1f40e07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "html_url": "https://github.com/rust-lang/rust/commit/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0644cc1242dbeebb69b1b2496562751ba5d23ffb", "url": "https://api.github.com/repos/rust-lang/rust/commits/0644cc1242dbeebb69b1b2496562751ba5d23ffb", "html_url": "https://github.com/rust-lang/rust/commit/0644cc1242dbeebb69b1b2496562751ba5d23ffb"}, {"sha": "fa200cec889b2b2308882a897cafe92bf1cf13c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa200cec889b2b2308882a897cafe92bf1cf13c7", "html_url": "https://github.com/rust-lang/rust/commit/fa200cec889b2b2308882a897cafe92bf1cf13c7"}], "stats": {"total": 756, "additions": 438, "deletions": 318}, "files": [{"sha": "71bcb8f090d07f98a9f50fe31c0e63a83ef9b113", "filename": "compiler/rustc_apfloat/src/ieee.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2Fsrc%2Fieee.rs?ref=a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "patch": "@@ -1511,11 +1511,16 @@ impl<S: Semantics, T: Semantics> FloatConvert<IeeeFloat<T>> for IeeeFloat<S> {\n                 sig::set_bit(&mut r.sig, T::PRECISION - 1);\n             }\n \n-            // gcc forces the Quiet bit on, which means (float)(double)(float_sNan)\n-            // does not give you back the same bits. This is dubious, and we\n-            // don't currently do it. You're really supposed to get\n-            // an invalid operation signal at runtime, but nobody does that.\n-            status = Status::OK;\n+            // Convert of sNaN creates qNaN and raises an exception (invalid op).\n+            // This also guarantees that a sNaN does not become Inf on a truncation\n+            // that loses all payload bits.\n+            if self.is_signaling() {\n+                // Quiet signaling NaN.\n+                sig::set_bit(&mut r.sig, T::QNAN_BIT);\n+                status = Status::INVALID_OP;\n+            } else {\n+                status = Status::OK;\n+            }\n         } else {\n             *loses_info = false;\n             status = Status::OK;"}, {"sha": "63d925cce9ad7f6e22e55388ef772b127c57bba6", "filename": "compiler/rustc_apfloat/tests/ieee.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/compiler%2Frustc_apfloat%2Ftests%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/compiler%2Frustc_apfloat%2Ftests%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_apfloat%2Ftests%2Fieee.rs?ref=a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "patch": "@@ -566,6 +566,17 @@ fn fma() {\n     }\n }\n \n+#[test]\n+fn issue_69532() {\n+    let f = Double::from_bits(0x7FF0_0000_0000_0001u64 as u128);\n+    let mut loses_info = false;\n+    let sta = f.convert(&mut loses_info);\n+    let r: Single = sta.value;\n+    assert!(loses_info);\n+    assert!(r.is_nan());\n+    assert_eq!(sta.status, Status::INVALID_OP);\n+}\n+\n #[test]\n fn min_num() {\n     let f1 = Double::from_f64(1.0);\n@@ -1492,27 +1503,32 @@ fn convert() {\n     assert_eq!(4294967295.0, test.to_f64());\n     assert!(!loses_info);\n \n-    let test = Single::snan(None);\n-    let x87_snan = X87DoubleExtended::snan(None);\n-    let test: X87DoubleExtended = test.convert(&mut loses_info).value;\n-    assert!(test.bitwise_eq(x87_snan));\n-    assert!(!loses_info);\n-\n     let test = Single::qnan(None);\n     let x87_qnan = X87DoubleExtended::qnan(None);\n     let test: X87DoubleExtended = test.convert(&mut loses_info).value;\n     assert!(test.bitwise_eq(x87_qnan));\n     assert!(!loses_info);\n \n-    let test = X87DoubleExtended::snan(None);\n-    let test: X87DoubleExtended = test.convert(&mut loses_info).value;\n-    assert!(test.bitwise_eq(x87_snan));\n+    let test = Single::snan(None);\n+    let sta = test.convert(&mut loses_info);\n+    let test: X87DoubleExtended = sta.value;\n+    assert!(test.is_nan());\n+    assert!(!test.is_signaling());\n     assert!(!loses_info);\n+    assert_eq!(sta.status, Status::INVALID_OP);\n \n     let test = X87DoubleExtended::qnan(None);\n     let test: X87DoubleExtended = test.convert(&mut loses_info).value;\n     assert!(test.bitwise_eq(x87_qnan));\n     assert!(!loses_info);\n+\n+    let test = X87DoubleExtended::snan(None);\n+    let sta = test.convert(&mut loses_info);\n+    let test: X87DoubleExtended = sta.value;\n+    assert!(test.is_nan());\n+    assert!(!test.is_signaling());\n+    assert!(!loses_info);\n+    assert_eq!(sta.status, Status::INVALID_OP);\n }\n \n #[test]"}, {"sha": "a633ea5e5a9ae558a1c8b7c66097a52b51191e24", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "patch": "@@ -349,17 +349,15 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n }\n \n pub fn provide(providers: &mut Providers) {\n+    use rustc_codegen_ssa::target_features::{all_known_features, supported_target_features};\n     providers.supported_target_features = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n         if tcx.sess.opts.actually_rustdoc {\n             // rustdoc needs to be able to document functions that use all the features, so\n             // provide them all.\n-            llvm_util::all_known_features().map(|(a, b)| (a.to_string(), b)).collect()\n+            all_known_features().map(|(a, b)| (a.to_string(), b)).collect()\n         } else {\n-            llvm_util::supported_target_features(tcx.sess)\n-                .iter()\n-                .map(|&(a, b)| (a.to_string(), b))\n-                .collect()\n+            supported_target_features(tcx.sess).iter().map(|&(a, b)| (a.to_string(), b)).collect()\n         }\n     };\n "}, {"sha": "e76e86f56510ba02ef77c1fa81990bfafe93c670", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "patch": "@@ -793,14 +793,18 @@ fn generic_simd_intrinsic(\n         require_simd!(arg_tys[1], \"argument\");\n         let v_len = arg_tys[1].simd_size(tcx);\n         require!(\n-            m_len == v_len,\n+            // Allow masks for vectors with fewer than 8 elements to be\n+            // represented with a u8 or i8.\n+            m_len == v_len || (m_len == 8 && v_len < 8),\n             \"mismatched lengths: mask length `{}` != other vector length `{}`\",\n             m_len,\n             v_len\n         );\n         let i1 = bx.type_i1();\n-        let i1xn = bx.type_vector(i1, m_len);\n-        let m_i1s = bx.bitcast(args[0].immediate(), i1xn);\n+        let im = bx.type_ix(v_len);\n+        let i1xn = bx.type_vector(i1, v_len);\n+        let m_im = bx.trunc(args[0].immediate(), im);\n+        let m_i1s = bx.bitcast(m_im, i1xn);\n         return Ok(bx.select(m_i1s, args[1].immediate(), args[2].immediate()));\n     }\n "}, {"sha": "d42020047fddd44f4cf776a3f4e003c3877727e8", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 1, "deletions": 149, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "patch": "@@ -1,12 +1,12 @@\n use crate::back::write::create_informational_target_machine;\n use crate::llvm;\n use libc::c_int;\n+use rustc_codegen_ssa::target_features::supported_target_features;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_feature::UnstableFeatures;\n use rustc_middle::bug;\n use rustc_session::config::PrintRequest;\n use rustc_session::Session;\n-use rustc_span::symbol::sym;\n use rustc_span::symbol::Symbol;\n use rustc_target::spec::{MergeFunctions, PanicStrategy};\n use std::ffi::CString;\n@@ -139,140 +139,6 @@ pub fn time_trace_profiler_finish(file_name: &str) {\n // WARNING: the features after applying `to_llvm_feature` must be known\n // to LLVM or the feature detection code will walk past the end of the feature\n // array, leading to crashes.\n-\n-const ARM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n-    (\"aclass\", Some(sym::arm_target_feature)),\n-    (\"mclass\", Some(sym::arm_target_feature)),\n-    (\"rclass\", Some(sym::arm_target_feature)),\n-    (\"dsp\", Some(sym::arm_target_feature)),\n-    (\"neon\", Some(sym::arm_target_feature)),\n-    (\"crc\", Some(sym::arm_target_feature)),\n-    (\"crypto\", Some(sym::arm_target_feature)),\n-    (\"v5te\", Some(sym::arm_target_feature)),\n-    (\"v6\", Some(sym::arm_target_feature)),\n-    (\"v6k\", Some(sym::arm_target_feature)),\n-    (\"v6t2\", Some(sym::arm_target_feature)),\n-    (\"v7\", Some(sym::arm_target_feature)),\n-    (\"v8\", Some(sym::arm_target_feature)),\n-    (\"vfp2\", Some(sym::arm_target_feature)),\n-    (\"vfp3\", Some(sym::arm_target_feature)),\n-    (\"vfp4\", Some(sym::arm_target_feature)),\n-    // This is needed for inline assembly, but shouldn't be stabilized as-is\n-    // since it should be enabled per-function using #[instruction_set], not\n-    // #[target_feature].\n-    (\"thumb-mode\", Some(sym::arm_target_feature)),\n-];\n-\n-const AARCH64_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n-    (\"fp\", Some(sym::aarch64_target_feature)),\n-    (\"neon\", Some(sym::aarch64_target_feature)),\n-    (\"sve\", Some(sym::aarch64_target_feature)),\n-    (\"crc\", Some(sym::aarch64_target_feature)),\n-    (\"crypto\", Some(sym::aarch64_target_feature)),\n-    (\"ras\", Some(sym::aarch64_target_feature)),\n-    (\"lse\", Some(sym::aarch64_target_feature)),\n-    (\"rdm\", Some(sym::aarch64_target_feature)),\n-    (\"fp16\", Some(sym::aarch64_target_feature)),\n-    (\"rcpc\", Some(sym::aarch64_target_feature)),\n-    (\"dotprod\", Some(sym::aarch64_target_feature)),\n-    (\"tme\", Some(sym::aarch64_target_feature)),\n-    (\"v8.1a\", Some(sym::aarch64_target_feature)),\n-    (\"v8.2a\", Some(sym::aarch64_target_feature)),\n-    (\"v8.3a\", Some(sym::aarch64_target_feature)),\n-];\n-\n-const X86_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n-    (\"adx\", Some(sym::adx_target_feature)),\n-    (\"aes\", None),\n-    (\"avx\", None),\n-    (\"avx2\", None),\n-    (\"avx512bw\", Some(sym::avx512_target_feature)),\n-    (\"avx512cd\", Some(sym::avx512_target_feature)),\n-    (\"avx512dq\", Some(sym::avx512_target_feature)),\n-    (\"avx512er\", Some(sym::avx512_target_feature)),\n-    (\"avx512f\", Some(sym::avx512_target_feature)),\n-    (\"avx512ifma\", Some(sym::avx512_target_feature)),\n-    (\"avx512pf\", Some(sym::avx512_target_feature)),\n-    (\"avx512vbmi\", Some(sym::avx512_target_feature)),\n-    (\"avx512vl\", Some(sym::avx512_target_feature)),\n-    (\"avx512vpopcntdq\", Some(sym::avx512_target_feature)),\n-    (\"bmi1\", None),\n-    (\"bmi2\", None),\n-    (\"cmpxchg16b\", Some(sym::cmpxchg16b_target_feature)),\n-    (\"f16c\", Some(sym::f16c_target_feature)),\n-    (\"fma\", None),\n-    (\"fxsr\", None),\n-    (\"lzcnt\", None),\n-    (\"movbe\", Some(sym::movbe_target_feature)),\n-    (\"pclmulqdq\", None),\n-    (\"popcnt\", None),\n-    (\"rdrand\", None),\n-    (\"rdseed\", None),\n-    (\"rtm\", Some(sym::rtm_target_feature)),\n-    (\"sha\", None),\n-    (\"sse\", None),\n-    (\"sse2\", None),\n-    (\"sse3\", None),\n-    (\"sse4.1\", None),\n-    (\"sse4.2\", None),\n-    (\"sse4a\", Some(sym::sse4a_target_feature)),\n-    (\"ssse3\", None),\n-    (\"tbm\", Some(sym::tbm_target_feature)),\n-    (\"xsave\", None),\n-    (\"xsavec\", None),\n-    (\"xsaveopt\", None),\n-    (\"xsaves\", None),\n-];\n-\n-const HEXAGON_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n-    (\"hvx\", Some(sym::hexagon_target_feature)),\n-    (\"hvx-length128b\", Some(sym::hexagon_target_feature)),\n-];\n-\n-const POWERPC_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n-    (\"altivec\", Some(sym::powerpc_target_feature)),\n-    (\"power8-altivec\", Some(sym::powerpc_target_feature)),\n-    (\"power9-altivec\", Some(sym::powerpc_target_feature)),\n-    (\"power8-vector\", Some(sym::powerpc_target_feature)),\n-    (\"power9-vector\", Some(sym::powerpc_target_feature)),\n-    (\"vsx\", Some(sym::powerpc_target_feature)),\n-];\n-\n-const MIPS_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] =\n-    &[(\"fp64\", Some(sym::mips_target_feature)), (\"msa\", Some(sym::mips_target_feature))];\n-\n-const RISCV_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n-    (\"m\", Some(sym::riscv_target_feature)),\n-    (\"a\", Some(sym::riscv_target_feature)),\n-    (\"c\", Some(sym::riscv_target_feature)),\n-    (\"f\", Some(sym::riscv_target_feature)),\n-    (\"d\", Some(sym::riscv_target_feature)),\n-    (\"e\", Some(sym::riscv_target_feature)),\n-];\n-\n-const WASM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n-    (\"simd128\", Some(sym::wasm_target_feature)),\n-    (\"atomics\", Some(sym::wasm_target_feature)),\n-    (\"nontrapping-fptoint\", Some(sym::wasm_target_feature)),\n-];\n-\n-/// When rustdoc is running, provide a list of all known features so that all their respective\n-/// primitives may be documented.\n-///\n-/// IMPORTANT: If you're adding another feature list above, make sure to add it to this iterator!\n-pub fn all_known_features() -> impl Iterator<Item = (&'static str, Option<Symbol>)> {\n-    std::iter::empty()\n-        .chain(ARM_ALLOWED_FEATURES.iter())\n-        .chain(AARCH64_ALLOWED_FEATURES.iter())\n-        .chain(X86_ALLOWED_FEATURES.iter())\n-        .chain(HEXAGON_ALLOWED_FEATURES.iter())\n-        .chain(POWERPC_ALLOWED_FEATURES.iter())\n-        .chain(MIPS_ALLOWED_FEATURES.iter())\n-        .chain(RISCV_ALLOWED_FEATURES.iter())\n-        .chain(WASM_ALLOWED_FEATURES.iter())\n-        .cloned()\n-}\n-\n pub fn to_llvm_feature<'a>(sess: &Session, s: &'a str) -> &'a str {\n     let arch = if sess.target.target.arch == \"x86_64\" { \"x86\" } else { &*sess.target.target.arch };\n     match (arch, s) {\n@@ -306,20 +172,6 @@ pub fn target_features(sess: &Session) -> Vec<Symbol> {\n         .collect()\n }\n \n-pub fn supported_target_features(sess: &Session) -> &'static [(&'static str, Option<Symbol>)] {\n-    match &*sess.target.target.arch {\n-        \"arm\" => ARM_ALLOWED_FEATURES,\n-        \"aarch64\" => AARCH64_ALLOWED_FEATURES,\n-        \"x86\" | \"x86_64\" => X86_ALLOWED_FEATURES,\n-        \"hexagon\" => HEXAGON_ALLOWED_FEATURES,\n-        \"mips\" | \"mips64\" => MIPS_ALLOWED_FEATURES,\n-        \"powerpc\" | \"powerpc64\" => POWERPC_ALLOWED_FEATURES,\n-        \"riscv32\" | \"riscv64\" => RISCV_ALLOWED_FEATURES,\n-        \"wasm32\" => WASM_ALLOWED_FEATURES,\n-        _ => &[],\n-    }\n-}\n-\n pub fn print_version() {\n     // Can be called without initializing LLVM\n     unsafe {"}, {"sha": "e34371ef59ac4b45987f9ef39bf5a28e0d7ca260", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "patch": "@@ -42,6 +42,7 @@ pub mod glue;\n pub mod meth;\n pub mod mir;\n pub mod mono_item;\n+pub mod target_features;\n pub mod traits;\n \n pub struct ModuleCodegen<M> {"}, {"sha": "4c61e21901bcd1064798c3dba182066d460b46cb", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "patch": "@@ -0,0 +1,150 @@\n+use rustc_session::Session;\n+use rustc_span::symbol::sym;\n+use rustc_span::symbol::Symbol;\n+\n+const ARM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n+    (\"aclass\", Some(sym::arm_target_feature)),\n+    (\"mclass\", Some(sym::arm_target_feature)),\n+    (\"rclass\", Some(sym::arm_target_feature)),\n+    (\"dsp\", Some(sym::arm_target_feature)),\n+    (\"neon\", Some(sym::arm_target_feature)),\n+    (\"crc\", Some(sym::arm_target_feature)),\n+    (\"crypto\", Some(sym::arm_target_feature)),\n+    (\"v5te\", Some(sym::arm_target_feature)),\n+    (\"v6\", Some(sym::arm_target_feature)),\n+    (\"v6k\", Some(sym::arm_target_feature)),\n+    (\"v6t2\", Some(sym::arm_target_feature)),\n+    (\"v7\", Some(sym::arm_target_feature)),\n+    (\"v8\", Some(sym::arm_target_feature)),\n+    (\"vfp2\", Some(sym::arm_target_feature)),\n+    (\"vfp3\", Some(sym::arm_target_feature)),\n+    (\"vfp4\", Some(sym::arm_target_feature)),\n+    // This is needed for inline assembly, but shouldn't be stabilized as-is\n+    // since it should be enabled per-function using #[instruction_set], not\n+    // #[target_feature].\n+    (\"thumb-mode\", Some(sym::arm_target_feature)),\n+];\n+\n+const AARCH64_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n+    (\"fp\", Some(sym::aarch64_target_feature)),\n+    (\"neon\", Some(sym::aarch64_target_feature)),\n+    (\"sve\", Some(sym::aarch64_target_feature)),\n+    (\"crc\", Some(sym::aarch64_target_feature)),\n+    (\"crypto\", Some(sym::aarch64_target_feature)),\n+    (\"ras\", Some(sym::aarch64_target_feature)),\n+    (\"lse\", Some(sym::aarch64_target_feature)),\n+    (\"rdm\", Some(sym::aarch64_target_feature)),\n+    (\"fp16\", Some(sym::aarch64_target_feature)),\n+    (\"rcpc\", Some(sym::aarch64_target_feature)),\n+    (\"dotprod\", Some(sym::aarch64_target_feature)),\n+    (\"tme\", Some(sym::aarch64_target_feature)),\n+    (\"v8.1a\", Some(sym::aarch64_target_feature)),\n+    (\"v8.2a\", Some(sym::aarch64_target_feature)),\n+    (\"v8.3a\", Some(sym::aarch64_target_feature)),\n+];\n+\n+const X86_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n+    (\"adx\", Some(sym::adx_target_feature)),\n+    (\"aes\", None),\n+    (\"avx\", None),\n+    (\"avx2\", None),\n+    (\"avx512bw\", Some(sym::avx512_target_feature)),\n+    (\"avx512cd\", Some(sym::avx512_target_feature)),\n+    (\"avx512dq\", Some(sym::avx512_target_feature)),\n+    (\"avx512er\", Some(sym::avx512_target_feature)),\n+    (\"avx512f\", Some(sym::avx512_target_feature)),\n+    (\"avx512ifma\", Some(sym::avx512_target_feature)),\n+    (\"avx512pf\", Some(sym::avx512_target_feature)),\n+    (\"avx512vbmi\", Some(sym::avx512_target_feature)),\n+    (\"avx512vl\", Some(sym::avx512_target_feature)),\n+    (\"avx512vpopcntdq\", Some(sym::avx512_target_feature)),\n+    (\"bmi1\", None),\n+    (\"bmi2\", None),\n+    (\"cmpxchg16b\", Some(sym::cmpxchg16b_target_feature)),\n+    (\"f16c\", Some(sym::f16c_target_feature)),\n+    (\"fma\", None),\n+    (\"fxsr\", None),\n+    (\"lzcnt\", None),\n+    (\"movbe\", Some(sym::movbe_target_feature)),\n+    (\"pclmulqdq\", None),\n+    (\"popcnt\", None),\n+    (\"rdrand\", None),\n+    (\"rdseed\", None),\n+    (\"rtm\", Some(sym::rtm_target_feature)),\n+    (\"sha\", None),\n+    (\"sse\", None),\n+    (\"sse2\", None),\n+    (\"sse3\", None),\n+    (\"sse4.1\", None),\n+    (\"sse4.2\", None),\n+    (\"sse4a\", Some(sym::sse4a_target_feature)),\n+    (\"ssse3\", None),\n+    (\"tbm\", Some(sym::tbm_target_feature)),\n+    (\"xsave\", None),\n+    (\"xsavec\", None),\n+    (\"xsaveopt\", None),\n+    (\"xsaves\", None),\n+];\n+\n+const HEXAGON_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n+    (\"hvx\", Some(sym::hexagon_target_feature)),\n+    (\"hvx-length128b\", Some(sym::hexagon_target_feature)),\n+];\n+\n+const POWERPC_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n+    (\"altivec\", Some(sym::powerpc_target_feature)),\n+    (\"power8-altivec\", Some(sym::powerpc_target_feature)),\n+    (\"power9-altivec\", Some(sym::powerpc_target_feature)),\n+    (\"power8-vector\", Some(sym::powerpc_target_feature)),\n+    (\"power9-vector\", Some(sym::powerpc_target_feature)),\n+    (\"vsx\", Some(sym::powerpc_target_feature)),\n+];\n+\n+const MIPS_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] =\n+    &[(\"fp64\", Some(sym::mips_target_feature)), (\"msa\", Some(sym::mips_target_feature))];\n+\n+const RISCV_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n+    (\"m\", Some(sym::riscv_target_feature)),\n+    (\"a\", Some(sym::riscv_target_feature)),\n+    (\"c\", Some(sym::riscv_target_feature)),\n+    (\"f\", Some(sym::riscv_target_feature)),\n+    (\"d\", Some(sym::riscv_target_feature)),\n+    (\"e\", Some(sym::riscv_target_feature)),\n+];\n+\n+const WASM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n+    (\"simd128\", Some(sym::wasm_target_feature)),\n+    (\"atomics\", Some(sym::wasm_target_feature)),\n+    (\"nontrapping-fptoint\", Some(sym::wasm_target_feature)),\n+];\n+\n+/// When rustdoc is running, provide a list of all known features so that all their respective\n+/// primitives may be documented.\n+///\n+/// IMPORTANT: If you're adding another feature list above, make sure to add it to this iterator!\n+pub fn all_known_features() -> impl Iterator<Item = (&'static str, Option<Symbol>)> {\n+    std::iter::empty()\n+        .chain(ARM_ALLOWED_FEATURES.iter())\n+        .chain(AARCH64_ALLOWED_FEATURES.iter())\n+        .chain(X86_ALLOWED_FEATURES.iter())\n+        .chain(HEXAGON_ALLOWED_FEATURES.iter())\n+        .chain(POWERPC_ALLOWED_FEATURES.iter())\n+        .chain(MIPS_ALLOWED_FEATURES.iter())\n+        .chain(RISCV_ALLOWED_FEATURES.iter())\n+        .chain(WASM_ALLOWED_FEATURES.iter())\n+        .cloned()\n+}\n+\n+pub fn supported_target_features(sess: &Session) -> &'static [(&'static str, Option<Symbol>)] {\n+    match &*sess.target.target.arch {\n+        \"arm\" => ARM_ALLOWED_FEATURES,\n+        \"aarch64\" => AARCH64_ALLOWED_FEATURES,\n+        \"x86\" | \"x86_64\" => X86_ALLOWED_FEATURES,\n+        \"hexagon\" => HEXAGON_ALLOWED_FEATURES,\n+        \"mips\" | \"mips64\" => MIPS_ALLOWED_FEATURES,\n+        \"powerpc\" | \"powerpc64\" => POWERPC_ALLOWED_FEATURES,\n+        \"riscv32\" | \"riscv64\" => RISCV_ALLOWED_FEATURES,\n+        \"wasm32\" => WASM_ALLOWED_FEATURES,\n+        _ => &[],\n+    }\n+}"}, {"sha": "3673b6a4aa223c2e5e9c0b9dd139c3133aed904e", "filename": "compiler/rustc_mir/src/transform/nrvo.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fnrvo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fnrvo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fnrvo.rs?ref=a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "patch": "@@ -36,12 +36,6 @@ impl<'tcx> MirPass<'tcx> for RenameReturnPlace {\n             return;\n         }\n \n-        if tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n-            // The `DestinationPropagation` pass runs at level 2, so this pass is redundant (and\n-            // fails some asserts).\n-            return;\n-        }\n-\n         let returned_local = match local_eligible_for_nrvo(body) {\n             Some(l) => l,\n             None => {"}, {"sha": "118e173bb16dbca66adff1f865b1dd0fff0ac0c9", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "patch": "@@ -1,12 +1,10 @@\n+use super::super::{navigate::Position, node, DeterministicRng};\n+use super::Entry::{Occupied, Vacant};\n+use super::*;\n use crate::boxed::Box;\n-use crate::collections::btree::navigate::Position;\n-use crate::collections::btree::node;\n-use crate::collections::btree_map::Entry::{Occupied, Vacant};\n-use crate::collections::BTreeMap;\n use crate::fmt::Debug;\n use crate::rc::Rc;\n-use crate::string::String;\n-use crate::string::ToString;\n+use crate::string::{String, ToString};\n use crate::vec::Vec;\n use std::convert::TryFrom;\n use std::iter::FromIterator;\n@@ -16,19 +14,17 @@ use std::ops::RangeBounds;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n-use super::super::DeterministicRng;\n-\n // Capacity of a tree with a single level,\n-// i.e. a tree who's root is a leaf node at height 0.\n+// i.e., a tree who's root is a leaf node at height 0.\n const NODE_CAPACITY: usize = node::CAPACITY;\n \n // Minimum number of elements to insert, to guarantee a tree with 2 levels,\n-// i.e. a tree who's root is an internal node at height 1, with edges to leaf nodes.\n+// i.e., a tree who's root is an internal node at height 1, with edges to leaf nodes.\n // It's not the minimum size: removing an element from such a tree does not always reduce height.\n const MIN_INSERTS_HEIGHT_1: usize = NODE_CAPACITY + 1;\n \n // Minimum number of elements to insert in ascending order, to guarantee a tree with 3 levels,\n-// i.e. a tree who's root is an internal node at height 2, with edges to more internal nodes.\n+// i.e., a tree who's root is an internal node at height 2, with edges to more internal nodes.\n // It's not the minimum size: removing an element from such a tree does not always reduce height.\n const MIN_INSERTS_HEIGHT_2: usize = 89;\n \n@@ -1386,44 +1382,65 @@ fn test_clone_from() {\n     }\n }\n \n-#[test]\n #[allow(dead_code)]\n fn test_variance() {\n-    use std::collections::btree_map::{IntoIter, Iter, Keys, Range, Values};\n-\n     fn map_key<'new>(v: BTreeMap<&'static str, ()>) -> BTreeMap<&'new str, ()> {\n         v\n     }\n     fn map_val<'new>(v: BTreeMap<(), &'static str>) -> BTreeMap<(), &'new str> {\n         v\n     }\n+\n     fn iter_key<'a, 'new>(v: Iter<'a, &'static str, ()>) -> Iter<'a, &'new str, ()> {\n         v\n     }\n     fn iter_val<'a, 'new>(v: Iter<'a, (), &'static str>) -> Iter<'a, (), &'new str> {\n         v\n     }\n+\n     fn into_iter_key<'new>(v: IntoIter<&'static str, ()>) -> IntoIter<&'new str, ()> {\n         v\n     }\n     fn into_iter_val<'new>(v: IntoIter<(), &'static str>) -> IntoIter<(), &'new str> {\n         v\n     }\n+\n+    fn into_keys_key<'new>(v: IntoKeys<&'static str, ()>) -> IntoKeys<&'new str, ()> {\n+        v\n+    }\n+    fn into_keys_val<'new>(v: IntoKeys<(), &'static str>) -> IntoKeys<(), &'new str> {\n+        v\n+    }\n+\n+    fn into_values_key<'new>(v: IntoValues<&'static str, ()>) -> IntoValues<&'new str, ()> {\n+        v\n+    }\n+    fn into_values_val<'new>(v: IntoValues<(), &'static str>) -> IntoValues<(), &'new str> {\n+        v\n+    }\n+\n     fn range_key<'a, 'new>(v: Range<'a, &'static str, ()>) -> Range<'a, &'new str, ()> {\n         v\n     }\n     fn range_val<'a, 'new>(v: Range<'a, (), &'static str>) -> Range<'a, (), &'new str> {\n         v\n     }\n-    fn keys<'a, 'new>(v: Keys<'a, &'static str, ()>) -> Keys<'a, &'new str, ()> {\n+\n+    fn keys_key<'a, 'new>(v: Keys<'a, &'static str, ()>) -> Keys<'a, &'new str, ()> {\n+        v\n+    }\n+    fn keys_val<'a, 'new>(v: Keys<'a, (), &'static str>) -> Keys<'a, (), &'new str> {\n+        v\n+    }\n+\n+    fn values_key<'a, 'new>(v: Values<'a, &'static str, ()>) -> Values<'a, &'new str, ()> {\n         v\n     }\n-    fn vals<'a, 'new>(v: Values<'a, (), &'static str>) -> Values<'a, (), &'new str> {\n+    fn values_val<'a, 'new>(v: Values<'a, (), &'static str>) -> Values<'a, (), &'new str> {\n         v\n     }\n }\n \n-#[test]\n #[allow(dead_code)]\n fn test_sync() {\n     fn map<T: Sync>(v: &BTreeMap<T, T>) -> impl Sync + '_ {\n@@ -1493,7 +1510,6 @@ fn test_sync() {\n     }\n }\n \n-#[test]\n #[allow(dead_code)]\n fn test_send() {\n     fn map<T: Send>(v: BTreeMap<T, T>) -> impl Send {\n@@ -1520,7 +1536,7 @@ fn test_send() {\n         v.iter()\n     }\n \n-    fn iter_mut<T: Send + Sync>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n+    fn iter_mut<T: Send>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n         v.iter_mut()\n     }\n \n@@ -1532,15 +1548,15 @@ fn test_send() {\n         v.values()\n     }\n \n-    fn values_mut<T: Send + Sync>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n+    fn values_mut<T: Send>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n         v.values_mut()\n     }\n \n     fn range<T: Send + Sync + Ord>(v: &BTreeMap<T, T>) -> impl Send + '_ {\n         v.range(..)\n     }\n \n-    fn range_mut<T: Send + Sync + Ord>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n+    fn range_mut<T: Send + Ord>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n         v.range_mut(..)\n     }\n "}, {"sha": "926743572821673bc839b9a43444ffe08dc93ecc", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 81, "deletions": 6, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "patch": "@@ -1,11 +1,10 @@\n-use crate::collections::BTreeSet;\n+use super::super::DeterministicRng;\n+use super::*;\n use crate::vec::Vec;\n use std::iter::FromIterator;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::sync::atomic::{AtomicU32, Ordering};\n \n-use super::super::DeterministicRng;\n-\n #[test]\n fn test_clone_eq() {\n     let mut m = BTreeSet::new();\n@@ -528,11 +527,8 @@ fn test_recovery() {\n     assert_eq!(s.iter().next(), None);\n }\n \n-#[test]\n #[allow(dead_code)]\n fn test_variance() {\n-    use std::collections::btree_set::{IntoIter, Iter, Range};\n-\n     fn set<'new>(v: BTreeSet<&'static str>) -> BTreeSet<&'new str> {\n         v\n     }\n@@ -545,6 +541,85 @@ fn test_variance() {\n     fn range<'a, 'new>(v: Range<'a, &'static str>) -> Range<'a, &'new str> {\n         v\n     }\n+    // not applied to Difference, Intersection, SymmetricDifference, Union\n+}\n+\n+#[allow(dead_code)]\n+fn test_sync() {\n+    fn set<T: Sync>(v: &BTreeSet<T>) -> impl Sync + '_ {\n+        v\n+    }\n+\n+    fn iter<T: Sync>(v: &BTreeSet<T>) -> impl Sync + '_ {\n+        v.iter()\n+    }\n+\n+    fn into_iter<T: Sync>(v: BTreeSet<T>) -> impl Sync {\n+        v.into_iter()\n+    }\n+\n+    fn range<T: Sync + Ord>(v: &BTreeSet<T>) -> impl Sync + '_ {\n+        v.range(..)\n+    }\n+\n+    fn drain_filter<T: Sync + Ord>(v: &mut BTreeSet<T>) -> impl Sync + '_ {\n+        v.drain_filter(|_| false)\n+    }\n+\n+    fn difference<T: Sync + Ord>(v: &BTreeSet<T>) -> impl Sync + '_ {\n+        v.difference(&v)\n+    }\n+\n+    fn intersection<T: Sync + Ord>(v: &BTreeSet<T>) -> impl Sync + '_ {\n+        v.intersection(&v)\n+    }\n+\n+    fn symmetric_difference<T: Sync + Ord>(v: &BTreeSet<T>) -> impl Sync + '_ {\n+        v.symmetric_difference(&v)\n+    }\n+\n+    fn union<T: Sync + Ord>(v: &BTreeSet<T>) -> impl Sync + '_ {\n+        v.union(&v)\n+    }\n+}\n+\n+#[allow(dead_code)]\n+fn test_send() {\n+    fn set<T: Send>(v: BTreeSet<T>) -> impl Send {\n+        v\n+    }\n+\n+    fn iter<T: Send + Sync>(v: &BTreeSet<T>) -> impl Send + '_ {\n+        v.iter()\n+    }\n+\n+    fn into_iter<T: Send>(v: BTreeSet<T>) -> impl Send {\n+        v.into_iter()\n+    }\n+\n+    fn range<T: Send + Sync + Ord>(v: &BTreeSet<T>) -> impl Send + '_ {\n+        v.range(..)\n+    }\n+\n+    fn drain_filter<T: Send + Ord>(v: &mut BTreeSet<T>) -> impl Send + '_ {\n+        v.drain_filter(|_| false)\n+    }\n+\n+    fn difference<T: Send + Sync + Ord>(v: &BTreeSet<T>) -> impl Send + '_ {\n+        v.difference(&v)\n+    }\n+\n+    fn intersection<T: Send + Sync + Ord>(v: &BTreeSet<T>) -> impl Send + '_ {\n+        v.intersection(&v)\n+    }\n+\n+    fn symmetric_difference<T: Send + Sync + Ord>(v: &BTreeSet<T>) -> impl Send + '_ {\n+        v.symmetric_difference(&v)\n+    }\n+\n+    fn union<T: Send + Sync + Ord>(v: &BTreeSet<T>) -> impl Send + '_ {\n+        v.union(&v)\n+    }\n }\n \n #[test]"}, {"sha": "114707b639bcede67c771a69857307540f2a4726", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "patch": "@@ -554,8 +554,8 @@ impl<K, V, S> HashMap<K, V, S> {\n     /// a.clear();\n     /// assert!(a.is_empty());\n     /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n         self.base.clear();\n     }\n@@ -746,8 +746,8 @@ where\n     /// assert_eq!(map.get_key_value(&1), Some((&1, &\"a\")));\n     /// assert_eq!(map.get_key_value(&2), None);\n     /// ```\n-    #[stable(feature = \"map_get_key_value\", since = \"1.40.0\")]\n     #[inline]\n+    #[stable(feature = \"map_get_key_value\", since = \"1.40.0\")]\n     pub fn get_key_value<Q: ?Sized>(&self, k: &Q) -> Option<(&K, &V)>\n     where\n         K: Borrow<Q>,\n@@ -772,8 +772,8 @@ where\n     /// assert_eq!(map.contains_key(&1), true);\n     /// assert_eq!(map.contains_key(&2), false);\n     /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n     where\n         K: Borrow<Q>,\n@@ -800,8 +800,8 @@ where\n     /// }\n     /// assert_eq!(map[&1], \"b\");\n     /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n     where\n         K: Borrow<Q>,\n@@ -834,8 +834,8 @@ where\n     /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n     /// assert_eq!(map[&37], \"c\");\n     /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n         self.base.insert(k, v)\n     }\n@@ -857,8 +857,8 @@ where\n     /// assert_eq!(map.remove(&1), Some(\"a\"));\n     /// assert_eq!(map.remove(&1), None);\n     /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n     where\n         K: Borrow<Q>,\n@@ -886,8 +886,8 @@ where\n     /// assert_eq!(map.remove(&1), None);\n     /// # }\n     /// ```\n-    #[stable(feature = \"hash_map_remove_entry\", since = \"1.27.0\")]\n     #[inline]\n+    #[stable(feature = \"hash_map_remove_entry\", since = \"1.27.0\")]\n     pub fn remove_entry<Q: ?Sized>(&mut self, k: &Q) -> Option<(K, V)>\n     where\n         K: Borrow<Q>,\n@@ -909,8 +909,8 @@ where\n     /// map.retain(|&k, _| k % 2 == 0);\n     /// assert_eq!(map.len(), 4);\n     /// ```\n-    #[stable(feature = \"retain_hash_collection\", since = \"1.18.0\")]\n     #[inline]\n+    #[stable(feature = \"retain_hash_collection\", since = \"1.18.0\")]\n     pub fn retain<F>(&mut self, f: F)\n     where\n         F: FnMut(&K, &mut V) -> bool,\n@@ -1647,7 +1647,7 @@ impl<'a, K, V, S> RawOccupiedEntryMut<'a, K, V, S> {\n         self.base.get()\n     }\n \n-    /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n+    /// Converts the `OccupiedEntry` into a mutable reference to the value in the entry\n     /// with a lifetime bound to the map itself.\n     #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n@@ -1676,7 +1676,7 @@ impl<'a, K, V, S> RawOccupiedEntryMut<'a, K, V, S> {\n         self.base.get_key_value_mut()\n     }\n \n-    /// Converts the OccupiedEntry into a mutable reference to the key and value in the entry\n+    /// Converts the `OccupiedEntry` into a mutable reference to the key and value in the entry\n     /// with a lifetime bound to the map itself.\n     #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n@@ -1714,7 +1714,7 @@ impl<'a, K, V, S> RawOccupiedEntryMut<'a, K, V, S> {\n }\n \n impl<'a, K, V, S> RawVacantEntryMut<'a, K, V, S> {\n-    /// Sets the value of the entry with the VacantEntry's key,\n+    /// Sets the value of the entry with the `VacantEntry`'s key,\n     /// and returns a mutable reference to it.\n     #[inline]\n     #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n@@ -2173,7 +2173,6 @@ where\n }\n \n impl<'a, K, V> Entry<'a, K, V> {\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Ensures a value is in the entry by inserting the default if empty, and returns\n     /// a mutable reference to the value in the entry.\n     ///\n@@ -2191,14 +2190,14 @@ impl<'a, K, V> Entry<'a, K, V> {\n     /// assert_eq!(map[\"poneyland\"], 6);\n     /// ```\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn or_insert(self, default: V) -> &'a mut V {\n         match self {\n             Occupied(entry) => entry.into_mut(),\n             Vacant(entry) => entry.insert(default),\n         }\n     }\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Ensures a value is in the entry by inserting the result of the default function if empty,\n     /// and returns a mutable reference to the value in the entry.\n     ///\n@@ -2215,14 +2214,14 @@ impl<'a, K, V> Entry<'a, K, V> {\n     /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n     /// ```\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n         match self {\n             Occupied(entry) => entry.into_mut(),\n             Vacant(entry) => entry.insert(default()),\n         }\n     }\n \n-    #[unstable(feature = \"or_insert_with_key\", issue = \"71024\")]\n     /// Ensures a value is in the entry by inserting, if empty, the result of the default function,\n     /// which takes the key as its argument, and returns a mutable reference to the value in the\n     /// entry.\n@@ -2240,6 +2239,7 @@ impl<'a, K, V> Entry<'a, K, V> {\n     /// assert_eq!(map[\"poneyland\"], 9);\n     /// ```\n     #[inline]\n+    #[unstable(feature = \"or_insert_with_key\", issue = \"71024\")]\n     pub fn or_insert_with_key<F: FnOnce(&K) -> V>(self, default: F) -> &'a mut V {\n         match self {\n             Occupied(entry) => entry.into_mut(),\n@@ -2304,7 +2304,7 @@ impl<'a, K, V> Entry<'a, K, V> {\n         }\n     }\n \n-    /// Sets the value of the entry, and returns an OccupiedEntry.\n+    /// Sets the value of the entry, and returns an `OccupiedEntry`.\n     ///\n     /// # Examples\n     ///\n@@ -2331,7 +2331,6 @@ impl<'a, K, V> Entry<'a, K, V> {\n }\n \n impl<'a, K, V: Default> Entry<'a, K, V> {\n-    #[stable(feature = \"entry_or_default\", since = \"1.28.0\")]\n     /// Ensures a value is in the entry by inserting the default value if empty,\n     /// and returns a mutable reference to the value in the entry.\n     ///\n@@ -2348,6 +2347,7 @@ impl<'a, K, V: Default> Entry<'a, K, V> {\n     /// # }\n     /// ```\n     #[inline]\n+    #[stable(feature = \"entry_or_default\", since = \"1.28.0\")]\n     pub fn or_default(self) -> &'a mut V {\n         match self {\n             Occupied(entry) => entry.into_mut(),\n@@ -2452,7 +2452,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n         self.base.get_mut()\n     }\n \n-    /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n+    /// Converts the `OccupiedEntry` into a mutable reference to the value in the entry\n     /// with a lifetime bound to the map itself.\n     ///\n     /// If you need multiple references to the `OccupiedEntry`, see [`get_mut`].\n@@ -2624,7 +2624,7 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n         self.base.into_key()\n     }\n \n-    /// Sets the value of the entry with the VacantEntry's key,\n+    /// Sets the value of the entry with the `VacantEntry`'s key,\n     /// and returns a mutable reference to it.\n     ///\n     /// # Examples\n@@ -2646,8 +2646,8 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n         self.base.insert(value)\n     }\n \n-    /// Sets the value of the entry with the VacantEntry's key,\n-    /// and returns an OccupiedEntry.\n+    /// Sets the value of the entry with the `VacantEntry`'s key,\n+    /// and returns an `OccupiedEntry`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "d70446d2574980a51073cc51179d7c6738403b0a", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 24, "deletions": 36, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "patch": "@@ -370,32 +370,22 @@ impl<I: IntoIterator<Item = ast::NestedMetaItem>> NestedAttributesExt for I {\n /// information can be given when a doctest fails. Sugared doc comments and \"raw\" doc comments are\n /// kept separate because of issue #42760.\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum DocFragment {\n+pub struct DocFragment {\n+    pub line: usize,\n+    pub span: rustc_span::Span,\n+    pub doc: String,\n+    pub kind: DocFragmentKind,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum DocFragmentKind {\n     /// A doc fragment created from a `///` or `//!` doc comment.\n-    SugaredDoc(usize, rustc_span::Span, String),\n+    SugaredDoc,\n     /// A doc fragment created from a \"raw\" `#[doc=\"\"]` attribute.\n-    RawDoc(usize, rustc_span::Span, String),\n+    RawDoc,\n     /// A doc fragment created from a `#[doc(include=\"filename\")]` attribute. Contains both the\n     /// given filename and the file contents.\n-    Include(usize, rustc_span::Span, String, String),\n-}\n-\n-impl DocFragment {\n-    pub fn as_str(&self) -> &str {\n-        match *self {\n-            DocFragment::SugaredDoc(_, _, ref s) => &s[..],\n-            DocFragment::RawDoc(_, _, ref s) => &s[..],\n-            DocFragment::Include(_, _, _, ref s) => &s[..],\n-        }\n-    }\n-\n-    pub fn span(&self) -> rustc_span::Span {\n-        match *self {\n-            DocFragment::SugaredDoc(_, span, _)\n-            | DocFragment::RawDoc(_, span, _)\n-            | DocFragment::Include(_, span, _, _) => span,\n-        }\n-    }\n+    Include { filename: String },\n }\n \n impl<'a> FromIterator<&'a DocFragment> for String {\n@@ -407,12 +397,7 @@ impl<'a> FromIterator<&'a DocFragment> for String {\n             if !acc.is_empty() {\n                 acc.push('\\n');\n             }\n-            match *frag {\n-                DocFragment::SugaredDoc(_, _, ref docs)\n-                | DocFragment::RawDoc(_, _, ref docs)\n-                | DocFragment::Include(_, _, _, ref docs) => acc.push_str(docs),\n-            }\n-\n+            acc.push_str(&frag.doc);\n             acc\n         })\n     }\n@@ -547,15 +532,15 @@ impl Attributes {\n             .filter_map(|attr| {\n                 if let Some(value) = attr.doc_str() {\n                     let value = beautify_doc_string(value);\n-                    let mk_fragment: fn(_, _, _) -> _ = if attr.is_doc_comment() {\n-                        DocFragment::SugaredDoc\n+                    let kind = if attr.is_doc_comment() {\n+                        DocFragmentKind::SugaredDoc\n                     } else {\n-                        DocFragment::RawDoc\n+                        DocFragmentKind::RawDoc\n                     };\n \n                     let line = doc_line;\n                     doc_line += value.lines().count();\n-                    doc_strings.push(mk_fragment(line, attr.span, value));\n+                    doc_strings.push(DocFragment { line, span: attr.span, doc: value, kind });\n \n                     if sp.is_none() {\n                         sp = Some(attr.span);\n@@ -575,9 +560,12 @@ impl Attributes {\n                             {\n                                 let line = doc_line;\n                                 doc_line += contents.lines().count();\n-                                doc_strings.push(DocFragment::Include(\n-                                    line, attr.span, filename, contents,\n-                                ));\n+                                doc_strings.push(DocFragment {\n+                                    line,\n+                                    span: attr.span,\n+                                    doc: contents,\n+                                    kind: DocFragmentKind::Include { filename },\n+                                });\n                             }\n                         }\n                     }\n@@ -621,7 +609,7 @@ impl Attributes {\n     /// Finds the `doc` attribute as a NameValue and returns the corresponding\n     /// value found.\n     pub fn doc_value(&self) -> Option<&str> {\n-        self.doc_strings.first().map(|s| s.as_str())\n+        self.doc_strings.first().map(|s| s.doc.as_str())\n     }\n \n     /// Finds all `doc` attributes as NameValues and returns their corresponding values, joined"}, {"sha": "3f4bd2886b1b2c985e99dcd36e0707f00d97dc1b", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "patch": "@@ -120,7 +120,7 @@ h3.impl, h3.method, h3.type {\n }\n \n h1, h2, h3, h4,\n-.sidebar, a.source, .search-input, .content table :not(code)>a,\n+.sidebar, a.source, .search-input, .content table td:first-child > a,\n .collapse-toggle, div.item-list .out-of-band,\n #source-sidebar, #sidebar-toggle {\n \tfont-family: \"Fira Sans\", sans-serif;"}, {"sha": "4bca3996eb48f50e96e251df1fd938f7ce08aee1", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "patch": "@@ -232,7 +232,12 @@ impl fold::DocFolder for CoverageCalculator {\n                 let mut tests = Tests { found_tests: 0 };\n \n                 find_testable_code(\n-                    &i.attrs.doc_strings.iter().map(|d| d.as_str()).collect::<Vec<_>>().join(\"\\n\"),\n+                    &i.attrs\n+                        .doc_strings\n+                        .iter()\n+                        .map(|d| d.doc.as_str())\n+                        .collect::<Vec<_>>()\n+                        .join(\"\\n\"),\n                     &mut tests,\n                     ErrorCodes::No,\n                     false,"}, {"sha": "be7250f833f0042f2460f2e01f666828279a3afb", "filename": "src/librustdoc/passes/collapse_docs.rs", "status": "modified", "additions": 12, "deletions": 37, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs?ref=a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "patch": "@@ -1,4 +1,4 @@\n-use crate::clean::{self, DocFragment, Item};\n+use crate::clean::{self, DocFragment, DocFragmentKind, Item};\n use crate::core::DocContext;\n use crate::fold;\n use crate::fold::DocFolder;\n@@ -12,23 +12,6 @@ pub const COLLAPSE_DOCS: Pass = Pass {\n     description: \"concatenates all document attributes into one document attribute\",\n };\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-enum DocFragmentKind {\n-    Sugared,\n-    Raw,\n-    Include,\n-}\n-\n-impl DocFragment {\n-    fn kind(&self) -> DocFragmentKind {\n-        match *self {\n-            DocFragment::SugaredDoc(..) => DocFragmentKind::Sugared,\n-            DocFragment::RawDoc(..) => DocFragmentKind::Raw,\n-            DocFragment::Include(..) => DocFragmentKind::Include,\n-        }\n-    }\n-}\n-\n pub fn collapse_docs(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n     let mut krate = Collapser.fold_crate(krate);\n     krate.collapsed = true;\n@@ -50,30 +33,22 @@ fn collapse(doc_strings: &mut Vec<DocFragment>) {\n \n     for frag in take(doc_strings) {\n         if let Some(mut curr_frag) = last_frag.take() {\n-            let curr_kind = curr_frag.kind();\n-            let new_kind = frag.kind();\n+            let curr_kind = &curr_frag.kind;\n+            let new_kind = &frag.kind;\n \n-            if curr_kind == DocFragmentKind::Include || curr_kind != new_kind {\n-                match curr_frag {\n-                    DocFragment::SugaredDoc(_, _, ref mut doc_string)\n-                    | DocFragment::RawDoc(_, _, ref mut doc_string) => {\n-                        // add a newline for extra padding between segments\n-                        doc_string.push('\\n');\n-                    }\n-                    _ => {}\n+            if matches!(*curr_kind, DocFragmentKind::Include { .. }) || curr_kind != new_kind {\n+                if *curr_kind == DocFragmentKind::SugaredDoc\n+                    || *curr_kind == DocFragmentKind::RawDoc\n+                {\n+                    // add a newline for extra padding between segments\n+                    curr_frag.doc.push('\\n');\n                 }\n                 docs.push(curr_frag);\n                 last_frag = Some(frag);\n             } else {\n-                match curr_frag {\n-                    DocFragment::SugaredDoc(_, ref mut span, ref mut doc_string)\n-                    | DocFragment::RawDoc(_, ref mut span, ref mut doc_string) => {\n-                        doc_string.push('\\n');\n-                        doc_string.push_str(frag.as_str());\n-                        *span = span.to(frag.span());\n-                    }\n-                    _ => unreachable!(),\n-                }\n+                curr_frag.doc.push('\\n');\n+                curr_frag.doc.push_str(&frag.doc);\n+                curr_frag.span = curr_frag.span.to(frag.span);\n                 last_frag = Some(curr_frag);\n             }\n         } else {"}, {"sha": "f8e395bfb41d9aba35b502b3ffe32f4cbf34aec2", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "patch": "@@ -8,7 +8,7 @@ use std::mem;\n use std::ops::Range;\n \n use self::Condition::*;\n-use crate::clean::{self, GetDefId, Item};\n+use crate::clean::{self, DocFragmentKind, GetDefId, Item};\n use crate::core::DocContext;\n use crate::fold::{DocFolder, StripItem};\n \n@@ -314,11 +314,11 @@ crate fn span_of_attrs(attrs: &clean::Attributes) -> Option<Span> {\n     if attrs.doc_strings.is_empty() {\n         return None;\n     }\n-    let start = attrs.doc_strings[0].span();\n+    let start = attrs.doc_strings[0].span;\n     if start == DUMMY_SP {\n         return None;\n     }\n-    let end = attrs.doc_strings.last().expect(\"no doc strings provided\").span();\n+    let end = attrs.doc_strings.last().expect(\"no doc strings provided\").span;\n     Some(start.to(end))\n }\n \n@@ -333,10 +333,8 @@ crate fn source_span_for_markdown_range(\n     md_range: &Range<usize>,\n     attrs: &clean::Attributes,\n ) -> Option<Span> {\n-    let is_all_sugared_doc = attrs.doc_strings.iter().all(|frag| match frag {\n-        clean::DocFragment::SugaredDoc(..) => true,\n-        _ => false,\n-    });\n+    let is_all_sugared_doc =\n+        attrs.doc_strings.iter().all(|frag| frag.kind == DocFragmentKind::SugaredDoc);\n \n     if !is_all_sugared_doc {\n         return None;"}, {"sha": "a9cf5a87f5493671365f49c0b95490f737be4415", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "patch": "@@ -36,13 +36,7 @@ impl clean::Attributes {\n \n fn unindent_fragments(docs: &mut Vec<DocFragment>) {\n     for fragment in docs {\n-        match *fragment {\n-            DocFragment::SugaredDoc(_, _, ref mut doc_string)\n-            | DocFragment::RawDoc(_, _, ref mut doc_string)\n-            | DocFragment::Include(_, _, _, ref mut doc_string) => {\n-                *doc_string = unindent(doc_string)\n-            }\n-        }\n+        fragment.doc = unindent(&fragment.doc);\n     }\n }\n "}, {"sha": "81007b15074f7bb82551347652bf04d886b1e432", "filename": "src/test/ui/issues/issue-69532.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/src%2Ftest%2Fui%2Fissues%2Fissue-69532.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/src%2Ftest%2Fui%2Fissues%2Fissue-69532.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69532.rs?ref=a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "patch": "@@ -0,0 +1,24 @@\n+// run-pass\n+#![feature(const_fn_transmute)]\n+\n+const fn make_nans() -> (f64, f64, f32, f32) {\n+    let nan1: f64 = unsafe { std::mem::transmute(0x7FF0_0001_0000_0001u64) };\n+    let nan2: f64 = unsafe { std::mem::transmute(0x7FF0_0000_0000_0001u64) };\n+\n+    let nan1_32 = nan1 as f32;\n+    let nan2_32 = nan2 as f32;\n+\n+    (nan1, nan2, nan1_32, nan2_32)\n+}\n+\n+static NANS: (f64, f64, f32, f32) = make_nans();\n+\n+fn main() {\n+    let (nan1, nan2, nan1_32, nan2_32) = NANS;\n+\n+    assert!(nan1.is_nan());\n+    assert!(nan2.is_nan());\n+\n+    assert!(nan1_32.is_nan());\n+    assert!(nan2_32.is_nan());\n+}"}, {"sha": "7d68af49e2868a8d76c38be186921451c784d739", "filename": "src/test/ui/simd-intrinsic/simd-intrinsic-generic-select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-select.rs?ref=a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "patch": "@@ -49,8 +49,8 @@ fn main() {\n         simd_select(m4, 0u32, 1u32);\n         //~^ ERROR found non-SIMD `u32`\n \n-        simd_select_bitmask(0u8, x, x);\n-        //~^ ERROR mask length `8` != other vector length `4`\n+        simd_select_bitmask(0u16, x, x);\n+        //~^ ERROR mask length `16` != other vector length `4`\n         //\n         simd_select_bitmask(0u8, 1u32, 2u32);\n         //~^ ERROR found non-SIMD `u32`"}, {"sha": "a1ef0bb8ee03bbef2acb06f6db314ec0837b8891", "filename": "src/test/ui/simd-intrinsic/simd-intrinsic-generic-select.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-select.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-select.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-select.stderr?ref=a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "patch": "@@ -22,11 +22,11 @@ error[E0511]: invalid monomorphization of `simd_select` intrinsic: expected SIMD\n LL |         simd_select(m4, 0u32, 1u32);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: mismatched lengths: mask length `8` != other vector length `4`\n+error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: mismatched lengths: mask length `16` != other vector length `4`\n   --> $DIR/simd-intrinsic-generic-select.rs:52:9\n    |\n-LL |         simd_select_bitmask(0u8, x, x);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         simd_select_bitmask(0u16, x, x);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: expected SIMD argument type, found non-SIMD `u32`\n   --> $DIR/simd-intrinsic-generic-select.rs:55:9"}, {"sha": "b850cf9750a1f665767945c7fcfe53336cd57f8a", "filename": "src/test/ui/simd/simd-intrinsic-generic-select.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/src%2Ftest%2Fui%2Fsimd%2Fsimd-intrinsic-generic-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a835b483fe0418b48ca44afb65cd0dd6bad4eb9b/src%2Ftest%2Fui%2Fsimd%2Fsimd-intrinsic-generic-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fsimd-intrinsic-generic-select.rs?ref=a835b483fe0418b48ca44afb65cd0dd6bad4eb9b", "patch": "@@ -167,4 +167,29 @@ fn main() {\n         let e = u32x8(8, 9, 10, 11, 4, 5, 6, 7);\n         assert_eq!(r, e);\n     }\n+\n+    unsafe {\n+        let a = u32x4(0, 1, 2, 3);\n+        let b = u32x4(4, 5, 6, 7);\n+\n+        let r: u32x4 = simd_select_bitmask(0u8, a, b);\n+        let e = b;\n+        assert_eq!(r, e);\n+\n+        let r: u32x4 = simd_select_bitmask(0xfu8, a, b);\n+        let e = a;\n+        assert_eq!(r, e);\n+\n+        let r: u32x4 = simd_select_bitmask(0b0101u8, a, b);\n+        let e = u32x4(0, 5, 2, 7);\n+        assert_eq!(r, e);\n+\n+        let r: u32x4 = simd_select_bitmask(0b1010u8, a, b);\n+        let e = u32x4(4, 1, 6, 3);\n+        assert_eq!(r, e);\n+\n+        let r: u32x4 = simd_select_bitmask(0b1100u8, a, b);\n+        let e = u32x4(4, 5, 2, 3);\n+        assert_eq!(r, e);\n+    }\n }"}]}