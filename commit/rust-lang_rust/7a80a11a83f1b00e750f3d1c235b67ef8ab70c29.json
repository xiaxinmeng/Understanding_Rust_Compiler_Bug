{"sha": "7a80a11a83f1b00e750f3d1c235b67ef8ab70c29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhODBhMTFhODNmMWIwMGU3NTBmM2QxYzIzNWI2N2VmOGFiNzBjMjk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-18T19:15:14Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-22T11:21:14Z"}, "message": "rustc_metadata: use a table for fn_sig.", "tree": {"sha": "c689ded3c63df4308d59215fc68379f48281bf67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c689ded3c63df4308d59215fc68379f48281bf67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a80a11a83f1b00e750f3d1c235b67ef8ab70c29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a80a11a83f1b00e750f3d1c235b67ef8ab70c29", "html_url": "https://github.com/rust-lang/rust/commit/7a80a11a83f1b00e750f3d1c235b67ef8ab70c29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a80a11a83f1b00e750f3d1c235b67ef8ab70c29/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74db3e8a9e31adf0ed7b3e9f4e1093e6b6a40fc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/74db3e8a9e31adf0ed7b3e9f4e1093e6b6a40fc4", "html_url": "https://github.com/rust-lang/rust/commit/74db3e8a9e31adf0ed7b3e9f4e1093e6b6a40fc4"}], "stats": {"total": 98, "additions": 38, "deletions": 60}, "files": [{"sha": "9c7b721fb7f634581d2073dada682c00b2f03e58", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7a80a11a83f1b00e750f3d1c235b67ef8ab70c29/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a80a11a83f1b00e750f3d1c235b67ef8ab70c29/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=7a80a11a83f1b00e750f3d1c235b67ef8ab70c29", "patch": "@@ -458,7 +458,7 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Impl(_) |\n             EntryKind::Field |\n             EntryKind::Generator(_) |\n-            EntryKind::Closure(_) => return None,\n+            EntryKind::Closure => return None,\n         })\n     }\n }\n@@ -1239,16 +1239,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n-        let sig = match self.kind(id) {\n-            EntryKind::Fn(data) |\n-            EntryKind::ForeignFn(data) => data.decode(self).sig,\n-            EntryKind::Method(data) => data.decode(self).fn_data.sig,\n-            EntryKind::Variant(data) |\n-            EntryKind::Struct(data, _) => data.decode(self).ctor_sig.unwrap(),\n-            EntryKind::Closure(data) => data.decode(self).sig,\n-            _ => bug!(),\n-        };\n-        sig.decode((self, tcx))\n+        self.root.per_def.fn_sig.get(self, id).unwrap().decode((self, tcx))\n     }\n \n     #[inline]"}, {"sha": "e3ad1c5e197b5d4662126d6ce3b8cbbd50078903", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 24, "deletions": 29, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7a80a11a83f1b00e750f3d1c235b67ef8ab70c29/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a80a11a83f1b00e750f3d1c235b67ef8ab70c29/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=7a80a11a83f1b00e750f3d1c235b67ef8ab70c29", "patch": "@@ -71,6 +71,7 @@ struct PerDefTables<'tcx> {\n     deprecation: PerDefTable<Lazy<attr::Deprecation>>,\n \n     ty: PerDefTable<Lazy<Ty<'tcx>>>,\n+    fn_sig: PerDefTable<Lazy<ty::PolyFnSig<'tcx>>>,\n     inherent_impls: PerDefTable<Lazy<[DefIndex]>>,\n     variances: PerDefTable<Lazy<[ty::Variance]>>,\n     generics: PerDefTable<Lazy<ty::Generics>>,\n@@ -509,6 +510,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             deprecation: self.per_def.deprecation.encode(&mut self.opaque),\n \n             ty: self.per_def.ty.encode(&mut self.opaque),\n+            fn_sig: self.per_def.fn_sig.encode(&mut self.opaque),\n             inherent_impls: self.per_def.inherent_impls.encode(&mut self.opaque),\n             variances: self.per_def.variances.encode(&mut self.opaque),\n             generics: self.per_def.generics.encode(&mut self.opaque),\n@@ -637,13 +639,7 @@ impl EncodeContext<'tcx> {\n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n-            // FIXME(eddyb) deduplicate these with `encode_enum_variant_ctor`.\n             ctor: variant.ctor_def_id.map(|did| did.index),\n-            ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n-                variant.ctor_def_id.map(|ctor_def_id| self.lazy(&tcx.fn_sig(ctor_def_id)))\n-            } else {\n-                None\n-            },\n         };\n \n         let enum_id = tcx.hir().as_local_hir_id(enum_did).unwrap();\n@@ -662,6 +658,11 @@ impl EncodeContext<'tcx> {\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n+            // FIXME(eddyb) encode signature only in `encode_enum_variant_ctor`.\n+            if let Some(ctor_def_id) = variant.ctor_def_id {\n+                record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(ctor_def_id));\n+            }\n+            // FIXME(eddyb) is this ever used?\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -681,15 +682,11 @@ impl EncodeContext<'tcx> {\n         let def_id = variant.ctor_def_id.unwrap();\n         debug!(\"EncodeContext::encode_enum_variant_ctor({:?})\", def_id);\n \n+        // FIXME(eddyb) encode only the `CtorKind` for constructors.\n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n             ctor: Some(def_id.index),\n-            ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n-                Some(self.lazy(tcx.fn_sig(def_id)))\n-            } else {\n-                None\n-            }\n         };\n \n         // Variant constructors have the same visibility as the parent enums, unless marked as\n@@ -708,6 +705,7 @@ impl EncodeContext<'tcx> {\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n+            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -782,11 +780,6 @@ impl EncodeContext<'tcx> {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n             ctor: Some(def_id.index),\n-            ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n-                Some(self.lazy(tcx.fn_sig(def_id)))\n-            } else {\n-                None\n-            }\n         };\n \n         let struct_id = tcx.hir().as_local_hir_id(adt_def_id).unwrap();\n@@ -813,6 +806,7 @@ impl EncodeContext<'tcx> {\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n+            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -881,7 +875,6 @@ impl EncodeContext<'tcx> {\n                         asyncness: m_sig.header.asyncness,\n                         constness: hir::Constness::NotConst,\n                         param_names,\n-                        sig: self.lazy(tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -913,6 +906,7 @@ impl EncodeContext<'tcx> {\n             ty::AssocKind::OpaqueTy => unreachable!(),\n         }\n         if trait_item.kind == ty::AssocKind::Method {\n+            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -959,7 +953,6 @@ impl EncodeContext<'tcx> {\n                         asyncness: sig.header.asyncness,\n                         constness: sig.header.constness,\n                         param_names: self.encode_fn_param_names_for_body(body),\n-                        sig: self.lazy(tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -980,6 +973,7 @@ impl EncodeContext<'tcx> {\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if impl_item.kind == ty::AssocKind::Method {\n+            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -1088,7 +1082,6 @@ impl EncodeContext<'tcx> {\n                     asyncness: header.asyncness,\n                     constness: header.constness,\n                     param_names: self.encode_fn_param_names_for_body(body),\n-                    sig: self.lazy(tcx.fn_sig(def_id)),\n                 };\n \n                 EntryKind::Fn(self.lazy(data))\n@@ -1116,7 +1109,6 @@ impl EncodeContext<'tcx> {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     ctor,\n-                    ctor_sig: None,\n                 }), adt_def.repr)\n             }\n             hir::ItemKind::Union(..) => {\n@@ -1127,7 +1119,6 @@ impl EncodeContext<'tcx> {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     ctor: None,\n-                    ctor_sig: None,\n                 }), adt_def.repr)\n             }\n             hir::ItemKind::Impl(_, _, defaultness, ..) => {\n@@ -1232,6 +1223,9 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::Impl(..) => self.encode_item_type(def_id),\n             _ => {}\n         }\n+        if let hir::ItemKind::Fn(..) = item.kind {\n+            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n+        }\n         self.encode_inherent_implementations(def_id);\n         match item.kind {\n             hir::ItemKind::Enum(..) |\n@@ -1328,10 +1322,12 @@ impl EncodeContext<'tcx> {\n     fn encode_info_for_closure(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_closure({:?})\", def_id);\n \n-        let tables = self.tcx.typeck_tables_of(def_id);\n+        // NOTE(eddyb) `tcx.type_of(def_id)` isn't used because it's fully generic,\n+        // including on the signature, which is inferred in `typeck_tables_of.\n         let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let ty = self.tcx.typeck_tables_of(def_id).node_type(hir_id);\n \n-        record!(self.per_def.kind[def_id] <- match tables.node_type(hir_id).kind {\n+        record!(self.per_def.kind[def_id] <- match ty.kind {\n             ty::Generator(def_id, ..) => {\n                 let layout = self.tcx.generator_layout(def_id);\n                 let data = GeneratorData {\n@@ -1340,18 +1336,17 @@ impl EncodeContext<'tcx> {\n                 EntryKind::Generator(self.lazy(data))\n             }\n \n-            ty::Closure(def_id, substs) => {\n-                let sig = substs.as_closure().sig(def_id, self.tcx);\n-                let data = ClosureData { sig: self.lazy(sig) };\n-                EntryKind::Closure(self.lazy(data))\n-            }\n+            ty::Closure(..) => EntryKind::Closure,\n \n             _ => bug!(\"closure that is neither generator nor closure\"),\n         });\n         record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n         record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n         record!(self.per_def.attributes[def_id] <- &self.tcx.get_attrs(def_id)[..]);\n         self.encode_item_type(def_id);\n+        if let ty::Closure(def_id, substs) = ty.kind {\n+            record!(self.per_def.fn_sig[def_id] <- substs.as_closure().sig(def_id, self.tcx));\n+        }\n         self.encode_generics(def_id);\n         self.encode_optimized_mir(def_id);\n         self.encode_promoted_mir(def_id);\n@@ -1560,7 +1555,6 @@ impl EncodeContext<'tcx> {\n                     asyncness: hir::IsAsync::NotAsync,\n                     constness: hir::Constness::NotConst,\n                     param_names: self.encode_fn_param_names(names),\n-                    sig: self.lazy(tcx.fn_sig(def_id)),\n                 };\n                 EntryKind::ForeignFn(self.lazy(data))\n             }\n@@ -1576,6 +1570,7 @@ impl EncodeContext<'tcx> {\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if let hir::ForeignItemKind::Fn(..) = nitem.kind {\n+            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);"}, {"sha": "03754c92252a3b2acad11830af162331392c0e3c", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7a80a11a83f1b00e750f3d1c235b67ef8ab70c29/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a80a11a83f1b00e750f3d1c235b67ef8ab70c29/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=7a80a11a83f1b00e750f3d1c235b67ef8ab70c29", "patch": "@@ -238,6 +238,7 @@ crate struct LazyPerDefTables<'tcx> {\n     pub deprecation: Lazy!(PerDefTable<Lazy<attr::Deprecation>>),\n \n     pub ty: Lazy!(PerDefTable<Lazy!(Ty<'tcx>)>),\n+    pub fn_sig: Lazy!(PerDefTable<Lazy!(ty::PolyFnSig<'tcx>)>),\n     pub inherent_impls: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n     pub variances: Lazy!(PerDefTable<Lazy<[ty::Variance]>>),\n     pub generics: Lazy!(PerDefTable<Lazy<ty::Generics>>),\n@@ -265,18 +266,18 @@ crate enum EntryKind<'tcx> {\n     OpaqueTy,\n     Enum(ReprOptions),\n     Field,\n-    Variant(Lazy!(VariantData<'tcx>)),\n-    Struct(Lazy!(VariantData<'tcx>), ReprOptions),\n-    Union(Lazy!(VariantData<'tcx>), ReprOptions),\n-    Fn(Lazy!(FnData<'tcx>)),\n-    ForeignFn(Lazy!(FnData<'tcx>)),\n+    Variant(Lazy<VariantData>),\n+    Struct(Lazy<VariantData>, ReprOptions),\n+    Union(Lazy<VariantData>, ReprOptions),\n+    Fn(Lazy<FnData>),\n+    ForeignFn(Lazy<FnData>),\n     Mod(Lazy<ModData>),\n     MacroDef(Lazy<MacroDef>),\n-    Closure(Lazy!(ClosureData<'tcx>)),\n+    Closure,\n     Generator(Lazy!(GeneratorData<'tcx>)),\n     Trait(Lazy<TraitData>),\n     Impl(Lazy!(ImplData<'tcx>)),\n-    Method(Lazy!(MethodData<'tcx>)),\n+    Method(Lazy<MethodData>),\n     AssocType(AssocContainer),\n     AssocOpaqueTy(AssocContainer),\n     AssocConst(AssocContainer, ConstQualif, Lazy<RenderedConst>),\n@@ -306,22 +307,18 @@ crate struct MacroDef {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct FnData<'tcx> {\n+crate struct FnData {\n     pub asyncness: hir::IsAsync,\n     pub constness: hir::Constness,\n     pub param_names: Lazy<[ast::Name]>,\n-    pub sig: Lazy!(ty::PolyFnSig<'tcx>),\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct VariantData<'tcx> {\n+crate struct VariantData {\n     pub ctor_kind: CtorKind,\n     pub discr: ty::VariantDiscr,\n     /// If this is unit or tuple-variant/struct, then this is the index of the ctor id.\n     pub ctor: Option<DefIndex>,\n-    /// If this is a tuple struct or variant\n-    /// ctor, this is its \"function\" signature.\n-    pub ctor_sig: Option<Lazy!(ty::PolyFnSig<'tcx>)>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -383,17 +380,12 @@ impl AssocContainer {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct MethodData<'tcx> {\n-    pub fn_data: FnData<'tcx>,\n+crate struct MethodData {\n+    pub fn_data: FnData,\n     pub container: AssocContainer,\n     pub has_self: bool,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n-crate struct ClosureData<'tcx> {\n-    pub sig: Lazy!(ty::PolyFnSig<'tcx>),\n-}\n-\n #[derive(RustcEncodable, RustcDecodable)]\n crate struct GeneratorData<'tcx> {\n     pub layout: mir::GeneratorLayout<'tcx>,"}]}