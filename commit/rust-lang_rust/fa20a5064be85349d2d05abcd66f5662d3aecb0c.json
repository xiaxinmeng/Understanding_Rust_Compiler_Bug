{"sha": "fa20a5064be85349d2d05abcd66f5662d3aecb0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhMjBhNTA2NGJlODUzNDlkMmQwNWFiY2Q2NmY1NjYyZDNhZWNiMGM=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-04-20T00:05:22Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-04-20T00:09:12Z"}, "message": "Remove SyntaxRewriter usage in insert_use in favor of ted", "tree": {"sha": "578e0f5f9208d607969b084921e174a1cebe1f44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/578e0f5f9208d607969b084921e174a1cebe1f44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa20a5064be85349d2d05abcd66f5662d3aecb0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa20a5064be85349d2d05abcd66f5662d3aecb0c", "html_url": "https://github.com/rust-lang/rust/commit/fa20a5064be85349d2d05abcd66f5662d3aecb0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa20a5064be85349d2d05abcd66f5662d3aecb0c/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8744ed9bb3e139e5d427db1f4f219f1fdeee13e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8744ed9bb3e139e5d427db1f4f219f1fdeee13e", "html_url": "https://github.com/rust-lang/rust/commit/e8744ed9bb3e139e5d427db1f4f219f1fdeee13e"}], "stats": {"total": 428, "additions": 185, "deletions": 243}, "files": [{"sha": "6db2d2edd6e19fa4ae776ce668890e5bfbb156a2", "filename": "crates/ide_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa20a5064be85349d2d05abcd66f5662d3aecb0c/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa20a5064be85349d2d05abcd66f5662d3aecb0c/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=fa20a5064be85349d2d05abcd66f5662d3aecb0c", "patch": "@@ -101,9 +101,11 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n             format!(\"Import `{}`\", import.import_path),\n             range,\n             |builder| {\n-                let rewriter =\n-                    insert_use(&scope, mod_path_to_ast(&import.import_path), ctx.config.insert_use);\n-                builder.rewrite(rewriter);\n+                let scope = match scope.clone() {\n+                    ImportScope::File(it) => ImportScope::File(builder.make_ast_mut(it)),\n+                    ImportScope::Module(it) => ImportScope::Module(builder.make_ast_mut(it)),\n+                };\n+                insert_use(&scope, mod_path_to_ast(&import.import_path), ctx.config.insert_use);\n             },\n         );\n     }"}, {"sha": "26e1c66ab471b1afdb6a4c7248c450d3c1fa11c7", "filename": "crates/ide_assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 45, "deletions": 40, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/fa20a5064be85349d2d05abcd66f5662d3aecb0c/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa20a5064be85349d2d05abcd66f5662d3aecb0c/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=fa20a5064be85349d2d05abcd66f5662d3aecb0c", "patch": "@@ -13,9 +13,9 @@ use ide_db::{\n };\n use rustc_hash::FxHashSet;\n use syntax::{\n-    algo::{find_node_at_offset, SyntaxRewriter},\n-    ast::{self, edit::IndentLevel, make, AstNode, NameOwner, VisibilityOwner},\n-    SourceFile, SyntaxElement, SyntaxNode, T,\n+    algo::find_node_at_offset,\n+    ast::{self, make, AstNode, NameOwner, VisibilityOwner},\n+    ted, SourceFile, SyntaxElement, SyntaxNode, T,\n };\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n@@ -62,40 +62,45 @@ pub(crate) fn extract_struct_from_enum_variant(\n             let mut visited_modules_set = FxHashSet::default();\n             let current_module = enum_hir.module(ctx.db());\n             visited_modules_set.insert(current_module);\n-            let mut def_rewriter = None;\n+            let mut def_file_references = None;\n             for (file_id, references) in usages {\n-                let mut rewriter = SyntaxRewriter::default();\n-                let source_file = ctx.sema.parse(file_id);\n+                if file_id == ctx.frange.file_id {\n+                    def_file_references = Some(references);\n+                    continue;\n+                }\n+                builder.edit_file(file_id);\n+                let source_file = builder.make_ast_mut(ctx.sema.parse(file_id));\n                 for reference in references {\n                     update_reference(\n                         ctx,\n-                        &mut rewriter,\n                         reference,\n                         &source_file,\n                         &enum_module_def,\n                         &variant_hir_name,\n                         &mut visited_modules_set,\n                     );\n                 }\n-                if file_id == ctx.frange.file_id {\n-                    def_rewriter = Some(rewriter);\n-                    continue;\n-                }\n-                builder.edit_file(file_id);\n-                builder.rewrite(rewriter);\n             }\n-            let mut rewriter = def_rewriter.unwrap_or_default();\n-            update_variant(&mut rewriter, &variant);\n+            builder.edit_file(ctx.frange.file_id);\n+            let variant = builder.make_ast_mut(variant.clone());\n+            let source_file = builder.make_ast_mut(ctx.sema.parse(ctx.frange.file_id));\n+            for reference in def_file_references.into_iter().flatten() {\n+                update_reference(\n+                    ctx,\n+                    reference,\n+                    &source_file,\n+                    &enum_module_def,\n+                    &variant_hir_name,\n+                    &mut visited_modules_set,\n+                );\n+            }\n             extract_struct_def(\n-                &mut rewriter,\n-                &enum_ast,\n                 variant_name.clone(),\n                 &field_list,\n                 &variant.parent_enum().syntax().clone().into(),\n                 enum_ast.visibility(),\n             );\n-            builder.edit_file(ctx.frange.file_id);\n-            builder.rewrite(rewriter);\n+            update_variant(&variant);\n         },\n     )\n }\n@@ -138,7 +143,6 @@ fn existing_definition(db: &RootDatabase, variant_name: &ast::Name, variant: &Va\n \n fn insert_import(\n     ctx: &AssistContext,\n-    rewriter: &mut SyntaxRewriter,\n     scope_node: &SyntaxNode,\n     module: &Module,\n     enum_module_def: &ModuleDef,\n@@ -151,14 +155,12 @@ fn insert_import(\n         mod_path.pop_segment();\n         mod_path.push_segment(variant_hir_name.clone());\n         let scope = ImportScope::find_insert_use_container(scope_node, &ctx.sema)?;\n-        *rewriter += insert_use(&scope, mod_path_to_ast(&mod_path), ctx.config.insert_use);\n+        insert_use(&scope, mod_path_to_ast(&mod_path), ctx.config.insert_use);\n     }\n     Some(())\n }\n \n fn extract_struct_def(\n-    rewriter: &mut SyntaxRewriter,\n-    enum_: &ast::Enum,\n     variant_name: ast::Name,\n     field_list: &Either<ast::RecordFieldList, ast::TupleFieldList>,\n     start_offset: &SyntaxElement,\n@@ -180,33 +182,34 @@ fn extract_struct_def(\n         .into(),\n     };\n \n-    rewriter.insert_before(\n-        start_offset,\n-        make::struct_(visibility, variant_name, None, field_list).syntax(),\n+    ted::insert_raw(\n+        ted::Position::before(start_offset),\n+        make::struct_(visibility, variant_name, None, field_list).clone_for_update().syntax(),\n     );\n-    rewriter.insert_before(start_offset, &make::tokens::blank_line());\n+    ted::insert_raw(ted::Position::before(start_offset), &make::tokens::blank_line());\n \n-    if let indent_level @ 1..=usize::MAX = IndentLevel::from_node(enum_.syntax()).0 as usize {\n-        rewriter\n-            .insert_before(start_offset, &make::tokens::whitespace(&\" \".repeat(4 * indent_level)));\n-    }\n+    // if let indent_level @ 1..=usize::MAX = IndentLevel::from_node(enum_.syntax()).0 as usize {\n+    //     ted::insert(ted::Position::before(start_offset), &make::tokens::blank_line());\n+    //     rewriter\n+    //         .insert_before(start_offset, &make::tokens::whitespace(&\" \".repeat(4 * indent_level)));\n+    // }\n     Some(())\n }\n \n-fn update_variant(rewriter: &mut SyntaxRewriter, variant: &ast::Variant) -> Option<()> {\n+fn update_variant(variant: &ast::Variant) -> Option<()> {\n     let name = variant.name()?;\n     let tuple_field = make::tuple_field(None, make::ty(&name.text()));\n     let replacement = make::variant(\n         name,\n         Some(ast::FieldList::TupleFieldList(make::tuple_field_list(iter::once(tuple_field)))),\n-    );\n-    rewriter.replace(variant.syntax(), replacement.syntax());\n+    )\n+    .clone_for_update();\n+    ted::replace(variant.syntax(), replacement.syntax());\n     Some(())\n }\n \n fn update_reference(\n     ctx: &AssistContext,\n-    rewriter: &mut SyntaxRewriter,\n     reference: FileReference,\n     source_file: &SourceFile,\n     enum_module_def: &ModuleDef,\n@@ -230,14 +233,16 @@ fn update_reference(\n \n     let module = ctx.sema.scope(&expr).module()?;\n     if !visited_modules_set.contains(&module) {\n-        if insert_import(ctx, rewriter, &expr, &module, enum_module_def, variant_hir_name).is_some()\n-        {\n+        if insert_import(ctx, &expr, &module, enum_module_def, variant_hir_name).is_some() {\n             visited_modules_set.insert(module);\n         }\n     }\n-    rewriter.insert_after(segment.syntax(), &make::token(T!['(']));\n-    rewriter.insert_after(segment.syntax(), segment.syntax());\n-    rewriter.insert_after(&expr, &make::token(T![')']));\n+    ted::insert_raw(\n+        ted::Position::before(segment.syntax()),\n+        make::path_from_text(&format!(\"{}\", segment)).clone_for_update().syntax(),\n+    );\n+    ted::insert_raw(ted::Position::before(segment.syntax()), make::token(T!['(']));\n+    ted::insert_raw(ted::Position::after(&expr), make::token(T![')']));\n     Some(())\n }\n "}, {"sha": "2f2306fcc2376f99ae2a85aa0e780ca4637d2b0e", "filename": "crates/ide_assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fa20a5064be85349d2d05abcd66f5662d3aecb0c/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa20a5064be85349d2d05abcd66f5662d3aecb0c/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=fa20a5064be85349d2d05abcd66f5662d3aecb0c", "patch": "@@ -1,5 +1,5 @@\n use ide_db::helpers::insert_use::{insert_use, ImportScope};\n-use syntax::{algo::SyntaxRewriter, ast, match_ast, AstNode, SyntaxNode};\n+use syntax::{ast, match_ast, ted, AstNode, SyntaxNode};\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n@@ -40,18 +40,17 @@ pub(crate) fn replace_qualified_name_with_use(\n         |builder| {\n             // Now that we've brought the name into scope, re-qualify all paths that could be\n             // affected (that is, all paths inside the node we added the `use` to).\n-            let mut rewriter = SyntaxRewriter::default();\n-            shorten_paths(&mut rewriter, syntax.clone(), &path);\n+            let syntax = builder.make_mut(syntax.clone());\n             if let Some(ref import_scope) = ImportScope::from(syntax.clone()) {\n-                rewriter += insert_use(import_scope, path, ctx.config.insert_use);\n-                builder.rewrite(rewriter);\n+                insert_use(import_scope, path.clone(), ctx.config.insert_use);\n             }\n+            shorten_paths(syntax.clone(), &path.clone_for_update());\n         },\n     )\n }\n \n /// Adds replacements to `re` that shorten `path` in all descendants of `node`.\n-fn shorten_paths(rewriter: &mut SyntaxRewriter<'static>, node: SyntaxNode, path: &ast::Path) {\n+fn shorten_paths(node: SyntaxNode, path: &ast::Path) {\n     for child in node.children() {\n         match_ast! {\n             match child {\n@@ -62,32 +61,28 @@ fn shorten_paths(rewriter: &mut SyntaxRewriter<'static>, node: SyntaxNode, path:\n                 ast::Module(_it) => continue,\n \n                 ast::Path(p) => {\n-                    match maybe_replace_path(rewriter, p.clone(), path.clone()) {\n+                    match maybe_replace_path(p.clone(), path.clone()) {\n                         Some(()) => {},\n-                        None => shorten_paths(rewriter, p.syntax().clone(), path),\n+                        None => shorten_paths(p.syntax().clone(), path),\n                     }\n                 },\n-                _ => shorten_paths(rewriter, child, path),\n+                _ => shorten_paths(child, path),\n             }\n         }\n     }\n }\n \n-fn maybe_replace_path(\n-    rewriter: &mut SyntaxRewriter<'static>,\n-    path: ast::Path,\n-    target: ast::Path,\n-) -> Option<()> {\n+fn maybe_replace_path(path: ast::Path, target: ast::Path) -> Option<()> {\n     if !path_eq(path.clone(), target) {\n         return None;\n     }\n \n     // Shorten `path`, leaving only its last segment.\n     if let Some(parent) = path.qualifier() {\n-        rewriter.delete(parent.syntax());\n+        ted::remove(parent.syntax());\n     }\n     if let Some(double_colon) = path.coloncolon_token() {\n-        rewriter.delete(&double_colon);\n+        ted::remove(&double_colon);\n     }\n \n     Some(())\n@@ -150,6 +145,7 @@ Debug\n     \",\n         );\n     }\n+\n     #[test]\n     fn test_replace_add_use_no_anchor_with_item_below() {\n         check_assist("}, {"sha": "99edb94992020e2914582d3ac4d52a66c0be5dd4", "filename": "crates/ide_completion/src/item.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fa20a5064be85349d2d05abcd66f5662d3aecb0c/crates%2Fide_completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa20a5064be85349d2d05abcd66f5662d3aecb0c/crates%2Fide_completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fitem.rs?ref=fa20a5064be85349d2d05abcd66f5662d3aecb0c", "patch": "@@ -377,11 +377,11 @@ impl ImportEdit {\n     pub fn to_text_edit(&self, cfg: InsertUseConfig) -> Option<TextEdit> {\n         let _p = profile::span(\"ImportEdit::to_text_edit\");\n \n-        let rewriter =\n-            insert_use::insert_use(&self.scope, mod_path_to_ast(&self.import.import_path), cfg);\n-        let old_ast = rewriter.rewrite_root()?;\n+        let new_ast = self.scope.clone_for_update();\n+        insert_use::insert_use(&new_ast, mod_path_to_ast(&self.import.import_path), cfg);\n         let mut import_insert = TextEdit::builder();\n-        algo::diff(&old_ast, &rewriter.rewrite(&old_ast)).into_text_edit(&mut import_insert);\n+        algo::diff(self.scope.as_syntax_node(), new_ast.as_syntax_node())\n+            .into_text_edit(&mut import_insert);\n \n         Some(import_insert.finish())\n     }"}, {"sha": "498d76f722a087181debe75257a855c9a882e825", "filename": "crates/ide_db/src/helpers/insert_use.rs", "status": "modified", "additions": 97, "deletions": 165, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/fa20a5064be85349d2d05abcd66f5662d3aecb0c/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa20a5064be85349d2d05abcd66f5662d3aecb0c/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use.rs?ref=fa20a5064be85349d2d05abcd66f5662d3aecb0c", "patch": "@@ -4,13 +4,9 @@ use std::{cmp::Ordering, iter::successors};\n use hir::Semantics;\n use itertools::{EitherOrBoth, Itertools};\n use syntax::{\n-    algo::SyntaxRewriter,\n-    ast::{\n-        self,\n-        edit::{AstNodeEdit, IndentLevel},\n-        make, AstNode, AttrsOwner, PathSegmentKind, VisibilityOwner,\n-    },\n-    AstToken, InsertPosition, NodeOrToken, SyntaxElement, SyntaxNode, SyntaxToken,\n+    algo,\n+    ast::{self, edit::AstNodeEdit, make, AstNode, AttrsOwner, PathSegmentKind, VisibilityOwner},\n+    ted, AstToken, Direction, NodeOrToken, SyntaxNode, SyntaxToken,\n };\n \n use crate::RootDatabase;\n@@ -56,127 +52,32 @@ impl ImportScope {\n         }\n     }\n \n-    fn indent_level(&self) -> IndentLevel {\n+    pub fn clone_for_update(&self) -> Self {\n         match self {\n-            ImportScope::File(file) => file.indent_level(),\n-            ImportScope::Module(item_list) => item_list.indent_level() + 1,\n+            ImportScope::File(file) => ImportScope::File(file.clone_for_update()),\n+            ImportScope::Module(item_list) => ImportScope::Module(item_list.clone_for_update()),\n         }\n     }\n-\n-    fn first_insert_pos(&self) -> (InsertPosition<SyntaxElement>, AddBlankLine) {\n-        match self {\n-            ImportScope::File(_) => (InsertPosition::First, AddBlankLine::AfterTwice),\n-            // don't insert the imports before the item list's opening curly brace\n-            ImportScope::Module(item_list) => item_list\n-                .l_curly_token()\n-                .map(|b| (InsertPosition::After(b.into()), AddBlankLine::Around))\n-                .unwrap_or((InsertPosition::First, AddBlankLine::AfterTwice)),\n-        }\n-    }\n-\n-    fn insert_pos_after_last_inner_element(&self) -> (InsertPosition<SyntaxElement>, AddBlankLine) {\n-        self.as_syntax_node()\n-            .children_with_tokens()\n-            .filter(|child| match child {\n-                NodeOrToken::Node(node) => is_inner_attribute(node.clone()),\n-                NodeOrToken::Token(token) => is_inner_comment(token.clone()),\n-            })\n-            .last()\n-            .map(|last_inner_element| {\n-                (InsertPosition::After(last_inner_element), AddBlankLine::BeforeTwice)\n-            })\n-            .unwrap_or_else(|| self.first_insert_pos())\n-    }\n-}\n-\n-fn is_inner_attribute(node: SyntaxNode) -> bool {\n-    ast::Attr::cast(node).map(|attr| attr.kind()) == Some(ast::AttrKind::Inner)\n-}\n-\n-fn is_inner_comment(token: SyntaxToken) -> bool {\n-    ast::Comment::cast(token).and_then(|comment| comment.kind().doc)\n-        == Some(ast::CommentPlacement::Inner)\n }\n \n /// Insert an import path into the given file/node. A `merge` value of none indicates that no import merging is allowed to occur.\n-pub fn insert_use<'a>(\n-    scope: &ImportScope,\n-    path: ast::Path,\n-    cfg: InsertUseConfig,\n-) -> SyntaxRewriter<'a> {\n+pub fn insert_use<'a>(scope: &ImportScope, path: ast::Path, cfg: InsertUseConfig) {\n     let _p = profile::span(\"insert_use\");\n-    let mut rewriter = SyntaxRewriter::default();\n-    let use_item = make::use_(None, make::use_tree(path.clone(), None, None, false));\n+    let use_item =\n+        make::use_(None, make::use_tree(path.clone(), None, None, false)).clone_for_update();\n     // merge into existing imports if possible\n     if let Some(mb) = cfg.merge {\n         for existing_use in scope.as_syntax_node().children().filter_map(ast::Use::cast) {\n             if let Some(merged) = try_merge_imports(&existing_use, &use_item, mb) {\n-                rewriter.replace(existing_use.syntax(), merged.syntax());\n-                return rewriter;\n+                ted::replace(existing_use.syntax(), merged.syntax());\n+                return;\n             }\n         }\n     }\n \n     // either we weren't allowed to merge or there is no import that fits the merge conditions\n     // so look for the place we have to insert to\n-    let (insert_position, add_blank) = find_insert_position(scope, path, cfg.group);\n-\n-    let indent = if let ident_level @ 1..=usize::MAX = scope.indent_level().0 as usize {\n-        Some(make::tokens::whitespace(&\" \".repeat(4 * ident_level)).into())\n-    } else {\n-        None\n-    };\n-\n-    let to_insert: Vec<SyntaxElement> = {\n-        let mut buf = Vec::new();\n-\n-        match add_blank {\n-            AddBlankLine::Before | AddBlankLine::Around => {\n-                buf.push(make::tokens::single_newline().into())\n-            }\n-            AddBlankLine::BeforeTwice => buf.push(make::tokens::blank_line().into()),\n-            _ => (),\n-        }\n-\n-        if add_blank.has_before() {\n-            if let Some(indent) = indent.clone() {\n-                cov_mark::hit!(insert_use_indent_before);\n-                buf.push(indent);\n-            }\n-        }\n-\n-        buf.push(use_item.syntax().clone().into());\n-\n-        match add_blank {\n-            AddBlankLine::After | AddBlankLine::Around => {\n-                buf.push(make::tokens::single_newline().into())\n-            }\n-            AddBlankLine::AfterTwice => buf.push(make::tokens::blank_line().into()),\n-            _ => (),\n-        }\n-\n-        // only add indentation *after* our stuff if there's another node directly after it\n-        if add_blank.has_after() && matches!(insert_position, InsertPosition::Before(_)) {\n-            if let Some(indent) = indent {\n-                cov_mark::hit!(insert_use_indent_after);\n-                buf.push(indent);\n-            }\n-        } else if add_blank.has_after() && matches!(insert_position, InsertPosition::After(_)) {\n-            cov_mark::hit!(insert_use_no_indent_after);\n-        }\n-\n-        buf\n-    };\n-\n-    match insert_position {\n-        InsertPosition::First => {\n-            rewriter.insert_many_as_first_children(scope.as_syntax_node(), to_insert)\n-        }\n-        InsertPosition::Last => return rewriter, // actually unreachable\n-        InsertPosition::Before(anchor) => rewriter.insert_many_before(&anchor, to_insert),\n-        InsertPosition::After(anchor) => rewriter.insert_many_after(&anchor, to_insert),\n-    }\n-    rewriter\n+    insert_use_(scope, path, cfg.group, use_item);\n }\n \n fn eq_visibility(vis0: Option<ast::Visibility>, vis1: Option<ast::Visibility>) -> bool {\n@@ -235,7 +136,7 @@ pub fn try_merge_trees(\n     } else {\n         (lhs.split_prefix(&lhs_prefix), rhs.split_prefix(&rhs_prefix))\n     };\n-    recursive_merge(&lhs, &rhs, merge).map(|it| it.clone_for_update())\n+    recursive_merge(&lhs, &rhs, merge)\n }\n \n /// Recursively \"zips\" together lhs and rhs.\n@@ -334,7 +235,12 @@ fn recursive_merge(\n             }\n         }\n     }\n-    Some(lhs.with_use_tree_list(make::use_tree_list(use_trees)))\n+\n+    Some(if let Some(old) = lhs.use_tree_list() {\n+        lhs.replace_descendant(old, make::use_tree_list(use_trees)).clone_for_update()\n+    } else {\n+        lhs.clone()\n+    })\n }\n \n /// Traverses both paths until they differ, returning the common prefix of both.\n@@ -520,32 +426,15 @@ impl ImportGroup {\n     }\n }\n \n-#[derive(PartialEq, Eq)]\n-enum AddBlankLine {\n-    Before,\n-    BeforeTwice,\n-    Around,\n-    After,\n-    AfterTwice,\n-}\n-\n-impl AddBlankLine {\n-    fn has_before(&self) -> bool {\n-        matches!(self, AddBlankLine::Before | AddBlankLine::BeforeTwice | AddBlankLine::Around)\n-    }\n-    fn has_after(&self) -> bool {\n-        matches!(self, AddBlankLine::After | AddBlankLine::AfterTwice | AddBlankLine::Around)\n-    }\n-}\n-\n-fn find_insert_position(\n+fn insert_use_(\n     scope: &ImportScope,\n     insert_path: ast::Path,\n     group_imports: bool,\n-) -> (InsertPosition<SyntaxElement>, AddBlankLine) {\n+    use_item: ast::Use,\n+) {\n+    let scope_syntax = scope.as_syntax_node();\n     let group = ImportGroup::new(&insert_path);\n-    let path_node_iter = scope\n-        .as_syntax_node()\n+    let path_node_iter = scope_syntax\n         .children()\n         .filter_map(|node| ast::Use::cast(node.clone()).zip(Some(node)))\n         .flat_map(|(use_, node)| {\n@@ -557,9 +446,12 @@ fn find_insert_position(\n \n     if !group_imports {\n         if let Some((_, _, node)) = path_node_iter.last() {\n-            return (InsertPosition::After(node.into()), AddBlankLine::Before);\n+            ted::insert(ted::Position::after(node), use_item.syntax());\n+        } else {\n+            ted::insert(ted::Position::first_child_of(scope_syntax), make::tokens::blank_line());\n+            ted::insert(ted::Position::first_child_of(scope_syntax), use_item.syntax());\n         }\n-        return (InsertPosition::First, AddBlankLine::AfterTwice);\n+        return;\n     }\n \n     // Iterator that discards anything thats not in the required grouping\n@@ -572,43 +464,83 @@ fn find_insert_position(\n     // track the last element we iterated over, if this is still None after the iteration then that means we never iterated in the first place\n     let mut last = None;\n     // find the element that would come directly after our new import\n-    let post_insert = group_iter.inspect(|(.., node)| last = Some(node.clone())).find(\n-        |&(ref path, has_tl, _)| {\n+    let post_insert: Option<(_, _, SyntaxNode)> = group_iter\n+        .inspect(|(.., node)| last = Some(node.clone()))\n+        .find(|&(ref path, has_tl, _)| {\n             use_tree_path_cmp(&insert_path, false, path, has_tl) != Ordering::Greater\n-        },\n-    );\n+        });\n \n-    match post_insert {\n+    if let Some((.., node)) = post_insert {\n         // insert our import before that element\n-        Some((.., node)) => (InsertPosition::Before(node.into()), AddBlankLine::After),\n+        return ted::insert(ted::Position::before(node), use_item.syntax());\n+    }\n+    if let Some(node) = last {\n         // there is no element after our new import, so append it to the end of the group\n-        None => match last {\n-            Some(node) => (InsertPosition::After(node.into()), AddBlankLine::Before),\n-            // the group we were looking for actually doesnt exist, so insert\n+        return ted::insert(ted::Position::after(node), use_item.syntax());\n+    }\n+\n+    // the group we were looking for actually doesn't exist, so insert\n+\n+    let mut last = None;\n+    // find the group that comes after where we want to insert\n+    let post_group = path_node_iter\n+        .inspect(|(.., node)| last = Some(node.clone()))\n+        .find(|(p, ..)| ImportGroup::new(p) > group);\n+    if let Some((.., node)) = post_group {\n+        ted::insert(ted::Position::before(&node), use_item.syntax());\n+        if let Some(node) = algo::non_trivia_sibling(node.into(), Direction::Prev) {\n+            ted::insert(ted::Position::after(node), make::tokens::single_newline());\n+        }\n+        return;\n+    }\n+    // there is no such group, so append after the last one\n+    if let Some(node) = last {\n+        ted::insert(ted::Position::after(&node), use_item.syntax());\n+        ted::insert(ted::Position::after(node), make::tokens::single_newline());\n+        return;\n+    }\n+    // there are no imports in this file at all\n+    if let Some(last_inner_element) = scope_syntax\n+        .children_with_tokens()\n+        .filter(|child| match child {\n+            NodeOrToken::Node(node) => is_inner_attribute(node.clone()),\n+            NodeOrToken::Token(token) => is_inner_comment(token.clone()),\n+        })\n+        .last()\n+    {\n+        ted::insert(ted::Position::after(&last_inner_element), use_item.syntax());\n+        ted::insert(ted::Position::after(last_inner_element), make::tokens::single_newline());\n+        return;\n+    }\n+    match scope {\n+        ImportScope::File(_) => {\n+            ted::insert(ted::Position::first_child_of(scope_syntax), make::tokens::blank_line());\n+            ted::insert(ted::Position::first_child_of(scope_syntax), use_item.syntax())\n+        }\n+        // don't insert the imports before the item list's opening curly brace\n+        ImportScope::Module(item_list) => match item_list.l_curly_token() {\n+            Some(b) => {\n+                ted::insert(ted::Position::after(&b), make::tokens::single_newline());\n+                ted::insert(ted::Position::after(&b), use_item.syntax());\n+            }\n             None => {\n-                // similar concept here to the `last` from above\n-                let mut last = None;\n-                // find the group that comes after where we want to insert\n-                let post_group = path_node_iter\n-                    .inspect(|(.., node)| last = Some(node.clone()))\n-                    .find(|(p, ..)| ImportGroup::new(p) > group);\n-                match post_group {\n-                    Some((.., node)) => {\n-                        (InsertPosition::Before(node.into()), AddBlankLine::AfterTwice)\n-                    }\n-                    // there is no such group, so append after the last one\n-                    None => match last {\n-                        Some(node) => {\n-                            (InsertPosition::After(node.into()), AddBlankLine::BeforeTwice)\n-                        }\n-                        // there are no imports in this file at all\n-                        None => scope.insert_pos_after_last_inner_element(),\n-                    },\n-                }\n+                ted::insert(\n+                    ted::Position::first_child_of(scope_syntax),\n+                    make::tokens::blank_line(),\n+                );\n+                ted::insert(ted::Position::first_child_of(scope_syntax), use_item.syntax());\n             }\n         },\n     }\n }\n \n+fn is_inner_attribute(node: SyntaxNode) -> bool {\n+    ast::Attr::cast(node).map(|attr| attr.kind()) == Some(ast::AttrKind::Inner)\n+}\n+\n+fn is_inner_comment(token: SyntaxToken) -> bool {\n+    ast::Comment::cast(token).and_then(|comment| comment.kind().doc)\n+        == Some(ast::CommentPlacement::Inner)\n+}\n #[cfg(test)]\n mod tests;"}, {"sha": "a3464d606b6eeeff8dcd1f4f44769146156862af", "filename": "crates/ide_db/src/helpers/insert_use/tests.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fa20a5064be85349d2d05abcd66f5662d3aecb0c/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa20a5064be85349d2d05abcd66f5662d3aecb0c/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Finsert_use%2Ftests.rs?ref=fa20a5064be85349d2d05abcd66f5662d3aecb0c", "patch": "@@ -51,17 +51,16 @@ use std::bar::G;\",\n \n #[test]\n fn insert_start_indent() {\n-    cov_mark::check!(insert_use_indent_after);\n     check_none(\n         \"std::bar::AA\",\n         r\"\n     use std::bar::B;\n-    use std::bar::D;\",\n+    use std::bar::C;\",\n         r\"\n     use std::bar::AA;\n     use std::bar::B;\n-    use std::bar::D;\",\n-    )\n+    use std::bar::C;\",\n+    );\n }\n \n #[test]\n@@ -120,7 +119,6 @@ use std::bar::ZZ;\",\n \n #[test]\n fn insert_end_indent() {\n-    cov_mark::check!(insert_use_indent_before);\n     check_none(\n         \"std::bar::ZZ\",\n         r\"\n@@ -255,7 +253,6 @@ fn insert_empty_file() {\n \n #[test]\n fn insert_empty_module() {\n-    cov_mark::check!(insert_use_no_indent_after);\n     check(\n         \"foo::bar\",\n         \"mod x {}\",\n@@ -615,20 +612,16 @@ fn check(\n     if module {\n         syntax = syntax.descendants().find_map(ast::Module::cast).unwrap().syntax().clone();\n     }\n-    let file = super::ImportScope::from(syntax).unwrap();\n+    let file = super::ImportScope::from(syntax.clone_for_update()).unwrap();\n     let path = ast::SourceFile::parse(&format!(\"use {};\", path))\n         .tree()\n         .syntax()\n         .descendants()\n         .find_map(ast::Path::cast)\n         .unwrap();\n \n-    let rewriter = insert_use(\n-        &file,\n-        path,\n-        InsertUseConfig { merge: mb, prefix_kind: PrefixKind::Plain, group },\n-    );\n-    let result = rewriter.rewrite(file.as_syntax_node()).to_string();\n+    insert_use(&file, path, InsertUseConfig { merge: mb, prefix_kind: PrefixKind::Plain, group });\n+    let result = file.as_syntax_node().to_string();\n     assert_eq_text!(ra_fixture_after, &result);\n }\n "}, {"sha": "882e9fa09039bcce98d9539f935e0ee4884c994e", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa20a5064be85349d2d05abcd66f5662d3aecb0c/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa20a5064be85349d2d05abcd66f5662d3aecb0c/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=fa20a5064be85349d2d05abcd66f5662d3aecb0c", "patch": "@@ -598,6 +598,7 @@ pub mod tokens {\n         SOURCE_FILE\n             .tree()\n             .syntax()\n+            .clone_for_update()\n             .descendants_with_tokens()\n             .filter_map(|it| it.into_token())\n             .find(|it| it.kind() == WHITESPACE && it.text() == \"\\n\\n\")"}, {"sha": "91a06101f5984548d1558b94e1b17adc6185067f", "filename": "crates/syntax/src/ted.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fa20a5064be85349d2d05abcd66f5662d3aecb0c/crates%2Fsyntax%2Fsrc%2Fted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa20a5064be85349d2d05abcd66f5662d3aecb0c/crates%2Fsyntax%2Fsrc%2Fted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fted.rs?ref=fa20a5064be85349d2d05abcd66f5662d3aecb0c", "patch": "@@ -7,7 +7,7 @@ use std::{mem, ops::RangeInclusive};\n use parser::T;\n \n use crate::{\n-    ast::{edit::IndentLevel, make},\n+    ast::{self, edit::IndentLevel, make, AstNode},\n     SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken,\n };\n \n@@ -147,6 +147,16 @@ pub fn append_child_raw(node: &(impl Into<SyntaxNode> + Clone), child: impl Elem\n fn ws_before(position: &Position, new: &SyntaxElement) -> Option<SyntaxToken> {\n     let prev = match &position.repr {\n         PositionRepr::FirstChild(_) => return None,\n+        PositionRepr::After(it) if it.kind() == SyntaxKind::L_CURLY => {\n+            if new.kind() == SyntaxKind::USE {\n+                if let Some(item_list) = it.parent().and_then(ast::ItemList::cast) {\n+                    let mut indent = IndentLevel::from_element(&item_list.syntax().clone().into());\n+                    indent.0 += 1;\n+                    return Some(make::tokens::whitespace(&format!(\"\\n{}\", indent)));\n+                }\n+            }\n+            it\n+        }\n         PositionRepr::After(it) => it,\n     };\n     ws_between(prev, new)\n@@ -173,7 +183,10 @@ fn ws_between(left: &SyntaxElement, right: &SyntaxElement) -> Option<SyntaxToken\n     }\n \n     if right.kind() == SyntaxKind::USE {\n-        let indent = IndentLevel::from_element(left);\n+        let mut indent = IndentLevel::from_element(left);\n+        if left.kind() == SyntaxKind::USE {\n+            indent.0 = IndentLevel::from_element(right).0.max(indent.0);\n+        }\n         return Some(make::tokens::whitespace(&format!(\"\\n{}\", indent)));\n     }\n     Some(make::tokens::single_space())"}]}