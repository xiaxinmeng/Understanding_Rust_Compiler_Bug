{"sha": "c6bd7e21c6239f4bcc3892ead298641ec1422f20", "node_id": "C_kwDOAAsO6NoAKGM2YmQ3ZTIxYzYyMzlmNGJjYzM4OTJlYWQyOTg2NDFlYzE0MjJmMjA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-25T09:37:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-25T09:37:06Z"}, "message": "Auto merge of #103513 - Dylan-DPC:rollup-nn3ite2, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #98204 (Stabilize `Option::unzip()`)\n - #102587 (rustc: Use `unix_sigpipe` instead of `rustc_driver::set_sigpipe_handler`)\n - #103122 (Remove misc_cast and validate types when casting)\n - #103379 (Truncate thread names on Linux and Apple targets)\n - #103482 (Clairify Vec::capacity docs)\n - #103511 (Codegen tweaks)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "0a0704a8b40df4119f426067c355eaa837f39820", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a0704a8b40df4119f426067c355eaa837f39820"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6bd7e21c6239f4bcc3892ead298641ec1422f20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6bd7e21c6239f4bcc3892ead298641ec1422f20", "html_url": "https://github.com/rust-lang/rust/commit/c6bd7e21c6239f4bcc3892ead298641ec1422f20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6bd7e21c6239f4bcc3892ead298641ec1422f20/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31d754a1dfba4d091a05589459708f286d5a231e", "url": "https://api.github.com/repos/rust-lang/rust/commits/31d754a1dfba4d091a05589459708f286d5a231e", "html_url": "https://github.com/rust-lang/rust/commit/31d754a1dfba4d091a05589459708f286d5a231e"}, {"sha": "6aea54c0823064391d87569e6704a628b5a53465", "url": "https://api.github.com/repos/rust-lang/rust/commits/6aea54c0823064391d87569e6704a628b5a53465", "html_url": "https://github.com/rust-lang/rust/commit/6aea54c0823064391d87569e6704a628b5a53465"}], "stats": {"total": 321, "additions": 203, "deletions": 118}, "files": [{"sha": "e21c9b660444083c001c5ca26c6087d956157a36", "filename": "compiler/rustc/src/main.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c6bd7e21c6239f4bcc3892ead298641ec1422f20/compiler%2Frustc%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bd7e21c6239f4bcc3892ead298641ec1422f20/compiler%2Frustc%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc%2Fsrc%2Fmain.rs?ref=c6bd7e21c6239f4bcc3892ead298641ec1422f20", "patch": "@@ -1,3 +1,5 @@\n+#![feature(unix_sigpipe)]\n+\n // A note about jemalloc: rustc uses jemalloc when built for CI and\n // distribution. The obvious way to do this is with the `#[global_allocator]`\n // mechanism. However, for complicated reasons (see\n@@ -23,6 +25,7 @@\n // libraries. So we must reference jemalloc symbols one way or another, because\n // this file is the only object code in the rustc executable.\n \n+#[unix_sigpipe = \"sig_dfl\"]\n fn main() {\n     // See the comment at the top of this file for an explanation of this.\n     #[cfg(feature = \"jemalloc-sys\")]\n@@ -58,6 +61,5 @@ fn main() {\n         }\n     }\n \n-    rustc_driver::set_sigpipe_handler();\n     rustc_driver::main()\n }"}, {"sha": "84b89cd71a6d3047ba3fc9974b40ec6d4eee08c0", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 16, "deletions": 30, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c6bd7e21c6239f4bcc3892ead298641ec1422f20/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bd7e21c6239f4bcc3892ead298641ec1422f20/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=c6bd7e21c6239f4bcc3892ead298641ec1422f20", "patch": "@@ -337,40 +337,26 @@ pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n pub fn cast_shift_expr_rhs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n-    op: hir::BinOpKind,\n-    lhs: Bx::Value,\n-    rhs: Bx::Value,\n-) -> Bx::Value {\n-    cast_shift_rhs(bx, op, lhs, rhs)\n-}\n-\n-fn cast_shift_rhs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &mut Bx,\n-    op: hir::BinOpKind,\n     lhs: Bx::Value,\n     rhs: Bx::Value,\n ) -> Bx::Value {\n     // Shifts may have any size int on the rhs\n-    if op.is_shift() {\n-        let mut rhs_llty = bx.cx().val_ty(rhs);\n-        let mut lhs_llty = bx.cx().val_ty(lhs);\n-        if bx.cx().type_kind(rhs_llty) == TypeKind::Vector {\n-            rhs_llty = bx.cx().element_type(rhs_llty)\n-        }\n-        if bx.cx().type_kind(lhs_llty) == TypeKind::Vector {\n-            lhs_llty = bx.cx().element_type(lhs_llty)\n-        }\n-        let rhs_sz = bx.cx().int_width(rhs_llty);\n-        let lhs_sz = bx.cx().int_width(lhs_llty);\n-        if lhs_sz < rhs_sz {\n-            bx.trunc(rhs, lhs_llty)\n-        } else if lhs_sz > rhs_sz {\n-            // FIXME (#1877: If in the future shifting by negative\n-            // values is no longer undefined then this is wrong.\n-            bx.zext(rhs, lhs_llty)\n-        } else {\n-            rhs\n-        }\n+    let mut rhs_llty = bx.cx().val_ty(rhs);\n+    let mut lhs_llty = bx.cx().val_ty(lhs);\n+    if bx.cx().type_kind(rhs_llty) == TypeKind::Vector {\n+        rhs_llty = bx.cx().element_type(rhs_llty)\n+    }\n+    if bx.cx().type_kind(lhs_llty) == TypeKind::Vector {\n+        lhs_llty = bx.cx().element_type(lhs_llty)\n+    }\n+    let rhs_sz = bx.cx().int_width(rhs_llty);\n+    let lhs_sz = bx.cx().int_width(lhs_llty);\n+    if lhs_sz < rhs_sz {\n+        bx.trunc(rhs, lhs_llty)\n+    } else if lhs_sz > rhs_sz {\n+        // FIXME (#1877: If in the future shifting by negative\n+        // values is no longer undefined then this is wrong.\n+        bx.zext(rhs, lhs_llty)\n     } else {\n         rhs\n     }"}, {"sha": "71f9179d02cca4d8755242083bf1e43b0e27812a", "filename": "compiler/rustc_codegen_ssa/src/common.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6bd7e21c6239f4bcc3892ead298641ec1422f20/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bd7e21c6239f4bcc3892ead298641ec1422f20/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs?ref=c6bd7e21c6239f4bcc3892ead298641ec1422f20", "patch": "@@ -1,7 +1,6 @@\n #![allow(non_camel_case_types)]\n \n use rustc_errors::struct_span_err;\n-use rustc_hir as hir;\n use rustc_hir::LangItem;\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::{self, layout::TyAndLayout, Ty, TyCtxt};\n@@ -140,7 +139,7 @@ pub fn build_unchecked_lshift<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     lhs: Bx::Value,\n     rhs: Bx::Value,\n ) -> Bx::Value {\n-    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shl, lhs, rhs);\n+    let rhs = base::cast_shift_expr_rhs(bx, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bx, rhs);\n     bx.shl(lhs, rhs)\n@@ -152,7 +151,7 @@ pub fn build_unchecked_rshift<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     lhs: Bx::Value,\n     rhs: Bx::Value,\n ) -> Bx::Value {\n-    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shr, lhs, rhs);\n+    let rhs = base::cast_shift_expr_rhs(bx, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bx, rhs);\n     let is_signed = lhs_t.is_signed();"}, {"sha": "29b7c9b0a8832af029fd84c07812acc057143d9f", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 47, "deletions": 39, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/c6bd7e21c6239f4bcc3892ead298641ec1422f20/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bd7e21c6239f4bcc3892ead298641ec1422f20/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=c6bd7e21c6239f4bcc3892ead298641ec1422f20", "patch": "@@ -63,7 +63,9 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         }\n     }\n \n-    fn lltarget<Bx: BuilderMethods<'a, 'tcx>>(\n+    /// Get a basic block (creating it if necessary), possibly with a landing\n+    /// pad next to it.\n+    fn llbb_with_landing_pad<Bx: BuilderMethods<'a, 'tcx>>(\n         &self,\n         fx: &mut FunctionCx<'a, 'tcx, Bx>,\n         target: mir::BasicBlock,\n@@ -73,32 +75,36 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         let target_funclet = fx.cleanup_kinds[target].funclet_bb(target);\n         match (self.funclet_bb, target_funclet) {\n             (None, None) => (lltarget, false),\n-            (Some(f), Some(t_f)) if f == t_f || !base::wants_msvc_seh(fx.cx.tcx().sess) => {\n-                (lltarget, false)\n-            }\n             // jump *into* cleanup - need a landing pad if GNU, cleanup pad if MSVC\n             (None, Some(_)) => (fx.landing_pad_for(target), false),\n             (Some(_), None) => span_bug!(span, \"{:?} - jump out of cleanup?\", self.terminator),\n-            (Some(_), Some(_)) => (fx.landing_pad_for(target), true),\n+            (Some(f), Some(t_f)) => {\n+                if f == t_f || !base::wants_msvc_seh(fx.cx.tcx().sess) {\n+                    (lltarget, false)\n+                } else {\n+                    (fx.landing_pad_for(target), true)\n+                }\n+            }\n         }\n     }\n \n-    /// Create a basic block.\n-    fn llblock<Bx: BuilderMethods<'a, 'tcx>>(\n+    /// Get a basic block (creating it if necessary), possibly with cleanup\n+    /// stuff in it or next to it.\n+    fn llbb_with_cleanup<Bx: BuilderMethods<'a, 'tcx>>(\n         &self,\n         fx: &mut FunctionCx<'a, 'tcx, Bx>,\n         target: mir::BasicBlock,\n     ) -> Bx::BasicBlock {\n-        let (lltarget, is_cleanupret) = self.lltarget(fx, target);\n+        let (lltarget, is_cleanupret) = self.llbb_with_landing_pad(fx, target);\n         if is_cleanupret {\n             // MSVC cross-funclet jump - need a trampoline\n-\n-            debug!(\"llblock: creating cleanup trampoline for {:?}\", target);\n+            debug_assert!(base::wants_msvc_seh(fx.cx.tcx().sess));\n+            debug!(\"llbb_with_cleanup: creating cleanup trampoline for {:?}\", target);\n             let name = &format!(\"{:?}_cleanup_trampoline_{:?}\", self.bb, target);\n-            let trampoline = Bx::append_block(fx.cx, fx.llfn, name);\n-            let mut trampoline_bx = Bx::build(fx.cx, trampoline);\n+            let trampoline_llbb = Bx::append_block(fx.cx, fx.llfn, name);\n+            let mut trampoline_bx = Bx::build(fx.cx, trampoline_llbb);\n             trampoline_bx.cleanup_ret(self.funclet(fx).unwrap(), Some(lltarget));\n-            trampoline\n+            trampoline_llbb\n         } else {\n             lltarget\n         }\n@@ -110,10 +116,11 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         bx: &mut Bx,\n         target: mir::BasicBlock,\n     ) {\n-        let (lltarget, is_cleanupret) = self.lltarget(fx, target);\n+        let (lltarget, is_cleanupret) = self.llbb_with_landing_pad(fx, target);\n         if is_cleanupret {\n-            // micro-optimization: generate a `ret` rather than a jump\n+            // MSVC micro-optimization: generate a `ret` rather than a jump\n             // to a trampoline.\n+            debug_assert!(base::wants_msvc_seh(fx.cx.tcx().sess));\n             bx.cleanup_ret(self.funclet(fx).unwrap(), Some(lltarget));\n         } else {\n             bx.br(lltarget);\n@@ -138,7 +145,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n \n         let unwind_block = if let Some(cleanup) = cleanup.filter(|_| fn_abi.can_unwind) {\n-            Some(self.llblock(fx, cleanup))\n+            Some(self.llbb_with_cleanup(fx, cleanup))\n         } else if fx.mir[self.bb].is_cleanup\n             && fn_abi.can_unwind\n             && !base::wants_msvc_seh(fx.cx.tcx().sess)\n@@ -231,7 +238,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n                 options,\n                 line_spans,\n                 instance,\n-                Some((ret_llbb, self.llblock(fx, cleanup), self.funclet(fx))),\n+                Some((ret_llbb, self.llbb_with_cleanup(fx, cleanup), self.funclet(fx))),\n             );\n         } else {\n             bx.codegen_inline_asm(template, &operands, options, line_spans, instance, None);\n@@ -281,8 +288,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         if target_iter.len() == 1 {\n             // If there are two targets (one conditional, one fallback), emit br instead of switch\n             let (test_value, target) = target_iter.next().unwrap();\n-            let lltrue = helper.llblock(self, target);\n-            let llfalse = helper.llblock(self, targets.otherwise());\n+            let lltrue = helper.llbb_with_cleanup(self, target);\n+            let llfalse = helper.llbb_with_cleanup(self, targets.otherwise());\n             if switch_ty == bx.tcx().types.bool {\n                 // Don't generate trivial icmps when switching on bool\n                 match test_value {\n@@ -299,8 +306,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         } else {\n             bx.switch(\n                 discr.immediate(),\n-                helper.llblock(self, targets.otherwise()),\n-                target_iter.map(|(value, target)| (value, helper.llblock(self, target))),\n+                helper.llbb_with_cleanup(self, targets.otherwise()),\n+                target_iter.map(|(value, target)| (value, helper.llbb_with_cleanup(self, target))),\n             );\n         }\n     }\n@@ -530,7 +537,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let cond = bx.expect(cond, expected);\n \n         // Create the failure block and the conditional branch to it.\n-        let lltarget = helper.llblock(self, target);\n+        let lltarget = helper.llbb_with_cleanup(self, target);\n         let panic_block = bx.append_sibling_block(\"panic\");\n         if expected {\n             bx.cond_br(cond, lltarget, panic_block);\n@@ -1459,20 +1466,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 //          bar();\n                 //      }\n                 Some(&mir::TerminatorKind::Abort) => {\n-                    let cs_bb =\n+                    let cs_llbb =\n                         Bx::append_block(self.cx, self.llfn, &format!(\"cs_funclet{:?}\", bb));\n-                    let cp_bb =\n+                    let cp_llbb =\n                         Bx::append_block(self.cx, self.llfn, &format!(\"cp_funclet{:?}\", bb));\n-                    ret_llbb = cs_bb;\n+                    ret_llbb = cs_llbb;\n \n-                    let mut cs_bx = Bx::build(self.cx, cs_bb);\n-                    let cs = cs_bx.catch_switch(None, None, &[cp_bb]);\n+                    let mut cs_bx = Bx::build(self.cx, cs_llbb);\n+                    let cs = cs_bx.catch_switch(None, None, &[cp_llbb]);\n \n                     // The \"null\" here is actually a RTTI type descriptor for the\n                     // C++ personality function, but `catch (...)` has no type so\n                     // it's null. The 64 here is actually a bitfield which\n                     // represents that this is a catch-all block.\n-                    let mut cp_bx = Bx::build(self.cx, cp_bb);\n+                    let mut cp_bx = Bx::build(self.cx, cp_llbb);\n                     let null = cp_bx.const_null(\n                         cp_bx.type_i8p_ext(cp_bx.cx().data_layout().instruction_address_space),\n                     );\n@@ -1481,30 +1488,31 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     cp_bx.br(llbb);\n                 }\n                 _ => {\n-                    let cleanup_bb =\n+                    let cleanup_llbb =\n                         Bx::append_block(self.cx, self.llfn, &format!(\"funclet_{:?}\", bb));\n-                    ret_llbb = cleanup_bb;\n-                    let mut cleanup_bx = Bx::build(self.cx, cleanup_bb);\n+                    ret_llbb = cleanup_llbb;\n+                    let mut cleanup_bx = Bx::build(self.cx, cleanup_llbb);\n                     funclet = cleanup_bx.cleanup_pad(None, &[]);\n                     cleanup_bx.br(llbb);\n                 }\n             }\n             self.funclets[bb] = Some(funclet);\n             ret_llbb\n         } else {\n-            let bb = Bx::append_block(self.cx, self.llfn, \"cleanup\");\n-            let mut bx = Bx::build(self.cx, bb);\n+            let cleanup_llbb = Bx::append_block(self.cx, self.llfn, \"cleanup\");\n+            let mut cleanup_bx = Bx::build(self.cx, cleanup_llbb);\n \n             let llpersonality = self.cx.eh_personality();\n             let llretty = self.landing_pad_type();\n-            let lp = bx.cleanup_landing_pad(llretty, llpersonality);\n+            let lp = cleanup_bx.cleanup_landing_pad(llretty, llpersonality);\n \n-            let slot = self.get_personality_slot(&mut bx);\n-            slot.storage_live(&mut bx);\n-            Pair(bx.extract_value(lp, 0), bx.extract_value(lp, 1)).store(&mut bx, slot);\n+            let slot = self.get_personality_slot(&mut cleanup_bx);\n+            slot.storage_live(&mut cleanup_bx);\n+            Pair(cleanup_bx.extract_value(lp, 0), cleanup_bx.extract_value(lp, 1))\n+                .store(&mut cleanup_bx, slot);\n \n-            bx.br(llbb);\n-            bx.llbb()\n+            cleanup_bx.br(llbb);\n+            cleanup_llbb\n         }\n     }\n "}, {"sha": "da9aaf00ecf6e83f4e9c62af5df4e1d054d5a08c", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c6bd7e21c6239f4bcc3892ead298641ec1422f20/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bd7e21c6239f4bcc3892ead298641ec1422f20/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=c6bd7e21c6239f4bcc3892ead298641ec1422f20", "patch": "@@ -148,10 +148,10 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     let debug_context = cx.create_function_debug_context(instance, &fn_abi, llfn, &mir);\n \n     let start_llbb = Bx::append_block(cx, llfn, \"start\");\n-    let mut bx = Bx::build(cx, start_llbb);\n+    let mut start_bx = Bx::build(cx, start_llbb);\n \n     if mir.basic_blocks.iter().any(|bb| bb.is_cleanup) {\n-        bx.set_personality_fn(cx.eh_personality());\n+        start_bx.set_personality_fn(cx.eh_personality());\n     }\n \n     let cleanup_kinds = analyze::cleanup_kinds(&mir);\n@@ -180,7 +180,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         caller_location: None,\n     };\n \n-    fx.per_local_var_debug_info = fx.compute_per_local_var_debug_info(&mut bx);\n+    fx.per_local_var_debug_info = fx.compute_per_local_var_debug_info(&mut start_bx);\n \n     // Evaluate all required consts; codegen later assumes that CTFE will never fail.\n     let mut all_consts_ok = true;\n@@ -206,29 +206,29 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     // Allocate variable and temp allocas\n     fx.locals = {\n-        let args = arg_local_refs(&mut bx, &mut fx, &memory_locals);\n+        let args = arg_local_refs(&mut start_bx, &mut fx, &memory_locals);\n \n         let mut allocate_local = |local| {\n             let decl = &mir.local_decls[local];\n-            let layout = bx.layout_of(fx.monomorphize(decl.ty));\n+            let layout = start_bx.layout_of(fx.monomorphize(decl.ty));\n             assert!(!layout.ty.has_erasable_regions());\n \n             if local == mir::RETURN_PLACE && fx.fn_abi.ret.is_indirect() {\n                 debug!(\"alloc: {:?} (return place) -> place\", local);\n-                let llretptr = bx.get_param(0);\n+                let llretptr = start_bx.get_param(0);\n                 return LocalRef::Place(PlaceRef::new_sized(llretptr, layout));\n             }\n \n             if memory_locals.contains(local) {\n                 debug!(\"alloc: {:?} -> place\", local);\n                 if layout.is_unsized() {\n-                    LocalRef::UnsizedPlace(PlaceRef::alloca_unsized_indirect(&mut bx, layout))\n+                    LocalRef::UnsizedPlace(PlaceRef::alloca_unsized_indirect(&mut start_bx, layout))\n                 } else {\n-                    LocalRef::Place(PlaceRef::alloca(&mut bx, layout))\n+                    LocalRef::Place(PlaceRef::alloca(&mut start_bx, layout))\n                 }\n             } else {\n                 debug!(\"alloc: {:?} -> operand\", local);\n-                LocalRef::new_operand(&mut bx, layout)\n+                LocalRef::new_operand(&mut start_bx, layout)\n             }\n         };\n \n@@ -240,7 +240,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     };\n \n     // Apply debuginfo to the newly allocated locals.\n-    fx.debug_introduce_locals(&mut bx);\n+    fx.debug_introduce_locals(&mut start_bx);\n \n     // Codegen the body of each block using reverse postorder\n     for (bb, _) in traversal::reverse_postorder(&mir) {"}, {"sha": "f980e606b932d2ae4640b6b03d4faa6741e08259", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 43, "deletions": 20, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c6bd7e21c6239f4bcc3892ead298641ec1422f20/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bd7e21c6239f4bcc3892ead298641ec1422f20/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=c6bd7e21c6239f4bcc3892ead298641ec1422f20", "patch": "@@ -42,10 +42,22 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let res = self.pointer_from_exposed_address_cast(&src, cast_ty)?;\n                 self.write_immediate(res, dest)?;\n             }\n-            // FIXME: We shouldn't use `misc_cast` for these but handle them separately.\n-            IntToInt | FloatToInt | FloatToFloat | IntToFloat | FnPtrToPtr | PtrToPtr => {\n+\n+            IntToInt | IntToFloat => {\n                 let src = self.read_immediate(src)?;\n-                let res = self.misc_cast(&src, cast_ty)?;\n+                let res = self.int_to_int_or_float(&src, cast_ty)?;\n+                self.write_immediate(res, dest)?;\n+            }\n+\n+            FloatToFloat | FloatToInt => {\n+                let src = self.read_immediate(src)?;\n+                let res = self.float_to_float_or_int(&src, cast_ty)?;\n+                self.write_immediate(res, dest)?;\n+            }\n+\n+            FnPtrToPtr | PtrToPtr => {\n+                let src = self.read_immediate(&src)?;\n+                let res = self.ptr_to_ptr(&src, cast_ty)?;\n                 self.write_immediate(res, dest)?;\n             }\n \n@@ -126,13 +138,27 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn misc_cast(\n+    pub fn int_to_int_or_float(\n+        &mut self,\n+        src: &ImmTy<'tcx, M::Provenance>,\n+        cast_ty: Ty<'tcx>,\n+    ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n+        if (src.layout.ty.is_integral() || src.layout.ty.is_char() || src.layout.ty.is_bool())\n+            && (cast_ty.is_floating_point() || cast_ty.is_integral() || cast_ty.is_char())\n+        {\n+            let scalar = src.to_scalar();\n+            Ok(self.cast_from_int_like(scalar, src.layout, cast_ty)?.into())\n+        } else {\n+            bug!(\"Unexpected cast from type {:?}\", src.layout.ty)\n+        }\n+    }\n+\n+    pub fn float_to_float_or_int(\n         &mut self,\n         src: &ImmTy<'tcx, M::Provenance>,\n         cast_ty: Ty<'tcx>,\n     ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n         use rustc_type_ir::sty::TyKind::*;\n-        trace!(\"Casting {:?}: {:?} to {:?}\", *src, src.layout.ty, cast_ty);\n \n         match src.layout.ty.kind() {\n             // Floating point\n@@ -142,19 +168,18 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Float(FloatTy::F64) => {\n                 return Ok(self.cast_from_float(src.to_scalar().to_f64()?, cast_ty).into());\n             }\n-            // The rest is integer/pointer-\"like\", including fn ptr casts\n-            _ => assert!(\n-                src.layout.ty.is_bool()\n-                    || src.layout.ty.is_char()\n-                    || src.layout.ty.is_integral()\n-                    || src.layout.ty.is_any_ptr(),\n-                \"Unexpected cast from type {:?}\",\n-                src.layout.ty\n-            ),\n+            _ => {\n+                bug!(\"Can't cast 'Float' type into {:?}\", cast_ty);\n+            }\n         }\n+    }\n \n-        // # First handle non-scalar source values.\n-\n+    /// Handles 'FnPtrToPtr' and 'PtrToPtr' casts.\n+    pub fn ptr_to_ptr(\n+        &mut self,\n+        src: &ImmTy<'tcx, M::Provenance>,\n+        cast_ty: Ty<'tcx>,\n+    ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n         // Handle casting any ptr to raw ptr (might be a fat ptr).\n         if src.layout.ty.is_any_ptr() && cast_ty.is_unsafe_ptr() {\n             let dest_layout = self.layout_of(cast_ty)?;\n@@ -178,11 +203,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Immediate::Uninit => throw_ub!(InvalidUninitBytes(None)),\n                 };\n             }\n+        } else {\n+            bug!(\"Can't cast 'Ptr' or 'FnPtr' into {:?}\", cast_ty);\n         }\n-\n-        // # The remaining source values are scalar and \"int-like\".\n-        let scalar = src.to_scalar();\n-        Ok(self.cast_from_int_like(scalar, src.layout, cast_ty)?.into())\n     }\n \n     pub fn pointer_expose_address_cast("}, {"sha": "7f78d963e9f0ad74913c69e2cc864a7bfdb2d2ce", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c6bd7e21c6239f4bcc3892ead298641ec1422f20/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bd7e21c6239f4bcc3892ead298641ec1422f20/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=c6bd7e21c6239f4bcc3892ead298641ec1422f20", "patch": "@@ -556,21 +556,36 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 check_kinds!(a, \"Cannot shallow init type {:?}\", ty::RawPtr(..));\n             }\n             Rvalue::Cast(kind, operand, target_type) => {\n+                let op_ty = operand.ty(self.body, self.tcx);\n                 match kind {\n                     CastKind::DynStar => {\n                         // FIXME(dyn-star): make sure nothing needs to be done here.\n                     }\n-                    // Nothing to check here\n+                    // FIXME: Add Checks for these\n                     CastKind::PointerFromExposedAddress\n                     | CastKind::PointerExposeAddress\n                     | CastKind::Pointer(_) => {}\n-                    _ => {\n-                        let op_ty = operand.ty(self.body, self.tcx);\n-                        if op_ty.is_enum() {\n+                    CastKind::IntToInt | CastKind::IntToFloat => {\n+                        let input_valid = op_ty.is_integral() || op_ty.is_char() || op_ty.is_bool();\n+                        let target_valid = target_type.is_numeric() || target_type.is_char();\n+                        if !input_valid || !target_valid {\n+                            self.fail(\n+                                location,\n+                                format!(\"Wrong cast kind {kind:?} for the type {op_ty}\",),\n+                            );\n+                        }\n+                    }\n+                    CastKind::FnPtrToPtr | CastKind::PtrToPtr => {\n+                        if !(op_ty.is_any_ptr() && target_type.is_unsafe_ptr()) {\n+                            self.fail(location, \"Can't cast {op_ty} into 'Ptr'\");\n+                        }\n+                    }\n+                    CastKind::FloatToFloat | CastKind::FloatToInt => {\n+                        if !op_ty.is_floating_point() || !target_type.is_numeric() {\n                             self.fail(\n                                 location,\n                                 format!(\n-                                    \"enum -> int casts should go through `Rvalue::Discriminant`: {operand:?}:{op_ty} as {target_type}\",\n+                                    \"Trying to cast non 'Float' as {kind:?} into {target_type:?}\"\n                                 ),\n                             );\n                         }"}, {"sha": "bbbdc3aa2a2d36885d8cd4ca11f3a8816797e8cb", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c6bd7e21c6239f4bcc3892ead298641ec1422f20/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bd7e21c6239f4bcc3892ead298641ec1422f20/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=c6bd7e21c6239f4bcc3892ead298641ec1422f20", "patch": "@@ -868,13 +868,14 @@ impl<T, A: Allocator> Vec<T, A> {\n         (ptr, len, capacity, alloc)\n     }\n \n-    /// Returns the number of elements the vector can hold without\n+    /// Returns the total number of elements the vector can hold without\n     /// reallocating.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// let vec: Vec<i32> = Vec::with_capacity(10);\n+    /// let mut vec: Vec<i32> = Vec::with_capacity(10);\n+    /// vec.push(42);\n     /// assert_eq!(vec.capacity(), 10);\n     /// ```\n     #[inline]"}, {"sha": "a81dbc6924fb737a3d9891bd7099f6f89ec7a24c", "filename": "library/core/src/option.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c6bd7e21c6239f4bcc3892ead298641ec1422f20/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bd7e21c6239f4bcc3892ead298641ec1422f20/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=c6bd7e21c6239f4bcc3892ead298641ec1422f20", "patch": "@@ -1713,17 +1713,20 @@ impl<T, U> Option<(T, U)> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(unzip_option)]\n-    ///\n     /// let x = Some((1, \"hi\"));\n     /// let y = None::<(u8, u32)>;\n     ///\n     /// assert_eq!(x.unzip(), (Some(1), Some(\"hi\")));\n     /// assert_eq!(y.unzip(), (None, None));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"unzip_option\", issue = \"87800\", reason = \"recently added\")]\n-    pub const fn unzip(self) -> (Option<T>, Option<U>) {\n+    #[stable(feature = \"unzip_option\", since = \"CURRENT_RUSTC_VERSION\")]\n+    #[rustc_const_unstable(feature = \"const_option\", issue = \"67441\")]\n+    pub const fn unzip(self) -> (Option<T>, Option<U>)\n+    where\n+        T: ~const Destruct,\n+        U: ~const Destruct,\n+    {\n         match self {\n             Some((a, b)) => (Some(a), Some(b)),\n             None => (None, None),"}, {"sha": "51f858adee167edd4453843ef226f3c564a8536b", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c6bd7e21c6239f4bcc3892ead298641ec1422f20/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bd7e21c6239f4bcc3892ead298641ec1422f20/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=c6bd7e21c6239f4bcc3892ead298641ec1422f20", "patch": "@@ -95,7 +95,6 @@\n #![feature(strict_provenance_atomic_ptr)]\n #![feature(trusted_random_access)]\n #![feature(unsize)]\n-#![feature(unzip_option)]\n #![feature(const_array_from_ref)]\n #![feature(const_slice_from_ref)]\n #![feature(waker_getters)]"}, {"sha": "69cd2b500a1f0819cf0aac85f6deb0aa8db73a6d", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c6bd7e21c6239f4bcc3892ead298641ec1422f20/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bd7e21c6239f4bcc3892ead298641ec1422f20/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=c6bd7e21c6239f4bcc3892ead298641ec1422f20", "patch": "@@ -132,8 +132,11 @@ impl Thread {\n \n     #[cfg(target_os = \"linux\")]\n     pub fn set_name(name: &CStr) {\n+        const TASK_COMM_LEN: usize = 16;\n+\n         unsafe {\n             // Available since glibc 2.12, musl 1.1.16, and uClibc 1.0.20.\n+            let name = truncate_cstr(name, TASK_COMM_LEN);\n             libc::pthread_setname_np(libc::pthread_self(), name.as_ptr());\n         }\n     }\n@@ -148,6 +151,7 @@ impl Thread {\n     #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))]\n     pub fn set_name(name: &CStr) {\n         unsafe {\n+            let name = truncate_cstr(name, libc::MAXTHREADNAMESIZE);\n             libc::pthread_setname_np(name.as_ptr());\n         }\n     }\n@@ -276,6 +280,20 @@ impl Drop for Thread {\n     }\n }\n \n+#[cfg(any(target_os = \"linux\", target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))]\n+fn truncate_cstr(cstr: &CStr, max_with_nul: usize) -> crate::borrow::Cow<'_, CStr> {\n+    use crate::{borrow::Cow, ffi::CString};\n+\n+    if cstr.to_bytes_with_nul().len() > max_with_nul {\n+        let bytes = cstr.to_bytes()[..max_with_nul - 1].to_vec();\n+        // SAFETY: the non-nul bytes came straight from a CStr.\n+        // (CString will add the terminating nul.)\n+        Cow::Owned(unsafe { CString::from_vec_unchecked(bytes) })\n+    } else {\n+        Cow::Borrowed(cstr)\n+    }\n+}\n+\n pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n     cfg_if::cfg_if! {\n         if #[cfg(any("}, {"sha": "6c9ce6fa0ddbd80b6d82c4b54158235283c7da70", "filename": "library/std/src/thread/tests.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c6bd7e21c6239f4bcc3892ead298641ec1422f20/library%2Fstd%2Fsrc%2Fthread%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bd7e21c6239f4bcc3892ead298641ec1422f20/library%2Fstd%2Fsrc%2Fthread%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Ftests.rs?ref=c6bd7e21c6239f4bcc3892ead298641ec1422f20", "patch": "@@ -37,6 +37,37 @@ fn test_named_thread() {\n         .unwrap();\n }\n \n+#[cfg(any(\n+    // Note: musl didn't add pthread_getname_np until 1.2.3\n+    all(target_os = \"linux\", target_env = \"gnu\"),\n+    target_os = \"macos\",\n+    target_os = \"ios\",\n+    target_os = \"watchos\"\n+))]\n+#[test]\n+fn test_named_thread_truncation() {\n+    use crate::ffi::CStr;\n+\n+    let long_name = crate::iter::once(\"test_named_thread_truncation\")\n+        .chain(crate::iter::repeat(\" yada\").take(100))\n+        .collect::<String>();\n+\n+    let result = Builder::new().name(long_name.clone()).spawn(move || {\n+        // Rust remembers the full thread name itself.\n+        assert_eq!(thread::current().name(), Some(long_name.as_str()));\n+\n+        // But the system is limited -- make sure we successfully set a truncation.\n+        let mut buf = vec![0u8; long_name.len() + 1];\n+        unsafe {\n+            libc::pthread_getname_np(libc::pthread_self(), buf.as_mut_ptr().cast(), buf.len());\n+        }\n+        let cstr = CStr::from_bytes_until_nul(&buf).unwrap();\n+        assert!(cstr.to_bytes().len() > 0);\n+        assert!(long_name.as_bytes().starts_with(cstr.to_bytes()));\n+    });\n+    result.unwrap().join().unwrap();\n+}\n+\n #[test]\n #[should_panic]\n fn test_invalid_named_thread() {"}, {"sha": "c1b949b1f79931de0095d18c8068cc0ec23c64e9", "filename": "src/tools/miri/src/shims/intrinsics/simd.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c6bd7e21c6239f4bcc3892ead298641ec1422f20/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6bd7e21c6239f4bcc3892ead298641ec1422f20/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fsimd.rs?ref=c6bd7e21c6239f4bcc3892ead298641ec1422f20", "patch": "@@ -437,13 +437,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     let val = match (op.layout.ty.kind(), dest.layout.ty.kind()) {\n                         // Int-to-(int|float): always safe\n                         (ty::Int(_) | ty::Uint(_), ty::Int(_) | ty::Uint(_) | ty::Float(_)) =>\n-                            this.misc_cast(&op, dest.layout.ty)?,\n+                            this.int_to_int_or_float(&op, dest.layout.ty)?,\n                         // Float-to-float: always safe\n                         (ty::Float(_), ty::Float(_)) =>\n-                            this.misc_cast(&op, dest.layout.ty)?,\n+                            this.float_to_float_or_int(&op, dest.layout.ty)?,\n                         // Float-to-int in safe mode\n                         (ty::Float(_), ty::Int(_) | ty::Uint(_)) if safe_cast =>\n-                            this.misc_cast(&op, dest.layout.ty)?,\n+                            this.float_to_float_or_int(&op, dest.layout.ty)?,\n                         // Float-to-int in unchecked mode\n                         (ty::Float(FloatTy::F32), ty::Int(_) | ty::Uint(_)) if !safe_cast =>\n                             this.float_to_int_unchecked(op.to_scalar().to_f32()?, dest.layout.ty)?.into(),"}]}