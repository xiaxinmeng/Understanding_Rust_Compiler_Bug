{"sha": "8b9e1ce75a3e1416f2db80d30f65879fd902183f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiOWUxY2U3NWEzZTE0MTZmMmRiODBkMzBmNjU4NzlmZDkwMjE4M2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-10T20:17:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-10T20:17:19Z"}, "message": "auto merge of #8430 : erickt/rust/cleanup-iterators, r=erickt\n\nThis PR does a bunch of cleaning up of various APIs. The major one is that it merges `Iterator` and `IteratorUtil`, and renames functions like `transform` into `map`. I also merged `DoubleEndedIterator` and `DoubleEndedIteratorUtil`, as well as I renamed various .consume* functions to .move_iter(). This helps to implement part of #7887.", "tree": {"sha": "07b97a6ad0d382272a978018c71c5220cece8237", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07b97a6ad0d382272a978018c71c5220cece8237"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b9e1ce75a3e1416f2db80d30f65879fd902183f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b9e1ce75a3e1416f2db80d30f65879fd902183f", "html_url": "https://github.com/rust-lang/rust/commit/8b9e1ce75a3e1416f2db80d30f65879fd902183f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b9e1ce75a3e1416f2db80d30f65879fd902183f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ba36ec62934c8b877766a6283633b6407c8d357", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ba36ec62934c8b877766a6283633b6407c8d357", "html_url": "https://github.com/rust-lang/rust/commit/2ba36ec62934c8b877766a6283633b6407c8d357"}, {"sha": "c8a93efdae48b88bf594480705a5c0aac39c75e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8a93efdae48b88bf594480705a5c0aac39c75e1", "html_url": "https://github.com/rust-lang/rust/commit/c8a93efdae48b88bf594480705a5c0aac39c75e1"}], "stats": {"total": 1299, "additions": 599, "deletions": 700}, "files": [{"sha": "5e3687d70575d3092fc46d5f9bb53553bdb40310", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -142,7 +142,7 @@ fn parse_check_line(line: &str) -> Option<~str> {\n fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n     do parse_name_value_directive(line, ~\"exec-env\").map |nv| {\n         // nv is either FOO or FOO=BAR\n-        let mut strs: ~[~str] = nv.splitn_iter('=', 1).transform(|s| s.to_owned()).collect();\n+        let mut strs: ~[~str] = nv.splitn_iter('=', 1).map(|s| s.to_owned()).collect();\n \n         match strs.len() {\n           1u => (strs.pop(), ~\"\"),"}, {"sha": "0fb64152d376c6eab42d744c83e21a3abf695979", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -350,13 +350,13 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n         fatal(~\"process did not return an error status\");\n     }\n \n-    let prefixes = expected_errors.iter().transform(|ee| {\n+    let prefixes = expected_errors.iter().map(|ee| {\n         fmt!(\"%s:%u:\", testfile.to_str(), ee.line)\n     }).collect::<~[~str]>();\n \n     fn to_lower( s : &str ) -> ~str {\n         let i = s.iter();\n-        let c : ~[char] = i.transform( |c| {\n+        let c : ~[char] = i.map( |c| {\n             if c.is_ascii() {\n                 c.to_ascii().to_lower().to_char()\n             } else {\n@@ -760,7 +760,7 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n     let cmdline = make_cmdline(\"\", args.prog, args.args);\n \n     // get bare program string\n-    let mut tvec: ~[~str] = args.prog.split_iter('/').transform(|ts| ts.to_owned()).collect();\n+    let mut tvec: ~[~str] = args.prog.split_iter('/').map(|ts| ts.to_owned()).collect();\n     let prog_short = tvec.pop();\n \n     // copy to target\n@@ -938,7 +938,7 @@ fn disassemble_extract(config: &config, _props: &TestProps,\n \n fn count_extracted_lines(p: &Path) -> uint {\n     let x = io::read_whole_file_str(&p.with_filetype(\"ll\")).unwrap();\n-    x.line_iter().len_()\n+    x.line_iter().len()\n }\n \n "}, {"sha": "63d62bd48098055c817fc71eb06d105bc288ed74", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -869,7 +869,7 @@ impl BitvSet {\n         let min = num::min(self.bitv.storage.len(), other.bitv.storage.len());\n         self.bitv.storage.slice(0, min).iter().enumerate()\n             .zip(Repeat::new(&other.bitv.storage))\n-            .transform(|((i, &w), o_store)| (i * uint::bits, w, o_store[i]))\n+            .map(|((i, &w), o_store)| (i * uint::bits, w, o_store[i]))\n     }\n \n     /// Visits each word in self or other that extends beyond the other. This\n@@ -888,11 +888,11 @@ impl BitvSet {\n         if olen < slen {\n             self.bitv.storage.slice_from(olen).iter().enumerate()\n                 .zip(Repeat::new(olen))\n-                .transform(|((i, &w), min)| (true, (i + min) * uint::bits, w))\n+                .map(|((i, &w), min)| (true, (i + min) * uint::bits, w))\n         } else {\n             other.bitv.storage.slice_from(slen).iter().enumerate()\n                 .zip(Repeat::new(slen))\n-                .transform(|((i, &w), min)| (false, (i + min) * uint::bits, w))\n+                .map(|((i, &w), min)| (false, (i + min) * uint::bits, w))\n         }\n     }\n }"}, {"sha": "19a72b0029fb2ab86b2aafb602727d7aa420c7b1", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -63,7 +63,7 @@ pub struct MutDListIterator<'self, T> {\n \n /// DList consuming iterator\n #[deriving(Clone)]\n-pub struct ConsumeIterator<T> {\n+pub struct MoveIterator<T> {\n     priv list: DList<T>\n }\n \n@@ -391,14 +391,14 @@ impl<T> DList<T> {\n \n     /// Consume the list into an iterator yielding elements by value\n     #[inline]\n-    pub fn consume_iter(self) -> ConsumeIterator<T> {\n-        ConsumeIterator{list: self}\n+    pub fn move_iter(self) -> MoveIterator<T> {\n+        MoveIterator{list: self}\n     }\n \n     /// Consume the list into an iterator yielding elements by value, in reverse\n     #[inline]\n-    pub fn consume_rev_iter(self) -> Invert<ConsumeIterator<T>> {\n-        self.consume_iter().invert()\n+    pub fn move_rev_iter(self) -> Invert<MoveIterator<T>> {\n+        self.move_iter().invert()\n     }\n }\n \n@@ -557,7 +557,7 @@ impl<'self, A> ListInsertion<A> for MutDListIterator<'self, A> {\n     }\n }\n \n-impl<A> Iterator<A> for ConsumeIterator<A> {\n+impl<A> Iterator<A> for MoveIterator<A> {\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.list.pop_front() }\n \n@@ -567,7 +567,7 @@ impl<A> Iterator<A> for ConsumeIterator<A> {\n     }\n }\n \n-impl<A> DoubleEndedIterator<A> for ConsumeIterator<A> {\n+impl<A> DoubleEndedIterator<A> for MoveIterator<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.list.pop_back() }\n }\n@@ -600,7 +600,7 @@ impl<A: Eq> Eq for DList<A> {\n \n impl<A: Clone> Clone for DList<A> {\n     fn clone(&self) -> DList<A> {\n-        self.iter().transform(|x| x.clone()).collect()\n+        self.iter().map(|x| x.clone()).collect()\n     }\n }\n \n@@ -690,7 +690,7 @@ mod tests {\n \n     #[cfg(test)]\n     fn list_from<T: Clone>(v: &[T]) -> DList<T> {\n-        v.iter().transform(|x| (*x).clone()).collect()\n+        v.iter().map(|x| (*x).clone()).collect()\n     }\n \n     #[test]\n@@ -721,7 +721,7 @@ mod tests {\n         check_links(&m);\n         let sum = v + u;\n         assert_eq!(sum.len(), m.len());\n-        for elt in sum.consume_iter() {\n+        for elt in sum.move_iter() {\n             assert_eq!(m.pop_front(), Some(elt))\n         }\n     }\n@@ -745,7 +745,7 @@ mod tests {\n         check_links(&m);\n         let sum = u + v;\n         assert_eq!(sum.len(), m.len());\n-        for elt in sum.consume_iter() {\n+        for elt in sum.move_iter() {\n             assert_eq!(m.pop_front(), Some(elt))\n         }\n     }\n@@ -770,7 +770,7 @@ mod tests {\n         m.rotate_backward(); check_links(&m);\n         m.push_front(9); check_links(&m);\n         m.rotate_forward(); check_links(&m);\n-        assert_eq!(~[3,9,5,1,2], m.consume_iter().collect());\n+        assert_eq!(~[3,9,5,1,2], m.move_iter().collect());\n     }\n \n     #[test]\n@@ -900,7 +900,7 @@ mod tests {\n         }\n         check_links(&m);\n         assert_eq!(m.len(), 3 + len * 2);\n-        assert_eq!(m.consume_iter().collect::<~[int]>(), ~[-2,0,1,2,3,4,5,6,7,8,9,0,1]);\n+        assert_eq!(m.move_iter().collect::<~[int]>(), ~[-2,0,1,2,3,4,5,6,7,8,9,0,1]);\n     }\n \n     #[test]\n@@ -911,7 +911,7 @@ mod tests {\n         m.merge(n, |a, b| a <= b);\n         assert_eq!(m.len(), len);\n         check_links(&m);\n-        let res = m.consume_iter().collect::<~[int]>();\n+        let res = m.move_iter().collect::<~[int]>();\n         assert_eq!(res, ~[-1, 0, 0, 0, 1, 3, 5, 6, 7, 2, 7, 7, 9]);\n     }\n \n@@ -927,7 +927,7 @@ mod tests {\n         m.push_back(4);\n         m.insert_ordered(3);\n         check_links(&m);\n-        assert_eq!(~[2,3,4], m.consume_iter().collect::<~[int]>());\n+        assert_eq!(~[2,3,4], m.move_iter().collect::<~[int]>());\n     }\n \n     #[test]\n@@ -1003,7 +1003,7 @@ mod tests {\n         check_links(&m);\n \n         let mut i = 0u;\n-        for (a, &b) in m.consume_iter().zip(v.iter()) {\n+        for (a, &b) in m.move_iter().zip(v.iter()) {\n             i += 1;\n             assert_eq!(a, b);\n         }\n@@ -1014,7 +1014,7 @@ mod tests {\n     fn bench_collect_into(b: &mut test::BenchHarness) {\n         let v = &[0, ..64];\n         do b.iter {\n-            let _: DList<int> = v.iter().transform(|x| *x).collect();\n+            let _: DList<int> = v.iter().map(|x| *x).collect();\n         }\n     }\n \n@@ -1075,33 +1075,33 @@ mod tests {\n     #[bench]\n     fn bench_iter(b: &mut test::BenchHarness) {\n         let v = &[0, ..128];\n-        let m: DList<int> = v.iter().transform(|&x|x).collect();\n+        let m: DList<int> = v.iter().map(|&x|x).collect();\n         do b.iter {\n-            assert!(m.iter().len_() == 128);\n+            assert!(m.iter().len() == 128);\n         }\n     }\n     #[bench]\n     fn bench_iter_mut(b: &mut test::BenchHarness) {\n         let v = &[0, ..128];\n-        let mut m: DList<int> = v.iter().transform(|&x|x).collect();\n+        let mut m: DList<int> = v.iter().map(|&x|x).collect();\n         do b.iter {\n-            assert!(m.mut_iter().len_() == 128);\n+            assert!(m.mut_iter().len() == 128);\n         }\n     }\n     #[bench]\n     fn bench_iter_rev(b: &mut test::BenchHarness) {\n         let v = &[0, ..128];\n-        let m: DList<int> = v.iter().transform(|&x|x).collect();\n+        let m: DList<int> = v.iter().map(|&x|x).collect();\n         do b.iter {\n-            assert!(m.rev_iter().len_() == 128);\n+            assert!(m.rev_iter().len() == 128);\n         }\n     }\n     #[bench]\n     fn bench_iter_mut_rev(b: &mut test::BenchHarness) {\n         let v = &[0, ..128];\n-        let mut m: DList<int> = v.iter().transform(|&x|x).collect();\n+        let mut m: DList<int> = v.iter().map(|&x|x).collect();\n         do b.iter {\n-            assert!(m.mut_rev_iter().len_() == 128);\n+            assert!(m.mut_rev_iter().len() == 128);\n         }\n     }\n }"}, {"sha": "e268e83bf3fb0653d290147ee24bb7fb1844406e", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -353,7 +353,7 @@ a literal `-`.\n */\n // XXX: stupid, unclear name\n pub fn pathify(vec: &[~str], stdin_hyphen : bool) -> ~[Option<Path>] {\n-    vec.iter().transform(|str| {\n+    vec.iter().map(|str| {\n         if stdin_hyphen && \"-\" == *str {\n             None\n         } else {"}, {"sha": "000520fe41e6e5200a4d1aea90ebe62d4c300565", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -647,7 +647,7 @@ pub mod groups {\n \n         let desc_sep = \"\\n\" + \" \".repeat(24);\n \n-        let mut rows = opts.iter().transform(|optref| {\n+        let mut rows = opts.iter().map(|optref| {\n             let OptGroup{short_name: short_name,\n                          long_name: long_name,\n                          hint: hint,"}, {"sha": "2287384b53a0e153385dd1fceac5477662d52f41", "filename": "src/libextra/json.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -948,7 +948,7 @@ impl serialize::Decoder for Decoder {\n         let name = match self.stack.pop() {\n             String(s) => s,\n             List(list) => {\n-                for v in list.consume_rev_iter() {\n+                for v in list.move_rev_iter() {\n                     self.stack.push(v);\n                 }\n                 match self.stack.pop() {\n@@ -1066,7 +1066,7 @@ impl serialize::Decoder for Decoder {\n         let len = match self.stack.pop() {\n             List(list) => {\n                 let len = list.len();\n-                for v in list.consume_rev_iter() {\n+                for v in list.move_rev_iter() {\n                     self.stack.push(v);\n                 }\n                 len\n@@ -1086,7 +1086,7 @@ impl serialize::Decoder for Decoder {\n         let len = match self.stack.pop() {\n             Object(obj) => {\n                 let len = obj.len();\n-                for (key, value) in obj.consume_iter() {\n+                for (key, value) in obj.move_iter() {\n                     self.stack.push(value);\n                     self.stack.push(String(key));\n                 }"}, {"sha": "27dfc090f8888a093fd01a766e46b7ca0bf5f8f5", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -287,7 +287,7 @@ impl Mul<BigUint, BigUint> for BigUint {\n             if n == 1 { return (*a).clone(); }\n \n             let mut carry = 0;\n-            let mut prod = do a.data.iter().transform |ai| {\n+            let mut prod = do a.data.iter().map |ai| {\n                 let (hi, lo) = BigDigit::from_uint(\n                     (*ai as uint) * (n as uint) + (carry as uint)\n                 );\n@@ -625,7 +625,7 @@ impl BigUint {\n         if n_bits == 0 || self.is_zero() { return (*self).clone(); }\n \n         let mut carry = 0;\n-        let mut shifted = do self.data.iter().transform |elem| {\n+        let mut shifted = do self.data.iter().map |elem| {\n             let (hi, lo) = BigDigit::from_uint(\n                 (*elem as uint) << n_bits | (carry as uint)\n             );"}, {"sha": "71dddc481ae37d3e3d205536d754d6020e59659a", "filename": "src/libextra/par.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpar.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -77,7 +77,7 @@ fn map_slices<A:Clone + Send,B:Clone + Send>(\n         info!(\"num_tasks: %?\", (num_tasks, futures.len()));\n         assert_eq!(num_tasks, futures.len());\n \n-        do futures.consume_iter().transform |ys| {\n+        do futures.move_iter().map |ys| {\n             let mut ys = ys;\n             ys.get()\n         }.collect()\n@@ -90,7 +90,7 @@ pub fn map<A:Clone + Send,B:Clone + Send>(\n     vec::concat(map_slices(xs, || {\n         let f = fn_factory();\n         let result: ~fn(uint, &[A]) -> ~[B] =\n-            |_, slice| slice.iter().transform(|x| f(x)).collect();\n+            |_, slice| slice.iter().map(|x| f(x)).collect();\n         result\n     }))\n }\n@@ -102,7 +102,7 @@ pub fn mapi<A:Clone + Send,B:Clone + Send>(\n     let slices = map_slices(xs, || {\n         let f = fn_factory();\n         let result: ~fn(uint, &[A]) -> ~[B] = |base, slice| {\n-            slice.iter().enumerate().transform(|(i, x)| {\n+            slice.iter().enumerate().map(|(i, x)| {\n                 f(i + base, x)\n             }).collect()\n         };"}, {"sha": "4b94219b30d537237406faad9799e06da2cfefdd", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -367,7 +367,7 @@ mod tests {\n     fn test_from_iter() {\n         let xs = ~[9u, 8, 7, 6, 5, 4, 3, 2, 1];\n \n-        let mut q: PriorityQueue<uint> = xs.rev_iter().transform(|&x| x).collect();\n+        let mut q: PriorityQueue<uint> = xs.rev_iter().map(|&x| x).collect();\n \n         for &x in xs.iter() {\n             assert_eq!(q.pop(), x);"}, {"sha": "bb9ac74bc77ac3d51563e2a6b73ec8b32859e65a", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -692,11 +692,11 @@ mod tests {\n     fn test_from_iterator() {\n         use std::iterator;\n         let v = ~[1,2,3,4,5,6,7];\n-        let deq: RingBuf<int> = v.iter().transform(|&x| x).collect();\n-        let u: ~[int] = deq.iter().transform(|&x| x).collect();\n+        let deq: RingBuf<int> = v.iter().map(|&x| x).collect();\n+        let u: ~[int] = deq.iter().map(|&x| x).collect();\n         assert_eq!(u, v);\n \n-        let mut seq = iterator::count(0u, 2).take_(256);\n+        let mut seq = iterator::count(0u, 2).take(256);\n         let deq: RingBuf<uint> = seq.collect();\n         for (i, &x) in deq.iter().enumerate() {\n             assert_eq!(2*i, x);"}, {"sha": "ac07fd2bebfbb1c1443c25863c6d5c583c64756d", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -15,7 +15,7 @@\n \n #[allow(missing_doc)];\n \n-use std::iterator::{Iterator, IteratorUtil, Enumerate, FilterMap, Invert};\n+use std::iterator::{Iterator, Enumerate, FilterMap, Invert};\n use std::util::replace;\n use std::vec::{VecIterator, VecMutIterator};\n use std::vec;\n@@ -152,12 +152,12 @@ impl<V> SmallIntMap<V> {\n     }\n \n     /// Empties the hash map, moving all values into the specified closure\n-    pub fn consume(&mut self)\n+    pub fn move_iter(&mut self)\n         -> FilterMap<(uint, Option<V>), (uint, V),\n-                Enumerate<vec::ConsumeIterator<Option<V>>>>\n+                Enumerate<vec::MoveIterator<Option<V>>>>\n     {\n         let values = replace(&mut self.v, ~[]);\n-        values.consume_iter().enumerate().filter_map(|(i, v)| {\n+        values.move_iter().enumerate().filter_map(|(i, v)| {\n             v.map_move(|v| (i, v))\n         })\n     }\n@@ -452,11 +452,11 @@ mod test_map {\n     }\n \n     #[test]\n-    fn test_consume() {\n+    fn test_move_iter() {\n         let mut m = SmallIntMap::new();\n         m.insert(1, ~2);\n         let mut called = false;\n-        for (k, v) in m.consume() {\n+        for (k, v) in m.move_iter() {\n             assert!(!called);\n             called = true;\n             assert_eq!(k, 1);"}, {"sha": "c7920e727089059032033c9bb0f0084081d34271", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -893,7 +893,7 @@ mod tests {\n         fn ile(x: &(&'static str), y: &(&'static str)) -> bool\n         {\n             // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n-            // to_ascii_consume and to_str_consume to not do a unnecessary clone.\n+            // to_ascii_move and to_str_move to not do a unnecessary clone.\n             // (Actually, could just remove the to_str_* call, but needs an deriving(Ord) on\n             // Ascii)\n             let x = x.to_ascii().to_lower().to_str_ascii();"}, {"sha": "bb59e34f98a123c11a1f3614b9199f8db908d602", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -12,7 +12,6 @@\n \n use std::{char, vec, util};\n use std::num::strconv::{SignNone,SignNeg,SignAll,int_to_str_bytes_common};\n-use std::iterator::IteratorUtil;\n \n #[deriving(Eq)]\n enum States {\n@@ -106,7 +105,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n         *dst = (*src).clone();\n     }\n \n-    for c in cap.iter().transform(|&x| x) {\n+    for c in cap.iter().map(|&x| x) {\n         let cur = c as char;\n         let mut old_state = state;\n         match state {"}, {"sha": "0d2badff4929bc185f5b722b3149d782a741a915", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -214,7 +214,7 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n     }\n \n     let names_str = str::from_bytes(file.read_bytes(names_bytes as uint - 1)); // don't read NUL\n-    let term_names: ~[~str] = names_str.split_iter('|').transform(|s| s.to_owned()).collect();\n+    let term_names: ~[~str] = names_str.split_iter('|').map(|s| s.to_owned()).collect();\n \n     file.read_byte(); // consume NUL\n "}, {"sha": "8b7332ff545a4868c9f62a1942dffe0cb4fc3c7e", "filename": "src/libextra/test.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -525,12 +525,11 @@ impl ConsoleTestState {\n }\n \n pub fn fmt_metrics(mm: &MetricMap) -> ~str {\n-    use std::iterator::IteratorUtil;\n     let v : ~[~str] = mm.iter()\n-        .transform(|(k,v)| fmt!(\"%s: %f (+/- %f)\",\n-                                *k,\n-                                v.value as float,\n-                                v.noise as float))\n+        .map(|(k,v)| fmt!(\"%s: %f (+/- %f)\",\n+                          *k,\n+                          v.value as float,\n+                          v.noise as float))\n         .collect();\n     v.connect(\", \")\n }\n@@ -698,7 +697,7 @@ fn run_tests(opts: &TestOpts,\n \n     // All benchmarks run at the end, in serial.\n     // (this includes metric fns)\n-    for b in filtered_benchs_and_metrics.consume_iter() {\n+    for b in filtered_benchs_and_metrics.move_iter() {\n         callback(TeWait(b.desc.clone()));\n         run_test(!opts.run_benchmarks, b, ch.clone());\n         let (test, result) = p.recv();\n@@ -744,7 +743,7 @@ pub fn filter_tests(\n             }\n         }\n \n-        filtered.consume_iter().filter_map(|x| filter_fn(x, filter_str)).collect()\n+        filtered.move_iter().filter_map(|x| filter_fn(x, filter_str)).collect()\n     };\n \n     // Maybe pull out the ignored test and unignore them\n@@ -762,7 +761,7 @@ pub fn filter_tests(\n                 None\n             }\n         };\n-        filtered.consume_iter().filter_map(|x| filter(x)).collect()\n+        filtered.move_iter().filter_map(|x| filter(x)).collect()\n     };\n \n     // Sort the tests alphabetically"}, {"sha": "424492a3cfea4d258524d386ddfb9f63f9f9c71e", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -213,13 +213,13 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n     }\n \n     /// Get a lazy iterator that consumes the treemap.\n-    pub fn consume_iter(self) -> TreeMapConsumeIterator<K, V> {\n+    pub fn move_iter(self) -> TreeMapMoveIterator<K, V> {\n         let TreeMap { root: root, length: length } = self;\n         let stk = match root {\n             None => ~[],\n             Some(~tn) => ~[tn]\n         };\n-        TreeMapConsumeIterator {\n+        TreeMapMoveIterator {\n             stack: stk,\n             remaining: length\n         }\n@@ -331,12 +331,12 @@ fn iter_traverse_complete<'a, K, V>(it: &mut TreeMapIterator<'a, K, V>) {\n }\n \n /// Lazy forward iterator over a map that consumes the map while iterating\n-pub struct TreeMapConsumeIterator<K, V> {\n+pub struct TreeMapMoveIterator<K, V> {\n     priv stack: ~[TreeNode<K, V>],\n     priv remaining: uint\n }\n \n-impl<K, V> Iterator<(K, V)> for TreeMapConsumeIterator<K,V> {\n+impl<K, V> Iterator<(K, V)> for TreeMapMoveIterator<K,V> {\n     #[inline]\n     fn next(&mut self) -> Option<(K, V)> {\n         while !self.stack.is_empty() {\n@@ -1259,7 +1259,7 @@ mod test_treemap {\n     fn test_from_iter() {\n         let xs = ~[(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n-        let map: TreeMap<int, int> = xs.iter().transform(|&x| x).collect();\n+        let map: TreeMap<int, int> = xs.iter().map(|&x| x).collect();\n \n         for &(k, v) in xs.iter() {\n             assert_eq!(map.find(&k), Some(&v));\n@@ -1558,7 +1558,7 @@ mod test_set {\n     fn test_from_iter() {\n         let xs = ~[1, 2, 3, 4, 5, 6, 7, 8, 9];\n \n-        let set: TreeSet<int> = xs.iter().transform(|&x| x).collect();\n+        let set: TreeSet<int> = xs.iter().map(|&x| x).collect();\n \n         for x in xs.iter() {\n             assert!(set.contains(x));"}, {"sha": "b8f81a44759cecfaf4bd90fc8b979e8f84c8f79e", "filename": "src/librust/rust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrust%2Frust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrust%2Frust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -128,7 +128,7 @@ fn rustc_help() {\n }\n \n fn find_cmd(command_string: &str) -> Option<Command> {\n-    do COMMANDS.iter().find_ |command| {\n+    do COMMANDS.iter().find |command| {\n         command.cmd == command_string\n     }.map_move(|x| *x)\n }"}, {"sha": "5da769a60d75cd167b31999d2add104565391352", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -935,7 +935,7 @@ pub fn link_args(sess: Session,\n     // Add all the link args for external crates.\n     do cstore::iter_crate_data(cstore) |crate_num, _| {\n         let link_args = csearch::get_link_args_for_crate(cstore, crate_num);\n-        for link_arg in link_args.consume_iter() {\n+        for link_arg in link_args.move_iter() {\n             args.push(link_arg);\n         }\n     }"}, {"sha": "e7706815ff537da1752edf18df269cb682097a4d", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -14,7 +14,7 @@ use metadata::cstore;\n use metadata::filesearch;\n \n use std::hashmap::HashSet;\n-use std::{num, os, path, uint, util, vec};\n+use std::{os, util, vec};\n \n fn not_win32(os: session::os) -> bool {\n   os != session::os_win32\n@@ -49,7 +49,7 @@ fn get_sysroot_absolute_rt_lib(sess: session::Session) -> Path {\n }\n \n pub fn rpaths_to_flags(rpaths: &[Path]) -> ~[~str] {\n-    rpaths.iter().transform(|rpath| fmt!(\"-Wl,-rpath,%s\",rpath.to_str())).collect()\n+    rpaths.iter().map(|rpath| fmt!(\"-Wl,-rpath,%s\",rpath.to_str())).collect()\n }\n \n fn get_rpaths(os: session::os,\n@@ -100,7 +100,7 @@ fn get_rpaths(os: session::os,\n fn get_rpaths_relative_to_output(os: session::os,\n                                  output: &Path,\n                                  libs: &[Path]) -> ~[Path] {\n-    libs.iter().transform(|a| get_rpath_relative_to_output(os, output, a)).collect()\n+    libs.iter().map(|a| get_rpath_relative_to_output(os, output, a)).collect()\n }\n \n pub fn get_rpath_relative_to_output(os: session::os,\n@@ -123,7 +123,7 @@ pub fn get_rpath_relative_to_output(os: session::os,\n }\n \n fn get_absolute_rpaths(libs: &[Path]) -> ~[Path] {\n-    libs.iter().transform(|a| get_absolute_rpath(a)).collect()\n+    libs.iter().map(|a| get_absolute_rpath(a)).collect()\n }\n \n pub fn get_absolute_rpath(lib: &Path) -> Path {"}, {"sha": "fdf887574695fb40663b29bf05b1747391726b00", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -120,7 +120,7 @@ pub fn build_configuration(sess: Session, argv0: @str, input: &input) ->\n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n fn parse_cfgspecs(cfgspecs: ~[~str],\n                   demitter: diagnostic::Emitter) -> ast::CrateConfig {\n-    do cfgspecs.consume_iter().transform |s| {\n+    do cfgspecs.move_iter().map |s| {\n         let sess = parse::new_parse_sess(Some(demitter));\n         parse::parse_meta_from_source_str(@\"cfgspec\", s.to_managed(), ~[], sess)\n     }.collect::<ast::CrateConfig>()\n@@ -631,7 +631,7 @@ pub fn build_session_options(binary: @str,\n         let level_name = lint::level_to_str(*level);\n \n         // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n-        // to_ascii_consume and to_str_consume to not do a unnecessary copy.\n+        // to_ascii_move and to_str_move to not do a unnecessary copy.\n         let level_short = level_name.slice_chars(0, 1);\n         let level_short = level_short.to_ascii().to_upper().to_str_ascii();\n         let flags = vec::append(getopts::opt_strs(matches, level_short),\n@@ -726,7 +726,7 @@ pub fn build_session_options(binary: @str,\n     let addl_lib_search_paths = getopts::opt_strs(matches, \"L\").map(|s| Path(*s));\n     let linker = getopts::opt_maybe_str(matches, \"linker\");\n     let linker_args = getopts::opt_strs(matches, \"link-args\").flat_map( |a| {\n-        a.split_iter(' ').transform(|arg| arg.to_owned()).collect()\n+        a.split_iter(' ').map(|arg| arg.to_owned()).collect()\n     });\n \n     let cfg = parse_cfgspecs(getopts::opt_strs(matches, \"cfg\"), demitter);\n@@ -737,7 +737,7 @@ pub fn build_session_options(binary: @str,\n     let custom_passes = match getopts::opt_maybe_str(matches, \"passes\") {\n         None => ~[],\n         Some(s) => {\n-            s.split_iter(|c: char| c == ' ' || c == ',').transform(|s| {\n+            s.split_iter(|c: char| c == ' ' || c == ',').map(|s| {\n                 s.trim().to_owned()\n             }).collect()\n         }\n@@ -946,7 +946,7 @@ pub fn build_output_filenames(input: &input,\n           let linkage_metas = attr::find_linkage_metas(attrs);\n           if !linkage_metas.is_empty() {\n               // But if a linkage meta is present, that overrides\n-              let maybe_name = linkage_metas.iter().find_(|m| \"name\" == m.name());\n+              let maybe_name = linkage_metas.iter().find(|m| \"name\" == m.name());\n               match maybe_name.chain(|m| m.value_str()) {\n                   Some(s) => stem = s,\n                   _ => ()"}, {"sha": "026532c89c3293689906de508fed2c8b2062c1ac", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -102,12 +102,12 @@ fn fold_item_underscore(cx: @Context, item: &ast::item_,\n     let item = match *item {\n         ast::item_impl(ref a, ref b, ref c, ref methods) => {\n             let methods = methods.iter().filter(|m| method_in_cfg(cx, **m))\n-                .transform(|x| *x).collect();\n+                .map(|x| *x).collect();\n             ast::item_impl((*a).clone(), (*b).clone(), (*c).clone(), methods)\n         }\n         ast::item_trait(ref a, ref b, ref methods) => {\n             let methods = methods.iter().filter(|m| trait_method_in_cfg(cx, *m) )\n-                .transform(|x| (*x).clone()).collect();\n+                .map(|x| (*x).clone()).collect();\n             ast::item_trait((*a).clone(), (*b).clone(), methods)\n         }\n         ref item => (*item).clone(),\n@@ -180,5 +180,5 @@ fn trait_method_in_cfg(cx: @Context, meth: &ast::trait_method) -> bool {\n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n fn in_cfg(cfg: &[@ast::MetaItem], attrs: &[ast::Attribute]) -> bool {\n-    attr::test_cfg(cfg, attrs.iter().transform(|x| *x))\n+    attr::test_cfg(cfg, attrs.iter().map(|x| *x))\n }"}, {"sha": "597de440ae1fc0f986bbd48f81f1a182f2b14875", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -126,7 +126,7 @@ fn fold_mod(cx: @mut TestCtxt,\n \n     let mod_nomain = ast::_mod {\n         view_items: m.view_items.clone(),\n-        items: m.items.iter().transform(|i| nomain(cx, *i)).collect(),\n+        items: m.items.iter().map(|i| nomain(cx, *i)).collect(),\n     };\n \n     fold::noop_fold_mod(&mod_nomain, fld)\n@@ -236,7 +236,7 @@ fn is_ignored(cx: @mut TestCtxt, i: @ast::item) -> bool {\n     do i.attrs.iter().any |attr| {\n         // check ignore(cfg(foo, bar))\n         \"ignore\" == attr.name() && match attr.meta_item_list() {\n-            Some(ref cfgs) => attr::test_cfg(cx.crate.config, cfgs.iter().transform(|x| *x)),\n+            Some(ref cfgs) => attr::test_cfg(cx.crate.config, cfgs.iter().map(|x| *x)),\n             None => true\n         }\n     }"}, {"sha": "82f5c4f88435a8c4a4c2641d239834870bcddf10", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -83,7 +83,7 @@ fn warn_if_multiple_versions(e: @mut Env,\n             *crate_cache[crate_cache.len() - 1].metas\n         );\n \n-        let vec: ~[Either<cache_entry, cache_entry>] = crate_cache.iter().transform(|&entry| {\n+        let vec: ~[Either<cache_entry, cache_entry>] = crate_cache.iter().map(|&entry| {\n             let othername = loader::crate_name_from_metas(*entry.metas);\n             if name == othername {\n                 Left(entry)\n@@ -183,7 +183,7 @@ fn visit_item(e: &Env, i: @ast::item) {\n         match fm.sort {\n             ast::named => {\n                 let link_name = i.attrs.iter()\n-                    .find_(|at| \"link_name\" == at.name())\n+                    .find(|at| \"link_name\" == at.name())\n                     .chain(|at| at.value_str());\n \n                 let foreign_name = match link_name {"}, {"sha": "56200a221be374716e826792984f89510277b2bc", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -11,7 +11,6 @@\n \n use std::option;\n use std::os;\n-use std::{result, str};\n use std::hashmap::HashSet;\n \n // A module for searching for libraries"}, {"sha": "8a7894efb915d97015466ea867e617cbe74eff1a", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -1204,7 +1204,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                     }\n                     c::tag_table_capture_map => {\n                         let cvars =\n-                            at_vec::to_managed_consume(\n+                            at_vec::to_managed_move(\n                                 val_dsr.read_to_vec(\n                                     |val_dsr| val_dsr.read_capture_var(xcx)));\n                         dcx.maps.capture_map.insert(id, cvars);"}, {"sha": "282292a2ac09ce52796390f042d2f08748d7da6a", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -112,23 +112,23 @@ impl CFGBuilder {\n             ast::pat_enum(_, Some(ref subpats)) |\n             ast::pat_tup(ref subpats) => {\n                 let pats_exit =\n-                    self.pats_all(subpats.iter().transform(|p| *p), pred);\n+                    self.pats_all(subpats.iter().map(|p| *p), pred);\n                 self.add_node(pat.id, [pats_exit])\n             }\n \n             ast::pat_struct(_, ref subpats, _) => {\n                 let pats_exit =\n-                    self.pats_all(subpats.iter().transform(|f| f.pat), pred);\n+                    self.pats_all(subpats.iter().map(|f| f.pat), pred);\n                 self.add_node(pat.id, [pats_exit])\n             }\n \n             ast::pat_vec(ref pre, ref vec, ref post) => {\n                 let pre_exit =\n-                    self.pats_all(pre.iter().transform(|p| *p), pred);\n+                    self.pats_all(pre.iter().map(|p| *p), pred);\n                 let vec_exit =\n-                    self.pats_all(vec.iter().transform(|p| *p), pre_exit);\n+                    self.pats_all(vec.iter().map(|p| *p), pre_exit);\n                 let post_exit =\n-                    self.pats_all(post.iter().transform(|p| *p), vec_exit);\n+                    self.pats_all(post.iter().map(|p| *p), vec_exit);\n                 self.add_node(pat.id, [post_exit])\n             }\n         }\n@@ -376,7 +376,7 @@ impl CFGBuilder {\n             ast::expr_struct(_, ref fields, base) => {\n                 let base_exit = self.opt_expr(base, pred);\n                 let field_exprs: ~[@ast::expr] =\n-                    fields.iter().transform(|f| f.expr).collect();\n+                    fields.iter().map(|f| f.expr).collect();\n                 self.straightline(expr, base_exit, field_exprs)\n             }\n "}, {"sha": "b640181515b38c0d3c9d8bd05d4550ea2f8463d5", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -169,7 +169,7 @@ pub fn check_exhaustive(cx: &MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n                     };\n                     let variants = ty::enum_variants(cx.tcx, id);\n \n-                    match variants.iter().find_(|v| v.id == vid) {\n+                    match variants.iter().find(|v| v.id == vid) {\n                         Some(v) => Some(cx.tcx.sess.str_of(v.name)),\n                         None => {\n                             fail!(\"check_exhaustive: bad variant in ctor\")\n@@ -222,7 +222,7 @@ pub enum ctor {\n pub fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n     if m.len() == 0u { return useful_; }\n     if m[0].len() == 0u { return not_useful; }\n-    let real_pat = match m.iter().find_(|r| r[0].id != 0) {\n+    let real_pat = match m.iter().find(|r| r[0].id != 0) {\n       Some(r) => r[0], None => v[0]\n     };\n     let left_ty = if real_pat.id == 0 { ty::mk_nil() }\n@@ -470,7 +470,7 @@ pub fn ctor_arity(cx: &MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n       ty::ty_enum(eid, _) => {\n           let id = match *ctor { variant(id) => id,\n           _ => fail!(\"impossible case\") };\n-        match ty::enum_variants(cx.tcx, eid).iter().find_(|v| v.id == id ) {\n+        match ty::enum_variants(cx.tcx, eid).iter().find(|v| v.id == id ) {\n             Some(v) => v.args.len(),\n             None => fail!(\"impossible case\")\n         }\n@@ -627,7 +627,7 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                         if variant(variant_id) == *ctor_id {\n                             // FIXME #4731: Is this right? --pcw\n                             let args = flds.map(|ty_field| {\n-                                match flds.iter().find_(|f|\n+                                match flds.iter().find(|f|\n                                                 f.ident == ty_field.ident) {\n                                     Some(f) => f.pat,\n                                     _ => wild()\n@@ -657,8 +657,8 @@ pub fn specialize(cx: &MatchCheckCtxt,\n                                          ty_to_str(cx.tcx, left_ty)));\n                             }\n                         }\n-                        let args = class_fields.iter().transform(|class_field| {\n-                            match flds.iter().find_(|f|\n+                        let args = class_fields.iter().map(|class_field| {\n+                            match flds.iter().find(|f|\n                                             f.ident == class_field.ident) {\n                                 Some(f) => f.pat,\n                                 _ => wild()"}, {"sha": "2de94cdbf4ccd03d2c249c1d6cd9f4f8b968b37b", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -102,7 +102,7 @@ pub fn classify(e: &expr,\n \n               ast::expr_tup(ref es) |\n               ast::expr_vec(ref es, ast::m_imm) => {\n-                join_all(es.iter().transform(|e| classify(*e, tcx)))\n+                join_all(es.iter().map(|e| classify(*e, tcx)))\n               }\n \n               ast::expr_vstore(e, vstore) => {\n@@ -116,7 +116,7 @@ pub fn classify(e: &expr,\n               }\n \n               ast::expr_struct(_, ref fs, None) => {\n-                let cs = do fs.iter().transform |f| {\n+                let cs = do fs.iter().map |f| {\n                     classify(f.expr, tcx)\n                 };\n                 join_all(cs)"}, {"sha": "3a15cbe0f5221bcb30101cd98df7fa11eed345c7", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -994,7 +994,7 @@ fn lint_session(cx: @mut Context) -> @visit::Visitor<()> {\n         match cx.tcx.sess.lints.pop(&id) {\n             None => {},\n             Some(l) => {\n-                for (lint, span, msg) in l.consume_iter() {\n+                for (lint, span, msg) in l.move_iter() {\n                     cx.span_lint(lint, span, msg)\n                 }\n             }"}, {"sha": "4d95909404e18ef33f8bc69e7630b3724575ab04", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -5366,7 +5366,7 @@ impl Resolver {\n         if idents.len() == 0 {\n             return ~\"???\";\n         }\n-        return self.idents_to_str(idents.consume_rev_iter().collect::<~[ast::ident]>());\n+        return self.idents_to_str(idents.move_rev_iter().collect::<~[ast::ident]>());\n     }\n \n     pub fn dump_module(@mut self, module_: @mut Module) {"}, {"sha": "1a9c36313df74c6d9be934577004edda112d08b3", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -588,7 +588,7 @@ fn enter_opt<'r>(bcx: @mut Block,\n                     let mut reordered_patterns = ~[];\n                     let r = ty::lookup_struct_fields(tcx, struct_id);\n                     for field in r.iter() {\n-                            match field_pats.iter().find_(|p| p.ident == field.ident) {\n+                            match field_pats.iter().find(|p| p.ident == field.ident) {\n                                 None => reordered_patterns.push(dummy),\n                                 Some(fp) => reordered_patterns.push(fp.pat)\n                             }\n@@ -648,7 +648,7 @@ fn enter_rec_or_struct<'r>(bcx: @mut Block,\n             ast::pat_struct(_, ref fpats, _) => {\n                 let mut pats = ~[];\n                 for fname in fields.iter() {\n-                    match fpats.iter().find_(|p| p.ident == *fname) {\n+                    match fpats.iter().find(|p| p.ident == *fname) {\n                         None => pats.push(dummy),\n                         Some(pat) => pats.push(pat.pat)\n                     }"}, {"sha": "a00cfa2912380a771e7b14066cc47e65e7ee5009", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -508,7 +508,7 @@ pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: uint,\n         }\n         General(ref cases) => {\n             let case = &cases[discr];\n-            let max_sz = cases.iter().transform(|x| x.size).max().unwrap();\n+            let max_sz = cases.iter().map(|x| x.size).max().unwrap();\n             let discr_ty = C_uint(ccx, discr);\n             let contents = build_const_struct(ccx, case,\n                                               ~[discr_ty] + vals);\n@@ -519,7 +519,7 @@ pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: uint,\n                 C_struct(build_const_struct(ccx, nonnull, vals))\n             } else {\n                 assert_eq!(vals.len(), 0);\n-                let vals = do nonnull.fields.iter().enumerate().transform |(i, &ty)| {\n+                let vals = do nonnull.fields.iter().enumerate().map |(i, &ty)| {\n                     let llty = type_of::sizing_type_of(ccx, ty);\n                     if i == ptrfield { C_null(llty) } else { C_undef(llty) }\n                 }.collect::<~[ValueRef]>();"}, {"sha": "762f6953bb2228aede51fac529c16359ad1db826", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -1278,7 +1278,7 @@ pub fn cleanup_and_leave(bcx: @mut Block,\n                         let mut skip = 0;\n                         let mut dest = None;\n                         {\n-                            let r = (*inf).cleanup_paths.rev_iter().find_(|cp| cp.target == leave);\n+                            let r = (*inf).cleanup_paths.rev_iter().find(|cp| cp.target == leave);\n                             for cp in r.iter() {\n                                 if cp.size == inf.cleanups.len() {\n                                     Br(bcx, cp.dest);"}, {"sha": "8ca18d81245e9ccfacc853dff039b8e422dbfa7c", "filename": "src/librustc/middle/trans/basic_block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbasic_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbasic_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbasic_block.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -29,7 +29,7 @@ impl BasicBlock {\n     pub fn pred_iter(self) -> PredIterator {\n         self.as_value().user_iter()\n             .filter(|user| user.is_a_terminator_inst())\n-            .transform(|user| user.get_parent().unwrap())\n+            .map(|user| user.get_parent().unwrap())\n     }\n \n     pub fn get_single_predecessor(self) -> Option<BasicBlock> {"}, {"sha": "8f48c00b8d6b4795e4e83efd4612f0c7afd22627", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -521,7 +521,7 @@ impl Builder {\n             }\n             self.inbounds_gep(base, small_vec.slice(0, ixs.len()))\n         } else {\n-            let v = do ixs.iter().transform |i| { C_i32(*i as i32) }.collect::<~[ValueRef]>();\n+            let v = do ixs.iter().map |i| { C_i32(*i as i32) }.collect::<~[ValueRef]>();\n             self.count_insn(\"gepi\");\n             self.inbounds_gep(base, v)\n         }"}, {"sha": "6a1905c451f97e4d99f397cc3498e841d754244e", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -37,7 +37,7 @@ pub struct FnType {\n \n impl FnType {\n     pub fn decl_fn(&self, decl: &fn(fnty: Type) -> ValueRef) -> ValueRef {\n-        let atys = self.arg_tys.iter().transform(|t| t.ty).collect::<~[Type]>();\n+        let atys = self.arg_tys.iter().map(|t| t.ty).collect::<~[Type]>();\n         let rty = self.ret_ty.ty;\n         let fnty = Type::func(atys, &rty);\n         let llfn = decl(fnty);"}, {"sha": "40a83eb9770787e8338e7471d31f4f4ee80f0c4d", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -316,7 +316,7 @@ pub struct cleanup_path {\n pub fn shrink_scope_clean(scope_info: &mut ScopeInfo, size: uint) {\n     scope_info.landing_pad = None;\n     scope_info.cleanup_paths = scope_info.cleanup_paths.iter()\n-            .take_while(|&cu| cu.size <= size).transform(|&x|x).collect();\n+            .take_while(|&cu| cu.size <= size).map(|&x|x).collect();\n }\n \n pub fn grow_scope_clean(scope_info: &mut ScopeInfo) {\n@@ -1000,7 +1000,7 @@ pub fn node_id_type_params(bcx: @mut Block, id: ast::NodeId) -> ~[ty::t] {\n \n     match bcx.fcx.param_substs {\n       Some(substs) => {\n-        do params.iter().transform |t| {\n+        do params.iter().map |t| {\n             ty::subst_tps(tcx, substs.tys, substs.self_ty, *t)\n         }.collect()\n       }\n@@ -1025,7 +1025,7 @@ pub fn resolve_vtables_under_param_substs(tcx: ty::ctxt,\n                                           param_substs: Option<@param_substs>,\n                                           vts: typeck::vtable_res)\n     -> typeck::vtable_res {\n-    @vts.iter().transform(|ds|\n+    @vts.iter().map(|ds|\n       resolve_param_vtables_under_param_substs(tcx,\n                                                param_substs,\n                                                *ds))\n@@ -1037,7 +1037,7 @@ pub fn resolve_param_vtables_under_param_substs(\n     param_substs: Option<@param_substs>,\n     ds: typeck::vtable_param_res)\n     -> typeck::vtable_param_res {\n-    @ds.iter().transform(\n+    @ds.iter().map(\n         |d| resolve_vtable_under_param_substs(tcx,\n                                               param_substs,\n                                               d))\n@@ -1063,7 +1063,7 @@ pub fn resolve_vtable_under_param_substs(tcx: ty::ctxt,\n         typeck::vtable_static(trait_id, ref tys, sub) => {\n             let tys = match param_substs {\n                 Some(substs) => {\n-                    do tys.iter().transform |t| {\n+                    do tys.iter().map |t| {\n                         ty::subst_tps(tcx, substs.tys, substs.self_ty, *t)\n                     }.collect()\n                 }"}, {"sha": "1992d71427f2053baacc7413c310324c9602202e", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -499,8 +499,8 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: &ast::expr) -> ValueRef {\n               do expr::with_field_tys(tcx, ety, Some(e.id))\n                   |discr, field_tys| {\n                   let cs: ~[ValueRef] = field_tys.iter().enumerate()\n-                      .transform(|(ix, &field_ty)| {\n-                      match fs.iter().find_(|f| field_ty.ident == f.ident) {\n+                      .map(|(ix, &field_ty)| {\n+                      match fs.iter().find(|f| field_ty.ident == f.ident) {\n                           Some(f) => const_expr(cx, (*f).expr),\n                           None => {\n                               match base_val {"}, {"sha": "1fb64d9c67130066722789673447d9139fd1b3ca", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -662,7 +662,7 @@ fn enum_metadata(cx: &mut CrateContext,\n \n     let enumerators_metadata: ~[DIDescriptor] = variants\n         .iter()\n-        .transform(|v| {\n+        .map(|v| {\n             let name: &str = cx.sess.str_of(v.name);\n             let discriminant_value = v.disr_val as c_ulonglong;\n \n@@ -709,7 +709,7 @@ fn enum_metadata(cx: &mut CrateContext,\n             let variants_member_metadata: ~[DIDescriptor] = do struct_defs\n                 .iter()\n                 .enumerate()\n-                .transform |(i, struct_def)| {\n+                .map |(i, struct_def)| {\n                     let variant_type_metadata = adt_struct_metadata(\n                         cx,\n                         struct_def,\n@@ -766,7 +766,7 @@ fn enum_metadata(cx: &mut CrateContext,\n     {\n         let arg_llvm_types: ~[Type] = do struct_def.fields.map |&ty| { type_of::type_of(cx, ty) };\n         let arg_metadata: ~[DIType] = do struct_def.fields.iter().enumerate()\n-            .transform |(i, &ty)| {\n+            .map |(i, &ty)| {\n                 match discriminant_type_metadata {\n                     Some(metadata) if i == 0 => metadata,\n                     _                        => type_metadata(cx, ty, span)\n@@ -816,7 +816,7 @@ fn composite_type_metadata(cx: &mut CrateContext,\n     let member_metadata: ~[DIDescriptor] = member_llvm_types\n         .iter()\n         .enumerate()\n-        .transform(|(i, &member_llvm_type)| {\n+        .map(|(i, &member_llvm_type)| {\n             let (member_size, member_align) = size_and_align_of(cx, member_llvm_type);\n             let member_offset = machine::llelement_offset(cx, composite_llvm_type, i);\n             let member_name: &str = member_names[i];"}, {"sha": "5931b54342f33e4d50e4c82ef7b13c122f546ff8", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -582,7 +582,7 @@ fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: @ast::expr,\n         ast::expr_tup(ref args) => {\n             let repr = adt::represent_type(bcx.ccx(), expr_ty(bcx, expr));\n             let numbered_fields: ~[(uint, @ast::expr)] =\n-                args.iter().enumerate().transform(|(i, arg)| (i, *arg)).collect();\n+                args.iter().enumerate().map(|(i, arg)| (i, *arg)).collect();\n             return trans_adt(bcx, repr, 0, numbered_fields, None, dest);\n         }\n         ast::expr_lit(@codemap::spanned {node: ast::lit_str(s), _}) => {"}, {"sha": "4cc4f8fa696d0cb1b92f5b6257351636f614a142", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -288,7 +288,7 @@ pub fn method_with_name(ccx: &mut CrateContext,\n \n     let imp = ccx.tcx.impls.find(&impl_id)\n         .expect(\"could not find impl while translating\");\n-    let meth = imp.methods.iter().find_(|m| m.ident == name)\n+    let meth = imp.methods.iter().find(|m| m.ident == name)\n         .expect(\"could not find method while translating\");\n \n     ccx.impl_method_cache.insert((impl_id, name), meth.def_id);"}, {"sha": "21ef9058069ab3154c5a3a0be766166b92b56fa2", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -245,7 +245,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n       }\n       ast_map::node_variant(ref v, enum_item, _) => {\n         let tvs = ty::enum_variants(ccx.tcx, local_def(enum_item.id));\n-        let this_tv = *tvs.iter().find_(|tv| { tv.id.node == fn_id.node}).unwrap();\n+        let this_tv = *tvs.iter().find(|tv| { tv.id.node == fn_id.node}).unwrap();\n         let d = mk_lldecl();\n         set_inline_hint(d);\n         match v.node.kind {\n@@ -366,18 +366,18 @@ pub fn make_mono_id(ccx: @mut CrateContext,\n                     param_uses: Option<@~[type_use::type_uses]>) -> mono_id {\n     // FIXME (possibly #5801): Need a lot of type hints to get\n     // .collect() to work.\n-    let substs_iter = substs.self_ty.iter().chain_(substs.tys.iter());\n+    let substs_iter = substs.self_ty.iter().chain(substs.tys.iter());\n     let precise_param_ids: ~[(ty::t, Option<@~[mono_id]>)] = match substs.vtables {\n       Some(vts) => {\n         debug!(\"make_mono_id vtables=%s substs=%s\",\n                vts.repr(ccx.tcx), substs.tys.repr(ccx.tcx));\n-        let vts_iter = substs.self_vtables.iter().chain_(vts.iter());\n-        vts_iter.zip(substs_iter).transform(|(vtable, subst)| {\n+        let vts_iter = substs.self_vtables.iter().chain(vts.iter());\n+        vts_iter.zip(substs_iter).map(|(vtable, subst)| {\n             let v = vtable.map(|vt| meth::vtable_id(ccx, vt));\n             (*subst, if !v.is_empty() { Some(@v) } else { None })\n         }).collect()\n       }\n-      None => substs_iter.transform(|subst| (*subst, None::<@~[mono_id]>)).collect()\n+      None => substs_iter.map(|subst| (*subst, None::<@~[mono_id]>)).collect()\n     };\n \n \n@@ -387,9 +387,9 @@ pub fn make_mono_id(ccx: @mut CrateContext,\n         // We just say it is fully used.\n         let self_use =\n             substs.self_ty.map(|_| type_use::use_repr|type_use::use_tydesc);\n-        let uses_iter = self_use.iter().chain_(uses.iter());\n+        let uses_iter = self_use.iter().chain(uses.iter());\n \n-        precise_param_ids.iter().zip(uses_iter).transform(|(id, uses)| {\n+        precise_param_ids.iter().zip(uses_iter).map(|(id, uses)| {\n             if ccx.sess.no_monomorphic_collapse() {\n                 match *id {\n                     (a, b) => mono_precise(a, b)\n@@ -429,7 +429,7 @@ pub fn make_mono_id(ccx: @mut CrateContext,\n         }).collect()\n       }\n       None => {\n-          precise_param_ids.iter().transform(|x| {\n+          precise_param_ids.iter().map(|x| {\n               let (a, b) = *x;\n               mono_precise(a, b)\n           }).collect()"}, {"sha": "bba5d85083b70ff6377b1f01b6417db10d485c8e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -3791,9 +3791,9 @@ pub fn substd_enum_variants(cx: ctxt,\n                             id: ast::def_id,\n                             substs: &substs)\n                          -> ~[@VariantInfo] {\n-    do enum_variants(cx, id).iter().transform |variant_info| {\n+    do enum_variants(cx, id).iter().map |variant_info| {\n         let substd_args = variant_info.args.iter()\n-            .transform(|aty| subst(cx, substs, *aty)).collect();\n+            .map(|aty| subst(cx, substs, *aty)).collect();\n \n         let substd_ctor_ty = subst(cx, substs, variant_info.ctor_ty);\n \n@@ -3935,7 +3935,7 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[@VariantInfo] {\n                     _\n                 }, _) => {\n             let mut last_discriminant: Option<uint> = None;\n-            @enum_definition.variants.iter().transform(|variant| {\n+            @enum_definition.variants.iter().map(|variant| {\n \n                 let mut discriminant = match last_discriminant {\n                     Some(val) => val + 1,\n@@ -4117,7 +4117,7 @@ pub fn lookup_struct_field(cx: ctxt,\n                            field_id: ast::def_id)\n                         -> field_ty {\n     let r = lookup_struct_fields(cx, parent);\n-    match r.iter().find_(\n+    match r.iter().find(\n                  |f| f.id.node == field_id.node) {\n         Some(t) => *t,\n         None => cx.sess.bug(\"struct ID not found in parent's fields\")"}, {"sha": "c666e98c9c15f5fab9ef218346b2bf538475af67", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -724,7 +724,7 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Clone + 'static>(\n         in_binding_rscope(rscope,\n                           RegionParamNames(bound_lifetime_names.clone()));\n \n-    let input_tys = do decl.inputs.iter().enumerate().transform |(i, a)| {\n+    let input_tys = do decl.inputs.iter().enumerate().map |(i, a)| {\n         let expected_arg_ty = do expected_sig.chain_ref |e| {\n             // no guarantee that the correct number of expected args\n             // were supplied"}, {"sha": "84e5d8f9bf7430f3a27602f3a147db732f5e34db", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -759,7 +759,7 @@ impl<'self> LookupContext<'self> {\n                                -> Option<method_map_entry> {\n         // XXX(pcwalton): Do we need to clone here?\n         let relevant_candidates: ~[Candidate] =\n-            candidates.iter().transform(|c| (*c).clone()).\n+            candidates.iter().map(|c| (*c).clone()).\n                 filter(|c| self.is_relevant(rcvr_ty, c)).collect();\n \n         let relevant_candidates = self.merge_candidates(relevant_candidates);"}, {"sha": "8bc3241256875fb9ea6e80ec9a5887c89164dd7f", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -1122,7 +1122,7 @@ pub fn lookup_field_ty(tcx: ty::ctxt,\n                        fieldname: ast::ident,\n                        substs: &ty::substs) -> Option<ty::t> {\n \n-    let o_field = items.iter().find_(|f| f.ident == fieldname);\n+    let o_field = items.iter().find(|f| f.ident == fieldname);\n     do o_field.map() |f| {\n         ty::lookup_field_type(tcx, class_id, f.id, substs)\n     }\n@@ -1818,7 +1818,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             _ => ()\n         }\n \n-        let tps : ~[ty::t] = tys.iter().transform(|ty| fcx.to_ty(ty)).collect();\n+        let tps : ~[ty::t] = tys.iter().map(|ty| fcx.to_ty(ty)).collect();\n         match method::lookup(fcx,\n                              expr,\n                              base,\n@@ -2644,7 +2644,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let mut bot_field = false;\n         let mut err_field = false;\n \n-        let elt_ts = do elts.iter().enumerate().transform |(i, e)| {\n+        let elt_ts = do elts.iter().enumerate().map |(i, e)| {\n             let opt_hint = match flds {\n                 Some(ref fs) if i < fs.len() => Some(fs[i]),\n                 _ => None"}, {"sha": "37f4a6ba49737720cb64c19a1a5313d9818b9bf6", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -100,7 +100,7 @@ fn lookup_vtables(vcx: &VtableContext,\n     let mut result =\n         substs.tps.rev_iter()\n         .zip(type_param_defs.rev_iter())\n-        .transform(|(ty, def)|\n+        .map(|(ty, def)|\n                    lookup_vtables_for_param(vcx, location_info, Some(substs),\n                                             &*def.bounds, *ty, is_early))\n         .to_owned_vec();"}, {"sha": "b93f979894db707f1a38a64b721e53050426985f", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -182,7 +182,7 @@ impl CoherenceChecker {\n                     item_impl(_, ref opt_trait, _, _) => {\n                         let opt_trait : ~[trait_ref] =\n                             opt_trait.iter()\n-                                     .transform(|x| (*x).clone())\n+                                     .map(|x| (*x).clone())\n                                      .collect();\n                         self.check_implementation(item, opt_trait);\n                     }"}, {"sha": "b5516fcc8eba6ed372992b8776740a8f5323a7c9", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -675,7 +675,7 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n     // we'll catch it in coherence\n     let trait_ms = ty::trait_methods(tcx, trait_ref.def_id);\n     for impl_m in impl_ms.iter() {\n-        match trait_ms.iter().find_(|trait_m| trait_m.ident == impl_m.mty.ident) {\n+        match trait_ms.iter().find(|trait_m| trait_m.ident == impl_m.mty.ident) {\n             Some(trait_m) => {\n                 let num_impl_tps = generics.ty_params.len();\n                 compare_impl_method(\n@@ -731,7 +731,7 @@ pub fn convert_methods(ccx: &CrateCtxt,\n                     -> ~[ConvertedMethod]\n {\n     let tcx = ccx.tcx;\n-    return ms.iter().transform(|m| {\n+    return ms.iter().map(|m| {\n         let num_rcvr_ty_params = rcvr_ty_generics.type_param_defs.len();\n         let m_ty_generics =\n             ty_generics(ccx, rcvr_ty_generics.region_param, &m.generics,"}, {"sha": "4cb6d7de0d3ddfdc3973bdcb395031edbade2684", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -156,8 +156,8 @@ Available lint options:\n \");\n \n     let lint_dict = lint::get_lint_dict();\n-    let mut lint_dict = lint_dict.consume()\n-                                 .transform(|(k, v)| (v, k))\n+    let mut lint_dict = lint_dict.move_iter()\n+                                 .map(|(k, v)| (v, k))\n                                  .collect::<~[(lint::LintSpec, &'static str)]>();\n     lint_dict.qsort();\n \n@@ -173,7 +173,7 @@ Available lint options:\n               padded(max_key, \"name\"), \"default\", \"meaning\");\n     printfln!(\"    %s  %7.7s  %s\\n\",\n               padded(max_key, \"----\"), \"-------\", \"-------\");\n-    for (spec, name) in lint_dict.consume_iter() {\n+    for (spec, name) in lint_dict.move_iter() {\n         let name = name.replace(\"_\", \"-\");\n         printfln!(\"    %s  %7.7s  %s\",\n                   padded(max_key, name),"}, {"sha": "ce8d1977443f81f6ab73189748c7829643589cde", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -27,7 +27,7 @@ pub struct CrateAttrs {\n fn doc_metas(attrs: ~[ast::Attribute]) -> ~[@ast::MetaItem] {\n     attrs.iter()\n         .filter(|at| \"doc\" == at.name())\n-        .transform(|at| at.desugar_doc().meta())\n+        .map(|at| at.desugar_doc().meta())\n         .collect()\n }\n \n@@ -41,7 +41,7 @@ pub fn parse_crate(attrs: ~[ast::Attribute]) -> CrateAttrs {\n }\n \n pub fn parse_desc(attrs: ~[ast::Attribute]) -> Option<~str> {\n-    let doc_strs = do doc_metas(attrs).consume_iter().filter_map |meta| {\n+    let doc_strs = do doc_metas(attrs).move_iter().filter_map |meta| {\n         meta.value_str()\n     }.collect::<~[@str]>();\n     if doc_strs.is_empty() {"}, {"sha": "b5503cc51e10ce755dda2345e6e32c6effd2ce24", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -123,7 +123,7 @@ fn fold_enum(\n     let doc = fold::default_seq_fold_enum(fold, doc);\n \n     doc::EnumDoc {\n-        variants: do doc.variants.iter().transform |variant| {\n+        variants: do doc.variants.iter().map |variant| {\n             let variant = (*variant).clone();\n             let desc = {\n                 let variant = variant.clone();\n@@ -133,7 +133,7 @@ fn fold_enum(\n                             node: ast::item_enum(ref enum_definition, _), _\n                         }, _) => {\n                             let ast_variant =\n-                                (*enum_definition.variants.iter().find_(|v| {\n+                                (*enum_definition.variants.iter().find(|v| {\n                                     to_str(v.node.name) == variant.name\n                                 }).unwrap()).clone();\n \n@@ -182,7 +182,7 @@ fn merge_method_attrs(\n             ast_map::node_item(@ast::item {\n                 node: ast::item_trait(_, _, ref methods), _\n             }, _) => {\n-                methods.iter().transform(|method| {\n+                methods.iter().map(|method| {\n                     match (*method).clone() {\n                         ast::required(ty_m) => {\n                             (to_str(ty_m.ident),\n@@ -197,7 +197,7 @@ fn merge_method_attrs(\n             ast_map::node_item(@ast::item {\n                 node: ast::item_impl(_, _, _, ref methods), _\n             }, _) => {\n-                methods.iter().transform(|method| {\n+                methods.iter().map(|method| {\n                     (to_str(method.ident),\n                      attr_parser::parse_desc(method.attrs.clone()))\n                 }).collect()\n@@ -206,7 +206,7 @@ fn merge_method_attrs(\n         }\n     };\n \n-    do docs.iter().zip(attrs.iter()).transform |(doc, attrs)| {\n+    do docs.iter().zip(attrs.iter()).map |(doc, attrs)| {\n         assert!(doc.name == attrs.first());\n         let desc = attrs.second();\n "}, {"sha": "877338902cc07ebf4e6b596c7d0fbcf3315708b8", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -221,7 +221,7 @@ pub fn maybe_find_pandoc(\n       }\n     };\n \n-    let pandoc = do possible_pandocs.iter().find_ |&pandoc| {\n+    let pandoc = do possible_pandocs.iter().find |&pandoc| {\n         let output = process_output(*pandoc, [~\"--version\"]);\n         debug!(\"testing pandoc cmd %s: %?\", *pandoc, output);\n         output.status == 0"}, {"sha": "55552924d4461575ba32aaca38b54f32af6527db", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -185,7 +185,7 @@ fn enumdoc_from_enum(\n fn variantdocs_from_variants(\n     variants: ~[ast::variant]\n ) -> ~[doc::VariantDoc] {\n-    variants.iter().transform(variantdoc_from_variant).collect()\n+    variants.iter().map(variantdoc_from_variant).collect()\n }\n \n fn variantdoc_from_variant(variant: &ast::variant) -> doc::VariantDoc {\n@@ -202,7 +202,7 @@ fn traitdoc_from_trait(\n ) -> doc::TraitDoc {\n     doc::TraitDoc {\n         item: itemdoc,\n-        methods: do methods.iter().transform |method| {\n+        methods: do methods.iter().map |method| {\n             match (*method).clone() {\n               ast::required(ty_m) => {\n                 doc::MethodDoc {\n@@ -238,7 +238,7 @@ fn impldoc_from_impl(\n         bounds_str: None,\n         trait_types: ~[],\n         self_ty: None,\n-        methods: do methods.iter().transform |method| {\n+        methods: do methods.iter().map |method| {\n             doc::MethodDoc {\n                 name: to_str(method.ident),\n                 brief: None,"}, {"sha": "3e74916228f00f046c034e73b94dbeabbea741cb", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -153,7 +153,7 @@ pub fn default_par_fold<T:Clone>(ctxt: T) -> Fold<T> {\n \n pub fn default_seq_fold_doc<T>(fold: &Fold<T>, doc: doc::Doc) -> doc::Doc {\n     doc::Doc {\n-        pages: do doc.pages.iter().transform |page| {\n+        pages: do doc.pages.iter().map |page| {\n             match (*page).clone() {\n               doc::CratePage(doc) => {\n                 doc::CratePage((fold.fold_crate)(fold, doc))\n@@ -189,7 +189,7 @@ pub fn default_any_fold_mod<T:Clone>(\n ) -> doc::ModDoc {\n     doc::ModDoc {\n         item: (fold.fold_item)(fold, doc.item.clone()),\n-        items: doc.items.iter().transform(|ItemTag| {\n+        items: doc.items.iter().map(|ItemTag| {\n             fold_ItemTag(fold, (*ItemTag).clone())\n         }).collect(),\n         .. doc\n@@ -202,7 +202,7 @@ pub fn default_seq_fold_mod<T>(\n ) -> doc::ModDoc {\n     doc::ModDoc {\n         item: (fold.fold_item)(fold, doc.item.clone()),\n-        items: doc.items.iter().transform(|ItemTag| {\n+        items: doc.items.iter().map(|ItemTag| {\n             fold_ItemTag(fold, (*ItemTag).clone())\n         }).collect(),\n         .. doc\n@@ -215,7 +215,7 @@ pub fn default_par_fold_mod<T:Clone>(\n ) -> doc::ModDoc {\n     doc::ModDoc {\n         item: (fold.fold_item)(fold, doc.item.clone()),\n-        items: doc.items.iter().transform(|ItemTag| {\n+        items: doc.items.iter().map(|ItemTag| {\n             fold_ItemTag(fold, (*ItemTag).clone())\n         }).collect(),\n         .. doc\n@@ -228,7 +228,7 @@ pub fn default_any_fold_nmod<T:Clone>(\n ) -> doc::NmodDoc {\n     doc::NmodDoc {\n         item: (fold.fold_item)(fold, doc.item.clone()),\n-        fns: doc.fns.iter().transform(|FnDoc| {\n+        fns: doc.fns.iter().map(|FnDoc| {\n             (fold.fold_fn)(fold, (*FnDoc).clone())\n         }).collect(),\n         .. doc\n@@ -241,7 +241,7 @@ pub fn default_seq_fold_nmod<T>(\n ) -> doc::NmodDoc {\n     doc::NmodDoc {\n         item: (fold.fold_item)(fold, doc.item.clone()),\n-        fns: doc.fns.iter().transform(|FnDoc| {\n+        fns: doc.fns.iter().map(|FnDoc| {\n             (fold.fold_fn)(fold, (*FnDoc).clone())\n         }).collect(),\n         .. doc\n@@ -254,7 +254,7 @@ pub fn default_par_fold_nmod<T:Clone>(\n ) -> doc::NmodDoc {\n     doc::NmodDoc {\n         item: (fold.fold_item)(fold, doc.item.clone()),\n-        fns: doc.fns.iter().transform(|FnDoc| {\n+        fns: doc.fns.iter().map(|FnDoc| {\n             (fold.fold_fn)(fold, (*FnDoc).clone())\n         }).collect(),\n         .. doc"}, {"sha": "342c949e3fc60957ba507c0d7105ae7394117efc", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -123,7 +123,7 @@ fn strip_mod(doc: doc::ModDoc) -> doc::ModDoc {\n               doc::ModTag(_) | doc::NmodTag(_) => false,\n               _ => true\n             }\n-        }.transform(|x| (*x).clone()).collect::<~[doc::ItemTag]>(),\n+        }.map(|x| (*x).clone()).collect::<~[doc::ItemTag]>(),\n         .. doc.clone()\n     }\n }"}, {"sha": "9dc2f43f7ac92451e98811920fa1141603204f87", "filename": "src/librustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_hidden_pass.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -43,7 +43,7 @@ fn fold_mod(\n     doc::ModDoc {\n         items: do doc.items.iter().filter |item_tag| {\n             !is_hidden(fold.ctxt.clone(), item_tag.item())\n-        }.transform(|x| (*x).clone()).collect(),\n+        }.map(|x| (*x).clone()).collect(),\n         .. doc\n     }\n }"}, {"sha": "e1bc059e20f9cc6b23bab4a4319b0c0c60885f37", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -81,7 +81,7 @@ fn strip_priv_methods(\n     item_vis: ast::visibility\n ) -> doc::ImplDoc {\n     let methods = do doc.methods.iter().filter |method| {\n-        let ast_method = do methods.iter().find_ |m| {\n+        let ast_method = do methods.iter().find |m| {\n             extract::to_str(m.ident) == method.name\n         };\n         assert!(ast_method.is_some());\n@@ -91,7 +91,7 @@ fn strip_priv_methods(\n             ast::private => false,\n             ast::inherited => item_vis == ast::public\n         }\n-    }.transform(|x| (*x).clone()).collect();\n+    }.map(|x| (*x).clone()).collect();\n \n     doc::ImplDoc {\n         methods: methods,\n@@ -126,7 +126,7 @@ fn fold_mod(\n                     is_visible(fold.ctxt.clone(), item_tag.item())\n                 }\n             }\n-        }).transform(|x| (*x).clone()).collect(),\n+        }).map(|x| (*x).clone()).collect(),\n         .. doc\n     }\n }"}, {"sha": "aa4407af76d2e2ba00bc21d220b6cc6d2d0ae893", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -124,7 +124,7 @@ fn fold_enum(\n     let srv = fold.ctxt.clone();\n \n     doc::EnumDoc {\n-        variants: do doc.variants.iter().transform |variant| {\n+        variants: do doc.variants.iter().map |variant| {\n             let sig = {\n                 let variant = (*variant).clone();\n                 do astsrv::exec(srv.clone()) |ctxt| {\n@@ -133,7 +133,7 @@ fn fold_enum(\n                             node: ast::item_enum(ref enum_definition, _), _\n                         }, _) => {\n                             let ast_variant =\n-                                (*do enum_definition.variants.iter().find_ |v| {\n+                                (*do enum_definition.variants.iter().find |v| {\n                                 to_str(v.node.name) == variant.name\n                             }.unwrap()).clone();\n \n@@ -169,7 +169,7 @@ fn merge_methods(\n     item_id: doc::AstId,\n     docs: ~[doc::MethodDoc]\n ) -> ~[doc::MethodDoc] {\n-    do docs.iter().transform |doc| {\n+    do docs.iter().map |doc| {\n         doc::MethodDoc {\n             sig: get_method_sig(srv.clone(), item_id, doc.name.clone()),\n             .. (*doc).clone()\n@@ -187,7 +187,7 @@ fn get_method_sig(\n             ast_map::node_item(@ast::item {\n                 node: ast::item_trait(_, _, ref methods), _\n             }, _) => {\n-                match methods.iter().find_(|&method| {\n+                match methods.iter().find(|&method| {\n                     match (*method).clone() {\n                         ast::required(ty_m) => to_str(ty_m.ident) == method_name,\n                         ast::provided(m) => to_str(m.ident) == method_name,\n@@ -223,7 +223,7 @@ fn get_method_sig(\n             ast_map::node_item(@ast::item {\n                 node: ast::item_impl(_, _, _, ref methods), _\n             }, _) => {\n-                match methods.iter().find_(|method| {\n+                match methods.iter().find(|method| {\n                     to_str(method.ident) == method_name\n                 }) {\n                     Some(method) => {"}, {"sha": "07af301260148db8fb0824d7b30c339716e7e6be", "filename": "src/librusti/program.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrusti%2Fprogram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrusti%2Fprogram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fprogram.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -167,7 +167,7 @@ impl Program {\n         }\n \n         let newvars = util::replace(&mut self.newvars, HashMap::new());\n-        for (name, var) in newvars.consume() {\n+        for (name, var) in newvars.move_iter() {\n             self.local_vars.insert(name, var);\n         }\n \n@@ -233,7 +233,7 @@ impl Program {\n     pub fn consume_cache(&mut self) {\n         let map = local_data::pop(tls_key).expect(\"tls is empty\");\n         let cons_map = util::replace(map, HashMap::new());\n-        for (name, value) in cons_map.consume() {\n+        for (name, value) in cons_map.move_iter() {\n             match self.local_vars.find_mut(&name) {\n                 Some(v) => { v.data = (*value).clone(); }\n                 None => { fail!(\"unknown variable %s\", name) }\n@@ -345,7 +345,7 @@ impl Program {\n \n         // I'm not an @ pointer, so this has to be done outside.\n         let cons_newvars = util::replace(newvars, HashMap::new());\n-        for (k, v) in cons_newvars.consume() {\n+        for (k, v) in cons_newvars.move_iter() {\n             self.newvars.insert(k, v);\n         }\n "}, {"sha": "29ad9eb49a3b120526aff145cdd83f9172a50331", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -315,7 +315,7 @@ fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n         // file, skip compilation and return None.\n         let mut should_compile = true;\n         let dir = os::list_dir_path(&Path(outputs.out_filename.dirname()));\n-        let maybe_lib_path = do dir.iter().find_ |file| {\n+        let maybe_lib_path = do dir.iter().find |file| {\n             // The actual file's name has a hash value and version\n             // number in it which is unknown at this time, so looking\n             // for a file that matches out_filename won't work,\n@@ -453,7 +453,7 @@ pub fn run_line(repl: &mut Repl, input: @io::Reader, out: @io::Writer, line: ~st\n     if line.starts_with(\":\") {\n         // drop the : and the \\n (one byte each)\n         let full = line.slice(1, line.len());\n-        let split: ~[~str] = full.word_iter().transform(|s| s.to_owned()).collect();\n+        let split: ~[~str] = full.word_iter().map(|s| s.to_owned()).collect();\n         let len = split.len();\n \n         if len > 0 {"}, {"sha": "ff485342fbe9871f51b2189379191dcfa8d666fc", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -55,7 +55,7 @@ impl PkgSrc {\n         let dir;\n         let dirs = pkgid_src_in_workspace(&self.id, &self.root);\n         debug!(\"Checking dirs: %?\", dirs);\n-        let path = dirs.iter().find_(|&d| os::path_exists(d));\n+        let path = dirs.iter().find(|&d| os::path_exists(d));\n         match path {\n             Some(d) => dir = (*d).clone(),\n             None => dir = match self.fetch_git() {"}, {"sha": "3ae2ad3751ffb0ddda5b09c0e128d7c74e3d3744", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -158,7 +158,7 @@ impl<'self> PkgScript<'self> {\n             let output = run::process_output(exe.to_str(), [root.to_str(), ~\"configs\"]);\n             // Run the configs() function to get the configs\n             let cfgs = str::from_bytes_slice(output.output).word_iter()\n-                .transform(|w| w.to_owned()).collect();\n+                .map(|w| w.to_owned()).collect();\n             (cfgs, output.status)\n         }\n     }"}, {"sha": "44cb8065b382b2503749be7a168eae84c34fc7ab", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -200,7 +200,7 @@ fn try_parsing_version(s: &str) -> Option<Version> {\n /// Just an approximation\n fn is_url_like(p: &Path) -> bool {\n     let str = p.to_str();\n-    str.split_iter('/').len_() > 2\n+    str.split_iter('/').len() > 2\n }\n \n /// If s is of the form foo#bar, where bar is a valid version\n@@ -215,7 +215,7 @@ pub fn split_version_general<'a>(s: &'a str, sep: char) -> Option<(&'a str, Vers\n     for st in s.split_iter(sep) {\n         debug!(\"whole = %s part = %s\", s, st);\n     }\n-    if s.split_iter(sep).len_() > 2 {\n+    if s.split_iter(sep).len() > 2 {\n         return None;\n     }\n     match s.rfind(sep) {"}, {"sha": "6ac959e4a3260fc8c4e97628f1322037ecf160e8", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -37,7 +37,7 @@ pub fn each_pkg_parent_workspace(pkgid: &PkgId, action: &fn(&Path) -> bool) -> b\n }\n \n pub fn pkg_parent_workspaces(pkgid: &PkgId) -> ~[Path] {\n-    rust_path().consume_iter()\n+    rust_path().move_iter()\n         .filter(|ws| workspace_contains_package_id(pkgid, ws))\n         .collect()\n }"}, {"sha": "c948074990a36824c9c8e9c10b09ff4eeba34cc5", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -141,11 +141,11 @@ pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> @[T] {\n  * Creates and initializes an immutable managed vector by moving all the\n  * elements from an owned vector.\n  */\n-pub fn to_managed_consume<T>(v: ~[T]) -> @[T] {\n+pub fn to_managed_move<T>(v: ~[T]) -> @[T] {\n     let mut av = @[];\n     unsafe {\n         raw::reserve(&mut av, v.len());\n-        for x in v.consume_iter() {\n+        for x in v.move_iter() {\n             raw::push(&mut av, x);\n         }\n         av\n@@ -331,12 +331,12 @@ mod test {\n     }\n \n     #[test]\n-    fn test_to_managed_consume() {\n-        assert_eq!(to_managed_consume::<int>(~[]), @[]);\n-        assert_eq!(to_managed_consume(~[true]), @[true]);\n-        assert_eq!(to_managed_consume(~[1, 2, 3, 4, 5]), @[1, 2, 3, 4, 5]);\n-        assert_eq!(to_managed_consume(~[~\"abc\", ~\"123\"]), @[~\"abc\", ~\"123\"]);\n-        assert_eq!(to_managed_consume(~[~[42]]), @[~[42]]);\n+    fn test_to_managed_move() {\n+        assert_eq!(to_managed_move::<int>(~[]), @[]);\n+        assert_eq!(to_managed_move(~[true]), @[true]);\n+        assert_eq!(to_managed_move(~[1, 2, 3, 4, 5]), @[1, 2, 3, 4, 5]);\n+        assert_eq!(to_managed_move(~[~\"abc\", ~\"123\"]), @[~\"abc\", ~\"123\"]);\n+        assert_eq!(to_managed_move(~[~[42]]), @[~[42]]);\n     }\n \n     #[test]"}, {"sha": "132ebc72960117763498599345c2f41b9d632efe", "filename": "src/libstd/either.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -150,7 +150,7 @@ pub fn rights<L, R: Clone>(eithers: &[Either<L, R>]) -> ~[R] {\n pub fn partition<L, R>(eithers: ~[Either<L, R>]) -> (~[L], ~[R]) {\n     let mut lefts: ~[L] = ~[];\n     let mut rights: ~[R] = ~[];\n-    for elt in eithers.consume_iter() {\n+    for elt in eithers.move_iter() {\n         match elt {\n             Left(l) => lefts.push(l),\n             Right(r) => rights.push(r)"}, {"sha": "7a22477685911cf9ee0a52afdc9f882b1ce3f49d", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -19,7 +19,7 @@ use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n use clone::Clone;\n use cmp::{Eq, Equiv};\n use hash::Hash;\n-use iterator::{Iterator, IteratorUtil, FromIterator, Extendable};\n+use iterator::{Iterator, FromIterator, Extendable};\n use iterator::{FilterMap, Chain, Repeat, Zip};\n use num;\n use option::{None, Option, Some};\n@@ -159,8 +159,8 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n                                   vec::from_fn(new_capacity, |_| None));\n \n         self.size = 0;\n-        // consume_rev_iter is more efficient\n-        for bucket in old_buckets.consume_rev_iter() {\n+        // move_rev_iter is more efficient\n+        for bucket in old_buckets.move_rev_iter() {\n             self.insert_opt_bucket(bucket);\n         }\n     }\n@@ -470,9 +470,9 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n     /// Creates a consuming iterator, that is, one that moves each key-value\n     /// pair out of the map in arbitrary order. The map cannot be used after\n     /// calling this.\n-    pub fn consume(self) -> HashMapConsumeIterator<K, V> {\n-        // `consume_rev_iter` is more efficient than `consume_iter` for vectors\n-        HashMapConsumeIterator {iter: self.buckets.consume_rev_iter()}\n+    pub fn move_iter(self) -> HashMapMoveIterator<K, V> {\n+        // `move_rev_iter` is more efficient than `move_iter` for vectors\n+        HashMapMoveIterator {iter: self.buckets.move_rev_iter()}\n     }\n }\n \n@@ -524,9 +524,9 @@ pub struct HashMapMutIterator<'self, K, V> {\n     priv iter: vec::VecMutIterator<'self, Option<Bucket<K, V>>>,\n }\n \n-/// HashMap consume iterator\n-pub struct HashMapConsumeIterator<K, V> {\n-    priv iter: vec::ConsumeRevIterator<Option<Bucket<K, V>>>,\n+/// HashMap move iterator\n+pub struct HashMapMoveIterator<K, V> {\n+    priv iter: vec::MoveRevIterator<Option<Bucket<K, V>>>,\n }\n \n /// HashSet iterator\n@@ -535,9 +535,9 @@ pub struct HashSetIterator<'self, K> {\n     priv iter: vec::VecIterator<'self, Option<Bucket<K, ()>>>,\n }\n \n-/// HashSet consume iterator\n-pub struct HashSetConsumeIterator<K> {\n-    priv iter: vec::ConsumeRevIterator<Option<Bucket<K, ()>>>,\n+/// HashSet move iterator\n+pub struct HashSetMoveIterator<K> {\n+    priv iter: vec::MoveRevIterator<Option<Bucket<K, ()>>>,\n }\n \n impl<'self, K, V> Iterator<(&'self K, &'self V)> for HashMapIterator<'self, K, V> {\n@@ -566,7 +566,7 @@ impl<'self, K, V> Iterator<(&'self K, &'self mut V)> for HashMapMutIterator<'sel\n     }\n }\n \n-impl<K, V> Iterator<(K, V)> for HashMapConsumeIterator<K, V> {\n+impl<K, V> Iterator<(K, V)> for HashMapMoveIterator<K, V> {\n     #[inline]\n     fn next(&mut self) -> Option<(K, V)> {\n         for elt in self.iter {\n@@ -592,7 +592,7 @@ impl<'self, K> Iterator<&'self K> for HashSetIterator<'self, K> {\n     }\n }\n \n-impl<K> Iterator<K> for HashSetConsumeIterator<K> {\n+impl<K> Iterator<K> for HashSetMoveIterator<K> {\n     #[inline]\n     fn next(&mut self) -> Option<K> {\n         for elt in self.iter {\n@@ -707,9 +707,9 @@ impl<T:Hash + Eq> HashSet<T> {\n     /// Creates a consuming iterator, that is, one that moves each value out\n     /// of the set in arbitrary order. The set cannot be used after calling\n     /// this.\n-    pub fn consume(self) -> HashSetConsumeIterator<T> {\n-        // `consume_rev_iter` is more efficient than `consume_iter` for vectors\n-        HashSetConsumeIterator {iter: self.map.buckets.consume_rev_iter()}\n+    pub fn move_iter(self) -> HashSetMoveIterator<T> {\n+        // `move_rev_iter` is more efficient than `move_iter` for vectors\n+        HashSetMoveIterator {iter: self.map.buckets.move_rev_iter()}\n     }\n \n     /// Visit the values representing the difference\n@@ -724,7 +724,7 @@ impl<T:Hash + Eq> HashSet<T> {\n     /// Visit the values representing the symmetric difference\n     pub fn symmetric_difference_iter<'a>(&'a self, other: &'a HashSet<T>)\n         -> Chain<SetAlgebraIter<'a, T>, SetAlgebraIter<'a, T>> {\n-        self.difference_iter(other).chain_(other.difference_iter(self))\n+        self.difference_iter(other).chain(other.difference_iter(self))\n     }\n \n     /// Visit the values representing the intersection\n@@ -740,7 +740,7 @@ impl<T:Hash + Eq> HashSet<T> {\n     /// Visit the values representing the union\n     pub fn union_iter<'a>(&'a self, other: &'a HashSet<T>)\n         -> Chain<HashSetIterator<'a, T>, SetAlgebraIter<'a, T>> {\n-        self.iter().chain_(other.difference_iter(self))\n+        self.iter().chain(other.difference_iter(self))\n     }\n \n }\n@@ -881,7 +881,7 @@ mod test_map {\n     }\n \n     #[test]\n-    fn test_consume() {\n+    fn test_move_iter() {\n         let hm = {\n             let mut hm = HashMap::new();\n \n@@ -891,7 +891,7 @@ mod test_map {\n             hm\n         };\n \n-        let v = hm.consume().collect::<~[(char, int)]>();\n+        let v = hm.move_iter().collect::<~[(char, int)]>();\n         assert!([('a', 1), ('b', 2)] == v || [('b', 2), ('a', 1)] == v);\n     }\n \n@@ -977,7 +977,7 @@ mod test_map {\n     fn test_from_iter() {\n         let xs = ~[(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n-        let map: HashMap<int, int> = xs.iter().transform(|&x| x).collect();\n+        let map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n \n         for &(k, v) in xs.iter() {\n             assert_eq!(map.find(&k), Some(&v));\n@@ -1169,15 +1169,15 @@ mod test_set {\n     fn test_from_iter() {\n         let xs = ~[1, 2, 3, 4, 5, 6, 7, 8, 9];\n \n-        let set: HashSet<int> = xs.iter().transform(|&x| x).collect();\n+        let set: HashSet<int> = xs.iter().map(|&x| x).collect();\n \n         for x in xs.iter() {\n             assert!(set.contains(x));\n         }\n     }\n \n     #[test]\n-    fn test_consume() {\n+    fn test_move_iter() {\n         let hs = {\n             let mut hs = HashSet::new();\n \n@@ -1187,7 +1187,7 @@ mod test_set {\n             hs\n         };\n \n-        let v = hs.consume().collect::<~[char]>();\n+        let v = hs.move_iter().collect::<~[char]>();\n         assert!(['a', 'b'] == v || ['b', 'a'] == v);\n     }\n }"}, {"sha": "a7a1c0bede8dbabf761920061f0bb30ffb8da38a", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 262, "deletions": 357, "changes": 619, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -49,89 +49,7 @@ pub trait Iterator<A> {\n     /// The common use case for the estimate is pre-allocating space to store the results.\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { (0, None) }\n-}\n-\n-/// A range iterator able to yield elements from both ends\n-pub trait DoubleEndedIterator<A>: Iterator<A> {\n-    /// Yield an element from the end of the range, returning `None` if the range is empty.\n-    fn next_back(&mut self) -> Option<A>;\n-}\n-\n-/// An object implementing random access indexing by `uint`\n-///\n-/// A `RandomAccessIterator` should be either infinite or a `DoubleEndedIterator`.\n-pub trait RandomAccessIterator<A>: Iterator<A> {\n-    /// Return the number of indexable elements. At most `std::uint::max_value`\n-    /// elements are indexable, even if the iterator represents a longer range.\n-    fn indexable(&self) -> uint;\n-\n-    /// Return an element at an index\n-    fn idx(&self, index: uint) -> Option<A>;\n-}\n-\n-/// Iterator adaptors provided for every `DoubleEndedIterator` implementation.\n-///\n-/// In the future these will be default methods instead of a utility trait.\n-pub trait DoubleEndedIteratorUtil {\n-    /// Flip the direction of the iterator\n-    fn invert(self) -> Invert<Self>;\n-}\n-\n-/// Iterator adaptors provided for every `DoubleEndedIterator` implementation.\n-///\n-/// In the future these will be default methods instead of a utility trait.\n-impl<A, T: DoubleEndedIterator<A>> DoubleEndedIteratorUtil for T {\n-    /// Flip the direction of the iterator\n-    ///\n-    /// The inverted iterator flips the ends on an iterator that can already\n-    /// be iterated from the front and from the back.\n-    ///\n-    ///\n-    /// If the iterator also implements RandomAccessIterator, the inverted\n-    /// iterator is also random access, with the indices starting at the back\n-    /// of the original iterator.\n-    ///\n-    /// Note: Random access with inverted indices still only applies to the first\n-    /// `uint::max_value` elements of the original iterator.\n-    #[inline]\n-    fn invert(self) -> Invert<T> {\n-        Invert{iter: self}\n-    }\n-}\n-\n-/// An double-ended iterator with the direction inverted\n-#[deriving(Clone)]\n-pub struct Invert<T> {\n-    priv iter: T\n-}\n \n-impl<A, T: DoubleEndedIterator<A>> Iterator<A> for Invert<T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<A> { self.iter.next_back() }\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n-}\n-\n-impl<A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Invert<T> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<A> { self.iter.next() }\n-}\n-\n-impl<A, T: DoubleEndedIterator<A> + RandomAccessIterator<A>> RandomAccessIterator<A>\n-    for Invert<T> {\n-    #[inline]\n-    fn indexable(&self) -> uint { self.iter.indexable() }\n-    #[inline]\n-    fn idx(&self, index: uint) -> Option<A> {\n-        self.iter.idx(self.indexable() - index - 1)\n-    }\n-}\n-\n-/// Iterator adaptors provided for every `Iterator` implementation. The adaptor objects are also\n-/// implementations of the `Iterator` trait.\n-///\n-/// In the future these will be default methods instead of a utility trait.\n-pub trait IteratorUtil<A> {\n     /// Chain this iterator with another, returning a new iterator which will\n     /// finish iterating over the current iterator, and then it will iterate\n     /// over the other specified iterator.\n@@ -141,12 +59,15 @@ pub trait IteratorUtil<A> {\n     /// ~~~ {.rust}\n     /// let a = [0];\n     /// let b = [1];\n-    /// let mut it = a.iter().chain_(b.iter());\n+    /// let mut it = a.iter().chain(b.iter());\n     /// assert_eq!(it.next().get(), &0);\n     /// assert_eq!(it.next().get(), &1);\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn chain_<U: Iterator<A>>(self, other: U) -> Chain<Self, U>;\n+    #[inline]\n+    fn chain<U: Iterator<A>>(self, other: U) -> Chain<Self, U> {\n+        Chain{a: self, b: other, flag: false}\n+    }\n \n     /// Creates an iterator which iterates over both this and the specified\n     /// iterators simultaneously, yielding the two elements as pairs. When\n@@ -162,22 +83,27 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), (&0, &1));\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn zip<B, U: Iterator<B>>(self, other: U) -> Zip<Self, U>;\n+    #[inline]\n+    fn zip<B, U: Iterator<B>>(self, other: U) -> Zip<Self, U> {\n+        Zip{a: self, b: other}\n+    }\n \n-    // FIXME: #5898: should be called map\n     /// Creates a new iterator which will apply the specified function to each\n     /// element returned by the first, yielding the mapped element instead.\n     ///\n     /// # Example\n     ///\n     /// ~~~ {.rust}\n     /// let a = [1, 2];\n-    /// let mut it = a.iter().transform(|&x| 2 * x);\n+    /// let mut it = a.iter().map(|&x| 2 * x);\n     /// assert_eq!(it.next().get(), 2);\n     /// assert_eq!(it.next().get(), 4);\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn transform<'r, B>(self, f: &'r fn(A) -> B) -> Map<'r, A, B, Self>;\n+    #[inline]\n+    fn map<'r, B>(self, f: &'r fn(A) -> B) -> Map<'r, A, B, Self> {\n+        Map{iter: self, f: f}\n+    }\n \n     /// Creates an iterator which applies the predicate to each element returned\n     /// by this iterator. Only elements which have the predicate evaluate to\n@@ -191,7 +117,10 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), &2);\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn filter<'r>(self, predicate: &'r fn(&A) -> bool) -> Filter<'r, A, Self>;\n+    #[inline]\n+    fn filter<'r>(self, predicate: &'r fn(&A) -> bool) -> Filter<'r, A, Self> {\n+        Filter{iter: self, predicate: predicate}\n+    }\n \n     /// Creates an iterator which both filters and maps elements.\n     /// If the specified function returns None, the element is skipped.\n@@ -205,7 +134,10 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), 4);\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn filter_map<'r,  B>(self, f: &'r fn(A) -> Option<B>) -> FilterMap<'r, A, B, Self>;\n+    #[inline]\n+    fn filter_map<'r, B>(self, f: &'r fn(A) -> Option<B>) -> FilterMap<'r, A, B, Self> {\n+        FilterMap { iter: self, f: f }\n+    }\n \n     /// Creates an iterator which yields a pair of the value returned by this\n     /// iterator plus the current index of iteration.\n@@ -219,7 +151,10 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), (1, &200));\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn enumerate(self) -> Enumerate<Self>;\n+    #[inline]\n+    fn enumerate(self) -> Enumerate<Self> {\n+        Enumerate{iter: self, count: 0}\n+    }\n \n     /// Creates an iterator which invokes the predicate on elements until it\n     /// returns false. Once the predicate returns false, all further elements are\n@@ -235,7 +170,10 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), &1);\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn skip_while<'r>(self, predicate: &'r fn(&A) -> bool) -> SkipWhile<'r, A, Self>;\n+    #[inline]\n+    fn skip_while<'r>(self, predicate: &'r fn(&A) -> bool) -> SkipWhile<'r, A, Self> {\n+        SkipWhile{iter: self, flag: false, predicate: predicate}\n+    }\n \n     /// Creates an iterator which yields elements so long as the predicate\n     /// returns true. After the predicate returns false for the first time, no\n@@ -250,7 +188,10 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), &2);\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn take_while<'r>(self, predicate: &'r fn(&A) -> bool) -> TakeWhile<'r, A, Self>;\n+    #[inline]\n+    fn take_while<'r>(self, predicate: &'r fn(&A) -> bool) -> TakeWhile<'r, A, Self> {\n+        TakeWhile{iter: self, flag: false, predicate: predicate}\n+    }\n \n     /// Creates an iterator which skips the first `n` elements of this iterator,\n     /// and then it yields all further items.\n@@ -264,23 +205,28 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), &5);\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn skip(self, n: uint) -> Skip<Self>;\n+    #[inline]\n+    fn skip(self, n: uint) -> Skip<Self> {\n+        Skip{iter: self, n: n}\n+    }\n \n-    // FIXME: #5898: should be called take\n     /// Creates an iterator which yields the first `n` elements of this\n     /// iterator, and then it will always return None.\n     ///\n     /// # Example\n     ///\n     /// ~~~ {.rust}\n     /// let a = [1, 2, 3, 4, 5];\n-    /// let mut it = a.iter().take_(3);\n+    /// let mut it = a.iter().take(3);\n     /// assert_eq!(it.next().get(), &1);\n     /// assert_eq!(it.next().get(), &2);\n     /// assert_eq!(it.next().get(), &3);\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn take_(self, n: uint) -> Take<Self>;\n+    #[inline]\n+    fn take(self, n: uint) -> Take<Self> {\n+        Take{iter: self, n: n}\n+    }\n \n     /// Creates a new iterator which behaves in a similar fashion to foldl.\n     /// There is a state which is passed between each iteration and can be\n@@ -302,8 +248,11 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), 120);\n     /// assert!(it.next().is_none());\n     /// ~~~\n+    #[inline]\n     fn scan<'r, St, B>(self, initial_state: St, f: &'r fn(&mut St, A) -> Option<B>)\n-        -> Scan<'r, A, B, Self, St>;\n+        -> Scan<'r, A, B, Self, St> {\n+        Scan{iter: self, f: f, state: initial_state}\n+    }\n \n     /// Creates an iterator that maps each element to an iterator,\n     /// and yields the elements of the produced iterators\n@@ -313,17 +262,19 @@ pub trait IteratorUtil<A> {\n     /// ~~~ {.rust}\n     /// let xs = [2u, 3];\n     /// let ys = [0u, 1, 0, 1, 2];\n-    /// let mut it = xs.iter().flat_map_(|&x| count(0u, 1).take_(x));\n+    /// let mut it = xs.iter().flat_map(|&x| count(0u, 1).take(x));\n     /// // Check that `it` has the same elements as `ys`\n     /// let mut i = 0;\n     /// for x: uint in it {\n     ///     assert_eq!(x, ys[i]);\n     ///     i += 1;\n     /// }\n     /// ~~~\n-    // FIXME: #5898: should be called `flat_map`\n-    fn flat_map_<'r, B, U: Iterator<B>>(self, f: &'r fn(A) -> U)\n-        -> FlatMap<'r, A, Self, U>;\n+    #[inline]\n+    fn flat_map<'r, B, U: Iterator<B>>(self, f: &'r fn(A) -> U)\n+        -> FlatMap<'r, A, Self, U> {\n+        FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n+    }\n \n     /// Creates an iterator that calls a function with a reference to each\n     /// element before yielding it. This is often useful for debugging an\n@@ -334,15 +285,17 @@ pub trait IteratorUtil<A> {\n     /// ~~~ {.rust}\n     ///let xs = [1u, 4, 2, 3, 8, 9, 6];\n     ///let sum = xs.iter()\n-    ///            .transform(|&x| x)\n-    ///            .peek_(|&x| debug!(\"filtering %u\", x))\n+    ///            .map(|&x| x)\n+    ///            .peek(|&x| debug!(\"filtering %u\", x))\n     ///            .filter(|&x| x % 2 == 0)\n-    ///            .peek_(|&x| debug!(\"%u made it through\", x))\n+    ///            .peek(|&x| debug!(\"%u made it through\", x))\n     ///            .sum();\n     ///println(sum.to_str());\n     /// ~~~\n-    // FIXME: #5898: should be called `peek`\n-    fn peek_<'r>(self, f: &'r fn(&A)) -> Peek<'r, A, Self>;\n+    #[inline]\n+    fn peek<'r>(self, f: &'r fn(&A)) -> Peek<'r, A, Self> {\n+        Peek{iter: self, f: f}\n+    }\n \n     /// An adaptation of an external iterator to the for-loop protocol of rust.\n     ///\n@@ -355,7 +308,17 @@ pub trait IteratorUtil<A> {\n     ///     printfln!(\"%d\", i);\n     /// }\n     /// ~~~\n-    fn advance(&mut self, f: &fn(A) -> bool) -> bool;\n+    #[inline]\n+    fn advance(&mut self, f: &fn(A) -> bool) -> bool {\n+        loop {\n+            match self.next() {\n+                Some(x) => {\n+                    if !f(x) { return false; }\n+                }\n+                None => { return true; }\n+            }\n+        }\n+    }\n \n     /// Loops through the entire iterator, collecting all of the elements into\n     /// a container implementing `FromIterator`.\n@@ -364,10 +327,13 @@ pub trait IteratorUtil<A> {\n     ///\n     /// ~~~ {.rust}\n     /// let a = [1, 2, 3, 4, 5];\n-    /// let b: ~[int] = a.iter().transform(|&x| x).collect();\n+    /// let b: ~[int] = a.iter().map(|&x| x).collect();\n     /// assert!(a == b);\n     /// ~~~\n-    fn collect<B: FromIterator<A, Self>>(&mut self) -> B;\n+    #[inline]\n+    fn collect<B: FromIterator<A, Self>>(&mut self) -> B {\n+        FromIterator::from_iterator(self)\n+    }\n \n     /// Loops through the entire iterator, collecting all of the elements into\n     /// a unique vector. This is simply collect() specialized for vectors.\n@@ -376,10 +342,13 @@ pub trait IteratorUtil<A> {\n     ///\n     /// ~~~ {.rust}\n     /// let a = [1, 2, 3, 4, 5];\n-    /// let b: ~[int] = a.iter().transform(|&x| x).to_owned_vec();\n+    /// let b: ~[int] = a.iter().map(|&x| x).to_owned_vec();\n     /// assert!(a == b);\n     /// ~~~\n-    fn to_owned_vec(&mut self) -> ~[A];\n+    #[inline]\n+    fn to_owned_vec(&mut self) -> ~[A] {\n+        self.collect()\n+    }\n \n     /// Loops through `n` iterations, returning the `n`th element of the\n     /// iterator.\n@@ -392,7 +361,16 @@ pub trait IteratorUtil<A> {\n     /// assert!(it.nth(2).get() == &3);\n     /// assert!(it.nth(2) == None);\n     /// ~~~\n-    fn nth(&mut self, n: uint) -> Option<A>;\n+    #[inline]\n+    fn nth(&mut self, mut n: uint) -> Option<A> {\n+        loop {\n+            match self.next() {\n+                Some(x) => if n == 0 { return Some(x) },\n+                None => return None\n+            }\n+            n -= 1;\n+        }\n+    }\n \n     /// Loops through the entire iterator, returning the last element of the\n     /// iterator.\n@@ -403,8 +381,12 @@ pub trait IteratorUtil<A> {\n     /// let a = [1, 2, 3, 4, 5];\n     /// assert!(a.iter().last().get() == &5);\n     /// ~~~\n-    // FIXME: #5898: should be called `last`\n-    fn last_(&mut self) -> Option<A>;\n+    #[inline]\n+    fn last(&mut self) -> Option<A> {\n+        let mut last = None;\n+        for x in *self { last = Some(x); }\n+        last\n+    }\n \n     /// Performs a fold operation over the entire iterator, returning the\n     /// eventual state at the end of the iteration.\n@@ -415,20 +397,32 @@ pub trait IteratorUtil<A> {\n     /// let a = [1, 2, 3, 4, 5];\n     /// assert!(a.iter().fold(0, |a, &b| a + b) == 15);\n     /// ~~~\n-    fn fold<B>(&mut self, start: B, f: &fn(B, A) -> B) -> B;\n+    #[inline]\n+    fn fold<B>(&mut self, init: B, f: &fn(B, A) -> B) -> B {\n+        let mut accum = init;\n+        loop {\n+            match self.next() {\n+                Some(x) => { accum = f(accum, x); }\n+                None    => { break; }\n+            }\n+        }\n+        accum\n+    }\n \n-    // FIXME: #5898: should be called len\n     /// Counts the number of elements in this iterator.\n     ///\n     /// # Example\n     ///\n     /// ~~~ {.rust}\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n-    /// assert!(it.len_() == 5);\n-    /// assert!(it.len_() == 0);\n+    /// assert!(it.len() == 5);\n+    /// assert!(it.len() == 0);\n     /// ~~~\n-    fn len_(&mut self) -> uint;\n+    #[inline]\n+    fn len(&mut self) -> uint {\n+        self.fold(0, |cnt, _x| cnt + 1)\n+    }\n \n     /// Tests whether the predicate holds true for all elements in the iterator.\n     ///\n@@ -439,7 +433,11 @@ pub trait IteratorUtil<A> {\n     /// assert!(a.iter().all(|&x| *x > 0));\n     /// assert!(!a.iter().all(|&x| *x > 2));\n     /// ~~~\n-    fn all(&mut self, f: &fn(A) -> bool) -> bool;\n+    #[inline]\n+    fn all(&mut self, f: &fn(A) -> bool) -> bool {\n+        for x in *self { if !f(x) { return false; } }\n+        true\n+    }\n \n     /// Tests whether any element of an iterator satisfies the specified\n     /// predicate.\n@@ -452,179 +450,6 @@ pub trait IteratorUtil<A> {\n     /// assert!(it.any(|&x| *x == 3));\n     /// assert!(!it.any(|&x| *x == 3));\n     /// ~~~\n-    fn any(&mut self, f: &fn(A) -> bool) -> bool;\n-\n-    /// Return the first element satisfying the specified predicate\n-    fn find_(&mut self, predicate: &fn(&A) -> bool) -> Option<A>;\n-\n-    /// Return the index of the first element satisfying the specified predicate\n-    fn position(&mut self, predicate: &fn(A) -> bool) -> Option<uint>;\n-\n-    /// Count the number of elements satisfying the specified predicate\n-    fn count(&mut self, predicate: &fn(A) -> bool) -> uint;\n-\n-    /// Return the element that gives the maximum value from the specfied function\n-    ///\n-    /// # Example\n-    ///\n-    /// ~~~ {.rust}\n-    /// let xs = [-3, 0, 1, 5, -10];\n-    /// assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n-    /// ~~~\n-    fn max_by<B: Ord>(&mut self, f: &fn(&A) -> B) -> Option<A>;\n-\n-    /// Return the element that gives the minimum value from the specfied function\n-    ///\n-    /// # Example\n-    ///\n-    /// ~~~ {.rust}\n-    /// let xs = [-3, 0, 1, 5, -10];\n-    /// assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n-    /// ~~~\n-    fn min_by<B: Ord>(&mut self, f: &fn(&A) -> B) -> Option<A>;\n-}\n-\n-/// Iterator adaptors provided for every `Iterator` implementation. The adaptor objects are also\n-/// implementations of the `Iterator` trait.\n-///\n-/// In the future these will be default methods instead of a utility trait.\n-impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n-    #[inline]\n-    fn chain_<U: Iterator<A>>(self, other: U) -> Chain<T, U> {\n-        Chain{a: self, b: other, flag: false}\n-    }\n-\n-    #[inline]\n-    fn zip<B, U: Iterator<B>>(self, other: U) -> Zip<T, U> {\n-        Zip{a: self, b: other}\n-    }\n-\n-    // FIXME: #5898: should be called map\n-    #[inline]\n-    fn transform<'r, B>(self, f: &'r fn(A) -> B) -> Map<'r, A, B, T> {\n-        Map{iter: self, f: f}\n-    }\n-\n-    #[inline]\n-    fn filter<'r>(self, predicate: &'r fn(&A) -> bool) -> Filter<'r, A, T> {\n-        Filter{iter: self, predicate: predicate}\n-    }\n-\n-    #[inline]\n-    fn filter_map<'r, B>(self, f: &'r fn(A) -> Option<B>) -> FilterMap<'r, A, B, T> {\n-        FilterMap { iter: self, f: f }\n-    }\n-\n-    #[inline]\n-    fn enumerate(self) -> Enumerate<T> {\n-        Enumerate{iter: self, count: 0}\n-    }\n-\n-    #[inline]\n-    fn skip_while<'r>(self, predicate: &'r fn(&A) -> bool) -> SkipWhile<'r, A, T> {\n-        SkipWhile{iter: self, flag: false, predicate: predicate}\n-    }\n-\n-    #[inline]\n-    fn take_while<'r>(self, predicate: &'r fn(&A) -> bool) -> TakeWhile<'r, A, T> {\n-        TakeWhile{iter: self, flag: false, predicate: predicate}\n-    }\n-\n-    #[inline]\n-    fn skip(self, n: uint) -> Skip<T> {\n-        Skip{iter: self, n: n}\n-    }\n-\n-    // FIXME: #5898: should be called take\n-    #[inline]\n-    fn take_(self, n: uint) -> Take<T> {\n-        Take{iter: self, n: n}\n-    }\n-\n-    #[inline]\n-    fn scan<'r, St, B>(self, initial_state: St, f: &'r fn(&mut St, A) -> Option<B>)\n-        -> Scan<'r, A, B, T, St> {\n-        Scan{iter: self, f: f, state: initial_state}\n-    }\n-\n-    #[inline]\n-    fn flat_map_<'r, B, U: Iterator<B>>(self, f: &'r fn(A) -> U)\n-        -> FlatMap<'r, A, T, U> {\n-        FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n-    }\n-\n-    // FIXME: #5898: should be called `peek`\n-    #[inline]\n-    fn peek_<'r>(self, f: &'r fn(&A)) -> Peek<'r, A, T> {\n-        Peek{iter: self, f: f}\n-    }\n-\n-    /// A shim implementing the `for` loop iteration protocol for iterator objects\n-    #[inline]\n-    fn advance(&mut self, f: &fn(A) -> bool) -> bool {\n-        loop {\n-            match self.next() {\n-                Some(x) => {\n-                    if !f(x) { return false; }\n-                }\n-                None => { return true; }\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn collect<B: FromIterator<A, T>>(&mut self) -> B {\n-        FromIterator::from_iterator(self)\n-    }\n-\n-    #[inline]\n-    fn to_owned_vec(&mut self) -> ~[A] {\n-        self.collect()\n-    }\n-\n-    /// Return the `n`th item yielded by an iterator.\n-    #[inline]\n-    fn nth(&mut self, mut n: uint) -> Option<A> {\n-        loop {\n-            match self.next() {\n-                Some(x) => if n == 0 { return Some(x) },\n-                None => return None\n-            }\n-            n -= 1;\n-        }\n-    }\n-\n-    /// Return the last item yielded by an iterator.\n-    #[inline]\n-    fn last_(&mut self) -> Option<A> {\n-        let mut last = None;\n-        for x in *self { last = Some(x); }\n-        last\n-    }\n-\n-    /// Reduce an iterator to an accumulated value\n-    #[inline]\n-    fn fold<B>(&mut self, init: B, f: &fn(B, A) -> B) -> B {\n-        let mut accum = init;\n-        loop {\n-            match self.next() {\n-                Some(x) => { accum = f(accum, x); }\n-                None    => { break; }\n-            }\n-        }\n-        accum\n-    }\n-\n-    /// Count the number of items yielded by an iterator\n-    #[inline]\n-    fn len_(&mut self) -> uint { self.fold(0, |cnt, _x| cnt + 1) }\n-\n-    #[inline]\n-    fn all(&mut self, f: &fn(A) -> bool) -> bool {\n-        for x in *self { if !f(x) { return false; } }\n-        true\n-    }\n-\n     #[inline]\n     fn any(&mut self, f: &fn(A) -> bool) -> bool {\n         for x in *self { if f(x) { return true; } }\n@@ -633,7 +458,7 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n \n     /// Return the first element satisfying the specified predicate\n     #[inline]\n-    fn find_(&mut self, predicate: &fn(&A) -> bool) -> Option<A> {\n+    fn find(&mut self, predicate: &fn(&A) -> bool) -> Option<A> {\n         for x in *self {\n             if predicate(&x) { return Some(x) }\n         }\n@@ -653,6 +478,7 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n         None\n     }\n \n+    /// Count the number of elements satisfying the specified predicate\n     #[inline]\n     fn count(&mut self, predicate: &fn(A) -> bool) -> uint {\n         let mut i = 0;\n@@ -662,6 +488,14 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n         i\n     }\n \n+    /// Return the element that gives the maximum value from the specfied function\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// let xs = [-3, 0, 1, 5, -10];\n+    /// assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n+    /// ~~~\n     #[inline]\n     fn max_by<B: Ord>(&mut self, f: &fn(&A) -> B) -> Option<A> {\n         self.fold(None, |max: Option<(A, B)>, x| {\n@@ -677,6 +511,14 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n         }).map_move(|(x, _)| x)\n     }\n \n+    /// Return the element that gives the minimum value from the specfied function\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// let xs = [-3, 0, 1, 5, -10];\n+    /// assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n+    /// ~~~\n     #[inline]\n     fn min_by<B: Ord>(&mut self, f: &fn(&A) -> B) -> Option<A> {\n         self.fold(None, |min: Option<(A, B)>, x| {\n@@ -693,6 +535,69 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     }\n }\n \n+/// A range iterator able to yield elements from both ends\n+pub trait DoubleEndedIterator<A>: Iterator<A> {\n+    /// Yield an element from the end of the range, returning `None` if the range is empty.\n+    fn next_back(&mut self) -> Option<A>;\n+\n+    /// Flip the direction of the iterator\n+    ///\n+    /// The inverted iterator flips the ends on an iterator that can already\n+    /// be iterated from the front and from the back.\n+    ///\n+    ///\n+    /// If the iterator also implements RandomAccessIterator, the inverted\n+    /// iterator is also random access, with the indices starting at the back\n+    /// of the original iterator.\n+    ///\n+    /// Note: Random access with inverted indices still only applies to the first\n+    /// `uint::max_value` elements of the original iterator.\n+    #[inline]\n+    fn invert(self) -> Invert<Self> {\n+        Invert{iter: self}\n+    }\n+}\n+\n+/// An object implementing random access indexing by `uint`\n+///\n+/// A `RandomAccessIterator` should be either infinite or a `DoubleEndedIterator`.\n+pub trait RandomAccessIterator<A>: Iterator<A> {\n+    /// Return the number of indexable elements. At most `std::uint::max_value`\n+    /// elements are indexable, even if the iterator represents a longer range.\n+    fn indexable(&self) -> uint;\n+\n+    /// Return an element at an index\n+    fn idx(&self, index: uint) -> Option<A>;\n+}\n+\n+/// An double-ended iterator with the direction inverted\n+#[deriving(Clone)]\n+pub struct Invert<T> {\n+    priv iter: T\n+}\n+\n+impl<A, T: DoubleEndedIterator<A>> Iterator<A> for Invert<T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<A> { self.iter.next_back() }\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+\n+impl<A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Invert<T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> { self.iter.next() }\n+}\n+\n+impl<A, T: DoubleEndedIterator<A> + RandomAccessIterator<A>> RandomAccessIterator<A>\n+    for Invert<T> {\n+    #[inline]\n+    fn indexable(&self) -> uint { self.iter.indexable() }\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<A> {\n+        self.iter.idx(self.indexable() - index - 1)\n+    }\n+}\n+\n /// A trait for iterators over elements which can be added together\n pub trait AdditiveIterator<A> {\n     /// Iterates over the entire iterator, summing up all the elements\n@@ -701,7 +606,7 @@ pub trait AdditiveIterator<A> {\n     ///\n     /// ~~~ {.rust}\n     /// let a = [1, 2, 3, 4, 5];\n-    /// let mut it = a.iter().transform(|&x| x);\n+    /// let mut it = a.iter().map(|&x| x);\n     /// assert!(it.sum() == 15);\n     /// ~~~\n     fn sum(&mut self) -> A;\n@@ -790,7 +695,7 @@ pub trait ClonableIterator {\n     /// # Example\n     ///\n     /// ~~~ {.rust}\n-    /// let a = count(1,1).take_(1);\n+    /// let a = count(1,1).take(1);\n     /// let mut cy = a.cycle();\n     /// assert_eq!(cy.next(), Some(1));\n     /// assert_eq!(cy.next(), Some(1));\n@@ -1617,7 +1522,7 @@ mod tests {\n \n     #[test]\n     fn test_counter_from_iter() {\n-        let mut it = count(0, 5).take_(10);\n+        let mut it = count(0, 5).take(10);\n         let xs: ~[int] = FromIterator::from_iterator(&mut it);\n         assert_eq!(xs, ~[0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n     }\n@@ -1627,16 +1532,16 @@ mod tests {\n         let xs = [0u, 1, 2, 3, 4, 5];\n         let ys = [30u, 40, 50, 60];\n         let expected = [0, 1, 2, 3, 4, 5, 30, 40, 50, 60];\n-        let mut it = xs.iter().chain_(ys.iter());\n+        let mut it = xs.iter().chain(ys.iter());\n         let mut i = 0;\n         for &x in it {\n             assert_eq!(x, expected[i]);\n             i += 1;\n         }\n         assert_eq!(i, expected.len());\n \n-        let ys = count(30u, 10).take_(4);\n-        let mut it = xs.iter().transform(|&x| x).chain_(ys);\n+        let ys = count(30u, 10).take(4);\n+        let mut it = xs.iter().map(|&x| x).chain(ys);\n         let mut i = 0;\n         for x in it {\n             assert_eq!(x, expected[i]);\n@@ -1647,7 +1552,7 @@ mod tests {\n \n     #[test]\n     fn test_filter_map() {\n-        let mut it = count(0u, 1u).take_(10)\n+        let mut it = count(0u, 1u).take(10)\n             .filter_map(|x| if x.is_even() { Some(x*x) } else { None });\n         assert_eq!(it.collect::<~[uint]>(), ~[0*0, 2*2, 4*4, 6*6, 8*8]);\n     }\n@@ -1704,7 +1609,7 @@ mod tests {\n     fn test_iterator_take() {\n         let xs = [0u, 1, 2, 3, 5, 13, 15, 16, 17, 19];\n         let ys = [0u, 1, 2, 3, 5];\n-        let mut it = xs.iter().take_(5);\n+        let mut it = xs.iter().take(5);\n         let mut i = 0;\n         for &x in it {\n             assert_eq!(x, ys[i]);\n@@ -1736,7 +1641,7 @@ mod tests {\n     fn test_iterator_flat_map() {\n         let xs = [0u, 3, 6];\n         let ys = [0u, 1, 2, 3, 4, 5, 6, 7, 8];\n-        let mut it = xs.iter().flat_map_(|&x| count(x, 1).take_(3));\n+        let mut it = xs.iter().flat_map(|&x| count(x, 1).take(3));\n         let mut i = 0;\n         for x in it {\n             assert_eq!(x, ys[i]);\n@@ -1751,8 +1656,8 @@ mod tests {\n         let mut n = 0;\n \n         let ys = xs.iter()\n-                   .transform(|&x| x)\n-                   .peek_(|_| n += 1)\n+                   .map(|&x| x)\n+                   .peek(|_| n += 1)\n                    .collect::<~[uint]>();\n \n         assert_eq!(n, xs.len());\n@@ -1783,13 +1688,13 @@ mod tests {\n     #[test]\n     fn test_cycle() {\n         let cycle_len = 3;\n-        let it = count(0u, 1).take_(cycle_len).cycle();\n+        let it = count(0u, 1).take(cycle_len).cycle();\n         assert_eq!(it.size_hint(), (uint::max_value, None));\n-        for (i, x) in it.take_(100).enumerate() {\n+        for (i, x) in it.take(100).enumerate() {\n             assert_eq!(i % cycle_len, x);\n         }\n \n-        let mut it = count(0u, 1).take_(0).cycle();\n+        let mut it = count(0u, 1).take(0).cycle();\n         assert_eq!(it.size_hint(), (0, Some(0)));\n         assert_eq!(it.next(), None);\n     }\n@@ -1805,48 +1710,48 @@ mod tests {\n     #[test]\n     fn test_iterator_last() {\n         let v = &[0, 1, 2, 3, 4];\n-        assert_eq!(v.iter().last_().unwrap(), &4);\n-        assert_eq!(v.slice(0, 1).iter().last_().unwrap(), &0);\n+        assert_eq!(v.iter().last().unwrap(), &4);\n+        assert_eq!(v.slice(0, 1).iter().last().unwrap(), &0);\n     }\n \n     #[test]\n     fn test_iterator_len() {\n         let v = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        assert_eq!(v.slice(0, 4).iter().len_(), 4);\n-        assert_eq!(v.slice(0, 10).iter().len_(), 10);\n-        assert_eq!(v.slice(0, 0).iter().len_(), 0);\n+        assert_eq!(v.slice(0, 4).iter().len(), 4);\n+        assert_eq!(v.slice(0, 10).iter().len(), 10);\n+        assert_eq!(v.slice(0, 0).iter().len(), 0);\n     }\n \n     #[test]\n     fn test_iterator_sum() {\n         let v = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        assert_eq!(v.slice(0, 4).iter().transform(|&x| x).sum(), 6);\n-        assert_eq!(v.iter().transform(|&x| x).sum(), 55);\n-        assert_eq!(v.slice(0, 0).iter().transform(|&x| x).sum(), 0);\n+        assert_eq!(v.slice(0, 4).iter().map(|&x| x).sum(), 6);\n+        assert_eq!(v.iter().map(|&x| x).sum(), 55);\n+        assert_eq!(v.slice(0, 0).iter().map(|&x| x).sum(), 0);\n     }\n \n     #[test]\n     fn test_iterator_product() {\n         let v = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        assert_eq!(v.slice(0, 4).iter().transform(|&x| x).product(), 0);\n-        assert_eq!(v.slice(1, 5).iter().transform(|&x| x).product(), 24);\n-        assert_eq!(v.slice(0, 0).iter().transform(|&x| x).product(), 1);\n+        assert_eq!(v.slice(0, 4).iter().map(|&x| x).product(), 0);\n+        assert_eq!(v.slice(1, 5).iter().map(|&x| x).product(), 24);\n+        assert_eq!(v.slice(0, 0).iter().map(|&x| x).product(), 1);\n     }\n \n     #[test]\n     fn test_iterator_max() {\n         let v = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        assert_eq!(v.slice(0, 4).iter().transform(|&x| x).max(), Some(3));\n-        assert_eq!(v.iter().transform(|&x| x).max(), Some(10));\n-        assert_eq!(v.slice(0, 0).iter().transform(|&x| x).max(), None);\n+        assert_eq!(v.slice(0, 4).iter().map(|&x| x).max(), Some(3));\n+        assert_eq!(v.iter().map(|&x| x).max(), Some(10));\n+        assert_eq!(v.slice(0, 0).iter().map(|&x| x).max(), None);\n     }\n \n     #[test]\n     fn test_iterator_min() {\n         let v = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        assert_eq!(v.slice(0, 4).iter().transform(|&x| x).min(), Some(0));\n-        assert_eq!(v.iter().transform(|&x| x).min(), Some(0));\n-        assert_eq!(v.slice(0, 0).iter().transform(|&x| x).min(), None);\n+        assert_eq!(v.slice(0, 4).iter().map(|&x| x).min(), Some(0));\n+        assert_eq!(v.iter().map(|&x| x).min(), Some(0));\n+        assert_eq!(v.slice(0, 0).iter().map(|&x| x).min(), None);\n     }\n \n     #[test]\n@@ -1859,43 +1764,43 @@ mod tests {\n         assert_eq!(c.size_hint(), (uint::max_value, None));\n         assert_eq!(vi.size_hint(), (10, Some(10)));\n \n-        assert_eq!(c.take_(5).size_hint(), (5, Some(5)));\n+        assert_eq!(c.take(5).size_hint(), (5, Some(5)));\n         assert_eq!(c.skip(5).size_hint().second(), None);\n         assert_eq!(c.take_while(|_| false).size_hint(), (0, None));\n         assert_eq!(c.skip_while(|_| false).size_hint(), (0, None));\n         assert_eq!(c.enumerate().size_hint(), (uint::max_value, None));\n-        assert_eq!(c.chain_(vi.transform(|&i| i)).size_hint(), (uint::max_value, None));\n+        assert_eq!(c.chain(vi.map(|&i| i)).size_hint(), (uint::max_value, None));\n         assert_eq!(c.zip(vi).size_hint(), (10, Some(10)));\n         assert_eq!(c.scan(0, |_,_| Some(0)).size_hint(), (0, None));\n         assert_eq!(c.filter(|_| false).size_hint(), (0, None));\n-        assert_eq!(c.transform(|_| 0).size_hint(), (uint::max_value, None));\n+        assert_eq!(c.map(|_| 0).size_hint(), (uint::max_value, None));\n         assert_eq!(c.filter_map(|_| Some(0)).size_hint(), (0, None));\n \n-        assert_eq!(vi.take_(5).size_hint(), (5, Some(5)));\n-        assert_eq!(vi.take_(12).size_hint(), (10, Some(10)));\n+        assert_eq!(vi.take(5).size_hint(), (5, Some(5)));\n+        assert_eq!(vi.take(12).size_hint(), (10, Some(10)));\n         assert_eq!(vi.skip(3).size_hint(), (7, Some(7)));\n         assert_eq!(vi.skip(12).size_hint(), (0, Some(0)));\n         assert_eq!(vi.take_while(|_| false).size_hint(), (0, Some(10)));\n         assert_eq!(vi.skip_while(|_| false).size_hint(), (0, Some(10)));\n         assert_eq!(vi.enumerate().size_hint(), (10, Some(10)));\n-        assert_eq!(vi.chain_(v2.iter()).size_hint(), (13, Some(13)));\n+        assert_eq!(vi.chain(v2.iter()).size_hint(), (13, Some(13)));\n         assert_eq!(vi.zip(v2.iter()).size_hint(), (3, Some(3)));\n         assert_eq!(vi.scan(0, |_,_| Some(0)).size_hint(), (0, Some(10)));\n         assert_eq!(vi.filter(|_| false).size_hint(), (0, Some(10)));\n-        assert_eq!(vi.transform(|i| i+1).size_hint(), (10, Some(10)));\n+        assert_eq!(vi.map(|i| i+1).size_hint(), (10, Some(10)));\n         assert_eq!(vi.filter_map(|_| Some(0)).size_hint(), (0, Some(10)));\n     }\n \n     #[test]\n     fn test_collect() {\n         let a = ~[1, 2, 3, 4, 5];\n-        let b: ~[int] = a.iter().transform(|&x| x).collect();\n+        let b: ~[int] = a.iter().map(|&x| x).collect();\n         assert_eq!(a, b);\n     }\n \n     #[test]\n     fn test_all() {\n-        let v = ~&[1, 2, 3, 4, 5];\n+        let v: ~&[int] = ~&[1, 2, 3, 4, 5];\n         assert!(v.iter().all(|&x| x < 10));\n         assert!(!v.iter().all(|&x| x.is_even()));\n         assert!(!v.iter().all(|&x| x > 100));\n@@ -1904,7 +1809,7 @@ mod tests {\n \n     #[test]\n     fn test_any() {\n-        let v = ~&[1, 2, 3, 4, 5];\n+        let v: ~&[int] = ~&[1, 2, 3, 4, 5];\n         assert!(v.iter().any(|&x| x < 10));\n         assert!(v.iter().any(|&x| x.is_even()));\n         assert!(!v.iter().any(|&x| x > 100));\n@@ -1913,10 +1818,10 @@ mod tests {\n \n     #[test]\n     fn test_find() {\n-        let v = &[1, 3, 9, 27, 103, 14, 11];\n-        assert_eq!(*v.iter().find_(|x| *x & 1 == 0).unwrap(), 14);\n-        assert_eq!(*v.iter().find_(|x| *x % 3 == 0).unwrap(), 3);\n-        assert!(v.iter().find_(|x| *x % 12 == 0).is_none());\n+        let v: &[int] = &[1, 3, 9, 27, 103, 14, 11];\n+        assert_eq!(*v.iter().find(|x| *x & 1 == 0).unwrap(), 14);\n+        assert_eq!(*v.iter().find(|x| *x % 3 == 0).unwrap(), 3);\n+        assert!(v.iter().find(|x| *x % 12 == 0).is_none());\n     }\n \n     #[test]\n@@ -1937,13 +1842,13 @@ mod tests {\n \n     #[test]\n     fn test_max_by() {\n-        let xs = [-3, 0, 1, 5, -10];\n+        let xs: &[int] = &[-3, 0, 1, 5, -10];\n         assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n     }\n \n     #[test]\n     fn test_min_by() {\n-        let xs = [-3, 0, 1, 5, -10];\n+        let xs: &[int] = &[-3, 0, 1, 5, -10];\n         assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n     }\n \n@@ -1953,13 +1858,13 @@ mod tests {\n         let mut it = xs.iter();\n         it.next();\n         it.next();\n-        assert_eq!(it.invert().transform(|&x| x).collect::<~[int]>(), ~[16, 14, 12, 10, 8, 6]);\n+        assert_eq!(it.invert().map(|&x| x).collect::<~[int]>(), ~[16, 14, 12, 10, 8, 6]);\n     }\n \n     #[test]\n     fn test_double_ended_map() {\n         let xs = [1, 2, 3, 4, 5, 6];\n-        let mut it = xs.iter().transform(|&x| x * -1);\n+        let mut it = xs.iter().map(|&x| x * -1);\n         assert_eq!(it.next(), Some(-1));\n         assert_eq!(it.next(), Some(-2));\n         assert_eq!(it.next_back(), Some(-6));\n@@ -1993,7 +1898,7 @@ mod tests {\n     fn test_double_ended_chain() {\n         let xs = [1, 2, 3, 4, 5];\n         let ys = ~[7, 9, 11];\n-        let mut it = xs.iter().chain_(ys.iter()).invert();\n+        let mut it = xs.iter().chain(ys.iter()).invert();\n         assert_eq!(it.next().unwrap(), &11)\n         assert_eq!(it.next().unwrap(), &9)\n         assert_eq!(it.next_back().unwrap(), &1)\n@@ -2029,7 +1934,7 @@ mod tests {\n     fn test_double_ended_flat_map() {\n         let u = [0u,1];\n         let v = [5,6,7,8];\n-        let mut it = u.iter().flat_map_(|x| v.slice(*x, v.len()).iter());\n+        let mut it = u.iter().flat_map(|x| v.slice(*x, v.len()).iter());\n         assert_eq!(it.next_back().unwrap(), &8);\n         assert_eq!(it.next().unwrap(),      &5);\n         assert_eq!(it.next_back().unwrap(), &7);\n@@ -2046,7 +1951,7 @@ mod tests {\n     fn test_random_access_chain() {\n         let xs = [1, 2, 3, 4, 5];\n         let ys = ~[7, 9, 11];\n-        let mut it = xs.iter().chain_(ys.iter());\n+        let mut it = xs.iter().chain(ys.iter());\n         assert_eq!(it.idx(0).unwrap(), &1);\n         assert_eq!(it.idx(5).unwrap(), &7);\n         assert_eq!(it.idx(7).unwrap(), &11);\n@@ -2091,10 +1996,10 @@ mod tests {\n     fn test_random_access_take() {\n         let xs = [1, 2, 3, 4, 5];\n         let empty: &[int] = [];\n-        check_randacc_iter(xs.iter().take_(3), 3);\n-        check_randacc_iter(xs.iter().take_(20), xs.len());\n-        check_randacc_iter(xs.iter().take_(0), 0);\n-        check_randacc_iter(empty.iter().take_(2), 0);\n+        check_randacc_iter(xs.iter().take(3), 3);\n+        check_randacc_iter(xs.iter().take(20), xs.len());\n+        check_randacc_iter(xs.iter().take(0), 0);\n+        check_randacc_iter(empty.iter().take(2), 0);\n     }\n \n     #[test]\n@@ -2109,8 +2014,8 @@ mod tests {\n     fn test_random_access_peek() {\n         let xs = [1, 2, 3, 4, 5];\n \n-        // test .transform and .peek_ that don't implement Clone\n-        let it = xs.iter().peek_(|_| {});\n+        // test .map and .peek that don't implement Clone\n+        let it = xs.iter().peek(|_| {});\n         assert_eq!(xs.len(), it.indexable());\n         for (i, elt) in xs.iter().enumerate() {\n             assert_eq!(Some(elt), it.idx(i));\n@@ -2119,11 +2024,11 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_random_access_transform() {\n+    fn test_random_access_map() {\n         let xs = [1, 2, 3, 4, 5];\n \n-        // test .transform and .peek_ that don't implement Clone\n-        let it = xs.iter().transform(|x| *x);\n+        // test .map and .peek that don't implement Clone\n+        let it = xs.iter().map(|x| *x);\n         assert_eq!(xs.len(), it.indexable());\n         for (i, elt) in xs.iter().enumerate() {\n             assert_eq!(Some(*elt), it.idx(i));\n@@ -2134,7 +2039,7 @@ mod tests {\n     fn test_random_access_cycle() {\n         let xs = [1, 2, 3, 4, 5];\n         let empty: &[int] = [];\n-        check_randacc_iter(xs.iter().cycle().take_(27), 27);\n+        check_randacc_iter(xs.iter().cycle().take(27), 27);\n         check_randacc_iter(empty.iter().cycle(), 0);\n     }\n "}, {"sha": "c1999ae47d61a79df63c9b3f43ffbe90b08fd240", "filename": "src/libstd/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -134,7 +134,7 @@ impl<T> Option<T> {\n \n     /// Return a consuming iterator over the possibly contained value\n     #[inline]\n-    pub fn consume(self) -> OptionIterator<T> {\n+    pub fn move_iter(self) -> OptionIterator<T> {\n         OptionIterator{opt: self}\n     }\n "}, {"sha": "c916be79c53e5a3fa13c5e0d072c3139e3a149ad", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -32,7 +32,7 @@ use c_str::ToCStr;\n use clone::Clone;\n use container::Container;\n use io;\n-use iterator::{IteratorUtil, range};\n+use iterator::range;\n use libc;\n use libc::{c_char, c_void, c_int, size_t};\n use libc::FILE;\n@@ -765,7 +765,7 @@ pub fn list_dir(p: &Path) -> ~[~str] {\n                 strings\n             }\n         }\n-        do get_list(p).consume_iter().filter |filename| {\n+        do get_list(p).move_iter().filter |filename| {\n             \".\" != *filename && \"..\" != *filename\n         }.collect()\n     }"}, {"sha": "177f0efb6dad380677fef7b9d442ddbb5bf11411", "filename": "src/libstd/path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -21,7 +21,7 @@ use c_str;\n use clone::Clone;\n use cmp::Eq;\n use container::Container;\n-use iterator::{Iterator, IteratorUtil, range};\n+use iterator::{Iterator, range};\n use libc;\n use num;\n use option::{None, Option, Some};\n@@ -961,7 +961,7 @@ impl GenericPath for WindowsPath {\n         match self.filestem() {\n             Some(stem) => {\n                 // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n-                // to_ascii_consume and to_str_consume to not do a unnecessary copy.\n+                // to_ascii_move and to_str_move to not do a unnecessary copy.\n                 match stem.to_ascii().to_lower().to_str_ascii() {\n                     ~\"con\" | ~\"aux\" | ~\"com1\" | ~\"com2\" | ~\"com3\" | ~\"com4\" |\n                     ~\"lpt1\" | ~\"lpt2\" | ~\"lpt3\" | ~\"prn\" | ~\"nul\" => true,\n@@ -1020,7 +1020,7 @@ impl GenericPath for WindowsPath {\n                 None => None,\n \n                 // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n-                // to_ascii_consume and to_str_consume to not do a unnecessary copy.\n+                // to_ascii_move and to_str_move to not do a unnecessary copy.\n                 Some(ref device) => Some(device.to_ascii().to_upper().to_str_ascii())\n             },\n             is_absolute: self.is_absolute,"}, {"sha": "9a8737f4dee3f5adc01dc60f481a5d2b1b91d103", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -51,7 +51,7 @@ pub use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n pub use hash::Hash;\n pub use iter::Times;\n pub use iterator::Extendable;\n-pub use iterator::{Iterator, IteratorUtil, DoubleEndedIterator, DoubleEndedIteratorUtil};\n+pub use iterator::{Iterator, DoubleEndedIterator};\n pub use iterator::{ClonableIterator, OrdIterator};\n pub use num::{Num, NumCast};\n pub use num::{Orderable, Signed, Unsigned, Round};"}, {"sha": "9de5e69148ae998cc39065e34844e0a4e3a0cdca", "filename": "src/libstd/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -94,7 +94,7 @@ impl<T, E: ToStr> Result<T, E> {\n         match *self {\n             Ok(ref t) => Some(t),\n             Err(*) => None,\n-        }.consume()\n+        }.move_iter()\n     }\n \n     /// Call a method based on a previous result\n@@ -108,7 +108,7 @@ impl<T, E: ToStr> Result<T, E> {\n         match *self {\n             Ok(*) => None,\n             Err(ref t) => Some(t),\n-        }.consume()\n+        }.move_iter()\n     }\n \n     /// Unwraps a result, yielding the content of an `Ok`."}, {"sha": "07b4ea10b6a3712200fe949b5e020bb0902c4574", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -239,7 +239,7 @@ impl BlockedTask {\n         };\n         // Even if the task was unkillable before, we use 'Killable' because\n         // multiple pipes will have handles. It does not really mean killable.\n-        handles.consume_iter().transform(|x| Killable(x)).collect()\n+        handles.move_iter().map(|x| Killable(x)).collect()\n     }\n \n     // This assertion has two flavours because the wake involves an atomic op."}, {"sha": "1b9f28b95fb3fc27b5042e067f933922b41d78ee", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -63,7 +63,7 @@ Several modules in `core` are clients of `rt`:\n use cell::Cell;\n use clone::Clone;\n use container::Container;\n-use iterator::{Iterator, IteratorUtil, range};\n+use iterator::{Iterator, range};\n use option::{Some, None};\n use ptr::RawPtr;\n use rt::local::Local;\n@@ -391,7 +391,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n     rtdebug!(\"waiting for threads\");\n \n     // Wait for schedulers\n-    for thread in threads.consume_iter() {\n+    for thread in threads.move_iter() {\n         thread.join();\n     }\n "}, {"sha": "bde703af31580eb382cf60a315a96cfbe989b9ce", "filename": "src/libstd/rt/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Frt%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Frt%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fselect.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -54,7 +54,7 @@ pub fn select<A: Select>(ports: &mut [A]) -> uint {\n         let task_handles = task.make_selectable(ports.len());\n \n         for (index, (port, task_handle)) in\n-                ports.mut_iter().zip(task_handles.consume_iter()).enumerate() {\n+                ports.mut_iter().zip(task_handles.move_iter()).enumerate() {\n             // If one of the ports has data by now, it will wake the handle.\n             if port.block_on(sched, task_handle) {\n                 ready_index = index;\n@@ -128,7 +128,7 @@ mod test {\n         let (ports, chans) = unzip(from_fn(num_ports, |_| oneshot::<()>()));\n         let mut dead_chans = ~[];\n         let mut ports = ports;\n-        for (i, chan) in chans.consume_iter().enumerate() {\n+        for (i, chan) in chans.move_iter().enumerate() {\n             if send_on_chans.contains(&i) {\n                 chan.send(());\n             } else {\n@@ -145,7 +145,7 @@ mod test {\n         let (ports, chans) = unzip(from_fn(num_ports, |_| stream::<()>()));\n         let mut dead_chans = ~[];\n         let mut ports = ports;\n-        for (i, chan) in chans.consume_iter().enumerate() {\n+        for (i, chan) in chans.move_iter().enumerate() {\n             if send_on_chans.contains(&i) {\n                 chan.send(());\n             } else {"}, {"sha": "ca94468e1adaedbb670c421840a46fd9c2d6d108", "filename": "src/libstd/rt/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftest.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -232,7 +232,7 @@ pub fn run_in_mt_newsched_task(f: ~fn()) {\n         }\n \n         // Wait for schedulers\n-        for thread in threads.consume_iter() {\n+        for thread in threads.move_iter() {\n             thread.join();\n         }\n     }"}, {"sha": "6280b64ecf51c71742a22751ef64ba176d0a0860", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -10,7 +10,6 @@\n \n use container::Container;\n use from_str::FromStr;\n-use iterator::IteratorUtil;\n use libc;\n use option::{Some, None};\n use os;"}, {"sha": "26a00cca4c82b1291c565cf1e6637ab8643b4445", "filename": "src/libstd/str.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -23,9 +23,9 @@ use char::Char;\n use clone::Clone;\n use container::{Container, Mutable};\n use iter::Times;\n-use iterator::{Iterator, FromIterator, Extendable, IteratorUtil};\n+use iterator::{Iterator, FromIterator, Extendable};\n use iterator::{Filter, AdditiveIterator, Map};\n-use iterator::{Invert, DoubleEndedIterator, DoubleEndedIteratorUtil};\n+use iterator::{Invert, DoubleEndedIterator};\n use libc;\n use num::Zero;\n use option::{None, Option, Some};\n@@ -59,7 +59,7 @@ pub fn from_bytes(vv: &[u8]) -> ~str {\n     use str::not_utf8::cond;\n \n     if !is_utf8(vv) {\n-        let first_bad_byte = *vv.iter().find_(|&b| !is_utf8([*b])).unwrap();\n+        let first_bad_byte = *vv.iter().find(|&b| !is_utf8([*b])).unwrap();\n         cond.raise(fmt!(\"from_bytes: input is not UTF-8; first bad byte is %u\",\n                         first_bad_byte as uint))\n     } else {\n@@ -76,7 +76,7 @@ pub fn from_bytes_owned(vv: ~[u8]) -> ~str {\n     use str::not_utf8::cond;\n \n     if !is_utf8(vv) {\n-        let first_bad_byte = *vv.iter().find_(|&b| !is_utf8([*b])).unwrap();\n+        let first_bad_byte = *vv.iter().find(|&b| !is_utf8([*b])).unwrap();\n         cond.raise(fmt!(\"from_bytes: input is not UTF-8; first bad byte is %u\",\n                         first_bad_byte as uint))\n     } else {\n@@ -185,7 +185,7 @@ impl<'self, S: Str> StrVector for &'self [S] {\n     pub fn concat(&self) -> ~str {\n         if self.is_empty() { return ~\"\"; }\n \n-        let len = self.iter().transform(|s| s.as_slice().len()).sum();\n+        let len = self.iter().map(|s| s.as_slice().len()).sum();\n \n         let mut s = with_capacity(len);\n \n@@ -210,7 +210,7 @@ impl<'self, S: Str> StrVector for &'self [S] {\n     pub fn concat(&self) -> ~str {\n         if self.is_empty() { return ~\"\"; }\n \n-        let len = self.iter().transform(|s| s.as_slice().len()).sum();\n+        let len = self.iter().map(|s| s.as_slice().len()).sum();\n \n         let mut s = with_capacity(len);\n \n@@ -239,7 +239,7 @@ impl<'self, S: Str> StrVector for &'self [S] {\n \n         // this is wrong without the guarantee that `self` is non-empty\n         let len = sep.len() * (self.len() - 1)\n-            + self.iter().transform(|s| s.as_slice().len()).sum();\n+            + self.iter().map(|s| s.as_slice().len()).sum();\n         let mut s = ~\"\";\n         let mut first = true;\n \n@@ -280,7 +280,7 @@ impl<'self, S: Str> StrVector for &'self [S] {\n \n         // this is wrong without the guarantee that `self` is non-empty\n         let len = sep.len() * (self.len() - 1)\n-            + self.iter().transform(|s| s.as_slice().len()).sum();\n+            + self.iter().map(|s| s.as_slice().len()).sum();\n         let mut s = ~\"\";\n         let mut first = true;\n \n@@ -1051,7 +1051,7 @@ pub mod raw {\n     /// If end is greater than the length of the string.\n     #[cfg(not(stage0))]\n     #[inline]\n-    pub unsafe fn slice_bytes(s: &str, begin: uint, end: uint) -> &str {\n+    pub unsafe fn slice_bytes<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n         do s.as_imm_buf |sbuf, n| {\n              assert!((begin <= end));\n              assert!((end <= n));\n@@ -1445,7 +1445,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// ~~~\n     #[inline]\n     fn iter(&self) -> CharIterator<'self> {\n-        self.char_offset_iter().transform(|(_, c)| c)\n+        self.char_offset_iter().map(|(_, c)| c)\n     }\n \n     /// An iterator over the characters of `self`, in reverse order.\n@@ -1457,7 +1457,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// An iterator over the bytes of `self`\n     #[inline]\n     fn byte_iter(&self) -> ByteIterator<'self> {\n-        self.as_bytes().iter().transform(|&b| b)\n+        self.as_bytes().iter().map(|&b| b)\n     }\n \n     /// An iterator over the bytes of `self`, in reverse order\n@@ -1565,7 +1565,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// An iterator over the lines of a string, separated by either\n     /// `\\n` or (`\\r\\n`).\n     fn any_line_iter(&self) -> AnyLineIterator<'self> {\n-        do self.line_iter().transform |line| {\n+        do self.line_iter().map |line| {\n             let l = line.len();\n             if l > 0 && line[l - 1] == '\\r' as u8 { line.slice(0, l - 1) }\n             else { line }\n@@ -1593,7 +1593,7 @@ impl<'self> StrSlice<'self> for &'self str {\n \n     /// Returns the number of characters that a string holds\n     #[inline]\n-    fn char_len(&self) -> uint { self.iter().len_() }\n+    fn char_len(&self) -> uint { self.iter().len() }\n \n     /// Returns a slice of the given string from the byte range\n     /// [`begin`..`end`)\n@@ -2546,7 +2546,6 @@ impl Zero for @str {\n \n #[cfg(test)]\n mod tests {\n-    use iterator::IteratorUtil;\n     use container::Container;\n     use option::Some;\n     use libc::c_char;\n@@ -3687,7 +3686,7 @@ mod tests {\n     #[test]\n     fn test_str_container() {\n         fn sum_len<S: Container>(v: &[S]) -> uint {\n-            v.iter().transform(|x| x.len()).sum()\n+            v.iter().map(|x| x.len()).sum()\n         }\n \n         let s = ~\"01234\";"}, {"sha": "c6ae535c19a3c4ec6edb5a3d7db38cf74c958fc1", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -17,7 +17,7 @@ use str::OwnedStr;\n use container::Container;\n use cast;\n use ptr;\n-use iterator::{Iterator, IteratorUtil};\n+use iterator::Iterator;\n use vec::{CopyableVector, ImmutableVector};\n #[cfg(stage0)]\n use vec::OwnedVector;"}, {"sha": "10bac9325ab43db57ac0c50389b9585900138a61", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -79,7 +79,7 @@ use cast;\n use cell::Cell;\n use container::MutableMap;\n use comm::{Chan, GenericChan, oneshot};\n-use hashmap::{HashSet, HashSetConsumeIterator};\n+use hashmap::{HashSet, HashSetMoveIterator};\n use local_data;\n use task::{Failure, SingleThreaded};\n use task::{Success, TaskOpts, TaskResult};\n@@ -141,8 +141,8 @@ impl TaskSet {\n         assert!(was_present);\n     }\n     #[inline]\n-    fn consume(self) -> HashSetConsumeIterator<TaskHandle> {\n-        (*self).consume()\n+    fn move_iter(self) -> HashSetMoveIterator<TaskHandle> {\n+        (*self).move_iter()\n     }\n }\n \n@@ -460,13 +460,13 @@ fn kill_taskgroup(state: TaskGroupInner, me: &TaskHandle, is_main: bool) {\n         if newstate.is_some() {\n             let TaskGroupData { members: members, descendants: descendants } =\n                 newstate.unwrap();\n-            for sibling in members.consume() {\n+            for sibling in members.move_iter() {\n                 // Skip self - killing ourself won't do much good.\n                 if &sibling != me {\n                     RuntimeGlue::kill_task(sibling);\n                 }\n             }\n-            for child in descendants.consume() {\n+            for child in descendants.move_iter() {\n                 assert!(&child != me);\n                 RuntimeGlue::kill_task(child);\n             }"}, {"sha": "f871f4ef6d6acad9db87970e8f40e271c15419ca", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -17,7 +17,7 @@ The `ToBytes` and `IterBytes` traits\n use cast;\n use io;\n use io::Writer;\n-use iterator::IteratorUtil;\n+use iterator::Iterator;\n use option::{None, Option, Some};\n use str::StrSlice;\n use vec::ImmutableVector;"}, {"sha": "0bfee145a3cfca18352f6d10e737bc440c5067d6", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -11,7 +11,7 @@\n //! An ordered map and set for integer keys implemented as a radix trie\n \n use prelude::*;\n-use iterator::{IteratorUtil, FromIterator, Extendable};\n+use iterator::{FromIterator, Extendable};\n use uint;\n use util::{swap, replace};\n use vec;\n@@ -617,7 +617,7 @@ mod test_map {\n     fn test_from_iter() {\n         let xs = ~[(1u, 1i), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n \n-        let map: TrieMap<int> = xs.iter().transform(|&x| x).collect();\n+        let map: TrieMap<int> = xs.iter().map(|&x| x).collect();\n \n         for &(k, v) in xs.iter() {\n             assert_eq!(map.find(&k), Some(&v));\n@@ -680,7 +680,7 @@ mod test_set {\n     fn test_from_iter() {\n         let xs = ~[9u, 8, 7, 6, 5, 4, 3, 2, 1];\n \n-        let set: TrieSet = xs.iter().transform(|&x| x).collect();\n+        let set: TrieSet = xs.iter().map(|&x| x).collect();\n \n         for x in xs.iter() {\n             assert!(set.contains(x));"}, {"sha": "80d1626c084fd0e2763fbce9d85069f16a78ae29", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -15,7 +15,7 @@\n use clone::Clone;\n use vec;\n use vec::ImmutableVector;\n-use iterator::IteratorUtil;\n+use iterator::Iterator;\n \n pub use self::inner::*;\n \n@@ -102,7 +102,7 @@ impl<'self,\n     fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C] {\n         match *self {\n             (ref a, ref b) => {\n-                a.iter().zip(b.iter()).transform(|(aa, bb)| f(aa, bb)).collect()\n+                a.iter().zip(b.iter()).map(|(aa, bb)| f(aa, bb)).collect()\n             }\n         }\n     }\n@@ -122,7 +122,7 @@ impl<A:Clone, B:Clone> ExtendedTupleOps<A,B> for (~[A], ~[B]) {\n     fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C] {\n         match *self {\n             (ref a, ref b) => {\n-                a.iter().zip(b.iter()).transform(|(aa, bb)| f(aa, bb)).collect()\n+                a.iter().zip(b.iter()).map(|(aa, bb)| f(aa, bb)).collect()\n             }\n         }\n     }"}, {"sha": "7b1f0e8ced8f2cbe8b7522664336f94d14cc6a17", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -526,7 +526,7 @@ pub mod rt {\n               TyHexLower => uint_to_str_prec(u, 16, prec),\n \n               // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n-              // to_ascii_consume and to_str_consume to not do a unnecessary copy.\n+              // to_ascii_move and to_str_move to not do a unnecessary copy.\n               TyHexUpper => {\n                 let s = uint_to_str_prec(u, 16, prec);\n                 s.to_ascii().to_upper().to_str_ascii()"}, {"sha": "c831dd709182824e42f1c13b63f5c82851173606", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -382,7 +382,7 @@ pub fn unzip_slice<T:Clone,U:Clone>(v: &[(T, U)]) -> (~[T], ~[U]) {\n pub fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n     let mut ts = ~[];\n     let mut us = ~[];\n-    for p in v.consume_iter() {\n+    for p in v.move_iter() {\n         let (t, u) = p;\n         ts.push(t);\n         us.push(u);\n@@ -1068,10 +1068,10 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     }\n \n     /// Deprecated, use iterators where possible\n-    /// (`self.iter().transform(f)`). Apply a function to each element\n+    /// (`self.iter().map(f)`). Apply a function to each element\n     /// of a vector and return the results.\n     fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U] {\n-        self.iter().transform(f).collect()\n+        self.iter().map(f).collect()\n     }\n \n     /**\n@@ -1174,8 +1174,8 @@ impl<'self,T:Clone> ImmutableCopyableVector<T> for &'self [T] {\n \n #[allow(missing_doc)]\n pub trait OwnedVector<T> {\n-    fn consume_iter(self) -> ConsumeIterator<T>;\n-    fn consume_rev_iter(self) -> ConsumeRevIterator<T>;\n+    fn move_iter(self) -> MoveIterator<T>;\n+    fn move_rev_iter(self) -> MoveRevIterator<T>;\n \n     fn reserve(&mut self, n: uint);\n     fn reserve_at_least(&mut self, n: uint);\n@@ -1204,26 +1204,26 @@ impl<T> OwnedVector<T> for ~[T] {\n     /// value out of the vector (from start to end). The vector cannot\n     /// be used after calling this.\n     ///\n-    /// Note that this performs O(n) swaps, and so `consume_rev_iter`\n+    /// Note that this performs O(n) swaps, and so `move_rev_iter`\n     /// (which just calls `pop` repeatedly) is more efficient.\n     ///\n     /// # Examples\n     ///\n     /// ~~~ {.rust}\n     /// let v = ~[~\"a\", ~\"b\"];\n-    /// for s in v.consume_iter() {\n+    /// for s in v.move_iter() {\n     ///   // s has type ~str, not &~str\n     ///   println(s);\n     /// }\n     /// ~~~\n-    fn consume_iter(self) -> ConsumeIterator<T> {\n-        ConsumeIterator { v: self, idx: 0 }\n+    fn move_iter(self) -> MoveIterator<T> {\n+        MoveIterator { v: self, idx: 0 }\n     }\n     /// Creates a consuming iterator that moves out of the vector in\n-    /// reverse order. Also see `consume_iter`, however note that this\n+    /// reverse order. Also see `move_iter`, however note that this\n     /// is more efficient.\n-    fn consume_rev_iter(self) -> ConsumeRevIterator<T> {\n-        ConsumeRevIterator { v: self }\n+    fn move_rev_iter(self) -> MoveRevIterator<T> {\n+        MoveRevIterator { v: self }\n     }\n \n     /**\n@@ -1540,7 +1540,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         let mut lefts  = ~[];\n         let mut rights = ~[];\n \n-        for elt in self.consume_iter() {\n+        for elt in self.move_iter() {\n             if f(&elt) {\n                 lefts.push(elt);\n             } else {\n@@ -2148,7 +2148,7 @@ pub mod bytes {\n impl<A:Clone> Clone for ~[A] {\n     #[inline]\n     fn clone(&self) -> ~[A] {\n-        self.iter().transform(|item| item.clone()).collect()\n+        self.iter().map(|item| item.clone()).collect()\n     }\n }\n \n@@ -2281,12 +2281,12 @@ pub type MutRevIterator<'self, T> = Invert<VecMutIterator<'self, T>>;\n \n /// An iterator that moves out of a vector.\n #[deriving(Clone)]\n-pub struct ConsumeIterator<T> {\n+pub struct MoveIterator<T> {\n     priv v: ~[T],\n     priv idx: uint,\n }\n \n-impl<T> Iterator<T> for ConsumeIterator<T> {\n+impl<T> Iterator<T> for MoveIterator<T> {\n     fn next(&mut self) -> Option<T> {\n         // this is peculiar, but is required for safety with respect\n         // to dtors. It traverses the first half of the vec, and\n@@ -2308,11 +2308,11 @@ impl<T> Iterator<T> for ConsumeIterator<T> {\n \n /// An iterator that moves out of a vector in reverse order.\n #[deriving(Clone)]\n-pub struct ConsumeRevIterator<T> {\n+pub struct MoveRevIterator<T> {\n     priv v: ~[T]\n }\n \n-impl<T> Iterator<T> for ConsumeRevIterator<T> {\n+impl<T> Iterator<T> for MoveRevIterator<T> {\n     fn next(&mut self) -> Option<T> {\n         self.v.pop_opt()\n     }\n@@ -3323,17 +3323,17 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_consume_iterator() {\n+    fn test_move_iterator() {\n         use iterator::*;\n         let xs = ~[1u,2,3,4,5];\n-        assert_eq!(xs.consume_iter().fold(0, |a: uint, b: uint| 10*a + b), 12345);\n+        assert_eq!(xs.move_iter().fold(0, |a: uint, b: uint| 10*a + b), 12345);\n     }\n \n     #[test]\n-    fn test_consume_rev_iterator() {\n+    fn test_move_rev_iterator() {\n         use iterator::*;\n         let xs = ~[1u,2,3,4,5];\n-        assert_eq!(xs.consume_rev_iter().fold(0, |a: uint, b: uint| 10*a + b), 54321);\n+        assert_eq!(xs.move_rev_iter().fold(0, |a: uint, b: uint| 10*a + b), 54321);\n     }\n \n     #[test]\n@@ -3608,7 +3608,7 @@ mod tests {\n         }\n         assert_eq!(cnt, 8);\n \n-        for f in v.consume_iter() {\n+        for f in v.move_iter() {\n             assert!(f == Foo);\n             cnt += 1;\n         }"}, {"sha": "0005180ef50ff473aa2b6679cc9185ff5b322f3b", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -247,7 +247,7 @@ pub fn unguarded_pat(a: &arm) -> Option<~[@pat]> {\n }\n \n pub fn public_methods(ms: ~[@method]) -> ~[@method] {\n-    do ms.consume_iter().filter |m| {\n+    do ms.move_iter().filter |m| {\n         match m.vis {\n             public => true,\n             _   => false"}, {"sha": "b0dda2b7dc89f0db4f24d7101411569e5900aeb1", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -186,13 +186,13 @@ pub fn contains_name<AM: AttrMetaMethods>(metas: &[AM], name: &str) -> bool {\n pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str)\n                                  -> Option<@str> {\n     attrs.iter()\n-        .find_(|at| name == at.name())\n+        .find(|at| name == at.name())\n         .chain(|at| at.value_str())\n }\n \n pub fn last_meta_item_value_str_by_name(items: &[@MetaItem], name: &str)\n                                      -> Option<@str> {\n-    items.rev_iter().find_(|mi| name == mi.name()).chain(|i| i.value_str())\n+    items.rev_iter().find(|mi| name == mi.name()).chain(|i| i.value_str())\n }\n \n /* Higher-level applications */\n@@ -201,15 +201,15 @@ pub fn sort_meta_items(items: &[@MetaItem]) -> ~[@MetaItem] {\n     // This is sort of stupid here, but we need to sort by\n     // human-readable strings.\n     let mut v = items.iter()\n-        .transform(|&mi| (mi.name(), mi))\n+        .map(|&mi| (mi.name(), mi))\n         .collect::<~[(@str, @MetaItem)]>();\n \n     do extra::sort::quick_sort(v) |&(a, _), &(b, _)| {\n         a <= b\n     }\n \n     // There doesn't seem to be a more optimal way to do this\n-    do v.consume_iter().transform |(_, m)| {\n+    do v.move_iter().map |(_, m)| {\n         match m.node {\n             MetaList(n, ref mis) => {\n                 @spanned {"}, {"sha": "65032642fda789d4b441697fa4854de1b5e96156", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -702,7 +702,7 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     fn variant(&self, span: span, name: ident, tys: ~[ast::Ty]) -> ast::variant {\n-        let args = tys.consume_iter().transform(|ty| {\n+        let args = tys.move_iter().map(|ty| {\n             ast::variant_arg { ty: ty, id: self.next_id() }\n         }).collect();\n "}, {"sha": "5f9437fd253ef7eedd6a669533c81f32a0ad2bdc", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -39,7 +39,7 @@ pub fn expand_cfg(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree]) -> base::MacR\n     // test_cfg searches for meta items looking like `cfg(foo, ...)`\n     let in_cfg = &[cx.meta_list(sp, @\"cfg\", cfgs)];\n \n-    let matches_cfg = attr::test_cfg(cx.cfg(), in_cfg.iter().transform(|&x| x));\n+    let matches_cfg = attr::test_cfg(cx.cfg(), in_cfg.iter().map(|&x| x));\n     let e = cx.expr_bool(sp, matches_cfg);\n     MRExpr(e)\n }"}, {"sha": "1abfe246f9da8b769163dff553e223b82ae842c5", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -90,7 +90,7 @@ fn decodable_substructure(cx: @ExtCtxt, span: span,\n                     }\n                 }\n                 Right(ref fields) => {\n-                    let fields = do fields.iter().enumerate().transform |(i, f)| {\n+                    let fields = do fields.iter().enumerate().map |(i, f)| {\n                         cx.field_imm(span, *f, getarg(cx.str_of(*f), i))\n                     }.collect();\n                     cx.expr_struct_ident(span, substr.type_ident, fields)\n@@ -132,7 +132,7 @@ fn decodable_substructure(cx: @ExtCtxt, span: span,\n                         }\n                     }\n                     Right(ref fields) => {\n-                        let fields = do fields.iter().enumerate().transform |(i, f)| {\n+                        let fields = do fields.iter().enumerate().map |(i, f)| {\n                             cx.field_imm(span, *f, getarg(i))\n                         }.collect();\n                         cx.expr_struct_ident(span, name, fields)"}, {"sha": "a1abe47e0909d39b98d2786e4932daa0d1fdfdee", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -590,7 +590,7 @@ impl<'self> MethodDef<'self> {\n         // transpose raw_fields\n         let fields = match raw_fields {\n             [ref self_arg, .. rest] => {\n-                do self_arg.iter().enumerate().transform |(i, &(opt_id, field))| {\n+                do self_arg.iter().enumerate().map |(i, &(opt_id, field))| {\n                     let other_fields = do rest.map |l| {\n                         match &l[i] {\n                             &(_, ex) => ex\n@@ -750,7 +750,7 @@ impl<'self> MethodDef<'self> {\n                     let field_tuples =\n                         do self_vec.iter()\n                            .zip(enum_matching_fields.iter())\n-                           .transform |(&(id, self_f), other)| {\n+                           .map |(&(id, self_f), other)| {\n                         (id, self_f, (*other).clone())\n                     }.collect();\n                     substructure = EnumMatching(variant_index, variant, field_tuples);"}, {"sha": "e55a96f77ff9b57e811000a58265e54a42928bc2", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -95,7 +95,7 @@ fn rand_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n             let rand_variant = cx.expr_binary(span, ast::rem,\n                                               rv_call, variant_count);\n \n-            let mut arms = do variants.iter().enumerate().transform |(i, id_sum)| {\n+            let mut arms = do variants.iter().enumerate().map |(i, id_sum)| {\n                 let i_expr = cx.expr_uint(span, i);\n                 let pat = cx.pat_lit(span, i_expr);\n "}, {"sha": "1963f3aef49c1eec17b48afbc3b42e576363a9f5", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -1075,7 +1075,6 @@ mod test {\n     use parse::token::{intern, get_ident_interner};\n     use print::pprust;\n     use util::parser_testing::{string_to_item, string_to_pat, strs_to_idents};\n-    use oldvisit::{mk_vt};\n \n     // make sure that fail! is present\n     #[test] fn fail_exists_test () {"}, {"sha": "10f2055b5fbbae4328b239f346392439dad2353f", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -269,7 +269,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n        corresponding function in std::unstable::extfmt. Each function takes a\n        buffer to insert data into along with the data being formatted. */\n     let npieces = pieces.len();\n-    for (i, pc) in pieces.consume_iter().enumerate() {\n+    for (i, pc) in pieces.move_iter().enumerate() {\n         match pc {\n             /* Raw strings get appended via str::push_str */\n             PieceString(s) => {"}, {"sha": "a3adb42425ae2bad75c892ecf62b0fe3b1cdcf32", "filename": "src/libsyntax/ext/ifmt.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fext%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fext%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fifmt.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -353,9 +353,9 @@ impl Context {\n         let trans_method = |method: &parse::Method| {\n             let method = match *method {\n                 parse::Select(ref arms, ref default) => {\n-                    let arms = arms.iter().transform(|arm| {\n+                    let arms = arms.iter().map(|arm| {\n                         let p = self.ecx.path_global(sp, rtpath(\"SelectArm\"));\n-                        let result = arm.result.iter().transform(|p| {\n+                        let result = arm.result.iter().map(|p| {\n                             self.trans_piece(p)\n                         }).collect();\n                         let s = arm.selector.to_managed();\n@@ -368,7 +368,7 @@ impl Context {\n                                                self.ecx.expr_vec_slice(sp, result)),\n                         ])\n                     }).collect();\n-                    let default = default.iter().transform(|p| {\n+                    let default = default.iter().map(|p| {\n                         self.trans_piece(p)\n                     }).collect();\n                     self.ecx.expr_call_global(sp, rtpath(\"Select\"), ~[\n@@ -381,9 +381,9 @@ impl Context {\n                         Some(i) => { some(self.ecx.expr_uint(sp, i)) }\n                         None => { none() }\n                     };\n-                    let arms = arms.iter().transform(|arm| {\n+                    let arms = arms.iter().map(|arm| {\n                         let p = self.ecx.path_global(sp, rtpath(\"PluralArm\"));\n-                        let result = arm.result.iter().transform(|p| {\n+                        let result = arm.result.iter().map(|p| {\n                             self.trans_piece(p)\n                         }).collect();\n                         let (lr, selarg) = match arm.selector {\n@@ -408,7 +408,7 @@ impl Context {\n                                                self.ecx.expr_vec_slice(sp, result)),\n                         ])\n                     }).collect();\n-                    let default = default.iter().transform(|p| {\n+                    let default = default.iter().map(|p| {\n                         self.trans_piece(p)\n                     }).collect();\n                     self.ecx.expr_call_global(sp, rtpath(\"Plural\"), ~[\n@@ -575,8 +575,8 @@ impl Context {\n                 Some(self.format_arg(e.span, Right(name), lname));\n         }\n \n-        let args = names.consume_iter().transform(|a| a.unwrap());\n-        let mut args = locals.consume_iter().chain_(args);\n+        let args = names.move_iter().map(|a| a.unwrap());\n+        let mut args = locals.move_iter().chain(args);\n \n         // Next, build up the actual call to the sprintf function.\n         let result = self.ecx.expr_call_global(self.fmtsp, ~[\n@@ -685,7 +685,7 @@ pub fn expand_syntax_ext(ecx: @ExtCtxt, sp: span,\n     };\n     cx.fmtsp = efmt.span;\n     let fmt = expr_to_str(ecx, efmt,\n-                          ~\"first argument to ifmt! must be a string literal.\");\n+                          \"first argument to ifmt! must be a string literal.\");\n \n     let mut err = false;\n     do parse::parse_error::cond.trap(|m| {"}, {"sha": "031f0fb4199aeade83ea8fe26cc0bfcd1add0a96", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -105,7 +105,7 @@ pub fn expand_include_bin(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_bin!\");\n     match io::read_whole_file(&res_rel_file(cx, sp, &Path(file))) {\n       result::Ok(src) => {\n-        let u8_exprs: ~[@ast::expr] = src.iter().transform(|char| cx.expr_u8(sp, *char)).collect();\n+        let u8_exprs: ~[@ast::expr] = src.iter().map(|char| cx.expr_u8(sp, *char)).collect();\n         base::MRExpr(cx.expr_vec(sp, u8_exprs))\n       }\n       result::Err(ref e) => {"}, {"sha": "65694f013f7517ed8bc8fc2e6647b25568917bd2", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -176,7 +176,7 @@ pub fn fold_ty_param(tp: TyParam,\n pub fn fold_ty_params(tps: &OptVec<TyParam>,\n                       fld: @ast_fold) -> OptVec<TyParam> {\n     let tps = /*bad*/ (*tps).clone();\n-    tps.map_consume(|tp| fold_ty_param(tp, fld))\n+    tps.map_move(|tp| fold_ty_param(tp, fld))\n }\n \n pub fn fold_lifetime(l: &Lifetime,\n@@ -704,7 +704,7 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n // ...nor do modules\n pub fn noop_fold_mod(m: &_mod, fld: @ast_fold) -> _mod {\n     ast::_mod {\n-        view_items: m.view_items.iter().transform(|x| fld.fold_view_item(x)).collect(),\n+        view_items: m.view_items.iter().map(|x| fld.fold_view_item(x)).collect(),\n         items: m.items.iter().filter_map(|x| fld.fold_item(*x)).collect(),\n     }\n }\n@@ -713,8 +713,8 @@ fn noop_fold_foreign_mod(nm: &foreign_mod, fld: @ast_fold) -> foreign_mod {\n     ast::foreign_mod {\n         sort: nm.sort,\n         abis: nm.abis,\n-        view_items: nm.view_items.iter().transform(|x| fld.fold_view_item(x)).collect(),\n-        items: nm.items.iter().transform(|x| fld.fold_foreign_item(*x)).collect(),\n+        view_items: nm.view_items.iter().map(|x| fld.fold_view_item(x)).collect(),\n+        items: nm.items.iter().map(|x| fld.fold_foreign_item(*x)).collect(),\n     }\n }\n \n@@ -734,7 +734,7 @@ fn noop_fold_variant(v: &variant_, fld: @ast_fold) -> variant_ {\n         struct_variant_kind(ref struct_def) => {\n             kind = struct_variant_kind(@ast::struct_def {\n                 fields: struct_def.fields.iter()\n-                    .transform(|f| fld.fold_struct_field(*f)).collect(),\n+                    .map(|f| fld.fold_struct_field(*f)).collect(),\n                 ctor_id: struct_def.ctor_id.map(|c| fld.new_id(*c))\n             })\n         }\n@@ -828,7 +828,7 @@ impl ast_fold for AstFoldFns {\n     fn fold_view_item(@self, x: &view_item) -> view_item {\n         ast::view_item {\n             node: (self.fold_view_item)(&x.node, self as @ast_fold),\n-            attrs: x.attrs.iter().transform(|a| fold_attribute_(*a, self as @ast_fold)).collect(),\n+            attrs: x.attrs.iter().map(|a| fold_attribute_(*a, self as @ast_fold)).collect(),\n             vis: x.vis,\n             span: (self.new_span)(x.span),\n         }"}, {"sha": "5d79532c8c5353617cdb42e325075b3859f9c3f9", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -57,10 +57,10 @@ impl<T> OptVec<T> {\n         }\n     }\n \n-    fn map_consume<U>(self, op: &fn(T) -> U) -> OptVec<U> {\n+    fn map_move<U>(self, op: &fn(T) -> U) -> OptVec<U> {\n         match self {\n             Empty => Empty,\n-            Vec(v) => Vec(v.consume_iter().transform(op).collect())\n+            Vec(v) => Vec(v.move_iter().map(op).collect())\n         }\n     }\n \n@@ -92,7 +92,7 @@ impl<T> OptVec<T> {\n \n     #[inline]\n     fn map_to_vec<B>(&self, op: &fn(&T) -> B) -> ~[B] {\n-        self.iter().transform(op).collect()\n+        self.iter().map(op).collect()\n     }\n \n     fn mapi_to_vec<B>(&self, op: &fn(uint, &T) -> B) -> ~[B] {"}, {"sha": "5b9725ec6a04239ed225ee18cd9ad80ed3d44d77", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -115,7 +115,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n     if comment.starts_with(\"/*\") {\n         let lines = comment.slice(3u, comment.len() - 2u)\n             .any_line_iter()\n-            .transform(|s| s.to_owned())\n+            .map(|s| s.to_owned())\n             .collect::<~[~str]>();\n \n         let lines = vertical_trim(lines);"}, {"sha": "d1916088a412a9a5f047a02e33d0b4d82033e1e9", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -4310,7 +4310,7 @@ impl Parser {\n                     seq_sep_trailing_disallowed(token::COMMA),\n                     |p| p.parse_ty(false)\n                 );\n-                for ty in arg_tys.consume_iter() {\n+                for ty in arg_tys.move_iter() {\n                     args.push(ast::variant_arg {\n                         ty: ty,\n                         id: self.get_id(),"}, {"sha": "9725297bace53b12371bef8e7c5c9eabe9bf4980", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -96,9 +96,9 @@ fn make_graph(N: uint, edges: ~[(node_id, node_id)]) -> graph {\n         }\n     }\n \n-    do graph.consume_iter().transform |v| {\n+    do graph.move_iter().map |v| {\n         let mut vec = ~[];\n-        for i in v.consume() {\n+        for i in v.move_iter() {\n             vec.push(i);\n         }\n         vec\n@@ -119,7 +119,7 @@ fn gen_search_keys(graph: &[~[node_id]], n: uint) -> ~[node_id] {\n         }\n     }\n     let mut vec = ~[];\n-    for i in keys.consume() {\n+    for i in keys.move_iter() {\n         vec.push(i);\n     }\n     return vec;\n@@ -193,7 +193,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n         // Do the BFS.\n         info!(\"PBFS iteration %?\", i);\n         i += 1;\n-        colors = do colors.iter().enumerate().transform |(i, c)| {\n+        colors = do colors.iter().enumerate().map |(i, c)| {\n             let c : color = *c;\n             match c {\n               white => {\n@@ -220,7 +220,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n     }\n \n     // Convert the results.\n-    do colors.iter().transform |c| {\n+    do colors.iter().map |c| {\n         match *c {\n           white => { -1i64 }\n           black(parent) => { parent }"}, {"sha": "f82c5e692e44d21a796314875b1d2774cff9684c", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -150,7 +150,7 @@ fn rendezvous(nn: uint, set: ~[color]) {\n \n     // these channels will allow us to talk to each creature by 'name'/index\n     let to_creature: ~[Chan<Option<CreatureInfo>>] =\n-        set.iter().enumerate().transform(|(ii, col)| {\n+        set.iter().enumerate().map(|(ii, col)| {\n             // create each creature as a listener with a port, and\n             // give us a channel to talk to each\n             let ii = ii;"}, {"sha": "66b9bdc0a42c9626924c5603c6b39c695a667b12", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -75,7 +75,7 @@ fn sort_and_fmt(mm: &HashMap<~[u8], uint>, total: uint) -> ~str {\n        unsafe {\n            let b = str::raw::from_bytes(k);\n            // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n-           // to_ascii_consume and to_str_consume to not do a unnecessary copy.\n+           // to_ascii_move and to_str_move to not do a unnecessary copy.\n            buffer.push_str(fmt!(\"%s %0.3f\\n\", b.to_ascii().to_upper().to_str_ascii(), v));\n        }\n    }\n@@ -86,7 +86,7 @@ fn sort_and_fmt(mm: &HashMap<~[u8], uint>, total: uint) -> ~str {\n // given a map, search for the frequency of a pattern\n fn find(mm: &HashMap<~[u8], uint>, key: ~str) -> uint {\n    // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n-   // to_ascii_consume and to_str_consume to not do a unnecessary copy.\n+   // to_ascii_move and to_str_move to not do a unnecessary copy.\n    let key = key.to_ascii().to_lower().to_str_ascii();\n    match mm.find_equiv(&key.as_bytes()) {\n       option::None      => { return 0u; }\n@@ -172,7 +172,7 @@ fn main() {\n     let sizes = ~[1u,2,3,4,6,12,18];\n     let mut streams = vec::from_fn(sizes.len(), |_| Some(stream::<~str>()));\n     let mut from_child = ~[];\n-    let to_child   = do sizes.iter().zip(streams.mut_iter()).transform |(sz, stream_ref)| {\n+    let to_child   = do sizes.iter().zip(streams.mut_iter()).map |(sz, stream_ref)| {\n         let sz = *sz;\n         let stream = util::replace(stream_ref, None);\n         let (from_child_, to_parent_) = stream.unwrap();"}, {"sha": "5efe13f8bca6b1376b8d7f39ec1783db30d46f70", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -28,20 +28,20 @@ fn calc(children: uint, parent_wait_chan: &Chan<Chan<Chan<int>>>) {\n     };\n \n     let child_start_chans: ~[Chan<Chan<int>>] =\n-        wait_ports.consume_iter().transform(|port| port.recv()).collect();\n+        wait_ports.move_iter().map(|port| port.recv()).collect();\n \n     let (start_port, start_chan) = stream::<Chan<int>>();\n     parent_wait_chan.send(start_chan);\n     let parent_result_chan: Chan<int> = start_port.recv();\n \n     let child_sum_ports: ~[Port<int>] =\n-        do child_start_chans.consume_iter().transform |child_start_chan| {\n+        do child_start_chans.move_iter().map |child_start_chan| {\n             let (child_sum_port, child_sum_chan) = stream::<int>();\n             child_start_chan.send(child_sum_chan);\n             child_sum_port\n     }.collect();\n \n-    let sum = child_sum_ports.consume_iter().fold(0, |sum, sum_port| sum + sum_port.recv() );\n+    let sum = child_sum_ports.move_iter().fold(0, |sum, sum_port| sum + sum_port.recv() );\n \n     parent_result_chan.send(sum + 1);\n }"}, {"sha": "aabc005c57fb3af900b02214dcccb8761f8068ed", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -28,7 +28,7 @@ pub fn main() {\n     assert!(any_negative);\n \n     // Higher precedence than unary operations:\n-    let abs_v = do v.iter().transform |e| { e.abs() }.collect::<~[float]>();\n+    let abs_v = do v.iter().map |e| { e.abs() }.collect::<~[float]>();\n     assert!(do abs_v.iter().all |e| { e.is_positive() });\n     assert!(!do abs_v.iter().any |e| { e.is_negative() });\n "}, {"sha": "493b810c10488592307665dace81dc2b45a282e5", "filename": "src/test/run-pass/trait-to-str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b9e1ce75a3e1416f2db80d30f65879fd902183f/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs?ref=8b9e1ce75a3e1416f2db80d30f65879fd902183f", "patch": "@@ -16,7 +16,7 @@ extern mod std;\n \n use std::str::StrVector;\n use std::vec::ImmutableVector;\n-use std::iterator::IteratorUtil;\n+use std::iterator::Iterator;\n use std::int;\n \n trait to_str {\n@@ -29,7 +29,7 @@ impl to_str for int {\n \n impl<T:to_str> to_str for ~[T] {\n     fn to_str(&self) -> ~str {\n-        fmt!(\"[%s]\", self.iter().transform(|e| e.to_str()).collect::<~[~str]>().connect(\", \"))\n+        fmt!(\"[%s]\", self.iter().map(|e| e.to_str()).collect::<~[~str]>().connect(\", \"))\n     }\n }\n "}]}