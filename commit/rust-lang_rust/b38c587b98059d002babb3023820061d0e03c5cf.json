{"sha": "b38c587b98059d002babb3023820061d0e03c5cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzOGM1ODdiOTgwNTlkMDAyYmFiYjMwMjM4MjAwNjFkMGUwM2M1Y2Y=", "commit": {"author": {"name": "Grzegorz", "email": "grzegorz.bartoszek@thaumatec.com", "date": "2019-02-10T11:58:51Z"}, "committer": {"name": "Grzegorz", "email": "grzegorz.bartoszek@thaumatec.com", "date": "2019-02-10T11:58:51Z"}, "message": "redundant closure implemented for closures containing method calls", "tree": {"sha": "1a00fb9f6a92e13db28ec1bfc77df2eebeb98b08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a00fb9f6a92e13db28ec1bfc77df2eebeb98b08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b38c587b98059d002babb3023820061d0e03c5cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b38c587b98059d002babb3023820061d0e03c5cf", "html_url": "https://github.com/rust-lang/rust/commit/b38c587b98059d002babb3023820061d0e03c5cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b38c587b98059d002babb3023820061d0e03c5cf/comments", "author": null, "committer": null, "parents": [{"sha": "5725726345039830677a0aeb8389ae78ce01ff97", "url": "https://api.github.com/repos/rust-lang/rust/commits/5725726345039830677a0aeb8389ae78ce01ff97", "html_url": "https://github.com/rust-lang/rust/commit/5725726345039830677a0aeb8389ae78ce01ff97"}], "stats": {"total": 267, "additions": 219, "deletions": 48}, "files": [{"sha": "83aca243275b2e2f39ac3f0fd58fc0f3bfe8366d", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 123, "deletions": 42, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/b38c587b98059d002babb3023820061d0e03c5cf/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38c587b98059d002babb3023820061d0e03c5cf/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=b38c587b98059d002babb3023820061d0e03c5cf", "patch": "@@ -1,4 +1,5 @@\n-use crate::utils::{is_adjusted, iter_input_pats, snippet_opt, span_lint_and_then};\n+use crate::utils::{is_adjusted, iter_input_pats, snippet_opt, span_lint_and_then, type_is_unsafe_function};\n+use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::ty;\n@@ -59,56 +60,136 @@ fn check_closure(cx: &LateContext<'_, '_>, expr: &Expr) {\n     if let ExprKind::Closure(_, ref decl, eid, _, _) = expr.node {\n         let body = cx.tcx.hir().body(eid);\n         let ex = &body.value;\n-        if let ExprKind::Call(ref caller, ref args) = ex.node {\n-            if args.len() != decl.inputs.len() {\n-                // Not the same number of arguments, there\n-                // is no way the closure is the same as the function\n-                return;\n-            }\n-            if is_adjusted(cx, ex) || args.iter().any(|arg| is_adjusted(cx, arg)) {\n-                // Are the expression or the arguments type-adjusted? Then we need the closure\n-                return;\n-            }\n+\n+        if_chain!(\n+            if let ExprKind::Call(ref caller, ref args) = ex.node;\n+\n+            // Not the same number of arguments, there is no way the closure is the same as the function return;\n+            if args.len() == decl.inputs.len();\n+\n+            // Are the expression or the arguments type-adjusted? Then we need the closure\n+            if !(is_adjusted(cx, ex) || args.iter().any(|arg| is_adjusted(cx, arg)));\n+\n             let fn_ty = cx.tables.expr_ty(caller);\n-            match fn_ty.sty {\n-                // Is it an unsafe function? They don't implement the closure traits\n-                ty::FnDef(..) | ty::FnPtr(_) => {\n-                    let sig = fn_ty.fn_sig(cx.tcx);\n-                    if sig.skip_binder().unsafety == Unsafety::Unsafe || sig.skip_binder().output().sty == ty::Never {\n-                        return;\n+            if !type_is_unsafe_function(cx, fn_ty);\n+\n+            if compare_inputs(&mut iter_input_pats(decl, body), &mut args.into_iter());\n+\n+            then {\n+                span_lint_and_then(cx, REDUNDANT_CLOSURE, expr.span, \"redundant closure found\", |db| {\n+                    if let Some(snippet) = snippet_opt(cx, caller.span) {\n+                        db.span_suggestion(\n+                            expr.span,\n+                            \"remove closure as shown\",\n+                            snippet,\n+                            Applicability::MachineApplicable,\n+                        );\n                     }\n-                },\n-                _ => (),\n+                });\n             }\n-            for (a1, a2) in iter_input_pats(decl, body).zip(args) {\n-                if let PatKind::Binding(.., ident, _) = a1.pat.node {\n-                    // XXXManishearth Should I be checking the binding mode here?\n-                    if let ExprKind::Path(QPath::Resolved(None, ref p)) = a2.node {\n-                        if p.segments.len() != 1 {\n-                            // If it's a proper path, it can't be a local variable\n-                            return;\n-                        }\n-                        if p.segments[0].ident.name != ident.name {\n-                            // The two idents should be the same\n-                            return;\n-                        }\n-                    } else {\n-                        return;\n-                    }\n-                } else {\n-                    return;\n-                }\n-            }\n-            span_lint_and_then(cx, REDUNDANT_CLOSURE, expr.span, \"redundant closure found\", |db| {\n-                if let Some(snippet) = snippet_opt(cx, caller.span) {\n+        );\n+\n+        if_chain!(\n+            if let ExprKind::MethodCall(ref path, _, ref args) = ex.node;\n+\n+            // Not the same number of arguments, there is no way the closure is the same as the function return;\n+            if args.len() == decl.inputs.len();\n+\n+            // Are the expression or the arguments type-adjusted? Then we need the closure\n+            if !(is_adjusted(cx, ex) || args.iter().skip(1).any(|arg| is_adjusted(cx, arg)));\n+\n+            let method_def_id = cx.tables.type_dependent_defs()[ex.hir_id].def_id();\n+            if !type_is_unsafe_function(cx, cx.tcx.type_of(method_def_id));\n+\n+            if compare_inputs(&mut iter_input_pats(decl, body), &mut args.into_iter());\n+\n+            if let Some(name) = get_ufcs_type_name(cx, method_def_id, &args[0]);\n+\n+            then {\n+                span_lint_and_then(cx, REDUNDANT_CLOSURE, expr.span, \"redundant closure found\", |db| {\n                     db.span_suggestion(\n                         expr.span,\n                         \"remove closure as shown\",\n-                        snippet,\n+                        format!(\"{}::{}\", name, path.ident.name),\n                         Applicability::MachineApplicable,\n                     );\n+                });\n+            }\n+        );\n+    }\n+}\n+\n+/// Tries to determine the type for universal function call to be used instead of the closure\n+fn get_ufcs_type_name(\n+    cx: &LateContext<'_, '_>,\n+    method_def_id: def_id::DefId,\n+    self_arg: &Expr,\n+) -> std::option::Option<String> {\n+    let expected_type_of_self = &cx.tcx.fn_sig(method_def_id).inputs_and_output().skip_binder()[0].sty;\n+    let actual_type_of_self = &cx.tables.node_id_to_type(self_arg.hir_id).sty;\n+\n+    if let Some(trait_id) = cx.tcx.trait_of_item(method_def_id) {\n+        //if the method expectes &self, ufcs requires explicit borrowing so closure can't be removed\n+        return match (expected_type_of_self, actual_type_of_self) {\n+            (ty::Ref(_, _, _), ty::Ref(_, _, _)) => Some(cx.tcx.item_path_str(trait_id)),\n+            (l, r) => match (l, r) {\n+                (ty::Ref(_, _, _), _) | (_, ty::Ref(_, _, _)) => None,\n+                (_, _) => Some(cx.tcx.item_path_str(trait_id)),\n+            },\n+        };\n+    }\n+\n+    cx.tcx.impl_of_method(method_def_id).and_then(|_| {\n+        //a type may implicitly implement other types methods (e.g. Deref)\n+        if match_types(expected_type_of_self, actual_type_of_self) {\n+            return Some(get_type_name(cx, &actual_type_of_self));\n+        }\n+        None\n+    })\n+}\n+\n+fn match_types(lhs: &ty::TyKind<'_>, rhs: &ty::TyKind<'_>) -> bool {\n+    match (lhs, rhs) {\n+        (ty::Bool, ty::Bool)\n+        | (ty::Char, ty::Char)\n+        | (ty::Int(_), ty::Int(_))\n+        | (ty::Uint(_), ty::Uint(_))\n+        | (ty::Str, ty::Str) => true,\n+        (ty::Ref(_, t1, _), ty::Ref(_, t2, _))\n+        | (ty::Array(t1, _), ty::Array(t2, _))\n+        | (ty::Slice(t1), ty::Slice(t2)) => match_types(&t1.sty, &t2.sty),\n+        (ty::Adt(def1, _), ty::Adt(def2, _)) => def1 == def2,\n+        (_, _) => false,\n+    }\n+}\n+\n+fn get_type_name(cx: &LateContext<'_, '_>, kind: &ty::TyKind<'_>) -> String {\n+    match kind {\n+        ty::Adt(t, _) => cx.tcx.item_path_str(t.did),\n+        ty::Ref(_, r, _) => get_type_name(cx, &r.sty),\n+        _ => kind.to_string(),\n+    }\n+}\n+\n+fn compare_inputs(closure_inputs: &mut dyn Iterator<Item = &Arg>, call_args: &mut dyn Iterator<Item = &Expr>) -> bool {\n+    for (closure_input, function_arg) in closure_inputs.zip(call_args) {\n+        if let PatKind::Binding(_, _, _, ident, _) = closure_input.pat.node {\n+            // XXXManishearth Should I be checking the binding mode here?\n+            if let ExprKind::Path(QPath::Resolved(None, ref p)) = function_arg.node {\n+                if p.segments.len() != 1 {\n+                    // If it's a proper path, it can't be a local variable\n+                    return false;\n                 }\n-            });\n+                if p.segments[0].ident.name != ident.name {\n+                    // The two idents should be the same\n+                    return false;\n+                }\n+            } else {\n+                return false;\n+            }\n+        } else {\n+            return false;\n         }\n     }\n+    true\n }"}, {"sha": "b482d37b1863377c6f0d2911a4646e47c7f16fb6", "filename": "tests/ui/eta.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b38c587b98059d002babb3023820061d0e03c5cf/tests%2Fui%2Feta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b38c587b98059d002babb3023820061d0e03c5cf/tests%2Fui%2Feta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.rs?ref=b38c587b98059d002babb3023820061d0e03c5cf", "patch": "@@ -9,6 +9,8 @@\n )]\n #![warn(clippy::redundant_closure, clippy::needless_borrow)]\n \n+use std::path::PathBuf;\n+\n fn main() {\n     let a = Some(1u8).map(|a| foo(a));\n     meta(|a| foo(a));\n@@ -26,6 +28,57 @@ fn main() {\n     // See #515\n     let a: Option<Box<::std::ops::Deref<Target = [i32]>>> =\n         Some(vec![1i32, 2]).map(|v| -> Box<::std::ops::Deref<Target = [i32]>> { Box::new(v) });\n+\n+}\n+\n+trait TestTrait {\n+    fn trait_foo(self) -> bool;\n+    fn trait_foo_ref(&self) -> bool;\n+}\n+\n+struct TestStruct<'a> {\n+    some_ref: &'a i32\n+}\n+\n+impl<'a> TestStruct<'a> {\n+    fn foo(self) -> bool { false }\n+    unsafe fn foo_unsafe(self) -> bool { true }\n+}\n+\n+impl<'a> TestTrait for TestStruct<'a> {\n+    fn trait_foo(self) -> bool { false }\n+    fn trait_foo_ref(&self) -> bool { false }\n+}\n+\n+impl<'a> std::ops::Deref for TestStruct<'a> {\n+    type Target = char;\n+    fn deref(&self) -> &char { &'a' }\n+}\n+\n+fn test_redundant_closures_containing_method_calls() {\n+    let i = 10;\n+    let e = Some(TestStruct{some_ref: &i}).map(|a| a.foo());\n+    let e = Some(TestStruct{some_ref: &i}).map(TestStruct::foo);\n+    let e = Some(TestStruct{some_ref: &i}).map(|a| a.trait_foo());\n+    let e = Some(TestStruct{some_ref: &i}).map(|a| a.trait_foo_ref());\n+    let e = Some(TestStruct{some_ref: &i}).map(TestTrait::trait_foo);\n+    let e = Some(&mut vec!(1,2,3)).map(|v| v.clear());\n+    let e = Some(&mut vec!(1,2,3)).map(std::vec::Vec::clear);\n+    unsafe {\n+        let e = Some(TestStruct{some_ref: &i}).map(|a| a.foo_unsafe());\n+    }\n+    let e = Some(\"str\").map(|s| s.to_string());\n+    let e = Some(\"str\").map(str::to_string);\n+    let e = Some('a').map(|s| s.to_uppercase());\n+    let e = Some('a').map(char::to_uppercase);\n+    let e: std::vec::Vec<usize> = vec!('a','b','c').iter().map(|c| c.len_utf8()).collect();\n+    let e: std::vec::Vec<char> = vec!('a','b','c').iter().map(|c| c.to_ascii_uppercase()).collect();\n+    let e: std::vec::Vec<char> = vec!('a','b','c').iter().map(char::to_ascii_uppercase).collect();\n+    let p = Some(PathBuf::new());\n+    let e = p.as_ref().and_then(|s| s.to_str());\n+    //let e = p.as_ref().and_then(std::path::Path::to_str);\n+    let c = Some(TestStruct{some_ref: &i}).as_ref().map(|c| c.to_ascii_uppercase());\n+    //let c = Some(TestStruct{some_ref: &i}).as_ref().map(char::to_ascii_uppercase);\n }\n \n fn meta<F>(f: F)\n@@ -61,3 +114,4 @@ fn divergent(_: u8) -> ! {\n fn generic<T>(_: T) -> u8 {\n     0\n }\n+"}, {"sha": "7d355f7215cf5c4cdaa5d402f196ebc800f7fbb7", "filename": "tests/ui/eta.stderr", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b38c587b98059d002babb3023820061d0e03c5cf/tests%2Fui%2Feta.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b38c587b98059d002babb3023820061d0e03c5cf/tests%2Fui%2Feta.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.stderr?ref=b38c587b98059d002babb3023820061d0e03c5cf", "patch": "@@ -1,36 +1,72 @@\n error: redundant closure found\n-  --> $DIR/eta.rs:13:27\n+  --> $DIR/eta.rs:15:27\n    |\n LL |     let a = Some(1u8).map(|a| foo(a));\n    |                           ^^^^^^^^^^ help: remove closure as shown: `foo`\n    |\n    = note: `-D clippy::redundant-closure` implied by `-D warnings`\n \n error: redundant closure found\n-  --> $DIR/eta.rs:14:10\n+  --> $DIR/eta.rs:16:10\n    |\n LL |     meta(|a| foo(a));\n    |          ^^^^^^^^^^ help: remove closure as shown: `foo`\n \n error: redundant closure found\n-  --> $DIR/eta.rs:15:27\n+  --> $DIR/eta.rs:17:27\n    |\n LL |     let c = Some(1u8).map(|a| {1+2; foo}(a));\n    |                           ^^^^^^^^^^^^^^^^^ help: remove closure as shown: `{1+2; foo}`\n \n error: this expression borrows a reference that is immediately dereferenced by the compiler\n-  --> $DIR/eta.rs:17:21\n+  --> $DIR/eta.rs:19:21\n    |\n LL |     all(&[1, 2, 3], &&2, |x, y| below(x, y)); //is adjusted\n    |                     ^^^ help: change this to: `&2`\n    |\n    = note: `-D clippy::needless-borrow` implied by `-D warnings`\n \n error: redundant closure found\n-  --> $DIR/eta.rs:24:27\n+  --> $DIR/eta.rs:26:27\n    |\n LL |     let e = Some(1u8).map(|a| generic(a));\n    |                           ^^^^^^^^^^^^^^ help: remove closure as shown: `generic`\n \n-error: aborting due to 5 previous errors\n+error: redundant closure found\n+  --> $DIR/eta.rs:60:48\n+   |\n+LL |     let e = Some(TestStruct{some_ref: &i}).map(|a| a.foo());\n+   |                                                ^^^^^^^^^^^ help: remove closure as shown: `TestStruct::foo`\n+\n+error: redundant closure found\n+  --> $DIR/eta.rs:62:48\n+   |\n+LL |     let e = Some(TestStruct{some_ref: &i}).map(|a| a.trait_foo());\n+   |                                                ^^^^^^^^^^^^^^^^^ help: remove closure as shown: `TestTrait::trait_foo`\n+\n+error: redundant closure found\n+  --> $DIR/eta.rs:65:40\n+   |\n+LL |     let e = Some(&mut vec!(1,2,3)).map(|v| v.clear());\n+   |                                        ^^^^^^^^^^^^^ help: remove closure as shown: `std::vec::Vec::clear`\n+\n+error: redundant closure found\n+  --> $DIR/eta.rs:70:29\n+   |\n+LL |     let e = Some(\"str\").map(|s| s.to_string());\n+   |                             ^^^^^^^^^^^^^^^^^ help: remove closure as shown: `std::string::ToString::to_string`\n+\n+error: redundant closure found\n+  --> $DIR/eta.rs:72:27\n+   |\n+LL |     let e = Some('a').map(|s| s.to_uppercase());\n+   |                           ^^^^^^^^^^^^^^^^^^^^ help: remove closure as shown: `char::to_uppercase`\n+\n+error: redundant closure found\n+  --> $DIR/eta.rs:75:63\n+   |\n+LL |     let e: std::vec::Vec<char> = vec!('a','b','c').iter().map(|c| c.to_ascii_uppercase()).collect();\n+   |                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove closure as shown: `char::to_ascii_uppercase`\n+\n+error: aborting due to 11 previous errors\n "}]}