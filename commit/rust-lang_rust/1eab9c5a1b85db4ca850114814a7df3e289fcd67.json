{"sha": "1eab9c5a1b85db4ca850114814a7df3e289fcd67", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlYWI5YzVhMWI4NWRiNGNhODUwMTE0ODE0YTdkZjNlMjg5ZmNkNjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-04T00:16:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-04T00:16:41Z"}, "message": "Auto merge of #50397 - sgrif:sg-smaller-universe-refactorings, r=nikomatsakis\n\nRefactorings in preparation for the removal of the leak check\n\nThis contains all of the commits from #48407 that I was able to pull out on their own. This has most of the refactoring/ground work to unblock other work, but without the behavior changes that still need a crater run and NLL changes.\n\nr? @nikomatsakis", "tree": {"sha": "54fc3bbf4d97538db2a21ef36482ca485663ec25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54fc3bbf4d97538db2a21ef36482ca485663ec25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1eab9c5a1b85db4ca850114814a7df3e289fcd67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1eab9c5a1b85db4ca850114814a7df3e289fcd67", "html_url": "https://github.com/rust-lang/rust/commit/1eab9c5a1b85db4ca850114814a7df3e289fcd67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1eab9c5a1b85db4ca850114814a7df3e289fcd67/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e82261dfbb5feaa2d28d2b138f4aabb2aa52c94b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e82261dfbb5feaa2d28d2b138f4aabb2aa52c94b", "html_url": "https://github.com/rust-lang/rust/commit/e82261dfbb5feaa2d28d2b138f4aabb2aa52c94b"}, {"sha": "68a1fdfee49eeca4d3379423879c5299b5d8e0b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/68a1fdfee49eeca4d3379423879c5299b5d8e0b0", "html_url": "https://github.com/rust-lang/rust/commit/68a1fdfee49eeca4d3379423879c5299b5d8e0b0"}], "stats": {"total": 324, "additions": 168, "deletions": 156}, "files": [{"sha": "ccba5a09cf6cc92433f3430288ad30cb567d4389", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1eab9c5a1b85db4ca850114814a7df3e289fcd67/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eab9c5a1b85db4ca850114814a7df3e289fcd67/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=1eab9c5a1b85db4ca850114814a7df3e289fcd67", "patch": "@@ -407,7 +407,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                             drop(variables);\n                             self.relate(&u, &u)\n                         }\n-                        TypeVariableValue::Unknown { .. } => {\n+                        TypeVariableValue::Unknown { universe } => {\n                             match self.ambient_variance {\n                                 // Invariant: no need to make a fresh type variable.\n                                 ty::Invariant => return Ok(t),\n@@ -424,7 +424,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                             }\n \n                             let origin = *variables.var_origin(vid);\n-                            let new_var_id = variables.new_var(false, origin);\n+                            let new_var_id = variables.new_var(universe, false, origin);\n                             let u = self.tcx().mk_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\",\n                                    vid, u);"}, {"sha": "b8437e39ddca48c6118fbbc91ba5e0b52fed6297", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1eab9c5a1b85db4ca850114814a7df3e289fcd67/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eab9c5a1b85db4ca850114814a7df3e289fcd67/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=1eab9c5a1b85db4ca850114814a7df3e289fcd67", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             // Second, we instantiate each bound region in the supertype with a\n             // fresh concrete region.\n             let (b_prime, skol_map) =\n-                self.infcx.skolemize_late_bound_regions(b, snapshot);\n+                self.infcx.skolemize_late_bound_regions(b);\n \n             debug!(\"a_prime={:?}\", a_prime);\n             debug!(\"b_prime={:?}\", b_prime);\n@@ -114,7 +114,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             // First, we instantiate each bound region in the matcher\n             // with a skolemized region.\n             let ((a_match, a_value), skol_map) =\n-                self.infcx.skolemize_late_bound_regions(a_pair, snapshot);\n+                self.infcx.skolemize_late_bound_regions(a_pair);\n \n             debug!(\"higher_ranked_match: a_match={:?}\", a_match);\n             debug!(\"higher_ranked_match: skol_map={:?}\", skol_map);\n@@ -587,14 +587,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/trait-hrtb.html\n     pub fn skolemize_late_bound_regions<T>(&self,\n-                                           binder: &ty::Binder<T>,\n-                                           snapshot: &CombinedSnapshot<'a, 'tcx>)\n+                                           binder: &ty::Binder<T>)\n                                            -> (T, SkolemizationMap<'tcx>)\n         where T : TypeFoldable<'tcx>\n     {\n         let (result, map) = self.tcx.replace_late_bound_regions(binder, |br| {\n-            self.borrow_region_constraints()\n-                .push_skolemized(self.tcx, br, &snapshot.region_constraints_snapshot)\n+            self.universe.set(self.universe().subuniverse());\n+            self.tcx.mk_region(ty::ReSkolemized(self.universe(), br))\n         });\n \n         debug!(\"skolemize_bound_regions(binder={:?}, result={:?}, map={:?})\",\n@@ -779,7 +778,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"pop_skolemized({:?})\", skol_map);\n         let skol_regions: FxHashSet<_> = skol_map.values().cloned().collect();\n         self.borrow_region_constraints()\n-            .pop_skolemized(self.tcx, &skol_regions, &snapshot.region_constraints_snapshot);\n+            .pop_skolemized(self.universe(), &skol_regions, &snapshot.region_constraints_snapshot);\n+        self.universe.set(snapshot.universe);\n         if !skol_map.is_empty() {\n             self.projection_cache.borrow_mut().rollback_skolemized(\n                 &snapshot.projection_cache_snapshot);"}, {"sha": "5984a831e6fa0eeb4028a539040af99763d2de31", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1eab9c5a1b85db4ca850114814a7df3e289fcd67/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eab9c5a1b85db4ca850114814a7df3e289fcd67/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=1eab9c5a1b85db4ca850114814a7df3e289fcd67", "patch": "@@ -15,7 +15,7 @@ use infer::RegionVariableOrigin;\n use infer::region_constraints::Constraint;\n use infer::region_constraints::GenericKind;\n use infer::region_constraints::RegionConstraintData;\n-use infer::region_constraints::VarOrigins;\n+use infer::region_constraints::VarInfos;\n use infer::region_constraints::VerifyBound;\n use middle::free_region::RegionRelations;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n@@ -37,7 +37,7 @@ mod graphviz;\n /// all the variables as well as a set of errors that must be reported.\n pub fn resolve<'tcx>(\n     region_rels: &RegionRelations<'_, '_, 'tcx>,\n-    var_origins: VarOrigins,\n+    var_infos: VarInfos,\n     data: RegionConstraintData<'tcx>,\n ) -> (\n     LexicalRegionResolutions<'tcx>,\n@@ -47,7 +47,7 @@ pub fn resolve<'tcx>(\n     let mut errors = vec![];\n     let mut resolver = LexicalResolver {\n         region_rels,\n-        var_origins,\n+        var_infos,\n         data,\n     };\n     let values = resolver.infer_variable_values(&mut errors);\n@@ -103,7 +103,7 @@ type RegionGraph<'tcx> = graph::Graph<(), Constraint<'tcx>>;\n \n struct LexicalResolver<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     region_rels: &'cx RegionRelations<'cx, 'gcx, 'tcx>,\n-    var_origins: VarOrigins,\n+    var_infos: VarInfos,\n     data: RegionConstraintData<'tcx>,\n }\n \n@@ -132,7 +132,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n     }\n \n     fn num_vars(&self) -> usize {\n-        self.var_origins.len()\n+        self.var_infos.len()\n     }\n \n     /// Initially, the value for all variables is set to `'empty`, the\n@@ -279,7 +279,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n \n             (&ReVar(v_id), _) | (_, &ReVar(v_id)) => {\n                 span_bug!(\n-                    self.var_origins[v_id].span(),\n+                    self.var_infos[v_id].origin.span(),\n                     \"lub_concrete_regions invoked with non-concrete \\\n                      regions: {:?}, {:?}\",\n                     a,\n@@ -576,7 +576,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n                 if !self.region_rels\n                     .is_subregion_of(lower_bound.region, upper_bound.region)\n                 {\n-                    let origin = self.var_origins[node_idx].clone();\n+                    let origin = self.var_infos[node_idx].origin.clone();\n                     debug!(\n                         \"region inference error at {:?} for {:?}: SubSupConflict sub: {:?} \\\n                          sup: {:?}\",\n@@ -598,7 +598,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n         }\n \n         span_bug!(\n-            self.var_origins[node_idx].span(),\n+            self.var_infos[node_idx].origin.span(),\n             \"collect_error_for_expanding_node() could not find \\\n              error for var {:?}, lower_bounds={:?}, \\\n              upper_bounds={:?}\","}, {"sha": "c62e7f8d9b6350a8a20350625a08c0b9f8039909", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 38, "deletions": 14, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1eab9c5a1b85db4ca850114814a7df3e289fcd67/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eab9c5a1b85db4ca850114814a7df3e289fcd67/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=1eab9c5a1b85db4ca850114814a7df3e289fcd67", "patch": "@@ -42,7 +42,7 @@ use arena::SyncDroplessArena;\n use self::combine::CombineFields;\n use self::higher_ranked::HrMatchResult;\n use self::region_constraints::{RegionConstraintCollector, RegionSnapshot};\n-use self::region_constraints::{GenericKind, VerifyBound, RegionConstraintData, VarOrigins};\n+use self::region_constraints::{GenericKind, VerifyBound, RegionConstraintData, VarInfos};\n use self::lexical_region_resolve::LexicalRegionResolutions;\n use self::outlives::env::OutlivesEnvironment;\n use self::type_variable::TypeVariableOrigin;\n@@ -183,6 +183,17 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // obligations within. This is expected to be done 'late enough'\n     // that all type inference variables have been bound and so forth.\n     pub region_obligations: RefCell<Vec<(ast::NodeId, RegionObligation<'tcx>)>>,\n+\n+    /// What is the innermost universe we have created? Starts out as\n+    /// `UniverseIndex::root()` but grows from there as we enter\n+    /// universal quantifiers.\n+    ///\n+    /// NB: At present, we exclude the universal quantifiers on the\n+    /// item we are type-checking, and just consider those names as\n+    /// part of the root universe. So this would only get incremented\n+    /// when we enter into a higher-ranked (`for<..>`) type or trait\n+    /// bound.\n+    universe: Cell<ty::UniverseIndex>,\n }\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n@@ -455,6 +466,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             err_count_on_creation: tcx.sess.err_count(),\n             in_snapshot: Cell::new(false),\n             region_obligations: RefCell::new(vec![]),\n+            universe: Cell::new(ty::UniverseIndex::ROOT),\n         }))\n     }\n }\n@@ -489,6 +501,7 @@ pub struct CombinedSnapshot<'a, 'tcx:'a> {\n     float_snapshot: ut::Snapshot<ut::InPlace<ty::FloatVid>>,\n     region_constraints_snapshot: RegionSnapshot,\n     region_obligations_snapshot: usize,\n+    universe: ty::UniverseIndex,\n     was_in_snapshot: bool,\n     _in_progress_tables: Option<Ref<'a, ty::TypeckTables<'tcx>>>,\n }\n@@ -618,6 +631,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             float_snapshot: self.float_unification_table.borrow_mut().snapshot(),\n             region_constraints_snapshot: self.borrow_region_constraints().start_snapshot(),\n             region_obligations_snapshot: self.region_obligations.borrow().len(),\n+            universe: self.universe(),\n             was_in_snapshot: in_snapshot,\n             // Borrow tables \"in progress\" (i.e. during typeck)\n             // to ban writes from within a snapshot to them.\n@@ -635,10 +649,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                float_snapshot,\n                                region_constraints_snapshot,\n                                region_obligations_snapshot,\n+                               universe,\n                                was_in_snapshot,\n                                _in_progress_tables } = snapshot;\n \n         self.in_snapshot.set(was_in_snapshot);\n+        self.universe.set(universe);\n \n         self.projection_cache\n             .borrow_mut()\n@@ -667,6 +683,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                float_snapshot,\n                                region_constraints_snapshot,\n                                region_obligations_snapshot: _,\n+                               universe: _,\n                                was_in_snapshot,\n                                _in_progress_tables } = snapshot;\n \n@@ -811,7 +828,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         Some(self.commit_if_ok(|snapshot| {\n             let (ty::SubtypePredicate { a_is_expected, a, b}, skol_map) =\n-                self.skolemize_late_bound_regions(predicate, snapshot);\n+                self.skolemize_late_bound_regions(predicate);\n \n             let cause_span = cause.span;\n             let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n@@ -828,7 +845,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     {\n         self.commit_if_ok(|snapshot| {\n             let (ty::OutlivesPredicate(r_a, r_b), skol_map) =\n-                self.skolemize_late_bound_regions(predicate, snapshot);\n+                self.skolemize_late_bound_regions(predicate);\n             let origin =\n                 SubregionOrigin::from_obligation_cause(cause,\n                                                        || RelateRegionParamBound(cause.span));\n@@ -841,7 +858,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n         self.type_variables\n             .borrow_mut()\n-            .new_var(diverging, origin)\n+            .new_var(self.universe(), diverging, origin)\n     }\n \n     pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n@@ -872,12 +889,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///   during diagnostics / error-reporting.\n     pub fn next_region_var(&self, origin: RegionVariableOrigin)\n                            -> ty::Region<'tcx> {\n-        self.tcx.mk_region(ty::ReVar(self.borrow_region_constraints().new_region_var(origin)))\n+        let region_var = self.borrow_region_constraints()\n+            .new_region_var(self.universe(), origin);\n+        self.tcx.mk_region(ty::ReVar(region_var))\n     }\n \n     /// Number of region variables created so far.\n     pub fn num_region_vars(&self) -> usize {\n-        self.borrow_region_constraints().var_origins().len()\n+        self.borrow_region_constraints().num_region_vars()\n     }\n \n     /// Just a convenient wrapper of `next_region_var` for using during NLL.\n@@ -909,7 +928,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             -> Ty<'tcx> {\n         let ty_var_id = self.type_variables\n                             .borrow_mut()\n-                            .new_var(false,\n+                            .new_var(self.universe(),\n+                                     false,\n                                      TypeVariableOrigin::TypeParameterDefinition(span, def.name));\n \n         self.tcx.mk_var(ty_var_id)\n@@ -1004,12 +1024,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                 region_context,\n                                                 region_map,\n                                                 outlives_env.free_region_map());\n-        let (var_origins, data) = self.region_constraints.borrow_mut()\n+        let (var_infos, data) = self.region_constraints.borrow_mut()\n                                                          .take()\n                                                          .expect(\"regions already resolved\")\n-                                                         .into_origins_and_data();\n+                                                         .into_infos_and_data();\n         let (lexical_region_resolutions, errors) =\n-            lexical_region_resolve::resolve(region_rels, var_origins, data);\n+            lexical_region_resolve::resolve(region_rels, var_infos, data);\n \n         let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n         assert!(old_value.is_none());\n@@ -1057,13 +1077,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// hence that `resolve_regions_and_report_errors` can never be\n     /// called. This is used only during NLL processing to \"hand off\" ownership\n     /// of the set of region vairables into the NLL region context.\n-    pub fn take_region_var_origins(&self) -> VarOrigins {\n-        let (var_origins, data) = self.region_constraints.borrow_mut()\n+    pub fn take_region_var_origins(&self) -> VarInfos {\n+        let (var_infos, data) = self.region_constraints.borrow_mut()\n                                                          .take()\n                                                          .expect(\"regions already resolved\")\n-                                                         .into_origins_and_data();\n+                                                         .into_infos_and_data();\n         assert!(data.is_empty());\n-        var_origins\n+        var_infos\n     }\n \n     pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n@@ -1356,6 +1376,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.evaluation_cache.clear();\n         self.projection_cache.borrow_mut().clear();\n     }\n+\n+    fn universe(&self) -> ty::UniverseIndex {\n+        self.universe.get()\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {"}, {"sha": "c388fa21371923ae3e23e3fd25c2bbf86c4e31e6", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 67, "deletions": 97, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/1eab9c5a1b85db4ca850114814a7df3e289fcd67/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eab9c5a1b85db4ca850114814a7df3e289fcd67/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=1eab9c5a1b85db4ca850114814a7df3e289fcd67", "patch": "@@ -22,18 +22,16 @@ use rustc_data_structures::unify as ut;\n use ty::{self, Ty, TyCtxt};\n use ty::{Region, RegionVid};\n use ty::ReStatic;\n-use ty::{BrFresh, ReLateBound, ReSkolemized, ReVar};\n+use ty::{BrFresh, ReLateBound, ReVar};\n \n use std::collections::BTreeMap;\n-use std::fmt;\n-use std::mem;\n-use std::u32;\n+use std::{cmp, fmt, mem, u32};\n \n mod taint;\n \n pub struct RegionConstraintCollector<'tcx> {\n     /// For each `RegionVid`, the corresponding `RegionVariableOrigin`.\n-    var_origins: IndexVec<RegionVid, RegionVariableOrigin>,\n+    var_infos: IndexVec<RegionVid, RegionVariableInfo>,\n \n     data: RegionConstraintData<'tcx>,\n \n@@ -47,9 +45,6 @@ pub struct RegionConstraintCollector<'tcx> {\n     /// exist). This prevents us from making many such regions.\n     glbs: CombineMap<'tcx>,\n \n-    /// Number of skolemized variables currently active.\n-    skolemization_count: u32,\n-\n     /// Global counter used during the GLB algorithm to create unique\n     /// names for fresh bound regions\n     bound_count: u32,\n@@ -76,7 +71,7 @@ pub struct RegionConstraintCollector<'tcx> {\n     unification_table: ut::UnificationTable<ut::InPlace<ty::RegionVid>>,\n }\n \n-pub type VarOrigins = IndexVec<RegionVid, RegionVariableOrigin>;\n+pub type VarInfos = IndexVec<RegionVid, RegionVariableInfo>;\n \n /// The full set of region constraints gathered up by the collector.\n /// Describes constraints between the region variables and other\n@@ -230,10 +225,15 @@ enum CombineMapType {\n \n type CombineMap<'tcx> = FxHashMap<TwoRegions<'tcx>, RegionVid>;\n \n+#[derive(Debug, Clone, Copy)]\n+pub struct RegionVariableInfo {\n+    pub origin: RegionVariableOrigin,\n+    pub universe: ty::UniverseIndex,\n+}\n+\n pub struct RegionSnapshot {\n     length: usize,\n     region_snapshot: ut::Snapshot<ut::InPlace<ty::RegionVid>>,\n-    skolemization_count: u32,\n }\n \n /// When working with skolemized regions, we often wish to find all of\n@@ -273,19 +273,18 @@ impl TaintDirections {\n impl<'tcx> RegionConstraintCollector<'tcx> {\n     pub fn new() -> RegionConstraintCollector<'tcx> {\n         RegionConstraintCollector {\n-            var_origins: VarOrigins::default(),\n+            var_infos: VarInfos::default(),\n             data: RegionConstraintData::default(),\n             lubs: FxHashMap(),\n             glbs: FxHashMap(),\n-            skolemization_count: 0,\n             bound_count: 0,\n             undo_log: Vec::new(),\n             unification_table: ut::UnificationTable::new(),\n         }\n     }\n \n-    pub fn var_origins(&self) -> &VarOrigins {\n-        &self.var_origins\n+    pub fn num_region_vars(&self) -> usize {\n+        self.var_infos.len()\n     }\n \n     pub fn region_constraint_data(&self) -> &RegionConstraintData<'tcx> {\n@@ -295,9 +294,9 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     /// Once all the constraints have been gathered, extract out the final data.\n     ///\n     /// Not legal during a snapshot.\n-    pub fn into_origins_and_data(self) -> (VarOrigins, RegionConstraintData<'tcx>) {\n+    pub fn into_infos_and_data(self) -> (VarInfos, RegionConstraintData<'tcx>) {\n         assert!(!self.in_snapshot());\n-        (self.var_origins, self.data)\n+        (self.var_infos, self.data)\n     }\n \n     /// Takes (and clears) the current set of constraints. Note that\n@@ -319,18 +318,15 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         // should think carefully about whether it needs to be cleared\n         // or updated in some way.\n         let RegionConstraintCollector {\n-            var_origins,\n+            var_infos,\n             data,\n             lubs,\n             glbs,\n-            skolemization_count,\n             bound_count: _,\n             undo_log: _,\n             unification_table,\n         } = self;\n \n-        assert_eq!(*skolemization_count, 0);\n-\n         // Clear the tables of (lubs, glbs), so that we will create\n         // fresh regions if we do a LUB operation. As it happens,\n         // LUB/GLB are not performed by the MIR type-checker, which is\n@@ -343,7 +339,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         // also insert `a <= b` and a `b <= a` edges, so the\n         // `RegionConstraintData` contains the relationship here.\n         *unification_table = ut::UnificationTable::new();\n-        for vid in var_origins.indices() {\n+        for vid in var_infos.indices() {\n             unification_table.new_key(unify_key::RegionVidKey { min_vid: vid });\n         }\n \n@@ -365,20 +361,13 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         RegionSnapshot {\n             length,\n             region_snapshot: self.unification_table.snapshot(),\n-            skolemization_count: self.skolemization_count,\n         }\n     }\n \n     pub fn commit(&mut self, snapshot: RegionSnapshot) {\n         debug!(\"RegionConstraintCollector: commit({})\", snapshot.length);\n         assert!(self.undo_log.len() > snapshot.length);\n         assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n-        assert!(\n-            self.skolemization_count == snapshot.skolemization_count,\n-            \"failed to pop skolemized regions: {} now vs {} at start\",\n-            self.skolemization_count,\n-            snapshot.skolemization_count\n-        );\n \n         if snapshot.length == 0 {\n             self.undo_log.truncate(0);\n@@ -398,7 +387,6 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         }\n         let c = self.undo_log.pop().unwrap();\n         assert!(c == OpenSnapshot);\n-        self.skolemization_count = snapshot.skolemization_count;\n         self.unification_table.rollback_to(snapshot.region_snapshot);\n     }\n \n@@ -411,8 +399,8 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n                 // nothing to do here\n             }\n             AddVar(vid) => {\n-                self.var_origins.pop().unwrap();\n-                assert_eq!(self.var_origins.len(), vid.index() as usize);\n+                self.var_infos.pop().unwrap();\n+                assert_eq!(self.var_infos.len(), vid.index() as usize);\n             }\n             AddConstraint(ref constraint) => {\n                 self.data.constraints.remove(constraint);\n@@ -433,8 +421,13 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         }\n     }\n \n-    pub fn new_region_var(&mut self, origin: RegionVariableOrigin) -> RegionVid {\n-        let vid = self.var_origins.push(origin.clone());\n+    pub fn new_region_var(&mut self,\n+                          universe: ty::UniverseIndex,\n+                          origin: RegionVariableOrigin) -> RegionVid {\n+        let vid = self.var_infos.push(RegionVariableInfo {\n+            origin,\n+            universe,\n+        });\n \n         let u_vid = self.unification_table\n             .new_key(unify_key::RegionVidKey { min_vid: vid });\n@@ -450,44 +443,14 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         return vid;\n     }\n \n-    /// Returns the origin for the given variable.\n-    pub fn var_origin(&self, vid: RegionVid) -> RegionVariableOrigin {\n-        self.var_origins[vid].clone()\n+    /// Returns the universe for the given variable.\n+    pub fn var_universe(&self, vid: RegionVid) -> ty::UniverseIndex {\n+        self.var_infos[vid].universe\n     }\n \n-    /// Creates a new skolemized region. Skolemized regions are fresh\n-    /// regions used when performing higher-ranked computations. They\n-    /// must be used in a very particular way and are never supposed\n-    /// to \"escape\" out into error messages or the code at large.\n-    ///\n-    /// The idea is to always create a snapshot. Skolemized regions\n-    /// can be created in the context of this snapshot, but before the\n-    /// snapshot is committed or rolled back, they must be popped\n-    /// (using `pop_skolemized_regions`), so that their numbers can be\n-    /// recycled. Normally you don't have to think about this: you use\n-    /// the APIs in `higher_ranked/mod.rs`, such as\n-    /// `skolemize_late_bound_regions` and `plug_leaks`, which will\n-    /// guide you on this path (ensure that the `SkolemizationMap` is\n-    /// consumed and you are good). For more info on how skolemization\n-    /// for HRTBs works, see the [rustc guide].\n-    ///\n-    /// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/trait-hrtb.html\n-    ///\n-    /// The `snapshot` argument to this function is not really used;\n-    /// it's just there to make it explicit which snapshot bounds the\n-    /// skolemized region that results. It should always be the top-most snapshot.\n-    pub fn push_skolemized(\n-        &mut self,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-        br: ty::BoundRegion,\n-        snapshot: &RegionSnapshot,\n-    ) -> Region<'tcx> {\n-        assert!(self.in_snapshot());\n-        assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n-\n-        let sc = self.skolemization_count;\n-        self.skolemization_count = sc + 1;\n-        tcx.mk_region(ReSkolemized(ty::SkolemizedRegionVid { index: sc }, br))\n+    /// Returns the origin for the given variable.\n+    pub fn var_origin(&self, vid: RegionVid) -> RegionVariableOrigin {\n+        self.var_infos[vid].origin\n     }\n \n     /// Removes all the edges to/from the skolemized regions that are\n@@ -496,7 +459,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     /// created in that time.\n     pub fn pop_skolemized(\n         &mut self,\n-        _tcx: TyCtxt<'_, '_, 'tcx>,\n+        skolemization_count: ty::UniverseIndex,\n         skols: &FxHashSet<ty::Region<'tcx>>,\n         snapshot: &RegionSnapshot,\n     ) {\n@@ -505,36 +468,28 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         assert!(self.in_snapshot());\n         assert!(self.undo_log[snapshot.length] == OpenSnapshot);\n         assert!(\n-            self.skolemization_count as usize >= skols.len(),\n+            skolemization_count.as_usize() >= skols.len(),\n             \"popping more skolemized variables than actually exist, \\\n-             sc now = {}, skols.len = {}\",\n-            self.skolemization_count,\n+             sc now = {:?}, skols.len = {:?}\",\n+            skolemization_count,\n             skols.len()\n         );\n \n-        let last_to_pop = self.skolemization_count;\n-        let first_to_pop = last_to_pop - (skols.len() as u32);\n+        let last_to_pop = skolemization_count.subuniverse();\n+        let first_to_pop = ty::UniverseIndex::from(last_to_pop.as_u32() - skols.len() as u32);\n \n-        assert!(\n-            first_to_pop >= snapshot.skolemization_count,\n-            \"popping more regions than snapshot contains, \\\n-             sc now = {}, sc then = {}, skols.len = {}\",\n-            self.skolemization_count,\n-            snapshot.skolemization_count,\n-            skols.len()\n-        );\n         debug_assert! {\n             skols.iter()\n                  .all(|&k| match *k {\n-                     ty::ReSkolemized(index, _) =>\n-                         index.index >= first_to_pop &&\n-                         index.index < last_to_pop,\n+                     ty::ReSkolemized(universe, _) =>\n+                         universe >= first_to_pop &&\n+                         universe < last_to_pop,\n                      _ =>\n                          false\n                  }),\n-            \"invalid skolemization keys or keys out of range ({}..{}): {:?}\",\n-            snapshot.skolemization_count,\n-            self.skolemization_count,\n+            \"invalid skolemization keys or keys out of range ({:?}..{:?}): {:?}\",\n+            first_to_pop,\n+            last_to_pop,\n             skols\n         }\n \n@@ -551,7 +506,6 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             self.rollback_undo_entry(undo_entry);\n         }\n \n-        self.skolemization_count = snapshot.skolemization_count;\n         return;\n \n         fn kill_constraint<'tcx>(\n@@ -805,7 +759,10 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         if let Some(&c) = self.combine_map(t).get(&vars) {\n             return tcx.mk_region(ReVar(c));\n         }\n-        let c = self.new_region_var(MiscVariable(origin.span()));\n+        let a_universe = self.universe(a);\n+        let b_universe = self.universe(b);\n+        let c_universe = cmp::max(a_universe, b_universe);\n+        let c = self.new_region_var(c_universe, MiscVariable(origin.span()));\n         self.combine_map(t).insert(vars, c);\n         if self.in_snapshot() {\n             self.undo_log.push(AddCombination(t, vars));\n@@ -821,6 +778,24 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         new_r\n     }\n \n+    fn universe(&self, region: Region<'tcx>) -> ty::UniverseIndex {\n+        match *region {\n+            ty::ReScope(..) |\n+            ty::ReStatic |\n+            ty::ReEmpty |\n+            ty::ReErased |\n+            ty::ReFree(..) |\n+            ty::ReEarlyBound(..) => ty::UniverseIndex::ROOT,\n+            ty::ReSkolemized(universe, _) => universe,\n+            ty::ReClosureBound(vid) |\n+            ty::ReVar(vid) => self.var_universe(vid),\n+            ty::ReLateBound(..) =>\n+                bug!(\"universe(): encountered bound region {:?}\", region),\n+            ty::ReCanonical(..) =>\n+                bug!(\"region_universe(): encountered canonical region {:?}\", region),\n+        }\n+    }\n+\n     pub fn vars_created_since_snapshot(&self, mark: &RegionSnapshot) -> Vec<RegionVid> {\n         self.undo_log[mark.length..]\n             .iter()\n@@ -865,12 +840,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n impl fmt::Debug for RegionSnapshot {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(\n-            f,\n-            \"RegionSnapshot(length={},skolemization={})\",\n-            self.length,\n-            self.skolemization_count\n-        )\n+        write!(f, \"RegionSnapshot(length={})\", self.length)\n     }\n }\n "}, {"sha": "d40e1b3760f0361a2bcf62877c1f528d46159269", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1eab9c5a1b85db4ca850114814a7df3e289fcd67/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eab9c5a1b85db4ca850114814a7df3e289fcd67/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=1eab9c5a1b85db4ca850114814a7df3e289fcd67", "patch": "@@ -78,10 +78,12 @@ struct TypeVariableData {\n #[derive(Copy, Clone, Debug)]\n pub enum TypeVariableValue<'tcx> {\n     Known { value: Ty<'tcx> },\n-    Unknown,\n+    Unknown { universe: ty::UniverseIndex },\n }\n \n impl<'tcx> TypeVariableValue<'tcx> {\n+    /// If this value is known, returns the type it is known to be.\n+    /// Otherwise, `None`.\n     pub fn known(&self) -> Option<Ty<'tcx>> {\n         match *self {\n             TypeVariableValue::Unknown { .. } => None,\n@@ -181,10 +183,11 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     ///   The code in this module doesn't care, but it can be useful\n     ///   for improving error messages.\n     pub fn new_var(&mut self,\n+                   universe: ty::UniverseIndex,\n                    diverging: bool,\n                    origin: TypeVariableOrigin)\n                    -> ty::TyVid {\n-        let eq_key = self.eq_relations.new_key(TypeVariableValue::Unknown);\n+        let eq_key = self.eq_relations.new_key(TypeVariableValue::Unknown { universe });\n \n         let sub_key = self.sub_relations.new_key(());\n         assert_eq!(eq_key.vid, sub_key);\n@@ -437,7 +440,16 @@ impl<'tcx> ut::UnifyValue for TypeVariableValue<'tcx> {\n             (&TypeVariableValue::Unknown { .. }, &TypeVariableValue::Known { .. }) => Ok(*value2),\n \n             // If both sides are *unknown*, it hardly matters, does it?\n-            (&TypeVariableValue::Unknown, &TypeVariableValue::Unknown) => Ok(*value1),\n+            (&TypeVariableValue::Unknown { universe: universe1 },\n+             &TypeVariableValue::Unknown { universe: universe2 }) =>  {\n+                // If we unify two unbound variables, ?T and ?U, then whatever\n+                // value they wind up taking (which must be the same value) must\n+                // be nameable by both universes. Therefore, the resulting\n+                // universe is the minimum of the two universes, because that is\n+                // the one which contains the fewest names in scope.\n+                let universe = cmp::min(universe1, universe2);\n+                Ok(TypeVariableValue::Unknown { universe })\n+            }\n         }\n     }\n }"}, {"sha": "45fa588bbf5334f821beec5a26a839d722d28274", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1eab9c5a1b85db4ca850114814a7df3e289fcd67/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eab9c5a1b85db4ca850114814a7df3e289fcd67/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=1eab9c5a1b85db4ca850114814a7df3e289fcd67", "patch": "@@ -188,7 +188,7 @@ pub fn poly_project_and_unify_type<'cx, 'gcx, 'tcx>(\n     let infcx = selcx.infcx();\n     infcx.commit_if_ok(|snapshot| {\n         let (skol_predicate, skol_map) =\n-            infcx.skolemize_late_bound_regions(&obligation.predicate, snapshot);\n+            infcx.skolemize_late_bound_regions(&obligation.predicate);\n \n         let skol_obligation = obligation.with(skol_predicate);\n         let r = match project_and_unify_type(selcx, &skol_obligation) {"}, {"sha": "54b2cf2808282fba665ed7f2ac777a088a59c458", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1eab9c5a1b85db4ca850114814a7df3e289fcd67/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eab9c5a1b85db4ca850114814a7df3e289fcd67/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=1eab9c5a1b85db4ca850114814a7df3e289fcd67", "patch": "@@ -1509,7 +1509,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let poly_trait_predicate =\n             self.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n         let (skol_trait_predicate, skol_map) =\n-            self.infcx().skolemize_late_bound_regions(&poly_trait_predicate, snapshot);\n+            self.infcx().skolemize_late_bound_regions(&poly_trait_predicate);\n         debug!(\"match_projection_obligation_against_definition_bounds: \\\n                 skol_trait_predicate={:?} skol_map={:?}\",\n                skol_trait_predicate,\n@@ -2338,7 +2338,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             self.in_snapshot(|this, snapshot| {\n                 let (skol_ty, skol_map) =\n-                    this.infcx().skolemize_late_bound_regions(&ty, snapshot);\n+                    this.infcx().skolemize_late_bound_regions(&ty);\n                 let Normalized { value: normalized_ty, mut obligations } =\n                     project::normalize_with_depth(this,\n                                                   param_env,\n@@ -2559,7 +2559,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let trait_obligations = self.in_snapshot(|this, snapshot| {\n             let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n             let (trait_ref, skol_map) =\n-                this.infcx().skolemize_late_bound_regions(&poly_trait_ref, snapshot);\n+                this.infcx().skolemize_late_bound_regions(&poly_trait_ref);\n             let cause = obligation.derived_cause(ImplDerivedObligation);\n             this.impl_or_trait_obligations(cause,\n                                            obligation.recursion_depth + 1,\n@@ -3142,8 +3142,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         }\n \n         let (skol_obligation, skol_map) = self.infcx().skolemize_late_bound_regions(\n-            &obligation.predicate,\n-            snapshot);\n+            &obligation.predicate);\n         let skol_obligation_trait_ref = skol_obligation.trait_ref;\n \n         let impl_substs = self.infcx.fresh_substs_for_item(obligation.cause.span,"}, {"sha": "c4fe112a9e913206ffbd1466d14cb9f390972bcf", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1eab9c5a1b85db4ca850114814a7df3e289fcd67/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eab9c5a1b85db4ca850114814a7df3e289fcd67/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=1eab9c5a1b85db4ca850114814a7df3e289fcd67", "patch": "@@ -69,7 +69,7 @@ pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n pub use self::sty::{ExistentialProjection, PolyExistentialProjection, Const};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n pub use self::sty::RegionKind;\n-pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid, SkolemizedRegionVid};\n+pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid};\n pub use self::sty::BoundRegion::*;\n pub use self::sty::InferTy::*;\n pub use self::sty::RegionKind::*;\n@@ -1370,15 +1370,13 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n /// type name in a non-zero universe is a skolemized type -- an\n /// idealized representative of \"types in general\" that we use for\n /// checking generic functions.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct UniverseIndex(u32);\n \n impl UniverseIndex {\n     /// The root universe, where things that the user defined are\n     /// visible.\n-    pub fn root() -> UniverseIndex {\n-        UniverseIndex(0)\n-    }\n+    pub const ROOT: Self = UniverseIndex(0);\n \n     /// A \"subuniverse\" corresponds to being inside a `forall` quantifier.\n     /// So, for example, suppose we have this type in universe `U`:\n@@ -1392,7 +1390,21 @@ impl UniverseIndex {\n     /// region `'a`, but that region was not nameable from `U` because\n     /// it was not in scope there.\n     pub fn subuniverse(self) -> UniverseIndex {\n-        UniverseIndex(self.0 + 1)\n+        UniverseIndex(self.0.checked_add(1).unwrap())\n+    }\n+\n+    pub fn as_u32(&self) -> u32 {\n+        self.0\n+    }\n+\n+    pub fn as_usize(&self) -> usize {\n+        self.0 as usize\n+    }\n+}\n+\n+impl From<u32> for UniverseIndex {\n+    fn from(index: u32) -> Self {\n+        UniverseIndex(index)\n     }\n }\n "}, {"sha": "382db571b524eea6bdad0f09c15aa4977661edde", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1eab9c5a1b85db4ca850114814a7df3e289fcd67/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eab9c5a1b85db4ca850114814a7df3e289fcd67/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=1eab9c5a1b85db4ca850114814a7df3e289fcd67", "patch": "@@ -1021,7 +1021,7 @@ pub enum RegionKind {\n \n     /// A skolemized region - basically the higher-ranked version of ReFree.\n     /// Should not exist after typeck.\n-    ReSkolemized(SkolemizedRegionVid, BoundRegion),\n+    ReSkolemized(ty::UniverseIndex, BoundRegion),\n \n     /// Empty lifetime is for data that is never accessed.\n     /// Bottom in the region lattice. We treat ReEmpty somewhat\n@@ -1075,11 +1075,6 @@ newtype_index!(RegionVid\n         DEBUG_FORMAT = custom,\n     });\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, PartialOrd, Ord)]\n-pub struct SkolemizedRegionVid {\n-    pub index: u32,\n-}\n-\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum InferTy {\n     TyVar(TyVid),"}, {"sha": "894a18b79ccb2ad8916312e3a1921224c4db663a", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1eab9c5a1b85db4ca850114814a7df3e289fcd67/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eab9c5a1b85db4ca850114814a7df3e289fcd67/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=1eab9c5a1b85db4ca850114814a7df3e289fcd67", "patch": "@@ -808,8 +808,8 @@ define_print! {\n                     write!(f, \"'?{}\", c.index())\n                 }\n \n-                ty::ReSkolemized(id, ref bound_region) => {\n-                    write!(f, \"ReSkolemized({}, {:?})\", id.index, bound_region)\n+                ty::ReSkolemized(universe, ref bound_region) => {\n+                    write!(f, \"ReSkolemized({:?}, {:?})\", universe, bound_region)\n                 }\n \n                 ty::ReEmpty => write!(f, \"ReEmpty\"),"}, {"sha": "4d1f3e2b4300ab30a8ed6927cfe0029b6f78bca9", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1eab9c5a1b85db4ca850114814a7df3e289fcd67/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eab9c5a1b85db4ca850114814a7df3e289fcd67/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=1eab9c5a1b85db4ca850114814a7df3e289fcd67", "patch": "@@ -16,7 +16,7 @@ use rustc::infer::RegionObligation;\n use rustc::infer::RegionVariableOrigin;\n use rustc::infer::SubregionOrigin;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n-use rustc::infer::region_constraints::{GenericKind, VarOrigins};\n+use rustc::infer::region_constraints::{GenericKind, VarInfos};\n use rustc::mir::{ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n                  Local, Location, Mir};\n use rustc::traits::ObligationCause;\n@@ -256,19 +256,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// of those will be constant regions representing the free\n     /// regions defined in `universal_regions`.\n     pub(crate) fn new(\n-        var_origins: VarOrigins,\n+        var_infos: VarInfos,\n         universal_regions: UniversalRegions<'tcx>,\n         mir: &Mir<'tcx>,\n     ) -> Self {\n-        let num_region_variables = var_origins.len();\n+        let num_region_variables = var_infos.len();\n         let num_universal_regions = universal_regions.len();\n \n         let elements = &Rc::new(RegionValueElements::new(mir, num_universal_regions));\n \n         // Create a RegionDefinition for each inference variable.\n-        let definitions = var_origins\n+        let definitions = var_infos\n             .into_iter()\n-            .map(|origin| RegionDefinition::new(origin))\n+            .map(|info| RegionDefinition::new(info.origin))\n             .collect();\n \n         let mut result = Self {"}]}