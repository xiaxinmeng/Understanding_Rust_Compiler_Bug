{"sha": "eea8f0a39a2423cc7a4acd31e3a7309853f22509", "node_id": "C_kwDOAAsO6NoAKGVlYThmMGEzOWEyNDIzY2M3YTRhY2QzMWUzYTczMDk4NTNmMjI1MDk", "commit": {"author": {"name": "Will Crichton", "email": "wcrichto@cs.stanford.edu", "date": "2021-08-26T03:15:46Z"}, "committer": {"name": "Will Crichton", "email": "wcrichto@cs.stanford.edu", "date": "2021-10-07T02:44:50Z"}, "message": "Sort examples by size\n\nImprove styling\n\nStart to clean up code, add comments", "tree": {"sha": "d32c2635226c7831b17ffd989797347c16314a9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d32c2635226c7831b17ffd989797347c16314a9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eea8f0a39a2423cc7a4acd31e3a7309853f22509", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eea8f0a39a2423cc7a4acd31e3a7309853f22509", "html_url": "https://github.com/rust-lang/rust/commit/eea8f0a39a2423cc7a4acd31e3a7309853f22509", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eea8f0a39a2423cc7a4acd31e3a7309853f22509/comments", "author": {"login": "willcrichton", "id": 663326, "node_id": "MDQ6VXNlcjY2MzMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/663326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willcrichton", "html_url": "https://github.com/willcrichton", "followers_url": "https://api.github.com/users/willcrichton/followers", "following_url": "https://api.github.com/users/willcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/willcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/willcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willcrichton/subscriptions", "organizations_url": "https://api.github.com/users/willcrichton/orgs", "repos_url": "https://api.github.com/users/willcrichton/repos", "events_url": "https://api.github.com/users/willcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/willcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "willcrichton", "id": 663326, "node_id": "MDQ6VXNlcjY2MzMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/663326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willcrichton", "html_url": "https://github.com/willcrichton", "followers_url": "https://api.github.com/users/willcrichton/followers", "following_url": "https://api.github.com/users/willcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/willcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/willcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willcrichton/subscriptions", "organizations_url": "https://api.github.com/users/willcrichton/orgs", "repos_url": "https://api.github.com/users/willcrichton/repos", "events_url": "https://api.github.com/users/willcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/willcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6338e7792fab06e015cdf3a3d1c30ff9797673e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6338e7792fab06e015cdf3a3d1c30ff9797673e", "html_url": "https://github.com/rust-lang/rust/commit/b6338e7792fab06e015cdf3a3d1c30ff9797673e"}], "stats": {"total": 219, "additions": 158, "deletions": 61}, "files": [{"sha": "eb507e4eecabb48d5c00aa37167848cfd923c52c", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eea8f0a39a2423cc7a4acd31e3a7309853f22509/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eea8f0a39a2423cc7a4acd31e3a7309853f22509/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=eea8f0a39a2423cc7a4acd31e3a7309853f22509", "patch": "@@ -1259,6 +1259,8 @@ crate struct Function {\n }\n \n impl Function {\n+    /// If --scrape-examples is used, then this function attempts to find call locations\n+    /// for `self` within `RenderOptions::call_locations` and store them in `Function::call_locations`.\n     crate fn load_call_locations(&mut self, def_id: hir::def_id::DefId, cx: &DocContext<'_>) {\n         if let Some(call_locations) = cx.render_options.call_locations.as_ref() {\n             let key = scrape_examples::def_id_call_key(cx.tcx, def_id);"}, {"sha": "4e019d4e15d3bf525bace24666ed5e5c638d69f8", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/eea8f0a39a2423cc7a4acd31e3a7309853f22509/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eea8f0a39a2423cc7a4acd31e3a7309853f22509/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=eea8f0a39a2423cc7a4acd31e3a7309853f22509", "patch": "@@ -2,7 +2,6 @@ use std::collections::BTreeMap;\n use std::convert::TryFrom;\n use std::ffi::OsStr;\n use std::fmt;\n-use std::fs;\n use std::path::PathBuf;\n use std::str::FromStr;\n \n@@ -680,29 +679,7 @@ impl Options {\n \n         let scrape_examples = matches.opt_str(\"scrape-examples\").map(PathBuf::from);\n         let with_examples = matches.opt_strs(\"with-examples\");\n-        let each_call_locations = with_examples\n-            .into_iter()\n-            .map(|path| {\n-                let bytes = fs::read(&path).map_err(|e| format!(\"{} (for path {})\", e, path))?;\n-                let calls: AllCallLocations =\n-                    serde_json::from_slice(&bytes).map_err(|e| format!(\"{}\", e))?;\n-                Ok(calls)\n-            })\n-            .collect::<Result<Vec<_>, _>>()\n-            .map_err(|e: String| {\n-                diag.err(&format!(\"failed to load examples with error: {}\", e));\n-                1\n-            })?;\n-        let call_locations = (each_call_locations.len() > 0).then(move || {\n-            each_call_locations.into_iter().fold(FxHashMap::default(), |mut acc, map| {\n-                for (function, calls) in map.into_iter() {\n-                    acc.entry(function)\n-                        .or_insert_with(FxHashMap::default)\n-                        .extend(calls.into_iter());\n-                }\n-                acc\n-            })\n-        });\n+        let call_locations = crate::scrape_examples::load_call_locations(with_examples, &diag)?;\n \n         let (lint_opts, describe_lints, lint_cap) = get_cmd_lint_options(matches, error_format);\n "}, {"sha": "b50aab6351c020ae8219ec9a61a03994fdb3a0f4", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 57, "deletions": 18, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/eea8f0a39a2423cc7a4acd31e3a7309853f22509/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eea8f0a39a2423cc7a4acd31e3a7309853f22509/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=eea8f0a39a2423cc7a4acd31e3a7309853f22509", "patch": "@@ -2453,32 +2453,31 @@ fn collect_paths_for_type(first_ty: clean::Type, cache: &Cache) -> Vec<String> {\n \n const MAX_FULL_EXAMPLES: usize = 5;\n \n+/// Generates the HTML for example call locations generated via the --scrape-examples flag.\n fn render_call_locations(\n     w: &mut Buffer,\n     cx: &Context<'_>,\n     call_locations: &Option<FnCallLocations>,\n ) {\n     let call_locations = match call_locations.as_ref() {\n-        Some(call_locations) => call_locations,\n-        None => {\n+        Some(call_locations) if call_locations.len() > 0 => call_locations,\n+        _ => {\n             return;\n         }\n     };\n \n-    if call_locations.len() == 0 {\n-        return;\n-    }\n-\n+    // Generate a unique ID so users can link to this section for a given method\n     let id = cx.id_map.borrow_mut().derive(\"scraped-examples\");\n     write!(\n         w,\n         r##\"<div class=\"docblock scraped-example-list\">\n           <h1 id=\"scraped-examples\" class=\"small-section-header\">\n-             <a href=\"#{}\">Uses found in <code>examples/</code></a>\n+             <a href=\"#{}\">Examples found in repository</a>\n           </h1>\"##,\n         id\n     );\n \n+    // Link to the source file containing a given example\n     let example_url = |call_data: &CallData| -> String {\n         format!(\n             r#\"<a href=\"{root}{url}\" target=\"_blank\">{name}</a>\"#,\n@@ -2488,18 +2487,27 @@ fn render_call_locations(\n         )\n     };\n \n+    // Generate the HTML for a single example, being the title and code block\n     let write_example = |w: &mut Buffer, (path, call_data): (&PathBuf, &CallData)| {\n-        let mut contents =\n+        // FIXME(wcrichto): is there a better way to handle an I/O error than a panic?\n+        //  When would such an error arise?\n+        let contents =\n             fs::read_to_string(&path).expect(&format!(\"Failed to read file: {}\", path.display()));\n \n+        // To reduce file sizes, we only want to embed the source code needed to understand the example, not\n+        // the entire file. So we find the smallest byte range that covers all items enclosing examples.\n         let min_loc =\n             call_data.locations.iter().min_by_key(|loc| loc.enclosing_item_span.0).unwrap();\n         let min_byte = min_loc.enclosing_item_span.0;\n         let min_line = min_loc.enclosing_item_lines.0;\n         let max_byte =\n             call_data.locations.iter().map(|loc| loc.enclosing_item_span.1).max().unwrap();\n-        contents = contents[min_byte..max_byte].to_string();\n \n+        // The output code is limited to that byte range.\n+        let contents_subset = &contents[min_byte..max_byte];\n+\n+        // The call locations need to be updated to reflect that the size of the program has changed.\n+        // Specifically, the ranges are all subtracted by `min_byte` since that's the new zero point.\n         let locations = call_data\n             .locations\n             .iter()\n@@ -2510,43 +2518,74 @@ fn render_call_locations(\n         write!(\n             w,\n             r#\"<div class=\"scraped-example\" data-code=\"{code}\" data-locs=\"{locations}\">\n-                <strong>{title}</strong>\n+                <div class=\"scraped-example-title\">{title}</div>\n                  <div class=\"code-wrapper\">\"#,\n-            code = contents.replace(\"\\\"\", \"&quot;\"),\n-            locations = serde_json::to_string(&locations).unwrap(),\n             title = example_url(call_data),\n+            // The code and locations are encoded as data attributes, so they can be read\n+            // later by the JS for interactions.\n+            code = contents_subset.replace(\"\\\"\", \"&quot;\"),\n+            locations = serde_json::to_string(&locations).unwrap(),\n         );\n         write!(w, r#\"<span class=\"prev\">&pr;</span> <span class=\"next\">&sc;</span>\"#);\n         write!(w, r#\"<span class=\"expand\">&varr;</span>\"#);\n+\n+        // FIXME(wcrichto): where should file_span and root_path come from?\n         let file_span = rustc_span::DUMMY_SP;\n         let root_path = \"\".to_string();\n-        sources::print_src(w, &contents, edition, file_span, cx, &root_path, Some(min_line));\n+        sources::print_src(w, contents_subset, edition, file_span, cx, &root_path, Some(min_line));\n         write!(w, \"</div></div>\");\n     };\n \n-    let mut it = call_locations.into_iter().peekable();\n+    // The call locations are output in sequence, so that sequence needs to be determined.\n+    // Ideally the most \"relevant\" examples would be shown first, but there's no general algorithm\n+    // for determining relevance. Instead, we prefer the smallest examples being likely the easiest to\n+    // understand at a glance.\n+    let ordered_locations = {\n+        let sort_criterion = |(_, call_data): &(_, &CallData)| {\n+            let (lo, hi) = call_data.locations[0].enclosing_item_span;\n+            hi - lo\n+        };\n+\n+        let mut locs = call_locations.into_iter().collect::<Vec<_>>();\n+        locs.sort_by_key(|x| sort_criterion(x));\n+        locs\n+    };\n+\n+    // Write just one example that's visible by default in the method's description.\n+    let mut it = ordered_locations.into_iter().peekable();\n     write_example(w, it.next().unwrap());\n \n+    // Then add the remaining examples in a hidden section.\n     if it.peek().is_some() {\n         write!(\n             w,\n             r#\"<details class=\"rustdoc-toggle more-examples-toggle\">\n                   <summary class=\"hideme\">\n                      <span>More examples</span>\n                   </summary>\n-                  <div class=\"more-scraped-examples\">\"#\n+                  <div class=\"more-scraped-examples\">\n+                    <div class=\"toggle-line\"><div class=\"toggle-line-inner\"></div></div>\n+                    <div>\n+\"#\n         );\n+\n+        // Only generate inline code for MAX_FULL_EXAMPLES number of examples. Otherwise we could\n+        // make the page arbitrarily huge!\n         (&mut it).take(MAX_FULL_EXAMPLES).for_each(|ex| write_example(w, ex));\n \n+        // For the remaining examples, generate a <ul /> containing links to the source files.\n         if it.peek().is_some() {\n-            write!(w, \"Additional examples can be found in:<br /><ul>\");\n+            write!(\n+                w,\n+                r#\"<div class=\"example-links\">Additional examples can be found in:<br /><ul>\"#\n+            );\n             it.for_each(|(_, call_data)| {\n                 write!(w, \"<li>{}</li>\", example_url(call_data));\n             });\n-            write!(w, \"</ul>\");\n+            write!(w, \"</ul></div>\");\n         }\n \n-        write!(w, \"</div></details>\");\n+        write!(w, \"</div></div></details>\");\n     }\n \n     write!(w, \"</div>\");"}, {"sha": "2767f6468fb512d50efd47c87cdb4cd70da999a8", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 49, "deletions": 9, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/eea8f0a39a2423cc7a4acd31e3a7309853f22509/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/eea8f0a39a2423cc7a4acd31e3a7309853f22509/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=eea8f0a39a2423cc7a4acd31e3a7309853f22509", "patch": "@@ -137,7 +137,7 @@ h1.fqn {\n \tmargin-top: 0;\n \n \t/* workaround to keep flex from breaking below 700 px width due to the float: right on the nav\n-\t   above the h1 */\n+\t\t above the h1 */\n \tpadding-left: 1px;\n }\n h1.fqn > .in-band > a:hover {\n@@ -974,7 +974,7 @@ body.blur > :not(#help) {\n \ttext-shadow:\n \t\t1px 0 0 black,\n \t\t-1px 0 0 black,\n-\t\t0  1px 0 black,\n+\t\t0\t 1px 0 black,\n \t\t0 -1px 0 black;\n }\n \n@@ -1214,8 +1214,8 @@ a.test-arrow:hover{\n \n .notable-traits-tooltip::after {\n \t/* The margin on the tooltip does not capture hover events,\n-\t   this extends the area of hover enough so that mouse hover is not\n-\t   lost when moving the mouse to the tooltip */\n+\t\t this extends the area of hover enough so that mouse hover is not\n+\t\t lost when moving the mouse to the tooltip */\n \tcontent: \"\\00a0\\00a0\\00a0\";\n }\n \n@@ -1715,7 +1715,7 @@ details.undocumented[open] > summary::before {\n \t}\n \n \t/* We do NOT hide this element so that alternative device readers still have this information\n-\t   available. */\n+\t\t available. */\n \t.sidebar-elems {\n \t\tposition: fixed;\n \t\tz-index: 1;\n@@ -1973,10 +1973,15 @@ details.undocumented[open] > summary::before {\n \n /* This part is for the new \"examples\" components */\n \n+.scraped-example-title {\n+\tfont-family: 'Fira Sans';\n+\tfont-weight: 500;\n+}\n+\n .scraped-example:not(.expanded) .code-wrapper pre.line-numbers,\n .scraped-example:not(.expanded) .code-wrapper .example-wrap pre.rust {\n \toverflow: hidden;\n-\theight: 240px;\n+\tmax-height: 240px;\n }\n \n .scraped-example .code-wrapper .prev {\n@@ -2033,7 +2038,7 @@ details.undocumented[open] > summary::before {\n \n .scraped-example:not(.expanded) .code-wrapper {\n \toverflow: hidden;\n-\theight: 240px;\n+\tmax-height: 240px;\n }\n \n .scraped-example .code-wrapper .line-numbers {\n@@ -2072,6 +2077,41 @@ details.undocumented[open] > summary::before {\n \n .more-scraped-examples {\n \tpadding-left: 10px;\n-\tborder-left: 1px solid #ccc;\n-\tmargin-left: 24px;\n+\tmargin-left: 15px;\n+\tdisplay: flex;\n+\tflex-direction: row;\n+}\n+\n+.toggle-line {\n+\talign-self: stretch;\n+\tmargin-right: 10px;\n+\tmargin-top: 5px;\n+\tpadding: 0 4px;\n+\tcursor: pointer;\n+}\n+\n+.toggle-line:hover .toggle-line-inner {\n+\tbackground: #aaa;\n+}\n+\n+.toggle-line-inner {\n+\tmin-width: 2px;\n+\tbackground: #ddd;\n+\theight: 100%;\n+}\n+\n+h1 + .scraped-example {\n+\tmargin-bottom: 10px;\n+}\n+\n+.more-scraped-examples .scraped-example {\n+\tmargin-bottom: 20px;\n+}\n+\n+.example-links a {\n+\tfont-family: 'Fira Sans';\n+}\n+\n+.example-links ul {\n+\tmargin-bottom: 0;\n }"}, {"sha": "a52e539fbd327f75db57f39e9d9f8e4e7c9294a5", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/eea8f0a39a2423cc7a4acd31e3a7309853f22509/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/eea8f0a39a2423cc7a4acd31e3a7309853f22509/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=eea8f0a39a2423cc7a4acd31e3a7309853f22509", "patch": "@@ -1121,15 +1121,22 @@ function hideThemeButtonState() {\n             example.querySelector('.next').remove();\n         }\n \n-        // Show full code on expansion\n-        example.querySelector('.expand').addEventListener('click', function () {\n-            if (hasClass(example, \"expanded\")) {\n-                removeClass(example, \"expanded\");\n-                scrollToLoc(example, locs[0]);\n-            } else {\n-                addClass(example, \"expanded\");\n-            }\n-        });\n+        let codeEl = example.querySelector('.rust');\n+        let expandButton = example.querySelector('.expand');\n+        if (codeEl.scrollHeight == codeEl.clientHeight) {\n+            addClass(example, 'expanded');\n+            expandButton.remove();\n+        } else {\n+            // Show full code on expansion\n+            expandButton.addEventListener('click', function () {\n+                if (hasClass(example, \"expanded\")) {\n+                    removeClass(example, \"expanded\");\n+                    scrollToLoc(example, locs[0]);\n+                } else {\n+                    addClass(example, \"expanded\");\n+                }\n+            });\n+        }\n \n         // Start with the first example in view\n         scrollToLoc(example, locs[0]);\n@@ -1139,6 +1146,10 @@ function hideThemeButtonState() {\n         var firstExamples = document.querySelectorAll('.scraped-example-list > .scraped-example');\n         onEach(firstExamples, updateScrapedExample);\n         onEach(document.querySelectorAll('.more-examples-toggle'), function(toggle) {\n+            toggle.querySelector('.toggle-line').addEventListener('click', function() {\n+                toggle.open = false;\n+            });\n+\n             var moreExamples = toggle.querySelectorAll('.scraped-example');\n             toggle.querySelector('summary').addEventListener('click', function() {\n                 // Wrapping in setTimeout ensures the update happens after the elements are actually"}, {"sha": "16a40ed1cb31b6ea2d6a7c2fae20f609e9590c17", "filename": "src/librustdoc/scrape_examples.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/eea8f0a39a2423cc7a4acd31e3a7309853f22509/src%2Flibrustdoc%2Fscrape_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eea8f0a39a2423cc7a4acd31e3a7309853f22509/src%2Flibrustdoc%2Fscrape_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fscrape_examples.rs?ref=eea8f0a39a2423cc7a4acd31e3a7309853f22509", "patch": "@@ -1,4 +1,4 @@\n-//! This module analyzes provided crates to find examples of uses for items in the\n+//! This module analyzes crates to find examples of uses for items in the\n //! current crate being documented.\n \n use crate::clean;\n@@ -158,3 +158,31 @@ crate fn run(\n         rustc_errors::ErrorReported\n     })\n }\n+\n+crate fn load_call_locations(\n+    with_examples: Vec<String>,\n+    diag: &rustc_errors::Handler,\n+) -> Result<Option<AllCallLocations>, i32> {\n+    let each_call_locations = with_examples\n+        .into_iter()\n+        .map(|path| {\n+            let bytes = fs::read(&path).map_err(|e| format!(\"{} (for path {})\", e, path))?;\n+            let calls: AllCallLocations =\n+                serde_json::from_slice(&bytes).map_err(|e| format!(\"{}\", e))?;\n+            Ok(calls)\n+        })\n+        .collect::<Result<Vec<_>, _>>()\n+        .map_err(|e: String| {\n+            diag.err(&format!(\"failed to load examples with error: {}\", e));\n+            1\n+        })?;\n+\n+    Ok((each_call_locations.len() > 0).then(|| {\n+        each_call_locations.into_iter().fold(FxHashMap::default(), |mut acc, map| {\n+            for (function, calls) in map.into_iter() {\n+                acc.entry(function).or_insert_with(FxHashMap::default).extend(calls.into_iter());\n+            }\n+            acc\n+        })\n+    }))\n+}"}]}