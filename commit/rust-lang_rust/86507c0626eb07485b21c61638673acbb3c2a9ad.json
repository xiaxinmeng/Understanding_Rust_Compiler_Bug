{"sha": "86507c0626eb07485b21c61638673acbb3c2a9ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2NTA3YzA2MjZlYjA3NDg1YjIxYzYxNjM4NjczYWNiYjNjMmE5YWQ=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-23T12:40:36Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-23T12:40:36Z"}, "message": "Merge #606\n\n606: generalize marking infrastructure r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "450e229240e7ffecd90a6251c1ef61ddb725ef4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/450e229240e7ffecd90a6251c1ef61ddb725ef4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86507c0626eb07485b21c61638673acbb3c2a9ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86507c0626eb07485b21c61638673acbb3c2a9ad", "html_url": "https://github.com/rust-lang/rust/commit/86507c0626eb07485b21c61638673acbb3c2a9ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86507c0626eb07485b21c61638673acbb3c2a9ad/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "b846832b8b2fb221cce42f170e9989c1dac5e468", "url": "https://api.github.com/repos/rust-lang/rust/commits/b846832b8b2fb221cce42f170e9989c1dac5e468", "html_url": "https://github.com/rust-lang/rust/commit/b846832b8b2fb221cce42f170e9989c1dac5e468"}, {"sha": "45da21672ad1e4ec53487c373b1b7e2ca8f944a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/45da21672ad1e4ec53487c373b1b7e2ca8f944a2", "html_url": "https://github.com/rust-lang/rust/commit/45da21672ad1e4ec53487c373b1b7e2ca8f944a2"}], "stats": {"total": 177, "additions": 91, "deletions": 86}, "files": [{"sha": "33a9ba60594fb646961a3fa9c75b709c27a18b85", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86507c0626eb07485b21c61638673acbb3c2a9ad/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86507c0626eb07485b21c61638673acbb3c2a9ad/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=86507c0626eb07485b21c61638673acbb3c2a9ad", "patch": "@@ -8,7 +8,7 @@\n pub mod db;\n #[cfg(test)]\n mod mock;\n-#[macro_use]\n+#[cfg(test)]\n mod marks;\n mod query_definitions;\n mod path;"}, {"sha": "6aff2c4e1e08508050dce7e3c3c988023a80cb3f", "filename": "crates/ra_hir/src/marks.rs", "status": "modified", "additions": 1, "deletions": 82, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/86507c0626eb07485b21c61638673acbb3c2a9ad/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86507c0626eb07485b21c61638673acbb3c2a9ad/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmarks.rs?ref=86507c0626eb07485b21c61638673acbb3c2a9ad", "patch": "@@ -1,82 +1 @@\n-//! This module implements manually tracked test coverage, which useful for\n-//! quickly finding a test responsible for testing a particular bit of code.\n-//!\n-//! See https://matklad.github.io/2018/06/18/a-trick-for-test-maintenance.html\n-//! for details, but the TL;DR is that you write your test as\n-//!\n-//! ```no-run\n-//! #[test]\n-//! fn test_foo() {\n-//!     covers!(test_foo);\n-//! }\n-//! ```\n-//!\n-//! and in the code under test you write\n-//!\n-//! ```no-run\n-//! fn foo() {\n-//!     if some_condition() {\n-//!         tested_by!(test_foo);\n-//!     }\n-//! }\n-//! ```\n-//!\n-//! This module then checks that executing the test indeed covers the specified\n-//! function. This is useful if you come back to the `foo` function ten years\n-//! later and wonder where the test are: now you can grep for `test_foo`.\n-\n-#[macro_export]\n-macro_rules! tested_by {\n-    ($ident:ident) => {\n-        #[cfg(test)]\n-        {\n-            crate::marks::marks::$ident.fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n-        }\n-    };\n-}\n-\n-#[macro_export]\n-macro_rules! covers {\n-    ($ident:ident) => {\n-        let _checker = crate::marks::marks::MarkChecker::new(&crate::marks::marks::$ident);\n-    };\n-}\n-\n-#[cfg(test)]\n-pub(crate) mod marks {\n-    use std::sync::atomic::{AtomicUsize, Ordering};\n-\n-    pub(crate) struct MarkChecker {\n-        mark: &'static AtomicUsize,\n-        value_on_entry: usize,\n-    }\n-\n-    impl MarkChecker {\n-        pub(crate) fn new(mark: &'static AtomicUsize) -> MarkChecker {\n-            let value_on_entry = mark.load(Ordering::SeqCst);\n-            MarkChecker {\n-                mark,\n-                value_on_entry,\n-            }\n-        }\n-    }\n-\n-    impl Drop for MarkChecker {\n-        fn drop(&mut self) {\n-            if std::thread::panicking() {\n-                return;\n-            }\n-            let value_on_exit = self.mark.load(Ordering::SeqCst);\n-            assert!(value_on_exit > self.value_on_entry, \"mark was not hit\")\n-        }\n-    }\n-\n-    macro_rules! mark {\n-        ($ident:ident) => {\n-            #[allow(bad_style)]\n-            pub(crate) static $ident: AtomicUsize = AtomicUsize::new(0);\n-        };\n-    }\n-\n-    mark!(name_res_works_for_broken_modules);\n-}\n+test_utils::mark!(name_res_works_for_broken_modules);"}, {"sha": "47c14af35b076441fe4797aef9173e261d91bffb", "filename": "crates/ra_hir/src/module_tree.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86507c0626eb07485b21c61638673acbb3c2a9ad/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86507c0626eb07485b21c61638673acbb3c2a9ad/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs?ref=86507c0626eb07485b21c61638673acbb3c2a9ad", "patch": "@@ -10,6 +10,7 @@ use ra_syntax::{\n     ast::{self, AstNode, NameOwner},\n };\n use ra_arena::{Arena, RawId, impl_arena_id};\n+use test_utils::tested_by;\n \n use crate::{Name, AsName, HirDatabase, SourceItemId, HirFileId, Problem, SourceFileItems, ModuleSource};\n "}, {"sha": "e920074533697c17ed78f2a8d8b708858d091b62", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86507c0626eb07485b21c61638673acbb3c2a9ad/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86507c0626eb07485b21c61638673acbb3c2a9ad/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=86507c0626eb07485b21c61638673acbb3c2a9ad", "patch": "@@ -2,7 +2,7 @@ use std::sync::Arc;\n \n use ra_db::{FilesDatabase, CrateGraph, SourceRootId, salsa::Database};\n use relative_path::RelativePath;\n-use test_utils::assert_eq_text;\n+use test_utils::{assert_eq_text, covers};\n \n use crate::{\n     ItemMap, Resolution,"}, {"sha": "35a679aea5a9d50783db17c6026309b6ca32e057", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/86507c0626eb07485b21c61638673acbb3c2a9ad/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86507c0626eb07485b21c61638673acbb3c2a9ad/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=86507c0626eb07485b21c61638673acbb3c2a9ad", "patch": "@@ -1,5 +1,10 @@\n-use std::fs;\n-use std::path::{Path, PathBuf};\n+#[macro_use]\n+pub mod marks;\n+\n+use std::{\n+    fs,\n+    path::{Path, PathBuf}\n+};\n \n use text_unit::{TextRange, TextUnit};\n use serde_json::Value;"}, {"sha": "79ffedf69bc71d7343dcf7740f26f5970ee858fc", "filename": "crates/test_utils/src/marks.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/86507c0626eb07485b21c61638673acbb3c2a9ad/crates%2Ftest_utils%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86507c0626eb07485b21c61638673acbb3c2a9ad/crates%2Ftest_utils%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fmarks.rs?ref=86507c0626eb07485b21c61638673acbb3c2a9ad", "patch": "@@ -0,0 +1,80 @@\n+//! This module implements manually tracked test coverage, which useful for\n+//! quickly finding a test responsible for testing a particular bit of code.\n+//!\n+//! See https://matklad.github.io/2018/06/18/a-trick-for-test-maintenance.html\n+//! for details, but the TL;DR is that you write your test as\n+//!\n+//! ```no-run\n+//! #[test]\n+//! fn test_foo() {\n+//!     covers!(test_foo);\n+//! }\n+//! ```\n+//!\n+//! and in the code under test you write\n+//!\n+//! ```no-run\n+//! fn foo() {\n+//!     if some_condition() {\n+//!         tested_by!(test_foo);\n+//!     }\n+//! }\n+//! ```\n+//!\n+//! This module then checks that executing the test indeed covers the specified\n+//! function. This is useful if you come back to the `foo` function ten years\n+//! later and wonder where the test are: now you can grep for `test_foo`.\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+\n+#[macro_export]\n+macro_rules! tested_by {\n+    ($ident:ident) => {\n+        #[cfg(test)]\n+        {\n+            // sic! use call-site crate\n+            crate::marks::$ident.fetch_add(1, std::sync::atomic::Ordering::SeqCst);\n+        }\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! covers {\n+    ($ident:ident) => {\n+        // sic! use call-site crate\n+        let _checker = $crate::marks::MarkChecker::new(&crate::marks::$ident);\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! mark {\n+    ($ident:ident) => {\n+        #[allow(bad_style)]\n+        pub(crate) static $ident: std::sync::atomic::AtomicUsize =\n+            std::sync::atomic::AtomicUsize::new(0);\n+    };\n+}\n+\n+pub struct MarkChecker {\n+    mark: &'static AtomicUsize,\n+    value_on_entry: usize,\n+}\n+\n+impl MarkChecker {\n+    pub fn new(mark: &'static AtomicUsize) -> MarkChecker {\n+        let value_on_entry = mark.load(Ordering::SeqCst);\n+        MarkChecker {\n+            mark,\n+            value_on_entry,\n+        }\n+    }\n+}\n+\n+impl Drop for MarkChecker {\n+    fn drop(&mut self) {\n+        if std::thread::panicking() {\n+            return;\n+        }\n+        let value_on_exit = self.mark.load(Ordering::SeqCst);\n+        assert!(value_on_exit > self.value_on_entry, \"mark was not hit\")\n+    }\n+}"}]}