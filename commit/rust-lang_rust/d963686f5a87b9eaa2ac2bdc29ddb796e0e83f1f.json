{"sha": "d963686f5a87b9eaa2ac2bdc29ddb796e0e83f1f", "node_id": "C_kwDOAAsO6NoAKGQ5NjM2ODZmNWE4N2I5ZWFhMmFjMmJkYzI5ZGRiNzk2ZTBlODNmMWY", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-11-03T22:19:34Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-11-04T03:24:41Z"}, "message": "Refactor `cook_lexer_literal`.\n\nIt deals with eight cases: ints, floats, and the six quoted types\n(char/byte/strings). For ints and floats we have an early return, and\nthe other six types fall through to the code at the end, which makes the\nfunction hard to read.\n\nThis commit rearranges things to avoid the early returns.", "tree": {"sha": "c3c881e1570fcd5fe9a582c21c6f27dccd833790", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3c881e1570fcd5fe9a582c21c6f27dccd833790"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d963686f5a87b9eaa2ac2bdc29ddb796e0e83f1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d963686f5a87b9eaa2ac2bdc29ddb796e0e83f1f", "html_url": "https://github.com/rust-lang/rust/commit/d963686f5a87b9eaa2ac2bdc29ddb796e0e83f1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d963686f5a87b9eaa2ac2bdc29ddb796e0e83f1f/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a21c0458979d786d821c2d75a1b109fe38914da0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a21c0458979d786d821c2d75a1b109fe38914da0", "html_url": "https://github.com/rust-lang/rust/commit/a21c0458979d786d821c2d75a1b109fe38914da0"}], "stats": {"total": 78, "additions": 36, "deletions": 42}, "files": [{"sha": "61b5be4240414a0a759d6cdfc33a8e2862e319af", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 36, "deletions": 42, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d963686f5a87b9eaa2ac2bdc29ddb796e0e83f1f/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d963686f5a87b9eaa2ac2bdc29ddb796e0e83f1f/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=d963686f5a87b9eaa2ac2bdc29ddb796e0e83f1f", "patch": "@@ -363,112 +363,103 @@ impl<'a> StringReader<'a> {\n     fn cook_lexer_literal(\n         &self,\n         start: BytePos,\n-        suffix_start: BytePos,\n+        end: BytePos,\n         kind: rustc_lexer::LiteralKind,\n     ) -> (token::LitKind, Symbol) {\n-        // prefix means `\"` or `br\"` or `r###\"`, ...\n-        let (lit_kind, mode, prefix_len, postfix_len) = match kind {\n+        match kind {\n             rustc_lexer::LiteralKind::Char { terminated } => {\n                 if !terminated {\n                     self.sess.span_diagnostic.span_fatal_with_code(\n-                        self.mk_sp(start, suffix_start),\n+                        self.mk_sp(start, end),\n                         \"unterminated character literal\",\n                         error_code!(E0762),\n                     )\n                 }\n-                (token::Char, Mode::Char, 1, 1) // ' '\n+                self.cook_quoted(token::Char, Mode::Char, start, end, 1, 1) // ' '\n             }\n             rustc_lexer::LiteralKind::Byte { terminated } => {\n                 if !terminated {\n                     self.sess.span_diagnostic.span_fatal_with_code(\n-                        self.mk_sp(start + BytePos(1), suffix_start),\n+                        self.mk_sp(start + BytePos(1), end),\n                         \"unterminated byte constant\",\n                         error_code!(E0763),\n                     )\n                 }\n-                (token::Byte, Mode::Byte, 2, 1) // b' '\n+                self.cook_quoted(token::Byte, Mode::Byte, start, end, 2, 1) // b' '\n             }\n             rustc_lexer::LiteralKind::Str { terminated } => {\n                 if !terminated {\n                     self.sess.span_diagnostic.span_fatal_with_code(\n-                        self.mk_sp(start, suffix_start),\n+                        self.mk_sp(start, end),\n                         \"unterminated double quote string\",\n                         error_code!(E0765),\n                     )\n                 }\n-                (token::Str, Mode::Str, 1, 1) // \" \"\n+                self.cook_quoted(token::Str, Mode::Str, start, end, 1, 1) // \" \"\n             }\n             rustc_lexer::LiteralKind::ByteStr { terminated } => {\n                 if !terminated {\n                     self.sess.span_diagnostic.span_fatal_with_code(\n-                        self.mk_sp(start + BytePos(1), suffix_start),\n+                        self.mk_sp(start + BytePos(1), end),\n                         \"unterminated double quote byte string\",\n                         error_code!(E0766),\n                     )\n                 }\n-                (token::ByteStr, Mode::ByteStr, 2, 1) // b\" \"\n+                self.cook_quoted(token::ByteStr, Mode::ByteStr, start, end, 2, 1) // b\" \"\n             }\n             rustc_lexer::LiteralKind::RawStr { n_hashes } => {\n                 if let Some(n_hashes) = n_hashes {\n                     let n = u32::from(n_hashes);\n-                    (token::StrRaw(n_hashes), Mode::RawStr, 2 + n, 1 + n) // r##\" \"##\n+                    let kind = token::StrRaw(n_hashes);\n+                    self.cook_quoted(kind, Mode::RawStr, start, end, 2 + n, 1 + n) // r##\" \"##\n                 } else {\n                     self.report_raw_str_error(start, 1);\n                 }\n             }\n             rustc_lexer::LiteralKind::RawByteStr { n_hashes } => {\n                 if let Some(n_hashes) = n_hashes {\n                     let n = u32::from(n_hashes);\n-                    (token::ByteStrRaw(n_hashes), Mode::RawByteStr, 3 + n, 1 + n) // br##\" \"##\n+                    let kind = token::ByteStrRaw(n_hashes);\n+                    self.cook_quoted(kind, Mode::RawByteStr, start, end, 3 + n, 1 + n) // br##\" \"##\n                 } else {\n                     self.report_raw_str_error(start, 2);\n                 }\n             }\n             rustc_lexer::LiteralKind::Int { base, empty_int } => {\n-                return if empty_int {\n+                if empty_int {\n                     self.sess\n                         .span_diagnostic\n                         .struct_span_err_with_code(\n-                            self.mk_sp(start, suffix_start),\n+                            self.mk_sp(start, end),\n                             \"no valid digits found for number\",\n                             error_code!(E0768),\n                         )\n                         .emit();\n                     (token::Integer, sym::integer(0))\n                 } else {\n-                    self.validate_int_literal(base, start, suffix_start);\n-                    (token::Integer, self.symbol_from_to(start, suffix_start))\n-                };\n+                    self.validate_int_literal(base, start, end);\n+                    (token::Integer, self.symbol_from_to(start, end))\n+                }\n             }\n             rustc_lexer::LiteralKind::Float { base, empty_exponent } => {\n                 if empty_exponent {\n                     self.err_span_(start, self.pos, \"expected at least one digit in exponent\");\n                 }\n-\n                 match base {\n-                    Base::Hexadecimal => self.err_span_(\n-                        start,\n-                        suffix_start,\n-                        \"hexadecimal float literal is not supported\",\n-                    ),\n+                    Base::Hexadecimal => {\n+                        self.err_span_(start, end, \"hexadecimal float literal is not supported\")\n+                    }\n                     Base::Octal => {\n-                        self.err_span_(start, suffix_start, \"octal float literal is not supported\")\n+                        self.err_span_(start, end, \"octal float literal is not supported\")\n                     }\n                     Base::Binary => {\n-                        self.err_span_(start, suffix_start, \"binary float literal is not supported\")\n+                        self.err_span_(start, end, \"binary float literal is not supported\")\n                     }\n-                    _ => (),\n+                    _ => {}\n                 }\n-\n-                let id = self.symbol_from_to(start, suffix_start);\n-                return (token::Float, id);\n+                (token::Float, self.symbol_from_to(start, end))\n             }\n-        };\n-        let content_start = start + BytePos(prefix_len);\n-        let content_end = suffix_start - BytePos(postfix_len);\n-        let id = self.symbol_from_to(content_start, content_end);\n-        self.validate_literal_escape(mode, content_start, content_end, prefix_len, postfix_len);\n-        (lit_kind, id)\n+        }\n     }\n \n     #[inline]\n@@ -659,20 +650,22 @@ impl<'a> StringReader<'a> {\n         )\n     }\n \n-    fn validate_literal_escape(\n+    fn cook_quoted(\n         &self,\n+        kind: token::LitKind,\n         mode: Mode,\n-        content_start: BytePos,\n-        content_end: BytePos,\n+        start: BytePos,\n+        end: BytePos,\n         prefix_len: u32,\n         postfix_len: u32,\n-    ) {\n+    ) -> (token::LitKind, Symbol) {\n+        let content_start = start + BytePos(prefix_len);\n+        let content_end = end - BytePos(postfix_len);\n         let lit_content = self.str_from_to(content_start, content_end);\n         unescape::unescape_literal(lit_content, mode, &mut |range, result| {\n             // Here we only check for errors. The actual unescaping is done later.\n             if let Err(err) = result {\n-                let span_with_quotes = self\n-                    .mk_sp(content_start - BytePos(prefix_len), content_end + BytePos(postfix_len));\n+                let span_with_quotes = self.mk_sp(start, end);\n                 let (start, end) = (range.start as u32, range.end as u32);\n                 let lo = content_start + BytePos(start);\n                 let hi = lo + BytePos(end - start);\n@@ -688,6 +681,7 @@ impl<'a> StringReader<'a> {\n                 );\n             }\n         });\n+        (kind, Symbol::intern(lit_content))\n     }\n \n     fn validate_int_literal(&self, base: Base, content_start: BytePos, content_end: BytePos) {"}]}