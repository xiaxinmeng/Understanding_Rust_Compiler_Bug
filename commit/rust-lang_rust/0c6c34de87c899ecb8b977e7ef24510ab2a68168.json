{"sha": "0c6c34de87c899ecb8b977e7ef24510ab2a68168", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjNmMzNGRlODdjODk5ZWNiOGI5NzdlN2VmMjQ1MTBhYjJhNjgxNjg=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-12-28T20:44:37Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-12-29T15:58:31Z"}, "message": "Remove \"Learn Rust\" from TRPL.\n\nSome history:\n\nWhile getting Rust to 1.0, it was a struggle to keep the book in a\nworking state. I had always wanted a certain kind of TOC, but couldn't\nquite get it there.\n\nAt the 11th hour, I wrote up \"Rust inside other langauges\" and \"Dining\nPhilosophers\" in an attempt to get the book in the direction I wanted to\ngo. They were fine, but not my best work. I wanted to further expand\nthis section, but it's just never going to end up happening. We're doing\nthe second draft of the book now, and these sections are basically gone\nalready.\n\nHere's the issues with these two sections, and removing them just fixes\nit all:\n\n// Philosophers\n\nThere was always controversy over which ones were chosen, and why. This\nis kind of a perpetual bikeshed, but it comes up every once in a while.\n\nThe implementation was originally supposed to show off channels, but\nnever did, due to time constraints. Months later, I still haven't\nre-written it to use them.\n\nPeople get different results and assume that means they're wrong, rather\nthan the non-determinism inherent in concurrency. Platform differences\naggrivate this, as does the exact amount of sleeping and printing.\n\n// Rust Inside Other Languages\n\nThis section is wonderful, and shows off a strength of Rust. However,\nit's not clear what qualifies a language to be in this section. And I'm\nnot sure how tracking a ton of other languages is gonna work, into the\nfuture; we can't test _anything_ in this section, so it's prone to\nbitrot.\n\nBy removing this section, and making the Guessing Game an initial\ntutorial, we will move this version of the book closer to the future\nversion, and just eliminate all of these questions.\n\nIn addition, this also solves the 'split-brained'-ness of having two\npaths, which has endlessly confused people in the past.\n\nI'm sad to see these sections go, but I think it's for the best.\n\nFixes #30471\nFixes #30163\nFixes #30162\nFixes #25488\nFixes #30345\nFixes #28713\nFixes #28915\n\nAnd probably others. This lengthy list alone is enough to show that\nthese should have been removed.\n\nRIP.", "tree": {"sha": "1c0a471a61037d6f010fb9848762c3bb59839b40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c0a471a61037d6f010fb9848762c3bb59839b40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c6c34de87c899ecb8b977e7ef24510ab2a68168", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c6c34de87c899ecb8b977e7ef24510ab2a68168", "html_url": "https://github.com/rust-lang/rust/commit/0c6c34de87c899ecb8b977e7ef24510ab2a68168", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c6c34de87c899ecb8b977e7ef24510ab2a68168/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27a1834ce522e3ec7fe4726b1661de16ee30c503", "url": "https://api.github.com/repos/rust-lang/rust/commits/27a1834ce522e3ec7fe4726b1661de16ee30c503", "html_url": "https://github.com/rust-lang/rust/commit/27a1834ce522e3ec7fe4726b1661de16ee30c503"}], "stats": {"total": 1100, "additions": 14, "deletions": 1086}, "files": [{"sha": "d16746e777a3ac8c28e4d91519438ec1d5f24816", "filename": "src/doc/book/README.md", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c6c34de87c899ecb8b977e7ef24510ab2a68168/src%2Fdoc%2Fbook%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/0c6c34de87c899ecb8b977e7ef24510ab2a68168/src%2Fdoc%2Fbook%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2FREADME.md?ref=0c6c34de87c899ecb8b977e7ef24510ab2a68168", "patch": "@@ -14,31 +14,25 @@ Even then, Rust still allows precise control like a low-level language would.\n \n [rust]: https://www.rust-lang.org\n \n-\u201cThe Rust Programming Language\u201d is split into eight sections. This introduction\n+\u201cThe Rust Programming Language\u201d is split into sections. This introduction\n is the first. After this:\n \n * [Getting started][gs] - Set up your computer for Rust development.\n-* [Learn Rust][lr] - Learn Rust programming through small projects.\n-* [Effective Rust][er] - Higher-level concepts for writing excellent Rust code.\n+* [Tutorial: Guessing Game][gg] - Learn some Rust with a small project.\n * [Syntax and Semantics][ss] - Each bit of Rust, broken down into small chunks.\n+* [Effective Rust][er] - Higher-level concepts for writing excellent Rust code.\n * [Nightly Rust][nr] - Cutting-edge features that aren\u2019t in stable builds yet.\n * [Glossary][gl] - A reference of terms used in the book.\n * [Bibliography][bi] - Background on Rust's influences, papers about Rust.\n \n [gs]: getting-started.html\n-[lr]: learn-rust.html\n+[gg]: guessing-game.html\n [er]: effective-rust.html\n [ss]: syntax-and-semantics.html\n [nr]: nightly-rust.html\n [gl]: glossary.html\n [bi]: bibliography.html\n \n-After reading this introduction, you\u2019ll want to dive into either \u2018Learn Rust\u2019 or\n-\u2018Syntax and Semantics\u2019, depending on your preference: \u2018Learn Rust\u2019 if you want\n-to dive in with a project, or \u2018Syntax and Semantics\u2019 if you prefer to start\n-small, and learn a single concept thoroughly before moving onto the next.\n-Copious cross-linking connects these parts together.\n-\n ### Contributing\n \n The source files from which this book is generated can be found on"}, {"sha": "3df791fd51bf6dcfc101a4ccd3b393942690db5b", "filename": "src/doc/book/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c6c34de87c899ecb8b977e7ef24510ab2a68168/src%2Fdoc%2Fbook%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/0c6c34de87c899ecb8b977e7ef24510ab2a68168/src%2Fdoc%2Fbook%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2FSUMMARY.md?ref=0c6c34de87c899ecb8b977e7ef24510ab2a68168", "patch": "@@ -1,10 +1,7 @@\n # Summary\n \n * [Getting Started](getting-started.md)\n-* [Learn Rust](learn-rust.md)\n-    * [Guessing Game](guessing-game.md)\n-    * [Dining Philosophers](dining-philosophers.md)\n-    * [Rust Inside Other Languages](rust-inside-other-languages.md)\n+* [Tutorial: Guessing Game](guessing-game.md)\n * [Syntax and Semantics](syntax-and-semantics.md)\n     * [Variable Bindings](variable-bindings.md)\n     * [Functions](functions.md)"}, {"sha": "a0f629c32e3fba3fda7c5012e3bd3acf463fa2bb", "filename": "src/doc/book/dining-philosophers.md", "status": "removed", "additions": 0, "deletions": 723, "changes": 723, "blob_url": "https://github.com/rust-lang/rust/blob/27a1834ce522e3ec7fe4726b1661de16ee30c503/src%2Fdoc%2Fbook%2Fdining-philosophers.md", "raw_url": "https://github.com/rust-lang/rust/raw/27a1834ce522e3ec7fe4726b1661de16ee30c503/src%2Fdoc%2Fbook%2Fdining-philosophers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fdining-philosophers.md?ref=27a1834ce522e3ec7fe4726b1661de16ee30c503", "patch": "@@ -1,723 +0,0 @@\n-% Dining Philosophers\n-\n-For our second project, let\u2019s look at a classic concurrency problem. It\u2019s\n-called \u2018the dining philosophers\u2019. It was originally conceived by Dijkstra in\n-1965, but we\u2019ll use a lightly adapted version from [this paper][paper] by Tony\n-Hoare in 1985.\n-\n-[paper]: http://www.usingcsp.com/cspbook.pdf\n-\n-> In ancient times, a wealthy philanthropist endowed a College to accommodate\n-> five eminent philosophers. Each philosopher had a room in which they could\n-> engage in their professional activity of thinking; there was also a common\n-> dining room, furnished with a circular table, surrounded by five chairs, each\n-> labelled by the name of the philosopher who was to sit in it. They sat\n-> anticlockwise around the table. To the left of each philosopher there was\n-> laid a golden fork, and in the center stood a large bowl of spaghetti, which\n-> was constantly replenished. A philosopher was expected to spend most of\n-> their time thinking; but when they felt hungry, they went to the dining\n-> room, sat down in their own chair, picked up their own fork on their left,\n-> and plunged it into the spaghetti. But such is the tangled nature of\n-> spaghetti that a second fork is required to carry it to the mouth. The\n-> philosopher therefore had also to pick up the fork on their right. When\n-> they were finished they would put down both their forks, get up from their\n-> chair, and continue thinking. Of course, a fork can be used by only one\n-> philosopher at a time. If the other philosopher wants it, they just have\n-> to wait until the fork is available again.\n-\n-This classic problem shows off a few different elements of concurrency. The\n-reason is that it's actually slightly tricky to implement: a simple\n-implementation can deadlock. For example, let's consider a simple algorithm\n-that would solve this problem:\n-\n-1. A philosopher picks up the fork on their left.\n-2. They then pick up the fork on their right.\n-3. They eat.\n-4. They return the forks.\n-\n-Now, let\u2019s imagine this sequence of events:\n-\n-1. Philosopher 1 begins the algorithm, picking up the fork on their left.\n-2. Philosopher 2 begins the algorithm, picking up the fork on their left.\n-3. Philosopher 3 begins the algorithm, picking up the fork on their left.\n-4. Philosopher 4 begins the algorithm, picking up the fork on their left.\n-5. Philosopher 5 begins the algorithm, picking up the fork on their left.\n-6. ... ? All the forks are taken, but nobody can eat!\n-\n-There are different ways to solve this problem. We\u2019ll get to our solution in\n-the tutorial itself. For now, let\u2019s get started and create a new project with\n-`cargo`:\n-\n-```bash\n-$ cd ~/projects\n-$ cargo new dining_philosophers --bin\n-$ cd dining_philosophers\n-```\n-\n-Now we can start modeling the problem itself. We\u2019ll start with the philosophers\n-in `src/main.rs`:\n-\n-```rust\n-struct Philosopher {\n-    name: String,\n-}\n-\n-impl Philosopher {\n-    fn new(name: &str) -> Philosopher {\n-        Philosopher {\n-            name: name.to_string(),\n-        }\n-    }\n-}\n-\n-fn main() {\n-    let p1 = Philosopher::new(\"Judith Butler\");\n-    let p2 = Philosopher::new(\"Gilles Deleuze\");\n-    let p3 = Philosopher::new(\"Karl Marx\");\n-    let p4 = Philosopher::new(\"Emma Goldman\");\n-    let p5 = Philosopher::new(\"Michel Foucault\");\n-}\n-```\n-\n-Here, we make a [`struct`][struct] to represent a philosopher. For now,\n-a name is all we need. We choose the [`String`][string] type for the name,\n-rather than `&str`. Generally speaking, working with a type which owns its\n-data is easier than working with one that uses references.\n-\n-[struct]: structs.html\n-[string]: strings.html\n-\n-Let\u2019s continue:\n-\n-```rust\n-# struct Philosopher {\n-#     name: String,\n-# }\n-impl Philosopher {\n-    fn new(name: &str) -> Philosopher {\n-        Philosopher {\n-            name: name.to_string(),\n-        }\n-    }\n-}\n-```\n-\n-This `impl` block lets us define things on `Philosopher` structs. In this case,\n-we define an \u2018associated function\u2019 called `new`. The first line looks like this:\n-\n-```rust\n-# struct Philosopher {\n-#     name: String,\n-# }\n-# impl Philosopher {\n-fn new(name: &str) -> Philosopher {\n-#         Philosopher {\n-#             name: name.to_string(),\n-#         }\n-#     }\n-# }\n-```\n-\n-We take one argument, a `name`, of type `&str`. This is a reference to another\n-string. It returns an instance of our `Philosopher` struct.\n-\n-```rust\n-# struct Philosopher {\n-#     name: String,\n-# }\n-# impl Philosopher {\n-#    fn new(name: &str) -> Philosopher {\n-Philosopher {\n-    name: name.to_string(),\n-}\n-#     }\n-# }\n-```\n-\n-This creates a new `Philosopher`, and sets its `name` to our `name` argument.\n-Not just the argument itself, though, as we call `.to_string()` on it. This\n-will create a copy of the string that our `&str` points to, and give us a new\n-`String`, which is the type of the `name` field of `Philosopher`.\n-\n-Why not accept a `String` directly? It\u2019s nicer to call. If we took a `String`,\n-but our caller had a `&str`, they\u2019d have to call this method themselves. The\n-downside of this flexibility is that we _always_ make a copy. For this small\n-program, that\u2019s not particularly important, as we know we\u2019ll just be using\n-short strings anyway.\n-\n-One last thing you\u2019ll notice: we just define a `Philosopher`, and seemingly\n-don\u2019t do anything with it. Rust is an \u2018expression based\u2019 language, which means\n-that almost everything in Rust is an expression which returns a value. This is\n-true of functions as well \u2014 the last expression is automatically returned. Since\n-we create a new `Philosopher` as the last expression of this function, we end\n-up returning it.\n-\n-This name, `new()`, isn\u2019t anything special to Rust, but it is a convention for\n-functions that create new instances of structs. Before we talk about why, let\u2019s\n-look at `main()` again:\n-\n-```rust\n-# struct Philosopher {\n-#     name: String,\n-# }\n-#\n-# impl Philosopher {\n-#     fn new(name: &str) -> Philosopher {\n-#         Philosopher {\n-#             name: name.to_string(),\n-#         }\n-#     }\n-# }\n-#\n-fn main() {\n-    let p1 = Philosopher::new(\"Judith Butler\");\n-    let p2 = Philosopher::new(\"Gilles Deleuze\");\n-    let p3 = Philosopher::new(\"Karl Marx\");\n-    let p4 = Philosopher::new(\"Emma Goldman\");\n-    let p5 = Philosopher::new(\"Michel Foucault\");\n-}\n-```\n-\n-Here, we create five variable bindings with five new philosophers.\n-If we _didn\u2019t_ define\n-that `new()` function, it would look like this:\n-\n-```rust\n-# struct Philosopher {\n-#     name: String,\n-# }\n-fn main() {\n-    let p1 = Philosopher { name: \"Judith Butler\".to_string() };\n-    let p2 = Philosopher { name: \"Gilles Deleuze\".to_string() };\n-    let p3 = Philosopher { name: \"Karl Marx\".to_string() };\n-    let p4 = Philosopher { name: \"Emma Goldman\".to_string() };\n-    let p5 = Philosopher { name: \"Michel Foucault\".to_string() };\n-}\n-```\n-\n-That\u2019s much noisier. Using `new` has other advantages too, but even in\n-this simple case, it ends up being nicer to use.\n-\n-Now that we\u2019ve got the basics in place, there\u2019s a number of ways that we can\n-tackle the broader problem here. I like to start from the end first: let\u2019s\n-set up a way for each philosopher to finish eating. As a tiny step, let\u2019s make\n-a method, and then loop through all the philosophers, calling it:\n-\n-```rust\n-struct Philosopher {\n-    name: String,\n-}\n-\n-impl Philosopher {\n-    fn new(name: &str) -> Philosopher {\n-        Philosopher {\n-            name: name.to_string(),\n-        }\n-    }\n-\n-    fn eat(&self) {\n-        println!(\"{} is done eating.\", self.name);\n-    }\n-}\n-\n-fn main() {\n-    let philosophers = vec![\n-        Philosopher::new(\"Judith Butler\"),\n-        Philosopher::new(\"Gilles Deleuze\"),\n-        Philosopher::new(\"Karl Marx\"),\n-        Philosopher::new(\"Emma Goldman\"),\n-        Philosopher::new(\"Michel Foucault\"),\n-    ];\n-\n-    for p in &philosophers {\n-        p.eat();\n-    }\n-}\n-```\n-\n-Let\u2019s look at `main()` first. Rather than have five individual variable\n-bindings for our philosophers, we make a `Vec<T>` of them instead. `Vec<T>` is\n-also called a \u2018vector\u2019, and it\u2019s a growable array type. We then use a\n-[`for`][for] loop to iterate through the vector, getting a reference to each\n-philosopher in turn.\n-\n-[for]: loops.html#for\n-\n-In the body of the loop, we call `p.eat()`, which is defined above:\n-\n-```rust,ignore\n-fn eat(&self) {\n-    println!(\"{} is done eating.\", self.name);\n-}\n-```\n-\n-In Rust, methods take an explicit `self` parameter. That\u2019s why `eat()` is a\n-method, but `new` is an associated function: `new()` has no `self`. For our\n-first version of `eat()`, we just print out the name of the philosopher, and\n-mention they\u2019re done eating. Running this program should give you the following\n-output:\n-\n-```text\n-Judith Butler is done eating.\n-Gilles Deleuze is done eating.\n-Karl Marx is done eating.\n-Emma Goldman is done eating.\n-Michel Foucault is done eating.\n-```\n-\n-Easy enough, they\u2019re all done! We haven\u2019t actually implemented the real problem\n-yet, though, so we\u2019re not done yet!\n-\n-Next, we want to make our philosophers not just finish eating, but actually\n-eat. Here\u2019s the next version:\n-\n-```rust\n-use std::thread;\n-use std::time::Duration;\n-\n-struct Philosopher {\n-    name: String,\n-}\n-\n-impl Philosopher {\n-    fn new(name: &str) -> Philosopher {\n-        Philosopher {\n-            name: name.to_string(),\n-        }\n-    }\n-\n-    fn eat(&self) {\n-        println!(\"{} is eating.\", self.name);\n-\n-        thread::sleep(Duration::from_millis(1000));\n-\n-        println!(\"{} is done eating.\", self.name);\n-    }\n-}\n-\n-fn main() {\n-    let philosophers = vec![\n-        Philosopher::new(\"Judith Butler\"),\n-        Philosopher::new(\"Gilles Deleuze\"),\n-        Philosopher::new(\"Karl Marx\"),\n-        Philosopher::new(\"Emma Goldman\"),\n-        Philosopher::new(\"Michel Foucault\"),\n-    ];\n-\n-    for p in &philosophers {\n-        p.eat();\n-    }\n-}\n-```\n-\n-Just a few changes. Let\u2019s break it down.\n-\n-```rust,ignore\n-use std::thread;\n-```\n-\n-`use` brings names into scope. We\u2019re going to start using the `thread` module\n-from the standard library, and so we need to `use` it.\n-\n-```rust,ignore\n-    fn eat(&self) {\n-        println!(\"{} is eating.\", self.name);\n-\n-        thread::sleep(Duration::from_millis(1000));\n-\n-        println!(\"{} is done eating.\", self.name);\n-    }\n-```\n-\n-We now print out two messages, with a `sleep` in the middle. This will\n-simulate the time it takes a philosopher to eat.\n-\n-If you run this program, you should see each philosopher eat in turn:\n-\n-```text\n-Judith Butler is eating.\n-Judith Butler is done eating.\n-Gilles Deleuze is eating.\n-Gilles Deleuze is done eating.\n-Karl Marx is eating.\n-Karl Marx is done eating.\n-Emma Goldman is eating.\n-Emma Goldman is done eating.\n-Michel Foucault is eating.\n-Michel Foucault is done eating.\n-```\n-\n-Excellent! We\u2019re getting there. There\u2019s just one problem: we aren\u2019t actually\n-operating in a concurrent fashion, which is a core part of the problem!\n-\n-To make our philosophers eat concurrently, we need to make a small change.\n-Here\u2019s the next iteration:\n-\n-```rust\n-use std::thread;\n-use std::time::Duration;\n-\n-struct Philosopher {\n-    name: String,\n-}\n-\n-impl Philosopher {\n-    fn new(name: &str) -> Philosopher {\n-        Philosopher {\n-            name: name.to_string(),\n-        }\n-    }\n-\n-    fn eat(&self) {\n-        println!(\"{} is eating.\", self.name);\n-\n-        thread::sleep(Duration::from_millis(1000));\n-\n-        println!(\"{} is done eating.\", self.name);\n-    }\n-}\n-\n-fn main() {\n-    let philosophers = vec![\n-        Philosopher::new(\"Judith Butler\"),\n-        Philosopher::new(\"Gilles Deleuze\"),\n-        Philosopher::new(\"Karl Marx\"),\n-        Philosopher::new(\"Emma Goldman\"),\n-        Philosopher::new(\"Michel Foucault\"),\n-    ];\n-\n-    let handles: Vec<_> = philosophers.into_iter().map(|p| {\n-        thread::spawn(move || {\n-            p.eat();\n-        })\n-    }).collect();\n-\n-    for h in handles {\n-        h.join().unwrap();\n-    }\n-}\n-```\n-\n-All we\u2019ve done is change the loop in `main()`, and added a second one! Here\u2019s the\n-first change:\n-\n-```rust,ignore\n-let handles: Vec<_> = philosophers.into_iter().map(|p| {\n-    thread::spawn(move || {\n-        p.eat();\n-    })\n-}).collect();\n-```\n-\n-While this is only five lines, they\u2019re a dense five. Let\u2019s break it down.\n-\n-```rust,ignore\n-let handles: Vec<_> =\n-```\n-\n-We introduce a new binding, called `handles`. We\u2019ve given it this name because\n-we are going to make some new threads, and that will return some handles to those\n-threads that let us control their operation. We need to explicitly annotate\n-the type here, though, due to an issue we\u2019ll talk about later. The `_` is\n-a type placeholder. We\u2019re saying \u201c`handles` is a vector of something, but you\n-can figure out what that something is, Rust.\u201d\n-\n-```rust,ignore\n-philosophers.into_iter().map(|p| {\n-```\n-\n-We take our list of philosophers and call `into_iter()` on it. This creates an\n-iterator that takes ownership of each philosopher. We need to do this to pass\n-them to our threads. We take that iterator and call `map` on it, which takes a\n-closure as an argument and calls that closure on each element in turn.\n-\n-```rust,ignore\n-    thread::spawn(move || {\n-        p.eat();\n-    })\n-```\n-\n-Here\u2019s where the concurrency happens. The `thread::spawn` function takes a closure\n-as an argument and executes that closure in a new thread. This closure needs\n-an extra annotation, `move`, to indicate that the closure is going to take\n-ownership of the values it\u2019s capturing. In this case, it's the `p` variable of the\n-`map` function.\n-\n-Inside the thread, all we do is call `eat()` on `p`. Also note that\n-the call to `thread::spawn` lacks a trailing semicolon, making this an\n-expression. This distinction is important, yielding the correct return\n-value. For more details, read [Expressions vs. Statements][es].\n-\n-[es]: functions.html#expressions-vs-statements\n-\n-```rust,ignore\n-}).collect();\n-```\n-\n-Finally, we take the result of all those `map` calls and collect them up.\n-`collect()` will make them into a collection of some kind, which is why we\n-needed to annotate the return type: we want a `Vec<T>`. The elements are the\n-return values of the `thread::spawn` calls, which are handles to those threads.\n-Whew!\n-\n-```rust,ignore\n-for h in handles {\n-    h.join().unwrap();\n-}\n-```\n-\n-At the end of `main()`, we loop through the handles and call `join()` on them,\n-which blocks execution until the thread has completed execution. This ensures\n-that the threads complete their work before the program exits.\n-\n-If you run this program, you\u2019ll see that the philosophers eat out of order!\n-We have multi-threading!\n-\n-```text\n-Judith Butler is eating.\n-Gilles Deleuze is eating.\n-Karl Marx is eating.\n-Emma Goldman is eating.\n-Michel Foucault is eating.\n-Judith Butler is done eating.\n-Gilles Deleuze is done eating.\n-Karl Marx is done eating.\n-Emma Goldman is done eating.\n-Michel Foucault is done eating.\n-```\n-\n-But what about the forks? We haven\u2019t modeled them at all yet.\n-\n-To do that, let\u2019s make a new `struct`:\n-\n-```rust\n-use std::sync::Mutex;\n-\n-struct Table {\n-    forks: Vec<Mutex<()>>,\n-}\n-```\n-\n-This `Table` has a vector of `Mutex`es. A mutex is a way to control\n-concurrency: only one thread can access the contents at once. This is exactly\n-the property we need with our forks. We use an empty tuple, `()`, inside the\n-mutex, since we\u2019re not actually going to use the value, just hold onto it.\n-\n-Let\u2019s modify the program to use the `Table`:\n-\n-```rust\n-use std::thread;\n-use std::time::Duration;\n-use std::sync::{Mutex, Arc};\n-\n-struct Philosopher {\n-    name: String,\n-    left: usize,\n-    right: usize,\n-}\n-\n-impl Philosopher {\n-    fn new(name: &str, left: usize, right: usize) -> Philosopher {\n-        Philosopher {\n-            name: name.to_string(),\n-            left: left,\n-            right: right,\n-        }\n-    }\n-\n-    fn eat(&self, table: &Table) {\n-        let _left = table.forks[self.left].lock().unwrap();\n-        thread::sleep(Duration::from_millis(150));\n-        let _right = table.forks[self.right].lock().unwrap();\n-\n-        println!(\"{} is eating.\", self.name);\n-\n-        thread::sleep(Duration::from_millis(1000));\n-\n-        println!(\"{} is done eating.\", self.name);\n-    }\n-}\n-\n-struct Table {\n-    forks: Vec<Mutex<()>>,\n-}\n-\n-fn main() {\n-    let table = Arc::new(Table { forks: vec![\n-        Mutex::new(()),\n-        Mutex::new(()),\n-        Mutex::new(()),\n-        Mutex::new(()),\n-        Mutex::new(()),\n-    ]});\n-\n-    let philosophers = vec![\n-        Philosopher::new(\"Judith Butler\", 0, 1),\n-        Philosopher::new(\"Gilles Deleuze\", 1, 2),\n-        Philosopher::new(\"Karl Marx\", 2, 3),\n-        Philosopher::new(\"Emma Goldman\", 3, 4),\n-        Philosopher::new(\"Michel Foucault\", 0, 4),\n-    ];\n-\n-    let handles: Vec<_> = philosophers.into_iter().map(|p| {\n-        let table = table.clone();\n-\n-        thread::spawn(move || {\n-            p.eat(&table);\n-        })\n-    }).collect();\n-\n-    for h in handles {\n-        h.join().unwrap();\n-    }\n-}\n-```\n-\n-Lots of changes! However, with this iteration, we\u2019ve got a working program.\n-Let\u2019s go over the details:\n-\n-```rust,ignore\n-use std::sync::{Mutex, Arc};\n-```\n-\n-We\u2019re going to use another structure from the `std::sync` package: `Arc<T>`.\n-We\u2019ll talk more about it when we use it.\n-\n-```rust,ignore\n-struct Philosopher {\n-    name: String,\n-    left: usize,\n-    right: usize,\n-}\n-```\n-\n-We need to add two more fields to our `Philosopher`. Each philosopher is going\n-to have two forks: the one on their left, and the one on their right.\n-We\u2019ll use the `usize` type to indicate them, as it\u2019s the type that you index\n-vectors with. These two values will be the indexes into the `forks` our `Table`\n-has.\n-\n-```rust,ignore\n-fn new(name: &str, left: usize, right: usize) -> Philosopher {\n-    Philosopher {\n-        name: name.to_string(),\n-        left: left,\n-        right: right,\n-    }\n-}\n-```\n-\n-We now need to construct those `left` and `right` values, so we add them to\n-`new()`.\n-\n-```rust,ignore\n-fn eat(&self, table: &Table) {\n-    let _left = table.forks[self.left].lock().unwrap();\n-    thread::sleep(Duration::from_millis(150));\n-    let _right = table.forks[self.right].lock().unwrap();\n-\n-    println!(\"{} is eating.\", self.name);\n-\n-    thread::sleep(Duration::from_millis(1000));\n-\n-    println!(\"{} is done eating.\", self.name);\n-}\n-```\n-\n-We have three new lines. We\u2019ve added an argument, `table`. We access the\n-`Table`\u2019s list of forks, and then use `self.left` and `self.right` to access\n-the fork at that particular index. That gives us access to the `Mutex` at that\n-index, and we call `lock()` on it. If the mutex is currently being accessed by\n-someone else, we\u2019ll block until it becomes available. We have also a call to\n-`thread::sleep` between the moment the first fork is picked and the moment the\n-second forked is picked, as the process of picking up the fork is not\n-immediate.\n-\n-The call to `lock()` might fail, and if it does, we want to crash. In this\n-case, the error that could happen is that the mutex is [\u2018poisoned\u2019][poison],\n-which is what happens when the thread panics while the lock is held. Since this\n-shouldn\u2019t happen, we just use `unwrap()`.\n-\n-[poison]: ../std/sync/struct.Mutex.html#poisoning\n-\n-One other odd thing about these lines: we\u2019ve named the results `_left` and\n-`_right`. What\u2019s up with that underscore? Well, we aren\u2019t planning on\n-_using_ the value inside the lock. We just want to acquire it. As such,\n-Rust will warn us that we never use the value. By using the underscore,\n-we tell Rust that this is what we intended, and it won\u2019t throw a warning.\n-\n-What about releasing the lock? Well, that will happen when `_left` and\n-`_right` go out of scope, automatically.\n-\n-```rust,ignore\n-    let table = Arc::new(Table { forks: vec![\n-        Mutex::new(()),\n-        Mutex::new(()),\n-        Mutex::new(()),\n-        Mutex::new(()),\n-        Mutex::new(()),\n-    ]});\n-```\n-\n-Next, in `main()`, we make a new `Table` and wrap it in an `Arc<T>`.\n-\u2018arc\u2019 stands for \u2018atomic reference count\u2019, and we need that to share\n-our `Table` across multiple threads. As we share it, the reference\n-count will go up, and when each thread ends, it will go back down.\n-\n-\n-```rust,ignore\n-let philosophers = vec![\n-    Philosopher::new(\"Judith Butler\", 0, 1),\n-    Philosopher::new(\"Gilles Deleuze\", 1, 2),\n-    Philosopher::new(\"Karl Marx\", 2, 3),\n-    Philosopher::new(\"Emma Goldman\", 3, 4),\n-    Philosopher::new(\"Michel Foucault\", 0, 4),\n-];\n-```\n-\n-We need to pass in our `left` and `right` values to the constructors for our\n-`Philosopher`s. But there\u2019s one more detail here, and it\u2019s _very_ important. If\n-you look at the pattern, it\u2019s all consistent until the very end. Monsieur\n-Foucault should have `4, 0` as arguments, but instead, has `0, 4`. This is what\n-prevents deadlock, actually: one of our philosophers is left handed! This is\n-one way to solve the problem, and in my opinion, it\u2019s the simplest. If you\n-change the order of the parameters, you will be able to observe the deadlock\n-taking place.\n-\n-```rust,ignore\n-let handles: Vec<_> = philosophers.into_iter().map(|p| {\n-    let table = table.clone();\n-\n-    thread::spawn(move || {\n-        p.eat(&table);\n-    })\n-}).collect();\n-```\n-\n-Finally, inside of our `map()`/`collect()` loop, we call `table.clone()`. The\n-`clone()` method on `Arc<T>` is what bumps up the reference count, and when it\n-goes out of scope, it decrements the count. This is needed so that we know how\n-many references to `table` exist across our threads. If we didn\u2019t have a count,\n-we wouldn\u2019t know how to deallocate it.\n-\n-You\u2019ll notice we can introduce a new binding to `table` here, and it will\n-shadow the old one. This is often used so that you don\u2019t need to come up with\n-two unique names.\n-\n-With this, our program works! Only two philosophers can eat at any one time,\n-and so you\u2019ll get some output like this:\n-\n-```text\n-Gilles Deleuze is eating.\n-Emma Goldman is eating.\n-Emma Goldman is done eating.\n-Gilles Deleuze is done eating.\n-Judith Butler is eating.\n-Karl Marx is eating.\n-Judith Butler is done eating.\n-Michel Foucault is eating.\n-Karl Marx is done eating.\n-Michel Foucault is done eating.\n-```\n-\n-Congrats! You\u2019ve implemented a classic concurrency problem in Rust."}, {"sha": "323bcbc95033ccd98e984949935bcfedb03a8340", "filename": "src/doc/book/guessing-game.md", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c6c34de87c899ecb8b977e7ef24510ab2a68168/src%2Fdoc%2Fbook%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/0c6c34de87c899ecb8b977e7ef24510ab2a68168/src%2Fdoc%2Fbook%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fguessing-game.md?ref=0c6c34de87c899ecb8b977e7ef24510ab2a68168", "patch": "@@ -1,10 +1,14 @@\n % Guessing Game\n \n-For our first project, we\u2019ll implement a classic beginner programming problem:\n-the guessing game. Here\u2019s how it works: Our program will generate a random\n-integer between one and a hundred. It will then prompt us to enter a guess.\n-Upon entering our guess, it will tell us if we\u2019re too low or too high. Once we\n-guess correctly, it will congratulate us. Sounds good?\n+Let\u2019s learn some Rust! For our first project, we\u2019ll implement a classic\n+beginner programming problem: the guessing game. Here\u2019s how it works: Our\n+program will generate a random integer between one and a hundred. It will then\n+prompt us to enter a guess. Upon entering our guess, it will tell us if we\u2019re\n+too low or too high. Once we guess correctly, it will congratulate us. Sounds\n+good?\n+\n+Along the way, we\u2019ll learn a little bit about Rust. The next section, \u2018Syntax\n+and Semantics\u2019, will dive deeper into each part.\n \n # Set up\n "}, {"sha": "61627c0b5a2fe99c63d292d315ea5a988a10bf2c", "filename": "src/doc/book/rust-inside-other-languages.md", "status": "removed", "additions": 0, "deletions": 344, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/27a1834ce522e3ec7fe4726b1661de16ee30c503/src%2Fdoc%2Fbook%2Frust-inside-other-languages.md", "raw_url": "https://github.com/rust-lang/rust/raw/27a1834ce522e3ec7fe4726b1661de16ee30c503/src%2Fdoc%2Fbook%2Frust-inside-other-languages.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Frust-inside-other-languages.md?ref=27a1834ce522e3ec7fe4726b1661de16ee30c503", "patch": "@@ -1,344 +0,0 @@\n-% Rust Inside Other Languages\n-\n-For our third project, we\u2019re going to choose something that shows off one of\n-Rust\u2019s greatest strengths: a lack of a substantial runtime.\n-\n-As organizations grow, they increasingly rely on a multitude of programming\n-languages. Different programming languages have different strengths and\n-weaknesses, and a polyglot stack lets you use a particular language where\n-its strengths make sense and a different one where it\u2019s weak.\n-\n-A very common area where many programming languages are weak is in runtime\n-performance of programs. Often, using a language that is slower, but offers\n-greater programmer productivity, is a worthwhile trade-off. To help mitigate\n-this, they provide a way to write some of your system in C and then call\n-that C code as though it were written in the higher-level language. This is\n-called a \u2018foreign function interface\u2019, often shortened to \u2018FFI\u2019.\n-\n-Rust has support for FFI in both directions: it can call into C code easily,\n-but crucially, it can also be called _into_ as easily as C. Combined with\n-Rust\u2019s lack of a garbage collector and low runtime requirements, this makes\n-Rust a great candidate to embed inside of other languages when you need\n-that extra oomph.\n-\n-There is a whole [chapter devoted to FFI][ffi] and its specifics elsewhere in\n-the book, but in this chapter, we\u2019ll examine this particular use-case of FFI,\n-with examples in Ruby, Python, and JavaScript.\n-\n-[ffi]: ffi.html\n-\n-# The problem\n-\n-There are many different projects we could choose here, but we\u2019re going to\n-pick an example where Rust has a clear advantage over many other languages:\n-numeric computing and threading.\n-\n-Many languages, for the sake of consistency, place numbers on the heap, rather\n-than on the stack. Especially in languages that focus on object-oriented\n-programming and use garbage collection, heap allocation is the default. Sometimes\n-optimizations can stack allocate particular numbers, but rather than relying\n-on an optimizer to do its job, we may want to ensure that we\u2019re always using\n-primitive number types rather than some sort of object type.\n-\n-Second, many languages have a \u2018global interpreter lock\u2019 (GIL), which limits\n-concurrency in many situations. This is done in the name of safety, which is\n-a positive effect, but it limits the amount of work that can be done at the\n-same time, which is a big negative.\n-\n-To emphasize these two aspects, we\u2019re going to create a little project that\n-uses these two aspects heavily. Since the focus of the example is to embed\n-Rust into other languages, rather than the problem itself, we\u2019ll just use a\n-toy example:\n-\n-> Start ten threads. Inside each thread, count from one to five million. After\n-> all ten threads are finished, print out \u2018done!\u2019.\n-\n-I chose five million based on my particular computer. Here\u2019s an example of this\n-code in Ruby:\n-\n-```ruby\n-threads = []\n-\n-10.times do\n-  threads << Thread.new do\n-    count = 0\n-\n-    5_000_000.times do\n-      count += 1\n-    end\n-\n-    count\n-  end\n-end\n-\n-threads.each do |t|\n-  puts \"Thread finished with count=#{t.value}\"\n-end\n-puts \"done!\"\n-```\n-\n-Try running this example, and choose a number that runs for a few seconds.\n-Depending on your computer\u2019s hardware, you may have to increase or decrease the\n-number.\n-\n-On my system, running this program takes `2.156` seconds. And, if I use some\n-sort of process monitoring tool, like `top`, I can see that it only uses one\n-core on my machine. That\u2019s the GIL kicking in.\n-\n-While it\u2019s true that this is a synthetic program, one can imagine many problems\n-that are similar to this in the real world. For our purposes, spinning up a few\n-busy threads represents some sort of parallel, expensive computation.\n-\n-# A Rust library\n-\n-Let\u2019s rewrite this problem in Rust. First, let\u2019s make a new project with\n-Cargo:\n-\n-```bash\n-$ cargo new embed\n-$ cd embed\n-```\n-\n-This program is fairly easy to write in Rust:\n-\n-```rust\n-use std::thread;\n-\n-fn process() {\n-    let handles: Vec<_> = (0..10).map(|_| {\n-        thread::spawn(|| {\n-            let mut x = 0;\n-            for _ in 0..5_000_000 {\n-                x += 1\n-            }\n-            x\n-        })\n-    }).collect();\n-\n-    for h in handles {\n-        println!(\"Thread finished with count={}\",\n-\t    h.join().map_err(|_| \"Could not join a thread!\").unwrap());\n-    }\n-}\n-```\n-\n-Some of this should look familiar from previous examples. We spin up ten\n-threads, collecting them into a `handles` vector. Inside of each thread, we\n-loop five million times, and add one to `x` each time. Finally, we join on\n-each thread.\n-\n-Right now, however, this is a Rust library, and it doesn\u2019t expose anything\n-that\u2019s callable from C. If we tried to hook this up to another language right\n-now, it wouldn\u2019t work. We only need to make two small changes to fix this,\n-though. The first is to modify the beginning of our code:\n-\n-```rust,ignore\n-#[no_mangle]\n-pub extern fn process() {\n-```\n-\n-We have to add a new attribute, `no_mangle`. When you create a Rust library, it\n-changes the name of the function in the compiled output. The reasons for this\n-are outside the scope of this tutorial, but in order for other languages to\n-know how to call the function, we can\u2019t do that. This attribute turns\n-that behavior off.\n-\n-The other change is the `pub extern`. The `pub` means that this function should\n-be callable from outside of this module, and the `extern` says that it should\n-be able to be called from C. That\u2019s it! Not a whole lot of change.\n-\n-The second thing we need to do is to change a setting in our `Cargo.toml`. Add\n-this at the bottom:\n-\n-```toml\n-[lib]\n-name = \"embed\"\n-crate-type = [\"dylib\"]\n-```\n-\n-This tells Rust that we want to compile our library into a standard dynamic\n-library. By default, Rust compiles an \u2018rlib\u2019, a Rust-specific format.\n-\n-Let\u2019s build the project now:\n-\n-```bash\n-$ cargo build --release\n-   Compiling embed v0.1.0 (file:///home/steve/src/embed)\n-```\n-\n-We\u2019ve chosen `cargo build --release`, which builds with optimizations on. We\n-want this to be as fast as possible! You can find the output of the library in\n-`target/release`:\n-\n-```bash\n-$ ls target/release/\n-build  deps  examples  libembed.so  native\n-```\n-\n-That `libembed.so` is our \u2018shared object\u2019 library. We can use this file\n-just like any shared object library written in C! As an aside, this may be\n-`embed.dll` (Microsoft Windows) or `libembed.dylib` (Mac OS X), depending on \n-your operating system.\n-\n-Now that we\u2019ve got our Rust library built, let\u2019s use it from our Ruby.\n-\n-# Ruby\n-\n-Open up an `embed.rb` file inside of our project, and do this:\n-\n-```ruby\n-require 'ffi'\n-\n-module Hello\n-  extend FFI::Library\n-  ffi_lib 'target/release/libembed.so'\n-  attach_function :process, [], :void\n-end\n-\n-Hello.process\n-\n-puts 'done!'\n-```\n-\n-Before we can run this, we need to install the `ffi` gem:\n-\n-```bash\n-$ gem install ffi # this may need sudo\n-Fetching: ffi-1.9.8.gem (100%)\n-Building native extensions.  This could take a while...\n-Successfully installed ffi-1.9.8\n-Parsing documentation for ffi-1.9.8\n-Installing ri documentation for ffi-1.9.8\n-Done installing documentation for ffi after 0 seconds\n-1 gem installed\n-```\n-\n-And finally, we can try running it:\n-\n-```bash\n-$ ruby embed.rb\n-Thread finished with count=5000000\n-Thread finished with count=5000000\n-Thread finished with count=5000000\n-Thread finished with count=5000000\n-Thread finished with count=5000000\n-Thread finished with count=5000000\n-Thread finished with count=5000000\n-Thread finished with count=5000000\n-Thread finished with count=5000000\n-Thread finished with count=5000000\n-done!\n-done!\n-$\n-```\n-\n-Whoa, that was fast! On my system, this took `0.086` seconds, rather than\n-the two seconds the pure Ruby version took. Let\u2019s break down this Ruby\n-code:\n-\n-```ruby\n-require 'ffi'\n-```\n-\n-We first need to require the `ffi` gem. This lets us interface with our\n-Rust library like a C library.\n-\n-```ruby\n-module Hello\n-  extend FFI::Library\n-  ffi_lib 'target/release/libembed.so'\n-```\n-\n-The `Hello` module is used to attach the native functions from the shared\n-library. Inside, we `extend` the necessary `FFI::Library` module and then call\n-`ffi_lib` to load up our shared object library. We just pass it the path that\n-our library is stored, which, as we saw before, is\n-`target/release/libembed.so`.\n-\n-```ruby\n-attach_function :process, [], :void\n-```\n-\n-The `attach_function` method is provided by the FFI gem. It\u2019s what\n-connects our `process()` function in Rust to a Ruby function of the\n-same name. Since `process()` takes no arguments, the second parameter\n-is an empty array, and since it returns nothing, we pass `:void` as\n-the final argument.\n-\n-```ruby\n-Hello.process\n-```\n-\n-This is the actual call into Rust. The combination of our `module`\n-and the call to `attach_function` sets this all up. It looks like\n-a Ruby function but is actually Rust!\n-\n-```ruby\n-puts 'done!'\n-```\n-\n-Finally, as per our project\u2019s requirements, we print out `done!`.\n-\n-That\u2019s it! As we\u2019ve seen, bridging between the two languages is really easy,\n-and buys us a lot of performance.\n-\n-Next, let\u2019s try Python!\n-\n-# Python\n-\n-Create an `embed.py` file in this directory, and put this in it:\n-\n-```python\n-from ctypes import cdll\n-\n-lib = cdll.LoadLibrary(\"target/release/libembed.so\")\n-\n-lib.process()\n-\n-print(\"done!\")\n-```\n-\n-Even easier! We use `cdll` from the `ctypes` module. A quick call\n-to `LoadLibrary` later, and we can call `process()`.\n-\n-On my system, this takes `0.017` seconds. Speedy!\n-\n-# Node.js\n-\n-Node isn\u2019t a language, but it\u2019s currently the dominant implementation of\n-server-side JavaScript.\n-\n-In order to do FFI with Node, we first need to install the library:\n-\n-```bash\n-$ npm install ffi\n-```\n-\n-After that installs, we can use it:\n-\n-```javascript\n-var ffi = require('ffi');\n-\n-var lib = ffi.Library('target/release/libembed', {\n-  'process': ['void', []]\n-});\n-\n-lib.process();\n-\n-console.log(\"done!\");\n-```\n-\n-It looks more like the Ruby example than the Python example. We use\n-the `ffi` module to get access to `ffi.Library()`, which loads up\n-our shared object. We need to annotate the return type and argument\n-types of the function, which are `void` for return and an empty\n-array to signify no arguments. From there, we just call it and\n-print the result.\n-\n-On my system, this takes a quick `0.092` seconds.\n-\n-# Conclusion\n-\n-As you can see, the basics of doing this are _very_ easy. Of course,\n-there's a lot more that we could do here. Check out the [FFI][ffi]\n-chapter for more details."}]}