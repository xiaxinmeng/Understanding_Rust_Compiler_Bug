{"sha": "e64ead2f46144963bc18ba34477422f39577f7f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2NGVhZDJmNDYxNDQ5NjNiYzE4YmEzNDQ3NzQyMmYzOTU3N2Y3ZjY=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-02T21:34:14Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-02T21:34:14Z"}, "message": "Implement timeouts for FUTEX_WAIT.", "tree": {"sha": "f9a0c640dc1061fa97642681f4ca7f055d0d89f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9a0c640dc1061fa97642681f4ca7f055d0d89f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e64ead2f46144963bc18ba34477422f39577f7f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e64ead2f46144963bc18ba34477422f39577f7f6", "html_url": "https://github.com/rust-lang/rust/commit/e64ead2f46144963bc18ba34477422f39577f7f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e64ead2f46144963bc18ba34477422f39577f7f6/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5b3f54b46125a3da9af7e466e004b6905bc2f26", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5b3f54b46125a3da9af7e466e004b6905bc2f26", "html_url": "https://github.com/rust-lang/rust/commit/d5b3f54b46125a3da9af7e466e004b6905bc2f26"}], "stats": {"total": 54, "additions": 47, "deletions": 7}, "files": [{"sha": "4201ef3f4790faf9c1e4a5cefe1ad1c8c41aaf99", "filename": "src/shims/posix/linux/sync.rs", "status": "modified", "additions": 40, "deletions": 7, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e64ead2f46144963bc18ba34477422f39577f7f6/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64ead2f46144963bc18ba34477422f39577f7f6/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fsync.rs?ref=e64ead2f46144963bc18ba34477422f39577f7f6", "patch": "@@ -1,5 +1,7 @@\n+use crate::thread::Time;\n use crate::*;\n use rustc_target::abi::{Align, Size};\n+use std::time::{Instant, SystemTime};\n \n /// Implementation of the SYS_futex syscall.\n pub fn futex<'tcx>(\n@@ -38,23 +40,37 @@ pub fn futex<'tcx>(\n     let futex_private = this.eval_libc_i32(\"FUTEX_PRIVATE_FLAG\")?;\n     let futex_wait = this.eval_libc_i32(\"FUTEX_WAIT\")?;\n     let futex_wake = this.eval_libc_i32(\"FUTEX_WAKE\")?;\n+    let futex_realtime = this.eval_libc_i32(\"FUTEX_CLOCK_REALTIME\")?;\n \n     // FUTEX_PRIVATE enables an optimization that stops it from working across processes.\n     // Miri doesn't support that anyway, so we ignore that flag.\n     match op & !futex_private {\n         // FUTEX_WAIT: (int *addr, int op = FUTEX_WAIT, int val, const timespec *timeout)\n         // Blocks the thread if *addr still equals val. Wakes up when FUTEX_WAKE is called on the same address,\n         // or *timeout expires. `timeout == null` for an infinite timeout.\n-        op if op == futex_wait => {\n+        op if op & !futex_realtime == futex_wait => {\n             if args.len() < 5 {\n                 throw_ub_format!(\"incorrect number of arguments for FUTEX_WAIT syscall: got {}, expected at least 5\", args.len());\n             }\n-            let timeout = this.read_scalar(args[4])?.check_init()?;\n-            if !this.is_null(timeout)? {\n-                // FIXME: Implement timeouts. The condvar waiting code is probably a good example to start with.\n-                // Note that a triggered timeout should have this syscall return with -1 and errno set to ETIMEOUT.\n-                throw_ub_format!(\"miri does not support timeouts for futex operations\");\n-            }\n+            let timeout = args[4];\n+            let timeout_time = if this.is_null(this.read_scalar(timeout)?.check_init()?)? {\n+                None\n+            } else {\n+                let duration = match this.read_timespec(timeout)? {\n+                    Some(duration) => duration,\n+                    None => {\n+                        let einval = this.eval_libc(\"EINVAL\")?;\n+                        this.set_last_error(einval)?;\n+                        this.write_scalar(Scalar::from_i32(-1), dest)?;\n+                        return Ok(());\n+                    }\n+                };\n+                Some(if op & futex_realtime != 0 {\n+                    Time::RealTime(SystemTime::now().checked_add(duration).unwrap())\n+                } else {\n+                    Time::Monotonic(Instant::now().checked_add(duration).unwrap())\n+                })\n+            };\n             // Check the pointer for alignment and validity.\n             // Atomic operations are only available for fully aligned values.\n             this.memory.check_ptr_access(addr.into(), Size::from_bytes(4), Align::from_bytes(4).unwrap())?;\n@@ -66,6 +82,22 @@ pub fn futex<'tcx>(\n                 this.futex_wait(addr, thread);\n                 // Succesfully waking up from FUTEX_WAIT always returns zero.\n                 this.write_scalar(Scalar::from_i32(0), dest)?;\n+                // Register a timeout callback if a timeout was specified.\n+                // This callback will override the return value when the timeout triggers.\n+                if let Some(timeout_time) = timeout_time {\n+                    this.register_timeout_callback(\n+                        thread,\n+                        timeout_time,\n+                        Box::new(move |this| {\n+                            this.unblock_thread(thread);\n+                            this.futex_remove_waiter(addr, thread);\n+                            let etimedout = this.eval_libc(\"ETIMEDOUT\")?;\n+                            this.set_last_error(etimedout)?;\n+                            this.write_scalar(Scalar::from_i32(-1), dest)?;\n+                            Ok(())\n+                        }),\n+                    );\n+                }\n             } else {\n                 // The futex value doesn't match the expected value, so we return failure\n                 // right away without sleeping: -1 and errno set to EAGAIN.\n@@ -83,6 +115,7 @@ pub fn futex<'tcx>(\n             for _ in 0..val {\n                 if let Some(thread) = this.futex_wake(addr) {\n                     this.unblock_thread(thread);\n+                    this.unregister_timeout_callback_if_exists(thread);\n                     n += 1;\n                 } else {\n                     break;"}, {"sha": "0c12da8d684562a51af5a8e50d1390ec032b5bc1", "filename": "src/sync.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e64ead2f46144963bc18ba34477422f39577f7f6/src%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e64ead2f46144963bc18ba34477422f39577f7f6/src%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsync.rs?ref=e64ead2f46144963bc18ba34477422f39577f7f6", "patch": "@@ -430,4 +430,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let waiters = &mut this.machine.threads.sync.futexes.get_mut(&addr.erase_tag())?.waiters;\n         waiters.pop_front().map(|waiter| waiter.thread)\n     }\n+\n+    fn futex_remove_waiter(&mut self, addr: Pointer<stacked_borrows::Tag>, thread: ThreadId) {\n+        let this = self.eval_context_mut();\n+        if let Some(futex) = this.machine.threads.sync.futexes.get_mut(&addr.erase_tag()) {\n+            futex.waiters.retain(|waiter| waiter.thread != thread);\n+        }\n+    }\n }"}]}