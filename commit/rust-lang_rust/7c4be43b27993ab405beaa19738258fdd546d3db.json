{"sha": "7c4be43b27993ab405beaa19738258fdd546d3db", "node_id": "C_kwDOAAsO6NoAKDdjNGJlNDNiMjc5OTNhYjQwNWJlYWExOTczODI1OGZkZDU0NmQzZGI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-23T06:08:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-23T06:08:37Z"}, "message": "Auto merge of #84197 - bbjornse:stack-protector, r=nikic\n\nadd codegen option for using LLVM stack smash protection\n\nLLVM has built-in heuristics for adding stack canaries to functions. These\nheuristics can be selected with LLVM function attributes. This PR adds a codegen\noption `-C stack-protector={basic,strong,all}` which controls the use of these\nattributes. This gives rustc the same stack smash protection support as clang\noffers through options `-fstack-protector`, `-fstack-protector-strong`, and\n`-fstack-protector-all`. The protection this can offer is demonstrated in\ntest/ui/abi/stack-protector.rs. This fills a gap in the current list of rustc\nexploit mitigations (https://doc.rust-lang.org/rustc/exploit-mitigations.html),\noriginally discussed in #15179.\n\nStack smash protection adds runtime overhead and is therefore still off by\ndefault, but now users have the option to trade performance for security as they\nsee fit. An example use case is adding Rust code in an existing C/C++ code base\ncompiled with stack smash protection. Without the ability to add stack smash\nprotection to the Rust code, the code base artifacts could be exploitable in\nways not possible if the code base remained pure C/C++.\n\nStack smash protection support is present in LLVM for almost all the current\ntier 1/tier 2 targets: see\ntest/assembly/stack-protector/stack-protector-target-support.rs. The one\nexception is nvptx64-nvidia-cuda. This PR follows clang's example, and adds a\nwarning message printed if stack smash protection is used with this target (see\ntest/ui/stack-protector/warn-stack-protector-unsupported.rs). Support for tier 3\ntargets has not been checked.\n\nSince the heuristics are applied at the LLVM level, the heuristics are expected\nto add stack smash protection to a fraction of functions comparable to C/C++.\nSome experiments demonstrating how Rust code is affected by the different\nheuristics can be found in\ntest/assembly/stack-protector/stack-protector-heuristics-effect.rs. There is\npotential for better heuristics using Rust-specific safety information. For\nexample it might be reasonable to skip stack smash protection in functions which\ntransitively only use safe Rust code, or which uses only a subset of functions\nthe user declares safe (such as anything under `std.*`). Such alternative\nheuristics could be added at a later point.\n\nLLVM also offers a \"safestack\" sanitizer as an alternative way to guard against\nstack smashing (see #26612). This could possibly also be included as a\nstack-protection heuristic. An alternative is to add it as a sanitizer (#39699).\nThis is what clang does: safestack is exposed with option\n`-fsanitize=safe-stack`.\n\nThe options are only supported by the LLVM backend, but as with other codegen\noptions it is visible in the main codegen option help menu. The heuristic names\n\"basic\", \"strong\", and \"all\" are hopefully sufficiently generic to be usable in\nother backends as well.", "tree": {"sha": "382164cd8641b64972d8979fd27c2c34a78281f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/382164cd8641b64972d8979fd27c2c34a78281f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c4be43b27993ab405beaa19738258fdd546d3db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c4be43b27993ab405beaa19738258fdd546d3db", "html_url": "https://github.com/rust-lang/rust/commit/7c4be43b27993ab405beaa19738258fdd546d3db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c4be43b27993ab405beaa19738258fdd546d3db/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e055d92e0d527b273d12584bd842f6527e7652c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e055d92e0d527b273d12584bd842f6527e7652c", "html_url": "https://github.com/rust-lang/rust/commit/2e055d92e0d527b273d12584bd842f6527e7652c"}, {"sha": "bb9dee95edef5a0da5f617cd94d3af8daef201c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb9dee95edef5a0da5f617cd94d3af8daef201c7", "html_url": "https://github.com/rust-lang/rust/commit/bb9dee95edef5a0da5f617cd94d3af8daef201c7"}], "stats": {"total": 1029, "additions": 1017, "deletions": 12}, "files": [{"sha": "8e6329a997f141bc990713c125a43d54a7c9be80", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7c4be43b27993ab405beaa19738258fdd546d3db/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4be43b27993ab405beaa19738258fdd546d3db/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=7c4be43b27993ab405beaa19738258fdd546d3db", "patch": "@@ -12,7 +12,7 @@ use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::config::OptLevel;\n use rustc_session::Session;\n use rustc_target::spec::abi::Abi;\n-use rustc_target::spec::{FramePointer, SanitizerSet, StackProbeType};\n+use rustc_target::spec::{FramePointer, SanitizerSet, StackProbeType, StackProtector};\n \n use crate::attributes;\n use crate::llvm::AttributePlace::Function;\n@@ -161,6 +161,17 @@ fn set_probestack(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     }\n }\n \n+fn set_stackprotector(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n+    let sspattr = match cx.sess().stack_protector() {\n+        StackProtector::None => return,\n+        StackProtector::All => Attribute::StackProtectReq,\n+        StackProtector::Strong => Attribute::StackProtectStrong,\n+        StackProtector::Basic => Attribute::StackProtect,\n+    };\n+\n+    sspattr.apply_llfn(Function, llfn)\n+}\n+\n pub fn apply_target_cpu_attr(cx: &CodegenCx<'ll, '_>, llfn: &'ll Value) {\n     let target_cpu = SmallCStr::new(llvm_util::target_cpu(cx.tcx.sess));\n     llvm::AddFunctionAttrStringValue(\n@@ -271,6 +282,7 @@ pub fn from_fn_attrs(cx: &CodegenCx<'ll, 'tcx>, llfn: &'ll Value, instance: ty::\n     set_frame_pointer_type(cx, llfn);\n     set_instrument_function(cx, llfn);\n     set_probestack(cx, llfn);\n+    set_stackprotector(cx, llfn);\n \n     if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::COLD) {\n         Attribute::Cold.apply_llfn(Function, llfn);"}, {"sha": "c66d7d872c915033221259803e77391f9210d98f", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7c4be43b27993ab405beaa19738258fdd546d3db/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4be43b27993ab405beaa19738258fdd546d3db/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=7c4be43b27993ab405beaa19738258fdd546d3db", "patch": "@@ -288,6 +288,31 @@ impl CodegenBackend for LlvmCodegenBackend {\n                 }\n                 println!();\n             }\n+            PrintRequest::StackProtectorStrategies => {\n+                println!(\n+                    r#\"Available stack protector strategies:\n+    all\n+        Generate stack canaries in all functions.\n+\n+    strong\n+        Generate stack canaries in a function if it either:\n+        - has a local variable of `[T; N]` type, regardless of `T` and `N`\n+        - takes the address of a local variable.\n+\n+          (Note that a local variable being borrowed is not equivalent to its\n+          address being taken: e.g. some borrows may be removed by optimization,\n+          while by-value argument passing may be implemented with reference to a\n+          local stack variable in the ABI.)\n+\n+    basic\n+        Generate stack canaries in functions with:\n+        - local variables of `[T; N]` type, where `T` is byte-sized and `N` > 8.\n+\n+    none\n+        Do not generate stack canaries.\n+\"#\n+                );\n+            }\n             req => llvm_util::print(req, sess),\n         }\n     }"}, {"sha": "1d255c075598078f616ef704c1470bcb4d064a33", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c4be43b27993ab405beaa19738258fdd546d3db/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4be43b27993ab405beaa19738258fdd546d3db/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=7c4be43b27993ab405beaa19738258fdd546d3db", "patch": "@@ -166,6 +166,9 @@ pub enum Attribute {\n     InaccessibleMemOnly = 27,\n     SanitizeHWAddress = 28,\n     WillReturn = 29,\n+    StackProtectReq = 30,\n+    StackProtectStrong = 31,\n+    StackProtect = 32,\n }\n \n /// LLVMIntPredicate"}, {"sha": "6ff94341142fda67563b9f412857a987ab1256f3", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c4be43b27993ab405beaa19738258fdd546d3db/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4be43b27993ab405beaa19738258fdd546d3db/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=7c4be43b27993ab405beaa19738258fdd546d3db", "patch": "@@ -736,7 +736,12 @@ impl RustcDefaultCalls {\n                         println!(\"{}\", cfg);\n                     }\n                 }\n-                RelocationModels | CodeModels | TlsModels | TargetCPUs | TargetFeatures => {\n+                RelocationModels\n+                | CodeModels\n+                | TlsModels\n+                | TargetCPUs\n+                | StackProtectorStrategies\n+                | TargetFeatures => {\n                     codegen_backend.print(*req, sess);\n                 }\n                 // Any output here interferes with Cargo's parsing of other printed output"}, {"sha": "24d4b05042133f548219983d00a898cc059debe7", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7c4be43b27993ab405beaa19738258fdd546d3db/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4be43b27993ab405beaa19738258fdd546d3db/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=7c4be43b27993ab405beaa19738258fdd546d3db", "patch": "@@ -20,7 +20,9 @@ use rustc_span::edition::{Edition, DEFAULT_EDITION};\n use rustc_span::symbol::sym;\n use rustc_span::SourceFileHashAlgorithm;\n use rustc_target::spec::{CodeModel, LinkerFlavor, MergeFunctions, PanicStrategy};\n-use rustc_target::spec::{RelocModel, RelroLevel, SanitizerSet, SplitDebuginfo, TlsModel};\n+use rustc_target::spec::{\n+    RelocModel, RelroLevel, SanitizerSet, SplitDebuginfo, StackProtector, TlsModel,\n+};\n \n use std::collections::{BTreeMap, BTreeSet};\n use std::iter::FromIterator;\n@@ -713,8 +715,8 @@ fn test_debugging_options_tracking_hash() {\n     // This list is in alphabetical order.\n     tracked!(allow_features, Some(vec![String::from(\"lang_items\")]));\n     tracked!(always_encode_mir, true);\n-    tracked!(assume_incomplete_release, true);\n     tracked!(asm_comments, true);\n+    tracked!(assume_incomplete_release, true);\n     tracked!(binary_dep_depinfo, true);\n     tracked!(chalk, true);\n     tracked!(codegen_backend, Some(\"abc\".to_string()));\n@@ -731,8 +733,8 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(human_readable_cgu_names, true);\n     tracked!(inline_in_all_cgus, Some(true));\n     tracked!(inline_mir, Some(true));\n-    tracked!(inline_mir_threshold, Some(123));\n     tracked!(inline_mir_hint_threshold, Some(123));\n+    tracked!(inline_mir_threshold, Some(123));\n     tracked!(instrument_coverage, Some(InstrumentCoverage::All));\n     tracked!(instrument_mcount, true);\n     tracked!(link_only, true);\n@@ -764,23 +766,24 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(relax_elf_relocations, Some(true));\n     tracked!(relro_level, Some(RelroLevel::Full));\n     tracked!(remap_cwd_prefix, Some(PathBuf::from(\"abc\")));\n-    tracked!(simulate_remapped_rust_src_base, Some(PathBuf::from(\"/rustc/abc\")));\n     tracked!(report_delayed_bugs, true);\n     tracked!(sanitizer, SanitizerSet::ADDRESS);\n     tracked!(sanitizer_memory_track_origins, 2);\n     tracked!(sanitizer_recover, SanitizerSet::ADDRESS);\n     tracked!(saturating_float_casts, Some(true));\n     tracked!(share_generics, Some(true));\n     tracked!(show_span, Some(String::from(\"abc\")));\n+    tracked!(simulate_remapped_rust_src_base, Some(PathBuf::from(\"/rustc/abc\")));\n     tracked!(src_hash_algorithm, Some(SourceFileHashAlgorithm::Sha1));\n+    tracked!(stack_protector, StackProtector::All);\n     tracked!(symbol_mangling_version, Some(SymbolManglingVersion::V0));\n     tracked!(teach, true);\n     tracked!(thinlto, Some(true));\n     tracked!(thir_unsafeck, true);\n-    tracked!(tune_cpu, Some(String::from(\"abc\")));\n     tracked!(tls_model, Some(TlsModel::GeneralDynamic));\n     tracked!(trap_unreachable, Some(false));\n     tracked!(treat_err_as_bug, NonZeroUsize::new(1));\n+    tracked!(tune_cpu, Some(String::from(\"abc\")));\n     tracked!(unleash_the_miri_inside_of_you, true);\n     tracked!(use_ctors_section, Some(true));\n     tracked!(verify_llvm_ir, true);"}, {"sha": "e2ce7da0e84afc0eca5ad033ef8a7d4e253efaaa", "filename": "compiler/rustc_llvm/llvm-wrapper/LLVMWrapper.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c4be43b27993ab405beaa19738258fdd546d3db/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h", "raw_url": "https://github.com/rust-lang/rust/raw/7c4be43b27993ab405beaa19738258fdd546d3db/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h?ref=7c4be43b27993ab405beaa19738258fdd546d3db", "patch": "@@ -79,6 +79,9 @@ enum LLVMRustAttribute {\n   InaccessibleMemOnly = 27,\n   SanitizeHWAddress = 28,\n   WillReturn = 29,\n+  StackProtectReq = 30,\n+  StackProtectStrong = 31,\n+  StackProtect = 32,\n };\n \n typedef struct OpaqueRustString *RustStringRef;"}, {"sha": "bb6d42c1a9cbb0c3d42b644863808511802d3854", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c4be43b27993ab405beaa19738258fdd546d3db/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/7c4be43b27993ab405beaa19738258fdd546d3db/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=7c4be43b27993ab405beaa19738258fdd546d3db", "patch": "@@ -213,6 +213,12 @@ static Attribute::AttrKind fromRust(LLVMRustAttribute Kind) {\n     return Attribute::SanitizeHWAddress;\n   case WillReturn:\n     return Attribute::WillReturn;\n+  case StackProtectReq:\n+    return Attribute::StackProtectReq;\n+  case StackProtectStrong:\n+    return Attribute::StackProtectStrong;\n+  case StackProtect:\n+    return Attribute::StackProtect;\n   }\n   report_fatal_error(\"bad AttributeKind\");\n }"}, {"sha": "58e5087c72f94fa77ae9c76c882e8ef84f85a2be", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7c4be43b27993ab405beaa19738258fdd546d3db/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4be43b27993ab405beaa19738258fdd546d3db/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=7c4be43b27993ab405beaa19738258fdd546d3db", "patch": "@@ -538,6 +538,7 @@ pub enum PrintRequest {\n     TlsModels,\n     TargetSpec,\n     NativeStaticLibs,\n+    StackProtectorStrategies,\n }\n \n #[derive(Copy, Clone)]\n@@ -1110,8 +1111,8 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n             \"print\",\n             \"Compiler information to print on stdout\",\n             \"[crate-name|file-names|sysroot|target-libdir|cfg|target-list|\\\n-             target-cpus|target-features|relocation-models|\\\n-             code-models|tls-models|target-spec-json|native-static-libs]\",\n+             target-cpus|target-features|relocation-models|code-models|\\\n+             tls-models|target-spec-json|native-static-libs|stack-protector-strategies]\",\n         ),\n         opt::flagmulti_s(\"g\", \"\", \"Equivalent to -C debuginfo=2\"),\n         opt::flagmulti_s(\"O\", \"\", \"Equivalent to -C opt-level=2\"),\n@@ -1527,6 +1528,7 @@ fn collect_print_requests(\n         \"code-models\" => PrintRequest::CodeModels,\n         \"tls-models\" => PrintRequest::TlsModels,\n         \"native-static-libs\" => PrintRequest::NativeStaticLibs,\n+        \"stack-protector-strategies\" => PrintRequest::StackProtectorStrategies,\n         \"target-spec-json\" => {\n             if dopts.unstable_options {\n                 PrintRequest::TargetSpec\n@@ -2494,7 +2496,9 @@ crate mod dep_tracking {\n     use rustc_span::edition::Edition;\n     use rustc_span::RealFileName;\n     use rustc_target::spec::{CodeModel, MergeFunctions, PanicStrategy, RelocModel};\n-    use rustc_target::spec::{RelroLevel, SanitizerSet, SplitDebuginfo, TargetTriple, TlsModel};\n+    use rustc_target::spec::{\n+        RelroLevel, SanitizerSet, SplitDebuginfo, StackProtector, TargetTriple, TlsModel,\n+    };\n     use std::collections::hash_map::DefaultHasher;\n     use std::collections::BTreeMap;\n     use std::hash::Hash;\n@@ -2568,6 +2572,7 @@ crate mod dep_tracking {\n         Edition,\n         LinkerPluginLto,\n         SplitDebuginfo,\n+        StackProtector,\n         SwitchWithOptPath,\n         SymbolManglingVersion,\n         SourceFileHashAlgorithm,"}, {"sha": "a84e16b9dc31ad1f1ca967866eae9ca11a239d36", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7c4be43b27993ab405beaa19738258fdd546d3db/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4be43b27993ab405beaa19738258fdd546d3db/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=7c4be43b27993ab405beaa19738258fdd546d3db", "patch": "@@ -5,7 +5,9 @@ use crate::lint;\n use crate::search_paths::SearchPath;\n use crate::utils::NativeLib;\n use rustc_target::spec::{CodeModel, LinkerFlavor, MergeFunctions, PanicStrategy, SanitizerSet};\n-use rustc_target::spec::{RelocModel, RelroLevel, SplitDebuginfo, TargetTriple, TlsModel};\n+use rustc_target::spec::{\n+    RelocModel, RelroLevel, SplitDebuginfo, StackProtector, TargetTriple, TlsModel,\n+};\n \n use rustc_feature::UnstableFeatures;\n use rustc_span::edition::Edition;\n@@ -385,6 +387,8 @@ mod desc {\n     pub const parse_split_debuginfo: &str =\n         \"one of supported split-debuginfo modes (`off`, `packed`, or `unpacked`)\";\n     pub const parse_gcc_ld: &str = \"one of: no value, `lld`\";\n+    pub const parse_stack_protector: &str =\n+        \"one of (`none` (default), `basic`, `strong`, or `all`)\";\n }\n \n mod parse {\n@@ -917,6 +921,14 @@ mod parse {\n         }\n         true\n     }\n+\n+    crate fn parse_stack_protector(slot: &mut StackProtector, v: Option<&str>) -> bool {\n+        match v.and_then(|s| StackProtector::from_str(s).ok()) {\n+            Some(ssp) => *slot = ssp,\n+            _ => return false,\n+        }\n+        true\n+    }\n }\n \n options! {\n@@ -1330,6 +1342,8 @@ options! {\n         \"exclude spans when debug-printing compiler state (default: no)\"),\n     src_hash_algorithm: Option<SourceFileHashAlgorithm> = (None, parse_src_file_hash, [TRACKED],\n         \"hash algorithm of source files in debug info (`md5`, `sha1`, or `sha256`)\"),\n+    stack_protector: StackProtector = (StackProtector::None, parse_stack_protector, [TRACKED],\n+        \"control stack smash protection strategy (`rustc --print stack-protector-strategies` for details)\"),\n     strip: Strip = (Strip::None, parse_strip, [UNTRACKED],\n         \"tell the linker which information to strip (`none` (default), `debuginfo` or `symbols`)\"),\n     split_dwarf_inlining: bool = (true, parse_bool, [UNTRACKED],"}, {"sha": "69494e6d9b36a491620c6eda245eb90c0ea44e36", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7c4be43b27993ab405beaa19738258fdd546d3db/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4be43b27993ab405beaa19738258fdd546d3db/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=7c4be43b27993ab405beaa19738258fdd546d3db", "patch": "@@ -27,7 +27,9 @@ use rustc_span::source_map::{FileLoader, MultiSpan, RealFileLoader, SourceMap, S\n use rustc_span::{sym, SourceFileHashAlgorithm, Symbol};\n use rustc_target::asm::InlineAsmArch;\n use rustc_target::spec::{CodeModel, PanicStrategy, RelocModel, RelroLevel};\n-use rustc_target::spec::{SanitizerSet, SplitDebuginfo, Target, TargetTriple, TlsModel};\n+use rustc_target::spec::{\n+    SanitizerSet, SplitDebuginfo, StackProtector, Target, TargetTriple, TlsModel,\n+};\n \n use std::cell::{self, RefCell};\n use std::env;\n@@ -732,6 +734,14 @@ impl Session {\n         self.opts.cg.split_debuginfo.unwrap_or(self.target.split_debuginfo)\n     }\n \n+    pub fn stack_protector(&self) -> StackProtector {\n+        if self.target.options.supports_stack_protector {\n+            self.opts.debugging_opts.stack_protector\n+        } else {\n+            StackProtector::None\n+        }\n+    }\n+\n     pub fn target_can_use_split_dwarf(&self) -> bool {\n         !self.target.is_like_windows && !self.target.is_like_osx\n     }\n@@ -1411,6 +1421,15 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n             sess.err(\"`-Zsanitizer=cfi` requires `-Clto`\");\n         }\n     }\n+\n+    if sess.opts.debugging_opts.stack_protector != StackProtector::None {\n+        if !sess.target.options.supports_stack_protector {\n+            sess.warn(&format!(\n+                \"`-Z stack-protector={}` is not supported for target {} and will be ignored\",\n+                sess.opts.debugging_opts.stack_protector, sess.opts.target_triple\n+            ))\n+        }\n+    }\n }\n \n /// Holds data on the current incremental compilation session, if there is one."}, {"sha": "0d49c7f6ee8b96417f9cec71d98744a79c6a5a3d", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/7c4be43b27993ab405beaa19738258fdd546d3db/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4be43b27993ab405beaa19738258fdd546d3db/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=7c4be43b27993ab405beaa19738258fdd546d3db", "patch": "@@ -712,6 +712,59 @@ impl ToJson for FramePointer {\n     }\n }\n \n+/// Controls use of stack canaries.\n+#[derive(Clone, Copy, Debug, PartialEq, Hash, Eq)]\n+pub enum StackProtector {\n+    /// Disable stack canary generation.\n+    None,\n+\n+    /// On LLVM, mark all generated LLVM functions with the `ssp` attribute (see\n+    /// llvm/docs/LangRef.rst). This triggers stack canary generation in\n+    /// functions which contain an array of a byte-sized type with more than\n+    /// eight elements.\n+    Basic,\n+\n+    /// On LLVM, mark all generated LLVM functions with the `sspstrong`\n+    /// attribute (see llvm/docs/LangRef.rst). This triggers stack canary\n+    /// generation in functions which either contain an array, or which take\n+    /// the address of a local variable.\n+    Strong,\n+\n+    /// Generate stack canaries in all functions.\n+    All,\n+}\n+\n+impl StackProtector {\n+    fn as_str(&self) -> &'static str {\n+        match self {\n+            StackProtector::None => \"none\",\n+            StackProtector::Basic => \"basic\",\n+            StackProtector::Strong => \"strong\",\n+            StackProtector::All => \"all\",\n+        }\n+    }\n+}\n+\n+impl FromStr for StackProtector {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<StackProtector, ()> {\n+        Ok(match s {\n+            \"none\" => StackProtector::None,\n+            \"basic\" => StackProtector::Basic,\n+            \"strong\" => StackProtector::Strong,\n+            \"all\" => StackProtector::All,\n+            _ => return Err(()),\n+        })\n+    }\n+}\n+\n+impl fmt::Display for StackProtector {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(self.as_str())\n+    }\n+}\n+\n macro_rules! supported_targets {\n     ( $(($( $triple:literal, )+ $module:ident ),)+ ) => {\n         $(mod $module;)+\n@@ -1360,6 +1413,10 @@ pub struct TargetOptions {\n \n     /// Whether or not the DWARF `.debug_aranges` section should be generated.\n     pub generate_arange_section: bool,\n+\n+    /// Whether the target supports stack canary checks. `true` by default,\n+    /// since this is most common among tier 1 and tier 2 targets.\n+    pub supports_stack_protector: bool,\n }\n \n impl Default for TargetOptions {\n@@ -1466,6 +1523,7 @@ impl Default for TargetOptions {\n             default_adjusted_cabi: None,\n             c_enum_min_bits: 32,\n             generate_arange_section: true,\n+            supports_stack_protector: true,\n         }\n     }\n }\n@@ -2052,6 +2110,7 @@ impl Target {\n         key!(default_adjusted_cabi, Option<Abi>)?;\n         key!(c_enum_min_bits, u64);\n         key!(generate_arange_section, bool);\n+        key!(supports_stack_protector, bool);\n \n         if base.is_builtin {\n             // This can cause unfortunate ICEs later down the line.\n@@ -2292,6 +2351,7 @@ impl ToJson for Target {\n         target_option_val!(supported_sanitizers);\n         target_option_val!(c_enum_min_bits);\n         target_option_val!(generate_arange_section);\n+        target_option_val!(supports_stack_protector);\n \n         if let Some(abi) = self.default_adjusted_cabi {\n             d.insert(\"default-adjusted-cabi\".to_string(), Abi::name(abi).to_json());"}, {"sha": "ba32a312910d89ba38daed726c57d89d5f449680", "filename": "compiler/rustc_target/src/spec/nvptx64_nvidia_cuda.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4be43b27993ab405beaa19738258fdd546d3db/compiler%2Frustc_target%2Fsrc%2Fspec%2Fnvptx64_nvidia_cuda.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4be43b27993ab405beaa19738258fdd546d3db/compiler%2Frustc_target%2Fsrc%2Fspec%2Fnvptx64_nvidia_cuda.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fnvptx64_nvidia_cuda.rs?ref=7c4be43b27993ab405beaa19738258fdd546d3db", "patch": "@@ -44,6 +44,10 @@ pub fn target() -> Target {\n             // produce kernel functions that call other kernel functions.\n             // This behavior is not supported by PTX ISA.\n             merge_functions: MergeFunctions::Disabled,\n+\n+            // The LLVM backend does not support stack canaries for this target\n+            supports_stack_protector: false,\n+\n             ..Default::default()\n         },\n     }"}, {"sha": "530326ab7438afe3640490daa33a63efd2fe818c", "filename": "src/test/assembly/stack-protector/stack-protector-heuristics-effect.rs", "status": "added", "additions": 396, "deletions": 0, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/7c4be43b27993ab405beaa19738258fdd546d3db/src%2Ftest%2Fassembly%2Fstack-protector%2Fstack-protector-heuristics-effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4be43b27993ab405beaa19738258fdd546d3db/src%2Ftest%2Fassembly%2Fstack-protector%2Fstack-protector-heuristics-effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fstack-protector%2Fstack-protector-heuristics-effect.rs?ref=7c4be43b27993ab405beaa19738258fdd546d3db", "patch": "@@ -0,0 +1,396 @@\n+// revisions: all strong basic none missing\n+// assembly-output: emit-asm\n+// ignore-macos slightly different policy on stack protection of arrays\n+// ignore-windows stack check code uses different function names\n+// ignore-nvptx64 stack protector is not supported\n+// [all] compile-flags: -Z stack-protector=all\n+// [strong] compile-flags: -Z stack-protector=strong\n+// [basic] compile-flags: -Z stack-protector=basic\n+// [none] compile-flags: -Z stack-protector=none\n+// compile-flags: -C opt-level=2 -Z merge-functions=disabled\n+\n+#![crate_type = \"lib\"]\n+\n+#![allow(incomplete_features)]\n+\n+#![feature(unsized_locals, unsized_fn_params)]\n+\n+\n+// CHECK-LABEL: emptyfn:\n+#[no_mangle]\n+pub fn emptyfn() {\n+    // all: __stack_chk_fail\n+    // strong-NOT: __stack_chk_fail\n+    // basic-NOT: __stack_chk_fail\n+    // none-NOT: __stack_chk_fail\n+    // missing-NOT: __stack_chk_fail\n+}\n+\n+// CHECK-LABEL: array_char\n+#[no_mangle]\n+pub fn array_char(f: fn(*const char)) {\n+    let a = ['c'; 1];\n+    let b = ['d'; 3];\n+    let c = ['e'; 15];\n+\n+    f(&a as *const _);\n+    f(&b as *const _);\n+    f(&c as *const _);\n+\n+    // Any type of local array variable leads to stack protection with the\n+    // \"strong\" heuristic. The 'basic' heuristic only adds stack protection to\n+    // functions with local array variables of a byte-sized type, however. Since\n+    // 'char' is 4 bytes in Rust, this function is not protected by the 'basic'\n+    // heuristic\n+    //\n+    // (This test *also* takes the address of the local stack variables. We\n+    // cannot know that this isn't what triggers the `strong` heuristic.\n+    // However, the test strategy of passing the address of a stack array to an\n+    // external function is sufficient to trigger the `basic` heuristic (see\n+    // test `array_u8_large()`). Since the `basic` heuristic only checks for the\n+    // presence of stack-local array variables, we can be confident that this\n+    // test also captures this part of the `strong` heuristic specification.)\n+\n+    // all: __stack_chk_fail\n+    // strong: __stack_chk_fail\n+    // basic-NOT: __stack_chk_fail\n+    // none-NOT: __stack_chk_fail\n+    // missing-NOT: __stack_chk_fail\n+}\n+\n+// CHECK-LABEL: array_u8_1\n+#[no_mangle]\n+pub fn array_u8_1(f: fn(*const u8)) {\n+    let a = [0u8; 1];\n+    f(&a as *const _);\n+\n+    // The 'strong' heuristic adds stack protection to functions with local\n+    // array variables regardless of their size.\n+\n+    // all: __stack_chk_fail\n+    // strong: __stack_chk_fail\n+    // basic-NOT: __stack_chk_fail\n+    // none-NOT: __stack_chk_fail\n+    // missing-NOT: __stack_chk_fail\n+}\n+\n+// CHECK-LABEL: array_u8_small:\n+#[no_mangle]\n+pub fn array_u8_small(f: fn(*const u8)) {\n+    let a = [0u8; 2];\n+    let b = [0u8; 8];\n+    f(&a as *const _);\n+    f(&b as *const _);\n+\n+    // Small arrays do not lead to stack protection by the 'basic' heuristic.\n+\n+    // all: __stack_chk_fail\n+    // strong: __stack_chk_fail\n+    // basic-NOT: __stack_chk_fail\n+    // none-NOT: __stack_chk_fail\n+    // missing-NOT: __stack_chk_fail\n+}\n+\n+// CHECK-LABEL: array_u8_large:\n+#[no_mangle]\n+pub fn array_u8_large(f: fn(*const u8)) {\n+    let a = [0u8; 9];\n+    f(&a as *const _);\n+\n+    // Since `a` is a byte array with size greater than 8, the basic heuristic\n+    // will also protect this function.\n+\n+    // all: __stack_chk_fail\n+    // strong: __stack_chk_fail\n+    // basic: __stack_chk_fail\n+    // none-NOT: __stack_chk_fail\n+    // missing-NOT: __stack_chk_fail\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct ByteSizedNewtype(u8);\n+\n+// CHECK-LABEL: array_bytesizednewtype_9:\n+#[no_mangle]\n+pub fn array_bytesizednewtype_9(f: fn(*const ByteSizedNewtype)) {\n+    let a = [ByteSizedNewtype(0); 9];\n+    f(&a as *const _);\n+\n+    // Since `a` is a byte array in the LLVM output, the basic heuristic will\n+    // also protect this function.\n+\n+    // all: __stack_chk_fail\n+    // strong: __stack_chk_fail\n+    // basic: __stack_chk_fail\n+    // none-NOT: __stack_chk_fail\n+    // missing-NOT: __stack_chk_fail\n+}\n+\n+// CHECK-LABEL: local_var_addr_used_indirectly\n+#[no_mangle]\n+pub fn local_var_addr_used_indirectly(f: fn(bool)) {\n+    let a = 5;\n+    let a_addr = &a as *const _ as usize;\n+    f(a_addr & 0x10 == 0);\n+\n+    // This function takes the address of a local variable taken. Although this\n+    // address is never used as a way to refer to stack memory, the `strong`\n+    // heuristic adds stack smash protection. This is also the case in C++:\n+    // ```\n+    // cat << EOF | clang++ -O2 -fstack-protector-strong -S -x c++ - -o - | grep stack_chk\n+    // #include <cstdint>\n+    // void f(void (*g)(bool)) {\n+    //     int32_t x;\n+    //     g((reinterpret_cast<uintptr_t>(&x) & 0x10U) == 0);\n+    // }\n+    // EOF\n+    // ```\n+\n+    // all: __stack_chk_fail\n+    // strong: __stack_chk_fail\n+    // basic-NOT: __stack_chk_fail\n+    // none-NOT: __stack_chk_fail\n+    // missing-NOT: __stack_chk_fail\n+}\n+\n+\n+// CHECK-LABEL: local_string_addr_taken\n+#[no_mangle]\n+pub fn local_string_addr_taken(f: fn(&String)) {\n+    let x = String::new();\n+    f(&x);\n+\n+    // Taking the address of the local variable `x` leads to stack smash\n+    // protection with the `strong` heuristic, but not with the `basic`\n+    // heuristic. It does not matter that the reference is not mut.\n+    //\n+    // An interesting note is that a similar function in C++ *would* be\n+    // protected by the `basic` heuristic, because `std::string` has a char\n+    // array internally as a small object optimization:\n+    // ```\n+    // cat <<EOF | clang++ -O2 -fstack-protector -S -x c++ - -o - | grep stack_chk\n+    // #include <string>\n+    // void f(void (*g)(const std::string&)) {\n+    //     std::string x;\n+    //     g(x);\n+    // }\n+    // EOF\n+    // ```\n+    //\n+\n+    // all: __stack_chk_fail\n+    // strong: __stack_chk_fail\n+    // basic-NOT: __stack_chk_fail\n+    // none-NOT: __stack_chk_fail\n+    // missing-NOT: __stack_chk_fail\n+}\n+\n+pub trait SelfByRef {\n+    fn f(&self) -> i32;\n+}\n+\n+impl SelfByRef for i32 {\n+    fn f(&self) -> i32 {\n+        return self + 1;\n+    }\n+}\n+\n+// CHECK-LABEL: local_var_addr_taken_used_locally_only\n+#[no_mangle]\n+pub fn local_var_addr_taken_used_locally_only(factory: fn() -> i32, sink: fn(i32)) {\n+    let x = factory();\n+    let g = x.f();\n+    sink(g);\n+\n+    // Even though the local variable conceptually has its address taken, as\n+    // it's passed by reference to the trait function, the use of the reference\n+    // is easily inlined. There is therefore no stack smash protection even with\n+    // the `strong` heuristic.\n+\n+    // all: __stack_chk_fail\n+    // strong-NOT: __stack_chk_fail\n+    // basic-NOT: __stack_chk_fail\n+    // none-NOT: __stack_chk_fail\n+    // missing-NOT: __stack_chk_fail\n+}\n+\n+pub struct Gigastruct {\n+    does: u64,\n+    not: u64,\n+    have: u64,\n+    array: u64,\n+    members: u64\n+}\n+\n+// CHECK-LABEL: local_large_var_moved\n+#[no_mangle]\n+pub fn local_large_var_moved(f: fn(Gigastruct)) {\n+    let x = Gigastruct { does: 0, not: 1, have: 2, array: 3, members: 4 };\n+    f(x);\n+\n+    // Even though the local variable conceptually doesn't have its address\n+    // taken, it's so large that the \"move\" is implemented with a reference to a\n+    // stack-local variable in the ABI. Consequently, this function *is*\n+    // protected by the `strong` heuristic. This is also the case for\n+    // rvalue-references in C++, regardless of struct size:\n+    // ```\n+    // cat <<EOF | clang++ -O2 -fstack-protector-strong -S -x c++ - -o - | grep stack_chk\n+    // #include <cstdint>\n+    // #include <utility>\n+    // void f(void (*g)(uint64_t&&)) {\n+    //     uint64_t x;\n+    //     g(std::move(x));\n+    // }\n+    // EOF\n+    // ```\n+\n+    // all: __stack_chk_fail\n+    // strong: __stack_chk_fail\n+    // basic-NOT: __stack_chk_fail\n+    // none-NOT: __stack_chk_fail\n+    // missing-NOT: __stack_chk_fail\n+}\n+\n+// CHECK-LABEL: local_large_var_cloned\n+#[no_mangle]\n+pub fn local_large_var_cloned(f: fn(Gigastruct)) {\n+    f(Gigastruct { does: 0, not: 1, have: 2, array: 3, members: 4 });\n+\n+    // A new instance of `Gigastruct` is passed to `f()`, without any apparent\n+    // connection to this stack frame. Still, since instances of `Gigastruct`\n+    // are sufficiently large, it is allocated in the caller stack frame and\n+    // passed as a pointer. As such, this function is *also* protected by the\n+    // `strong` heuristic, just like `local_large_var_moved`. This is also the\n+    // case for pass-by-value of sufficiently large structs in C++:\n+    // ```\n+    // cat <<EOF | clang++ -O2 -fstack-protector-strong -S -x c++ - -o - | grep stack_chk\n+    // #include <cstdint>\n+    // #include <utility>\n+    // struct Gigastruct { uint64_t a, b, c, d, e; };\n+    // void f(void (*g)(Gigastruct)) {\n+    //     g(Gigastruct{});\n+    // }\n+    // EOF\n+    // ```\n+\n+\n+    // all: __stack_chk_fail\n+    // strong: __stack_chk_fail\n+    // basic-NOT: __stack_chk_fail\n+    // none-NOT: __stack_chk_fail\n+    // missing-NOT: __stack_chk_fail\n+}\n+\n+\n+extern \"C\" {\n+    // A call to an external `alloca` function is *not* recognized as an\n+    // `alloca(3)` operation. This function is a compiler built-in, as the\n+    // man page explains. Clang translates it to an LLVM `alloca`\n+    // instruction with a count argument, which is also what the LLVM stack\n+    // protector heuristics looks for. The man page for `alloca(3)` details\n+    // a way to avoid using the compiler built-in: pass a -std=c11\n+    // argument, *and* don't include <alloca.h>. Though this leads to an\n+    // external alloca() function being called, it doesn't lead to stack\n+    // protection being included. It even fails with a linker error\n+    // \"undefined reference to `alloca'\". Example:\n+    // ```\n+    // cat<<EOF | clang -fstack-protector-strong -x c -std=c11 - -o /dev/null\n+    // #include <stdlib.h>\n+    // void * alloca(size_t);\n+    // void f(void (*g)(void*)) {\n+    //     void * p = alloca(10);\n+    //     g(p);\n+    // }\n+    // int main() { return 0; }\n+    // EOF\n+    // ```\n+    // The following tests demonstrate that calls to an external `alloca`\n+    // function in Rust also doesn't trigger stack protection.\n+\n+    fn alloca(size: usize) -> *mut ();\n+}\n+\n+// CHECK-LABEL: alloca_small_compile_time_constant_arg\n+#[no_mangle]\n+pub fn alloca_small_compile_time_constant_arg(f: fn(*mut ())) {\n+    f(unsafe { alloca(8) });\n+\n+    // all: __stack_chk_fail\n+    // strong-NOT: __stack_chk_fail\n+    // basic-NOT: __stack_chk_fail\n+    // none-NOT: __stack_chk_fail\n+    // missing-NOT: __stack_chk_fail\n+}\n+\n+// CHECK-LABEL: alloca_large_compile_time_constant_arg\n+#[no_mangle]\n+pub fn alloca_large_compile_time_constant_arg(f: fn(*mut ())) {\n+    f(unsafe { alloca(9) });\n+\n+    // all: __stack_chk_fail\n+    // strong-NOT: __stack_chk_fail\n+    // basic-NOT: __stack_chk_fail\n+    // none-NOT: __stack_chk_fail\n+    // missing-NOT: __stack_chk_fail\n+}\n+\n+\n+// CHECK-LABEL: alloca_dynamic_arg\n+#[no_mangle]\n+pub fn alloca_dynamic_arg(f: fn(*mut ()), n: usize) {\n+    f(unsafe { alloca(n) });\n+\n+    // all: __stack_chk_fail\n+    // strong-NOT: __stack_chk_fail\n+    // basic-NOT: __stack_chk_fail\n+    // none-NOT: __stack_chk_fail\n+    // missing-NOT: __stack_chk_fail\n+}\n+\n+// The question then is: in what ways can Rust code generate array-`alloca`\n+// LLVM instructions? This appears to only be generated by\n+// rustc_codegen_ssa::traits::Builder::array_alloca() through\n+// rustc_codegen_ssa::mir::operand::OperandValue::store_unsized(). FWICT\n+// this is support for the \"unsized locals\" unstable feature:\n+// https://doc.rust-lang.org/unstable-book/language-features/unsized-locals.html.\n+\n+\n+// CHECK-LABEL: unsized_fn_param\n+#[no_mangle]\n+pub fn unsized_fn_param(s: [u8], l: bool, f: fn([u8])) {\n+    let n = if l { 1 } else { 2 };\n+    f(*Box::<[u8]>::from(&s[0..n])); // slice-copy with Box::from\n+\n+    // Even though slices are conceptually passed by-value both into this\n+    // function and into `f()`, this is implemented with pass-by-reference\n+    // using a suitably constructed fat-pointer (as if the functions\n+    // accepted &[u8]). This function therefore doesn't need dynamic array\n+    // alloca, and is therefore not protected by the `strong` or `basic`\n+    // heuristics.\n+\n+\n+    // all: __stack_chk_fail\n+    // strong-NOT: __stack_chk_fail\n+    // basic-NOT: __stack_chk_fail\n+    // none-NOT: __stack_chk_fail\n+    // missing-NOT: __stack_chk_fail\n+}\n+\n+// CHECK-LABEL: unsized_local\n+#[no_mangle]\n+pub fn unsized_local(s: &[u8], l: bool, f: fn(&mut [u8])) {\n+    let n = if l { 1 } else { 2 };\n+    let mut a: [u8] = *Box::<[u8]>::from(&s[0..n]); // slice-copy with Box::from\n+    f(&mut a);\n+\n+    // This function allocates a slice as a local variable in its stack\n+    // frame. Since the size is not a compile-time constant, an array\n+    // alloca is required, and the function is protected by both the\n+    // `strong` and `basic` heuristic.\n+\n+    // all: __stack_chk_fail\n+    // strong: __stack_chk_fail\n+    // basic: __stack_chk_fail\n+    // none-NOT: __stack_chk_fail\n+    // missing-NOT: __stack_chk_fail\n+}"}, {"sha": "5ba46d082e157975ea6ab810b18359742b5055f2", "filename": "src/test/assembly/stack-protector/stack-protector-target-support.rs", "status": "added", "additions": 286, "deletions": 0, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/7c4be43b27993ab405beaa19738258fdd546d3db/src%2Ftest%2Fassembly%2Fstack-protector%2Fstack-protector-target-support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4be43b27993ab405beaa19738258fdd546d3db/src%2Ftest%2Fassembly%2Fstack-protector%2Fstack-protector-target-support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fstack-protector%2Fstack-protector-target-support.rs?ref=7c4be43b27993ab405beaa19738258fdd546d3db", "patch": "@@ -0,0 +1,286 @@\n+// Test that stack smash protection code is emitted for all tier1 and tier2\n+// targets, with the exception of nvptx64-nvidia-cuda\n+//\n+// revisions: r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 r16 r17 r18 r19 r20 r21 r22 r23\n+// revisions: r24 r25 r26 r27 r28 r29 r30 r31 r32 r33 r34 r35 r36 r37 r38 r39 r40 r41 r42 r43 r44\n+// revisions: r45 r46 r47 r48 r49 r50 r51 r52 r53 r54 r55 r56 r57 r58 r59 r60 r61 r62 r63 r64 r65\n+// revisions: r66 r67 r68 r69 r70 r71 r72 r73 r74 r75 r76 r77 r78 r79 r80 r81 r82 r83 r84\n+// assembly-output: emit-asm\n+// [r1] compile-flags: --target aarch64-unknown-linux-gnu\n+// [r1] needs-llvm-components: aarch64\n+// [r2] compile-flags: --target i686-pc-windows-gnu\n+// [r2] needs-llvm-components: x86\n+// [r3] compile-flags: --target i686-pc-windows-msvc\n+// [r3] needs-llvm-components: x86\n+// [r4] compile-flags: --target i686-unknown-linux-gnu\n+// [r4] needs-llvm-components: x86\n+// [r5] compile-flags: --target x86_64-apple-darwin\n+// [r5] needs-llvm-components: x86\n+// [r6] compile-flags: --target x86_64-pc-windows-gnu\n+// [r6] needs-llvm-components: x86\n+// [r7] compile-flags: --target x86_64-pc-windows-msvc\n+// [r7] needs-llvm-components: x86\n+// [r8] compile-flags: --target x86_64-unknown-linux-gnu\n+// [r8] needs-llvm-components: x86\n+// [r9] compile-flags: --target aarch64-apple-darwin\n+// [r9] needs-llvm-components: aarch64\n+// [r10] compile-flags: --target aarch64-apple-ios\n+// [r10] needs-llvm-components: aarch64\n+// [r11] compile-flags: --target aarch64-fuchsia\n+// [r11] needs-llvm-components: aarch64\n+// [r12] compile-flags: --target aarch64-linux-android\n+// [r12] needs-llvm-components: aarch64\n+// [r13] compile-flags: --target aarch64-pc-windows-msvc\n+// [r13] needs-llvm-components: aarch64\n+// [r14] compile-flags: --target aarch64-unknown-linux-musl\n+// [r14] needs-llvm-components: aarch64\n+// [r15] compile-flags: --target aarch64-unknown-none\n+// [r15] needs-llvm-components: aarch64\n+// [r16] compile-flags: --target aarch64-unknown-none-softfloat\n+// [r16] needs-llvm-components: aarch64\n+// [r17] compile-flags: --target arm-linux-androideabi\n+// [r17] needs-llvm-components: arm\n+// [r18] compile-flags: --target arm-unknown-linux-gnueabi\n+// [r18] needs-llvm-components: arm\n+// [r19] compile-flags: --target arm-unknown-linux-gnueabihf\n+// [r19] needs-llvm-components: arm\n+// [r20] compile-flags: --target arm-unknown-linux-musleabi\n+// [r20] needs-llvm-components: arm\n+// [r21] compile-flags: --target arm-unknown-linux-musleabihf\n+// [r21] needs-llvm-components: arm\n+// [r22] compile-flags: --target armebv7r-none-eabi\n+// [r22] needs-llvm-components: arm\n+// [r23] compile-flags: --target armebv7r-none-eabihf\n+// [r23] needs-llvm-components: arm\n+// [r24] compile-flags: --target armv5te-unknown-linux-gnueabi\n+// [r24] needs-llvm-components: arm\n+// [r25] compile-flags: --target armv5te-unknown-linux-musleabi\n+// [r25] needs-llvm-components: arm\n+// [r26] compile-flags: --target armv7-linux-androideabi\n+// [r26] needs-llvm-components: arm\n+// [r27] compile-flags: --target armv7a-none-eabi\n+// [r27] needs-llvm-components: arm\n+// [r28] compile-flags: --target armv7r-none-eabi\n+// [r28] needs-llvm-components: arm\n+// [r29] compile-flags: --target armv7r-none-eabihf\n+// [r29] needs-llvm-components: arm\n+// [r30] compile-flags: --target armv7-unknown-linux-gnueabi\n+// [r30] needs-llvm-components: arm\n+// [r31] compile-flags: --target armv7-unknown-linux-gnueabihf\n+// [r31] needs-llvm-components: arm\n+// [r32] compile-flags: --target armv7-unknown-linux-musleabi\n+// [r32] needs-llvm-components: arm\n+// [r33] compile-flags: --target armv7-unknown-linux-musleabihf\n+// [r33] needs-llvm-components: arm\n+// [r34] compile-flags: --target asmjs-unknown-emscripten\n+// [r34] needs-llvm-components: webassembly\n+// [r35] compile-flags: --target i586-pc-windows-msvc\n+// [r35] needs-llvm-components: x86\n+// [r36] compile-flags: --target i586-unknown-linux-gnu\n+// [r36] needs-llvm-components: x86\n+// [r37] compile-flags: --target i586-unknown-linux-musl\n+// [r37] needs-llvm-components: x86\n+// [r38] compile-flags: --target i686-linux-android\n+// [r38] needs-llvm-components: x86\n+// [r39] compile-flags: --target i686-unknown-freebsd\n+// [r39] needs-llvm-components: x86\n+// [r40] compile-flags: --target i686-unknown-linux-musl\n+// [r40] needs-llvm-components: x86\n+// [r41] compile-flags: --target mips-unknown-linux-gnu\n+// [r41] needs-llvm-components: mips\n+// [r42] compile-flags: --target mips-unknown-linux-musl\n+// [r42] needs-llvm-components: mips\n+// [r43] compile-flags: --target mips64-unknown-linux-gnuabi64\n+// [r43] needs-llvm-components: mips\n+// [r44] compile-flags: --target mips64-unknown-linux-muslabi64\n+// [r44] needs-llvm-components: mips\n+// [r45] compile-flags: --target mips64el-unknown-linux-gnuabi64\n+// [r45] needs-llvm-components: mips\n+// [r46] compile-flags: --target mips64el-unknown-linux-muslabi64\n+// [r46] needs-llvm-components: mips\n+// [r47] compile-flags: --target mipsel-unknown-linux-gnu\n+// [r47] needs-llvm-components: mips\n+// [r48] compile-flags: --target mipsel-unknown-linux-musl\n+// [r48] needs-llvm-components: mips\n+// [r49] compile-flags: --target nvptx64-nvidia-cuda\n+// [r49] needs-llvm-components: nvptx\n+// [r50] compile-flags: --target powerpc-unknown-linux-gnu\n+// [r50] needs-llvm-components: powerpc\n+// [r51] compile-flags: --target powerpc64-unknown-linux-gnu\n+// [r51] needs-llvm-components: powerpc\n+// [r52] compile-flags: --target powerpc64le-unknown-linux-gnu\n+// [r52] needs-llvm-components: powerpc\n+// [r53] compile-flags: --target riscv32i-unknown-none-elf\n+// [r53] needs-llvm-components: riscv\n+// [r54] compile-flags: --target riscv32imac-unknown-none-elf\n+// [r54] needs-llvm-components: riscv\n+// [r55] compile-flags:--target riscv32imc-unknown-none-elf\n+// [r55] needs-llvm-components: riscv\n+// [r56] compile-flags:--target riscv64gc-unknown-linux-gnu\n+// [r56] needs-llvm-components: riscv\n+// [r57] compile-flags:--target riscv64gc-unknown-none-elf\n+// [r57] needs-llvm-components: riscv\n+// [r58] compile-flags:--target riscv64imac-unknown-none-elf\n+// [r58] needs-llvm-components: riscv\n+// [r59] compile-flags:--target s390x-unknown-linux-gnu\n+// [r59] needs-llvm-components: systemz\n+// [r60] compile-flags:--target sparc64-unknown-linux-gnu\n+// [r60] needs-llvm-components: sparc\n+// [r61] compile-flags:--target sparcv9-sun-solaris\n+// [r61] needs-llvm-components: sparc\n+// [r62] compile-flags:--target thumbv6m-none-eabi\n+// [r62] needs-llvm-components: arm\n+// [r63] compile-flags:--target thumbv7em-none-eabi\n+// [r63] needs-llvm-components: arm\n+// [r64] compile-flags:--target thumbv7em-none-eabihf\n+// [r64] needs-llvm-components: arm\n+// [r65] compile-flags:--target thumbv7m-none-eabi\n+// [r65] needs-llvm-components: arm\n+// [r66] compile-flags:--target thumbv7neon-linux-androideabi\n+// [r66] needs-llvm-components: arm\n+// [r67] compile-flags:--target thumbv7neon-unknown-linux-gnueabihf\n+// [r67] needs-llvm-components: arm\n+// [r68] compile-flags:--target thumbv8m.base-none-eabi\n+// [r68] needs-llvm-components: arm\n+// [r69] compile-flags:--target thumbv8m.main-none-eabi\n+// [r69] needs-llvm-components: arm\n+// [r70] compile-flags:--target thumbv8m.main-none-eabihf\n+// [r70] needs-llvm-components: arm\n+// [r71] compile-flags:--target wasm32-unknown-emscripten\n+// [r71] needs-llvm-components: webassembly\n+// [r72] compile-flags:--target wasm32-unknown-unknown\n+// [r72] needs-llvm-components: webassembly\n+// [r73] compile-flags:--target wasm32-wasi\n+// [r73] needs-llvm-components: webassembly\n+// [r74] compile-flags:--target x86_64-apple-ios\n+// [r74] needs-llvm-components: x86\n+// [r75] compile-flags:--target x86_64-fortanix-unknown-sgx\n+// [r75] needs-llvm-components: x86\n+// [r75] min-llvm-version: 11.0.0\n+// [r76] compile-flags:--target x86_64-fuchsia\n+// [r76] needs-llvm-components: x86\n+// [r77] compile-flags:--target x86_64-linux-android\n+// [r77] needs-llvm-components: x86\n+// [r78] compile-flags:--target x86_64-sun-solaris\n+// [r78] needs-llvm-components: x86\n+// [r79] compile-flags:--target x86_64-unknown-freebsd\n+// [r79] needs-llvm-components: x86\n+// [r80] compile-flags:--target x86_64-unknown-illumos\n+// [r80] needs-llvm-components: x86\n+// [r81] compile-flags:--target x86_64-unknown-linux-gnux32\n+// [r81] needs-llvm-components: x86\n+// [r82] compile-flags:--target x86_64-unknown-linux-musl\n+// [r82] needs-llvm-components: x86\n+// [r83] compile-flags:--target x86_64-unknown-netbsd\n+// [r83] needs-llvm-components: x86\n+// [r84] compile-flags: --target x86_64-unknown-redox\n+// [r84] needs-llvm-components: x86\n+// compile-flags: -Z stack-protector=all\n+// compile-flags: -C opt-level=2\n+\n+#![crate_type = \"lib\"]\n+\n+#![feature(no_core, lang_items)]\n+#![crate_type = \"lib\"]\n+#![no_core]\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+#[no_mangle]\n+pub fn foo() {\n+    // CHECK: foo{{:|()}}\n+\n+    // MSVC does the stack checking within a stack-check function:\n+    // r3: calll @__security_check_cookie\n+    // r7: callq __security_check_cookie\n+    // r13: bl __security_check_cookie\n+    // r35: calll @__security_check_cookie\n+\n+    // cuda doesn't support stack-smash protection\n+    // r49-NOT: __security_check_cookie\n+    // r49-NOT: __stack_chk_fail\n+\n+    // Other targets do stack checking within the function, and call a failure function on error\n+    // r1: __stack_chk_fail\n+    // r2: __stack_chk_fail\n+    // r4: __stack_chk_fail\n+    // r5: __stack_chk_fail\n+    // r6: __stack_chk_fail\n+    // r8: __stack_chk_fail\n+    // r9: __stack_chk_fail\n+    // r10: __stack_chk_fail\n+    // r11: __stack_chk_fail\n+    // r12: __stack_chk_fail\n+    // r14: __stack_chk_fail\n+    // r15: __stack_chk_fail\n+    // r16: __stack_chk_fail\n+    // r17: __stack_chk_fail\n+    // r18: __stack_chk_fail\n+    // r19: __stack_chk_fail\n+    // r20: __stack_chk_fail\n+    // r21: __stack_chk_fail\n+    // r22: __stack_chk_fail\n+    // r23: __stack_chk_fail\n+    // r24: __stack_chk_fail\n+    // r25: __stack_chk_fail\n+    // r26: __stack_chk_fail\n+    // r27: __stack_chk_fail\n+    // r28: __stack_chk_fail\n+    // r29: __stack_chk_fail\n+    // r30: __stack_chk_fail\n+    // r31: __stack_chk_fail\n+    // r32: __stack_chk_fail\n+    // r33: __stack_chk_fail\n+    // r34: __stack_chk_fail\n+    // r36: __stack_chk_fail\n+    // r37: __stack_chk_fail\n+    // r38: __stack_chk_fail\n+    // r39: __stack_chk_fail\n+    // r40: __stack_chk_fail\n+    // r41: __stack_chk_fail\n+    // r42: __stack_chk_fail\n+    // r43: __stack_chk_fail\n+    // r44: __stack_chk_fail\n+    // r45: __stack_chk_fail\n+    // r46: __stack_chk_fail\n+    // r47: __stack_chk_fail\n+    // r48: __stack_chk_fail\n+    // r50: __stack_chk_fail\n+    // r51: __stack_chk_fail\n+    // r52: __stack_chk_fail\n+    // r53: __stack_chk_fail\n+    // r54: __stack_chk_fail\n+    // r55: __stack_chk_fail\n+    // r56: __stack_chk_fail\n+    // r57: __stack_chk_fail\n+    // r58: __stack_chk_fail\n+    // r59: __stack_chk_fail\n+    // r60: __stack_chk_fail\n+    // r61: __stack_chk_fail\n+    // r62: __stack_chk_fail\n+    // r63: __stack_chk_fail\n+    // r64: __stack_chk_fail\n+    // r65: __stack_chk_fail\n+    // r66: __stack_chk_fail\n+    // r67: __stack_chk_fail\n+    // r68: __stack_chk_fail\n+    // r69: __stack_chk_fail\n+    // r70: __stack_chk_fail\n+    // r71: __stack_chk_fail\n+    // r72: __stack_chk_fail\n+    // r73: __stack_chk_fail\n+    // r74: __stack_chk_fail\n+    // r75: __stack_chk_fail\n+    // r76: __stack_chk_fail\n+    // r77: __stack_chk_fail\n+    // r78: __stack_chk_fail\n+    // r79: __stack_chk_fail\n+    // r80: __stack_chk_fail\n+    // r81: __stack_chk_fail\n+    // r82: __stack_chk_fail\n+    // r83: __stack_chk_fail\n+    // r84: __stack_chk_fail\n+}"}, {"sha": "a24e6f1e4f19063a5e530aa8643d340b8728eb6f", "filename": "src/test/codegen/stack-protector.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7c4be43b27993ab405beaa19738258fdd546d3db/src%2Ftest%2Fcodegen%2Fstack-protector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4be43b27993ab405beaa19738258fdd546d3db/src%2Ftest%2Fcodegen%2Fstack-protector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fstack-protector.rs?ref=7c4be43b27993ab405beaa19738258fdd546d3db", "patch": "@@ -0,0 +1,34 @@\n+// revisions: all strong basic none\n+// ignore-nvptx64 stack protector not supported\n+// [all] compile-flags: -Z stack-protector=all\n+// [strong] compile-flags: -Z stack-protector=strong\n+// [basic] compile-flags: -Z stack-protector=basic\n+\n+#![crate_type = \"lib\"]\n+\n+#[no_mangle]\n+pub fn foo() {\n+    // CHECK: @foo() unnamed_addr #0\n+\n+    // all-NOT: attributes #0 = { {{.*}} sspstrong {{.*}} }\n+    // all-NOT: attributes #0 = { {{.*}} ssp {{.*}} }\n+    // all: attributes #0 = { {{.*}} sspreq {{.*}} }\n+    // all-NOT: attributes #0 = { {{.*}} sspstrong {{.*}} }\n+    // all-NOT: attributes #0 = { {{.*}} ssp {{.*}} }\n+\n+    // strong-NOT: attributes #0 = { {{.*}} sspreq {{.*}} }\n+    // strong-NOT: attributes #0 = { {{.*}} ssp {{.*}} }\n+    // strong: attributes #0 = { {{.*}} sspstrong {{.*}} }\n+    // strong-NOT: attributes #0 = { {{.*}} sspreq {{.*}} }\n+    // strong-NOT: attributes #0 = { {{.*}} ssp {{.*}} }\n+\n+    // basic-NOT: attributes #0 = { {{.*}} sspreq {{.*}} }\n+    // basic-NOT: attributes #0 = { {{.*}} sspstrong {{.*}} }\n+    // basic: attributes #0 = { {{.*}} ssp {{.*}} }\n+    // basic-NOT: attributes #0 = { {{.*}} sspreq {{.*}} }\n+    // basic-NOT: attributes #0 = { {{.*}} sspstrong {{.*}} }\n+\n+    // none-NOT: attributes #0 = { {{.*}} sspreq {{.*}} }\n+    // none-NOT: attributes #0 = { {{.*}} sspstrong {{.*}} }\n+    // none-NOT: attributes #0 = { {{.*}} ssp {{.*}} }\n+}"}, {"sha": "24bd2e219431395a2edff5ba1a114311a0d83c2b", "filename": "src/test/ui/abi/stack-protector.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/7c4be43b27993ab405beaa19738258fdd546d3db/src%2Ftest%2Fui%2Fabi%2Fstack-protector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4be43b27993ab405beaa19738258fdd546d3db/src%2Ftest%2Fui%2Fabi%2Fstack-protector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fabi%2Fstack-protector.rs?ref=7c4be43b27993ab405beaa19738258fdd546d3db", "patch": "@@ -0,0 +1,99 @@\n+// run-pass\n+// only-x86_64-unknown-linux-gnu\n+// revisions: ssp no-ssp\n+// [ssp] compile-flags: -Z stack-protector=all\n+// compile-flags: -C opt-level=2\n+// compile-flags: -g\n+\n+use std::env;\n+use std::process::{Command, ExitStatus};\n+\n+fn main() {\n+    if env::args().len() == 1 {\n+        // The test is initially run without arguments. Start the process again,\n+        // this time *with* an argument; in this configuration, the test program\n+        // will deliberately smash the stack.\n+        let cur_argv0 = env::current_exe().unwrap();\n+        let mut child = Command::new(&cur_argv0);\n+        child.arg(\"stacksmash\");\n+\n+        if cfg!(ssp) {\n+            assert_stack_smash_prevented(&mut child);\n+        } else {\n+            assert_stack_smashed(&mut child);\n+        }\n+    } else {\n+        vulnerable_function();\n+        // If we return here the test is broken: it should either have called\n+        // malicious_code() which terminates the process, or be caught by the\n+        // stack check which also terminates the process.\n+        panic!(\"TEST BUG: stack smash unsuccessful\");\n+    }\n+}\n+\n+// Avoid inlining to make sure the return address is pushed to stack.\n+#[inline(never)]\n+fn vulnerable_function() {\n+    let mut x = 5usize;\n+    let stackaddr = &mut x as *mut usize;\n+    let bad_code_ptr = malicious_code as usize;\n+    // Overwrite the on-stack return address with the address of `malicious_code()`,\n+    // thereby jumping to that function when returning from `vulnerable_function()`.\n+    unsafe { fill(stackaddr, bad_code_ptr, 20); }\n+}\n+\n+// Use an uninlined function with its own stack frame to make sure that we don't\n+// clobber e.g. the counter or address local variable.\n+#[inline(never)]\n+unsafe fn fill(addr: *mut usize, val: usize, count: usize) {\n+    let mut addr = addr;\n+    for _ in 0..count {\n+        *addr = val;\n+        addr = addr.add(1);\n+    }\n+}\n+\n+// We jump to malicious_code() having wreaked havoc with the previous stack\n+// frame and not setting up a new one. This function is therefore constrained,\n+// e.g. both println!() and std::process::exit() segfaults if called. We\n+// therefore keep the amount of work to a minimum by calling POSIX functions\n+// directly.\n+// The function is un-inlined just to make it possible to set a breakpoint here.\n+#[inline(never)]\n+fn malicious_code() {\n+    let msg = [112u8, 119u8, 110u8, 101u8, 100u8, 33u8, 0u8]; // \"pwned!\\0\" ascii\n+    unsafe {\n+        write(1, &msg as *const u8, msg.len());\n+        _exit(0);\n+    }\n+}\n+extern \"C\" {\n+    fn write(fd: i32, buf: *const u8, count: usize) -> isize;\n+    fn _exit(status: i32) -> !;\n+}\n+\n+\n+fn assert_stack_smash_prevented(cmd: &mut Command) {\n+    let (status, stdout, stderr) = run(cmd);\n+    assert!(!status.success());\n+    assert!(stdout.is_empty());\n+    assert!(stderr.contains(\"stack smashing detected\"));\n+}\n+\n+fn assert_stack_smashed(cmd: &mut Command) {\n+    let (status, stdout, stderr) = run(cmd);\n+    assert!(status.success());\n+    assert!(stdout.contains(\"pwned!\"));\n+    assert!(stderr.is_empty());\n+}\n+\n+\n+fn run(cmd: &mut Command) -> (ExitStatus, String, String) {\n+    let output = cmd.output().unwrap();\n+    let stdout = String::from_utf8_lossy(&output.stdout);\n+    let stderr = String::from_utf8_lossy(&output.stderr);\n+    println!(\"status: {}\", output.status);\n+    println!(\"stdout: {}\", stdout);\n+    println!(\"stderr: {}\", stderr);\n+    (output.status, stdout.to_string(), stderr.to_string())\n+}"}, {"sha": "54887715523c15d913a3b32d37c7b94497b476f1", "filename": "src/test/ui/stack-protector/warn-stack-protector-unsupported.all.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4be43b27993ab405beaa19738258fdd546d3db/src%2Ftest%2Fui%2Fstack-protector%2Fwarn-stack-protector-unsupported.all.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4be43b27993ab405beaa19738258fdd546d3db/src%2Ftest%2Fui%2Fstack-protector%2Fwarn-stack-protector-unsupported.all.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstack-protector%2Fwarn-stack-protector-unsupported.all.stderr?ref=7c4be43b27993ab405beaa19738258fdd546d3db", "patch": "@@ -0,0 +1,4 @@\n+warning: `-Z stack-protector=all` is not supported for target nvptx64-nvidia-cuda and will be ignored\n+\n+warning: 1 warning emitted\n+"}, {"sha": "f7a1ee39fb9af83648d8825339f56d62bee563c6", "filename": "src/test/ui/stack-protector/warn-stack-protector-unsupported.basic.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4be43b27993ab405beaa19738258fdd546d3db/src%2Ftest%2Fui%2Fstack-protector%2Fwarn-stack-protector-unsupported.basic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4be43b27993ab405beaa19738258fdd546d3db/src%2Ftest%2Fui%2Fstack-protector%2Fwarn-stack-protector-unsupported.basic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstack-protector%2Fwarn-stack-protector-unsupported.basic.stderr?ref=7c4be43b27993ab405beaa19738258fdd546d3db", "patch": "@@ -0,0 +1,4 @@\n+warning: `-Z stack-protector=basic` is not supported for target nvptx64-nvidia-cuda and will be ignored\n+\n+warning: 1 warning emitted\n+"}, {"sha": "6df5d3cd5ae1b590f27bdc8bdb2c14652b877d2e", "filename": "src/test/ui/stack-protector/warn-stack-protector-unsupported.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7c4be43b27993ab405beaa19738258fdd546d3db/src%2Ftest%2Fui%2Fstack-protector%2Fwarn-stack-protector-unsupported.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4be43b27993ab405beaa19738258fdd546d3db/src%2Ftest%2Fui%2Fstack-protector%2Fwarn-stack-protector-unsupported.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstack-protector%2Fwarn-stack-protector-unsupported.rs?ref=7c4be43b27993ab405beaa19738258fdd546d3db", "patch": "@@ -0,0 +1,19 @@\n+// build-pass\n+// revisions: all strong basic\n+// compile-flags: --target nvptx64-nvidia-cuda\n+// needs-llvm-components: nvptx\n+// [all] compile-flags: -Z stack-protector=all\n+// [strong] compile-flags: -Z stack-protector=strong\n+// [basic] compile-flags: -Z stack-protector=basic\n+\n+#![crate_type = \"lib\"]\n+#![feature(no_core, lang_items)]\n+#![no_std]\n+#![no_core]\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+pub fn main(){}"}, {"sha": "ccc2f9f2cc5b8aa5fb5d96034e7de8d9080501b9", "filename": "src/test/ui/stack-protector/warn-stack-protector-unsupported.strong.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4be43b27993ab405beaa19738258fdd546d3db/src%2Ftest%2Fui%2Fstack-protector%2Fwarn-stack-protector-unsupported.strong.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4be43b27993ab405beaa19738258fdd546d3db/src%2Ftest%2Fui%2Fstack-protector%2Fwarn-stack-protector-unsupported.strong.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstack-protector%2Fwarn-stack-protector-unsupported.strong.stderr?ref=7c4be43b27993ab405beaa19738258fdd546d3db", "patch": "@@ -0,0 +1,4 @@\n+warning: `-Z stack-protector=strong` is not supported for target nvptx64-nvidia-cuda and will be ignored\n+\n+warning: 1 warning emitted\n+"}]}