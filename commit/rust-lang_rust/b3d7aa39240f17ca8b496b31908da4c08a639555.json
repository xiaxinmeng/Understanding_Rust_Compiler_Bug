{"sha": "b3d7aa39240f17ca8b496b31908da4c08a639555", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzZDdhYTM5MjQwZjE3Y2E4YjQ5NmIzMTkwOGRhNGMwOGE2Mzk1NTU=", "commit": {"author": {"name": "mdinger", "email": "mdinger.bugzilla@gmail.com", "date": "2014-05-01T00:40:03Z"}, "committer": {"name": "mdinger", "email": "mdinger.bugzilla@gmail.com", "date": "2014-05-01T00:40:03Z"}, "message": "Merge pull request #1 from pnkfelix/clarify-omit-unit-vs-inference\n\nSuggested revisions to PR 13676.", "tree": {"sha": "ca544f17603c6b8b1119d81e434ef9c3db423cad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca544f17603c6b8b1119d81e434ef9c3db423cad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3d7aa39240f17ca8b496b31908da4c08a639555", "comment_count": 10, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3d7aa39240f17ca8b496b31908da4c08a639555", "html_url": "https://github.com/rust-lang/rust/commit/b3d7aa39240f17ca8b496b31908da4c08a639555", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3d7aa39240f17ca8b496b31908da4c08a639555/comments", "author": {"login": "mdinger", "id": 4156987, "node_id": "MDQ6VXNlcjQxNTY5ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/4156987?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mdinger", "html_url": "https://github.com/mdinger", "followers_url": "https://api.github.com/users/mdinger/followers", "following_url": "https://api.github.com/users/mdinger/following{/other_user}", "gists_url": "https://api.github.com/users/mdinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/mdinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mdinger/subscriptions", "organizations_url": "https://api.github.com/users/mdinger/orgs", "repos_url": "https://api.github.com/users/mdinger/repos", "events_url": "https://api.github.com/users/mdinger/events{/privacy}", "received_events_url": "https://api.github.com/users/mdinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mdinger", "id": 4156987, "node_id": "MDQ6VXNlcjQxNTY5ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/4156987?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mdinger", "html_url": "https://github.com/mdinger", "followers_url": "https://api.github.com/users/mdinger/followers", "following_url": "https://api.github.com/users/mdinger/following{/other_user}", "gists_url": "https://api.github.com/users/mdinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/mdinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mdinger/subscriptions", "organizations_url": "https://api.github.com/users/mdinger/orgs", "repos_url": "https://api.github.com/users/mdinger/repos", "events_url": "https://api.github.com/users/mdinger/events{/privacy}", "received_events_url": "https://api.github.com/users/mdinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f79571f51355826308573f713357eb9e33be665a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f79571f51355826308573f713357eb9e33be665a", "html_url": "https://github.com/rust-lang/rust/commit/f79571f51355826308573f713357eb9e33be665a"}, {"sha": "636f7d23647a77463a07ca9619307b17f0750a14", "url": "https://api.github.com/repos/rust-lang/rust/commits/636f7d23647a77463a07ca9619307b17f0750a14", "html_url": "https://github.com/rust-lang/rust/commit/636f7d23647a77463a07ca9619307b17f0750a14"}], "stats": {"total": 81, "additions": 53, "deletions": 28}, "files": [{"sha": "a33a8f6e70ac312fee79318b9a8ffb8bced3603d", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 53, "deletions": 28, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/b3d7aa39240f17ca8b496b31908da4c08a639555/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/b3d7aa39240f17ca8b496b31908da4c08a639555/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=b3d7aa39240f17ca8b496b31908da4c08a639555", "patch": "@@ -1731,13 +1731,13 @@ they try to access `x`:\n let x = 3;\n \n // `fun` is an invalid definition\n-fn  fun       () -> () { println!(\"{}\", x) }  // cannot capture enclosing scope\n-let closure = || -> () { println!(\"{}\", x) }; // can capture enclosing scope\n+fn  fun       () -> () { println!(\"{}\", x) }  // cannot capture from enclosing scope\n+let closure = || -> () { println!(\"{}\", x) }; // can capture from enclosing scope\n \n // `fun_arg` is an invalid definition\n-fn  fun_arg       (arg: int) -> () { println!(\"{}\", arg + x) }  // cannot capture enclosing scope\n-let closure_arg = |arg: int| -> () { println!(\"{}\", arg + x) }; // can capture enclosing scope\n-//                       ^\n+fn  fun_arg       (arg: int) -> () { println!(\"{}\", arg + x) }  // cannot capture\n+let closure_arg = |arg: int| -> () { println!(\"{}\", arg + x) }; // can capture\n+//                      ^\n // Requires a type because the implementation needs to know which `+` to use.\n // In the future, the implementation may not need the help.\n \n@@ -1752,43 +1752,68 @@ Closures begin with the argument list between vertical bars and are followed by\n a single expression. Remember that a block, `{ <expr1>; <expr2>; ... }`, is\n considered a single expression: it evaluates to the result of the last\n expression it contains if that expression is not followed by a semicolon,\n-otherwise the block evaluates to `()`.\n+otherwise the block evaluates to `()`, the unit value.\n \n-Since a closure is an expression, the compiler can usually infer the argument and\n-return types; so they are often omitted. This is in contrast to a function which\n-is a declaration and _not_ an expression. Declarations require the types to be\n-specified and carry no inference. Compare:\n+In general, return types and all argument types must be specified\n+explicitly for function definitions.  (As previously mentioned in the\n+[Functions section](#functions), omitting the return type from a\n+function declaration is synonymous with an explicit declaration of\n+return type unit, `()`.)\n \n ~~~~ {.ignore}\n-// `fun` cannot infer the type of `x` so it must be provided because it is a function.\n-fn  fun       (x: int) -> () { println!(\"{}\", x) };\n-let closure = |x     | -> () { println!(\"{}\", x) };\n+fn  fun   (x: int)         { println!(\"{}\", x) } // this is same as saying `-> ()`\n+fn  square(x: int) -> uint { (x * x) as uint }   // other return types are explicit\n \n-fun(10);     // Prints 10\n-closure(20); // Prints 20\n-\n-fun(\"String\"); // Error: wrong type\n-// Error: This type is different from when `x` was originally evaluated\n-closure(\"String\");\n+// Error: mismatched types: expected `()` but found `uint`\n+fn  badfun(x: int)         { (x * x) as uint }\n ~~~~\n \n-The null arguments `()` are typically dropped so the end result\n-is more compact.\n+On the other hand, the compiler can usually infer both the argument\n+and return types for a closure expression; therefore they are often\n+omitted, since both a human reader and the compiler can deduce the\n+types from the immediate context.  This is in contrast to function\n+declarations, which require types to be specified and are not subject\n+to type inference. Compare:\n+\n+~~~~ {.ignore}\n+// `fun` as a function declaration cannot infer the type of `x`, so it must be provided\n+fn  fun       (x: int) { println!(\"{}\", x) }\n+let closure = |x     | { println!(\"{}\", x) }; // infers `x: int`, return type `()`\n+\n+// For closures, omitting a return type is *not* synonymous with `-> ()`\n+let add_3   = |y     | { 3i + y }; // infers `y: int`, return type `int`.\n \n+fun(10);            // Prints 10\n+closure(20);        // Prints 20\n+closure(add_3(30)); // Prints 33\n+\n+fun(\"String\"); // Error: mismatched types\n+\n+// Error: mismatched types\n+// inference already assigned `closure` the type `|int| -> ()`\n+closure(\"String\");\n ~~~~\n-let closure = |x| { println!(\"{}\", x) };\n \n-closure(20); // Prints 20\n+In cases where the compiler needs assistance, the arguments and return\n+types may be annotated on closures, using the same notation as shown\n+earlier.  In the example below, since different types provide an\n+implementation for the operator `*`, the argument type for the `x`\n+parameter must be explicitly provided.\n+\n+~~~~{.ignore}\n+// Error: the type of `x` must be known to be used with `x * x`\n+let square = |x     | -> uint { (x * x) as uint };\n ~~~~\n \n-Here, in the rare case where the compiler needs assistance,\n-the arguments and return types may be annotated.\n+In the corrected version, the argument type is explicitly annotated,\n+while the return type can still be inferred.\n \n ~~~~\n-let square = |x: int| -> uint { (x * x) as uint };\n+let square_explicit = |x: int| -> uint { (x * x) as uint };\n+let square_infer    = |x: int|         { (x * x) as uint };\n \n-println!(\"{}\", square(20));  // 400\n-println!(\"{}\", square(-20)); // 400\n+println!(\"{}\", square_explicit(20));  // 400\n+println!(\"{}\", square_infer(-20));    // 400\n ~~~~\n \n There are several forms of closure, each with its own role. The most"}]}