{"sha": "c36205b48e83517e96a2887296114db3df831e21", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzNjIwNWI0OGU4MzUxN2U5NmEyODg3Mjk2MTE0ZGIzZGY4MzFlMjE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-06-01T11:01:49Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-07-02T16:15:19Z"}, "message": "add some tests, currently ICE-ing", "tree": {"sha": "3b86d2336616217de4e753da1c7d1cbf019ff188", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b86d2336616217de4e753da1c7d1cbf019ff188"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c36205b48e83517e96a2887296114db3df831e21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c36205b48e83517e96a2887296114db3df831e21", "html_url": "https://github.com/rust-lang/rust/commit/c36205b48e83517e96a2887296114db3df831e21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c36205b48e83517e96a2887296114db3df831e21/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfcd1c632897779c30d1fee9a6d3c8822bab4d4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfcd1c632897779c30d1fee9a6d3c8822bab4d4f", "html_url": "https://github.com/rust-lang/rust/commit/dfcd1c632897779c30d1fee9a6d3c8822bab4d4f"}], "stats": {"total": 385, "additions": 360, "deletions": 25}, "files": [{"sha": "61c711967ad594e850d45e54b795674fe923a598", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 90, "deletions": 6, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/c36205b48e83517e96a2887296114db3df831e21/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36205b48e83517e96a2887296114db3df831e21/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=c36205b48e83517e96a2887296114db3df831e21", "patch": "@@ -2,6 +2,7 @@\n \n use crate::infer::region_constraints::Constraint;\n use crate::infer::region_constraints::GenericKind;\n+use crate::infer::region_constraints::InConstraint;\n use crate::infer::region_constraints::RegionConstraintData;\n use crate::infer::region_constraints::VarInfos;\n use crate::infer::region_constraints::VerifyBound;\n@@ -117,6 +118,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n         let graph = self.construct_graph();\n         self.expand_givens(&graph);\n+        self.enforce_in_constraints(&graph, &mut var_data);\n         self.expansion(&mut var_data);\n         self.collect_errors(&mut var_data, errors);\n         self.collect_var_errors(&var_data, &graph, errors);\n@@ -178,6 +180,87 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n+    /// Enforce constraints of the form:\n+    ///\n+    /// ```\n+    /// 'r0 in ['o1...'oN]\n+    /// ```\n+    ///\n+    /// such a constraint simply means that `'r0` must be equal to one\n+    /// of the regions `'o1...'oN`. This is an annoying constraint to\n+    /// integrate into our inference, which generally works by\n+    /// iteratively growing regions until we find a match -- that's\n+    /// not an option here.\n+    ///\n+    /// What we currently do:\n+    ///\n+    /// - Search forward in the graph from `'r0` to find each region `'b`\n+    ///   where `'r0 <= 'b` must hold.\n+    ///   - Try to rule out some of the `'o1..'oN` options:\n+    ///     - if `'o[i] <= 'b` is false, then `'o[i]` is not an option\n+    ///\n+    /// Hopefully this narrows it down to just one option.\n+    fn enforce_in_constraints(\n+        &self,\n+        graph: &RegionGraph<'tcx>,\n+        var_values: &mut LexicalRegionResolutions<'tcx>,\n+    ) {\n+        for in_constraint in &self.data.in_constraints {\n+            let _ = self.enforce_in_constraint(graph, in_constraint, var_values);\n+        }\n+    }\n+\n+    fn enforce_in_constraint(\n+        &self,\n+        graph: &RegionGraph<'tcx>,\n+        in_constraint: &InConstraint<'tcx>,\n+        var_values: &mut LexicalRegionResolutions<'tcx>,\n+    ) -> Result<(), ()> {\n+        debug!(\"enforce_in_constraint(in_constraint={:#?})\", in_constraint);\n+\n+        // the constraint is some inference variable (`vid`) which\n+        // must be equal to one of the options\n+        let vid = match in_constraint.region {\n+            ty::ReVar(vid) => *vid,\n+            _ => return Err(()),\n+        };\n+\n+        // find all the \"bounds\" -- that is, each region `b` such that\n+        // `r0 <= b` must hold.\n+        let (bounds, _) = self.collect_concrete_regions(graph, vid, OUTGOING, None);\n+\n+        // get an iterator over the *available options* -- that is,\n+        // each constraint regions `o` where `o <= b` for all the\n+        // bounds `b`.\n+        debug!(\"enforce_in_constraint: bounds={:#?}\", bounds);\n+        let mut options = in_constraint.in_regions.iter().filter(|option| {\n+            bounds.iter().all(|bound| self.sub_concrete_regions(option, bound.region))\n+        });\n+\n+        // if there >1 option, we only make a choice if there is a\n+        // single *least* choice -- i.e., some available region that\n+        // is `<=` all the others.\n+        let mut least_choice = options.next().ok_or(())?;\n+        debug!(\"enforce_in_constraint: least_choice={:?}\", least_choice);\n+        for option in options {\n+            debug!(\"enforce_in_constraint: option={:?}\", option);\n+            if !self.sub_concrete_regions(least_choice, option) {\n+                if self.sub_concrete_regions(option, least_choice) {\n+                    debug!(\"enforce_in_constraint: new least choice\");\n+                    least_choice = option;\n+                } else {\n+                    debug!(\"enforce_in_constraint: no least choice\");\n+                    return Err(());\n+                }\n+            }\n+        }\n+\n+        debug!(\"enforce_in_constraint: final least choice = {:?}\", least_choice);\n+        *var_values.value_mut(vid) = VarValue::Value(least_choice);\n+\n+        Ok(())\n+    }\n+\n     fn expansion(&self, var_values: &mut LexicalRegionResolutions<'tcx>) {\n         self.iterate_until_fixed_point(\"Expansion\", |constraint| {\n             debug!(\"expansion: constraint={:?}\", constraint);\n@@ -275,6 +358,12 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n+    /// True if `a <= b`, but not defined over inference variables.\n+    fn sub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> bool {\n+        self.lub_concrete_regions(a, b) == b\n+    }\n+\n+    /// Returns the smallest region `c` such that `a <= c` and `b <= c`.\n     fn lub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> Region<'tcx> {\n         let tcx = self.tcx();\n \n@@ -500,12 +589,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     that is not used is not a problem, so if this rule\n                     starts to create problems we'll have to revisit\n                     this portion of the code and think hard about it. =) */\n-                    self.collect_error_for_expanding_node(\n-                        graph,\n-                        &mut dup_vec,\n-                        node_vid,\n-                        errors,\n-                    );\n+                    self.collect_error_for_expanding_node(graph, &mut dup_vec, node_vid, errors);\n                 }\n             }\n         }"}, {"sha": "d4c6c8b99b5ef1173a1ab09883feccf15f7d7ee6", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c36205b48e83517e96a2887296114db3df831e21/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36205b48e83517e96a2887296114db3df831e21/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=c36205b48e83517e96a2887296114db3df831e21", "patch": "@@ -445,6 +445,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// # Parameters\n     ///\n     /// - `def_id`, the `impl Trait` type\n+\n     /// - `opaque_defn`, the opaque definition created in `instantiate_opaque_types`\n     /// - `instantiated_ty`, the inferred type C1 -- fully resolved, lifted version of\n     ///   `opaque_defn.concrete_ty`\n@@ -648,25 +649,34 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                              does not appear in bounds\",\n                         );\n \n-                        // Assuming regionck succeeded, then we must\n-                        // be capturing *some* region from the fn\n-                        // header, and hence it must be free, so it's\n-                        // ok to invoke this fn (which doesn't accept\n-                        // all regions, and would ICE if an\n-                        // inappropriate region is given). We check\n-                        // `is_tainted_by_errors` by errors above, so\n-                        // we don't get in here unless regionck\n-                        // succeeded. (Note also that if regionck\n-                        // failed, then the regions we are attempting\n-                        // to map here may well be giving errors\n-                        // *because* the constraints were not\n-                        // satisfiable.)\n-                        self.tcx.note_and_explain_free_region(\n-                            &mut err,\n-                            &format!(\"hidden type `{}` captures \", hidden_ty),\n-                            r,\n-                            \"\",\n-                        );\n+                        // Explain the region we are capturing.\n+                        match r {\n+                            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic | ty::ReEmpty => {\n+                                // Assuming regionck succeeded (*), we\n+                                // ought to always be capturing *some* region\n+                                // from the fn header, and hence it ought to\n+                                // be free. So under normal circumstances, we will\n+                                // go down this path which gives a decent human readable\n+                                // explanation.\n+                                //\n+                                // (*) if not, the `tainted_by_errors`\n+                                // flag would be set to true in any\n+                                // case, so we wouldn't be here at\n+                                // all.\n+                                self.tcx.note_and_explain_free_region(\n+                                    &mut err,\n+                                    &format!(\"hidden type `{}` captures \", hidden_ty),\n+                                    r,\n+                                    \"\",\n+                                );\n+                            }\n+                            _ => {\n+                                // This case should not happen: it indicates that regionck\n+                                // failed to enforce an \"in constraint\".\n+                                err.note(&format!(\"hidden type `{}` captures `{:?}`\", hidden_ty, r));\n+                                err.note(&format!(\"this is likely a bug in the compiler, please file an issue on github\"));\n+                            }\n+                        }\n \n                         err.emit();\n                     }"}, {"sha": "41d4b59e8f029f362dfbac33ee3bbec098028a9b", "filename": "src/test/ui/impl-trait/multiple-lifetimes/inverse-bounds.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c36205b48e83517e96a2887296114db3df831e21/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Finverse-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36205b48e83517e96a2887296114db3df831e21/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Finverse-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Finverse-bounds.rs?ref=c36205b48e83517e96a2887296114db3df831e21", "patch": "@@ -0,0 +1,54 @@\n+// edition:2018\n+\n+#![feature(arbitrary_self_types, async_await, await_macro, pin)]\n+\n+trait Trait<'a, 'b> {}\n+impl<T> Trait<'_, '_> for T {}\n+\n+// `Invert<'a> <: Invert<'b>` if `'b: 'a`, unlike most types.\n+//\n+// I am purposefully avoiding the terms co- and contra-variant because\n+// their application to regions depends on how you interpreted Rust\n+// regions. -nikomatsakis\n+struct Invert<'a>(fn(&'a u8));\n+\n+fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Invert<'a>, b: Invert<'b>) -> impl Trait<'d, 'e>\n+//~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+// FIXME -- we ought to be able to pick `'d` here, but our handling of in constraints\n+// is not smart enough\n+where\n+    'c: 'a,\n+    'c: 'b,\n+    'd: 'c,\n+{\n+    // Representing the where clauses as a graph, where `A: B` is an\n+    // edge `B -> A`:\n+    //\n+    // ```\n+    // 'a -> 'c -> 'd\n+    //        ^\n+    //        |\n+    //       'b\n+    // ```\n+    //\n+    // Meanwhile we return a value &'0 u8 where we have the constraints:\n+    //\n+    // ```\n+    // '0: 'a\n+    // '0: 'b\n+    // '0 in ['d, 'e]\n+    // ```\n+    //\n+    // Here, ignoring the \"in\" constraint, the minimal choice for `'0`\n+    // is `'c`, but that is not in the \"in set\". Still, that reduces\n+    // the range of options in the \"in set\" to just `'d` (`'e: 'c`\n+    // does not hold).\n+    let p = if condition() { a } else { b };\n+    p\n+}\n+\n+fn condition() -> bool {\n+    true\n+}\n+\n+fn main() {}"}, {"sha": "182d07733ffd8c6862fc7e16fed28e0e08f59981", "filename": "src/test/ui/impl-trait/multiple-lifetimes/inverse-bounds.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c36205b48e83517e96a2887296114db3df831e21/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Finverse-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c36205b48e83517e96a2887296114db3df831e21/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Finverse-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Finverse-bounds.stderr?ref=c36205b48e83517e96a2887296114db3df831e21", "patch": "@@ -0,0 +1,15 @@\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/inverse-bounds.rs:15:70\n+   |\n+LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Invert<'a>, b: Invert<'b>) -> impl Trait<'d, 'e>\n+   |                                                                      ^^^^^^^^^^^^^^^^^^\n+   |\n+note: hidden type `Invert<'c>` captures the lifetime 'c as defined on the function body at 15:25\n+  --> $DIR/inverse-bounds.rs:15:25\n+   |\n+LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Invert<'a>, b: Invert<'b>) -> impl Trait<'d, 'e>\n+   |                         ^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0700`."}, {"sha": "dde3e6d72c9ae7ed99cef3c539db618e49efc531", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-pick-original.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c36205b48e83517e96a2887296114db3df831e21/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36205b48e83517e96a2887296114db3df831e21/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original.rs?ref=c36205b48e83517e96a2887296114db3df831e21", "patch": "@@ -0,0 +1,26 @@\n+// edition:2018\n+\n+#![feature(arbitrary_self_types, async_await, await_macro, pin)]\n+\n+trait Trait<'a, 'b> { }\n+impl<T> Trait<'_, '_> for T { }\n+\n+// Here we wind up selecting `'a` and `'b` in the hidden type because\n+// those are the types that appear inth e original values.\n+\n+fn upper_bounds<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a, 'b> {\n+    // In this simple case, you have a hidden type `(&'0 u8, &'1 u8)` and constraints like\n+    //\n+    // ```\n+    // 'a: '0\n+    // 'b: '1\n+    // '0 in ['a, 'b]\n+    // '1 in ['a, 'b]\n+    // ```\n+    //\n+    // We use the fact that `'a: 0'` must hold (combined with the in\n+    // constraint) to determine that `'0 = 'a` must be the answer.\n+    (a, b)\n+}\n+\n+fn main() { }"}, {"sha": "b53ef1dde42b22baad18d206fe02df013eea97e1", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-pick-other.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c36205b48e83517e96a2887296114db3df831e21/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-other.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36205b48e83517e96a2887296114db3df831e21/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-other.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-other.rs?ref=c36205b48e83517e96a2887296114db3df831e21", "patch": "@@ -0,0 +1,43 @@\n+// edition:2018\n+\n+#![feature(arbitrary_self_types, async_await, await_macro, pin)]\n+\n+trait Trait<'a, 'b> {}\n+impl<T> Trait<'_, '_> for T {}\n+\n+// `Ordinary<'a> <: Ordinary<'b>` if `'a: 'b`, as with most types.\n+//\n+// I am purposefully avoiding the terms co- and contra-variant because\n+// their application to regions depends on how you interpreted Rust\n+// regions. -nikomatsakis\n+struct Ordinary<'a>(&'a u8);\n+\n+// Here we wind up selecting `'e` in the hidden type because\n+// we need something outlived by both `'a` and `'b` and only `'e` applies.\n+\n+fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n+where\n+    'a: 'e,\n+    'b: 'e,\n+    'a: 'd,\n+{\n+    // We return a value:\n+    //\n+    // ```\n+    // 'a: '0\n+    // 'b: '1\n+    // '0 in ['d, 'e]\n+    // ```\n+    //\n+    // but we don't have it.\n+    //\n+    // We are forced to pick that '0 = 'e, because only 'e is outlived by *both* 'a and 'b.\n+    let p = if condition() { a } else { b };\n+    p\n+}\n+\n+fn condition() -> bool {\n+    true\n+}\n+\n+fn main() {}"}, {"sha": "c1322a391402e2a17dc36a3b61a4d33b7e8cf166", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unrelated.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c36205b48e83517e96a2887296114db3df831e21/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36205b48e83517e96a2887296114db3df831e21/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.rs?ref=c36205b48e83517e96a2887296114db3df831e21", "patch": "@@ -0,0 +1,38 @@\n+// edition:2018\n+\n+#![feature(arbitrary_self_types, async_await, await_macro, pin)]\n+\n+trait Trait<'a, 'b> {}\n+impl<T> Trait<'_, '_> for T {}\n+\n+// `Ordinary<'a> <: Ordinary<'b>` if `'a: 'b`, as with most types.\n+//\n+// I am purposefully avoiding the terms co- and contra-variant because\n+// their application to regions depends on how you interpreted Rust\n+// regions. -nikomatsakis\n+struct Ordinary<'a>(&'a u8);\n+\n+// Here we get an error because none of our choices (either `'d` nor `'e`) are outlived\n+// by both `'a` and `'b`.\n+\n+fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n+//~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+where\n+    'a: 'e,\n+    'b: 'd,\n+{\n+    // Hidden type `Ordinary<'0>` with constraints:\n+    //\n+    // ```\n+    // 'a: '0\n+    // 'b: '0\n+    // 'a in ['d, 'e]\n+    // ```\n+    if condition() { a } else { b }\n+}\n+\n+fn condition() -> bool {\n+    true\n+}\n+\n+fn main() {}"}, {"sha": "9b505c66dc1152288446440ac9f3a0df3801069d", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unrelated.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c36205b48e83517e96a2887296114db3df831e21/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c36205b48e83517e96a2887296114db3df831e21/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr?ref=c36205b48e83517e96a2887296114db3df831e21", "patch": "@@ -0,0 +1,12 @@\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/ordinary-bounds-unrelated.rs:18:74\n+   |\n+LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n+   |                                                                          ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: hidden type `Ordinary<'_>` captures `ReScope(CallSite(24))`\n+   = note: this is likely a bug in the compiler, please file an issue on github\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0700`."}, {"sha": "a28bbd5df7828a0548d45efdb251660d154e9141", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unsuited.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c36205b48e83517e96a2887296114db3df831e21/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c36205b48e83517e96a2887296114db3df831e21/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.rs?ref=c36205b48e83517e96a2887296114db3df831e21", "patch": "@@ -0,0 +1,41 @@\n+// edition:2018\n+\n+#![feature(arbitrary_self_types, async_await, await_macro, pin)]\n+\n+trait Trait<'a, 'b> {}\n+impl<T> Trait<'_, '_> for T {}\n+\n+// `Ordinary<'a> <: Ordinary<'b>` if `'a: 'b`, as with most types.\n+//\n+// I am purposefully avoiding the terms co- and contra-variant because\n+// their application to regions depends on how you interpreted Rust\n+// regions. -nikomatsakis\n+struct Ordinary<'a>(&'a u8);\n+\n+// Here we need something outlived by `'a` *and* outlived by `'b`, but\n+// we can only name `'a` and `'b` (and neither suits). So we get an\n+// error. Somewhat unfortunate, though, since the caller would have to\n+// consider the loans for both `'a` and `'b` alive.\n+\n+fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n+    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+{\n+    // We return a value:\n+    //\n+    // ```\n+    // 'a: '0\n+    // 'b: '1\n+    // '0 in ['d, 'e]\n+    // ```\n+    //\n+    // but we don't have it.\n+    //\n+    // We are forced to pick that '0 = 'e, because only 'e is outlived by *both* 'a and 'b.\n+    if condition() { a } else { b }\n+}\n+\n+fn condition() -> bool {\n+    true\n+}\n+\n+fn main() {}"}, {"sha": "d258948c7735dd6704a99583b98775d84b06faa4", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unsuited.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c36205b48e83517e96a2887296114db3df831e21/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c36205b48e83517e96a2887296114db3df831e21/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr?ref=c36205b48e83517e96a2887296114db3df831e21", "patch": "@@ -0,0 +1,12 @@\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/ordinary-bounds-unsuited.rs:20:62\n+   |\n+LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n+   |                                                              ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: hidden type `Ordinary<'_>` captures `ReScope(CallSite(24))`\n+   = note: this is likely a bug in the compiler, please file an issue on github\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0700`."}]}