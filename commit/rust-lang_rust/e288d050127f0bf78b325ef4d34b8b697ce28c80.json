{"sha": "e288d050127f0bf78b325ef4d34b8b697ce28c80", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyODhkMDUwMTI3ZjBiZjc4YjMyNWVmNGQzNGI4YjY5N2NlMjhjODA=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-08-02T13:03:47Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-08-02T13:49:26Z"}, "message": "Introduce an abstraction for EvaluationCache and SelectionCache.", "tree": {"sha": "265f883c92b8e38f549469f30fd595cc1e9149cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/265f883c92b8e38f549469f30fd595cc1e9149cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e288d050127f0bf78b325ef4d34b8b697ce28c80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e288d050127f0bf78b325ef4d34b8b697ce28c80", "html_url": "https://github.com/rust-lang/rust/commit/e288d050127f0bf78b325ef4d34b8b697ce28c80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e288d050127f0bf78b325ef4d34b8b697ce28c80/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c28244cf0fc9868f55070e55b8f332d196eaf3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c28244cf0fc9868f55070e55b8f332d196eaf3f", "html_url": "https://github.com/rust-lang/rust/commit/2c28244cf0fc9868f55070e55b8f332d196eaf3f"}], "stats": {"total": 168, "additions": 81, "deletions": 87}, "files": [{"sha": "aad91d60911aaf40925447e57a6c5933c3c028cb", "filename": "src/librustc_middle/traits/select.rs", "status": "modified", "additions": 8, "deletions": 50, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e288d050127f0bf78b325ef4d34b8b697ce28c80/src%2Flibrustc_middle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e288d050127f0bf78b325ef4d34b8b697ce28c80/src%2Flibrustc_middle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fselect.rs?ref=e288d050127f0bf78b325ef4d34b8b697ce28c80", "patch": "@@ -6,29 +6,18 @@ use self::EvaluationResult::*;\n \n use super::{SelectionError, SelectionResult};\n \n-use crate::dep_graph::DepNodeIndex;\n-use crate::ty::{self, TyCtxt};\n+use crate::ty;\n \n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::Lock;\n use rustc_hir::def_id::DefId;\n+use rustc_query_system::cache::Cache;\n \n-#[derive(Clone, Default)]\n-pub struct SelectionCache<'tcx> {\n-    pub hashmap: Lock<\n-        FxHashMap<\n-            ty::ParamEnvAnd<'tcx, ty::TraitRef<'tcx>>,\n-            WithDepNode<SelectionResult<'tcx, SelectionCandidate<'tcx>>>,\n-        >,\n-    >,\n-}\n+pub type SelectionCache<'tcx> = Cache<\n+    ty::ParamEnvAnd<'tcx, ty::TraitRef<'tcx>>,\n+    SelectionResult<'tcx, SelectionCandidate<'tcx>>,\n+>;\n \n-impl<'tcx> SelectionCache<'tcx> {\n-    /// Actually frees the underlying memory in contrast to what stdlib containers do on `clear`\n-    pub fn clear(&self) {\n-        *self.hashmap.borrow_mut() = Default::default();\n-    }\n-}\n+pub type EvaluationCache<'tcx> =\n+    Cache<ty::ParamEnvAnd<'tcx, ty::PolyTraitRef<'tcx>>, EvaluationResult>;\n \n /// The selection process begins by considering all impls, where\n /// clauses, and so forth that might resolve an obligation. Sometimes\n@@ -265,37 +254,6 @@ impl<'tcx> From<OverflowError> for SelectionError<'tcx> {\n     }\n }\n \n-#[derive(Clone, Default)]\n-pub struct EvaluationCache<'tcx> {\n-    pub hashmap: Lock<\n-        FxHashMap<ty::ParamEnvAnd<'tcx, ty::PolyTraitRef<'tcx>>, WithDepNode<EvaluationResult>>,\n-    >,\n-}\n-\n-impl<'tcx> EvaluationCache<'tcx> {\n-    /// Actually frees the underlying memory in contrast to what stdlib containers do on `clear`\n-    pub fn clear(&self) {\n-        *self.hashmap.borrow_mut() = Default::default();\n-    }\n-}\n-\n-#[derive(Clone, Eq, PartialEq)]\n-pub struct WithDepNode<T> {\n-    dep_node: DepNodeIndex,\n-    cached_value: T,\n-}\n-\n-impl<T: Clone> WithDepNode<T> {\n-    pub fn new(dep_node: DepNodeIndex, cached_value: T) -> Self {\n-        WithDepNode { dep_node, cached_value }\n-    }\n-\n-    pub fn get(&self, tcx: TyCtxt<'_>) -> T {\n-        tcx.dep_graph.read_index(self.dep_node);\n-        self.cached_value.clone()\n-    }\n-}\n-\n #[derive(Clone, Debug)]\n pub enum IntercrateAmbiguityCause {\n     DownstreamCrate { trait_desc: String, self_desc: Option<String> },"}, {"sha": "be3d3607728547c995dac174fdbb2b8c98db0921", "filename": "src/librustc_query_system/cache.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e288d050127f0bf78b325ef4d34b8b697ce28c80/src%2Flibrustc_query_system%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e288d050127f0bf78b325ef4d34b8b697ce28c80/src%2Flibrustc_query_system%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fcache.rs?ref=e288d050127f0bf78b325ef4d34b8b697ce28c80", "patch": "@@ -0,0 +1,62 @@\n+//! Cache for candidate selection.\n+\n+use crate::dep_graph::DepNodeIndex;\n+use crate::query::QueryContext;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::HashMapExt;\n+use rustc_data_structures::sync::Lock;\n+\n+use std::hash::Hash;\n+\n+#[derive(Clone)]\n+pub struct Cache<Key, Value> {\n+    hashmap: Lock<FxHashMap<Key, WithDepNode<Value>>>,\n+}\n+\n+impl<Key, Value> Default for Cache<Key, Value> {\n+    fn default() -> Self {\n+        Self { hashmap: Default::default() }\n+    }\n+}\n+\n+impl<Key, Value> Cache<Key, Value> {\n+    /// Actually frees the underlying memory in contrast to what stdlib containers do on `clear`\n+    pub fn clear(&self) {\n+        *self.hashmap.borrow_mut() = Default::default();\n+    }\n+}\n+\n+impl<Key: Eq + Hash, Value: Clone> Cache<Key, Value> {\n+    pub fn get<CTX: QueryContext>(&self, key: &Key, tcx: CTX) -> Option<Value> {\n+        Some(self.hashmap.borrow().get(key)?.get(tcx))\n+    }\n+\n+    pub fn insert(&self, key: Key, dep_node: DepNodeIndex, value: Value) {\n+        self.hashmap.borrow_mut().insert(key, WithDepNode::new(dep_node, value));\n+    }\n+\n+    pub fn insert_same(&self, key: Key, dep_node: DepNodeIndex, value: Value)\n+    where\n+        Value: Eq,\n+    {\n+        self.hashmap.borrow_mut().insert_same(key, WithDepNode::new(dep_node, value));\n+    }\n+}\n+\n+#[derive(Clone, Eq, PartialEq)]\n+pub struct WithDepNode<T> {\n+    dep_node: DepNodeIndex,\n+    cached_value: T,\n+}\n+\n+impl<T: Clone> WithDepNode<T> {\n+    pub fn new(dep_node: DepNodeIndex, cached_value: T) -> Self {\n+        WithDepNode { dep_node, cached_value }\n+    }\n+\n+    pub fn get<CTX: QueryContext>(&self, tcx: CTX) -> T {\n+        tcx.dep_graph().read_index(self.dep_node);\n+        self.cached_value.clone()\n+    }\n+}"}, {"sha": "4bbba7befe93f00363e03a8b458cca79f19f6e0d", "filename": "src/librustc_query_system/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e288d050127f0bf78b325ef4d34b8b697ce28c80/src%2Flibrustc_query_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e288d050127f0bf78b325ef4d34b8b697ce28c80/src%2Flibrustc_query_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Flib.rs?ref=e288d050127f0bf78b325ef4d34b8b697ce28c80", "patch": "@@ -11,5 +11,6 @@ extern crate log;\n #[macro_use]\n extern crate rustc_data_structures;\n \n+pub mod cache;\n pub mod dep_graph;\n pub mod query;"}, {"sha": "51567d34f42431aa8f05c8a8e052a1e17d5e2fff", "filename": "src/librustc_trait_selection/traits/select/mod.rs", "status": "modified", "additions": 10, "deletions": 37, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e288d050127f0bf78b325ef4d34b8b697ce28c80/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e288d050127f0bf78b325ef4d34b8b697ce28c80/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs?ref=e288d050127f0bf78b325ef4d34b8b697ce28c80", "patch": "@@ -833,17 +833,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> Option<EvaluationResult> {\n         let tcx = self.tcx();\n         if self.can_use_global_caches(param_env) {\n-            let cache = tcx.evaluation_cache.hashmap.borrow();\n-            if let Some(cached) = cache.get(&param_env.and(trait_ref)) {\n-                return Some(cached.get(tcx));\n+            if let Some(res) = tcx.evaluation_cache.get(&param_env.and(trait_ref), tcx) {\n+                return Some(res);\n             }\n         }\n-        self.infcx\n-            .evaluation_cache\n-            .hashmap\n-            .borrow()\n-            .get(&param_env.and(trait_ref))\n-            .map(|v| v.get(tcx))\n+        self.infcx.evaluation_cache.get(&param_env.and(trait_ref), tcx)\n     }\n \n     fn insert_evaluation_cache(\n@@ -869,21 +863,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // FIXME: Due to #50507 this overwrites the different values\n                 // This should be changed to use HashMapExt::insert_same\n                 // when that is fixed\n-                self.tcx()\n-                    .evaluation_cache\n-                    .hashmap\n-                    .borrow_mut()\n-                    .insert(param_env.and(trait_ref), WithDepNode::new(dep_node, result));\n+                self.tcx().evaluation_cache.insert(param_env.and(trait_ref), dep_node, result);\n                 return;\n             }\n         }\n \n         debug!(\"insert_evaluation_cache(trait_ref={:?}, candidate={:?})\", trait_ref, result,);\n-        self.infcx\n-            .evaluation_cache\n-            .hashmap\n-            .borrow_mut()\n-            .insert(param_env.and(trait_ref), WithDepNode::new(dep_node, result));\n+        self.infcx.evaluation_cache.insert(param_env.and(trait_ref), dep_node, result);\n     }\n \n     /// For various reasons, it's possible for a subobligation\n@@ -1180,17 +1166,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let tcx = self.tcx();\n         let trait_ref = &cache_fresh_trait_pred.skip_binder().trait_ref;\n         if self.can_use_global_caches(param_env) {\n-            let cache = tcx.selection_cache.hashmap.borrow();\n-            if let Some(cached) = cache.get(&param_env.and(*trait_ref)) {\n-                return Some(cached.get(tcx));\n+            if let Some(res) = tcx.selection_cache.get(&param_env.and(*trait_ref), tcx) {\n+                return Some(res);\n             }\n         }\n-        self.infcx\n-            .selection_cache\n-            .hashmap\n-            .borrow()\n-            .get(&param_env.and(*trait_ref))\n-            .map(|v| v.get(tcx))\n+        self.infcx.selection_cache.get(&param_env.and(*trait_ref), tcx)\n     }\n \n     /// Determines whether can we safely cache the result\n@@ -1248,10 +1228,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         trait_ref, candidate,\n                     );\n                     // This may overwrite the cache with the same value.\n-                    tcx.selection_cache\n-                        .hashmap\n-                        .borrow_mut()\n-                        .insert(param_env.and(trait_ref), WithDepNode::new(dep_node, candidate));\n+                    tcx.selection_cache.insert(param_env.and(trait_ref), dep_node, candidate);\n                     return;\n                 }\n             }\n@@ -1261,11 +1238,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             \"insert_candidate_cache(trait_ref={:?}, candidate={:?}) local\",\n             trait_ref, candidate,\n         );\n-        self.infcx\n-            .selection_cache\n-            .hashmap\n-            .borrow_mut()\n-            .insert(param_env.and(trait_ref), WithDepNode::new(dep_node, candidate));\n+        self.infcx.selection_cache.insert(param_env.and(trait_ref), dep_node, candidate);\n     }\n \n     fn match_projection_obligation_against_definition_bounds("}]}