{"sha": "43bfaa4a336095eb5697fb2df50909fd3c72ed14", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzYmZhYTRhMzM2MDk1ZWI1Njk3ZmIyZGY1MDkwOWZkM2M3MmVkMTQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-26T00:06:52Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-26T19:10:22Z"}, "message": "Mass rename uint/int to usize/isize\n\nNow that support has been removed, all lingering use cases are renamed.", "tree": {"sha": "e10610e1ce9811c89e1291b786d7a49b63ee02d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e10610e1ce9811c89e1291b786d7a49b63ee02d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43bfaa4a336095eb5697fb2df50909fd3c72ed14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43bfaa4a336095eb5697fb2df50909fd3c72ed14", "html_url": "https://github.com/rust-lang/rust/commit/43bfaa4a336095eb5697fb2df50909fd3c72ed14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43bfaa4a336095eb5697fb2df50909fd3c72ed14/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54f16b818b58f6d6e81891b041fc751986e75155", "url": "https://api.github.com/repos/rust-lang/rust/commits/54f16b818b58f6d6e81891b041fc751986e75155", "html_url": "https://github.com/rust-lang/rust/commit/54f16b818b58f6d6e81891b041fc751986e75155"}], "stats": {"total": 10424, "additions": 5183, "deletions": 5241}, "files": [{"sha": "6511bbd84750bd62009576e2d41424625cd3da31", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -12,7 +12,6 @@\n \n #![feature(box_syntax)]\n #![feature(collections)]\n-#![feature(int_uint)]\n #![feature(old_io)]\n #![feature(old_path)]\n #![feature(rustc_private)]"}, {"sha": "4b2a3e0283dc2a54347045890d03e7bffeb29a5e", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -15,13 +15,13 @@ use std::io::prelude::*;\n use std::path::Path;\n \n pub struct ExpectedError {\n-    pub line: uint,\n+    pub line: usize,\n     pub kind: String,\n     pub msg: String,\n }\n \n #[derive(PartialEq, Debug)]\n-enum WhichLine { ThisLine, FollowPrevious(uint), AdjustBackward(uint) }\n+enum WhichLine { ThisLine, FollowPrevious(usize), AdjustBackward(usize) }\n \n /// Looks for either \"//~| KIND MESSAGE\" or \"//~^^... KIND MESSAGE\"\n /// The former is a \"follow\" that inherits its target from the preceding line;\n@@ -58,8 +58,8 @@ pub fn load_errors(testfile: &Path) -> Vec<ExpectedError> {\n     }).collect()\n }\n \n-fn parse_expected(last_nonfollow_error: Option<uint>,\n-                  line_num: uint,\n+fn parse_expected(last_nonfollow_error: Option<usize>,\n+                  line_num: usize,\n                   line: &str) -> Option<(WhichLine, ExpectedError)> {\n     let start = match line.find(\"//~\") { Some(i) => i, None => return None };\n     let (follow, adjusts) = if line.char_at(start + 3) == '|' {"}, {"sha": "9612c0e06a34d7b311fb08db18b5181e7ac2fe7f", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -357,7 +357,7 @@ pub fn parse_name_value_directive(line: &str, directive: &str)\n     }\n }\n \n-pub fn gdb_version_to_int(version_string: &str) -> int {\n+pub fn gdb_version_to_int(version_string: &str) -> isize {\n     let error_string = format!(\n         \"Encountered GDB version string with unexpected format: {}\",\n         version_string);\n@@ -369,17 +369,17 @@ pub fn gdb_version_to_int(version_string: &str) -> int {\n         panic!(\"{}\", error_string);\n     }\n \n-    let major: int = components[0].parse().ok().expect(&error_string);\n-    let minor: int = components[1].parse().ok().expect(&error_string);\n+    let major: isize = components[0].parse().ok().expect(&error_string);\n+    let minor: isize = components[1].parse().ok().expect(&error_string);\n \n     return major * 1000 + minor;\n }\n \n-pub fn lldb_version_to_int(version_string: &str) -> int {\n+pub fn lldb_version_to_int(version_string: &str) -> isize {\n     let error_string = format!(\n         \"Encountered LLDB version string with unexpected format: {}\",\n         version_string);\n     let error_string = error_string;\n-    let major: int = version_string.parse().ok().expect(&error_string);\n+    let major: isize = version_string.parse().ok().expect(&error_string);\n     return major;\n }"}, {"sha": "23267c3e93472cb0b4f3faf59fd675594635e13d", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -758,7 +758,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n struct DebuggerCommands {\n     commands: Vec<String>,\n     check_lines: Vec<String>,\n-    breakpoint_lines: Vec<uint>,\n+    breakpoint_lines: Vec<usize>,\n }\n \n fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str)\n@@ -1036,7 +1036,7 @@ fn is_compiler_error_or_warning(line: &str) -> bool {\n          scan_string(line, \"warning\", &mut i));\n }\n \n-fn scan_until_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n+fn scan_until_char(haystack: &str, needle: char, idx: &mut usize) -> bool {\n     if *idx >= haystack.len() {\n         return false;\n     }\n@@ -1048,7 +1048,7 @@ fn scan_until_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n     return true;\n }\n \n-fn scan_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n+fn scan_char(haystack: &str, needle: char, idx: &mut usize) -> bool {\n     if *idx >= haystack.len() {\n         return false;\n     }\n@@ -1060,7 +1060,7 @@ fn scan_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n     return true;\n }\n \n-fn scan_integer(haystack: &str, idx: &mut uint) -> bool {\n+fn scan_integer(haystack: &str, idx: &mut usize) -> bool {\n     let mut i = *idx;\n     while i < haystack.len() {\n         let ch = haystack.char_at(i);\n@@ -1076,7 +1076,7 @@ fn scan_integer(haystack: &str, idx: &mut uint) -> bool {\n     return true;\n }\n \n-fn scan_string(haystack: &str, needle: &str, idx: &mut uint) -> bool {\n+fn scan_string(haystack: &str, needle: &str, idx: &mut usize) -> bool {\n     let mut haystack_i = *idx;\n     let mut needle_i = 0;\n     while needle_i < needle.len() {\n@@ -1725,7 +1725,7 @@ fn disassemble_extract(config: &Config, _props: &TestProps,\n }\n \n \n-fn count_extracted_lines(p: &Path) -> uint {\n+fn count_extracted_lines(p: &Path) -> usize {\n     let mut x = Vec::new();\n     File::open(&p.with_extension(\"ll\")).unwrap().read_to_end(&mut x).unwrap();\n     let x = str::from_utf8(&x).unwrap();"}, {"sha": "1f043424f31450a00792e64ed70cca3dc927db4b", "filename": "src/doc/reference.md", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -2440,9 +2440,6 @@ The currently implemented features of the reference compiler are:\n * `intrinsics` - Allows use of the \"rust-intrinsics\" ABI. Compiler intrinsics\n                  are inherently unstable and no promise about them is made.\n \n-* `int_uint` - Allows the use of the `int` and `uint` types, which are deprecated.\n-               Use `isize` and `usize` instead.\n-\n * `lang_items` - Allows use of the `#[lang]` attribute. Like `intrinsics`,\n                  lang items are inherently unstable and no promise about them\n                  is made.\n@@ -2759,7 +2756,7 @@ The following are examples of structure expressions:\n ```\n # struct Point { x: f64, y: f64 }\n # struct TuplePoint(f64, f64);\n-# mod game { pub struct User<'a> { pub name: &'a str, pub age: u32, pub score: uint } }\n+# mod game { pub struct User<'a> { pub name: &'a str, pub age: u32, pub score: usize } }\n # struct Cookie; fn some_fn<T>(t: T) {}\n Point {x: 10.0, y: 20.0};\n TuplePoint(10.0, 20.0);\n@@ -3402,7 +3399,7 @@ subpattern`. For example:\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n \n-enum List { Nil, Cons(uint, Box<List>) }\n+enum List { Nil, Cons(u32, Box<List>) }\n \n fn is_sorted(list: &List) -> bool {\n     match *list {"}, {"sha": "b65d90f52a420596cac27402a1c01b7927e81723", "filename": "src/doc/trpl/ffi.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Fdoc%2Ftrpl%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Fdoc%2Ftrpl%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fffi.md?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -401,7 +401,7 @@ Unsafe functions, on the other hand, advertise it to the world. An unsafe functi\n this:\n \n ```\n-unsafe fn kaboom(ptr: *const int) -> int { *ptr }\n+unsafe fn kaboom(ptr: *const i32) -> i32 { *ptr }\n ```\n \n This function can only be called from an `unsafe` block or another `unsafe` function.\n@@ -423,7 +423,7 @@ extern {\n \n fn main() {\n     println!(\"You have readline version {} installed.\",\n-             rl_readline_version as int);\n+             rl_readline_version as i32);\n }\n ```\n "}, {"sha": "17a463842e71c39fa24c4d9935667a6362b47229", "filename": "src/doc/trpl/more-strings.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Fdoc%2Ftrpl%2Fmore-strings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmore-strings.md?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -129,7 +129,7 @@ need, and it can make your lifetimes more complex.\n To write a function that's generic over types of strings, use `&str`.\n \n ```\n-fn some_string_length(x: &str) -> uint {\n+fn some_string_length(x: &str) -> usize {\n     x.len()\n }\n "}, {"sha": "4bbbfbaace932b680ba08d19f8bb10136f2268b0", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -1064,7 +1064,7 @@ pub fn fence(order: Ordering) {\n              reason = \"renamed to AtomicIsize\")]\n #[allow(missing_docs)]\n pub struct AtomicInt {\n-    v: UnsafeCell<int>,\n+    v: UnsafeCell<isize>,\n }\n \n #[allow(deprecated)]\n@@ -1075,7 +1075,7 @@ unsafe impl Sync for AtomicInt {}\n              reason = \"renamed to AtomicUsize\")]\n #[allow(missing_docs)]\n pub struct AtomicUint {\n-    v: UnsafeCell<uint>,\n+    v: UnsafeCell<usize>,\n }\n \n #[allow(deprecated)]\n@@ -1097,105 +1097,105 @@ pub const ATOMIC_UINT_INIT: AtomicUint =\n #[allow(missing_docs, deprecated)]\n impl AtomicInt {\n     #[inline]\n-    pub fn new(v: int) -> AtomicInt {\n+    pub fn new(v: isize) -> AtomicInt {\n         AtomicInt {v: UnsafeCell::new(v)}\n     }\n \n     #[inline]\n-    pub fn load(&self, order: Ordering) -> int {\n+    pub fn load(&self, order: Ordering) -> isize {\n         unsafe { atomic_load(self.v.get(), order) }\n     }\n \n     #[inline]\n-    pub fn store(&self, val: int, order: Ordering) {\n+    pub fn store(&self, val: isize, order: Ordering) {\n         unsafe { atomic_store(self.v.get(), val, order); }\n     }\n \n     #[inline]\n-    pub fn swap(&self, val: int, order: Ordering) -> int {\n+    pub fn swap(&self, val: isize, order: Ordering) -> isize {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n \n     #[inline]\n-    pub fn compare_and_swap(&self, old: int, new: int, order: Ordering) -> int {\n+    pub fn compare_and_swap(&self, old: isize, new: isize, order: Ordering) -> isize {\n         unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n \n     #[inline]\n-    pub fn fetch_add(&self, val: int, order: Ordering) -> int {\n+    pub fn fetch_add(&self, val: isize, order: Ordering) -> isize {\n         unsafe { atomic_add(self.v.get(), val, order) }\n     }\n \n     #[inline]\n-    pub fn fetch_sub(&self, val: int, order: Ordering) -> int {\n+    pub fn fetch_sub(&self, val: isize, order: Ordering) -> isize {\n         unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n \n     #[inline]\n-    pub fn fetch_and(&self, val: int, order: Ordering) -> int {\n+    pub fn fetch_and(&self, val: isize, order: Ordering) -> isize {\n         unsafe { atomic_and(self.v.get(), val, order) }\n     }\n \n     #[inline]\n-    pub fn fetch_or(&self, val: int, order: Ordering) -> int {\n+    pub fn fetch_or(&self, val: isize, order: Ordering) -> isize {\n         unsafe { atomic_or(self.v.get(), val, order) }\n     }\n \n     #[inline]\n-    pub fn fetch_xor(&self, val: int, order: Ordering) -> int {\n+    pub fn fetch_xor(&self, val: isize, order: Ordering) -> isize {\n         unsafe { atomic_xor(self.v.get(), val, order) }\n     }\n }\n \n #[allow(missing_docs, deprecated)]\n impl AtomicUint {\n     #[inline]\n-    pub fn new(v: uint) -> AtomicUint {\n+    pub fn new(v: usize) -> AtomicUint {\n         AtomicUint { v: UnsafeCell::new(v) }\n     }\n \n     #[inline]\n-    pub fn load(&self, order: Ordering) -> uint {\n+    pub fn load(&self, order: Ordering) -> usize {\n         unsafe { atomic_load(self.v.get(), order) }\n     }\n \n     #[inline]\n-    pub fn store(&self, val: uint, order: Ordering) {\n+    pub fn store(&self, val: usize, order: Ordering) {\n         unsafe { atomic_store(self.v.get(), val, order); }\n     }\n \n     #[inline]\n-    pub fn swap(&self, val: uint, order: Ordering) -> uint {\n+    pub fn swap(&self, val: usize, order: Ordering) -> usize {\n         unsafe { atomic_swap(self.v.get(), val, order) }\n     }\n \n     #[inline]\n-    pub fn compare_and_swap(&self, old: uint, new: uint, order: Ordering) -> uint {\n+    pub fn compare_and_swap(&self, old: usize, new: usize, order: Ordering) -> usize {\n         unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n     }\n \n     #[inline]\n-    pub fn fetch_add(&self, val: uint, order: Ordering) -> uint {\n+    pub fn fetch_add(&self, val: usize, order: Ordering) -> usize {\n         unsafe { atomic_add(self.v.get(), val, order) }\n     }\n \n     #[inline]\n-    pub fn fetch_sub(&self, val: uint, order: Ordering) -> uint {\n+    pub fn fetch_sub(&self, val: usize, order: Ordering) -> usize {\n         unsafe { atomic_sub(self.v.get(), val, order) }\n     }\n \n     #[inline]\n-    pub fn fetch_and(&self, val: uint, order: Ordering) -> uint {\n+    pub fn fetch_and(&self, val: usize, order: Ordering) -> usize {\n         unsafe { atomic_and(self.v.get(), val, order) }\n     }\n \n     #[inline]\n-    pub fn fetch_or(&self, val: uint, order: Ordering) -> uint {\n+    pub fn fetch_or(&self, val: usize, order: Ordering) -> usize {\n         unsafe { atomic_or(self.v.get(), val, order) }\n     }\n \n     #[inline]\n-    pub fn fetch_xor(&self, val: uint, order: Ordering) -> uint {\n+    pub fn fetch_xor(&self, val: usize, order: Ordering) -> usize {\n         unsafe { atomic_xor(self.v.get(), val, order) }\n     }\n }"}, {"sha": "ee2951602c71e39ad6cce9a36c7cc844ce214143", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -125,7 +125,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n     // otherwise as well.\n     let mut buf = [0; 1536];\n     let mut end = 0;\n-    let radix_gen: T = cast(radix as int).unwrap();\n+    let radix_gen: T = cast(radix as isize).unwrap();\n \n     let (num, exp) = match exp_format {\n         ExpNone => (num, 0),\n@@ -235,7 +235,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n             let extra_digit = ascii2value(buf[end - 1]);\n             end -= 1;\n             if extra_digit >= radix / 2 { // -> need to round\n-                let mut i: int = end as int - 1;\n+                let mut i: isize = end as isize - 1;\n                 loop {\n                     // If reached left end of number, have to\n                     // insert additional digit:"}, {"sha": "e2e5d26d6f7232d4e1987be90073f07fe1e04318", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -315,7 +315,7 @@ extern \"rust-intrinsic\" {\n     /// # #![feature(core)]\n     /// use std::ptr;\n     ///\n-    /// unsafe fn from_buf_raw<T>(ptr: *const T, elts: uint) -> Vec<T> {\n+    /// unsafe fn from_buf_raw<T>(ptr: *const T, elts: usize) -> Vec<T> {\n     ///     let mut dst = Vec::with_capacity(elts);\n     ///     dst.set_len(elts);\n     ///     ptr::copy(dst.as_mut_ptr(), ptr, elts);"}, {"sha": "dc1aef034eb00f0a14e9dd3570b3ebdf284fbfe2", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -63,7 +63,6 @@\n #![allow(raw_pointer_derive)]\n #![deny(missing_docs)]\n \n-#![feature(int_uint)]\n #![feature(intrinsics, lang_items)]\n #![feature(on_unimplemented)]\n #![feature(simd, unsafe_destructor)]"}, {"sha": "d5a7c1d6b26472ac3fb49cadc6e0c764252593c8", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -218,7 +218,7 @@ macro_rules! writeln {\n /// Match arms:\n ///\n /// ```\n-/// fn foo(x: Option<int>) {\n+/// fn foo(x: Option<i32>) {\n ///     match x {\n ///         Some(n) if n >= 0 => println!(\"Some(Non-negative)\"),\n ///         Some(n) if n <  0 => println!(\"Some(Negative)\"),"}, {"sha": "5b660970b8680bd6c3eb58f4de535ad233572839", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -193,12 +193,12 @@ impl Float for f32 {\n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn mantissa_digits(_: Option<f32>) -> uint { MANTISSA_DIGITS as uint }\n+    fn mantissa_digits(_: Option<f32>) -> usize { MANTISSA_DIGITS as usize }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn digits(_: Option<f32>) -> uint { DIGITS as uint }\n+    fn digits(_: Option<f32>) -> usize { DIGITS as usize }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n@@ -208,22 +208,22 @@ impl Float for f32 {\n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn min_exp(_: Option<f32>) -> int { MIN_EXP as int }\n+    fn min_exp(_: Option<f32>) -> isize { MIN_EXP as isize }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn max_exp(_: Option<f32>) -> int { MAX_EXP as int }\n+    fn max_exp(_: Option<f32>) -> isize { MAX_EXP as isize }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn min_10_exp(_: Option<f32>) -> int { MIN_10_EXP as int }\n+    fn min_10_exp(_: Option<f32>) -> isize { MIN_10_EXP as isize }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn max_10_exp(_: Option<f32>) -> int { MAX_10_EXP as int }\n+    fn max_10_exp(_: Option<f32>) -> isize { MAX_10_EXP as isize }\n \n     #[inline]\n     #[unstable(feature = \"core\")]"}, {"sha": "729b9422d5ca103b27c79c226e43f372f52e6169", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -200,12 +200,12 @@ impl Float for f64 {\n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn mantissa_digits(_: Option<f64>) -> uint { MANTISSA_DIGITS as uint }\n+    fn mantissa_digits(_: Option<f64>) -> usize { MANTISSA_DIGITS as usize }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn digits(_: Option<f64>) -> uint { DIGITS as uint }\n+    fn digits(_: Option<f64>) -> usize { DIGITS as usize }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n@@ -215,22 +215,22 @@ impl Float for f64 {\n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn min_exp(_: Option<f64>) -> int { MIN_EXP as int }\n+    fn min_exp(_: Option<f64>) -> isize { MIN_EXP as isize }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn max_exp(_: Option<f64>) -> int { MAX_EXP as int }\n+    fn max_exp(_: Option<f64>) -> isize { MAX_EXP as isize }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn min_10_exp(_: Option<f64>) -> int { MIN_10_EXP as int }\n+    fn min_10_exp(_: Option<f64>) -> isize { MIN_10_EXP as isize }\n \n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\")]\n-    fn max_10_exp(_: Option<f64>) -> int { MAX_10_EXP as int }\n+    fn max_10_exp(_: Option<f64>) -> isize { MAX_10_EXP as isize }\n \n     #[inline]\n     #[unstable(feature = \"core\")]"}, {"sha": "38f067ccb8cff20e420c467fc90a97064c9d18e4", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 51, "deletions": 49, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -52,8 +52,8 @@ pub trait Int\n     + BitAnd<Output=Self>\n     + BitOr<Output=Self>\n     + BitXor<Output=Self>\n-    + Shl<uint, Output=Self>\n-    + Shr<uint, Output=Self>\n+    + Shl<usize, Output=Self>\n+    + Shr<usize, Output=Self>\n     + WrappingOps\n     + OverflowingOps\n {\n@@ -565,7 +565,7 @@ uint_impl! { u64 = u64, 64,\n     intrinsics::u64_mul_with_overflow }\n \n #[cfg(target_pointer_width = \"32\")]\n-uint_impl! { uint = u32, 32,\n+uint_impl! { usize = u32, 32,\n     intrinsics::ctpop32,\n     intrinsics::ctlz32,\n     intrinsics::cttz32,\n@@ -575,7 +575,7 @@ uint_impl! { uint = u32, 32,\n     intrinsics::u32_mul_with_overflow }\n \n #[cfg(target_pointer_width = \"64\")]\n-uint_impl! { uint = u64, 64,\n+uint_impl! { usize = u64, 64,\n     intrinsics::ctpop64,\n     intrinsics::ctlz64,\n     intrinsics::cttz64,\n@@ -680,13 +680,13 @@ int_impl! { i64 = i64, u64, 64,\n     intrinsics::i64_mul_with_overflow }\n \n #[cfg(target_pointer_width = \"32\")]\n-int_impl! { int = i32, u32, 32,\n+int_impl! { isize = i32, u32, 32,\n     intrinsics::i32_add_with_overflow,\n     intrinsics::i32_sub_with_overflow,\n     intrinsics::i32_mul_with_overflow }\n \n #[cfg(target_pointer_width = \"64\")]\n-int_impl! { int = i64, u64, 64,\n+int_impl! { isize = i64, u64, 64,\n     intrinsics::i64_add_with_overflow,\n     intrinsics::i64_sub_with_overflow,\n     intrinsics::i64_mul_with_overflow }\n@@ -752,7 +752,7 @@ signed_int_impl! { i8 }\n signed_int_impl! { i16 }\n signed_int_impl! { i32 }\n signed_int_impl! { i64 }\n-signed_int_impl! { int }\n+signed_int_impl! { isize }\n \n // `Int` + `SignedInt` implemented for signed integers\n macro_rules! int_impl {\n@@ -1232,7 +1232,7 @@ impl i64 {\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { int = i32, u32, 32,\n+    int_impl! { isize = i32, u32, 32,\n         intrinsics::i32_add_with_overflow,\n         intrinsics::i32_sub_with_overflow,\n         intrinsics::i32_mul_with_overflow }\n@@ -1241,7 +1241,7 @@ impl isize {\n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { int = i64, u64, 64,\n+    int_impl! { isize = i64, u64, 64,\n         intrinsics::i64_add_with_overflow,\n         intrinsics::i64_sub_with_overflow,\n         intrinsics::i64_mul_with_overflow }\n@@ -1746,7 +1746,7 @@ impl u64 {\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { uint = u32, 32,\n+    uint_impl! { usize = u32, 32,\n         intrinsics::ctpop32,\n         intrinsics::ctlz32,\n         intrinsics::cttz32,\n@@ -1759,7 +1759,7 @@ impl usize {\n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { uint = u64, 64,\n+    uint_impl! { usize = u64, 64,\n         intrinsics::ctpop64,\n         intrinsics::ctlz64,\n         intrinsics::cttz64,\n@@ -1772,11 +1772,11 @@ impl usize {\n /// A generic trait for converting a value to a number.\n #[unstable(feature = \"core\", reason = \"trait is likely to be removed\")]\n pub trait ToPrimitive {\n-    /// Converts the value of `self` to an `int`.\n+    /// Converts the value of `self` to an `isize`.\n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use to_isize\")]\n-    fn to_int(&self) -> Option<int> {\n+    fn to_int(&self) -> Option<isize> {\n         self.to_i64().and_then(|x| x.to_isize())\n     }\n \n@@ -1807,11 +1807,11 @@ pub trait ToPrimitive {\n     /// Converts the value of `self` to an `i64`.\n     fn to_i64(&self) -> Option<i64>;\n \n-    /// Converts the value of `self` to an `uint`.\n+    /// Converts the value of `self` to an `usize`.\n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use to_usize\")]\n-    fn to_uint(&self) -> Option<uint> {\n+    fn to_uint(&self) -> Option<usize> {\n         self.to_u64().and_then(|x| x.to_usize())\n     }\n \n@@ -1893,7 +1893,7 @@ macro_rules! impl_to_primitive_int {\n     ($T:ty) => (\n         impl ToPrimitive for $T {\n             #[inline]\n-            fn to_int(&self) -> Option<int> { impl_to_primitive_int_to_int!($T, int, *self) }\n+            fn to_int(&self) -> Option<isize> { impl_to_primitive_int_to_int!($T, isize, *self) }\n             #[inline]\n             fn to_isize(&self) -> Option<isize> { impl_to_primitive_int_to_int!($T, isize, *self) }\n             #[inline]\n@@ -1906,7 +1906,7 @@ macro_rules! impl_to_primitive_int {\n             fn to_i64(&self) -> Option<i64> { impl_to_primitive_int_to_int!($T, i64, *self) }\n \n             #[inline]\n-            fn to_uint(&self) -> Option<uint> { impl_to_primitive_int_to_uint!($T, uint, *self) }\n+            fn to_uint(&self) -> Option<usize> { impl_to_primitive_int_to_uint!($T, usize, *self) }\n             #[inline]\n             fn to_usize(&self) -> Option<usize> { impl_to_primitive_int_to_uint!($T, usize, *self) }\n             #[inline]\n@@ -1967,9 +1967,9 @@ macro_rules! impl_to_primitive_uint {\n     ($T:ty) => (\n         impl ToPrimitive for $T {\n             #[inline]\n-            fn to_int(&self) -> Option<int> { impl_to_primitive_uint_to_int!(int, *self) }\n+            fn to_int(&self) -> Option<isize> { impl_to_primitive_uint_to_int!(isize, *self) }\n             #[inline]\n-            fn to_isize(&self) -> Option<int> { impl_to_primitive_uint_to_int!(isize, *self) }\n+            fn to_isize(&self) -> Option<isize> { impl_to_primitive_uint_to_int!(isize, *self) }\n             #[inline]\n             fn to_i8(&self) -> Option<i8> { impl_to_primitive_uint_to_int!(i8, *self) }\n             #[inline]\n@@ -1980,9 +1980,11 @@ macro_rules! impl_to_primitive_uint {\n             fn to_i64(&self) -> Option<i64> { impl_to_primitive_uint_to_int!(i64, *self) }\n \n             #[inline]\n-            fn to_uint(&self) -> Option<uint> { impl_to_primitive_uint_to_uint!($T, uint, *self) }\n+            fn to_uint(&self) -> Option<usize> { impl_to_primitive_uint_to_uint!($T, usize, *self) }\n             #[inline]\n-            fn to_usize(&self) -> Option<uint> { impl_to_primitive_uint_to_uint!($T, usize, *self) }\n+            fn to_usize(&self) -> Option<usize> {\n+                impl_to_primitive_uint_to_uint!($T, usize, *self)\n+            }\n             #[inline]\n             fn to_u8(&self) -> Option<u8> { impl_to_primitive_uint_to_uint!($T, u8, *self) }\n             #[inline]\n@@ -2026,9 +2028,9 @@ macro_rules! impl_to_primitive_float {\n     ($T:ident) => (\n         impl ToPrimitive for $T {\n             #[inline]\n-            fn to_int(&self) -> Option<int> { Some(*self as int) }\n+            fn to_int(&self) -> Option<isize> { Some(*self as isize) }\n             #[inline]\n-            fn to_isize(&self) -> Option<int> { Some(*self as isize) }\n+            fn to_isize(&self) -> Option<isize> { Some(*self as isize) }\n             #[inline]\n             fn to_i8(&self) -> Option<i8> { Some(*self as i8) }\n             #[inline]\n@@ -2039,9 +2041,9 @@ macro_rules! impl_to_primitive_float {\n             fn to_i64(&self) -> Option<i64> { Some(*self as i64) }\n \n             #[inline]\n-            fn to_uint(&self) -> Option<uint> { Some(*self as uint) }\n+            fn to_uint(&self) -> Option<usize> { Some(*self as usize) }\n             #[inline]\n-            fn to_usize(&self) -> Option<uint> { Some(*self as usize) }\n+            fn to_usize(&self) -> Option<usize> { Some(*self as usize) }\n             #[inline]\n             fn to_u8(&self) -> Option<u8> { Some(*self as u8) }\n             #[inline]\n@@ -2065,12 +2067,12 @@ impl_to_primitive_float! { f64 }\n /// A generic trait for converting a number to a value.\n #[unstable(feature = \"core\", reason = \"trait is likely to be removed\")]\n pub trait FromPrimitive : ::marker::Sized {\n-    /// Convert an `int` to return an optional value of this type. If the\n+    /// Convert an `isize` to return an optional value of this type. If the\n     /// value cannot be represented by this value, the `None` is returned.\n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use from_isize\")]\n-    fn from_int(n: int) -> Option<Self> {\n+    fn from_int(n: isize) -> Option<Self> {\n         FromPrimitive::from_i64(n as i64)\n     }\n \n@@ -2106,12 +2108,12 @@ pub trait FromPrimitive : ::marker::Sized {\n     /// type cannot be represented by this value, the `None` is returned.\n     fn from_i64(n: i64) -> Option<Self>;\n \n-    /// Convert an `uint` to return an optional value of this type. If the\n+    /// Convert an `usize` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     #[inline]\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use from_usize\")]\n-    fn from_uint(n: uint) -> Option<Self> {\n+    fn from_uint(n: usize) -> Option<Self> {\n         FromPrimitive::from_u64(n as u64)\n     }\n \n@@ -2165,7 +2167,7 @@ pub trait FromPrimitive : ::marker::Sized {\n /// A utility function that just calls `FromPrimitive::from_int`.\n #[unstable(feature = \"core\", reason = \"likely to be removed\")]\n #[deprecated(since = \"1.0.0\", reason = \"use from_isize\")]\n-pub fn from_int<A: FromPrimitive>(n: int) -> Option<A> {\n+pub fn from_int<A: FromPrimitive>(n: isize) -> Option<A> {\n     FromPrimitive::from_isize(n)\n }\n \n@@ -2202,7 +2204,7 @@ pub fn from_i64<A: FromPrimitive>(n: i64) -> Option<A> {\n /// A utility function that just calls `FromPrimitive::from_uint`.\n #[unstable(feature = \"core\", reason = \"likely to be removed\")]\n #[deprecated(since = \"1.0.0\", reason = \"use from_uint\")]\n-pub fn from_uint<A: FromPrimitive>(n: uint) -> Option<A> {\n+pub fn from_uint<A: FromPrimitive>(n: usize) -> Option<A> {\n     FromPrimitive::from_usize(n)\n }\n \n@@ -2252,13 +2254,13 @@ macro_rules! impl_from_primitive {\n     ($T:ty, $to_ty:ident) => (\n         #[allow(deprecated)]\n         impl FromPrimitive for $T {\n-            #[inline] fn from_int(n: int) -> Option<$T> { n.$to_ty() }\n+            #[inline] fn from_int(n: isize) -> Option<$T> { n.$to_ty() }\n             #[inline] fn from_i8(n: i8) -> Option<$T> { n.$to_ty() }\n             #[inline] fn from_i16(n: i16) -> Option<$T> { n.$to_ty() }\n             #[inline] fn from_i32(n: i32) -> Option<$T> { n.$to_ty() }\n             #[inline] fn from_i64(n: i64) -> Option<$T> { n.$to_ty() }\n \n-            #[inline] fn from_uint(n: uint) -> Option<$T> { n.$to_ty() }\n+            #[inline] fn from_uint(n: usize) -> Option<$T> { n.$to_ty() }\n             #[inline] fn from_u8(n: u8) -> Option<$T> { n.$to_ty() }\n             #[inline] fn from_u16(n: u16) -> Option<$T> { n.$to_ty() }\n             #[inline] fn from_u32(n: u32) -> Option<$T> { n.$to_ty() }\n@@ -2270,12 +2272,12 @@ macro_rules! impl_from_primitive {\n     )\n }\n \n-impl_from_primitive! { int, to_int }\n+impl_from_primitive! { isize, to_int }\n impl_from_primitive! { i8, to_i8 }\n impl_from_primitive! { i16, to_i16 }\n impl_from_primitive! { i32, to_i32 }\n impl_from_primitive! { i64, to_i64 }\n-impl_from_primitive! { uint, to_uint }\n+impl_from_primitive! { usize, to_uint }\n impl_from_primitive! { u8, to_u8 }\n impl_from_primitive! { u16, to_u16 }\n impl_from_primitive! { u32, to_u32 }\n@@ -2327,12 +2329,12 @@ impl_num_cast! { u8,    to_u8 }\n impl_num_cast! { u16,   to_u16 }\n impl_num_cast! { u32,   to_u32 }\n impl_num_cast! { u64,   to_u64 }\n-impl_num_cast! { uint,  to_uint }\n+impl_num_cast! { usize,  to_uint }\n impl_num_cast! { i8,    to_i8 }\n impl_num_cast! { i16,   to_i16 }\n impl_num_cast! { i32,   to_i32 }\n impl_num_cast! { i64,   to_i64 }\n-impl_num_cast! { int,   to_int }\n+impl_num_cast! { isize,   to_int }\n impl_num_cast! { f32,   to_f32 }\n impl_num_cast! { f64,   to_f64 }\n \n@@ -2392,12 +2394,12 @@ pub trait Float\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MANTISSA_DIGITS` or \\\n                            `std::f64::MANTISSA_DIGITS` as appropriate\")]\n-    fn mantissa_digits(unused_self: Option<Self>) -> uint;\n+    fn mantissa_digits(unused_self: Option<Self>) -> usize;\n     /// Returns the number of base-10 digits of precision that this type supports.\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\")]\n-    fn digits(unused_self: Option<Self>) -> uint;\n+    fn digits(unused_self: Option<Self>) -> usize;\n     /// Returns the difference between 1.0 and the smallest representable number larger than 1.0.\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\",\n@@ -2407,22 +2409,22 @@ pub trait Float\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\")]\n-    fn min_exp(unused_self: Option<Self>) -> int;\n+    fn min_exp(unused_self: Option<Self>) -> isize;\n     /// Returns the maximum binary exponent that this type can represent.\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\")]\n-    fn max_exp(unused_self: Option<Self>) -> int;\n+    fn max_exp(unused_self: Option<Self>) -> isize;\n     /// Returns the minimum base-10 exponent that this type can represent.\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\")]\n-    fn min_10_exp(unused_self: Option<Self>) -> int;\n+    fn min_10_exp(unused_self: Option<Self>) -> isize;\n     /// Returns the maximum base-10 exponent that this type can represent.\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\")]\n-    fn max_10_exp(unused_self: Option<Self>) -> int;\n+    fn max_10_exp(unused_self: Option<Self>) -> isize;\n     /// Returns the smallest finite value that this type can represent.\n     #[unstable(feature = \"core\")]\n     #[deprecated(since = \"1.0.0\",\n@@ -2625,7 +2627,7 @@ macro_rules! from_str_radix_float_impl {\n                 let mut prev_sig = sig;\n                 let mut cs = src.chars().enumerate();\n                 // Exponent prefix and exponent index offset\n-                let mut exp_info = None::<(char, uint)>;\n+                let mut exp_info = None::<(char, usize)>;\n \n                 // Parse the integer part of the significand\n                 for (i, c) in cs.by_ref() {\n@@ -2636,9 +2638,9 @@ macro_rules! from_str_radix_float_impl {\n \n                             // add/subtract current digit depending on sign\n                             if is_positive {\n-                                sig = sig + ((digit as int) as $T);\n+                                sig = sig + ((digit as isize) as $T);\n                             } else {\n-                                sig = sig - ((digit as int) as $T);\n+                                sig = sig - ((digit as isize) as $T);\n                             }\n \n                             // Detect overflow by comparing to last value, except\n@@ -2719,9 +2721,9 @@ macro_rules! from_str_radix_float_impl {\n                         // Parse the exponent as decimal integer\n                         let src = &src[offset..];\n                         let (is_positive, exp) = match src.slice_shift_char() {\n-                            Some(('-', src)) => (false, src.parse::<uint>()),\n-                            Some(('+', src)) => (true,  src.parse::<uint>()),\n-                            Some((_, _))     => (true,  src.parse::<uint>()),\n+                            Some(('-', src)) => (false, src.parse::<usize>()),\n+                            Some(('+', src)) => (true,  src.parse::<usize>()),\n+                            Some((_, _))     => (true,  src.parse::<usize>()),\n                             None             => return Err(PFE { kind: Invalid }),\n                         };\n "}, {"sha": "7e02c71a2a01eb49706e70ed5a0b490f7dc73936", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -64,7 +64,7 @@ macro_rules! wrapping_impl {\n     )*)\n }\n \n-wrapping_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n+wrapping_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n \n #[unstable(feature = \"core\", reason = \"may be removed, renamed, or relocated\")]\n #[derive(PartialEq,Eq,PartialOrd,Ord,Clone,Copy)]\n@@ -132,20 +132,20 @@ impl<T:WrappingOps+BitAnd<Output=T>> BitAnd for Wrapping<T> {\n     }\n }\n \n-impl<T:WrappingOps+Shl<uint,Output=T>> Shl<uint> for Wrapping<T> {\n+impl<T:WrappingOps+Shl<usize,Output=T>> Shl<usize> for Wrapping<T> {\n     type Output = Wrapping<T>;\n \n     #[inline(always)]\n-    fn shl(self, other: uint) -> Wrapping<T> {\n+    fn shl(self, other: usize) -> Wrapping<T> {\n         Wrapping(self.0 << other)\n     }\n }\n \n-impl<T:WrappingOps+Shr<uint,Output=T>> Shr<uint> for Wrapping<T> {\n+impl<T:WrappingOps+Shr<usize,Output=T>> Shr<usize> for Wrapping<T> {\n     type Output = Wrapping<T>;\n \n     #[inline(always)]\n-    fn shr(self, other: uint) -> Wrapping<T> {\n+    fn shr(self, other: usize) -> Wrapping<T> {\n         Wrapping(self.0 >> other)\n     }\n }"}, {"sha": "d6e00df1fd7955ea88f773bef85ad4f7b80afb1b", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -16,7 +16,7 @@\n //! interface for panicking is:\n //!\n //! ```ignore\n-//! fn panic_impl(fmt: fmt::Arguments, &(&'static str, uint)) -> !;\n+//! fn panic_impl(fmt: fmt::Arguments, &(&'static str, usize)) -> !;\n //! ```\n //!\n //! This definition allows for panicking with any general message, but it does not\n@@ -58,8 +58,8 @@ pub fn panic_fmt(fmt: fmt::Arguments, file_line: &(&'static str, u32)) -> ! {\n     #[allow(improper_ctypes)]\n     extern {\n         #[lang = \"panic_fmt\"]\n-        fn panic_impl(fmt: fmt::Arguments, file: &'static str, line: uint) -> !;\n+        fn panic_impl(fmt: fmt::Arguments, file: &'static str, line: usize) -> !;\n     }\n     let (file, line) = *file_line;\n-    unsafe { panic_impl(fmt, file, line as uint) }\n+    unsafe { panic_impl(fmt, file, line as usize) }\n }"}, {"sha": "c17a13493703d7515fe258263acf5e814edd78aa", "filename": "src/libcore/result.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -60,22 +60,22 @@\n //! that make working with it more succinct.\n //!\n //! ```\n-//! let good_result: Result<int, int> = Ok(10);\n-//! let bad_result: Result<int, int> = Err(10);\n+//! let good_result: Result<i32, i32> = Ok(10);\n+//! let bad_result: Result<i32, i32> = Err(10);\n //!\n //! // The `is_ok` and `is_err` methods do what they say.\n //! assert!(good_result.is_ok() && !good_result.is_err());\n //! assert!(bad_result.is_err() && !bad_result.is_ok());\n //!\n //! // `map` consumes the `Result` and produces another.\n-//! let good_result: Result<int, int> = good_result.map(|i| i + 1);\n-//! let bad_result: Result<int, int> = bad_result.map(|i| i - 1);\n+//! let good_result: Result<i32, i32> = good_result.map(|i| i + 1);\n+//! let bad_result: Result<i32, i32> = bad_result.map(|i| i - 1);\n //!\n //! // Use `and_then` to continue the computation.\n-//! let good_result: Result<bool, int> = good_result.and_then(|i| Ok(i == 11));\n+//! let good_result: Result<bool, i32> = good_result.and_then(|i| Ok(i == 11));\n //!\n //! // Use `or_else` to handle the error.\n-//! let bad_result: Result<int, int> = bad_result.or_else(|i| Ok(11));\n+//! let bad_result: Result<i32, i32> = bad_result.or_else(|i| Ok(11));\n //!\n //! // Consume the result and return the contents with `unwrap`.\n //! let final_awesome_result = good_result.unwrap();\n@@ -182,8 +182,8 @@\n //!\n //! struct Info {\n //!     name: String,\n-//!     age: int,\n-//!     rating: int\n+//!     age: i32,\n+//!     rating: i32,\n //! }\n //!\n //! fn write_info(info: &Info) -> Result<(), IoError> {\n@@ -208,8 +208,8 @@\n //!\n //! struct Info {\n //!     name: String,\n-//!     age: int,\n-//!     rating: int\n+//!     age: i32,\n+//!     rating: i32,\n //! }\n //!\n //! fn write_info(info: &Info) -> Result<(), IoError> {\n@@ -282,10 +282,10 @@ impl<T, E> Result<T, E> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let x: Result<int, &str> = Ok(-3);\n+    /// let x: Result<i32, &str> = Ok(-3);\n     /// assert_eq!(x.is_ok(), true);\n     ///\n-    /// let x: Result<int, &str> = Err(\"Some error message\");\n+    /// let x: Result<i32, &str> = Err(\"Some error message\");\n     /// assert_eq!(x.is_ok(), false);\n     /// ```\n     #[inline]\n@@ -302,10 +302,10 @@ impl<T, E> Result<T, E> {\n     /// # Examples\n     ///\n     /// ```\n-    /// let x: Result<int, &str> = Ok(-3);\n+    /// let x: Result<i32, &str> = Ok(-3);\n     /// assert_eq!(x.is_err(), false);\n     ///\n-    /// let x: Result<int, &str> = Err(\"Some error message\");\n+    /// let x: Result<i32, &str> = Err(\"Some error message\");\n     /// assert_eq!(x.is_err(), true);\n     /// ```\n     #[inline]\n@@ -392,18 +392,18 @@ impl<T, E> Result<T, E> {\n     /// Convert from `Result<T, E>` to `Result<&mut T, &mut E>`\n     ///\n     /// ```\n-    /// fn mutate(r: &mut Result<int, int>) {\n+    /// fn mutate(r: &mut Result<i32, i32>) {\n     ///     match r.as_mut() {\n     ///         Ok(&mut ref mut v) => *v = 42,\n     ///         Err(&mut ref mut e) => *e = 0,\n     ///     }\n     /// }\n     ///\n-    /// let mut x: Result<int, int> = Ok(2);\n+    /// let mut x: Result<i32, i32> = Ok(2);\n     /// mutate(&mut x);\n     /// assert_eq!(x.unwrap(), 42);\n     ///\n-    /// let mut x: Result<int, int> = Err(13);\n+    /// let mut x: Result<i32, i32> = Err(13);\n     /// mutate(&mut x);\n     /// assert_eq!(x.unwrap_err(), 0);\n     /// ```\n@@ -486,8 +486,8 @@ impl<T, E> Result<T, E> {\n     /// while !buffer.is_empty() {\n     ///     let line: IoResult<String> = buffer.read_line();\n     ///     // Convert the string line to a number using `map` and `from_str`\n-    ///     let val: IoResult<int> = line.map(|line| {\n-    ///         line.trim_right().parse::<int>().unwrap_or(0)\n+    ///     let val: IoResult<i32> = line.map(|line| {\n+    ///         line.trim_right().parse::<i32>().unwrap_or(0)\n     ///     });\n     ///     // Add the value if there were no errors, otherwise add 0\n     ///     sum += val.unwrap_or(0);"}, {"sha": "1f8e73e9ddcc542170ad98c227f6739a28c1e8f9", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -1704,7 +1704,7 @@ impl StrExt for str {\n     #[inline]\n     unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n         mem::transmute(Slice {\n-            data: self.as_ptr().offset(begin as int),\n+            data: self.as_ptr().offset(begin as isize),\n             len: end - begin,\n         })\n     }"}, {"sha": "eeaaa3e217e8f1c80bbb0aca874f3f688c3c42ce", "filename": "src/libcoretest/any.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcoretest%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcoretest%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fany.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -37,9 +37,9 @@ fn any_referenced() {\n fn any_owning() {\n     let (a, b, c) = (box 5_usize as Box<Any>, box TEST as Box<Any>, box Test as Box<Any>);\n \n-    assert!(a.is::<uint>());\n-    assert!(!b.is::<uint>());\n-    assert!(!c.is::<uint>());\n+    assert!(a.is::<usize>());\n+    assert!(!b.is::<usize>());\n+    assert!(!c.is::<usize>());\n \n     assert!(!a.is::<&'static str>());\n     assert!(b.is::<&'static str>());\n@@ -54,7 +54,7 @@ fn any_owning() {\n fn any_downcast_ref() {\n     let a = &5_usize as &Any;\n \n-    match a.downcast_ref::<uint>() {\n+    match a.downcast_ref::<usize>() {\n         Some(&5) => {}\n         x => panic!(\"Unexpected value {:?}\", x)\n     }\n@@ -71,18 +71,18 @@ fn any_downcast_mut() {\n     let mut b: Box<_> = box 7_usize;\n \n     let a_r = &mut a as &mut Any;\n-    let tmp: &mut uint = &mut *b;\n+    let tmp: &mut usize = &mut *b;\n     let b_r = tmp as &mut Any;\n \n-    match a_r.downcast_mut::<uint>() {\n+    match a_r.downcast_mut::<usize>() {\n         Some(x) => {\n             assert_eq!(*x, 5);\n             *x = 612;\n         }\n         x => panic!(\"Unexpected value {:?}\", x)\n     }\n \n-    match b_r.downcast_mut::<uint>() {\n+    match b_r.downcast_mut::<usize>() {\n         Some(x) => {\n             assert_eq!(*x, 7);\n             *x = 413;\n@@ -100,12 +100,12 @@ fn any_downcast_mut() {\n         x => panic!(\"Unexpected value {:?}\", x)\n     }\n \n-    match a_r.downcast_mut::<uint>() {\n+    match a_r.downcast_mut::<usize>() {\n         Some(&mut 612) => {}\n         x => panic!(\"Unexpected value {:?}\", x)\n     }\n \n-    match b_r.downcast_mut::<uint>() {\n+    match b_r.downcast_mut::<usize>() {\n         Some(&mut 413) => {}\n         x => panic!(\"Unexpected value {:?}\", x)\n     }\n@@ -115,8 +115,8 @@ fn any_downcast_mut() {\n fn any_fixed_vec() {\n     let test = [0_usize; 8];\n     let test = &test as &Any;\n-    assert!(test.is::<[uint; 8]>());\n-    assert!(!test.is::<[uint; 10]>());\n+    assert!(test.is::<[usize; 8]>());\n+    assert!(!test.is::<[usize; 10]>());\n }\n \n \n@@ -126,6 +126,6 @@ fn bench_downcast_ref(b: &mut Bencher) {\n         let mut x = 0;\n         let mut y = &mut x as &mut Any;\n         test::black_box(&mut y);\n-        test::black_box(y.downcast_ref::<int>() == Some(&0));\n+        test::black_box(y.downcast_ref::<isize>() == Some(&0));\n     });\n }"}, {"sha": "fff3cc14eadfd45fb4127f3ea800c7a4ad39fae6", "filename": "src/libcoretest/cell.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -134,19 +134,19 @@ fn clone_ref_updates_flag() {\n \n #[test]\n fn as_unsafe_cell() {\n-    let c1: Cell<uint> = Cell::new(0);\n+    let c1: Cell<usize> = Cell::new(0);\n     c1.set(1);\n     assert_eq!(1, unsafe { *c1.as_unsafe_cell().get() });\n \n-    let c2: Cell<uint> = Cell::new(0);\n+    let c2: Cell<usize> = Cell::new(0);\n     unsafe { *c2.as_unsafe_cell().get() = 1; }\n     assert_eq!(1, c2.get());\n \n-    let r1: RefCell<uint> = RefCell::new(0);\n+    let r1: RefCell<usize> = RefCell::new(0);\n     *r1.borrow_mut() = 1;\n     assert_eq!(1, unsafe { *r1.as_unsafe_cell().get() });\n \n-    let r2: RefCell<uint> = RefCell::new(0);\n+    let r2: RefCell<usize> = RefCell::new(0);\n     unsafe { *r2.as_unsafe_cell().get() = 1; }\n     assert_eq!(1, *r2.borrow());\n }"}, {"sha": "9ed1508c3eb7877c23b0831682569562ddea5a5f", "filename": "src/libcoretest/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcoretest%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcoretest%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcmp.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -114,7 +114,7 @@ fn test_user_defined_eq() {\n \n     // Our type.\n     struct SketchyNum {\n-        num : int\n+        num : isize\n     }\n \n     // Our implementation of `PartialEq` to support `==` and `!=`."}, {"sha": "15938a5dcb4770bdac1d5b59c2856db5dc580ff5", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -19,7 +19,7 @@ use test::Bencher;\n \n #[test]\n fn test_lt() {\n-    let empty: [int; 0] = [];\n+    let empty: [isize; 0] = [];\n     let xs = [1,2,3];\n     let ys = [1,2,0];\n \n@@ -73,7 +73,7 @@ fn test_multi_iter() {\n #[test]\n fn test_counter_from_iter() {\n     let it = count(0, 5).take(10);\n-    let xs: Vec<int> = FromIterator::from_iter(it);\n+    let xs: Vec<isize> = FromIterator::from_iter(it);\n     assert_eq!(xs, [0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n }\n \n@@ -104,7 +104,7 @@ fn test_iterator_chain() {\n fn test_filter_map() {\n     let it = count(0, 1).take(10)\n         .filter_map(|x| if x % 2 == 0 { Some(x*x) } else { None });\n-    assert_eq!(it.collect::<Vec<uint>>(), [0*0, 2*2, 4*4, 6*6, 8*8]);\n+    assert_eq!(it.collect::<Vec<usize>>(), [0*0, 2*2, 4*4, 6*6, 8*8]);\n }\n \n #[test]\n@@ -224,8 +224,8 @@ fn test_iterator_take_short() {\n #[test]\n fn test_iterator_scan() {\n     // test the type inference\n-    fn add(old: &mut int, new: &uint) -> Option<f64> {\n-        *old += *new as int;\n+    fn add(old: &mut isize, new: &usize) -> Option<f64> {\n+        *old += *new as isize;\n         Some(*old as f64)\n     }\n     let xs = [0, 1, 2, 3, 4];\n@@ -261,15 +261,15 @@ fn test_inspect() {\n     let ys = xs.iter()\n                .cloned()\n                .inspect(|_| n += 1)\n-               .collect::<Vec<uint>>();\n+               .collect::<Vec<usize>>();\n \n     assert_eq!(n, xs.len());\n     assert_eq!(&xs[..], &ys[..]);\n }\n \n #[test]\n fn test_unfoldr() {\n-    fn count(st: &mut uint) -> Option<uint> {\n+    fn count(st: &mut usize) -> Option<usize> {\n         if *st < 10 {\n             let ret = Some(*st);\n             *st += 1;\n@@ -398,14 +398,14 @@ fn test_iterator_size_hint() {\n #[test]\n fn test_collect() {\n     let a = vec![1, 2, 3, 4, 5];\n-    let b: Vec<int> = a.iter().cloned().collect();\n+    let b: Vec<isize> = a.iter().cloned().collect();\n     assert!(a == b);\n }\n \n #[test]\n fn test_all() {\n     // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n-    let v: Box<[int]> = Box::new([1, 2, 3, 4, 5]);\n+    let v: Box<[isize]> = Box::new([1, 2, 3, 4, 5]);\n     assert!(v.iter().all(|&x| x < 10));\n     assert!(!v.iter().all(|&x| x % 2 == 0));\n     assert!(!v.iter().all(|&x| x > 100));\n@@ -415,7 +415,7 @@ fn test_all() {\n #[test]\n fn test_any() {\n     // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n-    let v: Box<[int]> = Box::new([1, 2, 3, 4, 5]);\n+    let v: Box<[isize]> = Box::new([1, 2, 3, 4, 5]);\n     assert!(v.iter().any(|&x| x < 10));\n     assert!(v.iter().any(|&x| x % 2 == 0));\n     assert!(!v.iter().any(|&x| x > 100));\n@@ -424,7 +424,7 @@ fn test_any() {\n \n #[test]\n fn test_find() {\n-    let v: &[int] = &[1, 3, 9, 27, 103, 14, 11];\n+    let v: &[isize] = &[1, 3, 9, 27, 103, 14, 11];\n     assert_eq!(*v.iter().find(|&&x| x & 1 == 0).unwrap(), 14);\n     assert_eq!(*v.iter().find(|&&x| x % 3 == 0).unwrap(), 3);\n     assert!(v.iter().find(|&&x| x % 12 == 0).is_none());\n@@ -448,13 +448,13 @@ fn test_count() {\n \n #[test]\n fn test_max_by() {\n-    let xs: &[int] = &[-3, 0, 1, 5, -10];\n+    let xs: &[isize] = &[-3, 0, 1, 5, -10];\n     assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n }\n \n #[test]\n fn test_min_by() {\n-    let xs: &[int] = &[-3, 0, 1, 5, -10];\n+    let xs: &[isize] = &[-3, 0, 1, 5, -10];\n     assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n }\n \n@@ -473,7 +473,7 @@ fn test_rev() {\n     let mut it = xs.iter();\n     it.next();\n     it.next();\n-    assert!(it.rev().cloned().collect::<Vec<int>>() ==\n+    assert!(it.rev().cloned().collect::<Vec<isize>>() ==\n             vec![16, 14, 12, 10, 8, 6]);\n }\n \n@@ -572,8 +572,8 @@ fn test_double_ended_chain() {\n \n #[test]\n fn test_rposition() {\n-    fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n-    fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n+    fn f(xy: &(isize, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n+    fn g(xy: &(isize, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n     let v = [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n     assert_eq!(v.iter().rposition(f), Some(3));\n@@ -598,7 +598,7 @@ fn test_rposition_panic() {\n \n \n #[cfg(test)]\n-fn check_randacc_iter<A, T>(a: T, len: uint) where\n+fn check_randacc_iter<A, T>(a: T, len: usize) where\n     A: PartialEq,\n     T: Clone + RandomAccessIterator + Iterator<Item=A>,\n {\n@@ -684,7 +684,7 @@ fn test_random_access_zip() {\n #[test]\n fn test_random_access_take() {\n     let xs = [1, 2, 3, 4, 5];\n-    let empty: &[int] = &[];\n+    let empty: &[isize] = &[];\n     check_randacc_iter(xs.iter().take(3), 3);\n     check_randacc_iter(xs.iter().take(20), xs.len());\n     check_randacc_iter(xs.iter().take(0), 0);\n@@ -694,7 +694,7 @@ fn test_random_access_take() {\n #[test]\n fn test_random_access_skip() {\n     let xs = [1, 2, 3, 4, 5];\n-    let empty: &[int] = &[];\n+    let empty: &[isize] = &[];\n     check_randacc_iter(xs.iter().skip(2), xs.len() - 2);\n     check_randacc_iter(empty.iter().skip(2), 0);\n }\n@@ -726,7 +726,7 @@ fn test_random_access_map() {\n #[test]\n fn test_random_access_cycle() {\n     let xs = [1, 2, 3, 4, 5];\n-    let empty: &[int] = &[];\n+    let empty: &[isize] = &[];\n     check_randacc_iter(xs.iter().cycle().take(27), 27);\n     check_randacc_iter(empty.iter().cycle(), 0);\n }\n@@ -755,42 +755,42 @@ fn test_range() {\n     assert_eq!((200..200).rev().count(), 0);\n \n     assert_eq!((0..100).size_hint(), (100, Some(100)));\n-    // this test is only meaningful when sizeof uint < sizeof u64\n+    // this test is only meaningful when sizeof usize < sizeof u64\n     assert_eq!((usize::MAX - 1..usize::MAX).size_hint(), (1, Some(1)));\n     assert_eq!((-10..-1).size_hint(), (9, Some(9)));\n     assert_eq!((-1..-10).size_hint(), (0, Some(0)));\n }\n \n #[test]\n fn test_range_inclusive() {\n-    assert!(range_inclusive(0, 5).collect::<Vec<int>>() ==\n+    assert!(range_inclusive(0, 5).collect::<Vec<isize>>() ==\n             vec![0, 1, 2, 3, 4, 5]);\n-    assert!(range_inclusive(0, 5).rev().collect::<Vec<int>>() ==\n+    assert!(range_inclusive(0, 5).rev().collect::<Vec<isize>>() ==\n             vec![5, 4, 3, 2, 1, 0]);\n     assert_eq!(range_inclusive(200, -5).count(), 0);\n     assert_eq!(range_inclusive(200, -5).rev().count(), 0);\n-    assert_eq!(range_inclusive(200, 200).collect::<Vec<int>>(), [200]);\n-    assert_eq!(range_inclusive(200, 200).rev().collect::<Vec<int>>(), [200]);\n+    assert_eq!(range_inclusive(200, 200).collect::<Vec<isize>>(), [200]);\n+    assert_eq!(range_inclusive(200, 200).rev().collect::<Vec<isize>>(), [200]);\n }\n \n #[test]\n fn test_range_step() {\n-    assert_eq!((0..20).step_by(5).collect::<Vec<int>>(), [0, 5, 10, 15]);\n-    assert_eq!((20..0).step_by(-5).collect::<Vec<int>>(), [20, 15, 10, 5]);\n-    assert_eq!((20..0).step_by(-6).collect::<Vec<int>>(), [20, 14, 8, 2]);\n+    assert_eq!((0..20).step_by(5).collect::<Vec<isize>>(), [0, 5, 10, 15]);\n+    assert_eq!((20..0).step_by(-5).collect::<Vec<isize>>(), [20, 15, 10, 5]);\n+    assert_eq!((20..0).step_by(-6).collect::<Vec<isize>>(), [20, 14, 8, 2]);\n     assert_eq!((200..255).step_by(50).collect::<Vec<u8>>(), [200, 250]);\n-    assert_eq!((200..-5).step_by(1).collect::<Vec<int>>(), []);\n-    assert_eq!((200..200).step_by(1).collect::<Vec<int>>(), []);\n+    assert_eq!((200..-5).step_by(1).collect::<Vec<isize>>(), []);\n+    assert_eq!((200..200).step_by(1).collect::<Vec<isize>>(), []);\n }\n \n #[test]\n fn test_range_step_inclusive() {\n-    assert_eq!(range_step_inclusive(0, 20, 5).collect::<Vec<int>>(), [0, 5, 10, 15, 20]);\n-    assert_eq!(range_step_inclusive(20, 0, -5).collect::<Vec<int>>(), [20, 15, 10, 5, 0]);\n-    assert_eq!(range_step_inclusive(20, 0, -6).collect::<Vec<int>>(), [20, 14, 8, 2]);\n+    assert_eq!(range_step_inclusive(0, 20, 5).collect::<Vec<isize>>(), [0, 5, 10, 15, 20]);\n+    assert_eq!(range_step_inclusive(20, 0, -5).collect::<Vec<isize>>(), [20, 15, 10, 5, 0]);\n+    assert_eq!(range_step_inclusive(20, 0, -6).collect::<Vec<isize>>(), [20, 14, 8, 2]);\n     assert_eq!(range_step_inclusive(200, 255, 50).collect::<Vec<u8>>(), [200, 250]);\n-    assert_eq!(range_step_inclusive(200, -5, 1).collect::<Vec<int>>(), []);\n-    assert_eq!(range_step_inclusive(200, 200, 1).collect::<Vec<int>>(), [200]);\n+    assert_eq!(range_step_inclusive(200, -5, 1).collect::<Vec<isize>>(), []);\n+    assert_eq!(range_step_inclusive(200, 200, 1).collect::<Vec<isize>>(), [200]);\n }\n \n #[test]\n@@ -811,7 +811,7 @@ fn test_peekable_is_empty() {\n \n #[test]\n fn test_min_max() {\n-    let v: [int; 0] = [];\n+    let v: [isize; 0] = [];\n     assert_eq!(v.iter().min_max(), NoElements);\n \n     let v = [1];\n@@ -829,7 +829,7 @@ fn test_min_max() {\n \n #[test]\n fn test_min_max_result() {\n-    let r: MinMaxResult<int> = NoElements;\n+    let r: MinMaxResult<isize> = NoElements;\n     assert_eq!(r.into_option(), None);\n \n     let r = OneElement(1);\n@@ -876,7 +876,7 @@ fn test_fuse() {\n \n #[bench]\n fn bench_rposition(b: &mut Bencher) {\n-    let it: Vec<uint> = (0..300).collect();\n+    let it: Vec<usize> = (0..300).collect();\n     b.iter(|| {\n         it.iter().rposition(|&x| x <= 150);\n     });"}, {"sha": "fae36787c3dadf66df71995ae64b02ea9ad584c7", "filename": "src/libcoretest/mem.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcoretest%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcoretest%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fmem.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -21,15 +21,15 @@ fn size_of_basic() {\n #[test]\n #[cfg(target_pointer_width = \"32\")]\n fn size_of_32() {\n-    assert_eq!(size_of::<uint>(), 4);\n-    assert_eq!(size_of::<*const uint>(), 4);\n+    assert_eq!(size_of::<usize>(), 4);\n+    assert_eq!(size_of::<*const usize>(), 4);\n }\n \n #[test]\n #[cfg(target_pointer_width = \"64\")]\n fn size_of_64() {\n-    assert_eq!(size_of::<uint>(), 8);\n-    assert_eq!(size_of::<*const uint>(), 8);\n+    assert_eq!(size_of::<usize>(), 8);\n+    assert_eq!(size_of::<*const usize>(), 8);\n }\n \n #[test]\n@@ -50,15 +50,15 @@ fn align_of_basic() {\n #[test]\n #[cfg(target_pointer_width = \"32\")]\n fn align_of_32() {\n-    assert_eq!(align_of::<uint>(), 4);\n-    assert_eq!(align_of::<*const uint>(), 4);\n+    assert_eq!(align_of::<usize>(), 4);\n+    assert_eq!(align_of::<*const usize>(), 4);\n }\n \n #[test]\n #[cfg(target_pointer_width = \"64\")]\n fn align_of_64() {\n-    assert_eq!(align_of::<uint>(), 8);\n-    assert_eq!(align_of::<*const uint>(), 8);\n+    assert_eq!(align_of::<usize>(), 8);\n+    assert_eq!(align_of::<*const usize>(), 8);\n }\n \n #[test]\n@@ -93,12 +93,12 @@ fn test_transmute_copy() {\n #[test]\n fn test_transmute() {\n     trait Foo { fn dummy(&self) { } }\n-    impl Foo for int {}\n+    impl Foo for isize {}\n \n     let a = box 100isize as Box<Foo>;\n     unsafe {\n         let x: ::core::raw::TraitObject = transmute(a);\n-        assert!(*(x.data as *const int) == 100);\n+        assert!(*(x.data as *const isize) == 100);\n         let _x: Box<Foo> = transmute(x);\n     }\n \n@@ -112,15 +112,15 @@ fn test_transmute() {\n // Static/dynamic method dispatch\n \n struct Struct {\n-    field: int\n+    field: isize\n }\n \n trait Trait {\n-    fn method(&self) -> int;\n+    fn method(&self) -> isize;\n }\n \n impl Trait for Struct {\n-    fn method(&self) -> int {\n+    fn method(&self) -> isize {\n         self.field\n     }\n }"}, {"sha": "7a367ddeec8d4599ec8543a712306059061edd91", "filename": "src/libcoretest/nonzero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcoretest%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcoretest%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnonzero.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -43,7 +43,7 @@ fn test_match_on_nonzero_option() {\n \n #[test]\n fn test_match_option_empty_vec() {\n-    let a: Option<Vec<int>> = Some(vec![]);\n+    let a: Option<Vec<isize>> = Some(vec![]);\n     match a {\n         None => panic!(\"unexpected None while matching on Some(vec![])\"),\n         _ => {}"}, {"sha": "33674a3abd870271fa26c15453367bbfa5ee24df", "filename": "src/libcoretest/ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcoretest%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcoretest%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fops.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -14,7 +14,7 @@ use core::ops::{Range, RangeFull, RangeFrom, RangeTo};\n // Overhead of dtors\n \n struct HasDtor {\n-    _x: int\n+    _x: isize\n }\n \n impl Drop for HasDtor {"}, {"sha": "1a7d8f83d701860193cc26898a4c9c7c5861b6de", "filename": "src/libcoretest/option.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -17,10 +17,10 @@ use core::clone::Clone;\n fn test_get_ptr() {\n     unsafe {\n         let x: Box<_> = box 0;\n-        let addr_x: *const int = mem::transmute(&*x);\n+        let addr_x: *const isize = mem::transmute(&*x);\n         let opt = Some(x);\n         let y = opt.unwrap();\n-        let addr_y: *const int = mem::transmute(&*y);\n+        let addr_y: *const isize = mem::transmute(&*y);\n         assert_eq!(addr_x, addr_y);\n     }\n }\n@@ -41,7 +41,7 @@ fn test_get_resource() {\n     use core::cell::RefCell;\n \n     struct R {\n-       i: Rc<RefCell<int>>,\n+       i: Rc<RefCell<isize>>,\n     }\n \n     #[unsafe_destructor]\n@@ -53,7 +53,7 @@ fn test_get_resource() {\n         }\n     }\n \n-    fn r(i: Rc<RefCell<int>>) -> R {\n+    fn r(i: Rc<RefCell<isize>>) -> R {\n         R {\n             i: i\n         }\n@@ -89,44 +89,44 @@ fn test_option_too_much_dance() {\n \n #[test]\n fn test_and() {\n-    let x: Option<int> = Some(1);\n+    let x: Option<isize> = Some(1);\n     assert_eq!(x.and(Some(2)), Some(2));\n-    assert_eq!(x.and(None::<int>), None);\n+    assert_eq!(x.and(None::<isize>), None);\n \n-    let x: Option<int> = None;\n+    let x: Option<isize> = None;\n     assert_eq!(x.and(Some(2)), None);\n-    assert_eq!(x.and(None::<int>), None);\n+    assert_eq!(x.and(None::<isize>), None);\n }\n \n #[test]\n fn test_and_then() {\n-    let x: Option<int> = Some(1);\n+    let x: Option<isize> = Some(1);\n     assert_eq!(x.and_then(|x| Some(x + 1)), Some(2));\n-    assert_eq!(x.and_then(|_| None::<int>), None);\n+    assert_eq!(x.and_then(|_| None::<isize>), None);\n \n-    let x: Option<int> = None;\n+    let x: Option<isize> = None;\n     assert_eq!(x.and_then(|x| Some(x + 1)), None);\n-    assert_eq!(x.and_then(|_| None::<int>), None);\n+    assert_eq!(x.and_then(|_| None::<isize>), None);\n }\n \n #[test]\n fn test_or() {\n-    let x: Option<int> = Some(1);\n+    let x: Option<isize> = Some(1);\n     assert_eq!(x.or(Some(2)), Some(1));\n     assert_eq!(x.or(None), Some(1));\n \n-    let x: Option<int> = None;\n+    let x: Option<isize> = None;\n     assert_eq!(x.or(Some(2)), Some(2));\n     assert_eq!(x.or(None), None);\n }\n \n #[test]\n fn test_or_else() {\n-    let x: Option<int> = Some(1);\n+    let x: Option<isize> = Some(1);\n     assert_eq!(x.or_else(|| Some(2)), Some(1));\n     assert_eq!(x.or_else(|| None), Some(1));\n \n-    let x: Option<int> = None;\n+    let x: Option<isize> = None;\n     assert_eq!(x.or_else(|| Some(2)), Some(2));\n     assert_eq!(x.or_else(|| None), None);\n }\n@@ -141,7 +141,7 @@ fn test_unwrap() {\n #[test]\n #[should_panic]\n fn test_unwrap_panic1() {\n-    let x: Option<int> = None;\n+    let x: Option<isize> = None;\n     x.unwrap();\n }\n \n@@ -154,19 +154,19 @@ fn test_unwrap_panic2() {\n \n #[test]\n fn test_unwrap_or() {\n-    let x: Option<int> = Some(1);\n+    let x: Option<isize> = Some(1);\n     assert_eq!(x.unwrap_or(2), 1);\n \n-    let x: Option<int> = None;\n+    let x: Option<isize> = None;\n     assert_eq!(x.unwrap_or(2), 2);\n }\n \n #[test]\n fn test_unwrap_or_else() {\n-    let x: Option<int> = Some(1);\n+    let x: Option<isize> = Some(1);\n     assert_eq!(x.unwrap_or_else(|| 2), 1);\n \n-    let x: Option<int> = None;\n+    let x: Option<isize> = None;\n     assert_eq!(x.unwrap_or_else(|| 2), 2);\n }\n \n@@ -223,13 +223,13 @@ fn test_ord() {\n /* FIXME(#20575)\n #[test]\n fn test_collect() {\n-    let v: Option<Vec<int>> = (0..0).map(|_| Some(0)).collect();\n+    let v: Option<Vec<isize>> = (0..0).map(|_| Some(0)).collect();\n     assert!(v == Some(vec![]));\n \n-    let v: Option<Vec<int>> = (0..3).map(|x| Some(x)).collect();\n+    let v: Option<Vec<isize>> = (0..3).map(|x| Some(x)).collect();\n     assert!(v == Some(vec![0, 1, 2]));\n \n-    let v: Option<Vec<int>> = (0..3).map(|x| {\n+    let v: Option<Vec<isize>> = (0..3).map(|x| {\n         if x > 1 { None } else { Some(x) }\n     }).collect();\n     assert!(v == None);"}, {"sha": "bdb56c9f867a0229a0c18dec23c9ae495241f762", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -16,12 +16,12 @@ use std::iter::repeat;\n fn test() {\n     unsafe {\n         struct Pair {\n-            fst: int,\n-            snd: int\n+            fst: isize,\n+            snd: isize\n         };\n         let mut p = Pair {fst: 10, snd: 20};\n         let pptr: *mut Pair = &mut p;\n-        let iptr: *mut int = mem::transmute(pptr);\n+        let iptr: *mut isize = mem::transmute(pptr);\n         assert_eq!(*iptr, 10);\n         *iptr = 30;\n         assert_eq!(*iptr, 30);\n@@ -55,13 +55,13 @@ fn test() {\n \n #[test]\n fn test_is_null() {\n-    let p: *const int = null();\n+    let p: *const isize = null();\n     assert!(p.is_null());\n \n     let q = unsafe { p.offset(1) };\n     assert!(!q.is_null());\n \n-    let mp: *mut int = null_mut();\n+    let mp: *mut isize = null_mut();\n     assert!(mp.is_null());\n \n     let mq = unsafe { mp.offset(1) };\n@@ -71,22 +71,22 @@ fn test_is_null() {\n #[test]\n fn test_as_ref() {\n     unsafe {\n-        let p: *const int = null();\n+        let p: *const isize = null();\n         assert_eq!(p.as_ref(), None);\n \n-        let q: *const int = &2;\n+        let q: *const isize = &2;\n         assert_eq!(q.as_ref().unwrap(), &2);\n \n-        let p: *mut int = null_mut();\n+        let p: *mut isize = null_mut();\n         assert_eq!(p.as_ref(), None);\n \n-        let q: *mut int = &mut 2;\n+        let q: *mut isize = &mut 2;\n         assert_eq!(q.as_ref().unwrap(), &2);\n \n         // Lifetime inference\n         let u = 2isize;\n         {\n-            let p = &u as *const int;\n+            let p = &u as *const isize;\n             assert_eq!(p.as_ref().unwrap(), &2);\n         }\n     }\n@@ -95,16 +95,16 @@ fn test_as_ref() {\n #[test]\n fn test_as_mut() {\n     unsafe {\n-        let p: *mut int = null_mut();\n+        let p: *mut isize = null_mut();\n         assert!(p.as_mut() == None);\n \n-        let q: *mut int = &mut 2;\n+        let q: *mut isize = &mut 2;\n         assert!(q.as_mut().unwrap() == &mut 2);\n \n         // Lifetime inference\n         let mut u = 2isize;\n         {\n-            let p = &mut u as *mut int;\n+            let p = &mut u as *mut isize;\n             assert!(p.as_mut().unwrap() == &mut 2);\n         }\n     }\n@@ -143,7 +143,7 @@ fn test_ptr_subtraction() {\n         let ptr = xs.as_ptr();\n \n         while idx >= 0 {\n-            assert_eq!(*(ptr.offset(idx as int)), idx as int);\n+            assert_eq!(*(ptr.offset(idx as isize)), idx as isize);\n             idx = idx - 1;\n         }\n "}, {"sha": "ac8c2b953ae965d185873e429c84a5f547f93e29", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub fn op1() -> Result<int, &'static str> { Ok(666) }\n-pub fn op2() -> Result<int, &'static str> { Err(\"sadface\") }\n+pub fn op1() -> Result<isize, &'static str> { Ok(666) }\n+pub fn op2() -> Result<isize, &'static str> { Err(\"sadface\") }\n \n #[test]\n pub fn test_and() {\n@@ -24,13 +24,13 @@ pub fn test_and() {\n \n #[test]\n pub fn test_and_then() {\n-    assert_eq!(op1().and_then(|i| Ok::<int, &'static str>(i + 1)).unwrap(), 667);\n-    assert_eq!(op1().and_then(|_| Err::<int, &'static str>(\"bad\")).unwrap_err(),\n+    assert_eq!(op1().and_then(|i| Ok::<isize, &'static str>(i + 1)).unwrap(), 667);\n+    assert_eq!(op1().and_then(|_| Err::<isize, &'static str>(\"bad\")).unwrap_err(),\n                \"bad\");\n \n-    assert_eq!(op2().and_then(|i| Ok::<int, &'static str>(i + 1)).unwrap_err(),\n+    assert_eq!(op2().and_then(|i| Ok::<isize, &'static str>(i + 1)).unwrap_err(),\n                \"sadface\");\n-    assert_eq!(op2().and_then(|_| Err::<int, &'static str>(\"bad\")).unwrap_err(),\n+    assert_eq!(op2().and_then(|_| Err::<isize, &'static str>(\"bad\")).unwrap_err(),\n                \"sadface\");\n }\n \n@@ -45,53 +45,53 @@ pub fn test_or() {\n \n #[test]\n pub fn test_or_else() {\n-    assert_eq!(op1().or_else(|_| Ok::<int, &'static str>(667)).unwrap(), 666);\n-    assert_eq!(op1().or_else(|e| Err::<int, &'static str>(e)).unwrap(), 666);\n+    assert_eq!(op1().or_else(|_| Ok::<isize, &'static str>(667)).unwrap(), 666);\n+    assert_eq!(op1().or_else(|e| Err::<isize, &'static str>(e)).unwrap(), 666);\n \n-    assert_eq!(op2().or_else(|_| Ok::<int, &'static str>(667)).unwrap(), 667);\n-    assert_eq!(op2().or_else(|e| Err::<int, &'static str>(e)).unwrap_err(),\n+    assert_eq!(op2().or_else(|_| Ok::<isize, &'static str>(667)).unwrap(), 667);\n+    assert_eq!(op2().or_else(|e| Err::<isize, &'static str>(e)).unwrap_err(),\n                \"sadface\");\n }\n \n #[test]\n pub fn test_impl_map() {\n-    assert!(Ok::<int, int>(1).map(|x| x + 1) == Ok(2));\n-    assert!(Err::<int, int>(1).map(|x| x + 1) == Err(1));\n+    assert!(Ok::<isize, isize>(1).map(|x| x + 1) == Ok(2));\n+    assert!(Err::<isize, isize>(1).map(|x| x + 1) == Err(1));\n }\n \n #[test]\n pub fn test_impl_map_err() {\n-    assert!(Ok::<int, int>(1).map_err(|x| x + 1) == Ok(1));\n-    assert!(Err::<int, int>(1).map_err(|x| x + 1) == Err(2));\n+    assert!(Ok::<isize, isize>(1).map_err(|x| x + 1) == Ok(1));\n+    assert!(Err::<isize, isize>(1).map_err(|x| x + 1) == Err(2));\n }\n \n /* FIXME(#20575)\n #[test]\n fn test_collect() {\n-    let v: Result<Vec<int>, ()> = (0..0).map(|_| Ok::<int, ()>(0)).collect();\n+    let v: Result<Vec<isize>, ()> = (0..0).map(|_| Ok::<isize, ()>(0)).collect();\n     assert!(v == Ok(vec![]));\n \n-    let v: Result<Vec<int>, ()> = (0..3).map(|x| Ok::<int, ()>(x)).collect();\n+    let v: Result<Vec<isize>, ()> = (0..3).map(|x| Ok::<isize, ()>(x)).collect();\n     assert!(v == Ok(vec![0, 1, 2]));\n \n-    let v: Result<Vec<int>, int> = (0..3).map(|x| {\n+    let v: Result<Vec<isize>, isize> = (0..3).map(|x| {\n         if x > 1 { Err(x) } else { Ok(x) }\n     }).collect();\n     assert!(v == Err(2));\n \n     // test that it does not take more elements than it needs\n-    let mut functions: [Box<Fn() -> Result<(), int>>; 3] =\n+    let mut functions: [Box<Fn() -> Result<(), isize>>; 3] =\n         [box || Ok(()), box || Err(1), box || panic!()];\n \n-    let v: Result<Vec<()>, int> = functions.iter_mut().map(|f| (*f)()).collect();\n+    let v: Result<Vec<()>, isize> = functions.iter_mut().map(|f| (*f)()).collect();\n     assert!(v == Err(1));\n }\n */\n \n #[test]\n pub fn test_fmt_default() {\n-    let ok: Result<int, &'static str> = Ok(100);\n-    let err: Result<int, &'static str> = Err(\"Err\");\n+    let ok: Result<isize, &'static str> = Ok(100);\n+    let err: Result<isize, &'static str> = Err(\"Err\");\n \n     let s = format!(\"{:?}\", ok);\n     assert_eq!(s, \"Ok(100)\");\n@@ -101,25 +101,25 @@ pub fn test_fmt_default() {\n \n #[test]\n pub fn test_unwrap_or() {\n-    let ok: Result<int, &'static str> = Ok(100);\n-    let ok_err: Result<int, &'static str> = Err(\"Err\");\n+    let ok: Result<isize, &'static str> = Ok(100);\n+    let ok_err: Result<isize, &'static str> = Err(\"Err\");\n \n     assert_eq!(ok.unwrap_or(50), 100);\n     assert_eq!(ok_err.unwrap_or(50), 50);\n }\n \n #[test]\n pub fn test_unwrap_or_else() {\n-    fn handler(msg: &'static str) -> int {\n+    fn handler(msg: &'static str) -> isize {\n         if msg == \"I got this.\" {\n             50\n         } else {\n             panic!(\"BadBad\")\n         }\n     }\n \n-    let ok: Result<int, &'static str> = Ok(100);\n-    let ok_err: Result<int, &'static str> = Err(\"I got this.\");\n+    let ok: Result<isize, &'static str> = Ok(100);\n+    let ok_err: Result<isize, &'static str> = Err(\"I got this.\");\n \n     assert_eq!(ok.unwrap_or_else(handler), 100);\n     assert_eq!(ok_err.unwrap_or_else(handler), 50);\n@@ -128,14 +128,14 @@ pub fn test_unwrap_or_else() {\n #[test]\n #[should_panic]\n pub fn test_unwrap_or_else_panic() {\n-    fn handler(msg: &'static str) -> int {\n+    fn handler(msg: &'static str) -> isize {\n         if msg == \"I got this.\" {\n             50\n         } else {\n             panic!(\"BadBad\")\n         }\n     }\n \n-    let bad_err: Result<int, &'static str> = Err(\"Unrecoverable mess.\");\n-    let _ : int = bad_err.unwrap_or_else(handler);\n+    let bad_err: Result<isize, &'static str> = Err(\"Unrecoverable mess.\");\n+    let _ : isize = bad_err.unwrap_or_else(handler);\n }"}, {"sha": "9a5dde8e45e2f92e91bb0c505f2778ab5967426d", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -92,7 +92,6 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![deny(missing_docs)]\n-#![feature(int_uint)]\n #![feature(staged_api)]\n #![feature(str_words)]\n #![feature(str_char)]\n@@ -311,7 +310,7 @@ impl Matches {\n     }\n \n     /// Returns the number of times an option was matched.\n-    pub fn opt_count(&self, nm: &str) -> uint {\n+    pub fn opt_count(&self, nm: &str) -> usize {\n         self.opt_vals(nm).len()\n     }\n \n@@ -389,7 +388,7 @@ fn is_arg(arg: &str) -> bool {\n     arg.len() > 1 && arg.as_bytes()[0] == b'-'\n }\n \n-fn find_opt(opts: &[Opt], nm: Name) -> Option<uint> {\n+fn find_opt(opts: &[Opt], nm: Name) -> Option<usize> {\n     // Search main options.\n     let pos = opts.iter().position(|opt| opt.name == nm);\n     if pos.is_some() {\n@@ -587,7 +586,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n     let opts: Vec<Opt> = optgrps.iter().map(|x| x.long_to_short()).collect();\n     let n_opts = opts.len();\n \n-    fn f(_x: uint) -> Vec<Optval> { return Vec::new(); }\n+    fn f(_x: usize) -> Vec<Optval> { return Vec::new(); }\n \n     let mut vals: Vec<_> = (0..n_opts).map(f).collect();\n     let mut free: Vec<String> = Vec::new();\n@@ -873,7 +872,7 @@ enum LengthLimit {\n ///\n /// Panics during iteration if the string contains a non-whitespace\n /// sequence longer than the limit.\n-fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n+fn each_split_within<F>(ss: &str, lim: usize, mut it: F) -> bool where\n     F: FnMut(&str) -> bool\n {\n     // Just for fun, let's write this as a state machine:\n@@ -892,7 +891,7 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n         lim = fake_i;\n     }\n \n-    let mut machine = |cont: &mut bool, (i, c): (uint, char)| -> bool {\n+    let mut machine = |cont: &mut bool, (i, c): (usize, char)| -> bool {\n         let whitespace = if c.is_whitespace() { Ws }       else { Cr };\n         let limit      = if (i - slice_start + 1) <= lim  { UnderLim } else { OverLim };\n \n@@ -954,7 +953,7 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n \n #[test]\n fn test_split_within() {\n-    fn t(s: &str, i: uint, u: &[String]) {\n+    fn t(s: &str, i: usize, u: &[String]) {\n         let mut v = Vec::new();\n         each_split_within(s, i, |s| { v.push(s.to_string()); true });\n         assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));"}, {"sha": "b3a3f266a5ef33449a76658aeba5a9c4d77c6bd9", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -281,7 +281,6 @@\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![feature(int_uint)]\n #![feature(collections)]\n #![feature(into_cow)]\n "}, {"sha": "1cfac4d86680dc12f59e941aff3c5296f5d03f14", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -172,7 +172,6 @@\n #![feature(alloc)]\n #![feature(staged_api)]\n #![feature(box_syntax)]\n-#![feature(int_uint)]\n #![feature(core)]\n #![feature(std_misc)]\n \n@@ -246,7 +245,7 @@ pub struct LogLevel(pub u32);\n impl fmt::Display for LogLevel {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let LogLevel(level) = *self;\n-        match LOG_LEVEL_NAMES.get(level as uint - 1) {\n+        match LOG_LEVEL_NAMES.get(level as usize - 1) {\n             Some(ref name) => fmt::Display::fmt(name, fmt),\n             None => fmt::Display::fmt(&level, fmt)\n         }\n@@ -289,7 +288,7 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n     // is one.\n     unsafe {\n         let _g = LOCK.lock();\n-        match FILTER as uint {\n+        match FILTER as usize {\n             0 => {}\n             1 => panic!(\"cannot log after main thread has exited\"),\n             n => {\n@@ -383,8 +382,8 @@ pub fn mod_enabled(level: u32, module: &str) -> bool {\n \n     let _g = LOCK.lock();\n     unsafe {\n-        assert!(DIRECTIVES as uint != 0);\n-        assert!(DIRECTIVES as uint != 1,\n+        assert!(DIRECTIVES as usize != 0);\n+        assert!(DIRECTIVES as usize != 1,\n                 \"cannot log after the main thread has exited\");\n \n         enabled(level, module, (*DIRECTIVES).iter())"}, {"sha": "91abb548d2ee18520b13feabec69cc7a7fb60d89", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -15,9 +15,9 @@ use core::num::Int;\n use core::num::wrapping::WrappingOps;\n use {Rng, SeedableRng, Rand};\n \n-const KEY_WORDS    : uint =  8; // 8 words for the 256-bit key\n-const STATE_WORDS  : uint = 16;\n-const CHACHA_ROUNDS: uint = 20; // Cryptographically secure from 8 upwards as of this writing\n+const KEY_WORDS    : usize =  8; // 8 words for the 256-bit key\n+const STATE_WORDS  : usize = 16;\n+const CHACHA_ROUNDS: usize = 20; // Cryptographically secure from 8 upwards as of this writing\n \n /// A random number generator that uses the ChaCha20 algorithm [1].\n ///\n@@ -32,7 +32,7 @@ const CHACHA_ROUNDS: uint = 20; // Cryptographically secure from 8 upwards as of\n pub struct ChaChaRng {\n     buffer:  [u32; STATE_WORDS], // Internal buffer of output\n     state:   [u32; STATE_WORDS], // Initial state\n-    index:   uint,                 // Index into state\n+    index:   usize,                 // Index into state\n }\n \n static EMPTY: ChaChaRng = ChaChaRng {"}, {"sha": "f42960b9c3b2b3a50fbd101d66ef156c396c7bdb", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -76,7 +76,7 @@ impl<Sup: Rand> IndependentSample<Sup> for RandSample<Sup> {\n /// A value with a particular weight for use with `WeightedChoice`.\n pub struct Weighted<T> {\n     /// The numerical weight of this item\n-    pub weight: uint,\n+    pub weight: usize,\n     /// The actual item which is being weighted\n     pub item: T,\n }\n@@ -88,7 +88,7 @@ pub struct Weighted<T> {\n ///\n /// The `Clone` restriction is a limitation of the `Sample` and\n /// `IndependentSample` traits. Note that `&T` is (cheaply) `Clone` for\n-/// all `T`, as is `uint`, so one can store references or indices into\n+/// all `T`, as is `usize`, so one can store references or indices into\n /// another vector.\n ///\n /// # Examples\n@@ -110,7 +110,7 @@ pub struct Weighted<T> {\n /// ```\n pub struct WeightedChoice<'a, T:'a> {\n     items: &'a mut [Weighted<T>],\n-    weight_range: Range<uint>\n+    weight_range: Range<usize>\n }\n \n impl<'a, T: Clone> WeightedChoice<'a, T> {\n@@ -119,7 +119,7 @@ impl<'a, T: Clone> WeightedChoice<'a, T> {\n     /// Panics if:\n     /// - `v` is empty\n     /// - the total weight is 0\n-    /// - the total weight is larger than a `uint` can contain.\n+    /// - the total weight is larger than a `usize` can contain.\n     pub fn new(items: &'a mut [Weighted<T>]) -> WeightedChoice<'a, T> {\n         // strictly speaking, this is subsumed by the total weight == 0 case\n         assert!(!items.is_empty(), \"WeightedChoice::new called with no items\");\n@@ -133,7 +133,7 @@ impl<'a, T: Clone> WeightedChoice<'a, T> {\n             running_total = match running_total.checked_add(item.weight) {\n                 Some(n) => n,\n                 None => panic!(\"WeightedChoice::new called with a total weight \\\n-                               larger than a uint can contain\")\n+                               larger than a usize can contain\")\n             };\n \n             item.weight = running_total;\n@@ -238,7 +238,7 @@ fn ziggurat<R: Rng, P, Z>(\n         // this may be slower than it would be otherwise.)\n         // FIXME: investigate/optimise for the above.\n         let bits: u64 = rng.gen();\n-        let i = (bits & 0xff) as uint;\n+        let i = (bits & 0xff) as usize;\n         let f = (bits >> 11) as f64 / SCALE;\n \n         // u is either U(-1, 1) or U(0, 1) depending on if this is a\n@@ -270,7 +270,7 @@ mod tests {\n     use super::{RandSample, WeightedChoice, Weighted, Sample, IndependentSample};\n \n     #[derive(PartialEq, Debug)]\n-    struct ConstRand(uint);\n+    struct ConstRand(usize);\n     impl Rand for ConstRand {\n         fn rand<R: Rng>(_: &mut R) -> ConstRand {\n             ConstRand(0)\n@@ -352,7 +352,7 @@ mod tests {\n \n     #[test] #[should_panic]\n     fn test_weighted_choice_no_items() {\n-        WeightedChoice::<int>::new(&mut []);\n+        WeightedChoice::<isize>::new(&mut []);\n     }\n     #[test] #[should_panic]\n     fn test_weighted_choice_zero_weight() {\n@@ -361,7 +361,7 @@ mod tests {\n     }\n     #[test] #[should_panic]\n     fn test_weighted_choice_weight_overflows() {\n-        let x = (-1) as uint / 2; // x + x + 2 is the overflow\n+        let x = (-1) as usize / 2; // x + x + 2 is the overflow\n         WeightedChoice::new(&mut [Weighted { weight: x, item: 0 },\n                                   Weighted { weight: 1, item: 1 },\n                                   Weighted { weight: x, item: 2 },"}, {"sha": "2c200b4ea411a854b890bb39b1c58bc9c7d8060e", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -138,12 +138,12 @@ integer_impl! { i8, u8 }\n integer_impl! { i16, u16 }\n integer_impl! { i32, u32 }\n integer_impl! { i64, u64 }\n-integer_impl! { int, uint }\n+integer_impl! { isize, usize }\n integer_impl! { u8, u8 }\n integer_impl! { u16, u16 }\n integer_impl! { u32, u32 }\n integer_impl! { u64, u64 }\n-integer_impl! { uint, uint }\n+integer_impl! { usize, usize }\n \n macro_rules! float_impl {\n     ($ty:ty) => {\n@@ -204,8 +204,8 @@ mod tests {\n                  )*\n             }}\n         }\n-        t!(i8, i16, i32, i64, int,\n-           u8, u16, u32, u64, uint)\n+        t!(i8, i16, i32, i64, isize,\n+           u8, u16, u32, u64, usize)\n     }\n \n     #[test]"}, {"sha": "97106908cde4f04d39261a12eba9fff9026c78ff", "filename": "src/librand/lib.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -24,7 +24,6 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(int_uint)]\n #![feature(no_std)]\n #![no_std]\n #![unstable(feature = \"rand\")]\n@@ -99,8 +98,8 @@ pub trait Rng : Sized {\n     /// See `Closed01` for the closed interval `[0,1]`, and\n     /// `Open01` for the open interval `(0,1)`.\n     fn next_f32(&mut self) -> f32 {\n-        const MANTISSA_BITS: uint = 24;\n-        const IGNORED_BITS: uint = 8;\n+        const MANTISSA_BITS: usize = 24;\n+        const IGNORED_BITS: usize = 8;\n         const SCALE: f32 = (1u64 << MANTISSA_BITS) as f32;\n \n         // using any more than `MANTISSA_BITS` bits will\n@@ -121,8 +120,8 @@ pub trait Rng : Sized {\n     /// See `Closed01` for the closed interval `[0,1]`, and\n     /// `Open01` for the open interval `(0,1)`.\n     fn next_f64(&mut self) -> f64 {\n-        const MANTISSA_BITS: uint = 53;\n-        const IGNORED_BITS: uint = 11;\n+        const MANTISSA_BITS: usize = 53;\n+        const IGNORED_BITS: usize = 11;\n         const SCALE: f64 = (1u64 << MANTISSA_BITS) as f64;\n \n         (self.next_u64() >> IGNORED_BITS) as f64 / SCALE\n@@ -189,7 +188,7 @@ pub trait Rng : Sized {\n     /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let mut rng = thread_rng();\n-    /// let x: uint = rng.gen();\n+    /// let x: usize = rng.gen();\n     /// println!(\"{}\", x);\n     /// println!(\"{:?}\", rng.gen::<(f64, bool)>());\n     /// ```\n@@ -208,7 +207,7 @@ pub trait Rng : Sized {\n     /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let mut rng = thread_rng();\n-    /// let x = rng.gen_iter::<uint>().take(10).collect::<Vec<uint>>();\n+    /// let x = rng.gen_iter::<usize>().take(10).collect::<Vec<usize>>();\n     /// println!(\"{:?}\", x);\n     /// println!(\"{:?}\", rng.gen_iter::<(f64, bool)>().take(5)\n     ///                     .collect::<Vec<(f64, bool)>>());\n@@ -236,7 +235,7 @@ pub trait Rng : Sized {\n     /// use std::rand::{thread_rng, Rng};\n     ///\n     /// let mut rng = thread_rng();\n-    /// let n: uint = rng.gen_range(0, 10);\n+    /// let n: usize = rng.gen_range(0, 10);\n     /// println!(\"{}\", n);\n     /// let m: f64 = rng.gen_range(-40.0f64, 1.3e5f64);\n     /// println!(\"{}\", m);\n@@ -257,7 +256,7 @@ pub trait Rng : Sized {\n     /// let mut rng = thread_rng();\n     /// println!(\"{}\", rng.gen_weighted_bool(3));\n     /// ```\n-    fn gen_weighted_bool(&mut self, n: uint) -> bool {\n+    fn gen_weighted_bool(&mut self, n: usize) -> bool {\n         n <= 1 || self.gen_range(0, n) == 0\n     }\n "}, {"sha": "ab4939f57d41a62ff357bd543db5d4fa3d2b9097", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -18,14 +18,14 @@ use core::default::Default;\n \n /// How many bytes of entropy the underling RNG is allowed to generate\n /// before it is reseeded.\n-const DEFAULT_GENERATION_THRESHOLD: uint = 32 * 1024;\n+const DEFAULT_GENERATION_THRESHOLD: usize = 32 * 1024;\n \n /// A wrapper around any RNG which reseeds the underlying RNG after it\n /// has generated a certain number of random bytes.\n pub struct ReseedingRng<R, Rsdr> {\n     rng: R,\n-    generation_threshold: uint,\n-    bytes_generated: uint,\n+    generation_threshold: usize,\n+    bytes_generated: usize,\n     /// Controls the behaviour when reseeding the RNG.\n     pub reseeder: Rsdr,\n }\n@@ -38,7 +38,7 @@ impl<R: Rng, Rsdr: Reseeder<R>> ReseedingRng<R, Rsdr> {\n     /// * `rng`: the random number generator to use.\n     /// * `generation_threshold`: the number of bytes of entropy at which to reseed the RNG.\n     /// * `reseeder`: the reseeding object to use.\n-    pub fn new(rng: R, generation_threshold: uint, reseeder: Rsdr) -> ReseedingRng<R,Rsdr> {\n+    pub fn new(rng: R, generation_threshold: usize, reseeder: Rsdr) -> ReseedingRng<R,Rsdr> {\n         ReseedingRng {\n             rng: rng,\n             generation_threshold: generation_threshold,\n@@ -213,7 +213,7 @@ mod test {\n         assert_eq!(string1, string2);\n     }\n \n-    const FILL_BYTES_V_LEN: uint = 13579;\n+    const FILL_BYTES_V_LEN: usize = 13579;\n     #[test]\n     fn test_rng_fill_bytes() {\n         let mut v = repeat(0).take(FILL_BYTES_V_LEN).collect::<Vec<_>>();"}, {"sha": "fd35c9c6be96d215052129a696a5201792089e92", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 139, "deletions": 140, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -27,7 +27,7 @@\n //! where the tag number is ORed with 0xf000. (E.g. tag 0x123 = `f1 23`)\n //!\n //! **Lengths** encode the length of the following data.\n-//! It is a variable-length unsigned int, and one of the following forms:\n+//! It is a variable-length unsigned isize, and one of the following forms:\n //!\n //! - `80` through `fe` for lengths up to 0x7e;\n //! - `40 ff` through `7f ff` for lengths up to 0x3fff;\n@@ -125,7 +125,6 @@\n \n #![feature(io)]\n #![feature(core)]\n-#![feature(int_uint)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n \n@@ -146,16 +145,16 @@ use std::fmt;\n #[derive(Clone, Copy)]\n pub struct Doc<'a> {\n     pub data: &'a [u8],\n-    pub start: uint,\n-    pub end: uint,\n+    pub start: usize,\n+    pub end: usize,\n }\n \n impl<'doc> Doc<'doc> {\n     pub fn new(data: &'doc [u8]) -> Doc<'doc> {\n         Doc { data: data, start: 0, end: data.len() }\n     }\n \n-    pub fn get<'a>(&'a self, tag: uint) -> Doc<'a> {\n+    pub fn get<'a>(&'a self, tag: usize) -> Doc<'a> {\n         reader::get_doc(*self, tag)\n     }\n \n@@ -173,7 +172,7 @@ impl<'doc> Doc<'doc> {\n }\n \n pub struct TaggedDoc<'a> {\n-    tag: uint,\n+    tag: usize,\n     pub doc: Doc<'a>,\n }\n \n@@ -208,8 +207,8 @@ pub enum EbmlEncoderTag {\n     EsOpaque   = 0x17,\n }\n \n-const NUM_TAGS: uint = 0x1000;\n-const NUM_IMPLICIT_TAGS: uint = 0x0e;\n+const NUM_TAGS: usize = 0x1000;\n+const NUM_IMPLICIT_TAGS: usize = 0x0e;\n \n static TAG_IMPLICIT_LEN: [i8; NUM_IMPLICIT_TAGS] = [\n     1, 2, 4, 8, // EsU*\n@@ -222,8 +221,8 @@ static TAG_IMPLICIT_LEN: [i8; NUM_IMPLICIT_TAGS] = [\n \n #[derive(Debug)]\n pub enum Error {\n-    IntTooBig(uint),\n-    InvalidTag(uint),\n+    IntTooBig(usize),\n+    InvalidTag(usize),\n     Expected(String),\n     IoError(std::io::Error),\n     ApplicationError(String)\n@@ -270,50 +269,50 @@ pub mod reader {\n \n     #[derive(Copy)]\n     pub struct Res {\n-        pub val: uint,\n-        pub next: uint\n+        pub val: usize,\n+        pub next: usize\n     }\n \n-    pub fn tag_at(data: &[u8], start: uint) -> DecodeResult<Res> {\n-        let v = data[start] as uint;\n+    pub fn tag_at(data: &[u8], start: usize) -> DecodeResult<Res> {\n+        let v = data[start] as usize;\n         if v < 0xf0 {\n             Ok(Res { val: v, next: start + 1 })\n         } else if v > 0xf0 {\n-            Ok(Res { val: ((v & 0xf) << 8) | data[start + 1] as uint, next: start + 2 })\n+            Ok(Res { val: ((v & 0xf) << 8) | data[start + 1] as usize, next: start + 2 })\n         } else {\n             // every tag starting with byte 0xf0 is an overlong form, which is prohibited.\n             Err(InvalidTag(v))\n         }\n     }\n \n     #[inline(never)]\n-    fn vuint_at_slow(data: &[u8], start: uint) -> DecodeResult<Res> {\n+    fn vuint_at_slow(data: &[u8], start: usize) -> DecodeResult<Res> {\n         let a = data[start];\n         if a & 0x80 != 0 {\n-            return Ok(Res {val: (a & 0x7f) as uint, next: start + 1});\n+            return Ok(Res {val: (a & 0x7f) as usize, next: start + 1});\n         }\n         if a & 0x40 != 0 {\n-            return Ok(Res {val: ((a & 0x3f) as uint) << 8 |\n-                        (data[start + 1] as uint),\n+            return Ok(Res {val: ((a & 0x3f) as usize) << 8 |\n+                        (data[start + 1] as usize),\n                     next: start + 2});\n         }\n         if a & 0x20 != 0 {\n-            return Ok(Res {val: ((a & 0x1f) as uint) << 16 |\n-                        (data[start + 1] as uint) << 8 |\n-                        (data[start + 2] as uint),\n+            return Ok(Res {val: ((a & 0x1f) as usize) << 16 |\n+                        (data[start + 1] as usize) << 8 |\n+                        (data[start + 2] as usize),\n                     next: start + 3});\n         }\n         if a & 0x10 != 0 {\n-            return Ok(Res {val: ((a & 0x0f) as uint) << 24 |\n-                        (data[start + 1] as uint) << 16 |\n-                        (data[start + 2] as uint) << 8 |\n-                        (data[start + 3] as uint),\n+            return Ok(Res {val: ((a & 0x0f) as usize) << 24 |\n+                        (data[start + 1] as usize) << 16 |\n+                        (data[start + 2] as usize) << 8 |\n+                        (data[start + 3] as usize),\n                     next: start + 4});\n         }\n-        Err(IntTooBig(a as uint))\n+        Err(IntTooBig(a as usize))\n     }\n \n-    pub fn vuint_at(data: &[u8], start: uint) -> DecodeResult<Res> {\n+    pub fn vuint_at(data: &[u8], start: usize) -> DecodeResult<Res> {\n         if data.len() - start < 4 {\n             return vuint_at_slow(data, start);\n         }\n@@ -337,7 +336,7 @@ pub mod reader {\n         // most significant bit is set etc. we can replace up to three\n         // \"and+branch\" with a single table lookup which gives us a measured\n         // speedup of around 2x on x86_64.\n-        static SHIFT_MASK_TABLE: [(uint, u32); 16] = [\n+        static SHIFT_MASK_TABLE: [(usize, u32); 16] = [\n             (0, 0x0), (0, 0x0fffffff),\n             (8, 0x1fffff), (8, 0x1fffff),\n             (16, 0x3fff), (16, 0x3fff), (16, 0x3fff), (16, 0x3fff),\n@@ -346,10 +345,10 @@ pub mod reader {\n         ];\n \n         unsafe {\n-            let ptr = data.as_ptr().offset(start as int) as *const u32;\n+            let ptr = data.as_ptr().offset(start as isize) as *const u32;\n             let val = Int::from_be(*ptr);\n \n-            let i = (val >> 28) as uint;\n+            let i = (val >> 28) as usize;\n             let (shift, mask) = SHIFT_MASK_TABLE[i];\n             Ok(Res {\n                 val: ((val >> shift) & mask) as usize,\n@@ -360,13 +359,13 @@ pub mod reader {\n \n     pub fn tag_len_at(data: &[u8], tag: Res) -> DecodeResult<Res> {\n         if tag.val < NUM_IMPLICIT_TAGS && TAG_IMPLICIT_LEN[tag.val] >= 0 {\n-            Ok(Res { val: TAG_IMPLICIT_LEN[tag.val] as uint, next: tag.next })\n+            Ok(Res { val: TAG_IMPLICIT_LEN[tag.val] as usize, next: tag.next })\n         } else {\n             vuint_at(data, tag.next)\n         }\n     }\n \n-    pub fn doc_at<'a>(data: &'a [u8], start: uint) -> DecodeResult<TaggedDoc<'a>> {\n+    pub fn doc_at<'a>(data: &'a [u8], start: usize) -> DecodeResult<TaggedDoc<'a>> {\n         let elt_tag = try!(tag_at(data, start));\n         let elt_size = try!(tag_len_at(data, elt_tag));\n         let end = elt_size.next + elt_size.val;\n@@ -376,7 +375,7 @@ pub mod reader {\n         })\n     }\n \n-    pub fn maybe_get_doc<'a>(d: Doc<'a>, tg: uint) -> Option<Doc<'a>> {\n+    pub fn maybe_get_doc<'a>(d: Doc<'a>, tg: usize) -> Option<Doc<'a>> {\n         let mut pos = d.start;\n         while pos < d.end {\n             let elt_tag = try_or!(tag_at(d.data, pos), None);\n@@ -390,7 +389,7 @@ pub mod reader {\n         None\n     }\n \n-    pub fn get_doc<'a>(d: Doc<'a>, tg: uint) -> Doc<'a> {\n+    pub fn get_doc<'a>(d: Doc<'a>, tg: usize) -> Doc<'a> {\n         match maybe_get_doc(d, tg) {\n             Some(d) => d,\n             None => {\n@@ -401,7 +400,7 @@ pub mod reader {\n     }\n \n     pub fn docs<F>(d: Doc, mut it: F) -> bool where\n-        F: FnMut(uint, Doc) -> bool,\n+        F: FnMut(usize, Doc) -> bool,\n     {\n         let mut pos = d.start;\n         while pos < d.end {\n@@ -416,7 +415,7 @@ pub mod reader {\n         return true;\n     }\n \n-    pub fn tagged_docs<F>(d: Doc, tg: uint, mut it: F) -> bool where\n+    pub fn tagged_docs<F>(d: Doc, tg: usize, mut it: F) -> bool where\n         F: FnMut(Doc) -> bool,\n     {\n         let mut pos = d.start;\n@@ -475,7 +474,7 @@ pub mod reader {\n \n     pub struct Decoder<'a> {\n         parent: Doc<'a>,\n-        pos: uint,\n+        pos: usize,\n     }\n \n     impl<'doc> Decoder<'doc> {\n@@ -501,7 +500,7 @@ pub mod reader {\n                    r_tag,\n                    r_doc.start,\n                    r_doc.end);\n-            if r_tag != (exp_tag as uint) {\n+            if r_tag != (exp_tag as usize) {\n                 return Err(Expected(format!(\"expected EBML doc with tag {:?} but \\\n                                              found tag {:?}\", exp_tag, r_tag)));\n             }\n@@ -528,18 +527,18 @@ pub mod reader {\n             Ok(r)\n         }\n \n-        fn _next_sub(&mut self) -> DecodeResult<uint> {\n+        fn _next_sub(&mut self) -> DecodeResult<usize> {\n             // empty vector/map optimization\n             if self.parent.is_empty() {\n                 return Ok(0);\n             }\n \n             let TaggedDoc { tag: r_tag, doc: r_doc } =\n                 try!(doc_at(self.parent.data, self.pos));\n-            let r = if r_tag == (EsSub8 as uint) {\n-                doc_as_u8(r_doc) as uint\n-            } else if r_tag == (EsSub32 as uint) {\n-                doc_as_u32(r_doc) as uint\n+            let r = if r_tag == (EsSub8 as usize) {\n+                doc_as_u8(r_doc) as usize\n+            } else if r_tag == (EsSub32 as usize) {\n+                doc_as_u32(r_doc) as usize\n             } else {\n                 return Err(Expected(format!(\"expected EBML doc with tag {:?} or {:?} but \\\n                                              found tag {:?}\", EsSub8, EsSub32, r_tag)));\n@@ -568,8 +567,8 @@ pub mod reader {\n \n             let TaggedDoc { tag: r_tag, doc: r_doc } =\n                 try!(doc_at(self.parent.data, self.pos));\n-            let r = if first_tag as uint <= r_tag && r_tag <= last_tag as uint {\n-                match r_tag - first_tag as uint {\n+            let r = if first_tag as usize <= r_tag && r_tag <= last_tag as usize {\n+                match r_tag - first_tag as usize {\n                     0 => doc_as_u8(r_doc) as u64,\n                     1 => doc_as_u16(r_doc) as u64,\n                     2 => doc_as_u32(r_doc) as u64,\n@@ -615,26 +614,26 @@ pub mod reader {\n         fn read_u32(&mut self) -> DecodeResult<u32> { Ok(try!(self._next_int(EsU8, EsU32)) as u32) }\n         fn read_u16(&mut self) -> DecodeResult<u16> { Ok(try!(self._next_int(EsU8, EsU16)) as u16) }\n         fn read_u8(&mut self) -> DecodeResult<u8> { Ok(doc_as_u8(try!(self.next_doc(EsU8)))) }\n-        fn read_uint(&mut self) -> DecodeResult<uint> {\n+        fn read_uint(&mut self) -> DecodeResult<usize> {\n             let v = try!(self._next_int(EsU8, EsU64));\n             if v > (::std::usize::MAX as u64) {\n-                Err(IntTooBig(v as uint))\n+                Err(IntTooBig(v as usize))\n             } else {\n-                Ok(v as uint)\n+                Ok(v as usize)\n             }\n         }\n \n         fn read_i64(&mut self) -> DecodeResult<i64> { Ok(try!(self._next_int(EsI8, EsI64)) as i64) }\n         fn read_i32(&mut self) -> DecodeResult<i32> { Ok(try!(self._next_int(EsI8, EsI32)) as i32) }\n         fn read_i16(&mut self) -> DecodeResult<i16> { Ok(try!(self._next_int(EsI8, EsI16)) as i16) }\n         fn read_i8(&mut self) -> DecodeResult<i8> { Ok(doc_as_u8(try!(self.next_doc(EsI8))) as i8) }\n-        fn read_int(&mut self) -> DecodeResult<int> {\n+        fn read_int(&mut self) -> DecodeResult<isize> {\n             let v = try!(self._next_int(EsI8, EsI64)) as i64;\n             if v > (isize::MAX as i64) || v < (isize::MIN as i64) {\n                 debug!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n-                Err(IntTooBig(v as uint))\n+                Err(IntTooBig(v as usize))\n             } else {\n-                Ok(v as int)\n+                Ok(v as isize)\n             }\n         }\n \n@@ -678,7 +677,7 @@ pub mod reader {\n \n         fn read_enum_variant<T, F>(&mut self, _: &[&str],\n                                    mut f: F) -> DecodeResult<T>\n-            where F: FnMut(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n+            where F: FnMut(&mut Decoder<'doc>, usize) -> DecodeResult<T>,\n         {\n             debug!(\"read_enum_variant()\");\n             let idx = try!(self._next_sub());\n@@ -687,7 +686,7 @@ pub mod reader {\n             f(self, idx)\n         }\n \n-        fn read_enum_variant_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+        fn read_enum_variant_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n             debug!(\"read_enum_variant_arg(idx={})\", idx);\n@@ -696,7 +695,7 @@ pub mod reader {\n \n         fn read_enum_struct_variant<T, F>(&mut self, _: &[&str],\n                                           mut f: F) -> DecodeResult<T>\n-            where F: FnMut(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n+            where F: FnMut(&mut Decoder<'doc>, usize) -> DecodeResult<T>,\n         {\n             debug!(\"read_enum_struct_variant()\");\n             let idx = try!(self._next_sub());\n@@ -707,7 +706,7 @@ pub mod reader {\n \n         fn read_enum_struct_variant_field<T, F>(&mut self,\n                                                 name: &str,\n-                                                idx: uint,\n+                                                idx: usize,\n                                                 f: F)\n                                                 -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n@@ -716,21 +715,21 @@ pub mod reader {\n             f(self)\n         }\n \n-        fn read_struct<T, F>(&mut self, name: &str, _: uint, f: F) -> DecodeResult<T> where\n+        fn read_struct<T, F>(&mut self, name: &str, _: usize, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n             debug!(\"read_struct(name={})\", name);\n             f(self)\n         }\n \n-        fn read_struct_field<T, F>(&mut self, name: &str, idx: uint, f: F) -> DecodeResult<T> where\n+        fn read_struct_field<T, F>(&mut self, name: &str, idx: usize, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n             debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n             f(self)\n         }\n \n-        fn read_tuple<T, F>(&mut self, tuple_len: uint, f: F) -> DecodeResult<T> where\n+        fn read_tuple<T, F>(&mut self, tuple_len: usize, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n             debug!(\"read_tuple()\");\n@@ -744,22 +743,22 @@ pub mod reader {\n             })\n         }\n \n-        fn read_tuple_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+        fn read_tuple_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n             debug!(\"read_tuple_arg(idx={})\", idx);\n             self.read_seq_elt(idx, f)\n         }\n \n-        fn read_tuple_struct<T, F>(&mut self, name: &str, len: uint, f: F) -> DecodeResult<T> where\n+        fn read_tuple_struct<T, F>(&mut self, name: &str, len: usize, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n             debug!(\"read_tuple_struct(name={})\", name);\n             self.read_tuple(len, f)\n         }\n \n         fn read_tuple_struct_arg<T, F>(&mut self,\n-                                       idx: uint,\n+                                       idx: usize,\n                                        f: F)\n                                        -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n@@ -786,7 +785,7 @@ pub mod reader {\n         }\n \n         fn read_seq<T, F>(&mut self, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n+            F: FnOnce(&mut Decoder<'doc>, usize) -> DecodeResult<T>,\n         {\n             debug!(\"read_seq()\");\n             self.push_doc(EsVec, move |d| {\n@@ -796,15 +795,15 @@ pub mod reader {\n             })\n         }\n \n-        fn read_seq_elt<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+        fn read_seq_elt<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n             debug!(\"read_seq_elt(idx={})\", idx);\n             self.push_doc(EsVecElt, f)\n         }\n \n         fn read_map<T, F>(&mut self, f: F) -> DecodeResult<T> where\n-            F: FnOnce(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n+            F: FnOnce(&mut Decoder<'doc>, usize) -> DecodeResult<T>,\n         {\n             debug!(\"read_map()\");\n             self.push_doc(EsMap, move |d| {\n@@ -814,14 +813,14 @@ pub mod reader {\n             })\n         }\n \n-        fn read_map_elt_key<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+        fn read_map_elt_key<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n             debug!(\"read_map_elt_key(idx={})\", idx);\n             self.push_doc(EsMapKey, f)\n         }\n \n-        fn read_map_elt_val<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+        fn read_map_elt_val<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n             debug!(\"read_map_elt_val(idx={})\", idx);\n@@ -859,7 +858,7 @@ pub mod writer {\n         relax_limit: u64, // do not move encoded bytes before this position\n     }\n \n-    fn write_tag<W: Write>(w: &mut W, n: uint) -> EncodeResult {\n+    fn write_tag<W: Write>(w: &mut W, n: usize) -> EncodeResult {\n         if n < 0xf0 {\n             w.write_all(&[n as u8])\n         } else if 0x100 <= n && n < NUM_TAGS {\n@@ -870,7 +869,7 @@ pub mod writer {\n         }\n     }\n \n-    fn write_sized_vuint<W: Write>(w: &mut W, n: uint, size: uint) -> EncodeResult {\n+    fn write_sized_vuint<W: Write>(w: &mut W, n: usize, size: usize) -> EncodeResult {\n         match size {\n             1 => w.write_all(&[0x80 | (n as u8)]),\n             2 => w.write_all(&[0x40 | ((n >> 8) as u8), n as u8]),\n@@ -879,16 +878,16 @@ pub mod writer {\n             4 => w.write_all(&[0x10 | ((n >> 24) as u8), (n >> 16) as u8,\n                             (n >> 8) as u8, n as u8]),\n             _ => Err(io::Error::new(io::ErrorKind::Other,\n-                                    \"int too big\", Some(n.to_string())))\n+                                    \"isize too big\", Some(n.to_string())))\n         }\n     }\n \n-    fn write_vuint<W: Write>(w: &mut W, n: uint) -> EncodeResult {\n+    fn write_vuint<W: Write>(w: &mut W, n: usize) -> EncodeResult {\n         if n < 0x7f { return write_sized_vuint(w, n, 1); }\n         if n < 0x4000 { return write_sized_vuint(w, n, 2); }\n         if n < 0x200000 { return write_sized_vuint(w, n, 3); }\n         if n < 0x10000000 { return write_sized_vuint(w, n, 4); }\n-        Err(io::Error::new(io::ErrorKind::Other, \"int too big\",\n+        Err(io::Error::new(io::ErrorKind::Other, \"isize too big\",\n                            Some(n.to_string())))\n     }\n \n@@ -910,7 +909,7 @@ pub mod writer {\n             }\n         }\n \n-        pub fn start_tag(&mut self, tag_id: uint) -> EncodeResult {\n+        pub fn start_tag(&mut self, tag_id: usize) -> EncodeResult {\n             debug!(\"Start tag {:?}\", tag_id);\n             assert!(tag_id >= NUM_IMPLICIT_TAGS);\n \n@@ -932,13 +931,13 @@ pub mod writer {\n \n             // relax the size encoding for small tags (bigger tags are costly to move).\n             // we should never try to move the stable positions, however.\n-            const RELAX_MAX_SIZE: uint = 0x100;\n+            const RELAX_MAX_SIZE: usize = 0x100;\n             if size <= RELAX_MAX_SIZE && last_size_pos >= self.relax_limit {\n                 // we can't alter the buffer in place, so have a temporary buffer\n                 let mut buf = [0u8; RELAX_MAX_SIZE];\n                 {\n                     let last_size_pos = last_size_pos as usize;\n-                    let data = &self.writer.get_ref()[last_size_pos+4..cur_pos as uint];\n+                    let data = &self.writer.get_ref()[last_size_pos+4..cur_pos as usize];\n                     bytes::copy_memory(&mut buf, data);\n                 }\n \n@@ -955,98 +954,98 @@ pub mod writer {\n             Ok(())\n         }\n \n-        pub fn wr_tag<F>(&mut self, tag_id: uint, blk: F) -> EncodeResult where\n+        pub fn wr_tag<F>(&mut self, tag_id: usize, blk: F) -> EncodeResult where\n             F: FnOnce() -> EncodeResult,\n         {\n             try!(self.start_tag(tag_id));\n             try!(blk());\n             self.end_tag()\n         }\n \n-        pub fn wr_tagged_bytes(&mut self, tag_id: uint, b: &[u8]) -> EncodeResult {\n+        pub fn wr_tagged_bytes(&mut self, tag_id: usize, b: &[u8]) -> EncodeResult {\n             assert!(tag_id >= NUM_IMPLICIT_TAGS);\n             try!(write_tag(self.writer, tag_id));\n             try!(write_vuint(self.writer, b.len()));\n             self.writer.write_all(b)\n         }\n \n-        pub fn wr_tagged_u64(&mut self, tag_id: uint, v: u64) -> EncodeResult {\n+        pub fn wr_tagged_u64(&mut self, tag_id: usize, v: u64) -> EncodeResult {\n             let bytes: [u8; 8] = unsafe { mem::transmute(v.to_be()) };\n             self.wr_tagged_bytes(tag_id, &bytes)\n         }\n \n-        pub fn wr_tagged_u32(&mut self, tag_id: uint, v: u32)  -> EncodeResult{\n+        pub fn wr_tagged_u32(&mut self, tag_id: usize, v: u32)  -> EncodeResult{\n             let bytes: [u8; 4] = unsafe { mem::transmute(v.to_be()) };\n             self.wr_tagged_bytes(tag_id, &bytes)\n         }\n \n-        pub fn wr_tagged_u16(&mut self, tag_id: uint, v: u16) -> EncodeResult {\n+        pub fn wr_tagged_u16(&mut self, tag_id: usize, v: u16) -> EncodeResult {\n             let bytes: [u8; 2] = unsafe { mem::transmute(v.to_be()) };\n             self.wr_tagged_bytes(tag_id, &bytes)\n         }\n \n-        pub fn wr_tagged_u8(&mut self, tag_id: uint, v: u8) -> EncodeResult {\n+        pub fn wr_tagged_u8(&mut self, tag_id: usize, v: u8) -> EncodeResult {\n             self.wr_tagged_bytes(tag_id, &[v])\n         }\n \n-        pub fn wr_tagged_i64(&mut self, tag_id: uint, v: i64) -> EncodeResult {\n+        pub fn wr_tagged_i64(&mut self, tag_id: usize, v: i64) -> EncodeResult {\n             self.wr_tagged_u64(tag_id, v as u64)\n         }\n \n-        pub fn wr_tagged_i32(&mut self, tag_id: uint, v: i32) -> EncodeResult {\n+        pub fn wr_tagged_i32(&mut self, tag_id: usize, v: i32) -> EncodeResult {\n             self.wr_tagged_u32(tag_id, v as u32)\n         }\n \n-        pub fn wr_tagged_i16(&mut self, tag_id: uint, v: i16) -> EncodeResult {\n+        pub fn wr_tagged_i16(&mut self, tag_id: usize, v: i16) -> EncodeResult {\n             self.wr_tagged_u16(tag_id, v as u16)\n         }\n \n-        pub fn wr_tagged_i8(&mut self, tag_id: uint, v: i8) -> EncodeResult {\n+        pub fn wr_tagged_i8(&mut self, tag_id: usize, v: i8) -> EncodeResult {\n             self.wr_tagged_bytes(tag_id, &[v as u8])\n         }\n \n-        pub fn wr_tagged_str(&mut self, tag_id: uint, v: &str) -> EncodeResult {\n+        pub fn wr_tagged_str(&mut self, tag_id: usize, v: &str) -> EncodeResult {\n             self.wr_tagged_bytes(tag_id, v.as_bytes())\n         }\n \n         // for auto-serialization\n-        fn wr_tagged_raw_bytes(&mut self, tag_id: uint, b: &[u8]) -> EncodeResult {\n+        fn wr_tagged_raw_bytes(&mut self, tag_id: usize, b: &[u8]) -> EncodeResult {\n             try!(write_tag(self.writer, tag_id));\n             self.writer.write_all(b)\n         }\n \n-        fn wr_tagged_raw_u64(&mut self, tag_id: uint, v: u64) -> EncodeResult {\n+        fn wr_tagged_raw_u64(&mut self, tag_id: usize, v: u64) -> EncodeResult {\n             let bytes: [u8; 8] = unsafe { mem::transmute(v.to_be()) };\n             self.wr_tagged_raw_bytes(tag_id, &bytes)\n         }\n \n-        fn wr_tagged_raw_u32(&mut self, tag_id: uint, v: u32)  -> EncodeResult{\n+        fn wr_tagged_raw_u32(&mut self, tag_id: usize, v: u32)  -> EncodeResult{\n             let bytes: [u8; 4] = unsafe { mem::transmute(v.to_be()) };\n             self.wr_tagged_raw_bytes(tag_id, &bytes)\n         }\n \n-        fn wr_tagged_raw_u16(&mut self, tag_id: uint, v: u16) -> EncodeResult {\n+        fn wr_tagged_raw_u16(&mut self, tag_id: usize, v: u16) -> EncodeResult {\n             let bytes: [u8; 2] = unsafe { mem::transmute(v.to_be()) };\n             self.wr_tagged_raw_bytes(tag_id, &bytes)\n         }\n \n-        fn wr_tagged_raw_u8(&mut self, tag_id: uint, v: u8) -> EncodeResult {\n+        fn wr_tagged_raw_u8(&mut self, tag_id: usize, v: u8) -> EncodeResult {\n             self.wr_tagged_raw_bytes(tag_id, &[v])\n         }\n \n-        fn wr_tagged_raw_i64(&mut self, tag_id: uint, v: i64) -> EncodeResult {\n+        fn wr_tagged_raw_i64(&mut self, tag_id: usize, v: i64) -> EncodeResult {\n             self.wr_tagged_raw_u64(tag_id, v as u64)\n         }\n \n-        fn wr_tagged_raw_i32(&mut self, tag_id: uint, v: i32) -> EncodeResult {\n+        fn wr_tagged_raw_i32(&mut self, tag_id: usize, v: i32) -> EncodeResult {\n             self.wr_tagged_raw_u32(tag_id, v as u32)\n         }\n \n-        fn wr_tagged_raw_i16(&mut self, tag_id: uint, v: i16) -> EncodeResult {\n+        fn wr_tagged_raw_i16(&mut self, tag_id: usize, v: i16) -> EncodeResult {\n             self.wr_tagged_raw_u16(tag_id, v as u16)\n         }\n \n-        fn wr_tagged_raw_i8(&mut self, tag_id: uint, v: i8) -> EncodeResult {\n+        fn wr_tagged_raw_i8(&mut self, tag_id: usize, v: i8) -> EncodeResult {\n             self.wr_tagged_raw_bytes(tag_id, &[v as u8])\n         }\n \n@@ -1073,11 +1072,11 @@ pub mod writer {\n \n     impl<'a> Encoder<'a> {\n         // used internally to emit things like the vector length and so on\n-        fn _emit_tagged_sub(&mut self, v: uint) -> EncodeResult {\n+        fn _emit_tagged_sub(&mut self, v: usize) -> EncodeResult {\n             if let Some(v) = v.to_u8() {\n-                self.wr_tagged_raw_u8(EsSub8 as uint, v)\n+                self.wr_tagged_raw_u8(EsSub8 as usize, v)\n             } else if let Some(v) = v.to_u32() {\n-                self.wr_tagged_raw_u32(EsSub32 as uint, v)\n+                self.wr_tagged_raw_u32(EsSub32 as usize, v)\n             } else {\n                 Err(io::Error::new(io::ErrorKind::Other,\n                                    \"length or variant id too big\",\n@@ -1088,7 +1087,7 @@ pub mod writer {\n         pub fn emit_opaque<F>(&mut self, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder) -> EncodeResult,\n         {\n-            try!(self.start_tag(EsOpaque as uint));\n+            try!(self.start_tag(EsOpaque as usize));\n             try!(f(self));\n             self.end_tag()\n         }\n@@ -1101,105 +1100,105 @@ pub mod writer {\n             Ok(())\n         }\n \n-        fn emit_uint(&mut self, v: uint) -> EncodeResult {\n+        fn emit_uint(&mut self, v: usize) -> EncodeResult {\n             self.emit_u64(v as u64)\n         }\n         fn emit_u64(&mut self, v: u64) -> EncodeResult {\n             match v.to_u32() {\n                 Some(v) => self.emit_u32(v),\n-                None => self.wr_tagged_raw_u64(EsU64 as uint, v)\n+                None => self.wr_tagged_raw_u64(EsU64 as usize, v)\n             }\n         }\n         fn emit_u32(&mut self, v: u32) -> EncodeResult {\n             match v.to_u16() {\n                 Some(v) => self.emit_u16(v),\n-                None => self.wr_tagged_raw_u32(EsU32 as uint, v)\n+                None => self.wr_tagged_raw_u32(EsU32 as usize, v)\n             }\n         }\n         fn emit_u16(&mut self, v: u16) -> EncodeResult {\n             match v.to_u8() {\n                 Some(v) => self.emit_u8(v),\n-                None => self.wr_tagged_raw_u16(EsU16 as uint, v)\n+                None => self.wr_tagged_raw_u16(EsU16 as usize, v)\n             }\n         }\n         fn emit_u8(&mut self, v: u8) -> EncodeResult {\n-            self.wr_tagged_raw_u8(EsU8 as uint, v)\n+            self.wr_tagged_raw_u8(EsU8 as usize, v)\n         }\n \n-        fn emit_int(&mut self, v: int) -> EncodeResult {\n+        fn emit_int(&mut self, v: isize) -> EncodeResult {\n             self.emit_i64(v as i64)\n         }\n         fn emit_i64(&mut self, v: i64) -> EncodeResult {\n             match v.to_i32() {\n                 Some(v) => self.emit_i32(v),\n-                None => self.wr_tagged_raw_i64(EsI64 as uint, v)\n+                None => self.wr_tagged_raw_i64(EsI64 as usize, v)\n             }\n         }\n         fn emit_i32(&mut self, v: i32) -> EncodeResult {\n             match v.to_i16() {\n                 Some(v) => self.emit_i16(v),\n-                None => self.wr_tagged_raw_i32(EsI32 as uint, v)\n+                None => self.wr_tagged_raw_i32(EsI32 as usize, v)\n             }\n         }\n         fn emit_i16(&mut self, v: i16) -> EncodeResult {\n             match v.to_i8() {\n                 Some(v) => self.emit_i8(v),\n-                None => self.wr_tagged_raw_i16(EsI16 as uint, v)\n+                None => self.wr_tagged_raw_i16(EsI16 as usize, v)\n             }\n         }\n         fn emit_i8(&mut self, v: i8) -> EncodeResult {\n-            self.wr_tagged_raw_i8(EsI8 as uint, v)\n+            self.wr_tagged_raw_i8(EsI8 as usize, v)\n         }\n \n         fn emit_bool(&mut self, v: bool) -> EncodeResult {\n-            self.wr_tagged_raw_u8(EsBool as uint, v as u8)\n+            self.wr_tagged_raw_u8(EsBool as usize, v as u8)\n         }\n \n         fn emit_f64(&mut self, v: f64) -> EncodeResult {\n             let bits = unsafe { mem::transmute(v) };\n-            self.wr_tagged_raw_u64(EsF64 as uint, bits)\n+            self.wr_tagged_raw_u64(EsF64 as usize, bits)\n         }\n         fn emit_f32(&mut self, v: f32) -> EncodeResult {\n             let bits = unsafe { mem::transmute(v) };\n-            self.wr_tagged_raw_u32(EsF32 as uint, bits)\n+            self.wr_tagged_raw_u32(EsF32 as usize, bits)\n         }\n         fn emit_char(&mut self, v: char) -> EncodeResult {\n-            self.wr_tagged_raw_u32(EsChar as uint, v as u32)\n+            self.wr_tagged_raw_u32(EsChar as usize, v as u32)\n         }\n \n         fn emit_str(&mut self, v: &str) -> EncodeResult {\n-            self.wr_tagged_str(EsStr as uint, v)\n+            self.wr_tagged_str(EsStr as usize, v)\n         }\n \n         fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n-            try!(self.start_tag(EsEnum as uint));\n+            try!(self.start_tag(EsEnum as usize));\n             try!(f(self));\n             self.end_tag()\n         }\n \n         fn emit_enum_variant<F>(&mut self,\n                                 _: &str,\n-                                v_id: uint,\n-                                _: uint,\n+                                v_id: usize,\n+                                _: usize,\n                                 f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             try!(self._emit_tagged_sub(v_id));\n             f(self)\n         }\n \n-        fn emit_enum_variant_arg<F>(&mut self, _: uint, f: F) -> EncodeResult where\n+        fn emit_enum_variant_arg<F>(&mut self, _: usize, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             f(self)\n         }\n \n         fn emit_enum_struct_variant<F>(&mut self,\n                                        v_name: &str,\n-                                       v_id: uint,\n-                                       cnt: uint,\n+                                       v_id: usize,\n+                                       cnt: usize,\n                                        f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n@@ -1208,42 +1207,42 @@ pub mod writer {\n \n         fn emit_enum_struct_variant_field<F>(&mut self,\n                                              _: &str,\n-                                             idx: uint,\n+                                             idx: usize,\n                                              f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             self.emit_enum_variant_arg(idx, f)\n         }\n \n-        fn emit_struct<F>(&mut self, _: &str, _len: uint, f: F) -> EncodeResult where\n+        fn emit_struct<F>(&mut self, _: &str, _len: usize, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             f(self)\n         }\n \n-        fn emit_struct_field<F>(&mut self, _name: &str, _: uint, f: F) -> EncodeResult where\n+        fn emit_struct_field<F>(&mut self, _name: &str, _: usize, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             f(self)\n         }\n \n-        fn emit_tuple<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+        fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             self.emit_seq(len, f)\n         }\n-        fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+        fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             self.emit_seq_elt(idx, f)\n         }\n \n-        fn emit_tuple_struct<F>(&mut self, _: &str, len: uint, f: F) -> EncodeResult where\n+        fn emit_tuple_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             self.emit_seq(len, f)\n         }\n-        fn emit_tuple_struct_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+        fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             self.emit_seq_elt(idx, f)\n@@ -1264,56 +1263,56 @@ pub mod writer {\n             self.emit_enum_variant(\"Some\", 1, 1, f)\n         }\n \n-        fn emit_seq<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+        fn emit_seq<F>(&mut self, len: usize, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             if len == 0 {\n                 // empty vector optimization\n-                return self.wr_tagged_bytes(EsVec as uint, &[]);\n+                return self.wr_tagged_bytes(EsVec as usize, &[]);\n             }\n \n-            try!(self.start_tag(EsVec as uint));\n+            try!(self.start_tag(EsVec as usize));\n             try!(self._emit_tagged_sub(len));\n             try!(f(self));\n             self.end_tag()\n         }\n \n-        fn emit_seq_elt<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n+        fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n \n-            try!(self.start_tag(EsVecElt as uint));\n+            try!(self.start_tag(EsVecElt as usize));\n             try!(f(self));\n             self.end_tag()\n         }\n \n-        fn emit_map<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+        fn emit_map<F>(&mut self, len: usize, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n             if len == 0 {\n                 // empty map optimization\n-                return self.wr_tagged_bytes(EsMap as uint, &[]);\n+                return self.wr_tagged_bytes(EsMap as usize, &[]);\n             }\n \n-            try!(self.start_tag(EsMap as uint));\n+            try!(self.start_tag(EsMap as usize));\n             try!(self._emit_tagged_sub(len));\n             try!(f(self));\n             self.end_tag()\n         }\n \n-        fn emit_map_elt_key<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n+        fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n \n-            try!(self.start_tag(EsMapKey as uint));\n+            try!(self.start_tag(EsMapKey as usize));\n             try!(f(self));\n             self.end_tag()\n         }\n \n-        fn emit_map_elt_val<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n+        fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult where\n             F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n         {\n-            try!(self.start_tag(EsMapVal as uint));\n+            try!(self.start_tag(EsMapVal as usize));\n             try!(f(self));\n             self.end_tag()\n         }\n@@ -1381,7 +1380,7 @@ mod tests {\n \n     #[test]\n     fn test_option_int() {\n-        fn test_v(v: Option<int>) {\n+        fn test_v(v: Option<isize>) {\n             debug!(\"v == {:?}\", v);\n             let mut wr = Cursor::new(Vec::new());\n             {"}, {"sha": "4a7399ec8e43d1c417a1052d32aee98c0087b237", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -30,7 +30,6 @@\n #![feature(collections)]\n #![feature(core)]\n #![feature(hash)]\n-#![feature(int_uint)]\n #![feature(libc)]\n #![feature(old_path)]\n #![feature(quote)]"}, {"sha": "e4c0eda0448bdae443eeaeed4503b5dee84ff8d8", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 109, "deletions": 109, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -21,82 +21,82 @@ use back::svh::Svh;\n // 0xf0..0xff: internally used by RBML to encode 0x100..0xfff in two bytes\n // 0x100..0xfff: free for use, preferred for infrequent tags\n \n-pub const tag_items: uint = 0x100; // top-level only\n+pub const tag_items: usize = 0x100; // top-level only\n \n-pub const tag_paths_data_name: uint = 0x20;\n+pub const tag_paths_data_name: usize = 0x20;\n \n-pub const tag_def_id: uint = 0x21;\n+pub const tag_def_id: usize = 0x21;\n \n-pub const tag_items_data: uint = 0x22;\n+pub const tag_items_data: usize = 0x22;\n \n-pub const tag_items_data_item: uint = 0x23;\n+pub const tag_items_data_item: usize = 0x23;\n \n-pub const tag_items_data_item_family: uint = 0x24;\n+pub const tag_items_data_item_family: usize = 0x24;\n \n-pub const tag_items_data_item_type: uint = 0x25;\n+pub const tag_items_data_item_type: usize = 0x25;\n \n-pub const tag_items_data_item_symbol: uint = 0x26;\n+pub const tag_items_data_item_symbol: usize = 0x26;\n \n-pub const tag_items_data_item_variant: uint = 0x27;\n+pub const tag_items_data_item_variant: usize = 0x27;\n \n-pub const tag_items_data_parent_item: uint = 0x28;\n+pub const tag_items_data_parent_item: usize = 0x28;\n \n-pub const tag_items_data_item_is_tuple_struct_ctor: uint = 0x29;\n+pub const tag_items_data_item_is_tuple_struct_ctor: usize = 0x29;\n \n-pub const tag_index: uint = 0x2a;\n+pub const tag_index: usize = 0x2a;\n \n-pub const tag_index_buckets: uint = 0x2b;\n+pub const tag_index_buckets: usize = 0x2b;\n \n-pub const tag_index_buckets_bucket: uint = 0x2c;\n+pub const tag_index_buckets_bucket: usize = 0x2c;\n \n-pub const tag_index_buckets_bucket_elt: uint = 0x2d;\n+pub const tag_index_buckets_bucket_elt: usize = 0x2d;\n \n-pub const tag_index_table: uint = 0x2e;\n+pub const tag_index_table: usize = 0x2e;\n \n-pub const tag_meta_item_name_value: uint = 0x2f;\n+pub const tag_meta_item_name_value: usize = 0x2f;\n \n-pub const tag_meta_item_name: uint = 0x30;\n+pub const tag_meta_item_name: usize = 0x30;\n \n-pub const tag_meta_item_value: uint = 0x31;\n+pub const tag_meta_item_value: usize = 0x31;\n \n-pub const tag_attributes: uint = 0x101; // top-level only\n+pub const tag_attributes: usize = 0x101; // top-level only\n \n-pub const tag_attribute: uint = 0x32;\n+pub const tag_attribute: usize = 0x32;\n \n-pub const tag_meta_item_word: uint = 0x33;\n+pub const tag_meta_item_word: usize = 0x33;\n \n-pub const tag_meta_item_list: uint = 0x34;\n+pub const tag_meta_item_list: usize = 0x34;\n \n // The list of crates that this crate depends on\n-pub const tag_crate_deps: uint = 0x102; // top-level only\n+pub const tag_crate_deps: usize = 0x102; // top-level only\n \n // A single crate dependency\n-pub const tag_crate_dep: uint = 0x35;\n+pub const tag_crate_dep: usize = 0x35;\n \n-pub const tag_crate_hash: uint = 0x103; // top-level only\n-pub const tag_crate_crate_name: uint = 0x104; // top-level only\n+pub const tag_crate_hash: usize = 0x103; // top-level only\n+pub const tag_crate_crate_name: usize = 0x104; // top-level only\n \n-pub const tag_crate_dep_crate_name: uint = 0x36;\n-pub const tag_crate_dep_hash: uint = 0x37;\n+pub const tag_crate_dep_crate_name: usize = 0x36;\n+pub const tag_crate_dep_hash: usize = 0x37;\n \n-pub const tag_mod_impl: uint = 0x38;\n+pub const tag_mod_impl: usize = 0x38;\n \n-pub const tag_item_trait_item: uint = 0x39;\n+pub const tag_item_trait_item: usize = 0x39;\n \n-pub const tag_item_trait_ref: uint = 0x3a;\n+pub const tag_item_trait_ref: usize = 0x3a;\n \n // discriminator value for variants\n-pub const tag_disr_val: uint = 0x3c;\n+pub const tag_disr_val: usize = 0x3c;\n \n // used to encode ast_map::PathElem\n-pub const tag_path: uint = 0x3d;\n-pub const tag_path_len: uint = 0x3e;\n-pub const tag_path_elem_mod: uint = 0x3f;\n-pub const tag_path_elem_name: uint = 0x40;\n-pub const tag_item_field: uint = 0x41;\n-pub const tag_item_field_origin: uint = 0x42;\n-\n-pub const tag_item_variances: uint = 0x43;\n+pub const tag_path: usize = 0x3d;\n+pub const tag_path_len: usize = 0x3e;\n+pub const tag_path_elem_mod: usize = 0x3f;\n+pub const tag_path_elem_name: usize = 0x40;\n+pub const tag_item_field: usize = 0x41;\n+pub const tag_item_field_origin: usize = 0x42;\n+\n+pub const tag_item_variances: usize = 0x43;\n /*\n   trait items contain tag_item_trait_item elements,\n   impl items contain tag_item_impl_item elements, and classes\n@@ -105,19 +105,19 @@ pub const tag_item_variances: uint = 0x43;\n   both, tag_item_trait_item and tag_item_impl_item have to be two\n   different tags.\n  */\n-pub const tag_item_impl_item: uint = 0x44;\n-pub const tag_item_trait_method_explicit_self: uint = 0x45;\n+pub const tag_item_impl_item: usize = 0x44;\n+pub const tag_item_trait_method_explicit_self: usize = 0x45;\n \n \n // Reexports are found within module tags. Each reexport contains def_ids\n // and names.\n-pub const tag_items_data_item_reexport: uint = 0x46;\n-pub const tag_items_data_item_reexport_def_id: uint = 0x47;\n-pub const tag_items_data_item_reexport_name: uint = 0x48;\n+pub const tag_items_data_item_reexport: usize = 0x46;\n+pub const tag_items_data_item_reexport_def_id: usize = 0x47;\n+pub const tag_items_data_item_reexport_name: usize = 0x48;\n \n // used to encode crate_ctxt side tables\n #[derive(Copy, PartialEq, FromPrimitive)]\n-#[repr(uint)]\n+#[repr(usize)]\n pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n     tag_ast = 0x50,\n \n@@ -149,15 +149,15 @@ pub enum astencode_tag { // Reserves 0x50 -- 0x6f\n     tag_table_const_qualif = 0x69,\n }\n \n-pub const tag_item_trait_item_sort: uint = 0x70;\n+pub const tag_item_trait_item_sort: usize = 0x70;\n \n-pub const tag_item_trait_parent_sort: uint = 0x71;\n+pub const tag_item_trait_parent_sort: usize = 0x71;\n \n-pub const tag_item_impl_type_basename: uint = 0x72;\n+pub const tag_item_impl_type_basename: usize = 0x72;\n \n-pub const tag_crate_triple: uint = 0x105; // top-level only\n+pub const tag_crate_triple: usize = 0x105; // top-level only\n \n-pub const tag_dylib_dependency_formats: uint = 0x106; // top-level only\n+pub const tag_dylib_dependency_formats: usize = 0x106; // top-level only\n \n // Language items are a top-level directory (for speed). Hierarchy:\n //\n@@ -166,93 +166,93 @@ pub const tag_dylib_dependency_formats: uint = 0x106; // top-level only\n //   - tag_lang_items_item_id: u32\n //   - tag_lang_items_item_node_id: u32\n \n-pub const tag_lang_items: uint = 0x107; // top-level only\n-pub const tag_lang_items_item: uint = 0x73;\n-pub const tag_lang_items_item_id: uint = 0x74;\n-pub const tag_lang_items_item_node_id: uint = 0x75;\n-pub const tag_lang_items_missing: uint = 0x76;\n+pub const tag_lang_items: usize = 0x107; // top-level only\n+pub const tag_lang_items_item: usize = 0x73;\n+pub const tag_lang_items_item_id: usize = 0x74;\n+pub const tag_lang_items_item_node_id: usize = 0x75;\n+pub const tag_lang_items_missing: usize = 0x76;\n \n-pub const tag_item_unnamed_field: uint = 0x77;\n-pub const tag_items_data_item_visibility: uint = 0x78;\n+pub const tag_item_unnamed_field: usize = 0x77;\n+pub const tag_items_data_item_visibility: usize = 0x78;\n \n-pub const tag_item_method_tps: uint = 0x79;\n-pub const tag_item_method_fty: uint = 0x7a;\n+pub const tag_item_method_tps: usize = 0x79;\n+pub const tag_item_method_fty: usize = 0x7a;\n \n-pub const tag_mod_child: uint = 0x7b;\n-pub const tag_misc_info: uint = 0x108; // top-level only\n-pub const tag_misc_info_crate_items: uint = 0x7c;\n+pub const tag_mod_child: usize = 0x7b;\n+pub const tag_misc_info: usize = 0x108; // top-level only\n+pub const tag_misc_info_crate_items: usize = 0x7c;\n \n-pub const tag_item_method_provided_source: uint = 0x7d;\n-pub const tag_item_impl_vtables: uint = 0x7e;\n+pub const tag_item_method_provided_source: usize = 0x7d;\n+pub const tag_item_impl_vtables: usize = 0x7e;\n \n-pub const tag_impls: uint = 0x109; // top-level only\n-pub const tag_impls_impl: uint = 0x7f;\n+pub const tag_impls: usize = 0x109; // top-level only\n+pub const tag_impls_impl: usize = 0x7f;\n \n-pub const tag_items_data_item_inherent_impl: uint = 0x80;\n-pub const tag_items_data_item_extension_impl: uint = 0x81;\n+pub const tag_items_data_item_inherent_impl: usize = 0x80;\n+pub const tag_items_data_item_extension_impl: usize = 0x81;\n \n-pub const tag_native_libraries: uint = 0x10a; // top-level only\n-pub const tag_native_libraries_lib: uint = 0x82;\n-pub const tag_native_libraries_name: uint = 0x83;\n-pub const tag_native_libraries_kind: uint = 0x84;\n+pub const tag_native_libraries: usize = 0x10a; // top-level only\n+pub const tag_native_libraries_lib: usize = 0x82;\n+pub const tag_native_libraries_name: usize = 0x83;\n+pub const tag_native_libraries_kind: usize = 0x84;\n \n-pub const tag_plugin_registrar_fn: uint = 0x10b; // top-level only\n+pub const tag_plugin_registrar_fn: usize = 0x10b; // top-level only\n \n-pub const tag_method_argument_names: uint = 0x85;\n-pub const tag_method_argument_name: uint = 0x86;\n+pub const tag_method_argument_names: usize = 0x85;\n+pub const tag_method_argument_name: usize = 0x86;\n \n-pub const tag_reachable_extern_fns: uint = 0x10c; // top-level only\n-pub const tag_reachable_extern_fn_id: uint = 0x87;\n+pub const tag_reachable_extern_fns: usize = 0x10c; // top-level only\n+pub const tag_reachable_extern_fn_id: usize = 0x87;\n \n-pub const tag_items_data_item_stability: uint = 0x88;\n+pub const tag_items_data_item_stability: usize = 0x88;\n \n-pub const tag_items_data_item_repr: uint = 0x89;\n+pub const tag_items_data_item_repr: usize = 0x89;\n \n #[derive(Clone, Debug)]\n pub struct LinkMeta {\n     pub crate_name: String,\n     pub crate_hash: Svh,\n }\n \n-pub const tag_struct_fields: uint = 0x10d; // top-level only\n-pub const tag_struct_field: uint = 0x8a;\n-pub const tag_struct_field_id: uint = 0x8b;\n+pub const tag_struct_fields: usize = 0x10d; // top-level only\n+pub const tag_struct_field: usize = 0x8a;\n+pub const tag_struct_field_id: usize = 0x8b;\n \n-pub const tag_attribute_is_sugared_doc: uint = 0x8c;\n+pub const tag_attribute_is_sugared_doc: usize = 0x8c;\n \n-pub const tag_items_data_region: uint = 0x8e;\n+pub const tag_items_data_region: usize = 0x8e;\n \n-pub const tag_region_param_def: uint = 0x8f;\n-pub const tag_region_param_def_ident: uint = 0x90;\n-pub const tag_region_param_def_def_id: uint = 0x91;\n-pub const tag_region_param_def_space: uint = 0x92;\n-pub const tag_region_param_def_index: uint = 0x93;\n+pub const tag_region_param_def: usize = 0x8f;\n+pub const tag_region_param_def_ident: usize = 0x90;\n+pub const tag_region_param_def_def_id: usize = 0x91;\n+pub const tag_region_param_def_space: usize = 0x92;\n+pub const tag_region_param_def_index: usize = 0x93;\n \n-pub const tag_type_param_def: uint = 0x94;\n+pub const tag_type_param_def: usize = 0x94;\n \n-pub const tag_item_generics: uint = 0x95;\n-pub const tag_method_ty_generics: uint = 0x96;\n+pub const tag_item_generics: usize = 0x95;\n+pub const tag_method_ty_generics: usize = 0x96;\n \n-pub const tag_predicate: uint = 0x97;\n-pub const tag_predicate_space: uint = 0x98;\n-pub const tag_predicate_data: uint = 0x99;\n+pub const tag_predicate: usize = 0x97;\n+pub const tag_predicate_space: usize = 0x98;\n+pub const tag_predicate_data: usize = 0x99;\n \n-pub const tag_unsafety: uint = 0x9a;\n+pub const tag_unsafety: usize = 0x9a;\n \n-pub const tag_associated_type_names: uint = 0x9b;\n-pub const tag_associated_type_name: uint = 0x9c;\n+pub const tag_associated_type_names: usize = 0x9b;\n+pub const tag_associated_type_name: usize = 0x9c;\n \n-pub const tag_polarity: uint = 0x9d;\n+pub const tag_polarity: usize = 0x9d;\n \n-pub const tag_macro_defs: uint = 0x10e; // top-level only\n-pub const tag_macro_def: uint = 0x9e;\n-pub const tag_macro_def_body: uint = 0x9f;\n+pub const tag_macro_defs: usize = 0x10e; // top-level only\n+pub const tag_macro_def: usize = 0x9e;\n+pub const tag_macro_def_body: usize = 0x9f;\n \n-pub const tag_paren_sugar: uint = 0xa0;\n+pub const tag_paren_sugar: usize = 0xa0;\n \n-pub const tag_codemap: uint = 0xa1;\n-pub const tag_codemap_filemap: uint = 0xa2;\n+pub const tag_codemap: usize = 0xa1;\n+pub const tag_codemap_filemap: usize = 0xa2;\n \n-pub const tag_item_super_predicates: uint = 0xa3;\n+pub const tag_item_super_predicates: usize = 0xa3;\n \n-pub const tag_defaulted_trait: uint = 0xa4;\n+pub const tag_defaulted_trait: usize = 0xa4;"}, {"sha": "ebc3a6fd52c939b0afaf4b9004970f9450314bd5", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -46,7 +46,7 @@ pub fn each_lang_item<F>(cstore: &cstore::CStore,\n                          cnum: ast::CrateNum,\n                          f: F)\n                          -> bool where\n-    F: FnMut(ast::NodeId, uint) -> bool,\n+    F: FnMut(ast::NodeId, usize) -> bool,\n {\n     let crate_data = cstore.get_crate_data(cnum);\n     decoder::each_lang_item(&*crate_data, f)"}, {"sha": "811aa21a0b7b986ce8888cf73b83ad0ed2a25184", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -252,7 +252,7 @@ impl MetadataBlob {\n             let len = (((slice[0] as u32) << 24) |\n                        ((slice[1] as u32) << 16) |\n                        ((slice[2] as u32) << 8) |\n-                       ((slice[3] as u32) << 0)) as uint;\n+                       ((slice[3] as u32) << 0)) as usize;\n             if len + 4 <= slice.len() {\n                 &slice[4.. len + 4]\n             } else {"}, {"sha": "fc0b8543ea60c588ff6332ca82f1646300bc07cf", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -71,15 +71,15 @@ fn lookup_hash<'a, F>(d: rbml::Doc<'a>, mut eq_fn: F, hash: u64) -> Option<rbml:\n {\n     let index = reader::get_doc(d, tag_index);\n     let table = reader::get_doc(index, tag_index_table);\n-    let hash_pos = table.start + (hash % 256 * 4) as uint;\n-    let pos = u32_from_be_bytes(&d.data[hash_pos..]) as uint;\n+    let hash_pos = table.start + (hash % 256 * 4) as usize;\n+    let pos = u32_from_be_bytes(&d.data[hash_pos..]) as usize;\n     let tagged_doc = reader::doc_at(d.data, pos).unwrap();\n \n     let belt = tag_index_buckets_bucket_elt;\n \n     let mut ret = None;\n     reader::tagged_docs(tagged_doc.doc, belt, |elt| {\n-        let pos = u32_from_be_bytes(&elt.data[elt.start..]) as uint;\n+        let pos = u32_from_be_bytes(&elt.data[elt.start..]) as usize;\n         if eq_fn(&elt.data[elt.start + 4 .. elt.end]) {\n             ret = Some(reader::doc_at(d.data, pos).unwrap().doc);\n             false\n@@ -274,7 +274,7 @@ fn item_path(item_doc: rbml::Doc) -> Vec<ast_map::PathElem> {\n     let path_doc = reader::get_doc(item_doc, tag_path);\n \n     let len_doc = reader::get_doc(path_doc, tag_path_len);\n-    let len = reader::doc_as_u32(len_doc) as uint;\n+    let len = reader::doc_as_u32(len_doc) as usize;\n \n     let mut result = Vec::with_capacity(len);\n     reader::docs(path_doc, |tag, elt_doc| {\n@@ -513,13 +513,13 @@ pub enum DefLike {\n \n /// Iterates over the language items in the given crate.\n pub fn each_lang_item<F>(cdata: Cmd, mut f: F) -> bool where\n-    F: FnMut(ast::NodeId, uint) -> bool,\n+    F: FnMut(ast::NodeId, usize) -> bool,\n {\n     let root = rbml::Doc::new(cdata.data());\n     let lang_items = reader::get_doc(root, tag_lang_items);\n     reader::tagged_docs(lang_items, tag_lang_items_item, |item_doc| {\n         let id_doc = reader::get_doc(item_doc, tag_lang_items_item_id);\n-        let id = reader::doc_as_u32(id_doc) as uint;\n+        let id = reader::doc_as_u32(id_doc) as usize;\n         let node_id_doc = reader::get_doc(item_doc,\n                                           tag_lang_items_item_node_id);\n         let node_id = reader::doc_as_u32(node_id_doc) as ast::NodeId;\n@@ -1194,7 +1194,7 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n     let cratedoc = rbml::Doc::new(data);\n     let depsdoc = reader::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n-    fn docstr(doc: rbml::Doc, tag_: uint) -> String {\n+    fn docstr(doc: rbml::Doc, tag_: usize) -> String {\n         let d = reader::get_doc(doc, tag_);\n         d.as_str_slice().to_string()\n     }\n@@ -1454,7 +1454,7 @@ pub fn is_typedef(cdata: Cmd, id: ast::NodeId) -> bool {\n fn doc_generics<'tcx>(base_doc: rbml::Doc,\n                       tcx: &ty::ctxt<'tcx>,\n                       cdata: Cmd,\n-                      tag: uint)\n+                      tag: usize)\n                       -> ty::Generics<'tcx>\n {\n     let doc = reader::get_doc(base_doc, tag);\n@@ -1479,7 +1479,7 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n         let def_id = translate_def_id(cdata, def_id);\n \n         let doc = reader::get_doc(rp_doc, tag_region_param_def_space);\n-        let space = subst::ParamSpace::from_uint(reader::doc_as_u64(doc) as uint);\n+        let space = subst::ParamSpace::from_uint(reader::doc_as_u64(doc) as usize);\n \n         let doc = reader::get_doc(rp_doc, tag_region_param_def_index);\n         let index = reader::doc_as_u64(doc) as u32;\n@@ -1508,15 +1508,15 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n fn doc_predicates<'tcx>(base_doc: rbml::Doc,\n                         tcx: &ty::ctxt<'tcx>,\n                         cdata: Cmd,\n-                        tag: uint)\n+                        tag: usize)\n                         -> ty::GenericPredicates<'tcx>\n {\n     let doc = reader::get_doc(base_doc, tag);\n \n     let mut predicates = subst::VecPerParamSpace::empty();\n     reader::tagged_docs(doc, tag_predicate, |predicate_doc| {\n         let space_doc = reader::get_doc(predicate_doc, tag_predicate_space);\n-        let space = subst::ParamSpace::from_uint(reader::doc_as_u8(space_doc) as uint);\n+        let space = subst::ParamSpace::from_uint(reader::doc_as_u8(space_doc) as usize);\n \n         let data_doc = reader::get_doc(predicate_doc, tag_predicate_data);\n         let data = parse_predicate_data(data_doc.data, data_doc.start, cdata.cnum, tcx,"}, {"sha": "d5e8e152ee94998a4a2bfe29bc09928bdccb3520", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -105,7 +105,7 @@ struct entry<T> {\n fn encode_trait_ref<'a, 'tcx>(rbml_w: &mut Encoder,\n                               ecx: &EncodeContext<'a, 'tcx>,\n                               trait_ref: &ty::TraitRef<'tcx>,\n-                              tag: uint) {\n+                              tag: usize) {\n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n         ds: def_to_string,\n@@ -703,7 +703,7 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n                              ecx: &EncodeContext<'a, 'tcx>,\n                              generics: &ty::Generics<'tcx>,\n                              predicates: &ty::GenericPredicates<'tcx>,\n-                             tag: uint)\n+                             tag: usize)\n {\n     rbml_w.start_tag(tag);\n \n@@ -777,7 +777,7 @@ fn encode_predicates_in_current_doc<'a,'tcx>(rbml_w: &mut Encoder,\n fn encode_predicates<'a,'tcx>(rbml_w: &mut Encoder,\n                               ecx: &EncodeContext<'a,'tcx>,\n                               predicates: &ty::GenericPredicates<'tcx>,\n-                              tag: uint)\n+                              tag: usize)\n {\n     rbml_w.start_tag(tag);\n     encode_predicates_in_current_doc(rbml_w, ecx, predicates);\n@@ -1538,7 +1538,7 @@ fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn:\n     for elt in index {\n         let mut s = SipHasher::new();\n         elt.val.hash(&mut s);\n-        let h = s.finish() as uint;\n+        let h = s.finish() as usize;\n         (&mut buckets[h % 256]).push(elt);\n     }\n \n@@ -1944,7 +1944,7 @@ pub fn encode_metadata(parms: EncodeParams, krate: &ast::Crate) -> Vec<u8> {\n \n     // RBML compacts the encoded bytes whenever appropriate,\n     // so there are some garbages left after the end of the data.\n-    let metalen = wr.seek(SeekFrom::Current(0)).unwrap() as uint;\n+    let metalen = wr.seek(SeekFrom::Current(0)).unwrap() as usize;\n     let mut v = wr.into_inner();\n     v.truncate(metalen);\n     assert_eq!(v.len(), metalen);"}, {"sha": "b6053b930e9399988e6aa210b234319bc5264e78", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -745,7 +745,7 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n     unsafe {\n         let buf = common::path2cstr(filename);\n         let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf.as_ptr());\n-        if mb as int == 0 {\n+        if mb as isize == 0 {\n             return Err(format!(\"error reading library: '{}'\",\n                                filename.display()))\n         }\n@@ -761,12 +761,12 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n             let mut name_buf = ptr::null();\n             let name_len = llvm::LLVMRustGetSectionName(si.llsi, &mut name_buf);\n             let name = slice::from_raw_parts(name_buf as *const u8,\n-                                             name_len as uint).to_vec();\n+                                             name_len as usize).to_vec();\n             let name = String::from_utf8(name).unwrap();\n             debug!(\"get_metadata_section: name {}\", name);\n             if read_meta_section_name(is_osx) == name {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);\n-                let csz = llvm::LLVMGetSectionSize(si.llsi) as uint;\n+                let csz = llvm::LLVMGetSectionSize(si.llsi) as usize;\n                 let cvbuf: *const u8 = cbuf as *const u8;\n                 let vlen = encoder::metadata_encoding_version.len();\n                 debug!(\"checking {} bytes of metadata-version stamp\",\n@@ -779,7 +779,7 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n                                         filename.display())));\n                 }\n \n-                let cvbuf1 = cvbuf.offset(vlen as int);\n+                let cvbuf1 = cvbuf.offset(vlen as isize);\n                 debug!(\"inflating {} bytes of compressed metadata\",\n                        csz - vlen);\n                 let bytes = slice::from_raw_parts(cvbuf1, csz - vlen);"}, {"sha": "e2eebbfdc724d255056aad3cb6ba03d08a39e7c9", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -66,7 +66,7 @@ pub enum DefIdSource {\n pub struct PState<'a, 'tcx: 'a> {\n     data: &'a [u8],\n     krate: ast::CrateNum,\n-    pos: uint,\n+    pos: usize,\n     tcx: &'a ty::ctxt<'tcx>\n }\n \n@@ -119,7 +119,7 @@ fn parse_name_<F>(st: &mut PState, is_last: F) -> ast::Name where\n }\n \n pub fn parse_state_from_data<'a, 'tcx>(data: &'a [u8], crate_num: ast::CrateNum,\n-                                       pos: uint, tcx: &'a ty::ctxt<'tcx>)\n+                                       pos: usize, tcx: &'a ty::ctxt<'tcx>)\n                                        -> PState<'a, 'tcx> {\n     PState {\n         data: data,\n@@ -129,7 +129,7 @@ pub fn parse_state_from_data<'a, 'tcx>(data: &'a [u8], crate_num: ast::CrateNum,\n     }\n }\n \n-fn data_log_string(data: &[u8], pos: uint) -> String {\n+fn data_log_string(data: &[u8], pos: usize) -> String {\n     let mut buf = String::new();\n     buf.push_str(\"<<\");\n     for i in pos..data.len() {\n@@ -146,7 +146,7 @@ fn data_log_string(data: &[u8], pos: uint) -> String {\n \n pub fn parse_ty_closure_data<'tcx, F>(data: &[u8],\n                                       crate_num: ast::CrateNum,\n-                                      pos: uint,\n+                                      pos: usize,\n                                       tcx: &ty::ctxt<'tcx>,\n                                       conv: F)\n                                       -> ty::ClosureTy<'tcx> where\n@@ -156,7 +156,7 @@ pub fn parse_ty_closure_data<'tcx, F>(data: &[u8],\n     parse_closure_ty(&mut st, conv)\n }\n \n-pub fn parse_ty_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n+pub fn parse_ty_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: usize,\n                               tcx: &ty::ctxt<'tcx>, conv: F) -> Ty<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n@@ -165,7 +165,7 @@ pub fn parse_ty_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n     parse_ty(&mut st, conv)\n }\n \n-pub fn parse_region_data<F>(data: &[u8], crate_num: ast::CrateNum, pos: uint, tcx: &ty::ctxt,\n+pub fn parse_region_data<F>(data: &[u8], crate_num: ast::CrateNum, pos: usize, tcx: &ty::ctxt,\n                             conv: F) -> ty::Region where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n@@ -174,7 +174,7 @@ pub fn parse_region_data<F>(data: &[u8], crate_num: ast::CrateNum, pos: uint, tc\n     parse_region(&mut st, conv)\n }\n \n-pub fn parse_bare_fn_ty_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n+pub fn parse_bare_fn_ty_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: usize,\n                                       tcx: &ty::ctxt<'tcx>, conv: F)\n                                       -> ty::BareFnTy<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n@@ -184,7 +184,7 @@ pub fn parse_bare_fn_ty_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos\n     parse_bare_fn_ty(&mut st, conv)\n }\n \n-pub fn parse_trait_ref_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n+pub fn parse_trait_ref_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: usize,\n                                      tcx: &ty::ctxt<'tcx>, conv: F)\n                                      -> Rc<ty::TraitRef<'tcx>> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n@@ -194,7 +194,7 @@ pub fn parse_trait_ref_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos:\n     parse_trait_ref(&mut st, conv)\n }\n \n-pub fn parse_substs_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: uint,\n+pub fn parse_substs_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: usize,\n                                   tcx: &ty::ctxt<'tcx>, conv: F) -> subst::Substs<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n@@ -204,7 +204,7 @@ pub fn parse_substs_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: ui\n }\n \n pub fn parse_bounds_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum,\n-                                  pos: uint, tcx: &ty::ctxt<'tcx>, conv: F)\n+                                  pos: usize, tcx: &ty::ctxt<'tcx>, conv: F)\n                                   -> ty::ParamBounds<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n@@ -213,7 +213,7 @@ pub fn parse_bounds_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum,\n }\n \n pub fn parse_existential_bounds_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum,\n-                                              pos: uint, tcx: &ty::ctxt<'tcx>, conv: F)\n+                                              pos: usize, tcx: &ty::ctxt<'tcx>, conv: F)\n                                               -> ty::ExistentialBounds<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n@@ -222,15 +222,15 @@ pub fn parse_existential_bounds_data<'tcx, F>(data: &[u8], crate_num: ast::Crate\n }\n \n pub fn parse_builtin_bounds_data<F>(data: &[u8], crate_num: ast::CrateNum,\n-                                    pos: uint, tcx: &ty::ctxt, conv: F)\n+                                    pos: usize, tcx: &ty::ctxt, conv: F)\n                                     -> ty::BuiltinBounds where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n     parse_builtin_bounds(&mut st, conv)\n }\n \n-fn parse_size(st: &mut PState) -> Option<uint> {\n+fn parse_size(st: &mut PState) -> Option<usize> {\n     assert_eq!(next(st), '/');\n \n     if peek(st) == '|' {\n@@ -447,8 +447,8 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n     let tcx = st.tcx;\n     match next(st) {\n       'b' => return tcx.types.bool,\n-      'i' => { /* eat the s of is */ next(st); return tcx.types.int },\n-      'u' => { /* eat the s of us */ next(st); return tcx.types.uint },\n+      'i' => { /* eat the s of is */ next(st); return tcx.types.isize },\n+      'u' => { /* eat the s of us */ next(st); return tcx.types.usize },\n       'M' => {\n         match next(st) {\n           'b' => return tcx.types.u8,\n@@ -592,38 +592,38 @@ fn parse_def_<F>(st: &mut PState, source: DefIdSource, conv: &mut F) -> ast::Def\n     return (*conv)(source, scan(st, |c| { c == '|' }, parse_def_id));\n }\n \n-fn parse_uint(st: &mut PState) -> uint {\n+fn parse_uint(st: &mut PState) -> usize {\n     let mut n = 0;\n     loop {\n         let cur = peek(st);\n         if cur < '0' || cur > '9' { return n; }\n         st.pos = st.pos + 1;\n         n *= 10;\n-        n += (cur as uint) - ('0' as uint);\n+        n += (cur as usize) - ('0' as usize);\n     };\n }\n \n fn parse_u32(st: &mut PState) -> u32 {\n     let n = parse_uint(st);\n     let m = n as u32;\n-    assert_eq!(m as uint, n);\n+    assert_eq!(m as usize, n);\n     m\n }\n \n fn parse_param_space(st: &mut PState) -> subst::ParamSpace {\n     subst::ParamSpace::from_uint(parse_uint(st))\n }\n \n-fn parse_hex(st: &mut PState) -> uint {\n+fn parse_hex(st: &mut PState) -> usize {\n     let mut n = 0;\n     loop {\n         let cur = peek(st);\n         if (cur < '0' || cur > '9') && (cur < 'a' || cur > 'f') { return n; }\n         st.pos = st.pos + 1;\n         n *= 16;\n         if '0' <= cur && cur <= '9' {\n-            n += (cur as uint) - ('0' as uint);\n-        } else { n += 10 + (cur as uint) - ('a' as uint); }\n+            n += (cur as usize) - ('0' as usize);\n+        } else { n += 10 + (cur as usize) - ('a' as usize); }\n     };\n }\n \n@@ -725,14 +725,14 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n     let def_part = &buf[colon_idx + 1..len];\n \n     let crate_num = match str::from_utf8(crate_part).ok().and_then(|s| {\n-        s.parse::<uint>().ok()\n+        s.parse::<usize>().ok()\n     }) {\n        Some(cn) => cn as ast::CrateNum,\n        None => panic!(\"internal error: parse_def_id: crate number expected, found {:?}\",\n                      crate_part)\n     };\n     let def_num = match str::from_utf8(def_part).ok().and_then(|s| {\n-        s.parse::<uint>().ok()\n+        s.parse::<usize>().ok()\n     }) {\n        Some(dn) => dn as ast::NodeId,\n        None => panic!(\"internal error: parse_def_id: id expected, found {:?}\",\n@@ -742,7 +742,7 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n }\n \n pub fn parse_predicate_data<'tcx, F>(data: &[u8],\n-                                     start: uint,\n+                                     start: usize,\n                                      crate_num: ast::CrateNum,\n                                      tcx: &ty::ctxt<'tcx>,\n                                      conv: F)\n@@ -794,7 +794,7 @@ fn parse_projection_predicate_<'a,'tcx, F>(\n     }\n }\n \n-pub fn parse_type_param_def_data<'tcx, F>(data: &[u8], start: uint,\n+pub fn parse_type_param_def_data<'tcx, F>(data: &[u8], start: usize,\n                                           crate_num: ast::CrateNum, tcx: &ty::ctxt<'tcx>,\n                                           conv: F) -> ty::TypeParameterDef<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,"}, {"sha": "698cf105ae53c12d6b1a5d4dabec5175f1dc6c63", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -19,10 +19,10 @@ use middle::ty::{self, Ty};\n use syntax::ast;\n use util::ppaux::Repr;\n \n-pub const NO_REGIONS: uint = 1;\n-pub const NO_TPS: uint = 2;\n+pub const NO_REGIONS: usize = 1;\n+pub const NO_TPS: usize = 2;\n \n-pub fn check_path_args(tcx: &ty::ctxt, segments: &[ast::PathSegment], flags: uint) {\n+pub fn check_path_args(tcx: &ty::ctxt, segments: &[ast::PathSegment], flags: usize) {\n     for segment in segments {\n         if (flags & NO_TPS) != 0 {\n             for typ in segment.parameters.types() {"}, {"sha": "0b8469eda39c5c146560bf7435878dd99d6979c8", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -93,7 +93,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n     let ii = simplify_ast(ii);\n     let id_range = ast_util::compute_id_range_for_inlined_item(&ii);\n \n-    rbml_w.start_tag(c::tag_ast as uint);\n+    rbml_w.start_tag(c::tag_ast as usize);\n     id_range.encode(rbml_w);\n     encode_ast(rbml_w, &ii);\n     encode_side_tables_for_ii(ecx, rbml_w, &ii);\n@@ -360,7 +360,7 @@ impl<D:serialize::Decoder> def_id_decoder_helpers for D\n // but eventually we should add entries to the local codemap as required.\n \n fn encode_ast(rbml_w: &mut Encoder, item: &ast::InlinedItem) {\n-    rbml_w.start_tag(c::tag_tree as uint);\n+    rbml_w.start_tag(c::tag_tree as usize);\n     item.encode(rbml_w);\n     rbml_w.end_tag();\n }\n@@ -437,7 +437,7 @@ fn simplify_ast(ii: e::InlinedItemRef) -> ast::InlinedItem {\n }\n \n fn decode_ast(par_doc: rbml::Doc) -> ast::InlinedItem {\n-    let chi_doc = par_doc.get(c::tag_tree as uint);\n+    let chi_doc = par_doc.get(c::tag_tree as usize);\n     let mut d = reader::Decoder::new(chi_doc);\n     Decodable::decode(&mut d).unwrap()\n }\n@@ -1150,7 +1150,7 @@ impl<'a> write_tag_and_id for Encoder<'a> {\n               f: F) where\n         F: FnOnce(&mut Encoder<'a>),\n     {\n-        self.start_tag(tag_id as uint);\n+        self.start_tag(tag_id as usize);\n         f(self);\n         self.end_tag();\n     }\n@@ -1175,7 +1175,7 @@ impl<'a, 'b, 'c, 'tcx> ast_util::IdVisitingOperation for\n fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n                              rbml_w: &mut Encoder,\n                              ii: &ast::InlinedItem) {\n-    rbml_w.start_tag(c::tag_table as uint);\n+    rbml_w.start_tag(c::tag_table as usize);\n     ast_util::visit_ids_for_inlined_item(ii, &mut SideTableEncodingIdVisitor {\n         ecx: ecx,\n         rbml_w: rbml_w\n@@ -1323,14 +1323,14 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n }\n \n trait doc_decoder_helpers {\n-    fn as_int(&self) -> int;\n+    fn as_int(&self) -> isize;\n     fn opt_child(&self, tag: c::astencode_tag) -> Option<Self>;\n }\n \n impl<'a> doc_decoder_helpers for rbml::Doc<'a> {\n-    fn as_int(&self) -> int { reader::doc_as_u64(*self) as int }\n+    fn as_int(&self) -> isize { reader::doc_as_u64(*self) as isize }\n     fn opt_child(&self, tag: c::astencode_tag) -> Option<rbml::Doc<'a>> {\n-        reader::maybe_get_doc(*self, tag as uint)\n+        reader::maybe_get_doc(*self, tag as usize)\n     }\n }\n \n@@ -1746,7 +1746,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n             this.read_enum_variant(variants, |this, i| {\n                 Ok(match i {\n                     0 => {\n-                        let len: uint =\n+                        let len: usize =\n                             this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n \n                         ty::UnsizeLength(len)\n@@ -1755,7 +1755,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                         let uk: ty::UnsizeKind =\n                             this.read_enum_variant_arg(0,\n                                 |this| Ok(this.read_unsize_kind(dcx))).unwrap();\n-                        let idx: uint =\n+                        let idx: usize =\n                             this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n \n                         ty::UnsizeStruct(box uk, idx)\n@@ -1851,7 +1851,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n \n fn decode_side_tables(dcx: &DecodeContext,\n                       ast_doc: rbml::Doc) {\n-    let tbl_doc = ast_doc.get(c::tag_table as uint);\n+    let tbl_doc = ast_doc.get(c::tag_table as usize);\n     reader::docs(tbl_doc, |tag, entry_doc| {\n         let mut entry_dsr = reader::Decoder::new(entry_doc);\n         let id0: ast::NodeId = Decodable::decode(&mut entry_dsr).unwrap();\n@@ -1969,14 +1969,14 @@ fn decode_side_tables(dcx: &DecodeContext,\n \n #[cfg(test)]\n fn encode_item_ast(rbml_w: &mut Encoder, item: &ast::Item) {\n-    rbml_w.start_tag(c::tag_tree as uint);\n+    rbml_w.start_tag(c::tag_tree as usize);\n     (*item).encode(rbml_w);\n     rbml_w.end_tag();\n }\n \n #[cfg(test)]\n fn decode_item_ast(par_doc: rbml::Doc) -> ast::Item {\n-    let chi_doc = par_doc.get(c::tag_tree as uint);\n+    let chi_doc = par_doc.get(c::tag_tree as usize);\n     let mut d = reader::Decoder::new(chi_doc);\n     Decodable::decode(&mut d).unwrap()\n }\n@@ -2035,7 +2035,7 @@ fn test_basic() {\n fn test_smalltalk() {\n     let cx = mk_ctxt();\n     roundtrip(quote_item!(&cx,\n-        fn foo() -> int { 3 + 4 } // first smalltalk program ever executed.\n+        fn foo() -> isize { 3 + 4 } // first smalltalk program ever executed.\n     ));\n }\n */\n@@ -2044,7 +2044,7 @@ fn test_smalltalk() {\n fn test_more() {\n     let cx = mk_ctxt();\n     roundtrip(quote_item!(&cx,\n-        fn foo(x: uint, y: uint) -> uint {\n+        fn foo(x: usize, y: usize) -> usize {\n             let z = x + y;\n             return z;\n         }\n@@ -2055,15 +2055,15 @@ fn test_more() {\n fn test_simplification() {\n     let cx = mk_ctxt();\n     let item = quote_item!(&cx,\n-        fn new_int_alist<B>() -> alist<int, B> {\n-            fn eq_int(a: int, b: int) -> bool { a == b }\n+        fn new_int_alist<B>() -> alist<isize, B> {\n+            fn eq_int(a: isize, b: isize) -> bool { a == b }\n             return alist {eq_fn: eq_int, data: Vec::new()};\n         }\n     ).unwrap();\n     let item_in = e::IIItemRef(&*item);\n     let item_out = simplify_ast(item_in);\n     let item_exp = ast::IIItem(quote_item!(&cx,\n-        fn new_int_alist<B>() -> alist<int, B> {\n+        fn new_int_alist<B>() -> alist<isize, B> {\n             return alist {eq_fn: eq_int, data: Vec::new()};\n         }\n     ).unwrap());"}, {"sha": "69da9c252c864e67cf39a1052d405aade6cd29da", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -72,7 +72,7 @@ impl<'a> fmt::Debug for Matrix<'a> {\n \n         let column_count = m.iter().map(|row| row.len()).max().unwrap_or(0);\n         assert!(m.iter().all(|row| row.len() == column_count));\n-        let column_widths: Vec<uint> = (0..column_count).map(|col| {\n+        let column_widths: Vec<usize> = (0..column_count).map(|col| {\n             pretty_printed_matrix.iter().map(|row| row[col].len()).max().unwrap_or(0)\n         }).collect();\n \n@@ -116,9 +116,9 @@ pub enum Constructor {\n     /// Ranges of literal values (2..5).\n     ConstantRange(const_val, const_val),\n     /// Array patterns of length n.\n-    Slice(uint),\n+    Slice(usize),\n     /// Array patterns with a subslice.\n-    SliceWithSubslice(uint, uint)\n+    SliceWithSubslice(usize, usize)\n }\n \n #[derive(Clone, PartialEq)]\n@@ -498,7 +498,7 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n /// left_ty: tuple of 3 elements\n /// pats: [10, 20, _]           => (10, 20, _)\n ///\n-/// left_ty: struct X { a: (bool, &'static str), b: uint}\n+/// left_ty: struct X { a: (bool, &'static str), b: usize}\n /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n                      pats: Vec<&Pat>, left_ty: Ty) -> P<Pat> {\n@@ -580,7 +580,7 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &Constructor,\n }\n \n fn missing_constructor(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n-                       left_ty: Ty, max_slice_length: uint) -> Option<Constructor> {\n+                       left_ty: Ty, max_slice_length: usize) -> Option<Constructor> {\n     let used_constructors: Vec<Constructor> = rows.iter()\n         .flat_map(|row| pat_constructors(cx, row[0], left_ty, max_slice_length).into_iter())\n         .collect();\n@@ -594,7 +594,7 @@ fn missing_constructor(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n /// but is instead bounded by the maximum fixed length of slice patterns in\n /// the column of patterns being analyzed.\n fn all_constructors(cx: &MatchCheckCtxt, left_ty: Ty,\n-                    max_slice_length: uint) -> Vec<Constructor> {\n+                    max_slice_length: usize) -> Vec<Constructor> {\n     match left_ty.sty {\n         ty::ty_bool =>\n             [true, false].iter().map(|b| ConstantValue(const_bool(*b))).collect(),\n@@ -741,7 +741,7 @@ fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix,\n /// On the other hand, a wild pattern and an identifier pattern cannot be\n /// specialized in any way.\n fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n-                    left_ty: Ty, max_slice_length: uint) -> Vec<Constructor> {\n+                    left_ty: Ty, max_slice_length: usize) -> Vec<Constructor> {\n     let pat = raw_pat(p);\n     match pat.node {\n         ast::PatIdent(..) =>\n@@ -798,7 +798,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n ///\n /// For instance, a tuple pattern (_, 42, Some([])) has the arity of 3.\n /// A struct pattern's arity is the number of fields it contains, etc.\n-pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> uint {\n+pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize {\n     match ty.sty {\n         ty::ty_tup(ref fs) => fs.len(),\n         ty::ty_uniq(_) => 1,\n@@ -850,7 +850,7 @@ fn range_covered_by_constructor(ctor: &Constructor,\n /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n /// fields filled with wild patterns.\n pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n-                      constructor: &Constructor, col: uint, arity: uint) -> Option<Vec<&'a Pat>> {\n+                      constructor: &Constructor, col: usize, arity: usize) -> Option<Vec<&'a Pat>> {\n     let &Pat {\n         id: pat_id, ref node, span: pat_span\n     } = raw_pat(r[col]);"}, {"sha": "0d9e0d14def645ced90898ae7b5c300def44859e", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -262,8 +262,8 @@ impl ConstEvalErr {\n             CannotCastTo(s) => format!(\"can't cast this type to {}\", s).into_cow(),\n             InvalidOpForBools(_) =>  \"can't do this op on bools\".into_cow(),\n             InvalidOpForFloats(_) => \"can't do this op on floats\".into_cow(),\n-            InvalidOpForIntUint(..) => \"can't do this op on an int and uint\".into_cow(),\n-            InvalidOpForUintInt(..) => \"can't do this op on a uint and int\".into_cow(),\n+            InvalidOpForIntUint(..) => \"can't do this op on an isize and usize\".into_cow(),\n+            InvalidOpForUintInt(..) => \"can't do this op on a usize and isize\".into_cow(),\n             NegateOnString => \"negate on string\".into_cow(),\n             NegateOnBoolean => \"negate on boolean\".into_cow(),\n             NegateOnBinary => \"negate on binary literal\".into_cow(),\n@@ -369,7 +369,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n       }\n       ast::ExprBinary(op, ref a, ref b) => {\n         let b_ty = match op.node {\n-            ast::BiShl | ast::BiShr => Some(tcx.types.uint),\n+            ast::BiShl | ast::BiShr => Some(tcx.types.usize),\n             _ => ety\n         };\n         match (try!(eval_const_expr_partial(tcx, &**a, ety)),\n@@ -434,8 +434,8 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n               ast::BiAnd | ast::BiBitAnd => const_int(a & b),\n               ast::BiOr | ast::BiBitOr => const_int(a | b),\n               ast::BiBitXor => const_int(a ^ b),\n-              ast::BiShl => const_int(a << b as uint),\n-              ast::BiShr => const_int(a >> b as uint),\n+              ast::BiShl => const_int(a << b as usize),\n+              ast::BiShr => const_int(a >> b as usize),\n               ast::BiEq => fromb(a == b),\n               ast::BiLt => fromb(a < b),\n               ast::BiLe => fromb(a <= b),\n@@ -456,8 +456,8 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n               ast::BiAnd | ast::BiBitAnd => const_uint(a & b),\n               ast::BiOr | ast::BiBitOr => const_uint(a | b),\n               ast::BiBitXor => const_uint(a ^ b),\n-              ast::BiShl => const_uint(a << b as uint),\n-              ast::BiShr => const_uint(a >> b as uint),\n+              ast::BiShl => const_uint(a << b as usize),\n+              ast::BiShr => const_uint(a >> b as usize),\n               ast::BiEq => fromb(a == b),\n               ast::BiLt => fromb(a < b),\n               ast::BiLe => fromb(a <= b),\n@@ -469,15 +469,15 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           // shifts can have any integral type as their rhs\n           (const_int(a), const_uint(b)) => {\n             match op.node {\n-              ast::BiShl => const_int(a << b as uint),\n-              ast::BiShr => const_int(a >> b as uint),\n+              ast::BiShl => const_int(a << b as usize),\n+              ast::BiShr => const_int(a >> b as usize),\n               _ => signal!(e, InvalidOpForIntUint(op.node)),\n             }\n           }\n           (const_uint(a), const_int(b)) => {\n             match op.node {\n-              ast::BiShl => const_uint(a << b as uint),\n-              ast::BiShr => const_uint(a >> b as uint),\n+              ast::BiShl => const_uint(a << b as usize),\n+              ast::BiShr => const_uint(a >> b as usize),\n               _ => signal!(e, InvalidOpForUintInt(op.node)),\n             }\n           }\n@@ -628,12 +628,12 @@ fn cast_const(val: const_val, ty: Ty) -> Result<const_val, ErrKind> {\n     }\n \n     define_casts!{\n-        ty::ty_int(ast::TyIs) => (int, const_int, i64),\n+        ty::ty_int(ast::TyIs) => (isize, const_int, i64),\n         ty::ty_int(ast::TyI8) => (i8, const_int, i64),\n         ty::ty_int(ast::TyI16) => (i16, const_int, i64),\n         ty::ty_int(ast::TyI32) => (i32, const_int, i64),\n         ty::ty_int(ast::TyI64) => (i64, const_int, i64),\n-        ty::ty_uint(ast::TyUs) => (uint, const_uint, u64),\n+        ty::ty_uint(ast::TyUs) => (usize, const_uint, u64),\n         ty::ty_uint(ast::TyU8) => (u8, const_uint, u64),\n         ty::ty_uint(ast::TyU16) => (u16, const_uint, u64),\n         ty::ty_uint(ast::TyU32) => (u32, const_uint, u64),"}, {"sha": "6c7db4ce5482b80827b9789f3bb48391801db05b", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -45,11 +45,11 @@ pub struct DataFlowContext<'a, 'tcx: 'a, O> {\n     oper: O,\n \n     /// number of bits to propagate per id\n-    bits_per_id: uint,\n+    bits_per_id: usize,\n \n     /// number of words we will use to store bits_per_id.\n     /// equal to bits_per_id/usize::BITS rounded up.\n-    words_per_id: uint,\n+    words_per_id: usize,\n \n     // mapping from node to cfg node index\n     // FIXME (#6298): Shouldn't this go with CFG?\n@@ -62,19 +62,19 @@ pub struct DataFlowContext<'a, 'tcx: 'a, O> {\n     // the full vector (see the method `compute_id_range()`).\n \n     /// bits generated as we exit the cfg node. Updated by `add_gen()`.\n-    gens: Vec<uint>,\n+    gens: Vec<usize>,\n \n     /// bits killed as we exit the cfg node. Updated by `add_kill()`.\n-    kills: Vec<uint>,\n+    kills: Vec<usize>,\n \n     /// bits that are valid on entry to the cfg node. Updated by\n     /// `propagate()`.\n-    on_entry: Vec<uint>,\n+    on_entry: Vec<usize>,\n }\n \n pub trait BitwiseOperator {\n     /// Joins two predecessor bits together, typically either `|` or `&`\n-    fn join(&self, succ: uint, pred: uint) -> uint;\n+    fn join(&self, succ: usize, pred: usize) -> usize;\n }\n \n /// Parameterization for the precise form of data flow that is used.\n@@ -204,7 +204,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                cfg: &cfg::CFG,\n                oper: O,\n                id_range: IdRange,\n-               bits_per_id: uint) -> DataFlowContext<'a, 'tcx, O> {\n+               bits_per_id: usize) -> DataFlowContext<'a, 'tcx, O> {\n         let words_per_id = (bits_per_id + usize::BITS as usize - 1) / usize::BITS as usize;\n         let num_nodes = cfg.graph.all_nodes().len();\n \n@@ -235,7 +235,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         }\n     }\n \n-    pub fn add_gen(&mut self, id: ast::NodeId, bit: uint) {\n+    pub fn add_gen(&mut self, id: ast::NodeId, bit: usize) {\n         //! Indicates that `id` generates `bit`\n         debug!(\"{} add_gen(id={}, bit={})\",\n                self.analysis_name, id, bit);\n@@ -250,7 +250,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         }\n     }\n \n-    pub fn add_kill(&mut self, id: ast::NodeId, bit: uint) {\n+    pub fn add_kill(&mut self, id: ast::NodeId, bit: usize) {\n         //! Indicates that `id` kills `bit`\n         debug!(\"{} add_kill(id={}, bit={})\",\n                self.analysis_name, id, bit);\n@@ -265,7 +265,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         }\n     }\n \n-    fn apply_gen_kill(&self, cfgidx: CFGIndex, bits: &mut [uint]) {\n+    fn apply_gen_kill(&self, cfgidx: CFGIndex, bits: &mut [usize]) {\n         //! Applies the gen and kill sets for `cfgidx` to `bits`\n         debug!(\"{} apply_gen_kill(cfgidx={:?}, bits={}) [before]\",\n                self.analysis_name, cfgidx, mut_bits_to_string(bits));\n@@ -281,7 +281,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                self.analysis_name, cfgidx, mut_bits_to_string(bits));\n     }\n \n-    fn compute_id_range(&self, cfgidx: CFGIndex) -> (uint, uint) {\n+    fn compute_id_range(&self, cfgidx: CFGIndex) -> (usize, usize) {\n         let n = cfgidx.node_id();\n         let start = n * self.words_per_id;\n         let end = start + self.words_per_id;\n@@ -296,7 +296,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n \n     pub fn each_bit_on_entry<F>(&self, id: ast::NodeId, mut f: F) -> bool where\n-        F: FnMut(uint) -> bool,\n+        F: FnMut(usize) -> bool,\n     {\n         //! Iterates through each bit that is set on entry to `id`.\n         //! Only useful after `propagate()` has been called.\n@@ -313,7 +313,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n     }\n \n     pub fn each_bit_for_node<F>(&self, e: EntryOrExit, cfgidx: CFGIndex, f: F) -> bool where\n-        F: FnMut(uint) -> bool,\n+        F: FnMut(usize) -> bool,\n     {\n         //! Iterates through each bit that is set on entry/exit to `cfgidx`.\n         //! Only useful after `propagate()` has been called.\n@@ -342,7 +342,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n     }\n \n     pub fn each_gen_bit<F>(&self, id: ast::NodeId, mut f: F) -> bool where\n-        F: FnMut(uint) -> bool,\n+        F: FnMut(usize) -> bool,\n     {\n         //! Iterates through each bit in the gen set for `id`.\n         if !self.has_bitset_for_nodeid(id) {\n@@ -368,8 +368,8 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         return true;\n     }\n \n-    fn each_bit<F>(&self, words: &[uint], mut f: F) -> bool where\n-        F: FnMut(uint) -> bool,\n+    fn each_bit<F>(&self, words: &[usize], mut f: F) -> bool where\n+        F: FnMut(usize) -> bool,\n     {\n         //! Helper for iterating over the bits in a bit set.\n         //! Returns false on the first call to `f` that returns false;\n@@ -505,7 +505,7 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n     fn walk_cfg(&mut self,\n                 cfg: &cfg::CFG,\n-                in_out: &mut [uint]) {\n+                in_out: &mut [usize]) {\n         debug!(\"DataFlowContext::walk_cfg(in_out={}) {}\",\n                bits_to_string(in_out), self.dfcx.analysis_name);\n         assert!(self.dfcx.bits_per_id > 0);\n@@ -529,15 +529,15 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n         });\n     }\n \n-    fn reset(&mut self, bits: &mut [uint]) {\n+    fn reset(&mut self, bits: &mut [usize]) {\n         let e = if self.dfcx.oper.initial_value() {usize::MAX} else {0};\n         for b in bits {\n             *b = e;\n         }\n     }\n \n     fn propagate_bits_into_graph_successors_of(&mut self,\n-                                               pred_bits: &[uint],\n+                                               pred_bits: &[usize],\n                                                cfg: &cfg::CFG,\n                                                cfgidx: CFGIndex) {\n         cfg.graph.each_outgoing_edge(cfgidx, |_e_idx, edge| {\n@@ -547,7 +547,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n     }\n \n     fn propagate_bits_into_entry_set_for(&mut self,\n-                                         pred_bits: &[uint],\n+                                         pred_bits: &[usize],\n                                          edge: &cfg::CFGEdge) {\n         let source = edge.source();\n         let cfgidx = edge.target();\n@@ -570,11 +570,11 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n     }\n }\n \n-fn mut_bits_to_string(words: &mut [uint]) -> String {\n+fn mut_bits_to_string(words: &mut [usize]) -> String {\n     bits_to_string(words)\n }\n \n-fn bits_to_string(words: &[uint]) -> String {\n+fn bits_to_string(words: &[usize]) -> String {\n     let mut result = String::new();\n     let mut sep = '[';\n \n@@ -594,8 +594,8 @@ fn bits_to_string(words: &[uint]) -> String {\n }\n \n #[inline]\n-fn bitwise<Op:BitwiseOperator>(out_vec: &mut [uint],\n-                               in_vec: &[uint],\n+fn bitwise<Op:BitwiseOperator>(out_vec: &mut [usize],\n+                               in_vec: &[usize],\n                                op: &Op) -> bool {\n     assert_eq!(out_vec.len(), in_vec.len());\n     let mut changed = false;\n@@ -608,7 +608,7 @@ fn bitwise<Op:BitwiseOperator>(out_vec: &mut [uint],\n     changed\n }\n \n-fn set_bit(words: &mut [uint], bit: uint) -> bool {\n+fn set_bit(words: &mut [usize], bit: usize) -> bool {\n     debug!(\"set_bit: words={} bit={}\",\n            mut_bits_to_string(words), bit_str(bit));\n     let word = bit / usize::BITS as usize;\n@@ -621,17 +621,17 @@ fn set_bit(words: &mut [uint], bit: uint) -> bool {\n     oldv != newv\n }\n \n-fn bit_str(bit: uint) -> String {\n+fn bit_str(bit: usize) -> String {\n     let byte = bit >> 8;\n     let lobits = 1 << (bit & 0xFF);\n     format!(\"[{}:{}-{:02x}]\", bit, byte, lobits)\n }\n \n struct Union;\n impl BitwiseOperator for Union {\n-    fn join(&self, a: uint, b: uint) -> uint { a | b }\n+    fn join(&self, a: usize, b: usize) -> usize { a | b }\n }\n struct Subtract;\n impl BitwiseOperator for Subtract {\n-    fn join(&self, a: uint, b: uint) -> uint { a & !b }\n+    fn join(&self, a: usize, b: usize) -> usize { a & !b }\n }"}, {"sha": "568375597c0de1bfd9f1d2dd9db2ee5a9a2fa108", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -145,7 +145,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn handle_tup_field_access(&mut self, lhs: &ast::Expr, idx: uint) {\n+    fn handle_tup_field_access(&mut self, lhs: &ast::Expr, idx: usize) {\n         match ty::expr_ty_adjusted(self.tcx, lhs).sty {\n             ty::ty_struct(id, _) => {\n                 let fields = ty::lookup_struct_fields(self.tcx, id);"}, {"sha": "0b688e1e08a2e3eabdc7a7324b3eb2cf05c0784c", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -172,7 +172,7 @@ fn calculate_type(sess: &session::Session,\n             assert!(src.rlib.is_some());\n             debug!(\"adding staticlib: {}\", data.name);\n             add_library(sess, cnum, cstore::RequireStatic, &mut formats);\n-            ret[cnum as uint - 1] = Some(cstore::RequireStatic);\n+            ret[cnum as usize - 1] = Some(cstore::RequireStatic);\n         }\n     });\n "}, {"sha": "36c9e582b41e9769dfa21cda7f75f5376c98e221", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -823,7 +823,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     /// `deref()` is declared with `&self`, this is an autoref of `x`.\n     fn walk_autoderefs(&mut self,\n                        expr: &ast::Expr,\n-                       autoderefs: uint) {\n+                       autoderefs: usize) {\n         debug!(\"walk_autoderefs expr={} autoderefs={}\", expr.repr(self.tcx()), autoderefs);\n \n         for i in 0..autoderefs {\n@@ -855,7 +855,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     fn walk_autoref(&mut self,\n                     expr: &ast::Expr,\n                     autoref: &ty::AutoRef,\n-                    n: uint) {\n+                    n: usize) {\n         debug!(\"walk_autoref expr={}\", expr.repr(self.tcx()));\n \n         match *autoref {"}, {"sha": "36065aaca57f33b4708d7ce721d95cc54238b6fa", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -25,11 +25,11 @@ pub enum SimplifiedType {\n     StrSimplifiedType,\n     VecSimplifiedType,\n     PtrSimplifiedType,\n-    TupleSimplifiedType(uint),\n+    TupleSimplifiedType(usize),\n     TraitSimplifiedType(ast::DefId),\n     StructSimplifiedType(ast::DefId),\n     ClosureSimplifiedType(ast::DefId),\n-    FunctionSimplifiedType(uint),\n+    FunctionSimplifiedType(usize),\n     ParameterSimplifiedType,\n }\n "}, {"sha": "8673273f9b3c9c3c4fdd947ea14c462110fbc5b3", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -62,33 +62,33 @@ impl<E: Debug> Debug for Edge<E> {\n }\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n-pub struct NodeIndex(pub uint);\n+pub struct NodeIndex(pub usize);\n #[allow(non_upper_case_globals)]\n pub const InvalidNodeIndex: NodeIndex = NodeIndex(usize::MAX);\n \n #[derive(Copy, PartialEq, Debug)]\n-pub struct EdgeIndex(pub uint);\n+pub struct EdgeIndex(pub usize);\n #[allow(non_upper_case_globals)]\n pub const InvalidEdgeIndex: EdgeIndex = EdgeIndex(usize::MAX);\n \n // Use a private field here to guarantee no more instances are created:\n #[derive(Copy, Debug)]\n-pub struct Direction { repr: uint }\n+pub struct Direction { repr: usize }\n #[allow(non_upper_case_globals)]\n pub const Outgoing: Direction = Direction { repr: 0 };\n #[allow(non_upper_case_globals)]\n pub const Incoming: Direction = Direction { repr: 1 };\n \n impl NodeIndex {\n-    fn get(&self) -> uint { let NodeIndex(v) = *self; v }\n+    fn get(&self) -> usize { let NodeIndex(v) = *self; v }\n     /// Returns unique id (unique with respect to the graph holding associated node).\n-    pub fn node_id(&self) -> uint { self.get() }\n+    pub fn node_id(&self) -> usize { self.get() }\n }\n \n impl EdgeIndex {\n-    fn get(&self) -> uint { let EdgeIndex(v) = *self; v }\n+    fn get(&self) -> usize { let EdgeIndex(v) = *self; v }\n     /// Returns unique id (unique with respect to the graph holding associated edge).\n-    pub fn edge_id(&self) -> uint { self.get() }\n+    pub fn edge_id(&self) -> usize { self.get() }\n }\n \n impl<N,E> Graph<N,E> {\n@@ -99,8 +99,8 @@ impl<N,E> Graph<N,E> {\n         }\n     }\n \n-    pub fn with_capacity(num_nodes: uint,\n-                         num_edges: uint) -> Graph<N,E> {\n+    pub fn with_capacity(num_nodes: usize,\n+                         num_edges: usize) -> Graph<N,E> {\n         Graph {\n             nodes: Vec::with_capacity(num_nodes),\n             edges: Vec::with_capacity(num_edges),\n@@ -275,7 +275,7 @@ impl<N,E> Graph<N,E> {\n     // computation.\n \n     pub fn iterate_until_fixed_point<'a, F>(&'a self, mut op: F) where\n-        F: FnMut(uint, EdgeIndex, &'a Edge<E>) -> bool,\n+        F: FnMut(usize, EdgeIndex, &'a Edge<E>) -> bool,\n     {\n         let mut iteration = 0;\n         let mut changed = true;"}, {"sha": "de4dbc146946d88a5ccba1b6c8bb6d5af85c4271", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -1766,7 +1766,7 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n // LifeGiver is responsible for generating fresh lifetime names\n struct LifeGiver {\n     taken: HashSet<String>,\n-    counter: Cell<uint>,\n+    counter: Cell<usize>,\n     generated: RefCell<Vec<ast::Lifetime>>,\n }\n \n@@ -1806,7 +1806,7 @@ impl LifeGiver {\n         return lifetime;\n \n         // 0 .. 25 generates a .. z, 26 .. 51 generates aa .. zz, and so on\n-        fn num_to_string(counter: uint) -> String {\n+        fn num_to_string(counter: usize) -> String {\n             let mut s = String::new();\n             let (n, r) = (counter/26 + 1, counter % 26);\n             let letter: char = from_u32((r+97) as u32).unwrap();"}, {"sha": "097a3b4ce4fe4c23336985ccf69f791746b11f21", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -811,7 +811,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         ty::mk_var(self.tcx, self.next_ty_var_id(true))\n     }\n \n-    pub fn next_ty_vars(&self, n: uint) -> Vec<Ty<'tcx>> {\n+    pub fn next_ty_vars(&self, n: usize) -> Vec<Ty<'tcx>> {\n         (0..n).map(|_i| self.next_ty_var()).collect()\n     }\n "}, {"sha": "1fcbf80c904e0d7175c6cd69341529d0aa122f3a", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -121,7 +121,7 @@ struct ConstraintGraph<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n     graph_name: String,\n     map: &'a FnvHashMap<Constraint, SubregionOrigin<'tcx>>,\n-    node_ids: FnvHashMap<Node, uint>,\n+    node_ids: FnvHashMap<Node, usize>,\n }\n \n #[derive(Clone, Hash, PartialEq, Eq, Debug, Copy)]"}, {"sha": "c432d114b6eed5cbe38d42c5dc5c4baeefb1f9a3", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -86,7 +86,7 @@ pub enum UndoLogEntry {\n     CommitedSnapshot,\n     AddVar(RegionVid),\n     AddConstraint(Constraint),\n-    AddVerify(uint),\n+    AddVerify(usize),\n     AddGiven(ty::FreeRegion, ty::RegionVid),\n     AddCombination(CombineMapType, TwoRegions)\n }\n@@ -224,7 +224,7 @@ pub struct RegionVarBindings<'a, 'tcx: 'a> {\n \n #[derive(Debug)]\n pub struct RegionSnapshot {\n-    length: uint,\n+    length: usize,\n     skolemization_count: u32,\n }\n \n@@ -284,7 +284,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 AddVar(vid) => {\n                     let mut var_origins = self.var_origins.borrow_mut();\n                     var_origins.pop().unwrap();\n-                    assert_eq!(var_origins.len(), vid.index as uint);\n+                    assert_eq!(var_origins.len(), vid.index as usize);\n                 }\n                 AddConstraint(ref constraint) => {\n                     self.constraints.borrow_mut().remove(constraint);\n@@ -312,7 +312,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     pub fn num_vars(&self) -> u32 {\n         let len = self.var_origins.borrow().len();\n         // enforce no overflow\n-        assert!(len as u32 as uint == len);\n+        assert!(len as u32 as usize == len);\n         len as u32\n     }\n \n@@ -557,7 +557,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         match *self.values.borrow() {\n             None => {\n                 self.tcx.sess.span_bug(\n-                    (*self.var_origins.borrow())[rid.index as uint].span(),\n+                    (*self.var_origins.borrow())[rid.index as usize].span(),\n                     \"attempt to resolve region variable before values have \\\n                      been computed!\")\n             }\n@@ -629,7 +629,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         let mut result_set = vec!(r0);\n         let mut result_index = 0;\n         while result_index < result_set.len() {\n-            // nb: can't use uint::range() here because result_set grows\n+            // nb: can't use usize::range() here because result_set grows\n             let r = result_set[result_index];\n             debug!(\"result_index={}, r={:?}\", result_index, r);\n \n@@ -746,7 +746,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n           (ReInfer(ReVar(v_id)), _) | (_, ReInfer(ReVar(v_id))) => {\n             self.tcx.sess.span_bug(\n-                (*self.var_origins.borrow())[v_id.index as uint].span(),\n+                (*self.var_origins.borrow())[v_id.index as usize].span(),\n                 &format!(\"lub_concrete_regions invoked with \\\n                          non-concrete regions: {:?}, {:?}\",\n                         a,\n@@ -850,7 +850,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             (ReInfer(ReVar(v_id)), _) |\n             (_, ReInfer(ReVar(v_id))) => {\n                 self.tcx.sess.span_bug(\n-                    (*self.var_origins.borrow())[v_id.index as uint].span(),\n+                    (*self.var_origins.borrow())[v_id.index as usize].span(),\n                     &format!(\"glb_concrete_regions invoked with \\\n                              non-concrete regions: {:?}, {:?}\",\n                             a,\n@@ -984,7 +984,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     fn construct_var_data(&self) -> Vec<VarData> {\n-        (0..self.num_vars() as uint).map(|_| {\n+        (0..self.num_vars() as usize).map(|_| {\n             VarData {\n                 // All nodes are initially classified as contracting; during\n                 // the expansion phase, we will shift the classification for\n@@ -1013,14 +1013,14 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                                    .repr(self.tcx));\n             match *constraint {\n               ConstrainRegSubVar(a_region, b_vid) => {\n-                let b_data = &mut var_data[b_vid.index as uint];\n+                let b_data = &mut var_data[b_vid.index as usize];\n                 self.expand_node(a_region, b_vid, b_data)\n               }\n               ConstrainVarSubVar(a_vid, b_vid) => {\n-                match var_data[a_vid.index as uint].value {\n+                match var_data[a_vid.index as usize].value {\n                   NoValue | ErrorValue => false,\n                   Value(a_region) => {\n-                    let b_node = &mut var_data[b_vid.index as uint];\n+                    let b_node = &mut var_data[b_vid.index as usize];\n                     self.expand_node(a_region, b_vid, b_node)\n                   }\n                 }\n@@ -1101,16 +1101,16 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 false\n               }\n               ConstrainVarSubVar(a_vid, b_vid) => {\n-                match var_data[b_vid.index as uint].value {\n+                match var_data[b_vid.index as usize].value {\n                   NoValue | ErrorValue => false,\n                   Value(b_region) => {\n-                    let a_data = &mut var_data[a_vid.index as uint];\n+                    let a_data = &mut var_data[a_vid.index as usize];\n                     self.contract_node(a_vid, a_data, b_region)\n                   }\n                 }\n               }\n               ConstrainVarSubReg(a_vid, b_region) => {\n-                let a_data = &mut var_data[a_vid.index as uint];\n+                let a_data = &mut var_data[a_vid.index as usize];\n                 self.contract_node(a_vid, a_data, b_region)\n               }\n             }\n@@ -1250,11 +1250,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // idea is to report errors that derive from independent\n         // regions of the graph, but not those that derive from\n         // overlapping locations.\n-        let mut dup_vec: Vec<_> = repeat(u32::MAX).take(self.num_vars() as uint).collect();\n+        let mut dup_vec: Vec<_> = repeat(u32::MAX).take(self.num_vars() as usize).collect();\n \n         let mut opt_graph = None;\n \n-        for idx in 0..self.num_vars() as uint {\n+        for idx in 0..self.num_vars() as usize {\n             match var_data[idx].value {\n                 Value(_) => {\n                     /* Inference successful */\n@@ -1311,7 +1311,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             }\n         }\n \n-        (0..self.num_vars() as uint).map(|idx| var_data[idx].value).collect()\n+        (0..self.num_vars() as usize).map(|idx| var_data[idx].value).collect()\n     }\n \n     fn construct_graph(&self) -> RegionGraph {\n@@ -1320,7 +1320,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         let constraints = self.constraints.borrow();\n         let num_edges = constraints.len();\n \n-        let mut graph = graph::Graph::with_capacity(num_vars as uint + 1,\n+        let mut graph = graph::Graph::with_capacity(num_vars as usize + 1,\n                                                     num_edges);\n \n         for _ in 0..num_vars {\n@@ -1331,17 +1331,17 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         for (constraint, _) in &*constraints {\n             match *constraint {\n                 ConstrainVarSubVar(a_id, b_id) => {\n-                    graph.add_edge(NodeIndex(a_id.index as uint),\n-                                   NodeIndex(b_id.index as uint),\n+                    graph.add_edge(NodeIndex(a_id.index as usize),\n+                                   NodeIndex(b_id.index as usize),\n                                    *constraint);\n                 }\n                 ConstrainRegSubVar(_, b_id) => {\n                     graph.add_edge(dummy_idx,\n-                                   NodeIndex(b_id.index as uint),\n+                                   NodeIndex(b_id.index as usize),\n                                    *constraint);\n                 }\n                 ConstrainVarSubReg(a_id, _) => {\n-                    graph.add_edge(NodeIndex(a_id.index as uint),\n+                    graph.add_edge(NodeIndex(a_id.index as usize),\n                                    dummy_idx,\n                                    *constraint);\n                 }\n@@ -1395,7 +1395,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     debug!(\"pushing SubSupConflict sub: {:?} sup: {:?}\",\n                            lower_bound.region, upper_bound.region);\n                     errors.push(SubSupConflict(\n-                        (*self.var_origins.borrow())[node_idx.index as uint].clone(),\n+                        (*self.var_origins.borrow())[node_idx.index as usize].clone(),\n                         lower_bound.origin.clone(),\n                         lower_bound.region,\n                         upper_bound.origin.clone(),\n@@ -1406,7 +1406,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n \n         self.tcx.sess.span_bug(\n-            (*self.var_origins.borrow())[node_idx.index as uint].span(),\n+            (*self.var_origins.borrow())[node_idx.index as usize].span(),\n             &format!(\"collect_error_for_expanding_node() could not find error \\\n                     for var {:?}, lower_bounds={}, upper_bounds={}\",\n                     node_idx,\n@@ -1439,7 +1439,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                   Ok(_) => {}\n                   Err(_) => {\n                     errors.push(SupSupConflict(\n-                        (*self.var_origins.borrow())[node_idx.index as uint].clone(),\n+                        (*self.var_origins.borrow())[node_idx.index as usize].clone(),\n                         upper_bound_1.origin.clone(),\n                         upper_bound_1.region,\n                         upper_bound_2.origin.clone(),\n@@ -1451,7 +1451,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n \n         self.tcx.sess.span_bug(\n-            (*self.var_origins.borrow())[node_idx.index as uint].span(),\n+            (*self.var_origins.borrow())[node_idx.index as usize].span(),\n             &format!(\"collect_error_for_contracting_node() could not find error \\\n                      for var {:?}, upper_bounds={}\",\n                     node_idx,\n@@ -1485,12 +1485,12 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         while !state.stack.is_empty() {\n             let node_idx = state.stack.pop().unwrap();\n-            let classification = var_data[node_idx.index as uint].classification;\n+            let classification = var_data[node_idx.index as usize].classification;\n \n             // check whether we've visited this node on some previous walk\n-            if dup_vec[node_idx.index as uint] == u32::MAX {\n-                dup_vec[node_idx.index as uint] = orig_node_idx.index;\n-            } else if dup_vec[node_idx.index as uint] != orig_node_idx.index {\n+            if dup_vec[node_idx.index as usize] == u32::MAX {\n+                dup_vec[node_idx.index as usize] = orig_node_idx.index;\n+            } else if dup_vec[node_idx.index as usize] != orig_node_idx.index {\n                 state.dup_found = true;\n             }\n \n@@ -1518,7 +1518,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                          dir: Direction) {\n             debug!(\"process_edges(source_vid={:?}, dir={:?})\", source_vid, dir);\n \n-            let source_node_index = NodeIndex(source_vid.index as uint);\n+            let source_node_index = NodeIndex(source_vid.index as usize);\n             graph.each_adjacent_edge(source_node_index, dir, |_, edge| {\n                 match edge.data {\n                     ConstrainVarSubVar(from_vid, to_vid) => {\n@@ -1603,7 +1603,7 @@ fn normalize(values: &Vec<VarValue>, r: ty::Region) -> ty::Region {\n }\n \n fn lookup(values: &Vec<VarValue>, rid: ty::RegionVid) -> ty::Region {\n-    match values[rid.index as uint] {\n+    match values[rid.index as usize] {\n         Value(r) => r,\n         NoValue => ReEmpty, // No constraints, return ty::ReEmpty\n         ErrorValue => ReStatic, // Previously reported error."}, {"sha": "553ef9afc28165da821f6dad614e8d2d30d6a78d", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -69,11 +69,11 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     }\n \n     fn relations<'a>(&'a mut self, a: ty::TyVid) -> &'a mut Vec<Relation> {\n-        relations(self.values.get_mut(a.index as uint))\n+        relations(self.values.get_mut(a.index as usize))\n     }\n \n     pub fn var_diverges<'a>(&'a self, vid: ty::TyVid) -> bool {\n-        self.values.get(vid.index as uint).diverging\n+        self.values.get(vid.index as usize).diverging\n     }\n \n     /// Records that `a <: b`, `a :> b`, or `a == b`, depending on `dir`.\n@@ -97,7 +97,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         stack: &mut Vec<(Ty<'tcx>, RelationDir, ty::TyVid)>)\n     {\n         let old_value = {\n-            let value_ptr = &mut self.values.get_mut(vid.index as uint).value;\n+            let value_ptr = &mut self.values.get_mut(vid.index as usize).value;\n             mem::replace(value_ptr, Known(ty))\n         };\n \n@@ -123,7 +123,7 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     }\n \n     pub fn probe(&self, vid: ty::TyVid) -> Option<Ty<'tcx>> {\n-        match self.values.get(vid.index as uint).value {\n+        match self.values.get(vid.index as usize).value {\n             Bounded(..) => None,\n             Known(t) => Some(t)\n         }\n@@ -206,12 +206,12 @@ impl<'tcx> sv::SnapshotVecDelegate for Delegate<'tcx> {\n                action: UndoEntry) {\n         match action {\n             SpecifyVar(vid, relations) => {\n-                values[vid.index as uint].value = Bounded(relations);\n+                values[vid.index as usize].value = Bounded(relations);\n             }\n \n             Relate(a, b) => {\n-                relations(&mut (*values)[a.index as uint]).pop();\n-                relations(&mut (*values)[b.index as uint]).pop();\n+                relations(&mut (*values)[a.index as usize]).pop();\n+                relations(&mut (*values)[b.index as usize]).pop();\n             }\n         }\n     }"}, {"sha": "8a736d47b5d8944a338c1ad9a9dcdc3ee2bea29f", "filename": "src/librustc/middle/infer/unify.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -35,9 +35,9 @@ use util::snapshot_vec as sv;\n pub trait UnifyKey : Clone + Debug + PartialEq {\n     type Value : UnifyValue;\n \n-    fn index(&self) -> uint;\n+    fn index(&self) -> usize;\n \n-    fn from_index(u: uint) -> Self;\n+    fn from_index(u: usize) -> Self;\n \n     // Given an inference context, returns the unification table\n     // appropriate to this key type.\n@@ -67,7 +67,7 @@ pub trait UnifyValue : Clone + PartialEq + Debug {\n #[derive(PartialEq,Clone,Debug)]\n pub enum VarValue<K:UnifyKey> {\n     Redirect(K),\n-    Root(K::Value, uint),\n+    Root(K::Value, usize),\n }\n \n /// Table of unification keys and their values.\n@@ -89,7 +89,7 @@ pub struct Snapshot<K:UnifyKey> {\n pub struct Node<K:UnifyKey> {\n     pub key: K,\n     pub value: K::Value,\n-    pub rank: uint,\n+    pub rank: usize,\n }\n \n #[derive(Copy)]\n@@ -186,7 +186,7 @@ impl<K:UnifyKey> UnificationTable<K> {\n                        tcx: &ty::ctxt<'tcx>,\n                        node_a: &Node<K>,\n                        node_b: &Node<K>)\n-                       -> (K, uint)\n+                       -> (K, usize)\n     {\n         debug!(\"unify(node_a(id={:?}, rank={:?}), node_b(id={:?}, rank={:?}))\",\n                node_a.key,\n@@ -358,9 +358,9 @@ impl<'a,'tcx,V,K> InferCtxtMethodsForSimplyUnifiableTypes<'tcx,K,V> for InferCtx\n impl UnifyKey for ty::IntVid {\n     type Value = Option<IntVarValue>;\n \n-    fn index(&self) -> uint { self.index as uint }\n+    fn index(&self) -> usize { self.index as usize }\n \n-    fn from_index(i: uint) -> ty::IntVid { ty::IntVid { index: i as u32 } }\n+    fn from_index(i: usize) -> ty::IntVid { ty::IntVid { index: i as u32 } }\n \n     fn unification_table<'v>(infcx: &'v InferCtxt) -> &'v RefCell<UnificationTable<ty::IntVid>> {\n         return &infcx.int_unification_table;\n@@ -391,9 +391,9 @@ impl UnifyValue for Option<IntVarValue> { }\n impl UnifyKey for ty::FloatVid {\n     type Value = Option<ast::FloatTy>;\n \n-    fn index(&self) -> uint { self.index as uint }\n+    fn index(&self) -> usize { self.index as usize }\n \n-    fn from_index(i: uint) -> ty::FloatVid { ty::FloatVid { index: i as u32 } }\n+    fn from_index(i: usize) -> ty::FloatVid { ty::FloatVid { index: i as u32 } }\n \n     fn unification_table<'v>(infcx: &'v InferCtxt) -> &'v RefCell<UnificationTable<ty::FloatVid>> {\n         return &infcx.float_unification_table;"}, {"sha": "2a4c25345447fb84e980525862e8b8b984fafbd5", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -28,8 +28,8 @@ pub fn check_crate(tcx: &ctxt) {\n     let mut visitor = IntrinsicCheckingVisitor {\n         tcx: tcx,\n         param_envs: Vec::new(),\n-        dummy_sized_ty: tcx.types.int,\n-        dummy_unsized_ty: ty::mk_vec(tcx, tcx.types.int, None),\n+        dummy_sized_ty: tcx.types.isize,\n+        dummy_unsized_ty: ty::mk_vec(tcx, tcx.types.isize, None),\n     };\n     visit::walk_crate(&mut visitor, tcx.map.krate());\n }"}, {"sha": "b9a82669f65d3910f0606e884f88aafc7d64f141", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -70,7 +70,7 @@ impl LanguageItems {\n         self.items.iter().enumerate()\n     }\n \n-    pub fn item_name(index: uint) -> &'static str {\n+    pub fn item_name(index: usize) -> &'static str {\n         let item: Option<LangItem> = FromPrimitive::from_usize(index);\n         match item {\n             $( Some($variant) => $name, )*\n@@ -79,11 +79,11 @@ impl LanguageItems {\n     }\n \n     pub fn require(&self, it: LangItem) -> Result<ast::DefId, String> {\n-        match self.items[it as uint] {\n+        match self.items[it as usize] {\n             Some(id) => Ok(id),\n             None => {\n                 Err(format!(\"requires `{}` lang_item\",\n-                            LanguageItems::item_name(it as uint)))\n+                            LanguageItems::item_name(it as usize)))\n             }\n         }\n     }\n@@ -132,7 +132,7 @@ impl LanguageItems {\n     $(\n         #[allow(dead_code)]\n         pub fn $method(&self) -> Option<ast::DefId> {\n-            self.items[$variant as uint]\n+            self.items[$variant as usize]\n         }\n     )*\n }\n@@ -142,7 +142,7 @@ struct LanguageItemCollector<'a> {\n \n     session: &'a Session,\n \n-    item_refs: FnvHashMap<&'static str, uint>,\n+    item_refs: FnvHashMap<&'static str, usize>,\n }\n \n impl<'a, 'v> Visitor<'v> for LanguageItemCollector<'a> {\n@@ -163,7 +163,7 @@ impl<'a> LanguageItemCollector<'a> {\n     pub fn new(session: &'a Session) -> LanguageItemCollector<'a> {\n         let mut item_refs = FnvHashMap();\n \n-        $( item_refs.insert($name, $variant as uint); )*\n+        $( item_refs.insert($name, $variant as usize); )*\n \n         LanguageItemCollector {\n             session: session,\n@@ -172,7 +172,7 @@ impl<'a> LanguageItemCollector<'a> {\n         }\n     }\n \n-    pub fn collect_item(&mut self, item_index: uint,\n+    pub fn collect_item(&mut self, item_index: usize,\n                         item_def_id: ast::DefId, span: Span) {\n         // Check for duplicates.\n         match self.items.items[item_index] {"}, {"sha": "e4e6a5016937d895bda0709babdb094d81851483", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -94,7 +94,7 @@ pub enum categorization<'tcx> {\n     cat_static_item,\n     cat_upvar(Upvar),                          // upvar referenced by closure env\n     cat_local(ast::NodeId),                    // local variable\n-    cat_deref(cmt<'tcx>, uint, PointerKind),   // deref of a ptr\n+    cat_deref(cmt<'tcx>, usize, PointerKind),   // deref of a ptr\n     cat_interior(cmt<'tcx>, InteriorKind),     // something interior: field, tuple, etc\n     cat_downcast(cmt<'tcx>, ast::DefId),       // selects a particular enum variant (*1)\n \n@@ -135,7 +135,7 @@ pub enum InteriorKind {\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum FieldName {\n     NamedField(ast::Name),\n-    PositionalField(uint)\n+    PositionalField(usize)\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n@@ -462,7 +462,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n     pub fn cat_expr_autoderefd(&self,\n                                expr: &ast::Expr,\n-                               autoderefs: uint)\n+                               autoderefs: usize)\n                                -> McResult<cmt<'tcx>> {\n         let mut cmt = try!(self.cat_expr_unadjusted(expr));\n         debug!(\"cat_expr_autoderefd: autoderefs={}, cmt={}\",\n@@ -868,7 +868,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn cat_tup_field<N:ast_node>(&self,\n                                      node: &N,\n                                      base_cmt: cmt<'tcx>,\n-                                     f_idx: uint,\n+                                     f_idx: usize,\n                                      f_ty: Ty<'tcx>)\n                                      -> cmt<'tcx> {\n         Rc::new(cmt_ {\n@@ -884,7 +884,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     fn cat_deref<N:ast_node>(&self,\n                              node: &N,\n                              base_cmt: cmt<'tcx>,\n-                             deref_cnt: uint,\n+                             deref_cnt: usize,\n                              deref_context: DerefKindContext)\n                              -> McResult<cmt<'tcx>> {\n         let adjustment = match self.typer.adjustments().borrow().get(&node.id()) {\n@@ -928,7 +928,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     fn cat_deref_common<N:ast_node>(&self,\n                                     node: &N,\n                                     base_cmt: cmt<'tcx>,\n-                                    deref_cnt: uint,\n+                                    deref_cnt: usize,\n                                     deref_ty: Ty<'tcx>,\n                                     deref_context: DerefKindContext,\n                                     implicit: bool)"}, {"sha": "8d2de18fea13e955757dfffe09962108dee81ea9", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -136,7 +136,7 @@ impl DestructionScopeData {\n          RustcDecodable, Debug, Copy)]\n pub struct BlockRemainder {\n     pub block: ast::NodeId,\n-    pub first_statement_index: uint,\n+    pub first_statement_index: usize,\n }\n \n impl CodeExtent {\n@@ -284,7 +284,7 @@ impl InnermostDeclaringBlock {\n struct DeclaringStatementContext {\n     stmt_id: ast::NodeId,\n     block_id: ast::NodeId,\n-    stmt_index: uint,\n+    stmt_index: usize,\n }\n \n impl DeclaringStatementContext {"}, {"sha": "e2ebe2bc0f1e53fa1ad1cb39aebf17f116469f9b", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -98,7 +98,7 @@ impl<'tcx> Substs<'tcx> {\n     }\n \n     pub fn type_for_def(&self, ty_param_def: &ty::TypeParameterDef) -> Ty<'tcx> {\n-        *self.types.get(ty_param_def.space, ty_param_def.index as uint)\n+        *self.types.get(ty_param_def.space, ty_param_def.index as usize)\n     }\n \n     pub fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n@@ -193,15 +193,15 @@ impl ParamSpace {\n         [TypeSpace, SelfSpace, FnSpace]\n     }\n \n-    pub fn to_uint(self) -> uint {\n+    pub fn to_uint(self) -> usize {\n         match self {\n             TypeSpace => 0,\n             SelfSpace => 1,\n             FnSpace => 2,\n         }\n     }\n \n-    pub fn from_uint(u: uint) -> ParamSpace {\n+    pub fn from_uint(u: usize) -> ParamSpace {\n         match u {\n             0 => TypeSpace,\n             1 => SelfSpace,\n@@ -226,8 +226,8 @@ pub struct VecPerParamSpace<T> {\n     // AF(self) = (self.content[..self.type_limit],\n     //             self.content[self.type_limit..self.self_limit],\n     //             self.content[self.self_limit..])\n-    type_limit: uint,\n-    self_limit: uint,\n+    type_limit: usize,\n+    self_limit: usize,\n     content: Vec<T>,\n }\n \n@@ -251,7 +251,7 @@ impl<T: fmt::Debug> fmt::Debug for VecPerParamSpace<T> {\n }\n \n impl<T> VecPerParamSpace<T> {\n-    fn limits(&self, space: ParamSpace) -> (uint, uint) {\n+    fn limits(&self, space: ParamSpace) -> (usize, usize) {\n         match space {\n             TypeSpace => (0, self.type_limit),\n             SelfSpace => (self.type_limit, self.self_limit),\n@@ -290,7 +290,7 @@ impl<T> VecPerParamSpace<T> {\n         }\n     }\n \n-    fn new_internal(content: Vec<T>, type_limit: uint, self_limit: uint)\n+    fn new_internal(content: Vec<T>, type_limit: usize, self_limit: usize)\n                     -> VecPerParamSpace<T>\n     {\n         VecPerParamSpace {\n@@ -343,7 +343,7 @@ impl<T> VecPerParamSpace<T> {\n         }\n     }\n \n-    pub fn truncate(&mut self, space: ParamSpace, len: uint) {\n+    pub fn truncate(&mut self, space: ParamSpace, len: usize) {\n         // FIXME (#15435): slow; O(n^2); could enhance vec to make it O(n).\n         while self.len(space) > len {\n             self.pop(space);\n@@ -364,7 +364,7 @@ impl<T> VecPerParamSpace<T> {\n         if v.len() == 0 { None } else { Some(&v[0]) }\n     }\n \n-    pub fn len(&self, space: ParamSpace) -> uint {\n+    pub fn len(&self, space: ParamSpace) -> usize {\n         self.get_slice(space).len()\n     }\n \n@@ -384,13 +384,13 @@ impl<T> VecPerParamSpace<T> {\n \n     pub fn opt_get<'a>(&'a self,\n                        space: ParamSpace,\n-                       index: uint)\n+                       index: usize)\n                        -> Option<&'a T> {\n         let v = self.get_slice(space);\n         if index < v.len() { Some(&v[index]) } else { None }\n     }\n \n-    pub fn get<'a>(&'a self, space: ParamSpace, index: uint) -> &'a T {\n+    pub fn get<'a>(&'a self, space: ParamSpace, index: usize) -> &'a T {\n         &self.get_slice(space)[index]\n     }\n \n@@ -441,7 +441,7 @@ impl<T> VecPerParamSpace<T> {\n     }\n \n     pub fn map_enumerated<U, P>(&self, pred: P) -> VecPerParamSpace<U> where\n-        P: FnMut((ParamSpace, uint, &T)) -> U,\n+        P: FnMut((ParamSpace, usize, &T)) -> U,\n     {\n         let result = self.iter_enumerated().map(pred).collect();\n         VecPerParamSpace::new_internal(result,\n@@ -487,8 +487,8 @@ impl<T> VecPerParamSpace<T> {\n #[derive(Clone)]\n pub struct EnumeratedItems<'a,T:'a> {\n     vec: &'a VecPerParamSpace<T>,\n-    space_index: uint,\n-    elem_index: uint\n+    space_index: usize,\n+    elem_index: usize\n }\n \n impl<'a,T> EnumeratedItems<'a,T> {\n@@ -511,9 +511,9 @@ impl<'a,T> EnumeratedItems<'a,T> {\n }\n \n impl<'a,T> Iterator for EnumeratedItems<'a,T> {\n-    type Item = (ParamSpace, uint, &'a T);\n+    type Item = (ParamSpace, usize, &'a T);\n \n-    fn next(&mut self) -> Option<(ParamSpace, uint, &'a T)> {\n+    fn next(&mut self) -> Option<(ParamSpace, usize, &'a T)> {\n         let spaces = ParamSpace::all();\n         if self.space_index < spaces.len() {\n             let space = spaces[self.space_index];\n@@ -598,7 +598,7 @@ struct SubstFolder<'a, 'tcx: 'a> {\n     root_ty: Option<Ty<'tcx>>,\n \n     // Depth of type stack\n-    ty_stack_depth: uint,\n+    ty_stack_depth: usize,\n \n     // Number of region binders we have passed through while doing the substitution\n     region_binders_passed: u32,\n@@ -626,7 +626,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                 match self.substs.regions {\n                     ErasedRegions => ty::ReStatic,\n                     NonerasedRegions(ref regions) =>\n-                        match regions.opt_get(space, i as uint) {\n+                        match regions.opt_get(space, i as usize) {\n                             Some(&r) => {\n                                 self.shift_region_through_binders(r)\n                             }\n@@ -682,7 +682,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n impl<'a,'tcx> SubstFolder<'a,'tcx> {\n     fn ty_for_param(&self, p: ty::ParamTy, source_ty: Ty<'tcx>) -> Ty<'tcx> {\n         // Look up the type in the substitutions. It really should be in there.\n-        let opt_ty = self.substs.types.opt_get(p.space, p.idx as uint);\n+        let opt_ty = self.substs.types.opt_get(p.space, p.idx as usize);\n         let ty = match opt_ty {\n             Some(t) => *t,\n             None => {"}, {"sha": "1b7469b8cb750e9c244ea4a5f5c0ee2b69577bf9", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -54,7 +54,7 @@ pub struct FulfillmentContext<'tcx> {\n     // Remembers the count of trait obligations that we have already\n     // attempted to select. This is used to avoid repeating work\n     // when `select_new_obligations` is called.\n-    attempted_mark: uint,\n+    attempted_mark: usize,\n \n     // A set of constraints that regionck must validate. Each\n     // constraint has the form `T:'a`, meaning \"some type `T` must"}, {"sha": "c72d1b0e9727087b1f52bafc645f6d987a8fed1e", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -68,7 +68,7 @@ mod util;\n #[derive(Clone, PartialEq, Eq)]\n pub struct Obligation<'tcx, T> {\n     pub cause: ObligationCause<'tcx>,\n-    pub recursion_depth: uint,\n+    pub recursion_depth: usize,\n     pub predicate: T,\n }\n \n@@ -482,7 +482,7 @@ impl<'tcx,O> Obligation<'tcx,O> {\n     }\n \n     fn with_depth(cause: ObligationCause<'tcx>,\n-                  recursion_depth: uint,\n+                  recursion_depth: usize,\n                   trait_ref: O)\n                   -> Obligation<'tcx, O>\n     {"}, {"sha": "1594d8b2e0d047b06a836e72ea02afe7a307416d", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -197,7 +197,7 @@ pub fn normalize<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n /// As `normalize`, but with a custom depth.\n pub fn normalize_with_depth<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n                                           cause: ObligationCause<'tcx>,\n-                                          depth: uint,\n+                                          depth: usize,\n                                           value: &T)\n                                           -> Normalized<'tcx, T>\n     where T : TypeFoldable<'tcx> + HasProjectionTypes + Clone + Repr<'tcx>\n@@ -214,13 +214,13 @@ struct AssociatedTypeNormalizer<'a,'b:'a,'tcx:'b> {\n     selcx: &'a mut SelectionContext<'b,'tcx>,\n     cause: ObligationCause<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,\n-    depth: uint,\n+    depth: usize,\n }\n \n impl<'a,'b,'tcx> AssociatedTypeNormalizer<'a,'b,'tcx> {\n     fn new(selcx: &'a mut SelectionContext<'b,'tcx>,\n            cause: ObligationCause<'tcx>,\n-           depth: uint)\n+           depth: usize)\n            -> AssociatedTypeNormalizer<'a,'b,'tcx>\n     {\n         AssociatedTypeNormalizer {\n@@ -314,7 +314,7 @@ pub fn normalize_projection_type<'a,'b,'tcx>(\n     selcx: &'a mut SelectionContext<'b,'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n-    depth: uint)\n+    depth: usize)\n     -> NormalizedTy<'tcx>\n {\n     opt_normalize_projection_type(selcx, projection_ty.clone(), cause.clone(), depth)\n@@ -344,7 +344,7 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n     selcx: &'a mut SelectionContext<'b,'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n-    depth: uint)\n+    depth: usize)\n     -> Option<NormalizedTy<'tcx>>\n {\n     debug!(\"normalize_projection_type(\\\n@@ -412,7 +412,7 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n fn normalize_to_error<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                                projection_ty: ty::ProjectionTy<'tcx>,\n                                cause: ObligationCause<'tcx>,\n-                               depth: uint)\n+                               depth: usize)\n                                -> NormalizedTy<'tcx>\n {\n     let trait_ref = projection_ty.trait_ref.to_poly_trait_ref();\n@@ -699,10 +699,10 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n             // But wait, you say! What about an example like this:\n             //\n             // ```\n-            // fn bar<T:SomeTrait<Foo=uint>>(...) { ... }\n+            // fn bar<T:SomeTrait<Foo=usize>>(...) { ... }\n             // ```\n             //\n-            // Doesn't the `T : Sometrait<Foo=uint>` predicate help\n+            // Doesn't the `T : Sometrait<Foo=usize>` predicate help\n             // resolve `T::Foo`? And of course it does, but in fact\n             // that single predicate is desugared into two predicates\n             // in the compiler: a trait predicate (`T : SomeTrait`) and a"}, {"sha": "04f855979e1a51cff8e0507195d2f15a37516ef9", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -110,7 +110,7 @@ pub enum MethodMatchedData {\n /// The selection process begins by considering all impls, where\n /// clauses, and so forth that might resolve an obligation.  Sometimes\n /// we'll be able to say definitively that (e.g.) an impl does not\n-/// apply to the obligation: perhaps it is defined for `uint` but the\n+/// apply to the obligation: perhaps it is defined for `usize` but the\n /// obligation is for `int`. In that case, we drop the impl out of the\n /// list.  But the other cases are considered *candidates*.\n ///\n@@ -627,7 +627,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // for example, we are looking for $0:Eq where $0 is some\n         // unconstrained type variable. In that case, we'll get a\n         // candidate which assumes $0 == int, one that assumes $0 ==\n-        // uint, etc. This spells an ambiguity.\n+        // usize, etc. This spells an ambiguity.\n \n         // If there is more than one candidate, first winnow them down\n         // by considering extra conditions (nested obligations and so\n@@ -2010,7 +2010,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                    impl_def_id: ast::DefId,\n                    substs: Normalized<'tcx, Substs<'tcx>>,\n                    cause: ObligationCause<'tcx>,\n-                   recursion_depth: uint,\n+                   recursion_depth: usize,\n                    skol_map: infer::SkolemizationMap,\n                    snapshot: &infer::CombinedSnapshot)\n                    -> VtableImplData<'tcx, PredicateObligation<'tcx>>\n@@ -2142,9 +2142,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ///\n     ///     impl Fn(int) for Closure { ... }\n     ///\n-    /// Now imagine our obligation is `Fn(uint) for Closure`. So far\n+    /// Now imagine our obligation is `Fn(usize) for Closure`. So far\n     /// we have matched the self-type `Closure`. At this point we'll\n-    /// compare the `int` to `uint` and generate an error.\n+    /// compare the `int` to `usize` and generate an error.\n     ///\n     /// Note that this checking occurs *after* the impl has selected,\n     /// because these output type parameters should not affect the\n@@ -2441,7 +2441,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// impl.\n     fn impl_or_trait_obligations(&mut self,\n                                  cause: ObligationCause<'tcx>,\n-                                 recursion_depth: uint,\n+                                 recursion_depth: usize,\n                                  def_id: ast::DefId, // of impl or trait\n                                  substs: &Substs<'tcx>, // for impl or trait\n                                  skol_map: infer::SkolemizationMap,"}, {"sha": "719eff034245ba7fa5151acb48f3f14ede37fdef", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -278,7 +278,7 @@ impl<'tcx> fmt::Debug for super::VtableObjectData<'tcx> {\n /// See `super::obligations_for_generics`\n pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      cause: ObligationCause<'tcx>,\n-                                     recursion_depth: uint,\n+                                     recursion_depth: usize,\n                                      generic_bounds: &ty::InstantiatedPredicates<'tcx>)\n                                      -> VecPerParamSpace<PredicateObligation<'tcx>>\n {\n@@ -316,7 +316,7 @@ pub fn trait_ref_for_builtin_bound<'tcx>(\n pub fn predicate_for_trait_ref<'tcx>(\n     cause: ObligationCause<'tcx>,\n     trait_ref: Rc<ty::TraitRef<'tcx>>,\n-    recursion_depth: uint)\n+    recursion_depth: usize)\n     -> Result<PredicateObligation<'tcx>, ErrorReported>\n {\n     Ok(Obligation {\n@@ -330,7 +330,7 @@ pub fn predicate_for_trait_def<'tcx>(\n     tcx: &ty::ctxt<'tcx>,\n     cause: ObligationCause<'tcx>,\n     trait_def_id: ast::DefId,\n-    recursion_depth: uint,\n+    recursion_depth: usize,\n     param_ty: Ty<'tcx>)\n     -> Result<PredicateObligation<'tcx>, ErrorReported>\n {\n@@ -345,7 +345,7 @@ pub fn predicate_for_builtin_bound<'tcx>(\n     tcx: &ty::ctxt<'tcx>,\n     cause: ObligationCause<'tcx>,\n     builtin_bound: ty::BuiltinBound,\n-    recursion_depth: uint,\n+    recursion_depth: usize,\n     param_ty: Ty<'tcx>)\n     -> Result<PredicateObligation<'tcx>, ErrorReported>\n {\n@@ -377,7 +377,7 @@ pub fn upcast<'tcx>(tcx: &ty::ctxt<'tcx>,\n pub fn get_vtable_index_of_object_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                object_trait_ref: ty::PolyTraitRef<'tcx>,\n                                                trait_def_id: ast::DefId,\n-                                               method_offset_in_trait: uint) -> uint {\n+                                               method_offset_in_trait: usize) -> usize {\n     // We need to figure the \"real index\" of the method in a\n     // listing of all the methods of an object. We do this by\n     // iterating down the supertraits of the object's trait until"}, {"sha": "c6f63e9503e506dddc54969902c7cffac0ef232d", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 92, "deletions": 92, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -261,8 +261,8 @@ pub struct field_ty {\n #[derive(Copy, PartialEq, Eq, Hash)]\n pub struct creader_cache_key {\n     pub cnum: CrateNum,\n-    pub pos: uint,\n-    pub len: uint\n+    pub pos: usize,\n+    pub len: usize\n }\n \n #[derive(Clone, PartialEq, RustcDecodable, RustcEncodable)]\n@@ -288,18 +288,18 @@ pub enum AutoAdjustment<'tcx> {\n \n #[derive(Clone, PartialEq, Debug)]\n pub enum UnsizeKind<'tcx> {\n-    // [T, ..n] -> [T], the uint field is n.\n-    UnsizeLength(uint),\n+    // [T, ..n] -> [T], the usize field is n.\n+    UnsizeLength(usize),\n     // An unsize coercion applied to the tail field of a struct.\n-    // The uint is the index of the type parameter which is unsized.\n-    UnsizeStruct(Box<UnsizeKind<'tcx>>, uint),\n+    // The usize is the index of the type parameter which is unsized.\n+    UnsizeStruct(Box<UnsizeKind<'tcx>>, usize),\n     UnsizeVtable(TyTrait<'tcx>, /* the self type of the trait */ Ty<'tcx>),\n     UnsizeUpcast(Ty<'tcx>),\n }\n \n #[derive(Clone, Debug)]\n pub struct AutoDerefRef<'tcx> {\n-    pub autoderefs: uint,\n+    pub autoderefs: usize,\n     pub autoref: Option<AutoRef<'tcx>>\n }\n \n@@ -423,7 +423,7 @@ pub fn type_of_adjust<'tcx>(cx: &ctxt<'tcx>, adj: &AutoAdjustment<'tcx>) -> Opti\n #[derive(Clone, Copy, RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Debug)]\n pub struct param_index {\n     pub space: subst::ParamSpace,\n-    pub index: uint\n+    pub index: usize\n }\n \n #[derive(Clone, Debug)]\n@@ -452,10 +452,10 @@ pub struct MethodParam<'tcx> {\n     // instantiated with fresh variables at this point.\n     pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n \n-    // index of uint in the list of trait items. Note that this is NOT\n+    // index of usize in the list of trait items. Note that this is NOT\n     // the index into the vtable, because the list of trait items\n     // includes associated types.\n-    pub method_num: uint,\n+    pub method_num: usize,\n \n     /// The impl for the trait from which the method comes. This\n     /// should only be used for certain linting/heuristic purposes\n@@ -474,13 +474,13 @@ pub struct MethodObject<'tcx> {\n     pub object_trait_id: ast::DefId,\n \n     // index of the method to be invoked amongst the trait's items\n-    pub method_num: uint,\n+    pub method_num: usize,\n \n     // index into the actual runtime vtable.\n     // the vtable is formed by concatenating together the method lists of\n     // the base object trait and all supertraits; this is the index into\n     // that vtable\n-    pub vtable_index: uint,\n+    pub vtable_index: usize,\n }\n \n #[derive(Clone)]\n@@ -511,7 +511,7 @@ pub struct MethodCall {\n #[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, Copy)]\n pub enum ExprAdjustment {\n     NoAdjustment,\n-    AutoDeref(uint),\n+    AutoDeref(usize),\n     AutoObject\n }\n \n@@ -530,7 +530,7 @@ impl MethodCall {\n         }\n     }\n \n-    pub fn autoderef(expr_id: ast::NodeId, autoderef: uint) -> MethodCall {\n+    pub fn autoderef(expr_id: ast::NodeId, autoderef: usize) -> MethodCall {\n         MethodCall {\n             expr_id: expr_id,\n             adjustment: AutoDeref(1 + autoderef)\n@@ -564,7 +564,7 @@ pub enum vtable_origin<'tcx> {\n       The first argument is the param index (identifying T in the example),\n       and the second is the bound number (identifying baz)\n      */\n-    vtable_param(param_index, uint),\n+    vtable_param(param_index, usize),\n \n     /*\n       Vtable automatically generated for a closure. The def ID is the\n@@ -639,12 +639,12 @@ impl<'tcx> CtxtArenas<'tcx> {\n pub struct CommonTypes<'tcx> {\n     pub bool: Ty<'tcx>,\n     pub char: Ty<'tcx>,\n-    pub int: Ty<'tcx>,\n+    pub isize: Ty<'tcx>,\n     pub i8: Ty<'tcx>,\n     pub i16: Ty<'tcx>,\n     pub i32: Ty<'tcx>,\n     pub i64: Ty<'tcx>,\n-    pub uint: Ty<'tcx>,\n+    pub usize: Ty<'tcx>,\n     pub u8: Ty<'tcx>,\n     pub u16: Ty<'tcx>,\n     pub u32: Ty<'tcx>,\n@@ -877,10 +877,10 @@ macro_rules! sty_debug_print {\n             use middle::ty;\n             #[derive(Copy)]\n             struct DebugStat {\n-                total: uint,\n-                region_infer: uint,\n-                ty_infer: uint,\n-                both_infer: uint,\n+                total: usize,\n+                region_infer: usize,\n+                ty_infer: usize,\n+                both_infer: usize,\n             }\n \n             pub fn go(tcx: &ty::ctxt) {\n@@ -1024,7 +1024,7 @@ pub fn type_has_late_bound_regions(ty: Ty) -> bool {\n ///\n /// So, for example, consider a type like the following, which has two binders:\n ///\n-///    for<'a> fn(x: for<'b> fn(&'a int, &'b int))\n+///    for<'a> fn(x: for<'b> fn(&'a isize, &'b isize))\n ///    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ outer scope\n ///                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~  inner scope\n ///\n@@ -1110,7 +1110,7 @@ impl<'tcx> PolyFnSig<'tcx> {\n     pub fn inputs(&self) -> ty::Binder<Vec<Ty<'tcx>>> {\n         ty::Binder(self.0.inputs.clone())\n     }\n-    pub fn input(&self, index: uint) -> ty::Binder<Ty<'tcx>> {\n+    pub fn input(&self, index: usize) -> ty::Binder<Ty<'tcx>> {\n         ty::Binder(self.0.inputs[index])\n     }\n     pub fn output(&self) -> ty::Binder<FnOutput<'tcx>> {\n@@ -1132,7 +1132,7 @@ pub struct ParamTy {\n /// regions (and perhaps later types) in a higher-ranked setting. In\n /// particular, imagine a type like this:\n ///\n-///     for<'a> fn(for<'b> fn(&'b int, &'a int), &'a char)\n+///     for<'a> fn(for<'b> fn(&'b isize, &'a isize), &'a char)\n ///     ^          ^            |        |         |\n ///     |          |            |        |         |\n ///     |          +------------+ 1      |         |\n@@ -1149,11 +1149,11 @@ pub struct ParamTy {\n /// count the number of binders, inside out. Some examples should help\n /// clarify what I mean.\n ///\n-/// Let's start with the reference type `&'b int` that is the first\n+/// Let's start with the reference type `&'b isize` that is the first\n /// argument to the inner function. This region `'b` is assigned a De\n /// Bruijn index of 1, meaning \"the innermost binder\" (in this case, a\n /// fn). The region `'a` that appears in the second argument type (`&'a\n-/// int`) would then be assigned a De Bruijn index of 2, meaning \"the\n+/// isize`) would then be assigned a De Bruijn index of 2, meaning \"the\n /// second-innermost binder\". (These indices are written on the arrays\n /// in the diagram).\n ///\n@@ -1234,23 +1234,23 @@ pub enum BorrowKind {\n     /// implicit closure bindings. It is needed when you the closure\n     /// is borrowing or mutating a mutable referent, e.g.:\n     ///\n-    ///    let x: &mut int = ...;\n+    ///    let x: &mut isize = ...;\n     ///    let y = || *x += 5;\n     ///\n     /// If we were to try to translate this closure into a more explicit\n     /// form, we'd encounter an error with the code as written:\n     ///\n-    ///    struct Env { x: & &mut int }\n-    ///    let x: &mut int = ...;\n+    ///    struct Env { x: & &mut isize }\n+    ///    let x: &mut isize = ...;\n     ///    let y = (&mut Env { &x }, fn_ptr);  // Closure is pair of env and fn\n     ///    fn fn_ptr(env: &mut Env) { **env.x += 5; }\n     ///\n     /// This is then illegal because you cannot mutate a `&mut` found\n     /// in an aliasable location. To solve, you'd have to translate with\n     /// an `&mut` borrow:\n     ///\n-    ///    struct Env { x: & &mut int }\n-    ///    let x: &mut int = ...;\n+    ///    struct Env { x: & &mut isize }\n+    ///    let x: &mut isize = ...;\n     ///    let y = (&mut Env { &mut x }, fn_ptr); // changed from &x to &mut x\n     ///    fn fn_ptr(env: &mut Env) { **env.x += 5; }\n     ///\n@@ -1361,7 +1361,7 @@ pub enum sty<'tcx> {\n     ty_enum(DefId, &'tcx Substs<'tcx>),\n     ty_uniq(Ty<'tcx>),\n     ty_str,\n-    ty_vec(Ty<'tcx>, Option<uint>), // Second field is length.\n+    ty_vec(Ty<'tcx>, Option<usize>), // Second field is length.\n     ty_ptr(mt<'tcx>),\n     ty_rptr(&'tcx Region, mt<'tcx>),\n \n@@ -1491,7 +1491,7 @@ impl<'tcx> PolyTraitRef<'tcx> {\n }\n \n /// Binder is a binder for higher-ranked lifetimes. It is part of the\n-/// compiler's representation for things like `for<'a> Fn(&'a int)`\n+/// compiler's representation for things like `for<'a> Fn(&'a isize)`\n /// (which would be represented by the type `PolyTraitRef ==\n /// Binder<TraitRef>`). Note that when we skolemize, instantiate,\n /// erase, or otherwise \"discharge\" these bound regions, we change the\n@@ -1552,9 +1552,9 @@ pub enum type_err<'tcx> {\n     terr_ptr_mutability,\n     terr_ref_mutability,\n     terr_vec_mutability,\n-    terr_tuple_size(expected_found<uint>),\n-    terr_fixed_array_size(expected_found<uint>),\n-    terr_ty_param_size(expected_found<uint>),\n+    terr_tuple_size(expected_found<usize>),\n+    terr_fixed_array_size(expected_found<usize>),\n+    terr_ty_param_size(expected_found<usize>),\n     terr_arg_count,\n     terr_regions_does_not_outlive(Region, Region),\n     terr_regions_not_same(Region, Region),\n@@ -1571,7 +1571,7 @@ pub enum type_err<'tcx> {\n     terr_cyclic_ty,\n     terr_convergence_mismatch(expected_found<bool>),\n     terr_projection_name_mismatched(expected_found<ast::Name>),\n-    terr_projection_bounds_length(expected_found<uint>),\n+    terr_projection_bounds_length(expected_found<usize>),\n }\n \n /// Bounds suitable for a named type parameter like `A` in `fn foo<A>`\n@@ -1600,7 +1600,7 @@ pub type BuiltinBounds = EnumSet<BuiltinBound>;\n \n #[derive(Clone, RustcEncodable, PartialEq, Eq, RustcDecodable, Hash,\n            Debug, Copy)]\n-#[repr(uint)]\n+#[repr(usize)]\n pub enum BuiltinBound {\n     BoundSend,\n     BoundSized,\n@@ -1628,10 +1628,10 @@ pub fn region_existential_bound<'tcx>(r: ty::Region) -> ExistentialBounds<'tcx>\n }\n \n impl CLike for BuiltinBound {\n-    fn to_usize(&self) -> uint {\n-        *self as uint\n+    fn to_usize(&self) -> usize {\n+        *self as usize\n     }\n-    fn from_usize(v: uint) -> BuiltinBound {\n+    fn from_usize(v: usize) -> BuiltinBound {\n         unsafe { mem::transmute(v) }\n     }\n }\n@@ -2202,8 +2202,8 @@ impl<'tcx> Predicate<'tcx> {\n ///\n /// Here, the `GenericPredicates` for `Foo` would contain a list of bounds like\n /// `[[], [U:Bar<T>]]`.  Now if there were some particular reference\n-/// like `Foo<int,uint>`, then the `InstantiatedPredicates` would be `[[],\n-/// [uint:Bar<int>]]`.\n+/// like `Foo<isize,usize>`, then the `InstantiatedPredicates` would be `[[],\n+/// [usize:Bar<isize>]]`.\n #[derive(Clone, Debug)]\n pub struct InstantiatedPredicates<'tcx> {\n     pub predicates: VecPerParamSpace<Predicate<'tcx>>,\n@@ -2545,12 +2545,12 @@ impl<'tcx> CommonTypes<'tcx> {\n             bool: intern_ty(arena, interner, ty_bool),\n             char: intern_ty(arena, interner, ty_char),\n             err: intern_ty(arena, interner, ty_err),\n-            int: intern_ty(arena, interner, ty_int(ast::TyIs)),\n+            isize: intern_ty(arena, interner, ty_int(ast::TyIs)),\n             i8: intern_ty(arena, interner, ty_int(ast::TyI8)),\n             i16: intern_ty(arena, interner, ty_int(ast::TyI16)),\n             i32: intern_ty(arena, interner, ty_int(ast::TyI32)),\n             i64: intern_ty(arena, interner, ty_int(ast::TyI64)),\n-            uint: intern_ty(arena, interner, ty_uint(ast::TyUs)),\n+            usize: intern_ty(arena, interner, ty_uint(ast::TyUs)),\n             u8: intern_ty(arena, interner, ty_uint(ast::TyU8)),\n             u16: intern_ty(arena, interner, ty_uint(ast::TyU16)),\n             u32: intern_ty(arena, interner, ty_uint(ast::TyU32)),\n@@ -2935,7 +2935,7 @@ impl FlagComputation {\n \n pub fn mk_mach_int<'tcx>(tcx: &ctxt<'tcx>, tm: ast::IntTy) -> Ty<'tcx> {\n     match tm {\n-        ast::TyIs   => tcx.types.int,\n+        ast::TyIs   => tcx.types.isize,\n         ast::TyI8   => tcx.types.i8,\n         ast::TyI16  => tcx.types.i16,\n         ast::TyI32  => tcx.types.i32,\n@@ -2945,7 +2945,7 @@ pub fn mk_mach_int<'tcx>(tcx: &ctxt<'tcx>, tm: ast::IntTy) -> Ty<'tcx> {\n \n pub fn mk_mach_uint<'tcx>(tcx: &ctxt<'tcx>, tm: ast::UintTy) -> Ty<'tcx> {\n     match tm {\n-        ast::TyUs   => tcx.types.uint,\n+        ast::TyUs   => tcx.types.usize,\n         ast::TyU8   => tcx.types.u8,\n         ast::TyU16  => tcx.types.u16,\n         ast::TyU32  => tcx.types.u32,\n@@ -3004,7 +3004,7 @@ pub fn mk_nil_ptr<'tcx>(cx: &ctxt<'tcx>) -> Ty<'tcx> {\n     mk_ptr(cx, mt {ty: mk_nil(cx), mutbl: ast::MutImmutable})\n }\n \n-pub fn mk_vec<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, sz: Option<uint>) -> Ty<'tcx> {\n+pub fn mk_vec<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, sz: Option<usize>) -> Ty<'tcx> {\n     mk_t(cx, ty_vec(ty, sz))\n }\n \n@@ -3130,9 +3130,9 @@ impl<'tcx> TyS<'tcx> {\n     /// structs or variants. For example:\n     ///\n     /// ```notrust\n-    /// int => { int }\n-    /// Foo<Bar<int>> => { Foo<Bar<int>>, Bar<int>, int }\n-    /// [int] => { [int], int }\n+    /// isize => { isize }\n+    /// Foo<Bar<isize>> => { Foo<Bar<isize>>, Bar<isize>, isize }\n+    /// [isize] => { [isize], isize }\n     /// ```\n     pub fn walk(&'tcx self) -> TypeWalker<'tcx> {\n         TypeWalker::new(self)\n@@ -3143,9 +3143,9 @@ impl<'tcx> TyS<'tcx> {\n     /// example:\n     ///\n     /// ```notrust\n-    /// int => { }\n-    /// Foo<Bar<int>> => { Bar<int>, int }\n-    /// [int] => { int }\n+    /// isize => { }\n+    /// Foo<Bar<isize>> => { Bar<isize>, isize }\n+    /// [isize] => { isize }\n     /// ```\n     pub fn walk_children(&'tcx self) -> TypeWalker<'tcx> {\n         // Walks type reachable from `self` but not `self\n@@ -3343,7 +3343,7 @@ pub fn simd_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     }\n }\n \n-pub fn simd_size(cx: &ctxt, ty: Ty) -> uint {\n+pub fn simd_size(cx: &ctxt, ty: Ty) -> usize {\n     match ty.sty {\n         ty_struct(did, _) => {\n             let fields = lookup_struct_fields(cx, did);\n@@ -3611,7 +3611,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n         cache.insert(ty, TC::None);\n \n         let result = match ty.sty {\n-            // uint and int are ffi-unsafe\n+            // usize and isize are ffi-unsafe\n             ty_uint(ast::TyUs) | ty_int(ast::TyIs) => {\n                 TC::ReachesFfiUnsafe\n             }\n@@ -4292,7 +4292,7 @@ pub fn array_element_ty<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>\n /// For an enum `t`, `variant` is None only if `t` is a univariant enum.\n pub fn positional_element_ty<'tcx>(cx: &ctxt<'tcx>,\n                                    ty: Ty<'tcx>,\n-                                   i: uint,\n+                                   i: usize,\n                                    variant: Option<ast::DefId>) -> Option<Ty<'tcx>> {\n \n     match (&ty.sty, variant) {\n@@ -4468,8 +4468,8 @@ pub fn pat_ty_opt<'tcx>(cx: &ctxt<'tcx>, pat: &ast::Pat) -> Option<Ty<'tcx>> {\n // adjustments.  See `expr_ty_adjusted()` instead.\n //\n // NB (2): This type doesn't provide type parameter substitutions; e.g. if you\n-// ask for the type of \"id\" in \"id(3)\", it will return \"fn(&int) -> int\"\n-// instead of \"fn(ty) -> T with T = int\".\n+// ask for the type of \"id\" in \"id(3)\", it will return \"fn(&isize) -> isize\"\n+// instead of \"fn(ty) -> T with T = isize\".\n pub fn expr_ty<'tcx>(cx: &ctxt<'tcx>, expr: &ast::Expr) -> Ty<'tcx> {\n     return node_id_to_type(cx, expr.id);\n }\n@@ -4879,7 +4879,7 @@ pub fn stmt_node_id(s: &ast::Stmt) -> ast::NodeId {\n }\n \n pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n-                     -> uint {\n+                     -> usize {\n     let mut i = 0;\n     for f in fields { if f.name == name { return i; } i += 1; }\n     tcx.sess.bug(&format!(\n@@ -4891,7 +4891,7 @@ pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n }\n \n pub fn impl_or_trait_item_idx(id: ast::Name, trait_items: &[ImplOrTraitItem])\n-                              -> Option<uint> {\n+                              -> Option<usize> {\n     trait_items.iter().position(|m| m.name() == id)\n }\n \n@@ -5163,7 +5163,7 @@ fn lookup_locally_or_in_crate_store<V, F>(descr: &str,\n     v\n }\n \n-pub fn trait_item<'tcx>(cx: &ctxt<'tcx>, trait_did: ast::DefId, idx: uint)\n+pub fn trait_item<'tcx>(cx: &ctxt<'tcx>, trait_did: ast::DefId, idx: usize)\n                         -> ImplOrTraitItem<'tcx> {\n     let method_def_id = (*ty::trait_item_def_ids(cx, trait_did))[idx].def_id();\n     impl_or_trait_item(cx, method_def_id)\n@@ -5238,10 +5238,10 @@ pub fn is_associated_type(cx: &ctxt, id: ast::DefId) -> bool {\n pub fn associated_type_parameter_index(cx: &ctxt,\n                                        trait_def: &TraitDef,\n                                        associated_type_id: ast::DefId)\n-                                       -> uint {\n+                                       -> usize {\n     for type_parameter_def in trait_def.generics.types.iter() {\n         if type_parameter_def.def_id == associated_type_id {\n-            return type_parameter_def.index as uint\n+            return type_parameter_def.index as usize\n         }\n     }\n     cx.sess.bug(\"couldn't find associated type parameter index\")\n@@ -5794,24 +5794,24 @@ pub fn closure_upvars<'tcx>(typer: &mc::Typer<'tcx>,\n \n pub fn is_binopable<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, op: ast::BinOp) -> bool {\n     #![allow(non_upper_case_globals)]\n-    const tycat_other: int = 0;\n-    const tycat_bool: int = 1;\n-    const tycat_char: int = 2;\n-    const tycat_int: int = 3;\n-    const tycat_float: int = 4;\n-    const tycat_raw_ptr: int = 6;\n-\n-    const opcat_add: int = 0;\n-    const opcat_sub: int = 1;\n-    const opcat_mult: int = 2;\n-    const opcat_shift: int = 3;\n-    const opcat_rel: int = 4;\n-    const opcat_eq: int = 5;\n-    const opcat_bit: int = 6;\n-    const opcat_logic: int = 7;\n-    const opcat_mod: int = 8;\n-\n-    fn opcat(op: ast::BinOp) -> int {\n+    const tycat_other: isize = 0;\n+    const tycat_bool: isize = 1;\n+    const tycat_char: isize = 2;\n+    const tycat_int: isize = 3;\n+    const tycat_float: isize = 4;\n+    const tycat_raw_ptr: isize = 6;\n+\n+    const opcat_add: isize = 0;\n+    const opcat_sub: isize = 1;\n+    const opcat_mult: isize = 2;\n+    const opcat_shift: isize = 3;\n+    const opcat_rel: isize = 4;\n+    const opcat_eq: isize = 5;\n+    const opcat_bit: isize = 6;\n+    const opcat_logic: isize = 7;\n+    const opcat_mod: isize = 8;\n+\n+    fn opcat(op: ast::BinOp) -> isize {\n         match op.node {\n           ast::BiAdd => opcat_add,\n           ast::BiSub => opcat_sub,\n@@ -5834,7 +5834,7 @@ pub fn is_binopable<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, op: ast::BinOp) -> bool\n         }\n     }\n \n-    fn tycat<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> int {\n+    fn tycat<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> isize {\n         if type_is_simd(cx, ty) {\n             return tycat(cx, simd_type(cx, ty))\n         }\n@@ -5856,21 +5856,21 @@ pub fn is_binopable<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, op: ast::BinOp) -> bool\n     /*other*/   [f, f, f, f,     f,   f,  f,   f,     f],\n     /*bool*/    [f, f, f, f,     t,   t,  t,   t,     f],\n     /*char*/    [f, f, f, f,     t,   t,  f,   f,     f],\n-    /*int*/     [t, t, t, t,     t,   t,  t,   f,     t],\n+    /*isize*/     [t, t, t, t,     t,   t,  t,   f,     t],\n     /*float*/   [t, t, t, f,     t,   t,  f,   f,     f],\n     /*bot*/     [t, t, t, t,     t,   t,  t,   t,     t],\n     /*raw ptr*/ [f, f, f, f,     t,   t,  f,   f,     f]];\n \n-    return tbl[tycat(cx, ty) as uint ][opcat(op) as uint];\n+    return tbl[tycat(cx, ty) as usize ][opcat(op) as usize];\n }\n \n // Returns the repeat count for a repeating vector expression.\n-pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n-    match const_eval::eval_const_expr_partial(tcx, count_expr, Some(tcx.types.uint)) {\n+pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> usize {\n+    match const_eval::eval_const_expr_partial(tcx, count_expr, Some(tcx.types.usize)) {\n         Ok(val) => {\n             let found = match val {\n-                const_eval::const_uint(count) => return count as uint,\n-                const_eval::const_int(count) if count >= 0 => return count as uint,\n+                const_eval::const_uint(count) => return count as usize,\n+                const_eval::const_int(count) if count >= 0 => return count as usize,\n                 const_eval::const_int(_) => \"negative integer\",\n                 const_eval::const_float(_) => \"float\",\n                 const_eval::const_str(_) => \"string\",\n@@ -6739,7 +6739,7 @@ pub fn liberate_late_bound_regions<'tcx, T>(\n pub fn count_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n     value: &Binder<T>)\n-    -> uint\n+    -> usize\n     where T : TypeFoldable<'tcx> + Repr<'tcx>\n {\n     let (_, skol_map) = replace_late_bound_regions(tcx, value, |_| ty::ReStatic);\n@@ -6785,8 +6785,8 @@ pub fn erase_late_bound_regions<'tcx, T>(\n ///\n /// The chief purpose of this function is to canonicalize regions so that two\n /// `FnSig`s or `TraitRef`s which are equivalent up to region naming will become\n-/// structurally identical.  For example, `for<'a, 'b> fn(&'a int, &'b int)` and\n-/// `for<'a, 'b> fn(&'b int, &'a int)` will become identical after anonymization.\n+/// structurally identical.  For example, `for<'a, 'b> fn(&'a isize, &'b isize)` and\n+/// `for<'a, 'b> fn(&'b isize, &'a isize)` will become identical after anonymization.\n pub fn anonymize_late_bound_regions<'tcx, T>(\n     tcx: &ctxt<'tcx>,\n     sig: &Binder<T>)"}, {"sha": "5d492f1c95e11c81ccb8b4a528e2484a4a3712af", "filename": "src/librustc/middle/ty_walk.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_walk.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -15,7 +15,7 @@ use std::iter::Iterator;\n \n pub struct TypeWalker<'tcx> {\n     stack: Vec<Ty<'tcx>>,\n-    last_subtree: uint,\n+    last_subtree: usize,\n }\n \n impl<'tcx> TypeWalker<'tcx> {\n@@ -80,14 +80,14 @@ impl<'tcx> TypeWalker<'tcx> {\n     /// Skips the subtree of types corresponding to the last type\n     /// returned by `next()`.\n     ///\n-    /// Example: Imagine you are walking `Foo<Bar<int>, uint>`.\n+    /// Example: Imagine you are walking `Foo<Bar<int>, usize>`.\n     ///\n     /// ```\n     /// let mut iter: TypeWalker = ...;\n     /// iter.next(); // yields Foo\n     /// iter.next(); // yields Bar<int>\n     /// iter.skip_current_subtree(); // skips int\n-    /// iter.next(); // yields uint\n+    /// iter.next(); // yields usize\n     /// ```\n     pub fn skip_current_subtree(&mut self) {\n         self.stack.truncate(self.last_subtree);"}, {"sha": "1f0431d8c4f0ea8d8b4b82af2f05dfb79fa97e00", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -440,14 +440,14 @@ macro_rules! options {\n             }\n         }\n \n-        fn parse_uint(slot: &mut uint, v: Option<&str>) -> bool {\n+        fn parse_uint(slot: &mut usize, v: Option<&str>) -> bool {\n             match v.and_then(|s| s.parse().ok()) {\n                 Some(i) => { *slot = i; true },\n                 None => false\n             }\n         }\n \n-        fn parse_opt_uint(slot: &mut Option<uint>, v: Option<&str>) -> bool {\n+        fn parse_opt_uint(slot: &mut Option<usize>, v: Option<&str>) -> bool {\n             match v {\n                 Some(s) => { *slot = s.parse().ok(); slot.is_some() }\n                 None => { *slot = None; true }\n@@ -519,16 +519,16 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n          \"metadata to mangle symbol names with\"),\n     extra_filename: String = (\"\".to_string(), parse_string,\n          \"extra data to put in each output filename\"),\n-    codegen_units: uint = (1, parse_uint,\n+    codegen_units: usize = (1, parse_uint,\n         \"divide crate into N units to optimize in parallel\"),\n     remark: Passes = (SomePasses(Vec::new()), parse_passes,\n         \"print remarks for these optimization passes (space separated, or \\\"all\\\")\"),\n     no_stack_check: bool = (false, parse_bool,\n         \"disable checks for stack exhaustion (a memory-safety hazard!)\"),\n-    debuginfo: Option<uint> = (None, parse_opt_uint,\n+    debuginfo: Option<usize> = (None, parse_opt_uint,\n         \"debug info emission level, 0 = no debug info, 1 = line tables only, \\\n          2 = full debug info with variable and type information\"),\n-    opt_level: Option<uint> = (None, parse_opt_uint,\n+    opt_level: Option<usize> = (None, parse_opt_uint,\n         \"Optimize with possible levels 0-3\"),\n     debug_assertions: Option<bool> = (None, parse_opt_bool,\n         \"explicitly enable the cfg(debug_assertions) directive\"),"}, {"sha": "3e3e5e17963cd1ac294782be0b19838f2132c91c", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -58,7 +58,7 @@ pub struct Session {\n \n     /// The maximum recursion limit for potentially infinitely recursive\n     /// operations such as auto-dereference and monomorphization.\n-    pub recursion_limit: Cell<uint>,\n+    pub recursion_limit: Cell<usize>,\n \n     pub can_print_warnings: bool\n }\n@@ -106,7 +106,7 @@ impl Session {\n         }\n         self.diagnostic().handler().err(msg)\n     }\n-    pub fn err_count(&self) -> uint {\n+    pub fn err_count(&self) -> usize {\n         self.diagnostic().handler().err_count()\n     }\n     pub fn has_errors(&self) -> bool {"}, {"sha": "60ae053dbaf04eeabc5f1b6684bf6347a8768e6c", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -35,7 +35,7 @@ pub struct ErrorReported;\n pub fn time<T, U, F>(do_it: bool, what: &str, u: U, f: F) -> T where\n     F: FnOnce(U) -> T,\n {\n-    thread_local!(static DEPTH: Cell<uint> = Cell::new(0));\n+    thread_local!(static DEPTH: Cell<usize> = Cell::new(0));\n     if !do_it { return f(u); }\n \n     let old = DEPTH.with(|slot| {\n@@ -196,10 +196,10 @@ pub fn can_reach<T, S>(edges_map: &HashMap<T, Vec<T>, S>, source: T,\n /// # Examples\n /// ```\n /// struct Context {\n-///    cache: RefCell<HashMap<uint, uint>>\n+///    cache: RefCell<HashMap<usize, usize>>\n /// }\n ///\n-/// fn factorial(ctxt: &Context, n: uint) -> uint {\n+/// fn factorial(ctxt: &Context, n: usize) -> usize {\n ///     memoized(&ctxt.cache, n, |n| match n {\n ///         0 | 1 => n,\n ///         _ => factorial(ctxt, n - 2) + factorial(ctxt, n - 1)"}, {"sha": "28f8510ce3fee150100523f49c455f82e2c6e7c3", "filename": "src/librustc/util/lev_distance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Flev_distance.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -10,7 +10,7 @@\n \n use std::cmp;\n \n-pub fn lev_distance(me: &str, t: &str) -> uint {\n+pub fn lev_distance(me: &str, t: &str) -> usize {\n     if me.is_empty() { return t.chars().count(); }\n     if t.is_empty() { return me.chars().count(); }\n "}, {"sha": "d2e0b3aec2f40236d3ac6615a42b8f4629858486", "filename": "src/librustc/util/snapshot_vec.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -30,10 +30,10 @@ pub enum UndoLog<D:SnapshotVecDelegate> {\n     CommittedSnapshot,\n \n     /// New variable with given index was created.\n-    NewElem(uint),\n+    NewElem(usize),\n \n     /// Variable with given index was changed *from* the given value.\n-    SetElem(uint, D::Value),\n+    SetElem(usize, D::Value),\n \n     /// Extensible set of actions\n     Other(D::Undo)\n@@ -48,7 +48,7 @@ pub struct SnapshotVec<D:SnapshotVecDelegate> {\n // Snapshots are tokens that should be created/consumed linearly.\n pub struct Snapshot {\n     // Length of the undo log at the time the snapshot was taken.\n-    length: uint,\n+    length: usize,\n }\n \n pub trait SnapshotVecDelegate {\n@@ -77,7 +77,7 @@ impl<D:SnapshotVecDelegate> SnapshotVec<D> {\n         }\n     }\n \n-    pub fn push(&mut self, elem: D::Value) -> uint {\n+    pub fn push(&mut self, elem: D::Value) -> usize {\n         let len = self.values.len();\n         self.values.push(elem);\n \n@@ -88,20 +88,20 @@ impl<D:SnapshotVecDelegate> SnapshotVec<D> {\n         len\n     }\n \n-    pub fn get<'a>(&'a self, index: uint) -> &'a D::Value {\n+    pub fn get<'a>(&'a self, index: usize) -> &'a D::Value {\n         &self.values[index]\n     }\n \n     /// Returns a mutable pointer into the vec; whatever changes you make here cannot be undone\n     /// automatically, so you should be sure call `record()` with some sort of suitable undo\n     /// action.\n-    pub fn get_mut<'a>(&'a mut self, index: uint) -> &'a mut D::Value {\n+    pub fn get_mut<'a>(&'a mut self, index: usize) -> &'a mut D::Value {\n         &mut self.values[index]\n     }\n \n     /// Updates the element at the given index. The old value will saved (and perhaps restored) if\n     /// a snapshot is active.\n-    pub fn set(&mut self, index: uint, new_elem: D::Value) {\n+    pub fn set(&mut self, index: usize, new_elem: D::Value) {\n         let old_elem = mem::replace(&mut self.values[index], new_elem);\n         if self.in_snapshot() {\n             self.undo_log.push(SetElem(index, old_elem));"}, {"sha": "c3a3a8d582aff91f2fc400141e0b57d16d605234", "filename": "src/librustc_back/abi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_back%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_back%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fabi.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -8,17 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub const BOX_FIELD_DROP_GLUE: uint = 1;\n-pub const BOX_FIELD_BODY: uint = 4;\n+pub const BOX_FIELD_DROP_GLUE: usize = 1;\n+pub const BOX_FIELD_BODY: usize = 4;\n \n /// The first half of a fat pointer.\n /// - For a closure, this is the code address.\n /// - For an object or trait instance, this is the address of the box.\n /// - For a slice, this is the base address.\n-pub const FAT_PTR_ADDR: uint = 0;\n+pub const FAT_PTR_ADDR: usize = 0;\n \n /// The second half of a fat pointer.\n /// - For a closure, this is the address of the environment.\n /// - For an object or trait instance, this is the address of the vtable.\n /// - For a slice, this is the length.\n-pub const FAT_PTR_EXTRA: uint = 1;\n+pub const FAT_PTR_EXTRA: usize = 1;"}, {"sha": "9f5751c421ecebe39ad56cc1f866e2bd0a916b19", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -246,7 +246,7 @@ impl<'a> ArchiveBuilder<'a> {\n         // Don't allow the total size of `args` to grow beyond 32,000 bytes.\n         // Windows will raise an error if the argument string is longer than\n         // 32,768, and we leave a bit of extra space for the program name.\n-        const ARG_LENGTH_LIMIT: uint = 32_000;\n+        const ARG_LENGTH_LIMIT: usize = 32_000;\n \n         for member_name in &self.members {\n             let len = member_name.to_string_lossy().len();"}, {"sha": "fe457841e9116c81c5ea88b21240f13b9f3a6c45", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -36,7 +36,6 @@\n #![feature(collections)]\n #![feature(core)]\n #![feature(old_fs)]\n-#![feature(int_uint)]\n #![feature(io)]\n #![feature(old_io)]\n #![feature(old_path)]"}, {"sha": "c7049f750fcdb84d0d2b270dfbbe5de12d416939", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -90,29 +90,29 @@ trait FixedBuffer {\n \n     /// Zero the buffer up until the specified index. The buffer position currently must not be\n     /// greater than that index.\n-    fn zero_until(&mut self, idx: uint);\n+    fn zero_until(&mut self, idx: usize);\n \n     /// Get a slice of the buffer of the specified size. There must be at least that many bytes\n     /// remaining in the buffer.\n-    fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8];\n+    fn next<'s>(&'s mut self, len: usize) -> &'s mut [u8];\n \n     /// Get the current buffer. The buffer must already be full. This clears the buffer as well.\n     fn full_buffer<'s>(&'s mut self) -> &'s [u8];\n \n     /// Get the current position of the buffer.\n-    fn position(&self) -> uint;\n+    fn position(&self) -> usize;\n \n     /// Get the number of bytes remaining in the buffer until it is full.\n-    fn remaining(&self) -> uint;\n+    fn remaining(&self) -> usize;\n \n     /// Get the size of the buffer\n-    fn size(&self) -> uint;\n+    fn size(&self) -> usize;\n }\n \n /// A FixedBuffer of 64 bytes useful for implementing Sha256 which has a 64 byte blocksize.\n struct FixedBuffer64 {\n     buffer: [u8; 64],\n-    buffer_idx: uint,\n+    buffer_idx: usize,\n }\n \n impl FixedBuffer64 {\n@@ -174,13 +174,13 @@ impl FixedBuffer for FixedBuffer64 {\n         self.buffer_idx = 0;\n     }\n \n-    fn zero_until(&mut self, idx: uint) {\n+    fn zero_until(&mut self, idx: usize) {\n         assert!(idx >= self.buffer_idx);\n         self.buffer[self.buffer_idx..idx].set_memory(0);\n         self.buffer_idx = idx;\n     }\n \n-    fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8] {\n+    fn next<'s>(&'s mut self, len: usize) -> &'s mut [u8] {\n         self.buffer_idx += len;\n         return &mut self.buffer[self.buffer_idx - len..self.buffer_idx];\n     }\n@@ -191,11 +191,11 @@ impl FixedBuffer for FixedBuffer64 {\n         return &self.buffer[..64];\n     }\n \n-    fn position(&self) -> uint { self.buffer_idx }\n+    fn position(&self) -> usize { self.buffer_idx }\n \n-    fn remaining(&self) -> uint { 64 - self.buffer_idx }\n+    fn remaining(&self) -> usize { 64 - self.buffer_idx }\n \n-    fn size(&self) -> uint { 64 }\n+    fn size(&self) -> usize { 64 }\n }\n \n /// The StandardPadding trait adds a method useful for Sha256 to a FixedBuffer struct.\n@@ -204,11 +204,11 @@ trait StandardPadding {\n     /// guaranteed to have exactly rem remaining bytes when it returns. If there are not at least\n     /// rem bytes available, the buffer will be zero padded, processed, cleared, and then filled\n     /// with zeros again until only rem bytes are remaining.\n-    fn standard_padding<F>(&mut self, rem: uint, func: F) where F: FnMut(&[u8]);\n+    fn standard_padding<F>(&mut self, rem: usize, func: F) where F: FnMut(&[u8]);\n }\n \n impl <T: FixedBuffer> StandardPadding for T {\n-    fn standard_padding<F>(&mut self, rem: uint, mut func: F) where F: FnMut(&[u8]) {\n+    fn standard_padding<F>(&mut self, rem: usize, mut func: F) where F: FnMut(&[u8]) {\n         let size = self.size();\n \n         self.next(1)[0] = 128;\n@@ -244,7 +244,7 @@ pub trait Digest {\n     fn reset(&mut self);\n \n     /// Get the output size in bits.\n-    fn output_bits(&self) -> uint;\n+    fn output_bits(&self) -> usize;\n \n     /// Convenience function that feeds a string into a digest.\n     ///\n@@ -514,7 +514,7 @@ impl Digest for Sha256 {\n         self.engine.reset(&H256);\n     }\n \n-    fn output_bits(&self) -> uint { 256 }\n+    fn output_bits(&self) -> usize { 256 }\n }\n \n static H256: [u32; 8] = [\n@@ -613,7 +613,7 @@ mod tests {\n \n     /// Feed 1,000,000 'a's into the digest with varying input sizes and check that the result is\n     /// correct.\n-    fn test_digest_1million_random<D: Digest>(digest: &mut D, blocksize: uint, expected: &str) {\n+    fn test_digest_1million_random<D: Digest>(digest: &mut D, blocksize: usize, expected: &str) {\n         let total_size = 1000000;\n         let buffer: Vec<u8> = repeat('a' as u8).take(blocksize * 2).collect();\n         let mut rng = IsaacRng::new_unseeded();\n@@ -622,7 +622,7 @@ mod tests {\n         digest.reset();\n \n         while count < total_size {\n-            let next: uint = rng.gen_range(0, 2 * blocksize + 1);\n+            let next: usize = rng.gen_range(0, 2 * blocksize + 1);\n             let remaining = total_size - count;\n             let size = if next > remaining { remaining } else { next };\n             digest.input(&buffer[..size]);"}, {"sha": "f9416d53a8fa3a51dcf74ab662d2393d152ab8d3", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -221,7 +221,7 @@ mod svh_visitor {\n \n         SawExprLoop(Option<token::InternedString>),\n         SawExprField(token::InternedString),\n-        SawExprTupField(uint),\n+        SawExprTupField(usize),\n         SawExprBreak(Option<token::InternedString>),\n         SawExprAgain(Option<token::InternedString>),\n "}, {"sha": "d4503ae7fc9872e3309111bb953f80a9324e9ca2", "filename": "src/librustc_back/tempdir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_back%2Ftempdir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_back%2Ftempdir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftempdir.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -27,7 +27,7 @@ const NUM_RETRIES: u32 = 1 << 31;\n // be enough to dissuade an attacker from trying to preemptively create names\n // of that length, but not so huge that we unnecessarily drain the random number\n // generator of entropy.\n-const NUM_RAND_CHARS: uint = 12;\n+const NUM_RAND_CHARS: usize = 12;\n \n impl TempDir {\n     /// Attempts to make a temporary directory inside of `tmpdir` whose name"}, {"sha": "f268a957fe84c80834456cf16c1ee208cbd5acd4", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -335,7 +335,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         return true;\n     }\n \n-    pub fn loans_generated_by(&self, scope: region::CodeExtent) -> Vec<uint> {\n+    pub fn loans_generated_by(&self, scope: region::CodeExtent) -> Vec<usize> {\n         //! Returns a vector of the loans that are generated as\n         //! we enter `scope`.\n \n@@ -727,7 +727,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     /// let a: int;\n     /// a = 10; // ok, even though a is uninitialized\n     ///\n-    /// struct Point { x: uint, y: uint }\n+    /// struct Point { x: usize, y: usize }\n     /// let p: Point;\n     /// p.x = 22; // ok, even though `p` is uninitialized\n     ///"}, {"sha": "b5ceff6124d995f80011b3fea3825693737f4011", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -88,7 +88,7 @@ pub fn check_crate(tcx: &ty::ctxt) {\n                  make_stat(&bccx, bccx.stats.stable_paths));\n     }\n \n-    fn make_stat(bccx: &BorrowckCtxt, stat: uint) -> String {\n+    fn make_stat(bccx: &BorrowckCtxt, stat: usize) -> String {\n         let total = bccx.stats.guaranteed_paths as f64;\n         let perc = if total == 0.0 { 0.0 } else { stat as f64 * 100.0 / total };\n         format!(\"{} ({:.0}%)\", stat, perc)\n@@ -238,10 +238,10 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n }\n \n struct BorrowStats {\n-    loaned_paths_same: uint,\n-    loaned_paths_imm: uint,\n-    stable_paths: uint,\n-    guaranteed_paths: uint\n+    loaned_paths_same: usize,\n+    loaned_paths_imm: usize,\n+    stable_paths: usize,\n+    guaranteed_paths: usize\n }\n \n pub type BckResult<'tcx, T> = Result<T, BckError<'tcx>>;\n@@ -251,7 +251,7 @@ pub type BckResult<'tcx, T> = Result<T, BckError<'tcx>>;\n \n /// Record of a loan that was issued.\n pub struct Loan<'tcx> {\n-    index: uint,\n+    index: usize,\n     loan_path: Rc<LoanPath<'tcx>>,\n     kind: ty::BorrowKind,\n     restricted_paths: Vec<Rc<LoanPath<'tcx>>>,\n@@ -382,7 +382,7 @@ impl<'tcx> LoanPath<'tcx> {\n         }\n     }\n \n-    fn depth(&self) -> uint {\n+    fn depth(&self) -> usize {\n         match self.kind {\n             LpExtend(ref base, _, LpDeref(_)) => base.depth(),\n             LpExtend(ref base, _, LpInterior(_)) => base.depth() + 1,\n@@ -1043,7 +1043,7 @@ fn is_statement_scope(tcx: &ty::ctxt, region: ty::Region) -> bool {\n \n impl BitwiseOperator for LoanDataFlowOperator {\n     #[inline]\n-    fn join(&self, succ: uint, pred: uint) -> uint {\n+    fn join(&self, succ: usize, pred: usize) -> usize {\n         succ | pred // loans from both preds are in scope\n     }\n }"}, {"sha": "a4470acbe4d20dc8f043943759a32982c7a4ba6b", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -76,10 +76,10 @@ pub struct FlowedMoveData<'a, 'tcx: 'a> {\n \n /// Index into `MoveData.paths`, used like a pointer\n #[derive(Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n-pub struct MovePathIndex(uint);\n+pub struct MovePathIndex(usize);\n \n impl MovePathIndex {\n-    fn get(&self) -> uint {\n+    fn get(&self) -> usize {\n         let MovePathIndex(v) = *self; v\n     }\n }\n@@ -95,10 +95,10 @@ const InvalidMovePathIndex: MovePathIndex = MovePathIndex(usize::MAX);\n \n /// Index into `MoveData.moves`, used like a pointer\n #[derive(Copy, PartialEq)]\n-pub struct MoveIndex(uint);\n+pub struct MoveIndex(usize);\n \n impl MoveIndex {\n-    fn get(&self) -> uint {\n+    fn get(&self) -> usize {\n         let MoveIndex(v) = *self; v\n     }\n }\n@@ -740,7 +740,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n \n impl BitwiseOperator for MoveDataFlowOperator {\n     #[inline]\n-    fn join(&self, succ: uint, pred: uint) -> uint {\n+    fn join(&self, succ: usize, pred: usize) -> usize {\n         succ | pred // moves from both preds are in scope\n     }\n }\n@@ -754,7 +754,7 @@ impl DataFlowOperator for MoveDataFlowOperator {\n \n impl BitwiseOperator for AssignDataFlowOperator {\n     #[inline]\n-    fn join(&self, succ: uint, pred: uint) -> uint {\n+    fn join(&self, succ: usize, pred: usize) -> usize {\n         succ | pred // moves from both preds are in scope\n     }\n }"}, {"sha": "624a95c2906e139182f91802a44f29a6c3ce634a", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -79,7 +79,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n                                         cfgidx: CFGIndex,\n                                         dfcx: &DataFlowContext<'a, 'tcx, O>,\n                                         mut to_lp: F) -> String where\n-        F: FnMut(uint) -> Rc<LoanPath<'tcx>>,\n+        F: FnMut(usize) -> Rc<LoanPath<'tcx>>,\n     {\n         let mut saw_some = false;\n         let mut set = \"{\".to_string();"}, {"sha": "fbbd20d6dc7fdf5ea6b1e198966262679583844d", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -22,7 +22,6 @@\n #![allow(non_camel_case_types)]\n \n #![feature(core)]\n-#![feature(int_uint)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]"}, {"sha": "756a575523fe7c6de4e2e2d5fb320fa3398bdd7a", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -28,7 +28,6 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(int_uint)]\n #![feature(libc)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n@@ -101,7 +100,7 @@ const BUG_REPORT_URL: &'static str =\n     \"https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\";\n \n \n-pub fn run(args: Vec<String>) -> int {\n+pub fn run(args: Vec<String>) -> isize {\n     monitor(move || run_compiler(&args, &mut RustcDefaultCalls));\n     0\n }\n@@ -795,7 +794,7 @@ fn parse_crate_attrs(sess: &Session, input: &Input) ->\n /// errors of the compiler.\n #[allow(deprecated)]\n pub fn monitor<F:FnOnce()+Send+'static>(f: F) {\n-    const STACK_SIZE: uint = 8 * 1024 * 1024; // 8MB\n+    const STACK_SIZE: usize = 8 * 1024 * 1024; // 8MB\n \n     struct Sink(Arc<Mutex<Vec<u8>>>);\n     impl Write for Sink {"}, {"sha": "fcb0b9bdd3cfb05db2e0d6fefd0e54ae999227e3", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -88,13 +88,13 @@ impl Emitter for ExpectErrorEmitter {\n     }\n }\n \n-fn errors(msgs: &[&str]) -> (Box<Emitter+Send>, uint) {\n+fn errors(msgs: &[&str]) -> (Box<Emitter+Send>, usize) {\n     let v = msgs.iter().map(|m| m.to_string()).collect();\n     (box ExpectErrorEmitter { messages: v } as Box<Emitter+Send>, msgs.len())\n }\n \n fn test_env<F>(source_string: &str,\n-               (emitter, expected_err_count): (Box<Emitter+Send>, uint),\n+               (emitter, expected_err_count): (Box<Emitter+Send>, usize),\n                body: F) where\n     F: FnOnce(Env),\n {\n@@ -178,7 +178,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n         fn search_mod(this: &Env,\n                       m: &ast::Mod,\n-                      idx: uint,\n+                      idx: usize,\n                       names: &[String])\n                       -> Option<ast::NodeId> {\n             assert!(idx < names.len());\n@@ -192,7 +192,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n         fn search(this: &Env,\n                   it: &ast::Item,\n-                  idx: uint,\n+                  idx: usize,\n                   names: &[String])\n                   -> Option<ast::NodeId> {\n             if idx == names.len() {\n@@ -300,14 +300,14 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     pub fn t_rptr(&self, r: ty::Region) -> Ty<'tcx> {\n         ty::mk_imm_rptr(self.infcx.tcx,\n                         self.infcx.tcx.mk_region(r),\n-                        self.tcx().types.int)\n+                        self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_late_bound(&self, id: u32) -> Ty<'tcx> {\n         let r = self.re_late_bound_with_debruijn(id, ty::DebruijnIndex::new(1));\n         ty::mk_imm_rptr(self.infcx.tcx,\n                         self.infcx.tcx.mk_region(r),\n-                        self.tcx().types.int)\n+                        self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_late_bound_with_debruijn(&self,\n@@ -317,13 +317,13 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         let r = self.re_late_bound_with_debruijn(id, debruijn);\n         ty::mk_imm_rptr(self.infcx.tcx,\n                         self.infcx.tcx.mk_region(r),\n-                        self.tcx().types.int)\n+                        self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_scope(&self, id: ast::NodeId) -> Ty<'tcx> {\n         let r = ty::ReScope(CodeExtent::from_node_id(id));\n         ty::mk_imm_rptr(self.infcx.tcx, self.infcx.tcx.mk_region(r),\n-                        self.tcx().types.int)\n+                        self.tcx().types.isize)\n     }\n \n     pub fn re_free(&self, nid: ast::NodeId, id: u32) -> ty::Region {\n@@ -335,13 +335,13 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         let r = self.re_free(nid, id);\n         ty::mk_imm_rptr(self.infcx.tcx,\n                         self.infcx.tcx.mk_region(r),\n-                        self.tcx().types.int)\n+                        self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_static(&self) -> Ty<'tcx> {\n         ty::mk_imm_rptr(self.infcx.tcx,\n                         self.infcx.tcx.mk_region(ty::ReStatic),\n-                        self.tcx().types.int)\n+                        self.tcx().types.isize)\n     }\n \n     pub fn dummy_type_trace(&self) -> infer::TypeTrace<'tcx> {\n@@ -464,67 +464,67 @@ fn contravariant_region_ptr_err() {\n fn sub_free_bound_false() {\n     //! Test that:\n     //!\n-    //!     fn(&'a int) <: for<'b> fn(&'b int)\n+    //!     fn(&'a isize) <: for<'b> fn(&'b isize)\n     //!\n     //! does NOT hold.\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        env.check_not_sub(env.t_fn(&[t_rptr_free1], env.tcx().types.int),\n-                          env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n+        env.check_not_sub(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n+                          env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n     })\n }\n \n #[test]\n fn sub_bound_free_true() {\n     //! Test that:\n     //!\n-    //!     for<'a> fn(&'a int) <: fn(&'b int)\n+    //!     for<'a> fn(&'a isize) <: fn(&'b isize)\n     //!\n     //! DOES hold.\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        env.check_sub(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_free1], env.tcx().types.int));\n+        env.check_sub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n     })\n }\n \n #[test]\n fn sub_free_bound_false_infer() {\n     //! Test that:\n     //!\n-    //!     fn(_#1) <: for<'b> fn(&'b int)\n+    //!     fn(_#1) <: for<'b> fn(&'b isize)\n     //!\n     //! does NOT hold for any instantiation of `_#1`.\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_infer1 = env.infcx.next_ty_var();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        env.check_not_sub(env.t_fn(&[t_infer1], env.tcx().types.int),\n-                          env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n+        env.check_not_sub(env.t_fn(&[t_infer1], env.tcx().types.isize),\n+                          env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n     })\n }\n \n #[test]\n fn lub_free_bound_infer() {\n     //! Test result of:\n     //!\n-    //!     LUB(fn(_#1), for<'b> fn(&'b int))\n+    //!     LUB(fn(_#1), for<'b> fn(&'b isize))\n     //!\n-    //! This should yield `fn(&'_ int)`. We check\n-    //! that it yields `fn(&'x int)` for some free `'x`,\n+    //! This should yield `fn(&'_ isize)`. We check\n+    //! that it yields `fn(&'x isize)` for some free `'x`,\n     //! anyhow.\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_infer1 = env.infcx.next_ty_var();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        env.check_lub(env.t_fn(&[t_infer1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_free1], env.tcx().types.int));\n+        env.check_lub(env.t_fn(&[t_infer1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n     });\n }\n \n@@ -533,9 +533,9 @@ fn lub_bound_bound() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_bound2 = env.t_rptr_late_bound(2);\n-        env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_bound2], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n+        env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_bound2], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n     })\n }\n \n@@ -544,9 +544,9 @@ fn lub_bound_free() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_free1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_free1], env.tcx().types.int));\n+        env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n     })\n }\n \n@@ -555,9 +555,9 @@ fn lub_bound_static() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_static = env.t_rptr_static();\n-        env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_static], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_static], env.tcx().types.int));\n+        env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_static], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_static], env.tcx().types.isize));\n     })\n }\n \n@@ -578,9 +578,9 @@ fn lub_free_free() {\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n         let t_rptr_free2 = env.t_rptr_free(0, 2);\n         let t_rptr_static = env.t_rptr_static();\n-        env.check_lub(env.t_fn(&[t_rptr_free1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_free2], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_static], env.tcx().types.int));\n+        env.check_lub(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_free2], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_static], env.tcx().types.isize));\n     })\n }\n \n@@ -603,9 +603,9 @@ fn glb_free_free_with_common_scope() {\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n         let t_rptr_free2 = env.t_rptr_free(0, 2);\n         let t_rptr_scope = env.t_rptr_scope(0);\n-        env.check_glb(env.t_fn(&[t_rptr_free1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_free2], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_scope], env.tcx().types.int));\n+        env.check_glb(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_free2], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_scope], env.tcx().types.isize));\n     })\n }\n \n@@ -614,9 +614,9 @@ fn glb_bound_bound() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_bound2 = env.t_rptr_late_bound(2);\n-        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_bound2], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n+        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_bound2], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n     })\n }\n \n@@ -625,9 +625,9 @@ fn glb_bound_free() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_free1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n+        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n     })\n }\n \n@@ -637,14 +637,14 @@ fn glb_bound_free_infer() {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_infer1 = env.infcx.next_ty_var();\n \n-        // compute GLB(fn(_) -> int, for<'b> fn(&'b int) -> int),\n-        // which should yield for<'b> fn(&'b int) -> int\n-        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n-                      env.t_fn(&[t_infer1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n+        // compute GLB(fn(_) -> isize, for<'b> fn(&'b isize) -> isize),\n+        // which should yield for<'b> fn(&'b isize) -> isize\n+        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+                      env.t_fn(&[t_infer1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n \n         // as a side-effect, computing GLB should unify `_` with\n-        // `&'_ int`\n+        // `&'_ isize`\n         let t_resolve1 = env.infcx.shallow_resolve(t_infer1);\n         match t_resolve1.sty {\n             ty::ty_rptr(..) => { }\n@@ -658,9 +658,9 @@ fn glb_bound_static() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_static = env.t_rptr_static();\n-        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_static], env.tcx().types.int),\n-                      env.t_fn(&[t_rptr_bound1], env.tcx().types.int));\n+        env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_static], env.tcx().types.isize),\n+                      env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n     })\n }\n \n@@ -684,7 +684,7 @@ fn subst_ty_renumber_bound() {\n         let substs = subst::Substs::new_type(vec![t_rptr_bound1], vec![]);\n         let t_substituted = t_source.subst(env.infcx.tcx, &substs);\n \n-        // t_expected = fn(&'a int)\n+        // t_expected = fn(&'a isize)\n         let t_expected = {\n             let t_ptr_bound2 = env.t_rptr_late_bound_with_debruijn(1, ty::DebruijnIndex::new(2));\n             env.t_fn(&[t_ptr_bound2], env.t_nil())\n@@ -719,7 +719,7 @@ fn subst_ty_renumber_some_bounds() {\n         let substs = subst::Substs::new_type(vec![t_rptr_bound1], vec![]);\n         let t_substituted = t_source.subst(env.infcx.tcx, &substs);\n \n-        // t_expected = (&'a int, fn(&'a int))\n+        // t_expected = (&'a isize, fn(&'a isize))\n         //\n         // but not that the Debruijn index is different in the different cases.\n         let t_expected = {\n@@ -771,7 +771,7 @@ fn subst_region_renumber_region() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let re_bound1 = env.re_late_bound_with_debruijn(1, ty::DebruijnIndex::new(1));\n \n-        // type t_source<'a> = fn(&'a int)\n+        // type t_source<'a> = fn(&'a isize)\n         let t_source = {\n             let re_early = env.re_early_bound(subst::TypeSpace, 0, \"'a\");\n             env.t_fn(&[env.t_rptr(re_early)], env.t_nil())\n@@ -780,7 +780,7 @@ fn subst_region_renumber_region() {\n         let substs = subst::Substs::new_type(vec![], vec![re_bound1]);\n         let t_substituted = t_source.subst(env.infcx.tcx, &substs);\n \n-        // t_expected = fn(&'a int)\n+        // t_expected = fn(&'a isize)\n         //\n         // but not that the Debruijn index is different in the different cases.\n         let t_expected = {\n@@ -802,8 +802,8 @@ fn subst_region_renumber_region() {\n fn walk_ty() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let tcx = env.infcx.tcx;\n-        let int_ty = tcx.types.int;\n-        let uint_ty = tcx.types.uint;\n+        let int_ty = tcx.types.isize;\n+        let uint_ty = tcx.types.usize;\n         let tup1_ty = ty::mk_tup(tcx, vec!(int_ty, uint_ty, int_ty, uint_ty));\n         let tup2_ty = ty::mk_tup(tcx, vec!(tup1_ty, tup1_ty, uint_ty));\n         let uniq_ty = ty::mk_uniq(tcx, tup2_ty);\n@@ -821,8 +821,8 @@ fn walk_ty() {\n fn walk_ty_skip_subtree() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let tcx = env.infcx.tcx;\n-        let int_ty = tcx.types.int;\n-        let uint_ty = tcx.types.uint;\n+        let int_ty = tcx.types.isize;\n+        let uint_ty = tcx.types.usize;\n         let tup1_ty = ty::mk_tup(tcx, vec!(int_ty, uint_ty, int_ty, uint_ty));\n         let tup2_ty = ty::mk_tup(tcx, vec!(tup1_ty, tup1_ty, uint_ty));\n         let uniq_ty = ty::mk_uniq(tcx, tup2_ty);\n@@ -836,7 +836,7 @@ fn walk_ty_skip_subtree() {\n                                 (uint_ty, false),\n                                 (int_ty, false),\n                                 (uint_ty, false),\n-                                (tup1_ty, true), // skip the int/uint/int/uint\n+                                (tup1_ty, true), // skip the isize/usize/isize/usize\n                                 (uint_ty, false));\n         expected.reverse();\n "}, {"sha": "5a3d7c728e0735326d75beb05a42918c207b7d5b", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -180,7 +180,7 @@ impl LintPass for TypeLimits {\n                             if let ast::LitInt(shift, _) = lit.node { shift >= bits }\n                             else { false }\n                         } else {\n-                            match eval_const_expr_partial(cx.tcx, &**r, Some(cx.tcx.types.uint)) {\n+                            match eval_const_expr_partial(cx.tcx, &**r, Some(cx.tcx.types.usize)) {\n                                 Ok(const_int(shift)) => { shift as u64 >= bits },\n                                 Ok(const_uint(shift)) => { shift >= bits },\n                                 _ => { false }"}, {"sha": "34f7436d0cd5d8d7cc5ccc9be4e2b88664b1183e", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -34,7 +34,6 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(int_uint)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]"}, {"sha": "cc6a85e86ce077646aa5ee75b4c0c0cb0899cd94", "filename": "src/librustc_llvm/archive_ro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_llvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_llvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Farchive_ro.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -61,7 +61,7 @@ impl ArchiveRO {\n             if ptr.is_null() {\n                 None\n             } else {\n-                Some(slice::from_raw_parts(ptr as *const u8, size as uint))\n+                Some(slice::from_raw_parts(ptr as *const u8, size as usize))\n             }\n         }\n     }"}, {"sha": "60755093516c6c048b8a36b8f4b279665744b140", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -28,7 +28,6 @@\n \n #![feature(box_syntax)]\n #![feature(collections)]\n-#![feature(int_uint)]\n #![feature(libc)]\n #![feature(link_args)]\n #![feature(staged_api)]\n@@ -77,7 +76,7 @@ pub type Bool = c_uint;\n pub const True: Bool = 1 as Bool;\n pub const False: Bool = 0 as Bool;\n \n-// Consts for the LLVM CallConv type, pre-cast to uint.\n+// Consts for the LLVM CallConv type, pre-cast to usize.\n \n #[derive(Copy, PartialEq)]\n pub enum CallConv {\n@@ -242,7 +241,7 @@ impl AttrHelper for SpecialAttribute {\n }\n \n pub struct AttrBuilder {\n-    attrs: Vec<(uint, Box<AttrHelper+'static>)>\n+    attrs: Vec<(usize, Box<AttrHelper+'static>)>\n }\n \n impl AttrBuilder {\n@@ -252,13 +251,13 @@ impl AttrBuilder {\n         }\n     }\n \n-    pub fn arg<'a, T: AttrHelper + 'static>(&'a mut self, idx: uint, a: T) -> &'a mut AttrBuilder {\n+    pub fn arg<'a, T: AttrHelper + 'static>(&'a mut self, idx: usize, a: T) -> &'a mut AttrBuilder {\n         self.attrs.push((idx, box a as Box<AttrHelper+'static>));\n         self\n     }\n \n     pub fn ret<'a, T: AttrHelper + 'static>(&'a mut self, a: T) -> &'a mut AttrBuilder {\n-        self.attrs.push((ReturnIndex as uint, box a as Box<AttrHelper+'static>));\n+        self.attrs.push((ReturnIndex as usize, box a as Box<AttrHelper+'static>));\n         self\n     }\n \n@@ -693,7 +692,7 @@ extern {\n                          -> ValueRef;\n     pub fn LLVMConstFCmp(Pred: c_ushort, V1: ValueRef, V2: ValueRef)\n                          -> ValueRef;\n-    /* only for int/vector */\n+    /* only for isize/vector */\n     pub fn LLVMGetUndef(Ty: TypeRef) -> ValueRef;\n     pub fn LLVMIsConstant(Val: ValueRef) -> Bool;\n     pub fn LLVMIsNull(Val: ValueRef) -> Bool;\n@@ -2167,7 +2166,7 @@ impl ObjectFile {\n     pub fn new(llmb: MemoryBufferRef) -> Option<ObjectFile> {\n         unsafe {\n             let llof = LLVMCreateObjectFile(llmb);\n-            if llof as int == 0 {\n+            if llof as isize == 0 {\n                 // LLVMCreateObjectFile took ownership of llmb\n                 return None\n             }\n@@ -2227,7 +2226,7 @@ type RustStringRepr = *mut RefCell<Vec<u8>>;\n pub unsafe extern \"C\" fn rust_llvm_string_write_impl(sr: RustStringRef,\n                                                      ptr: *const c_char,\n                                                      size: size_t) {\n-    let slice = slice::from_raw_parts(ptr as *const u8, size as uint);\n+    let slice = slice::from_raw_parts(ptr as *const u8, size as usize);\n \n     let sr: RustStringRepr = mem::transmute(sr);\n     (*sr).borrow_mut().push_all(slice);"}, {"sha": "9b1b57e7bbe282b702352e50c11fbc85fbf5a287", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -19,7 +19,6 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n-#![feature(int_uint)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n@@ -378,7 +377,7 @@ enum PrivacyResult {\n }\n \n enum FieldName {\n-    UnnamedField(uint), // index\n+    UnnamedField(usize), // index\n     // (Name, not Ident, because struct fields are not macro-hygienic)\n     NamedField(ast::Name),\n }"}, {"sha": "0f8f309131995cea605962dafa64fa6fdfe78354", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -22,7 +22,6 @@\n #![feature(alloc)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(int_uint)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n@@ -327,7 +326,7 @@ enum UseLexicalScopeFlag {\n \n enum ModulePrefixResult {\n     NoPrefixFound,\n-    PrefixFound(Rc<Module>, uint)\n+    PrefixFound(Rc<Module>, usize)\n }\n \n #[derive(Copy, PartialEq)]\n@@ -415,10 +414,10 @@ pub struct Module {\n     import_resolutions: RefCell<HashMap<Name, ImportResolution>>,\n \n     // The number of unresolved globs that this module exports.\n-    glob_count: Cell<uint>,\n+    glob_count: Cell<usize>,\n \n     // The index of the import we're resolving.\n-    resolved_import_count: Cell<uint>,\n+    resolved_import_count: Cell<usize>,\n \n     // Whether this module is populated. If not populated, any attempt to\n     // access the children must be preceded with a\n@@ -777,7 +776,7 @@ pub struct Resolver<'a, 'tcx:'a> {\n     structs: FnvHashMap<DefId, Vec<Name>>,\n \n     // The number of imports that are currently unresolved.\n-    unresolved_imports: uint,\n+    unresolved_imports: usize,\n \n     // The module that represents the current item scope.\n     current_module: Rc<Module>,\n@@ -959,7 +958,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     fn resolve_module_path_from_root(&mut self,\n                                      module_: Rc<Module>,\n                                      module_path: &[Name],\n-                                     index: uint,\n+                                     index: usize,\n                                      span: Span,\n                                      name_search_type: NameSearchType,\n                                      lp: LastPrivate)\n@@ -3053,12 +3052,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         NoSuggestion\n     }\n \n-    fn find_best_match_for_name(&mut self, name: &str, max_distance: uint)\n+    fn find_best_match_for_name(&mut self, name: &str, max_distance: usize)\n                                 -> Option<String> {\n         let this = &mut *self;\n \n         let mut maybes: Vec<token::InternedString> = Vec::new();\n-        let mut values: Vec<uint> = Vec::new();\n+        let mut values: Vec<usize> = Vec::new();\n \n         for rib in this.value_ribs.iter().rev() {\n             for (&k, _) in &rib.bindings {"}, {"sha": "b2004c89ed2d8d0001a4da9ca5dc13581910ce3f", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -115,7 +115,7 @@ pub struct ImportResolution {\n     // Note that this is usually either 0 or 1 - shadowing is forbidden the only\n     // way outstanding_references is > 1 in a legal program is if the name is\n     // used in both namespaces.\n-    pub outstanding_references: uint,\n+    pub outstanding_references: usize,\n \n     /// The value that this `use` directive names, if there is one.\n     pub value_target: Option<Target>,"}, {"sha": "5e85209fe1ae55a71fefdfc9132ae42819f656f3", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -60,16 +60,16 @@ pub const RLIB_BYTECODE_OBJECT_MAGIC: &'static [u8] = b\"RUST_OBJECT\";\n pub const RLIB_BYTECODE_OBJECT_VERSION: u32 = 1;\n \n // The offset in bytes the bytecode object format version number can be found at\n-pub const RLIB_BYTECODE_OBJECT_VERSION_OFFSET: uint = 11;\n+pub const RLIB_BYTECODE_OBJECT_VERSION_OFFSET: usize = 11;\n \n // The offset in bytes the size of the compressed bytecode can be found at in\n // format version 1\n-pub const RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET: uint =\n+pub const RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET: usize =\n     RLIB_BYTECODE_OBJECT_VERSION_OFFSET + 4;\n \n // The offset in bytes the compressed LLVM bytecode can be found at in format\n // version 1\n-pub const RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET: uint =\n+pub const RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET: usize =\n     RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET + 8;\n \n \n@@ -323,7 +323,7 @@ pub fn mangle_exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, path: PathEl\n         \"abcdefghijklmnopqrstuvwxyz\\\n          ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n          0123456789\";\n-    let id = id as uint;\n+    let id = id as usize;\n     let extra1 = id % EXTRA_CHARS.len();\n     let id = id / EXTRA_CHARS.len();\n     let extra2 = id % EXTRA_CHARS.len();\n@@ -695,7 +695,7 @@ fn write_rlib_bytecode_object_v1(writer: &mut Write,\n         RLIB_BYTECODE_OBJECT_MAGIC.len() +                // magic id\n         mem::size_of_val(&RLIB_BYTECODE_OBJECT_VERSION) + // version\n         mem::size_of_val(&bc_data_deflated_size) +        // data size field\n-        bc_data_deflated_size as uint;                    // actual data\n+        bc_data_deflated_size as usize;                    // actual data\n \n     // If the number of bytes written to the object so far is odd, add a\n     // padding byte to make it even. This works around a crash bug in LLDB\n@@ -1154,7 +1154,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n         // We may not pass all crates through to the linker. Some crates may\n         // appear statically in an existing dylib, meaning we'll pick up all the\n         // symbols from the dylib.\n-        let kind = match data[cnum as uint - 1] {\n+        let kind = match data[cnum as usize - 1] {\n             Some(t) => t,\n             None => continue\n         };"}, {"sha": "056550f6635da306015955e60fe9a8f94f84e4d0", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -92,7 +92,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                         let data_size = extract_compressed_bytecode_size_v1(bc_encoded);\n                         let compressed_data = &bc_encoded[\n                             link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET..\n-                            (link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint)];\n+                            (link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as usize)];\n \n                         match flate::inflate_bytes(compressed_data) {\n                             Ok(inflated) => inflated,\n@@ -204,7 +204,7 @@ fn extract_compressed_bytecode_size_v1(bc: &[u8]) -> u64 {\n     return read_from_le_bytes::<u64>(bc, link::RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET);\n }\n \n-fn read_from_le_bytes<T: Int>(bytes: &[u8], position_in_bytes: uint) -> T {\n+fn read_from_le_bytes<T: Int>(bytes: &[u8], position_in_bytes: usize) -> T {\n     let byte_data = &bytes[position_in_bytes..position_in_bytes + mem::size_of::<T>()];\n     let data = unsafe {\n         *(byte_data.as_ptr() as *const T)"}, {"sha": "cc588a365f6e68c5ab2ca3d950f1787d5eee82e6", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -898,7 +898,7 @@ fn run_work_singlethreaded(sess: &Session,\n \n fn run_work_multithreaded(sess: &Session,\n                           work_items: Vec<WorkItem>,\n-                          num_workers: uint) {\n+                          num_workers: usize) {\n     // Run some workers to process the work items.\n     let work_items_arc = Arc::new(Mutex::new(work_items));\n     let mut diag_emitter = SharedEmitter::new();"}, {"sha": "8cb4f886b2d5de928a76e60e2a57f433d8668732", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -30,7 +30,6 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(int_uint)]\n #![feature(libc)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "a415875d852cc8bb8a94ae4d0fba41156c674f75", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -465,7 +465,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         // However full span is the entire enum/fn/struct block, so we only want\n         // the first few to match the number of generics we're looking for.\n         let param_sub_spans = self.span.spans_for_ty_params(full_span,\n-                                                           (generics.ty_params.len() as int));\n+                                                           (generics.ty_params.len() as isize));\n         for (param, param_ss) in generics.ty_params.iter().zip(param_sub_spans.iter()) {\n             // Append $id to name to make sure each one is unique\n             let name = format!(\"{}::{}${}\","}, {"sha": "84a7678959d3efdcb792489e81aff6e98f913441", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -24,7 +24,7 @@ use syntax::parse::token::{keywords, Token};\n #[derive(Clone)]\n pub struct SpanUtils<'a> {\n     pub sess: &'a Session,\n-    pub err_count: Cell<int>,\n+    pub err_count: Cell<isize>,\n }\n \n impl<'a> SpanUtils<'a> {\n@@ -232,7 +232,7 @@ impl<'a> SpanUtils<'a> {\n     // example with Foo<Bar<T,V>, Bar<T,V>>\n     // Nesting = 0: all idents outside of brackets: ~[Foo]\n     // Nesting = 1: idents within one level of brackets: ~[Bar, Bar]\n-    pub fn spans_with_brackets(&self, span: Span, nesting: int, limit: int) -> Vec<Span> {\n+    pub fn spans_with_brackets(&self, span: Span, nesting: isize, limit: isize) -> Vec<Span> {\n         let mut result: Vec<Span> = vec!();\n \n         let mut toks = self.retokenise_span(span);\n@@ -250,7 +250,7 @@ impl<'a> SpanUtils<'a> {\n                 }\n                 return result\n             }\n-            if (result.len() as int) == limit {\n+            if (result.len() as isize) == limit {\n                 return result;\n             }\n             bracket_count += match ts.tok {\n@@ -347,7 +347,7 @@ impl<'a> SpanUtils<'a> {\n \n     // Return an owned vector of the subspans of the param identifier\n     // tokens found in span.\n-    pub fn spans_for_ty_params(&self, span: Span, number: int) -> Vec<Span> {\n+    pub fn spans_for_ty_params(&self, span: Span, number: isize) -> Vec<Span> {\n         if generated_code(span) {\n             return vec!();\n         }"}, {"sha": "e669accf150a837128cbee2d15e7bfe0619aa150", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -28,7 +28,7 @@\n //! constituent pattern.  N here is usually the number of arms but may be\n //! greater, if some arms have multiple alternatives.  For example, here:\n //!\n-//!     enum Foo { A, B(int), C(uint, uint) }\n+//!     enum Foo { A, B(int), C(usize, usize) }\n //!     match foo {\n //!         A => ...,\n //!         B(x) => ...,\n@@ -246,9 +246,9 @@ enum Opt<'a, 'tcx> {\n     ConstantValue(ConstantExpr<'a>, DebugLoc),\n     ConstantRange(ConstantExpr<'a>, ConstantExpr<'a>, DebugLoc),\n     Variant(ty::Disr, Rc<adt::Repr<'tcx>>, ast::DefId, DebugLoc),\n-    SliceLengthEqual(uint, DebugLoc),\n-    SliceLengthGreaterOrEqual(/* prefix length */ uint,\n-                              /* suffix length */ uint,\n+    SliceLengthEqual(usize, DebugLoc),\n+    SliceLengthGreaterOrEqual(/* prefix length */ usize,\n+                              /* suffix length */ usize,\n                               DebugLoc),\n }\n \n@@ -381,7 +381,7 @@ impl<'a, 'p, 'blk, 'tcx> Repr<'tcx> for Match<'a, 'p, 'blk, 'tcx> {\n     }\n }\n \n-fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n+fn has_nested_bindings(m: &[Match], col: usize) -> bool {\n     for br in m {\n         match br.pats[col].node {\n             ast::PatIdent(_, _, Some(_)) => return true,\n@@ -393,7 +393,7 @@ fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n \n fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                               m: &[Match<'a, 'p, 'blk, 'tcx>],\n-                                              col: uint,\n+                                              col: usize,\n                                               val: ValueRef)\n                                               -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"expand_nested_bindings(bcx={}, m={}, col={}, val={})\",\n@@ -430,7 +430,7 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                           dm: &DefMap,\n                                           m: &[Match<'a, 'p, 'blk, 'tcx>],\n-                                          col: uint,\n+                                          col: usize,\n                                           val: ValueRef,\n                                           mut e: F)\n                                           -> Vec<Match<'a, 'p, 'blk, 'tcx>> where\n@@ -476,7 +476,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      dm: &DefMap,\n                                      m: &[Match<'a, 'p, 'blk, 'tcx>],\n-                                     col: uint,\n+                                     col: usize,\n                                      val: ValueRef)\n                                      -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"enter_default(bcx={}, m={}, col={}, val={})\",\n@@ -532,8 +532,8 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n              dm: &DefMap,\n              m: &[Match<'a, 'p, 'blk, 'tcx>],\n              opt: &Opt,\n-             col: uint,\n-             variant_size: uint,\n+             col: usize,\n+             variant_size: usize,\n              val: ValueRef)\n              -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n     debug!(\"enter_opt(bcx={}, m={}, opt={:?}, col={}, val={})\",\n@@ -575,7 +575,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n // on a set of enum variants or a literal.\n fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     m: &[Match<'a, 'p, 'blk, 'tcx>],\n-                                    col: uint)\n+                                    col: usize)\n                                     -> Vec<Opt<'p, 'tcx>> {\n     let tcx = bcx.tcx();\n \n@@ -656,8 +656,8 @@ fn match_datum<'tcx>(val: ValueRef, left_ty: Ty<'tcx>) -> Datum<'tcx, Lvalue> {\n fn bind_subslice_pat(bcx: Block,\n                      pat_id: ast::NodeId,\n                      val: ValueRef,\n-                     offset_left: uint,\n-                     offset_right: uint) -> ValueRef {\n+                     offset_left: usize,\n+                     offset_right: usize) -> ValueRef {\n     let _icx = push_ctxt(\"match::bind_subslice_pat\");\n     let vec_ty = node_id_type(bcx, pat_id);\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), ty::type_content(vec_ty));\n@@ -679,8 +679,8 @@ fn bind_subslice_pat(bcx: Block,\n \n fn extract_vec_elems<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  left_ty: Ty<'tcx>,\n-                                 before: uint,\n-                                 after: uint,\n+                                 before: usize,\n+                                 after: usize,\n                                  val: ValueRef)\n                                  -> ExtractedBlock<'blk, 'tcx> {\n     let _icx = push_ctxt(\"match::extract_vec_elems\");\n@@ -711,15 +711,15 @@ macro_rules! any_pat {\n     )\n }\n \n-fn any_uniq_pat(m: &[Match], col: uint) -> bool {\n+fn any_uniq_pat(m: &[Match], col: usize) -> bool {\n     any_pat!(m, col, ast::PatBox(_))\n }\n \n-fn any_region_pat(m: &[Match], col: uint) -> bool {\n+fn any_region_pat(m: &[Match], col: usize) -> bool {\n     any_pat!(m, col, ast::PatRegion(..))\n }\n \n-fn any_irrefutable_adt_pat(tcx: &ty::ctxt, m: &[Match], col: uint) -> bool {\n+fn any_irrefutable_adt_pat(tcx: &ty::ctxt, m: &[Match], col: usize) -> bool {\n     m.iter().any(|br| {\n         let pat = br.pats[col];\n         match pat.node {\n@@ -772,16 +772,16 @@ impl FailureHandler {\n     }\n }\n \n-fn pick_column_to_specialize(def_map: &DefMap, m: &[Match]) -> Option<uint> {\n-    fn pat_score(def_map: &DefMap, pat: &ast::Pat) -> uint {\n+fn pick_column_to_specialize(def_map: &DefMap, m: &[Match]) -> Option<usize> {\n+    fn pat_score(def_map: &DefMap, pat: &ast::Pat) -> usize {\n         match pat.node {\n             ast::PatIdent(_, _, Some(ref inner)) => pat_score(def_map, &**inner),\n             _ if pat_is_refutable(def_map, pat) => 1,\n             _ => 0\n         }\n     }\n \n-    let column_score = |m: &[Match], col: uint| -> uint {\n+    let column_score = |m: &[Match], col: usize| -> usize {\n         let total_score = m.iter()\n             .map(|row| row.pats[col])\n             .map(|pat| pat_score(def_map, pat))\n@@ -795,7 +795,7 @@ fn pick_column_to_specialize(def_map: &DefMap, m: &[Match]) -> Option<uint> {\n         }\n     };\n \n-    let column_contains_any_nonwild_patterns = |&col: &uint| -> bool {\n+    let column_contains_any_nonwild_patterns = |&col: &usize| -> bool {\n         m.iter().any(|row| match row.pats[col].node {\n             ast::PatWild(_) => false,\n             _ => true\n@@ -1047,7 +1047,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                  m: &[Match<'a, 'p, 'blk, 'tcx>],\n                                                  vals: &[ValueRef],\n                                                  chk: &FailureHandler,\n-                                                 col: uint,\n+                                                 col: usize,\n                                                  val: ValueRef,\n                                                  has_genuine_default: bool) {\n     let fcx = bcx.fcx;\n@@ -1187,7 +1187,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     let t = if kind == Compare {\n                         left_ty\n                     } else {\n-                        tcx.types.uint // vector length\n+                        tcx.types.usize // vector length\n                     };\n                     let Result { bcx: after_cx, val: matches } = {\n                         match opt.trans(bcx) {"}, {"sha": "c88503f8d3d9bc01c78c5fb6521b98822111266f", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -339,7 +339,7 @@ struct Case<'tcx> {\n }\n \n /// This represents the (GEP) indices to follow to get to the discriminant field\n-pub type DiscrField = Vec<uint>;\n+pub type DiscrField = Vec<usize>;\n \n fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                     ty: Ty<'tcx>,\n@@ -776,7 +776,7 @@ fn load_discr(bcx: Block, ity: IntType, ptr: ValueRef, min: Disr, max: Disr)\n     assert_eq!(val_ty(ptr), llty.ptr_to());\n     let bits = machine::llbitsize_of_real(bcx.ccx(), llty);\n     assert!(bits <= 64);\n-    let  bits = bits as uint;\n+    let  bits = bits as usize;\n     let mask = (-1u64 >> (64 - bits)) as Disr;\n     // For a (max) discr of -1, max will be `-1 as usize`, which overflows.\n     // However, that is fine here (it would still represent the full range),\n@@ -832,7 +832,7 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n         General(ity, ref cases, dtor) => {\n             if dtor {\n                 let ptr = trans_field_ptr(bcx, r, val, discr,\n-                                          cases[discr as uint].fields.len() - 2);\n+                                          cases[discr as usize].fields.len() - 2);\n                 Store(bcx, C_u8(bcx.ccx(), 1), ptr);\n             }\n             Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true),\n@@ -870,15 +870,15 @@ fn assert_discr_in_range(ity: IntType, min: Disr, max: Disr, discr: Disr) {\n \n /// The number of fields in a given case; for use when obtaining this\n /// information from the type or definition is less convenient.\n-pub fn num_args(r: &Repr, discr: Disr) -> uint {\n+pub fn num_args(r: &Repr, discr: Disr) -> usize {\n     match *r {\n         CEnum(..) => 0,\n         Univariant(ref st, dtor) => {\n             assert_eq!(discr, 0);\n             st.fields.len() - (if dtor { 1 } else { 0 })\n         }\n         General(_, ref cases, dtor) => {\n-            cases[discr as uint].fields.len() - 1 - (if dtor { 1 } else { 0 })\n+            cases[discr as usize].fields.len() - 1 - (if dtor { 1 } else { 0 })\n         }\n         RawNullablePointer { nndiscr, ref nullfields, .. } => {\n             if discr == nndiscr { 1 } else { nullfields.len() }\n@@ -892,7 +892,7 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n \n /// Access a field, at a point when the value's case is known.\n pub fn trans_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n-                                   val: ValueRef, discr: Disr, ix: uint) -> ValueRef {\n+                                   val: ValueRef, discr: Disr, ix: usize) -> ValueRef {\n     // Note: if this ever needs to generate conditionals (e.g., if we\n     // decide to do some kind of cdr-coding-like non-unique repr\n     // someday), it will need to return a possibly-new bcx as well.\n@@ -905,7 +905,7 @@ pub fn trans_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n             struct_field_ptr(bcx, st, val, ix, false)\n         }\n         General(_, ref cases, _) => {\n-            struct_field_ptr(bcx, &cases[discr as uint], val, ix + 1, true)\n+            struct_field_ptr(bcx, &cases[discr as usize], val, ix + 1, true)\n         }\n         RawNullablePointer { nndiscr, ref nullfields, .. } |\n         StructWrappedNullablePointer { nndiscr, ref nullfields, .. } if discr != nndiscr => {\n@@ -931,7 +931,7 @@ pub fn trans_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n }\n \n pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, val: ValueRef,\n-                                    ix: uint, needs_cast: bool) -> ValueRef {\n+                                    ix: usize, needs_cast: bool) -> ValueRef {\n     let val = if needs_cast {\n         let ccx = bcx.ccx();\n         let fields = st.fields.iter().map(|&ty| type_of::type_of(ccx, ty)).collect::<Vec<_>>();\n@@ -1046,7 +1046,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n             C_integral(ll_inttype(ccx, ity), discr as u64, true)\n         }\n         General(ity, ref cases, _) => {\n-            let case = &cases[discr as uint];\n+            let case = &cases[discr as usize];\n             let (max_sz, _) = union_size_and_align(&cases[..]);\n             let lldiscr = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n             let mut f = vec![lldiscr];\n@@ -1184,7 +1184,7 @@ pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef) -> Disr {\n /// (Not to be confused with `common::const_get_elt`, which operates on\n /// raw LLVM-level structs and arrays.)\n pub fn const_get_field(ccx: &CrateContext, r: &Repr, val: ValueRef,\n-                       _discr: Disr, ix: uint) -> ValueRef {\n+                       _discr: Disr, ix: usize) -> ValueRef {\n     match *r {\n         CEnum(..) => ccx.sess().bug(\"element access in C-like enum const\"),\n         Univariant(..) => const_struct_field(ccx, val, ix),\n@@ -1198,7 +1198,7 @@ pub fn const_get_field(ccx: &CrateContext, r: &Repr, val: ValueRef,\n }\n \n /// Extract field of struct-like const, skipping our alignment padding.\n-fn const_struct_field(ccx: &CrateContext, val: ValueRef, ix: uint) -> ValueRef {\n+fn const_struct_field(ccx: &CrateContext, val: ValueRef, ix: usize) -> ValueRef {\n     // Get the ix-th non-undef element of the struct.\n     let mut real_ix = 0; // actual position in the struct\n     let mut ix = ix; // logical index relative to real_ix"}, {"sha": "206b8c80c77c7ec4baa87475eec27b9d4fa81b45", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -151,7 +151,7 @@ pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n pub struct StatRecorder<'a, 'tcx: 'a> {\n     ccx: &'a CrateContext<'a, 'tcx>,\n     name: Option<String>,\n-    istart: uint,\n+    istart: usize,\n }\n \n impl<'a, 'tcx> StatRecorder<'a, 'tcx> {\n@@ -707,7 +707,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                                     substs, &mut f);\n               }\n               (_match::Switch, Some(lldiscrim_a)) => {\n-                  cx = f(cx, lldiscrim_a, cx.tcx().types.int);\n+                  cx = f(cx, lldiscrim_a, cx.tcx().types.isize);\n                   let unr_cx = fcx.new_temp_block(\"enum-iter-unr\");\n                   Unreachable(unr_cx);\n                   let llswitch = Switch(cx, lldiscrim_a, unr_cx.llbb,"}, {"sha": "a16c4d6c2c4a78f1e1bb42a1095df124622a7167", "filename": "src/librustc_trans/trans/build.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -105,7 +105,7 @@ pub fn CondBr(cx: Block,\n     B(cx).cond_br(if_, then, else_);\n }\n \n-pub fn Switch(cx: Block, v: ValueRef, else_: BasicBlockRef, num_cases: uint)\n+pub fn Switch(cx: Block, v: ValueRef, else_: BasicBlockRef, num_cases: usize)\n     -> ValueRef {\n     if cx.unreachable.get() { return _Undef(v); }\n     check_not_terminated(cx);\n@@ -122,7 +122,7 @@ pub fn AddCase(s: ValueRef, on_val: ValueRef, dest: BasicBlockRef) {\n \n pub fn IndirectBr(cx: Block,\n                   addr: ValueRef,\n-                  num_dests: uint,\n+                  num_dests: usize,\n                   debug_loc: DebugLoc) {\n     if cx.unreachable.get() {\n         return;\n@@ -673,7 +673,7 @@ pub fn GEP(cx: Block, pointer: ValueRef, indices: &[ValueRef]) -> ValueRef {\n // Simple wrapper around GEP that takes an array of ints and wraps them\n // in C_i32()\n #[inline]\n-pub fn GEPi(cx: Block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n+pub fn GEPi(cx: Block, base: ValueRef, ixs: &[usize]) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).ptr_to().to_ref());\n@@ -691,7 +691,7 @@ pub fn InBoundsGEP(cx: Block, pointer: ValueRef, indices: &[ValueRef]) -> ValueR\n     }\n }\n \n-pub fn StructGEP(cx: Block, pointer: ValueRef, idx: uint) -> ValueRef {\n+pub fn StructGEP(cx: Block, pointer: ValueRef, idx: usize) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).ptr_to().to_ref());\n@@ -1011,7 +1011,7 @@ pub fn ShuffleVector(cx: Block, v1: ValueRef, v2: ValueRef,\n     }\n }\n \n-pub fn VectorSplat(cx: Block, num_elts: uint, elt_val: ValueRef) -> ValueRef {\n+pub fn VectorSplat(cx: Block, num_elts: usize, elt_val: ValueRef) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n@@ -1020,7 +1020,7 @@ pub fn VectorSplat(cx: Block, num_elts: uint, elt_val: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn ExtractValue(cx: Block, agg_val: ValueRef, index: uint) -> ValueRef {\n+pub fn ExtractValue(cx: Block, agg_val: ValueRef, index: usize) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n@@ -1029,7 +1029,7 @@ pub fn ExtractValue(cx: Block, agg_val: ValueRef, index: uint) -> ValueRef {\n     }\n }\n \n-pub fn InsertValue(cx: Block, agg_val: ValueRef, elt_val: ValueRef, index: uint) -> ValueRef {\n+pub fn InsertValue(cx: Block, agg_val: ValueRef, elt_val: ValueRef, index: usize) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::nil(cx.ccx()).to_ref());\n@@ -1070,7 +1070,7 @@ pub fn Trap(cx: Block) {\n }\n \n pub fn LandingPad(cx: Block, ty: Type, pers_fn: ValueRef,\n-                  num_clauses: uint) -> ValueRef {\n+                  num_clauses: usize) -> ValueRef {\n     check_not_terminated(cx);\n     assert!(!cx.unreachable.get());\n     B(cx).landing_pad(ty, pers_fn, num_clauses)"}, {"sha": "92bc20bafcfbe59412f82290db5173b71a044e6c", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -140,13 +140,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn switch(&self, v: ValueRef, else_llbb: BasicBlockRef, num_cases: uint) -> ValueRef {\n+    pub fn switch(&self, v: ValueRef, else_llbb: BasicBlockRef, num_cases: usize) -> ValueRef {\n         unsafe {\n             llvm::LLVMBuildSwitch(self.llbuilder, v, else_llbb, num_cases as c_uint)\n         }\n     }\n \n-    pub fn indirect_br(&self, addr: ValueRef, num_dests: uint) {\n+    pub fn indirect_br(&self, addr: ValueRef, num_dests: usize) {\n         self.count_insn(\"indirectbr\");\n         unsafe {\n             llvm::LLVMBuildIndirectBr(self.llbuilder, addr, num_dests as c_uint);\n@@ -555,7 +555,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     // Simple wrapper around GEP that takes an array of ints and wraps them\n     // in C_i32()\n     #[inline]\n-    pub fn gepi(&self, base: ValueRef, ixs: &[uint]) -> ValueRef {\n+    pub fn gepi(&self, base: ValueRef, ixs: &[usize]) -> ValueRef {\n         // Small vector optimization. This should catch 100% of the cases that\n         // we care about.\n         if ixs.len() < 16 {\n@@ -579,7 +579,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn struct_gep(&self, ptr: ValueRef, idx: uint) -> ValueRef {\n+    pub fn struct_gep(&self, ptr: ValueRef, idx: usize) -> ValueRef {\n         self.count_insn(\"structgep\");\n         unsafe {\n             llvm::LLVMBuildStructGEP(self.llbuilder, ptr, idx as c_uint, noname())\n@@ -886,7 +886,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn vector_splat(&self, num_elts: uint, elt: ValueRef) -> ValueRef {\n+    pub fn vector_splat(&self, num_elts: usize, elt: ValueRef) -> ValueRef {\n         unsafe {\n             let elt_ty = val_ty(elt);\n             let undef = llvm::LLVMGetUndef(Type::vector(&elt_ty, num_elts as u64).to_ref());\n@@ -896,15 +896,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn extract_value(&self, agg_val: ValueRef, idx: uint) -> ValueRef {\n+    pub fn extract_value(&self, agg_val: ValueRef, idx: usize) -> ValueRef {\n         self.count_insn(\"extractvalue\");\n         unsafe {\n             llvm::LLVMBuildExtractValue(self.llbuilder, agg_val, idx as c_uint, noname())\n         }\n     }\n \n     pub fn insert_value(&self, agg_val: ValueRef, elt: ValueRef,\n-                       idx: uint) -> ValueRef {\n+                       idx: usize) -> ValueRef {\n         self.count_insn(\"insertvalue\");\n         unsafe {\n             llvm::LLVMBuildInsertValue(self.llbuilder, agg_val, elt, idx as c_uint,\n@@ -940,15 +940,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let m: ModuleRef = llvm::LLVMGetGlobalParent(fn_);\n             let p = \"llvm.trap\\0\".as_ptr();\n             let t: ValueRef = llvm::LLVMGetNamedFunction(m, p as *const _);\n-            assert!((t as int != 0));\n+            assert!((t as isize != 0));\n             let args: &[ValueRef] = &[];\n             self.count_insn(\"trap\");\n             llvm::LLVMBuildCall(\n                 self.llbuilder, t, args.as_ptr(), args.len() as c_uint, noname());\n         }\n     }\n \n-    pub fn landing_pad(&self, ty: Type, pers_fn: ValueRef, num_clauses: uint) -> ValueRef {\n+    pub fn landing_pad(&self, ty: Type, pers_fn: ValueRef, num_clauses: usize) -> ValueRef {\n         self.count_insn(\"landingpad\");\n         unsafe {\n             llvm::LLVMBuildLandingPad("}, {"sha": "8ac4f84d6ef9f9088db9e15af7ac05c49e36f148", "filename": "src/librustc_trans/trans/cabi_aarch64.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -18,18 +18,18 @@ use trans::type_::Type;\n \n use std::cmp;\n \n-fn align_up_to(off: uint, a: uint) -> uint {\n+fn align_up_to(off: usize, a: usize) -> usize {\n     return (off + a - 1) / a * a;\n }\n \n-fn align(off: uint, ty: Type) -> uint {\n+fn align(off: usize, ty: Type) -> usize {\n     let a = ty_align(ty);\n     return align_up_to(off, a);\n }\n \n-fn ty_align(ty: Type) -> uint {\n+fn ty_align(ty: Type) -> usize {\n     match ty.kind() {\n-        Integer => ((ty.int_width() as uint) + 7) / 8,\n+        Integer => ((ty.int_width() as usize) + 7) / 8,\n         Pointer => 8,\n         Float => 4,\n         Double => 8,\n@@ -54,9 +54,9 @@ fn ty_align(ty: Type) -> uint {\n     }\n }\n \n-fn ty_size(ty: Type) -> uint {\n+fn ty_size(ty: Type) -> usize {\n     match ty.kind() {\n-        Integer => ((ty.int_width() as uint) + 7) / 8,\n+        Integer => ((ty.int_width() as usize) + 7) / 8,\n         Pointer => 8,\n         Float => 4,\n         Double => 8,"}, {"sha": "941c065e3d5d43b9769ce8bc49bf44c60dd0bf64", "filename": "src/librustc_trans/trans/cabi_arm.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_arm.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -23,20 +23,20 @@ pub enum Flavor {\n     Ios\n }\n \n-type TyAlignFn = fn(ty: Type) -> uint;\n+type TyAlignFn = fn(ty: Type) -> usize;\n \n-fn align_up_to(off: uint, a: uint) -> uint {\n+fn align_up_to(off: usize, a: usize) -> usize {\n     return (off + a - 1) / a * a;\n }\n \n-fn align(off: uint, ty: Type, align_fn: TyAlignFn) -> uint {\n+fn align(off: usize, ty: Type, align_fn: TyAlignFn) -> usize {\n     let a = align_fn(ty);\n     return align_up_to(off, a);\n }\n \n-fn general_ty_align(ty: Type) -> uint {\n+fn general_ty_align(ty: Type) -> usize {\n     match ty.kind() {\n-        Integer => ((ty.int_width() as uint) + 7) / 8,\n+        Integer => ((ty.int_width() as usize) + 7) / 8,\n         Pointer => 4,\n         Float => 4,\n         Double => 8,\n@@ -68,9 +68,9 @@ fn general_ty_align(ty: Type) -> uint {\n // ARMv6\n // https://developer.apple.com/library/ios/documentation/Xcode/Conceptual\n //    /iPhoneOSABIReference/Articles/ARMv6FunctionCallingConventions.html\n-fn ios_ty_align(ty: Type) -> uint {\n+fn ios_ty_align(ty: Type) -> usize {\n     match ty.kind() {\n-        Integer => cmp::min(4, ((ty.int_width() as uint) + 7) / 8),\n+        Integer => cmp::min(4, ((ty.int_width() as usize) + 7) / 8),\n         Pointer => 4,\n         Float => 4,\n         Double => 4,\n@@ -95,9 +95,9 @@ fn ios_ty_align(ty: Type) -> uint {\n     }\n }\n \n-fn ty_size(ty: Type, align_fn: TyAlignFn) -> uint {\n+fn ty_size(ty: Type, align_fn: TyAlignFn) -> usize {\n     match ty.kind() {\n-        Integer => ((ty.int_width() as uint) + 7) / 8,\n+        Integer => ((ty.int_width() as usize) + 7) / 8,\n         Pointer => 4,\n         Float => 4,\n         Double => 8,"}, {"sha": "2d7fdd2f2eba47a0acdcff06e96804d69bb680e3", "filename": "src/librustc_trans/trans/cabi_mips.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_mips.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -19,18 +19,18 @@ use trans::cabi::{ArgType, FnType};\n use trans::context::CrateContext;\n use trans::type_::Type;\n \n-fn align_up_to(off: uint, a: uint) -> uint {\n+fn align_up_to(off: usize, a: usize) -> usize {\n     return (off + a - 1) / a * a;\n }\n \n-fn align(off: uint, ty: Type) -> uint {\n+fn align(off: usize, ty: Type) -> usize {\n     let a = ty_align(ty);\n     return align_up_to(off, a);\n }\n \n-fn ty_align(ty: Type) -> uint {\n+fn ty_align(ty: Type) -> usize {\n     match ty.kind() {\n-        Integer => ((ty.int_width() as uint) + 7) / 8,\n+        Integer => ((ty.int_width() as usize) + 7) / 8,\n         Pointer => 4,\n         Float => 4,\n         Double => 8,\n@@ -55,9 +55,9 @@ fn ty_align(ty: Type) -> uint {\n     }\n }\n \n-fn ty_size(ty: Type) -> uint {\n+fn ty_size(ty: Type) -> usize {\n     match ty.kind() {\n-        Integer => ((ty.int_width() as uint) + 7) / 8,\n+        Integer => ((ty.int_width() as usize) + 7) / 8,\n         Pointer => 4,\n         Float => 4,\n         Double => 8,\n@@ -96,7 +96,7 @@ fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut uint) -> ArgType {\n+fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut usize) -> ArgType {\n     let orig_offset = *offset;\n     let size = ty_size(ty) * 8;\n     let mut align = ty_align(ty);\n@@ -129,15 +129,15 @@ fn is_reg_ty(ty: Type) -> bool {\n     };\n }\n \n-fn padding_ty(ccx: &CrateContext, align: uint, offset: uint) -> Option<Type> {\n+fn padding_ty(ccx: &CrateContext, align: usize, offset: usize) -> Option<Type> {\n     if ((align - 1 ) & offset) > 0 {\n         Some(Type::i32(ccx))\n     } else {\n         None\n     }\n }\n \n-fn coerce_to_int(ccx: &CrateContext, size: uint) -> Vec<Type> {\n+fn coerce_to_int(ccx: &CrateContext, size: usize) -> Vec<Type> {\n     let int_ty = Type::i32(ccx);\n     let mut args = Vec::new();\n "}, {"sha": "8c30d4fcc2b1f2c35310ee9dd557819f4e1f8842", "filename": "src/librustc_trans/trans/cabi_powerpc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_powerpc.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -18,20 +18,20 @@ use trans::type_::Type;\n \n use std::cmp;\n \n-fn align_up_to(off: uint, a: uint) -> uint {\n+fn align_up_to(off: usize, a: usize) -> usize {\n     return (off + a - 1) / a * a;\n }\n \n-fn align(off: uint, ty: Type) -> uint {\n+fn align(off: usize, ty: Type) -> usize {\n     let a = ty_align(ty);\n     return align_up_to(off, a);\n }\n \n-fn ty_align(ty: Type) -> uint {\n+fn ty_align(ty: Type) -> usize {\n     match ty.kind() {\n         Integer => {\n             unsafe {\n-                ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n+                ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as usize) + 7) / 8\n             }\n         }\n         Pointer => 4,\n@@ -53,11 +53,11 @@ fn ty_align(ty: Type) -> uint {\n     }\n }\n \n-fn ty_size(ty: Type) -> uint {\n+fn ty_size(ty: Type) -> usize {\n     match ty.kind() {\n         Integer => {\n             unsafe {\n-                ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n+                ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as usize) + 7) / 8\n             }\n         }\n         Pointer => 4,\n@@ -92,7 +92,7 @@ fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut uint) -> ArgType {\n+fn classify_arg_ty(ccx: &CrateContext, ty: Type, offset: &mut usize) -> ArgType {\n     let orig_offset = *offset;\n     let size = ty_size(ty) * 8;\n     let mut align = ty_align(ty);\n@@ -124,15 +124,15 @@ fn is_reg_ty(ty: Type) -> bool {\n     };\n }\n \n-fn padding_ty(ccx: &CrateContext, align: uint, offset: uint) -> Option<Type> {\n+fn padding_ty(ccx: &CrateContext, align: usize, offset: usize) -> Option<Type> {\n     if ((align - 1 ) & offset) > 0 {\n         Some(Type::i32(ccx))\n     } else {\n         None\n     }\n }\n \n-fn coerce_to_int(ccx: &CrateContext, size: uint) -> Vec<Type> {\n+fn coerce_to_int(ccx: &CrateContext, size: usize) -> Vec<Type> {\n     let int_ty = Type::i32(ccx);\n     let mut args = Vec::new();\n "}, {"sha": "754b7ee5cf555d7c26ad89e7ecb3947d8b759ef3", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -86,14 +86,14 @@ impl ClassList for [RegClass] {\n }\n \n fn classify_ty(ty: Type) -> Vec<RegClass> {\n-    fn align(off: uint, ty: Type) -> uint {\n+    fn align(off: usize, ty: Type) -> usize {\n         let a = ty_align(ty);\n         return (off + a - 1) / a * a;\n     }\n \n-    fn ty_align(ty: Type) -> uint {\n+    fn ty_align(ty: Type) -> usize {\n         match ty.kind() {\n-            Integer => ((ty.int_width() as uint) + 7) / 8,\n+            Integer => ((ty.int_width() as usize) + 7) / 8,\n             Pointer => 8,\n             Float => 4,\n             Double => 8,\n@@ -118,9 +118,9 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n         }\n     }\n \n-    fn ty_size(ty: Type) -> uint {\n+    fn ty_size(ty: Type) -> usize {\n         match ty.kind() {\n-            Integer => (ty.int_width() as uint + 7) / 8,\n+            Integer => (ty.int_width() as usize + 7) / 8,\n             Pointer => 8,\n             Float => 4,\n             Double => 8,\n@@ -157,7 +157,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n     }\n \n     fn unify(cls: &mut [RegClass],\n-             i: uint,\n+             i: usize,\n              newv: RegClass) {\n         if cls[i] == newv { return }\n \n@@ -191,8 +191,8 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n \n     fn classify_struct(tys: &[Type],\n                        cls: &mut [RegClass],\n-                       i: uint,\n-                       off: uint,\n+                       i: usize,\n+                       off: usize,\n                        packed: bool) {\n         let mut field_off = off;\n         for ty in tys {\n@@ -205,8 +205,8 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n     }\n \n     fn classify(ty: Type,\n-                cls: &mut [RegClass], ix: uint,\n-                off: uint) {\n+                cls: &mut [RegClass], ix: usize,\n+                off: usize) {\n         let t_align = ty_align(ty);\n         let t_size = ty_size(ty);\n \n@@ -331,7 +331,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n }\n \n fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n-    fn llvec_len(cls: &[RegClass]) -> uint {\n+    fn llvec_len(cls: &[RegClass]) -> usize {\n         let mut len = 1;\n         for c in cls {\n             if *c != SSEUp {"}, {"sha": "de6e439801a4e0d1273ec7fea3c64c9a0288ff1a", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -155,12 +155,12 @@ pub struct CleanupScope<'blk, 'tcx: 'blk> {\n \n #[derive(Copy, Debug)]\n pub struct CustomScopeIndex {\n-    index: uint\n+    index: usize\n }\n \n-pub const EXIT_BREAK: uint = 0;\n-pub const EXIT_LOOP: uint = 1;\n-pub const EXIT_MAX: uint = 2;\n+pub const EXIT_BREAK: usize = 0;\n+pub const EXIT_LOOP: usize = 1;\n+pub const EXIT_MAX: usize = 2;\n \n pub enum CleanupScopeKind<'blk, 'tcx: 'blk> {\n     CustomScopeKind,\n@@ -188,7 +188,7 @@ impl<'blk, 'tcx: 'blk> fmt::Debug for CleanupScopeKind<'blk, 'tcx> {\n pub enum EarlyExitLabel {\n     UnwindExit,\n     ReturnExit,\n-    LoopExit(ast::NodeId, uint)\n+    LoopExit(ast::NodeId, usize)\n }\n \n #[derive(Copy)]\n@@ -357,7 +357,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     /// break/continue (depending on `exit`) out of the loop with id `cleanup_scope`\n     fn normal_exit_block(&'blk self,\n                          cleanup_scope: ast::NodeId,\n-                         exit: uint) -> BasicBlockRef {\n+                         exit: usize) -> BasicBlockRef {\n         self.trans_cleanups_to_exit_scope(LoopExit(cleanup_scope, exit))\n     }\n \n@@ -585,7 +585,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n         None\n     }\n \n-    fn top_nonempty_cleanup_scope(&self) -> Option<uint> {\n+    fn top_nonempty_cleanup_scope(&self) -> Option<usize> {\n         self.scopes.borrow().iter().rev().position(|s| !s.cleanups.is_empty())\n     }\n \n@@ -614,7 +614,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n         bcx\n     }\n \n-    fn scopes_len(&self) -> uint {\n+    fn scopes_len(&self) -> usize {\n         self.scopes.borrow().len()\n     }\n \n@@ -962,7 +962,7 @@ impl<'blk, 'tcx> CleanupScopeKind<'blk, 'tcx> {\n     /// If this is a loop scope with id `id`, return the early exit block `exit`, else `None`\n     fn early_exit_block(&self,\n                         id: ast::NodeId,\n-                        exit: uint) -> Option<BasicBlockRef> {\n+                        exit: usize) -> Option<BasicBlockRef> {\n         match *self {\n             LoopScopeKind(i, ref exits) if id == i => Some(exits[exit].llbb),\n             _ => None,\n@@ -1182,7 +1182,7 @@ pub trait CleanupMethods<'blk, 'tcx> {\n     fn top_loop_scope(&self) -> ast::NodeId;\n     fn normal_exit_block(&'blk self,\n                          cleanup_scope: ast::NodeId,\n-                         exit: uint) -> BasicBlockRef;\n+                         exit: usize) -> BasicBlockRef;\n     fn return_exit_block(&'blk self) -> BasicBlockRef;\n     fn schedule_lifetime_end(&self,\n                          cleanup_scope: ScopeId,\n@@ -1225,7 +1225,7 @@ pub trait CleanupMethods<'blk, 'tcx> {\n \n trait CleanupHelperMethods<'blk, 'tcx> {\n     fn top_ast_scope(&self) -> Option<ast::NodeId>;\n-    fn top_nonempty_cleanup_scope(&self) -> Option<uint>;\n+    fn top_nonempty_cleanup_scope(&self) -> Option<usize>;\n     fn is_valid_to_pop_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool;\n     fn is_valid_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool;\n     fn trans_scope_cleanups(&self,\n@@ -1235,7 +1235,7 @@ trait CleanupHelperMethods<'blk, 'tcx> {\n                                     label: EarlyExitLabel)\n                                     -> BasicBlockRef;\n     fn get_or_create_landing_pad(&'blk self) -> BasicBlockRef;\n-    fn scopes_len(&self) -> uint;\n+    fn scopes_len(&self) -> usize;\n     fn push_scope(&self, scope: CleanupScope<'blk, 'tcx>);\n     fn pop_scope(&self) -> CleanupScope<'blk, 'tcx>;\n     fn top_scope<R, F>(&self, f: F) -> R where F: FnOnce(&CleanupScope<'blk, 'tcx>) -> R;"}, {"sha": "1644871492a0e93732b475eddcf49fdd53ce97c7", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -459,7 +459,7 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n-    pub fn arg_pos(&self, arg: uint) -> uint {\n+    pub fn arg_pos(&self, arg: usize) -> usize {\n         let arg = self.env_arg_pos() + arg;\n         if self.llenv.is_some() {\n             arg + 1\n@@ -468,7 +468,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn env_arg_pos(&self) -> uint {\n+    pub fn env_arg_pos(&self) -> usize {\n         if self.caller_expects_out_pointer {\n             1\n         } else {\n@@ -846,13 +846,13 @@ pub trait AsU64 { fn as_u64(self) -> u64; }\n // are host-architecture-dependent\n impl AsI64 for i64 { fn as_i64(self) -> i64 { self as i64 }}\n impl AsI64 for i32 { fn as_i64(self) -> i64 { self as i64 }}\n-impl AsI64 for int { fn as_i64(self) -> i64 { self as i64 }}\n+impl AsI64 for isize { fn as_i64(self) -> i64 { self as i64 }}\n \n impl AsU64 for u64  { fn as_u64(self) -> u64 { self as u64 }}\n impl AsU64 for u32  { fn as_u64(self) -> u64 { self as u64 }}\n-impl AsU64 for uint { fn as_u64(self) -> u64 { self as u64 }}\n+impl AsU64 for usize { fn as_u64(self) -> u64 { self as u64 }}\n \n-pub fn C_u8(ccx: &CrateContext, i: uint) -> ValueRef {\n+pub fn C_u8(ccx: &CrateContext, i: usize) -> ValueRef {\n     C_integral(Type::i8(ccx), i as u64, false)\n }\n "}, {"sha": "348335139da649e4c4a8a4919cfd376c5c9d36ec", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -53,7 +53,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n                 }\n                 _ => cx.sess().span_bug(lit.span,\n                         &format!(\"integer literal has type {} (expected int \\\n-                                 or uint)\",\n+                                 or usize)\",\n                                 ty_to_string(cx.tcx(), lit_int_ty)))\n             }\n         }\n@@ -652,8 +652,8 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let unit_ty = ty::sequence_element_type(cx.tcx(), ety);\n             let llunitty = type_of::type_of(cx, unit_ty);\n             let n = match const_eval::eval_const_expr_partial(cx.tcx(), &**count, None) {\n-                Ok(const_eval::const_int(i))  => i as uint,\n-                Ok(const_eval::const_uint(i)) => i as uint,\n+                Ok(const_eval::const_int(i))  => i as usize,\n+                Ok(const_eval::const_uint(i)) => i as usize,\n                 _ => cx.sess().span_bug(count.span, \"count must be integral const expression.\")\n             };\n             let unit_val = const_expr(cx, &**elem, param_substs).0;"}, {"sha": "5239389a593f52987eb54f8b7fa23496b0f5d035", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -38,17 +38,17 @@ use syntax::ast;\n use syntax::parse::token::InternedString;\n \n pub struct Stats {\n-    pub n_glues_created: Cell<uint>,\n-    pub n_null_glues: Cell<uint>,\n-    pub n_real_glues: Cell<uint>,\n-    pub n_fns: Cell<uint>,\n-    pub n_monos: Cell<uint>,\n-    pub n_inlines: Cell<uint>,\n-    pub n_closures: Cell<uint>,\n-    pub n_llvm_insns: Cell<uint>,\n-    pub llvm_insns: RefCell<FnvHashMap<String, uint>>,\n+    pub n_glues_created: Cell<usize>,\n+    pub n_null_glues: Cell<usize>,\n+    pub n_real_glues: Cell<usize>,\n+    pub n_fns: Cell<usize>,\n+    pub n_monos: Cell<usize>,\n+    pub n_inlines: Cell<usize>,\n+    pub n_closures: Cell<usize>,\n+    pub n_llvm_insns: Cell<usize>,\n+    pub llvm_insns: RefCell<FnvHashMap<String, usize>>,\n     // (ident, llvm-instructions)\n-    pub fn_stats: RefCell<Vec<(String, uint)> >,\n+    pub fn_stats: RefCell<Vec<(String, usize)> >,\n }\n \n /// The shared portion of a `CrateContext`.  There is one `SharedCrateContext`\n@@ -95,7 +95,7 @@ pub struct LocalCrateContext<'tcx> {\n     external_srcs: RefCell<NodeMap<ast::DefId>>,\n     /// Cache instances of monomorphized functions\n     monomorphized: RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>>,\n-    monomorphizing: RefCell<DefIdMap<uint>>,\n+    monomorphizing: RefCell<DefIdMap<usize>>,\n     /// Cache generated vtables\n     vtables: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, ValueRef>>,\n     /// Cache of constant strings,\n@@ -149,7 +149,7 @@ pub struct LocalCrateContext<'tcx> {\n     /// Number of LLVM instructions translated into this `LocalCrateContext`.\n     /// This is used to perform some basic load-balancing to keep all LLVM\n     /// contexts around the same size.\n-    n_llvm_insns: Cell<uint>,\n+    n_llvm_insns: Cell<usize>,\n \n     trait_cache: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>,\n                                     traits::Vtable<'tcx, ()>>>,\n@@ -160,12 +160,12 @@ pub struct CrateContext<'a, 'tcx: 'a> {\n     local: &'a LocalCrateContext<'tcx>,\n     /// The index of `local` in `shared.local_ccxs`.  This is used in\n     /// `maybe_iter(true)` to identify the original `LocalCrateContext`.\n-    index: uint,\n+    index: usize,\n }\n \n pub struct CrateContextIterator<'a, 'tcx: 'a> {\n     shared: &'a SharedCrateContext<'tcx>,\n-    index: uint,\n+    index: usize,\n }\n \n impl<'a, 'tcx> Iterator for CrateContextIterator<'a,'tcx> {\n@@ -190,9 +190,9 @@ impl<'a, 'tcx> Iterator for CrateContextIterator<'a,'tcx> {\n /// The iterator produced by `CrateContext::maybe_iter`.\n pub struct CrateContextMaybeIterator<'a, 'tcx: 'a> {\n     shared: &'a SharedCrateContext<'tcx>,\n-    index: uint,\n+    index: usize,\n     single: bool,\n-    origin: uint,\n+    origin: usize,\n }\n \n impl<'a, 'tcx> Iterator for CrateContextMaybeIterator<'a, 'tcx> {\n@@ -236,7 +236,7 @@ unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextR\n \n impl<'tcx> SharedCrateContext<'tcx> {\n     pub fn new(crate_name: &str,\n-               local_count: uint,\n+               local_count: usize,\n                tcx: ty::ctxt<'tcx>,\n                export_map: ExportMap,\n                symbol_hasher: Sha256,\n@@ -299,7 +299,7 @@ impl<'tcx> SharedCrateContext<'tcx> {\n         }\n     }\n \n-    pub fn get_ccx<'a>(&'a self, index: uint) -> CrateContext<'a, 'tcx> {\n+    pub fn get_ccx<'a>(&'a self, index: usize) -> CrateContext<'a, 'tcx> {\n         CrateContext {\n             shared: self,\n             local: &self.local_ccxs[index],\n@@ -456,7 +456,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n         CrateContext {\n             shared: shared,\n             local: self,\n-            index: -1 as uint,\n+            index: -1 as usize,\n         }\n     }\n }\n@@ -588,7 +588,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.monomorphized\n     }\n \n-    pub fn monomorphizing<'a>(&'a self) -> &'a RefCell<DefIdMap<uint>> {\n+    pub fn monomorphizing<'a>(&'a self) -> &'a RefCell<DefIdMap<usize>> {\n         &self.local.monomorphizing\n     }\n "}, {"sha": "bd31580333fab25f5cfba61820afbdfcea84dfb0", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -293,7 +293,7 @@ pub fn trans_loop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     expr: &ast::Expr,\n                                     opt_label: Option<Ident>,\n-                                    exit: uint)\n+                                    exit: usize)\n                                     -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_break_cont\");\n     let fcx = bcx.fcx;"}, {"sha": "f2c24501c66c8e6c97856919fa471b01f01b0fcb", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -694,7 +694,7 @@ impl FunctionDebugContext {\n struct FunctionDebugContextData {\n     scope_map: RefCell<NodeMap<DIScope>>,\n     fn_metadata: DISubprogram,\n-    argument_counter: Cell<uint>,\n+    argument_counter: Cell<usize>,\n     source_locations_enabled: Cell<bool>,\n     source_location_override: Cell<bool>,\n }\n@@ -708,7 +708,7 @@ enum VariableAccess<'a> {\n }\n \n enum VariableKind {\n-    ArgumentVariable(uint /*index*/),\n+    ArgumentVariable(usize /*index*/),\n     LocalVariable,\n     CapturedVariable,\n }\n@@ -876,7 +876,7 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                 node_id: ast::NodeId,\n                                                 env_pointer: ValueRef,\n-                                                env_index: uint,\n+                                                env_index: usize,\n                                                 captured_by_ref: bool,\n                                                 span: Span) {\n     if bcx.unreachable.get() ||\n@@ -1873,7 +1873,7 @@ fn pointer_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n //=-----------------------------------------------------------------------------\n \n enum MemberOffset {\n-    FixedMemberOffset { bytes: uint },\n+    FixedMemberOffset { bytes: usize },\n     // For ComputedMemberOffset, the offset is read from the llvm type definition\n     ComputedMemberOffset\n }\n@@ -2022,7 +2022,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n         }\n \n         let field_size = if self.is_simd {\n-            machine::llsize_of_alloc(cx, type_of::type_of(cx, self.fields[0].mt.ty)) as uint\n+            machine::llsize_of_alloc(cx, type_of::type_of(cx, self.fields[0].mt.ty)) as usize\n         } else {\n             0xdeadbeef\n         };\n@@ -2245,7 +2245,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // DWARF representation of enums uniform.\n \n                 // First create a description of the artificial wrapper struct:\n-                let non_null_variant = &(*self.variants)[non_null_variant_index as uint];\n+                let non_null_variant = &(*self.variants)[non_null_variant_index as usize];\n                 let non_null_variant_name = token::get_name(non_null_variant.name);\n \n                 // The llvm type and metadata of the pointer\n@@ -2290,7 +2290,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n \n                 // Encode the information about the null variant in the union\n                 // member's name.\n-                let null_variant_index = (1 - non_null_variant_index) as uint;\n+                let null_variant_index = (1 - non_null_variant_index) as usize;\n                 let null_variant_name = token::get_name((*self.variants)[null_variant_index].name);\n                 let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n                                                 0,\n@@ -2316,7 +2316,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     describe_enum_variant(cx,\n                                           self.enum_type,\n                                           struct_def,\n-                                          &*(*self.variants)[nndiscr as uint],\n+                                          &*(*self.variants)[nndiscr as usize],\n                                           OptimizedDiscriminant,\n                                           self.containing_scope,\n                                           self.span);\n@@ -2331,7 +2331,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n \n                 // Encode the information about the null variant in the union\n                 // member's name.\n-                let null_variant_index = (1 - nndiscr) as uint;\n+                let null_variant_index = (1 - nndiscr) as usize;\n                 let null_variant_name = token::get_name((*self.variants)[null_variant_index].name);\n                 let discrfield = discrfield.iter()\n                                            .skip(1)\n@@ -2813,7 +2813,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         MemberDescription {\n             name: \"length\".to_string(),\n             llvm_type: member_llvm_types[1],\n-            type_metadata: type_metadata(cx, cx.tcx().types.uint, span),\n+            type_metadata: type_metadata(cx, cx.tcx().types.usize, span),\n             offset: ComputedMemberOffset,\n             flags: FLAGS_NONE\n         },\n@@ -3108,12 +3108,12 @@ impl MetadataCreationResult {\n \n #[derive(Copy, PartialEq)]\n enum InternalDebugLocation {\n-    KnownLocation { scope: DIScope, line: uint, col: uint },\n+    KnownLocation { scope: DIScope, line: usize, col: usize },\n     UnknownLocation\n }\n \n impl InternalDebugLocation {\n-    fn new(scope: DIScope, line: uint, col: uint) -> InternalDebugLocation {\n+    fn new(scope: DIScope, line: usize, col: usize) -> InternalDebugLocation {\n         KnownLocation {\n             scope: scope,\n             line: line,"}, {"sha": "b064f16ebd409e70c59a3fc04843dc21aafdfb01", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -521,7 +521,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     fn unsize_unique_vec<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      expr: &ast::Expr,\n                                      datum: Datum<'tcx, Expr>,\n-                                     len: uint)\n+                                     len: usize)\n                                      -> DatumBlock<'blk, 'tcx, Expr> {\n         let mut bcx = bcx;\n         let tcx = bcx.tcx();\n@@ -744,7 +744,7 @@ fn trans_field<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                               base: &ast::Expr,\n                               get_idx: F)\n                               -> DatumBlock<'blk, 'tcx, Expr> where\n-    F: FnOnce(&'blk ty::ctxt<'tcx>, &[ty::field<'tcx>]) -> uint,\n+    F: FnOnce(&'blk ty::ctxt<'tcx>, &[ty::field<'tcx>]) -> usize,\n {\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_rec_field\");\n@@ -785,7 +785,7 @@ fn trans_rec_field<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// Translates `base.<idx>`.\n fn trans_rec_tup_field<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    base: &ast::Expr,\n-                                   idx: uint)\n+                                   idx: usize)\n                                    -> DatumBlock<'blk, 'tcx, Expr> {\n     trans_field(bcx, base, |_, _| idx)\n }\n@@ -1149,7 +1149,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         ast::ExprTup(ref args) => {\n-            let numbered_fields: Vec<(uint, &ast::Expr)> =\n+            let numbered_fields: Vec<(usize, &ast::Expr)> =\n                 args.iter().enumerate().map(|(i, arg)| (i, &**arg)).collect();\n             trans_adt(bcx,\n                       expr_ty(bcx, expr),\n@@ -1485,7 +1485,7 @@ pub struct StructBaseInfo<'a, 'tcx> {\n     /// The base expression; will be evaluated after all explicit fields.\n     expr: &'a ast::Expr,\n     /// The indices of fields to copy paired with their types.\n-    fields: Vec<(uint, Ty<'tcx>)>\n+    fields: Vec<(usize, Ty<'tcx>)>\n }\n \n /// Constructs an ADT instance:\n@@ -1499,7 +1499,7 @@ pub struct StructBaseInfo<'a, 'tcx> {\n pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                  ty: Ty<'tcx>,\n                                  discr: ty::Disr,\n-                                 fields: &[(uint, &ast::Expr)],\n+                                 fields: &[(usize, &ast::Expr)],\n                                  optbase: Option<StructBaseInfo<'a, 'tcx>>,\n                                  dest: Dest,\n                                  debug_location: DebugLoc)\n@@ -2228,7 +2228,7 @@ fn auto_ref<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn deref_multiple<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               expr: &ast::Expr,\n                               datum: Datum<'tcx, Expr>,\n-                              times: uint)\n+                              times: usize)\n                               -> DatumBlock<'blk, 'tcx, Expr> {\n     let mut bcx = bcx;\n     let mut datum = datum;"}, {"sha": "f6db40b684e83e29682874e695f3d1da55e8d466", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -121,21 +121,21 @@ pub fn check_intrinsics(ccx: &CrateContext) {\n                     &format!(\"transmute called on types with potentially different sizes: \\\n                               {} (could be {} bit{}) to {} (could be {} bit{})\",\n                              ty_to_string(ccx.tcx(), transmute_restriction.original_from),\n-                             from_type_size as uint,\n+                             from_type_size as usize,\n                              if from_type_size == 1 {\"\"} else {\"s\"},\n                              ty_to_string(ccx.tcx(), transmute_restriction.original_to),\n-                             to_type_size as uint,\n+                             to_type_size as usize,\n                              if to_type_size == 1 {\"\"} else {\"s\"}));\n             } else {\n                 ccx.sess().span_err(\n                     transmute_restriction.span,\n                     &format!(\"transmute called on types with different sizes: \\\n                               {} ({} bit{}) to {} ({} bit{})\",\n                              ty_to_string(ccx.tcx(), transmute_restriction.original_from),\n-                             from_type_size as uint,\n+                             from_type_size as usize,\n                              if from_type_size == 1 {\"\"} else {\"s\"},\n                              ty_to_string(ccx.tcx(), transmute_restriction.original_to),\n-                             to_type_size as uint,\n+                             to_type_size as usize,\n                              if to_type_size == 1 {\"\"} else {\"s\"}));\n             }\n         }"}, {"sha": "ce37d38dc894fb3ff2efcedfca6c705bf8d0266c", "filename": "src/librustc_trans/trans/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmachine.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -99,7 +99,7 @@ pub fn llalign_of_min(cx: &CrateContext, ty: Type) -> llalign {\n     }\n }\n \n-pub fn llelement_offset(cx: &CrateContext, struct_ty: Type, element: uint) -> u64 {\n+pub fn llelement_offset(cx: &CrateContext, struct_ty: Type, element: usize) -> u64 {\n     unsafe {\n         return llvm::LLVMOffsetOfElement(cx.td().lltd, struct_ty.to_ref(),\n                                          element as u32);"}, {"sha": "ea1d4690f0565bae98ce3a197c49864d6b0aaccf", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -47,7 +47,7 @@ use syntax::codemap::DUMMY_SP;\n use syntax::ptr::P;\n \n // drop_glue pointer, size, align.\n-const VTABLE_OFFSET: uint = 3;\n+const VTABLE_OFFSET: usize = 3;\n \n /// The main \"translation\" pass for methods.  Generates code\n /// for non-monomorphized methods only.  Other methods will\n@@ -325,7 +325,7 @@ fn method_with_name(ccx: &CrateContext, impl_id: ast::DefId, name: ast::Name)\n fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                           method_call: MethodCall,\n                                           trait_id: ast::DefId,\n-                                          n_method: uint,\n+                                          n_method: usize,\n                                           vtable: traits::Vtable<'tcx, ()>)\n                                           -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"meth::trans_monomorphized_callee\");\n@@ -437,7 +437,7 @@ fn combine_impl_and_methods_tps<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// extract the self data and vtable out of the pair.\n fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                   method_ty: Ty<'tcx>,\n-                                  vtable_index: uint,\n+                                  vtable_index: usize,\n                                   self_expr: &ast::Expr,\n                                   arg_cleanup_scope: cleanup::ScopeId)\n                                   -> Callee<'blk, 'tcx> {\n@@ -474,7 +474,7 @@ fn trans_trait_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// pair.\n pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                  callee_ty: Ty<'tcx>,\n-                                                 vtable_index: uint,\n+                                                 vtable_index: usize,\n                                                  llpair: ValueRef)\n                                                  -> Callee<'blk, 'tcx> {\n     let _icx = push_ctxt(\"meth::trans_trait_callee\");\n@@ -547,7 +547,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n     object_ty: Ty<'tcx>,\n     upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n-    method_offset_in_trait: uint)\n+    method_offset_in_trait: usize)\n     -> (ValueRef, Ty<'tcx>)\n {\n     let _icx = push_ctxt(\"trans_object_shim\");"}, {"sha": "8f1ef84386f4faf9018f67c41f2a56a607a35b2c", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -265,7 +265,7 @@ fn vec_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, unit_ty: Ty<'tcx>)\n     }\n }\n \n-fn elements_required(bcx: Block, content_expr: &ast::Expr) -> uint {\n+fn elements_required(bcx: Block, content_expr: &ast::Expr) -> usize {\n     //! Figure out the number of elements we need to store this content\n \n     match content_expr.node {\n@@ -291,7 +291,7 @@ fn elements_required(bcx: Block, content_expr: &ast::Expr) -> uint {\n /// which should be by ref.\n pub fn get_fixed_base_and_len(bcx: Block,\n                               llval: ValueRef,\n-                              vec_length: uint)\n+                              vec_length: usize)\n                               -> (ValueRef, ValueRef) {\n     let ccx = bcx.ccx();\n "}, {"sha": "339b4734ee4b1b82da3ed88cf46794314666ade2", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -239,21 +239,21 @@ impl Type {\n     }\n \n     /// Return the number of elements in `self` if it is a LLVM vector type.\n-    pub fn vector_length(&self) -> uint {\n+    pub fn vector_length(&self) -> usize {\n         unsafe {\n-            llvm::LLVMGetVectorSize(self.to_ref()) as uint\n+            llvm::LLVMGetVectorSize(self.to_ref()) as usize\n         }\n     }\n \n-    pub fn array_length(&self) -> uint {\n+    pub fn array_length(&self) -> usize {\n         unsafe {\n-            llvm::LLVMGetArrayLength(self.to_ref()) as uint\n+            llvm::LLVMGetArrayLength(self.to_ref()) as usize\n         }\n     }\n \n     pub fn field_types(&self) -> Vec<Type> {\n         unsafe {\n-            let n_elts = llvm::LLVMCountStructElementTypes(self.to_ref()) as uint;\n+            let n_elts = llvm::LLVMCountStructElementTypes(self.to_ref()) as usize;\n             if n_elts == 0 {\n                 return Vec::new();\n             }\n@@ -270,15 +270,15 @@ impl Type {\n \n     pub fn func_params(&self) -> Vec<Type> {\n         unsafe {\n-            let n_args = llvm::LLVMCountParamTypes(self.to_ref()) as uint;\n+            let n_args = llvm::LLVMCountParamTypes(self.to_ref()) as usize;\n             let mut args: Vec<_> = repeat(Type { rf: ptr::null_mut() }).take(n_args).collect();\n             llvm::LLVMGetParamTypes(self.to_ref(),\n                                     args.as_mut_ptr() as *mut TypeRef);\n             args\n         }\n     }\n \n-    pub fn float_width(&self) -> uint {\n+    pub fn float_width(&self) -> usize {\n         match self.kind() {\n             Float => 32,\n             Double => 64,"}, {"sha": "c2d91e4e160248925d084b34c5e259515b0645f9", "filename": "src/librustc_trans/trans/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -107,7 +107,7 @@ impl Value {\n \n     /// Returns the requested operand of this instruction\n     /// Returns None, if there's no operand at the given index\n-    pub fn get_operand(self, i: uint) -> Option<Value> {\n+    pub fn get_operand(self, i: usize) -> Option<Value> {\n         opt_val!(llvm::LLVMGetOperand(self.get(), i as c_uint))\n     }\n "}, {"sha": "0d6ca7430d38ed0792bba57990444c3697090ea4", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -504,9 +504,9 @@ fn convert_angle_bracketed_parameters<'tcx>(this: &AstConv<'tcx>,\n /// (if one exists) and a vector of the (pattern, number of lifetimes)\n /// corresponding to each input type/pattern.\n fn find_implied_output_region(input_tys: &[Ty], input_pats: Vec<String>)\n-                              -> (Option<ty::Region>, Vec<(String, uint)>)\n+                              -> (Option<ty::Region>, Vec<(String, usize)>)\n {\n-    let mut lifetimes_for_params: Vec<(String, uint)> = Vec::new();\n+    let mut lifetimes_for_params: Vec<(String, usize)> = Vec::new();\n     let mut possible_implied_output_region = None;\n \n     for (input_type, input_pat) in input_tys.iter().zip(input_pats.into_iter()) {\n@@ -534,7 +534,7 @@ fn find_implied_output_region(input_tys: &[Ty], input_pats: Vec<String>)\n \n fn convert_ty_with_lifetime_elision<'tcx>(this: &AstConv<'tcx>,\n                                           implied_output_region: Option<ty::Region>,\n-                                          param_lifetimes: Vec<(String, uint)>,\n+                                          param_lifetimes: Vec<(String, usize)>,\n                                           ty: &ast::Ty)\n                                           -> Ty<'tcx>\n {\n@@ -1401,15 +1401,15 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n             ty\n         }\n         ast::TyFixedLengthVec(ref ty, ref e) => {\n-            match const_eval::eval_const_expr_partial(tcx, &**e, Some(tcx.types.uint)) {\n+            match const_eval::eval_const_expr_partial(tcx, &**e, Some(tcx.types.usize)) {\n                 Ok(r) => {\n                     match r {\n                         const_eval::const_int(i) =>\n                             ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n-                                        Some(i as uint)),\n+                                        Some(i as usize)),\n                         const_eval::const_uint(i) =>\n                             ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n-                                        Some(i as uint)),\n+                                        Some(i as usize)),\n                         _ => {\n                             span_err!(tcx.sess, ast_ty.span, E0249,\n                                       \"expected constant expr for array length\");\n@@ -1666,7 +1666,7 @@ fn determine_explicit_self_category<'a, 'tcx>(this: &AstConv<'tcx>,\n         }\n     };\n \n-    fn count_modifiers(ty: Ty) -> uint {\n+    fn count_modifiers(ty: Ty) -> usize {\n         match ty.sty {\n             ty::ty_rptr(_, mt) => count_modifiers(mt.ty) + 1,\n             ty::ty_uniq(t) => count_modifiers(t) + 1,"}, {"sha": "49f4399b2c7b43b32638072928b096ef9be7a3b4", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -339,8 +339,8 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n     ty_root: ty::Ty<'tcx>,\n     span: Span,\n     scope: region::CodeExtent,\n-    depth: uint,\n-    xref_depth: uint) -> Result<(), Error<'tcx>>\n+    depth: usize,\n+    xref_depth: usize) -> Result<(), Error<'tcx>>\n {\n     // Issue #22443: Watch out for overflow. While we are careful to\n     // handle regular types properly, non-regular ones cause problems."}, {"sha": "930ba4ae03ef3ac6b512ce17af9134943f6a3292", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -58,7 +58,7 @@ pub enum CandidateSource {\n     TraitSource(/* trait id */ ast::DefId),\n }\n \n-type MethodIndex = uint; // just for doc purposes\n+type MethodIndex = usize; // just for doc purposes\n \n /// Determines whether the type `self_ty` supports a method name `method_name` or not.\n pub fn exists<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -334,7 +334,7 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                       trait_def_id: ast::DefId,\n                       method_name: ast::Name)\n-                      -> Option<(uint, Rc<ty::Method<'tcx>>)>\n+                      -> Option<(usize, Rc<ty::Method<'tcx>>)>\n {\n     let trait_items = ty::trait_items(tcx, trait_def_id);\n     trait_items"}, {"sha": "d1ebfe7d26edd27f5c787abb28e028446d5f1722", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -60,7 +60,7 @@ struct Candidate<'tcx> {\n \n enum CandidateKind<'tcx> {\n     InherentImplCandidate(/* Impl */ ast::DefId, subst::Substs<'tcx>),\n-    ObjectCandidate(/* Trait */ ast::DefId, /* method_num */ uint, /* vtable index */ uint),\n+    ObjectCandidate(/* Trait */ ast::DefId, /* method_num */ usize, /* vtable index */ usize),\n     ExtensionImplCandidate(/* Impl */ ast::DefId, Rc<ty::TraitRef<'tcx>>,\n                            subst::Substs<'tcx>, MethodIndex),\n     ClosureCandidate(/* Trait */ ast::DefId, MethodIndex),\n@@ -77,7 +77,7 @@ pub struct Pick<'tcx> {\n #[derive(Clone,Debug)]\n pub enum PickKind<'tcx> {\n     InherentImplPick(/* Impl */ ast::DefId),\n-    ObjectPick(/* Trait */ ast::DefId, /* method_num */ uint, /* real_index */ uint),\n+    ObjectPick(/* Trait */ ast::DefId, /* method_num */ usize, /* real_index */ usize),\n     ExtensionImplPick(/* Impl */ ast::DefId, MethodIndex),\n     TraitPick(/* Trait */ ast::DefId, MethodIndex),\n     WhereClausePick(/* Trait */ ty::PolyTraitRef<'tcx>, MethodIndex),\n@@ -94,14 +94,14 @@ pub enum PickAdjustment {\n     // Indicates that the source expression should be autoderef'd N times\n     //\n     // A = expr | *expr | **expr\n-    AutoDeref(uint),\n+    AutoDeref(usize),\n \n     // Indicates that the source expression should be autoderef'd N\n     // times and then \"unsized\". This should probably eventually go\n     // away in favor of just coercing method receivers.\n     //\n     // A = unsize(expr | *expr | **expr)\n-    AutoUnsizeLength(/* number of autoderefs */ uint, /* length*/ uint),\n+    AutoUnsizeLength(/* number of autoderefs */ usize, /* length*/ usize),\n \n     // Indicates that an autoref is applied after some number of other adjustments\n     //\n@@ -526,7 +526,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             &mut ProbeContext<'b, 'tcx>,\n             ty::PolyTraitRef<'tcx>,\n             Rc<ty::Method<'tcx>>,\n-            uint,\n+            usize,\n         ),\n     {\n         debug!(\"elaborate_bounds(bounds={})\", bounds.repr(self.tcx()));\n@@ -625,7 +625,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn assemble_extension_candidates_for_trait_impls(&mut self,\n                                                      trait_def_id: ast::DefId,\n                                                      method: Rc<ty::Method<'tcx>>,\n-                                                     method_index: uint)\n+                                                     method_index: usize)\n     {\n         ty::populate_implementations_for_trait_if_necessary(self.tcx(),\n                                                             trait_def_id);\n@@ -692,7 +692,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn assemble_closure_candidates(&mut self,\n                                    trait_def_id: ast::DefId,\n                                    method_ty: Rc<ty::Method<'tcx>>,\n-                                   method_index: uint)\n+                                   method_index: usize)\n                                    -> Result<(),MethodError>\n     {\n         // Check if this is one of the Fn,FnMut,FnOnce traits.\n@@ -754,7 +754,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn assemble_projection_candidates(&mut self,\n                                       trait_def_id: ast::DefId,\n                                       method: Rc<ty::Method<'tcx>>,\n-                                      method_index: uint)\n+                                      method_index: usize)\n     {\n         debug!(\"assemble_projection_candidates(\\\n                trait_def_id={}, \\\n@@ -815,7 +815,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn assemble_where_clause_candidates(&mut self,\n                                         trait_def_id: ast::DefId,\n                                         method_ty: Rc<ty::Method<'tcx>>,\n-                                        method_index: uint)\n+                                        method_index: usize)\n     {\n         debug!(\"assemble_where_clause_candidates(trait_def_id={})\",\n                trait_def_id.repr(self.tcx()));\n@@ -933,7 +933,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         return self.pick_method(step.self_ty).map(|r| self.adjust(r, adjustment.clone()));\n \n-        fn consider_reborrow<'tcx>(ty: Ty<'tcx>, d: uint) -> PickAdjustment {\n+        fn consider_reborrow<'tcx>(ty: Ty<'tcx>, d: usize) -> PickAdjustment {\n             // Insert a `&*` or `&mut *` if this is a reference type:\n             match ty.sty {\n                 ty::ty_rptr(_, ref mt) => AutoRef(mt.mutbl, box AutoDeref(d+1)),\n@@ -1100,7 +1100,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     /// ```\n     /// trait Foo { ... }\n     /// impl Foo for Vec<int> { ... }\n-    /// impl Foo for Vec<uint> { ... }\n+    /// impl Foo for Vec<usize> { ... }\n     /// ```\n     ///\n     /// Now imagine the receiver is `Vec<_>`. It doesn't really matter at this time which impl we\n@@ -1281,7 +1281,7 @@ fn impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                       trait_def_id: ast::DefId,\n                       method_name: ast::Name)\n-                      -> Option<(uint, Rc<ty::Method<'tcx>>)>\n+                      -> Option<(usize, Rc<ty::Method<'tcx>>)>\n {\n     let trait_items = ty::trait_items(tcx, trait_def_id);\n     debug!(\"trait_method; items: {:?}\", trait_items);"}, {"sha": "9b107c4227bfdaa28695fe66443384a851687bdf", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -310,7 +310,7 @@ pub struct FnCtxt<'a, 'tcx: 'a> {\n     // checking this function. On exit, if we find that *more* errors\n     // have been reported, we will skip regionck and other work that\n     // expects the types within the function to be consistent.\n-    err_count_on_creation: uint,\n+    err_count_on_creation: usize,\n \n     ret_ty: ty::FnOutput<'tcx>,\n \n@@ -468,7 +468,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, t: &'tcx ast::Ty) {\n         match t.node {\n             ast::TyFixedLengthVec(_, ref expr) => {\n-                check_const_in_type(self.ccx, &**expr, self.ccx.tcx.types.uint);\n+                check_const_in_type(self.ccx, &**expr, self.ccx.tcx.types.usize);\n             }\n             _ => {}\n         }\n@@ -612,7 +612,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n         match t.node {\n             ast::TyFixedLengthVec(ref ty, ref count_expr) => {\n                 self.visit_ty(&**ty);\n-                check_expr_with_hint(self.fcx, &**count_expr, self.fcx.tcx().types.uint);\n+                check_expr_with_hint(self.fcx, &**count_expr, self.fcx.tcx().types.usize);\n             }\n             _ => visit::walk_ty(self, t)\n         }\n@@ -1314,7 +1314,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self.tcx().sess\n     }\n \n-    pub fn err_count_since_creation(&self) -> uint {\n+    pub fn err_count_since_creation(&self) -> usize {\n         self.ccx.tcx.sess.err_count() - self.err_count_on_creation\n     }\n \n@@ -1437,7 +1437,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn write_autoderef_adjustment(&self,\n                                       node_id: ast::NodeId,\n                                       span: Span,\n-                                      derefs: uint) {\n+                                      derefs: usize) {\n         if derefs == 0 { return; }\n         self.write_adjustment(\n             node_id,\n@@ -1914,7 +1914,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                span: Span,\n                                class_id: ast::DefId,\n                                items: &[ty::field_ty],\n-                               idx: uint,\n+                               idx: usize,\n                                substs: &subst::Substs<'tcx>)\n                                -> Option<Ty<'tcx>>\n     {\n@@ -1945,8 +1945,8 @@ impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> {\n         Some(self.infcx().next_region_var(infer::MiscVariable(span)))\n     }\n \n-    fn anon_regions(&self, span: Span, count: uint)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>> {\n+    fn anon_regions(&self, span: Span, count: usize)\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>> {\n         Ok((0..count).map(|_| {\n             self.infcx().next_region_var(infer::MiscVariable(span))\n         }).collect())\n@@ -1982,8 +1982,8 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                  unresolved_type_action: UnresolvedTypeAction,\n                                  mut lvalue_pref: LvaluePreference,\n                                  mut should_stop: F)\n-                                 -> (Ty<'tcx>, uint, Option<T>)\n-    where F: FnMut(Ty<'tcx>, uint) -> Option<T>,\n+                                 -> (Ty<'tcx>, usize, Option<T>)\n+    where F: FnMut(Ty<'tcx>, usize) -> Option<T>,\n {\n     debug!(\"autoderef(base_ty={}, opt_expr={}, lvalue_pref={:?})\",\n            base_ty.repr(fcx.tcx()),\n@@ -2189,7 +2189,7 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         (Some(ty), &ty::ty_uint(ast::TyUs)) | (Some(ty), &ty::ty_infer(ty::IntVar(_))) => {\n             debug!(\"try_index_step: success, using built-in indexing\");\n             fcx.write_adjustment(base_expr.id, base_expr.span, ty::AdjustDerefRef(adjustment));\n-            return Some((tcx.types.uint, ty));\n+            return Some((tcx.types.usize, ty));\n         }\n         _ => {}\n     }\n@@ -2490,7 +2490,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n }\n \n // FIXME(#17596) Ty<'tcx> is incorrectly invariant w.r.t 'tcx.\n-fn err_args<'tcx>(tcx: &ty::ctxt<'tcx>, len: uint) -> Vec<Ty<'tcx>> {\n+fn err_args<'tcx>(tcx: &ty::ctxt<'tcx>, len: usize) -> Vec<Ty<'tcx>> {\n     (0..len).map(|_| tcx.types.err).collect()\n }\n \n@@ -2528,8 +2528,8 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 match ty.sty {\n                     ty::ty_int(_) | ty::ty_uint(_) => Some(ty),\n                     ty::ty_char => Some(tcx.types.u8),\n-                    ty::ty_ptr(..) => Some(tcx.types.uint),\n-                    ty::ty_bare_fn(..) => Some(tcx.types.uint),\n+                    ty::ty_ptr(..) => Some(tcx.types.usize),\n+                    ty::ty_bare_fn(..) => Some(tcx.types.usize),\n                     _ => None\n                 }\n             });\n@@ -2638,7 +2638,7 @@ pub enum AutorefArgs {\n /// passed as a single parameter. For example, if tupling is enabled, this\n /// function:\n ///\n-///     fn f(x: (int, int))\n+///     fn f(x: (isize, isize))\n ///\n /// Can be called as:\n ///\n@@ -2921,7 +2921,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             });\n \n         if ty::type_is_integral(lhs_t) && ast_util::is_shift_binop(op.node) {\n-            // Shift is a special case: rhs must be uint, no matter what lhs is\n+            // Shift is a special case: rhs must be usize, no matter what lhs is\n             check_expr(fcx, &**rhs);\n             let rhs_ty = fcx.expr_ty(&**rhs);\n             let rhs_ty = structurally_resolved_type(fcx, rhs.span, rhs_ty);\n@@ -3184,7 +3184,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                 expr: &'tcx ast::Expr,\n                                 lvalue_pref: LvaluePreference,\n                                 base: &'tcx ast::Expr,\n-                                idx: codemap::Spanned<uint>) {\n+                                idx: codemap::Spanned<usize>) {\n         let tcx = fcx.ccx.tcx;\n         check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n@@ -3834,7 +3834,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       ast::ExprCast(ref e, ref t) => {\n         if let ast::TyFixedLengthVec(_, ref count_expr) = t.node {\n-            check_expr_with_hint(fcx, &**count_expr, tcx.types.uint);\n+            check_expr_with_hint(fcx, &**count_expr, tcx.types.usize);\n         }\n \n         // Find the type of `e`. Supply hints based on the type we are casting to,\n@@ -3891,7 +3891,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_ty(id, typ);\n       }\n       ast::ExprRepeat(ref element, ref count_expr) => {\n-        check_expr_has_type(fcx, &**count_expr, tcx.types.uint);\n+        check_expr_has_type(fcx, &**count_expr, tcx.types.usize);\n         let count = ty::eval_repeat_count(fcx.tcx(), &**count_expr);\n \n         let uty = match expected {\n@@ -4199,16 +4199,16 @@ impl<'tcx> Expectation<'tcx> {\n     /// is useful in determining the concrete type.\n     ///\n     /// The primary use case is where the expected type is a fat pointer,\n-    /// like `&[int]`. For example, consider the following statement:\n+    /// like `&[isize]`. For example, consider the following statement:\n     ///\n-    ///    let x: &[int] = &[1, 2, 3];\n+    ///    let x: &[isize] = &[1, 2, 3];\n     ///\n     /// In this case, the expected type for the `&[1, 2, 3]` expression is\n-    /// `&[int]`. If however we were to say that `[1, 2, 3]` has the\n-    /// expectation `ExpectHasType([int])`, that would be too strong --\n-    /// `[1, 2, 3]` does not have the type `[int]` but rather `[int; 3]`.\n+    /// `&[isize]`. If however we were to say that `[1, 2, 3]` has the\n+    /// expectation `ExpectHasType([isize])`, that would be too strong --\n+    /// `[1, 2, 3]` does not have the type `[isize]` but rather `[isize; 3]`.\n     /// It is only the `&[1, 2, 3]` expression as a whole that can be coerced\n-    /// to the type `&[int]`. Therefore, we propagate this more limited hint,\n+    /// to the type `&[isize]`. Therefore, we propagate this more limited hint,\n     /// which still is useful, because it informs integer literals and the like.\n     /// See the test case `test/run-pass/coerce-expect-unsized.rs` and #20169\n     /// for examples of where this comes up,.\n@@ -4655,7 +4655,9 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                     let inh = static_inherited_fields(ccx);\n                     let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), e.id);\n                     let declty = match hint {\n-                        attr::ReprAny | attr::ReprPacked | attr::ReprExtern => fcx.tcx().types.int,\n+                        attr::ReprAny | attr::ReprPacked |\n+                        attr::ReprExtern => fcx.tcx().types.isize,\n+\n                         attr::ReprInt(_, attr::SignedInt(ity)) => {\n                             ty::mk_mach_int(fcx.tcx(), ity)\n                         }\n@@ -5324,7 +5326,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             match t.sty {\n                 ty::ty_param(ParamTy {idx, ..}) => {\n                     debug!(\"Found use of ty param num {}\", idx);\n-                    tps_used[idx as uint] = true;\n+                    tps_used[idx as usize] = true;\n                 }\n                 _ => ()\n             }\n@@ -5383,7 +5385,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n         let (n_tps, inputs, output) = match &name[..] {\n             \"breakpoint\" => (0, Vec::new(), ty::mk_nil(tcx)),\n             \"size_of\" |\n-            \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), ccx.tcx.types.uint),\n+            \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), ccx.tcx.types.usize),\n             \"init\" => (1, Vec::new(), param(ccx, 0)),\n             \"uninit\" => (1, Vec::new(), param(ccx, 0)),\n             \"forget\" => (1, vec!( param(ccx, 0) ), ty::mk_nil(tcx)),\n@@ -5412,7 +5414,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutImmutable\n                   }),\n-                  ccx.tcx.types.int\n+                  ccx.tcx.types.isize\n                ),\n                ty::mk_ptr(tcx, ty::mt {\n                    ty: param(ccx, 0),\n@@ -5431,7 +5433,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                       ty: param(ccx, 0),\n                       mutbl: ast::MutImmutable\n                   }),\n-                  tcx.types.uint,\n+                  tcx.types.usize,\n                ),\n                ty::mk_nil(tcx))\n             }\n@@ -5443,7 +5445,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                       mutbl: ast::MutMutable\n                   }),\n                   tcx.types.u8,\n-                  tcx.types.uint,\n+                  tcx.types.usize,\n                ),\n                ty::mk_nil(tcx))\n             }"}, {"sha": "3edea6d3004449b3e8d586902180feb24886e07c", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -319,7 +319,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     /// This method populates the region map's `free_region_map`. It walks over the transformed\n     /// argument and return types for each function just before we check the body of that function,\n     /// looking for types where you have a borrowed pointer to other borrowed data (e.g., `&'a &'b\n-    /// [uint]`.  We do not allow references to outlive the things they point at, so we can assume\n+    /// [usize]`.  We do not allow references to outlive the things they point at, so we can assume\n     /// that `'a <= 'b`. This holds for both the argument and return types, basically because, on\n     /// the caller side, the caller is responsible for checking that the type of every expression\n     /// (including the actual values for the arguments, as well as the return type of the fn call)\n@@ -862,7 +862,7 @@ fn constrain_call<'a, I: Iterator<Item=&'a ast::Expr>>(rcx: &mut Rcx,\n /// dereferenced, the lifetime of the pointer includes the deref expr.\n fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                   deref_expr: &ast::Expr,\n-                                  derefs: uint,\n+                                  derefs: usize,\n                                   mut derefd_ty: Ty<'tcx>)\n {\n     debug!(\"constrain_autoderefs(deref_expr={}, derefs={}, derefd_ty={})\",\n@@ -1118,7 +1118,7 @@ fn link_pattern<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n /// autoref'd.\n fn link_autoref(rcx: &Rcx,\n                 expr: &ast::Expr,\n-                autoderefs: uint,\n+                autoderefs: usize,\n                 autoref: &ty::AutoRef) {\n \n     debug!(\"link_autoref(autoref={:?})\", autoref);"}, {"sha": "d26d26557ab79cb355c3eb8df4346bdb7f17c5a2", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -528,7 +528,7 @@ pub struct BoundsChecker<'cx,'tcx:'cx> {\n     // has left it as a NodeId rather than porting to CodeExtent.\n     scope: ast::NodeId,\n \n-    binding_count: uint,\n+    binding_count: usize,\n     cache: Option<&'cx mut HashSet<Ty<'tcx>>>,\n }\n "}, {"sha": "e555d3085a4c7348fa4d3b2c176e8641e06c0a57", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -169,7 +169,7 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n         match t.node {\n             ast::TyFixedLengthVec(ref ty, ref count_expr) => {\n                 self.visit_ty(&**ty);\n-                write_ty_to_tcx(self.tcx(), count_expr.id, self.tcx().types.uint);\n+                write_ty_to_tcx(self.tcx(), count_expr.id, self.tcx().types.usize);\n             }\n             _ => visit::walk_ty(self, t)\n         }"}, {"sha": "91410fa808c78a8436c7d639ba2a78a1eabac0fb", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -79,7 +79,6 @@ This API is completely unstable and subject to change.\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(int_uint)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n@@ -281,10 +280,10 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 abi: abi::Rust,\n                 sig: ty::Binder(ty::FnSig {\n                     inputs: vec!(\n-                        tcx.types.int,\n+                        tcx.types.isize,\n                         ty::mk_imm_ptr(tcx, ty::mk_imm_ptr(tcx, tcx.types.u8))\n                     ),\n-                    output: ty::FnConverging(tcx.types.int),\n+                    output: ty::FnConverging(tcx.types.isize),\n                     variadic: false,\n                 }),\n             }));"}, {"sha": "f1050a936e276f480f5ff0f822432dafe4ba90de", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -29,8 +29,8 @@ use syntax::codemap::Span;\n pub trait RegionScope {\n     fn anon_regions(&self,\n                     span: Span,\n-                    count: uint)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>;\n+                    count: usize)\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>>;\n \n     /// If an object omits any explicit lifetime bound, and none can\n     /// be derived from the object traits, what should we use? If\n@@ -50,17 +50,17 @@ impl RegionScope for ExplicitRscope {\n \n     fn anon_regions(&self,\n                     _span: Span,\n-                    _count: uint)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>> {\n+                    _count: usize)\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>> {\n         Err(None)\n     }\n }\n \n // Same as `ExplicitRscope`, but provides some extra information for diagnostics\n-pub struct UnelidableRscope(Vec<(String, uint)>);\n+pub struct UnelidableRscope(Vec<(String, usize)>);\n \n impl UnelidableRscope {\n-    pub fn new(v: Vec<(String, uint)>) -> UnelidableRscope {\n+    pub fn new(v: Vec<(String, usize)>) -> UnelidableRscope {\n         UnelidableRscope(v)\n     }\n }\n@@ -72,8 +72,8 @@ impl RegionScope for UnelidableRscope {\n \n     fn anon_regions(&self,\n                     _span: Span,\n-                    _count: uint)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>> {\n+                    _count: usize)\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>> {\n         let UnelidableRscope(ref v) = *self;\n         Err(Some(v.clone()))\n     }\n@@ -103,8 +103,8 @@ impl RegionScope for ElidableRscope {\n \n     fn anon_regions(&self,\n                     _span: Span,\n-                    count: uint)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>\n+                    count: usize)\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>>\n     {\n         Ok(repeat(self.default).take(count).collect())\n     }\n@@ -140,8 +140,8 @@ impl RegionScope for BindingRscope {\n \n     fn anon_regions(&self,\n                     _: Span,\n-                    count: uint)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>\n+                    count: usize)\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>>\n     {\n         Ok((0..count).map(|_| self.next_region()).collect())\n     }\n@@ -176,8 +176,8 @@ impl<'r> RegionScope for ObjectLifetimeDefaultRscope<'r> {\n \n     fn anon_regions(&self,\n                     span: Span,\n-                    count: uint)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>\n+                    count: usize)\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>>\n     {\n         self.base_scope.anon_regions(span, count)\n     }\n@@ -203,8 +203,8 @@ impl<'r> RegionScope for ShiftedRscope<'r> {\n \n     fn anon_regions(&self,\n                     span: Span,\n-                    count: uint)\n-                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>\n+                    count: usize)\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, usize)>>>\n     {\n         match self.base_scope.anon_regions(span, count) {\n             Ok(mut v) => {"}, {"sha": "89b8d389f22a922cd23bc00943e3c4c6f960263b", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -296,7 +296,7 @@ pub fn infer_variance(tcx: &ty::ctxt) {\n type VarianceTermPtr<'a> = &'a VarianceTerm<'a>;\n \n #[derive(Copy, Debug)]\n-struct InferredIndex(uint);\n+struct InferredIndex(usize);\n \n #[derive(Copy)]\n enum VarianceTerm<'a> {\n@@ -346,7 +346,7 @@ struct InferredInfo<'a> {\n     item_id: ast::NodeId,\n     kind: ParamKind,\n     space: ParamSpace,\n-    index: uint,\n+    index: usize,\n     param_id: ast::NodeId,\n     term: VarianceTermPtr<'a>,\n \n@@ -457,7 +457,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n                     item_id: ast::NodeId,\n                     kind: ParamKind,\n                     space: ParamSpace,\n-                    index: uint,\n+                    index: usize,\n                     param_id: ast::NodeId) {\n         let inf_index = InferredIndex(self.inferred_infos.len());\n         let term = self.arena.alloc(InferredTerm(inf_index));\n@@ -488,7 +488,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n     fn pick_initial_variance(&self,\n                              item_id: ast::NodeId,\n                              space: ParamSpace,\n-                             index: uint)\n+                             index: usize)\n                              -> ty::Variance\n     {\n         match space {\n@@ -505,7 +505,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n         }\n     }\n \n-    fn num_inferred(&self) -> uint {\n+    fn num_inferred(&self) -> usize {\n         self.inferred_infos.len()\n     }\n }\n@@ -791,7 +791,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                          item_def_id: ast::DefId,\n                          kind: ParamKind,\n                          space: ParamSpace,\n-                         index: uint)\n+                         index: usize)\n                          -> VarianceTermPtr<'a> {\n         assert_eq!(param_def_id.krate, item_def_id.krate);\n \n@@ -977,7 +977,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::ty_param(ref data) => {\n-                let def_id = generics.types.get(data.space, data.idx as uint).def_id;\n+                let def_id = generics.types.get(data.space, data.idx as usize).def_id;\n                 assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n                 match self.terms_cx.inferred_map.get(&def_id.node) {\n                     Some(&index) => {\n@@ -1027,9 +1027,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         for p in type_param_defs {\n             let variance_decl =\n                 self.declared_variance(p.def_id, def_id, TypeParam,\n-                                       p.space, p.index as uint);\n+                                       p.space, p.index as usize);\n             let variance_i = self.xform(variance, variance_decl);\n-            let substs_ty = *substs.types.get(p.space, p.index as uint);\n+            let substs_ty = *substs.types.get(p.space, p.index as usize);\n             debug!(\"add_constraints_from_substs: variance_decl={:?} variance_i={:?}\",\n                    variance_decl, variance_i);\n             self.add_constraints_from_ty(generics, substs_ty, variance_i);\n@@ -1038,9 +1038,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         for p in region_param_defs {\n             let variance_decl =\n                 self.declared_variance(p.def_id, def_id,\n-                                       RegionParam, p.space, p.index as uint);\n+                                       RegionParam, p.space, p.index as usize);\n             let variance_i = self.xform(variance, variance_decl);\n-            let substs_r = *substs.regions().get(p.space, p.index as uint);\n+            let substs_r = *substs.regions().get(p.space, p.index as usize);\n             self.add_constraints_from_region(generics, substs_r, variance_i);\n         }\n     }"}, {"sha": "e4d9fac5b9cb53e5d90bb790ef877d10879efecc", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -1322,7 +1322,7 @@ pub enum Type {\n     /// For parameterized types, so the consumer of the JSON don't go\n     /// looking for types which don't exist anywhere.\n     Generic(String),\n-    /// Primitives are the fixed-size numeric types (plus int/uint/float), char,\n+    /// Primitives are the fixed-size numeric types (plus int/usize/float), char,\n     /// arrays, slices, and tuples.\n     Primitive(PrimitiveType),\n     /// extern \"ABI\" fn\n@@ -1383,12 +1383,12 @@ pub enum TypeKind {\n impl PrimitiveType {\n     fn from_str(s: &str) -> Option<PrimitiveType> {\n         match s {\n-            \"isize\" | \"int\" => Some(Isize),\n+            \"isize\" => Some(Isize),\n             \"i8\" => Some(I8),\n             \"i16\" => Some(I16),\n             \"i32\" => Some(I32),\n             \"i64\" => Some(I64),\n-            \"usize\" | \"uint\" => Some(Usize),\n+            \"usize\" => Some(Usize),\n             \"u8\" => Some(U8),\n             \"u16\" => Some(U16),\n             \"u32\" => Some(U32),\n@@ -1516,12 +1516,12 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n         match self.sty {\n             ty::ty_bool => Primitive(Bool),\n             ty::ty_char => Primitive(Char),\n-            ty::ty_int(ast::TyIs(_)) => Primitive(Isize),\n+            ty::ty_int(ast::TyIs) => Primitive(Isize),\n             ty::ty_int(ast::TyI8) => Primitive(I8),\n             ty::ty_int(ast::TyI16) => Primitive(I16),\n             ty::ty_int(ast::TyI32) => Primitive(I32),\n             ty::ty_int(ast::TyI64) => Primitive(I64),\n-            ty::ty_uint(ast::TyUs(_)) => Primitive(Usize),\n+            ty::ty_uint(ast::TyUs) => Primitive(Usize),\n             ty::ty_uint(ast::TyU8) => Primitive(U8),\n             ty::ty_uint(ast::TyU16) => Primitive(U16),\n             ty::ty_uint(ast::TyU32) => Primitive(U32),\n@@ -1833,10 +1833,10 @@ impl Clean<VariantKind> for ast::VariantKind {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Span {\n     pub filename: String,\n-    pub loline: uint,\n-    pub locol: uint,\n-    pub hiline: uint,\n-    pub hicol: uint,\n+    pub loline: usize,\n+    pub locol: usize,\n+    pub hiline: usize,\n+    pub hicol: usize,\n }\n \n impl Span {\n@@ -2399,12 +2399,12 @@ fn resolve_type(cx: &DocContext,\n             ast::TyStr => return Primitive(Str),\n             ast::TyBool => return Primitive(Bool),\n             ast::TyChar => return Primitive(Char),\n-            ast::TyInt(ast::TyIs(_)) => return Primitive(Isize),\n+            ast::TyInt(ast::TyIs) => return Primitive(Isize),\n             ast::TyInt(ast::TyI8) => return Primitive(I8),\n             ast::TyInt(ast::TyI16) => return Primitive(I16),\n             ast::TyInt(ast::TyI32) => return Primitive(I32),\n             ast::TyInt(ast::TyI64) => return Primitive(I64),\n-            ast::TyUint(ast::TyUs(_)) => return Primitive(Usize),\n+            ast::TyUint(ast::TyUs) => return Primitive(Usize),\n             ast::TyUint(ast::TyU8) => return Primitive(U8),\n             ast::TyUint(ast::TyU16) => return Primitive(U16),\n             ast::TyUint(ast::TyU32) => return Primitive(U32),"}, {"sha": "4e6db5e5cd1a9592781230a2623015490fd07454", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -185,7 +185,7 @@ fn stripped_filtered_line<'a>(s: &'a str) -> Option<&'a str> {\n     }\n }\n \n-thread_local!(static USED_HEADER_MAP: RefCell<HashMap<String, uint>> = {\n+thread_local!(static USED_HEADER_MAP: RefCell<HashMap<String, usize>> = {\n     RefCell::new(HashMap::new())\n });\n "}, {"sha": "6ea218368f1bb4b64e6a01bb8ff34a0c8eb60e11", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -498,7 +498,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::Result<String> {\n             try!(write!(&mut w, \",\"));\n         }\n         try!(write!(&mut w, r#\"[{},\"{}\",\"{}\",{}\"#,\n-                    item.ty as uint, item.name, path,\n+                    item.ty as usize, item.name, path,\n                     item.desc.to_json().to_string()));\n         match item.parent {\n             Some(nodeid) => {\n@@ -522,7 +522,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::Result<String> {\n             try!(write!(&mut w, \",\"));\n         }\n         try!(write!(&mut w, r#\"[{},\"{}\"]\"#,\n-                    short as uint, *fqp.last().unwrap()));\n+                    short as usize, *fqp.last().unwrap()));\n     }\n \n     try!(write!(&mut w, \"]}};\"));\n@@ -1572,7 +1572,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n \n     let mut indices = (0..items.len()).filter(|i| {\n         !cx.ignore_private_item(&items[*i])\n-    }).collect::<Vec<uint>>();\n+    }).collect::<Vec<usize>>();\n \n     // the order of item types in the listing\n     fn reorder(ty: ItemType) -> u8 {\n@@ -1593,7 +1593,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n         }\n     }\n \n-    fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: uint, idx2: uint) -> Ordering {\n+    fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: usize, idx2: usize) -> Ordering {\n         let ty1 = shortty(i1);\n         let ty2 = shortty(i2);\n         if ty1 == ty2 {"}, {"sha": "78feb6c77c45451f8f2df38420c850651825923c", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -33,7 +33,7 @@ pub struct Toc {\n }\n \n impl Toc {\n-    fn count_entries_with_level(&self, level: u32) -> uint {\n+    fn count_entries_with_level(&self, level: u32) -> usize {\n         self.entries.iter().filter(|e| e.level == level).count()\n     }\n }"}, {"sha": "14045ce9fc7e683776f63d999ee3be170d6a6e18", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -16,16 +16,15 @@\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-       html_root_url = \"http://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"http://play.rust-lang.org/\")]\n+   html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+   html_root_url = \"http://doc.rust-lang.org/nightly/\",\n+   html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n #![feature(exit_status)]\n-#![feature(int_uint)]\n #![feature(set_stdio)]\n #![feature(libc)]\n #![feature(old_path)]\n@@ -195,7 +194,7 @@ pub fn usage(argv0: &str) {\n                             &opts()));\n }\n \n-pub fn main_args(args: &[String]) -> int {\n+pub fn main_args(args: &[String]) -> isize {\n     let matches = match getopts::getopts(args.tail(), &opts()) {\n         Ok(m) => m,\n         Err(err) => {"}, {"sha": "a84da60b01831da1b6e7733ef105539a7d0dec0c", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -44,7 +44,7 @@ fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {\n /// Render `input` (e.g. \"foo.md\") into an HTML file in `output`\n /// (e.g. output = \"bar\" => \"bar/foo.html\").\n pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n-              external_html: &ExternalHtml, include_toc: bool) -> int {\n+              external_html: &ExternalHtml, include_toc: bool) -> isize {\n     let input_p = Path::new(input);\n     output.push(input_p.file_stem().unwrap());\n     output.set_extension(\"html\");\n@@ -140,7 +140,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n \n /// Run any tests/code examples in the markdown file `input`.\n pub fn test(input: &str, libs: SearchPaths, externs: core::Externs,\n-            mut test_args: Vec<String>) -> int {\n+            mut test_args: Vec<String>) -> isize {\n     let input_str = load_or_return!(input, 1, 2);\n \n     let mut collector = Collector::new(input.to_string(), libs, externs, true, false);"}, {"sha": "6d17627e0a78ceb97d9ba771068b01312e519d69", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -45,7 +45,7 @@ pub fn run(input: &str,\n            externs: core::Externs,\n            mut test_args: Vec<String>,\n            crate_name: Option<String>)\n-           -> int {\n+           -> isize {\n     let input_path = PathBuf::from(input);\n     let input = config::Input::File(input_path.clone());\n \n@@ -321,7 +321,7 @@ pub struct Collector {\n     names: Vec<String>,\n     libs: SearchPaths,\n     externs: core::Externs,\n-    cnt: uint,\n+    cnt: usize,\n     use_headers: bool,\n     current_header: Option<String>,\n     cratename: String,"}, {"sha": "dc44536d60cea0403a619e3a27f814926111a6b3", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -44,8 +44,8 @@ impl ToHex for [u8] {\n     fn to_hex(&self) -> String {\n         let mut v = Vec::with_capacity(self.len() * 2);\n         for &byte in self {\n-            v.push(CHARS[(byte >> 4) as uint]);\n-            v.push(CHARS[(byte & 0xf) as uint]);\n+            v.push(CHARS[(byte >> 4) as usize]);\n+            v.push(CHARS[(byte & 0xf) as usize]);\n         }\n \n         unsafe {\n@@ -65,7 +65,7 @@ pub trait FromHex {\n #[derive(Copy, Debug)]\n pub enum FromHexError {\n     /// The input contained a character not part of the hex format\n-    InvalidHexCharacter(char, uint),\n+    InvalidHexCharacter(char, usize),\n     /// The input had an invalid length\n     InvalidHexLength,\n }\n@@ -188,18 +188,18 @@ mod tests {\n     #[test]\n     pub fn test_to_hex_all_bytes() {\n         for i in 0..256 {\n-            assert_eq!([i as u8].to_hex(), format!(\"{:02x}\", i as uint));\n+            assert_eq!([i as u8].to_hex(), format!(\"{:02x}\", i as usize));\n         }\n     }\n \n     #[test]\n     pub fn test_from_hex_all_bytes() {\n         for i in 0..256 {\n             let ii: &[u8] = &[i as u8];\n-            assert_eq!(format!(\"{:02x}\", i as uint).from_hex()\n+            assert_eq!(format!(\"{:02x}\", i as usize).from_hex()\n                                                    .unwrap(),\n                        ii);\n-            assert_eq!(format!(\"{:02X}\", i as uint).from_hex()\n+            assert_eq!(format!(\"{:02X}\", i as usize).from_hex()\n                                                    .unwrap(),\n                        ii);\n         }"}, {"sha": "d4998b496d902f8c826b2696d4a3da03279425ee", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 98, "deletions": 98, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -233,7 +233,7 @@ pub type Object = BTreeMap<string::String, Json>;\n pub struct PrettyJson<'a> { inner: &'a Json }\n \n pub struct AsJson<'a, T: 'a> { inner: &'a T }\n-pub struct AsPrettyJson<'a, T: 'a> { inner: &'a T, indent: Option<uint> }\n+pub struct AsPrettyJson<'a, T: 'a> { inner: &'a T, indent: Option<usize> }\n \n /// The errors that can arise while parsing a JSON stream.\n #[derive(Clone, Copy, PartialEq, Debug)]\n@@ -260,7 +260,7 @@ pub enum ErrorCode {\n #[derive(Clone, PartialEq, Debug)]\n pub enum ParserError {\n     /// msg, line, col\n-    SyntaxError(ErrorCode, uint, uint),\n+    SyntaxError(ErrorCode, usize, usize),\n     IoError(io::ErrorKind, String),\n }\n \n@@ -441,7 +441,7 @@ fn escape_char(writer: &mut fmt::Write, v: char) -> EncodeResult {\n     escape_str(writer, buf)\n }\n \n-fn spaces(wr: &mut fmt::Write, mut n: uint) -> EncodeResult {\n+fn spaces(wr: &mut fmt::Write, mut n: usize) -> EncodeResult {\n     const BUF: &'static str = \"                \";\n \n     while n >= BUF.len() {\n@@ -498,13 +498,13 @@ impl<'a> ::Encoder for Encoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_uint(&mut self, v: uint) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_uint(&mut self, v: usize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u64(&mut self, v: u64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u32(&mut self, v: u32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u16(&mut self, v: u16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u8(&mut self, v: u8) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n \n-    fn emit_int(&mut self, v: int) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_int(&mut self, v: isize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i64(&mut self, v: i64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i32(&mut self, v: i32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i16(&mut self, v: i16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n@@ -542,8 +542,8 @@ impl<'a> ::Encoder for Encoder<'a> {\n \n     fn emit_enum_variant<F>(&mut self,\n                             name: &str,\n-                            _id: uint,\n-                            cnt: uint,\n+                            _id: usize,\n+                            cnt: usize,\n                             f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n@@ -563,7 +563,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n         }\n     }\n \n-    fn emit_enum_variant_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+    fn emit_enum_variant_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -575,8 +575,8 @@ impl<'a> ::Encoder for Encoder<'a> {\n \n     fn emit_enum_struct_variant<F>(&mut self,\n                                    name: &str,\n-                                   id: uint,\n-                                   cnt: uint,\n+                                   id: usize,\n+                                   cnt: usize,\n                                    f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n@@ -586,15 +586,15 @@ impl<'a> ::Encoder for Encoder<'a> {\n \n     fn emit_enum_struct_variant_field<F>(&mut self,\n                                          _: &str,\n-                                         idx: uint,\n+                                         idx: usize,\n                                          f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n-    fn emit_struct<F>(&mut self, _: &str, _: uint, f: F) -> EncodeResult where\n+    fn emit_struct<F>(&mut self, _: &str, _: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -604,7 +604,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_struct_field<F>(&mut self, name: &str, idx: uint, f: F) -> EncodeResult where\n+    fn emit_struct_field<F>(&mut self, name: &str, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -614,26 +614,26 @@ impl<'a> ::Encoder for Encoder<'a> {\n         f(self)\n     }\n \n-    fn emit_tuple<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+    fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+    fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_tuple_struct<F>(&mut self, _name: &str, len: uint, f: F) -> EncodeResult where\n+    fn emit_tuple_struct<F>(&mut self, _name: &str, len: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_struct_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+    fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -657,7 +657,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n         f(self)\n     }\n \n-    fn emit_seq<F>(&mut self, _len: uint, f: F) -> EncodeResult where\n+    fn emit_seq<F>(&mut self, _len: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -667,7 +667,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_seq_elt<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+    fn emit_seq_elt<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -677,7 +677,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n         f(self)\n     }\n \n-    fn emit_map<F>(&mut self, _len: uint, f: F) -> EncodeResult where\n+    fn emit_map<F>(&mut self, _len: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -687,7 +687,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_map_elt_key<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+    fn emit_map_elt_key<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -698,7 +698,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_map_elt_val<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n+    fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -711,8 +711,8 @@ impl<'a> ::Encoder for Encoder<'a> {\n /// compact data\n pub struct PrettyEncoder<'a> {\n     writer: &'a mut (fmt::Write+'a),\n-    curr_indent: uint,\n-    indent: uint,\n+    curr_indent: usize,\n+    indent: usize,\n     is_emitting_map_key: bool,\n }\n \n@@ -729,7 +729,7 @@ impl<'a> PrettyEncoder<'a> {\n \n     /// Set the number of spaces to indent for each level.\n     /// This is safe to set during encoding.\n-    pub fn set_indent(&mut self, indent: uint) {\n+    pub fn set_indent(&mut self, indent: usize) {\n         // self.indent very well could be 0 so we need to use checked division.\n         let level = self.curr_indent.checked_div(self.indent).unwrap_or(0);\n         self.indent = indent;\n@@ -746,13 +746,13 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_uint(&mut self, v: uint) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_uint(&mut self, v: usize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u64(&mut self, v: u64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u32(&mut self, v: u32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u16(&mut self, v: u16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u8(&mut self, v: u8) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n \n-    fn emit_int(&mut self, v: int) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_int(&mut self, v: isize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i64(&mut self, v: i64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i32(&mut self, v: i32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i16(&mut self, v: i16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n@@ -790,8 +790,8 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n \n     fn emit_enum_variant<F>(&mut self,\n                             name: &str,\n-                            _id: uint,\n-                            cnt: uint,\n+                            _id: usize,\n+                            cnt: usize,\n                             f: F)\n                             -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n@@ -821,7 +821,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n         }\n     }\n \n-    fn emit_enum_variant_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+    fn emit_enum_variant_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -834,8 +834,8 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n \n     fn emit_enum_struct_variant<F>(&mut self,\n                                    name: &str,\n-                                   id: uint,\n-                                   cnt: uint,\n+                                   id: usize,\n+                                   cnt: usize,\n                                    f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n@@ -845,7 +845,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n \n     fn emit_enum_struct_variant_field<F>(&mut self,\n                                          _: &str,\n-                                         idx: uint,\n+                                         idx: usize,\n                                          f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n@@ -854,7 +854,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     }\n \n \n-    fn emit_struct<F>(&mut self, _: &str, len: uint, f: F) -> EncodeResult where\n+    fn emit_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -872,7 +872,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_struct_field<F>(&mut self, name: &str, idx: uint, f: F) -> EncodeResult where\n+    fn emit_struct_field<F>(&mut self, name: &str, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -887,26 +887,26 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n         f(self)\n     }\n \n-    fn emit_tuple<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+    fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+    fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_tuple_struct<F>(&mut self, _: &str, len: uint, f: F) -> EncodeResult where\n+    fn emit_tuple_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_struct_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+    fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -930,7 +930,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n         f(self)\n     }\n \n-    fn emit_seq<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+    fn emit_seq<F>(&mut self, len: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -948,7 +948,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_seq_elt<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+    fn emit_seq_elt<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -961,7 +961,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n         f(self)\n     }\n \n-    fn emit_map<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+    fn emit_map<F>(&mut self, len: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -979,7 +979,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_map_elt_key<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+    fn emit_map_elt_key<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -995,7 +995,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_map_elt_val<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n+    fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n@@ -1237,25 +1237,25 @@ impl<'a> Index<&'a str>  for Json {\n }\n \n #[cfg(stage0)]\n-impl Index<uint> for Json {\n+impl Index<usize> for Json {\n     type Output = Json;\n \n-    fn index<'a>(&'a self, idx: &uint) -> &'a Json {\n+    fn index<'a>(&'a self, idx: &usize) -> &'a Json {\n         match self {\n             &Json::Array(ref v) => &v[*idx],\n-            _ => panic!(\"can only index Json with uint if it is an array\")\n+            _ => panic!(\"can only index Json with usize if it is an array\")\n         }\n     }\n }\n \n #[cfg(not(stage0))]\n-impl Index<uint> for Json {\n+impl Index<usize> for Json {\n     type Output = Json;\n \n-    fn index<'a>(&'a self, idx: uint) -> &'a Json {\n+    fn index<'a>(&'a self, idx: usize) -> &'a Json {\n         match self {\n             &Json::Array(ref v) => &v[idx],\n-            _ => panic!(\"can only index Json with uint if it is an array\")\n+            _ => panic!(\"can only index Json with usize if it is an array\")\n         }\n     }\n }\n@@ -1326,20 +1326,20 @@ impl Stack {\n     }\n \n     /// Returns The number of elements in the Stack.\n-    pub fn len(&self) -> uint { self.stack.len() }\n+    pub fn len(&self) -> usize { self.stack.len() }\n \n     /// Returns true if the stack is empty.\n     pub fn is_empty(&self) -> bool { self.stack.is_empty() }\n \n     /// Provides access to the StackElement at a given index.\n     /// lower indices are at the bottom of the stack while higher indices are\n     /// at the top.\n-    pub fn get<'l>(&'l self, idx: uint) -> StackElement<'l> {\n+    pub fn get<'l>(&'l self, idx: usize) -> StackElement<'l> {\n         match self.stack[idx] {\n             InternalIndex(i) => StackElement::Index(i),\n             InternalKey(start, size) => {\n                 StackElement::Key(str::from_utf8(\n-                    &self.str_buffer[start as uint .. start as uint + size as uint])\n+                    &self.str_buffer[start as usize .. start as usize + size as usize])\n                         .unwrap())\n             }\n         }\n@@ -1382,7 +1382,7 @@ impl Stack {\n             Some(&InternalIndex(i)) => Some(StackElement::Index(i)),\n             Some(&InternalKey(start, size)) => {\n                 Some(StackElement::Key(str::from_utf8(\n-                    &self.str_buffer[start as uint .. (start+size) as uint]\n+                    &self.str_buffer[start as usize .. (start+size) as usize]\n                 ).unwrap()))\n             }\n         }\n@@ -1406,7 +1406,7 @@ impl Stack {\n         assert!(!self.is_empty());\n         match *self.stack.last().unwrap() {\n             InternalKey(_, sz) => {\n-                let new_size = self.str_buffer.len() - sz as uint;\n+                let new_size = self.str_buffer.len() - sz as usize;\n                 self.str_buffer.truncate(new_size);\n             }\n             InternalIndex(_) => {}\n@@ -1439,8 +1439,8 @@ impl Stack {\n pub struct Parser<T> {\n     rdr: T,\n     ch: Option<char>,\n-    line: uint,\n-    col: uint,\n+    line: usize,\n+    col: usize,\n     // We maintain a stack representing where we are in the logical structure\n     // of the JSON stream.\n     stack: Stack,\n@@ -1625,7 +1625,7 @@ impl<T: Iterator<Item=char>> Parser<T> {\n             match self.ch_or_null() {\n                 c @ '0' ... '9' => {\n                     dec /= 10.0;\n-                    res += (((c as int) - ('0' as int)) as f64) * dec;\n+                    res += (((c as isize) - ('0' as isize)) as f64) * dec;\n                     self.bump();\n                 }\n                 _ => break,\n@@ -1657,7 +1657,7 @@ impl<T: Iterator<Item=char>> Parser<T> {\n             match self.ch_or_null() {\n                 c @ '0' ... '9' => {\n                     exp *= 10;\n-                    exp += (c as uint) - ('0' as uint);\n+                    exp += (c as usize) - ('0' as usize);\n \n                     self.bump();\n                 }\n@@ -1769,7 +1769,7 @@ impl<T: Iterator<Item=char>> Parser<T> {\n     // information to return a JsonEvent.\n     // Manages an internal state so that parsing can be interrupted and resumed.\n     // Also keeps track of the position in the logical structure of the json\n-    // stream int the form of a stack that can be queried by the user using the\n+    // stream isize the form of a stack that can be queried by the user using the\n     // stack() method.\n     fn parse(&mut self) -> JsonEvent {\n         loop {\n@@ -2150,7 +2150,7 @@ macro_rules! read_primitive {\n                     None => Err(ExpectedError(\"Number\".to_string(), format!(\"{}\", f))),\n                 },\n                 Json::F64(f) => Err(ExpectedError(\"Integer\".to_string(), format!(\"{}\", f))),\n-                // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n+                // re: #12967.. a type w/ numeric keys (ie HashMap<usize, V> etc)\n                 // is going to have a string here, as per JSON spec.\n                 Json::String(s) => match s.parse().ok() {\n                     Some(f) => Ok(f),\n@@ -2169,12 +2169,12 @@ impl ::Decoder for Decoder {\n         expect!(self.pop(), Null)\n     }\n \n-    read_primitive! { read_uint, uint }\n+    read_primitive! { read_uint, usize }\n     read_primitive! { read_u8, u8 }\n     read_primitive! { read_u16, u16 }\n     read_primitive! { read_u32, u32 }\n     read_primitive! { read_u64, u64 }\n-    read_primitive! { read_int, int }\n+    read_primitive! { read_int, isize }\n     read_primitive! { read_i8, i8 }\n     read_primitive! { read_i16, i16 }\n     read_primitive! { read_i32, i32 }\n@@ -2188,7 +2188,7 @@ impl ::Decoder for Decoder {\n             Json::U64(f) => Ok(f as f64),\n             Json::F64(f) => Ok(f),\n             Json::String(s) => {\n-                // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n+                // re: #12967.. a type w/ numeric keys (ie HashMap<usize, V> etc)\n                 // is going to have a string here, as per JSON spec.\n                 match s.parse().ok() {\n                     Some(f) => Ok(f),\n@@ -2229,7 +2229,7 @@ impl ::Decoder for Decoder {\n \n     fn read_enum_variant<T, F>(&mut self, names: &[&str],\n                                mut f: F) -> DecodeResult<T>\n-        where F: FnMut(&mut Decoder, uint) -> DecodeResult<T>,\n+        where F: FnMut(&mut Decoder, usize) -> DecodeResult<T>,\n     {\n         let name = match self.pop() {\n             Json::String(s) => s,\n@@ -2269,30 +2269,30 @@ impl ::Decoder for Decoder {\n         f(self, idx)\n     }\n \n-    fn read_enum_variant_arg<T, F>(&mut self, _idx: uint, f: F) -> DecodeResult<T> where\n+    fn read_enum_variant_arg<T, F>(&mut self, _idx: usize, f: F) -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n         f(self)\n     }\n \n     fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F) -> DecodeResult<T> where\n-        F: FnMut(&mut Decoder, uint) -> DecodeResult<T>,\n+        F: FnMut(&mut Decoder, usize) -> DecodeResult<T>,\n     {\n         self.read_enum_variant(names, f)\n     }\n \n \n     fn read_enum_struct_variant_field<T, F>(&mut self,\n                                          _name: &str,\n-                                         idx: uint,\n+                                         idx: usize,\n                                          f: F)\n                                          -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n         self.read_enum_variant_arg(idx, f)\n     }\n \n-    fn read_struct<T, F>(&mut self, _name: &str, _len: uint, f: F) -> DecodeResult<T> where\n+    fn read_struct<T, F>(&mut self, _name: &str, _len: usize, f: F) -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n         let value = try!(f(self));\n@@ -2302,7 +2302,7 @@ impl ::Decoder for Decoder {\n \n     fn read_struct_field<T, F>(&mut self,\n                                name: &str,\n-                               _idx: uint,\n+                               _idx: usize,\n                                f: F)\n                                -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n@@ -2328,7 +2328,7 @@ impl ::Decoder for Decoder {\n         Ok(value)\n     }\n \n-    fn read_tuple<T, F>(&mut self, tuple_len: uint, f: F) -> DecodeResult<T> where\n+    fn read_tuple<T, F>(&mut self, tuple_len: usize, f: F) -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n         self.read_seq(move |d, len| {\n@@ -2340,15 +2340,15 @@ impl ::Decoder for Decoder {\n         })\n     }\n \n-    fn read_tuple_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+    fn read_tuple_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n         self.read_seq_elt(idx, f)\n     }\n \n     fn read_tuple_struct<T, F>(&mut self,\n                                _name: &str,\n-                               len: uint,\n+                               len: usize,\n                                f: F)\n                                -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n@@ -2357,7 +2357,7 @@ impl ::Decoder for Decoder {\n     }\n \n     fn read_tuple_struct_arg<T, F>(&mut self,\n-                                   idx: uint,\n+                                   idx: usize,\n                                    f: F)\n                                    -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n@@ -2375,7 +2375,7 @@ impl ::Decoder for Decoder {\n     }\n \n     fn read_seq<T, F>(&mut self, f: F) -> DecodeResult<T> where\n-        F: FnOnce(&mut Decoder, uint) -> DecodeResult<T>,\n+        F: FnOnce(&mut Decoder, usize) -> DecodeResult<T>,\n     {\n         let array = try!(expect!(self.pop(), Array));\n         let len = array.len();\n@@ -2385,14 +2385,14 @@ impl ::Decoder for Decoder {\n         f(self, len)\n     }\n \n-    fn read_seq_elt<T, F>(&mut self, _idx: uint, f: F) -> DecodeResult<T> where\n+    fn read_seq_elt<T, F>(&mut self, _idx: usize, f: F) -> DecodeResult<T> where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n         f(self)\n     }\n \n     fn read_map<T, F>(&mut self, f: F) -> DecodeResult<T> where\n-        F: FnOnce(&mut Decoder, uint) -> DecodeResult<T>,\n+        F: FnOnce(&mut Decoder, usize) -> DecodeResult<T>,\n     {\n         let obj = try!(expect!(self.pop(), Object));\n         let len = obj.len();\n@@ -2403,13 +2403,13 @@ impl ::Decoder for Decoder {\n         f(self, len)\n     }\n \n-    fn read_map_elt_key<T, F>(&mut self, _idx: uint, f: F) -> DecodeResult<T> where\n+    fn read_map_elt_key<T, F>(&mut self, _idx: usize, f: F) -> DecodeResult<T> where\n        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n         f(self)\n     }\n \n-    fn read_map_elt_val<T, F>(&mut self, _idx: uint, f: F) -> DecodeResult<T> where\n+    fn read_map_elt_val<T, F>(&mut self, _idx: usize, f: F) -> DecodeResult<T> where\n        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n         f(self)\n@@ -2437,7 +2437,7 @@ macro_rules! to_json_impl_i64 {\n     )\n }\n \n-to_json_impl_i64! { int, i8, i16, i32, i64 }\n+to_json_impl_i64! { isize, i8, i16, i32, i64 }\n \n macro_rules! to_json_impl_u64 {\n     ($($t:ty), +) => (\n@@ -2450,7 +2450,7 @@ macro_rules! to_json_impl_u64 {\n     )\n }\n \n-to_json_impl_u64! { uint, u8, u16, u32, u64 }\n+to_json_impl_u64! { usize, u8, u16, u32, u64 }\n \n impl ToJson for Json {\n     fn to_json(&self) -> Json { self.clone() }\n@@ -2605,7 +2605,7 @@ impl<'a, T: Encodable> fmt::Display for AsJson<'a, T> {\n \n impl<'a, T> AsPrettyJson<'a, T> {\n     /// Set the indentation level for the emitted JSON\n-    pub fn indent(mut self, indent: uint) -> AsPrettyJson<'a, T> {\n+    pub fn indent(mut self, indent: usize) -> AsPrettyJson<'a, T> {\n         self.indent = Some(indent);\n         self\n     }\n@@ -2655,7 +2655,7 @@ mod tests {\n \n     #[derive(RustcDecodable, Eq, PartialEq, Debug)]\n     struct OptionData {\n-        opt: Option<uint>,\n+        opt: Option<usize>,\n     }\n \n     #[test]\n@@ -2683,13 +2683,13 @@ mod tests {\n     #[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n     enum Animal {\n         Dog,\n-        Frog(string::String, int)\n+        Frog(string::String, isize)\n     }\n \n     #[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n     struct Inner {\n         a: (),\n-        b: uint,\n+        b: usize,\n         c: Vec<string::String>,\n     }\n \n@@ -3113,30 +3113,30 @@ mod tests {\n         let v: Vec<bool> = super::decode(\"[true]\").unwrap();\n         assert_eq!(v, [true]);\n \n-        let v: Vec<int> = super::decode(\"[3, 1]\").unwrap();\n+        let v: Vec<isize> = super::decode(\"[3, 1]\").unwrap();\n         assert_eq!(v, [3, 1]);\n \n-        let v: Vec<Vec<uint>> = super::decode(\"[[3], [1, 2]]\").unwrap();\n+        let v: Vec<Vec<usize>> = super::decode(\"[[3], [1, 2]]\").unwrap();\n         assert_eq!(v, [vec![3], vec![1, 2]]);\n     }\n \n     #[test]\n     fn test_decode_tuple() {\n-        let t: (uint, uint, uint) = super::decode(\"[1, 2, 3]\").unwrap();\n+        let t: (usize, usize, usize) = super::decode(\"[1, 2, 3]\").unwrap();\n         assert_eq!(t, (1, 2, 3));\n \n-        let t: (uint, string::String) = super::decode(\"[1, \\\"two\\\"]\").unwrap();\n+        let t: (usize, string::String) = super::decode(\"[1, \\\"two\\\"]\").unwrap();\n         assert_eq!(t, (1, \"two\".to_string()));\n     }\n \n     #[test]\n     fn test_decode_tuple_malformed_types() {\n-        assert!(super::decode::<(uint, string::String)>(\"[1, 2]\").is_err());\n+        assert!(super::decode::<(usize, string::String)>(\"[1, 2]\").is_err());\n     }\n \n     #[test]\n     fn test_decode_tuple_malformed_length() {\n-        assert!(super::decode::<(uint, uint)>(\"[1, 2, 3]\").is_err());\n+        assert!(super::decode::<(usize, usize)>(\"[1, 2, 3]\").is_err());\n     }\n \n     #[test]\n@@ -3488,7 +3488,7 @@ mod tests {\n         use std::str::from_utf8;\n         use std::old_io::Writer;\n         use std::collections::HashMap;\n-        let mut hm: HashMap<uint, bool> = HashMap::new();\n+        let mut hm: HashMap<usize, bool> = HashMap::new();\n         hm.insert(1, true);\n         let mut mem_buf = Vec::new();\n         write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n@@ -3504,7 +3504,7 @@ mod tests {\n         use std::str::from_utf8;\n         use std::old_io::Writer;\n         use std::collections::HashMap;\n-        let mut hm: HashMap<uint, bool> = HashMap::new();\n+        let mut hm: HashMap<usize, bool> = HashMap::new();\n         hm.insert(1, true);\n         let mut mem_buf = Vec::new();\n         write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n@@ -3537,7 +3537,7 @@ mod tests {\n         );\n \n         // Helper function for counting indents\n-        fn indents(source: &str) -> uint {\n+        fn indents(source: &str) -> usize {\n             let trimmed = source.trim_left_matches(' ');\n             source.len() - trimmed.len()\n         }\n@@ -3595,7 +3595,7 @@ mod tests {\n             Ok(o) => o\n         };\n         let mut decoder = Decoder::new(json_obj);\n-        let _hm: HashMap<uint, bool> = Decodable::decode(&mut decoder).unwrap();\n+        let _hm: HashMap<usize, bool> = Decodable::decode(&mut decoder).unwrap();\n     }\n \n     #[test]\n@@ -3608,7 +3608,7 @@ mod tests {\n             Ok(o) => o\n         };\n         let mut decoder = Decoder::new(json_obj);\n-        let result: Result<HashMap<uint, bool>, DecoderError> = Decodable::decode(&mut decoder);\n+        let result: Result<HashMap<usize, bool>, DecoderError> = Decodable::decode(&mut decoder);\n         assert_eq!(result, Err(ExpectedError(\"Number\".to_string(), \"a\".to_string())));\n     }\n \n@@ -3971,14 +3971,14 @@ mod tests {\n         assert_eq!(hash_map.to_json(), object);\n         assert_eq!(Some(15).to_json(), I64(15));\n         assert_eq!(Some(15 as usize).to_json(), U64(15));\n-        assert_eq!(None::<int>.to_json(), Null);\n+        assert_eq!(None::<isize>.to_json(), Null);\n     }\n \n     #[test]\n     fn test_encode_hashmap_with_arbitrary_key() {\n         use std::collections::HashMap;\n         #[derive(PartialEq, Eq, Hash, RustcEncodable)]\n-        struct ArbitraryType(uint);\n+        struct ArbitraryType(usize);\n         let mut hm: HashMap<ArbitraryType, bool> = HashMap::new();\n         hm.insert(ArbitraryType(1), true);\n         let mut mem_buf = string::String::new();"}, {"sha": "b79323b3f962de18e5241780813d3fba3c188831", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -30,7 +30,6 @@ Core encoding and decoding interfaces.\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(int_uint)]\n #![feature(old_path)]\n #![feature(rustc_private)]\n #![feature(staged_api)]"}, {"sha": "81b5d4c5818b659d48b216d703f78c09fa3b4e56", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -26,12 +26,12 @@ pub trait Encoder {\n \n     // Primitive types:\n     fn emit_nil(&mut self) -> Result<(), Self::Error>;\n-    fn emit_uint(&mut self, v: uint) -> Result<(), Self::Error>;\n+    fn emit_uint(&mut self, v: usize) -> Result<(), Self::Error>;\n     fn emit_u64(&mut self, v: u64) -> Result<(), Self::Error>;\n     fn emit_u32(&mut self, v: u32) -> Result<(), Self::Error>;\n     fn emit_u16(&mut self, v: u16) -> Result<(), Self::Error>;\n     fn emit_u8(&mut self, v: u8) -> Result<(), Self::Error>;\n-    fn emit_int(&mut self, v: int) -> Result<(), Self::Error>;\n+    fn emit_int(&mut self, v: isize) -> Result<(), Self::Error>;\n     fn emit_i64(&mut self, v: i64) -> Result<(), Self::Error>;\n     fn emit_i32(&mut self, v: i32) -> Result<(), Self::Error>;\n     fn emit_i16(&mut self, v: i16) -> Result<(), Self::Error>;\n@@ -47,41 +47,41 @@ pub trait Encoder {\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n \n     fn emit_enum_variant<F>(&mut self, v_name: &str,\n-                            v_id: uint,\n-                            len: uint,\n+                            v_id: usize,\n+                            len: usize,\n                             f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_enum_variant_arg<F>(&mut self, a_idx: uint, f: F)\n+    fn emit_enum_variant_arg<F>(&mut self, a_idx: usize, f: F)\n                                 -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n \n     fn emit_enum_struct_variant<F>(&mut self, v_name: &str,\n-                                   v_id: uint,\n-                                   len: uint,\n+                                   v_id: usize,\n+                                   len: usize,\n                                    f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n     fn emit_enum_struct_variant_field<F>(&mut self,\n                                          f_name: &str,\n-                                         f_idx: uint,\n+                                         f_idx: usize,\n                                          f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n \n-    fn emit_struct<F>(&mut self, name: &str, len: uint, f: F)\n+    fn emit_struct<F>(&mut self, name: &str, len: usize, f: F)\n                       -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_struct_field<F>(&mut self, f_name: &str, f_idx: uint, f: F)\n+    fn emit_struct_field<F>(&mut self, f_name: &str, f_idx: usize, f: F)\n                             -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n \n-    fn emit_tuple<F>(&mut self, len: uint, f: F) -> Result<(), Self::Error>\n+    fn emit_tuple<F>(&mut self, len: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> Result<(), Self::Error>\n+    fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n \n-    fn emit_tuple_struct<F>(&mut self, name: &str, len: uint, f: F)\n+    fn emit_tuple_struct<F>(&mut self, name: &str, len: usize, f: F)\n                             -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_tuple_struct_arg<F>(&mut self, f_idx: uint, f: F)\n+    fn emit_tuple_struct_arg<F>(&mut self, f_idx: usize, f: F)\n                                 -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n \n@@ -92,16 +92,16 @@ pub trait Encoder {\n     fn emit_option_some<F>(&mut self, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n \n-    fn emit_seq<F>(&mut self, len: uint, f: F) -> Result<(), Self::Error>\n+    fn emit_seq<F>(&mut self, len: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_seq_elt<F>(&mut self, idx: uint, f: F) -> Result<(), Self::Error>\n+    fn emit_seq_elt<F>(&mut self, idx: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n \n-    fn emit_map<F>(&mut self, len: uint, f: F) -> Result<(), Self::Error>\n+    fn emit_map<F>(&mut self, len: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_map_elt_key<F>(&mut self, idx: uint, f: F) -> Result<(), Self::Error>\n+    fn emit_map_elt_key<F>(&mut self, idx: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n-    fn emit_map_elt_val<F>(&mut self, idx: uint, f: F) -> Result<(), Self::Error>\n+    fn emit_map_elt_val<F>(&mut self, idx: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n }\n \n@@ -110,12 +110,12 @@ pub trait Decoder {\n \n     // Primitive types:\n     fn read_nil(&mut self) -> Result<(), Self::Error>;\n-    fn read_uint(&mut self) -> Result<uint, Self::Error>;\n+    fn read_uint(&mut self) -> Result<usize, Self::Error>;\n     fn read_u64(&mut self) -> Result<u64, Self::Error>;\n     fn read_u32(&mut self) -> Result<u32, Self::Error>;\n     fn read_u16(&mut self) -> Result<u16, Self::Error>;\n     fn read_u8(&mut self) -> Result<u8, Self::Error>;\n-    fn read_int(&mut self) -> Result<int, Self::Error>;\n+    fn read_int(&mut self) -> Result<isize, Self::Error>;\n     fn read_i64(&mut self) -> Result<i64, Self::Error>;\n     fn read_i32(&mut self) -> Result<i32, Self::Error>;\n     fn read_i16(&mut self) -> Result<i16, Self::Error>;\n@@ -132,41 +132,41 @@ pub trait Decoder {\n \n     fn read_enum_variant<T, F>(&mut self, names: &[&str], f: F)\n                                -> Result<T, Self::Error>\n-        where F: FnMut(&mut Self, uint) -> Result<T, Self::Error>;\n-    fn read_enum_variant_arg<T, F>(&mut self, a_idx: uint, f: F)\n+        where F: FnMut(&mut Self, usize) -> Result<T, Self::Error>;\n+    fn read_enum_variant_arg<T, F>(&mut self, a_idx: usize, f: F)\n                                    -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n \n     fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F)\n                                       -> Result<T, Self::Error>\n-        where F: FnMut(&mut Self, uint) -> Result<T, Self::Error>;\n+        where F: FnMut(&mut Self, usize) -> Result<T, Self::Error>;\n     fn read_enum_struct_variant_field<T, F>(&mut self,\n                                             &f_name: &str,\n-                                            f_idx: uint,\n+                                            f_idx: usize,\n                                             f: F)\n                                             -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n \n-    fn read_struct<T, F>(&mut self, s_name: &str, len: uint, f: F)\n+    fn read_struct<T, F>(&mut self, s_name: &str, len: usize, f: F)\n                          -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n     fn read_struct_field<T, F>(&mut self,\n                                f_name: &str,\n-                               f_idx: uint,\n+                               f_idx: usize,\n                                f: F)\n                                -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n \n-    fn read_tuple<T, F>(&mut self, len: uint, f: F) -> Result<T, Self::Error>\n+    fn read_tuple<T, F>(&mut self, len: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n-    fn read_tuple_arg<T, F>(&mut self, a_idx: uint, f: F)\n+    fn read_tuple_arg<T, F>(&mut self, a_idx: usize, f: F)\n                             -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n \n-    fn read_tuple_struct<T, F>(&mut self, s_name: &str, len: uint, f: F)\n+    fn read_tuple_struct<T, F>(&mut self, s_name: &str, len: usize, f: F)\n                                -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n-    fn read_tuple_struct_arg<T, F>(&mut self, a_idx: uint, f: F)\n+    fn read_tuple_struct_arg<T, F>(&mut self, a_idx: usize, f: F)\n                                    -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n \n@@ -175,16 +175,16 @@ pub trait Decoder {\n         where F: FnMut(&mut Self, bool) -> Result<T, Self::Error>;\n \n     fn read_seq<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self, uint) -> Result<T, Self::Error>;\n-    fn read_seq_elt<T, F>(&mut self, idx: uint, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self, usize) -> Result<T, Self::Error>;\n+    fn read_seq_elt<T, F>(&mut self, idx: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n \n     fn read_map<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self, uint) -> Result<T, Self::Error>;\n-    fn read_map_elt_key<T, F>(&mut self, idx: uint, f: F)\n+        where F: FnOnce(&mut Self, usize) -> Result<T, Self::Error>;\n+    fn read_map_elt_key<T, F>(&mut self, idx: usize, f: F)\n                               -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n-    fn read_map_elt_val<T, F>(&mut self, idx: uint, f: F)\n+    fn read_map_elt_val<T, F>(&mut self, idx: usize, f: F)\n                               -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n \n@@ -200,14 +200,14 @@ pub trait Decodable {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error>;\n }\n \n-impl Encodable for uint {\n+impl Encodable for usize {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_uint(*self)\n     }\n }\n \n-impl Decodable for uint {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<uint, D::Error> {\n+impl Decodable for usize {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<usize, D::Error> {\n         d.read_uint()\n     }\n }\n@@ -260,14 +260,14 @@ impl Decodable for u64 {\n     }\n }\n \n-impl Encodable for int {\n+impl Encodable for isize {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_int(*self)\n     }\n }\n \n-impl Decodable for int {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<int, D::Error> {\n+impl Decodable for isize {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<isize, D::Error> {\n         d.read_int()\n     }\n }\n@@ -510,7 +510,7 @@ macro_rules! tuple {\n         impl<$($name:Decodable),*> Decodable for ($($name,)*) {\n             #[allow(non_snake_case)]\n             fn decode<D: Decoder>(d: &mut D) -> Result<($($name,)*), D::Error> {\n-                let len: uint = count_idents!($($name,)*);\n+                let len: usize = count_idents!($($name,)*);\n                 d.read_tuple(len, |d| {\n                     let mut i = 0;\n                     let ret = ($(try!(d.read_tuple_arg({ i+=1; i-1 },"}, {"sha": "76d7570bfed69b5f5d7baf80c49e3cce3da0708b", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -505,7 +505,7 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n     ///\n     /// ```\n     /// use std::collections::HashMap;\n-    /// let mut map: HashMap<&str, int> = HashMap::new();\n+    /// let mut map: HashMap<&str, isize> = HashMap::new();\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -519,7 +519,7 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n     ///\n     /// ```\n     /// use std::collections::HashMap;\n-    /// let mut map: HashMap<&str, int> = HashMap::with_capacity(10);\n+    /// let mut map: HashMap<&str, isize> = HashMap::with_capacity(10);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -596,7 +596,7 @@ impl<K, V, S> HashMap<K, V, S>\n     ///\n     /// ```\n     /// use std::collections::HashMap;\n-    /// let map: HashMap<int, int> = HashMap::with_capacity(100);\n+    /// let map: HashMap<isize, isize> = HashMap::with_capacity(100);\n     /// assert!(map.capacity() >= 100);\n     /// ```\n     #[inline]\n@@ -617,7 +617,7 @@ impl<K, V, S> HashMap<K, V, S>\n     ///\n     /// ```\n     /// use std::collections::HashMap;\n-    /// let mut map: HashMap<&str, int> = HashMap::new();\n+    /// let mut map: HashMap<&str, isize> = HashMap::new();\n     /// map.reserve(10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -725,7 +725,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     /// use std::collections::HashMap;\n     ///\n-    /// let mut map: HashMap<int, int> = HashMap::with_capacity(100);\n+    /// let mut map: HashMap<isize, isize> = HashMap::with_capacity(100);\n     /// map.insert(1, 2);\n     /// map.insert(3, 4);\n     /// assert!(map.capacity() >= 100);\n@@ -797,9 +797,9 @@ impl<K, V, S> HashMap<K, V, S>\n                 }\n             }\n \n-            let robin_ib = bucket.index() as int - bucket.distance() as int;\n+            let robin_ib = bucket.index() as isize - bucket.distance() as isize;\n \n-            if (ib as int) < robin_ib {\n+            if (ib as isize) < robin_ib {\n                 // Found a luckier bucket than me. Better steal his spot.\n                 return robin_hood(bucket, robin_ib as usize, hash, k, v);\n             }\n@@ -924,7 +924,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// map.insert(\"c\", 3);\n     ///\n     /// // Not possible with .iter()\n-    /// let vec: Vec<(&str, int)> = map.into_iter().collect();\n+    /// let vec: Vec<(&str, isize)> = map.into_iter().collect();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<K, V> {\n@@ -1188,9 +1188,9 @@ fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHas\n             }\n         }\n \n-        let robin_ib = bucket.index() as int - bucket.distance() as int;\n+        let robin_ib = bucket.index() as isize - bucket.distance() as isize;\n \n-        if (ib as int) < robin_ib {\n+        if (ib as isize) < robin_ib {\n             // Found a luckier bucket than me. Better steal his spot.\n             return Vacant(VacantEntry {\n                 hash: hash,\n@@ -1648,7 +1648,7 @@ mod test_map {\n         assert_eq!(*m.get(&2).unwrap(), 4);\n     }\n \n-    thread_local! { static DROP_VECTOR: RefCell<Vec<int>> = RefCell::new(Vec::new()) }\n+    thread_local! { static DROP_VECTOR: RefCell<Vec<isize>> = RefCell::new(Vec::new()) }\n \n     #[derive(Hash, PartialEq, Eq)]\n     struct Dropable {\n@@ -1805,7 +1805,7 @@ mod test_map {\n \n     #[test]\n     fn test_empty_pop() {\n-        let mut m: HashMap<int, bool> = HashMap::new();\n+        let mut m: HashMap<isize, bool> = HashMap::new();\n         assert_eq!(m.remove(&0), None);\n     }\n "}, {"sha": "8cc1dde98a0b8bd25178874dfda8da92742d7d46", "filename": "src/libstd/fs/tempdir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Ffs%2Ftempdir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Ffs%2Ftempdir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs%2Ftempdir.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -34,7 +34,7 @@ const NUM_RETRIES: u32 = 1 << 31;\n // be enough to dissuade an attacker from trying to preemptively create names\n // of that length, but not so huge that we unnecessarily drain the random number\n // generator of entropy.\n-const NUM_RAND_CHARS: uint = 12;\n+const NUM_RAND_CHARS: usize = 12;\n \n impl TempDir {\n     /// Attempts to make a temporary directory inside of `tmpdir` whose name"}, {"sha": "34d442e2fb5429ee2852a2469931ba5989857ca2", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -98,7 +98,7 @@ impl<R: Read> BufRead for BufReader<R> {\n         self.buf.fill_buf()\n     }\n \n-    fn consume(&mut self, amt: uint) {\n+    fn consume(&mut self, amt: usize) {\n         self.buf.consume(amt)\n     }\n }\n@@ -427,7 +427,7 @@ impl<S: Read + Write> BufStream<S> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: Read + Write> BufRead for BufStream<S> {\n     fn fill_buf(&mut self) -> io::Result<&[u8]> { self.inner.fill_buf() }\n-    fn consume(&mut self, amt: uint) { self.inner.consume(amt) }\n+    fn consume(&mut self, amt: usize) { self.inner.consume(amt) }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "5890a750f6edb7359d85b511846ce311121badb2", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -123,7 +123,6 @@\n #![feature(unsafe_destructor)]\n #![feature(unsafe_no_drop_flag)]\n #![feature(macro_reexport)]\n-#![feature(int_uint)]\n #![feature(unique)]\n #![feature(convert)]\n #![feature(allow_internal_unstable)]"}, {"sha": "dc1d53b8a3963f6d8f8623b9715f156b5f0f5057", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -91,27 +91,27 @@ impl Float for f32 {\n \n     #[allow(deprecated)]\n     #[inline]\n-    fn mantissa_digits(unused_self: Option<f32>) -> uint {\n+    fn mantissa_digits(unused_self: Option<f32>) -> usize {\n         num::Float::mantissa_digits(unused_self)\n     }\n     #[allow(deprecated)]\n     #[inline]\n-    fn digits(unused_self: Option<f32>) -> uint { num::Float::digits(unused_self) }\n+    fn digits(unused_self: Option<f32>) -> usize { num::Float::digits(unused_self) }\n     #[allow(deprecated)]\n     #[inline]\n     fn epsilon() -> f32 { num::Float::epsilon() }\n     #[allow(deprecated)]\n     #[inline]\n-    fn min_exp(unused_self: Option<f32>) -> int { num::Float::min_exp(unused_self) }\n+    fn min_exp(unused_self: Option<f32>) -> isize { num::Float::min_exp(unused_self) }\n     #[allow(deprecated)]\n     #[inline]\n-    fn max_exp(unused_self: Option<f32>) -> int { num::Float::max_exp(unused_self) }\n+    fn max_exp(unused_self: Option<f32>) -> isize { num::Float::max_exp(unused_self) }\n     #[allow(deprecated)]\n     #[inline]\n-    fn min_10_exp(unused_self: Option<f32>) -> int { num::Float::min_10_exp(unused_self) }\n+    fn min_10_exp(unused_self: Option<f32>) -> isize { num::Float::min_10_exp(unused_self) }\n     #[allow(deprecated)]\n     #[inline]\n-    fn max_10_exp(unused_self: Option<f32>) -> int { num::Float::max_10_exp(unused_self) }\n+    fn max_10_exp(unused_self: Option<f32>) -> isize { num::Float::max_10_exp(unused_self) }\n     #[allow(deprecated)]\n     #[inline]\n     fn min_value() -> f32 { num::Float::min_value() }\n@@ -201,11 +201,11 @@ impl Float for f32 {\n     /// - `self = x * pow(2, exp)`\n     /// - `0.5 <= abs(x) < 1.0`\n     #[inline]\n-    fn frexp(self) -> (f32, int) {\n+    fn frexp(self) -> (f32, isize) {\n         unsafe {\n             let mut exp = 0;\n             let x = cmath::frexpf(self, &mut exp);\n-            (x, exp as int)\n+            (x, exp as isize)\n         }\n     }\n \n@@ -476,7 +476,7 @@ impl f32 {\n                            `std::f64::MANTISSA_DIGITS` as appropriate\")]\n     #[allow(deprecated)]\n     #[inline]\n-    pub fn mantissa_digits(unused_self: Option<f32>) -> uint {\n+    pub fn mantissa_digits(unused_self: Option<f32>) -> usize {\n         num::Float::mantissa_digits(unused_self)\n     }\n \n@@ -486,7 +486,7 @@ impl f32 {\n                  reason = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\")]\n     #[allow(deprecated)]\n     #[inline]\n-    pub fn digits(unused_self: Option<f32>) -> uint { num::Float::digits(unused_self) }\n+    pub fn digits(unused_self: Option<f32>) -> usize { num::Float::digits(unused_self) }\n \n     /// Deprecated: use `std::f32::EPSILON` or `std::f64::EPSILON` instead.\n     #[unstable(feature = \"std_misc\")]\n@@ -502,31 +502,31 @@ impl f32 {\n                  reason = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\")]\n     #[allow(deprecated)]\n     #[inline]\n-    pub fn min_exp(unused_self: Option<f32>) -> int { num::Float::min_exp(unused_self) }\n+    pub fn min_exp(unused_self: Option<f32>) -> isize { num::Float::min_exp(unused_self) }\n \n     /// Deprecated: use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\")]\n     #[allow(deprecated)]\n     #[inline]\n-    pub fn max_exp(unused_self: Option<f32>) -> int { num::Float::max_exp(unused_self) }\n+    pub fn max_exp(unused_self: Option<f32>) -> isize { num::Float::max_exp(unused_self) }\n \n     /// Deprecated: use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\")]\n     #[allow(deprecated)]\n     #[inline]\n-    pub fn min_10_exp(unused_self: Option<f32>) -> int { num::Float::min_10_exp(unused_self) }\n+    pub fn min_10_exp(unused_self: Option<f32>) -> isize { num::Float::min_10_exp(unused_self) }\n \n     /// Deprecated: use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\")]\n     #[allow(deprecated)]\n     #[inline]\n-    pub fn max_10_exp(unused_self: Option<f32>) -> int { num::Float::max_10_exp(unused_self) }\n+    pub fn max_10_exp(unused_self: Option<f32>) -> isize { num::Float::max_10_exp(unused_self) }\n \n     /// Returns the smallest finite value that this type can represent.\n     ///\n@@ -1126,7 +1126,7 @@ impl f32 {\n     #[unstable(feature = \"std_misc\",\n                reason = \"pending integer conventions\")]\n     #[inline]\n-    pub fn ldexp(x: f32, exp: int) -> f32 {\n+    pub fn ldexp(x: f32, exp: isize) -> f32 {\n         unsafe { cmath::ldexpf(x, exp as c_int) }\n     }\n \n@@ -1153,11 +1153,11 @@ impl f32 {\n     #[unstable(feature = \"std_misc\",\n                reason = \"pending integer conventions\")]\n     #[inline]\n-    pub fn frexp(self) -> (f32, int) {\n+    pub fn frexp(self) -> (f32, isize) {\n         unsafe {\n             let mut exp = 0;\n             let x = cmath::frexpf(self, &mut exp);\n-            (x, exp as int)\n+            (x, exp as isize)\n         }\n     }\n \n@@ -1681,7 +1681,7 @@ pub fn to_str_radix_special(num: f32, rdx: u32) -> (String, bool) {\n /// * digits - The number of significant digits\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exact(num: f32, dig: uint) -> String {\n+pub fn to_str_exact(num: f32, dig: usize) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10, true, SignNeg, DigExact(dig), ExpNone, false);\n     r\n@@ -1696,7 +1696,7 @@ pub fn to_str_exact(num: f32, dig: uint) -> String {\n /// * digits - The number of significant digits\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_digits(num: f32, dig: uint) -> String {\n+pub fn to_str_digits(num: f32, dig: usize) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10, true, SignNeg, DigMax(dig), ExpNone, false);\n     r\n@@ -1712,7 +1712,7 @@ pub fn to_str_digits(num: f32, dig: uint) -> String {\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> String {\n+pub fn to_str_exp_exact(num: f32, dig: usize, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10, true, SignNeg, DigExact(dig), ExpDec, upper);\n     r\n@@ -1728,7 +1728,7 @@ pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> String {\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String {\n+pub fn to_str_exp_digits(num: f32, dig: usize, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10, true, SignNeg, DigMax(dig), ExpDec, upper);\n     r"}, {"sha": "41ce9a2598c44a63cd673f1ce0f67f484c7a00a3", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -101,27 +101,27 @@ impl Float for f64 {\n \n     #[allow(deprecated)]\n     #[inline]\n-    fn mantissa_digits(unused_self: Option<f64>) -> uint {\n+    fn mantissa_digits(unused_self: Option<f64>) -> usize {\n         num::Float::mantissa_digits(unused_self)\n     }\n     #[allow(deprecated)]\n     #[inline]\n-    fn digits(unused_self: Option<f64>) -> uint { num::Float::digits(unused_self) }\n+    fn digits(unused_self: Option<f64>) -> usize { num::Float::digits(unused_self) }\n     #[allow(deprecated)]\n     #[inline]\n     fn epsilon() -> f64 { num::Float::epsilon() }\n     #[allow(deprecated)]\n     #[inline]\n-    fn min_exp(unused_self: Option<f64>) -> int { num::Float::min_exp(unused_self) }\n+    fn min_exp(unused_self: Option<f64>) -> isize { num::Float::min_exp(unused_self) }\n     #[allow(deprecated)]\n     #[inline]\n-    fn max_exp(unused_self: Option<f64>) -> int { num::Float::max_exp(unused_self) }\n+    fn max_exp(unused_self: Option<f64>) -> isize { num::Float::max_exp(unused_self) }\n     #[allow(deprecated)]\n     #[inline]\n-    fn min_10_exp(unused_self: Option<f64>) -> int { num::Float::min_10_exp(unused_self) }\n+    fn min_10_exp(unused_self: Option<f64>) -> isize { num::Float::min_10_exp(unused_self) }\n     #[allow(deprecated)]\n     #[inline]\n-    fn max_10_exp(unused_self: Option<f64>) -> int { num::Float::max_10_exp(unused_self) }\n+    fn max_10_exp(unused_self: Option<f64>) -> isize { num::Float::max_10_exp(unused_self) }\n     #[allow(deprecated)]\n     #[inline]\n     fn min_value() -> f64 { num::Float::min_value() }\n@@ -210,11 +210,11 @@ impl Float for f64 {\n     /// - `self = x * pow(2, exp)`\n     /// - `0.5 <= abs(x) < 1.0`\n     #[inline]\n-    fn frexp(self) -> (f64, int) {\n+    fn frexp(self) -> (f64, isize) {\n         unsafe {\n             let mut exp = 0;\n             let x = cmath::frexp(self, &mut exp);\n-            (x, exp as int)\n+            (x, exp as isize)\n         }\n     }\n \n@@ -485,7 +485,7 @@ impl f64 {\n                            `std::f64::MANTISSA_DIGITS` as appropriate\")]\n     #[allow(deprecated)]\n     #[inline]\n-    pub fn mantissa_digits(unused_self: Option<f64>) -> uint {\n+    pub fn mantissa_digits(unused_self: Option<f64>) -> usize {\n         num::Float::mantissa_digits(unused_self)\n     }\n \n@@ -495,7 +495,7 @@ impl f64 {\n                  reason = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\")]\n     #[allow(deprecated)]\n     #[inline]\n-    pub fn digits(unused_self: Option<f64>) -> uint { num::Float::digits(unused_self) }\n+    pub fn digits(unused_self: Option<f64>) -> usize { num::Float::digits(unused_self) }\n \n     /// Deprecated: use `std::f32::EPSILON` or `std::f64::EPSILON` instead.\n     #[unstable(feature = \"std_misc\")]\n@@ -511,31 +511,31 @@ impl f64 {\n                  reason = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\")]\n     #[allow(deprecated)]\n     #[inline]\n-    pub fn min_exp(unused_self: Option<f64>) -> int { num::Float::min_exp(unused_self) }\n+    pub fn min_exp(unused_self: Option<f64>) -> isize { num::Float::min_exp(unused_self) }\n \n     /// Deprecated: use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\")]\n     #[allow(deprecated)]\n     #[inline]\n-    pub fn max_exp(unused_self: Option<f64>) -> int { num::Float::max_exp(unused_self) }\n+    pub fn max_exp(unused_self: Option<f64>) -> isize { num::Float::max_exp(unused_self) }\n \n     /// Deprecated: use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\")]\n     #[allow(deprecated)]\n     #[inline]\n-    pub fn min_10_exp(unused_self: Option<f64>) -> int { num::Float::min_10_exp(unused_self) }\n+    pub fn min_10_exp(unused_self: Option<f64>) -> isize { num::Float::min_10_exp(unused_self) }\n \n     /// Deprecated: use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` instead.\n     #[unstable(feature = \"std_misc\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\")]\n     #[allow(deprecated)]\n     #[inline]\n-    pub fn max_10_exp(unused_self: Option<f64>) -> int { num::Float::max_10_exp(unused_self) }\n+    pub fn max_10_exp(unused_self: Option<f64>) -> isize { num::Float::max_10_exp(unused_self) }\n \n     /// Returns the smallest finite value that this type can represent.\n     ///\n@@ -1134,7 +1134,7 @@ impl f64 {\n     #[unstable(feature = \"std_misc\",\n                reason = \"pending integer conventions\")]\n     #[inline]\n-    pub fn ldexp(x: f64, exp: int) -> f64 {\n+    pub fn ldexp(x: f64, exp: isize) -> f64 {\n         unsafe { cmath::ldexp(x, exp as c_int) }\n     }\n \n@@ -1161,11 +1161,11 @@ impl f64 {\n     #[unstable(feature = \"std_misc\",\n                reason = \"pending integer conventions\")]\n     #[inline]\n-    pub fn frexp(self) -> (f64, int) {\n+    pub fn frexp(self) -> (f64, isize) {\n         unsafe {\n             let mut exp = 0;\n             let x = cmath::frexp(self, &mut exp);\n-            (x, exp as int)\n+            (x, exp as isize)\n         }\n     }\n \n@@ -1687,7 +1687,7 @@ pub fn to_str_radix_special(num: f64, rdx: u32) -> (String, bool) {\n /// * digits - The number of significant digits\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exact(num: f64, dig: uint) -> String {\n+pub fn to_str_exact(num: f64, dig: usize) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10, true, SignNeg, DigExact(dig), ExpNone, false);\n     r\n@@ -1702,7 +1702,7 @@ pub fn to_str_exact(num: f64, dig: uint) -> String {\n /// * digits - The number of significant digits\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_digits(num: f64, dig: uint) -> String {\n+pub fn to_str_digits(num: f64, dig: usize) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10, true, SignNeg, DigMax(dig), ExpNone, false);\n     r\n@@ -1718,7 +1718,7 @@ pub fn to_str_digits(num: f64, dig: uint) -> String {\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> String {\n+pub fn to_str_exp_exact(num: f64, dig: usize, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10, true, SignNeg, DigExact(dig), ExpDec, upper);\n     r\n@@ -1734,7 +1734,7 @@ pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> String {\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n #[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n-pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String {\n+pub fn to_str_exp_digits(num: f64, dig: usize, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10, true, SignNeg, DigMax(dig), ExpDec, upper);\n     r"}, {"sha": "1c1aaeb6d535a1519660af80f08b0158aa7032b3", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -49,10 +49,10 @@ pub enum SignificantDigits {\n \n     /// At most the given number of digits will be printed, truncating any\n     /// trailing zeroes.\n-    DigMax(uint),\n+    DigMax(usize),\n \n     /// Precisely the given number of digits will be printed.\n-    DigExact(uint)\n+    DigExact(usize)\n }\n \n /// How to emit the sign of a number.\n@@ -87,7 +87,7 @@ pub enum SignFormat {\n /// # Panics\n ///\n /// - Panics if `radix` < 2 or `radix` > 36.\n-fn int_to_str_bytes_common<T, F>(num: T, radix: uint, sign: SignFormat, mut f: F) where\n+fn int_to_str_bytes_common<T, F>(num: T, radix: usize, sign: SignFormat, mut f: F) where\n     T: Int,\n     F: FnMut(u8),\n {\n@@ -216,7 +216,7 @@ pub fn float_to_str_bytes_common<T: Float>(\n \n     let neg = num < _0 || (negative_zero && _1 / num == Float::neg_infinity());\n     let mut buf = Vec::new();\n-    let radix_gen: T = num::cast(radix as int).unwrap();\n+    let radix_gen: T = num::cast(radix as isize).unwrap();\n \n     let (num, exp) = match exp_format {\n         ExpNone => (num, 0),\n@@ -328,28 +328,28 @@ pub fn float_to_str_bytes_common<T: Float>(\n \n             let extra_digit = ascii2value(buf.pop().unwrap());\n             if extra_digit >= radix / 2 { // -> need to round\n-                let mut i: int = buf.len() as int - 1;\n+                let mut i: isize = buf.len() as isize - 1;\n                 loop {\n                     // If reached left end of number, have to\n                     // insert additional digit:\n                     if i < 0\n-                    || buf[i as uint] == b'-'\n-                    || buf[i as uint] == b'+' {\n-                        buf.insert((i + 1) as uint, value2ascii(1));\n+                    || buf[i as usize] == b'-'\n+                    || buf[i as usize] == b'+' {\n+                        buf.insert((i + 1) as usize, value2ascii(1));\n                         break;\n                     }\n \n                     // Skip the '.'\n-                    if buf[i as uint] == b'.' { i -= 1; continue; }\n+                    if buf[i as usize] == b'.' { i -= 1; continue; }\n \n                     // Either increment the digit,\n                     // or set to 0 if max and carry the 1.\n-                    let current_digit = ascii2value(buf[i as uint]);\n+                    let current_digit = ascii2value(buf[i as usize]);\n                     if current_digit < (radix - 1) {\n-                        buf[i as uint] = value2ascii(current_digit+1);\n+                        buf[i as usize] = value2ascii(current_digit+1);\n                         break;\n                     } else {\n-                        buf[i as uint] = value2ascii(0);\n+                        buf[i as usize] = value2ascii(0);\n                         i -= 1;\n                     }\n                 }\n@@ -461,85 +461,85 @@ mod bench {\n     #![allow(deprecated)] // rand\n     extern crate test;\n \n-    mod uint {\n+    mod usize {\n         use super::test::Bencher;\n         use rand::{weak_rng, Rng};\n         use std::fmt;\n \n         #[inline]\n-        fn to_string(x: uint, base: u8) {\n+        fn to_string(x: usize, base: u8) {\n             format!(\"{}\", fmt::radix(x, base));\n         }\n \n         #[bench]\n         fn to_str_bin(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { to_string(rng.gen::<uint>(), 2); })\n+            b.iter(|| { to_string(rng.gen::<usize>(), 2); })\n         }\n \n         #[bench]\n         fn to_str_oct(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { to_string(rng.gen::<uint>(), 8); })\n+            b.iter(|| { to_string(rng.gen::<usize>(), 8); })\n         }\n \n         #[bench]\n         fn to_str_dec(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { to_string(rng.gen::<uint>(), 10); })\n+            b.iter(|| { to_string(rng.gen::<usize>(), 10); })\n         }\n \n         #[bench]\n         fn to_str_hex(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { to_string(rng.gen::<uint>(), 16); })\n+            b.iter(|| { to_string(rng.gen::<usize>(), 16); })\n         }\n \n         #[bench]\n         fn to_str_base_36(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { to_string(rng.gen::<uint>(), 36); })\n+            b.iter(|| { to_string(rng.gen::<usize>(), 36); })\n         }\n     }\n \n-    mod int {\n+    mod isize {\n         use super::test::Bencher;\n         use rand::{weak_rng, Rng};\n         use std::fmt;\n \n         #[inline]\n-        fn to_string(x: int, base: u8) {\n+        fn to_string(x: isize, base: u8) {\n             format!(\"{}\", fmt::radix(x, base));\n         }\n \n         #[bench]\n         fn to_str_bin(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { to_string(rng.gen::<int>(), 2); })\n+            b.iter(|| { to_string(rng.gen::<isize>(), 2); })\n         }\n \n         #[bench]\n         fn to_str_oct(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { to_string(rng.gen::<int>(), 8); })\n+            b.iter(|| { to_string(rng.gen::<isize>(), 8); })\n         }\n \n         #[bench]\n         fn to_str_dec(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { to_string(rng.gen::<int>(), 10); })\n+            b.iter(|| { to_string(rng.gen::<isize>(), 10); })\n         }\n \n         #[bench]\n         fn to_str_hex(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { to_string(rng.gen::<int>(), 16); })\n+            b.iter(|| { to_string(rng.gen::<isize>(), 16); })\n         }\n \n         #[bench]\n         fn to_str_base_36(b: &mut Bencher) {\n             let mut rng = weak_rng();\n-            b.iter(|| { to_string(rng.gen::<int>(), 36); })\n+            b.iter(|| { to_string(rng.gen::<isize>(), 36); })\n         }\n     }\n "}, {"sha": "085ec78b565958b947f582b614fc77b7817e5ceb", "filename": "src/libstd/old_io/buffered.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fbuffered.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -49,8 +49,8 @@ use vec::Vec;\n pub struct BufferedReader<R> {\n     inner: R,\n     buf: Vec<u8>,\n-    pos: uint,\n-    cap: uint,\n+    pos: usize,\n+    cap: usize,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -63,7 +63,7 @@ impl<R> fmt::Debug for BufferedReader<R> where R: fmt::Debug {\n \n impl<R: Reader> BufferedReader<R> {\n     /// Creates a new `BufferedReader` with the specified buffer capacity\n-    pub fn with_capacity(cap: uint, inner: R) -> BufferedReader<R> {\n+    pub fn with_capacity(cap: usize, inner: R) -> BufferedReader<R> {\n         BufferedReader {\n             inner: inner,\n             // We can't use the same trick here as we do for BufferedWriter,\n@@ -104,14 +104,14 @@ impl<R: Reader> Buffer for BufferedReader<R> {\n         Ok(&self.buf[self.pos..self.cap])\n     }\n \n-    fn consume(&mut self, amt: uint) {\n+    fn consume(&mut self, amt: usize) {\n         self.pos += amt;\n         assert!(self.pos <= self.cap);\n     }\n }\n \n impl<R: Reader> Reader for BufferedReader<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         if self.pos == self.cap && buf.len() >= self.buf.len() {\n             return self.inner.read(buf);\n         }\n@@ -151,7 +151,7 @@ impl<R: Reader> Reader for BufferedReader<R> {\n pub struct BufferedWriter<W: Writer> {\n     inner: Option<W>,\n     buf: Vec<u8>,\n-    pos: uint\n+    pos: usize\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -164,7 +164,7 @@ impl<W: Writer> fmt::Debug for BufferedWriter<W> where W: fmt::Debug {\n \n impl<W: Writer> BufferedWriter<W> {\n     /// Creates a new `BufferedWriter` with the specified buffer capacity\n-    pub fn with_capacity(cap: uint, inner: W) -> BufferedWriter<W> {\n+    pub fn with_capacity(cap: usize, inner: W) -> BufferedWriter<W> {\n         // It's *much* faster to create an uninitialized buffer than it is to\n         // fill everything in with 0. This buffer is entirely an implementation\n         // detail and is never exposed, so we're safe to not initialize\n@@ -309,7 +309,7 @@ impl<W: Writer> InternalBufferedWriter<W> {\n }\n \n impl<W: Reader + Writer> Reader for InternalBufferedWriter<W> {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         self.get_mut().inner.as_mut().unwrap().read(buf)\n     }\n }\n@@ -362,7 +362,7 @@ impl<S: Writer> fmt::Debug for BufferedStream<S> where S: fmt::Debug {\n impl<S: Stream> BufferedStream<S> {\n     /// Creates a new buffered stream with explicitly listed capacities for the\n     /// reader/writer buffer.\n-    pub fn with_capacities(reader_cap: uint, writer_cap: uint, inner: S)\n+    pub fn with_capacities(reader_cap: usize, writer_cap: usize, inner: S)\n                            -> BufferedStream<S> {\n         let writer = BufferedWriter::with_capacity(writer_cap, inner);\n         let internal_writer = InternalBufferedWriter(writer);\n@@ -407,11 +407,11 @@ impl<S: Stream> BufferedStream<S> {\n \n impl<S: Stream> Buffer for BufferedStream<S> {\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> { self.inner.fill_buf() }\n-    fn consume(&mut self, amt: uint) { self.inner.consume(amt) }\n+    fn consume(&mut self, amt: usize) { self.inner.consume(amt) }\n }\n \n impl<S: Stream> Reader for BufferedStream<S> {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         self.inner.read(buf)\n     }\n }\n@@ -442,7 +442,7 @@ mod test {\n     pub struct NullStream;\n \n     impl Reader for NullStream {\n-        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<uint> {\n+        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<usize> {\n             Err(old_io::standard_error(old_io::EndOfFile))\n         }\n     }\n@@ -453,11 +453,11 @@ mod test {\n \n     /// A dummy reader intended at testing short-reads propagation.\n     pub struct ShortReader {\n-        lengths: Vec<uint>,\n+        lengths: Vec<usize>,\n     }\n \n     impl Reader for ShortReader {\n-        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<uint> {\n+        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<usize> {\n             if self.lengths.is_empty() {\n                 Err(old_io::standard_error(old_io::EndOfFile))\n             } else {\n@@ -565,7 +565,7 @@ mod test {\n         }\n \n         impl old_io::Reader for S {\n-            fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<uint> {\n+            fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<usize> {\n                 Err(old_io::standard_error(old_io::EndOfFile))\n             }\n         }"}, {"sha": "35bc58fecd282f3b6fc6886984bb89e13ce692d6", "filename": "src/libstd/old_io/comm_adapters.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -39,7 +39,7 @@ use vec::Vec;\n /// ```\n pub struct ChanReader {\n     buf: Vec<u8>,          // A buffer of bytes received but not consumed.\n-    pos: uint,             // How many of the buffered bytes have already be consumed.\n+    pos: usize,             // How many of the buffered bytes have already be consumed.\n     rx: Receiver<Vec<u8>>, // The Receiver to pull data from.\n     closed: bool,          // Whether the channel this Receiver connects to has been closed.\n }\n@@ -77,14 +77,14 @@ impl Buffer for ChanReader {\n         }\n     }\n \n-    fn consume(&mut self, amt: uint) {\n+    fn consume(&mut self, amt: usize) {\n         self.pos += amt;\n         assert!(self.pos <= self.buf.len());\n     }\n }\n \n impl Reader for ChanReader {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         let mut num_read = 0;\n         loop {\n             let count = match self.fill_buf().ok() {"}, {"sha": "441f0a7536e14139000ee6a78c0dcb31213cc2ad", "filename": "src/libstd/old_io/extensions.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fextensions.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -81,7 +81,7 @@ impl<'r, R: Reader> Iterator for Bytes<'r, R> {\n /// * `f`: A callback that receives the value.\n ///\n /// This function returns the value returned by the callback, for convenience.\n-pub fn u64_to_le_bytes<T, F>(n: u64, size: uint, f: F) -> T where\n+pub fn u64_to_le_bytes<T, F>(n: u64, size: usize, f: F) -> T where\n     F: FnOnce(&[u8]) -> T,\n {\n     use mem::transmute;\n@@ -122,7 +122,7 @@ pub fn u64_to_le_bytes<T, F>(n: u64, size: uint, f: F) -> T where\n /// * `f`: A callback that receives the value.\n ///\n /// This function returns the value returned by the callback, for convenience.\n-pub fn u64_to_be_bytes<T, F>(n: u64, size: uint, f: F) -> T where\n+pub fn u64_to_be_bytes<T, F>(n: u64, size: usize, f: F) -> T where\n     F: FnOnce(&[u8]) -> T,\n {\n     use mem::transmute;\n@@ -158,7 +158,7 @@ pub fn u64_to_be_bytes<T, F>(n: u64, size: uint, f: F) -> T where\n ///           less, or task panic occurs. If this is less than 8, then only\n ///           that many bytes are parsed. For example, if `size` is 4, then a\n ///           32-bit value is parsed.\n-pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n+pub fn u64_from_be_bytes(data: &[u8], start: usize, size: usize) -> u64 {\n     use ptr::{copy_nonoverlapping};\n \n     assert!(size <= 8);\n@@ -169,9 +169,9 @@ pub fn u64_from_be_bytes(data: &[u8], start: uint, size: uint) -> u64 {\n \n     let mut buf = [0; 8];\n     unsafe {\n-        let ptr = data.as_ptr().offset(start as int);\n+        let ptr = data.as_ptr().offset(start as isize);\n         let out = buf.as_mut_ptr();\n-        copy_nonoverlapping(out.offset((8 - size) as int), ptr, size);\n+        copy_nonoverlapping(out.offset((8 - size) as isize), ptr, size);\n         (*(out as *const u64)).to_be()\n     }\n }\n@@ -183,11 +183,11 @@ mod test {\n     use old_io::{MemReader, BytesReader};\n \n     struct InitialZeroByteReader {\n-        count: int,\n+        count: isize,\n     }\n \n     impl Reader for InitialZeroByteReader {\n-        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n             if self.count == 0 {\n                 self.count = 1;\n                 Ok(0)\n@@ -201,25 +201,25 @@ mod test {\n     struct EofReader;\n \n     impl Reader for EofReader {\n-        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<uint> {\n+        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<usize> {\n             Err(old_io::standard_error(old_io::EndOfFile))\n         }\n     }\n \n     struct ErroringReader;\n \n     impl Reader for ErroringReader {\n-        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<uint> {\n+        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<usize> {\n             Err(old_io::standard_error(old_io::InvalidInput))\n         }\n     }\n \n     struct PartialReader {\n-        count: int,\n+        count: isize,\n     }\n \n     impl Reader for PartialReader {\n-        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n             if self.count == 0 {\n                 self.count = 1;\n                 buf[0] = 10;\n@@ -234,11 +234,11 @@ mod test {\n     }\n \n     struct ErroringLaterReader {\n-        count: int,\n+        count: isize,\n     }\n \n     impl Reader for ErroringLaterReader {\n-        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n             if self.count == 0 {\n                 self.count = 1;\n                 buf[0] = 10;\n@@ -250,11 +250,11 @@ mod test {\n     }\n \n     struct ThreeChunkReader {\n-        count: int,\n+        count: isize,\n     }\n \n     impl Reader for ThreeChunkReader {\n-        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n             if self.count == 0 {\n                 self.count = 1;\n                 buf[0] = 10;"}, {"sha": "9ce8e53f6e9bdd0eb8cbca4f664a7a03538b5f7f", "filename": "src/libstd/old_io/fs.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ffs.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -88,7 +88,7 @@ use sys_common;\n pub struct File {\n     fd: fs_imp::FileDesc,\n     path: Path,\n-    last_nread: int,\n+    last_nread: isize,\n }\n \n impl sys_common::AsInner<fs_imp::FileDesc> for File {\n@@ -472,14 +472,14 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::set_permissions\")]\n #[unstable(feature = \"old_io\")]\n pub fn chmod(path: &Path, mode: old_io::FilePermission) -> IoResult<()> {\n-    fs_imp::chmod(path, mode.bits() as uint)\n+    fs_imp::chmod(path, mode.bits() as usize)\n            .update_err(\"couldn't chmod path\", |e|\n                format!(\"{}; path={}; mode={:?}\", e, path.display(), mode))\n }\n \n /// Change the user and group owners of a file at the specified path.\n #[unstable(feature = \"old_fs\")]\n-pub fn chown(path: &Path, uid: int, gid: int) -> IoResult<()> {\n+pub fn chown(path: &Path, uid: isize, gid: isize) -> IoResult<()> {\n     fs_imp::chown(path, uid, gid)\n            .update_err(\"couldn't chown path\", |e|\n                format!(\"{}; path={}; uid={}; gid={}\", e, path.display(), uid, gid))\n@@ -541,7 +541,7 @@ pub fn readlink(path: &Path) -> IoResult<Path> {\n /// new directory at the provided `path`, or if the directory already exists.\n #[unstable(feature = \"old_fs\")]\n pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n-    fs_imp::mkdir(path, mode.bits() as uint)\n+    fs_imp::mkdir(path, mode.bits() as usize)\n            .update_err(\"couldn't create directory\", |e|\n                format!(\"{}; path={}; mode={}\", e, path.display(), mode))\n }\n@@ -773,7 +773,7 @@ pub fn change_file_times(path: &Path, atime: u64, mtime: u64) -> IoResult<()> {\n }\n \n impl Reader for File {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         fn update_err<T>(result: IoResult<T>, file: &File) -> IoResult<T> {\n             result.update_err(\"couldn't read file\",\n                               |e| format!(\"{}; path={}\",\n@@ -784,10 +784,10 @@ impl Reader for File {\n \n         match result {\n             Ok(read) => {\n-                self.last_nread = read as int;\n+                self.last_nread = read as isize;\n                 match read {\n                     0 => update_err(Err(standard_error(old_io::EndOfFile)), self),\n-                    _ => Ok(read as uint)\n+                    _ => Ok(read as usize)\n                 }\n             },\n             Err(e) => Err(e)\n@@ -1227,8 +1227,8 @@ mod test {\n             let stem = f.filestem_str().unwrap();\n             let root = stem.as_bytes()[0] - b'0';\n             let name = stem.as_bytes()[1] - b'0';\n-            assert!(cur[root as uint] < name);\n-            cur[root as uint] = name;\n+            assert!(cur[root as usize] < name);\n+            cur[root as usize] = name;\n         }\n \n         check!(rmdir_recursive(dir));"}, {"sha": "b84515c62f6fc69eafa9b98f064dab6cb3d586cc", "filename": "src/libstd/old_io/mem.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -20,9 +20,9 @@ use old_io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n use slice;\n use vec::Vec;\n \n-const BUF_CAPACITY: uint = 128;\n+const BUF_CAPACITY: usize = 128;\n \n-fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64> {\n+fn combine(seek: SeekStyle, cur: usize, end: usize, offset: i64) -> IoResult<u64> {\n     // compute offset as signed and clamp to prevent overflow\n     let pos = match seek {\n         old_io::SeekSet => 0,\n@@ -82,7 +82,7 @@ impl MemWriter {\n     /// Create a new `MemWriter`, allocating at least `n` bytes for\n     /// the internal buffer.\n     #[inline]\n-    pub fn with_capacity(n: uint) -> MemWriter {\n+    pub fn with_capacity(n: usize) -> MemWriter {\n         MemWriter::from_vec(Vec::with_capacity(n))\n     }\n     /// Create a new `MemWriter` that will append to an existing `Vec`.\n@@ -125,7 +125,7 @@ impl Writer for MemWriter {\n /// ```\n pub struct MemReader {\n     buf: Vec<u8>,\n-    pos: uint\n+    pos: usize\n }\n \n impl MemReader {\n@@ -160,7 +160,7 @@ impl MemReader {\n \n impl Reader for MemReader {\n     #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         if self.eof() { return Err(old_io::standard_error(old_io::EndOfFile)) }\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n@@ -184,7 +184,7 @@ impl Seek for MemReader {\n     #[inline]\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n         let new = try!(combine(style, self.pos, self.buf.len(), pos));\n-        self.pos = new as uint;\n+        self.pos = new as usize;\n         Ok(())\n     }\n }\n@@ -200,12 +200,12 @@ impl Buffer for MemReader {\n     }\n \n     #[inline]\n-    fn consume(&mut self, amt: uint) { self.pos += amt; }\n+    fn consume(&mut self, amt: usize) { self.pos += amt; }\n }\n \n impl<'a> Reader for &'a [u8] {\n     #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         if self.is_empty() { return Err(old_io::standard_error(old_io::EndOfFile)); }\n \n         let write_len = min(buf.len(), self.len());\n@@ -232,7 +232,7 @@ impl<'a> Buffer for &'a [u8] {\n     }\n \n     #[inline]\n-    fn consume(&mut self, amt: uint) {\n+    fn consume(&mut self, amt: usize) {\n         *self = &self[amt..];\n     }\n }\n@@ -259,7 +259,7 @@ impl<'a> Buffer for &'a [u8] {\n /// ```\n pub struct BufWriter<'a> {\n     buf: &'a mut [u8],\n-    pos: uint\n+    pos: usize\n }\n \n impl<'a> BufWriter<'a> {\n@@ -309,7 +309,7 @@ impl<'a> Seek for BufWriter<'a> {\n     #[inline]\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n         let new = try!(combine(style, self.pos, self.buf.len(), pos));\n-        self.pos = min(new as uint, self.buf.len());\n+        self.pos = min(new as usize, self.buf.len());\n         Ok(())\n     }\n }\n@@ -330,7 +330,7 @@ impl<'a> Seek for BufWriter<'a> {\n /// ```\n pub struct BufReader<'a> {\n     buf: &'a [u8],\n-    pos: uint\n+    pos: usize\n }\n \n impl<'a> BufReader<'a> {\n@@ -352,7 +352,7 @@ impl<'a> BufReader<'a> {\n \n impl<'a> Reader for BufReader<'a> {\n     #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         if self.eof() { return Err(old_io::standard_error(old_io::EndOfFile)) }\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n@@ -376,7 +376,7 @@ impl<'a> Seek for BufReader<'a> {\n     #[inline]\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n         let new = try!(combine(style, self.pos, self.buf.len(), pos));\n-        self.pos = new as uint;\n+        self.pos = new as usize;\n         Ok(())\n     }\n }\n@@ -392,7 +392,7 @@ impl<'a> Buffer for BufReader<'a> {\n     }\n \n     #[inline]\n-    fn consume(&mut self, amt: uint) { self.pos += amt; }\n+    fn consume(&mut self, amt: usize) { self.pos += amt; }\n }\n \n #[cfg(test)]\n@@ -663,7 +663,7 @@ mod test {\n         assert_eq!(buf, b);\n     }\n \n-    fn do_bench_mem_writer(b: &mut Bencher, times: uint, len: uint) {\n+    fn do_bench_mem_writer(b: &mut Bencher, times: usize, len: usize) {\n         let src: Vec<u8> = repeat(5).take(len).collect();\n \n         b.bytes = (times * len) as u64;"}, {"sha": "1bbd602b18af479d4e06303eabbda988c1de197d", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -326,7 +326,7 @@ pub mod test;\n /// The default buffer size for various I/O operations\n // libuv recommends 64k buffers to maximize throughput\n // https://groups.google.com/forum/#!topic/libuv/oQO1HJAIDdA\n-const DEFAULT_BUF_SIZE: uint = 1024 * 64;\n+const DEFAULT_BUF_SIZE: usize = 1024 * 64;\n \n /// A convenient typedef of the return value of any I/O action.\n pub type IoResult<T> = Result<T, IoError>;\n@@ -441,7 +441,7 @@ pub enum IoErrorKind {\n     ///\n     /// The payload contained as part of this variant is the number of bytes\n     /// which are known to have been successfully written.\n-    ShortWrite(uint),\n+    ShortWrite(usize),\n     /// The Reader returned 0 bytes from `read()` too many times.\n     NoProgress,\n }\n@@ -483,7 +483,7 @@ impl<T> UpdateIoError for IoResult<T> {\n     }\n }\n \n-static NO_PROGRESS_LIMIT: uint = 1000;\n+static NO_PROGRESS_LIMIT: usize = 1000;\n \n /// A trait for objects which are byte-oriented streams. Readers are defined by\n /// one method, `read`. This function will block until data is available,\n@@ -511,7 +511,7 @@ pub trait Reader {\n     ///\n     /// When implementing this method on a new Reader, you are strongly encouraged\n     /// not to return 0 if you can avoid it.\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint>;\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize>;\n \n     // Convenient helper methods based on the above methods\n \n@@ -526,7 +526,7 @@ pub trait Reader {\n     ///\n     /// If an error occurs at any point, that error is returned, and no further\n     /// bytes are read.\n-    fn read_at_least(&mut self, min: uint, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read_at_least(&mut self, min: usize, buf: &mut [u8]) -> IoResult<usize> {\n         if min > buf.len() {\n             return Err(IoError {\n                 detail: Some(String::from_str(\"the buffer is too short\")),\n@@ -570,7 +570,7 @@ pub trait Reader {\n     ///\n     /// If an error occurs during this I/O operation, then it is returned\n     /// as `Err(IoError)`. See `read()` for more details.\n-    fn push(&mut self, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> {\n+    fn push(&mut self, len: usize, buf: &mut Vec<u8>) -> IoResult<usize> {\n         let start_len = buf.len();\n         buf.reserve(len);\n \n@@ -594,7 +594,7 @@ pub trait Reader {\n     ///\n     /// If an error occurs at any point, that error is returned, and no further\n     /// bytes are read.\n-    fn push_at_least(&mut self, min: uint, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> {\n+    fn push_at_least(&mut self, min: usize, len: usize, buf: &mut Vec<u8>) -> IoResult<usize> {\n         if min > len {\n             return Err(IoError {\n                 detail: Some(String::from_str(\"the buffer is too short\")),\n@@ -629,7 +629,7 @@ pub trait Reader {\n     /// have already been consumed from the underlying reader, and they are lost\n     /// (not returned as part of the error). If this is unacceptable, then it is\n     /// recommended to use the `push_at_least` or `read` methods.\n-    fn read_exact(&mut self, len: uint) -> IoResult<Vec<u8>> {\n+    fn read_exact(&mut self, len: usize) -> IoResult<Vec<u8>> {\n         let mut buf = Vec::with_capacity(len);\n         match self.push_at_least(len, len, &mut buf) {\n             Ok(_) => Ok(buf),\n@@ -679,7 +679,7 @@ pub trait Reader {\n     /// Reads `n` little-endian unsigned integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    fn read_le_uint_n(&mut self, nbytes: uint) -> IoResult<u64> {\n+    fn read_le_uint_n(&mut self, nbytes: usize) -> IoResult<u64> {\n         assert!(nbytes > 0 && nbytes <= 8);\n \n         let mut val = 0;\n@@ -696,14 +696,14 @@ pub trait Reader {\n     /// Reads `n` little-endian signed integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    fn read_le_int_n(&mut self, nbytes: uint) -> IoResult<i64> {\n+    fn read_le_int_n(&mut self, nbytes: usize) -> IoResult<i64> {\n         self.read_le_uint_n(nbytes).map(|i| extend_sign(i, nbytes))\n     }\n \n     /// Reads `n` big-endian unsigned integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    fn read_be_uint_n(&mut self, nbytes: uint) -> IoResult<u64> {\n+    fn read_be_uint_n(&mut self, nbytes: usize) -> IoResult<u64> {\n         assert!(nbytes > 0 && nbytes <= 8);\n \n         let mut val = 0;\n@@ -718,36 +718,36 @@ pub trait Reader {\n     /// Reads `n` big-endian signed integer bytes.\n     ///\n     /// `n` must be between 1 and 8, inclusive.\n-    fn read_be_int_n(&mut self, nbytes: uint) -> IoResult<i64> {\n+    fn read_be_int_n(&mut self, nbytes: usize) -> IoResult<i64> {\n         self.read_be_uint_n(nbytes).map(|i| extend_sign(i, nbytes))\n     }\n \n     /// Reads a little-endian unsigned integer.\n     ///\n     /// The number of bytes returned is system-dependent.\n-    fn read_le_uint(&mut self) -> IoResult<uint> {\n-        self.read_le_uint_n(usize::BYTES as usize).map(|i| i as uint)\n+    fn read_le_uint(&mut self) -> IoResult<usize> {\n+        self.read_le_uint_n(usize::BYTES as usize).map(|i| i as usize)\n     }\n \n     /// Reads a little-endian integer.\n     ///\n     /// The number of bytes returned is system-dependent.\n-    fn read_le_int(&mut self) -> IoResult<int> {\n-        self.read_le_int_n(isize::BYTES as usize).map(|i| i as int)\n+    fn read_le_int(&mut self) -> IoResult<isize> {\n+        self.read_le_int_n(isize::BYTES as usize).map(|i| i as isize)\n     }\n \n     /// Reads a big-endian unsigned integer.\n     ///\n     /// The number of bytes returned is system-dependent.\n-    fn read_be_uint(&mut self) -> IoResult<uint> {\n-        self.read_be_uint_n(usize::BYTES as usize).map(|i| i as uint)\n+    fn read_be_uint(&mut self) -> IoResult<usize> {\n+        self.read_be_uint_n(usize::BYTES as usize).map(|i| i as usize)\n     }\n \n     /// Reads a big-endian integer.\n     ///\n     /// The number of bytes returned is system-dependent.\n-    fn read_be_int(&mut self) -> IoResult<int> {\n-        self.read_be_int_n(isize::BYTES as usize).map(|i| i as int)\n+    fn read_be_int(&mut self) -> IoResult<isize> {\n+        self.read_be_int_n(isize::BYTES as usize).map(|i| i as isize)\n     }\n \n     /// Reads a big-endian `u64`.\n@@ -919,14 +919,14 @@ impl<T: Reader> BytesReader for T {\n }\n \n impl<'a> Reader for Box<Reader+'a> {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         let reader: &mut Reader = &mut **self;\n         reader.read(buf)\n     }\n }\n \n impl<'a> Reader for &'a mut (Reader+'a) {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { (*self).read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> { (*self).read(buf) }\n }\n \n /// Returns a slice of `v` between `start` and `end`.\n@@ -940,13 +940,13 @@ impl<'a> Reader for &'a mut (Reader+'a) {\n /// `start` > `end`.\n // Private function here because we aren't sure if we want to expose this as\n // API yet. If so, it should be a method on Vec.\n-unsafe fn slice_vec_capacity<'a, T>(v: &'a mut Vec<T>, start: uint, end: uint) -> &'a mut [T] {\n+unsafe fn slice_vec_capacity<'a, T>(v: &'a mut Vec<T>, start: usize, end: usize) -> &'a mut [T] {\n     use slice;\n \n     assert!(start <= end);\n     assert!(end <= v.capacity());\n     slice::from_raw_parts_mut(\n-        v.as_mut_ptr().offset(start as int),\n+        v.as_mut_ptr().offset(start as isize),\n         end - start\n     )\n }\n@@ -980,15 +980,15 @@ pub struct RefReader<'a, R:'a> {\n }\n \n impl<'a, R: Reader> Reader for RefReader<'a, R> {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.inner.read(buf) }\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> { self.inner.read(buf) }\n }\n \n impl<'a, R: Buffer> Buffer for RefReader<'a, R> {\n     fn fill_buf(&mut self) -> IoResult<&[u8]> { self.inner.fill_buf() }\n-    fn consume(&mut self, amt: uint) { self.inner.consume(amt) }\n+    fn consume(&mut self, amt: usize) { self.inner.consume(amt) }\n }\n \n-fn extend_sign(val: u64, nbytes: uint) -> i64 {\n+fn extend_sign(val: u64, nbytes: usize) -> i64 {\n     let shift = (8 - nbytes) * 8;\n     (val << shift) as i64 >> shift\n }\n@@ -1095,39 +1095,39 @@ pub trait Writer {\n         self.write_all(&buf[..n])\n     }\n \n-    /// Write the result of passing n through `int::to_str_bytes`.\n+    /// Write the result of passing n through `isize::to_str_bytes`.\n     #[inline]\n-    fn write_int(&mut self, n: int) -> IoResult<()> {\n+    fn write_int(&mut self, n: isize) -> IoResult<()> {\n         write!(self, \"{}\", n)\n     }\n \n-    /// Write the result of passing n through `uint::to_str_bytes`.\n+    /// Write the result of passing n through `usize::to_str_bytes`.\n     #[inline]\n-    fn write_uint(&mut self, n: uint) -> IoResult<()> {\n+    fn write_uint(&mut self, n: usize) -> IoResult<()> {\n         write!(self, \"{}\", n)\n     }\n \n-    /// Write a little-endian uint (number of bytes depends on system).\n+    /// Write a little-endian usize (number of bytes depends on system).\n     #[inline]\n-    fn write_le_uint(&mut self, n: uint) -> IoResult<()> {\n+    fn write_le_uint(&mut self, n: usize) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, usize::BYTES as usize, |v| self.write_all(v))\n     }\n \n-    /// Write a little-endian int (number of bytes depends on system).\n+    /// Write a little-endian isize (number of bytes depends on system).\n     #[inline]\n-    fn write_le_int(&mut self, n: int) -> IoResult<()> {\n+    fn write_le_int(&mut self, n: isize) -> IoResult<()> {\n         extensions::u64_to_le_bytes(n as u64, isize::BYTES as usize, |v| self.write_all(v))\n     }\n \n-    /// Write a big-endian uint (number of bytes depends on system).\n+    /// Write a big-endian usize (number of bytes depends on system).\n     #[inline]\n-    fn write_be_uint(&mut self, n: uint) -> IoResult<()> {\n+    fn write_be_uint(&mut self, n: usize) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, usize::BYTES as usize, |v| self.write_all(v))\n     }\n \n-    /// Write a big-endian int (number of bytes depends on system).\n+    /// Write a big-endian isize (number of bytes depends on system).\n     #[inline]\n-    fn write_be_int(&mut self, n: int) -> IoResult<()> {\n+    fn write_be_int(&mut self, n: isize) -> IoResult<()> {\n         extensions::u64_to_be_bytes(n as u64, isize::BYTES as usize, |v| self.write_all(v))\n     }\n \n@@ -1409,7 +1409,7 @@ pub trait Buffer: Reader {\n \n     /// Tells this buffer that `amt` bytes have been consumed from the buffer,\n     /// so they should no longer be returned in calls to `read`.\n-    fn consume(&mut self, amt: uint);\n+    fn consume(&mut self, amt: usize);\n \n     /// Reads the next line of input, interpreted as a sequence of UTF-8\n     /// encoded Unicode codepoints. If a newline is encountered, then the\n@@ -1870,8 +1870,8 @@ mod tests {\n \n     #[derive(Clone, PartialEq, Debug)]\n     enum BadReaderBehavior {\n-        GoodBehavior(uint),\n-        BadBehavior(uint)\n+        GoodBehavior(usize),\n+        BadBehavior(usize)\n     }\n \n     struct BadReader<T> {\n@@ -1886,7 +1886,7 @@ mod tests {\n     }\n \n     impl<T: Reader> Reader for BadReader<T> {\n-        fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+        fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n             let BadReader { ref mut behavior, ref mut r } = *self;\n             loop {\n                 if behavior.is_empty() {"}, {"sha": "0413a89ac4f29e9e25054c53a964a3674223d159", "filename": "src/libstd/old_io/net/addrinfo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -63,19 +63,19 @@ pub enum Protocol {\n /// `man -s 3 getaddrinfo`\n #[derive(Copy, Debug)]\n pub struct Hint {\n-    pub family: uint,\n+    pub family: usize,\n     pub socktype: Option<SocketType>,\n     pub protocol: Option<Protocol>,\n-    pub flags: uint,\n+    pub flags: usize,\n }\n \n #[derive(Copy, Debug)]\n pub struct Info {\n     pub address: SocketAddr,\n-    pub family: uint,\n+    pub family: usize,\n     pub socktype: Option<SocketType>,\n     pub protocol: Option<Protocol>,\n-    pub flags: uint,\n+    pub flags: usize,\n }\n \n /// Easy name resolution. Given a hostname, returns the list of IP addresses for"}, {"sha": "ba3578f742596f5d422c17207e7c707cd690be31", "filename": "src/libstd/old_io/net/ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -82,7 +82,7 @@ impl fmt::Display for SocketAddr {\n struct Parser<'a> {\n     // parsing as ASCII, so can use byte array\n     s: &'a [u8],\n-    pos: uint,\n+    pos: usize,\n }\n \n impl<'a> Parser<'a> {\n@@ -256,7 +256,7 @@ impl<'a> Parser<'a> {\n             Ipv6Addr(gs[0], gs[1], gs[2], gs[3], gs[4], gs[5], gs[6], gs[7])\n         }\n \n-        fn read_groups(p: &mut Parser, groups: &mut [u16; 8], limit: uint) -> (uint, bool) {\n+        fn read_groups(p: &mut Parser, groups: &mut [u16; 8], limit: usize) -> (usize, bool) {\n             let mut i = 0;\n             while i < limit {\n                 if i < limit - 1 {"}, {"sha": "2f3cf3d84d092680798917090e2e562e84bf7f21", "filename": "src/libstd/old_io/net/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -150,7 +150,7 @@ impl Clone for UnixStream {\n }\n \n impl Reader for UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         self.inner.read(buf)\n     }\n }"}, {"sha": "d55d9ca11d14cf5391392ef89e5acb3be9c35166", "filename": "src/libstd/old_io/net/tcp.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -122,7 +122,7 @@ impl TcpStream {\n     /// this connection. Otherwise, the keepalive timeout will be set to the\n     /// specified time, in seconds.\n     #[unstable(feature = \"io\")]\n-    pub fn set_keepalive(&mut self, delay_in_seconds: Option<uint>) -> IoResult<()> {\n+    pub fn set_keepalive(&mut self, delay_in_seconds: Option<usize>) -> IoResult<()> {\n         self.inner.set_keepalive(delay_in_seconds)\n     }\n \n@@ -257,7 +257,7 @@ impl Clone for TcpStream {\n }\n \n impl Reader for TcpStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         self.inner.read(buf)\n     }\n }\n@@ -789,12 +789,12 @@ mod test {\n     #[test]\n     fn multiple_connect_interleaved_greedy_schedule_ip4() {\n         let addr = next_test_ip4();\n-        static MAX: int = 10;\n+        static MAX: isize = 10;\n         let acceptor = TcpListener::bind(addr).listen();\n \n         let _t = thread::spawn(move|| {\n             let mut acceptor = acceptor;\n-            for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n+            for (i, stream) in acceptor.incoming().enumerate().take(MAX as usize) {\n                 // Start another task to handle the connection\n                 let _t = thread::spawn(move|| {\n                     let mut stream = stream;\n@@ -808,7 +808,7 @@ mod test {\n \n         connect(0, addr);\n \n-        fn connect(i: int, addr: SocketAddr) {\n+        fn connect(i: isize, addr: SocketAddr) {\n             if i == MAX { return }\n \n             let _t = thread::spawn(move|| {\n@@ -825,12 +825,12 @@ mod test {\n     #[test]\n     fn multiple_connect_interleaved_greedy_schedule_ip6() {\n         let addr = next_test_ip6();\n-        static MAX: int = 10;\n+        static MAX: isize = 10;\n         let acceptor = TcpListener::bind(addr).listen();\n \n         let _t = thread::spawn(move|| {\n             let mut acceptor = acceptor;\n-            for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n+            for (i, stream) in acceptor.incoming().enumerate().take(MAX as usize) {\n                 // Start another task to handle the connection\n                 let _t = thread::spawn(move|| {\n                     let mut stream = stream;\n@@ -844,7 +844,7 @@ mod test {\n \n         connect(0, addr);\n \n-        fn connect(i: int, addr: SocketAddr) {\n+        fn connect(i: isize, addr: SocketAddr) {\n             if i == MAX { return }\n \n             let _t = thread::spawn(move|| {\n@@ -860,13 +860,13 @@ mod test {\n \n     #[test]\n     fn multiple_connect_interleaved_lazy_schedule_ip4() {\n-        static MAX: int = 10;\n+        static MAX: isize = 10;\n         let addr = next_test_ip4();\n         let acceptor = TcpListener::bind(addr).listen();\n \n         let _t = thread::spawn(move|| {\n             let mut acceptor = acceptor;\n-            for stream in acceptor.incoming().take(MAX as uint) {\n+            for stream in acceptor.incoming().take(MAX as usize) {\n                 // Start another task to handle the connection\n                 let _t = thread::spawn(move|| {\n                     let mut stream = stream;\n@@ -880,7 +880,7 @@ mod test {\n \n         connect(0, addr);\n \n-        fn connect(i: int, addr: SocketAddr) {\n+        fn connect(i: isize, addr: SocketAddr) {\n             if i == MAX { return }\n \n             let _t = thread::spawn(move|| {\n@@ -896,13 +896,13 @@ mod test {\n \n     #[test]\n     fn multiple_connect_interleaved_lazy_schedule_ip6() {\n-        static MAX: int = 10;\n+        static MAX: isize = 10;\n         let addr = next_test_ip6();\n         let acceptor = TcpListener::bind(addr).listen();\n \n         let _t = thread::spawn(move|| {\n             let mut acceptor = acceptor;\n-            for stream in acceptor.incoming().take(MAX as uint) {\n+            for stream in acceptor.incoming().take(MAX as usize) {\n                 // Start another task to handle the connection\n                 let _t = thread::spawn(move|| {\n                     let mut stream = stream;\n@@ -916,7 +916,7 @@ mod test {\n \n         connect(0, addr);\n \n-        fn connect(i: int, addr: SocketAddr) {\n+        fn connect(i: isize, addr: SocketAddr) {\n             if i == MAX { return }\n \n             let _t = thread::spawn(move|| {"}, {"sha": "196447d71efbf8ff598cf6fa4bb564365aa790b1", "filename": "src/libstd/old_io/net/udp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -73,7 +73,7 @@ impl UdpSocket {\n \n     /// Receives data from the socket. On success, returns the number of bytes\n     /// read and the address from whence the data came.\n-    pub fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(uint, SocketAddr)> {\n+    pub fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(usize, SocketAddr)> {\n         self.inner.recv_from(buf)\n     }\n \n@@ -113,13 +113,13 @@ impl UdpSocket {\n \n     /// Sets the multicast TTL\n     #[unstable(feature = \"io\")]\n-    pub fn set_multicast_ttl(&mut self, ttl: int) -> IoResult<()> {\n+    pub fn set_multicast_ttl(&mut self, ttl: isize) -> IoResult<()> {\n         self.inner.multicast_time_to_live(ttl)\n     }\n \n     /// Sets this socket's TTL\n     #[unstable(feature = \"io\")]\n-    pub fn set_ttl(&mut self, ttl: int) -> IoResult<()> {\n+    pub fn set_ttl(&mut self, ttl: isize) -> IoResult<()> {\n         self.inner.time_to_live(ttl)\n     }\n "}, {"sha": "26f2460047982eb3223604cfc173e40eb1e522e8", "filename": "src/libstd/old_io/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fpipe.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -100,7 +100,7 @@ impl Clone for PipeStream {\n }\n \n impl Reader for PipeStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         self.inner.read(buf)\n     }\n }"}, {"sha": "45bf5a58ec2183c5eff56dd71953cb280c80f405", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -41,16 +41,16 @@ use thread;\n \n /// Signal a process to exit, without forcibly killing it. Corresponds to\n /// SIGTERM on unix platforms.\n-#[cfg(windows)] pub const PleaseExitSignal: int = 15;\n+#[cfg(windows)] pub const PleaseExitSignal: isize = 15;\n /// Signal a process to exit immediately, forcibly killing it. Corresponds to\n /// SIGKILL on unix platforms.\n-#[cfg(windows)] pub const MustDieSignal: int = 9;\n+#[cfg(windows)] pub const MustDieSignal: isize = 9;\n /// Signal a process to exit, without forcibly killing it. Corresponds to\n /// SIGTERM on unix platforms.\n-#[cfg(not(windows))] pub const PleaseExitSignal: int = libc::SIGTERM as int;\n+#[cfg(not(windows))] pub const PleaseExitSignal: isize = libc::SIGTERM as isize;\n /// Signal a process to exit immediately, forcibly killing it. Corresponds to\n /// SIGKILL on unix platforms.\n-#[cfg(not(windows))] pub const MustDieSignal: int = libc::SIGKILL as int;\n+#[cfg(not(windows))] pub const MustDieSignal: isize = libc::SIGKILL as isize;\n \n /// Representation of a running or exited child process.\n ///\n@@ -80,7 +80,7 @@ pub struct Process {\n     exit_code: Option<ProcessExit>,\n \n     /// Manually delivered signal\n-    exit_signal: Option<int>,\n+    exit_signal: Option<isize>,\n \n     /// Deadline after which wait() will return\n     deadline: u64,\n@@ -186,8 +186,8 @@ pub struct Command {\n     stdin: StdioContainer,\n     stdout: StdioContainer,\n     stderr: StdioContainer,\n-    uid: Option<uint>,\n-    gid: Option<uint>,\n+    uid: Option<usize>,\n+    gid: Option<usize>,\n     detach: bool,\n }\n \n@@ -321,14 +321,14 @@ impl Command {\n     /// the child process. Setting this value on windows will cause the spawn to\n     /// fail. Failure in the `setuid` call on unix will also cause the spawn to\n     /// fail.\n-    pub fn uid<'a>(&'a mut self, id: uint) -> &'a mut Command {\n+    pub fn uid<'a>(&'a mut self, id: usize) -> &'a mut Command {\n         self.uid = Some(id);\n         self\n     }\n \n     /// Similar to `uid`, but sets the group id of the child process. This has\n     /// the same semantics as the `uid` field.\n-    pub fn gid<'a>(&'a mut self, id: uint) -> &'a mut Command {\n+    pub fn gid<'a>(&'a mut self, id: usize) -> &'a mut Command {\n         self.gid = Some(id);\n         self\n     }\n@@ -458,10 +458,10 @@ impl sys::process::ProcessConfig<EnvKey, CString> for Command {\n     fn cwd(&self) -> Option<&CString> {\n         self.cwd.as_ref()\n     }\n-    fn uid(&self) -> Option<uint> {\n+    fn uid(&self) -> Option<usize> {\n         self.uid.clone()\n     }\n-    fn gid(&self) -> Option<uint> {\n+    fn gid(&self) -> Option<usize> {\n         self.gid.clone()\n     }\n     fn detach(&self) -> bool {\n@@ -507,10 +507,10 @@ pub enum StdioContainer {\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n pub enum ProcessExit {\n     /// Normal termination with an exit status.\n-    ExitStatus(int),\n+    ExitStatus(isize),\n \n     /// Termination by signal, with the signal number.\n-    ExitSignal(int),\n+    ExitSignal(isize),\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -533,7 +533,7 @@ impl ProcessExit {\n \n     /// Checks whether this ProcessExit matches the given exit status.\n     /// Termination by signal will never match an exit code.\n-    pub fn matches_exit_status(&self, wanted: int) -> bool {\n+    pub fn matches_exit_status(&self, wanted: isize) -> bool {\n         *self == ExitStatus(wanted)\n     }\n }\n@@ -549,7 +549,7 @@ impl Process {\n     /// process. Note, though, that on some platforms signals will continue to\n     /// be successfully delivered if the child has exited, but not yet been\n     /// reaped.\n-    pub fn kill(id: libc::pid_t, signal: int) -> IoResult<()> {\n+    pub fn kill(id: libc::pid_t, signal: isize) -> IoResult<()> {\n         unsafe { ProcessImp::killpid(id, signal) }\n     }\n \n@@ -571,7 +571,7 @@ impl Process {\n     /// # Errors\n     ///\n     /// If the signal delivery fails, the corresponding error is returned.\n-    pub fn signal(&mut self, signal: int) -> IoResult<()> {\n+    pub fn signal(&mut self, signal: isize) -> IoResult<()> {\n         #[cfg(unix)] fn collect_status(p: &mut Process) {\n             // On Linux (and possibly other unices), a process that has exited will\n             // continue to accept signals because it is \"defunct\". The delivery of\n@@ -888,8 +888,8 @@ mod tests {\n         use libc;\n         let mut p = Command::new(\"/bin/sh\")\n                             .arg(\"-c\").arg(\"true\")\n-                            .uid(unsafe { libc::getuid() as uint })\n-                            .gid(unsafe { libc::getgid() as uint })\n+                            .uid(unsafe { libc::getuid() as usize })\n+                            .gid(unsafe { libc::getgid() as usize })\n                             .spawn().unwrap();\n         assert!(p.wait().unwrap().success());\n     }"}, {"sha": "cda19f8ae84669cc4abd3de56b219100590f6a06", "filename": "src/libstd/old_io/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fresult.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -35,7 +35,7 @@ impl<W: Writer> Writer for IoResult<W> {\n }\n \n impl<R: Reader> Reader for IoResult<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         match *self {\n             Ok(ref mut reader) => reader.read(buf),\n             Err(ref e) => Err(e.clone()),"}, {"sha": "b4924c7b78b753112d6e58ff59b9b8872fe4c28c", "filename": "src/libstd/old_io/stdio.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fstdio.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -182,31 +182,31 @@ impl StdinReader {\n }\n \n impl Reader for StdinReader {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         self.inner.lock().unwrap().0.read(buf)\n     }\n \n     // We have to manually delegate all of these because the default impls call\n     // read more than once and we don't want those calls to interleave (or\n     // incur the costs of repeated locking).\n \n-    fn read_at_least(&mut self, min: uint, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read_at_least(&mut self, min: usize, buf: &mut [u8]) -> IoResult<usize> {\n         self.inner.lock().unwrap().0.read_at_least(min, buf)\n     }\n \n-    fn push_at_least(&mut self, min: uint, len: uint, buf: &mut Vec<u8>) -> IoResult<uint> {\n+    fn push_at_least(&mut self, min: usize, len: usize, buf: &mut Vec<u8>) -> IoResult<usize> {\n         self.inner.lock().unwrap().0.push_at_least(min, len, buf)\n     }\n \n     fn read_to_end(&mut self) -> IoResult<Vec<u8>> {\n         self.inner.lock().unwrap().0.read_to_end()\n     }\n \n-    fn read_le_uint_n(&mut self, nbytes: uint) -> IoResult<u64> {\n+    fn read_le_uint_n(&mut self, nbytes: usize) -> IoResult<u64> {\n         self.inner.lock().unwrap().0.read_le_uint_n(nbytes)\n     }\n \n-    fn read_be_uint_n(&mut self, nbytes: uint) -> IoResult<u64> {\n+    fn read_be_uint_n(&mut self, nbytes: usize) -> IoResult<u64> {\n         self.inner.lock().unwrap().0.read_be_uint_n(nbytes)\n     }\n }\n@@ -410,16 +410,16 @@ impl StdReader {\n }\n \n impl Reader for StdReader {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         let ret = match self.inner {\n             TTY(ref mut tty) => {\n                 // Flush the task-local stdout so that weird issues like a\n                 // print!'d prompt not being shown until after the user hits\n                 // enter.\n                 flush();\n-                tty.read(buf).map(|i| i as uint)\n+                tty.read(buf).map(|i| i as usize)\n             },\n-            File(ref mut file) => file.read(buf).map(|i| i as uint),\n+            File(ref mut file) => file.read(buf).map(|i| i as usize),\n         };\n         match ret {\n             // When reading a piped stdin, libuv will return 0-length reads when\n@@ -452,7 +452,7 @@ impl StdWriter {\n     ///\n     /// This function will return an error if the output stream is not actually\n     /// connected to a TTY instance, or if querying the TTY instance fails.\n-    pub fn winsize(&mut self) -> IoResult<(int, int)> {\n+    pub fn winsize(&mut self) -> IoResult<(isize, isize)> {\n         match self.inner {\n             TTY(ref mut tty) => {\n                 tty.get_winsize()"}, {"sha": "bf9b79ce65aacc08e204a3f45a97a55db571c429", "filename": "src/libstd/old_io/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftempfile.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -89,7 +89,7 @@ const NUM_RETRIES: u32 = 1 << 31;\n // be enough to dissuade an attacker from trying to preemptively create names\n // of that length, but not so huge that we unnecessarily drain the random number\n // generator of entropy.\n-const NUM_RAND_CHARS: uint = 12;\n+const NUM_RAND_CHARS: usize = 12;\n \n impl TempDir {\n     /// Attempts to make a temporary directory inside of `tmpdir` whose name"}, {"sha": "604099f117884a5126a821af919607d57e2269e3", "filename": "src/libstd/old_io/util.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_io%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Futil.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -22,7 +22,7 @@ use slice::bytes::MutableByteVector;\n #[deprecated(since = \"1.0.0\", reason = \"use std::io::Take\")]\n #[unstable(feature = \"old_io\")]\n pub struct LimitReader<R> {\n-    limit: uint,\n+    limit: usize,\n     inner: R\n }\n \n@@ -32,7 +32,7 @@ impl<R: Reader> LimitReader<R> {\n     /// Creates a new `LimitReader`\n     #[deprecated(since = \"1.0.0\", reason = \"use std::io's take method instead\")]\n     #[unstable(feature = \"old_io\")]\n-    pub fn new(r: R, limit: uint) -> LimitReader<R> {\n+    pub fn new(r: R, limit: usize) -> LimitReader<R> {\n         LimitReader { limit: limit, inner: r }\n     }\n \n@@ -46,13 +46,13 @@ impl<R: Reader> LimitReader<R> {\n     ///\n     /// The reader may reach EOF after reading fewer bytes than indicated by\n     /// this method if the underlying reader reaches EOF.\n-    pub fn limit(&self) -> uint { self.limit }\n+    pub fn limit(&self) -> usize { self.limit }\n }\n \n #[deprecated(since = \"1.0.0\", reason = \"use std::io's take method instead\")]\n #[unstable(feature = \"old_io\")]\n impl<R: Reader> Reader for LimitReader<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n         if self.limit == 0 {\n             return Err(old_io::standard_error(old_io::EndOfFile));\n         }\n@@ -80,7 +80,7 @@ impl<R: Buffer> Buffer for LimitReader<R> {\n         }\n     }\n \n-    fn consume(&mut self, amt: uint) {\n+    fn consume(&mut self, amt: usize) {\n         // Don't let callers reset the limit by passing an overlarge value\n         let amt = cmp::min(amt, self.limit);\n         self.limit -= amt;\n@@ -112,7 +112,7 @@ pub struct ZeroReader;\n #[unstable(feature = \"old_io\")]\n impl Reader for ZeroReader {\n     #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n         buf.set_memory(0);\n         Ok(buf.len())\n     }\n@@ -126,7 +126,7 @@ impl Buffer for ZeroReader {\n         Ok(&DATA)\n     }\n \n-    fn consume(&mut self, _amt: uint) {}\n+    fn consume(&mut self, _amt: usize) {}\n }\n \n /// A `Reader` which is always at EOF, like /dev/null.\n@@ -139,7 +139,7 @@ pub struct NullReader;\n #[unstable(feature = \"old_io\")]\n impl Reader for NullReader {\n     #[inline]\n-    fn read(&mut self, _buf: &mut [u8]) -> old_io::IoResult<uint> {\n+    fn read(&mut self, _buf: &mut [u8]) -> old_io::IoResult<usize> {\n         Err(old_io::standard_error(old_io::EndOfFile))\n     }\n }\n@@ -150,7 +150,7 @@ impl Buffer for NullReader {\n     fn fill_buf<'a>(&'a mut self) -> old_io::IoResult<&'a [u8]> {\n         Err(old_io::standard_error(old_io::EndOfFile))\n     }\n-    fn consume(&mut self, _amt: uint) {}\n+    fn consume(&mut self, _amt: usize) {}\n }\n \n /// A `Writer` which multiplexes writes to a set of `Writer`s.\n@@ -216,7 +216,7 @@ impl<R: Reader, I: Iterator<Item=R>> ChainedReader<I, R> {\n #[deprecated(since = \"1.0.0\", reason = \"use std::io::Chain instead\")]\n #[unstable(feature = \"old_io\")]\n impl<R: Reader, I: Iterator<Item=R>> Reader for ChainedReader<I, R> {\n-    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n         loop {\n             let err = match self.cur_reader {\n                 Some(ref mut r) => {\n@@ -269,7 +269,7 @@ impl<R: Reader, W: Writer> TeeReader<R, W> {\n #[deprecated(since = \"1.0.0\", reason = \"use std::io::Tee instead\")]\n #[unstable(feature = \"old_io\")]\n impl<R: Reader, W: Writer> Reader for TeeReader<R, W> {\n-    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n         self.reader.read(buf).and_then(|len| {\n             self.writer.write_all(&mut buf[..len]).map(|()| len)\n         })\n@@ -307,7 +307,7 @@ impl<T: Iterator<Item=u8>> IterReader<T> {\n \n impl<T: Iterator<Item=u8>> Reader for IterReader<T> {\n     #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<uint> {\n+    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n         let mut len = 0;\n         for (slot, elt) in buf.iter_mut().zip(self.iter.by_ref()) {\n             *slot = elt;\n@@ -392,8 +392,8 @@ mod test {\n \n     #[test]\n     fn test_multi_writer() {\n-        static mut writes: uint = 0;\n-        static mut flushes: uint = 0;\n+        static mut writes: usize = 0;\n+        static mut flushes: usize = 0;\n \n         struct TestWriter;\n         impl Writer for TestWriter {"}, {"sha": "67bfe2bd77026f6c0bb725187ceb97fb7735b37d", "filename": "src/libstd/old_path/posix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_path%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_path%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fposix.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -37,7 +37,7 @@ pub type StrComponents<'a> =\n #[derive(Clone)]\n pub struct Path {\n     repr: Vec<u8>, // assumed to never be empty or contain NULs\n-    sepidx: Option<uint> // index of the final separator in repr\n+    sepidx: Option<usize> // index of the final separator in repr\n }\n \n /// The standard path separator character"}, {"sha": "869a8127301730fbf0c599653c9355781657f92a", "filename": "src/libstd/old_path/windows.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_path%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fold_path%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fwindows.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -81,7 +81,7 @@ pub type Components<'a> =\n pub struct Path {\n     repr: String, // assumed to never be empty\n     prefix: Option<PathPrefix>,\n-    sepidx: Option<uint> // index of the final separator in the non-prefix portion of repr\n+    sepidx: Option<usize> // index of the final separator in the non-prefix portion of repr\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -749,7 +749,7 @@ impl Path {\n                     if prefix.is_some() && comps.is_empty() {\n                         match prefix.unwrap() {\n                             DiskPrefix => {\n-                                let len = prefix_len(prefix) + is_abs as uint;\n+                                let len = prefix_len(prefix) + is_abs as usize;\n                                 let mut s = String::from_str(&s[..len]);\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n@@ -764,7 +764,7 @@ impl Path {\n                                 Some(s)\n                             }\n                             VerbatimDiskPrefix => {\n-                                let len = prefix_len(prefix) + is_abs as uint;\n+                                let len = prefix_len(prefix) + is_abs as usize;\n                                 let mut s = String::from_str(&s[..len]);\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n@@ -838,7 +838,7 @@ impl Path {\n         self.sepidx = idx.and_then(|x| if x < prefixlen { None } else { Some(x) });\n     }\n \n-    fn prefix_len(&self) -> uint {\n+    fn prefix_len(&self) -> usize {\n         prefix_len(self.prefix)\n     }\n \n@@ -847,7 +847,7 @@ impl Path {\n     // end is the length of the string, normally, or the index of the final character if it is\n     // a non-semantic trailing separator in a verbatim string.\n     // If the prefix is considered the separator, before and after are the same.\n-    fn sepidx_or_prefix_len(&self) -> Option<(uint,uint,uint)> {\n+    fn sepidx_or_prefix_len(&self) -> Option<(usize,usize,usize)> {\n         match self.sepidx {\n             None => match self.prefix_len() { 0 => None, x => Some((x,x,self.repr.len())) },\n             Some(x) => {\n@@ -973,16 +973,16 @@ pub fn is_sep_byte_verbatim(u: &u8) -> bool {\n /// Prefix types for Path\n #[derive(Copy, PartialEq, Clone, Debug)]\n pub enum PathPrefix {\n-    /// Prefix `\\\\?\\`, uint is the length of the following component\n-    VerbatimPrefix(uint),\n+    /// Prefix `\\\\?\\`, usize is the length of the following component\n+    VerbatimPrefix(usize),\n     /// Prefix `\\\\?\\UNC\\`, uints are the lengths of the UNC components\n-    VerbatimUNCPrefix(uint, uint),\n+    VerbatimUNCPrefix(usize, usize),\n     /// Prefix `\\\\?\\C:\\` (for any alphabetic character)\n     VerbatimDiskPrefix,\n-    /// Prefix `\\\\.\\`, uint is the length of the following component\n-    DeviceNSPrefix(uint),\n+    /// Prefix `\\\\.\\`, usize is the length of the following component\n+    DeviceNSPrefix(usize),\n     /// UNC prefix `\\\\server\\share`, uints are the lengths of the server/share\n-    UNCPrefix(uint, uint),\n+    UNCPrefix(usize, usize),\n     /// Prefix `C:` for any alphabetic character\n     DiskPrefix\n }\n@@ -1037,7 +1037,7 @@ fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n     }\n     return None;\n \n-    fn parse_two_comps(mut path: &str, f: fn(char) -> bool) -> Option<(uint, uint)> {\n+    fn parse_two_comps(mut path: &str, f: fn(char) -> bool) -> Option<(usize, usize)> {\n         let idx_a = match path.find(f) {\n             None => return None,\n             Some(x) => x\n@@ -1107,7 +1107,7 @@ fn prefix_is_verbatim(p: Option<PathPrefix>) -> bool {\n     }\n }\n \n-fn prefix_len(p: Option<PathPrefix>) -> uint {\n+fn prefix_len(p: Option<PathPrefix>) -> usize {\n     match p {\n         None => 0,\n         Some(VerbatimPrefix(x)) => 4 + x,"}, {"sha": "2e8521cc94bd77cfb9079c04bcc62ffc0034fd77", "filename": "src/libstd/os.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -100,17 +100,17 @@ fn path2old(path: &path::Path) -> Path {\n }\n \n /// Get the number of cores available\n-pub fn num_cpus() -> uint {\n+pub fn num_cpus() -> usize {\n     unsafe {\n-        return rust_get_num_cpus() as uint;\n+        return rust_get_num_cpus() as usize;\n     }\n \n     extern {\n         fn rust_get_num_cpus() -> libc::uintptr_t;\n     }\n }\n \n-pub const TMPBUF_SZ : uint = 1000;\n+pub const TMPBUF_SZ : usize = 1000;\n \n /// Returns the current working directory as a `Path`.\n ///\n@@ -592,20 +592,20 @@ pub fn last_os_error() -> String {\n /// Note that this is not synchronized against modifications of other threads.\n #[deprecated(since = \"1.0.0\", reason = \"renamed to env::set_exit_status\")]\n #[unstable(feature = \"os\")]\n-pub fn set_exit_status(code: int) {\n+pub fn set_exit_status(code: isize) {\n     env::set_exit_status(code as i32)\n }\n \n /// Fetches the process's current exit code. This defaults to 0 and can change\n /// by calling `set_exit_status`.\n #[deprecated(since = \"1.0.0\", reason = \"renamed to env::get_exit_status\")]\n #[unstable(feature = \"os\")]\n-pub fn get_exit_status() -> int {\n+pub fn get_exit_status() -> isize {\n     env::get_exit_status() as isize\n }\n \n #[cfg(target_os = \"macos\")]\n-unsafe fn load_argc_and_argv(argc: int,\n+unsafe fn load_argc_and_argv(argc: isize,\n                              argv: *const *const c_char) -> Vec<Vec<u8>> {\n     use ffi::CStr;\n \n@@ -620,7 +620,7 @@ unsafe fn load_argc_and_argv(argc: int,\n #[cfg(target_os = \"macos\")]\n fn real_args_as_bytes() -> Vec<Vec<u8>> {\n     unsafe {\n-        let (argc, argv) = (*_NSGetArgc() as int,\n+        let (argc, argv) = (*_NSGetArgc() as isize,\n                             *_NSGetArgv() as *const *const c_char);\n         load_argc_and_argv(argc, argv)\n     }\n@@ -670,7 +670,7 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n         let info = objc_msgSend(klass, processInfoSel);\n         let args = objc_msgSend(info, argumentsSel);\n \n-        let cnt: int = mem::transmute(objc_msgSend(args, countSel));\n+        let cnt: isize = mem::transmute(objc_msgSend(args, countSel));\n         for i in 0..cnt {\n             let tmp = objc_msgSend(args, objectAtSel, i);\n             let utf_c_str: *const libc::c_char =\n@@ -711,11 +711,11 @@ fn real_args() -> Vec<String> {\n     let lpCmdLine = unsafe { GetCommandLineW() };\n     let szArgList = unsafe { CommandLineToArgvW(lpCmdLine, lpArgCount) };\n \n-    let args: Vec<_> = (0..nArgs as uint).map(|i| unsafe {\n+    let args: Vec<_> = (0..nArgs as usize).map(|i| unsafe {\n         // Determine the length of this argument.\n-        let ptr = *szArgList.offset(i as int);\n+        let ptr = *szArgList.offset(i as isize);\n         let mut len = 0;\n-        while *ptr.offset(len as int) != 0 { len += 1; }\n+        while *ptr.offset(len as isize) != 0 { len += 1; }\n \n         // Push it onto the list.\n         let ptr = ptr as *const u16;\n@@ -796,7 +796,7 @@ extern {\n /// Returns the page size of the current architecture in bytes.\n #[deprecated(since = \"1.0.0\", reason = \"renamed to env::page_size\")]\n #[unstable(feature = \"os\")]\n-pub fn page_size() -> uint {\n+pub fn page_size() -> usize {\n     sys::os::page_size()\n }\n \n@@ -810,7 +810,7 @@ pub fn page_size() -> uint {\n /// let it leave scope by accident if you want it to stick around.\n pub struct MemoryMap {\n     data: *mut u8,\n-    len: uint,\n+    len: usize,\n     kind: MemoryMapKind,\n }\n \n@@ -846,9 +846,9 @@ pub enum MapOption {\n     /// Create a memory mapping for a file with a given fd.\n     #[cfg(not(windows))]\n     MapFd(c_int),\n-    /// When using `MapFd`, the start of the map is `uint` bytes from the start\n+    /// When using `MapFd`, the start of the map is `usize` bytes from the start\n     /// of the file.\n-    MapOffset(uint),\n+    MapOffset(usize),\n     /// On POSIX, this can be used to specify the default flags passed to\n     /// `mmap`. By default it uses `MAP_PRIVATE` and, if not using `MapFd`,\n     /// `MAP_ANON`. This will override both of those. This is platform-specific\n@@ -880,7 +880,7 @@ pub enum MapError {\n     /// Not all platforms obey this, but this wrapper does.\n     ErrZeroLength,\n     /// Unrecognized error. The inner value is the unrecognized errno.\n-    ErrUnknown(int),\n+    ErrUnknown(isize),\n     /// # The following are Windows-specific\n     ///\n     /// Unsupported combination of protection flags\n@@ -940,7 +940,7 @@ impl Error for MapError {\n }\n \n // Round up `from` to be divisible by `to`\n-fn round_up(from: uint, to: uint) -> uint {\n+fn round_up(from: usize, to: usize) -> usize {\n     let r = if from % to == 0 {\n         from\n     } else {\n@@ -958,7 +958,7 @@ impl MemoryMap {\n     /// Create a new mapping with the given `options`, at least `min_len` bytes\n     /// long. `min_len` must be greater than zero; see the note on\n     /// `ErrZeroLength`.\n-    pub fn new(min_len: uint, options: &[MapOption]) -> Result<MemoryMap, MapError> {\n+    pub fn new(min_len: usize, options: &[MapOption]) -> Result<MemoryMap, MapError> {\n         use libc::off_t;\n \n         if min_len == 0 {\n@@ -1002,7 +1002,7 @@ impl MemoryMap {\n                 libc::EINVAL => ErrUnaligned,\n                 libc::ENODEV => ErrNoMapSupport,\n                 libc::ENOMEM => ErrNoMem,\n-                code => ErrUnknown(code as int)\n+                code => ErrUnknown(code as isize)\n             })\n         } else {\n             Ok(MemoryMap {\n@@ -1019,7 +1019,7 @@ impl MemoryMap {\n \n     /// Granularity that the offset or address must be for `MapOffset` and\n     /// `MapAddr` respectively.\n-    pub fn granularity() -> uint {\n+    pub fn granularity() -> usize {\n         env::page_size()\n     }\n }\n@@ -1040,15 +1040,15 @@ impl Drop for MemoryMap {\n #[cfg(windows)]\n impl MemoryMap {\n     /// Create a new mapping with the given `options`, at least `min_len` bytes long.\n-    pub fn new(min_len: uint, options: &[MapOption]) -> Result<MemoryMap, MapError> {\n+    pub fn new(min_len: usize, options: &[MapOption]) -> Result<MemoryMap, MapError> {\n         use libc::types::os::arch::extra::{LPVOID, DWORD, SIZE_T, HANDLE};\n \n         let mut lpAddress: LPVOID = ptr::null_mut();\n         let mut readable = false;\n         let mut writable = false;\n         let mut executable = false;\n         let mut handle: HANDLE = libc::INVALID_HANDLE_VALUE;\n-        let mut offset: uint = 0;\n+        let mut offset: usize = 0;\n         let len = round_up(min_len, env::page_size());\n \n         for &o in options {\n@@ -1083,7 +1083,7 @@ impl MemoryMap {\n                                    libc::MEM_COMMIT | libc::MEM_RESERVE,\n                                    flProtect)\n             };\n-            match r as uint {\n+            match r as usize {\n                 0 => Err(ErrVirtualAlloc(errno())),\n                 _ => Ok(MemoryMap {\n                    data: r as *mut u8,\n@@ -1119,7 +1119,7 @@ impl MemoryMap {\n                                             ((len as u64) >> 32) as DWORD,\n                                             (offset & 0xffff_ffff) as DWORD,\n                                             0);\n-                match r as uint {\n+                match r as usize {\n                     0 => Err(ErrMapViewOfFile(errno())),\n                     _ => Ok(MemoryMap {\n                        data: r as *mut u8,\n@@ -1133,13 +1133,13 @@ impl MemoryMap {\n \n     /// Granularity of MapAddr() and MapOffset() parameter values.\n     /// This may be greater than the value returned by page_size().\n-    pub fn granularity() -> uint {\n+    pub fn granularity() -> usize {\n         use mem;\n         unsafe {\n             let mut info = mem::zeroed();\n             libc::GetSystemInfo(&mut info);\n \n-            return info.dwAllocationGranularity as uint;\n+            return info.dwAllocationGranularity as usize;\n         }\n     }\n }\n@@ -1178,7 +1178,7 @@ impl MemoryMap {\n     /// Returns the pointer to the memory created or modified by this map.\n     pub fn data(&self) -> *mut u8 { self.data }\n     /// Returns the number of bytes this map applies to.\n-    pub fn len(&self) -> uint { self.len }\n+    pub fn len(&self) -> usize { self.len }\n     /// Returns the type of mapping this represents.\n     pub fn kind(&self) -> MemoryMapKind { self.kind }\n }"}, {"sha": "cfd4e17c021b1d6f55e8e1b9c00c771010e6483d", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -64,7 +64,7 @@\n //!\n //! let mut rng = rand::thread_rng();\n //! if rng.gen() { // random bool\n-//!     println!(\"int: {}, uint: {}\", rng.gen::<int>(), rng.gen::<uint>())\n+//!     println!(\"isize: {}, usize: {}\", rng.gen::<isize>(), rng.gen::<usize>())\n //! }\n //! ```\n //!\n@@ -148,7 +148,7 @@\n //! }\n //!\n //! // Run a single simulation of the Monty Hall problem.\n-//! fn simulate<R: Rng>(random_door: &Range<uint>, rng: &mut R) -> SimulationResult {\n+//! fn simulate<R: Rng>(random_door: &Range<usize>, rng: &mut R) -> SimulationResult {\n //!     let car = random_door.ind_sample(rng);\n //!\n //!     // This is our initial choice\n@@ -168,18 +168,18 @@\n //!\n //! // Returns the door the game host opens given our choice and knowledge of\n //! // where the car is. The game host will never open the door with the car.\n-//! fn game_host_open<R: Rng>(car: uint, choice: uint, rng: &mut R) -> uint {\n+//! fn game_host_open<R: Rng>(car: usize, choice: usize, rng: &mut R) -> usize {\n //!     let choices = free_doors(&[car, choice]);\n //!     rand::sample(rng, choices.into_iter(), 1)[0]\n //! }\n //!\n //! // Returns the door we switch to, given our current choice and\n //! // the open door. There will only be one valid door.\n-//! fn switch_door(choice: uint, open: uint) -> uint {\n+//! fn switch_door(choice: usize, open: usize) -> usize {\n //!     free_doors(&[choice, open])[0]\n //! }\n //!\n-//! fn free_doors(blocked: &[uint]) -> Vec<uint> {\n+//! fn free_doors(blocked: &[usize]) -> Vec<usize> {\n //!     (0..3).filter(|x| !blocked.contains(x)).collect()\n //! }\n //!\n@@ -336,7 +336,7 @@ pub struct ThreadRng {\n \n /// Retrieve the lazily-initialized thread-local random number\n /// generator, seeded by the system. Intended to be used in method\n-/// chaining style, e.g. `thread_rng().gen::<int>()`.\n+/// chaining style, e.g. `thread_rng().gen::<isize>()`.\n ///\n /// The RNG provided will reseed itself from the operating system\n /// after generating a certain amount of randomness.\n@@ -556,14 +556,14 @@ mod test {\n         let mut r = thread_rng();\n         assert_eq!(r.choose(&[1, 1, 1]).cloned(), Some(1));\n \n-        let v: &[int] = &[];\n+        let v: &[isize] = &[];\n         assert_eq!(r.choose(v), None);\n     }\n \n     #[test]\n     fn test_shuffle() {\n         let mut r = thread_rng();\n-        let empty: &mut [int] = &mut [];\n+        let empty: &mut [isize] = &mut [];\n         r.shuffle(empty);\n         let mut one = [1];\n         r.shuffle(&mut one);\n@@ -583,7 +583,7 @@ mod test {\n     #[test]\n     fn test_thread_rng() {\n         let mut r = thread_rng();\n-        r.gen::<int>();\n+        r.gen::<isize>();\n         let mut v = [1, 1, 1];\n         r.shuffle(&mut v);\n         let b: &[_] = &[1, 1, 1];\n@@ -594,12 +594,12 @@ mod test {\n     #[test]\n     fn test_random() {\n         // not sure how to test this aside from just getting some values\n-        let _n : uint = random();\n+        let _n : usize = random();\n         let _f : f32 = random();\n         let _o : Option<Option<i8>> = random();\n         let _many : ((),\n-                     (uint,\n-                      int,\n+                     (usize,\n+                      isize,\n                       Option<(u32, (bool,))>),\n                      (u8, i8, u16, i16, u32, i32, u64, i64),\n                      (f32, (f64, (f64,)))) = random();\n@@ -611,7 +611,7 @@ mod test {\n         let max_val = 100;\n \n         let mut r = thread_rng();\n-        let vals = (min_val..max_val).collect::<Vec<int>>();\n+        let vals = (min_val..max_val).collect::<Vec<isize>>();\n         let small_sample = sample(&mut r, vals.iter(), 5);\n         let large_sample = sample(&mut r, vals.iter(), vals.len() + 5);\n \n@@ -625,7 +625,7 @@ mod test {\n \n     #[test]\n     fn test_std_rng_seeded() {\n-        let s = thread_rng().gen_iter::<uint>().take(256).collect::<Vec<uint>>();\n+        let s = thread_rng().gen_iter::<usize>().take(256).collect::<Vec<usize>>();\n         let mut ra: StdRng = SeedableRng::from_seed(&*s);\n         let mut rb: StdRng = SeedableRng::from_seed(&*s);\n         assert!(order::equals(ra.gen_ascii_chars().take(100),\n@@ -634,7 +634,7 @@ mod test {\n \n     #[test]\n     fn test_std_rng_reseed() {\n-        let s = thread_rng().gen_iter::<uint>().take(256).collect::<Vec<uint>>();\n+        let s = thread_rng().gen_iter::<usize>().take(256).collect::<Vec<usize>>();\n         let mut r: StdRng = SeedableRng::from_seed(&*s);\n         let string1 = r.gen_ascii_chars().take(100).collect::<String>();\n \n@@ -662,49 +662,49 @@ mod bench {\n         let mut rng: XorShiftRng = OsRng::new().unwrap().gen();\n         b.iter(|| {\n             for _ in 0..RAND_BENCH_N {\n-                rng.gen::<uint>();\n+                rng.gen::<usize>();\n             }\n         });\n-        b.bytes = size_of::<uint>() as u64 * RAND_BENCH_N;\n+        b.bytes = size_of::<usize>() as u64 * RAND_BENCH_N;\n     }\n \n     #[bench]\n     fn rand_isaac(b: &mut Bencher) {\n         let mut rng: IsaacRng = OsRng::new().unwrap().gen();\n         b.iter(|| {\n             for _ in 0..RAND_BENCH_N {\n-                rng.gen::<uint>();\n+                rng.gen::<usize>();\n             }\n         });\n-        b.bytes = size_of::<uint>() as u64 * RAND_BENCH_N;\n+        b.bytes = size_of::<usize>() as u64 * RAND_BENCH_N;\n     }\n \n     #[bench]\n     fn rand_isaac64(b: &mut Bencher) {\n         let mut rng: Isaac64Rng = OsRng::new().unwrap().gen();\n         b.iter(|| {\n             for _ in 0..RAND_BENCH_N {\n-                rng.gen::<uint>();\n+                rng.gen::<usize>();\n             }\n         });\n-        b.bytes = size_of::<uint>() as u64 * RAND_BENCH_N;\n+        b.bytes = size_of::<usize>() as u64 * RAND_BENCH_N;\n     }\n \n     #[bench]\n     fn rand_std(b: &mut Bencher) {\n         let mut rng = StdRng::new().unwrap();\n         b.iter(|| {\n             for _ in 0..RAND_BENCH_N {\n-                rng.gen::<uint>();\n+                rng.gen::<usize>();\n             }\n         });\n-        b.bytes = size_of::<uint>() as u64 * RAND_BENCH_N;\n+        b.bytes = size_of::<usize>() as u64 * RAND_BENCH_N;\n     }\n \n     #[bench]\n     fn rand_shuffle_100(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        let x : &mut[uint] = &mut [1; 100];\n+        let x : &mut[usize] = &mut [1; 100];\n         b.iter(|| {\n             rng.shuffle(x);\n         })"}, {"sha": "ece6867ddcaa1e33f3d8639868cb992eecfc1be6", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -29,7 +29,7 @@ use result::Result::{Ok, Err};\n /// use std::old_io::MemReader;\n ///\n /// let mut rng = reader::ReaderRng::new(MemReader::new(vec!(1,2,3,4,5,6,7,8)));\n-/// println!(\"{:x}\", rng.gen::<uint>());\n+/// println!(\"{:x}\", rng.gen::<usize>());\n /// ```\n pub struct ReaderRng<R> {\n     reader: R"}, {"sha": "428bcaa49f7d918d2c0f8f25c763a5e11b866fe5", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -23,7 +23,7 @@ use core::prelude::*;\n use vec::Vec;\n \n /// One-time global initialization.\n-pub unsafe fn init(argc: int, argv: *const *const u8) { imp::init(argc, argv) }\n+pub unsafe fn init(argc: isize, argv: *const *const u8) { imp::init(argc, argv) }\n \n /// One-time global cleanup.\n pub unsafe fn cleanup() { imp::cleanup() }\n@@ -54,10 +54,10 @@ mod imp {\n \n     use sync::{StaticMutex, MUTEX_INIT};\n \n-    static mut GLOBAL_ARGS_PTR: uint = 0;\n+    static mut GLOBAL_ARGS_PTR: usize = 0;\n     static LOCK: StaticMutex = MUTEX_INIT;\n \n-    pub unsafe fn init(argc: int, argv: *const *const u8) {\n+    pub unsafe fn init(argc: isize, argv: *const *const u8) {\n         let args = load_argc_and_argv(argc, argv);\n         put(args);\n     }\n@@ -146,7 +146,7 @@ mod imp {\n     use core::prelude::*;\n     use vec::Vec;\n \n-    pub unsafe fn init(_argc: int, _argv: *const *const u8) {\n+    pub unsafe fn init(_argc: isize, _argv: *const *const u8) {\n     }\n \n     pub fn cleanup() {"}, {"sha": "b77699105646d3c009c451122f0fa4d87f5b7224", "filename": "src/libstd/rt/libunwind.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Frt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Frt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flibunwind.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -64,25 +64,25 @@ pub type _Unwind_Exception_Class = u64;\n pub type _Unwind_Word = libc::uintptr_t;\n \n #[cfg(target_arch = \"x86\")]\n-pub const unwinder_private_data_size: uint = 5;\n+pub const unwinder_private_data_size: usize = 5;\n \n #[cfg(target_arch = \"x86_64\")]\n-pub const unwinder_private_data_size: uint = 6;\n+pub const unwinder_private_data_size: usize = 6;\n \n #[cfg(all(target_arch = \"arm\", not(target_os = \"ios\")))]\n-pub const unwinder_private_data_size: uint = 20;\n+pub const unwinder_private_data_size: usize = 20;\n \n #[cfg(all(target_arch = \"arm\", target_os = \"ios\"))]\n-pub const unwinder_private_data_size: uint = 5;\n+pub const unwinder_private_data_size: usize = 5;\n \n #[cfg(target_arch = \"aarch64\")]\n-pub const unwinder_private_data_size: uint = 2;\n+pub const unwinder_private_data_size: usize = 2;\n \n #[cfg(any(target_arch = \"mips\", target_arch = \"mipsel\"))]\n-pub const unwinder_private_data_size: uint = 2;\n+pub const unwinder_private_data_size: usize = 2;\n \n #[cfg(target_arch = \"powerpc\")]\n-pub const unwinder_private_data_size: uint = 2;\n+pub const unwinder_private_data_size: usize = 2;\n \n #[repr(C)]\n pub struct _Unwind_Exception {"}, {"sha": "696c7960c3e6f4e11b71aa268c932c47ceabf6c2", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -48,16 +48,16 @@ mod libunwind;\n \n /// The default error code of the rust runtime if the main thread panics instead\n /// of exiting cleanly.\n-pub const DEFAULT_ERROR_CODE: int = 101;\n+pub const DEFAULT_ERROR_CODE: isize = 101;\n \n #[cfg(any(windows, android))]\n-const OS_DEFAULT_STACK_ESTIMATE: uint = 1 << 20;\n+const OS_DEFAULT_STACK_ESTIMATE: usize = 1 << 20;\n #[cfg(all(unix, not(android)))]\n-const OS_DEFAULT_STACK_ESTIMATE: uint = 2 * (1 << 20);\n+const OS_DEFAULT_STACK_ESTIMATE: usize = 2 * (1 << 20);\n \n #[cfg(not(test))]\n #[lang = \"start\"]\n-fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n+fn lang_start(main: *const u8, argc: isize, argv: *const *const u8) -> isize {\n     use prelude::v1::*;\n \n     use mem;\n@@ -68,13 +68,13 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n     use thread::Thread;\n \n     let something_around_the_top_of_the_stack = 1;\n-    let addr = &something_around_the_top_of_the_stack as *const _ as *const int;\n-    let my_stack_top = addr as uint;\n+    let addr = &something_around_the_top_of_the_stack as *const _ as *const isize;\n+    let my_stack_top = addr as usize;\n \n     // FIXME #11359 we just assume that this thread has a stack of a\n     // certain size, and estimate that there's at most 20KB of stack\n     // frames above our current position.\n-    const TWENTY_KB: uint = 20000;\n+    const TWENTY_KB: usize = 20000;\n \n     // saturating-add to sidestep overflow\n     let top_plus_spill = if usize::MAX - TWENTY_KB < my_stack_top {"}, {"sha": "e4927bbd3d274c5436b4bbeee00457e092f94a3e", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -78,12 +78,12 @@ struct Exception {\n     cause: Option<Box<Any + Send + 'static>>,\n }\n \n-pub type Callback = fn(msg: &(Any + Send), file: &'static str, line: uint);\n+pub type Callback = fn(msg: &(Any + Send), file: &'static str, line: usize);\n \n // Variables used for invoking callbacks when a thread starts to unwind.\n //\n // For more information, see below.\n-const MAX_CALLBACKS: uint = 16;\n+const MAX_CALLBACKS: usize = 16;\n static CALLBACKS: [atomic::AtomicUsize; MAX_CALLBACKS] =\n         [atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n          atomic::ATOMIC_USIZE_INIT, atomic::ATOMIC_USIZE_INIT,\n@@ -176,7 +176,7 @@ fn rust_panic(cause: Box<Any + Send + 'static>) -> ! {\n         };\n         let exception_param = boxed::into_raw(exception) as *mut uw::_Unwind_Exception;\n         let error = uw::_Unwind_RaiseException(exception_param);\n-        rtabort!(\"Could not unwind stack, error = {}\", error as int)\n+        rtabort!(\"Could not unwind stack, error = {}\", error as isize)\n     }\n \n     extern fn exception_cleanup(_unwind_code: uw::_Unwind_Reason_Code,\n@@ -484,7 +484,7 @@ pub mod eabi {\n /// Entry point of panic from the libcore crate.\n #[lang = \"panic_fmt\"]\n pub extern fn rust_begin_unwind(msg: fmt::Arguments,\n-                                file: &'static str, line: uint) -> ! {\n+                                file: &'static str, line: usize) -> ! {\n     begin_unwind_fmt(msg, &(file, line))\n }\n \n@@ -496,7 +496,7 @@ pub extern fn rust_begin_unwind(msg: fmt::Arguments,\n /// the actual formatting into this shared place.\n #[inline(never)] #[cold]\n #[stable(since = \"1.0.0\", feature = \"rust1\")]\n-pub fn begin_unwind_fmt(msg: fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n+pub fn begin_unwind_fmt(msg: fmt::Arguments, file_line: &(&'static str, usize)) -> ! {\n     use fmt::Write;\n \n     // We do two allocations here, unfortunately. But (a) they're\n@@ -512,7 +512,7 @@ pub fn begin_unwind_fmt(msg: fmt::Arguments, file_line: &(&'static str, uint)) -\n /// This is the entry point of unwinding for panic!() and assert!().\n #[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\n #[stable(since = \"1.0.0\", feature = \"rust1\")]\n-pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, uint)) -> ! {\n+pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, usize)) -> ! {\n     // Note that this should be the only allocation performed in this code path.\n     // Currently this means that panic!() on OOM will invoke this code path,\n     // but then again we're not really ready for panic on OOM anyway. If\n@@ -535,7 +535,7 @@ pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, uint)) ->\n /// }` from ~1900/3700 (-O/no opts) to 180/590.\n #[inline(never)] #[cold] // this is the slow path, please never inline this\n fn begin_unwind_inner(msg: Box<Any + Send>,\n-                      file_line: &(&'static str, uint)) -> ! {\n+                      file_line: &(&'static str, usize)) -> ! {\n     // Make sure the default failure handler is registered before we look at the\n     // callbacks. We also use a raw sys-based mutex here instead of a\n     // `std::sync` one as accessing TLS can cause weird recursive problems (and"}, {"sha": "5a482fbb50fec1d85f37cb50d13bedabd07f0ac9", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -43,7 +43,7 @@ pub fn limit_thread_creation_due_to_osx_and_valgrind() -> bool {\n     (cfg!(target_os=\"macos\")) && running_on_valgrind()\n }\n \n-pub fn min_stack() -> uint {\n+pub fn min_stack() -> usize {\n     static MIN: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n     match MIN.load(Ordering::SeqCst) {\n         0 => {}"}, {"sha": "b2b87bb6c44a757bcbd2014da07a40d7921e3b44", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -1109,13 +1109,13 @@ mod test {\n \n     #[test]\n     fn drop_full() {\n-        let (tx, _rx) = channel::<Box<int>>();\n+        let (tx, _rx) = channel::<Box<isize>>();\n         tx.send(box 1).unwrap();\n     }\n \n     #[test]\n     fn drop_full_shared() {\n-        let (tx, _rx) = channel::<Box<int>>();\n+        let (tx, _rx) = channel::<Box<isize>>();\n         drop(tx.clone());\n         drop(tx.clone());\n         tx.send(box 1).unwrap();\n@@ -1454,7 +1454,7 @@ mod test {\n     #[test]\n     fn oneshot_multi_thread_send_recv_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = channel::<Box<int>>();\n+            let (tx, rx) = channel::<Box<isize>>();\n             let _t = thread::spawn(move|| {\n                 tx.send(box 10).unwrap();\n             });\n@@ -1631,7 +1631,7 @@ mod sync_tests {\n \n     #[test]\n     fn drop_full() {\n-        let (tx, _rx) = sync_channel::<Box<int>>(1);\n+        let (tx, _rx) = sync_channel::<Box<isize>>(1);\n         tx.send(box 1).unwrap();\n     }\n "}, {"sha": "80cbd0761638ff398bc2f4c79a69e7822161b7f7", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -398,7 +398,7 @@ impl<T: Send> Packet<T> {\n     }\n \n     // increment the count on the channel (used for selection)\n-    fn bump(&mut self, amt: int) -> int {\n+    fn bump(&mut self, amt: isize) -> isize {\n         match self.cnt.fetch_add(amt, Ordering::SeqCst) {\n             DISCONNECTED => {\n                 self.cnt.store(DISCONNECTED, Ordering::SeqCst);"}, {"sha": "a79ffaa0860e3673f349396ff880394358d8740b", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -551,7 +551,7 @@ mod tests {\n         let arc2 = arc.clone();\n         let _ = thread::spawn(move|| -> () {\n             struct Unwinder {\n-                i: Arc<RwLock<int>>,\n+                i: Arc<RwLock<isize>>,\n             }\n             impl Drop for Unwinder {\n                 fn drop(&mut self) {"}, {"sha": "be521095aa95f9fa1aeaaa46d457eb1dd2c7d584", "filename": "src/libstd/sync/semaphore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -44,7 +44,7 @@ use sync::{Mutex, Condvar};\n /// sem.release();\n /// ```\n pub struct Semaphore {\n-    lock: Mutex<int>,\n+    lock: Mutex<isize>,\n     cvar: Condvar,\n }\n \n@@ -60,7 +60,7 @@ impl Semaphore {\n     /// The count specified can be thought of as a number of resources, and a\n     /// call to `acquire` or `access` will block until at least one resource is\n     /// available. It is valid to initialize a semaphore with a negative count.\n-    pub fn new(count: int) -> Semaphore {\n+    pub fn new(count: isize) -> Semaphore {\n         Semaphore {\n             lock: Mutex::new(count),\n             cvar: Condvar::new(),"}, {"sha": "cd118b3c9eefe609394f3d71c902691aaa2ade98", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -14,10 +14,10 @@ use io::prelude::*;\n use io;\n \n #[cfg(target_pointer_width = \"64\")]\n-pub const HEX_WIDTH: uint = 18;\n+pub const HEX_WIDTH: usize = 18;\n \n #[cfg(target_pointer_width = \"32\")]\n-pub const HEX_WIDTH: uint = 10;\n+pub const HEX_WIDTH: usize = 10;\n \n // All rust symbols are in theory lists of \"::\"-separated identifiers. Some\n // assemblers, however, can't handle these characters in symbol names. To get\n@@ -57,7 +57,7 @@ pub fn demangle(writer: &mut Write, s: &str) -> io::Result<()> {\n             let mut i = 0;\n             for c in chars.by_ref() {\n                 if c.is_numeric() {\n-                    i = i * 10 + c as uint - '0' as uint;\n+                    i = i * 10 + c as usize - '0' as usize;\n                 } else {\n                     break\n                 }\n@@ -86,7 +86,7 @@ pub fn demangle(writer: &mut Write, s: &str) -> io::Result<()> {\n             while rest.char_at(0).is_numeric() {\n                 rest = &rest[1..];\n             }\n-            let i: uint = inner[.. (inner.len() - rest.len())].parse().unwrap();\n+            let i: usize = inner[.. (inner.len() - rest.len())].parse().unwrap();\n             inner = &rest[i..];\n             rest = &rest[..i];\n             while rest.len() > 0 {"}, {"sha": "34a58f6c83aa73002f781376b81c0bc049f211a5", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -51,7 +51,7 @@ pub struct Helper<M:Send> {\n     pub chan: UnsafeCell<*mut Sender<M>>,\n \n     /// OS handle used to wake up a blocked helper thread\n-    pub signal: UnsafeCell<uint>,\n+    pub signal: UnsafeCell<usize>,\n \n     /// Flag if this helper thread has booted and been initialized yet.\n     pub initialized: UnsafeCell<bool>,\n@@ -96,11 +96,11 @@ impl<M: Send> Helper<M> {\n     {\n         unsafe {\n             let _guard = self.lock.lock().unwrap();\n-            if *self.chan.get() as uint == 0 {\n+            if *self.chan.get() as usize == 0 {\n                 let (tx, rx) = channel();\n                 *self.chan.get() = boxed::into_raw(box tx);\n                 let (receive, send) = helper_signal::new();\n-                *self.signal.get() = send as uint;\n+                *self.signal.get() = send as usize;\n \n                 let receive = RaceBox(receive);\n \n@@ -114,7 +114,7 @@ impl<M: Send> Helper<M> {\n \n                 let _ = rt::at_exit(move || { self.shutdown() });\n                 *self.initialized.get() = true;\n-            } else if *self.chan.get() as uint == 1 {\n+            } else if *self.chan.get() as usize == 1 {\n                 panic!(\"cannot continue usage after shutdown\");\n             }\n         }\n@@ -130,8 +130,8 @@ impl<M: Send> Helper<M> {\n             // Must send and *then* signal to ensure that the child receives the\n             // message. Otherwise it could wake up and go to sleep before we\n             // send the message.\n-            assert!(*self.chan.get() as uint != 0);\n-            assert!(*self.chan.get() as uint != 1,\n+            assert!(*self.chan.get() as usize != 0);\n+            assert!(*self.chan.get() as usize != 1,\n                     \"cannot continue usage after shutdown\");\n             (**self.chan.get()).send(msg).unwrap();\n             helper_signal::signal(*self.signal.get() as helper_signal::signal);\n@@ -146,7 +146,7 @@ impl<M: Send> Helper<M> {\n             let mut guard = self.lock.lock().unwrap();\n \n             let ptr = *self.chan.get();\n-            if ptr as uint == 1 {\n+            if ptr as usize == 1 {\n                 panic!(\"cannot continue usage after shutdown\");\n             }\n             // Close the channel by destroying it"}, {"sha": "a8769ba99e8b368c4c34168b6053bdf611b316f7", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -56,7 +56,7 @@ pub fn timeout(desc: &'static str) -> IoError {\n }\n \n #[allow(deprecated)]\n-pub fn short_write(n: uint, desc: &'static str) -> IoError {\n+pub fn short_write(n: usize, desc: &'static str) -> IoError {\n     IoError {\n         kind: if n == 0 { old_io::TimedOut } else { old_io::ShortWrite(n) },\n         desc: desc,\n@@ -84,7 +84,7 @@ pub fn mkerr_libc<T: Int>(ret: T) -> IoResult<()> {\n }\n \n pub fn keep_going<F>(data: &[u8], mut f: F) -> i64 where\n-    F: FnMut(*const u8, uint) -> i64,\n+    F: FnMut(*const u8, usize) -> i64,\n {\n     let origamt = data.len();\n     let mut data = data.as_ptr();\n@@ -94,8 +94,8 @@ pub fn keep_going<F>(data: &[u8], mut f: F) -> i64 where\n         if ret == 0 {\n             break\n         } else if ret != -1 {\n-            amt -= ret as uint;\n-            data = unsafe { data.offset(ret as int) };\n+            amt -= ret as usize;\n+            data = unsafe { data.offset(ret as isize) };\n         } else {\n             return ret;\n         }\n@@ -134,7 +134,7 @@ pub trait ProcessConfig<K: BytesContainer, V: BytesContainer> {\n     fn args(&self) -> &[CString];\n     fn env(&self) -> Option<&collections::HashMap<K, V>>;\n     fn cwd(&self) -> Option<&CString>;\n-    fn uid(&self) -> Option<uint>;\n-    fn gid(&self) -> Option<uint>;\n+    fn uid(&self) -> Option<usize>;\n+    fn gid(&self) -> Option<usize>;\n     fn detach(&self) -> bool;\n }"}, {"sha": "1a0ee17904a243afa274b3b6347b2e43145feb22", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -148,7 +148,7 @@ pub fn getsockopt<T: Copy>(fd: sock_t, opt: libc::c_int,\n         if ret != 0 {\n             Err(last_net_error())\n         } else {\n-            assert!(len as uint == mem::size_of::<T>());\n+            assert!(len as usize == mem::size_of::<T>());\n             Ok(slot)\n         }\n     }\n@@ -170,14 +170,14 @@ pub fn sockname(fd: sock_t,\n             return Err(last_net_error())\n         }\n     }\n-    return sockaddr_to_addr(&storage, len as uint);\n+    return sockaddr_to_addr(&storage, len as usize);\n }\n \n pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n-                        len: uint) -> IoResult<SocketAddr> {\n+                        len: usize) -> IoResult<SocketAddr> {\n     match storage.ss_family as libc::c_int {\n         libc::AF_INET => {\n-            assert!(len as uint >= mem::size_of::<libc::sockaddr_in>());\n+            assert!(len as usize >= mem::size_of::<libc::sockaddr_in>());\n             let storage: &libc::sockaddr_in = unsafe {\n                 mem::transmute(storage)\n             };\n@@ -192,7 +192,7 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n             })\n         }\n         libc::AF_INET6 => {\n-            assert!(len as uint >= mem::size_of::<libc::sockaddr_in6>());\n+            assert!(len as usize >= mem::size_of::<libc::sockaddr_in6>());\n             let storage: &libc::sockaddr_in6 = unsafe {\n                 mem::transmute(storage)\n             };\n@@ -283,13 +283,13 @@ pub fn get_host_addresses(host: Option<&str>, servname: Option<&str>,\n     while !rp.is_null() {\n         unsafe {\n             let addr = try!(sockaddr_to_addr(mem::transmute((*rp).ai_addr),\n-                                             (*rp).ai_addrlen as uint));\n+                                             (*rp).ai_addrlen as usize));\n             addrs.push(addrinfo::Info {\n                 address: addr,\n-                family: (*rp).ai_family as uint,\n+                family: (*rp).ai_family as usize,\n                 socktype: None,\n                 protocol: None,\n-                flags: (*rp).ai_flags as uint\n+                flags: (*rp).ai_flags as usize\n             });\n \n             rp = (*rp).ai_next as *mut libc::addrinfo;\n@@ -312,7 +312,7 @@ extern \"system\" {\n         flags: c_int) -> c_int;\n }\n \n-const NI_MAXHOST: uint = 1025;\n+const NI_MAXHOST: usize = 1025;\n \n pub fn get_address_name(addr: IpAddr) -> Result<String, IoError> {\n     let addr = SocketAddr{ip: addr, port: 0};\n@@ -393,7 +393,7 @@ pub fn get_address_name(addr: IpAddr) -> Result<String, IoError> {\n // [1] http://twistedmatrix.com/pipermail/twisted-commits/2012-April/034692.html\n // [2] http://stackoverflow.com/questions/19819198/does-send-msg-dontwait\n \n-pub fn read<T, L, R>(fd: sock_t, deadline: u64, mut lock: L, mut read: R) -> IoResult<uint> where\n+pub fn read<T, L, R>(fd: sock_t, deadline: u64, mut lock: L, mut read: R) -> IoResult<usize> where\n     L: FnMut() -> T,\n     R: FnMut(bool) -> libc::c_int,\n {\n@@ -431,7 +431,7 @@ pub fn read<T, L, R>(fd: sock_t, deadline: u64, mut lock: L, mut read: R) -> IoR\n     match ret {\n         0 => Err(sys_common::eof()),\n         n if n < 0 => Err(last_net_error()),\n-        n => Ok(n as uint)\n+        n => Ok(n as usize)\n     }\n }\n \n@@ -440,9 +440,9 @@ pub fn write<T, L, W>(fd: sock_t,\n                       buf: &[u8],\n                       write_everything: bool,\n                       mut lock: L,\n-                      mut write: W) -> IoResult<uint> where\n+                      mut write: W) -> IoResult<usize> where\n     L: FnMut() -> T,\n-    W: FnMut(bool, *const u8, uint) -> i64,\n+    W: FnMut(bool, *const u8, usize) -> i64,\n {\n     let mut ret = -1;\n     let mut written = 0;\n@@ -454,7 +454,7 @@ pub fn write<T, L, W>(fd: sock_t,\n             });\n         } else {\n             ret = retry(|| { write(false, buf.as_ptr(), buf.len()) });\n-            if ret > 0 { written = ret as uint; }\n+            if ret > 0 { written = ret as usize; }\n         }\n     }\n \n@@ -483,7 +483,7 @@ pub fn write<T, L, W>(fd: sock_t,\n             match retry(|| write(deadline.is_some(), ptr, len)) {\n                 -1 if wouldblock() => {}\n                 -1 => return Err(last_net_error()),\n-                n => { written += n as uint; }\n+                n => { written += n as usize; }\n             }\n         }\n         ret = 0;\n@@ -513,8 +513,8 @@ pub fn connect_timeout(fd: sock_t,\n         // If the connection is in progress, then we need to wait for it to\n         // finish (with a timeout). The current strategy for doing this is\n         // to use select() with a timeout.\n-        -1 if os::errno() as int == INPROGRESS as int ||\n-              os::errno() as int == WOULDBLOCK as int => {\n+        -1 if os::errno() as isize == INPROGRESS as isize ||\n+              os::errno() as isize == WOULDBLOCK as isize => {\n             let mut set: c::fd_set = unsafe { mem::zeroed() };\n             c::fd_set(&mut set, fd);\n             match await(fd, &mut set, timeout_ms) {\n@@ -686,7 +686,7 @@ impl TcpStream {\n                    nodelay as libc::c_int)\n     }\n \n-    pub fn set_keepalive(&mut self, seconds: Option<uint>) -> IoResult<()> {\n+    pub fn set_keepalive(&mut self, seconds: Option<usize>) -> IoResult<()> {\n         let ret = setsockopt(self.fd(), libc::SOL_SOCKET, libc::SO_KEEPALIVE,\n                              seconds.is_some() as libc::c_int);\n         match seconds {\n@@ -696,18 +696,18 @@ impl TcpStream {\n     }\n \n     #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-    fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> {\n+    fn set_tcp_keepalive(&mut self, seconds: usize) -> IoResult<()> {\n         setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_KEEPALIVE,\n                    seconds as libc::c_int)\n     }\n     #[cfg(any(target_os = \"freebsd\",\n               target_os = \"dragonfly\"))]\n-    fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> {\n+    fn set_tcp_keepalive(&mut self, seconds: usize) -> IoResult<()> {\n         setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_KEEPIDLE,\n                    seconds as libc::c_int)\n     }\n     #[cfg(target_os = \"openbsd\")]\n-    fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> {\n+    fn set_tcp_keepalive(&mut self, seconds: usize) -> IoResult<()> {\n         setsockopt(self.fd(), libc::IPPROTO_TCP, libc::SO_KEEPALIVE,\n                    seconds as libc::c_int)\n     }\n@@ -716,7 +716,7 @@ impl TcpStream {\n                   target_os = \"freebsd\",\n                   target_os = \"dragonfly\",\n                   target_os = \"openbsd\")))]\n-    fn set_tcp_keepalive(&mut self, _seconds: uint) -> IoResult<()> {\n+    fn set_tcp_keepalive(&mut self, _seconds: usize) -> IoResult<()> {\n         Ok(())\n     }\n \n@@ -733,7 +733,7 @@ impl TcpStream {\n         ret\n     }\n \n-    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         let fd = self.fd();\n         let dolock = || self.lock_nonblocking();\n         let doread = |nb| unsafe {\n@@ -749,7 +749,7 @@ impl TcpStream {\n     pub fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let fd = self.fd();\n         let dolock = || self.lock_nonblocking();\n-        let dowrite = |nb: bool, buf: *const u8, len: uint| unsafe {\n+        let dowrite = |nb: bool, buf: *const u8, len: usize| unsafe {\n             let flags = if nb {c::MSG_DONTWAIT} else {0};\n             libc::send(fd,\n                        buf as *const _,\n@@ -876,7 +876,7 @@ impl UdpSocket {\n         sockname(self.fd(), libc::getsockname)\n     }\n \n-    pub fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(uint, SocketAddr)> {\n+    pub fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(usize, SocketAddr)> {\n         let fd = self.fd();\n         let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n         let storagep = &mut storage as *mut _ as *mut libc::sockaddr;\n@@ -893,7 +893,7 @@ impl UdpSocket {\n                            storagep,\n                            &mut addrlen) as libc::c_int\n         }));\n-        Ok((n as uint, sockaddr_to_addr(&storage, addrlen as uint).unwrap()))\n+        Ok((n as usize, sockaddr_to_addr(&storage, addrlen as usize).unwrap()))\n     }\n \n     pub fn send_to(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> {\n@@ -903,7 +903,7 @@ impl UdpSocket {\n \n         let fd = self.fd();\n         let dolock = || self.lock_nonblocking();\n-        let dowrite = |nb, buf: *const u8, len: uint| unsafe {\n+        let dowrite = |nb, buf: *const u8, len: usize| unsafe {\n             let flags = if nb {c::MSG_DONTWAIT} else {0};\n             libc::sendto(fd,\n                          buf as *const libc::c_void,\n@@ -939,11 +939,11 @@ impl UdpSocket {\n         }\n     }\n \n-    pub fn multicast_time_to_live(&mut self, ttl: int) -> IoResult<()> {\n+    pub fn multicast_time_to_live(&mut self, ttl: isize) -> IoResult<()> {\n         setsockopt(self.fd(), libc::IPPROTO_IP, libc::IP_MULTICAST_TTL,\n                    ttl as libc::c_int)\n     }\n-    pub fn time_to_live(&mut self, ttl: int) -> IoResult<()> {\n+    pub fn time_to_live(&mut self, ttl: isize) -> IoResult<()> {\n         setsockopt(self.fd(), libc::IPPROTO_IP, libc::IP_TTL, ttl as libc::c_int)\n     }\n "}, {"sha": "8dc3407db77a20f27b51818ddd6dec3c0d40c7b4", "filename": "src/libstd/sys/common/stack.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fstack.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -46,7 +46,7 @@\n // corresponding prolog, decision was taken to disable segmented\n // stack support on iOS.\n \n-pub const RED_ZONE: uint = 20 * 1024;\n+pub const RED_ZONE: usize = 20 * 1024;\n \n /// This function is invoked from rust's current __morestack function. Segmented\n /// stacks are currently not enabled as segmented stacks, but rather one giant\n@@ -117,7 +117,7 @@ extern fn stack_exhausted() {\n // On all other platforms both variants behave identically.\n \n #[inline(always)]\n-pub unsafe fn record_os_managed_stack_bounds(stack_lo: uint, _stack_hi: uint) {\n+pub unsafe fn record_os_managed_stack_bounds(stack_lo: usize, _stack_hi: usize) {\n     record_sp_limit(stack_lo + RED_ZONE);\n }\n \n@@ -136,50 +136,50 @@ pub unsafe fn record_os_managed_stack_bounds(stack_lo: uint, _stack_hi: uint) {\n /// would be unfortunate for the functions themselves to trigger a morestack\n /// invocation (if they were an actual function call).\n #[inline(always)]\n-pub unsafe fn record_sp_limit(limit: uint) {\n+pub unsafe fn record_sp_limit(limit: usize) {\n     return target_record_sp_limit(limit);\n \n     // x86-64\n     #[cfg(all(target_arch = \"x86_64\",\n               any(target_os = \"macos\", target_os = \"ios\")))]\n     #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: uint) {\n+    unsafe fn target_record_sp_limit(limit: usize) {\n         asm!(\"movq $$0x60+90*8, %rsi\n               movq $0, %gs:(%rsi)\" :: \"r\"(limit) : \"rsi\" : \"volatile\")\n     }\n     #[cfg(all(target_arch = \"x86_64\", target_os = \"linux\"))] #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: uint) {\n+    unsafe fn target_record_sp_limit(limit: usize) {\n         asm!(\"movq $0, %fs:112\" :: \"r\"(limit) :: \"volatile\")\n     }\n     #[cfg(all(target_arch = \"x86_64\", target_os = \"windows\"))] #[inline(always)]\n-    unsafe fn target_record_sp_limit(_: uint) {\n+    unsafe fn target_record_sp_limit(_: usize) {\n     }\n     #[cfg(all(target_arch = \"x86_64\", target_os = \"freebsd\"))] #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: uint) {\n+    unsafe fn target_record_sp_limit(limit: usize) {\n         asm!(\"movq $0, %fs:24\" :: \"r\"(limit) :: \"volatile\")\n     }\n     #[cfg(all(target_arch = \"x86_64\", target_os = \"dragonfly\"))]\n     #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: uint) {\n+    unsafe fn target_record_sp_limit(limit: usize) {\n         asm!(\"movq $0, %fs:32\" :: \"r\"(limit) :: \"volatile\")\n     }\n \n     // x86\n     #[cfg(all(target_arch = \"x86\",\n               any(target_os = \"macos\", target_os = \"ios\")))]\n     #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: uint) {\n+    unsafe fn target_record_sp_limit(limit: usize) {\n         asm!(\"movl $$0x48+90*4, %eax\n               movl $0, %gs:(%eax)\" :: \"r\"(limit) : \"eax\" : \"volatile\")\n     }\n     #[cfg(all(target_arch = \"x86\",\n               any(target_os = \"linux\", target_os = \"freebsd\")))]\n     #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: uint) {\n+    unsafe fn target_record_sp_limit(limit: usize) {\n         asm!(\"movl $0, %gs:48\" :: \"r\"(limit) :: \"volatile\")\n     }\n     #[cfg(all(target_arch = \"x86\", target_os = \"windows\"))] #[inline(always)]\n-    unsafe fn target_record_sp_limit(_: uint) {\n+    unsafe fn target_record_sp_limit(_: usize) {\n     }\n \n     // mips, arm - Some brave soul can port these to inline asm, but it's over\n@@ -188,7 +188,7 @@ pub unsafe fn record_sp_limit(limit: uint) {\n               target_arch = \"mipsel\",\n               all(target_arch = \"arm\", not(target_os = \"ios\"))))]\n     #[inline(always)]\n-    unsafe fn target_record_sp_limit(limit: uint) {\n+    unsafe fn target_record_sp_limit(limit: usize) {\n         use libc::c_void;\n         return record_sp_limit(limit as *const c_void);\n         extern {\n@@ -205,7 +205,7 @@ pub unsafe fn record_sp_limit(limit: uint) {\n               all(target_arch = \"arm\", target_os = \"ios\"),\n               target_os = \"bitrig\",\n               target_os = \"openbsd\"))]\n-    unsafe fn target_record_sp_limit(_: uint) {\n+    unsafe fn target_record_sp_limit(_: usize) {\n     }\n }\n \n@@ -218,38 +218,38 @@ pub unsafe fn record_sp_limit(limit: uint) {\n /// As with the setter, this function does not have a __morestack header and can\n /// therefore be called in a \"we're out of stack\" situation.\n #[inline(always)]\n-pub unsafe fn get_sp_limit() -> uint {\n+pub unsafe fn get_sp_limit() -> usize {\n     return target_get_sp_limit();\n \n     // x86-64\n     #[cfg(all(target_arch = \"x86_64\",\n               any(target_os = \"macos\", target_os = \"ios\")))]\n     #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> uint {\n+    unsafe fn target_get_sp_limit() -> usize {\n         let limit;\n         asm!(\"movq $$0x60+90*8, %rsi\n               movq %gs:(%rsi), $0\" : \"=r\"(limit) :: \"rsi\" : \"volatile\");\n         return limit;\n     }\n     #[cfg(all(target_arch = \"x86_64\", target_os = \"linux\"))] #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> uint {\n+    unsafe fn target_get_sp_limit() -> usize {\n         let limit;\n         asm!(\"movq %fs:112, $0\" : \"=r\"(limit) ::: \"volatile\");\n         return limit;\n     }\n     #[cfg(all(target_arch = \"x86_64\", target_os = \"windows\"))] #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> uint {\n+    unsafe fn target_get_sp_limit() -> usize {\n         return 1024;\n     }\n     #[cfg(all(target_arch = \"x86_64\", target_os = \"freebsd\"))] #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> uint {\n+    unsafe fn target_get_sp_limit() -> usize {\n         let limit;\n         asm!(\"movq %fs:24, $0\" : \"=r\"(limit) ::: \"volatile\");\n         return limit;\n     }\n     #[cfg(all(target_arch = \"x86_64\", target_os = \"dragonfly\"))]\n     #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> uint {\n+    unsafe fn target_get_sp_limit() -> usize {\n         let limit;\n         asm!(\"movq %fs:32, $0\" : \"=r\"(limit) ::: \"volatile\");\n         return limit;\n@@ -259,7 +259,7 @@ pub unsafe fn get_sp_limit() -> uint {\n     #[cfg(all(target_arch = \"x86\",\n               any(target_os = \"macos\", target_os = \"ios\")))]\n     #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> uint {\n+    unsafe fn target_get_sp_limit() -> usize {\n         let limit;\n         asm!(\"movl $$0x48+90*4, %eax\n               movl %gs:(%eax), $0\" : \"=r\"(limit) :: \"eax\" : \"volatile\");\n@@ -268,13 +268,13 @@ pub unsafe fn get_sp_limit() -> uint {\n     #[cfg(all(target_arch = \"x86\",\n               any(target_os = \"linux\", target_os = \"freebsd\")))]\n     #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> uint {\n+    unsafe fn target_get_sp_limit() -> usize {\n         let limit;\n         asm!(\"movl %gs:48, $0\" : \"=r\"(limit) ::: \"volatile\");\n         return limit;\n     }\n     #[cfg(all(target_arch = \"x86\", target_os = \"windows\"))] #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> uint {\n+    unsafe fn target_get_sp_limit() -> usize {\n         return 1024;\n     }\n \n@@ -284,9 +284,9 @@ pub unsafe fn get_sp_limit() -> uint {\n               target_arch = \"mipsel\",\n               all(target_arch = \"arm\", not(target_os = \"ios\"))))]\n     #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> uint {\n+    unsafe fn target_get_sp_limit() -> usize {\n         use libc::c_void;\n-        return get_sp_limit() as uint;\n+        return get_sp_limit() as usize;\n         extern {\n             fn get_sp_limit() -> *const c_void;\n         }\n@@ -305,7 +305,7 @@ pub unsafe fn get_sp_limit() -> uint {\n               target_os = \"bitrig\",\n               target_os = \"openbsd\"))]\n     #[inline(always)]\n-    unsafe fn target_get_sp_limit() -> uint {\n+    unsafe fn target_get_sp_limit() -> usize {\n         1024\n     }\n }"}, {"sha": "22cb59433713043dbaf2a3409072e147e13901c5", "filename": "src/libstd/sys/common/thread_info.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -18,7 +18,7 @@ use thread::Thread;\n use thread::LocalKeyState;\n \n struct ThreadInfo {\n-    stack_guard: uint,\n+    stack_guard: usize,\n     thread: Thread,\n }\n \n@@ -47,11 +47,11 @@ pub fn current_thread() -> Thread {\n     ThreadInfo::with(|info| info.thread.clone())\n }\n \n-pub fn stack_guard() -> uint {\n+pub fn stack_guard() -> usize {\n     ThreadInfo::with(|info| info.stack_guard)\n }\n \n-pub fn set(stack_guard: uint, thread: Thread) {\n+pub fn set(stack_guard: usize, thread: Thread) {\n     THREAD_INFO.with(|c| assert!(c.borrow().is_none()));\n     THREAD_INFO.with(move |c| *c.borrow_mut() = Some(ThreadInfo{\n         stack_guard: stack_guard,"}, {"sha": "5995d7ac10f73d7b3270c9ab22f3303d20905c37", "filename": "src/libstd/sys/common/thread_local.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -178,7 +178,7 @@ impl StaticKey {\n         }\n     }\n \n-    unsafe fn lazy_init(&self) -> uint {\n+    unsafe fn lazy_init(&self) -> usize {\n         // POSIX allows the key created here to be 0, but the compare_and_swap\n         // below relies on using 0 as a sentinel value to check who won the\n         // race to set the shared TLS key. As far as I know, there is no\n@@ -197,9 +197,9 @@ impl StaticKey {\n             key2\n         };\n         assert!(key != 0);\n-        match self.inner.key.compare_and_swap(0, key as uint, Ordering::SeqCst) {\n+        match self.inner.key.compare_and_swap(0, key as usize, Ordering::SeqCst) {\n             // The CAS succeeded, so we've created the actual key\n-            0 => key as uint,\n+            0 => key as usize,\n             // If someone beat us to the punch, use their key instead\n             n => { imp::destroy(key); n }\n         }\n@@ -261,8 +261,8 @@ mod tests {\n         assert!(k2.get().is_null());\n         k1.set(1 as *mut _);\n         k2.set(2 as *mut _);\n-        assert_eq!(k1.get() as uint, 1);\n-        assert_eq!(k2.get() as uint, 2);\n+        assert_eq!(k1.get() as usize, 1);\n+        assert_eq!(k2.get() as usize, 2);\n     }\n \n     #[test]\n@@ -275,8 +275,8 @@ mod tests {\n             assert!(K2.get().is_null());\n             K1.set(1 as *mut _);\n             K2.set(2 as *mut _);\n-            assert_eq!(K1.get() as uint, 1);\n-            assert_eq!(K2.get() as uint, 2);\n+            assert_eq!(K1.get() as usize, 1);\n+            assert_eq!(K2.get() as usize, 2);\n         }\n     }\n }"}, {"sha": "7efe7d96b7190a9e67cfa2ef6e7ff92158139ac5", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -158,7 +158,7 @@ impl Wtf8Buf {\n \n     /// Create an new, empty WTF-8 string with pre-allocated capacity for `n` bytes.\n     #[inline]\n-    pub fn with_capacity(n: uint) -> Wtf8Buf {\n+    pub fn with_capacity(n: usize) -> Wtf8Buf {\n         Wtf8Buf { bytes: Vec::with_capacity(n) }\n     }\n \n@@ -214,7 +214,7 @@ impl Wtf8Buf {\n             // Attempt to not use an intermediate buffer by just pushing bytes\n             // directly onto this string.\n             let slice = slice::from_raw_parts_mut(\n-                self.bytes.as_mut_ptr().offset(cur_len as int),\n+                self.bytes.as_mut_ptr().offset(cur_len as isize),\n                 4\n             );\n             let used = encode_utf8_raw(code_point.value, mem::transmute(slice))\n@@ -234,15 +234,15 @@ impl Wtf8Buf {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `uint`.\n+    /// Panics if the new capacity overflows `usize`.\n     #[inline]\n-    pub fn reserve(&mut self, additional: uint) {\n+    pub fn reserve(&mut self, additional: usize) {\n         self.bytes.reserve(additional)\n     }\n \n     /// Returns the number of bytes that this string buffer can hold without reallocating.\n     #[inline]\n-    pub fn capacity(&self) -> uint {\n+    pub fn capacity(&self) -> usize {\n         self.bytes.capacity()\n     }\n \n@@ -313,7 +313,7 @@ impl Wtf8Buf {\n     /// Panics if `new_len` > current length,\n     /// or if `new_len` is not a code point boundary.\n     #[inline]\n-    pub fn truncate(&mut self, new_len: uint) {\n+    pub fn truncate(&mut self, new_len: usize) {\n         assert!(is_code_point_boundary(self, new_len));\n         self.bytes.truncate(new_len)\n     }\n@@ -463,7 +463,7 @@ impl Wtf8 {\n \n     /// Return the length, in WTF-8 bytes.\n     #[inline]\n-    pub fn len(&self) -> uint {\n+    pub fn len(&self) -> usize {\n         self.bytes.len()\n     }\n \n@@ -474,7 +474,7 @@ impl Wtf8 {\n     ///\n     /// Panics if `position` is beyond the end of the string.\n     #[inline]\n-    pub fn ascii_byte_at(&self, position: uint) -> u8 {\n+    pub fn ascii_byte_at(&self, position: usize) -> u8 {\n         match self.bytes[position] {\n             ascii_byte @ 0x00 ... 0x7F => ascii_byte,\n             _ => 0xFF\n@@ -488,7 +488,7 @@ impl Wtf8 {\n     /// Panics if `position` is not at a code point boundary,\n     /// or is beyond the end of the string.\n     #[inline]\n-    pub fn code_point_at(&self, position: uint) -> CodePoint {\n+    pub fn code_point_at(&self, position: usize) -> CodePoint {\n         let (code_point, _) = self.code_point_range_at(position);\n         code_point\n     }\n@@ -501,7 +501,7 @@ impl Wtf8 {\n     /// Panics if `position` is not at a code point boundary,\n     /// or is beyond the end of the string.\n     #[inline]\n-    pub fn code_point_range_at(&self, position: uint) -> (CodePoint, uint) {\n+    pub fn code_point_range_at(&self, position: usize) -> (CodePoint, usize) {\n         let (c, n) = char_range_at_raw(&self.bytes, position);\n         (CodePoint { value: c }, n)\n     }\n@@ -570,7 +570,7 @@ impl Wtf8 {\n     }\n \n     #[inline]\n-    fn next_surrogate(&self, mut pos: uint) -> Option<(uint, u16)> {\n+    fn next_surrogate(&self, mut pos: usize) -> Option<(usize, u16)> {\n         let mut iter = self.bytes[pos..].iter();\n         loop {\n             let b = match iter.next() {\n@@ -792,7 +792,7 @@ fn decode_surrogate_pair(lead: u16, trail: u16) -> char {\n \n /// Copied from core::str::StrPrelude::is_char_boundary\n #[inline]\n-pub fn is_code_point_boundary(slice: &Wtf8, index: uint) -> bool {\n+pub fn is_code_point_boundary(slice: &Wtf8, index: usize) -> bool {\n     if index == slice.len() { return true; }\n     match slice.bytes.get(index) {\n         None => false,\n@@ -802,17 +802,17 @@ pub fn is_code_point_boundary(slice: &Wtf8, index: uint) -> bool {\n \n /// Copied from core::str::raw::slice_unchecked\n #[inline]\n-pub unsafe fn slice_unchecked(s: &Wtf8, begin: uint, end: uint) -> &Wtf8 {\n+pub unsafe fn slice_unchecked(s: &Wtf8, begin: usize, end: usize) -> &Wtf8 {\n     // memory layout of an &[u8] and &Wtf8 are the same\n     mem::transmute(slice::from_raw_parts(\n-        s.bytes.as_ptr().offset(begin as int),\n+        s.bytes.as_ptr().offset(begin as isize),\n         end - begin\n     ))\n }\n \n /// Copied from core::str::raw::slice_error_fail\n #[inline(never)]\n-pub fn slice_error_fail(s: &Wtf8, begin: uint, end: uint) -> ! {\n+pub fn slice_error_fail(s: &Wtf8, begin: usize, end: usize) -> ! {\n     assert!(begin <= end);\n     panic!(\"index {} and/or {} in `{:?}` do not lie on character boundary\",\n           begin, end, s);\n@@ -835,7 +835,7 @@ impl<'a> Iterator for Wtf8CodePoints<'a> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (len, _) = self.bytes.size_hint();\n         (len.saturating_add(3) / 4, Some(len))\n     }\n@@ -869,7 +869,7 @@ impl<'a> Iterator for EncodeWide<'a> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (low, high) = self.code_points.size_hint();\n         // every code point gets either one u16 or two u16,\n         // so this iterator is between 1 or 2 times as"}, {"sha": "b46d390826c93934cf292746b2e5b92634297835", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -128,7 +128,7 @@ pub fn write(w: &mut Write) -> io::Result<()> {\n \n     // skipping the first one as it is write itself\n     let iter = (1..cnt).map(|i| {\n-        print(w, i as int, buf[i], buf[i])\n+        print(w, i as isize, buf[i], buf[i])\n     });\n     result::fold(iter, (), |_, _| ())\n }\n@@ -138,7 +138,7 @@ pub fn write(w: &mut Write) -> io::Result<()> {\n                  // tracing\n pub fn write(w: &mut Write) -> io::Result<()> {\n     struct Context<'a> {\n-        idx: int,\n+        idx: isize,\n         writer: &'a mut (Write+'a),\n         last_error: Option<io::Error>,\n     }\n@@ -222,7 +222,7 @@ pub fn write(w: &mut Write) -> io::Result<()> {\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-fn print(w: &mut Write, idx: int, addr: *mut libc::c_void,\n+fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n          _symaddr: *mut libc::c_void) -> io::Result<()> {\n     use intrinsics;\n     #[repr(C)]\n@@ -248,7 +248,7 @@ fn print(w: &mut Write, idx: int, addr: *mut libc::c_void,\n }\n \n #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n-fn print(w: &mut Write, idx: int, addr: *mut libc::c_void,\n+fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n          symaddr: *mut libc::c_void) -> io::Result<()> {\n     use env;\n     use ffi::AsOsStr;\n@@ -441,7 +441,7 @@ fn print(w: &mut Write, idx: int, addr: *mut libc::c_void,\n }\n \n // Finally, after all that work above, we can emit a symbol.\n-fn output(w: &mut Write, idx: int, addr: *mut libc::c_void,\n+fn output(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n           s: Option<&[u8]>) -> io::Result<()> {\n     try!(write!(w, \"  {:2}: {:2$?} - \", idx, addr, HEX_WIDTH));\n     match s.and_then(|s| str::from_utf8(s).ok()) {"}, {"sha": "2514d4bf4a39605b0c7b76a4ae30d51be503ae87", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -167,15 +167,15 @@ extern {\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n mod select {\n-    pub const FD_SETSIZE: uint = 1024;\n+    pub const FD_SETSIZE: usize = 1024;\n \n     #[repr(C)]\n     pub struct fd_set {\n         fds_bits: [i32; (FD_SETSIZE / 32)]\n     }\n \n     pub fn fd_set(set: &mut fd_set, fd: i32) {\n-        set.fds_bits[(fd / 32) as uint] |= 1 << ((fd % 32) as uint);\n+        set.fds_bits[(fd / 32) as usize] |= 1 << ((fd % 32) as usize);\n     }\n }\n \n@@ -198,7 +198,7 @@ mod select {\n     }\n \n     pub fn fd_set(set: &mut fd_set, fd: i32) {\n-        let fd = fd as uint;\n+        let fd = fd as usize;\n         set.fds_bits[fd / usize::BITS as usize] |= 1 << (fd % usize::BITS as usize);\n     }\n }"}, {"sha": "2569653811f11e2892900a3ca710551becb07b22", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -42,7 +42,7 @@ impl FileDesc {\n         FileDesc { fd: fd, close_on_drop: close_on_drop }\n     }\n \n-    pub fn read(&self, buf: &mut [u8]) -> IoResult<uint> {\n+    pub fn read(&self, buf: &mut [u8]) -> IoResult<usize> {\n         let ret = retry(|| unsafe {\n             libc::read(self.fd(),\n                        buf.as_mut_ptr() as *mut libc::c_void,\n@@ -53,7 +53,7 @@ impl FileDesc {\n         } else if ret < 0 {\n             Err(super::last_error())\n         } else {\n-            Ok(ret as uint)\n+            Ok(ret as usize)\n         }\n     }\n     pub fn write(&self, buf: &[u8]) -> IoResult<()> {\n@@ -181,7 +181,7 @@ pub fn open(path: &Path, fm: FileMode, fa: FileAccess) -> IoResult<FileDesc> {\n     }\n }\n \n-pub fn mkdir(p: &Path, mode: uint) -> IoResult<()> {\n+pub fn mkdir(p: &Path, mode: usize) -> IoResult<()> {\n     let p = try!(cstr(p));\n     mkerr_libc(unsafe { libc::mkdir(p.as_ptr(), mode as libc::mode_t) })\n }\n@@ -204,13 +204,13 @@ pub fn readdir(p: &Path) -> IoResult<Vec<Path>> {\n     }\n \n     let size = unsafe { rust_dirent_t_size() };\n-    let mut buf = Vec::<u8>::with_capacity(size as uint);\n+    let mut buf = Vec::<u8>::with_capacity(size as usize);\n     let ptr = buf.as_mut_ptr() as *mut dirent_t;\n \n     let p = try!(CString::new(p.as_vec()));\n     let dir_ptr = unsafe {opendir(p.as_ptr())};\n \n-    if dir_ptr as uint != 0 {\n+    if dir_ptr as usize != 0 {\n         let mut paths = vec!();\n         let mut entry_ptr = ptr::null_mut();\n         while unsafe { readdir_r(dir_ptr, ptr, &mut entry_ptr) == 0 } {\n@@ -239,7 +239,7 @@ pub fn rename(old: &Path, new: &Path) -> IoResult<()> {\n     })\n }\n \n-pub fn chmod(p: &Path, mode: uint) -> IoResult<()> {\n+pub fn chmod(p: &Path, mode: usize) -> IoResult<()> {\n     let p = try!(cstr(p));\n     mkerr_libc(retry(|| unsafe {\n         libc::chmod(p.as_ptr(), mode as libc::mode_t)\n@@ -251,7 +251,7 @@ pub fn rmdir(p: &Path) -> IoResult<()> {\n     mkerr_libc(unsafe { libc::rmdir(p.as_ptr()) })\n }\n \n-pub fn chown(p: &Path, uid: int, gid: int) -> IoResult<()> {\n+pub fn chown(p: &Path, uid: isize, gid: isize) -> IoResult<()> {\n     let p = try!(cstr(p));\n     mkerr_libc(retry(|| unsafe {\n         libc::chown(p.as_ptr(), uid as libc::uid_t, gid as libc::gid_t)\n@@ -265,15 +265,15 @@ pub fn readlink(p: &Path) -> IoResult<Path> {\n     if len == -1 {\n         len = 1024; // FIXME: read PATH_MAX from C ffi?\n     }\n-    let mut buf: Vec<u8> = Vec::with_capacity(len as uint);\n+    let mut buf: Vec<u8> = Vec::with_capacity(len as usize);\n     match unsafe {\n         libc::readlink(p, buf.as_ptr() as *mut libc::c_char,\n                        len as libc::size_t) as libc::c_int\n     } {\n         -1 => Err(super::last_error()),\n         n => {\n             assert!(n > 0);\n-            unsafe { buf.set_len(n as uint); }\n+            unsafe { buf.set_len(n as usize); }\n             Ok(Path::new(buf))\n         }\n     }"}, {"sha": "724156d81d84e7e515b1997b5fd85cc0aa83375f", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -199,13 +199,13 @@ pub fn current_exe() -> io::Result<PathBuf> {\n                          0 as libc::size_t);\n         if err != 0 { return Err(io::Error::last_os_error()); }\n         if sz == 0 { return Err(io::Error::last_os_error()); }\n-        let mut v: Vec<u8> = Vec::with_capacity(sz as uint);\n+        let mut v: Vec<u8> = Vec::with_capacity(sz as usize);\n         let err = sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n                          v.as_mut_ptr() as *mut libc::c_void, &mut sz,\n                          ptr::null_mut(), 0 as libc::size_t);\n         if err != 0 { return Err(io::Error::last_os_error()); }\n         if sz == 0 { return Err(io::Error::last_os_error()); }\n-        v.set_len(sz as uint - 1); // chop off trailing NUL\n+        v.set_len(sz as usize - 1); // chop off trailing NUL\n         Ok(PathBuf::from(OsString::from_vec(v)))\n     }\n }\n@@ -249,10 +249,10 @@ pub fn current_exe() -> io::Result<PathBuf> {\n         let mut sz: u32 = 0;\n         _NSGetExecutablePath(ptr::null_mut(), &mut sz);\n         if sz == 0 { return Err(io::Error::last_os_error()); }\n-        let mut v: Vec<u8> = Vec::with_capacity(sz as uint);\n+        let mut v: Vec<u8> = Vec::with_capacity(sz as usize);\n         let err = _NSGetExecutablePath(v.as_mut_ptr() as *mut i8, &mut sz);\n         if err != 0 { return Err(io::Error::last_os_error()); }\n-        v.set_len(sz as uint - 1); // chop off trailing NUL\n+        v.set_len(sz as usize - 1); // chop off trailing NUL\n         Ok(PathBuf::from(OsString::from_vec(v)))\n     }\n }"}, {"sha": "f0071295bf237316afdc4bed80434ea40e267d7f", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -151,7 +151,7 @@ impl UnixStream {\n         ret\n     }\n \n-    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         let fd = self.fd();\n         let dolock = || self.lock_nonblocking();\n         let doread = |nb| unsafe {\n@@ -167,7 +167,7 @@ impl UnixStream {\n     pub fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let fd = self.fd();\n         let dolock = || self.lock_nonblocking();\n-        let dowrite = |nb: bool, buf: *const u8, len: uint| unsafe {\n+        let dowrite = |nb: bool, buf: *const u8, len: usize| unsafe {\n             let flags = if nb {c::MSG_DONTWAIT} else {0};\n             libc::send(fd,\n                        buf as *const _,"}, {"sha": "0d35ace185d844b86bf874ee5a1420ffa8338a17", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -49,11 +49,11 @@ impl Process {\n         self.pid\n     }\n \n-    pub unsafe fn kill(&self, signal: int) -> IoResult<()> {\n+    pub unsafe fn kill(&self, signal: isize) -> IoResult<()> {\n         Process::killpid(self.pid, signal)\n     }\n \n-    pub unsafe fn killpid(pid: pid_t, signal: int) -> IoResult<()> {\n+    pub unsafe fn killpid(pid: pid_t, signal: isize) -> IoResult<()> {\n         let r = libc::funcs::posix88::signal::kill(pid, signal as c_int);\n         mkerr_libc(r)\n     }\n@@ -454,7 +454,7 @@ impl Process {\n                 // with process timeouts, but libgreen should get there first\n                 // (currently libuv doesn't handle old signal handlers).\n                 if drain(read_fd) {\n-                    let i: uint = unsafe { mem::transmute(old.sa_handler) };\n+                    let i: usize = unsafe { mem::transmute(old.sa_handler) };\n                     if i != 0 {\n                         assert!(old.sa_flags & c::SA_SIGINFO == 0);\n                         (old.sa_handler)(c::SIGCHLD);\n@@ -618,8 +618,8 @@ fn translate_status(status: c_int) -> ProcessExit {\n     }\n \n     if imp::WIFEXITED(status) {\n-        ExitStatus(imp::WEXITSTATUS(status) as int)\n+        ExitStatus(imp::WEXITSTATUS(status) as isize)\n     } else {\n-        ExitSignal(imp::WTERMSIG(status) as int)\n+        ExitSignal(imp::WTERMSIG(status) as isize)\n     }\n }"}, {"sha": "6887095c53a7d1cdc24a5a7cf7d1acfe5b9a8baf", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -60,7 +60,7 @@ mod imp {\n \n \n     // This is initialized in init() and only read from after\n-    static mut PAGE_SIZE: uint = 0;\n+    static mut PAGE_SIZE: usize = 0;\n \n     #[no_stack_check]\n     unsafe extern fn signal_handler(signum: libc::c_int,\n@@ -82,7 +82,7 @@ mod imp {\n         stack::record_sp_limit(0);\n \n         let guard = thread_info::stack_guard();\n-        let addr = (*info).si_addr as uint;\n+        let addr = (*info).si_addr as usize;\n \n         if guard == 0 || addr < guard - PAGE_SIZE || addr >= guard {\n             term(signum);\n@@ -101,7 +101,7 @@ mod imp {\n             panic!(\"failed to get page size\");\n         }\n \n-        PAGE_SIZE = psize as uint;\n+        PAGE_SIZE = psize as usize;\n \n         let mut action: sigaction = mem::zeroed();\n         action.sa_flags = SA_SIGINFO | SA_ONSTACK;"}, {"sha": "3c05fd602be8530d5d23251d12930d58bff4e900", "filename": "src/libstd/sys/unix/sync.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fsync.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -66,24 +66,24 @@ mod os {\n \n     #[cfg(any(target_arch = \"x86_64\",\n               target_arch = \"aarch64\"))]\n-    const __PTHREAD_MUTEX_SIZE__: uint = 56;\n+    const __PTHREAD_MUTEX_SIZE__: usize = 56;\n     #[cfg(any(target_arch = \"x86\",\n               target_arch = \"arm\"))]\n-    const __PTHREAD_MUTEX_SIZE__: uint = 40;\n+    const __PTHREAD_MUTEX_SIZE__: usize = 40;\n \n     #[cfg(any(target_arch = \"x86_64\",\n               target_arch = \"aarch64\"))]\n-    const __PTHREAD_COND_SIZE__: uint = 40;\n+    const __PTHREAD_COND_SIZE__: usize = 40;\n     #[cfg(any(target_arch = \"x86\",\n               target_arch = \"arm\"))]\n-    const __PTHREAD_COND_SIZE__: uint = 24;\n+    const __PTHREAD_COND_SIZE__: usize = 24;\n \n     #[cfg(any(target_arch = \"x86_64\",\n               target_arch = \"aarch64\"))]\n-    const __PTHREAD_RWLOCK_SIZE__: uint = 192;\n+    const __PTHREAD_RWLOCK_SIZE__: usize = 192;\n     #[cfg(any(target_arch = \"x86\",\n               target_arch = \"arm\"))]\n-    const __PTHREAD_RWLOCK_SIZE__: uint = 124;\n+    const __PTHREAD_RWLOCK_SIZE__: usize = 124;\n \n     const _PTHREAD_MUTEX_SIG_INIT: libc::c_long = 0x32AAABA7;\n     const _PTHREAD_COND_SIG_INIT: libc::c_long = 0x3CB0B1BB;\n@@ -125,15 +125,15 @@ mod os {\n \n     // minus 8 because we have an 'align' field\n     #[cfg(target_arch = \"x86_64\")]\n-    const __SIZEOF_PTHREAD_MUTEX_T: uint = 40 - 8;\n+    const __SIZEOF_PTHREAD_MUTEX_T: usize = 40 - 8;\n     #[cfg(any(target_arch = \"x86\",\n               target_arch = \"arm\",\n               target_arch = \"mips\",\n               target_arch = \"mipsel\",\n               target_arch = \"powerpc\"))]\n-    const __SIZEOF_PTHREAD_MUTEX_T: uint = 24 - 8;\n+    const __SIZEOF_PTHREAD_MUTEX_T: usize = 24 - 8;\n     #[cfg(target_arch = \"aarch64\")]\n-    const __SIZEOF_PTHREAD_MUTEX_T: uint = 48 - 8;\n+    const __SIZEOF_PTHREAD_MUTEX_T: usize = 48 - 8;\n \n     #[cfg(any(target_arch = \"x86_64\",\n               target_arch = \"x86\",\n@@ -142,18 +142,18 @@ mod os {\n               target_arch = \"mips\",\n               target_arch = \"mipsel\",\n               target_arch = \"powerpc\"))]\n-    const __SIZEOF_PTHREAD_COND_T: uint = 48 - 8;\n+    const __SIZEOF_PTHREAD_COND_T: usize = 48 - 8;\n \n     #[cfg(any(target_arch = \"x86_64\",\n               target_arch = \"aarch64\"))]\n-    const __SIZEOF_PTHREAD_RWLOCK_T: uint = 56 - 8;\n+    const __SIZEOF_PTHREAD_RWLOCK_T: usize = 56 - 8;\n \n     #[cfg(any(target_arch = \"x86\",\n               target_arch = \"arm\",\n               target_arch = \"mips\",\n               target_arch = \"mipsel\",\n               target_arch = \"powerpc\"))]\n-    const __SIZEOF_PTHREAD_RWLOCK_T: uint = 32 - 8;\n+    const __SIZEOF_PTHREAD_RWLOCK_T: usize = 32 - 8;\n \n     #[repr(C)]\n     pub struct pthread_mutex_t {"}, {"sha": "a9f2198208bc31cbd825ce36302f2c9c4fa0619f", "filename": "src/libstd/sys/unix/tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -64,7 +64,7 @@ impl TcpListener {\n \n     pub fn fd(&self) -> sock_t { self.inner.fd() }\n \n-    pub fn listen(self, backlog: int) -> IoResult<TcpAcceptor> {\n+    pub fn listen(self, backlog: isize) -> IoResult<TcpAcceptor> {\n         match unsafe { libc::listen(self.fd(), backlog as libc::c_int) } {\n             -1 => Err(last_net_error()),\n             _ => {"}, {"sha": "d9a162302fc1cc28c1bd0c0756c0c4a20c76b02d", "filename": "src/libstd/sys/unix/timer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -69,7 +69,7 @@ pub trait Callback {\n }\n \n pub struct Timer {\n-    id: uint,\n+    id: usize,\n     inner: Option<Box<Inner>>,\n }\n \n@@ -78,7 +78,7 @@ pub struct Inner {\n     interval: u64,\n     repeat: bool,\n     target: u64,\n-    id: uint,\n+    id: usize,\n }\n \n pub enum Req {\n@@ -87,7 +87,7 @@ pub enum Req {\n \n     // Remove a timer based on its id and then send it back on the channel\n     // provided\n-    RemoveTimer(uint, Sender<Box<Inner>>),\n+    RemoveTimer(usize, Sender<Box<Inner>>),\n }\n \n // returns the current time (in milliseconds)\n@@ -121,7 +121,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n \n     // signals the first requests in the queue, possible re-enqueueing it.\n     fn signal(active: &mut Vec<Box<Inner>>,\n-              dead: &mut Vec<(uint, Box<Inner>)>) {\n+              dead: &mut Vec<(usize, Box<Inner>)>) {\n         if active.is_empty() { return }\n \n         let mut timer = active.remove(0);\n@@ -216,7 +216,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n \n impl Timer {\n     pub fn new() -> IoResult<Timer> {\n-        // See notes above regarding using int return value\n+        // See notes above regarding using isize return value\n         // instead of ()\n         HELPER.boot(|| {}, helper);\n \n@@ -244,7 +244,7 @@ impl Timer {\n             tv_nsec: ((ms % 1000) * 1000000) as libc::c_long,\n         };\n         while unsafe { libc::nanosleep(&to_sleep, &mut to_sleep) } != 0 {\n-            if os::errno() as int != libc::EINTR as int {\n+            if os::errno() as isize != libc::EINTR as isize {\n                 panic!(\"failed to sleep, but not because of EINTR?\");\n             }\n         }"}, {"sha": "2f6fd713bfba50c01d7049e83e84ab5a48d873fd", "filename": "src/libstd/sys/unix/tty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftty.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -46,7 +46,7 @@ impl TTY {\n         }\n     }\n \n-    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         self.fd.read(buf)\n     }\n     pub fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n@@ -56,7 +56,7 @@ impl TTY {\n         Err(sys_common::unimpl())\n     }\n \n-    pub fn get_winsize(&mut self) -> IoResult<(int, int)> {\n+    pub fn get_winsize(&mut self) -> IoResult<(isize, isize)> {\n         unsafe {\n             #[repr(C)]\n             struct winsize {\n@@ -74,7 +74,7 @@ impl TTY {\n                     detail: None,\n                 })\n             } else {\n-                Ok((size.ws_col as int, size.ws_row as int))\n+                Ok((size.ws_col as isize, size.ws_row as isize))\n             }\n         }\n     }"}, {"sha": "509205a20b12697e457df143f151ee18fa337fcc", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -63,7 +63,7 @@ type StackWalk64Fn =\n                        *mut libc::c_void, *mut libc::c_void,\n                        *mut libc::c_void, *mut libc::c_void) -> libc::BOOL;\n \n-const MAX_SYM_NAME: uint = 2000;\n+const MAX_SYM_NAME: usize = 2000;\n const IMAGE_FILE_MACHINE_I386: libc::DWORD = 0x014c;\n const IMAGE_FILE_MACHINE_IA64: libc::DWORD = 0x0200;\n const IMAGE_FILE_MACHINE_AMD64: libc::DWORD = 0x8664;\n@@ -138,7 +138,7 @@ struct KDHELP64 {\n mod arch {\n     use libc;\n \n-    const MAXIMUM_SUPPORTED_EXTENSION: uint = 512;\n+    const MAXIMUM_SUPPORTED_EXTENSION: usize = 512;\n \n     #[repr(C)]\n     pub struct CONTEXT {"}, {"sha": "3330130c7700207fab3279f53768b9d311af9fdd", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -42,15 +42,15 @@ impl FileDesc {\n         FileDesc { fd: fd, close_on_drop: close_on_drop }\n     }\n \n-    pub fn read(&self, buf: &mut [u8]) -> IoResult<uint> {\n+    pub fn read(&self, buf: &mut [u8]) -> IoResult<usize> {\n         let mut read = 0;\n         let ret = unsafe {\n             libc::ReadFile(self.handle(), buf.as_ptr() as libc::LPVOID,\n                            buf.len() as libc::DWORD, &mut read,\n                            ptr::null_mut())\n         };\n         if ret != 0 {\n-            Ok(read as uint)\n+            Ok(read as usize)\n         } else {\n             Err(super::last_error())\n         }\n@@ -67,8 +67,8 @@ impl FileDesc {\n                                 ptr::null_mut())\n             };\n             if ret != 0 {\n-                remaining -= amt as uint;\n-                cur = unsafe { cur.offset(amt as int) };\n+                remaining -= amt as usize;\n+                cur = unsafe { cur.offset(amt as isize) };\n             } else {\n                 return Err(super::last_error())\n             }\n@@ -234,7 +234,7 @@ pub fn open(path: &Path, fm: FileMode, fa: FileAccess) -> IoResult<FileDesc> {\n     }\n }\n \n-pub fn mkdir(p: &Path, _mode: uint) -> IoResult<()> {\n+pub fn mkdir(p: &Path, _mode: usize) -> IoResult<()> {\n     let p = try!(to_utf16(p));\n     super::mkerr_winbool(unsafe {\n         // FIXME: turn mode into something useful? #2623\n@@ -308,11 +308,11 @@ pub fn unlink(p: &Path) -> IoResult<()> {\n                 };\n                 if stat.perm.intersects(old_io::USER_WRITE) { return Err(e) }\n \n-                match chmod(p, (stat.perm | old_io::USER_WRITE).bits() as uint) {\n+                match chmod(p, (stat.perm | old_io::USER_WRITE).bits() as usize) {\n                     Ok(()) => do_unlink(&p_utf16),\n                     Err(..) => {\n                         // Try to put it back as we found it\n-                        let _ = chmod(p, stat.perm.bits() as uint);\n+                        let _ = chmod(p, stat.perm.bits() as usize);\n                         Err(e)\n                     }\n                 }\n@@ -331,7 +331,7 @@ pub fn rename(old: &Path, new: &Path) -> IoResult<()> {\n     })\n }\n \n-pub fn chmod(p: &Path, mode: uint) -> IoResult<()> {\n+pub fn chmod(p: &Path, mode: usize) -> IoResult<()> {\n     let p = try!(to_utf16(p));\n     mkerr_libc(unsafe {\n         libc::wchmod(p.as_ptr(), mode as libc::c_int)\n@@ -343,7 +343,7 @@ pub fn rmdir(p: &Path) -> IoResult<()> {\n     super::mkerr_winbool(unsafe { libc::RemoveDirectoryW(p.as_ptr()) })\n }\n \n-pub fn chown(_p: &Path, _uid: int, _gid: int) -> IoResult<()> {\n+pub fn chown(_p: &Path, _uid: isize, _gid: isize) -> IoResult<()> {\n     // libuv has this as a no-op, so seems like this should as well?\n     Ok(())\n }"}, {"sha": "064c003bd15a909b90392f5ce531e5330a6085d7", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -115,7 +115,7 @@ impl Event {\n                                initial_state as libc::BOOL,\n                                ptr::null())\n         };\n-        if event as uint == 0 {\n+        if event as usize == 0 {\n             Err(super::last_error())\n         } else {\n             Ok(Event(event))\n@@ -181,7 +181,7 @@ unsafe fn pipe(name: *const u16, init: bool) -> libc::HANDLE {\n }\n \n pub fn await(handle: libc::HANDLE, deadline: u64,\n-             events: &[libc::HANDLE]) -> IoResult<uint> {\n+             events: &[libc::HANDLE]) -> IoResult<usize> {\n     use libc::consts::os::extra::{WAIT_FAILED, WAIT_TIMEOUT, WAIT_OBJECT_0};\n \n     // If we've got a timeout, use WaitForSingleObject in tandem with CancelIo\n@@ -204,7 +204,7 @@ pub fn await(handle: libc::HANDLE, deadline: u64,\n             let _ = c::CancelIo(handle);\n             Err(sys_common::timeout(\"operation timed out\"))\n         },\n-        n => Ok((n - WAIT_OBJECT_0) as uint)\n+        n => Ok((n - WAIT_OBJECT_0) as usize)\n     }\n }\n \n@@ -314,7 +314,7 @@ impl UnixStream {\n             // `WaitNamedPipe` function, and this is indicated with an error\n             // code of ERROR_PIPE_BUSY.\n             let code = unsafe { libc::GetLastError() };\n-            if code as int != libc::ERROR_PIPE_BUSY as int {\n+            if code as isize != libc::ERROR_PIPE_BUSY as isize {\n                 return Err(super::last_error())\n             }\n \n@@ -362,7 +362,7 @@ impl UnixStream {\n         }\n     }\n \n-    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         if self.read.is_none() {\n             self.read = Some(try!(Event::new(true, false)));\n         }\n@@ -390,7 +390,7 @@ impl UnixStream {\n                            &mut bytes_read,\n                            &mut overlapped)\n         };\n-        if ret != 0 { return Ok(bytes_read as uint) }\n+        if ret != 0 { return Ok(bytes_read as usize) }\n \n         // If our errno doesn't say that the I/O is pending, then we hit some\n         // legitimate error and return immediately.\n@@ -418,7 +418,7 @@ impl UnixStream {\n             };\n             // If we succeeded, or we failed for some reason other than\n             // CancelIoEx, return immediately\n-            if ret != 0 { return Ok(bytes_read as uint) }\n+            if ret != 0 { return Ok(bytes_read as usize) }\n             if os::errno() != libc::ERROR_OPERATION_ABORTED as i32 {\n                 return Err(super::last_error())\n             }\n@@ -487,7 +487,7 @@ impl UnixStream {\n                         return Err(super::last_error())\n                     }\n                     if !wait_succeeded.is_ok() {\n-                        let amt = offset + bytes_written as uint;\n+                        let amt = offset + bytes_written as usize;\n                         return if amt > 0 {\n                             Err(IoError {\n                                 kind: old_io::ShortWrite(amt),\n@@ -504,7 +504,7 @@ impl UnixStream {\n                     continue // retry\n                 }\n             }\n-            offset += bytes_written as uint;\n+            offset += bytes_written as usize;\n         }\n         Ok(())\n     }"}, {"sha": "297f6e173abdc9f48d3b6872ab2c712f54fe4e2d", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -63,11 +63,11 @@ impl Process {\n         self.pid\n     }\n \n-    pub unsafe fn kill(&self, signal: int) -> IoResult<()> {\n+    pub unsafe fn kill(&self, signal: isize) -> IoResult<()> {\n         Process::killpid(self.pid, signal)\n     }\n \n-    pub unsafe fn killpid(pid: pid_t, signal: int) -> IoResult<()> {\n+    pub unsafe fn killpid(pid: pid_t, signal: isize) -> IoResult<()> {\n         let handle = libc::OpenProcess(libc::PROCESS_TERMINATE |\n                                        libc::PROCESS_QUERY_INFORMATION,\n                                        libc::FALSE, pid as libc::DWORD);\n@@ -309,7 +309,7 @@ impl Process {\n                 }\n                 if status != STILL_ACTIVE {\n                     assert!(CloseHandle(process) != 0);\n-                    return Ok(ExitStatus(status as int));\n+                    return Ok(ExitStatus(status as isize));\n                 }\n                 let interval = if deadline == 0 {\n                     INFINITE\n@@ -394,7 +394,7 @@ fn make_command_line(prog: &CString, args: &[CString]) -> String {\n         }\n     }\n \n-    fn append_char_at(cmd: &mut String, arg: &[char], i: uint) {\n+    fn append_char_at(cmd: &mut String, arg: &[char], i: usize) {\n         match arg[i] {\n             '\"' => {\n                 // Escape quotes.\n@@ -415,7 +415,7 @@ fn make_command_line(prog: &CString, args: &[CString]) -> String {\n         }\n     }\n \n-    fn backslash_run_ends_in_quote(s: &[char], mut i: uint) -> bool {\n+    fn backslash_run_ends_in_quote(s: &[char], mut i: usize) -> bool {\n         while i < s.len() && s[i] == '\\\\' {\n             i += 1;\n         }"}, {"sha": "79b7de4f341ac07280d7d69a5c28faa44266f75d", "filename": "src/libstd/sys/windows/stack_overflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -31,7 +31,7 @@ impl Drop for Handler {\n }\n \n // This is initialized in init() and only read from after\n-static mut PAGE_SIZE: uint = 0;\n+static mut PAGE_SIZE: usize = 0;\n \n #[no_stack_check]\n extern \"system\" fn vectored_handler(ExceptionInfo: *mut EXCEPTION_POINTERS) -> LONG {\n@@ -56,7 +56,7 @@ extern \"system\" fn vectored_handler(ExceptionInfo: *mut EXCEPTION_POINTERS) -> L\n pub unsafe fn init() {\n     let mut info = mem::zeroed();\n     libc::GetSystemInfo(&mut info);\n-    PAGE_SIZE = info.dwPageSize as uint;\n+    PAGE_SIZE = info.dwPageSize as usize;\n \n     if AddVectoredExceptionHandler(0, vectored_handler) == ptr::null_mut() {\n         panic!(\"failed to install exception handler\");\n@@ -96,7 +96,7 @@ pub type PVECTORED_EXCEPTION_HANDLER = extern \"system\"\n pub type ULONG = libc::c_ulong;\n \n const EXCEPTION_CONTINUE_SEARCH: LONG = 0;\n-const EXCEPTION_MAXIMUM_PARAMETERS: uint = 15;\n+const EXCEPTION_MAXIMUM_PARAMETERS: usize = 15;\n const EXCEPTION_STACK_OVERFLOW: DWORD = 0xc00000fd;\n \n extern \"system\" {"}, {"sha": "2ac8ac10aa9ae7a3b09f58ae03524aae581978eb", "filename": "src/libstd/sys/windows/tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -77,7 +77,7 @@ impl TcpListener {\n \n     pub fn socket(&self) -> sock_t { self.sock }\n \n-    pub fn listen(self, backlog: int) -> IoResult<TcpAcceptor> {\n+    pub fn listen(self, backlog: isize) -> IoResult<TcpAcceptor> {\n         match unsafe { libc::listen(self.socket(), backlog as libc::c_int) } {\n             -1 => Err(last_net_error()),\n "}, {"sha": "98e4a737c7b178a8fcf0a02d7746752e5351ac23", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -25,8 +25,8 @@ use time::Duration;\n pub type rust_thread = HANDLE;\n \n pub mod guard {\n-    pub unsafe fn main() -> uint { 0 }\n-    pub unsafe fn current() -> uint { 0 }\n+    pub unsafe fn main() -> usize { 0 }\n+    pub unsafe fn current() -> usize { 0 }\n     pub unsafe fn init() {}\n }\n "}, {"sha": "cbabab8acb78060b1959de4c29fcd307489ccd70", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -139,7 +139,7 @@ unsafe fn init_dtors() {\n         let dtors = DTORS;\n         DTORS = 1 as *mut _;\n         Box::from_raw(dtors);\n-        assert!(DTORS as uint == 1); // can't re-init after destructing\n+        assert!(DTORS as usize == 1); // can't re-init after destructing\n         DTOR_LOCK.unlock();\n     });\n     if res.is_ok() {\n@@ -152,8 +152,8 @@ unsafe fn init_dtors() {\n unsafe fn register_dtor(key: Key, dtor: Dtor) {\n     DTOR_LOCK.lock();\n     init_dtors();\n-    assert!(DTORS as uint != 0);\n-    assert!(DTORS as uint != 1,\n+    assert!(DTORS as usize != 0);\n+    assert!(DTORS as usize != 1,\n             \"cannot create new TLS keys after the main thread has exited\");\n     (*DTORS).push((key, dtor));\n     DTOR_LOCK.unlock();\n@@ -162,8 +162,8 @@ unsafe fn register_dtor(key: Key, dtor: Dtor) {\n unsafe fn unregister_dtor(key: Key) -> bool {\n     DTOR_LOCK.lock();\n     init_dtors();\n-    assert!(DTORS as uint != 0);\n-    assert!(DTORS as uint != 1,\n+    assert!(DTORS as usize != 0);\n+    assert!(DTORS as usize != 1,\n             \"cannot unregister destructors after the main thread has exited\");\n     let ret = {\n         let dtors = &mut *DTORS;"}, {"sha": "8856cc26b2e9060b8eaa3dbff863e5e70a6bba5f", "filename": "src/libstd/sys/windows/timer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -91,13 +91,13 @@ fn helper(input: libc::HANDLE, messages: Receiver<Req>, _: ()) {\n             }\n         } else {\n             let remove = {\n-                match &mut chans[idx as uint - 1] {\n+                match &mut chans[idx as usize - 1] {\n                     &mut (ref mut c, oneshot) => { c.call(); oneshot }\n                 }\n             };\n             if remove {\n-                drop(objs.remove(idx as uint));\n-                drop(chans.remove(idx as uint - 1));\n+                drop(objs.remove(idx as usize));\n+                drop(chans.remove(idx as usize - 1));\n             }\n         }\n     }"}, {"sha": "38faabf32763b62876ec26c4415c1553679baf74", "filename": "src/libstd/sys/windows/tty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -92,7 +92,7 @@ impl TTY {\n         }\n     }\n \n-    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n+    pub fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n         // Read more if the buffer is empty\n         if self.utf8.eof() {\n             let mut utf16: Vec<u16> = repeat(0u16).take(0x1000).collect();\n@@ -105,7 +105,7 @@ impl TTY {\n                 0 => return Err(super::last_error()),\n                 _ => (),\n             };\n-            utf16.truncate(num as uint);\n+            utf16.truncate(num as usize);\n             let utf8 = match String::from_utf16(&utf16) {\n                 Ok(utf8) => utf8.into_bytes(),\n                 Err(..) => return Err(invalid_encoding()),\n@@ -149,12 +149,12 @@ impl TTY {\n         }\n     }\n \n-    pub fn get_winsize(&mut self) -> IoResult<(int, int)> {\n+    pub fn get_winsize(&mut self) -> IoResult<(isize, isize)> {\n         let mut info: CONSOLE_SCREEN_BUFFER_INFO = unsafe { mem::zeroed() };\n         match unsafe { GetConsoleScreenBufferInfo(self.handle, &mut info as *mut _) } {\n             0 => Err(super::last_error()),\n-            _ => Ok(((info.srWindow.Right + 1 - info.srWindow.Left) as int,\n-                     (info.srWindow.Bottom + 1 - info.srWindow.Top) as int)),\n+            _ => Ok(((info.srWindow.Right + 1 - info.srWindow.Left) as isize,\n+                     (info.srWindow.Bottom + 1 - info.srWindow.Top) as isize)),\n         }\n     }\n }"}, {"sha": "236b16920a8cd94e8d4fabb3a39d5dafd7be6302", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -328,12 +328,12 @@ pub mod rt {\n     impl_to_tokens! { () }\n     impl_to_tokens! { char }\n     impl_to_tokens! { bool }\n-    impl_to_tokens! { int }\n+    impl_to_tokens! { isize }\n     impl_to_tokens! { i8 }\n     impl_to_tokens! { i16 }\n     impl_to_tokens! { i32 }\n     impl_to_tokens! { i64 }\n-    impl_to_tokens! { uint }\n+    impl_to_tokens! { usize }\n     impl_to_tokens! { u8 }\n     impl_to_tokens! { u16 }\n     impl_to_tokens! { u32 }"}, {"sha": "a0bff7404c750a620b28ce78cb37621674fd6d67", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -29,7 +29,6 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(int_uint)]\n #![feature(libc)]\n #![feature(old_path)]\n #![feature(quote, unsafe_destructor)]"}, {"sha": "ed2d00d6ad788ad00008e3a6fb868745f4a1df84", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -57,7 +57,6 @@\n \n #![feature(box_syntax)]\n #![feature(collections)]\n-#![feature(int_uint)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(std_misc)]"}, {"sha": "4840cd1fddadfe2ecd142e67b6ea2354e96f2d56", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -82,7 +82,7 @@ impl<T: Write+Send+'static> Terminal<T> for TerminfoTerminal<T> {\n                                .get(\"setaf\")\n                                .unwrap()\n                                ,\n-                           &[Number(color as int)], &mut Variables::new());\n+                           &[Number(color as isize)], &mut Variables::new());\n             if s.is_ok() {\n                 try!(self.out.write_all(&s.unwrap()));\n                 return Ok(true)\n@@ -99,7 +99,7 @@ impl<T: Write+Send+'static> Terminal<T> for TerminfoTerminal<T> {\n                                .get(\"setab\")\n                                .unwrap()\n                                ,\n-                           &[Number(color as int)], &mut Variables::new());\n+                           &[Number(color as isize)], &mut Variables::new());\n             if s.is_ok() {\n                 try!(self.out.write_all(&s.unwrap()));\n                 return Ok(true)"}, {"sha": "d6a4659c45a893275093250a7d1b14f8407452f5", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -27,12 +27,12 @@ enum States {\n     PushParam,\n     CharConstant,\n     CharClose,\n-    IntConstant(int),\n+    IntConstant(isize),\n     FormatPattern(Flags, FormatState),\n-    SeekIfElse(int),\n-    SeekIfElsePercent(int),\n-    SeekIfEnd(int),\n-    SeekIfEndPercent(int)\n+    SeekIfElse(isize),\n+    SeekIfElsePercent(isize),\n+    SeekIfEnd(isize),\n+    SeekIfEndPercent(isize)\n }\n \n #[derive(Copy, PartialEq)]\n@@ -47,7 +47,7 @@ enum FormatState {\n #[derive(Clone)]\n pub enum Param {\n     Words(String),\n-    Number(int)\n+    Number(isize)\n }\n \n /// Container for static and dynamic variable arrays\n@@ -143,7 +143,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     '{' => state = IntConstant(0),\n                     'l' => if stack.len() > 0 {\n                         match stack.pop().unwrap() {\n-                            Words(s) => stack.push(Number(s.len() as int)),\n+                            Words(s) => stack.push(Number(s.len() as isize)),\n                             _        => return Err(\"a non-str was used with %l\".to_string())\n                         }\n                     } else { return Err(\"stack is empty\".to_string()) },\n@@ -268,7 +268,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                             ' ' => flags.space = true,\n                             '.' => fstate = FormatStatePrecision,\n                             '0'...'9' => {\n-                                flags.width = cur as uint - '0' as uint;\n+                                flags.width = cur as usize - '0' as usize;\n                                 fstate = FormatStateWidth;\n                             }\n                             _ => unreachable!()\n@@ -305,12 +305,12 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                 if cur >= 'A' && cur <= 'Z' {\n                     if stack.len() > 0 {\n                         let idx = (cur as u8) - b'A';\n-                        vars.sta[idx as uint] = stack.pop().unwrap();\n+                        vars.sta[idx as usize] = stack.pop().unwrap();\n                     } else { return Err(\"stack is empty\".to_string()) }\n                 } else if cur >= 'a' && cur <= 'z' {\n                     if stack.len() > 0 {\n                         let idx = (cur as u8) - b'a';\n-                        vars.dyn[idx as uint] = stack.pop().unwrap();\n+                        vars.dyn[idx as usize] = stack.pop().unwrap();\n                     } else { return Err(\"stack is empty\".to_string()) }\n                 } else {\n                     return Err(\"bad variable name in %P\".to_string());\n@@ -319,16 +319,16 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             GetVar => {\n                 if cur >= 'A' && cur <= 'Z' {\n                     let idx = (cur as u8) - b'A';\n-                    stack.push(vars.sta[idx as uint].clone());\n+                    stack.push(vars.sta[idx as usize].clone());\n                 } else if cur >= 'a' && cur <= 'z' {\n                     let idx = (cur as u8) - b'a';\n-                    stack.push(vars.dyn[idx as uint].clone());\n+                    stack.push(vars.dyn[idx as usize].clone());\n                 } else {\n                     return Err(\"bad variable name in %g\".to_string());\n                 }\n             },\n             CharConstant => {\n-                stack.push(Number(c as int));\n+                stack.push(Number(c as isize));\n                 state = CharClose;\n             },\n             CharClose => {\n@@ -343,10 +343,10 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         state = Nothing;\n                     }\n                     '0'...'9' => {\n-                        state = IntConstant(i*10 + (cur as int - '0' as int));\n+                        state = IntConstant(i*10 + (cur as isize - '0' as isize));\n                         old_state = Nothing;\n                     }\n-                    _ => return Err(\"bad int constant\".to_string())\n+                    _ => return Err(\"bad isize constant\".to_string())\n                 }\n             }\n             FormatPattern(ref mut flags, ref mut fstate) => {\n@@ -372,23 +372,23 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         flags.space = true;\n                     }\n                     (FormatStateFlags,'0'...'9') => {\n-                        flags.width = cur as uint - '0' as uint;\n+                        flags.width = cur as usize - '0' as usize;\n                         *fstate = FormatStateWidth;\n                     }\n                     (FormatStateFlags,'.') => {\n                         *fstate = FormatStatePrecision;\n                     }\n                     (FormatStateWidth,'0'...'9') => {\n                         let old = flags.width;\n-                        flags.width = flags.width * 10 + (cur as uint - '0' as uint);\n+                        flags.width = flags.width * 10 + (cur as usize - '0' as usize);\n                         if flags.width < old { return Err(\"format width overflow\".to_string()) }\n                     }\n                     (FormatStateWidth,'.') => {\n                         *fstate = FormatStatePrecision;\n                     }\n                     (FormatStatePrecision,'0'...'9') => {\n                         let old = flags.precision;\n-                        flags.precision = flags.precision * 10 + (cur as uint - '0' as uint);\n+                        flags.precision = flags.precision * 10 + (cur as usize - '0' as usize);\n                         if flags.precision < old {\n                             return Err(\"format precision overflow\".to_string())\n                         }\n@@ -446,8 +446,8 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n \n #[derive(Copy, PartialEq)]\n struct Flags {\n-    width: uint,\n-    precision: uint,\n+    width: usize,\n+    precision: usize,\n     alternate: bool,\n     left: bool,\n     sign: bool,"}, {"sha": "01d191f30147b23450942f367135dac8b16d583f", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -189,31 +189,31 @@ pub fn parse(file: &mut Read, longnames: bool)\n                            0x011A_usize, magic as usize));\n     }\n \n-    let names_bytes          = try!(read_le_u16(file)) as int;\n-    let bools_bytes          = try!(read_le_u16(file)) as int;\n-    let numbers_count        = try!(read_le_u16(file)) as int;\n-    let string_offsets_count = try!(read_le_u16(file)) as int;\n-    let string_table_bytes   = try!(read_le_u16(file)) as int;\n+    let names_bytes          = try!(read_le_u16(file)) as isize;\n+    let bools_bytes          = try!(read_le_u16(file)) as isize;\n+    let numbers_count        = try!(read_le_u16(file)) as isize;\n+    let string_offsets_count = try!(read_le_u16(file)) as isize;\n+    let string_table_bytes   = try!(read_le_u16(file)) as isize;\n \n     assert!(names_bytes          > 0);\n \n-    if (bools_bytes as uint) > boolnames.len() {\n+    if (bools_bytes as usize) > boolnames.len() {\n         return Err(\"incompatible file: more booleans than \\\n                     expected\".to_string());\n     }\n \n-    if (numbers_count as uint) > numnames.len() {\n+    if (numbers_count as usize) > numnames.len() {\n         return Err(\"incompatible file: more numbers than \\\n                     expected\".to_string());\n     }\n \n-    if (string_offsets_count as uint) > stringnames.len() {\n+    if (string_offsets_count as usize) > stringnames.len() {\n         return Err(\"incompatible file: more string offsets than \\\n                     expected\".to_string());\n     }\n \n     // don't read NUL\n-    let bytes = try!(read_exact(file, names_bytes as uint - 1));\n+    let bytes = try!(read_exact(file, names_bytes as usize - 1));\n     let names_str = match String::from_utf8(bytes) {\n         Ok(s)  => s,\n         Err(_) => return Err(\"input not utf-8\".to_string()),\n@@ -230,7 +230,7 @@ pub fn parse(file: &mut Read, longnames: bool)\n         for i in 0..bools_bytes {\n             let b = try!(read_byte(file));\n             if b == 1 {\n-                bools_map.insert(bnames[i as uint].to_string(), true);\n+                bools_map.insert(bnames[i as usize].to_string(), true);\n             }\n         }\n     }\n@@ -244,7 +244,7 @@ pub fn parse(file: &mut Read, longnames: bool)\n         for i in 0..numbers_count {\n             let n = try!(read_le_u16(file));\n             if n != 0xFFFF {\n-                numbers_map.insert(nnames[i as uint].to_string(), n);\n+                numbers_map.insert(nnames[i as usize].to_string(), n);\n             }\n         }\n     }\n@@ -259,7 +259,7 @@ pub fn parse(file: &mut Read, longnames: bool)\n \n         let string_table = try!(read_exact(file, string_table_bytes as usize));\n \n-        if string_table.len() != string_table_bytes as uint {\n+        if string_table.len() != string_table_bytes as usize {\n             return Err(\"error: hit EOF before end of string \\\n                         table\".to_string());\n         }\n@@ -285,13 +285,13 @@ pub fn parse(file: &mut Read, longnames: bool)\n \n \n             // Find the offset of the NUL we want to go to\n-            let nulpos = string_table[offset as uint .. string_table_bytes as uint]\n+            let nulpos = string_table[offset as usize .. string_table_bytes as usize]\n                 .iter().position(|&b| b == 0);\n             match nulpos {\n                 Some(len) => {\n                     string_map.insert(name.to_string(),\n-                                      string_table[offset as uint ..\n-                                                   (offset as uint + len)].to_vec())\n+                                      string_table[offset as usize ..\n+                                                   (offset as usize + len)].to_vec())\n                 },\n                 None => {\n                     return Err(\"invalid file: missing NUL in \\"}, {"sha": "3083f8e89298904526351d0b0bf2df4064df68c9", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -67,7 +67,7 @@ pub fn get_dbpath_for_term(term: &str) -> Option<Box<PathBuf>> {\n                 return Some(box newp);\n             }\n             // on some installations the dir is named after the hex of the char (e.g. OS X)\n-            let f = format!(\"{:x}\", first_char as uint);\n+            let f = format!(\"{:x}\", first_char as usize);\n             let newp = p.join(&f).join(term);\n             if newp.exists() {\n                 return Some(box newp);"}, {"sha": "91c0db08aba223fee40712d211fdd423a5344a44", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -38,7 +38,6 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(int_uint)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n@@ -129,7 +128,7 @@ enum NamePadding {\n }\n \n impl TestDesc {\n-    fn padded_name(&self, column_count: uint, align: NamePadding) -> String {\n+    fn padded_name(&self, column_count: usize, align: NamePadding) -> String {\n         let mut name = String::from_str(self.name.as_slice());\n         let fill = column_count.saturating_sub(name.len());\n         let mut pad = repeat(\" \").take(fill).collect::<String>();\n@@ -421,7 +420,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n #[derive(Clone, PartialEq)]\n pub struct BenchSamples {\n     ns_iter_summ: stats::Summary<f64>,\n-    mb_s: uint,\n+    mb_s: usize,\n }\n \n #[derive(Clone, PartialEq)]\n@@ -444,14 +443,14 @@ struct ConsoleTestState<T> {\n     log_out: Option<File>,\n     out: OutputLocation<T>,\n     use_color: bool,\n-    total: uint,\n-    passed: uint,\n-    failed: uint,\n-    ignored: uint,\n-    measured: uint,\n+    total: usize,\n+    passed: usize,\n+    failed: usize,\n+    ignored: usize,\n+    measured: usize,\n     metrics: MetricMap,\n     failures: Vec<(TestDesc, Vec<u8> )> ,\n-    max_name_len: uint, // number of columns to fill when aligning names\n+    max_name_len: usize, // number of columns to fill when aligning names\n }\n \n impl<T: Write> ConsoleTestState<T> {\n@@ -535,7 +534,7 @@ impl<T: Write> ConsoleTestState<T> {\n         }\n     }\n \n-    pub fn write_run_start(&mut self, len: uint) -> io::Result<()> {\n+    pub fn write_run_start(&mut self, len: usize) -> io::Result<()> {\n         self.total = len;\n         let noun = if len != 1 { \"tests\" } else { \"test\" };\n         self.write_plain(&format!(\"\\nrunning {} {}\\n\", len, noun))\n@@ -635,13 +634,13 @@ impl<T: Write> ConsoleTestState<T> {\n pub fn fmt_bench_samples(bs: &BenchSamples) -> String {\n     if bs.mb_s != 0 {\n         format!(\"{:>9} ns/iter (+/- {}) = {} MB/s\",\n-             bs.ns_iter_summ.median as uint,\n-             (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as uint,\n+             bs.ns_iter_summ.median as usize,\n+             (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as usize,\n              bs.mb_s)\n     } else {\n         format!(\"{:>9} ns/iter (+/- {})\",\n-             bs.ns_iter_summ.median as uint,\n-             (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as uint)\n+             bs.ns_iter_summ.median as usize,\n+             (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as usize)\n     }\n }\n \n@@ -689,7 +688,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn> ) -> io::Res\n     }\n \n     let mut st = try!(ConsoleTestState::new(opts, None::<io::Stdout>));\n-    fn len_if_padded(t: &TestDescAndFn) -> uint {\n+    fn len_if_padded(t: &TestDescAndFn) -> usize {\n         match t.testfn.padding() {\n             PadNone => 0,\n             PadOnLeft | PadOnRight => t.desc.name.as_slice().len(),\n@@ -845,10 +844,10 @@ fn run_tests<F>(opts: &TestOpts,\n }\n \n #[allow(deprecated)]\n-fn get_concurrency() -> uint {\n+fn get_concurrency() -> usize {\n     match env::var(\"RUST_TEST_THREADS\") {\n         Ok(s) => {\n-            let opt_n: Option<uint> = s.parse().ok();\n+            let opt_n: Option<usize> = s.parse().ok();\n             match opt_n {\n                 Some(n) if n > 0 => n,\n                 _ => panic!(\"RUST_TEST_THREADS is `{}`, should be a positive integer.\", s)\n@@ -1164,7 +1163,7 @@ pub mod bench {\n \n         BenchSamples {\n             ns_iter_summ: ns_iter_summ,\n-            mb_s: mb_s as uint\n+            mb_s: mb_s as usize\n         }\n     }\n }\n@@ -1333,8 +1332,8 @@ mod tests {\n \n         let names =\n             vec!(\"sha1::test\".to_string(),\n-                 \"int::test_to_str\".to_string(),\n-                 \"int::test_pow\".to_string(),\n+                 \"isize::test_to_str\".to_string(),\n+                 \"isize::test_pow\".to_string(),\n                  \"test::do_not_run_ignored_tests\".to_string(),\n                  \"test::ignored_tests_result_in_ignored\".to_string(),\n                  \"test::first_free_arg_should_be_a_filter\".to_string(),\n@@ -1361,8 +1360,8 @@ mod tests {\n         let filtered = filter_tests(&opts, tests);\n \n         let expected =\n-            vec!(\"int::test_pow\".to_string(),\n-                 \"int::test_to_str\".to_string(),\n+            vec!(\"isize::test_pow\".to_string(),\n+                 \"isize::test_to_str\".to_string(),\n                  \"sha1::test\".to_string(),\n                  \"test::do_not_run_ignored_tests\".to_string(),\n                  \"test::filter_for_ignored_option\".to_string(),"}, {"sha": "bd23fb88217080d03513fa505f448a2d7148e402", "filename": "src/test/auxiliary/ambig_impl_2_lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fambig_impl_2_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fambig_impl_2_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fambig_impl_2_lib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n trait me {\n-    fn me(&self) -> uint;\n+    fn me(&self) -> usize;\n }\n-impl me for uint { fn me(&self) -> uint { *self } }\n+impl me for usize { fn me(&self) -> usize { *self } }"}, {"sha": "9d93d9689e737c94cd369ff800b2b06d51ba6687", "filename": "src/test/auxiliary/anon_trait_static_method_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fanon_trait_static_method_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fanon_trait_static_method_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fanon_trait_static_method_lib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub struct Foo {\n-    pub x: int\n+    pub x: isize\n }\n \n impl Foo {"}, {"sha": "b3960c2707b4b81c71a928c867837e64396e6518", "filename": "src/test/auxiliary/associated-types-cc-lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fassociated-types-cc-lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fassociated-types-cc-lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fassociated-types-cc-lib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -19,8 +19,8 @@ pub trait Bar {\n     fn get(x: Option<Self>) -> <Self as Bar>::T;\n }\n \n-impl Bar for int {\n-    type T = uint;\n+impl Bar for isize {\n+    type T = usize;\n \n-    fn get(_: Option<int>) -> uint { 22 }\n+    fn get(_: Option<isize>) -> usize { 22 }\n }"}, {"sha": "9c90510a8573e7bb5dab27678bc5c84d2a537b16", "filename": "src/test/auxiliary/cci_borrow_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_borrow_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_borrow_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_borrow_lib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -8,6 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub fn foo(x: &uint) -> uint {\n+pub fn foo(x: &usize) -> usize {\n     *x\n }"}, {"sha": "08a13fd8bcc9ab47cedd21cb844ad22c56b85da7", "filename": "src/test/auxiliary/cci_class.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -10,12 +10,12 @@\n \n pub mod kitties {\n     pub struct cat {\n-      meows : uint,\n+      meows : usize,\n \n-      pub how_hungry : int,\n+      pub how_hungry : isize,\n     }\n \n-    pub fn cat(in_x : uint, in_y : int) -> cat  {\n+    pub fn cat(in_x : usize, in_y : isize) -> cat  {\n         cat {\n             meows: in_x,\n             how_hungry: in_y"}, {"sha": "7d147832f09437f40d12ec428220de0884462ab6", "filename": "src/test/auxiliary/cci_class_2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_class_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_class_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_2.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -10,17 +10,17 @@\n \n pub mod kitties {\n     pub struct cat {\n-      meows : uint,\n+      meows : usize,\n \n-      pub how_hungry : int,\n+      pub how_hungry : isize,\n \n     }\n \n     impl cat {\n         pub fn speak(&self) {}\n     }\n \n-    pub fn cat(in_x : uint, in_y : int) -> cat {\n+    pub fn cat(in_x : usize, in_y : isize) -> cat {\n         cat {\n             meows: in_x,\n             how_hungry: in_y"}, {"sha": "ec1bf108dcb007145909d00f1fdac1ab3c652967", "filename": "src/test/auxiliary/cci_class_3.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_class_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_class_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_3.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -10,17 +10,17 @@\n \n pub mod kitties {\n     pub struct cat {\n-        meows : uint,\n+        meows : usize,\n \n-        pub how_hungry : int,\n+        pub how_hungry : isize,\n     }\n \n     impl cat {\n         pub fn speak(&mut self) { self.meows += 1; }\n-        pub fn meow_count(&mut self) -> uint { self.meows }\n+        pub fn meow_count(&mut self) -> usize { self.meows }\n     }\n \n-    pub fn cat(in_x : uint, in_y : int) -> cat {\n+    pub fn cat(in_x : usize, in_y : isize) -> cat {\n         cat {\n             meows: in_x,\n             how_hungry: in_y"}, {"sha": "300cc31632e40e7375004841fd67d642746dd285", "filename": "src/test/auxiliary/cci_class_4.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -10,9 +10,9 @@\n \n pub mod kitties {\n     pub struct cat {\n-        meows : uint,\n+        meows : usize,\n \n-        pub how_hungry : int,\n+        pub how_hungry : isize,\n         pub name : String,\n     }\n \n@@ -41,7 +41,7 @@ pub mod kitties {\n         }\n     }\n \n-    pub fn cat(in_x : uint, in_y : int, in_name: String) -> cat {\n+    pub fn cat(in_x : usize, in_y : isize, in_name: String) -> cat {\n         cat {\n             meows: in_x,\n             how_hungry: in_y,"}, {"sha": "7fe608f1634c2d91574d2aa66ece0d0ded301f93", "filename": "src/test/auxiliary/cci_class_5.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_class_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_class_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_5.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -10,15 +10,15 @@\n \n pub mod kitties {\n     pub struct cat {\n-        meows : uint,\n-        pub how_hungry : int,\n+        meows : usize,\n+        pub how_hungry : isize,\n     }\n \n     impl cat {\n         fn nap(&self) {}\n     }\n \n-    pub fn cat(in_x : uint, in_y : int) -> cat {\n+    pub fn cat(in_x : usize, in_y : isize) -> cat {\n         cat {\n             meows: in_x,\n             how_hungry: in_y"}, {"sha": "c902a6c7dca89dbbe8fe8f79427c1c35d1ecee78", "filename": "src/test/auxiliary/cci_class_6.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -12,20 +12,20 @@ pub mod kitties {\n \n     pub struct cat<U> {\n         info : Vec<U> ,\n-        meows : uint,\n+        meows : usize,\n \n-        pub how_hungry : int,\n+        pub how_hungry : isize,\n     }\n \n     impl<U> cat<U> {\n         pub fn speak<T>(&mut self, stuff: Vec<T> ) {\n             self.meows += stuff.len();\n         }\n \n-        pub fn meow_count(&mut self) -> uint { self.meows }\n+        pub fn meow_count(&mut self) -> usize { self.meows }\n     }\n \n-    pub fn cat<U>(in_x : uint, in_y : int, in_info: Vec<U> ) -> cat<U> {\n+    pub fn cat<U>(in_x : usize, in_y : isize, in_info: Vec<U> ) -> cat<U> {\n         cat {\n             meows: in_x,\n             how_hungry: in_y,"}, {"sha": "f54a39d61ef3ed0dd53bdfc2efb389e2f3e8ea54", "filename": "src/test/auxiliary/cci_class_cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -12,8 +12,8 @@ pub mod kitty {\n     use std::fmt;\n \n     pub struct cat {\n-      meows : uint,\n-      pub how_hungry : int,\n+      meows : usize,\n+      pub how_hungry : isize,\n       pub name : String,\n     }\n \n@@ -50,7 +50,7 @@ pub mod kitty {\n         }\n     }\n \n-    pub fn cat(in_x : uint, in_y : int, in_name: String) -> cat {\n+    pub fn cat(in_x : usize, in_y : isize, in_name: String) -> cat {\n         cat {\n             meows: in_x,\n             how_hungry: in_y,"}, {"sha": "ee8290050f91babafb87664c20cd087fa1262b58", "filename": "src/test/auxiliary/cci_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_const.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -12,5 +12,5 @@ pub extern fn bar() {\n }\n \n pub const foopy: &'static str = \"hi there\";\n-pub const uint_val: uint = 12;\n-pub const uint_expr: uint = (1 << uint_val) - 1;\n+pub const uint_val: usize = 12;\n+pub const uint_expr: usize = (1 << uint_val) - 1;"}, {"sha": "76fe9fe5aa40a6a73b8c8f7dd8a90c12b75fead0", "filename": "src/test/auxiliary/cci_const_block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_const_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_const_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_const_block.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub static BLOCK_FN_DEF: fn(uint) -> uint = {\n-    fn foo(a: uint) -> uint {\n+pub static BLOCK_FN_DEF: fn(usize) -> usize = {\n+    fn foo(a: usize) -> usize {\n         a + 10\n     }\n     foo"}, {"sha": "d8921f4e09a8a0bd2fb79cea5f2e547a482cb537", "filename": "src/test/auxiliary/cci_impl_lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -11,12 +11,12 @@\n #![crate_name=\"cci_impl_lib\"]\n \n pub trait uint_helpers {\n-    fn to<F>(&self, v: uint, f: F) where F: FnMut(uint);\n+    fn to<F>(&self, v: usize, f: F) where F: FnMut(usize);\n }\n \n-impl uint_helpers for uint {\n+impl uint_helpers for usize {\n     #[inline]\n-    fn to<F>(&self, v: uint, mut f: F) where F: FnMut(uint) {\n+    fn to<F>(&self, v: usize, mut f: F) where F: FnMut(usize) {\n         let mut i = *self;\n         while i < v {\n             f(i);"}, {"sha": "b6e69d29f70cd48dc45a44ea0542361c69890183", "filename": "src/test/auxiliary/cci_intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_intrinsic.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -17,7 +17,7 @@ pub mod rusti {\n }\n \n #[inline(always)]\n-pub fn atomic_xchg(dst: *mut int, src: int) -> int {\n+pub fn atomic_xchg(dst: *mut isize, src: isize) -> isize {\n     unsafe {\n         rusti::atomic_xchg(dst, src)\n     }"}, {"sha": "8c1a283a72d77b98e3909af7c7e858e104c9b262", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -44,18 +44,18 @@ pub fn alist_get<A:Clone + 'static,\n }\n \n #[inline]\n-pub fn new_int_alist<B:'static>() -> alist<int, B> {\n-    fn eq_int(a: int, b: int) -> bool { a == b }\n+pub fn new_int_alist<B:'static>() -> alist<isize, B> {\n+    fn eq_int(a: isize, b: isize) -> bool { a == b }\n     return alist {\n         eq_fn: eq_int,\n         data: box RefCell::new(Vec::new()),\n     };\n }\n \n #[inline]\n-pub fn new_int_alist_2<B:'static>() -> alist<int, B> {\n+pub fn new_int_alist_2<B:'static>() -> alist<isize, B> {\n     #[inline]\n-    fn eq_int(a: int, b: int) -> bool { a == b }\n+    fn eq_int(a: isize, b: isize) -> bool { a == b }\n     return alist {\n         eq_fn: eq_int,\n         data: box RefCell::new(Vec::new()),"}, {"sha": "4c6f808c6192040a0fcc3e84ab4d9ecee1b47d5f", "filename": "src/test/auxiliary/cci_no_inline_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -12,7 +12,7 @@\n \n \n // same as cci_iter_lib, more-or-less, but not marked inline\n-pub fn iter<F>(v: Vec<uint> , mut f: F) where F: FnMut(uint) {\n+pub fn iter<F>(v: Vec<usize> , mut f: F) where F: FnMut(usize) {\n     let mut i = 0;\n     let n = v.len();\n     while i < n {"}, {"sha": "b5b4390657b4f18d648421a75cf7286dbd28dd72", "filename": "src/test/auxiliary/cfg_inner_static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcfg_inner_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcfg_inner_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcfg_inner_static.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -11,7 +11,7 @@\n // this used to just ICE on compiling\n pub fn foo() {\n     if cfg!(foo) {\n-        static a: int = 3;\n+        static a: isize = 3;\n         a\n     } else { 3 };\n }"}, {"sha": "7b1190fc085802ce00142236eec74bbbb979b127", "filename": "src/test/auxiliary/changing-crates-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fchanging-crates-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fchanging-crates-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fchanging-crates-b.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -12,4 +12,4 @@\n \n extern crate a;\n \n-pub fn foo() { a::foo::<int>(); }\n+pub fn foo() { a::foo::<isize>(); }"}, {"sha": "050f2fe732935e84799dc479f30d95e7b664b2b7", "filename": "src/test/auxiliary/crateresolve1-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve1-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve1-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve1-1.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -12,4 +12,4 @@\n #![crate_name = \"crateresolve1\"]\n #![crate_type = \"lib\"]\n \n-pub fn f() -> int { 10 }\n+pub fn f() -> isize { 10 }"}, {"sha": "d19b3bafba5075a49fe327811b8f93fd78b15746", "filename": "src/test/auxiliary/crateresolve1-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve1-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve1-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve1-2.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -12,4 +12,4 @@\n #![crate_name = \"crateresolve1\"]\n #![crate_type = \"lib\"]\n \n-pub fn f() -> int { 20 }\n+pub fn f() -> isize { 20 }"}, {"sha": "c5096ac49a885189b29c3f793096d2d46644848a", "filename": "src/test/auxiliary/crateresolve1-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve1-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve1-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve1-3.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -12,4 +12,4 @@\n #![crate_name = \"crateresolve1\"]\n #![crate_type = \"lib\"]\n \n-pub fn f() -> int { 30 }\n+pub fn f() -> isize { 30 }"}, {"sha": "0e02a8d96a3b2bc52eca85aa3a63f4617ef91032", "filename": "src/test/auxiliary/crateresolve3-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve3-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve3-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve3-1.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -12,4 +12,4 @@\n \n #![crate_type = \"lib\"]\n \n-pub fn f() -> int { 10 }\n+pub fn f() -> isize { 10 }"}, {"sha": "6a11465b27ca077b67f55619e4f981847040dfcf", "filename": "src/test/auxiliary/crateresolve3-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve3-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve3-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve3-2.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -12,4 +12,4 @@\n \n #![crate_type = \"lib\"]\n \n-pub fn g() -> int { 20 }\n+pub fn g() -> isize { 20 }"}, {"sha": "579e93aa059c68654baeff2131ef12f7f7c8fd53", "filename": "src/test/auxiliary/crateresolve4a-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve4a-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve4a-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve4a-1.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -11,4 +11,4 @@\n #![crate_name=\"crateresolve4a#0.1\"]\n #![crate_type = \"lib\"]\n \n-pub fn f() -> int { 10 }\n+pub fn f() -> isize { 10 }"}, {"sha": "7da96e07b3f05628ded6c9f395e218e1cb3922dc", "filename": "src/test/auxiliary/crateresolve4a-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve4a-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve4a-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve4a-2.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -11,4 +11,4 @@\n #![crate_name=\"crateresolve4a#0.2\"]\n #![crate_type = \"lib\"]\n \n-pub fn g() -> int { 20 }\n+pub fn g() -> isize { 20 }"}, {"sha": "9e4b0d158ecb90ae5a5dc92e29b9095bd5fd28d9", "filename": "src/test/auxiliary/crateresolve4b-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve4b-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve4b-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve4b-1.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -15,4 +15,4 @@\n \n extern crate \"crateresolve4a#0.2\" as crateresolve4a;\n \n-pub fn f() -> int { crateresolve4a::g() }\n+pub fn f() -> isize { crateresolve4a::g() }"}, {"sha": "a50b8dbf957eae57679298b070be0c508be4f29e", "filename": "src/test/auxiliary/crateresolve4b-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve4b-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve4b-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve4b-2.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -15,4 +15,4 @@\n \n extern crate \"crateresolve4a#0.1\" as crateresolve4a;\n \n-pub fn g() -> int { crateresolve4a::f() }\n+pub fn g() -> isize { crateresolve4a::f() }"}, {"sha": "eaec37ed417d06afe8bcfee37d338d28a170515e", "filename": "src/test/auxiliary/crateresolve5-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-1.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -12,7 +12,7 @@\n \n #![crate_type = \"lib\"]\n \n-pub struct NameVal { pub name: String, pub val: int }\n+pub struct NameVal { pub name: String, pub val: isize }\n \n pub fn struct_nameval() -> NameVal {\n     NameVal { name: \"crateresolve5\".to_string(), val: 10 }\n@@ -31,4 +31,4 @@ impl PartialEq for e {\n     fn ne(&self, other: &e) -> bool { !nominal_eq(*self, *other) }\n }\n \n-pub fn f() -> int { 10 }\n+pub fn f() -> isize { 10 }"}, {"sha": "14d28c709cdb56f8a08ed738b2aaf9485285ef74", "filename": "src/test/auxiliary/crateresolve5-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve5-2.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -12,7 +12,7 @@\n \n #![crate_type = \"lib\"]\n \n-pub struct NameVal { pub name: String, pub val: int }\n+pub struct NameVal { pub name: String, pub val: isize }\n pub fn struct_nameval() -> NameVal {\n     NameVal { name: \"crateresolve5\".to_string(), val: 10 }\n }\n@@ -30,4 +30,4 @@ pub fn nominal() -> e { e_val }\n \n pub fn nominal_neq(_e1: e, _e2: e) -> bool { false }\n \n-pub fn f() -> int { 20 }\n+pub fn f() -> isize { 20 }"}, {"sha": "c05d292eaea47a395c115d08b5b1e6290da89061", "filename": "src/test/auxiliary/crateresolve7x.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve7x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve7x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve7x.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -14,10 +14,10 @@\n // These both have the same version but differ in other metadata\n pub mod a {\n     extern crate cr_1 (name = \"crateresolve_calories\", vers = \"0.1\", calories=\"100\");\n-    pub fn f() -> int { cr_1::f() }\n+    pub fn f() -> isize { cr_1::f() }\n }\n \n pub mod b {\n     extern crate cr_2 (name = \"crateresolve_calories\", vers = \"0.1\", calories=\"200\");\n-    pub fn f() -> int { cr_2::f() }\n+    pub fn f() -> isize { cr_2::f() }\n }"}, {"sha": "bc2a2d83bfec120db02d76c7d53bff421bdab85d", "filename": "src/test/auxiliary/crateresolve8-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve8-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve8-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve8-1.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -13,4 +13,4 @@\n \n #![crate_type = \"lib\"]\n \n-pub fn f() -> int { 20 }\n+pub fn f() -> isize { 20 }"}, {"sha": "c1705d687abb00bf6fbdad445cc6151b77b0c23c", "filename": "src/test/auxiliary/crateresolve_calories-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-1.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -11,4 +11,4 @@\n #![crate_name=\"crateresolve_calories#0.1\"]\n #![crate_type = \"lib\"]\n \n-pub fn f() -> int { 100 }\n+pub fn f() -> isize { 100 }"}, {"sha": "2ae87daab4e29b63f4498b9c0ac40678a752564e", "filename": "src/test/auxiliary/crateresolve_calories-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcrateresolve_calories-2.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -11,4 +11,4 @@\n #![crate_name=\"crateresolve_calories#0.1\"]\n #![crate_type = \"lib\"]\n \n-pub fn f() -> int { 200 }\n+pub fn f() -> isize { 200 }"}, {"sha": "91a404bbba3935c4c9e2c802a303f69641aaa7b2", "filename": "src/test/auxiliary/extern_calling_convention.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fextern_calling_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fextern_calling_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fextern_calling_convention.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -13,7 +13,7 @@\n \n #[inline(never)]\n #[cfg(target_arch = \"x86_64\")]\n-pub extern \"win64\" fn foo(a: int, b: int, c: int, d: int) {\n+pub extern \"win64\" fn foo(a: isize, b: isize, c: isize, d: isize) {\n     assert!(a == 1);\n     assert!(b == 2);\n     assert!(c == 3);\n@@ -25,7 +25,7 @@ pub extern \"win64\" fn foo(a: int, b: int, c: int, d: int) {\n \n #[inline(never)]\n #[cfg(any(target_arch = \"x86\", target_arch = \"arm\", target_arch = \"aarch64\"))]\n-pub extern fn foo(a: int, b: int, c: int, d: int) {\n+pub extern fn foo(a: isize, b: isize, c: isize, d: isize) {\n     assert!(a == 1);\n     assert!(b == 2);\n     assert!(c == 3);"}, {"sha": "0a921c8f5b3a0b1eb8fe6110786cf19a49977ba5", "filename": "src/test/auxiliary/go_trait.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fgo_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fgo_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fgo_trait.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -11,41 +11,41 @@\n // Common code used for tests that model the Fn/FnMut/FnOnce hierarchy.\n \n pub trait Go {\n-    fn go(&self, arg: int);\n+    fn go(&self, arg: isize);\n }\n \n-pub fn go<G:Go>(this: &G, arg: int) {\n+pub fn go<G:Go>(this: &G, arg: isize) {\n     this.go(arg)\n }\n \n pub trait GoMut {\n-    fn go_mut(&mut self, arg: int);\n+    fn go_mut(&mut self, arg: isize);\n }\n \n-pub fn go_mut<G:GoMut>(this: &mut G, arg: int) {\n+pub fn go_mut<G:GoMut>(this: &mut G, arg: isize) {\n     this.go_mut(arg)\n }\n \n pub trait GoOnce {\n-    fn go_once(self, arg: int);\n+    fn go_once(self, arg: isize);\n }\n \n-pub fn go_once<G:GoOnce>(this: G, arg: int) {\n+pub fn go_once<G:GoOnce>(this: G, arg: isize) {\n     this.go_once(arg)\n }\n \n impl<G> GoMut for G\n     where G : Go\n {\n-    fn go_mut(&mut self, arg: int) {\n+    fn go_mut(&mut self, arg: isize) {\n         go(&*self, arg)\n     }\n }\n \n impl<G> GoOnce for G\n     where G : GoMut\n {\n-    fn go_once(mut self, arg: int) {\n+    fn go_once(mut self, arg: isize) {\n         go_mut(&mut self, arg)\n     }\n }"}, {"sha": "ad3cdedf7eafebca8c7234ccdc29ea606708d3d1", "filename": "src/test/auxiliary/impl_privacy_xc_1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fimpl_privacy_xc_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fimpl_privacy_xc_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fimpl_privacy_xc_1.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -11,7 +11,7 @@\n #![crate_type = \"lib\"]\n \n pub struct Fish {\n-    pub x: int\n+    pub x: isize\n }\n \n impl Fish {"}, {"sha": "c3212b0fc6d22da10f0e422af95a3c793f6389ad", "filename": "src/test/auxiliary/impl_privacy_xc_2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fimpl_privacy_xc_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fimpl_privacy_xc_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fimpl_privacy_xc_2.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -11,7 +11,7 @@\n #![crate_type = \"lib\"]\n \n pub struct Fish {\n-    pub x: int\n+    pub x: isize\n }\n \n mod unexported {"}, {"sha": "6f5ddfd37a5c221e6585c1b13562e9374177bd8a", "filename": "src/test/auxiliary/inherit_struct_lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Finherit_struct_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Finherit_struct_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Finherit_struct_lib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -12,11 +12,11 @@\n #![feature(struct_inherit)]\n \n pub virtual struct S1 {\n-    pub f1: int,\n+    pub f1: isize,\n }\n \n pub struct S2 : S1 {\n-    pub f2: int,\n+    pub f2: isize,\n }\n \n pub fn test_s2(s2: S2) {"}, {"sha": "c09cc53466dc1f84c6d1d45edf3f86e7a86cd35f", "filename": "src/test/auxiliary/inherited_stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Finherited_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Finherited_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Finherited_stability.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -43,7 +43,7 @@ pub trait Stable {\n     fn stable(&self);\n }\n \n-impl Stable for uint {\n+impl Stable for usize {\n     fn unstable(&self) {}\n     fn stable(&self) {}\n }"}, {"sha": "0d15c13a4ef1e936322f9c64d9f947db9e2d348c", "filename": "src/test/auxiliary/inner_static.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Finner_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Finner_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Finner_static.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -15,43 +15,43 @@ pub mod test {\n     pub struct A<T> { pub v: T }\n \n     impl<T> A<T> {\n-        pub fn foo(&self) -> int {\n-            static a: int = 5;\n+        pub fn foo(&self) -> isize {\n+            static a: isize = 5;\n             return a\n         }\n \n-        pub fn bar(&self) -> int {\n-            static a: int = 6;\n+        pub fn bar(&self) -> isize {\n+            static a: isize = 6;\n             return a;\n         }\n     }\n }\n \n impl<T> A<T> {\n-    pub fn foo(&self) -> int {\n-        static a: int = 1;\n+    pub fn foo(&self) -> isize {\n+        static a: isize = 1;\n         return a\n     }\n \n-    pub fn bar(&self) -> int {\n-        static a: int = 2;\n+    pub fn bar(&self) -> isize {\n+        static a: isize = 2;\n         return a;\n     }\n }\n \n impl<T> B<T> {\n-    pub fn foo(&self) -> int {\n-        static a: int = 3;\n+    pub fn foo(&self) -> isize {\n+        static a: isize = 3;\n         return a\n     }\n \n-    pub fn bar(&self) -> int {\n-        static a: int = 4;\n+    pub fn bar(&self) -> isize {\n+        static a: isize = 4;\n         return a;\n     }\n }\n \n-pub fn foo() -> int {\n+pub fn foo() -> isize {\n     let a = A { v: () };\n     let b = B { v: () };\n     let c = test::A { v: () };"}, {"sha": "21935b6b9ab07fbc514e488143ff8b197b298100", "filename": "src/test/auxiliary/issue-11224.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue-11224.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue-11224.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-11224.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -15,12 +15,12 @@ mod inner {\n         fn f(&self) { f(); }\n     }\n \n-    impl Trait for int {}\n+    impl Trait for isize {}\n \n     fn f() {}\n }\n \n pub fn foo() {\n-    let a = &1i as &inner::Trait;\n+    let a = &1is as &inner::Trait;\n     a.f();\n }"}, {"sha": "37543ea1d3c5ef7028419ac7d1aa591cdf026bbd", "filename": "src/test/auxiliary/issue-11225-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue-11225-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue-11225-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-11225-1.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -13,7 +13,7 @@ mod inner {\n         fn f(&self) { f(); }\n     }\n \n-    impl Trait for int {}\n+    impl Trait for isize {}\n \n     fn f() {}\n }"}, {"sha": "f12e4c9b6e7ea347361f0fa075aba59997e28bf9", "filename": "src/test/auxiliary/issue-11225-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue-11225-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue-11225-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-11225-2.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -25,7 +25,7 @@ pub trait Outer {\n     fn foo<T: Trait>(&self, t: T) { t.f(); }\n }\n \n-impl Outer for int {}\n+impl Outer for isize {}\n \n pub fn foo<T: Outer>(t: T) {\n     t.foo(inner::Foo);"}, {"sha": "21ef99e3c3d95c7a562254d3c3e90cbc5894ef0a", "filename": "src/test/auxiliary/issue-11529.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue-11529.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue-11529.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-11529.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub struct A<'a>(pub &'a int);\n+pub struct A<'a>(pub &'a isize);"}, {"sha": "67474e7902170c91e96cc2a31474cb7e4a884894", "filename": "src/test/auxiliary/issue-17718.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue-17718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue-17718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-17718.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -10,13 +10,13 @@\n \n use std::sync::atomic;\n \n-pub const C1: uint = 1;\n+pub const C1: usize = 1;\n pub const C2: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n pub const C3: fn() = foo;\n-pub const C4: uint = C1 * C1 + C1 / C1;\n-pub const C5: &'static uint = &C4;\n+pub const C4: usize = C1 * C1 + C1 / C1;\n+pub const C5: &'static usize = &C4;\n \n-pub static S1: uint = 3;\n+pub static S1: usize = 3;\n pub static S2: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n \n fn foo() {}"}, {"sha": "8c414193bd6281185efdc23fe0d02df9868aa693", "filename": "src/test/auxiliary/issue-2414-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue-2414-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue-2414-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2414-a.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -11,7 +11,7 @@\n #![crate_name=\"a\"]\n #![crate_type = \"lib\"]\n \n-type t1 = uint;\n+type t1 = usize;\n \n trait foo {\n     fn foo(&self);"}, {"sha": "e85a0a90aff0fce5d1e4abc3d348f78012e39010", "filename": "src/test/auxiliary/issue-2526.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2526.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -16,7 +16,7 @@\n use std::marker;\n \n struct arc_destruct<T: Sync> {\n-    _data: int,\n+    _data: isize,\n     _marker: marker::PhantomData<T>\n }\n \n@@ -25,7 +25,7 @@ impl<T: Sync> Drop for arc_destruct<T> {\n     fn drop(&mut self) {}\n }\n \n-fn arc_destruct<T: Sync>(data: int) -> arc_destruct<T> {\n+fn arc_destruct<T: Sync>(data: isize) -> arc_destruct<T> {\n     arc_destruct {\n         _data: data,\n         _marker: marker::PhantomData\n@@ -41,7 +41,7 @@ fn init() -> arc_destruct<context_res> {\n }\n \n struct context_res {\n-    ctx : int,\n+    ctx : isize,\n }\n \n impl Drop for context_res {"}, {"sha": "82bd2b6420437f46357c755f7b47fd7a5da42802", "filename": "src/test/auxiliary/issue-5521.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue-5521.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue-5521.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-5521.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -11,4 +11,4 @@\n \n use std::collections::HashMap;\n \n-pub type map = Box<HashMap<uint, uint>>;\n+pub type map = Box<HashMap<usize, usize>>;"}, {"sha": "8f328699ae0aadb7aaefac767b1d24aaa6baf49e", "filename": "src/test/auxiliary/issue-8044.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue-8044.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue-8044.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-8044.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -21,5 +21,5 @@ pub fn leaf<V>(value: V) -> TreeItem<V> {\n }\n \n fn main() {\n-    BTree::<int> { node: leaf(1) };\n+    BTree::<isize> { node: leaf(1) };\n }"}, {"sha": "0da0b9fa47d6c1c01918ae1bb4ce77e125fada9c", "filename": "src/test/auxiliary/issue-9906.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue-9906.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue-9906.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-9906.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -14,9 +14,9 @@ pub use other::FooBar;\n pub use other::foo;\n \n mod other {\n-    pub struct FooBar{value: int}\n+    pub struct FooBar{value: isize}\n     impl FooBar{\n-        pub fn new(val: int) -> FooBar {\n+        pub fn new(val: isize) -> FooBar {\n             FooBar{value: val}\n         }\n     }"}, {"sha": "22ccb3dfacdf1285912e6bbab1083ca38e17d73d", "filename": "src/test/auxiliary/issue13507.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue13507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue13507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue13507.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -41,10 +41,10 @@ pub mod testtypes {\n     pub type FooChar = char;\n \n     // Tests ty_int (does not test all variants of IntTy)\n-    pub type FooInt = int;\n+    pub type FooInt = isize;\n \n     // Tests ty_uint (does not test all variants of UintTy)\n-    pub type FooUint = uint;\n+    pub type FooUint = usize;\n \n     // Tests ty_float (does not test all variants of FloatTy)\n     pub type FooFloat = f64;\n@@ -53,8 +53,8 @@ pub mod testtypes {\n \n     // Tests ty_enum\n     pub enum FooEnum {\n-        VarA(uint),\n-        VarB(uint, uint)\n+        VarA(usize),\n+        VarB(usize, usize)\n     }\n \n     // Tests ty_uniq (of u8)\n@@ -71,14 +71,14 @@ pub mod testtypes {\n \n     // Tests ty_trait\n     pub trait FooTrait {\n-        fn foo_method(&self) -> uint;\n-        fn foo_static_method() -> uint;\n+        fn foo_method(&self) -> usize;\n+        fn foo_static_method() -> usize;\n     }\n \n     // Tests ty_struct\n     pub struct FooStruct {\n-        pub pub_foo_field: uint,\n-        foo_field: uint\n+        pub pub_foo_field: usize,\n+        foo_field: usize\n     }\n \n     // Tests ty_tup"}, {"sha": "18f78750b15fc4df1b1050f8a6235d7021e7f82e", "filename": "src/test/auxiliary/issue_11680.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue_11680.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue_11680.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_11680.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n enum Foo {\n-    Bar(int)\n+    Bar(isize)\n }\n \n pub mod test {\n     enum Foo {\n-        Bar(int)\n+        Bar(isize)\n     }\n }"}, {"sha": "3901d73382fcfa2df3c5fcf5e6367d0d29b5e678", "filename": "src/test/auxiliary/issue_17718_const_privacy.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue_17718_const_privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue_17718_const_privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_17718_const_privacy.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -10,9 +10,9 @@\n \n pub use foo::FOO2;\n \n-pub const FOO: uint = 3;\n-const BAR: uint = 3;\n+pub const FOO: usize = 3;\n+const BAR: usize = 3;\n \n mod foo {\n-    pub const FOO2: uint = 3;\n+    pub const FOO2: usize = 3;\n }"}, {"sha": "12894ad72e1a4cea4f5d4a4ce1a91d576f0f97e3", "filename": "src/test/auxiliary/issue_19293.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue_19293.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue_19293.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_19293.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub struct Foo (pub int);\n+pub struct Foo (pub isize);\n pub enum MyEnum {\n     Foo(Foo),\n }"}, {"sha": "44bea136a7c3b3468d2653199572f214fb78e191", "filename": "src/test/auxiliary/issue_2723_a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue_2723_a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue_2723_a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2723_a.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n \n-pub unsafe fn f(xs: Vec<int> ) {\n+pub unsafe fn f(xs: Vec<isize> ) {\n     xs.iter().map(|_x| { unsafe fn q() { panic!(); } }).collect::<Vec<()>>();\n }"}, {"sha": "5c306be69c42935cb656df5484c5a94f7b18411f", "filename": "src/test/auxiliary/issue_3979_traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue_3979_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue_3979_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_3979_traits.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -13,12 +13,12 @@\n #![crate_type = \"lib\"]\n \n pub trait Positioned {\n-  fn SetX(&mut self, int);\n-  fn X(&self) -> int;\n+  fn SetX(&mut self, isize);\n+  fn X(&self) -> isize;\n }\n \n pub trait Movable: Positioned {\n-  fn translate(&mut self, dx: int) {\n+  fn translate(&mut self, dx: isize) {\n     let x = self.X() + dx;\n     self.SetX(x);\n   }"}, {"sha": "8ff85cc359d4f7bd3499daae67e7a831eef39a6d", "filename": "src/test/auxiliary/issue_9188.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue_9188.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fissue_9188.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_9188.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -8,16 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub fn foo<T>() -> &'static int {\n+pub fn foo<T>() -> &'static isize {\n     if false {\n-        static a: int = 4;\n+        static a: isize = 4;\n         return &a;\n     } else {\n-        static a: int = 5;\n+        static a: isize = 5;\n         return &a;\n     }\n }\n \n-pub fn bar() -> &'static int {\n-    foo::<int>()\n+pub fn bar() -> &'static isize {\n+    foo::<isize>()\n }"}, {"sha": "3b4547e31f5d53a6420409729133536756c5c4c6", "filename": "src/test/auxiliary/lang-item-public.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Flang-item-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flang-item-public.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -20,7 +20,7 @@ impl<A:?Sized, R:?Sized, U:?Sized> PhantomFn<A,R> for U { }\n pub trait Sized : PhantomFn<Self> {}\n \n #[lang=\"panic\"]\n-fn panic(_: &(&'static str, &'static str, uint)) -> ! { loop {} }\n+fn panic(_: &(&'static str, &'static str, usize)) -> ! { loop {} }\n \n #[lang = \"stack_exhausted\"]\n extern fn stack_exhausted() {}"}, {"sha": "d96dfd848f3f0e3b8968c6086abcba5628228477", "filename": "src/test/auxiliary/linkage-visibility.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -31,8 +31,8 @@ fn baz() { }\n pub fn test() {\n     let lib = DynamicLibrary::open(None).unwrap();\n     unsafe {\n-        assert!(lib.symbol::<int>(\"foo\").is_ok());\n-        assert!(lib.symbol::<int>(\"baz\").is_err());\n-        assert!(lib.symbol::<int>(\"bar\").is_err());\n+        assert!(lib.symbol::<isize>(\"foo\").is_ok());\n+        assert!(lib.symbol::<isize>(\"baz\").is_err());\n+        assert!(lib.symbol::<isize>(\"bar\").is_err());\n     }\n }"}, {"sha": "ca4046d81636a2a1bc9e1749f99432ee28b9c2ce", "filename": "src/test/auxiliary/linkage1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Flinkage1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Flinkage1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flinkage1.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n #[no_mangle]\n-pub static foo: int = 3;\n+pub static foo: isize = 3;\n \n pub fn bar() {}"}, {"sha": "50a9202a87b5c224ff4280bc001e90c56bc99b04", "filename": "src/test/auxiliary/lint_output_format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Flint_output_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Flint_output_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_output_format.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -16,16 +16,16 @@\n \n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n #[deprecated(since = \"1.0.0\")]\n-pub fn foo() -> uint {\n+pub fn foo() -> usize {\n     20\n }\n \n #[unstable(feature = \"test_feature\")]\n-pub fn bar() -> uint {\n+pub fn bar() -> usize {\n     40\n }\n \n #[unstable(feature = \"test_feature\")]\n-pub fn baz() -> uint {\n+pub fn baz() -> usize {\n     30\n }"}, {"sha": "bb3b71bc2441b3a5761c47d4362a8d25c6574c62", "filename": "src/test/auxiliary/lint_stability.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -101,20 +101,20 @@ pub trait UnstableTrait { fn dummy(&self) { } }\n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n #[deprecated(since = \"1.0.0\")]\n pub struct DeprecatedStruct {\n-    #[stable(feature = \"test_feature\", since = \"1.0.0\")] pub i: int\n+    #[stable(feature = \"test_feature\", since = \"1.0.0\")] pub i: isize\n }\n #[unstable(feature = \"test_feature\")]\n #[deprecated(since = \"1.0.0\")]\n pub struct DeprecatedUnstableStruct {\n-    #[stable(feature = \"test_feature\", since = \"1.0.0\")] pub i: int\n+    #[stable(feature = \"test_feature\", since = \"1.0.0\")] pub i: isize\n }\n #[unstable(feature = \"test_feature\")]\n pub struct UnstableStruct {\n-    #[stable(feature = \"test_feature\", since = \"1.0.0\")] pub i: int\n+    #[stable(feature = \"test_feature\", since = \"1.0.0\")] pub i: isize\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StableStruct {\n-    #[stable(feature = \"test_feature\", since = \"1.0.0\")] pub i: int\n+    #[stable(feature = \"test_feature\", since = \"1.0.0\")] pub i: isize\n }\n \n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n@@ -145,14 +145,14 @@ pub enum Enum {\n \n #[stable(feature = \"test_feature\", since = \"1.0.0\")]\n #[deprecated(since = \"1.0.0\")]\n-pub struct DeprecatedTupleStruct(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub int);\n+pub struct DeprecatedTupleStruct(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub isize);\n #[unstable(feature = \"test_feature\")]\n #[deprecated(since = \"1.0.0\")]\n-pub struct DeprecatedUnstableTupleStruct(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub int);\n+pub struct DeprecatedUnstableTupleStruct(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub isize);\n #[unstable(feature = \"test_feature\")]\n-pub struct UnstableTupleStruct(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub int);\n+pub struct UnstableTupleStruct(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub isize);\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct StableTupleStruct(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub int);\n+pub struct StableTupleStruct(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub isize);\n \n #[macro_export]\n macro_rules! macro_test {"}, {"sha": "db26b10fc67cbf24442d3ea5bb78871234c7a03a", "filename": "src/test/auxiliary/logging_right_crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Flogging_right_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Flogging_right_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flogging_right_crate.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -13,6 +13,6 @@\n #[macro_use] extern crate log;\n \n pub fn foo<T>() {\n-    fn death() -> int { panic!() }\n+    fn death() -> isize { panic!() }\n     debug!(\"{}\", (||{ death() })());\n }"}, {"sha": "4f75e2b5d75651e05095f0fa6d2b0046c297363d", "filename": "src/test/auxiliary/macro_crate_nonterminal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fmacro_crate_nonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fmacro_crate_nonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_nonterminal.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub fn increment(x: uint) -> uint {\n+pub fn increment(x: usize) -> usize {\n     x + 1\n }\n "}, {"sha": "f95be3f4a1d057def76337564ffd0e2f876c653f", "filename": "src/test/auxiliary/moves_based_on_type_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fmoves_based_on_type_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fmoves_based_on_type_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmoves_based_on_type_lib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -11,7 +11,7 @@\n #![crate_type=\"lib\"]\n \n pub struct S {\n-    x: int,\n+    x: isize,\n }\n \n impl Drop for S {"}, {"sha": "b7bde4a74a553b05c13e38788fdcf94a4db24e7c", "filename": "src/test/auxiliary/namespaced_enum_emulate_flat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fnamespaced_enum_emulate_flat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fnamespaced_enum_emulate_flat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fnamespaced_enum_emulate_flat.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -12,8 +12,8 @@ pub use Foo::*;\n \n pub enum Foo {\n     A,\n-    B(int),\n-    C { a: int },\n+    B(isize),\n+    C { a: isize },\n }\n \n impl Foo {\n@@ -25,8 +25,8 @@ pub mod nest {\n \n     pub enum Bar {\n         D,\n-        E(int),\n-        F { a: int },\n+        E(isize),\n+        F { a: isize },\n     }\n \n     impl Bar {"}, {"sha": "3bf39b788db6e1e2b6b8c3f9728c1485916cb5ad", "filename": "src/test/auxiliary/namespaced_enums.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fnamespaced_enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fnamespaced_enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fnamespaced_enums.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -10,8 +10,8 @@\n \n pub enum Foo {\n     A,\n-    B(int),\n-    C { a: int },\n+    B(isize),\n+    C { a: isize },\n }\n \n impl Foo {"}, {"sha": "63639c4cdb3c921eafff3fde33a11bbc7aca58d1", "filename": "src/test/auxiliary/nested_item.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fnested_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fnested_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fnested_item.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n // original problem\n-pub fn foo<T>() -> int {\n+pub fn foo<T>() -> isize {\n     {\n-        static foo: int = 2;\n+        static foo: isize = 2;\n         foo\n     }\n }\n@@ -20,7 +20,7 @@ pub fn foo<T>() -> int {\n struct Foo;\n impl Foo {\n     pub fn foo<T>(&self) {\n-        static X: uint = 1;\n+        static X: usize = 1;\n     }\n }\n \n@@ -35,6 +35,6 @@ impl<T: std::iter::Iterator<Item=char>> Parser<T> {\n struct Bar;\n impl Foo {\n     pub fn bar<T>(&self) {\n-        static X: uint = 1;\n+        static X: usize = 1;\n     }\n }"}, {"sha": "be3414b7ad2c0ab39be4334b3634cc887dda9e89", "filename": "src/test/auxiliary/newtype_struct_xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fnewtype_struct_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fnewtype_struct_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fnewtype_struct_xc.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -10,4 +10,4 @@\n \n #![crate_type=\"lib\"]\n \n-pub struct Au(pub int);\n+pub struct Au(pub isize);"}, {"sha": "5ae8e0d298e53b046fb7e0203c6e5f51cac3505e", "filename": "src/test/auxiliary/noexporttypelib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fnoexporttypelib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fnoexporttypelib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fnoexporttypelib.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -8,5 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub type oint = Option<int>;\n+pub type oint = Option<isize>;\n pub fn foo() -> oint { Some(3) }"}, {"sha": "5d93c131cadb73cbae3136c4a87844177c7fc3ea", "filename": "src/test/auxiliary/plugin_crate_outlive_expansion_phase.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fplugin_crate_outlive_expansion_phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fplugin_crate_outlive_expansion_phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fplugin_crate_outlive_expansion_phase.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -20,7 +20,7 @@ use std::cell::RefCell;\n use rustc::plugin::Registry;\n \n struct Foo {\n-    foo: int\n+    foo: isize\n }\n \n impl Drop for Foo {"}, {"sha": "19cdede5518a4e620f162c7482694f6b45ab9a38", "filename": "src/test/auxiliary/priv-impl-prim-ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fpriv-impl-prim-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fpriv-impl-prim-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fpriv-impl-prim-ty.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -12,7 +12,7 @@ pub trait A {\n     fn frob(&self);\n }\n \n-impl A for int { fn frob(&self) {} }\n+impl A for isize { fn frob(&self) {} }\n \n pub fn frob<T:A>(t: T) {\n     t.frob();"}, {"sha": "141b6bdd604fe0aff9701ff9f32c7a31683af341", "filename": "src/test/auxiliary/privacy_tuple_struct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fprivacy_tuple_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fprivacy_tuple_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fprivacy_tuple_struct.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n pub struct A(());\n-pub struct B(int);\n-pub struct C(pub int, int);\n-pub struct D(pub int);\n+pub struct B(isize);\n+pub struct C(pub isize, isize);\n+pub struct D(pub isize);"}, {"sha": "41aafd64cb3f488fd8f9f514e83054420c86f3b9", "filename": "src/test/auxiliary/pub_use_xcrate1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fpub_use_xcrate1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43bfaa4a336095eb5697fb2df50909fd3c72ed14/src%2Ftest%2Fauxiliary%2Fpub_use_xcrate1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fpub_use_xcrate1.rs?ref=43bfaa4a336095eb5697fb2df50909fd3c72ed14", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n pub struct Foo {\n-    pub name: int\n+    pub name: isize\n }"}]}