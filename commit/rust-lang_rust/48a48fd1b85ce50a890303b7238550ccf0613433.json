{"sha": "48a48fd1b85ce50a890303b7238550ccf0613433", "node_id": "C_kwDOAAsO6NoAKDQ4YTQ4ZmQxYjg1Y2U1MGE4OTAzMDNiNzIzODU1MGNjZjA2MTM0MzM", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2021-12-19T00:06:53Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2022-02-08T17:35:42Z"}, "message": "Improve opaque type higher-ranked region error message under NLL\n\nCurrently, any higher-ranked region errors involving opaque types\nfall back to a generic \"higher-ranked subtype error\" message when\nrun under NLL. This PR adds better error message handling for this\ncase, giving us the same kinds of error messages that we currently\nget without NLL:\n\n```\nerror: implementation of `MyTrait` is not general enough\n  --> $DIR/opaque-hrtb.rs:12:13\n   |\nLL | fn foo() -> impl for<'a> MyTrait<&'a str> {\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `MyTrait` is not general enough\n   |\n   = note: `impl MyTrait<&'2 str>` must implement `MyTrait<&'1 str>`, for any lifetime `'1`...\n   = note: ...but it actually implements `MyTrait<&'2 str>`, for some specific lifetime `'2`\n\nerror: aborting due to previous error\n```\n\nTo accomplish this, several different refactoring needed to be made:\n\n* We now have a dedicated `InstantiateOpaqueType` struct which\nimplements `TypeOp`. This is used to invoke `instantiate_opaque_types`\nduring MIR type checking.\n* `TypeOp` is refactored to pass around a `MirBorrowckCtxt`, which is\nneeded to report opaque type region errors.\n* We no longer assume that all `TypeOp`s correspond to canonicalized\nqueries. This allows us to properly handle opaque type instantiation\n(which does not occur in a query) as a `TypeOp`.\nA new `ErrorInfo` associated type is used to determine what\nadditional information is used during higher-ranked region error\nhandling.\n* The body of `try_extract_error_from_fulfill_cx`\nhas been moved out to a new function `try_extract_error_from_region_constraints`.\nThis allows us to re-use the same error reporting code between\ncanonicalized queries (which can extract region constraints directly\nfrom a fresh `InferCtxt`) and opaque type handling (which needs to take\nregion constraints from the pre-existing `InferCtxt` that we use\nthroughout MIR borrow checking).", "tree": {"sha": "a03ebee81006eac9a123fb735c1ca03f431d5a1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a03ebee81006eac9a123fb735c1ca03f431d5a1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48a48fd1b85ce50a890303b7238550ccf0613433", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAmICqe4ACgkQtAh+UQ6Y\nsWTWrRAAmGab/Mg1alKO3teUAOluYwEP/CxN/RXWbTJ4VjiyEGol2mVB69wBAFq+\n0qioR/kKpLuTdHRmZBjksBfYebFy5c0DRJU2kjDE35xGbMAWAWEgrj/NGxr63oCC\nJrq6T4TE41Q++kAj+916K0Zy4RUmdq7MH7CeR2Q8G4VukbAIRP7qydHt1zFRREB5\nXlCh4R0qonwGu1wIXA95fwbTbsGYYVCIgfw0MFOxk6HwKVPerGOnYYmcLzKGqJQu\nwbWCqHblmn2vXVmeH3DYLb9bJDqypTM2p4Oj+eEzyl0ocDjVJjetbPHje0/ysCRd\nCKHZuT+ydQ33VbaQURcgmEl/H74eFTUQGAy+7MXxF7CTxAPAQDaLQUla9naT8rdC\nSvufEu/HLDF0secSR5b/48PkYPX/YVc0qWhd/7vbo/khDF9pzkzlGTto9DXfVEui\n7iyCPQvFcKUwtwBwrdCXcuAJbESSZVsqQ2VIsjM7AkvfyIj3DykqmLxn4TcVB2oU\nRaMeWGVswsOB2v1vRH5x+nsRW026VCKIh8EXBVX6+ZnfKkBLyCnrI3ZT3+rC39Sw\nZlJrWsy4sQB/fPpkcNhkyJsb4nECjBue966GZ6vXeFXYfUxQ/O/sVWgjtW5efFdb\n0RbC7rN2D8/kORB16loCfB2gM72I9f47GrT6/5Nk+rASG3WKCaM=\n=z3A0\n-----END PGP SIGNATURE-----", "payload": "tree a03ebee81006eac9a123fb735c1ca03f431d5a1d\nparent e7cc3bddbe0d0e374d05e7003e662bba1742dbae\nauthor Aaron Hill <aa1ronham@gmail.com> 1639872413 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1644341742 -0500\n\nImprove opaque type higher-ranked region error message under NLL\n\nCurrently, any higher-ranked region errors involving opaque types\nfall back to a generic \"higher-ranked subtype error\" message when\nrun under NLL. This PR adds better error message handling for this\ncase, giving us the same kinds of error messages that we currently\nget without NLL:\n\n```\nerror: implementation of `MyTrait` is not general enough\n  --> $DIR/opaque-hrtb.rs:12:13\n   |\nLL | fn foo() -> impl for<'a> MyTrait<&'a str> {\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `MyTrait` is not general enough\n   |\n   = note: `impl MyTrait<&'2 str>` must implement `MyTrait<&'1 str>`, for any lifetime `'1`...\n   = note: ...but it actually implements `MyTrait<&'2 str>`, for some specific lifetime `'2`\n\nerror: aborting due to previous error\n```\n\nTo accomplish this, several different refactoring needed to be made:\n\n* We now have a dedicated `InstantiateOpaqueType` struct which\nimplements `TypeOp`. This is used to invoke `instantiate_opaque_types`\nduring MIR type checking.\n* `TypeOp` is refactored to pass around a `MirBorrowckCtxt`, which is\nneeded to report opaque type region errors.\n* We no longer assume that all `TypeOp`s correspond to canonicalized\nqueries. This allows us to properly handle opaque type instantiation\n(which does not occur in a query) as a `TypeOp`.\nA new `ErrorInfo` associated type is used to determine what\nadditional information is used during higher-ranked region error\nhandling.\n* The body of `try_extract_error_from_fulfill_cx`\nhas been moved out to a new function `try_extract_error_from_region_constraints`.\nThis allows us to re-use the same error reporting code between\ncanonicalized queries (which can extract region constraints directly\nfrom a fresh `InferCtxt`) and opaque type handling (which needs to take\nregion constraints from the pre-existing `InferCtxt` that we use\nthroughout MIR borrow checking).\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48a48fd1b85ce50a890303b7238550ccf0613433", "html_url": "https://github.com/rust-lang/rust/commit/48a48fd1b85ce50a890303b7238550ccf0613433", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48a48fd1b85ce50a890303b7238550ccf0613433/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7cc3bddbe0d0e374d05e7003e662bba1742dbae", "html_url": "https://github.com/rust-lang/rust/commit/e7cc3bddbe0d0e374d05e7003e662bba1742dbae"}], "stats": {"total": 302, "additions": 231, "deletions": 71}, "files": [{"sha": "07289d68e2de38b7d618a66f4df5af02432df486", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 87, "deletions": 21, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/48a48fd1b85ce50a890303b7238550ccf0613433/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a48fd1b85ce50a890303b7238550ccf0613433/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=48a48fd1b85ce50a890303b7238550ccf0613433", "patch": "@@ -2,9 +2,13 @@ use rustc_errors::DiagnosticBuilder;\n use rustc_infer::infer::canonical::Canonical;\n use rustc_infer::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc_infer::infer::region_constraints::Constraint;\n+use rustc_infer::infer::region_constraints::RegionConstraintData;\n+use rustc_infer::infer::RegionVariableOrigin;\n use rustc_infer::infer::{InferCtxt, RegionResolutionError, SubregionOrigin, TyCtxtInferExt as _};\n use rustc_infer::traits::{Normalized, ObligationCause, TraitEngine, TraitEngineExt};\n use rustc_middle::ty::error::TypeError;\n+use rustc_middle::ty::RegionVid;\n+use rustc_middle::ty::UniverseIndex;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::type_op;\n@@ -78,6 +82,15 @@ crate trait ToUniverseInfo<'tcx> {\n     fn to_universe_info(self, base_universe: ty::UniverseIndex) -> UniverseInfo<'tcx>;\n }\n \n+impl<'tcx> ToUniverseInfo<'tcx> for crate::type_check::InstantiateOpaqueType<'tcx> {\n+    fn to_universe_info(self, base_universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n+        UniverseInfo(UniverseInfoInner::TypeOp(Rc::new(crate::type_check::InstantiateOpaqueType {\n+            base_universe: Some(base_universe),\n+            ..self\n+        })))\n+    }\n+}\n+\n impl<'tcx> ToUniverseInfo<'tcx>\n     for Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::prove_predicate::ProvePredicate<'tcx>>>\n {\n@@ -118,6 +131,12 @@ impl<'tcx, F, G> ToUniverseInfo<'tcx> for Canonical<'tcx, type_op::custom::Custo\n     }\n }\n \n+impl<'tcx> ToUniverseInfo<'tcx> for ! {\n+    fn to_universe_info(self, _base_universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n+        self\n+    }\n+}\n+\n #[allow(unused_lifetimes)]\n trait TypeOpInfo<'tcx> {\n     /// Returns an error to be reported if rerunning the type op fails to\n@@ -128,7 +147,7 @@ trait TypeOpInfo<'tcx> {\n \n     fn nice_error(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n+        mbcx: &mut MirBorrowckCtxt<'_, 'tcx>,\n         cause: ObligationCause<'tcx>,\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n@@ -175,7 +194,7 @@ trait TypeOpInfo<'tcx> {\n         debug!(?placeholder_region);\n \n         let span = cause.span;\n-        let nice_error = self.nice_error(tcx, cause, placeholder_region, error_region);\n+        let nice_error = self.nice_error(mbcx, cause, placeholder_region, error_region);\n \n         if let Some(nice_error) = nice_error {\n             nice_error.buffer(&mut mbcx.errors_buffer);\n@@ -204,16 +223,16 @@ impl<'tcx> TypeOpInfo<'tcx> for PredicateQuery<'tcx> {\n \n     fn nice_error(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n+        mbcx: &mut MirBorrowckCtxt<'_, 'tcx>,\n         cause: ObligationCause<'tcx>,\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx>> {\n-        tcx.infer_ctxt().enter_with_canonical(\n+        mbcx.infcx.tcx.infer_ctxt().enter_with_canonical(\n             cause.span,\n             &self.canonical_query,\n             |ref infcx, key, _| {\n-                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(tcx);\n+                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n                 type_op_prove_predicate_with_cause(infcx, &mut *fulfill_cx, key, cause);\n                 try_extract_error_from_fulfill_cx(\n                     fulfill_cx,\n@@ -247,16 +266,16 @@ where\n \n     fn nice_error(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n+        mbcx: &mut MirBorrowckCtxt<'_, 'tcx>,\n         cause: ObligationCause<'tcx>,\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx>> {\n-        tcx.infer_ctxt().enter_with_canonical(\n+        mbcx.infcx.tcx.infer_ctxt().enter_with_canonical(\n             cause.span,\n             &self.canonical_query,\n             |ref infcx, key, _| {\n-                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(tcx);\n+                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n \n                 let mut selcx = SelectionContext::new(infcx);\n \n@@ -304,16 +323,16 @@ impl<'tcx> TypeOpInfo<'tcx> for AscribeUserTypeQuery<'tcx> {\n \n     fn nice_error(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n+        mbcx: &mut MirBorrowckCtxt<'_, 'tcx>,\n         cause: ObligationCause<'tcx>,\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx>> {\n-        tcx.infer_ctxt().enter_with_canonical(\n+        mbcx.infcx.tcx.infer_ctxt().enter_with_canonical(\n             cause.span,\n             &self.canonical_query,\n             |ref infcx, key, _| {\n-                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(tcx);\n+                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n                 type_op_ascribe_user_type_with_span(infcx, &mut *fulfill_cx, key, Some(cause.span))\n                     .ok()?;\n                 try_extract_error_from_fulfill_cx(\n@@ -327,43 +346,90 @@ impl<'tcx> TypeOpInfo<'tcx> for AscribeUserTypeQuery<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeOpInfo<'tcx> for crate::type_check::InstantiateOpaqueType<'tcx> {\n+    fn fallback_error(&self, tcx: TyCtxt<'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+        // FIXME: This error message isn't great, but it doesn't show up in the existing UI tests,\n+        // and is only the fallback when the nice error fails. Consider improving this some more.\n+        tcx.sess.struct_span_err(span, \"higher-ranked lifetime error for opaque type!\")\n+    }\n+\n+    fn base_universe(&self) -> ty::UniverseIndex {\n+        self.base_universe.unwrap()\n+    }\n+\n+    fn nice_error(\n+        &self,\n+        mbcx: &mut MirBorrowckCtxt<'_, 'tcx>,\n+        _cause: ObligationCause<'tcx>,\n+        placeholder_region: ty::Region<'tcx>,\n+        error_region: Option<ty::Region<'tcx>>,\n+    ) -> Option<DiagnosticBuilder<'tcx>> {\n+        try_extract_error_from_region_constraints(\n+            mbcx.infcx,\n+            placeholder_region,\n+            error_region,\n+            self.region_constraints.as_ref().unwrap(),\n+            // We're using the original `InferCtxt` that we\n+            // started MIR borrowchecking with, so the region\n+            // constraints have already been taken. Use the data from\n+            // our `mbcx` instead.\n+            |vid| mbcx.regioncx.var_infos[vid].origin,\n+            |vid| mbcx.regioncx.var_infos[vid].universe,\n+        )\n+    }\n+}\n+\n #[instrument(skip(fulfill_cx, infcx), level = \"debug\")]\n fn try_extract_error_from_fulfill_cx<'tcx>(\n     mut fulfill_cx: Box<dyn TraitEngine<'tcx> + 'tcx>,\n     infcx: &InferCtxt<'_, 'tcx>,\n     placeholder_region: ty::Region<'tcx>,\n     error_region: Option<ty::Region<'tcx>>,\n ) -> Option<DiagnosticBuilder<'tcx>> {\n-    let tcx = infcx.tcx;\n-\n     // We generally shouldn't have errors here because the query was\n     // already run, but there's no point using `delay_span_bug`\n     // when we're going to emit an error here anyway.\n     let _errors = fulfill_cx.select_all_or_error(infcx);\n+    let region_constraints = infcx.with_region_constraints(|r| r.clone());\n+    try_extract_error_from_region_constraints(\n+        infcx,\n+        placeholder_region,\n+        error_region,\n+        &region_constraints,\n+        |vid| infcx.region_var_origin(vid),\n+        |vid| infcx.universe_of_region(infcx.tcx.mk_region(ty::ReVar(vid))),\n+    )\n+}\n \n-    let (sub_region, cause) = infcx.with_region_constraints(|region_constraints| {\n-        debug!(\"{:#?}\", region_constraints);\n+fn try_extract_error_from_region_constraints<'tcx>(\n+    infcx: &InferCtxt<'_, 'tcx>,\n+    placeholder_region: ty::Region<'tcx>,\n+    error_region: Option<ty::Region<'tcx>>,\n+    region_constraints: &RegionConstraintData<'tcx>,\n+    mut region_var_origin: impl FnMut(RegionVid) -> RegionVariableOrigin,\n+    mut universe_of_region: impl FnMut(RegionVid) -> UniverseIndex,\n+) -> Option<DiagnosticBuilder<'tcx>> {\n+    let (sub_region, cause) =\n         region_constraints.constraints.iter().find_map(|(constraint, cause)| {\n             match *constraint {\n                 Constraint::RegSubReg(sub, sup) if sup == placeholder_region && sup != sub => {\n                     Some((sub, cause.clone()))\n                 }\n                 // FIXME: Should this check the universe of the var?\n                 Constraint::VarSubReg(vid, sup) if sup == placeholder_region => {\n-                    Some((tcx.mk_region(ty::ReVar(vid)), cause.clone()))\n+                    Some((infcx.tcx.mk_region(ty::ReVar(vid)), cause.clone()))\n                 }\n                 _ => None,\n             }\n-        })\n-    })?;\n+        })?;\n \n     debug!(?sub_region, \"cause = {:#?}\", cause);\n     let nice_error = match (error_region, sub_region) {\n         (Some(error_region), &ty::ReVar(vid)) => NiceRegionError::new(\n             infcx,\n             RegionResolutionError::SubSupConflict(\n                 vid,\n-                infcx.region_var_origin(vid),\n+                region_var_origin(vid),\n                 cause.clone(),\n                 error_region,\n                 cause.clone(),\n@@ -380,8 +446,8 @@ fn try_extract_error_from_fulfill_cx<'tcx>(\n             infcx,\n             RegionResolutionError::UpperBoundUniverseConflict(\n                 vid,\n-                infcx.region_var_origin(vid),\n-                infcx.universe_of_region(sub_region),\n+                region_var_origin(vid),\n+                universe_of_region(vid),\n                 cause.clone(),\n                 placeholder_region,\n             ),"}, {"sha": "d698131df18dc10a39ff7871f9374097e99d8246", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48a48fd1b85ce50a890303b7238550ccf0613433/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a48fd1b85ce50a890303b7238550ccf0613433/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=48a48fd1b85ce50a890303b7238550ccf0613433", "patch": "@@ -5,6 +5,7 @@\n #![feature(crate_visibility_modifier)]\n #![feature(let_else)]\n #![feature(min_specialization)]\n+#![feature(never_type)]\n #![feature(stmt_expr_attributes)]\n #![feature(trusted_step)]\n #![feature(try_blocks)]"}, {"sha": "1dc9240620b1368343c0dec3e97dc383a76abaca", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48a48fd1b85ce50a890303b7238550ccf0613433/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a48fd1b85ce50a890303b7238550ccf0613433/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=48a48fd1b85ce50a890303b7238550ccf0613433", "patch": "@@ -44,6 +44,7 @@ mod reverse_sccs;\n pub mod values;\n \n pub struct RegionInferenceContext<'tcx> {\n+    pub var_infos: VarInfos,\n     /// Contains the definition for every region variable. Region\n     /// variables are identified by their index (`RegionVid`). The\n     /// definition contains information about where the region came\n@@ -266,7 +267,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> Self {\n         // Create a RegionDefinition for each inference variable.\n         let definitions: IndexVec<_, _> = var_infos\n-            .into_iter()\n+            .iter()\n             .map(|info| RegionDefinition::new(info.universe, info.origin))\n             .collect();\n \n@@ -291,6 +292,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             Rc::new(member_constraints_in.into_mapped(|r| constraint_sccs.scc(r)));\n \n         let mut result = Self {\n+            var_infos,\n             definitions,\n             liveness_constraints,\n             constraints,"}, {"sha": "3856b7f4a4b8227e182bd3e2969a962085958ee0", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/48a48fd1b85ce50a890303b7238550ccf0613433/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a48fd1b85ce50a890303b7238550ccf0613433/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=48a48fd1b85ce50a890303b7238550ccf0613433", "patch": "@@ -33,12 +33,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     ) -> Fallible<R>\n     where\n         Op: type_op::TypeOp<'tcx, Output = R>,\n-        Canonical<'tcx, Op>: ToUniverseInfo<'tcx>,\n+        Op::ErrorInfo: ToUniverseInfo<'tcx>,\n     {\n         let old_universe = self.infcx.universe();\n \n-        let TypeOpOutput { output, constraints, canonicalized_query } =\n-            op.fully_perform(self.infcx)?;\n+        let TypeOpOutput { output, constraints, error_info } = op.fully_perform(self.infcx)?;\n \n         if let Some(data) = &constraints {\n             self.push_region_constraints(locations, category, data);\n@@ -47,8 +46,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         let universe = self.infcx.universe();\n \n         if old_universe != universe {\n-            let universe_info = match canonicalized_query {\n-                Some(canonicalized_query) => canonicalized_query.to_universe_info(old_universe),\n+            let universe_info = match error_info {\n+                Some(error_info) => error_info.to_universe_info(old_universe),\n                 None => UniverseInfo::other(),\n             };\n             for u in old_universe..universe {"}, {"sha": "48d8ae8947ff75537c47153a50223b6ce760efd3", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48a48fd1b85ce50a890303b7238550ccf0613433/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a48fd1b85ce50a890303b7238550ccf0613433/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=48a48fd1b85ce50a890303b7238550ccf0613433", "patch": "@@ -268,7 +268,7 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n                         TypeOpOutput {\n                             output: self.infcx.tcx.ty_error(),\n                             constraints: None,\n-                            canonicalized_query: None,\n+                            error_info: None,\n                         }\n                     });\n                 // Note: we need this in examples like"}, {"sha": "97021aa228420272af7966f440cdda8c74764d98", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/48a48fd1b85ce50a890303b7238550ccf0613433/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a48fd1b85ce50a890303b7238550ccf0613433/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=48a48fd1b85ce50a890303b7238550ccf0613433", "patch": "@@ -17,6 +17,7 @@ use rustc_hir::lang_items::LangItem;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n use rustc_infer::infer::outlives::env::RegionBoundPairs;\n+use rustc_infer::infer::region_constraints::RegionConstraintData;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{\n     InferCtxt, InferOk, LateBoundRegionConversionTime, NllRegionVariableOrigin,\n@@ -39,9 +40,11 @@ use rustc_target::abi::VariantIdx;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::type_op;\n+use rustc_trait_selection::traits::query::type_op::custom::scrape_region_constraints;\n use rustc_trait_selection::traits::query::type_op::custom::CustomTypeOp;\n+use rustc_trait_selection::traits::query::type_op::{TypeOp, TypeOpOutput};\n use rustc_trait_selection::traits::query::Fallible;\n-use rustc_trait_selection::traits::{self, ObligationCause};\n+use rustc_trait_selection::traits::{self, ObligationCause, PredicateObligation};\n \n use rustc_const_eval::transform::{\n     check_consts::ConstCx, promote_consts::is_const_fn_in_array_repeat_expression,\n@@ -2637,3 +2640,32 @@ impl NormalizeLocation for Location {\n         Locations::Single(self)\n     }\n }\n+\n+/// Runs `infcx.instantiate_opaque_types`. Unlike other `TypeOp`s,\n+/// this is not canonicalized - it directly affects the main `InferCtxt`\n+/// that we use during MIR borrowchecking.\n+#[derive(Debug)]\n+pub(super) struct InstantiateOpaqueType<'tcx> {\n+    pub base_universe: Option<ty::UniverseIndex>,\n+    pub region_constraints: Option<RegionConstraintData<'tcx>>,\n+    pub obligation: PredicateObligation<'tcx>,\n+}\n+\n+impl<'tcx> TypeOp<'tcx> for InstantiateOpaqueType<'tcx> {\n+    type Output = ();\n+    /// We use this type itself to store the information used\n+    /// when reporting errors. Since this is not a query, we don't\n+    /// re-run anything during error reporting - we just use the information\n+    /// we saved to help extract an error from the already-existing region\n+    /// constraints in our `InferCtxt`\n+    type ErrorInfo = InstantiateOpaqueType<'tcx>;\n+\n+    fn fully_perform(mut self, infcx: &InferCtxt<'_, 'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>> {\n+        let (mut output, region_constraints) = scrape_region_constraints(infcx, || {\n+            Ok(InferOk { value: (), obligations: vec![self.obligation.clone()] })\n+        })?;\n+        self.region_constraints = Some(region_constraints);\n+        output.error_info = Some(self);\n+        Ok(output)\n+    }\n+}"}, {"sha": "1d6ad697443aa44c292bf2b6fbc27a8757f30267", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/48a48fd1b85ce50a890303b7238550ccf0613433/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a48fd1b85ce50a890303b7238550ccf0613433/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=48a48fd1b85ce50a890303b7238550ccf0613433", "patch": "@@ -1,5 +1,5 @@\n use rustc_infer::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelatingDelegate};\n-use rustc_infer::infer::{InferOk, NllRegionVariableOrigin};\n+use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::relate::TypeRelation;\n@@ -9,7 +9,7 @@ use rustc_trait_selection::traits::query::Fallible;\n \n use crate::constraints::OutlivesConstraint;\n use crate::diagnostics::UniverseInfo;\n-use crate::type_check::{CustomTypeOp, Locations, TypeChecker};\n+use crate::type_check::{InstantiateOpaqueType, Locations, TypeChecker};\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     /// Adds sufficient constraints to ensure that `a R b` where `R` depends on `v`:\n@@ -146,21 +146,18 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n             .fully_perform_op(\n                 self.locations,\n                 self.category,\n-                CustomTypeOp::new(\n-                    |infcx| {\n-                        Ok(InferOk {\n-                            value: (),\n-                            obligations: vec![infcx.opaque_ty_obligation(\n-                                a,\n-                                b,\n-                                a_is_expected,\n-                                param_env,\n-                                cause,\n-                            )],\n-                        })\n-                    },\n-                    || \"register_opaque_type\".to_string(),\n-                ),\n+                InstantiateOpaqueType {\n+                    obligation: self.type_checker.infcx.opaque_ty_obligation(\n+                        a,\n+                        b,\n+                        a_is_expected,\n+                        param_env,\n+                        cause,\n+                    ),\n+                    // These fields are filled in during exectuion of the operation\n+                    base_universe: None,\n+                    region_constraints: None,\n+                },\n             )\n             .unwrap();\n     }"}, {"sha": "f4df86e2ac7d35e72702ea3f191b8d8a7c6bf415", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48a48fd1b85ce50a890303b7238550ccf0613433/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a48fd1b85ce50a890303b7238550ccf0613433/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=48a48fd1b85ce50a890303b7238550ccf0613433", "patch": "@@ -22,6 +22,7 @@\n #![feature(control_flow_enum)]\n #![feature(min_specialization)]\n #![feature(label_break_value)]\n+#![feature(backtrace)]\n #![recursion_limit = \"512\"] // For rustdoc\n #![cfg_attr(not(bootstrap), allow(rustc::potential_query_instability))]\n "}, {"sha": "605c9ace5ed06644c22ea0d0e5774a9aa74f0e3c", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/custom.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/48a48fd1b85ce50a890303b7238550ccf0613433/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a48fd1b85ce50a890303b7238550ccf0613433/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=48a48fd1b85ce50a890303b7238550ccf0613433", "patch": "@@ -4,6 +4,7 @@ use crate::traits::engine::TraitEngineExt as _;\n use crate::traits::query::type_op::TypeOpOutput;\n use crate::traits::query::Fallible;\n use crate::traits::TraitEngine;\n+use rustc_infer::infer::region_constraints::RegionConstraintData;\n use rustc_infer::traits::TraitEngineExt as _;\n use rustc_span::source_map::DUMMY_SP;\n \n@@ -31,6 +32,9 @@ where\n     G: Fn() -> String,\n {\n     type Output = R;\n+    /// We can't do any custom error reporting for `CustomTypeOp`, so\n+    /// we can use `!` to enforce that the implementation never provides it.\n+    type ErrorInfo = !;\n \n     /// Processes the operation and all resulting obligations,\n     /// returning the final result along with any region constraints\n@@ -40,7 +44,7 @@ where\n             info!(\"fully_perform({:?})\", self);\n         }\n \n-        scrape_region_constraints(infcx, || (self.closure)(infcx))\n+        Ok(scrape_region_constraints(infcx, || (self.closure)(infcx))?.0)\n     }\n }\n \n@@ -55,10 +59,10 @@ where\n \n /// Executes `op` and then scrapes out all the \"old style\" region\n /// constraints that result, creating query-region-constraints.\n-fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n+pub fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n     infcx: &InferCtxt<'_, 'tcx>,\n     op: impl FnOnce() -> Fallible<InferOk<'tcx, R>>,\n-) -> Fallible<TypeOpOutput<'tcx, Op>> {\n+) -> Fallible<(TypeOpOutput<'tcx, Op>, RegionConstraintData<'tcx>)> {\n     let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n \n     // During NLL, we expect that nobody will register region\n@@ -97,12 +101,18 @@ fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n     );\n \n     if region_constraints.is_empty() {\n-        Ok(TypeOpOutput { output: value, constraints: None, canonicalized_query: None })\n+        Ok((\n+            TypeOpOutput { output: value, constraints: None, error_info: None },\n+            region_constraint_data,\n+        ))\n     } else {\n-        Ok(TypeOpOutput {\n-            output: value,\n-            constraints: Some(Rc::new(region_constraints)),\n-            canonicalized_query: None,\n-        })\n+        Ok((\n+            TypeOpOutput {\n+                output: value,\n+                constraints: Some(Rc::new(region_constraints)),\n+                error_info: None,\n+            },\n+            region_constraint_data,\n+        ))\n     }\n }"}, {"sha": "1e72dd693396a8cfcf5d11a864268bd25f510de2", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/48a48fd1b85ce50a890303b7238550ccf0613433/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a48fd1b85ce50a890303b7238550ccf0613433/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=48a48fd1b85ce50a890303b7238550ccf0613433", "patch": "@@ -28,6 +28,7 @@ pub use rustc_middle::traits::query::type_op::*;\n /// cannot be completed).\n pub trait TypeOp<'tcx>: Sized + fmt::Debug {\n     type Output;\n+    type ErrorInfo;\n \n     /// Processes the operation and all resulting obligations,\n     /// returning the final result along with any region constraints\n@@ -41,9 +42,8 @@ pub struct TypeOpOutput<'tcx, Op: TypeOp<'tcx>> {\n     pub output: Op::Output,\n     /// Any region constraints from performing the type op.\n     pub constraints: Option<Rc<QueryRegionConstraints<'tcx>>>,\n-    /// The canonicalized form of the query.\n-    /// This for error reporting to be able to rerun the query.\n-    pub canonicalized_query: Option<Canonical<'tcx, Op>>,\n+    /// Used for error reporting to be able to rerun the query\n+    pub error_info: Option<Op::ErrorInfo>,\n }\n \n /// \"Query type ops\" are type ops that are implemented using a\n@@ -119,10 +119,11 @@ where\n     Q: QueryTypeOp<'tcx>,\n {\n     type Output = Q::QueryResponse;\n+    type ErrorInfo = Canonical<'tcx, ParamEnvAnd<'tcx, Q>>;\n \n     fn fully_perform(self, infcx: &InferCtxt<'_, 'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>> {\n         let mut region_constraints = QueryRegionConstraints::default();\n-        let (output, canonicalized_query, mut obligations, _) =\n+        let (output, error_info, mut obligations, _) =\n             Q::fully_perform_into(self, infcx, &mut region_constraints)?;\n \n         // Typically, instantiating NLL query results does not\n@@ -160,6 +161,6 @@ where\n         let region_constraints =\n             if region_constraints.is_empty() { None } else { Some(Rc::new(region_constraints)) };\n \n-        Ok(TypeOpOutput { output, constraints: region_constraints, canonicalized_query })\n+        Ok(TypeOpOutput { output, constraints: region_constraints, error_info })\n     }\n }"}, {"sha": "9cf8ff76c87f8301f0f8f140b89276b6ad898d88", "filename": "src/test/ui/impl-trait/issues/issue-88236-2.nll.stderr", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/48a48fd1b85ce50a890303b7238550ccf0613433/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/48a48fd1b85ce50a890303b7238550ccf0613433/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-88236-2.nll.stderr?ref=48a48fd1b85ce50a890303b7238550ccf0613433", "patch": "@@ -1,14 +1,20 @@\n-error: higher-ranked subtype error\n+error: implementation of `Hrtb` is not general enough\n   --> $DIR/issue-88236-2.rs:17:5\n    |\n LL |     &()\n-   |     ^^^\n+   |     ^^^ implementation of `Hrtb` is not general enough\n+   |\n+   = note: `Hrtb<'0>` would have to be implemented for the type `&()`, for any lifetime `'0`...\n+   = note: ...but `Hrtb<'1>` is actually implemented for the type `&'1 ()`, for some specific lifetime `'1`\n \n-error: higher-ranked subtype error\n+error: implementation of `Hrtb` is not general enough\n   --> $DIR/issue-88236-2.rs:17:5\n    |\n LL |     &()\n-   |     ^^^\n+   |     ^^^ implementation of `Hrtb` is not general enough\n+   |\n+   = note: `Hrtb<'0>` would have to be implemented for the type `&()`, for any lifetime `'0`...\n+   = note: ...but `Hrtb<'1>` is actually implemented for the type `&'1 ()`, for some specific lifetime `'1`\n \n error: lifetime may not live long enough\n   --> $DIR/issue-88236-2.rs:20:5\n@@ -23,17 +29,23 @@ help: to allow this `impl Trait` to capture borrowed data with lifetime `'b`, ad\n LL | fn make_bad_impl<'b>(x: &'b ()) -> impl for<'a> Hrtb<'a, Assoc = impl Send + 'a> + 'b {\n    |                                                                                  ++++\n \n-error: higher-ranked subtype error\n+error: implementation of `Hrtb` is not general enough\n   --> $DIR/issue-88236-2.rs:20:5\n    |\n LL |     x\n-   |     ^\n+   |     ^ implementation of `Hrtb` is not general enough\n+   |\n+   = note: `Hrtb<'0>` would have to be implemented for the type `&()`, for any lifetime `'0`...\n+   = note: ...but `Hrtb<'1>` is actually implemented for the type `&'1 ()`, for some specific lifetime `'1`\n \n-error: higher-ranked subtype error\n+error: implementation of `Hrtb` is not general enough\n   --> $DIR/issue-88236-2.rs:20:5\n    |\n LL |     x\n-   |     ^\n+   |     ^ implementation of `Hrtb` is not general enough\n+   |\n+   = note: `Hrtb<'0>` would have to be implemented for the type `&()`, for any lifetime `'0`...\n+   = note: ...but `Hrtb<'1>` is actually implemented for the type `&'1 ()`, for some specific lifetime `'1`\n \n error: aborting due to 5 previous errors\n "}, {"sha": "0fbe6a63c0b685fbd51c369ed283f811ced84323", "filename": "src/test/ui/nll/relate_tys/opaque-hrtb.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/48a48fd1b85ce50a890303b7238550ccf0613433/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fopaque-hrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a48fd1b85ce50a890303b7238550ccf0613433/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fopaque-hrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fopaque-hrtb.rs?ref=48a48fd1b85ce50a890303b7238550ccf0613433", "patch": "@@ -0,0 +1,16 @@\n+#![feature(nll)]\n+\n+trait MyTrait<T> {}\n+\n+struct Foo;\n+impl<T> MyTrait<T> for Foo {}\n+\n+fn bar<Input>() -> impl MyTrait<Input> {\n+    Foo\n+}\n+\n+fn foo() -> impl for<'a> MyTrait<&'a str> {\n+    bar() //~ ERROR implementation of `MyTrait` is not general enough\n+}\n+\n+fn main() {}"}, {"sha": "4c8b66f21abe015e408c163e51e3c3aa07350143", "filename": "src/test/ui/nll/relate_tys/opaque-hrtb.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/48a48fd1b85ce50a890303b7238550ccf0613433/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fopaque-hrtb.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/48a48fd1b85ce50a890303b7238550ccf0613433/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fopaque-hrtb.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fopaque-hrtb.stderr?ref=48a48fd1b85ce50a890303b7238550ccf0613433", "patch": "@@ -0,0 +1,11 @@\n+error: implementation of `MyTrait` is not general enough\n+  --> $DIR/opaque-hrtb.rs:13:5\n+   |\n+LL |     bar()\n+   |     ^^^^^ implementation of `MyTrait` is not general enough\n+   |\n+   = note: `impl MyTrait<&'2 str>` must implement `MyTrait<&'1 str>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `MyTrait<&'2 str>`, for some specific lifetime `'2`\n+\n+error: aborting due to previous error\n+"}, {"sha": "91daa65d6563a33f2d8b89dfd08a262f39e7f647", "filename": "src/test/ui/type-alias-impl-trait/issue-57611-trait-alias.nll.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/48a48fd1b85ce50a890303b7238550ccf0613433/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/48a48fd1b85ce50a890303b7238550ccf0613433/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.nll.stderr?ref=48a48fd1b85ce50a890303b7238550ccf0613433", "patch": "@@ -1,14 +1,26 @@\n-error: higher-ranked subtype error\n+error[E0308]: mismatched types\n+  --> $DIR/issue-57611-trait-alias.rs:20:9\n+   |\n+LL |         |x| x\n+   |         ^^^^^ one type is more general than the other\n+   |\n+   = note: expected type `for<'r> Fn<(&'r X,)>`\n+              found type `Fn<(&X,)>`\n+note: this closure does not fulfill the lifetime requirements\n   --> $DIR/issue-57611-trait-alias.rs:20:9\n    |\n LL |         |x| x\n    |         ^^^^^\n \n-error: higher-ranked subtype error\n+error: implementation of `FnOnce` is not general enough\n   --> $DIR/issue-57611-trait-alias.rs:20:9\n    |\n LL |         |x| x\n-   |         ^^^^^\n+   |         ^^^^^ implementation of `FnOnce` is not general enough\n+   |\n+   = note: closure with signature `fn(&'2 X) -> &X` must implement `FnOnce<(&'1 X,)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&'2 X,)>`, for some specific lifetime `'2`\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0308`."}]}