{"sha": "ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhMGQxNTVmMmQwZmE4MzI4YzkzZWU3Y2E1MmY5NmNjZDc2NGNjZjA=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-10-11T22:09:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-11T22:09:42Z"}, "message": "Rollup merge of #64986 - skinny121:fn-ptr-const-generics, r=varkor\n\nFunction pointers as const generic arguments\n\nMakes function pointers as const generic arguments usable.\n\nFixes #62395\n\nr? @varkor", "tree": {"sha": "69408fb9053a57ce42a8e5babf752d448ed05143", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69408fb9053a57ce42a8e5babf752d448ed05143"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdoP2mCRBK7hj4Ov3rIwAAdHIIACl7Ai45oFdjghzogr+NrSys\nYxIHfcWlI9rVF9vNzlRjxX4UFMiGVybm65SVER1PAkpEiJ50hY+Ey46ub6M+GZFb\nEcDrrdOSC0jaZreDj2bHz+V13DpnkwxAEEettJKgvt43Mz2dIs44awtxs8Nr3o1/\nL0Czwva95lfyUAro38cQk0SJK9xvZV1q1d5UWD2k5usLgRbrravfmrAwclFxM7uS\n9iUDXkxJM88orNWx/4pZdfQVkQ6A5lfL8IAu5VltQstQi7HiL24x7PAqOhDGkq4o\n69lgRuNdtv2+62+uU2fiXcyDl/wyhB97Z0TfNwwHtmIaVLxiun/MtGlkBU0njfY=\n=LSza\n-----END PGP SIGNATURE-----\n", "payload": "tree 69408fb9053a57ce42a8e5babf752d448ed05143\nparent 215b09194f2ca1c19b1b5b4f5de4044671d6ad9a\nparent 8569dd1db985509cd235fafdd962aa52ced68e35\nauthor Tyler Mandry <tmandry@gmail.com> 1570831782 -0700\ncommitter GitHub <noreply@github.com> 1570831782 -0700\n\nRollup merge of #64986 - skinny121:fn-ptr-const-generics, r=varkor\n\nFunction pointers as const generic arguments\n\nMakes function pointers as const generic arguments usable.\n\nFixes #62395\n\nr? @varkor\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0", "html_url": "https://github.com/rust-lang/rust/commit/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "215b09194f2ca1c19b1b5b4f5de4044671d6ad9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/215b09194f2ca1c19b1b5b4f5de4044671d6ad9a", "html_url": "https://github.com/rust-lang/rust/commit/215b09194f2ca1c19b1b5b4f5de4044671d6ad9a"}, {"sha": "8569dd1db985509cd235fafdd962aa52ced68e35", "url": "https://api.github.com/repos/rust-lang/rust/commits/8569dd1db985509cd235fafdd962aa52ced68e35", "html_url": "https://github.com/rust-lang/rust/commit/8569dd1db985509cd235fafdd962aa52ced68e35"}], "stats": {"total": 541, "additions": 389, "deletions": 152}, "files": [{"sha": "6c31d54e081c42b9ee62c787ff815eb7e58f02c8", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0", "patch": "@@ -470,6 +470,14 @@ impl<'tcx> AllocMap<'tcx> {\n         }\n     }\n \n+    /// Panics if the `AllocId` does not refer to a function\n+    pub fn unwrap_fn(&self, id: AllocId) -> Instance<'tcx> {\n+        match self.get(id) {\n+            Some(GlobalAlloc::Function(instance)) => instance,\n+            _ => bug!(\"expected allocation ID {} to point to a function\", id),\n+        }\n+    }\n+\n     /// Freezes an `AllocId` created with `reserve` by pointing it at an `Allocation`. Trying to\n     /// call this function twice, even with the same `Allocation` will ICE the compiler.\n     pub fn set_alloc_id_memory(&mut self, id: AllocId, mem: &'tcx Allocation) {"}, {"sha": "9ac1465cb0ba9a0f58dd773a7cdfe0591e28b73e", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0", "patch": "@@ -2602,7 +2602,14 @@ impl<'tcx> Debug for Constant<'tcx> {\n impl<'tcx> Display for Constant<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         write!(fmt, \"const \")?;\n-        write!(fmt, \"{}\", self.literal)\n+        // FIXME make the default pretty printing of raw pointers more detailed. Here we output the\n+        // debug representation of raw pointers, so that the raw pointers in the mir dump output are\n+        // detailed and just not '{pointer}'.\n+        if let ty::RawPtr(_) = self.literal.ty.kind {\n+            write!(fmt, \"{:?} : {}\", self.literal.val, self.literal.ty)\n+        } else {\n+            write!(fmt, \"{}\", self.literal)\n+        }\n     }\n }\n "}, {"sha": "c4967f8d66da20a74a3bd3ed375b21b1df741226", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 107, "deletions": 111, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0", "patch": "@@ -863,125 +863,121 @@ pub trait PrettyPrinter<'tcx>:\n         }\n \n         let u8 = self.tcx().types.u8;\n-        if let ty::FnDef(did, substs) = ct.ty.kind {\n-            p!(print_value_path(did, substs));\n-            return Ok(self);\n-        }\n-        if let ConstValue::Unevaluated(did, substs) = ct.val {\n-            match self.tcx().def_kind(did) {\n-                | Some(DefKind::Static)\n-                | Some(DefKind::Const)\n-                | Some(DefKind::AssocConst) => p!(print_value_path(did, substs)),\n-                _ => if did.is_local() {\n-                    let span = self.tcx().def_span(did);\n-                    if let Ok(snip) = self.tcx().sess.source_map().span_to_snippet(span) {\n-                        p!(write(\"{}\", snip))\n+\n+        match (ct.val, &ct.ty.kind) {\n+            (_,  ty::FnDef(did, substs)) => p!(print_value_path(*did, substs)),\n+            (ConstValue::Unevaluated(did, substs), _) => {\n+                match self.tcx().def_kind(did) {\n+                    | Some(DefKind::Static)\n+                    | Some(DefKind::Const)\n+                    | Some(DefKind::AssocConst) => p!(print_value_path(did, substs)),\n+                    _ => if did.is_local() {\n+                        let span = self.tcx().def_span(did);\n+                        if let Ok(snip) = self.tcx().sess.source_map().span_to_snippet(span) {\n+                            p!(write(\"{}\", snip))\n+                        } else {\n+                            p!(write(\"_: \"), print(ct.ty))\n+                        }\n                     } else {\n                         p!(write(\"_: \"), print(ct.ty))\n-                    }\n+                    },\n+                }\n+            },\n+            (ConstValue::Infer(..), _) =>  p!(write(\"_: \"), print(ct.ty)),\n+            (ConstValue::Param(ParamConst { name, .. }), _) => p!(write(\"{}\", name)),\n+            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Bool) =>\n+                p!(write(\"{}\", if data == 0 { \"false\" } else { \"true\" })),\n+            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Float(ast::FloatTy::F32)) =>\n+                p!(write(\"{}f32\", Single::from_bits(data))),\n+            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Float(ast::FloatTy::F64)) =>\n+                p!(write(\"{}f64\", Double::from_bits(data))),\n+            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Uint(ui)) => {\n+                let bit_size = Integer::from_attr(&self.tcx(), UnsignedInt(*ui)).size();\n+                let max = truncate(u128::max_value(), bit_size);\n+\n+                if data == max {\n+                    p!(write(\"std::{}::MAX\", ui))\n                 } else {\n-                    p!(write(\"_: \"), print(ct.ty))\n-                },\n-            }\n-            return Ok(self);\n-        }\n-        if let ConstValue::Infer(..) = ct.val {\n-            p!(write(\"_: \"), print(ct.ty));\n-            return Ok(self);\n-        }\n-        if let ConstValue::Param(ParamConst { name, .. }) = ct.val {\n-            p!(write(\"{}\", name));\n-            return Ok(self);\n-        }\n-        if let ConstValue::Scalar(Scalar::Raw { data, .. }) = ct.val {\n-            match ct.ty.kind {\n-                ty::Bool => {\n-                    p!(write(\"{}\", if data == 0 { \"false\" } else { \"true\" }));\n-                    return Ok(self);\n-                },\n-                ty::Float(ast::FloatTy::F32) => {\n-                    p!(write(\"{}f32\", Single::from_bits(data)));\n-                    return Ok(self);\n-                },\n-                ty::Float(ast::FloatTy::F64) => {\n-                    p!(write(\"{}f64\", Double::from_bits(data)));\n-                    return Ok(self);\n-                },\n-                ty::Uint(ui) => {\n-                    let bit_size = Integer::from_attr(&self.tcx(), UnsignedInt(ui)).size();\n-                    let max = truncate(u128::max_value(), bit_size);\n+                    p!(write(\"{}{}\", data, ui))\n+                };\n+            },\n+            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Int(i)) => {\n+                let bit_size = Integer::from_attr(&self.tcx(), SignedInt(*i))\n+                    .size().bits() as u128;\n+                let min = 1u128 << (bit_size - 1);\n+                let max = min - 1;\n+\n+                let ty = self.tcx().lift(&ct.ty).unwrap();\n+                let size = self.tcx().layout_of(ty::ParamEnv::empty().and(ty))\n+                    .unwrap()\n+                    .size;\n+                match data {\n+                    d if d == min => p!(write(\"std::{}::MIN\", i)),\n+                    d if d == max => p!(write(\"std::{}::MAX\", i)),\n+                    _ => p!(write(\"{}{}\", sign_extend(data, size) as i128, i))\n+                }\n+            },\n+            (ConstValue::Scalar(Scalar::Raw { data, .. }), ty::Char) =>\n+                p!(write(\"{:?}\", ::std::char::from_u32(data as u32).unwrap())),\n+            (ConstValue::Scalar(_), ty::RawPtr(_)) => p!(write(\"{{pointer}}\")),\n+            (ConstValue::Scalar(Scalar::Ptr(ptr)), ty::FnPtr(_)) => {\n+                let instance = {\n+                    let alloc_map = self.tcx().alloc_map.lock();\n+                    alloc_map.unwrap_fn(ptr.alloc_id)\n+                };\n+                p!(print_value_path(instance.def_id(), instance.substs));\n+            },\n+            _ => {\n+                let printed = if let ty::Ref(_, ref_ty, _) = ct.ty.kind {\n+                    let byte_str = match (ct.val, &ref_ty.kind) {\n+                        (ConstValue::Scalar(Scalar::Ptr(ptr)), ty::Array(t, n)) if *t == u8 => {\n+                            let n = n.eval_usize(self.tcx(), ty::ParamEnv::empty());\n+                            Some(self.tcx()\n+                                .alloc_map.lock()\n+                                .unwrap_memory(ptr.alloc_id)\n+                                .get_bytes(&self.tcx(), ptr, Size::from_bytes(n)).unwrap())\n+                        },\n+                        (ConstValue::Slice { data, start, end }, ty::Slice(t)) if *t == u8 => {\n+                            // The `inspect` here is okay since we checked the bounds, and there are\n+                            // no relocations (we have an active slice reference here). We don't use\n+                            // this result to affect interpreter execution.\n+                            Some(data.inspect_with_undef_and_ptr_outside_interpreter(start..end))\n+                        },\n+                        _ => None,\n+                    };\n \n-                    if data == max {\n-                        p!(write(\"std::{}::MAX\", ui))\n+                    if let Some(byte_str) = byte_str {\n+                        p!(write(\"b\\\"\"));\n+                        for &c in byte_str {\n+                            for e in std::ascii::escape_default(c) {\n+                                self.write_char(e as char)?;\n+                            }\n+                        }\n+                        p!(write(\"\\\"\"));\n+                        true\n+                    } else if let (ConstValue::Slice { data, start, end }, ty::Str) =\n+                        (ct.val, &ref_ty.kind)\n+                    {\n+                        // The `inspect` here is okay since we checked the bounds, and there are no\n+                        // relocations (we have an active `str` reference here). We don't use this\n+                        // result to affect interpreter execution.\n+                        let slice = data.inspect_with_undef_and_ptr_outside_interpreter(start..end);\n+                        let s = ::std::str::from_utf8(slice)\n+                            .expect(\"non utf8 str from miri\");\n+                        p!(write(\"{:?}\", s));\n+                        true\n                     } else {\n-                        p!(write(\"{}{}\", data, ui))\n-                    };\n-                    return Ok(self);\n-                },\n-                ty::Int(i) =>{\n-                    let bit_size = Integer::from_attr(&self.tcx(), SignedInt(i))\n-                        .size().bits() as u128;\n-                    let min = 1u128 << (bit_size - 1);\n-                    let max = min - 1;\n-\n-                    let ty = self.tcx().lift(&ct.ty).unwrap();\n-                    let size = self.tcx().layout_of(ty::ParamEnv::empty().and(ty))\n-                        .unwrap()\n-                        .size;\n-                    match data {\n-                        d if d == min => p!(write(\"std::{}::MIN\", i)),\n-                        d if d == max => p!(write(\"std::{}::MAX\", i)),\n-                        _ => p!(write(\"{}{}\", sign_extend(data, size) as i128, i))\n-                    }\n-                    return Ok(self);\n-                },\n-                ty::Char => {\n-                    p!(write(\"{:?}\", ::std::char::from_u32(data as u32).unwrap()));\n-                    return Ok(self);\n-                }\n-                _ => {},\n-            }\n-        }\n-        if let ty::Ref(_, ref_ty, _) = ct.ty.kind {\n-            let byte_str = match (ct.val, &ref_ty.kind) {\n-                (ConstValue::Scalar(Scalar::Ptr(ptr)), ty::Array(t, n)) if *t == u8 => {\n-                    let n = n.eval_usize(self.tcx(), ty::ParamEnv::empty());\n-                    Some(self.tcx()\n-                        .alloc_map.lock()\n-                        .unwrap_memory(ptr.alloc_id)\n-                        .get_bytes(&self.tcx(), ptr, Size::from_bytes(n)).unwrap())\n-                },\n-                (ConstValue::Slice { data, start, end }, ty::Slice(t)) if *t == u8 => {\n-                    // The `inspect` here is okay since we checked the bounds, and there are no\n-                    // relocations (we have an active slice reference here). We don't use this\n-                    // result to affect interpreter execution.\n-                    Some(data.inspect_with_undef_and_ptr_outside_interpreter(start..end))\n-                },\n-                (ConstValue::Slice { data, start, end }, ty::Str) => {\n-                    // The `inspect` here is okay since we checked the bounds, and there are no\n-                    // relocations (we have an active `str` reference here). We don't use this\n-                    // result to affect interpreter execution.\n-                    let slice = data.inspect_with_undef_and_ptr_outside_interpreter(start..end);\n-                    let s = ::std::str::from_utf8(slice)\n-                        .expect(\"non utf8 str from miri\");\n-                    p!(write(\"{:?}\", s));\n-                    return Ok(self);\n-                },\n-                _ => None,\n-            };\n-            if let Some(byte_str) = byte_str {\n-                p!(write(\"b\\\"\"));\n-                for &c in byte_str {\n-                    for e in std::ascii::escape_default(c) {\n-                        self.write_char(e as char)?;\n+                        false\n                     }\n+                } else {\n+                    false\n+                };\n+                if !printed {\n+                    // fallback\n+                    p!(write(\"{:?} : \", ct.val), print(ct.ty))\n                 }\n-                p!(write(\"\\\"\"));\n-                return Ok(self);\n             }\n-        }\n-        p!(write(\"{:?} : \", ct.val), print(ct.ty));\n-\n+        };\n         Ok(self)\n     }\n }"}, {"sha": "41f34703622e7f9606828a90947243840a97429d", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0", "patch": "@@ -8,7 +8,7 @@ use crate::hir::def_id::DefId;\n use crate::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use crate::ty::error::{ExpectedFound, TypeError};\n-use crate::mir::interpret::{ConstValue, get_slice_bytes, Scalar};\n+use crate::mir::interpret::{ConstValue, get_slice_bytes};\n use std::rc::Rc;\n use std::iter;\n use rustc_target::spec::abi;\n@@ -561,37 +561,39 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n     // implement both `PartialEq` and `Eq`, corresponding to\n     // `structural_match` types.\n     // FIXME(const_generics): check for `structural_match` synthetic attribute.\n-    match (eagerly_eval(a), eagerly_eval(b)) {\n+    let new_const_val = match (eagerly_eval(a), eagerly_eval(b)) {\n         (ConstValue::Infer(_), _) | (_, ConstValue::Infer(_)) => {\n             // The caller should handle these cases!\n             bug!(\"var types encountered in super_relate_consts: {:?} {:?}\", a, b)\n         }\n         (ConstValue::Param(a_p), ConstValue::Param(b_p)) if a_p.index == b_p.index => {\n-            Ok(a)\n+            return Ok(a);\n         }\n         (ConstValue::Placeholder(p1), ConstValue::Placeholder(p2)) if p1 == p2 => {\n-            Ok(a)\n+            return Ok(a);\n         }\n-        (a_val @ ConstValue::Scalar(Scalar::Raw { .. }), b_val @ _)\n-            if a.ty == b.ty && a_val == b_val =>\n-        {\n-            Ok(tcx.mk_const(ty::Const {\n-                val: a_val,\n-                ty: a.ty,\n-            }))\n+        (ConstValue::Scalar(a_val), ConstValue::Scalar(b_val)) if a.ty == b.ty => {\n+            if a_val == b_val {\n+                Ok(ConstValue::Scalar(a_val))\n+            } else if let ty::FnPtr(_) = a.ty.kind {\n+                let alloc_map = tcx.alloc_map.lock();\n+                let a_instance = alloc_map.unwrap_fn(a_val.to_ptr().unwrap().alloc_id);\n+                let b_instance = alloc_map.unwrap_fn(b_val.to_ptr().unwrap().alloc_id);\n+                if a_instance == b_instance {\n+                    Ok(ConstValue::Scalar(a_val))\n+                } else {\n+                    Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n+                }\n+            } else {\n+                Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n+            }\n         }\n \n-        // FIXME(const_generics): we should either handle `Scalar::Ptr` or add a comment\n-        // saying that we're not handling it intentionally.\n-\n         (a_val @ ConstValue::Slice { .. }, b_val @ ConstValue::Slice { .. }) => {\n             let a_bytes = get_slice_bytes(&tcx, a_val);\n             let b_bytes = get_slice_bytes(&tcx, b_val);\n             if a_bytes == b_bytes {\n-                Ok(tcx.mk_const(ty::Const {\n-                    val: a_val,\n-                    ty: a.ty,\n-                }))\n+                Ok(a_val)\n             } else {\n                 Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n             }\n@@ -602,16 +604,16 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n         // FIXME(const_generics): this is wrong, as it is a projection\n         (ConstValue::Unevaluated(a_def_id, a_substs),\n             ConstValue::Unevaluated(b_def_id, b_substs)) if a_def_id == b_def_id => {\n-                let substs =\n-                    relation.relate_with_variance(ty::Variance::Invariant, &a_substs, &b_substs)?;\n-                Ok(tcx.mk_const(ty::Const {\n-                    val: ConstValue::Unevaluated(a_def_id, &substs),\n-                    ty: a.ty,\n-                }))\n-            }\n-\n-        _ => Err(TypeError::ConstMismatch(expected_found(relation, &a, &b))),\n-    }\n+            let substs =\n+                relation.relate_with_variance(ty::Variance::Invariant, &a_substs, &b_substs)?;\n+            Ok(ConstValue::Unevaluated(a_def_id, &substs))\n+        }\n+        _ =>  Err(TypeError::ConstMismatch(expected_found(relation, &a, &b))),\n+    };\n+    new_const_val.map(|val| tcx.mk_const(ty::Const {\n+        val,\n+        ty: a.ty,\n+    }))\n }\n \n impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {"}, {"sha": "8f8df395053681e481a8d04c316fcdb5f7c09340", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0", "patch": "@@ -1272,7 +1272,14 @@ fn collect_const<'tcx>(\n ) {\n     debug!(\"visiting const {:?}\", constant);\n \n-    match constant.val {\n+    let param_env = ty::ParamEnv::reveal_all();\n+    let substituted_constant = tcx.subst_and_normalize_erasing_regions(\n+        param_substs,\n+        param_env,\n+        &constant,\n+    );\n+\n+    match substituted_constant.val {\n         ConstValue::Scalar(Scalar::Ptr(ptr)) =>\n             collect_miri(tcx, ptr.alloc_id, output),\n         ConstValue::Slice { data: alloc, start: _, end: _ } |\n@@ -1282,12 +1289,6 @@ fn collect_const<'tcx>(\n             }\n         }\n         ConstValue::Unevaluated(def_id, substs) => {\n-            let param_env = ty::ParamEnv::reveal_all();\n-            let substs = tcx.subst_and_normalize_erasing_regions(\n-                param_substs,\n-                param_env,\n-                &substs,\n-            );\n             let instance = ty::Instance::resolve(tcx,\n                                                 param_env,\n                                                 def_id,\n@@ -1304,7 +1305,7 @@ fn collect_const<'tcx>(\n                     tcx.def_span(def_id), \"collection encountered polymorphic constant\",\n                 ),\n             }\n-        }\n+        },\n         _ => {},\n     }\n }"}, {"sha": "5b2081bef78dcf50602752237892af6bcbd9f6b6", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0", "patch": "@@ -1508,9 +1508,29 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n         }\n \n         Node::GenericParam(param) => match &param.kind {\n-            hir::GenericParamKind::Type { default: Some(ref ty), .. } |\n-            hir::GenericParamKind::Const { ref ty, .. } => {\n-                icx.to_ty(ty)\n+            hir::GenericParamKind::Type { default: Some(ref ty), .. } => icx.to_ty(ty),\n+            hir::GenericParamKind::Const { ty: ref hir_ty, .. } => {\n+                let ty = icx.to_ty(hir_ty);\n+                if !tcx.features().const_compare_raw_pointers {\n+                    let err = match ty.peel_refs().kind {\n+                        ty::FnPtr(_) => Some(\"function pointers\"),\n+                        ty::RawPtr(_) => Some(\"raw pointers\"),\n+                        _ => None,\n+                    };\n+                    if let Some(unsupported_type) = err {\n+                        feature_gate::emit_feature_err(\n+                            &tcx.sess.parse_sess,\n+                            sym::const_compare_raw_pointers,\n+                            hir_ty.span,\n+                            feature_gate::GateIssue::Language,\n+                            &format!(\n+                                \"using {} as const generic parameters is unstable\",\n+                                unsupported_type\n+                            ),\n+                        );\n+                    };\n+                }\n+                ty\n             }\n             x => {\n                 if !fail {"}, {"sha": "ad7f195676a68b194707837b52d1cef11c607725", "filename": "src/test/mir-opt/const_prop/reify_fn_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freify_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freify_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Freify_fn_ptr.rs?ref=ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0", "patch": "@@ -16,7 +16,7 @@ fn main() {\n // START rustc.main.ConstProp.after.mir\n //  bb0: {\n //      ...\n-//      _3 = const Scalar(AllocId(0).0x0) : fn();\n+//      _3 = const main;\n //      _2 = move _3 as usize (Misc);\n //      ...\n //      _1 = move _2 as *const fn() (Misc);"}, {"sha": "84615386d29959a07024cd5fd0e7610edeb9af17", "filename": "src/test/ui/const-generics/fn-const-param-call.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-call.rs?ref=ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0", "patch": "@@ -0,0 +1,20 @@\n+// run-pass\n+\n+#![feature(const_generics, const_compare_raw_pointers)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+fn function() -> u32 {\n+    17\n+}\n+\n+struct Wrapper<const F: fn() -> u32>;\n+\n+impl<const F: fn() -> u32> Wrapper<{F}> {\n+    fn call() -> u32 {\n+        F()\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(Wrapper::<{function}>::call(), 17);\n+}"}, {"sha": "c677d70374931774c8fb2a303966cc29b7a7abc2", "filename": "src/test/ui/const-generics/fn-const-param-call.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-call.stderr?ref=ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0", "patch": "@@ -0,0 +1,8 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/fn-const-param-call.rs:3:12\n+   |\n+LL | #![feature(const_generics, const_compare_raw_pointers)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+"}, {"sha": "78fb10e8cb9043296f86848767796cdf3261e227", "filename": "src/test/ui/const-generics/fn-const-param-infer.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.rs?ref=ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0", "patch": "@@ -0,0 +1,26 @@\n+#![feature(const_generics, const_compare_raw_pointers)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+struct Checked<const F: fn(usize) -> bool>;\n+\n+fn not_one(val: usize) -> bool { val != 1 }\n+fn not_two(val: usize) -> bool { val != 2 }\n+\n+fn generic_arg<T>(val: T) -> bool { true }\n+\n+fn generic<T>(val: usize) -> bool { val != 1 }\n+\n+fn main() {\n+    let _: Option<Checked<{not_one}>> = None;\n+    let _: Checked<{not_one}> = Checked::<{not_one}>;\n+    let _: Checked<{not_one}> = Checked::<{not_two}>; //~ mismatched types\n+\n+    let _ = Checked::<{generic_arg}>;\n+    let _ = Checked::<{generic_arg::<usize>}>;\n+    let _ = Checked::<{generic_arg::<u32>}>;  //~ mismatched types\n+\n+    let _ = Checked::<{generic}>; //~ type annotations needed\n+    let _ = Checked::<{generic::<u16>}>;\n+    let _: Checked<{generic::<u16>}> = Checked::<{generic::<u16>}>;\n+    let _: Checked<{generic::<u32>}> = Checked::<{generic::<u16>}>; //~ mismatched types\n+}"}, {"sha": "de0916b26bfef307d665e63b8480c6d7e109a7b3", "filename": "src/test/ui/const-generics/fn-const-param-infer.stderr", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.stderr?ref=ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0", "patch": "@@ -0,0 +1,45 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/fn-const-param-infer.rs:1:12\n+   |\n+LL | #![feature(const_generics, const_compare_raw_pointers)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0308]: mismatched types\n+  --> $DIR/fn-const-param-infer.rs:16:33\n+   |\n+LL |     let _: Checked<{not_one}> = Checked::<{not_two}>;\n+   |                                 ^^^^^^^^^^^^^^^^^^^^ expected `not_one`, found `not_two`\n+   |\n+   = note: expected type `Checked<not_one>`\n+              found type `Checked<not_two>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/fn-const-param-infer.rs:20:24\n+   |\n+LL |     let _ = Checked::<{generic_arg::<u32>}>;\n+   |                        ^^^^^^^^^^^^^^^^^^ expected usize, found u32\n+   |\n+   = note: expected type `fn(usize) -> bool`\n+              found type `fn(u32) -> bool {generic_arg::<u32>}`\n+\n+error[E0282]: type annotations needed\n+  --> $DIR/fn-const-param-infer.rs:22:24\n+   |\n+LL |     let _ = Checked::<{generic}>;\n+   |                        ^^^^^^^ cannot infer type for `T`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/fn-const-param-infer.rs:25:40\n+   |\n+LL |     let _: Checked<{generic::<u32>}> = Checked::<{generic::<u16>}>;\n+   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `generic::<u32>`, found `generic::<u16>`\n+   |\n+   = note: expected type `Checked<generic::<u32>>`\n+              found type `Checked<generic::<u16>>`\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors have detailed explanations: E0282, E0308.\n+For more information about an error, try `rustc --explain E0282`."}, {"sha": "d26ab8be4c3fe67ab26e50a080847b3072b1c0eb", "filename": "src/test/ui/const-generics/raw-ptr-const-param-deref.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param-deref.rs?ref=ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0", "patch": "@@ -0,0 +1,19 @@\n+// run-pass\n+#![feature(const_generics, const_compare_raw_pointers)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+const A: u32 = 3;\n+\n+struct Const<const P: *const u32>;\n+\n+impl<const P: *const u32> Const<{P}> {\n+    fn get() -> u32 {\n+        unsafe {\n+            *P\n+        }\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(Const::<{&A as *const _}>::get(), 3)\n+}"}, {"sha": "73221596c8e8797755a2669687e573ee321853d3", "filename": "src/test/ui/const-generics/raw-ptr-const-param-deref.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param-deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param-deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param-deref.stderr?ref=ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0", "patch": "@@ -0,0 +1,8 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/raw-ptr-const-param-deref.rs:2:12\n+   |\n+LL | #![feature(const_generics, const_compare_raw_pointers)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+"}, {"sha": "f69c37fbb8f3d0e7be0b40c5ea6cf25fcb79de70", "filename": "src/test/ui/const-generics/raw-ptr-const-param.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.rs?ref=ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0", "patch": "@@ -0,0 +1,9 @@\n+#![feature(const_generics, const_compare_raw_pointers)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+struct Const<const P: *const u32>;\n+\n+fn main() {\n+    let _: Const<{15 as *const _}> = Const::<{10 as *const _}>; //~ mismatched types\n+    let _: Const<{10 as *const _}> = Const::<{10 as *const _}>;\n+}"}, {"sha": "75b4c0a0a3de30623e7c1885692205cda9871075", "filename": "src/test/ui/const-generics/raw-ptr-const-param.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.stderr?ref=ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0", "patch": "@@ -0,0 +1,20 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/raw-ptr-const-param.rs:1:12\n+   |\n+LL | #![feature(const_generics, const_compare_raw_pointers)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0308]: mismatched types\n+  --> $DIR/raw-ptr-const-param.rs:7:38\n+   |\n+LL |     let _: Const<{15 as *const _}> = Const::<{10 as *const _}>;\n+   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `{pointer}`, found `{pointer}`\n+   |\n+   = note: expected type `Const<{pointer}>`\n+              found type `Const<{pointer}>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "1ab11ce3b4423458705cc5bcc69f5489ff0d13fb", "filename": "src/test/ui/feature-gates/feature-gate-const_generics-ptr.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics-ptr.rs?ref=ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0", "patch": "@@ -0,0 +1,9 @@\n+struct ConstFn<const F: fn()>;\n+//~^ ERROR const generics are unstable\n+//~^^ ERROR using function pointers as const generic parameters is unstable\n+\n+struct ConstPtr<const P: *const u32>;\n+//~^ ERROR const generics are unstable\n+//~^^ ERROR using raw pointers as const generic parameters is unstable\n+\n+fn main() {}"}, {"sha": "935f84b9163d38f9e599c96985fbefd4c87cbb34", "filename": "src/test/ui/feature-gates/feature-gate-const_generics-ptr.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics-ptr.stderr?ref=ea0d155f2d0fa8328c93ee7ca52f96ccd764ccf0", "patch": "@@ -0,0 +1,39 @@\n+error[E0658]: const generics are unstable\n+  --> $DIR/feature-gate-const_generics-ptr.rs:1:22\n+   |\n+LL | struct ConstFn<const F: fn()>;\n+   |                      ^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/44580\n+   = help: add `#![feature(const_generics)]` to the crate attributes to enable\n+\n+error[E0658]: const generics are unstable\n+  --> $DIR/feature-gate-const_generics-ptr.rs:5:23\n+   |\n+LL | struct ConstPtr<const P: *const u32>;\n+   |                       ^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/44580\n+   = help: add `#![feature(const_generics)]` to the crate attributes to enable\n+\n+error[E0658]: using function pointers as const generic parameters is unstable\n+  --> $DIR/feature-gate-const_generics-ptr.rs:1:25\n+   |\n+LL | struct ConstFn<const F: fn()>;\n+   |                         ^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53020\n+   = help: add `#![feature(const_compare_raw_pointers)]` to the crate attributes to enable\n+\n+error[E0658]: using raw pointers as const generic parameters is unstable\n+  --> $DIR/feature-gate-const_generics-ptr.rs:5:26\n+   |\n+LL | struct ConstPtr<const P: *const u32>;\n+   |                          ^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/53020\n+   = help: add `#![feature(const_compare_raw_pointers)]` to the crate attributes to enable\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}]}