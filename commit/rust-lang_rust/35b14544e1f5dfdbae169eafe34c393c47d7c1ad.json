{"sha": "35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1YjE0NTQ0ZTFmNWRmZGJhZTE2OWVhZmUzNGMzOTNjNDdkN2MxYWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-04T02:33:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-04T02:33:44Z"}, "message": "Auto merge of #28220 - steveklabnik:rollup, r=steveklabnik\n\n- Successful merges: #28167, #28202, #28203, #28204, #28205, #28207, #28208, #28209, #28210, #28212, #28213, #28214, #28215, #28216\n- Failed merges:", "tree": {"sha": "7a5be1c3e9f64eafe1f11341520b1c656a51dcbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a5be1c3e9f64eafe1f11341520b1c656a51dcbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "html_url": "https://github.com/rust-lang/rust/commit/35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2727a8e1c06f27169be6a414623880f118551dbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2727a8e1c06f27169be6a414623880f118551dbd", "html_url": "https://github.com/rust-lang/rust/commit/2727a8e1c06f27169be6a414623880f118551dbd"}, {"sha": "6c9549dd20511769c58e4a0fdd2ffb5c5de7a820", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c9549dd20511769c58e4a0fdd2ffb5c5de7a820", "html_url": "https://github.com/rust-lang/rust/commit/6c9549dd20511769c58e4a0fdd2ffb5c5de7a820"}], "stats": {"total": 207, "additions": 97, "deletions": 110}, "files": [{"sha": "3ae93b8f279dc6aa961e71affb60b1ce77747d72", "filename": "src/doc/grammar.md", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -281,7 +281,7 @@ type_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n ## Macros\n \n ```antlr\n-expr_macro_rules : \"macro_rules\" '!' ident '(' macro_rule * ')' ';' \n+expr_macro_rules : \"macro_rules\" '!' ident '(' macro_rule * ')' ';'\n                  | \"macro_rules\" '!' ident '{' macro_rule * '}' ;\n macro_rule : '(' matcher * ')' \"=>\" '(' transcriber * ')' ';' ;\n matcher : '(' matcher * ')' | '[' matcher * ']'\n@@ -306,7 +306,7 @@ transcriber : '(' transcriber * ')' | '[' transcriber * ']'\n \n ```antlr\n item : vis ? mod_item | fn_item | type_item | struct_item | enum_item\n-     | const_item | static_item | trait_item | impl_item | extern_block ;\n+     | const_item | static_item | trait_item | impl_item | extern_block_item ;\n ```\n \n ### Type Parameters\n@@ -636,31 +636,31 @@ lambda_expr : '|' ident_list '|' expr ;\n ### While loops\n \n ```antlr\n-while_expr : [ lifetime ':' ] \"while\" no_struct_literal_expr '{' block '}' ;\n+while_expr : [ lifetime ':' ] ? \"while\" no_struct_literal_expr '{' block '}' ;\n ```\n \n ### Infinite loops\n \n ```antlr\n-loop_expr : [ lifetime ':' ] \"loop\" '{' block '}';\n+loop_expr : [ lifetime ':' ] ? \"loop\" '{' block '}';\n ```\n \n ### Break expressions\n \n ```antlr\n-break_expr : \"break\" [ lifetime ];\n+break_expr : \"break\" [ lifetime ] ?;\n ```\n \n ### Continue expressions\n \n ```antlr\n-continue_expr : \"continue\" [ lifetime ];\n+continue_expr : \"continue\" [ lifetime ] ?;\n ```\n \n ### For expressions\n \n ```antlr\n-for_expr : [ lifetime ':' ] \"for\" pat \"in\" no_struct_literal_expr '{' block '}' ;\n+for_expr : [ lifetime ':' ] ? \"for\" pat \"in\" no_struct_literal_expr '{' block '}' ;\n ```\n \n ### If expressions\n@@ -688,13 +688,12 @@ match_pat : pat [ '|' pat ] * [ \"if\" expr ] ? ;\n ```antlr\n if_let_expr : \"if\" \"let\" pat '=' expr '{' block '}'\n                else_tail ? ;\n-else_tail : \"else\" [ if_expr | if_let_expr | '{' block '}' ] ;\n ```\n \n ### While let loops\n \n ```antlr\n-while_let_expr : \"while\" \"let\" pat '=' expr '{' block '}' ;\n+while_let_expr : [ lifetime ':' ] ? \"while\" \"let\" pat '=' expr '{' block '}' ;\n ```\n \n ### Return expressions\n@@ -754,8 +753,6 @@ return_expr : \"return\" expr ? ;\n ```antlr\n closure_type := [ 'unsafe' ] [ '<' lifetime-list '>' ] '|' arg-list '|'\n                 [ ':' bound-list ] [ '->' type ]\n-procedure_type := 'proc' [ '<' lifetime-list '>' ] '(' arg-list ')'\n-                  [ ':' bound-list ] [ '->' type ]\n lifetime-list := lifetime | lifetime ',' lifetime-list\n arg-list := ident ':' type | ident ':' type ',' arg-list\n bound-list := bound | bound '+' bound-list"}, {"sha": "900d1306e050c3802b8836aabbfc8d7d2783961c", "filename": "src/doc/reference.md", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -3200,16 +3200,6 @@ let z = match x { &0 => \"zero\", _ => \"some\" };\n assert_eq!(y, z);\n ```\n \n-A pattern that's just an identifier, like `Nil` in the previous example, could\n-either refer to an enum variant that's in scope, or bind a new variable. The\n-compiler resolves this ambiguity by forbidding variable bindings that occur in\n-`match` patterns from shadowing names of variants that are in scope. For\n-example, wherever `List` is in scope, a `match` pattern would not be able to\n-bind `Nil` as a new name. The compiler interprets a variable pattern `x` as a\n-binding _only_ if there is no variant named `x` in scope. A convention you can\n-use to avoid conflicts is simply to name variants with upper-case letters, and\n-local variables with lower-case letters.\n-\n Multiple match patterns may be joined with the `|` operator. A range of values\n may be specified with `...`. For example:\n "}, {"sha": "b86ad47feb2e95fa1c4594b5be69793642fb7835", "filename": "src/doc/trpl/choosing-your-guarantees.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Fdoc%2Ftrpl%2Fchoosing-your-guarantees.md", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Fdoc%2Ftrpl%2Fchoosing-your-guarantees.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fchoosing-your-guarantees.md?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -1,6 +1,6 @@\n % Choosing your Guarantees\n \n-One important feature of Rust as language is that it lets us control the costs and guarantees\n+One important feature of Rust is that it lets us control the costs and guarantees\n of a program.\n \n There are various &ldquo;wrapper type&rdquo; abstractions in the Rust standard library which embody\n@@ -18,9 +18,9 @@ Before proceeding, it is highly recommended that one reads about [ownership][own\n \n ## `Box<T>`\n \n-[`Box<T>`][box] is pointer which is &ldquo;owned&rdquo;, or a &ldquo;box&rdquo;. While it can hand\n-out references to the contained data, it is the only owner of the data. In particular, when\n-something like the following occurs:\n+[`Box<T>`][box] is an &ldquo;owned&rdquo; pointer, or a &ldquo;box&rdquo;. While it can hand\n+out references to the contained data, it is the only owner of the data. In particular, consider\n+the following:\n \n ```rust\n let x = Box::new(1);\n@@ -40,7 +40,7 @@ allowed to share references to this by the regular borrowing rules, checked at c\n \n [box]: ../std/boxed/struct.Box.html\n \n-## `&T` and `&mut T` \n+## `&T` and `&mut T`\n \n These are immutable and mutable references respectively. They follow the &ldquo;read-write lock&rdquo;\n pattern, such that one may either have only one mutable reference to some data, or any number of\n@@ -243,7 +243,7 @@ Many of the types above cannot be used in a threadsafe manner. Particularly, `Rc\n `RefCell<T>`, which both use non-atomic reference counts (_atomic_ reference counts are those which\n can be incremented from multiple threads without causing a data race), cannot be used this way. This\n makes them cheaper to use, but we need thread safe versions of these too. They exist, in the form of\n-`Arc<T>` and `Mutex<T>`/`RWLock<T>`\n+`Arc<T>` and `Mutex<T>`/`RwLock<T>`\n \n Note that the non-threadsafe types _cannot_ be sent between threads, and this is checked at compile\n time."}, {"sha": "beb65c4ce358af3641e08de4485d669fa6ab5055", "filename": "src/doc/trpl/deref-coercions.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Fdoc%2Ftrpl%2Fderef-coercions.md", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Fdoc%2Ftrpl%2Fderef-coercions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fderef-coercions.md?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -89,8 +89,8 @@ Vectors can `Deref` to a slice.\n \n ## Deref and method calls\n \n-`Deref` will also kick in when calling a method. In other words, these are\n-the same two things in Rust:\n+`Deref` will also kick in when calling a method. Consider the following\n+example.\n \n ```rust\n struct Foo;\n@@ -99,13 +99,13 @@ impl Foo {\n     fn foo(&self) { println!(\"Foo\"); }\n }\n \n-let f = Foo;\n+let f = &&Foo;\n \n f.foo();\n ```\n \n-Even though `f` isn\u2019t a reference, and `foo` takes `&self`, this works.\n-That\u2019s because these things are the same:\n+Even though `f` is a `&&Foo` and `foo` takes `&self`, this works. That\u2019s\n+because these things are the same:\n \n ```rust,ignore\n f.foo();"}, {"sha": "fb778b59a3d9385524b41df6c853cb802f182557", "filename": "src/doc/trpl/the-stack-and-the-heap.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -38,7 +38,7 @@ local variables and some other information. This is called a \u2018stack frame\u2019,\n for the purpose of this tutorial, we\u2019re going to ignore the extra information\n and just consider the local variables we\u2019re allocating. So in this case, when\n `main()` is run, we\u2019ll allocate a single 32-bit integer for our stack frame.\n-This is automatically handled for you, as you can see, we didn\u2019t have to write\n+This is automatically handled for you, as you can see; we didn\u2019t have to write\n any special Rust code or anything.\n \n When the function is over, its stack frame gets deallocated. This happens\n@@ -51,7 +51,7 @@ we\u2019ll throw them all away at the same time as well, we can get rid of it very\n fast too.\n \n The downside is that we can\u2019t keep values around if we need them for longer\n-than a single function. We also haven\u2019t talked about what that name, \u2018stack\u2019\n+than a single function. We also haven\u2019t talked about what the word, \u2018stack\u2019,\n means. To do that, we need a slightly more complicated example:\n \n ```rust"}, {"sha": "5c13295451c7a4d5e8972a81196439c5e29aa731", "filename": "src/grammar/RustLexer.g4", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Fgrammar%2FRustLexer.g4", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Fgrammar%2FRustLexer.g4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2FRustLexer.g4?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -13,8 +13,8 @@ tokens {\n     BINOPEQ, AT, DOT, DOTDOT, DOTDOTDOT, COMMA, SEMI, COLON,\n     MOD_SEP, RARROW, FAT_ARROW, LPAREN, RPAREN, LBRACKET, RBRACKET,\n     LBRACE, RBRACE, POUND, DOLLAR, UNDERSCORE, LIT_CHAR, LIT_BYTE,\n-    LIT_INTEGER, LIT_FLOAT, LIT_STR, LIT_STR_RAW, LIT_BINARY,\n-    LIT_BINARY_RAW, QUESTION, IDENT, LIFETIME, WHITESPACE, DOC_COMMENT,\n+    LIT_INTEGER, LIT_FLOAT, LIT_STR, LIT_STR_RAW, LIT_BYTE_STR,\n+    LIT_BYTE_STR_RAW, QUESTION, IDENT, LIFETIME, WHITESPACE, DOC_COMMENT,\n     COMMENT, SHEBANG, UTF8_BOM\n }\n \n@@ -148,8 +148,8 @@ LIT_STR\n   : '\"' ('\\\\\\n' | '\\\\\\r\\n' | '\\\\' CHAR_ESCAPE | .)*? '\"' SUFFIX?\n   ;\n \n-LIT_BINARY : 'b' LIT_STR ;\n-LIT_BINARY_RAW : 'b' LIT_STR_RAW ;\n+LIT_BYTE_STR : 'b' LIT_STR ;\n+LIT_BYTE_STR_RAW : 'b' LIT_STR_RAW ;\n \n /* this is a bit messy */\n "}, {"sha": "dd7b1c74de7497700bf75fab225bc9cb0c9439c5", "filename": "src/grammar/lexer.l", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Fgrammar%2Flexer.l", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Fgrammar%2Flexer.l", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Flexer.l?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -200,7 +200,7 @@ while    { return WHILE; }\n <ltorchar><<EOF>>                     { BEGIN(INITIAL); return -1; }\n \n b\\x22              { BEGIN(bytestr); yymore(); }\n-<bytestr>\\x22      { BEGIN(suffix); return LIT_BINARY; }\n+<bytestr>\\x22      { BEGIN(suffix); return LIT_BYTE_STR; }\n \n <bytestr><<EOF>>                { return -1; }\n <bytestr>\\\\[n\\nrt\\\\\\x27\\x220]   { yymore(); }\n@@ -210,7 +210,7 @@ b\\x22              { BEGIN(bytestr); yymore(); }\n <bytestr>(.|\\n)                 { yymore(); }\n \n br\\x22                      { BEGIN(rawbytestr_nohash); yymore(); }\n-<rawbytestr_nohash>\\x22     { BEGIN(suffix); return LIT_BINARY_RAW; }\n+<rawbytestr_nohash>\\x22     { BEGIN(suffix); return LIT_BYTE_STR_RAW; }\n <rawbytestr_nohash>(.|\\n)   { yymore(); }\n <rawbytestr_nohash><<EOF>>  { return -1; }\n \n@@ -228,7 +228,7 @@ br/# {\n         end_hashes++;\n         if (end_hashes == num_hashes) {\n             BEGIN(INITIAL);\n-            return LIT_BINARY_RAW;\n+            return LIT_BYTE_STR_RAW;\n         }\n     }\n     yymore();\n@@ -237,7 +237,7 @@ br/# {\n     end_hashes = 1;\n     if (end_hashes == num_hashes) {\n         BEGIN(INITIAL);\n-        return LIT_BINARY_RAW;\n+        return LIT_BYTE_STR_RAW;\n     }\n     yymore();\n }"}, {"sha": "75d9d28242f4e13183e3bf41e7017a96c845d4ef", "filename": "src/grammar/parser-lalr.y", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -52,8 +52,8 @@ extern char *yytext;\n %token LIT_FLOAT\n %token LIT_STR\n %token LIT_STR_RAW\n-%token LIT_BINARY\n-%token LIT_BINARY_RAW\n+%token LIT_BYTE_STR\n+%token LIT_BYTE_STR_RAW\n %token IDENT\n %token UNDERSCORE\n %token LIFETIME\n@@ -1772,8 +1772,8 @@ lit\n str\n : LIT_STR                    { $$ = mk_node(\"LitStr\", 1, mk_atom(yytext), mk_atom(\"CookedStr\")); }\n | LIT_STR_RAW                { $$ = mk_node(\"LitStr\", 1, mk_atom(yytext), mk_atom(\"RawStr\")); }\n-| LIT_BINARY                 { $$ = mk_node(\"LitBinary\", 1, mk_atom(yytext), mk_atom(\"BinaryStr\")); }\n-| LIT_BINARY_RAW             { $$ = mk_node(\"LitBinary\", 1, mk_atom(yytext), mk_atom(\"RawBinaryStr\")); }\n+| LIT_BYTE_STR                 { $$ = mk_node(\"LitByteStr\", 1, mk_atom(yytext), mk_atom(\"ByteStr\")); }\n+| LIT_BYTE_STR_RAW             { $$ = mk_node(\"LitByteStr\", 1, mk_atom(yytext), mk_atom(\"RawByteStr\")); }\n ;\n \n maybe_ident\n@@ -1815,8 +1815,8 @@ unpaired_token\n | LIT_FLOAT                  { $$ = mk_atom(yytext); }\n | LIT_STR                    { $$ = mk_atom(yytext); }\n | LIT_STR_RAW                { $$ = mk_atom(yytext); }\n-| LIT_BINARY                 { $$ = mk_atom(yytext); }\n-| LIT_BINARY_RAW             { $$ = mk_atom(yytext); }\n+| LIT_BYTE_STR                 { $$ = mk_atom(yytext); }\n+| LIT_BYTE_STR_RAW             { $$ = mk_atom(yytext); }\n | IDENT                      { $$ = mk_atom(yytext); }\n | UNDERSCORE                 { $$ = mk_atom(yytext); }\n | LIFETIME                   { $$ = mk_atom(yytext); }"}, {"sha": "081bd05025967e76940f075c1c490c6ccdf2bfa7", "filename": "src/grammar/tokens.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Fgrammar%2Ftokens.h", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Fgrammar%2Ftokens.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Ftokens.h?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -38,8 +38,8 @@ enum Token {\n   LIT_FLOAT,\n   LIT_STR,\n   LIT_STR_RAW,\n-  LIT_BINARY,\n-  LIT_BINARY_RAW,\n+  LIT_BYTE_STR,\n+  LIT_BYTE_STR_RAW,\n   IDENT,\n   UNDERSCORE,\n   LIFETIME,"}, {"sha": "6709479b2b5b2d2352a971c64d781182b7e2ec9f", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -107,8 +107,8 @@ fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n             \"OR\"                => token::BinOp(token::Or),\n             \"GT\"                => token::Gt,\n             \"LE\"                => token::Le,\n-            \"LIT_BINARY\"        => token::Literal(token::Binary(Name(0)), None),\n-            \"LIT_BINARY_RAW\"    => token::Literal(token::BinaryRaw(Name(0), 0), None),\n+            \"LIT_BYTE_STR\"      => token::Literal(token::ByteStr(Name(0)), None),\n+            \"LIT_BYTE_STR_RAW\"  => token::Literal(token::ByteStrRaw(Name(0), 0), None),\n             \"QUESTION\"          => token::Question,\n             \"SHEBANG\"           => token::Shebang(Name(0)),\n             _                   => continue,\n@@ -137,8 +137,8 @@ fn str_to_binop(s: &str) -> token::BinOpToken {\n     }\n }\n \n-/// Assuming a string/binary literal, strip out the leading/trailing\n-/// hashes and surrounding quotes/raw/binary prefix.\n+/// Assuming a string/byte string literal, strip out the leading/trailing\n+/// hashes and surrounding quotes/raw/byte prefix.\n fn fix(mut lit: &str) -> ast::Name {\n     if lit.char_at(0) == 'r' {\n         if lit.char_at(1) == 'b' {\n@@ -205,8 +205,8 @@ fn parse_antlr_token(s: &str, tokens: &HashMap<String, token::Token>, surrogate_\n         token::DocComment(..)      => token::DocComment(nm),\n         token::Literal(token::Integer(..), n)   => token::Literal(token::Integer(nm), n),\n         token::Literal(token::Float(..), n)     => token::Literal(token::Float(nm), n),\n-        token::Literal(token::Binary(..), n)    => token::Literal(token::Binary(nm), n),\n-        token::Literal(token::BinaryRaw(..), n) => token::Literal(token::BinaryRaw(fix(content),\n+        token::Literal(token::ByteStr(..), n)    => token::Literal(token::ByteStr(nm), n),\n+        token::Literal(token::ByteStrRaw(..), n) => token::Literal(token::ByteStrRaw(fix(content),\n                                                                                 count(content)), n),\n         token::Ident(..)           => token::Ident(ast::Ident { name: nm, ctxt: 0 },\n                                                    token::ModName),\n@@ -340,8 +340,8 @@ fn main() {\n             token::Literal(token::Float(..), _),\n             token::Literal(token::Str_(..), _),\n             token::Literal(token::StrRaw(..), _),\n-            token::Literal(token::Binary(..), _),\n-            token::Literal(token::BinaryRaw(..), _),\n+            token::Literal(token::ByteStr(..), _),\n+            token::Literal(token::ByteStrRaw(..), _),\n             token::Ident(..),\n             token::Lifetime(..),\n             token::Interpolated(..),"}, {"sha": "2f92fb7bac5fa681810f084414d51cd199060f88", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -51,7 +51,7 @@\n //! fn main() {\n //!     // Create a reference counted Owner.\n //!     let gadget_owner : Rc<Owner> = Rc::new(\n-//!             Owner { name: String::from(\"Gadget Man\") }\n+//!         Owner { name: String::from(\"Gadget Man\") }\n //!     );\n //!\n //!     // Create Gadgets belonging to gadget_owner. To increment the reference\n@@ -102,13 +102,13 @@\n //!\n //! struct Owner {\n //!     name: String,\n-//!     gadgets: RefCell<Vec<Weak<Gadget>>>\n+//!     gadgets: RefCell<Vec<Weak<Gadget>>>,\n //!     // ...other fields\n //! }\n //!\n //! struct Gadget {\n //!     id: i32,\n-//!     owner: Rc<Owner>\n+//!     owner: Rc<Owner>,\n //!     // ...other fields\n //! }\n //!\n@@ -117,10 +117,10 @@\n //!     // Owner's vector of Gadgets inside a RefCell so that we can mutate it\n //!     // through a shared reference.\n //!     let gadget_owner : Rc<Owner> = Rc::new(\n-//!             Owner {\n-//!                 name: \"Gadget Man\".to_string(),\n-//!                 gadgets: RefCell::new(Vec::new())\n-//!             }\n+//!         Owner {\n+//!             name: \"Gadget Man\".to_string(),\n+//!             gadgets: RefCell::new(Vec::new()),\n+//!         }\n //!     );\n //!\n //!     // Create Gadgets belonging to gadget_owner as before."}, {"sha": "e1cf6ace8432eaa2af09b87f7546806517a69a89", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -269,7 +269,7 @@ pub enum ConstVal {\n     Int(i64),\n     Uint(u64),\n     Str(InternedString),\n-    Binary(Rc<Vec<u8>>),\n+    ByteStr(Rc<Vec<u8>>),\n     Bool(bool),\n     Struct(ast::NodeId),\n     Tuple(ast::NodeId),\n@@ -283,7 +283,7 @@ impl ConstVal {\n             Int(_) => \"positive integer\",\n             Uint(_) => \"unsigned integer\",\n             Str(_) => \"string literal\",\n-            Binary(_) => \"binary array\",\n+            ByteStr(_) => \"byte string literal\",\n             Bool(_) => \"boolean\",\n             Struct(_) => \"struct\",\n             Tuple(_) => \"tuple\",\n@@ -1175,8 +1175,8 @@ fn cast_const<'tcx>(tcx: &ty::ctxt<'tcx>, val: ConstVal, ty: Ty) -> CastResult {\n fn lit_to_const(lit: &hir::Lit, ty_hint: Option<Ty>) -> ConstVal {\n     match lit.node {\n         hir::LitStr(ref s, _) => Str((*s).clone()),\n-        hir::LitBinary(ref data) => {\n-            Binary(data.clone())\n+        hir::LitByteStr(ref data) => {\n+            ByteStr(data.clone())\n         }\n         hir::LitByte(n) => Uint(n as u64),\n         hir::LitChar(n) => Uint(n as u64),\n@@ -1214,7 +1214,7 @@ pub fn compare_const_vals(a: &ConstVal, b: &ConstVal) -> Option<Ordering> {\n         }\n         (&Str(ref a), &Str(ref b)) => a.cmp(b),\n         (&Bool(a), &Bool(b)) => a.cmp(&b),\n-        (&Binary(ref a), &Binary(ref b)) => a.cmp(b),\n+        (&ByteStr(ref a), &ByteStr(ref b)) => a.cmp(b),\n         _ => return None\n     })\n }"}, {"sha": "6ea5fc2d6c87e26a48e9e9c457d3a75e9a5f7b2a", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -838,7 +838,7 @@ pub enum Lit_ {\n     /// A string literal (`\"foo\"`)\n     LitStr(InternedString, StrStyle),\n     /// A byte string (`b\"foo\"`)\n-    LitBinary(Rc<Vec<u8>>),\n+    LitByteStr(Rc<Vec<u8>>),\n     /// A byte char (`b'f'`)\n     LitByte(u8),\n     /// A character literal (`'a'`)"}, {"sha": "aa7545d52d11e1eb6805a14d397e87c239b1c1c9", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -664,7 +664,7 @@ pub fn lower_lit(l: &Lit) -> hir::Lit {\n     Spanned {\n         node: match l.node {\n             LitStr(ref i, s) => hir::LitStr(i.clone(), lower_string_style(s)),\n-            LitBinary(ref b) => hir::LitBinary(b.clone()),\n+            LitByteStr(ref b) => hir::LitByteStr(b.clone()),\n             LitByte(u) => hir::LitByte(u),\n             LitChar(c) => hir::LitChar(c),\n             LitInt(u, ref t) => hir::LitInt(u, lower_lit_int_type(t)),\n@@ -680,7 +680,7 @@ pub fn unlower_lit(l: &hir::Lit) -> Lit {\n     Spanned {\n         node: match l.node {\n             hir::LitStr(ref i, s) => LitStr(i.clone(), unlower_string_style(s)),\n-            hir::LitBinary(ref b) => LitBinary(b.clone()),\n+            hir::LitByteStr(ref b) => LitByteStr(b.clone()),\n             hir::LitByte(u) => LitByte(u),\n             hir::LitChar(c) => LitChar(c),\n             hir::LitInt(u, ref t) => LitInt(u, unlower_lit_int_type(t)),"}, {"sha": "38dded781e1e1394ba221b1315fce2b5ee01e86f", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -2549,7 +2549,7 @@ impl<'a> State<'a> {\n             hir::LitBool(val) => {\n                 if val { word(&mut self.s, \"true\") } else { word(&mut self.s, \"false\") }\n             }\n-            hir::LitBinary(ref v) => {\n+            hir::LitByteStr(ref v) => {\n                 let mut escaped: String = String::new();\n                 for &ch in v.iter() {\n                     escaped.extend(ascii::escape_default(ch)"}, {"sha": "d139819a79f9e73f4f4e166cff5278d19b320eb0", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -94,8 +94,8 @@ pub fn const_lit(cx: &CrateContext, e: &hir::Expr, lit: &hir::Lit)\n         }\n         hir::LitBool(b) => C_bool(cx, b),\n         hir::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n-        hir::LitBinary(ref data) => {\n-            addr_of(cx, C_bytes(cx, &data[..]), \"binary\")\n+        hir::LitByteStr(ref data) => {\n+            addr_of(cx, C_bytes(cx, &data[..]), \"byte_str\")\n         }\n     }\n }"}, {"sha": "f6f7586de5c515e38c1e5f7f5e8f9600adde8e05", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -56,7 +56,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             // They can denote both statically and dynamically sized byte arrays\n             let mut pat_ty = expr_ty;\n             if let hir::ExprLit(ref lt) = lt.node {\n-                if let hir::LitBinary(_) = lt.node {\n+                if let hir::LitByteStr(_) = lt.node {\n                     let expected_ty = structurally_resolved_type(fcx, pat.span, expected);\n                     if let ty::TyRef(_, mt) = expected_ty.sty {\n                         if let ty::TySlice(_) = mt.ty.sty {"}, {"sha": "a5fc9ce6a958a722b9c730c9669c9377bda39040", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -2633,7 +2633,7 @@ fn check_lit<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     match lit.node {\n         hir::LitStr(..) => tcx.mk_static_str(),\n-        hir::LitBinary(ref v) => {\n+        hir::LitByteStr(ref v) => {\n             tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic),\n                             tcx.mk_array(tcx.types.u8, v.len()))\n         }"}, {"sha": "7ef359787e87e1b6438e9737f85af75785e0d069", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -2518,7 +2518,7 @@ impl ToSource for syntax::codemap::Span {\n fn lit_to_string(lit: &hir::Lit) -> String {\n     match lit.node {\n         hir::LitStr(ref st, _) => st.to_string(),\n-        hir::LitBinary(ref data) => format!(\"{:?}\", data),\n+        hir::LitByteStr(ref data) => format!(\"{:?}\", data),\n         hir::LitByte(b) => {\n             let mut res = String::from(\"b'\");\n             for c in (b as char).escape_default() {"}, {"sha": "cca365d16c85c09a4f6acbe74f88e6f83fa1167a", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -131,7 +131,7 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n                 match lit {\n                     // text literals\n                     token::Byte(..) | token::Char(..) |\n-                        token::Binary(..) | token::BinaryRaw(..) |\n+                        token::ByteStr(..) | token::ByteStrRaw(..) |\n                         token::Str_(..) | token::StrRaw(..) => \"string\",\n \n                     // number literals"}, {"sha": "ce3989b5bba4414c6d2f31134b3c7d6d6bd3950b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -1190,7 +1190,7 @@ pub enum Lit_ {\n     /// A string literal (`\"foo\"`)\n     LitStr(InternedString, StrStyle),\n     /// A byte string (`b\"foo\"`)\n-    LitBinary(Rc<Vec<u8>>),\n+    LitByteStr(Rc<Vec<u8>>),\n     /// A byte char (`b'f'`)\n     LitByte(u8),\n     /// A character literal (`'a'`)"}, {"sha": "71430b7aad5964af5f44d560b143744a3705de13", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -50,8 +50,8 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                         accumulator.push_str(&format!(\"{}\", b));\n                     }\n                     ast::LitByte(..) |\n-                    ast::LitBinary(..) => {\n-                        cx.span_err(e.span, \"cannot concatenate a binary literal\");\n+                    ast::LitByteStr(..) => {\n+                        cx.span_err(e.span, \"cannot concatenate a byte string literal\");\n                     }\n                 }\n             }"}, {"sha": "25063e7b0d6f109d793fcbfaf3e4b5c3a265ce4e", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -189,7 +189,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             let filename = format!(\"{}\", file.display());\n             cx.codemap().new_filemap_and_lines(&filename, \"\");\n \n-            base::MacEager::expr(cx.expr_lit(sp, ast::LitBinary(Rc::new(bytes))))\n+            base::MacEager::expr(cx.expr_lit(sp, ast::LitByteStr(Rc::new(bytes))))\n         }\n     }\n }"}, {"sha": "a0e170b4ace466fa5a28e40ce3ce71a213e62139", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -1304,7 +1304,7 @@ impl<'a> StringReader<'a> {\n         }\n         let id = if valid { self.name_from(start) } else { token::intern(\"??\") };\n         self.bump();\n-        return token::Binary(id);\n+        return token::ByteStr(id);\n     }\n \n     fn scan_raw_byte_string(&mut self) -> token::Lit {\n@@ -1355,7 +1355,7 @@ impl<'a> StringReader<'a> {\n             self.bump();\n         }\n         self.bump();\n-        return token::BinaryRaw(self.name_from_to(content_start_bpos,\n+        return token::ByteStrRaw(self.name_from_to(content_start_bpos,\n                                                   content_end_bpos),\n                                 hash_count);\n     }\n@@ -1546,7 +1546,7 @@ mod tests {\n         test!(\"'a'\", Char, \"a\");\n         test!(\"b'a'\", Byte, \"a\");\n         test!(\"\\\"a\\\"\", Str_, \"a\");\n-        test!(\"b\\\"a\\\"\", Binary, \"a\");\n+        test!(\"b\\\"a\\\"\", ByteStr, \"a\");\n         test!(\"1234\", Integer, \"1234\");\n         test!(\"0b101\", Integer, \"0b101\");\n         test!(\"0xABC\", Integer, \"0xABC\");\n@@ -1560,7 +1560,7 @@ mod tests {\n                    token::Literal(token::StrRaw(token::intern(\"raw\"), 3),\n                                   Some(token::intern(\"suffix\"))));\n         assert_eq!(setup(&mk_sh(), \"br###\\\"raw\\\"###suffix\".to_string()).next_token().tok,\n-                   token::Literal(token::BinaryRaw(token::intern(\"raw\"), 3),\n+                   token::Literal(token::ByteStrRaw(token::intern(\"raw\"), 3),\n                                   Some(token::intern(\"suffix\"))));\n     }\n "}, {"sha": "269f8bdd98acc45b4f1ef6dc294a6353223b0a2c", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -499,7 +499,7 @@ pub fn byte_lit(lit: &str) -> (u8, usize) {\n     }\n }\n \n-pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n+pub fn byte_str_lit(lit: &str) -> Rc<Vec<u8>> {\n     let mut res = Vec::with_capacity(lit.len());\n \n     // FIXME #8372: This could be a for-loop if it didn't borrow the iterator\n@@ -517,7 +517,7 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n         }\n     }\n \n-    // binary literals *must* be ASCII, but the escapes don't have to be\n+    // byte string literals *must* be ASCII, but the escapes don't have to be\n     let mut chars = lit.bytes().enumerate().peekable();\n     loop {\n         match chars.next() {"}, {"sha": "337e855f9009462e37dc8aeff9845db5a4770d6c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -34,7 +34,7 @@ use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl, ItemConst};\n use ast::{ItemMac, ItemMod, ItemStruct, ItemTrait, ItemTy, ItemDefaultImpl};\n use ast::{ItemExternCrate, ItemUse};\n use ast::{LifetimeDef, Lit, Lit_};\n-use ast::{LitBool, LitChar, LitByte, LitBinary};\n+use ast::{LitBool, LitChar, LitByte, LitByteStr};\n use ast::{LitStr, LitInt, Local};\n use ast::{MacStmtWithBraces, MacStmtWithSemicolon, MacStmtWithoutBraces};\n use ast::{MutImmutable, MutMutable, Mac_, MacInvocTT, MatchSource};\n@@ -1543,11 +1543,11 @@ impl<'a> Parser<'a> {\n                             token::intern_and_get_ident(&parse::raw_str_lit(&s.as_str())),\n                             ast::RawStr(n)))\n                     }\n-                    token::Binary(i) =>\n-                        (true, LitBinary(parse::binary_lit(&i.as_str()))),\n-                    token::BinaryRaw(i, _) =>\n+                    token::ByteStr(i) =>\n+                        (true, LitByteStr(parse::byte_str_lit(&i.as_str()))),\n+                    token::ByteStrRaw(i, _) =>\n                         (true,\n-                         LitBinary(Rc::new(i.to_string().into_bytes()))),\n+                         LitByteStr(Rc::new(i.to_string().into_bytes()))),\n                 };\n \n                 if suffix_illegal {\n@@ -5826,7 +5826,7 @@ impl<'a> Parser<'a> {\n         match try!(self.parse_optional_str()) {\n             Some((s, style, suf)) => {\n                 let sp = self.last_span;\n-                self.expect_no_suffix(sp, \"str literal\", suf);\n+                self.expect_no_suffix(sp, \"string literal\", suf);\n                 Ok((s, style))\n             }\n             _ =>  Err(self.fatal(\"expected string literal\"))"}, {"sha": "ca92a37d8c35a4076d551f16836b1a74f3822555", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -82,8 +82,8 @@ pub enum Lit {\n     Float(ast::Name),\n     Str_(ast::Name),\n     StrRaw(ast::Name, usize), /* raw str delimited by n hash symbols */\n-    Binary(ast::Name),\n-    BinaryRaw(ast::Name, usize), /* raw binary str delimited by n hash symbols */\n+    ByteStr(ast::Name),\n+    ByteStrRaw(ast::Name, usize), /* raw byte str delimited by n hash symbols */\n }\n \n impl Lit {\n@@ -93,8 +93,8 @@ impl Lit {\n             Char(_) => \"char\",\n             Integer(_) => \"integer\",\n             Float(_) => \"float\",\n-            Str_(_) | StrRaw(..) => \"str\",\n-            Binary(_) | BinaryRaw(..) => \"binary str\"\n+            Str_(_) | StrRaw(..) => \"string\",\n+            ByteStr(_) | ByteStrRaw(..) => \"byte string\"\n         }\n     }\n }"}, {"sha": "341b177923ce7fa74eb7c9862eb2f792536f1444", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -259,8 +259,8 @@ pub fn token_to_string(tok: &Token) -> String {\n                 token::StrRaw(s, n)      => format!(\"r{delim}\\\"{string}\\\"{delim}\",\n                                                     delim=repeat(\"#\", n),\n                                                     string=s),\n-                token::Binary(v)         => format!(\"b\\\"{}\\\"\", v),\n-                token::BinaryRaw(s, n)   => format!(\"br{delim}\\\"{string}\\\"{delim}\",\n+                token::ByteStr(v)         => format!(\"b\\\"{}\\\"\", v),\n+                token::ByteStrRaw(s, n)   => format!(\"br{delim}\\\"{string}\\\"{delim}\",\n                                                     delim=repeat(\"#\", n),\n                                                     string=s),\n             };\n@@ -2887,7 +2887,7 @@ impl<'a> State<'a> {\n             ast::LitBool(val) => {\n                 if val { word(&mut self.s, \"true\") } else { word(&mut self.s, \"false\") }\n             }\n-            ast::LitBinary(ref v) => {\n+            ast::LitByteStr(ref v) => {\n                 let mut escaped: String = String::new();\n                 for &ch in v.iter() {\n                     escaped.extend(ascii::escape_default(ch)"}, {"sha": "e29c6ac5d5e949a2d3c626fa574f76fdebe0ffcc", "filename": "src/test/compile-fail/concat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Ftest%2Fcompile-fail%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Ftest%2Fcompile-fail%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconcat.rs?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n fn main() {\n-    concat!(b'f');  //~ ERROR: cannot concatenate a binary literal\n-    concat!(b\"foo\");  //~ ERROR: cannot concatenate a binary literal\n+    concat!(b'f');  //~ ERROR: cannot concatenate a byte string literal\n+    concat!(b\"foo\");  //~ ERROR: cannot concatenate a byte string literal\n     concat!(foo);   //~ ERROR: expected a literal\n     concat!(foo()); //~ ERROR: expected a literal\n }"}, {"sha": "d5985fcebeb26acc422338c6fa395bd2d77a68c7", "filename": "src/test/parse-fail/bad-lit-suffixes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Ftest%2Fparse-fail%2Fbad-lit-suffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Ftest%2Fparse-fail%2Fbad-lit-suffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fbad-lit-suffixes.rs?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -20,10 +20,10 @@ extern\n {}\n \n fn main() {\n-    \"\"suffix; //~ ERROR str literal with a suffix is invalid\n-    b\"\"suffix; //~ ERROR binary str literal with a suffix is invalid\n-    r#\"\"#suffix; //~ ERROR str literal with a suffix is invalid\n-    br#\"\"#suffix; //~ ERROR binary str literal with a suffix is invalid\n+    \"\"suffix; //~ ERROR string literal with a suffix is invalid\n+    b\"\"suffix; //~ ERROR byte string literal with a suffix is invalid\n+    r#\"\"#suffix; //~ ERROR string literal with a suffix is invalid\n+    br#\"\"#suffix; //~ ERROR byte string literal with a suffix is invalid\n     'a'suffix; //~ ERROR char literal with a suffix is invalid\n     b'a'suffix; //~ ERROR byte literal with a suffix is invalid\n "}, {"sha": "c668ffc5832b6a6c71ede94310dfd91f3cfb521a", "filename": "src/test/run-make/symbols-are-reasonable/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Ftest%2Frun-make%2Fsymbols-are-reasonable%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/35b14544e1f5dfdbae169eafe34c393c47d7c1ad/src%2Ftest%2Frun-make%2Fsymbols-are-reasonable%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsymbols-are-reasonable%2FMakefile?ref=35b14544e1f5dfdbae169eafe34c393c47d7c1ad", "patch": "@@ -11,5 +11,5 @@ all:\n \t$(RUSTC) lib.rs --emit=asm --crate-type=staticlib\n \t# just check for symbol declarations with the names we're expecting.\n \tgrep 'str[0-9][0-9]*:' $(OUT)\n-\tgrep 'binary[0-9][0-9]*:' $(OUT)\n+\tgrep 'byte_str[0-9][0-9]*:' $(OUT)\n \tgrep 'vtable[0-9][0-9]*' $(OUT)"}]}