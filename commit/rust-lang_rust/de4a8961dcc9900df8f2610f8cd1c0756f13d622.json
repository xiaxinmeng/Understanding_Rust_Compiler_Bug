{"sha": "de4a8961dcc9900df8f2610f8cd1c0756f13d622", "node_id": "C_kwDOAAsO6NoAKGRlNGE4OTYxZGNjOTkwMGRmOGYyNjEwZjhjZDFjMDc1NmYxM2Q2MjI", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-03-01T09:43:50Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-03-01T10:06:05Z"}, "message": "Support removing nested `dbg!()`s in `remove_dbg`", "tree": {"sha": "7b24839115be3bd7f2b213b6af224b06b60c0b82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b24839115be3bd7f2b213b6af224b06b60c0b82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de4a8961dcc9900df8f2610f8cd1c0756f13d622", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmP/I6IACgkQ4laYqTBY\nYXEkWw/+MZwiUlIKzgi4deeEYX5Tfva2M3BDrKhQa24XLRBerKF/lG8SmsHEmm6K\nRd+UPLBcYj9FDy20hcpM9rxn7FUmuauWl72vlNCbzBc55cCKdKFRmNhlnZF+Uymj\nzpj8laLLBHO281LgkuuUDa2koASdj9c7IABQbevaLtKJk/QFKa4x4hqL+1XiiBc1\ngu6XN+/ZeUg+nTfQhxRRS7slYwQ6mgz5ZguijMBKaOTTfS5o6IX3gHQCBOT/Id1h\nh3RB2wVNdxLfkz1Jh2TvQxwkXP8qvdR2GEXjkt1bC87diCLeviZmsDnqC05iS1gb\nOhrx6M1vEJSNpDLuMLOritwtNseqOhZ2bSxoruS+c3Fd9yadvxt/8d2Pdfe3lEZQ\nqjvFGtTijdFU343CSYfcTCJLoyBlfi13et6SZGnpsxOoc7fMZB4FBQIGsAbCsOa5\nX3Jlo7xNHbAv87pgsLw+ILJoEnnDKx0Fs32cm6atZtAq5lijULCa+Fn8XtSuA1bl\ncpRqlCY9361YmxZJECYZO8OaQXYZGOGorc3kAProeLqu4UEIiT/IgB4sK/UfZo3z\nj4GRAYPhANSm7Zkcgy8/ZqeXjWcZypPrgXXvA7a7EW1BOMz6LhhYDofewKCjZS3j\naoRWw1CAaemY19+5K+URDxPEfSL4pKLSOJb3MyKuiMn3bkqCdjg=\n=8ztV\n-----END PGP SIGNATURE-----", "payload": "tree 7b24839115be3bd7f2b213b6af224b06b60c0b82\nparent 7f01ae877dfd26277a52630c9e40724db23ff8fc\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1677663830 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1677665165 +0900\n\nSupport removing nested `dbg!()`s in `remove_dbg`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de4a8961dcc9900df8f2610f8cd1c0756f13d622", "html_url": "https://github.com/rust-lang/rust/commit/de4a8961dcc9900df8f2610f8cd1c0756f13d622", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de4a8961dcc9900df8f2610f8cd1c0756f13d622/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f01ae877dfd26277a52630c9e40724db23ff8fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f01ae877dfd26277a52630c9e40724db23ff8fc", "html_url": "https://github.com/rust-lang/rust/commit/7f01ae877dfd26277a52630c9e40724db23ff8fc"}], "stats": {"total": 138, "additions": 116, "deletions": 22}, "files": [{"sha": "1361cdf00cc6d56234b7b33bbe7000ecb5cbebca", "filename": "crates/ide-assists/src/handlers/remove_dbg.rs", "status": "modified", "additions": 114, "deletions": 20, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/de4a8961dcc9900df8f2610f8cd1c0756f13d622/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de4a8961dcc9900df8f2610f8cd1c0756f13d622/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs?ref=de4a8961dcc9900df8f2610f8cd1c0756f13d622", "patch": "@@ -1,7 +1,7 @@\n use itertools::Itertools;\n use syntax::{\n-    ast::{self, AstNode, AstToken},\n-    match_ast, NodeOrToken, SyntaxElement, TextRange, TextSize, T,\n+    ast::{self, make, AstNode, AstToken},\n+    match_ast, ted, NodeOrToken, SyntaxElement, TextRange, TextSize, T,\n };\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n@@ -12,24 +12,28 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //\n // ```\n // fn main() {\n-//     $0dbg!(92);\n+//     let x = $0dbg!(42 * dbg!(4 + 2));$0\n // }\n // ```\n // ->\n // ```\n // fn main() {\n-//     92;\n+//     let x = 42 * (4 + 2);\n // }\n // ```\n pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let macro_calls = if ctx.has_empty_selection() {\n-        vec![ctx.find_node_at_offset::<ast::MacroCall>()?]\n+        vec![ctx.find_node_at_offset::<ast::MacroExpr>()?]\n     } else {\n         ctx.covering_element()\n             .as_node()?\n             .descendants()\n             .filter(|node| ctx.selection_trimmed().contains_range(node.text_range()))\n+            // When the selection exactly covers the macro call to be removed, `covering_element()`\n+            // returns `ast::MacroCall` instead of its parent `ast::MacroExpr` that we want. So\n+            // first try finding `ast::MacroCall`s and then retrieve their parent.\n             .filter_map(ast::MacroCall::cast)\n+            .filter_map(|it| it.syntax().parent().and_then(ast::MacroExpr::cast))\n             .collect()\n     };\n \n@@ -44,14 +48,25 @@ pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<(\n         \"Remove dbg!()\",\n         ctx.selection_trimmed(),\n         |builder| {\n-            for (range, text) in replacements {\n-                builder.replace(range, text);\n+            for (range, expr) in replacements {\n+                if let Some(expr) = expr {\n+                    builder.replace(range, expr.to_string());\n+                } else {\n+                    builder.delete(range);\n+                }\n             }\n         },\n     )\n }\n \n-fn compute_dbg_replacement(macro_call: ast::MacroCall) -> Option<(TextRange, String)> {\n+/// Returns `None` when either\n+/// - macro call is not `dbg!()`\n+/// - any node inside `dbg!()` could not be parsed as an expression\n+/// - (`macro_expr` has no parent - is that possible?)\n+///\n+/// Returns `Some(_, None)` when the macro call should just be removed.\n+fn compute_dbg_replacement(macro_expr: ast::MacroExpr) -> Option<(TextRange, Option<ast::Expr>)> {\n+    let macro_call = macro_expr.macro_call()?;\n     let tt = macro_call.token_tree()?;\n     let r_delim = NodeOrToken::Token(tt.right_delimiter_token()?);\n     if macro_call.path()?.segment()?.name_ref()?.text() != \"dbg\"\n@@ -68,40 +83,43 @@ fn compute_dbg_replacement(macro_call: ast::MacroCall) -> Option<(TextRange, Str\n         .map(|mut tokens| syntax::hacks::parse_expr_from_str(&tokens.join(\"\")))\n         .collect::<Option<Vec<ast::Expr>>>()?;\n \n-    let macro_expr = ast::MacroExpr::cast(macro_call.syntax().parent()?)?;\n     let parent = macro_expr.syntax().parent()?;\n     Some(match &*input_expressions {\n         // dbg!()\n         [] => {\n             match_ast! {\n                 match parent {\n-                    ast::StmtList(__) => {\n+                    ast::StmtList(_) => {\n                         let range = macro_expr.syntax().text_range();\n                         let range = match whitespace_start(macro_expr.syntax().prev_sibling_or_token()) {\n                             Some(start) => range.cover_offset(start),\n                             None => range,\n                         };\n-                        (range, String::new())\n+                        (range, None)\n                     },\n                     ast::ExprStmt(it) => {\n                         let range = it.syntax().text_range();\n                         let range = match whitespace_start(it.syntax().prev_sibling_or_token()) {\n                             Some(start) => range.cover_offset(start),\n                             None => range,\n                         };\n-                        (range, String::new())\n+                        (range, None)\n                     },\n-                    _ => (macro_call.syntax().text_range(), \"()\".to_owned())\n+                    _ => (macro_call.syntax().text_range(), Some(make::expr_unit())),\n                 }\n             }\n         }\n         // dbg!(expr0)\n         [expr] => {\n+            // dbg!(expr, &parent);\n             let wrap = match ast::Expr::cast(parent) {\n                 Some(parent) => match (expr, parent) {\n                     (ast::Expr::CastExpr(_), ast::Expr::CastExpr(_)) => false,\n                     (\n-                        ast::Expr::BoxExpr(_) | ast::Expr::PrefixExpr(_) | ast::Expr::RefExpr(_),\n+                        ast::Expr::BoxExpr(_)\n+                        | ast::Expr::PrefixExpr(_)\n+                        | ast::Expr::RefExpr(_)\n+                        | ast::Expr::MacroExpr(_),\n                         ast::Expr::AwaitExpr(_)\n                         | ast::Expr::CallExpr(_)\n                         | ast::Expr::CastExpr(_)\n@@ -112,7 +130,10 @@ fn compute_dbg_replacement(macro_call: ast::MacroCall) -> Option<(TextRange, Str\n                         | ast::Expr::TryExpr(_),\n                     ) => true,\n                     (\n-                        ast::Expr::BinExpr(_) | ast::Expr::CastExpr(_) | ast::Expr::RangeExpr(_),\n+                        ast::Expr::BinExpr(_)\n+                        | ast::Expr::CastExpr(_)\n+                        | ast::Expr::RangeExpr(_)\n+                        | ast::Expr::MacroExpr(_),\n                         ast::Expr::AwaitExpr(_)\n                         | ast::Expr::BinExpr(_)\n                         | ast::Expr::CallExpr(_)\n@@ -129,16 +150,61 @@ fn compute_dbg_replacement(macro_call: ast::MacroCall) -> Option<(TextRange, Str\n                 },\n                 None => false,\n             };\n-            (\n-                macro_call.syntax().text_range(),\n-                if wrap { format!(\"({expr})\") } else { expr.to_string() },\n-            )\n+            let expr = replace_nested_dbgs(expr.clone());\n+            let expr = if wrap { make::expr_paren(expr) } else { expr.clone_subtree() };\n+            (macro_call.syntax().text_range(), Some(expr))\n         }\n         // dbg!(expr0, expr1, ...)\n-        exprs => (macro_call.syntax().text_range(), format!(\"({})\", exprs.iter().format(\", \"))),\n+        exprs => {\n+            let exprs = exprs.iter().cloned().map(replace_nested_dbgs);\n+            let expr = make::expr_tuple(exprs);\n+            (macro_call.syntax().text_range(), Some(expr))\n+        }\n     })\n }\n \n+fn replace_nested_dbgs(expanded: ast::Expr) -> ast::Expr {\n+    if let ast::Expr::MacroExpr(mac) = &expanded {\n+        // Special-case when `expanded` itself is `dbg!()` since we cannot replace the whole tree\n+        // with `ted`. It should be fairly rare as it means the user wrote `dbg!(dbg!(..))` but you\n+        // never know how code ends up being!\n+        let replaced = if let Some((_, expr_opt)) = compute_dbg_replacement(mac.clone()) {\n+            match expr_opt {\n+                Some(expr) => expr,\n+                None => {\n+                    stdx::never!(\"dbg! inside dbg! should not be just removed\");\n+                    expanded\n+                }\n+            }\n+        } else {\n+            expanded\n+        };\n+\n+        return replaced;\n+    }\n+\n+    let expanded = expanded.clone_for_update();\n+\n+    // We need to collect to avoid mutation during traversal.\n+    let macro_exprs: Vec<_> =\n+        expanded.syntax().descendants().filter_map(ast::MacroExpr::cast).collect();\n+\n+    for mac in macro_exprs {\n+        let expr_opt = match compute_dbg_replacement(mac.clone()) {\n+            Some((_, expr)) => expr,\n+            None => continue,\n+        };\n+\n+        if let Some(expr) = expr_opt {\n+            ted::replace(mac.syntax(), expr.syntax().clone_for_update());\n+        } else {\n+            ted::remove(mac.syntax());\n+        }\n+    }\n+\n+    expanded\n+}\n+\n fn whitespace_start(it: Option<SyntaxElement>) -> Option<TextSize> {\n     Some(it?.into_token().and_then(ast::Whitespace::cast)?.syntax().text_range().start())\n }\n@@ -287,4 +353,32 @@ fn f() {\n         check_assist_not_applicable(remove_dbg, r#\"$0dbg$0!(0)\"#);\n         check_assist_not_applicable(remove_dbg, r#\"$0dbg!(0$0)\"#);\n     }\n+\n+    #[test]\n+    fn test_nested_dbg() {\n+        check(\n+            r#\"$0let x = dbg!(dbg!(dbg!(dbg!(0 + 1)) * 2) + dbg!(3));$0\"#,\n+            r#\"let x = ((0 + 1) * 2) + 3;\"#,\n+        );\n+        check(r#\"$0dbg!(10, dbg!(), dbg!(20, 30))$0\"#, r#\"(10, (), (20, 30))\"#);\n+    }\n+\n+    #[test]\n+    fn test_multiple_nested_dbg() {\n+        check(\n+            r#\"\n+fn f() {\n+    $0dbg!();\n+    let x = dbg!(dbg!(dbg!(0 + 1)) + 2) + dbg!(3);\n+    dbg!(10, dbg!(), dbg!(20, 30));$0\n+}\n+\"#,\n+            r#\"\n+fn f() {\n+    let x = ((0 + 1) + 2) + 3;\n+    (10, (), (20, 30));\n+}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "524af200130ce658ed1836f8ef3acee10c7e1f62", "filename": "crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de4a8961dcc9900df8f2610f8cd1c0756f13d622/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de4a8961dcc9900df8f2610f8cd1c0756f13d622/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=de4a8961dcc9900df8f2610f8cd1c0756f13d622", "patch": "@@ -2006,12 +2006,12 @@ fn doctest_remove_dbg() {\n         \"remove_dbg\",\n         r#####\"\n fn main() {\n-    $0dbg!(92);\n+    let x = $0dbg!(42 * dbg!(4 + 2));$0\n }\n \"#####,\n         r#####\"\n fn main() {\n-    92;\n+    let x = 42 * (4 + 2);\n }\n \"#####,\n     )"}]}