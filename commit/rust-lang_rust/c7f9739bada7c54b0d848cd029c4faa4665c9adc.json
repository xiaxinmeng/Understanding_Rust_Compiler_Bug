{"sha": "c7f9739bada7c54b0d848cd029c4faa4665c9adc", "node_id": "C_kwDOAAsO6NoAKGM3Zjk3MzliYWRhN2M1NGIwZDg0OGNkMDI5YzRmYWE0NjY1YzlhZGM", "commit": {"author": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2023-03-28T09:33:44Z"}, "committer": {"name": "joboet", "email": "jonasboettiger@icloud.com", "date": "2023-03-30T12:49:43Z"}, "message": "core: improve code documentation for `LazyCell`", "tree": {"sha": "cbdade20ae49e35380bfed83236b7c4119e49092", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbdade20ae49e35380bfed83236b7c4119e49092"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7f9739bada7c54b0d848cd029c4faa4665c9adc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEVuz3PwcqDyifNyYbcE4BSbAZSzwFAmQlhWcACgkQcE4BSbAZ\nSzzOWw/9FKXEba/ryhm0+wDKV1i/zGUj2SEGWROXr8KSkj5HW1s10W11xHOJPm2O\nKXfyhnjjxLmpXiSaexDyvHNECce1Mflazrob2cE0jPAkNpLCWeyaGtG5+krGeUP/\nbuZSksbb7S26AGDP6k+cU9CzR0P29iF77irFJ1EmIcI0hqLFfpaP2mVOzgSONp8m\nY7vW1voJcQ2R7wwsvzqQMWur+zwFm52ftfV2G/84CSgsoEjy0vGrBKLqEkP9kRPp\nnJkS3AMjpIj91tbpPldjyUUwKYM4iP9vZ6O5OWlNi/hO5qP0zk5IIL8a5meEDOZY\n4+8tV8NP5IYYJGdB8fJuWh5l3hS9UuIg29p6MlFvhX0dWSrFZD/IxhDKOepDz6KZ\nCw15612NGJmtiCfDU4mqxWA49RmHnp4VE0jUYTeCCbAnuXBtRhxUdY/gp+Cjk9qC\nJwV3F20JLsYFOjB1uMmNBNVEAihic3H1bCSI/oyAnk+LoTXOMu8XlGoFqvVLiFii\nzTrv59oKqZo3EdiDy1xWiajQvMinNJ8m2HIeOkAUaLC2aKu6kHuYyQUsUzQxpmWE\nq7LdRPSil/eFpFcoMPm7Er8KG+suzemNUnjLBm6WoOzwUW9BPPYbVLQECXOugbaP\nctzHMwkVTAM3AdRPiFDBq6Ki1MAjbQHJxYU+g21F5lsN10Rpn6Q=\n=iHyQ\n-----END PGP SIGNATURE-----", "payload": "tree cbdade20ae49e35380bfed83236b7c4119e49092\nparent f015e6fe499f0d6dc2c3ea7422ac8efd1ddb3920\nauthor joboet <jonasboettiger@icloud.com> 1679996024 +0200\ncommitter joboet <jonasboettiger@icloud.com> 1680180583 +0200\n\ncore: improve code documentation for `LazyCell`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7f9739bada7c54b0d848cd029c4faa4665c9adc", "html_url": "https://github.com/rust-lang/rust/commit/c7f9739bada7c54b0d848cd029c4faa4665c9adc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7f9739bada7c54b0d848cd029c4faa4665c9adc/comments", "author": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "joboet", "id": 25721079, "node_id": "MDQ6VXNlcjI1NzIxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/25721079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joboet", "html_url": "https://github.com/joboet", "followers_url": "https://api.github.com/users/joboet/followers", "following_url": "https://api.github.com/users/joboet/following{/other_user}", "gists_url": "https://api.github.com/users/joboet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joboet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joboet/subscriptions", "organizations_url": "https://api.github.com/users/joboet/orgs", "repos_url": "https://api.github.com/users/joboet/repos", "events_url": "https://api.github.com/users/joboet/events{/privacy}", "received_events_url": "https://api.github.com/users/joboet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f015e6fe499f0d6dc2c3ea7422ac8efd1ddb3920", "url": "https://api.github.com/repos/rust-lang/rust/commits/f015e6fe499f0d6dc2c3ea7422ac8efd1ddb3920", "html_url": "https://github.com/rust-lang/rust/commit/f015e6fe499f0d6dc2c3ea7422ac8efd1ddb3920"}], "stats": {"total": 29, "additions": 24, "deletions": 5}, "files": [{"sha": "4039cc268120f3f6a2cd6fb5575ff8669a630264", "filename": "library/core/src/cell/lazy.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c7f9739bada7c54b0d848cd029c4faa4665c9adc/library%2Fcore%2Fsrc%2Fcell%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7f9739bada7c54b0d848cd029c4faa4665c9adc/library%2Fcore%2Fsrc%2Fcell%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell%2Flazy.rs?ref=c7f9739bada7c54b0d848cd029c4faa4665c9adc", "patch": "@@ -83,9 +83,15 @@ impl<T, F: FnOnce() -> T> LazyCell<T, F> {\n     #[inline]\n     #[unstable(feature = \"lazy_cell\", issue = \"109736\")]\n     pub fn force(this: &LazyCell<T, F>) -> &T {\n+        // SAFETY:\n+        // This invalidates any mutable references to the data. The resulting\n+        // reference lives either until the end of the borrow of `this` (in the\n+        // initialized case) or is invalidates in `really_init` (in the\n+        // uninitialized case).\n         let state = unsafe { &*this.state.get() };\n         match state {\n             State::Init(data) => data,\n+            // SAFETY: The state is uninitialized.\n             State::Uninit(_) => unsafe { LazyCell::really_init(this) },\n             State::Poisoned => panic!(\"LazyCell has previously been poisoned\"),\n         }\n@@ -95,21 +101,30 @@ impl<T, F: FnOnce() -> T> LazyCell<T, F> {\n     /// May only be called when the state is `Uninit`.\n     #[cold]\n     unsafe fn really_init(this: &LazyCell<T, F>) -> &T {\n+        // SAFETY:\n+        // This function is only called when the state is uninitialized,\n+        // so no references to `state` can exist except for the reference\n+        // in `force`, which is invalidated here and not accessed again.\n         let state = unsafe { &mut *this.state.get() };\n         // Temporarily mark the state as poisoned. This prevents reentrant\n         // accesses and correctly poisons the cell if the closure panicked.\n         let State::Uninit(f) = mem::replace(state, State::Poisoned) else { unreachable!() };\n \n         let data = f();\n \n-        // If the closure accessed the cell, the mutable borrow will be\n-        // invalidated, so create a new one here.\n+        // SAFETY:\n+        // If the closure accessed the cell through something like a reentrant\n+        // mutex, but caught the panic resulting from the state being poisoned,\n+        // the mutable borrow for `state` will be invalidated, so create a new\n+        // one here.\n         let state = unsafe { &mut *this.state.get() };\n         *state = State::Init(data);\n \n-        // A reference obtained by downcasting from the mutable borrow\n-        // would become stale if other references are created in `force`.\n-        // Borrow the state directly instead.\n+        // SAFETY:\n+        // A reference obtained by downcasting from the mutable borrow would\n+        // become stale the next time `force` is called (since there is a conflict\n+        // between the mutable reference here and the shared reference there).\n+        // Do a new shared borrow of the state instead.\n         let state = unsafe { &*this.state.get() };\n         let State::Init(data) = state else { unreachable!() };\n         data\n@@ -119,6 +134,10 @@ impl<T, F: FnOnce() -> T> LazyCell<T, F> {\n impl<T, F> LazyCell<T, F> {\n     #[inline]\n     fn get(&self) -> Option<&T> {\n+        // SAFETY:\n+        // This is sound for the same reason as in `force`: once the state is\n+        // initialized, it will not be mutably accessed again, so this reference\n+        // will stay valid for the duration of the borrow to `self`.\n         let state = unsafe { &*self.state.get() };\n         match state {\n             State::Init(data) => Some(data),"}]}