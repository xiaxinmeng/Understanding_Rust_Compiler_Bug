{"sha": "d1462d8558cf4551608457f63d9b999185ebf3bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxNDYyZDg1NThjZjQ1NTE2MDg0NTdmNjNkOWI5OTkxODVlYmYzYmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-18T04:22:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-18T04:22:16Z"}, "message": "Auto merge of #81172 - SimonSapin:ptr-metadata, r=oli-obk\n\nImplement RFC 2580: Pointer metadata & VTable\n\nRFC: https://github.com/rust-lang/rfcs/pull/2580\n\n~~Before merging this PR:~~\n\n* [x] Wait for the end of the RFC\u2019s [FCP to merge](https://github.com/rust-lang/rfcs/pull/2580#issuecomment-759145278).\n* [x] Open a tracking issue: https://github.com/rust-lang/rust/issues/81513\n* [x] Update `#[unstable]` attributes in the PR with the tracking issue number\n\n----\n\nThis PR extends the language with a new lang item for the `Pointee` trait which is special-cased in trait resolution to implement it for all types. Even in generic contexts, parameters can be assumed to implement it without a corresponding bound.\n\nFor this I mostly imitated what the compiler was already doing for the `DiscriminantKind` trait. I\u2019m very unfamiliar with compiler internals, so careful review is appreciated.\n\nThis PR also extends the standard library with new unstable APIs in `core::ptr` and `std::ptr`:\n\n```rust\npub trait Pointee {\n    /// One of `()`, `usize`, or `DynMetadata<dyn SomeTrait>`\n    type Metadata: Copy + Send + Sync + Ord + Hash + Unpin;\n}\n\npub trait Thin = Pointee<Metadata = ()>;\n\npub const fn metadata<T: ?Sized>(ptr: *const T) -> <T as Pointee>::Metadata {}\n\npub const fn from_raw_parts<T: ?Sized>(*const (), <T as Pointee>::Metadata) -> *const T {}\npub const fn from_raw_parts_mut<T: ?Sized>(*mut (),<T as Pointee>::Metadata) -> *mut T {}\n\nimpl<T: ?Sized> NonNull<T> {\n    pub const fn from_raw_parts(NonNull<()>, <T as Pointee>::Metadata) -> NonNull<T> {}\n\n    /// Convenience for `(ptr.cast(), metadata(ptr))`\n    pub const fn to_raw_parts(self) -> (NonNull<()>, <T as Pointee>::Metadata) {}\n}\n\nimpl<T: ?Sized> *const T {\n    pub const fn to_raw_parts(self) -> (*const (), <T as Pointee>::Metadata) {}\n}\n\nimpl<T: ?Sized> *mut T {\n    pub const fn to_raw_parts(self) -> (*mut (), <T as Pointee>::Metadata) {}\n}\n\n/// `<dyn SomeTrait as Pointee>::Metadata == DynMetadata<dyn SomeTrait>`\npub struct DynMetadata<Dyn: ?Sized> {\n    // Private pointer to vtable\n}\n\nimpl<Dyn: ?Sized> DynMetadata<Dyn> {\n    pub fn size_of(self) -> usize {}\n    pub fn align_of(self) -> usize {}\n    pub fn layout(self) -> crate::alloc::Layout {}\n}\n\nunsafe impl<Dyn: ?Sized> Send for DynMetadata<Dyn> {}\nunsafe impl<Dyn: ?Sized> Sync for DynMetadata<Dyn> {}\nimpl<Dyn: ?Sized> Debug for DynMetadata<Dyn> {}\nimpl<Dyn: ?Sized> Unpin for DynMetadata<Dyn> {}\nimpl<Dyn: ?Sized> Copy for DynMetadata<Dyn> {}\nimpl<Dyn: ?Sized> Clone for DynMetadata<Dyn> {}\nimpl<Dyn: ?Sized> Eq for DynMetadata<Dyn> {}\nimpl<Dyn: ?Sized> PartialEq for DynMetadata<Dyn> {}\nimpl<Dyn: ?Sized> Ord for DynMetadata<Dyn> {}\nimpl<Dyn: ?Sized> PartialOrd for DynMetadata<Dyn> {}\nimpl<Dyn: ?Sized> Hash for DynMetadata<Dyn> {}\n```\n\nAPI differences from the RFC, in areas noted as unresolved questions in the RFC:\n\n* Module-level functions instead of associated `from_raw_parts` functions on `*const T` and `*mut T`, following the precedent of `null`, `slice_from_raw_parts`, etc.\n* Added `to_raw_parts`", "tree": {"sha": "4df48734d48f6afc8201397ace7fad3723b9c6ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4df48734d48f6afc8201397ace7fad3723b9c6ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1462d8558cf4551608457f63d9b999185ebf3bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1462d8558cf4551608457f63d9b999185ebf3bf", "html_url": "https://github.com/rust-lang/rust/commit/d1462d8558cf4551608457f63d9b999185ebf3bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1462d8558cf4551608457f63d9b999185ebf3bf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbf666dbc1409f1afbe866ba03755e44dbd1927c", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbf666dbc1409f1afbe866ba03755e44dbd1927c", "html_url": "https://github.com/rust-lang/rust/commit/cbf666dbc1409f1afbe866ba03755e44dbd1927c"}, {"sha": "cac71bf8098f41205567d0442f99ae972effbee1", "url": "https://api.github.com/repos/rust-lang/rust/commits/cac71bf8098f41205567d0442f99ae972effbee1", "html_url": "https://github.com/rust-lang/rust/commit/cac71bf8098f41205567d0442f99ae972effbee1"}], "stats": {"total": 917, "additions": 865, "deletions": 52}, "files": [{"sha": "27a3210c5ce9dd8b900b1f71ad944fa96ae59b71", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1462d8558cf4551608457f63d9b999185ebf3bf/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1462d8558cf4551608457f63d9b999185ebf3bf/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=d1462d8558cf4551608457f63d9b999185ebf3bf", "patch": "@@ -201,6 +201,10 @@ language_item_table! {\n     // The associated item of `trait DiscriminantKind`.\n     Discriminant,            sym::discriminant_type,   discriminant_type,          Target::AssocTy;\n \n+    PointeeTrait,            sym::pointee_trait,       pointee_trait,              Target::Trait;\n+    Metadata,                sym::metadata_type,       metadata_type,              Target::AssocTy;\n+    DynMetadata,             sym::dyn_metadata,        dyn_metadata,               Target::Struct;\n+\n     Freeze,                  sym::freeze,              freeze_trait,               Target::Trait;\n \n     Drop,                    sym::drop,                drop_trait,                 Target::Trait;"}, {"sha": "9deeaf462d65d41b451e0d27c3c4cf4068ac614c", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d1462d8558cf4551608457f63d9b999185ebf3bf/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1462d8558cf4551608457f63d9b999185ebf3bf/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=d1462d8558cf4551608457f63d9b999185ebf3bf", "patch": "@@ -479,6 +479,9 @@ pub enum ImplSource<'tcx, N> {\n     /// ImplSource for a builtin `DeterminantKind` trait implementation.\n     DiscriminantKind(ImplSourceDiscriminantKindData),\n \n+    /// ImplSource for a builtin `Pointee` trait implementation.\n+    Pointee(ImplSourcePointeeData),\n+\n     /// ImplSource automatically generated for a generator.\n     Generator(ImplSourceGeneratorData<'tcx, N>),\n \n@@ -497,7 +500,8 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n             ImplSource::Generator(c) => c.nested,\n             ImplSource::Object(d) => d.nested,\n             ImplSource::FnPointer(d) => d.nested,\n-            ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData) => Vec::new(),\n+            ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData)\n+            | ImplSource::Pointee(ImplSourcePointeeData) => Vec::new(),\n             ImplSource::TraitAlias(d) => d.nested,\n         }\n     }\n@@ -512,7 +516,8 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n             ImplSource::Generator(c) => &c.nested[..],\n             ImplSource::Object(d) => &d.nested[..],\n             ImplSource::FnPointer(d) => &d.nested[..],\n-            ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData) => &[],\n+            ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData)\n+            | ImplSource::Pointee(ImplSourcePointeeData) => &[],\n             ImplSource::TraitAlias(d) => &d.nested[..],\n         }\n     }\n@@ -557,6 +562,9 @@ impl<'tcx, N> ImplSource<'tcx, N> {\n             ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData) => {\n                 ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData)\n             }\n+            ImplSource::Pointee(ImplSourcePointeeData) => {\n+                ImplSource::Pointee(ImplSourcePointeeData)\n+            }\n             ImplSource::TraitAlias(d) => ImplSource::TraitAlias(ImplSourceTraitAliasData {\n                 alias_def_id: d.alias_def_id,\n                 substs: d.substs,\n@@ -635,6 +643,9 @@ pub struct ImplSourceFnPointerData<'tcx, N> {\n #[derive(Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n pub struct ImplSourceDiscriminantKindData;\n \n+#[derive(Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, HashStable)]\n+pub struct ImplSourcePointeeData;\n+\n #[derive(Clone, PartialEq, Eq, TyEncodable, TyDecodable, HashStable, TypeFoldable, Lift)]\n pub struct ImplSourceTraitAliasData<'tcx, N> {\n     pub alias_def_id: DefId,"}, {"sha": "ab085175762ab2409a2d4e05b630a5f2ea515ec7", "filename": "compiler/rustc_middle/src/traits/select.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1462d8558cf4551608457f63d9b999185ebf3bf/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1462d8558cf4551608457f63d9b999185ebf3bf/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs?ref=d1462d8558cf4551608457f63d9b999185ebf3bf", "patch": "@@ -125,6 +125,9 @@ pub enum SelectionCandidate<'tcx> {\n     /// Builtin implementation of `DiscriminantKind`.\n     DiscriminantKindCandidate,\n \n+    /// Builtin implementation of `Pointee`.\n+    PointeeCandidate,\n+\n     TraitAliasCandidate(DefId),\n \n     /// Matching `dyn Trait` with a supertrait of `Trait`. The index is the"}, {"sha": "4f978e63630440561e43fb5c0d4473f0c3d2a69a", "filename": "compiler/rustc_middle/src/traits/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1462d8558cf4551608457f63d9b999185ebf3bf/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1462d8558cf4551608457f63d9b999185ebf3bf/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=d1462d8558cf4551608457f63d9b999185ebf3bf", "patch": "@@ -19,6 +19,8 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSource<'tcx, N> {\n \n             super::ImplSource::DiscriminantKind(ref d) => write!(f, \"{:?}\", d),\n \n+            super::ImplSource::Pointee(ref d) => write!(f, \"{:?}\", d),\n+\n             super::ImplSource::Object(ref d) => write!(f, \"{:?}\", d),\n \n             super::ImplSource::Param(ref n, ct) => {\n@@ -110,4 +112,5 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::ImplSourceTraitAliasData<'tcx,\n TrivialTypeFoldableAndLiftImpls! {\n     super::IfExpressionCause,\n     super::ImplSourceDiscriminantKindData,\n+    super::ImplSourcePointeeData,\n }"}, {"sha": "b534b5ac4d47d6d7cb7fd0ac17f86f110fd5c165", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d1462d8558cf4551608457f63d9b999185ebf3bf/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1462d8558cf4551608457f63d9b999185ebf3bf/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=d1462d8558cf4551608457f63d9b999185ebf3bf", "patch": "@@ -2133,6 +2133,54 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n+    /// Returns the type of metadata for (potentially fat) pointers to this type.\n+    pub fn ptr_metadata_ty(&'tcx self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+        // FIXME:\u00a0should this normalize?\n+        let tail = tcx.struct_tail_without_normalization(self);\n+        match tail.kind() {\n+            // Sized types\n+            ty::Infer(ty::IntVar(_) | ty::FloatVar(_))\n+            | ty::Uint(_)\n+            | ty::Int(_)\n+            | ty::Bool\n+            | ty::Float(_)\n+            | ty::FnDef(..)\n+            | ty::FnPtr(_)\n+            | ty::RawPtr(..)\n+            | ty::Char\n+            | ty::Ref(..)\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(..)\n+            | ty::Array(..)\n+            | ty::Closure(..)\n+            | ty::Never\n+            | ty::Error(_)\n+            | ty::Foreign(..)\n+            // If returned by `struct_tail_without_normalization` this is a unit struct\n+            // without any fields, or not a struct, and therefore is Sized.\n+            | ty::Adt(..)\n+            // If returned by `struct_tail_without_normalization` this is the empty tuple,\n+            // a.k.a. unit type, which is Sized\n+            | ty::Tuple(..) => tcx.types.unit,\n+\n+            ty::Str | ty::Slice(_) => tcx.types.usize,\n+            ty::Dynamic(..) => {\n+                let dyn_metadata = tcx.lang_items().dyn_metadata().unwrap();\n+                tcx.type_of(dyn_metadata).subst(tcx, &[tail.into()])\n+            },\n+\n+            ty::Projection(_)\n+            | ty::Param(_)\n+            | ty::Opaque(..)\n+            | ty::Infer(ty::TyVar(_))\n+            | ty::Bound(..)\n+            | ty::Placeholder(..)\n+            | ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n+                bug!(\"`ptr_metadata_ty` applied to unexpected type: {:?}\", tail)\n+            }\n+        }\n+    }\n+\n     /// When we create a closure, we record its kind (i.e., what trait\n     /// it implements) into its `ClosureSubsts` using a type\n     /// parameter. This is kind of a phantom type, except that the"}, {"sha": "653d70b6cf24497ba88e61e2c4f21e238e52e08a", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1462d8558cf4551608457f63d9b999185ebf3bf/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1462d8558cf4551608457f63d9b999185ebf3bf/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=d1462d8558cf4551608457f63d9b999185ebf3bf", "patch": "@@ -475,6 +475,7 @@ symbols! {\n         dropck_eyepatch,\n         dropck_parametricity,\n         dylib,\n+        dyn_metadata,\n         dyn_trait,\n         edition_macro_pats,\n         eh_catch_typeinfo,\n@@ -709,6 +710,7 @@ symbols! {\n         memory,\n         message,\n         meta,\n+        metadata_type,\n         min_align_of,\n         min_align_of_val,\n         min_const_fn,\n@@ -831,6 +833,7 @@ symbols! {\n         plugin,\n         plugin_registrar,\n         plugins,\n+        pointee_trait,\n         pointer,\n         pointer_trait,\n         pointer_trait_fmt,"}, {"sha": "2819b60c144c6c152c3d843671d4361ba105a705", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 67, "deletions": 1, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d1462d8558cf4551608457f63d9b999185ebf3bf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1462d8558cf4551608457f63d9b999185ebf3bf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=d1462d8558cf4551608457f63d9b999185ebf3bf", "patch": "@@ -12,7 +12,7 @@ use super::SelectionContext;\n use super::SelectionError;\n use super::{\n     ImplSourceClosureData, ImplSourceDiscriminantKindData, ImplSourceFnPointerData,\n-    ImplSourceGeneratorData, ImplSourceUserDefinedData,\n+    ImplSourceGeneratorData, ImplSourcePointeeData, ImplSourceUserDefinedData,\n };\n use super::{Normalized, NormalizedTy, ProjectionCacheEntry, ProjectionCacheKey};\n \n@@ -1069,6 +1069,51 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                     | ty::Error(_) => false,\n                 }\n             }\n+            super::ImplSource::Pointee(..) => {\n+                // While `Pointee` is automatically implemented for every type,\n+                // the concrete metadata type may not be known yet.\n+                //\n+                // Any type with multiple potential metadata types is therefore not eligible.\n+                let self_ty = selcx.infcx().shallow_resolve(obligation.predicate.self_ty());\n+\n+                // FIXME:\u00a0should this normalize?\n+                let tail = selcx.tcx().struct_tail_without_normalization(self_ty);\n+                match tail.kind() {\n+                    ty::Bool\n+                    | ty::Char\n+                    | ty::Int(_)\n+                    | ty::Uint(_)\n+                    | ty::Float(_)\n+                    | ty::Foreign(_)\n+                    | ty::Str\n+                    | ty::Array(..)\n+                    | ty::Slice(_)\n+                    | ty::RawPtr(..)\n+                    | ty::Ref(..)\n+                    | ty::FnDef(..)\n+                    | ty::FnPtr(..)\n+                    | ty::Dynamic(..)\n+                    | ty::Closure(..)\n+                    | ty::Generator(..)\n+                    | ty::GeneratorWitness(..)\n+                    | ty::Never\n+                    // If returned by `struct_tail_without_normalization` this is a unit struct\n+                    // without any fields, or not a struct, and therefore is Sized.\n+                    | ty::Adt(..)\n+                    // If returned by `struct_tail_without_normalization` this is the empty tuple.\n+                    | ty::Tuple(..)\n+                    // Integers and floats are always Sized, and so have unit type metadata.\n+                    | ty::Infer(ty::InferTy::IntVar(_) | ty::InferTy::FloatVar(..)) => true,\n+\n+                    ty::Projection(..)\n+                    | ty::Opaque(..)\n+                    | ty::Param(..)\n+                    | ty::Bound(..)\n+                    | ty::Placeholder(..)\n+                    | ty::Infer(..)\n+                    | ty::Error(_) => false,\n+                }\n+            }\n             super::ImplSource::Param(..) => {\n                 // This case tell us nothing about the value of an\n                 // associated type. Consider:\n@@ -1169,6 +1214,7 @@ fn confirm_select_candidate<'cx, 'tcx>(\n         super::ImplSource::DiscriminantKind(data) => {\n             confirm_discriminant_kind_candidate(selcx, obligation, data)\n         }\n+        super::ImplSource::Pointee(data) => confirm_pointee_candidate(selcx, obligation, data),\n         super::ImplSource::Object(_)\n         | super::ImplSource::AutoImpl(..)\n         | super::ImplSource::Param(..)\n@@ -1256,6 +1302,26 @@ fn confirm_discriminant_kind_candidate<'cx, 'tcx>(\n     confirm_param_env_candidate(selcx, obligation, ty::Binder::dummy(predicate), false)\n }\n \n+fn confirm_pointee_candidate<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    _: ImplSourcePointeeData,\n+) -> Progress<'tcx> {\n+    let tcx = selcx.tcx();\n+\n+    let self_ty = selcx.infcx().shallow_resolve(obligation.predicate.self_ty());\n+    let substs = tcx.mk_substs([self_ty.into()].iter());\n+\n+    let metadata_def_id = tcx.require_lang_item(LangItem::Metadata, None);\n+\n+    let predicate = ty::ProjectionPredicate {\n+        projection_ty: ty::ProjectionTy { substs, item_def_id: metadata_def_id },\n+        ty: self_ty.ptr_metadata_ty(tcx),\n+    };\n+\n+    confirm_param_env_candidate(selcx, obligation, ty::Binder::bind(predicate), false)\n+}\n+\n fn confirm_fn_pointer_candidate<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,"}, {"sha": "752f6a8debc9ef5c064f0d937cfff2ecbf26811f", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1462d8558cf4551608457f63d9b999185ebf3bf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1462d8558cf4551608457f63d9b999185ebf3bf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=d1462d8558cf4551608457f63d9b999185ebf3bf", "patch": "@@ -267,6 +267,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         } else if lang_items.discriminant_kind_trait() == Some(def_id) {\n             // `DiscriminantKind` is automatically implemented for every type.\n             candidates.vec.push(DiscriminantKindCandidate);\n+        } else if lang_items.pointee_trait() == Some(def_id) {\n+            // `Pointee` is automatically implemented for every type.\n+            candidates.vec.push(PointeeCandidate);\n         } else if lang_items.sized_trait() == Some(def_id) {\n             // Sized is never implementable by end-users, it is\n             // always automatically computed."}, {"sha": "272930f6bb9cabfddca72019b2da224ee2f44222", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d1462d8558cf4551608457f63d9b999185ebf3bf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1462d8558cf4551608457f63d9b999185ebf3bf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=d1462d8558cf4551608457f63d9b999185ebf3bf", "patch": "@@ -30,7 +30,8 @@ use crate::traits::{BuiltinDerivedObligation, ImplDerivedObligation};\n use crate::traits::{\n     ImplSourceAutoImplData, ImplSourceBuiltinData, ImplSourceClosureData,\n     ImplSourceDiscriminantKindData, ImplSourceFnPointerData, ImplSourceGeneratorData,\n-    ImplSourceObjectData, ImplSourceTraitAliasData, ImplSourceUserDefinedData,\n+    ImplSourceObjectData, ImplSourcePointeeData, ImplSourceTraitAliasData,\n+    ImplSourceUserDefinedData,\n };\n use crate::traits::{ObjectCastObligation, PredicateObligation, TraitObligation};\n use crate::traits::{Obligation, ObligationCause};\n@@ -99,6 +100,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(ImplSource::DiscriminantKind(ImplSourceDiscriminantKindData))\n             }\n \n+            PointeeCandidate => Ok(ImplSource::Pointee(ImplSourcePointeeData)),\n+\n             TraitAliasCandidate(alias_def_id) => {\n                 let data = self.confirm_trait_alias_candidate(obligation, alias_def_id);\n                 Ok(ImplSource::TraitAlias(data))"}, {"sha": "49591df97758e64256f0d2092ed1ddd2562c2fcc", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d1462d8558cf4551608457f63d9b999185ebf3bf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1462d8558cf4551608457f63d9b999185ebf3bf/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=d1462d8558cf4551608457f63d9b999185ebf3bf", "patch": "@@ -1318,8 +1318,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let is_global =\n             |cand: &ty::PolyTraitRef<'_>| cand.is_global() && !cand.has_late_bound_regions();\n \n-        // (*) Prefer `BuiltinCandidate { has_nested: false }` and `DiscriminantKindCandidate`\n-        // to anything else.\n+        // (*) Prefer `BuiltinCandidate { has_nested: false }`, `PointeeCandidate`,\n+        // and `DiscriminantKindCandidate` to anything else.\n         //\n         // This is a fix for #53123 and prevents winnowing from accidentally extending the\n         // lifetime of a variable.\n@@ -1332,8 +1332,18 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             // (*)\n-            (BuiltinCandidate { has_nested: false } | DiscriminantKindCandidate, _) => true,\n-            (_, BuiltinCandidate { has_nested: false } | DiscriminantKindCandidate) => false,\n+            (\n+                BuiltinCandidate { has_nested: false }\n+                | DiscriminantKindCandidate\n+                | PointeeCandidate,\n+                _,\n+            ) => true,\n+            (\n+                _,\n+                BuiltinCandidate { has_nested: false }\n+                | DiscriminantKindCandidate\n+                | PointeeCandidate,\n+            ) => false,\n \n             (ParamCandidate(other), ParamCandidate(victim)) => {\n                 if other.value == victim.value && victim.constness == Constness::NotConst {"}, {"sha": "6b9d46ee0af808af559581e58e761ae3a81118b2", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1462d8558cf4551608457f63d9b999185ebf3bf/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1462d8558cf4551608457f63d9b999185ebf3bf/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=d1462d8558cf4551608457f63d9b999185ebf3bf", "patch": "@@ -275,7 +275,8 @@ fn resolve_associated_item<'tcx>(\n         traits::ImplSource::AutoImpl(..)\n         | traits::ImplSource::Param(..)\n         | traits::ImplSource::TraitAlias(..)\n-        | traits::ImplSource::DiscriminantKind(..) => None,\n+        | traits::ImplSource::DiscriminantKind(..)\n+        | traits::ImplSource::Pointee(..) => None,\n     })\n }\n "}, {"sha": "f04782a1f442daa5fae94a903a57b473d37506da", "filename": "compiler/rustc_typeck/src/coherence/mod.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d1462d8558cf4551608457f63d9b999185ebf3bf/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1462d8558cf4551608457f63d9b999185ebf3bf/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs?ref=d1462d8558cf4551608457f63d9b999185ebf3bf", "patch": "@@ -48,7 +48,20 @@ fn enforce_trait_manually_implementable(\n     let did = Some(trait_def_id);\n     let li = tcx.lang_items();\n \n-    // Disallow *all* explicit impls of `DiscriminantKind`, `Sized` and `Unsize` for now.\n+    // Disallow *all* explicit impls of `Pointee`, `DiscriminantKind`, `Sized` and `Unsize` for now.\n+    if did == li.pointee_trait() {\n+        let span = impl_header_span(tcx, impl_def_id);\n+        struct_span_err!(\n+            tcx.sess,\n+            span,\n+            E0322,\n+            \"explicit impls for the `Pointee` trait are not permitted\"\n+        )\n+        .span_label(span, \"impl of 'Pointee' not allowed\")\n+        .emit();\n+        return;\n+    }\n+\n     if did == li.discriminant_kind_trait() {\n         let span = impl_header_span(tcx, impl_def_id);\n         struct_span_err!("}, {"sha": "cd47f97496a4a8735ac3db8cf00b0bafe3afdab9", "filename": "library/core/src/hash/mod.rs", "status": "modified", "additions": 44, "deletions": 26, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d1462d8558cf4551608457f63d9b999185ebf3bf/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1462d8558cf4551608457f63d9b999185ebf3bf/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs?ref=d1462d8558cf4551608457f63d9b999185ebf3bf", "patch": "@@ -673,39 +673,57 @@ mod impls {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<T: ?Sized> Hash for *const T {\n         fn hash<H: Hasher>(&self, state: &mut H) {\n-            if mem::size_of::<Self>() == mem::size_of::<usize>() {\n-                // Thin pointer\n-                state.write_usize(*self as *const () as usize);\n-            } else {\n-                // Fat pointer\n-                // SAFETY: we are accessing the memory occupied by `self`\n-                // which is guaranteed to be valid.\n-                // This assumes a fat pointer can be represented by a `(usize, usize)`,\n-                // which is safe to do in `std` because it is shipped and kept in sync\n-                // with the implementation of fat pointers in `rustc`.\n-                let (a, b) = unsafe { *(self as *const Self as *const (usize, usize)) };\n-                state.write_usize(a);\n-                state.write_usize(b);\n+            #[cfg(not(bootstrap))]\n+            {\n+                let (address, metadata) = self.to_raw_parts();\n+                state.write_usize(address as usize);\n+                metadata.hash(state);\n+            }\n+            #[cfg(bootstrap)]\n+            {\n+                if mem::size_of::<Self>() == mem::size_of::<usize>() {\n+                    // Thin pointer\n+                    state.write_usize(*self as *const () as usize);\n+                } else {\n+                    // Fat pointer\n+                    // SAFETY: we are accessing the memory occupied by `self`\n+                    // which is guaranteed to be valid.\n+                    // This assumes a fat pointer can be represented by a `(usize, usize)`,\n+                    // which is safe to do in `std` because it is shipped and kept in sync\n+                    // with the implementation of fat pointers in `rustc`.\n+                    let (a, b) = unsafe { *(self as *const Self as *const (usize, usize)) };\n+                    state.write_usize(a);\n+                    state.write_usize(b);\n+                }\n             }\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl<T: ?Sized> Hash for *mut T {\n         fn hash<H: Hasher>(&self, state: &mut H) {\n-            if mem::size_of::<Self>() == mem::size_of::<usize>() {\n-                // Thin pointer\n-                state.write_usize(*self as *const () as usize);\n-            } else {\n-                // Fat pointer\n-                // SAFETY: we are accessing the memory occupied by `self`\n-                // which is guaranteed to be valid.\n-                // This assumes a fat pointer can be represented by a `(usize, usize)`,\n-                // which is safe to do in `std` because it is shipped and kept in sync\n-                // with the implementation of fat pointers in `rustc`.\n-                let (a, b) = unsafe { *(self as *const Self as *const (usize, usize)) };\n-                state.write_usize(a);\n-                state.write_usize(b);\n+            #[cfg(not(bootstrap))]\n+            {\n+                let (address, metadata) = self.to_raw_parts();\n+                state.write_usize(address as usize);\n+                metadata.hash(state);\n+            }\n+            #[cfg(bootstrap)]\n+            {\n+                if mem::size_of::<Self>() == mem::size_of::<usize>() {\n+                    // Thin pointer\n+                    state.write_usize(*self as *const () as usize);\n+                } else {\n+                    // Fat pointer\n+                    // SAFETY: we are accessing the memory occupied by `self`\n+                    // which is guaranteed to be valid.\n+                    // This assumes a fat pointer can be represented by a `(usize, usize)`,\n+                    // which is safe to do in `std` because it is shipped and kept in sync\n+                    // with the implementation of fat pointers in `rustc`.\n+                    let (a, b) = unsafe { *(self as *const Self as *const (usize, usize)) };\n+                    state.write_usize(a);\n+                    state.write_usize(b);\n+                }\n             }\n         }\n     }"}, {"sha": "7c0e5ab8926ef731161d5cc5080d9d78ec11dd83", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1462d8558cf4551608457f63d9b999185ebf3bf/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1462d8558cf4551608457f63d9b999185ebf3bf/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=d1462d8558cf4551608457f63d9b999185ebf3bf", "patch": "@@ -111,6 +111,7 @@\n #![feature(extended_key_value_attributes)]\n #![feature(extern_types)]\n #![feature(fundamental)]\n+#![cfg_attr(not(bootstrap), feature(intra_doc_pointers))]\n #![feature(intrinsics)]\n #![feature(lang_items)]\n #![feature(link_llvm_intrinsics)]\n@@ -123,6 +124,7 @@\n #![feature(auto_traits)]\n #![feature(or_patterns)]\n #![feature(prelude_import)]\n+#![cfg_attr(not(bootstrap), feature(ptr_metadata))]\n #![feature(repr_simd, platform_intrinsics)]\n #![feature(rustc_attrs)]\n #![feature(simd_ffi)]\n@@ -133,6 +135,7 @@\n #![feature(stmt_expr_attributes)]\n #![feature(str_split_as_str)]\n #![feature(str_split_inclusive_as_str)]\n+#![feature(trait_alias)]\n #![feature(transparent_unions)]\n #![feature(try_blocks)]\n #![feature(unboxed_closures)]"}, {"sha": "ddff0ff67dea2e9aa57bfcda104bebcd70e647b9", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d1462d8558cf4551608457f63d9b999185ebf3bf/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1462d8558cf4551608457f63d9b999185ebf3bf/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=d1462d8558cf4551608457f63d9b999185ebf3bf", "patch": "@@ -48,6 +48,17 @@ impl<T: ?Sized> *const T {\n         self as _\n     }\n \n+    /// Decompose a (possibly wide) pointer into is address and metadata components.\n+    ///\n+    /// The pointer can be later reconstructed with [`from_raw_parts`].\n+    #[cfg(not(bootstrap))]\n+    #[unstable(feature = \"ptr_metadata\", issue = \"81513\")]\n+    #[rustc_const_unstable(feature = \"ptr_metadata\", issue = \"81513\")]\n+    #[inline]\n+    pub const fn to_raw_parts(self) -> (*const (), <T as super::Pointee>::Metadata) {\n+        (self.cast(), metadata(self))\n+    }\n+\n     /// Returns `None` if the pointer is null, or else returns a shared reference to\n     /// the value wrapped in `Some`. If the value may be uninitialized, [`as_uninit_ref`]\n     /// must be used instead.\n@@ -905,9 +916,14 @@ impl<T> *const [T] {\n     #[unstable(feature = \"slice_ptr_len\", issue = \"71146\")]\n     #[rustc_const_unstable(feature = \"const_slice_ptr_len\", issue = \"71146\")]\n     pub const fn len(self) -> usize {\n-        // SAFETY: this is safe because `*const [T]` and `FatPtr<T>` have the same layout.\n-        // Only `std` can make this guarantee.\n-        unsafe { Repr { rust: self }.raw }.len\n+        #[cfg(bootstrap)]\n+        {\n+            // SAFETY: this is safe because `*const [T]` and `FatPtr<T>` have the same layout.\n+            // Only `std` can make this guarantee.\n+            unsafe { Repr { rust: self }.raw }.len\n+        }\n+        #[cfg(not(bootstrap))]\n+        metadata(self)\n     }\n \n     /// Returns a raw pointer to the slice's buffer."}, {"sha": "7c7dce0ce74e2ba0f7ffb87017cdd1121f48c337", "filename": "library/core/src/ptr/metadata.rs", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/d1462d8558cf4551608457f63d9b999185ebf3bf/library%2Fcore%2Fsrc%2Fptr%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1462d8558cf4551608457f63d9b999185ebf3bf/library%2Fcore%2Fsrc%2Fptr%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmetadata.rs?ref=d1462d8558cf4551608457f63d9b999185ebf3bf", "patch": "@@ -0,0 +1,265 @@\n+#![unstable(feature = \"ptr_metadata\", issue = \"81513\")]\n+\n+use crate::fmt;\n+use crate::hash::{Hash, Hasher};\n+\n+/// Provides the pointer metadata type of any pointed-to type.\n+///\n+/// # Pointer metadata\n+///\n+/// Raw pointer types and reference types in Rust can be thought of as made of two parts:\n+/// a data pointer that contains the memory address of the value, and some metadata.\n+///\n+/// For statically-sized types (that implement the `Sized` traits)\n+/// as well as for `extern` types,\n+/// pointers are said to be \u201cthin\u201d: metadata is zero-sized and its type is `()`.\n+///\n+/// Pointers to [dynamically-sized types][dst] are said to be \u201cwide\u201d or \u201cfat\u201d,\n+/// they have non-zero-sized metadata:\n+///\n+/// * For structs whose last field is a DST, metadata is the metadata for the last field\n+/// * For the `str` type, metadata is the length in bytes as `usize`\n+/// * For slice types like `[T]`, metadata is the length in items as `usize`\n+/// * For trait objects like `dyn SomeTrait`, metadata is [`DynMetadata<Self>`][DynMetadata]\n+///   (e.g. `DynMetadata<dyn SomeTrait>`)\n+///\n+/// In the future, the Rust language may gain new kinds of types\n+/// that have different pointer metadata.\n+///\n+/// [dst]: https://doc.rust-lang.org/nomicon/exotic-sizes.html#dynamically-sized-types-dsts\n+///\n+///\n+/// # The `Pointee` trait\n+///\n+/// The point of this trait is its `Metadata` associated type,\n+/// which is `()` or `usize` or `DynMetadata<_>` as described above.\n+/// It is automatically implemented for every type.\n+/// It can be assumed to be implemented in a generic context, even without a corresponding bound.\n+///\n+///\n+/// # Usage\n+///\n+/// Raw pointers can be decomposed into the data address and metadata components\n+/// with their [`to_raw_parts`] method.\n+///\n+/// Alternatively, metadata alone can be extracted with the [`metadata`] function.\n+/// A reference can be passed to [`metadata`] and implicitly coerced.\n+///\n+/// A (possibly-wide) pointer can be put back together from its address and metadata\n+/// with [`from_raw_parts`] or [`from_raw_parts_mut`].\n+///\n+/// [`to_raw_parts`]: *const::to_raw_parts\n+#[lang = \"pointee_trait\"]\n+pub trait Pointee {\n+    /// The type for metadata in pointers and references to `Self`.\n+    #[lang = \"metadata_type\"]\n+    // NOTE: Keep trait bounds in `static_assert_expected_bounds_for_metadata`\n+    // in `library/core/src/ptr/metadata.rs`\n+    // in sync with those here:\n+    type Metadata: Copy + Send + Sync + Ord + Hash + Unpin;\n+}\n+\n+/// Pointers to types implementing this trait alias are \u201cthin\u201d.\n+///\n+/// This includes statically-`Sized` types and `extern` types.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// #![feature(ptr_metadata)]\n+///\n+/// fn this_never_panics<T: std::ptr::Thin>() {\n+///     assert_eq!(std::mem::size_of::<&T>(), std::mem::size_of::<usize>())\n+/// }\n+/// ```\n+#[unstable(feature = \"ptr_metadata\", issue = \"81513\")]\n+// NOTE: don\u2019t stabilize this before trait aliases are stable in the language?\n+pub trait Thin = Pointee<Metadata = ()>;\n+\n+/// Extract the metadata component of a pointer.\n+///\n+/// Values of type `*mut T`, `&T`, or `&mut T` can be passed directly to this function\n+/// as they implicitly coerce to `*const T`.\n+///\n+/// # Example\n+///\n+/// ```\n+/// #![feature(ptr_metadata)]\n+///\n+/// assert_eq!(std::ptr::metadata(\"foo\"), 3_usize);\n+/// ```\n+#[rustc_const_unstable(feature = \"ptr_metadata\", issue = \"81513\")]\n+#[inline]\n+pub const fn metadata<T: ?Sized>(ptr: *const T) -> <T as Pointee>::Metadata {\n+    // SAFETY: Accessing the value from the `PtrRepr` union is safe since *const T\n+    // and PtrComponents<T> have the same memory layouts. Only std can make this\n+    // guarantee.\n+    unsafe { PtrRepr { const_ptr: ptr }.components.metadata }\n+}\n+\n+/// Forms a (possibly-wide) raw pointer from a data address and metadata.\n+///\n+/// This function is safe but the returned pointer is not necessarily safe to dereference.\n+/// For slices, see the documentation of [`slice::from_raw_parts`] for safety requirements.\n+/// For trait objects, the metadata must come from a pointer to the same underlying ereased type.\n+///\n+/// [`slice::from_raw_parts`]: crate::slice::from_raw_parts\n+#[unstable(feature = \"ptr_metadata\", issue = \"81513\")]\n+#[rustc_const_unstable(feature = \"ptr_metadata\", issue = \"81513\")]\n+#[inline]\n+pub const fn from_raw_parts<T: ?Sized>(\n+    data_address: *const (),\n+    metadata: <T as Pointee>::Metadata,\n+) -> *const T {\n+    // SAFETY: Accessing the value from the `PtrRepr` union is safe since *const T\n+    // and PtrComponents<T> have the same memory layouts. Only std can make this\n+    // guarantee.\n+    unsafe { PtrRepr { components: PtrComponents { data_address, metadata } }.const_ptr }\n+}\n+\n+/// Performs the same functionality as [`from_raw_parts`], except that a\n+/// raw `*mut` pointer is returned, as opposed to a raw `*const` pointer.\n+///\n+/// See the documentation of [`from_raw_parts`] for more details.\n+#[unstable(feature = \"ptr_metadata\", issue = \"81513\")]\n+#[rustc_const_unstable(feature = \"ptr_metadata\", issue = \"81513\")]\n+#[inline]\n+pub const fn from_raw_parts_mut<T: ?Sized>(\n+    data_address: *mut (),\n+    metadata: <T as Pointee>::Metadata,\n+) -> *mut T {\n+    // SAFETY: Accessing the value from the `PtrRepr` union is safe since *const T\n+    // and PtrComponents<T> have the same memory layouts. Only std can make this\n+    // guarantee.\n+    unsafe { PtrRepr { components: PtrComponents { data_address, metadata } }.mut_ptr }\n+}\n+\n+#[repr(C)]\n+pub(crate) union PtrRepr<T: ?Sized> {\n+    pub(crate) const_ptr: *const T,\n+    pub(crate) mut_ptr: *mut T,\n+    pub(crate) components: PtrComponents<T>,\n+}\n+\n+#[repr(C)]\n+pub(crate) struct PtrComponents<T: ?Sized> {\n+    pub(crate) data_address: *const (),\n+    pub(crate) metadata: <T as Pointee>::Metadata,\n+}\n+\n+// Manual impl needed to avoid `T: Copy` bound.\n+impl<T: ?Sized> Copy for PtrComponents<T> {}\n+\n+// Manual impl needed to avoid `T: Clone` bound.\n+impl<T: ?Sized> Clone for PtrComponents<T> {\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+/// The metadata for a `Dyn = dyn SomeTrait` trait object type.\n+///\n+/// It is a pointer to a vtable (virtual call table)\n+/// that represents all the necessary information\n+/// to manipulate the concrete type stored inside a trait object.\n+/// The vtable notably it contains:\n+///\n+/// * type size\n+/// * type alignment\n+/// * a pointer to the type\u2019s `drop_in_place` impl (may be a no-op for plain-old-data)\n+/// * pointers to all the methods for the type\u2019s implementation of the trait\n+///\n+/// Note that the first three are special because they\u2019re necessary to allocate, drop,\n+/// and deallocate any trait object.\n+///\n+/// It is possible to name this struct with a type parameter that is not a `dyn` trait object\n+/// (for example `DynMetadata<u64>`) but not to obtain a meaningful value of that struct.\n+#[lang = \"dyn_metadata\"]\n+pub struct DynMetadata<Dyn: ?Sized> {\n+    vtable_ptr: &'static VTable,\n+    phantom: crate::marker::PhantomData<Dyn>,\n+}\n+\n+/// The common prefix of all vtables. It is followed by function pointers for trait methods.\n+///\n+/// Private implementation detail of `DynMetadata::size_of` etc.\n+#[repr(C)]\n+struct VTable {\n+    drop_in_place: fn(*mut ()),\n+    size_of: usize,\n+    align_of: usize,\n+}\n+\n+impl<Dyn: ?Sized> DynMetadata<Dyn> {\n+    /// Returns the size of the type associated with this vtable.\n+    #[inline]\n+    pub fn size_of(self) -> usize {\n+        self.vtable_ptr.size_of\n+    }\n+\n+    /// Returns the alignment of the type associated with this vtable.\n+    #[inline]\n+    pub fn align_of(self) -> usize {\n+        self.vtable_ptr.align_of\n+    }\n+\n+    /// Returns the size and alignment together as a `Layout`\n+    #[inline]\n+    pub fn layout(self) -> crate::alloc::Layout {\n+        // SAFETY: the compiler emitted this vtable for a concrete Rust type which\n+        // is known to have a valid layout. Same rationale as in `Layout::for_value`.\n+        unsafe { crate::alloc::Layout::from_size_align_unchecked(self.size_of(), self.align_of()) }\n+    }\n+}\n+\n+unsafe impl<Dyn: ?Sized> Send for DynMetadata<Dyn> {}\n+unsafe impl<Dyn: ?Sized> Sync for DynMetadata<Dyn> {}\n+\n+impl<Dyn: ?Sized> fmt::Debug for DynMetadata<Dyn> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"DynMetadata\").field(&(self.vtable_ptr as *const VTable)).finish()\n+    }\n+}\n+\n+// Manual impls needed to avoid `Dyn: $Trait` bounds.\n+\n+impl<Dyn: ?Sized> Unpin for DynMetadata<Dyn> {}\n+\n+impl<Dyn: ?Sized> Copy for DynMetadata<Dyn> {}\n+\n+impl<Dyn: ?Sized> Clone for DynMetadata<Dyn> {\n+    #[inline]\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+impl<Dyn: ?Sized> Eq for DynMetadata<Dyn> {}\n+\n+impl<Dyn: ?Sized> PartialEq for DynMetadata<Dyn> {\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        crate::ptr::eq::<VTable>(self.vtable_ptr, other.vtable_ptr)\n+    }\n+}\n+\n+impl<Dyn: ?Sized> Ord for DynMetadata<Dyn> {\n+    #[inline]\n+    fn cmp(&self, other: &Self) -> crate::cmp::Ordering {\n+        (self.vtable_ptr as *const VTable).cmp(&(other.vtable_ptr as *const VTable))\n+    }\n+}\n+\n+impl<Dyn: ?Sized> PartialOrd for DynMetadata<Dyn> {\n+    #[inline]\n+    fn partial_cmp(&self, other: &Self) -> Option<crate::cmp::Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl<Dyn: ?Sized> Hash for DynMetadata<Dyn> {\n+    #[inline]\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        crate::ptr::hash::<VTable, _>(self.vtable_ptr, hasher)\n+    }\n+}"}, {"sha": "9c53430ce3556319da81f9619f757ca3f9e63956", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d1462d8558cf4551608457f63d9b999185ebf3bf/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1462d8558cf4551608457f63d9b999185ebf3bf/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=d1462d8558cf4551608457f63d9b999185ebf3bf", "patch": "@@ -82,6 +82,14 @@ pub use crate::intrinsics::copy;\n #[doc(inline)]\n pub use crate::intrinsics::write_bytes;\n \n+#[cfg(not(bootstrap))]\n+mod metadata;\n+#[cfg(not(bootstrap))]\n+pub(crate) use metadata::PtrRepr;\n+#[cfg(not(bootstrap))]\n+#[unstable(feature = \"ptr_metadata\", issue = \"81513\")]\n+pub use metadata::{from_raw_parts, from_raw_parts_mut, metadata, DynMetadata, Pointee, Thin};\n+\n mod non_null;\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n pub use non_null::NonNull;\n@@ -220,26 +228,30 @@ pub const fn null_mut<T>() -> *mut T {\n     0 as *mut T\n }\n \n+#[cfg(bootstrap)]\n #[repr(C)]\n pub(crate) union Repr<T> {\n     pub(crate) rust: *const [T],\n     rust_mut: *mut [T],\n     pub(crate) raw: FatPtr<T>,\n }\n \n+#[cfg(bootstrap)]\n #[repr(C)]\n pub(crate) struct FatPtr<T> {\n     data: *const T,\n     pub(crate) len: usize,\n }\n \n+#[cfg(bootstrap)]\n // Manual impl needed to avoid `T: Clone` bound.\n impl<T> Clone for FatPtr<T> {\n     fn clone(&self) -> Self {\n         *self\n     }\n }\n \n+#[cfg(bootstrap)]\n // Manual impl needed to avoid `T: Copy` bound.\n impl<T> Copy for FatPtr<T> {}\n \n@@ -267,10 +279,15 @@ impl<T> Copy for FatPtr<T> {}\n #[stable(feature = \"slice_from_raw_parts\", since = \"1.42.0\")]\n #[rustc_const_unstable(feature = \"const_slice_from_raw_parts\", issue = \"67456\")]\n pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n-    // SAFETY: Accessing the value from the `Repr` union is safe since *const [T]\n-    // and FatPtr have the same memory layouts. Only std can make this\n-    // guarantee.\n-    unsafe { Repr { raw: FatPtr { data, len } }.rust }\n+    #[cfg(bootstrap)]\n+    {\n+        // SAFETY: Accessing the value from the `Repr` union is safe since *const [T]\n+        // and FatPtr have the same memory layouts. Only std can make this\n+        // guarantee.\n+        unsafe { Repr { raw: FatPtr { data, len } }.rust }\n+    }\n+    #[cfg(not(bootstrap))]\n+    from_raw_parts(data.cast(), len)\n }\n \n /// Performs the same functionality as [`slice_from_raw_parts`], except that a\n@@ -302,9 +319,14 @@ pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n #[stable(feature = \"slice_from_raw_parts\", since = \"1.42.0\")]\n #[rustc_const_unstable(feature = \"const_slice_from_raw_parts\", issue = \"67456\")]\n pub const fn slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T] {\n-    // SAFETY: Accessing the value from the `Repr` union is safe since *mut [T]\n-    // and FatPtr have the same memory layouts\n-    unsafe { Repr { raw: FatPtr { data, len } }.rust_mut }\n+    #[cfg(bootstrap)]\n+    {\n+        // SAFETY: Accessing the value from the `Repr` union is safe since *mut [T]\n+        // and FatPtr have the same memory layouts\n+        unsafe { Repr { raw: FatPtr { data, len } }.rust_mut }\n+    }\n+    #[cfg(not(bootstrap))]\n+    from_raw_parts_mut(data.cast(), len)\n }\n \n /// Swaps the values at two mutable locations of the same type, without"}, {"sha": "6651c3dd4e86bd90dd2657870f548f4c918411fb", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d1462d8558cf4551608457f63d9b999185ebf3bf/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1462d8558cf4551608457f63d9b999185ebf3bf/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=d1462d8558cf4551608457f63d9b999185ebf3bf", "patch": "@@ -47,6 +47,17 @@ impl<T: ?Sized> *mut T {\n         self as _\n     }\n \n+    /// Decompose a (possibly wide) pointer into is address and metadata components.\n+    ///\n+    /// The pointer can be later reconstructed with [`from_raw_parts_mut`].\n+    #[cfg(not(bootstrap))]\n+    #[unstable(feature = \"ptr_metadata\", issue = \"81513\")]\n+    #[rustc_const_unstable(feature = \"ptr_metadata\", issue = \"81513\")]\n+    #[inline]\n+    pub const fn to_raw_parts(self) -> (*mut (), <T as super::Pointee>::Metadata) {\n+        (self.cast(), super::metadata(self))\n+    }\n+\n     /// Returns `None` if the pointer is null, or else returns a shared reference to\n     /// the value wrapped in `Some`. If the value may be uninitialized, [`as_uninit_ref`]\n     /// must be used instead.\n@@ -1162,9 +1173,14 @@ impl<T> *mut [T] {\n     #[unstable(feature = \"slice_ptr_len\", issue = \"71146\")]\n     #[rustc_const_unstable(feature = \"const_slice_ptr_len\", issue = \"71146\")]\n     pub const fn len(self) -> usize {\n-        // SAFETY: this is safe because `*const [T]` and `FatPtr<T>` have the same layout.\n-        // Only `std` can make this guarantee.\n-        unsafe { Repr { rust_mut: self }.raw }.len\n+        #[cfg(bootstrap)]\n+        {\n+            // SAFETY: this is safe because `*const [T]` and `FatPtr<T>` have the same layout.\n+            // Only `std` can make this guarantee.\n+            unsafe { Repr { rust_mut: self }.raw }.len\n+        }\n+        #[cfg(not(bootstrap))]\n+        metadata(self)\n     }\n \n     /// Returns a raw pointer to the slice's buffer."}, {"sha": "709c247f2961466138e8e7bf2ef8dc9d595b38dc", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d1462d8558cf4551608457f63d9b999185ebf3bf/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1462d8558cf4551608457f63d9b999185ebf3bf/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=d1462d8558cf4551608457f63d9b999185ebf3bf", "patch": "@@ -175,6 +175,37 @@ impl<T: ?Sized> NonNull<T> {\n         }\n     }\n \n+    /// Performs the same functionality as [`std::ptr::from_raw_parts`], except that a\n+    /// `NonNull` pointer is returned, as opposed to a raw `*const` pointer.\n+    ///\n+    /// See the documentation of [`std::ptr::from_raw_parts`] for more details.\n+    ///\n+    /// [`std::ptr::from_raw_parts`]: crate::ptr::from_raw_parts\n+    #[cfg(not(bootstrap))]\n+    #[unstable(feature = \"ptr_metadata\", issue = \"81513\")]\n+    #[rustc_const_unstable(feature = \"ptr_metadata\", issue = \"81513\")]\n+    #[inline]\n+    pub const fn from_raw_parts(\n+        data_address: NonNull<()>,\n+        metadata: <T as super::Pointee>::Metadata,\n+    ) -> NonNull<T> {\n+        // SAFETY: The result of `ptr::from::raw_parts_mut` is non-null because `data_address` is.\n+        unsafe {\n+            NonNull::new_unchecked(super::from_raw_parts_mut(data_address.as_ptr(), metadata))\n+        }\n+    }\n+\n+    /// Decompose a (possibly wide) pointer into is address and metadata components.\n+    ///\n+    /// The pointer can be later reconstructed with [`NonNull::from_raw_parts`].\n+    #[cfg(not(bootstrap))]\n+    #[unstable(feature = \"ptr_metadata\", issue = \"81513\")]\n+    #[rustc_const_unstable(feature = \"ptr_metadata\", issue = \"81513\")]\n+    #[inline]\n+    pub const fn to_raw_parts(self) -> (NonNull<()>, <T as super::Pointee>::Metadata) {\n+        (self.cast(), super::metadata(self.as_ptr()))\n+    }\n+\n     /// Acquires the underlying `*mut` pointer.\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[rustc_const_stable(feature = \"const_nonnull_as_ptr\", since = \"1.32.0\")]"}, {"sha": "1c1b9e0b27e2558a8bc53e2b13a0da1f119572c4", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d1462d8558cf4551608457f63d9b999185ebf3bf/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1462d8558cf4551608457f63d9b999185ebf3bf/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=d1462d8558cf4551608457f63d9b999185ebf3bf", "patch": "@@ -94,9 +94,23 @@ impl<T> [T] {\n     // SAFETY: const sound because we transmute out the length field as a usize (which it must be)\n     #[rustc_allow_const_fn_unstable(const_fn_union)]\n     pub const fn len(&self) -> usize {\n-        // SAFETY: this is safe because `&[T]` and `FatPtr<T>` have the same layout.\n-        // Only `std` can make this guarantee.\n-        unsafe { crate::ptr::Repr { rust: self }.raw.len }\n+        #[cfg(bootstrap)]\n+        {\n+            // SAFETY: this is safe because `&[T]` and `FatPtr<T>` have the same layout.\n+            // Only `std` can make this guarantee.\n+            unsafe { crate::ptr::Repr { rust: self }.raw.len }\n+        }\n+        #[cfg(not(bootstrap))]\n+        {\n+            // FIXME: Replace with `crate::ptr::metadata(self)` when that is const-stable.\n+            // As of this writing this causes a \"Const-stable functions can only call other\n+            // const-stable functions\" error.\n+\n+            // SAFETY: Accessing the value from the `PtrRepr` union is safe since *const T\n+            // and PtrComponents<T> have the same memory layouts. Only std can make this\n+            // guarantee.\n+            unsafe { crate::ptr::PtrRepr { const_ptr: self }.components.metadata }\n+        }\n     }\n \n     /// Returns `true` if the slice has a length of 0."}, {"sha": "12182accc471a0eb191f2687efbfba91745c0130", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1462d8558cf4551608457f63d9b999185ebf3bf/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1462d8558cf4551608457f63d9b999185ebf3bf/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=d1462d8558cf4551608457f63d9b999185ebf3bf", "patch": "@@ -27,6 +27,7 @@\n #![feature(duration_saturating_ops)]\n #![feature(duration_zero)]\n #![feature(exact_size_is_empty)]\n+#![feature(extern_types)]\n #![feature(fixed_size_array)]\n #![feature(flt2dec)]\n #![feature(fmt_internals)]\n@@ -68,15 +69,18 @@\n #![feature(result_into_ok_or_err)]\n #![feature(option_unwrap_none)]\n #![feature(peekable_peek_mut)]\n+#![cfg_attr(not(bootstrap), feature(ptr_metadata))]\n #![feature(once_cell)]\n #![feature(unsafe_block_in_unsafe_fn)]\n+#![feature(unsized_tuple_coercion)]\n #![feature(int_bits_const)]\n #![feature(nonzero_leading_trailing_zeros)]\n #![feature(const_option)]\n #![feature(integer_atomics)]\n #![feature(slice_group_by)]\n #![feature(trusted_random_access)]\n #![deny(unsafe_op_in_unsafe_fn)]\n+#![cfg_attr(not(bootstrap), feature(unsize))]\n \n extern crate test;\n "}, {"sha": "224a58e3ccdb7bcc81f2c80a29155c6ca571a4b9", "filename": "library/core/tests/ptr.rs", "status": "modified", "additions": 254, "deletions": 0, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/d1462d8558cf4551608457f63d9b999185ebf3bf/library%2Fcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1462d8558cf4551608457f63d9b999185ebf3bf/library%2Fcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fptr.rs?ref=d1462d8558cf4551608457f63d9b999185ebf3bf", "patch": "@@ -1,5 +1,9 @@\n use core::cell::RefCell;\n+#[cfg(not(bootstrap))]\n+use core::ptr;\n use core::ptr::*;\n+#[cfg(not(bootstrap))]\n+use std::fmt::{Debug, Display};\n \n #[test]\n fn test_const_from_raw_parts() {\n@@ -413,3 +417,253 @@ fn offset_from() {\n         assert_eq!(ptr2.offset(-2), ptr1);\n     }\n }\n+\n+#[test]\n+#[cfg(not(bootstrap))]\n+fn ptr_metadata() {\n+    struct Unit;\n+    struct Pair<A, B: ?Sized>(A, B);\n+    extern \"C\" {\n+        type Extern;\n+    }\n+    let () = metadata(&());\n+    let () = metadata(&Unit);\n+    let () = metadata(&4_u32);\n+    let () = metadata(&String::new());\n+    let () = metadata(&Some(4_u32));\n+    let () = metadata(&ptr_metadata);\n+    let () = metadata(&|| {});\n+    let () = metadata(&[4, 7]);\n+    let () = metadata(&(4, String::new()));\n+    let () = metadata(&Pair(4, String::new()));\n+    let () = metadata(0 as *const Extern);\n+    let () = metadata(0 as *const <&u32 as std::ops::Deref>::Target);\n+\n+    assert_eq!(metadata(\"foo\"), 3_usize);\n+    assert_eq!(metadata(&[4, 7][..]), 2_usize);\n+\n+    let dst_tuple: &(bool, [u8]) = &(true, [0x66, 0x6F, 0x6F]);\n+    let dst_struct: &Pair<bool, [u8]> = &Pair(true, [0x66, 0x6F, 0x6F]);\n+    assert_eq!(metadata(dst_tuple), 3_usize);\n+    assert_eq!(metadata(dst_struct), 3_usize);\n+    unsafe {\n+        let dst_tuple: &(bool, str) = std::mem::transmute(dst_tuple);\n+        let dst_struct: &Pair<bool, str> = std::mem::transmute(dst_struct);\n+        assert_eq!(&dst_tuple.1, \"foo\");\n+        assert_eq!(&dst_struct.1, \"foo\");\n+        assert_eq!(metadata(dst_tuple), 3_usize);\n+        assert_eq!(metadata(dst_struct), 3_usize);\n+    }\n+\n+    let vtable_1: DynMetadata<dyn Debug> = metadata(&4_u16 as &dyn Debug);\n+    let vtable_2: DynMetadata<dyn Display> = metadata(&4_u16 as &dyn Display);\n+    let vtable_3: DynMetadata<dyn Display> = metadata(&4_u32 as &dyn Display);\n+    let vtable_4: DynMetadata<dyn Display> = metadata(&(true, 7_u32) as &(bool, dyn Display));\n+    let vtable_5: DynMetadata<dyn Display> =\n+        metadata(&Pair(true, 7_u32) as &Pair<bool, dyn Display>);\n+    unsafe {\n+        let address_1: usize = std::mem::transmute(vtable_1);\n+        let address_2: usize = std::mem::transmute(vtable_2);\n+        let address_3: usize = std::mem::transmute(vtable_3);\n+        let address_4: usize = std::mem::transmute(vtable_4);\n+        let address_5: usize = std::mem::transmute(vtable_5);\n+        // Different trait => different vtable pointer\n+        assert_ne!(address_1, address_2);\n+        // Different erased type => different vtable pointer\n+        assert_ne!(address_2, address_3);\n+        // Same erased type and same trait => same vtable pointer\n+        assert_eq!(address_3, address_4);\n+        assert_eq!(address_3, address_5);\n+    }\n+}\n+\n+#[test]\n+#[cfg(not(bootstrap))]\n+fn ptr_metadata_bounds() {\n+    fn metadata_eq_method_address<T: ?Sized>() -> usize {\n+        // The `Metadata` associated type has an `Ord` bound, so this is valid:\n+        <<T as Pointee>::Metadata as PartialEq>::eq as usize\n+    }\n+    // \"Synthetic\" trait impls generated by the compiler like those of `Pointee`\n+    // are not checked for bounds of associated type.\n+    // So with a buggy libcore we could have both:\n+    // * `<dyn Display as Pointee>::Metadata == DynMetadata`\n+    // * `DynMetadata: !PartialEq`\n+    // \u2026 and cause an ICE here:\n+    metadata_eq_method_address::<dyn Display>();\n+\n+    // For this reason, let\u2019s check here that bounds are satisfied:\n+\n+    let _ = static_assert_expected_bounds_for_metadata::<()>;\n+    let _ = static_assert_expected_bounds_for_metadata::<usize>;\n+    let _ = static_assert_expected_bounds_for_metadata::<DynMetadata<dyn Display>>;\n+    fn _static_assert_associated_type<T: ?Sized>() {\n+        let _ = static_assert_expected_bounds_for_metadata::<<T as Pointee>::Metadata>;\n+    }\n+\n+    fn static_assert_expected_bounds_for_metadata<Meta>()\n+    where\n+        // Keep this in sync with the associated type in `library/core/src/ptr/metadata.rs`\n+        Meta: Copy + Send + Sync + Ord + std::hash::Hash + Unpin,\n+    {\n+    }\n+}\n+\n+#[test]\n+#[cfg(not(bootstrap))]\n+fn dyn_metadata() {\n+    #[derive(Debug)]\n+    #[repr(align(32))]\n+    struct Something([u8; 47]);\n+\n+    let value = Something([0; 47]);\n+    let trait_object: &dyn Debug = &value;\n+    let meta = metadata(trait_object);\n+\n+    assert_eq!(meta.size_of(), 64);\n+    assert_eq!(meta.size_of(), std::mem::size_of::<Something>());\n+    assert_eq!(meta.align_of(), 32);\n+    assert_eq!(meta.align_of(), std::mem::align_of::<Something>());\n+    assert_eq!(meta.layout(), std::alloc::Layout::new::<Something>());\n+\n+    assert!(format!(\"{:?}\", meta).starts_with(\"DynMetadata(0x\"));\n+}\n+\n+#[test]\n+#[cfg(not(bootstrap))]\n+fn from_raw_parts() {\n+    let mut value = 5_u32;\n+    let address = &mut value as *mut _ as *mut ();\n+    let trait_object: &dyn Display = &mut value;\n+    let vtable = metadata(trait_object);\n+    let trait_object = NonNull::from(trait_object);\n+\n+    assert_eq!(ptr::from_raw_parts(address, vtable), trait_object.as_ptr());\n+    assert_eq!(ptr::from_raw_parts_mut(address, vtable), trait_object.as_ptr());\n+    assert_eq!(NonNull::from_raw_parts(NonNull::new(address).unwrap(), vtable), trait_object);\n+\n+    let mut array = [5_u32, 5, 5, 5, 5];\n+    let address = &mut array as *mut _ as *mut ();\n+    let array_ptr = NonNull::from(&mut array);\n+    let slice_ptr = NonNull::from(&mut array[..]);\n+\n+    assert_eq!(ptr::from_raw_parts(address, ()), array_ptr.as_ptr());\n+    assert_eq!(ptr::from_raw_parts_mut(address, ()), array_ptr.as_ptr());\n+    assert_eq!(NonNull::from_raw_parts(NonNull::new(address).unwrap(), ()), array_ptr);\n+\n+    assert_eq!(ptr::from_raw_parts(address, 5), slice_ptr.as_ptr());\n+    assert_eq!(ptr::from_raw_parts_mut(address, 5), slice_ptr.as_ptr());\n+    assert_eq!(NonNull::from_raw_parts(NonNull::new(address).unwrap(), 5), slice_ptr);\n+}\n+\n+#[test]\n+#[cfg(not(bootstrap))]\n+fn thin_box() {\n+    let foo = ThinBox::<dyn Display>::new(4);\n+    assert_eq!(foo.to_string(), \"4\");\n+    drop(foo);\n+    let bar = ThinBox::<dyn Display>::new(7);\n+    assert_eq!(bar.to_string(), \"7\");\n+\n+    // A slightly more interesting library that could be built on top of metadata APIs.\n+    //\n+    // * It could be generalized to any `T:\u00a0?Sized` (not just trait object)\n+    //   if `{size,align}_of_for_meta<T:\u00a0?Sized>(T::Metadata)` are added.\n+    // * Constructing a `ThinBox` without consuming and deallocating a `Box`\n+    //   requires either the unstable `Unsize` marker trait,\n+    //   or the unstable `unsized_locals`\u00a0language feature,\n+    //   or taking `&dyn T` and restricting to `T: Copy`.\n+\n+    use std::alloc::*;\n+    use std::marker::PhantomData;\n+\n+    struct ThinBox<T>\n+    where\n+        T: ?Sized + Pointee<Metadata = DynMetadata<T>>,\n+    {\n+        ptr: NonNull<DynMetadata<T>>,\n+        phantom: PhantomData<T>,\n+    }\n+\n+    impl<T> ThinBox<T>\n+    where\n+        T: ?Sized + Pointee<Metadata = DynMetadata<T>>,\n+    {\n+        pub fn new<Value: std::marker::Unsize<T>>(value: Value) -> Self {\n+            let unsized_: &T = &value;\n+            let meta = metadata(unsized_);\n+            let meta_layout = Layout::for_value(&meta);\n+            let value_layout = Layout::for_value(&value);\n+            let (layout, offset) = meta_layout.extend(value_layout).unwrap();\n+            // `DynMetadata` is pointer-sized:\n+            assert!(layout.size() > 0);\n+            // If `ThinBox<T>` is generalized to any `T: ?Sized`,\n+            // handle ZSTs with a dangling pointer without going through `alloc()`,\n+            // like `Box<T>` does.\n+            unsafe {\n+                let ptr = NonNull::new(alloc(layout))\n+                    .unwrap_or_else(|| handle_alloc_error(layout))\n+                    .cast::<DynMetadata<T>>();\n+                ptr.as_ptr().write(meta);\n+                ptr.cast::<u8>().as_ptr().add(offset).cast::<Value>().write(value);\n+                Self { ptr, phantom: PhantomData }\n+            }\n+        }\n+\n+        fn meta(&self) -> DynMetadata<T> {\n+            unsafe { *self.ptr.as_ref() }\n+        }\n+\n+        fn layout(&self) -> (Layout, usize) {\n+            let meta = self.meta();\n+            Layout::for_value(&meta).extend(meta.layout()).unwrap()\n+        }\n+\n+        fn value_ptr(&self) -> *const T {\n+            let (_, offset) = self.layout();\n+            let data_ptr = unsafe { self.ptr.cast::<u8>().as_ptr().add(offset) };\n+            ptr::from_raw_parts(data_ptr.cast(), self.meta())\n+        }\n+\n+        fn value_mut_ptr(&mut self) -> *mut T {\n+            let (_, offset) = self.layout();\n+            // FIXME: can this line be shared with the same in `value_ptr()`\n+            // without upsetting Stacked Borrows?\n+            let data_ptr = unsafe { self.ptr.cast::<u8>().as_ptr().add(offset) };\n+            from_raw_parts_mut(data_ptr.cast(), self.meta())\n+        }\n+    }\n+\n+    impl<T> std::ops::Deref for ThinBox<T>\n+    where\n+        T: ?Sized + Pointee<Metadata = DynMetadata<T>>,\n+    {\n+        type Target = T;\n+\n+        fn deref(&self) -> &T {\n+            unsafe { &*self.value_ptr() }\n+        }\n+    }\n+\n+    impl<T> std::ops::DerefMut for ThinBox<T>\n+    where\n+        T: ?Sized + Pointee<Metadata = DynMetadata<T>>,\n+    {\n+        fn deref_mut(&mut self) -> &mut T {\n+            unsafe { &mut *self.value_mut_ptr() }\n+        }\n+    }\n+\n+    impl<T> std::ops::Drop for ThinBox<T>\n+    where\n+        T: ?Sized + Pointee<Metadata = DynMetadata<T>>,\n+    {\n+        fn drop(&mut self) {\n+            let (layout, _) = self.layout();\n+            unsafe {\n+                drop_in_place::<T>(&mut **self);\n+                dealloc(self.ptr.cast().as_ptr(), layout);\n+            }\n+        }\n+    }\n+}"}, {"sha": "16733b7ccd3537262156b610df39330f462ad6e2", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d1462d8558cf4551608457f63d9b999185ebf3bf/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1462d8558cf4551608457f63d9b999185ebf3bf/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=d1462d8558cf4551608457f63d9b999185ebf3bf", "patch": "@@ -275,6 +275,7 @@\n #![feature(int_error_matching)]\n #![feature(integer_atomics)]\n #![feature(into_future)]\n+#![cfg_attr(not(bootstrap), feature(intra_doc_pointers))]\n #![feature(lang_items)]\n #![feature(link_args)]\n #![feature(linkage)]"}, {"sha": "fc0ff904389320f01f8be3c86d034311d1dccf41", "filename": "src/test/rustdoc/intra-doc/libstd-re-export.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d1462d8558cf4551608457f63d9b999185ebf3bf/src%2Ftest%2Frustdoc%2Fintra-doc%2Flibstd-re-export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1462d8558cf4551608457f63d9b999185ebf3bf/src%2Ftest%2Frustdoc%2Fintra-doc%2Flibstd-re-export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Flibstd-re-export.rs?ref=d1462d8558cf4551608457f63d9b999185ebf3bf", "patch": "@@ -1,3 +1,4 @@\n #![deny(broken_intra_doc_links)]\n+#![feature(intra_doc_pointers)]\n \n pub use std::*;"}]}