{"sha": "ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkMzBlOWE2ODE0YjVkMjlkZmJkY2Q4NWVjZGU0OGFmY2M5NDM4OWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-22T13:40:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-22T13:40:01Z"}, "message": "Auto merge of #57830 - Centril:rollup, r=Centril\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #57537 (Small perf improvement for fmt)\n - #57552 (Default images)\n - #57604 (Make `str` indexing generic on `SliceIndex`.)\n - #57667 (Fix memory leak in P::filter_map)\n - #57677 (const_eval: Predetermine the layout of all locals when pushing a stack frame)\n - #57791 (Add regression test for #54582)\n - #57798 (Corrected spelling inconsistency)\n - #57809 (Add powerpc64-unknown-freebsd)\n - #57813 (fix validation range printing when encountering undef)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "0e358d32a69cc6c584211e87fd412d8f3cb505fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e358d32a69cc6c584211e87fd412d8f3cb505fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "html_url": "https://github.com/rust-lang/rust/commit/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76c87a166fa8ca247855ea6c32465d627d1ead14", "url": "https://api.github.com/repos/rust-lang/rust/commits/76c87a166fa8ca247855ea6c32465d627d1ead14", "html_url": "https://github.com/rust-lang/rust/commit/76c87a166fa8ca247855ea6c32465d627d1ead14"}, {"sha": "dec7b7b1315a073c40c253cc9c80fc693422e3bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/dec7b7b1315a073c40c253cc9c80fc693422e3bf", "html_url": "https://github.com/rust-lang/rust/commit/dec7b7b1315a073c40c253cc9c80fc693422e3bf"}], "stats": {"total": 777, "additions": 494, "deletions": 283}, "files": [{"sha": "92f10c760c6d2cc63fefb8e37d79f9ff1ce59774", "filename": "src/libcore/benches/fmt.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibcore%2Fbenches%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibcore%2Fbenches%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Ffmt.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -0,0 +1,110 @@\n+use std::io::{self, Write as IoWrite};\n+use std::fmt::{self, Write as FmtWrite};\n+use test::Bencher;\n+\n+#[bench]\n+fn write_vec_value(bh: &mut Bencher) {\n+    bh.iter(|| {\n+        let mut mem = Vec::new();\n+        for _ in 0..1000 {\n+            mem.write_all(\"abc\".as_bytes()).unwrap();\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn write_vec_ref(bh: &mut Bencher) {\n+    bh.iter(|| {\n+        let mut mem = Vec::new();\n+        let wr = &mut mem as &mut dyn io::Write;\n+        for _ in 0..1000 {\n+            wr.write_all(\"abc\".as_bytes()).unwrap();\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn write_vec_macro1(bh: &mut Bencher) {\n+    bh.iter(|| {\n+        let mut mem = Vec::new();\n+        let wr = &mut mem as &mut dyn io::Write;\n+        for _ in 0..1000 {\n+            write!(wr, \"abc\").unwrap();\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn write_vec_macro2(bh: &mut Bencher) {\n+    bh.iter(|| {\n+        let mut mem = Vec::new();\n+        let wr = &mut mem as &mut dyn io::Write;\n+        for _ in 0..1000 {\n+            write!(wr, \"{}\", \"abc\").unwrap();\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn write_vec_macro_debug(bh: &mut Bencher) {\n+    bh.iter(|| {\n+        let mut mem = Vec::new();\n+        let wr = &mut mem as &mut dyn io::Write;\n+        for _ in 0..1000 {\n+            write!(wr, \"{:?}\", \"\u2603\").unwrap();\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn write_str_value(bh: &mut Bencher) {\n+    bh.iter(|| {\n+        let mut mem = String::new();\n+        for _ in 0..1000 {\n+            mem.write_str(\"abc\").unwrap();\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn write_str_ref(bh: &mut Bencher) {\n+    bh.iter(|| {\n+        let mut mem = String::new();\n+        let wr = &mut mem as &mut dyn fmt::Write;\n+        for _ in 0..1000 {\n+            wr.write_str(\"abc\").unwrap();\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn write_str_macro1(bh: &mut Bencher) {\n+    bh.iter(|| {\n+        let mut mem = String::new();\n+        for _ in 0..1000 {\n+            write!(mem, \"abc\").unwrap();\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn write_str_macro2(bh: &mut Bencher) {\n+    bh.iter(|| {\n+        let mut mem = String::new();\n+        let wr = &mut mem as &mut dyn fmt::Write;\n+        for _ in 0..1000 {\n+            write!(wr, \"{}\", \"abc\").unwrap();\n+        }\n+    });\n+}\n+\n+#[bench]\n+fn write_str_macro_debug(bh: &mut Bencher) {\n+    bh.iter(|| {\n+        let mut mem = String::new();\n+        let wr = &mut mem as &mut dyn fmt::Write;\n+        for _ in 0..1000 {\n+            write!(wr, \"{:?}\", \"\u2603\").unwrap();\n+        }\n+    });\n+}"}, {"sha": "48572af611a5b79a2a8dcdf660289c0c304a28e5", "filename": "src/libcore/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibcore%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibcore%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Flib.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -11,3 +11,4 @@ mod iter;\n mod num;\n mod ops;\n mod slice;\n+mod fmt;"}, {"sha": "935579f4943b60f12b5e79b795edb0301ecd54f4", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -1006,28 +1006,30 @@ pub fn write(output: &mut dyn Write, args: Arguments) -> Result {\n         curarg: args.args.iter(),\n     };\n \n-    let mut pieces = args.pieces.iter();\n+    let mut idx = 0;\n \n     match args.fmt {\n         None => {\n             // We can use default formatting parameters for all arguments.\n-            for (arg, piece) in args.args.iter().zip(pieces.by_ref()) {\n+            for (arg, piece) in args.args.iter().zip(args.pieces.iter()) {\n                 formatter.buf.write_str(*piece)?;\n                 (arg.formatter)(arg.value, &mut formatter)?;\n+                idx += 1;\n             }\n         }\n         Some(fmt) => {\n             // Every spec has a corresponding argument that is preceded by\n             // a string piece.\n-            for (arg, piece) in fmt.iter().zip(pieces.by_ref()) {\n+            for (arg, piece) in fmt.iter().zip(args.pieces.iter()) {\n                 formatter.buf.write_str(*piece)?;\n                 formatter.run(arg)?;\n+                idx += 1;\n             }\n         }\n     }\n \n     // There can be only one trailing string piece left.\n-    if let Some(piece) = pieces.next() {\n+    if let Some(piece) = args.pieces.get(idx) {\n         formatter.buf.write_str(*piece)?;\n     }\n "}, {"sha": "d4ed86142768d418bf83ea28c5de10be0527f09d", "filename": "src/libcore/ops/index.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibcore%2Fops%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibcore%2Fops%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Findex.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -51,21 +51,6 @@\n /// ```\n #[lang = \"index\"]\n #[rustc_on_unimplemented(\n-    on(\n-        _Self=\"&str\",\n-        note=\"you can use `.chars().nth()` or `.bytes().nth()`\n-see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n-    ),\n-    on(\n-        _Self=\"str\",\n-        note=\"you can use `.chars().nth()` or `.bytes().nth()`\n-see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n-    ),\n-    on(\n-        _Self=\"std::string::String\",\n-        note=\"you can use `.chars().nth()` or `.bytes().nth()`\n-see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n-    ),\n     message=\"the type `{Self}` cannot be indexed by `{Idx}`\",\n     label=\"`{Self}` cannot be indexed by `{Idx}`\",\n )]"}, {"sha": "9f9515e6d9b7c4e372eee8beb937aac3dd89fc6b", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -2383,7 +2383,6 @@ impl [u8] {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\n impl<T, I> ops::Index<I> for [T]\n     where I: SliceIndex<[T]>\n {\n@@ -2396,7 +2395,6 @@ impl<T, I> ops::Index<I> for [T]\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\n impl<T, I> ops::IndexMut<I> for [T]\n     where I: SliceIndex<[T]>\n {\n@@ -2447,7 +2445,19 @@ mod private_slice_index {\n \n /// A helper trait used for indexing operations.\n #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\n+#[rustc_on_unimplemented(\n+    on(\n+        T = \"str\",\n+        label = \"string indices are ranges of `usize`\",\n+    ),\n+    on(\n+        all(any(T = \"str\", T = \"&str\", T = \"std::string::String\"), _Self=\"{integer}\"),\n+        note=\"you can use `.chars().nth()` or `.bytes().nth()`\n+see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\"\n+    ),\n+    message = \"the type `{T}` cannot be indexed by `{Self}`\",\n+    label = \"slice indices are of type `usize` or ranges of `usize`\",\n+)]\n pub trait SliceIndex<T: ?Sized>: private_slice_index::Sealed {\n     /// The output type returned by methods.\n     #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]"}, {"sha": "1ee8b7735c17d19fcb85b82555dab48fcca784fe", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 119, "deletions": 177, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -1621,190 +1621,26 @@ mod traits {\n         }\n     }\n \n-    /// Implements substring slicing with syntax `&self[begin .. end]`.\n-    ///\n-    /// Returns a slice of the given string from the byte range\n-    /// [`begin`..`end`).\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `begin` or `end` does not point to the starting\n-    /// byte offset of a character (as defined by `is_char_boundary`).\n-    /// Requires that `begin <= end` and `end <= len` where `len` is the\n-    /// length of the string.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert_eq!(&s[0 .. 1], \"L\");\n-    ///\n-    /// assert_eq!(&s[1 .. 9], \"\u00f6we \u8001\");\n-    ///\n-    /// // these will panic:\n-    /// // byte 2 lies within `\u00f6`:\n-    /// // &s[2 ..3];\n-    ///\n-    /// // byte 8 lies within `\u8001`\n-    /// // &s[1 .. 8];\n-    ///\n-    /// // byte 100 is outside the string\n-    /// // &s[3 .. 100];\n-    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::Range<usize>> for str {\n-        type Output = str;\n-        #[inline]\n-        fn index(&self, index: ops::Range<usize>) -> &str {\n-            index.index(self)\n-        }\n-    }\n-\n-    /// Implements mutable substring slicing with syntax\n-    /// `&mut self[begin .. end]`.\n-    ///\n-    /// Returns a mutable slice of the given string from the byte range\n-    /// [`begin`..`end`).\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `begin` or `end` does not point to the starting\n-    /// byte offset of a character (as defined by `is_char_boundary`).\n-    /// Requires that `begin <= end` and `end <= len` where `len` is the\n-    /// length of the string.\n-    #[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\n-    impl ops::IndexMut<ops::Range<usize>> for str {\n-        #[inline]\n-        fn index_mut(&mut self, index: ops::Range<usize>) -> &mut str {\n-            index.index_mut(self)\n-        }\n-    }\n-\n-    /// Implements substring slicing with syntax `&self[.. end]`.\n-    ///\n-    /// Returns a slice of the string from the beginning to byte offset\n-    /// `end`.\n-    ///\n-    /// Equivalent to `&self[0 .. end]`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::RangeTo<usize>> for str {\n-        type Output = str;\n-\n-        #[inline]\n-        fn index(&self, index: ops::RangeTo<usize>) -> &str {\n-            index.index(self)\n-        }\n-    }\n-\n-    /// Implements mutable substring slicing with syntax `&mut self[.. end]`.\n-    ///\n-    /// Returns a mutable slice of the string from the beginning to byte offset\n-    /// `end`.\n-    ///\n-    /// Equivalent to `&mut self[0 .. end]`.\n-    #[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\n-    impl ops::IndexMut<ops::RangeTo<usize>> for str {\n-        #[inline]\n-        fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut str {\n-            index.index_mut(self)\n-        }\n-    }\n-\n-    /// Implements substring slicing with syntax `&self[begin ..]`.\n-    ///\n-    /// Returns a slice of the string from byte offset `begin`\n-    /// to the end of the string.\n-    ///\n-    /// Equivalent to `&self[begin .. len]`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::RangeFrom<usize>> for str {\n-        type Output = str;\n+    impl<I> ops::Index<I> for str\n+    where\n+        I: SliceIndex<str>,\n+    {\n+        type Output = I::Output;\n \n         #[inline]\n-        fn index(&self, index: ops::RangeFrom<usize>) -> &str {\n+        fn index(&self, index: I) -> &I::Output {\n             index.index(self)\n         }\n     }\n \n-    /// Implements mutable substring slicing with syntax `&mut self[begin ..]`.\n-    ///\n-    /// Returns a mutable slice of the string from byte offset `begin`\n-    /// to the end of the string.\n-    ///\n-    /// Equivalent to `&mut self[begin .. len]`.\n-    #[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\n-    impl ops::IndexMut<ops::RangeFrom<usize>> for str {\n-        #[inline]\n-        fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut str {\n-            index.index_mut(self)\n-        }\n-    }\n-\n-    /// Implements substring slicing with syntax `&self[..]`.\n-    ///\n-    /// Returns a slice of the whole string. This operation can\n-    /// never panic.\n-    ///\n-    /// Equivalent to `&self[0 .. len]`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::RangeFull> for str {\n-        type Output = str;\n-\n-        #[inline]\n-        fn index(&self, _index: ops::RangeFull) -> &str {\n-            self\n-        }\n-    }\n-\n-    /// Implements mutable substring slicing with syntax `&mut self[..]`.\n-    ///\n-    /// Returns a mutable slice of the whole string. This operation can\n-    /// never panic.\n-    ///\n-    /// Equivalent to `&mut self[0 .. len]`.\n-    #[stable(feature = \"derefmut_for_string\", since = \"1.3.0\")]\n-    impl ops::IndexMut<ops::RangeFull> for str {\n-        #[inline]\n-        fn index_mut(&mut self, _index: ops::RangeFull) -> &mut str {\n-            self\n-        }\n-    }\n-\n-    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-    impl ops::Index<ops::RangeInclusive<usize>> for str {\n-        type Output = str;\n-\n-        #[inline]\n-        fn index(&self, index: ops::RangeInclusive<usize>) -> &str {\n-            index.index(self)\n-        }\n-    }\n-\n-    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-    impl ops::Index<ops::RangeToInclusive<usize>> for str {\n-        type Output = str;\n-\n-        #[inline]\n-        fn index(&self, index: ops::RangeToInclusive<usize>) -> &str {\n-            index.index(self)\n-        }\n-    }\n-\n-    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-    impl ops::IndexMut<ops::RangeInclusive<usize>> for str {\n-        #[inline]\n-        fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut str {\n-            index.index_mut(self)\n-        }\n-    }\n-    #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-    impl ops::IndexMut<ops::RangeToInclusive<usize>> for str {\n+    impl<I> ops::IndexMut<I> for str\n+    where\n+        I: SliceIndex<str>,\n+    {\n         #[inline]\n-        fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut str {\n+        fn index_mut(&mut self, index: I) -> &mut I::Output {\n             index.index_mut(self)\n         }\n     }\n@@ -1815,6 +1651,18 @@ mod traits {\n         panic!(\"attempted to index str up to maximum usize\");\n     }\n \n+    /// Implements substring slicing with syntax `&self[..]` or `&mut self[..]`.\n+    ///\n+    /// Returns a slice of the whole string, i.e., returns `&self` or `&mut\n+    /// self`. Equivalent to `&self[0 .. len]` or `&mut self[0 .. len]`. Unlike\n+    /// other indexing operations, this can never panic.\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// Prior to 1.20.0, these indexing operations were still supported by\n+    /// direct implementation of `Index` and `IndexMut`.\n+    ///\n+    /// Equivalent to `&self[0 .. len]` or `&mut self[0 .. len]`.\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     impl SliceIndex<str> for ops::RangeFull {\n         type Output = str;\n@@ -1844,6 +1692,41 @@ mod traits {\n         }\n     }\n \n+    /// Implements substring slicing with syntax `&self[begin .. end]` or `&mut\n+    /// self[begin .. end]`.\n+    ///\n+    /// Returns a slice of the given string from the byte range\n+    /// [`begin`, `end`).\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// Prior to 1.20.0, these indexing operations were still supported by\n+    /// direct implementation of `Index` and `IndexMut`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `begin` or `end` does not point to the starting byte offset of\n+    /// a character (as defined by `is_char_boundary`), if `begin > end`, or if\n+    /// `end > len`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert_eq!(&s[0 .. 1], \"L\");\n+    ///\n+    /// assert_eq!(&s[1 .. 9], \"\u00f6we \u8001\");\n+    ///\n+    /// // these will panic:\n+    /// // byte 2 lies within `\u00f6`:\n+    /// // &s[2 ..3];\n+    ///\n+    /// // byte 8 lies within `\u8001`\n+    /// // &s[1 .. 8];\n+    ///\n+    /// // byte 100 is outside the string\n+    /// // &s[3 .. 100];\n+    /// ```\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     impl SliceIndex<str> for ops::Range<usize> {\n         type Output = str;\n@@ -1898,6 +1781,21 @@ mod traits {\n         }\n     }\n \n+    /// Implements substring slicing with syntax `&self[.. end]` or `&mut\n+    /// self[.. end]`.\n+    ///\n+    /// Returns a slice of the given string from the byte range [`0`, `end`).\n+    /// Equivalent to `&self[0 .. end]` or `&mut self[0 .. end]`.\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// Prior to 1.20.0, these indexing operations were still supported by\n+    /// direct implementation of `Index` and `IndexMut`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `end` does not point to the starting byte offset of a\n+    /// character (as defined by `is_char_boundary`), or if `end > len`.\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     impl SliceIndex<str> for ops::RangeTo<usize> {\n         type Output = str;\n@@ -1943,6 +1841,22 @@ mod traits {\n         }\n     }\n \n+    /// Implements substring slicing with syntax `&self[begin ..]` or `&mut\n+    /// self[begin ..]`.\n+    ///\n+    /// Returns a slice of the given string from the byte range [`begin`,\n+    /// `len`). Equivalent to `&self[begin .. len]` or `&mut self[begin ..\n+    /// len]`.\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// Prior to 1.20.0, these indexing operations were still supported by\n+    /// direct implementation of `Index` and `IndexMut`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `begin` does not point to the starting byte offset of\n+    /// a character (as defined by `is_char_boundary`), or if `begin >= len`.\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     impl SliceIndex<str> for ops::RangeFrom<usize> {\n         type Output = str;\n@@ -1990,6 +1904,22 @@ mod traits {\n         }\n     }\n \n+    /// Implements substring slicing with syntax `&self[begin ..= end]` or `&mut\n+    /// self[begin ..= end]`.\n+    ///\n+    /// Returns a slice of the given string from the byte range\n+    /// [`begin`, `end`]. Equivalent to `&self [begin .. end + 1]` or `&mut\n+    /// self[begin .. end + 1]`, except if `end` has the maximum value for\n+    /// `usize`.\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `begin` does not point to the starting byte offset of\n+    /// a character (as defined by `is_char_boundary`), if `end` does not point\n+    /// to the ending byte offset of a character (`end + 1` is either a starting\n+    /// byte offset or equal to `len`), if `begin > end`, or if `end >= len`.\n     #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n     impl SliceIndex<str> for ops::RangeInclusive<usize> {\n         type Output = str;\n@@ -2023,8 +1953,20 @@ mod traits {\n         }\n     }\n \n-\n-\n+    /// Implements substring slicing with syntax `&self[..= end]` or `&mut\n+    /// self[..= end]`.\n+    ///\n+    /// Returns a slice of the given string from the byte range [0, `end`].\n+    /// Equivalent to `&self [0 .. end + 1]`, except if `end` has the maximum\n+    /// value for `usize`.\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `end` does not point to the ending byte offset of a character\n+    /// (`end + 1` is either a starting byte offset as defined by\n+    /// `is_char_boundary`, or equal to `len`), or if `end >= len`.\n     #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n     impl SliceIndex<str> for ops::RangeToInclusive<usize> {\n         type Output = str;"}, {"sha": "da440cdd72f8065d7266a09d8feaff3959dfdb15", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -72,6 +72,15 @@ pub enum Position<'a> {\n     ArgumentNamed(&'a str),\n }\n \n+impl Position<'_> {\n+    pub fn index(&self) -> Option<usize> {\n+        match self {\n+            ArgumentIs(i) | ArgumentImplicitlyIs(i) => Some(*i),\n+            _ => None,\n+        }\n+    }\n+}\n+\n /// Enum of alignments which are supported.\n #[derive(Copy, Clone, PartialEq)]\n pub enum Alignment {"}, {"sha": "905a3ceed81c9d04bd957241a773c7de0102ca70", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -1931,7 +1931,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_parenthesized_parameter_data(\n         &mut self,\n-        data: &ParenthesisedArgs,\n+        data: &ParenthesizedArgs,\n     ) -> (hir::GenericArgs, bool) {\n         // Switch to `PassThrough` mode for anonymous lifetimes: this\n         // means that we permit things like `&Ref<T>`, where `Ref` has\n@@ -1941,7 +1941,7 @@ impl<'a> LoweringContext<'a> {\n         self.with_anonymous_lifetime_mode(\n             AnonymousLifetimeMode::PassThrough,\n             |this| {\n-                let &ParenthesisedArgs { ref inputs, ref output, span } = data;\n+                let &ParenthesizedArgs { ref inputs, ref output, span } = data;\n                 let inputs = inputs\n                     .iter()\n                     .map(|ty| this.lower_ty_direct(ty, ImplTraitContext::disallowed()))"}, {"sha": "105856fecc729175ac9d15ea8360c1fc8fa8e220", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -72,6 +72,7 @@ fn mk_eval_cx_inner<'a, 'mir, 'tcx>(\n     ecx.stack.push(interpret::Frame {\n         block: mir::START_BLOCK,\n         locals: IndexVec::new(),\n+        local_layouts: IndexVec::new(),\n         instance,\n         span,\n         mir,"}, {"sha": "b2d3328a73fe8335885f97a520e35937c2ea0289", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -1,3 +1,4 @@\n+use std::cell::Cell;\n use std::fmt::Write;\n use std::mem;\n \n@@ -76,6 +77,7 @@ pub struct Frame<'mir, 'tcx: 'mir, Tag=(), Extra=()> {\n     /// `None` represents a local that is currently dead, while a live local\n     /// can either directly contain `Scalar` or refer to some part of an `Allocation`.\n     pub locals: IndexVec<mir::Local, LocalValue<Tag>>,\n+    pub local_layouts: IndexVec<mir::Local, Cell<Option<TyLayout<'tcx>>>>,\n \n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n@@ -290,9 +292,15 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         frame: &Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n         local: mir::Local\n     ) -> EvalResult<'tcx, TyLayout<'tcx>> {\n-        let local_ty = frame.mir.local_decls[local].ty;\n-        let local_ty = self.monomorphize(local_ty, frame.instance.substs);\n-        self.layout_of(local_ty)\n+        let cell = &frame.local_layouts[local];\n+        if cell.get().is_none() {\n+            let local_ty = frame.mir.local_decls[local].ty;\n+            let local_ty = self.monomorphize(local_ty, frame.instance.substs);\n+            let layout = self.layout_of(local_ty)?;\n+            cell.set(Some(layout));\n+        }\n+\n+        Ok(cell.get().unwrap())\n     }\n \n     pub fn str_to_immediate(&mut self, s: &str) -> EvalResult<'tcx, Immediate<M::PointerTag>> {\n@@ -426,6 +434,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             // empty local array, we fill it in below, after we are inside the stack frame and\n             // all methods actually know about the frame\n             locals: IndexVec::new(),\n+            local_layouts: IndexVec::from_elem_n(Default::default(), mir.local_decls.len()),\n             span,\n             instance,\n             stmt: 0,\n@@ -464,11 +473,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n                 },\n             }\n             // Finally, properly initialize all those that still have the dummy value\n-            for (local, decl) in locals.iter_mut().zip(mir.local_decls.iter()) {\n+            for (idx, local) in locals.iter_enumerated_mut() {\n                 match *local {\n                     LocalValue::Live(_) => {\n                         // This needs to be peoperly initialized.\n-                        let layout = self.layout_of(self.monomorphize(decl.ty, instance.substs))?;\n+                        let layout = self.layout_of_local(self.frame(), idx)?;\n                         *local = LocalValue::Live(self.uninit_operand(layout)?);\n                     }\n                     LocalValue::Dead => {"}, {"sha": "b2648480f203cc9eae0b588cb155be08979ea852", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -457,36 +457,30 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     }\n \n     /// This is used by [priroda](https://github.com/oli-obk/priroda) to get an OpTy from a local\n-    ///\n-    /// When you know the layout of the local in advance, you can pass it as last argument\n-    pub fn access_local(\n+    fn access_local(\n         &self,\n         frame: &super::Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>,\n         local: mir::Local,\n-        layout: Option<TyLayout<'tcx>>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         assert_ne!(local, mir::RETURN_PLACE);\n         let op = *frame.locals[local].access()?;\n-        let layout = from_known_layout(layout,\n-                    || self.layout_of_local(frame, local))?;\n+        let layout = self.layout_of_local(frame, local)?;\n         Ok(OpTy { op, layout })\n     }\n \n     // Evaluate a place with the goal of reading from it.  This lets us sometimes\n-    // avoid allocations.  If you already know the layout, you can pass it in\n-    // to avoid looking it up again.\n+    // avoid allocations.\n     fn eval_place_to_op(\n         &self,\n         mir_place: &mir::Place<'tcx>,\n-        layout: Option<TyLayout<'tcx>>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         use rustc::mir::Place::*;\n         let op = match *mir_place {\n             Local(mir::RETURN_PLACE) => return err!(ReadFromReturnPointer),\n-            Local(local) => self.access_local(self.frame(), local, layout)?,\n+            Local(local) => self.access_local(self.frame(), local)?,\n \n             Projection(ref proj) => {\n-                let op = self.eval_place_to_op(&proj.base, None)?;\n+                let op = self.eval_place_to_op(&proj.base)?;\n                 self.operand_projection(op, &proj.elem)?\n             }\n \n@@ -510,7 +504,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             // FIXME: do some more logic on `move` to invalidate the old location\n             Copy(ref place) |\n             Move(ref place) =>\n-                self.eval_place_to_op(place, layout)?,\n+                self.eval_place_to_op(place)?,\n \n             Constant(ref constant) => {\n                 let layout = from_known_layout(layout, || {"}, {"sha": "53105266b39284372354d84860652e4d2adf97ac", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -314,13 +314,14 @@ struct FrameSnapshot<'a, 'tcx: 'a> {\n     stmt: usize,\n }\n \n-impl_stable_hash_for!(impl<'tcx, 'mir: 'tcx> for struct Frame<'mir, 'tcx> {\n+impl_stable_hash_for!(impl<'mir, 'tcx: 'mir> for struct Frame<'mir, 'tcx> {\n     mir,\n     instance,\n     span,\n     return_to_block,\n     return_place -> (return_place.as_ref().map(|r| &**r)),\n     locals,\n+    local_layouts -> _,\n     block,\n     stmt,\n     extra,\n@@ -339,6 +340,7 @@ impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n             return_to_block,\n             return_place,\n             locals,\n+            local_layouts: _,\n             block,\n             stmt,\n             extra: _,"}, {"sha": "8f5a5bf8ee312d77dcbf27c6ebc9527aa484c340", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -449,8 +449,13 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n         }\n         // At least one value is excluded. Get the bits.\n         let value = try_validation!(value.not_undef(),\n-            value, self.path,\n-            format!(\"something in the range {:?}\", layout.valid_range));\n+            value,\n+            self.path,\n+            format!(\n+                \"something {}\",\n+                wrapping_range_format(&layout.valid_range, max_hi),\n+            )\n+        );\n         let bits = match value {\n             Scalar::Ptr(ptr) => {\n                 if lo == 1 && hi == max_hi {"}, {"sha": "e47da3cff95b695e2545a8b28bcc5f20724cfab9", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -367,6 +367,7 @@ supported_targets! {\n \n     (\"aarch64-unknown-freebsd\", aarch64_unknown_freebsd),\n     (\"i686-unknown-freebsd\", i686_unknown_freebsd),\n+    (\"powerpc64-unknown-freebsd\", powerpc64_unknown_freebsd),\n     (\"x86_64-unknown-freebsd\", x86_64_unknown_freebsd),\n \n     (\"i686-unknown-dragonfly\", i686_unknown_dragonfly),"}, {"sha": "cc7b87bfdebc345e29a95c8fe1239bb7363f7996", "filename": "src/librustc_target/spec/powerpc64_unknown_freebsd.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustc_target%2Fspec%2Fpowerpc64_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustc_target%2Fspec%2Fpowerpc64_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fpowerpc64_unknown_freebsd.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -0,0 +1,22 @@\n+use spec::{LinkerFlavor, Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::freebsd_base::opts();\n+    base.cpu = \"ppc64\".to_string();\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n+    base.max_atomic_width = Some(64);\n+\n+    Ok(Target {\n+        llvm_target: \"powerpc64-unknown-freebsd\".to_string(),\n+        target_endian: \"big\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"E-m:e-i64:64-n32:64\".to_string(),\n+        arch: \"powerpc64\".to_string(),\n+        target_os: \"freebsd\".to_string(),\n+        target_env: String::new(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: base,\n+    })\n+}"}, {"sha": "c34dcbbb672e9b8753d784dbe9687171faed258f", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -177,7 +177,10 @@ pub fn render<T: fmt::Display, S: fmt::Display>(\n     root_path = page.root_path,\n     css_class = page.css_class,\n     logo      = if layout.logo.is_empty() {\n-        String::new()\n+        format!(\"<a href='{}{}/index.html'>\\\n+                 <img src='{static_root_path}rust-logo{suffix}.png' alt='logo' width='100'></a>\",\n+                static_root_path=static_root_path,\n+                suffix=page.resource_suffix)\n     } else {\n         format!(\"<a href='{}{}/index.html'>\\\n                  <img src='{}' alt='logo' width='100'></a>\",\n@@ -188,7 +191,9 @@ pub fn render<T: fmt::Display, S: fmt::Display>(\n     description = page.description,\n     keywords = page.keywords,\n     favicon   = if layout.favicon.is_empty() {\n-        String::new()\n+        format!(r#\"<link rel=\"shortcut icon\" href=\"{static_root_path}favicon{suffix}.ico\">\"#,\n+                static_root_path=static_root_path,\n+                suffix=page.resource_suffix)\n     } else {\n         format!(r#\"<link rel=\"shortcut icon\" href=\"{}\">\"#, layout.favicon)\n     },"}, {"sha": "86fb51419c270a581d9bff2a6a5d931831d26075", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -789,6 +789,14 @@ fn write_shared(\n         themes.insert(theme.to_owned());\n     }\n \n+    if (*cx.shared).layout.logo.is_empty() {\n+        write(cx.dst.join(&format!(\"rust-logo{}.png\", cx.shared.resource_suffix)),\n+              static_files::RUST_LOGO)?;\n+    }\n+    if (*cx.shared).layout.favicon.is_empty() {\n+        write(cx.dst.join(&format!(\"favicon{}.ico\", cx.shared.resource_suffix)),\n+              static_files::RUST_FAVICON)?;\n+    }\n     write(cx.dst.join(&format!(\"brush{}.svg\", cx.shared.resource_suffix)),\n           static_files::BRUSH_SVG)?;\n     write(cx.dst.join(&format!(\"wheel{}.svg\", cx.shared.resource_suffix)),\n@@ -2068,8 +2076,6 @@ impl Context {\n         themes.push(PathBuf::from(\"settings.css\"));\n         let mut layout = self.shared.layout.clone();\n         layout.krate = String::new();\n-        layout.logo = String::new();\n-        layout.favicon = String::new();\n         try_err!(layout::render(&mut w, &layout,\n                                 &page, &sidebar, &settings,\n                                 self.shared.css_file_extension.is_some(),"}, {"sha": "b8ad23769ac8d06eb5973bfb3d2acbf385240f98", "filename": "src/librustdoc/html/static/favicon.ico", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Ffavicon.ico", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Ffavicon.ico", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Ffavicon.ico?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b"}, {"sha": "74b4bd695045ebc52c21af95301adc9311ca881c", "filename": "src/librustdoc/html/static/rust-logo.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frust-logo.png", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frust-logo.png", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frust-logo.png?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b"}, {"sha": "a1d8cfacc54ada112d34a7cb52037559b4c522bd", "filename": "src/librustdoc/html/static_files.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -51,6 +51,11 @@ pub static LICENSE_APACHE: &'static [u8] = include_bytes!(\"static/LICENSE-APACHE\n /// The contents of `LICENSE-MIT.txt`, the text of the MIT License.\n pub static LICENSE_MIT: &'static [u8] = include_bytes!(\"static/LICENSE-MIT.txt\");\n \n+/// The contents of `rust-logo.png`, the default icon of the documentation.\n+pub static RUST_LOGO: &'static [u8] = include_bytes!(\"static/rust-logo.png\");\n+/// The contents of `favicon.ico`, the default favicon of the documentation.\n+pub static RUST_FAVICON: &'static [u8] = include_bytes!(\"static/favicon.ico\");\n+\n /// The built-in themes given to every documentation site.\n pub mod themes {\n     /// The \"light\" theme, selected by default when no setting is available. Used as the basis for"}, {"sha": "798f14dcba955216cb588413bc361117f6d3334e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -136,7 +136,7 @@ pub enum GenericArgs {\n     /// The `<'a, A,B,C>` in `foo::bar::baz::<'a, A,B,C>`\n     AngleBracketed(AngleBracketedArgs),\n     /// The `(A,B)` and `C` in `Foo(A,B) -> C`\n-    Parenthesized(ParenthesisedArgs),\n+    Parenthesized(ParenthesizedArgs),\n }\n \n impl GenericArgs {\n@@ -173,15 +173,15 @@ impl Into<Option<P<GenericArgs>>> for AngleBracketedArgs {\n     }\n }\n \n-impl Into<Option<P<GenericArgs>>> for ParenthesisedArgs {\n+impl Into<Option<P<GenericArgs>>> for ParenthesizedArgs {\n     fn into(self) -> Option<P<GenericArgs>> {\n         Some(P(GenericArgs::Parenthesized(self)))\n     }\n }\n \n /// A path like `Foo(A,B) -> C`\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub struct ParenthesisedArgs {\n+pub struct ParenthesizedArgs {\n     /// Overall span\n     pub span: Span,\n \n@@ -192,7 +192,7 @@ pub struct ParenthesisedArgs {\n     pub output: Option<P<Ty>>,\n }\n \n-impl ParenthesisedArgs {\n+impl ParenthesizedArgs {\n     pub fn as_angle_bracketed_args(&self) -> AngleBracketedArgs {\n         AngleBracketedArgs {\n             span: self.span,"}, {"sha": "fdcbbb939a6cf16167c86ecc7bb20725c7151470", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -207,8 +207,8 @@ pub trait Folder : Sized {\n         noop_fold_angle_bracketed_parameter_data(p, self)\n     }\n \n-    fn fold_parenthesized_parameter_data(&mut self, p: ParenthesisedArgs)\n-                                         -> ParenthesisedArgs\n+    fn fold_parenthesized_parameter_data(&mut self, p: ParenthesizedArgs)\n+                                         -> ParenthesizedArgs\n     {\n         noop_fold_parenthesized_parameter_data(p, self)\n     }\n@@ -504,12 +504,12 @@ pub fn noop_fold_angle_bracketed_parameter_data<T: Folder>(data: AngleBracketedA\n     }\n }\n \n-pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesisedArgs,\n+pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedArgs,\n                                                          fld: &mut T)\n-                                                         -> ParenthesisedArgs\n+                                                         -> ParenthesizedArgs\n {\n-    let ParenthesisedArgs { inputs, output, span } = data;\n-    ParenthesisedArgs {\n+    let ParenthesizedArgs { inputs, output, span } = data;\n+    ParenthesizedArgs {\n         inputs: inputs.move_map(|ty| fld.fold_ty(ty)),\n         output: output.map(|ty| fld.fold_ty(ty)),\n         span: fld.new_span(span)"}, {"sha": "09ea099525326015c87b3c9893d4df0559515548", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -1,5 +1,5 @@\n use rustc_target::spec::abi::{self, Abi};\n-use ast::{AngleBracketedArgs, ParenthesisedArgs, AttrStyle, BareFnTy};\n+use ast::{AngleBracketedArgs, ParenthesizedArgs, AttrStyle, BareFnTy};\n use ast::{GenericBound, TraitBoundModifier};\n use ast::Unsafety;\n use ast::{Mod, AnonConst, Arg, Arm, Guard, Attribute, BindingMode, TraitItemKind};\n@@ -2203,7 +2203,7 @@ impl<'a> Parser<'a> {\n                 } else {\n                     None\n                 };\n-                ParenthesisedArgs { inputs, output, span }.into()\n+                ParenthesizedArgs { inputs, output, span }.into()\n             };\n \n             PathSegment { ident, args, id: ast::DUMMY_NODE_ID }"}, {"sha": "3effe53cd29b05c821a7a7025eb21e5a1e55d85f", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -101,6 +101,7 @@ impl<T: 'static> P<T> {\n                 // Recreate self from the raw pointer.\n                 Some(P { ptr: Box::from_raw(p) })\n             } else {\n+                drop(Box::from_raw(p));\n                 None\n             }\n         }"}, {"sha": "215df4224c5f1ec7516ece1931eabbfea94d120c", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -493,7 +493,10 @@ impl<'a, 'b> Context<'a, 'b> {\n \n                 let fill = arg.format.fill.unwrap_or(' ');\n \n-                if *arg != simple_arg || fill != ' ' {\n+                let pos_simple =\n+                    arg.position.index() == simple_arg.position.index();\n+\n+                if !pos_simple || arg.format != simple_arg.format || fill != ' ' {\n                     self.all_pieces_simple = false;\n                 }\n "}, {"sha": "3e0b0948ef3c3ff4b536809a261fb28bc50d6c72", "filename": "src/test/ui/consts/const-eval/ub-nonnull.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -13,6 +13,13 @@ const NULL_U8: NonZeroU8 = unsafe { mem::transmute(0u8) };\n const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n //~^ ERROR it is undefined behavior to use this value\n \n+union Transmute {\n+    uninit: (),\n+    out: NonZeroU8,\n+}\n+const UNINIT: NonZeroU8 = unsafe { Transmute { uninit: () }.out };\n+//~^ ERROR it is undefined behavior to use this value\n+\n // Also test other uses of rustc_layout_scalar_valid_range_start\n \n #[rustc_layout_scalar_valid_range_start(10)]"}, {"sha": "6230712ad6f232497c7123a6acf4d3b378470093", "filename": "src/test/ui/consts/const-eval/ub-nonnull.stderr", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -23,21 +23,29 @@ LL | const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:21:1\n+  --> $DIR/ub-nonnull.rs:20:1\n+   |\n+LL | const UNINIT: NonZeroU8 = unsafe { Transmute { uninit: () }.out };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected something greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-nonnull.rs:28:1\n    |\n LL | const BAD_RANGE1: RestrictedRange1 = unsafe { RestrictedRange1(42) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 42, but expected something in the range 10..=30\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:27:1\n+  --> $DIR/ub-nonnull.rs:34:1\n    |\n LL | const BAD_RANGE2: RestrictedRange2 = unsafe { RestrictedRange2(20) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 20, but expected something less or equal to 10, or greater or equal to 30\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "4c585a958c14bcd0955d6cdda49e01993dba70a5", "filename": "src/test/ui/index-help.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Findex-help.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Findex-help.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Findex-help.stderr?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -1,4 +1,4 @@\n-error[E0277]: the trait bound `i32: std::slice::SliceIndex<[{integer}]>` is not satisfied\n+error[E0277]: the type `[{integer}]` cannot be indexed by `i32`\n   --> $DIR/index-help.rs:3:5\n    |\n LL |     x[0i32]; //~ ERROR E0277"}, {"sha": "dbe9b44a13890b8b09289cd91d385f7ea97f3c44", "filename": "src/test/ui/indexing-requires-a-uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Findexing-requires-a-uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Findexing-requires-a-uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Findexing-requires-a-uint.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -3,7 +3,7 @@\n \n fn main() {\n     fn bar<T>(_: T) {}\n-    [0][0u8]; //~ ERROR: the trait bound `u8: std::slice::SliceIndex<[{integer}]>` is not satisfied\n+    [0][0u8]; //~ ERROR: the type `[{integer}]` cannot be indexed by `u8`\n \n     [0][0]; // should infer to be a usize\n "}, {"sha": "363c3d0d45853e7fea18fdbb8bf96339702b2239", "filename": "src/test/ui/indexing-requires-a-uint.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Findexing-requires-a-uint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Findexing-requires-a-uint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Findexing-requires-a-uint.stderr?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -1,7 +1,7 @@\n-error[E0277]: the trait bound `u8: std::slice::SliceIndex<[{integer}]>` is not satisfied\n+error[E0277]: the type `[{integer}]` cannot be indexed by `u8`\n   --> $DIR/indexing-requires-a-uint.rs:6:5\n    |\n-LL |     [0][0u8]; //~ ERROR: the trait bound `u8: std::slice::SliceIndex<[{integer}]>` is not satisfied\n+LL |     [0][0u8]; //~ ERROR: the type `[{integer}]` cannot be indexed by `u8`\n    |     ^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `std::slice::SliceIndex<[{integer}]>` is not implemented for `u8`"}, {"sha": "f076dfcb0a42c039febb89f54ab94a26c596f9c9", "filename": "src/test/ui/integral-indexing.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Fintegral-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Fintegral-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintegral-indexing.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -3,14 +3,14 @@ pub fn main() {\n     let s: String = \"abcdef\".to_string();\n     v[3_usize];\n     v[3];\n-    v[3u8];  //~ERROR : std::slice::SliceIndex<[isize]>` is not satisfied\n-    v[3i8];  //~ERROR : std::slice::SliceIndex<[isize]>` is not satisfied\n-    v[3u32]; //~ERROR : std::slice::SliceIndex<[isize]>` is not satisfied\n-    v[3i32]; //~ERROR : std::slice::SliceIndex<[isize]>` is not satisfied\n+    v[3u8];  //~ERROR : the type `[isize]` cannot be indexed by `u8`\n+    v[3i8];  //~ERROR : the type `[isize]` cannot be indexed by `i8`\n+    v[3u32]; //~ERROR : the type `[isize]` cannot be indexed by `u32`\n+    v[3i32]; //~ERROR : the type `[isize]` cannot be indexed by `i32`\n     s.as_bytes()[3_usize];\n     s.as_bytes()[3];\n-    s.as_bytes()[3u8];  //~ERROR : std::slice::SliceIndex<[u8]>` is not satisfied\n-    s.as_bytes()[3i8];  //~ERROR : std::slice::SliceIndex<[u8]>` is not satisfied\n-    s.as_bytes()[3u32]; //~ERROR : std::slice::SliceIndex<[u8]>` is not satisfied\n-    s.as_bytes()[3i32]; //~ERROR : std::slice::SliceIndex<[u8]>` is not satisfied\n+    s.as_bytes()[3u8];  //~ERROR : the type `[u8]` cannot be indexed by `u8`\n+    s.as_bytes()[3i8];  //~ERROR : the type `[u8]` cannot be indexed by `i8`\n+    s.as_bytes()[3u32]; //~ERROR : the type `[u8]` cannot be indexed by `u32`\n+    s.as_bytes()[3i32]; //~ERROR : the type `[u8]` cannot be indexed by `i32`\n }"}, {"sha": "efbad86c4d31b3126546cba841a2e98afcaca9f0", "filename": "src/test/ui/integral-indexing.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Fintegral-indexing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Fintegral-indexing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintegral-indexing.stderr?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -1,70 +1,70 @@\n-error[E0277]: the trait bound `u8: std::slice::SliceIndex<[isize]>` is not satisfied\n+error[E0277]: the type `[isize]` cannot be indexed by `u8`\n   --> $DIR/integral-indexing.rs:6:5\n    |\n-LL |     v[3u8];  //~ERROR : std::slice::SliceIndex<[isize]>` is not satisfied\n+LL |     v[3u8];  //~ERROR : the type `[isize]` cannot be indexed by `u8`\n    |     ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `std::slice::SliceIndex<[isize]>` is not implemented for `u8`\n    = note: required because of the requirements on the impl of `std::ops::Index<u8>` for `std::vec::Vec<isize>`\n \n-error[E0277]: the trait bound `i8: std::slice::SliceIndex<[isize]>` is not satisfied\n+error[E0277]: the type `[isize]` cannot be indexed by `i8`\n   --> $DIR/integral-indexing.rs:7:5\n    |\n-LL |     v[3i8];  //~ERROR : std::slice::SliceIndex<[isize]>` is not satisfied\n+LL |     v[3i8];  //~ERROR : the type `[isize]` cannot be indexed by `i8`\n    |     ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `std::slice::SliceIndex<[isize]>` is not implemented for `i8`\n    = note: required because of the requirements on the impl of `std::ops::Index<i8>` for `std::vec::Vec<isize>`\n \n-error[E0277]: the trait bound `u32: std::slice::SliceIndex<[isize]>` is not satisfied\n+error[E0277]: the type `[isize]` cannot be indexed by `u32`\n   --> $DIR/integral-indexing.rs:8:5\n    |\n-LL |     v[3u32]; //~ERROR : std::slice::SliceIndex<[isize]>` is not satisfied\n+LL |     v[3u32]; //~ERROR : the type `[isize]` cannot be indexed by `u32`\n    |     ^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `std::slice::SliceIndex<[isize]>` is not implemented for `u32`\n    = note: required because of the requirements on the impl of `std::ops::Index<u32>` for `std::vec::Vec<isize>`\n \n-error[E0277]: the trait bound `i32: std::slice::SliceIndex<[isize]>` is not satisfied\n+error[E0277]: the type `[isize]` cannot be indexed by `i32`\n   --> $DIR/integral-indexing.rs:9:5\n    |\n-LL |     v[3i32]; //~ERROR : std::slice::SliceIndex<[isize]>` is not satisfied\n+LL |     v[3i32]; //~ERROR : the type `[isize]` cannot be indexed by `i32`\n    |     ^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `std::slice::SliceIndex<[isize]>` is not implemented for `i32`\n    = note: required because of the requirements on the impl of `std::ops::Index<i32>` for `std::vec::Vec<isize>`\n \n-error[E0277]: the trait bound `u8: std::slice::SliceIndex<[u8]>` is not satisfied\n+error[E0277]: the type `[u8]` cannot be indexed by `u8`\n   --> $DIR/integral-indexing.rs:12:5\n    |\n-LL |     s.as_bytes()[3u8];  //~ERROR : std::slice::SliceIndex<[u8]>` is not satisfied\n+LL |     s.as_bytes()[3u8];  //~ERROR : the type `[u8]` cannot be indexed by `u8`\n    |     ^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `std::slice::SliceIndex<[u8]>` is not implemented for `u8`\n    = note: required because of the requirements on the impl of `std::ops::Index<u8>` for `[u8]`\n \n-error[E0277]: the trait bound `i8: std::slice::SliceIndex<[u8]>` is not satisfied\n+error[E0277]: the type `[u8]` cannot be indexed by `i8`\n   --> $DIR/integral-indexing.rs:13:5\n    |\n-LL |     s.as_bytes()[3i8];  //~ERROR : std::slice::SliceIndex<[u8]>` is not satisfied\n+LL |     s.as_bytes()[3i8];  //~ERROR : the type `[u8]` cannot be indexed by `i8`\n    |     ^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `std::slice::SliceIndex<[u8]>` is not implemented for `i8`\n    = note: required because of the requirements on the impl of `std::ops::Index<i8>` for `[u8]`\n \n-error[E0277]: the trait bound `u32: std::slice::SliceIndex<[u8]>` is not satisfied\n+error[E0277]: the type `[u8]` cannot be indexed by `u32`\n   --> $DIR/integral-indexing.rs:14:5\n    |\n-LL |     s.as_bytes()[3u32]; //~ERROR : std::slice::SliceIndex<[u8]>` is not satisfied\n+LL |     s.as_bytes()[3u32]; //~ERROR : the type `[u8]` cannot be indexed by `u32`\n    |     ^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `std::slice::SliceIndex<[u8]>` is not implemented for `u32`\n    = note: required because of the requirements on the impl of `std::ops::Index<u32>` for `[u8]`\n \n-error[E0277]: the trait bound `i32: std::slice::SliceIndex<[u8]>` is not satisfied\n+error[E0277]: the type `[u8]` cannot be indexed by `i32`\n   --> $DIR/integral-indexing.rs:15:5\n    |\n-LL |     s.as_bytes()[3i32]; //~ERROR : std::slice::SliceIndex<[u8]>` is not satisfied\n+LL |     s.as_bytes()[3i32]; //~ERROR : the type `[u8]` cannot be indexed by `i32`\n    |     ^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `std::slice::SliceIndex<[u8]>` is not implemented for `i32`"}, {"sha": "c2dbf361911b5826c6045705ba4abfba561f7d0e", "filename": "src/test/ui/issues/issue-54582.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Fissues%2Fissue-54582.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Fissues%2Fissue-54582.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54582.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -0,0 +1,16 @@\n+// run-pass\n+\n+pub trait Stage: Sync {}\n+\n+pub enum Enum {\n+    A,\n+    B,\n+}\n+\n+impl Stage for Enum {}\n+\n+pub static ARRAY: [(&Stage, &str); 1] = [\n+    (&Enum::A, \"\"),\n+];\n+\n+fn main() {}"}, {"sha": "7b45d848c97b7a3e1406f287154084728cd879e1", "filename": "src/test/ui/on-unimplemented/slice-index.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Fon-unimplemented%2Fslice-index.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Fon-unimplemented%2Fslice-index.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fslice-index.stderr?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -1,4 +1,4 @@\n-error[E0277]: the trait bound `i32: std::slice::SliceIndex<[i32]>` is not satisfied\n+error[E0277]: the type `[i32]` cannot be indexed by `i32`\n   --> $DIR/slice-index.rs:11:5\n    |\n LL |     x[1i32]; //~ ERROR E0277\n@@ -7,7 +7,7 @@ LL |     x[1i32]; //~ ERROR E0277\n    = help: the trait `std::slice::SliceIndex<[i32]>` is not implemented for `i32`\n    = note: required because of the requirements on the impl of `std::ops::Index<i32>` for `[i32]`\n \n-error[E0277]: the trait bound `std::ops::RangeTo<i32>: std::slice::SliceIndex<[i32]>` is not satisfied\n+error[E0277]: the type `[i32]` cannot be indexed by `std::ops::RangeTo<i32>`\n   --> $DIR/slice-index.rs:12:5\n    |\n LL |     x[..1i32]; //~ ERROR E0277"}, {"sha": "0b4ccdd5a56d4939ce553c2bc25bd6f717558479", "filename": "src/test/ui/parenthesized-deref-suggestion.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Fparenthesized-deref-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Fparenthesized-deref-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparenthesized-deref-suggestion.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "previous_filename": "src/test/ui/parenthesised-deref-suggestion.rs"}, {"sha": "fd9b0e8216b4113b56814b25efa3ccd0d070f5b8", "filename": "src/test/ui/parenthesized-deref-suggestion.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Fparenthesized-deref-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Fparenthesized-deref-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparenthesized-deref-suggestion.stderr?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -1,5 +1,5 @@\n error[E0609]: no field `opts` on type `*const Session`\n-  --> $DIR/parenthesised-deref-suggestion.rs:7:30\n+  --> $DIR/parenthesized-deref-suggestion.rs:7:30\n    |\n LL |     (sess as *const Session).opts; //~ ERROR no field `opts` on type `*const Session`\n    |                              ^^^^\n@@ -9,7 +9,7 @@ LL |     (*(sess as *const Session)).opts; //~ ERROR no field `opts` on type `*c\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0609]: no field `0` on type `[u32; 1]`\n-  --> $DIR/parenthesised-deref-suggestion.rs:10:21\n+  --> $DIR/parenthesized-deref-suggestion.rs:10:21\n    |\n LL |     (x as [u32; 1]).0; //~ ERROR no field `0` on type `[u32; 1]`\n    |     ----------------^", "previous_filename": "src/test/ui/parenthesised-deref-suggestion.stderr"}, {"sha": "1b32ed5533d35279bb086b1851e65477c3610a98", "filename": "src/test/ui/str/str-idx.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Fstr%2Fstr-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Fstr%2Fstr-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstr%2Fstr-idx.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -1,4 +1,7 @@\n pub fn main() {\n     let s: &str = \"hello\";\n-    let c: u8 = s[4]; //~ ERROR the type `str` cannot be indexed by `{integer}`\n+    let _: u8 = s[4]; //~ ERROR the type `str` cannot be indexed by `{integer}`\n+    let _ = s.get(4); //~ ERROR the type `str` cannot be indexed by `{integer}`\n+    let _ = s.get_unchecked(4); //~ ERROR the type `str` cannot be indexed by `{integer}`\n+    let _: u8 = s['c']; //~ ERROR the type `str` cannot be indexed by `char`\n }"}, {"sha": "99df85d92fd9662085e4d7d76bd2e2e340ae849e", "filename": "src/test/ui/str/str-idx.stderr", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Fstr%2Fstr-idx.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Fstr%2Fstr-idx.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstr%2Fstr-idx.stderr?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -1,13 +1,43 @@\n error[E0277]: the type `str` cannot be indexed by `{integer}`\n   --> $DIR/str-idx.rs:3:17\n    |\n-LL |     let c: u8 = s[4]; //~ ERROR the type `str` cannot be indexed by `{integer}`\n-   |                 ^^^^ `str` cannot be indexed by `{integer}`\n+LL |     let _: u8 = s[4]; //~ ERROR the type `str` cannot be indexed by `{integer}`\n+   |                 ^^^^ string indices are ranges of `usize`\n    |\n-   = help: the trait `std::ops::Index<{integer}>` is not implemented for `str`\n+   = help: the trait `std::slice::SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n+   = note: required because of the requirements on the impl of `std::ops::Index<{integer}>` for `str`\n \n-error: aborting due to previous error\n+error[E0277]: the type `str` cannot be indexed by `{integer}`\n+  --> $DIR/str-idx.rs:4:15\n+   |\n+LL |     let _ = s.get(4); //~ ERROR the type `str` cannot be indexed by `{integer}`\n+   |               ^^^ string indices are ranges of `usize`\n+   |\n+   = help: the trait `std::slice::SliceIndex<str>` is not implemented for `{integer}`\n+   = note: you can use `.chars().nth()` or `.bytes().nth()`\n+           see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n+\n+error[E0277]: the type `str` cannot be indexed by `{integer}`\n+  --> $DIR/str-idx.rs:5:15\n+   |\n+LL |     let _ = s.get_unchecked(4); //~ ERROR the type `str` cannot be indexed by `{integer}`\n+   |               ^^^^^^^^^^^^^ string indices are ranges of `usize`\n+   |\n+   = help: the trait `std::slice::SliceIndex<str>` is not implemented for `{integer}`\n+   = note: you can use `.chars().nth()` or `.bytes().nth()`\n+           see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n+\n+error[E0277]: the type `str` cannot be indexed by `char`\n+  --> $DIR/str-idx.rs:6:17\n+   |\n+LL |     let _: u8 = s['c']; //~ ERROR the type `str` cannot be indexed by `char`\n+   |                 ^^^^^^ string indices are ranges of `usize`\n+   |\n+   = help: the trait `std::slice::SliceIndex<str>` is not implemented for `char`\n+   = note: required because of the requirements on the impl of `std::ops::Index<char>` for `str`\n+\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "575a9eae859465788d447044a07034685e21434d", "filename": "src/test/ui/str/str-mut-idx.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Fstr%2Fstr-mut-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Fstr%2Fstr-mut-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstr%2Fstr-mut-idx.rs?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -5,7 +5,13 @@ fn mutate(s: &mut str) {\n     //~^ ERROR the size for values of type\n     //~| ERROR the size for values of type\n     s[1usize] = bot();\n-    //~^ ERROR the type `str` cannot be mutably indexed by `usize`\n+    //~^ ERROR the type `str` cannot be indexed by `usize`\n+    s.get_mut(1);\n+    //~^ ERROR the type `str` cannot be indexed by `{integer}`\n+    s.get_unchecked_mut(1);\n+    //~^ ERROR the type `str` cannot be indexed by `{integer}`\n+    s['c'];\n+    //~^ ERROR the type `str` cannot be indexed by `char`\n }\n \n pub fn main() {}"}, {"sha": "beb227245236343c7e7fcfc0b5c06bf22f48a17c", "filename": "src/test/ui/str/str-mut-idx.stderr", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Fstr%2Fstr-mut-idx.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad30e9a6814b5d29dfbdcd85ecde48afcc94389b/src%2Ftest%2Fui%2Fstr%2Fstr-mut-idx.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstr%2Fstr-mut-idx.stderr?ref=ad30e9a6814b5d29dfbdcd85ecde48afcc94389b", "patch": "@@ -22,16 +22,44 @@ LL |     s[1..2] = bot();\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n    = note: the left-hand-side of an assignment must have a statically known size\n \n-error[E0277]: the type `str` cannot be mutably indexed by `usize`\n+error[E0277]: the type `str` cannot be indexed by `usize`\n   --> $DIR/str-mut-idx.rs:7:5\n    |\n LL |     s[1usize] = bot();\n-   |     ^^^^^^^^^ `str` cannot be mutably indexed by `usize`\n+   |     ^^^^^^^^^ string indices are ranges of `usize`\n    |\n-   = help: the trait `std::ops::IndexMut<usize>` is not implemented for `str`\n+   = help: the trait `std::slice::SliceIndex<str>` is not implemented for `usize`\n+   = note: required because of the requirements on the impl of `std::ops::Index<usize>` for `str`\n+\n+error[E0277]: the type `str` cannot be indexed by `{integer}`\n+  --> $DIR/str-mut-idx.rs:9:7\n+   |\n+LL |     s.get_mut(1);\n+   |       ^^^^^^^ string indices are ranges of `usize`\n+   |\n+   = help: the trait `std::slice::SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n \n-error: aborting due to 3 previous errors\n+error[E0277]: the type `str` cannot be indexed by `{integer}`\n+  --> $DIR/str-mut-idx.rs:11:7\n+   |\n+LL |     s.get_unchecked_mut(1);\n+   |       ^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`\n+   |\n+   = help: the trait `std::slice::SliceIndex<str>` is not implemented for `{integer}`\n+   = note: you can use `.chars().nth()` or `.bytes().nth()`\n+           see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n+\n+error[E0277]: the type `str` cannot be indexed by `char`\n+  --> $DIR/str-mut-idx.rs:13:5\n+   |\n+LL |     s['c'];\n+   |     ^^^^^^ string indices are ranges of `usize`\n+   |\n+   = help: the trait `std::slice::SliceIndex<str>` is not implemented for `char`\n+   = note: required because of the requirements on the impl of `std::ops::Index<char>` for `str`\n+\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}]}