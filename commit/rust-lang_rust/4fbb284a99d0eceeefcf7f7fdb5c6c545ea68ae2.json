{"sha": "4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2", "node_id": "C_kwDOAAsO6NoAKDRmYmIyODRhOTlkMGVjZWVlZmNmN2Y3ZmRiNWM2YzU0NWVhNjhhZTI", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-24T23:45:35Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-25T00:05:56Z"}, "message": "implement 'delimited' expose tracking so we still detect some UB", "tree": {"sha": "5bc4f4e0fa448df0a8908bf5db9cb3b39a1b2ca9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bc4f4e0fa448df0a8908bf5db9cb3b39a1b2ca9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2", "html_url": "https://github.com/rust-lang/rust/commit/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d6fdaa024138de464a74ebd5307c706c68a3eef", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d6fdaa024138de464a74ebd5307c706c68a3eef", "html_url": "https://github.com/rust-lang/rust/commit/8d6fdaa024138de464a74ebd5307c706c68a3eef"}], "stats": {"total": 418, "additions": 293, "deletions": 125}, "files": [{"sha": "230f46c569dbffa8ffebdef23ac7883ef51fab3e", "filename": "src/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::ty;\n use rustc_span::{source_map::DUMMY_SP, Span, SpanData, Symbol};\n \n use crate::helpers::HexRange;\n-use crate::stacked_borrows::{diagnostics::TagHistory, AccessKind, SbTag};\n+use crate::stacked_borrows::{diagnostics::TagHistory, AccessKind};\n use crate::*;\n \n /// Details of premature program termination.\n@@ -61,9 +61,9 @@ impl MachineStopType for TerminationInfo {}\n /// Miri specific diagnostics\n pub enum NonHaltingDiagnostic {\n     CreatedPointerTag(NonZeroU64),\n-    /// This `Item` was popped from the borrow stack, either due to a grant of\n-    /// `AccessKind` to `SbTag` or a deallocation when the second argument is `None`.\n-    PoppedPointerTag(Item, Option<(SbTag, AccessKind)>),\n+    /// This `Item` was popped from the borrow stack, either due to an access with the given tag or\n+    /// a deallocation when the second argument is `None`.\n+    PoppedPointerTag(Item, Option<(SbTagExtra, AccessKind)>),\n     CreatedCallId(CallId),\n     CreatedAlloc(AllocId),\n     FreedAlloc(AllocId),"}, {"sha": "cfaf61f9d5c887b11f1998532454dca672622b4a", "filename": "src/intptrcast.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2", "patch": "@@ -142,9 +142,7 @@ impl<'mir, 'tcx> GlobalStateInner {\n                 // Determine the allocation this points to at cast time.\n                 let alloc_id = Self::alloc_id_from_addr(ecx, addr);\n                 Pointer::new(\n-                    alloc_id.map(|alloc_id| {\n-                        Tag::Concrete(ConcreteTag { alloc_id, sb: SbTag::Untagged })\n-                    }),\n+                    alloc_id.map(|alloc_id| Tag::Concrete { alloc_id, sb: SbTag::Untagged }),\n                     Size::from_bytes(addr),\n                 )\n             }\n@@ -222,8 +220,8 @@ impl<'mir, 'tcx> GlobalStateInner {\n     ) -> Option<(AllocId, Size)> {\n         let (tag, addr) = ptr.into_parts(); // addr is absolute (Tag provenance)\n \n-        let alloc_id = if let Tag::Concrete(concrete) = tag {\n-            concrete.alloc_id\n+        let alloc_id = if let Tag::Concrete { alloc_id, .. } = tag {\n+            alloc_id\n         } else {\n             // A wildcard pointer.\n             assert_eq!(ecx.machine.intptrcast.borrow().provenance_mode, ProvenanceMode::Permissive);"}, {"sha": "68489c9b47b96a0c0793ad7cf626a90eea1b8eaa", "filename": "src/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2", "patch": "@@ -7,6 +7,7 @@\n #![feature(io_error_more)]\n #![feature(yeet_expr)]\n #![feature(is_some_with)]\n+#![feature(nonzero_ops)]\n #![warn(rust_2018_idioms)]\n #![allow(\n     clippy::collapsible_else_if,\n@@ -81,15 +82,15 @@ pub use crate::eval::{\n pub use crate::helpers::{CurrentSpan, EvalContextExt as HelpersEvalContextExt};\n pub use crate::intptrcast::ProvenanceMode;\n pub use crate::machine::{\n-    AllocExtra, ConcreteTag, Evaluator, FrameData, MiriEvalContext, MiriEvalContextExt,\n-    MiriMemoryKind, Tag, NUM_CPUS, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n+    AllocExtra, Evaluator, FrameData, MiriEvalContext, MiriEvalContextExt, MiriMemoryKind, Tag,\n+    NUM_CPUS, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n };\n pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n pub use crate::range_map::RangeMap;\n pub use crate::stacked_borrows::{\n-    CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, PtrId, SbTag, Stack,\n-    Stacks,\n+    CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, PtrId, SbTag, SbTagExtra,\n+    Stack, Stacks,\n };\n pub use crate::sync::{CondvarId, EvalContextExt as SyncEvalContextExt, MutexId, RwLockId};\n pub use crate::thread::{"}, {"sha": "5810ac6d7ecac74cf8d31b8284220212f36ce22a", "filename": "src/machine.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2", "patch": "@@ -130,17 +130,14 @@ impl fmt::Display for MiriMemoryKind {\n /// Pointer provenance (tag).\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum Tag {\n-    Concrete(ConcreteTag),\n+    Concrete {\n+        alloc_id: AllocId,\n+        /// Stacked Borrows tag.\n+        sb: SbTag,\n+    },\n     Wildcard,\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct ConcreteTag {\n-    pub alloc_id: AllocId,\n-    /// Stacked Borrows tag.\n-    pub sb: SbTag,\n-}\n-\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(Pointer<Tag>, 24);\n // #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n@@ -160,15 +157,15 @@ impl Provenance for Tag {\n         write!(f, \"0x{:x}\", addr.bytes())?;\n \n         match tag {\n-            Tag::Concrete(tag) => {\n+            Tag::Concrete { alloc_id, sb } => {\n                 // Forward `alternate` flag to `alloc_id` printing.\n                 if f.alternate() {\n-                    write!(f, \"[{:#?}]\", tag.alloc_id)?;\n+                    write!(f, \"[{:#?}]\", alloc_id)?;\n                 } else {\n-                    write!(f, \"[{:?}]\", tag.alloc_id)?;\n+                    write!(f, \"[{:?}]\", alloc_id)?;\n                 }\n                 // Print Stacked Borrows tag.\n-                write!(f, \"{:?}\", tag.sb)?;\n+                write!(f, \"{:?}\", sb)?;\n             }\n             Tag::Wildcard => {\n                 write!(f, \"[Wildcard]\")?;\n@@ -180,7 +177,7 @@ impl Provenance for Tag {\n \n     fn get_alloc_id(self) -> Option<AllocId> {\n         match self {\n-            Tag::Concrete(concrete) => Some(concrete.alloc_id),\n+            Tag::Concrete { alloc_id, .. } => Some(alloc_id),\n             Tag::Wildcard => None,\n         }\n     }\n@@ -489,8 +486,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     type AllocExtra = AllocExtra;\n \n     type PointerTag = Tag;\n-    // `None` represents a wildcard pointer.\n-    type TagExtra = Option<SbTag>;\n+    type TagExtra = SbTagExtra;\n \n     type MemoryMap =\n         MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<Tag, Self::AllocExtra>)>;\n@@ -683,7 +679,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n             SbTag::Untagged\n         };\n         Pointer::new(\n-            Tag::Concrete(ConcreteTag { alloc_id: ptr.provenance, sb: sb_tag }),\n+            Tag::Concrete { alloc_id: ptr.provenance, sb: sb_tag },\n             Size::from_bytes(absolute_addr),\n         )\n     }\n@@ -709,7 +705,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         ptr: Pointer<Self::PointerTag>,\n     ) -> InterpResult<'tcx> {\n         match ptr.provenance {\n-            Tag::Concrete(ConcreteTag { alloc_id, sb }) => {\n+            Tag::Concrete { alloc_id, sb } => {\n                 intptrcast::GlobalStateInner::expose_ptr(ecx, alloc_id, sb);\n             }\n             Tag::Wildcard => {\n@@ -730,8 +726,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n         rel.map(|(alloc_id, size)| {\n             let sb = match ptr.provenance {\n-                Tag::Concrete(ConcreteTag { sb, .. }) => Some(sb),\n-                Tag::Wildcard => None,\n+                Tag::Concrete { sb, .. } => SbTagExtra::Concrete(sb),\n+                Tag::Wildcard => SbTagExtra::Wildcard,\n             };\n             (alloc_id, size, sb)\n         })"}, {"sha": "b7b339ce77bf07cc378f16b2eac6620e4d475994", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 152, "deletions": 75, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2", "patch": "@@ -3,6 +3,7 @@\n \n use log::trace;\n use std::cell::RefCell;\n+use std::cmp;\n use std::fmt;\n use std::num::NonZeroU64;\n \n@@ -60,6 +61,32 @@ impl fmt::Debug for SbTag {\n     }\n }\n \n+/// The \"extra\" information an SB pointer has over a regular AllocId.\n+/// Newtype for `Option<SbTag>`.\n+#[derive(Copy, Clone)]\n+pub enum SbTagExtra {\n+    Concrete(SbTag),\n+    Wildcard,\n+}\n+\n+impl fmt::Debug for SbTagExtra {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            SbTagExtra::Concrete(tag) => write!(f, \"{tag:?}\"),\n+            SbTagExtra::Wildcard => write!(f, \"<wildcard>\"),\n+        }\n+    }\n+}\n+\n+impl SbTagExtra {\n+    fn and_then<T>(self, f: impl FnOnce(SbTag) -> Option<T>) -> Option<T> {\n+        match self {\n+            SbTagExtra::Concrete(tag) => f(tag),\n+            SbTagExtra::Wildcard => None,\n+        }\n+    }\n+}\n+\n /// Indicates which permission is granted (by this item to some pointers)\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum Permission {\n@@ -108,6 +135,8 @@ pub struct Stack {\n     /// wildcard pointers are used to access this location. What we do know is that `borrows` are at\n     /// the top of the stack, and below it are arbitrarily many items whose `tag` is either\n     /// `Untagged` or strictly less than `id`.\n+    /// When the bottom is unknown, `borrows` always has a `SharedReadOnly` or `Unique` at the bottom;\n+    /// we never have the unknown-to-known boundary in an SRW group.\n     unknown_bottom: Option<PtrId>,\n }\n \n@@ -289,35 +318,37 @@ impl Permission {\n /// Core per-location operations: access, dealloc, reborrow.\n impl<'tcx> Stack {\n     /// Find the item granting the given kind of access to the given tag, and return where\n-    /// it is on the stack.\n-    /// `Ok(None)` indicates it matched the \"unknown\" part of the stack, or it was a wildcard tag\n-    /// and we have no clue what exactly it matched (but it could have matched something)\n+    /// it is on the stack. For wildcard tags, the given index is approximate, but if *no*\n+    /// index is given it means the match was *not* in the known part of the stack.\n+    /// `Ok(None)` indicates it matched the \"unknown\" part of the stack.\n     /// `Err` indicates it was not found.\n     fn find_granting(\n         &self,\n         access: AccessKind,\n-        tag: Option<SbTag>,\n+        tag: SbTagExtra,\n         exposed_tags: &FxHashSet<SbTag>,\n     ) -> Result<Option<usize>, ()> {\n-        let Some(tag) = tag else {\n+        let SbTagExtra::Concrete(tag) = tag else {\n             // Handle the wildcard case.\n             // Go search the stack for an exposed tag.\n-            let maybe_in_stack = self\n-                .borrows\n-                .iter()\n-                .rev() // search top-to-bottom\n-                .find_map(|item| {\n-                    // If the item fits and *might* be this wildcard, use it.\n-                    if item.perm.grants(access) && exposed_tags.contains(&item.tag) {\n-                        Some(())\n-                    } else {\n-                        None\n-                    }\n-                })\n-                .is_some();\n+            if let Some(idx) =\n+                self.borrows\n+                    .iter()\n+                    .enumerate() // we also need to know *where* in the stack\n+                    .rev() // search top-to-bottom\n+                    .find_map(|(idx, item)| {\n+                        // If the item fits and *might* be this wildcard, use it.\n+                        if item.perm.grants(access) && exposed_tags.contains(&item.tag) {\n+                            Some(idx)\n+                        } else {\n+                            None\n+                        }\n+                    })\n+            {\n+                return Ok(Some(idx));\n+            }\n             // If we couldn't find it in the stack, check the unknown bottom.\n-            let found = maybe_in_stack || self.unknown_bottom.is_some();\n-            return if found { Ok(None) } else { Err(()) };\n+            return if self.unknown_bottom.is_some() { Ok(None) } else { Err(()) };\n         };\n \n         if let Some(idx) =\n@@ -351,8 +382,10 @@ impl<'tcx> Stack {\n         match perm {\n             Permission::SharedReadOnly => bug!(\"Cannot use SharedReadOnly for writing\"),\n             Permission::Disabled => bug!(\"Cannot use Disabled for anything\"),\n-            // On a write, everything above us is incompatible.\n-            Permission::Unique => granting + 1,\n+            Permission::Unique => {\n+                // On a write, everything above us is incompatible.\n+                granting + 1\n+            }\n             Permission::SharedReadWrite => {\n                 // The SharedReadWrite *just* above us are compatible, to skip those.\n                 let mut idx = granting + 1;\n@@ -380,7 +413,7 @@ impl<'tcx> Stack {\n     /// currently checking.\n     fn check_protector(\n         item: &Item,\n-        provoking_access: Option<(SbTag, AllocRange, Size, AccessKind)>, // just for debug printing and error messages\n+        provoking_access: Option<(SbTagExtra, AllocRange, Size, AccessKind)>, // just for debug printing and error messages\n         global: &GlobalStateInner,\n         alloc_history: &mut AllocHistory,\n     ) -> InterpResult<'tcx> {\n@@ -401,12 +434,14 @@ impl<'tcx> Stack {\n                             tag, item\n                         ),\n                         None,\n-                        alloc_history.get_logs_relevant_to(\n-                            tag,\n-                            alloc_range,\n-                            offset,\n-                            Some(item.tag),\n-                        ),\n+                        tag.and_then(|tag| {\n+                            alloc_history.get_logs_relevant_to(\n+                                tag,\n+                                alloc_range,\n+                                offset,\n+                                Some(item.tag),\n+                            )\n+                        }),\n                     ))?\n                 } else {\n                     Err(err_sb_ub(\n@@ -427,7 +462,7 @@ impl<'tcx> Stack {\n     fn access(\n         &mut self,\n         access: AccessKind,\n-        tag: Option<SbTag>,\n+        tag: SbTagExtra,\n         (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &mut GlobalStateInner,\n         current_span: &mut CurrentSpan<'_, '_, 'tcx>,\n@@ -441,22 +476,22 @@ impl<'tcx> Stack {\n             alloc_history.access_error(access, tag, alloc_id, alloc_range, offset, self)\n         })?;\n \n-        let Some(granting_idx) = granting_idx else {\n-            // The access used a wildcard pointer or matched the unknown bottom.\n-            // Nobody knows what happened, so forget everything.\n-            trace!(\"access: clearing stack due to wildcard\");\n-            self.borrows.clear();\n-            self.unknown_bottom = Some(global.next_ptr_id);\n-            return Ok(());\n-        };\n-        let tag = tag.unwrap(); // only precise tags have precise locations\n-\n         // Step 2: Remove incompatible items above them.  Make sure we do not remove protected\n         // items.  Behavior differs for reads and writes.\n+        // In case of wildcards/unknown matches, we remove everything that is *definitely* gone.\n         if access == AccessKind::Write {\n             // Remove everything above the write-compatible items, like a proper stack. This makes sure read-only and unique\n             // pointers become invalid on write accesses (ensures F2a, and ensures U2 for write accesses).\n-            let first_incompatible_idx = self.find_first_write_incompatible(granting_idx);\n+            let first_incompatible_idx = if let Some(granting_idx) = granting_idx {\n+                // The granting_idx *might* be approximate, but any lower idx would remove more\n+                // things. Even if this is a Unique and the lower idx is an SRW (which removes\n+                // less), there is an SRW group boundary here so strictly more would get removed.\n+                self.find_first_write_incompatible(granting_idx)\n+            } else {\n+                // We are writing to something in the unknown part.\n+                // There is a SRW group boundary between the unknown and the known, so everything is incompatible.\n+                0\n+            };\n             for item in self.borrows.drain(first_incompatible_idx..).rev() {\n                 trace!(\"access: popping item {:?}\", item);\n                 Stack::check_protector(\n@@ -476,7 +511,13 @@ impl<'tcx> Stack {\n             // This pattern occurs a lot in the standard library: create a raw pointer, then also create a shared\n             // reference and use that.\n             // We *disable* instead of removing `Unique` to avoid \"connecting\" two neighbouring blocks of SRWs.\n-            let first_incompatible_idx = granting_idx + 1;\n+            let first_incompatible_idx = if let Some(granting_idx) = granting_idx {\n+                // The granting_idx *might* be approximate, but any lower idx would disable more things.\n+                granting_idx + 1\n+            } else {\n+                // We are reading from something in the unknown part. That means *all* `Unique` we know about are dead now.\n+                0\n+            };\n             for idx in (first_incompatible_idx..self.borrows.len()).rev() {\n                 let item = &mut self.borrows[idx];\n \n@@ -494,6 +535,31 @@ impl<'tcx> Stack {\n             }\n         }\n \n+        // If this was an approximate action, we now collapse everything into an unknown.\n+        if granting_idx.is_none() || matches!(tag, SbTagExtra::Wildcard) {\n+            // Compute the upper bound of the items that remain.\n+            // (This is why we did all the work above: to reduce the items we have to consider here.)\n+            let mut max = NonZeroU64::new(1).unwrap();\n+            for item in &self.borrows {\n+                // Skip disabled items, they cannot be matched anyway.\n+                if !matches!(item.perm, Permission::Disabled) {\n+                    if let SbTag::Tagged(tag) = item.tag {\n+                        // We are looking for a strict upper bound, so add 1 to this tag.\n+                        max = cmp::max(tag.checked_add(1).unwrap(), max);\n+                    }\n+                }\n+            }\n+            if let Some(unk) = self.unknown_bottom {\n+                max = cmp::max(unk, max);\n+            }\n+            // Use `max` as new strict upper bound for everything.\n+            trace!(\n+                \"access: forgetting stack to upper bound {max} due to wildcard or unknown access\"\n+            );\n+            self.borrows.clear();\n+            self.unknown_bottom = Some(max);\n+        }\n+\n         // Done.\n         Ok(())\n     }\n@@ -502,7 +568,7 @@ impl<'tcx> Stack {\n     /// active protectors at all because we will remove all items.\n     fn dealloc(\n         &mut self,\n-        tag: Option<SbTag>,\n+        tag: SbTagExtra,\n         (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &GlobalStateInner,\n         alloc_history: &mut AllocHistory,\n@@ -534,7 +600,7 @@ impl<'tcx> Stack {\n     /// `range` that we are currently checking.\n     fn grant(\n         &mut self,\n-        derived_from: Option<SbTag>,\n+        derived_from: SbTagExtra,\n         new: Item,\n         (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &mut GlobalStateInner,\n@@ -562,10 +628,12 @@ impl<'tcx> Stack {\n                 \"this case only makes sense for stack-like accesses\"\n             );\n \n-            let Some(granting_idx) = granting_idx else {\n+            let (Some(granting_idx), SbTagExtra::Concrete(_)) = (granting_idx, derived_from) else {\n                 // The parent is a wildcard pointer or matched the unknown bottom.\n-                // Nobody knows what happened, so forget everything.\n-                trace!(\"reborrow: clearing stack due to wildcard\");\n+                // This is approximate. Nobody knows what happened, so forget everything.\n+                // The new thing is SRW anyway, so we cannot push it \"on top of the unkown part\"\n+                // (for all we know, it might join an SRW group inside the unknown).\n+                trace!(\"reborrow: forgetting stack entirely due to SharedReadWrite reborrow from wildcard or unknown\");\n                 self.borrows.clear();\n                 self.unknown_bottom = Some(global.next_ptr_id);\n                 return Ok(());\n@@ -723,7 +791,7 @@ impl Stacks {\n     pub fn memory_read<'tcx>(\n         &self,\n         alloc_id: AllocId,\n-        tag: Option<SbTag>,\n+        tag: SbTagExtra,\n         range: AllocRange,\n         state: &GlobalState,\n         mut current_span: CurrentSpan<'_, '_, 'tcx>,\n@@ -752,7 +820,7 @@ impl Stacks {\n     pub fn memory_written<'tcx>(\n         &mut self,\n         alloc_id: AllocId,\n-        tag: Option<SbTag>,\n+        tag: SbTagExtra,\n         range: AllocRange,\n         state: &GlobalState,\n         mut current_span: CurrentSpan<'_, '_, 'tcx>,\n@@ -781,7 +849,7 @@ impl Stacks {\n     pub fn memory_deallocated<'tcx>(\n         &mut self,\n         alloc_id: AllocId,\n-        tag: Option<SbTag>,\n+        tag: SbTagExtra,\n         range: AllocRange,\n         state: &GlobalState,\n     ) -> InterpResult<'tcx> {\n@@ -798,14 +866,16 @@ impl Stacks {\n /// to grant for which references, and when to add protectors.\n impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    /// Returns the `AllocId` the reborrow was done in, if some actual borrow stack manipulation\n+    /// happened.\n     fn reborrow(\n         &mut self,\n         place: &MPlaceTy<'tcx, Tag>,\n         size: Size,\n         kind: RefKind,\n         new_tag: SbTag,\n         protect: bool,\n-    ) -> InterpResult<'tcx> {\n+    ) -> InterpResult<'tcx, Option<AllocId>> {\n         let this = self.eval_context_mut();\n         let current_span = &mut this.machine.current_span();\n \n@@ -815,6 +885,10 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                             base_offset,\n                             orig_tag|\n          -> InterpResult<'tcx> {\n+            let SbTagExtra::Concrete(orig_tag) = orig_tag else {\n+                // FIXME: should we log this?\n+                return Ok(())\n+            };\n             let extra = this.get_alloc_extra(alloc_id)?;\n             let stacked_borrows =\n                 extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n@@ -832,6 +906,13 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         };\n \n         if size == Size::ZERO {\n+            trace!(\n+                \"reborrow of size 0: {} reference {:?} derived from {:?} (pointee {})\",\n+                kind,\n+                new_tag,\n+                place.ptr,\n+                place.layout.ty,\n+            );\n             // Don't update any stacks for a zero-sized access; borrow stacks are per-byte and this\n             // touches no bytes so there is no stack to put this tag in.\n             // However, if the pointer for this operation points at a real allocation we still\n@@ -840,24 +921,14 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Dangling slices are a common case here; it's valid to get their length but with raw\n             // pointer tagging for example all calls to get_unchecked on them are invalid.\n             if let Ok((alloc_id, base_offset, orig_tag)) = this.ptr_try_get_alloc_id(place.ptr) {\n-                if let Some(orig_tag) = orig_tag {\n-                    log_creation(this, current_span, alloc_id, base_offset, orig_tag)?;\n-                }\n+                log_creation(this, current_span, alloc_id, base_offset, orig_tag)?;\n+                return Ok(Some(alloc_id));\n             }\n-\n-            trace!(\n-                \"reborrow of size 0: {} reference {:?} derived from {:?} (pointee {})\",\n-                kind,\n-                new_tag,\n-                place.ptr,\n-                place.layout.ty,\n-            );\n-            return Ok(());\n+            // This pointer doesn't come with an AllocId. :shrug:\n+            return Ok(None);\n         }\n         let (alloc_id, base_offset, orig_tag) = this.ptr_get_alloc_id(place.ptr)?;\n-        if let Some(orig_tag) = orig_tag {\n-            log_creation(this, current_span, alloc_id, base_offset, orig_tag)?;\n-        }\n+        log_creation(this, current_span, alloc_id, base_offset, orig_tag)?;\n \n         // Ensure we bail out if the pointer goes out-of-bounds (see miri#1050).\n         let (alloc_size, _) =\n@@ -937,7 +1008,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         )\n                     })\n                 })?;\n-                return Ok(());\n+                return Ok(Some(alloc_id));\n             }\n         };\n         // Here we can avoid `borrow()` calls because we have mutable references.\n@@ -962,7 +1033,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             )\n         })?;\n \n-        Ok(())\n+        Ok(Some(alloc_id))\n     }\n \n     /// Retags an indidual pointer, returning the retagged version.\n@@ -997,16 +1068,22 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         };\n \n         // Reborrow.\n-        this.reborrow(&place, size, kind, new_tag, protect)?;\n+        let alloc_id = this.reborrow(&place, size, kind, new_tag, protect)?;\n \n         // Adjust pointer.\n         let new_place = place.map_provenance(|p| {\n-            p.map(|t| {\n-                // TODO: Fix this eventually\n-                if let Tag::Concrete(t) = t {\n-                    Tag::Concrete(ConcreteTag { sb: new_tag, ..t })\n-                } else {\n-                    t\n+            p.map(|prov| {\n+                match alloc_id {\n+                    Some(alloc_id) => {\n+                        // If `reborrow` could figure out the AllocId of this ptr, hard-code it into the new one.\n+                        // Even if we started out with a wildcard, this newly retagged pointer is tied to that allocation.\n+                        Tag::Concrete { alloc_id, sb: new_tag }\n+                    }\n+                    None => {\n+                        // Looks like this has to stay a wildcard pointer.\n+                        assert!(matches!(prov, Tag::Wildcard));\n+                        Tag::Wildcard\n+                    }\n                 }\n             })\n         });"}, {"sha": "d3c706c1404ab1b01fb936cdb62f34020090fbef", "filename": "src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/src%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/src%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fdiagnostics.rs?ref=4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2", "patch": "@@ -4,12 +4,11 @@ use rustc_middle::mir::interpret::{AllocId, AllocRange};\n use rustc_span::{Span, SpanData};\n use rustc_target::abi::Size;\n \n-use core::fmt::Debug;\n-\n use crate::helpers::{CurrentSpan, HexRange};\n use crate::stacked_borrows::{err_sb_ub, AccessKind, Permission};\n use crate::Item;\n use crate::SbTag;\n+use crate::SbTagExtra;\n use crate::Stack;\n \n use rustc_middle::mir::interpret::InterpError;\n@@ -199,19 +198,15 @@ impl AllocHistory {\n     /// Report a descriptive error when `new` could not be granted from `derived_from`.\n     pub fn grant_error<'tcx>(\n         &self,\n-        derived_from: Option<SbTag>,\n+        derived_from: SbTagExtra,\n         new: Item,\n         alloc_id: AllocId,\n         alloc_range: AllocRange,\n         error_offset: Size,\n         stack: &Stack,\n     ) -> InterpError<'tcx> {\n-        // TODO: Fix this properly\n-        let z = &derived_from;\n-        let f = if let Some(ref t) = z { t as &dyn Debug } else { &\"<wildcard>\" as &dyn Debug };\n         let action = format!(\n-            \"trying to reborrow {:?} for {:?} permission at {}[{:#x}]\",\n-            f,\n+            \"trying to reborrow {derived_from:?} for {:?} permission at {}[{:#x}]\",\n             new.perm,\n             alloc_id,\n             error_offset.bytes(),\n@@ -229,18 +224,14 @@ impl AllocHistory {\n     pub fn access_error<'tcx>(\n         &self,\n         access: AccessKind,\n-        tag: Option<SbTag>,\n+        tag: SbTagExtra,\n         alloc_id: AllocId,\n         alloc_range: AllocRange,\n         error_offset: Size,\n         stack: &Stack,\n     ) -> InterpError<'tcx> {\n-        let z = &tag;\n-        let f = if let Some(ref t) = z { t as &dyn Debug } else { &\"<wildcard>\" as &dyn Debug };\n         let action = format!(\n-            \"attempting a {} using {:?} at {}[{:#x}]\",\n-            access,\n-            f,\n+            \"attempting a {access} using {tag:?} at {}[{:#x}]\",\n             alloc_id,\n             error_offset.bytes(),\n         );\n@@ -260,8 +251,8 @@ fn operation_summary(\n     format!(\"this error occurs as part of {} at {:?}{}\", operation, alloc_id, HexRange(alloc_range))\n }\n \n-fn error_cause(stack: &Stack, tag: Option<SbTag>) -> &'static str {\n-    if let Some(tag) = tag {\n+fn error_cause(stack: &Stack, tag: SbTagExtra) -> &'static str {\n+    if let SbTagExtra::Concrete(tag) = tag {\n         if stack.borrows.iter().any(|item| item.tag == tag && item.perm != Permission::Disabled) {\n             \", but that tag only grants SharedReadOnly permission for this location\"\n         } else {"}, {"sha": "ceeca61e5587a0c4d7882223c0eefca9b6c55099", "filename": "tests/fail/stacked_borrows/exposed_only_ro.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/tests%2Ffail%2Fstacked_borrows%2Fexposed_only_ro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/tests%2Ffail%2Fstacked_borrows%2Fexposed_only_ro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fexposed_only_ro.stderr?ref=4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2", "patch": "@@ -1,10 +1,10 @@\n-error: Undefined Behavior: attempting a write access using \"<wildcard>\" at ALLOC[0x0], but no exposed tags are valid in the borrow stack for this location\n+error: Undefined Behavior: attempting a write access using <wildcard> at ALLOC[0x0], but no exposed tags are valid in the borrow stack for this location\n   --> $DIR/exposed_only_ro.rs:LL:CC\n    |\n LL |     unsafe { *ptr = 0 };\n    |              ^^^^^^^^\n    |              |\n-   |              attempting a write access using \"<wildcard>\" at ALLOC[0x0], but no exposed tags are valid in the borrow stack for this location\n+   |              attempting a write access using <wildcard> at ALLOC[0x0], but no exposed tags are valid in the borrow stack for this location\n    |              this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental"}, {"sha": "61a5e05d34cd34251b915683b9f5fa8355502ae0", "filename": "tests/fail/stacked_borrows/illegal_read_despite_exposed1.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed1.rs?ref=4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2", "patch": "@@ -0,0 +1,17 @@\n+// compile-flags: -Zmiri-permissive-provenance\n+\n+fn main() {\n+    unsafe {\n+        let root = &mut 42;\n+        let addr = root as *mut i32 as usize;\n+        let exposed_ptr = addr as *mut i32;\n+        // From the exposed ptr, we get a new unique ptr.\n+        let root2 = &mut *exposed_ptr;\n+        let _fool = root2 as *mut _; // this would have fooled the old untagged pointer logic\n+        // Stack: Unknown(<N), Unique(N), SRW(N+1)\n+        // And we test that it has uniqueness by doing a conflicting write.\n+        *exposed_ptr = 0;\n+        // Stack: Unknown(<N)\n+        let _val = *root2; //~ ERROR: borrow stack\n+    }\n+}"}, {"sha": "fde135f752f7889324ae7f203d84e17122c88336", "filename": "tests/fail/stacked_borrows/illegal_read_despite_exposed1.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed1.stderr?ref=4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2", "patch": "@@ -0,0 +1,18 @@\n+error: Undefined Behavior: attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+  --> $DIR/illegal_read_despite_exposed1.rs:LL:CC\n+   |\n+LL |         let _val = *root2;\n+   |                    ^^^^^^\n+   |                    |\n+   |                    attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |                    this error occurs as part of an access at ALLOC[0x0..0x4]\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+           \n+   = note: inside `main` at $DIR/illegal_read_despite_exposed1.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "b45b7b5d285c2402ca476dbcc3d82e57c8dab3ad", "filename": "tests/fail/stacked_borrows/illegal_read_despite_exposed2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed2.rs?ref=4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2", "patch": "@@ -0,0 +1,18 @@\n+// compile-flags: -Zmiri-permissive-provenance\n+\n+fn main() {\n+    unsafe {\n+        let root = &mut 42;\n+        let addr = root as *mut i32 as usize;\n+        let exposed_ptr = addr as *mut i32;\n+        // From the exposed ptr, we get a new unique ptr.\n+        let root2 = &mut *exposed_ptr;\n+        // let _fool = root2 as *mut _; // this would [fool] us, since SRW(N+1) remains on the stack\n+        // Stack: Unknown(<N), Unique(N) [, SRW(N+1)]\n+        // And we test that it has uniqueness by doing a conflicting read.\n+        let _val = *exposed_ptr;\n+        // Stack: Unknown(<N), Disabled(N) [, SRW(N+1)]\n+        // collapsed to Unknown(<N) [Unknown(<N+2)]\n+        let _val = *root2; //~ ERROR: borrow stack\n+    }\n+}"}, {"sha": "947d9fd70a0d2046f972d3172463398da0f2d1a9", "filename": "tests/fail/stacked_borrows/illegal_read_despite_exposed2.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed2.stderr?ref=4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2", "patch": "@@ -0,0 +1,18 @@\n+error: Undefined Behavior: attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+  --> $DIR/illegal_read_despite_exposed2.rs:LL:CC\n+   |\n+LL |         let _val = *root2;\n+   |                    ^^^^^^\n+   |                    |\n+   |                    attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |                    this error occurs as part of an access at ALLOC[0x0..0x4]\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+           \n+   = note: inside `main` at $DIR/illegal_read_despite_exposed2.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "b50399b9df52177f875353e469dbe8f98eeff277", "filename": "tests/fail/stacked_borrows/illegal_write_despite_exposed1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/tests%2Ffail%2Fstacked_borrows%2Fillegal_write_despite_exposed1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/tests%2Ffail%2Fstacked_borrows%2Fillegal_write_despite_exposed1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write_despite_exposed1.rs?ref=4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2", "patch": "@@ -0,0 +1,16 @@\n+// compile-flags: -Zmiri-permissive-provenance\n+\n+fn main() {\n+    unsafe {\n+        let root = &mut 42;\n+        let addr = root as *mut i32 as usize;\n+        let exposed_ptr = addr as *mut i32;\n+        // From the exposed ptr, we get a new SRO ptr.\n+        let root2 = &*exposed_ptr;\n+        // Stack: Unknown(<N), SRO(N), SRO(N+1)\n+        // And we test that it is read-only by doing a conflicting write.\n+        *exposed_ptr = 0;\n+        // Stack: Unknown(<N)\n+        let _val = *root2; //~ ERROR: borrow stack\n+    }\n+}"}, {"sha": "ac96c9dac8d8402275b07b831d95b573a1e42cff", "filename": "tests/fail/stacked_borrows/illegal_write_despite_exposed1.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/tests%2Ffail%2Fstacked_borrows%2Fillegal_write_despite_exposed1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2/tests%2Ffail%2Fstacked_borrows%2Fillegal_write_despite_exposed1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write_despite_exposed1.stderr?ref=4fbb284a99d0eceeefcf7f7fdb5c6c545ea68ae2", "patch": "@@ -0,0 +1,18 @@\n+error: Undefined Behavior: attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+  --> $DIR/illegal_write_despite_exposed1.rs:LL:CC\n+   |\n+LL |         let _val = *root2;\n+   |                    ^^^^^^\n+   |                    |\n+   |                    attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |                    this error occurs as part of an access at ALLOC[0x0..0x4]\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+           \n+   = note: inside `main` at $DIR/illegal_write_despite_exposed1.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}]}