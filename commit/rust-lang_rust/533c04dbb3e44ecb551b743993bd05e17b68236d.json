{"sha": "533c04dbb3e44ecb551b743993bd05e17b68236d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzM2MwNGRiYjNlNDRlY2I1NTFiNzQzOTkzYmQwNWUxN2I2ODIzNmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-23T02:54:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-23T02:54:56Z"}, "message": "Auto merge of #36573 - jseyfried:groundwork, r=nrc\n\nresolve: groundwork for building the module graph during expansion\n\nr? @nrc", "tree": {"sha": "0be7efba11643371f201155a524cfc5747fdc3de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0be7efba11643371f201155a524cfc5747fdc3de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/533c04dbb3e44ecb551b743993bd05e17b68236d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/533c04dbb3e44ecb551b743993bd05e17b68236d", "html_url": "https://github.com/rust-lang/rust/commit/533c04dbb3e44ecb551b743993bd05e17b68236d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/533c04dbb3e44ecb551b743993bd05e17b68236d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a5d975fdcef451375df20e5ac234bb01e453e33", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a5d975fdcef451375df20e5ac234bb01e453e33", "html_url": "https://github.com/rust-lang/rust/commit/3a5d975fdcef451375df20e5ac234bb01e453e33"}, {"sha": "173d5b339f5d17dd9a6e7796d307fe97e2fdde8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/173d5b339f5d17dd9a6e7796d307fe97e2fdde8a", "html_url": "https://github.com/rust-lang/rust/commit/173d5b339f5d17dd9a6e7796d307fe97e2fdde8a"}], "stats": {"total": 358, "additions": 172, "deletions": 186}, "files": [{"sha": "b0a717e18f98d79796d0a19297e04e3f106e457f", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/533c04dbb3e44ecb551b743993bd05e17b68236d/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/533c04dbb3e44ecb551b743993bd05e17b68236d/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=533c04dbb3e44ecb551b743993bd05e17b68236d", "patch": "@@ -30,31 +30,20 @@ pub struct DefCollector<'ast> {\n }\n \n impl<'ast> DefCollector<'ast> {\n-    pub fn root(definitions: &'ast mut Definitions) -> DefCollector<'ast> {\n-        let mut collector = DefCollector {\n+    pub fn new(definitions: &'ast mut Definitions) -> DefCollector<'ast> {\n+        DefCollector {\n             hir_crate: None,\n             definitions: definitions,\n             parent_def: None,\n-        };\n-        let root = collector.create_def_with_parent(None, CRATE_NODE_ID, DefPathData::CrateRoot);\n-        assert_eq!(root, CRATE_DEF_INDEX);\n-        collector.parent_def = Some(root);\n-\n-        collector.create_def_with_parent(Some(CRATE_DEF_INDEX), DUMMY_NODE_ID, DefPathData::Misc);\n-\n-        collector\n+        }\n     }\n \n     pub fn extend(parent_node: NodeId,\n                   parent_def_path: DefPath,\n                   parent_def_id: DefId,\n                   definitions: &'ast mut Definitions)\n                   -> DefCollector<'ast> {\n-        let mut collector = DefCollector {\n-            hir_crate: None,\n-            parent_def: None,\n-            definitions: definitions,\n-        };\n+        let mut collector = DefCollector::new(definitions);\n \n         assert_eq!(parent_def_path.krate, parent_def_id.krate);\n         let root_path = Box::new(InlinedRootPath {\n@@ -68,17 +57,21 @@ impl<'ast> DefCollector<'ast> {\n         collector\n     }\n \n+    pub fn collect_root(&mut self) {\n+        let root = self.create_def_with_parent(None, CRATE_NODE_ID, DefPathData::CrateRoot);\n+        assert_eq!(root, CRATE_DEF_INDEX);\n+        self.parent_def = Some(root);\n+\n+        self.create_def_with_parent(Some(CRATE_DEF_INDEX), DUMMY_NODE_ID, DefPathData::Misc);\n+    }\n+\n     pub fn walk_item(&mut self, ii: &'ast InlinedItem, krate: &'ast hir::Crate) {\n         self.hir_crate = Some(krate);\n         ii.visit(self);\n     }\n \n-    fn parent_def(&self) -> Option<DefIndex> {\n-        self.parent_def\n-    }\n-\n     fn create_def(&mut self, node_id: NodeId, data: DefPathData) -> DefIndex {\n-        let parent_def = self.parent_def();\n+        let parent_def = self.parent_def;\n         debug!(\"create_def(node_id={:?}, data={:?}, parent_def={:?})\", node_id, data, parent_def);\n         self.definitions.create_def_with_parent(parent_def, node_id, data)\n     }"}, {"sha": "5cfb71f4fc877f81b5011eb2538296cb24bc4bb0", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/533c04dbb3e44ecb551b743993bd05e17b68236d/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/533c04dbb3e44ecb551b743993bd05e17b68236d/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=533c04dbb3e44ecb551b743993bd05e17b68236d", "patch": "@@ -225,7 +225,8 @@ impl Definitions {\n     }\n \n     pub fn collect(&mut self, krate: &ast::Crate) {\n-        let mut def_collector = DefCollector::root(self);\n+        let mut def_collector = DefCollector::new(self);\n+        def_collector.collect_root();\n         visit::walk_crate(&mut def_collector, krate);\n     }\n "}, {"sha": "18ce35237afcb8d3dcbf4c5fa04e6a1c2256174e", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/533c04dbb3e44ecb551b743993bd05e17b68236d/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/533c04dbb3e44ecb551b743993bd05e17b68236d/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=533c04dbb3e44ecb551b743993bd05e17b68236d", "patch": "@@ -643,7 +643,8 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n         macro_import::MacroLoader::new(sess, &cstore, crate_name, krate.config.clone());\n \n     let resolver_arenas = Resolver::arenas();\n-    let mut resolver = Resolver::new(sess, make_glob_map, &mut macro_loader, &resolver_arenas);\n+    let mut resolver =\n+        Resolver::new(sess, &krate, make_glob_map, &mut macro_loader, &resolver_arenas);\n     syntax_ext::register_builtins(&mut resolver, sess.features.borrow().quote);\n \n     krate = time(time_passes, \"expansion\", || {"}, {"sha": "3075e394869a5a35322555563ea5b7171314c12b", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 54, "deletions": 51, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/533c04dbb3e44ecb551b743993bd05e17b68236d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/533c04dbb3e44ecb551b743993bd05e17b68236d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=533c04dbb3e44ecb551b743993bd05e17b68236d", "patch": "@@ -14,10 +14,9 @@\n //! any imports resolved.\n \n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport};\n-use Module;\n+use {Module, ModuleS, ModuleKind};\n use Namespace::{self, TypeNS, ValueNS};\n use {NameBinding, NameBindingKind, ToNameBinding};\n-use ParentLink::{ModuleParentLink, BlockParentLink};\n use Resolver;\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n@@ -34,7 +33,7 @@ use syntax::parse::token;\n \n use syntax::ast::{Block, Crate};\n use syntax::ast::{ForeignItem, ForeignItemKind, Item, ItemKind};\n-use syntax::ast::{Mutability, StmtKind, TraitItemKind};\n+use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind};\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::parse::token::keywords;\n use syntax::visit::{self, Visitor};\n@@ -56,8 +55,6 @@ impl<'a> ToNameBinding<'a> for (Def, Span, ty::Visibility) {\n impl<'b> Resolver<'b> {\n     /// Constructs the reduced graph for the entire crate.\n     pub fn build_reduced_graph(&mut self, krate: &Crate) {\n-        let no_implicit_prelude = attr::contains_name(&krate.attrs, \"no_implicit_prelude\");\n-        self.graph_root.no_implicit_prelude.set(no_implicit_prelude);\n         visit::walk_crate(&mut BuildReducedGraphVisitor { resolver: self }, krate);\n     }\n \n@@ -196,22 +193,25 @@ impl<'b> Resolver<'b> {\n                         krate: crate_id,\n                         index: CRATE_DEF_INDEX,\n                     };\n-                    let parent_link = ModuleParentLink(parent, name);\n-                    let def = Def::Mod(def_id);\n-                    let module = self.new_extern_crate_module(parent_link, def, item.id);\n+                    let module = self.arenas.alloc_module(ModuleS {\n+                        extern_crate_id: Some(item.id),\n+                        populated: Cell::new(false),\n+                        ..ModuleS::new(Some(parent), ModuleKind::Def(Def::Mod(def_id), name))\n+                    });\n                     self.define(parent, name, TypeNS, (module, sp, vis));\n \n                     self.populate_module_if_necessary(module);\n                 }\n             }\n \n             ItemKind::Mod(..) => {\n-                let parent_link = ModuleParentLink(parent, name);\n                 let def = Def::Mod(self.definitions.local_def_id(item.id));\n-                let module = self.new_module(parent_link, Some(def), Some(item.id));\n-                module.no_implicit_prelude.set({\n-                    parent.no_implicit_prelude.get() ||\n+                let module = self.arenas.alloc_module(ModuleS {\n+                    no_implicit_prelude: parent.no_implicit_prelude || {\n                         attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n+                    },\n+                    normal_ancestor_id: Some(item.id),\n+                    ..ModuleS::new(Some(parent), ModuleKind::Def(def, name))\n                 });\n                 self.define(parent, name, TypeNS, (module, sp, vis));\n                 self.module_map.insert(item.id, module);\n@@ -244,9 +244,8 @@ impl<'b> Resolver<'b> {\n             }\n \n             ItemKind::Enum(ref enum_definition, _) => {\n-                let parent_link = ModuleParentLink(parent, name);\n                 let def = Def::Enum(self.definitions.local_def_id(item.id));\n-                let module = self.new_module(parent_link, Some(def), parent.normal_ancestor_id);\n+                let module = self.new_module(parent, ModuleKind::Def(def, name), true);\n                 self.define(parent, name, TypeNS, (module, sp, vis));\n \n                 for variant in &(*enum_definition).variants {\n@@ -293,40 +292,17 @@ impl<'b> Resolver<'b> {\n \n             ItemKind::DefaultImpl(..) | ItemKind::Impl(..) => {}\n \n-            ItemKind::Trait(.., ref items) => {\n+            ItemKind::Trait(..) => {\n                 let def_id = self.definitions.local_def_id(item.id);\n \n                 // Add all the items within to a new module.\n-                let parent_link = ModuleParentLink(parent, name);\n-                let def = Def::Trait(def_id);\n-                let module_parent =\n-                    self.new_module(parent_link, Some(def), parent.normal_ancestor_id);\n-                self.define(parent, name, TypeNS, (module_parent, sp, vis));\n-\n-                // Add the names of all the items to the trait info.\n-                for item in items {\n-                    let item_def_id = self.definitions.local_def_id(item.id);\n-                    let mut is_static_method = false;\n-                    let (def, ns) = match item.node {\n-                        TraitItemKind::Const(..) => (Def::AssociatedConst(item_def_id), ValueNS),\n-                        TraitItemKind::Method(ref sig, _) => {\n-                            is_static_method = !sig.decl.has_self();\n-                            (Def::Method(item_def_id), ValueNS)\n-                        }\n-                        TraitItemKind::Type(..) => (Def::AssociatedTy(item_def_id), TypeNS),\n-                        TraitItemKind::Macro(_) => panic!(\"unexpanded macro in resolve!\"),\n-                    };\n-\n-                    self.define(module_parent, item.ident.name, ns, (def, item.span, vis));\n-\n-                    self.trait_item_map.insert((item.ident.name, def_id), is_static_method);\n-                }\n+                let module =\n+                    self.new_module(parent, ModuleKind::Def(Def::Trait(def_id), name), true);\n+                self.define(parent, name, TypeNS, (module, sp, vis));\n+                self.current_module = module;\n             }\n             ItemKind::Mac(_) => panic!(\"unexpanded macro in resolve!\"),\n         }\n-\n-        visit::walk_item(&mut BuildReducedGraphVisitor { resolver: self }, item);\n-        self.current_module = parent;\n     }\n \n     // Constructs the reduced graph for one variant. Variants exist in the\n@@ -375,14 +351,10 @@ impl<'b> Resolver<'b> {\n                     {}\",\n                    block_id);\n \n-            let parent_link = BlockParentLink(parent, block_id);\n-            let new_module = self.new_module(parent_link, None, parent.normal_ancestor_id);\n+            let new_module = self.new_module(parent, ModuleKind::Block(block_id), true);\n             self.module_map.insert(block_id, new_module);\n             self.current_module = new_module; // Descend into the block.\n         }\n-\n-        visit::walk_block(&mut BuildReducedGraphVisitor { resolver: self }, block);\n-        self.current_module = parent;\n     }\n \n     /// Builds the reduced graph for a single item in an external crate.\n@@ -407,8 +379,7 @@ impl<'b> Resolver<'b> {\n             Def::Mod(_) | Def::Enum(..) => {\n                 debug!(\"(building reduced graph for external crate) building module {} {:?}\",\n                        name, vis);\n-                let parent_link = ModuleParentLink(parent, name);\n-                let module = self.new_module(parent_link, Some(def), None);\n+                let module = self.new_module(parent, ModuleKind::Def(def, name), false);\n                 let _ = self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n             }\n             Def::Variant(variant_id) => {\n@@ -451,8 +422,7 @@ impl<'b> Resolver<'b> {\n                     self.trait_item_map.insert((trait_item_name, def_id), false);\n                 }\n \n-                let parent_link = ModuleParentLink(parent, name);\n-                let module = self.new_module(parent_link, Some(def), None);\n+                let module = self.new_module(parent, ModuleKind::Def(def, name), false);\n                 let _ = self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n             }\n             Def::TyAlias(..) | Def::AssociatedTy(..) => {\n@@ -512,14 +482,47 @@ struct BuildReducedGraphVisitor<'a, 'b: 'a> {\n \n impl<'a, 'b> Visitor for BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_item(&mut self, item: &Item) {\n+        let parent = self.resolver.current_module;\n         self.resolver.build_reduced_graph_for_item(item);\n+        visit::walk_item(self, item);\n+        self.resolver.current_module = parent;\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n         self.resolver.build_reduced_graph_for_foreign_item(foreign_item);\n     }\n \n     fn visit_block(&mut self, block: &Block) {\n+        let parent = self.resolver.current_module;\n         self.resolver.build_reduced_graph_for_block(block);\n+        visit::walk_block(self, block);\n+        self.resolver.current_module = parent;\n+    }\n+\n+    fn visit_trait_item(&mut self, item: &TraitItem) {\n+        let parent = self.resolver.current_module;\n+        let def_id = parent.def_id().unwrap();\n+\n+        // Add the item to the trait info.\n+        let item_def_id = self.resolver.definitions.local_def_id(item.id);\n+        let mut is_static_method = false;\n+        let (def, ns) = match item.node {\n+            TraitItemKind::Const(..) => (Def::AssociatedConst(item_def_id), ValueNS),\n+            TraitItemKind::Method(ref sig, _) => {\n+                is_static_method = !sig.decl.has_self();\n+                (Def::Method(item_def_id), ValueNS)\n+            }\n+            TraitItemKind::Type(..) => (Def::AssociatedTy(item_def_id), TypeNS),\n+            TraitItemKind::Macro(_) => panic!(\"unexpanded macro in resolve!\"),\n+        };\n+\n+        self.resolver.trait_item_map.insert((item.ident.name, def_id), is_static_method);\n+\n+        let vis = ty::Visibility::Public;\n+        self.resolver.define(parent, item.ident.name, ns, (def, item.span, vis));\n+\n+        self.resolver.current_module = parent.parent.unwrap(); // nearest normal ancestor\n+        visit::walk_trait_item(self, item);\n+        self.resolver.current_module = parent;\n     }\n }"}, {"sha": "0d75685df55d09e456cf7fc0d97b88d01f69aa35", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 81, "deletions": 95, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/533c04dbb3e44ecb551b743993bd05e17b68236d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/533c04dbb3e44ecb551b743993bd05e17b68236d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=533c04dbb3e44ecb551b743993bd05e17b68236d", "patch": "@@ -41,7 +41,6 @@ use self::TypeParameters::*;\n use self::RibKind::*;\n use self::UseLexicalScopeFlag::*;\n use self::ModulePrefixResult::*;\n-use self::ParentLink::*;\n \n use rustc::hir::map::Definitions;\n use rustc::hir::{self, PrimTy, TyBool, TyChar, TyFloat, TyInt, TyUint, TyStr};\n@@ -61,6 +60,7 @@ use syntax::parse::token::{self, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use syntax::visit::{self, FnKind, Visitor};\n+use syntax::attr;\n use syntax::ast::{Arm, BindingMode, Block, Crate, Expr, ExprKind};\n use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n@@ -753,18 +753,15 @@ impl<'a> LexicalScopeBinding<'a> {\n     }\n }\n \n-/// The link from a module up to its nearest parent node.\n-#[derive(Clone,Debug)]\n-enum ParentLink<'a> {\n-    NoParentLink,\n-    ModuleParentLink(Module<'a>, Name),\n-    BlockParentLink(Module<'a>, NodeId),\n+enum ModuleKind {\n+    Block(NodeId),\n+    Def(Def, Name),\n }\n \n /// One node in the tree of modules.\n pub struct ModuleS<'a> {\n-    parent_link: ParentLink<'a>,\n-    def: Option<Def>,\n+    parent: Option<Module<'a>>,\n+    kind: ModuleKind,\n \n     // The node id of the closest normal module (`mod`) ancestor (including this module).\n     normal_ancestor_id: Option<NodeId>,\n@@ -775,7 +772,7 @@ pub struct ModuleS<'a> {\n \n     resolutions: RefCell<FnvHashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n \n-    no_implicit_prelude: Cell<bool>,\n+    no_implicit_prelude: bool,\n \n     glob_importers: RefCell<Vec<&'a ImportDirective<'a>>>,\n     globs: RefCell<Vec<&'a ImportDirective<'a>>>,\n@@ -792,19 +789,18 @@ pub struct ModuleS<'a> {\n pub type Module<'a> = &'a ModuleS<'a>;\n \n impl<'a> ModuleS<'a> {\n-    fn new(parent_link: ParentLink<'a>, def: Option<Def>, normal_ancestor_id: Option<NodeId>)\n-           -> Self {\n+    fn new(parent: Option<Module<'a>>, kind: ModuleKind) -> Self {\n         ModuleS {\n-            parent_link: parent_link,\n-            def: def,\n-            normal_ancestor_id: normal_ancestor_id,\n+            parent: parent,\n+            kind: kind,\n+            normal_ancestor_id: None,\n             extern_crate_id: None,\n             resolutions: RefCell::new(FnvHashMap()),\n-            no_implicit_prelude: Cell::new(false),\n+            no_implicit_prelude: false,\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new((Vec::new())),\n             traits: RefCell::new(None),\n-            populated: Cell::new(normal_ancestor_id.is_some()),\n+            populated: Cell::new(true),\n         }\n     }\n \n@@ -814,36 +810,36 @@ impl<'a> ModuleS<'a> {\n         }\n     }\n \n+    fn def(&self) -> Option<Def> {\n+        match self.kind {\n+            ModuleKind::Def(def, _) => Some(def),\n+            _ => None,\n+        }\n+    }\n+\n     fn def_id(&self) -> Option<DefId> {\n-        self.def.as_ref().map(Def::def_id)\n+        self.def().as_ref().map(Def::def_id)\n     }\n \n     // `self` resolves to the first module ancestor that `is_normal`.\n     fn is_normal(&self) -> bool {\n-        match self.def {\n-            Some(Def::Mod(_)) => true,\n+        match self.kind {\n+            ModuleKind::Def(Def::Mod(_), _) => true,\n             _ => false,\n         }\n     }\n \n     fn is_trait(&self) -> bool {\n-        match self.def {\n-            Some(Def::Trait(_)) => true,\n+        match self.kind {\n+            ModuleKind::Def(Def::Trait(_), _) => true,\n             _ => false,\n         }\n     }\n-\n-    fn parent(&self) -> Option<&'a Self> {\n-        match self.parent_link {\n-            ModuleParentLink(parent, _) | BlockParentLink(parent, _) => Some(parent),\n-            NoParentLink => None,\n-        }\n-    }\n }\n \n impl<'a> fmt::Debug for ModuleS<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{:?}\", self.def)\n+        write!(f, \"{:?}\", self.def())\n     }\n }\n \n@@ -903,7 +899,7 @@ impl<'a> NameBinding<'a> {\n     fn def(&self) -> Def {\n         match self.kind {\n             NameBindingKind::Def(def) => def,\n-            NameBindingKind::Module(module) => module.def.unwrap(),\n+            NameBindingKind::Module(module) => module.def().unwrap(),\n             NameBindingKind::Import { binding, .. } => binding.def(),\n             NameBindingKind::Ambiguity { .. } => Def::Err,\n         }\n@@ -1074,7 +1070,7 @@ pub struct Resolver<'a> {\n     macro_names: FnvHashSet<Name>,\n \n     // Maps the `Mark` of an expansion to its containing module or block.\n-    expansion_data: Vec<macros::ExpansionData>,\n+    expansion_data: FnvHashMap<u32, macros::ExpansionData>,\n }\n \n pub struct ResolverArenas<'a> {\n@@ -1111,7 +1107,7 @@ impl<'a> ResolverArenas<'a> {\n impl<'a> ty::NodeIdTree for Resolver<'a> {\n     fn is_descendant_of(&self, mut node: NodeId, ancestor: NodeId) -> bool {\n         while node != ancestor {\n-            node = match self.module_map[&node].parent() {\n+            node = match self.module_map[&node].parent {\n                 Some(parent) => parent.normal_ancestor_id.unwrap(),\n                 None => return false,\n             }\n@@ -1174,17 +1170,23 @@ impl Named for hir::PathSegment {\n \n impl<'a> Resolver<'a> {\n     pub fn new(session: &'a Session,\n+               krate: &Crate,\n                make_glob_map: MakeGlobMap,\n                macro_loader: &'a mut MacroLoader,\n                arenas: &'a ResolverArenas<'a>)\n                -> Resolver<'a> {\n-        let root_def_id = DefId::local(CRATE_DEF_INDEX);\n-        let graph_root =\n-            ModuleS::new(NoParentLink, Some(Def::Mod(root_def_id)), Some(CRATE_NODE_ID));\n-        let graph_root = arenas.alloc_module(graph_root);\n+        let root_def = Def::Mod(DefId::local(CRATE_DEF_INDEX));\n+        let graph_root = arenas.alloc_module(ModuleS {\n+            normal_ancestor_id: Some(CRATE_NODE_ID),\n+            no_implicit_prelude: attr::contains_name(&krate.attrs, \"no_implicit_prelude\"),\n+            ..ModuleS::new(None, ModuleKind::Def(root_def, keywords::Invalid.name()))\n+        });\n         let mut module_map = NodeMap();\n         module_map.insert(CRATE_NODE_ID, graph_root);\n \n+        let mut expansion_data = FnvHashMap();\n+        expansion_data.insert(0, macros::ExpansionData::default()); // Crate root expansion\n+\n         Resolver {\n             session: session,\n \n@@ -1240,7 +1242,7 @@ impl<'a> Resolver<'a> {\n \n             macro_loader: macro_loader,\n             macro_names: FnvHashSet(),\n-            expansion_data: vec![macros::ExpansionData::default()],\n+            expansion_data: expansion_data,\n         }\n     }\n \n@@ -1263,20 +1265,12 @@ impl<'a> Resolver<'a> {\n         self.report_errors();\n     }\n \n-    fn new_module(&self,\n-                  parent_link: ParentLink<'a>,\n-                  def: Option<Def>,\n-                  normal_ancestor_id: Option<NodeId>)\n-                  -> Module<'a> {\n-        self.arenas.alloc_module(ModuleS::new(parent_link, def, normal_ancestor_id))\n-    }\n-\n-    fn new_extern_crate_module(&self, parent_link: ParentLink<'a>, def: Def, local_node_id: NodeId)\n-                               -> Module<'a> {\n-        let mut module = ModuleS::new(parent_link, Some(def), Some(local_node_id));\n-        module.extern_crate_id = Some(local_node_id);\n-        module.populated.set(false);\n-        self.arenas.modules.alloc(module)\n+    fn new_module(&self, parent: Module<'a>, kind: ModuleKind, local: bool) -> Module<'a> {\n+        self.arenas.alloc_module(ModuleS {\n+            normal_ancestor_id: if local { self.current_module.normal_ancestor_id } else { None },\n+            populated: Cell::new(local),\n+            ..ModuleS::new(Some(parent), kind)\n+        })\n     }\n \n     fn get_ribs<'b>(&'b mut self, ns: Namespace) -> &'b mut Vec<Rib<'a>> {\n@@ -1336,11 +1330,10 @@ impl<'a> Resolver<'a> {\n                                        -> Option<Module<'a>> {\n             match this.resolve_name_in_module(module, needle, TypeNS, false, None) {\n                 Success(binding) if binding.is_extern_crate() => Some(module),\n-                _ => match module.parent_link {\n-                    ModuleParentLink(ref parent, _) => {\n-                        search_parent_externals(this, needle, parent)\n-                    }\n-                    _ => None,\n+                _ => if let (&ModuleKind::Def(..), Some(parent)) = (&module.kind, module.parent) {\n+                    search_parent_externals(this, needle, parent)\n+                } else {\n+                    None\n                 },\n             }\n         }\n@@ -1516,15 +1509,13 @@ impl<'a> Resolver<'a> {\n                     return Some(LexicalScopeBinding::Item(binding));\n                 }\n \n-                // We can only see through anonymous modules\n-                if module.def.is_some() {\n-                    return match self.prelude {\n-                        Some(prelude) if !module.no_implicit_prelude.get() => {\n-                            self.resolve_name_in_module(prelude, name, ns, false, None).success()\n-                                .map(LexicalScopeBinding::Item)\n-                        }\n-                        _ => None,\n-                    };\n+                if let ModuleKind::Block(..) = module.kind { // We can see through blocks\n+                } else if !module.no_implicit_prelude {\n+                    return self.prelude.and_then(|prelude| {\n+                        self.resolve_name_in_module(prelude, name, ns, false, None).success()\n+                    }).map(LexicalScopeBinding::Item)\n+                } else {\n+                    return None;\n                 }\n             }\n \n@@ -1561,7 +1552,7 @@ impl<'a> Resolver<'a> {\n         while i < module_path.len() && \"super\" == module_path[i].as_str() {\n             debug!(\"(resolving module prefix) resolving `super` at {}\",\n                    module_to_string(&containing_module));\n-            if let Some(parent) = containing_module.parent() {\n+            if let Some(parent) = containing_module.parent {\n                 containing_module = self.module_map[&parent.normal_ancestor_id.unwrap()];\n                 i += 1;\n             } else {\n@@ -2954,7 +2945,7 @@ impl<'a> Resolver<'a> {\n                                                                    UseLexicalScope,\n                                                                    Some(expr.span)) {\n                                         Success(e) => {\n-                                            if let Some(def_type) = e.def {\n+                                            if let Some(def_type) = e.def() {\n                                                 def = def_type;\n                                             }\n                                             context = UnresolvedNameContext::PathIsMod(parent);\n@@ -3163,16 +3154,13 @@ impl<'a> Resolver<'a> {\n             };\n             search_in_module(self, search_module);\n \n-            match search_module.parent_link {\n-                NoParentLink | ModuleParentLink(..) => {\n-                    if !search_module.no_implicit_prelude.get() {\n-                        self.prelude.map(|prelude| search_in_module(self, prelude));\n-                    }\n-                    break;\n-                }\n-                BlockParentLink(parent_module, _) => {\n-                    search_module = parent_module;\n+            if let ModuleKind::Block(..) = search_module.kind {\n+                search_module = search_module.parent.unwrap();\n+            } else {\n+                if !search_module.no_implicit_prelude {\n+                    self.prelude.map(|prelude| search_in_module(self, prelude));\n                 }\n+                break;\n             }\n         }\n \n@@ -3240,9 +3228,9 @@ impl<'a> Resolver<'a> {\n                 // collect submodules to explore\n                 if let Ok(module) = name_binding.module() {\n                     // form the path\n-                    let path_segments = match module.parent_link {\n-                        NoParentLink => path_segments.clone(),\n-                        ModuleParentLink(_, name) => {\n+                    let path_segments = match module.kind {\n+                        _ if module.parent.is_none() => path_segments.clone(),\n+                        ModuleKind::Def(_, name) => {\n                             let mut paths = path_segments.clone();\n                             let ident = ast::Ident::with_empty_ctxt(name);\n                             let params = PathParameters::none();\n@@ -3259,7 +3247,7 @@ impl<'a> Resolver<'a> {\n                     if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                         // add the module to the lookup\n                         let is_extern = in_module_is_extern || name_binding.is_extern_crate();\n-                        if !worklist.iter().any(|&(m, ..)| m.def == module.def) {\n+                        if !worklist.iter().any(|&(m, ..)| m.def() == module.def()) {\n                             worklist.push((module, path_segments, is_extern));\n                         }\n                     }\n@@ -3294,7 +3282,7 @@ impl<'a> Resolver<'a> {\n         let mut path_resolution = err_path_resolution();\n         let vis = match self.resolve_module_path(&segments, DontUseLexicalScope, Some(path.span)) {\n             Success(module) => {\n-                path_resolution = PathResolution::new(module.def.unwrap());\n+                path_resolution = PathResolution::new(module.def().unwrap());\n                 ty::Visibility::Restricted(module.normal_ancestor_id.unwrap())\n             }\n             Indeterminate => unreachable!(),\n@@ -3360,10 +3348,10 @@ impl<'a> Resolver<'a> {\n             return self.report_conflict(parent, name, ns, old_binding, binding);\n         }\n \n-        let container = match parent.def {\n-            Some(Def::Mod(_)) => \"module\",\n-            Some(Def::Trait(_)) => \"trait\",\n-            None => \"block\",\n+        let container = match parent.kind {\n+            ModuleKind::Def(Def::Mod(_), _) => \"module\",\n+            ModuleKind::Def(Def::Trait(_), _) => \"trait\",\n+            ModuleKind::Block(..) => \"block\",\n             _ => \"enum\",\n         };\n \n@@ -3510,17 +3498,15 @@ fn module_to_string(module: Module) -> String {\n     let mut names = Vec::new();\n \n     fn collect_mod(names: &mut Vec<ast::Name>, module: Module) {\n-        match module.parent_link {\n-            NoParentLink => {}\n-            ModuleParentLink(ref module, name) => {\n+        if let ModuleKind::Def(_, name) = module.kind {\n+            if let Some(parent) = module.parent {\n                 names.push(name);\n-                collect_mod(names, module);\n-            }\n-            BlockParentLink(ref module, _) => {\n-                // danger, shouldn't be ident?\n-                names.push(token::intern(\"<opaque>\"));\n-                collect_mod(names, module);\n+                collect_mod(names, parent);\n             }\n+        } else {\n+            // danger, shouldn't be ident?\n+            names.push(token::intern(\"<opaque>\"));\n+            collect_mod(names, module);\n         }\n     }\n     collect_mod(&mut names, module);"}, {"sha": "c9aa7d6a330184577c1342de8aafd24bc4220724", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/533c04dbb3e44ecb551b743993bd05e17b68236d/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/533c04dbb3e44ecb551b743993bd05e17b68236d/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=533c04dbb3e44ecb551b743993bd05e17b68236d", "patch": "@@ -47,7 +47,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion) {\n         expansion.visit_with(&mut ExpansionVisitor {\n-            current_module: self.expansion_data[mark.as_u32() as usize].module.clone(),\n+            current_module: self.expansion_data[&mark.as_u32()].module.clone(),\n             resolver: self,\n         });\n     }\n@@ -57,7 +57,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             self.macro_names.insert(ident.name);\n         }\n \n-        let mut module = self.expansion_data[scope.as_u32() as usize].module.clone();\n+        let mut module = self.expansion_data[&scope.as_u32()].module.clone();\n         while module.macros_escape {\n             module = module.parent.clone().unwrap();\n         }\n@@ -71,7 +71,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn find_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n         for i in 0..attrs.len() {\n             let name = intern(&attrs[i].name());\n-            match self.expansion_data[0].module.macros.borrow().get(&name) {\n+            match self.expansion_data[&0].module.macros.borrow().get(&name) {\n                 Some(ext) => match **ext {\n                     MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n                         return Some(attrs.remove(i))\n@@ -84,7 +84,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         None\n     }\n \n-    fn resolve_invoc(&mut self, invoc: &Invocation) -> Option<Rc<SyntaxExtension>> {\n+    fn resolve_invoc(&mut self, scope: Mark, invoc: &Invocation) -> Option<Rc<SyntaxExtension>> {\n         let (name, span) = match invoc.kind {\n             InvocationKind::Bang { ref mac, .. } => {\n                 let path = &mac.node.path;\n@@ -99,7 +99,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             InvocationKind::Attr { ref attr, .. } => (intern(&*attr.name()), attr.span),\n         };\n \n-        let mut module = self.expansion_data[invoc.mark().as_u32() as usize].module.clone();\n+        let mut module = self.expansion_data[&scope.as_u32()].module.clone();\n         loop {\n             if let Some(ext) = module.macros.borrow().get(&name) {\n                 return Some(ext.clone());\n@@ -137,8 +137,7 @@ struct ExpansionVisitor<'b, 'a: 'b> {\n \n impl<'a, 'b> ExpansionVisitor<'a, 'b> {\n     fn visit_invoc(&mut self, id: ast::NodeId) {\n-        assert_eq!(id.as_u32(), self.resolver.expansion_data.len() as u32);\n-        self.resolver.expansion_data.push(ExpansionData {\n+        self.resolver.expansion_data.insert(id.as_u32(), ExpansionData {\n             module: self.current_module.clone(),\n         });\n     }"}, {"sha": "ba45b773c09f36915174a4c5078e5da9bcbf0ef7", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/533c04dbb3e44ecb551b743993bd05e17b68236d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/533c04dbb3e44ecb551b743993bd05e17b68236d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=533c04dbb3e44ecb551b743993bd05e17b68236d", "patch": "@@ -733,7 +733,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         let module = directive.imported_module.get().unwrap();\n         self.populate_module_if_necessary(module);\n \n-        if let Some(Def::Trait(_)) = module.def {\n+        if let Some(Def::Trait(_)) = module.def() {\n             self.session.span_err(directive.span, \"items in traits are not importable.\");\n             return;\n         } else if module.def_id() == directive.parent.def_id()  {"}, {"sha": "71a1b4ac3b109c5e6df16cc8ec15ff1b7e357a0f", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/533c04dbb3e44ecb551b743993bd05e17b68236d/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/533c04dbb3e44ecb551b743993bd05e17b68236d/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=533c04dbb3e44ecb551b743993bd05e17b68236d", "patch": "@@ -667,7 +667,7 @@ pub trait Resolver {\n     fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>);\n \n     fn find_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n-    fn resolve_invoc(&mut self, invoc: &Invocation) -> Option<Rc<SyntaxExtension>>;\n+    fn resolve_invoc(&mut self, scope: Mark, invoc: &Invocation) -> Option<Rc<SyntaxExtension>>;\n }\n \n pub enum LoadedMacro {\n@@ -688,7 +688,9 @@ impl Resolver for DummyResolver {\n     fn add_expansions_at_stmt(&mut self, _id: ast::NodeId, _macros: Vec<Mark>) {}\n \n     fn find_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }\n-    fn resolve_invoc(&mut self, _invoc: &Invocation) -> Option<Rc<SyntaxExtension>> { None }\n+    fn resolve_invoc(&mut self, _scope: Mark, _invoc: &Invocation) -> Option<Rc<SyntaxExtension>> {\n+        None\n+    }\n }\n \n #[derive(Clone)]"}, {"sha": "a30109f0051bd247bec3a6f68ca7900cd6443123", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/533c04dbb3e44ecb551b743993bd05e17b68236d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/533c04dbb3e44ecb551b743993bd05e17b68236d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=533c04dbb3e44ecb551b743993bd05e17b68236d", "patch": "@@ -168,10 +168,6 @@ impl Invocation {\n             InvocationKind::Attr { ref attr, .. } => attr.span,\n         }\n     }\n-\n-    pub fn mark(&self) -> Mark {\n-        self.expansion_data.mark\n-    }\n }\n \n pub struct MacroExpander<'a, 'b:'a> {\n@@ -229,7 +225,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             let ExpansionData { depth, mark, .. } = invoc.expansion_data;\n             self.cx.current_expansion = invoc.expansion_data.clone();\n \n-            let expansion = match self.cx.resolver.resolve_invoc(&invoc) {\n+            let scope = if self.monotonic { mark } else { orig_expansion_data.mark };\n+            self.cx.current_expansion.mark = scope;\n+            let expansion = match self.cx.resolver.resolve_invoc(scope, &invoc) {\n                 Some(ext) => self.expand_invoc(invoc, ext),\n                 None => invoc.expansion_kind.dummy(invoc.span()),\n             };\n@@ -277,8 +275,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         };\n         self.cx.cfg = crate_config;\n \n-        let mark = self.cx.current_expansion.mark;\n-        self.cx.resolver.visit_expansion(mark, &result.0);\n+        if self.monotonic {\n+            let mark = self.cx.current_expansion.mark;\n+            self.cx.resolver.visit_expansion(mark, &result.0);\n+        }\n+\n         result\n     }\n \n@@ -338,7 +339,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n     /// Expand a macro invocation. Returns the result of expansion.\n     fn expand_bang_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n-        let (mark, kind) = (invoc.mark(), invoc.expansion_kind);\n+        let (mark, kind) = (invoc.expansion_data.mark, invoc.expansion_kind);\n         let (attrs, mac, ident, span) = match invoc.kind {\n             InvocationKind::Bang { attrs, mac, ident, span } => (attrs, mac, ident, span),\n             _ => unreachable!(),"}]}