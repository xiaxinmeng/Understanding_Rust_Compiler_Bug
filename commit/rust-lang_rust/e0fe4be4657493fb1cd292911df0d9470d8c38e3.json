{"sha": "e0fe4be4657493fb1cd292911df0d9470d8c38e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwZmU0YmU0NjU3NDkzZmIxY2QyOTI5MTFkZjBkOTQ3MGQ4YzM4ZTM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-01T10:11:38Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-07T03:59:56Z"}, "message": "syntax: cleanup associated const parsing.", "tree": {"sha": "226b9cc7ecfb48ed4e01546510bf9c47c55a426b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/226b9cc7ecfb48ed4e01546510bf9c47c55a426b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0fe4be4657493fb1cd292911df0d9470d8c38e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0fe4be4657493fb1cd292911df0d9470d8c38e3", "html_url": "https://github.com/rust-lang/rust/commit/e0fe4be4657493fb1cd292911df0d9470d8c38e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0fe4be4657493fb1cd292911df0d9470d8c38e3/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ac4809ccf5f77083ae7155dcc83e921341c2614", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ac4809ccf5f77083ae7155dcc83e921341c2614", "html_url": "https://github.com/rust-lang/rust/commit/4ac4809ccf5f77083ae7155dcc83e921341c2614"}], "stats": {"total": 71, "additions": 39, "deletions": 32}, "files": [{"sha": "6a832d5f3014ed75bd0160972a1c883ceed3affa", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 39, "deletions": 32, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e0fe4be4657493fb1cd292911df0d9470d8c38e3/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0fe4be4657493fb1cd292911df0d9470d8c38e3/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=e0fe4be4657493fb1cd292911df0d9470d8c38e3", "patch": "@@ -4,7 +4,7 @@ use crate::maybe_whole;\n use crate::ptr::P;\n use crate::ast::{\n     self, DUMMY_NODE_ID, Ident, Attribute, AttrStyle,\n-    Item, ItemKind, ImplItem, TraitItem, TraitItemKind,\n+    Item, ItemKind, ImplItem, ImplItemKind, TraitItem, TraitItemKind,\n     UseTree, UseTreeKind, PathSegment,\n     IsAuto, Constness, IsAsync, Unsafety, Defaultness,\n     Visibility, VisibilityKind, Mutability, FnDecl, FnHeader, MethodSig, Block,\n@@ -727,16 +727,7 @@ impl<'a> Parser<'a> {\n             };\n             (name, kind, generics)\n         } else if self.is_const_item() {\n-            // This parses the grammar:\n-            //     ImplItemConst = \"const\" Ident \":\" Ty \"=\" Expr \";\"\n-            self.expect_keyword(kw::Const)?;\n-            let name = self.parse_ident()?;\n-            self.expect(&token::Colon)?;\n-            let typ = self.parse_ty()?;\n-            self.expect(&token::Eq)?;\n-            let expr = self.parse_expr()?;\n-            self.expect(&token::Semi)?;\n-            (name, ast::ImplItemKind::Const(typ, expr), Generics::default())\n+            self.parse_impl_const()?\n         } else {\n             let (name, inner_attrs, generics, kind) = self.parse_impl_method(&vis, at_end)?;\n             attrs.extend(inner_attrs);\n@@ -785,12 +776,25 @@ impl<'a> Parser<'a> {\n             !self.is_keyword_ahead(1, &[kw::Fn, kw::Unsafe])\n     }\n \n+    /// This parses the grammar:\n+    ///     ImplItemConst = \"const\" Ident \":\" Ty \"=\" Expr \";\"\n+    fn parse_impl_const(&mut self) -> PResult<'a, (Ident, ImplItemKind, Generics)> {\n+        self.expect_keyword(kw::Const)?;\n+        let name = self.parse_ident()?;\n+        self.expect(&token::Colon)?;\n+        let typ = self.parse_ty()?;\n+        self.expect(&token::Eq)?;\n+        let expr = self.parse_expr()?;\n+        self.expect(&token::Semi)?;\n+        Ok((name, ImplItemKind::Const(typ, expr), Generics::default()))\n+    }\n+\n     /// Parses a method or a macro invocation in a trait impl.\n     fn parse_impl_method(\n         &mut self,\n         vis: &Visibility,\n         at_end: &mut bool\n-    ) -> PResult<'a, (Ident, Vec<Attribute>, Generics, ast::ImplItemKind)> {\n+    ) -> PResult<'a, (Ident, Vec<Attribute>, Generics, ImplItemKind)> {\n         // FIXME: code copied from `parse_macro_use_or_failure` -- use abstraction!\n         if let Some(mac) = self.parse_assoc_macro_invoc(\"impl\", Some(vis), at_end)? {\n             // method macro\n@@ -935,38 +939,28 @@ impl<'a> Parser<'a> {\n         Ok(item)\n     }\n \n-    fn parse_trait_item_(&mut self,\n-                         at_end: &mut bool,\n-                         mut attrs: Vec<Attribute>) -> PResult<'a, TraitItem> {\n+    fn parse_trait_item_(\n+        &mut self,\n+        at_end: &mut bool,\n+        mut attrs: Vec<Attribute>,\n+    ) -> PResult<'a, TraitItem> {\n         let lo = self.token.span;\n         self.eat_bad_pub();\n         let (name, kind, generics) = if self.eat_keyword(kw::Type) {\n             self.parse_trait_item_assoc_ty()?\n         } else if self.is_const_item() {\n-            self.expect_keyword(kw::Const)?;\n-            let ident = self.parse_ident()?;\n-            self.expect(&token::Colon)?;\n-            let ty = self.parse_ty()?;\n-            let default = if self.eat(&token::Eq) {\n-                let expr = self.parse_expr()?;\n-                self.expect(&token::Semi)?;\n-                Some(expr)\n-            } else {\n-                self.expect(&token::Semi)?;\n-                None\n-            };\n-            (ident, TraitItemKind::Const(ty, default), Generics::default())\n+            self.parse_trait_item_const()?\n         } else if let Some(mac) = self.parse_assoc_macro_invoc(\"trait\", None, &mut false)? {\n             // trait item macro.\n-            (Ident::invalid(), ast::TraitItemKind::Macro(mac), Generics::default())\n+            (Ident::invalid(), TraitItemKind::Macro(mac), Generics::default())\n         } else {\n             // This is somewhat dubious; We don't want to allow\n             // argument names to be left off if there is a definition...\n             //\n             // We don't allow argument names to be left off in edition 2018.\n             let (ident, sig, generics) = self.parse_method_sig(|t| t.span.rust_2018())?;\n             let body = self.parse_trait_method_body(at_end, &mut attrs)?;\n-            (ident, ast::TraitItemKind::Method(sig, body), generics)\n+            (ident, TraitItemKind::Method(sig, body), generics)\n         };\n \n         Ok(TraitItem {\n@@ -980,6 +974,20 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n+    fn parse_trait_item_const(&mut self) -> PResult<'a, (Ident, TraitItemKind, Generics)> {\n+        self.expect_keyword(kw::Const)?;\n+        let ident = self.parse_ident()?;\n+        self.expect(&token::Colon)?;\n+        let ty = self.parse_ty()?;\n+        let default = if self.eat(&token::Eq) {\n+            Some(self.parse_expr()?)\n+        } else {\n+            None\n+        };\n+        self.expect(&token::Semi)?;\n+        Ok((ident, TraitItemKind::Const(ty, default), Generics::default()))\n+    }\n+\n     /// Parse the \"body\" of a method in a trait item definition.\n     /// This can either be `;` when there's no body,\n     /// or e.g. a block when the method is a provided one.\n@@ -1020,8 +1028,7 @@ impl<'a> Parser<'a> {\n     /// Parses the following grammar:\n     ///\n     ///     TraitItemAssocTy = Ident [\"<\"...\">\"] [\":\" [GenericBounds]] [\"where\" ...] [\"=\" Ty]\n-    fn parse_trait_item_assoc_ty(&mut self)\n-        -> PResult<'a, (Ident, TraitItemKind, Generics)> {\n+    fn parse_trait_item_assoc_ty(&mut self) -> PResult<'a, (Ident, TraitItemKind, Generics)> {\n         let ident = self.parse_ident()?;\n         let mut generics = self.parse_generics()?;\n "}]}