{"sha": "adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkYjhiMGIyMzBkNWU1Yzc5YjRmODczODI1YjNkM2NmZjhkMWJjOGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-11T06:21:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-11T06:21:44Z"}, "message": "auto merge of #14006 : thestinger/rust/jemalloc, r=alexcrichton\n\nCloses #11807", "tree": {"sha": "770b50ee78ec3b79feeaf70f73f50f1166bed980", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/770b50ee78ec3b79feeaf70f73f50f1166bed980"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "html_url": "https://github.com/rust-lang/rust/commit/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11571cd9c1cde63c3b46ca65e608b84647785ac8", "url": "https://api.github.com/repos/rust-lang/rust/commits/11571cd9c1cde63c3b46ca65e608b84647785ac8", "html_url": "https://github.com/rust-lang/rust/commit/11571cd9c1cde63c3b46ca65e608b84647785ac8"}, {"sha": "81fadbbc4182c5a34e0d2ff698471abfc1ec0e33", "url": "https://api.github.com/repos/rust-lang/rust/commits/81fadbbc4182c5a34e0d2ff698471abfc1ec0e33", "html_url": "https://github.com/rust-lang/rust/commit/81fadbbc4182c5a34e0d2ff698471abfc1ec0e33"}], "stats": {"total": 787, "additions": 570, "deletions": 217}, "files": [{"sha": "d65c979a07409558257732a81cceb18743d1b3a5", "filename": ".gitattributes", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -8,4 +8,3 @@ src/etc/pkg/rust-logo.ico binary\n src/etc/pkg/rust-logo.png binary\n src/rt/msvc/* -whitespace\n src/rt/vg/* -whitespace\n-src/rt/jemalloc/**/* -whitespace"}, {"sha": "37dbb30c82a8f444aef99ce953007560a47db7b7", "filename": ".gitmodules", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -15,3 +15,6 @@\n [submodule \"src/rt/hoedown\"]\n \tpath = src/rt/hoedown\n \turl = https://github.com/rust-lang/hoedown.git\n+[submodule \"src/jemalloc\"]\n+\tpath = src/jemalloc\n+\turl = https://github.com/rust-lang/jemalloc.git"}, {"sha": "3ab71f762f236e6c7baa7010af3de0b184a68a72", "filename": "configure", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/configure", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -782,6 +782,7 @@ do\n   for s in 0 1 2 3\n   do\n     make_dir $t/rt/stage$s\n+    make_dir $t/rt/jemalloc\n     make_dir $t/rt/libuv\n     make_dir $t/rt/libuv/src/ares\n     make_dir $t/rt/libuv/src/eio"}, {"sha": "0437e08de28b6b4f3eba83fcbbc07f0ae8a48d2a", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -57,7 +57,7 @@ CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc\n \n DEPS_core :=\n-DEPS_std := core libc native:rustrt native:compiler-rt native:backtrace\n+DEPS_std := core libc native:rustrt native:compiler-rt native:backtrace native:jemalloc\n DEPS_green := std rand native:context_switch\n DEPS_rustuv := std native:uv native:uv_support\n DEPS_native := std"}, {"sha": "ecff34159da77274db3a53854242bb255f9b361b", "filename": "mk/platform.mk", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -145,6 +145,7 @@ CFG_LIB_NAME_x86_64-unknown-linux-gnu=lib$(1).so\n CFG_STATIC_LIB_NAME_x86_64-unknown-linux-gnu=lib$(1).a\n CFG_LIB_GLOB_x86_64-unknown-linux-gnu=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_x86_64-unknown-linux-gnu=lib$(1)-*.dylib.dSYM\n+CFG_CFLAGS_x86_64-unknown-linux-gnu := -m64\n CFG_GCCISH_CFLAGS_x86_64-unknown-linux-gnu := -Wall -Werror -g -fPIC -m64\n CFG_GCCISH_CXXFLAGS_x86_64-unknown-linux-gnu := -fno-rtti\n CFG_GCCISH_LINK_FLAGS_x86_64-unknown-linux-gnu := -shared -fPIC -ldl -pthread  -lrt -g -m64\n@@ -172,6 +173,7 @@ CFG_LIB_NAME_i686-unknown-linux-gnu=lib$(1).so\n CFG_STATIC_LIB_NAME_i686-unknown-linux-gnu=lib$(1).a\n CFG_LIB_GLOB_i686-unknown-linux-gnu=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_i686-unknown-linux-gnu=lib$(1)-*.dylib.dSYM\n+CFG_CFLAGS_i686-unknown-linux-gnu := -m32\n CFG_GCCISH_CFLAGS_i686-unknown-linux-gnu := -Wall -Werror -g -fPIC -m32\n CFG_GCCISH_CXXFLAGS_i686-unknown-linux-gnu := -fno-rtti\n CFG_GCCISH_LINK_FLAGS_i686-unknown-linux-gnu := -shared -fPIC -ldl -pthread  -lrt -g -m32\n@@ -201,6 +203,7 @@ AR_arm-apple-darwin = $(shell xcrun -find -sdk iphoneos ar)\n CFG_LIB_NAME_arm-apple-darwin = lib$(1).dylib\n CFG_LIB_GLOB_arm-apple-darwin = lib$(1)-*.dylib\n CFG_LIB_DSYM_GLOB_arm-apple-darwin = lib$(1)-*.dylib.dSYM\n+CFG_CFLAGS_arm-apple-darwin := $(CFG_IOS_FLAGS)\n CFG_GCCISH_CFLAGS_arm-apple-darwin := -Wall -Werror -g -fPIC $(CFG_IOS_FLAGS)\n CFG_GCCISH_CXXFLAGS_arm-apple-darwin := -fno-rtti $(CFG_IOS_FLAGS)\n CFG_GCCISH_LINK_FLAGS_arm-apple-darwin := -dynamiclib -lpthread -framework CoreServices -Wl,-no_compact_unwind\n@@ -229,6 +232,7 @@ CFG_LIB_NAME_x86_64-apple-darwin=lib$(1).dylib\n CFG_STATIC_LIB_NAME_x86_64-apple-darwin=lib$(1).a\n CFG_LIB_GLOB_x86_64-apple-darwin=lib$(1)-*.dylib\n CFG_LIB_DSYM_GLOB_x86_64-apple-darwin=lib$(1)-*.dylib.dSYM\n+CFG_CFLAGS_x86_64-apple-darwin := -m64 -arch x86_64\n CFG_GCCISH_CFLAGS_x86_64-apple-darwin := -Wall -Werror -g -fPIC -m64 -arch x86_64\n CFG_GCCISH_CXXFLAGS_x86_64-apple-darwin := -fno-rtti\n CFG_GCCISH_LINK_FLAGS_x86_64-apple-darwin := -dynamiclib -pthread  -framework CoreServices -m64\n@@ -256,6 +260,7 @@ CFG_LIB_NAME_i686-apple-darwin=lib$(1).dylib\n CFG_STATIC_LIB_NAME_i686-apple-darwin=lib$(1).a\n CFG_LIB_GLOB_i686-apple-darwin=lib$(1)-*.dylib\n CFG_LIB_DSYM_GLOB_i686-apple-darwin=lib$(1)-*.dylib.dSYM\n+CFG_CFLAGS_i686-apple-darwin := -m32 -arch i386\n CFG_GCCISH_CFLAGS_i686-apple-darwin := -Wall -Werror -g -fPIC -m32 -arch i386\n CFG_GCCISH_CXXFLAGS_i686-apple-darwin := -fno-rtti\n CFG_GCCISH_LINK_FLAGS_i686-apple-darwin := -dynamiclib -pthread  -framework CoreServices -m32\n@@ -283,6 +288,7 @@ CFG_LIB_NAME_arm-linux-androideabi=lib$(1).so\n CFG_STATIC_LIB_NAME_arm-linux-androideabi=lib$(1).a\n CFG_LIB_GLOB_arm-linux-androideabi=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_arm-linux-androideabi=lib$(1)-*.dylib.dSYM\n+CFG_CFLAGS_arm-linux-androideabi := -D__arm__ -DANDROID -D__ANDROID__\n CFG_GCCISH_CFLAGS_arm-linux-androideabi := -Wall -g -fPIC -D__arm__ -DANDROID -D__ANDROID__\n CFG_GCCISH_CXXFLAGS_arm-linux-androideabi := -fno-rtti\n CFG_GCCISH_LINK_FLAGS_arm-linux-androideabi := -shared -fPIC -ldl -g -lm -lsupc++\n@@ -313,6 +319,7 @@ CFG_LIB_NAME_arm-unknown-linux-gnueabihf=lib$(1).so\n CFG_STATIC_LIB_NAME_arm-unknown-linux-gnueabihf=lib$(1).a\n CFG_LIB_GLOB_arm-unknown-linux-gnueabihf=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_arm-unknown-linux-gnueabihf=lib$(1)-*.dylib.dSYM\n+CFG_CFLAGS_arm-unknown-linux-gnueabihf := -D__arm__\n CFG_GCCISH_CFLAGS_arm-unknown-linux-gnueabihf := -Wall -g -fPIC -D__arm__\n CFG_GCCISH_CXXFLAGS_arm-unknown-linux-gnueabihf := -fno-rtti\n CFG_GCCISH_LINK_FLAGS_arm-unknown-linux-gnueabihf := -shared -fPIC -g\n@@ -343,6 +350,7 @@ CFG_LIB_NAME_arm-unknown-linux-gnueabi=lib$(1).so\n CFG_STATIC_LIB_NAME_arm-unknown-linux-gnueabi=lib$(1).a\n CFG_LIB_GLOB_arm-unknown-linux-gnueabi=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_arm-unknown-linux-gnueabi=lib$(1)-*.dylib.dSYM\n+CFG_CFLAGS_arm-unknown-linux-gnueabi := -D__arm__ -mfpu=vfp\n CFG_GCCISH_CFLAGS_arm-unknown-linux-gnueabi := -Wall -g -fPIC -D__arm__ -mfpu=vfp\n CFG_GCCISH_CXXFLAGS_arm-unknown-linux-gnueabi := -fno-rtti\n CFG_GCCISH_LINK_FLAGS_arm-unknown-linux-gnueabi := -shared -fPIC -g\n@@ -372,6 +380,7 @@ CFG_LIB_NAME_mips-unknown-linux-gnu=lib$(1).so\n CFG_STATIC_LIB_NAME_mips-unknown-linux-gnu=lib$(1).a\n CFG_LIB_GLOB_mips-unknown-linux-gnu=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_mips-unknown-linux-gnu=lib$(1)-*.dylib.dSYM\n+CFG_CFLAGS_mips-unknown-linux-gnu := -mips32r2 -msoft-float -mabi=32 -mno-compact-eh\n CFG_GCCISH_CFLAGS_mips-unknown-linux-gnu := -Wall -g -fPIC -mips32r2 -msoft-float -mabi=32 -mno-compact-eh\n CFG_GCCISH_CXXFLAGS_mips-unknown-linux-gnu := -fno-rtti\n CFG_GCCISH_LINK_FLAGS_mips-unknown-linux-gnu := -shared -fPIC -g -mips32r2 -msoft-float -mabi=32\n@@ -400,6 +409,7 @@ CFG_LIB_NAME_i686-pc-mingw32=$(1).dll\n CFG_STATIC_LIB_NAME_i686-pc-mingw32=$(1).lib\n CFG_LIB_GLOB_i686-pc-mingw32=$(1)-*.dll\n CFG_LIB_DSYM_GLOB_i686-pc-mingw32=$(1)-*.dylib.dSYM\n+CFG_CFLAGS_mips-i686-pc-mingw32 := -m32 -march=i686 -D_WIN32_WINNT=0x0600\n CFG_GCCISH_CFLAGS_i686-pc-mingw32 := -Wall -Werror -g -m32 -march=i686 -D_WIN32_WINNT=0x0600 -I$(CFG_SRC_DIR)src/etc/mingw-fix-include\n CFG_GCCISH_CXXFLAGS_i686-pc-mingw32 := -fno-rtti\n CFG_GCCISH_LINK_FLAGS_i686-pc-mingw32 := -shared -fPIC -g -m32\n@@ -428,6 +438,7 @@ CFG_LIB_NAME_i586-mingw32msvc=$(1).dll\n CFG_STATIC_LIB_NAME_i586-mingw32msvc=$(1).lib\n CFG_LIB_GLOB_i586-mingw32msvc=$(1)-*.dll\n CFG_LIB_DSYM_GLOB_i586-mingw32msvc=$(1)-*.dylib.dSYM\n+CFG_CFLAGS_i586-mingw32msvc := -march=i586 -m32\n CFG_GCCISH_CFLAGS_i586-mingw32msvc := -Wall -Werror -g -march=i586 -m32\n CFG_GCCISH_CXXFLAGS_i586-mingw32msvc := -fno-rtti\n CFG_GCCISH_LINK_FLAGS_i586-mingw32msvc := -shared -g -m32\n@@ -458,6 +469,7 @@ CFG_LIB_NAME_i686-w64-mingw32=$(1).dll\n CFG_STATIC_LIB_NAME_i686-w64-mingw32=$(1).lib\n CFG_LIB_GLOB_i686-w64-mingw32=$(1)-*.dll\n CFG_LIB_DSYM_GLOB_i686-w64-mingw32=$(1)-*.dylib.dSYM\n+CFG_CFLAGS_i586-w64-mingw32 := -march=i586 -m32 -D_WIN32_WINNT=0x0600\n CFG_GCCISH_CFLAGS_i686-w64-mingw32 := -Wall -Werror -g -m32 -D_WIN32_WINNT=0x0600\n CFG_GCCISH_CXXFLAGS_i686-w64-mingw32 := -fno-rtti\n CFG_GCCISH_LINK_FLAGS_i686-w64-mingw32 := -shared -g -m32\n@@ -487,6 +499,7 @@ CFG_LIB_NAME_x86_64-w64-mingw32=$(1).dll\n CFG_STATIC_LIB_NAME_x86_64-w64-mingw32=$(1).lib\n CFG_LIB_GLOB_x86_64-w64-mingw32=$(1)-*.dll\n CFG_LIB_DSYM_GLOB_x86_64-w64-mingw32=$(1)-*.dylib.dSYM\n+CFG_CFLAGS_x86_64-w64-mingw32 := -m64 -D_WIN32_WINNT=0x0600\n CFG_GCCISH_CFLAGS_x86_64-w64-mingw32 := -Wall -Werror -g -m64 -D_WIN32_WINNT=0x0600\n CFG_GCCISH_CXXFLAGS_x86_64-w64-mingw32 := -fno-rtti\n CFG_GCCISH_LINK_FLAGS_x86_64-w64-mingw32 := -shared -g -m64\n@@ -515,6 +528,7 @@ CFG_LIB_NAME_x86_64-unknown-freebsd=lib$(1).so\n CFG_STATIC_LIB_NAME_x86_64-unknown-freebsd=lib$(1).a\n CFG_LIB_GLOB_x86_64-unknown-freebsd=lib$(1)-*.so\n CFG_LIB_DSYM_GLOB_x86_64-unknown-freebsd=$(1)-*.dylib.dSYM\n+CFG_CFLAGS_x86_64-unknown-freebsd := -I/usr/local/include\n CFG_GCCISH_CFLAGS_x86_64-unknown-freebsd := -Wall -Werror -g -fPIC -I/usr/local/include\n CFG_GCCISH_LINK_FLAGS_x86_64-unknown-freebsd := -shared -fPIC -g -pthread  -lrt\n CFG_GCCISH_DEF_FLAG_x86_64-unknown-freebsd := -Wl,--export-dynamic,--dynamic-list="}, {"sha": "b18b13c25c0de12b0f0f7ecad3e1d59e98d25d6d", "filename": "mk/rt.mk", "status": "modified", "additions": 48, "deletions": 4, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -122,10 +122,13 @@ $(foreach lib,$(NATIVE_LIBS),\t\t\t\t\t    \\\n ################################################################################\n # Building third-party targets with external build systems\n #\n-# The only current member of this section is libuv, but long ago this used to\n-# also be occupied by jemalloc. This location is meant for dependencies which\n-# have external build systems. It is still assumed that the output of each of\n-# these steps is a static library in the correct location.\n+# This location is meant for dependencies which have external build systems. It\n+# is still assumed that the output of each of these steps is a static library\n+# in the correct location.\n+################################################################################\n+\n+################################################################################\n+# libuv\n ################################################################################\n \n define DEF_LIBUV_ARCH_VAR\n@@ -154,13 +157,19 @@ define DEF_THIRD_PARTY_TARGETS\n \n ifeq ($$(CFG_WINDOWSY_$(1)), 1)\n   LIBUV_OSTYPE_$(1) := win\n+  # This isn't necessarily a desired option, but it's harmless and works around\n+  # what appears to be a mingw-w64 bug.\n+  #\n+  # https://sourceforge.net/p/mingw-w64/bugs/395/\n+  JEMALLOC_ARGS_$(1) := --enable-lazy-lock\n else ifeq ($(OSTYPE_$(1)), apple-darwin)\n   LIBUV_OSTYPE_$(1) := mac\n else ifeq ($(OSTYPE_$(1)), unknown-freebsd)\n   LIBUV_OSTYPE_$(1) := freebsd\n else ifeq ($(OSTYPE_$(1)), linux-androideabi)\n   LIBUV_OSTYPE_$(1) := android\n   LIBUV_ARGS_$(1) := PLATFORM=android host=android OS=linux\n+  JEMALLOC_ARGS_$(1) := --disable-tls\n else\n   LIBUV_OSTYPE_$(1) := linux\n endif\n@@ -220,6 +229,41 @@ $$(LIBUV_DIR_$(1))/Release/libuv.a: $$(LIBUV_DEPS) $$(LIBUV_MAKEFILE_$(1)) \\\n \n endif\n \n+################################################################################\n+# jemalloc\n+################################################################################\n+\n+ifdef CFG_ENABLE_FAST_MAKE\n+JEMALLOC_DEPS := $(S)/.gitmodules\n+else\n+JEMALLOC_DEPS := $(wildcard \\\n+\t\t   $(S)src/jemalloc/* \\\n+\t\t   $(S)src/jemalloc/*/* \\\n+\t\t   $(S)src/jemalloc/*/*/* \\\n+\t\t   $(S)src/jemalloc/*/*/*/*)\n+endif\n+\n+JEMALLOC_NAME_$(1) := $$(call CFG_STATIC_LIB_NAME_$(1),jemalloc)\n+ifeq ($$(CFG_WINDOWSY_$(1)),1)\n+  JEMALLOC_REAL_NAME_$(1) := $$(call CFG_STATIC_LIB_NAME_$(1),jemalloc_s)\n+else\n+  JEMALLOC_REAL_NAME_$(1) := $$(call CFG_STATIC_LIB_NAME_$(1),jemalloc_pic)\n+endif\n+JEMALLOC_LIB_$(1) := $$(RT_OUTPUT_DIR_$(1))/$$(JEMALLOC_NAME_$(1))\n+JEMALLOC_BUILD_DIR_$(1) := $$(RT_OUTPUT_DIR_$(1))/jemalloc\n+\n+$$(JEMALLOC_LIB_$(1)): $$(JEMALLOC_DEPS) $$(MKFILE_DEPS)\n+\t@$$(call E, make: jemalloc)\n+\tcd \"$$(JEMALLOC_BUILD_DIR_$(1))\"; \"$(S)src/jemalloc/configure\" \\\n+\t\t$$(JEMALLOC_ARGS_$(1)) --enable-cc-silence --with-jemalloc-prefix=je_ \\\n+\t\t--disable-experimental --build=$(CFG_BUILD) --host=$(1) \\\n+\t\tCC=\"$$(CC_$(1))\" \\\n+\t\tAR=\"$$(AR_$(1))\" \\\n+\t\tRANLIB=\"$$(AR_$(1)) s\" \\\n+\t\tEXTRA_CFLAGS=\"$$(CFG_CFLAGS_$(1))\"\n+\t$$(Q)$$(MAKE) -C \"$$(JEMALLOC_BUILD_DIR_$(1))\" build_lib_static\n+\t$$(Q)cp $$(JEMALLOC_BUILD_DIR_$(1))/lib/$$(JEMALLOC_REAL_NAME_$(1)) $$(JEMALLOC_LIB_$(1))\n+\n ################################################################################\n # compiler-rt\n ################################################################################"}, {"sha": "71d56d11a7346c21c62d911aa52e6b4bade9d7a6", "filename": "mk/tests.mk", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -240,6 +240,7 @@ ALL_HS := $(filter-out $(S)src/rt/vg/valgrind.h \\\n tidy:\n \t\t@$(call E, check: formatting)\n \t\t$(Q)find $(S)src -name '*.r[sc]' \\\n+\t\t| grep '^$(S)src/jemalloc' -v \\\n \t\t| grep '^$(S)src/libuv' -v \\\n \t\t| grep '^$(S)src/llvm' -v \\\n \t\t| grep '^$(S)src/gyp' -v \\\n@@ -264,8 +265,9 @@ tidy:\n \t\t$(Q)find $(S)src -type f -perm +111 \\\n \t\t    -not -name '*.rs' -and -not -name '*.py' \\\n \t\t    -and -not -name '*.sh' \\\n-\t\t| grep '^$(S)src/llvm' -v \\\n+\t\t| grep '^$(S)src/jemalloc' -v \\\n \t\t| grep '^$(S)src/libuv' -v \\\n+\t\t| grep '^$(S)src/llvm' -v \\\n \t\t| grep '^$(S)src/rt/hoedown' -v \\\n \t\t| grep '^$(S)src/gyp' -v \\\n \t\t| grep '^$(S)src/etc' -v \\"}, {"sha": "6a96910f2eaea6d2c705bb12379b23576b30d7d5", "filename": "src/jemalloc", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fjemalloc?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -0,0 +1 @@\n+Subproject commit 6a96910f2eaea6d2c705bb12379b23576b30d7d5"}, {"sha": "526b72e9b86acfd09aebd3ff04426bb4af876abe", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -33,10 +33,11 @@ use std::cmp;\n use std::intrinsics::{TyDesc, get_tydesc};\n use std::intrinsics;\n use std::mem;\n+use std::mem::min_align_of;\n use std::num;\n use std::ptr::read;\n use std::rc::Rc;\n-use std::rt::global_heap;\n+use std::rt::heap::exchange_malloc;\n \n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array\n@@ -204,7 +205,7 @@ impl Arena {\n     #[inline]\n     fn alloc_copy<'a, T>(&'a mut self, op: || -> T) -> &'a T {\n         unsafe {\n-            let ptr = self.alloc_copy_inner(mem::size_of::<T>(), mem::min_align_of::<T>());\n+            let ptr = self.alloc_copy_inner(mem::size_of::<T>(), min_align_of::<T>());\n             let ptr: *mut T = transmute(ptr);\n             mem::move_val_init(&mut (*ptr), op());\n             return transmute(ptr);\n@@ -261,7 +262,7 @@ impl Arena {\n         unsafe {\n             let tydesc = get_tydesc::<T>();\n             let (ty_ptr, ptr) =\n-                self.alloc_noncopy_inner(mem::size_of::<T>(), mem::min_align_of::<T>());\n+                self.alloc_noncopy_inner(mem::size_of::<T>(), min_align_of::<T>());\n             let ty_ptr: *mut uint = transmute(ty_ptr);\n             let ptr: *mut T = transmute(ptr);\n             // Write in our tydesc along with a bit indicating that it\n@@ -353,7 +354,29 @@ struct TypedArenaChunk<T> {\n }\n \n impl<T> TypedArenaChunk<T> {\n+    #[cfg(stage0)]\n     #[inline]\n+    fn new(next: Option<Box<TypedArenaChunk<T>>>, capacity: uint)\n+           -> Box<TypedArenaChunk<T>> {\n+        let mut size = mem::size_of::<TypedArenaChunk<T>>();\n+        size = round_up(size, min_align_of::<T>());\n+        let elem_size = mem::size_of::<T>();\n+        let elems_size = elem_size.checked_mul(&capacity).unwrap();\n+        size = size.checked_add(&elems_size).unwrap();\n+\n+        let mut chunk = unsafe {\n+            let chunk = exchange_malloc(size);\n+            let mut chunk: Box<TypedArenaChunk<T>> = cast::transmute(chunk);\n+            mem::move_val_init(&mut chunk.next, next);\n+            chunk\n+        };\n+\n+        chunk.capacity = capacity;\n+        chunk\n+    }\n+\n+    #[inline]\n+    #[cfg(not(stage0))]\n     fn new(next: Option<Box<TypedArenaChunk<T>>>, capacity: uint)\n            -> Box<TypedArenaChunk<T>> {\n         let mut size = mem::size_of::<TypedArenaChunk<T>>();\n@@ -363,7 +386,7 @@ impl<T> TypedArenaChunk<T> {\n         size = size.checked_add(&elems_size).unwrap();\n \n         let mut chunk = unsafe {\n-            let chunk = global_heap::exchange_malloc(size);\n+            let chunk = exchange_malloc(size, min_align_of::<TypedArenaChunk<T>>());\n             let mut chunk: Box<TypedArenaChunk<T>> = cast::transmute(chunk);\n             mem::move_val_init(&mut chunk.next, next);\n             chunk\n@@ -402,7 +425,7 @@ impl<T> TypedArenaChunk<T> {\n     fn start(&self) -> *u8 {\n         let this: *TypedArenaChunk<T> = self;\n         unsafe {\n-            cast::transmute(round_up(this.offset(1) as uint, mem::min_align_of::<T>()))\n+            cast::transmute(round_up(this.offset(1) as uint, min_align_of::<T>()))\n         }\n     }\n "}, {"sha": "1a222a27e4795dd5a0f76a6eb63c2d5d8debd61e", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -42,7 +42,7 @@ mod table {\n     use std::prelude::Drop;\n     use std::ptr;\n     use std::ptr::RawPtr;\n-    use std::rt::global_heap;\n+    use std::rt::libc_heap;\n     use std::intrinsics::{size_of, min_align_of, transmute};\n     use std::intrinsics::{move_val_init, set_memory};\n     use std::iter::{Iterator, range_step_inclusive};\n@@ -243,7 +243,7 @@ mod table {\n                     keys_size,   min_align_of::< K >(),\n                     vals_size,   min_align_of::< V >());\n \n-            let buffer = global_heap::malloc_raw(size) as *mut u8;\n+            let buffer = libc_heap::malloc_raw(size) as *mut u8;\n \n             // FIXME #13094: If malloc was not at as aligned as we expected,\n             // our offset calculations are just plain wrong. We could support"}, {"sha": "f199aa051d1663416c00d97c8f2be5944c98119e", "filename": "src/libcore/should_not_exist.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibcore%2Fshould_not_exist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibcore%2Fshould_not_exist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fshould_not_exist.rs?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -29,13 +29,30 @@ use str::StrSlice;\n \n #[allow(ctypes)]\n extern {\n-    fn malloc(size: uint) -> *u8;\n-    fn free(ptr: *u8);\n+    #[cfg(stage0)]\n+    fn rust_malloc(size: uint) -> *u8;\n+    #[cfg(not(stage0))]\n+    fn rust_malloc(size: uint, align: uint) -> *u8;\n+    fn rust_free(ptr: *u8, size: uint, align: uint);\n }\n \n+#[cfg(stage0)]\n unsafe fn alloc(cap: uint) -> *mut Vec<()> {\n     let cap = cap.checked_add(&mem::size_of::<Vec<()>>()).unwrap();\n-    let ret = malloc(cap) as *mut Vec<()>;\n+    let ret = rust_malloc(cap) as *mut Vec<()>;\n+    if ret.is_null() {\n+        intrinsics::abort();\n+    }\n+    (*ret).fill = 0;\n+    (*ret).alloc = cap;\n+    ret\n+}\n+\n+#[cfg(not(stage0))]\n+unsafe fn alloc(cap: uint) -> *mut Vec<()> {\n+    let cap = cap.checked_add(&mem::size_of::<Vec<()>>()).unwrap();\n+    // this should use the real alignment, but the new representation will take care of that\n+    let ret = rust_malloc(cap, 8) as *mut Vec<()>;\n     if ret.is_null() {\n         intrinsics::abort();\n     }\n@@ -102,7 +119,8 @@ impl FromIterator<char> for ~str {\n                     ptr::copy_nonoverlapping_memory(&mut (*ptr2).data,\n                                                     &(*ptr).data,\n                                                     len);\n-                    free(ptr as *u8);\n+                    // FIXME: #13994: port to the sized deallocation API when available\n+                    rust_free(ptr as *u8, 0, 8);\n                     cast::forget(ret);\n                     ret = cast::transmute(ptr2);\n                     ptr = ptr2;\n@@ -172,7 +190,7 @@ impl<A: Clone> Clone for ~[A] {\n                     for j in range(0, *i as int) {\n                         ptr::read(&*p.offset(j));\n                     }\n-                    free(ret as *u8);\n+                    rust_free(ret as *u8, 0, 8);\n                 });\n             cast::transmute(ret)\n         }"}, {"sha": "5fc9e506cf2677c4fb49d65deb9cd54a7189481a", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -339,7 +339,7 @@ pub fn mkdir(p: &CString, _mode: io::FilePermission) -> IoResult<()> {\n }\n \n pub fn readdir(p: &CString) -> IoResult<Vec<Path>> {\n-    use std::rt::global_heap::malloc_raw;\n+    use std::rt::libc_heap::malloc_raw;\n \n     fn prune(root: &CString, dirs: Vec<Path>) -> Vec<Path> {\n         let root = unsafe { CString::new(root.with_ref(|p| p), false) };"}, {"sha": "8f878f099fc41d4e1b5dd6aba4ee5321c9a36b17", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -345,15 +345,16 @@ fn require_alloc_fn(bcx: &Block, info_ty: ty::t, it: LangItem) -> ast::DefId {\n \n pub fn malloc_raw_dyn<'a>(bcx: &'a Block<'a>,\n                           ptr_ty: ty::t,\n-                          size: ValueRef)\n+                          size: ValueRef,\n+                          align: ValueRef)\n                           -> Result<'a> {\n     let _icx = push_ctxt(\"malloc_raw_exchange\");\n     let ccx = bcx.ccx();\n \n     // Allocate space:\n     let r = callee::trans_lang_call(bcx,\n         require_alloc_fn(bcx, ptr_ty, ExchangeMallocFnLangItem),\n-        [size],\n+        [size, align],\n         None);\n \n     let llty_ptr = type_of::type_of(ccx, ptr_ty);"}, {"sha": "463aa67ac90f58a136d8d442875c610caa4e252f", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -67,7 +67,7 @@ use middle::typeck::MethodCall;\n use util::common::indenter;\n use util::ppaux::Repr;\n use util::nodemap::NodeMap;\n-use middle::trans::machine::{llsize_of, llsize_of_alloc};\n+use middle::trans::machine::{llalign_of_min, llsize_of, llsize_of_alloc};\n use middle::trans::type_::Type;\n \n use syntax::ast;\n@@ -1170,10 +1170,11 @@ fn trans_uniq_expr<'a>(bcx: &'a Block<'a>,\n     let fcx = bcx.fcx;\n     let llty = type_of::type_of(bcx.ccx(), contents_ty);\n     let size = llsize_of(bcx.ccx(), llty);\n+    let align = C_uint(bcx.ccx(), llalign_of_min(bcx.ccx(), llty) as uint);\n     // We need to a make a pointer type because box_ty is ty_bot\n     // if content_ty is, e.g. box fail!().\n     let real_box_ty = ty::mk_uniq(bcx.tcx(), contents_ty);\n-    let Result { bcx, val } = malloc_raw_dyn(bcx, real_box_ty, size);\n+    let Result { bcx, val } = malloc_raw_dyn(bcx, real_box_ty, size, align);\n     // Unique boxes do not allocate for zero-size types. The standard library\n     // may assume that `free` is never called on the pointer returned for\n     // `Box<ZeroSizeType>`."}, {"sha": "48179abc052ec4ff50548bbdb575a24498e13b21", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -278,7 +278,9 @@ pub fn trans_uniq_vstore<'a>(bcx: &'a Block<'a>,\n \n     let vecsize = Add(bcx, alloc, llsize_of(ccx, ccx.opaque_vec_type));\n \n-    let Result { bcx: bcx, val: val } = malloc_raw_dyn(bcx, vec_ty, vecsize);\n+    // ~[T] is not going to be changed to support alignment, since it's obsolete.\n+    let align = C_uint(ccx, 8);\n+    let Result { bcx: bcx, val: val } = malloc_raw_dyn(bcx, vec_ty, vecsize, align);\n     Store(bcx, fill, GEPi(bcx, val, [0u, abi::vec_elt_fill]));\n     Store(bcx, alloc, GEPi(bcx, val, [0u, abi::vec_elt_alloc]));\n "}, {"sha": "6236fd0e0e56345882a71eeebeb989586d75e645", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -32,7 +32,7 @@\n use libc::{size_t, c_int, c_uint, c_void, c_char, c_double};\n use libc::{ssize_t, sockaddr, free, addrinfo};\n use libc;\n-use std::rt::global_heap::malloc_raw;\n+use std::rt::libc_heap::malloc_raw;\n \n #[cfg(test)]\n use libc::uintptr_t;"}, {"sha": "b33d211aa192849bf258182bb3bab41239e51bc7", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -81,7 +81,7 @@ use str::StrSlice;\n use str;\n use slice::{ImmutableVector, MutableVector};\n use slice;\n-use rt::global_heap::malloc_raw;\n+use rt::libc_heap::malloc_raw;\n use raw::Slice;\n \n /// The representation of a C String."}, {"sha": "8c2c4fd1f0be7e416f3eba768798574609fd988e", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -160,7 +160,7 @@ mod tests {\n     use super::CVec;\n     use libc;\n     use ptr;\n-    use rt::global_heap::malloc_raw;\n+    use rt::libc_heap::malloc_raw;\n \n     fn malloc(n: uint) -> CVec<u8> {\n         unsafe {"}, {"sha": "3f22a76c1f4e78ec9243f372c58099e882eaf568", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -110,6 +110,7 @@\n // Don't link to std. We are std.\n #![no_std]\n \n+#![allow(deprecated)]\n #![deny(missing_doc)]\n \n // When testing libstd, bring in libuv as the I/O backend so tests can print"}, {"sha": "e0fe75fd907101aa291ca6726c80c739eedec0b9", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -32,7 +32,8 @@ use ops::{Deref, Drop};\n use option::{Option, Some, None};\n use ptr;\n use ptr::RawPtr;\n-use rt::global_heap::exchange_free;\n+use mem::{min_align_of, size_of};\n+use rt::heap::exchange_free;\n \n struct RcBox<T> {\n     value: T,\n@@ -104,7 +105,8 @@ impl<T> Drop for Rc<T> {\n                     self.dec_weak();\n \n                     if self.weak() == 0 {\n-                        exchange_free(self.ptr as *u8)\n+                        exchange_free(self.ptr as *mut u8, size_of::<RcBox<T>>(),\n+                                      min_align_of::<RcBox<T>>())\n                     }\n                 }\n             }\n@@ -177,7 +179,8 @@ impl<T> Drop for Weak<T> {\n                 // the weak count starts at 1, and will only go to\n                 // zero if all the strong pointers have disappeared.\n                 if self.weak() == 0 {\n-                    exchange_free(self.ptr as *u8)\n+                    exchange_free(self.ptr as *mut u8, size_of::<RcBox<T>>(),\n+                                  min_align_of::<RcBox<T>>())\n                 }\n             }\n         }"}, {"sha": "7d54c3faf4241c07841574befcd3b7732f792cb8", "filename": "src/libstd/rt/global_heap.rs", "status": "removed", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/11571cd9c1cde63c3b46ca65e608b84647785ac8/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11571cd9c1cde63c3b46ca65e608b84647785ac8/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=11571cd9c1cde63c3b46ca65e608b84647785ac8", "patch": "@@ -1,139 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-//! The global (exchange) heap.\n-\n-use libc::{c_void, size_t, free, malloc, realloc};\n-use ptr::{RawPtr, mut_null};\n-use intrinsics::abort;\n-use raw;\n-use mem::size_of;\n-\n-#[inline]\n-pub fn get_box_size(body_size: uint, body_align: uint) -> uint {\n-    let header_size = size_of::<raw::Box<()>>();\n-    let total_size = align_to(header_size, body_align) + body_size;\n-    total_size\n-}\n-\n-// Rounds |size| to the nearest |alignment|. Invariant: |alignment| is a power\n-// of two.\n-#[inline]\n-fn align_to(size: uint, align: uint) -> uint {\n-    assert!(align != 0);\n-    (size + align - 1) & !(align - 1)\n-}\n-\n-/// A wrapper around libc::malloc, aborting on out-of-memory\n-#[inline]\n-pub unsafe fn malloc_raw(size: uint) -> *mut u8 {\n-    // `malloc(0)` may allocate, but it may also return a null pointer\n-    // http://pubs.opengroup.org/onlinepubs/9699919799/functions/malloc.html\n-    if size == 0 {\n-        mut_null()\n-    } else {\n-        let p = malloc(size as size_t);\n-        if p.is_null() {\n-            // we need a non-allocating way to print an error here\n-            abort();\n-        }\n-        p as *mut u8\n-    }\n-}\n-\n-/// A wrapper around libc::realloc, aborting on out-of-memory\n-#[inline]\n-pub unsafe fn realloc_raw(ptr: *mut u8, size: uint) -> *mut u8 {\n-    // `realloc(ptr, 0)` may allocate, but it may also return a null pointer\n-    // http://pubs.opengroup.org/onlinepubs/9699919799/functions/realloc.html\n-    if size == 0 {\n-        free(ptr as *mut c_void);\n-        mut_null()\n-    } else {\n-        let p = realloc(ptr as *mut c_void, size as size_t);\n-        if p.is_null() {\n-            // we need a non-allocating way to print an error here\n-            abort();\n-        }\n-        p as *mut u8\n-    }\n-}\n-\n-/// The allocator for unique pointers without contained managed pointers.\n-#[cfg(not(test))]\n-#[lang=\"exchange_malloc\"]\n-#[inline]\n-pub unsafe fn exchange_malloc(size: uint) -> *mut u8 {\n-    // The compiler never calls `exchange_free` on Box<ZeroSizeType>, so\n-    // zero-size allocations can point to this `static`. It would be incorrect\n-    // to use a null pointer, due to enums assuming types like unique pointers\n-    // are never null.\n-    static EMPTY: () = ();\n-\n-    if size == 0 {\n-        &EMPTY as *() as *mut u8\n-    } else {\n-        malloc_raw(size)\n-    }\n-}\n-\n-// FIXME: #7496\n-#[cfg(not(test))]\n-#[lang=\"closure_exchange_malloc\"]\n-#[inline]\n-pub unsafe fn closure_exchange_malloc_(drop_glue: fn(*mut u8), size: uint, align: uint) -> *u8 {\n-    closure_exchange_malloc(drop_glue, size, align)\n-}\n-\n-#[inline]\n-pub unsafe fn closure_exchange_malloc(drop_glue: fn(*mut u8), size: uint, align: uint) -> *u8 {\n-    let total_size = get_box_size(size, align);\n-    let p = malloc_raw(total_size);\n-\n-    let alloc = p as *mut raw::Box<()>;\n-    (*alloc).drop_glue = drop_glue;\n-\n-    alloc as *u8\n-}\n-\n-// NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n-// inside a landing pad may corrupt the state of the exception handler.\n-#[cfg(not(test))]\n-#[lang=\"exchange_free\"]\n-#[inline]\n-pub unsafe fn exchange_free_(ptr: *u8) {\n-    exchange_free(ptr)\n-}\n-\n-#[inline]\n-pub unsafe fn exchange_free(ptr: *u8) {\n-    free(ptr as *mut c_void);\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-    use self::test::Bencher;\n-\n-    #[bench]\n-    fn alloc_owned_small(b: &mut Bencher) {\n-        b.iter(|| {\n-            box 10\n-        })\n-    }\n-\n-    #[bench]\n-    fn alloc_owned_big(b: &mut Bencher) {\n-        b.iter(|| {\n-            box [10, ..1000]\n-        })\n-    }\n-}"}, {"sha": "ffe6dccfa15c5fc19faa07d98f4da374b4fd5881", "filename": "src/libstd/rt/heap.rs", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibstd%2Frt%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibstd%2Frt%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fheap.rs?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -0,0 +1,222 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// FIXME: #13994: port to the sized deallocation API when available\n+// FIXME: #13996: need a way to mark the `allocate` and `reallocate` return values as `noalias`\n+\n+use intrinsics::{abort, cttz32};\n+use libc::{c_int, c_void, size_t};\n+use ptr::RawPtr;\n+\n+#[link(name = \"jemalloc\", kind = \"static\")]\n+extern {\n+    fn je_mallocx(size: size_t, flags: c_int) -> *mut c_void;\n+    fn je_rallocx(ptr: *mut c_void, size: size_t, flags: c_int) -> *mut c_void;\n+    fn je_xallocx(ptr: *mut c_void, size: size_t, extra: size_t, flags: c_int) -> size_t;\n+    fn je_dallocx(ptr: *mut c_void, flags: c_int);\n+    fn je_nallocx(size: size_t, flags: c_int) -> size_t;\n+}\n+\n+// -lpthread needs to occur after -ljemalloc, the earlier argument isn't enough\n+#[cfg(not(windows), not(target_os = \"android\"))]\n+#[link(name = \"pthread\")]\n+extern {}\n+\n+// MALLOCX_ALIGN(a) macro\n+#[inline(always)]\n+fn mallocx_align(a: uint) -> c_int { unsafe { cttz32(a as u32) as c_int } }\n+\n+/// Return a pointer to `size` bytes of memory.\n+///\n+/// Behavior is undefined if the requested size is 0 or the alignment is not a power of 2. The\n+/// alignment must be no larger than the largest supported page size on the platform.\n+#[inline]\n+pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n+    let ptr = je_mallocx(size as size_t, mallocx_align(align)) as *mut u8;\n+    if ptr.is_null() {\n+        abort()\n+    }\n+    ptr\n+}\n+\n+/// Extend or shrink the allocation referenced by `ptr` to `size` bytes of memory.\n+///\n+/// Behavior is undefined if the requested size is 0 or the alignment is not a power of 2. The\n+/// alignment must be no larger than the largest supported page size on the platform.\n+///\n+/// The `old_size` and `align` parameters are the parameters that were used to create the\n+/// allocation referenced by `ptr`. The `old_size` parameter may also be the value returned by\n+/// `usable_size` for the requested size.\n+#[inline]\n+#[allow(unused_variable)] // for the parameter names in the documentation\n+pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint, old_size: uint) -> *mut u8 {\n+    let ptr = je_rallocx(ptr as *mut c_void, size as size_t, mallocx_align(align)) as *mut u8;\n+    if ptr.is_null() {\n+        abort()\n+    }\n+    ptr\n+}\n+\n+/// Extend or shrink the allocation referenced by `ptr` to `size` bytes of memory in-place.\n+///\n+/// Return true if successful, otherwise false if the allocation was not altered.\n+///\n+/// Behavior is undefined if the requested size is 0 or the alignment is not a power of 2. The\n+/// alignment must be no larger than the largest supported page size on the platform.\n+///\n+/// The `old_size` and `align` parameters are the parameters that were used to\n+/// create the allocation referenced by `ptr`. The `old_size` parameter may be\n+/// any value in range_inclusive(requested_size, usable_size).\n+#[inline]\n+#[allow(unused_variable)] // for the parameter names in the documentation\n+pub unsafe fn reallocate_inplace(ptr: *mut u8, size: uint, align: uint, old_size: uint) -> bool {\n+    je_xallocx(ptr as *mut c_void, size as size_t, 0, mallocx_align(align)) == size as size_t\n+}\n+\n+/// Deallocate the memory referenced by `ptr`.\n+///\n+/// The `ptr` parameter must not be null.\n+///\n+/// The `size` and `align` parameters are the parameters that were used to create the\n+/// allocation referenced by `ptr`. The `size` parameter may also be the value returned by\n+/// `usable_size` for the requested size.\n+#[inline]\n+#[allow(unused_variable)] // for the parameter names in the documentation\n+pub unsafe fn deallocate(ptr: *mut u8, size: uint, align: uint) {\n+    je_dallocx(ptr as *mut c_void, mallocx_align(align))\n+}\n+\n+/// Return the usable size of an allocation created with the specified the `size` and `align`.\n+#[inline]\n+pub fn usable_size(size: uint, align: uint) -> uint {\n+    unsafe { je_nallocx(size as size_t, mallocx_align(align)) as uint }\n+}\n+\n+/// The allocator for unique pointers.\n+#[cfg(stage0)]\n+#[lang=\"exchange_malloc\"]\n+#[inline(always)]\n+pub unsafe fn exchange_malloc_(size: uint) -> *mut u8 {\n+    exchange_malloc(size)\n+}\n+\n+/// The allocator for unique pointers.\n+#[cfg(not(test), not(stage0))]\n+#[lang=\"exchange_malloc\"]\n+#[inline(always)]\n+pub unsafe fn exchange_malloc_(size: uint, align: uint) -> *mut u8 {\n+    exchange_malloc(size, align)\n+}\n+\n+/// The allocator for unique pointers.\n+#[cfg(stage0)]\n+#[inline]\n+pub unsafe fn exchange_malloc(size: uint) -> *mut u8 {\n+    // The compiler never calls `exchange_free` on ~ZeroSizeType, so zero-size\n+    // allocations can point to this `static`. It would be incorrect to use a null\n+    // pointer, due to enums assuming types like unique pointers are never null.\n+    static EMPTY: () = ();\n+\n+    if size == 0 {\n+        &EMPTY as *() as *mut u8\n+    } else {\n+        allocate(size, 8)\n+    }\n+}\n+\n+/// The allocator for unique pointers.\n+#[cfg(not(stage0))]\n+#[inline]\n+pub unsafe fn exchange_malloc(size: uint, align: uint) -> *mut u8 {\n+    // The compiler never calls `exchange_free` on ~ZeroSizeType, so zero-size\n+    // allocations can point to this `static`. It would be incorrect to use a null\n+    // pointer, due to enums assuming types like unique pointers are never null.\n+    static EMPTY: () = ();\n+\n+    if size == 0 {\n+        &EMPTY as *() as *mut u8\n+    } else {\n+        allocate(size, align)\n+    }\n+}\n+\n+#[cfg(not(test))]\n+#[lang=\"exchange_free\"]\n+#[inline]\n+// FIXME: #13994 (rustc should pass align and size here)\n+pub unsafe fn exchange_free_(ptr: *mut u8) {\n+    exchange_free(ptr, 0, 8)\n+}\n+\n+#[inline]\n+pub unsafe fn exchange_free(ptr: *mut u8, size: uint, align: uint) {\n+    deallocate(ptr, size, align);\n+}\n+\n+// FIXME: #7496\n+#[cfg(not(test))]\n+#[lang=\"closure_exchange_malloc\"]\n+#[inline]\n+unsafe fn closure_exchange_malloc(drop_glue: fn(*mut u8), size: uint, align: uint) -> *mut u8 {\n+    let total_size = ::rt::util::get_box_size(size, align);\n+    let p = allocate(total_size, 8);\n+\n+    let alloc = p as *mut ::raw::Box<()>;\n+    (*alloc).drop_glue = drop_glue;\n+\n+    alloc as *mut u8\n+}\n+\n+// hack for libcore\n+#[no_mangle]\n+#[doc(hidden)]\n+#[deprecated]\n+#[cfg(stage0, not(test))]\n+pub extern \"C\" fn rust_malloc(size: uint) -> *mut u8 {\n+    unsafe { exchange_malloc(size) }\n+}\n+\n+// hack for libcore\n+#[no_mangle]\n+#[doc(hidden)]\n+#[deprecated]\n+#[cfg(not(stage0), not(test))]\n+pub extern \"C\" fn rust_malloc(size: uint, align: uint) -> *mut u8 {\n+    unsafe { exchange_malloc(size, align) }\n+}\n+\n+// hack for libcore\n+#[no_mangle]\n+#[doc(hidden)]\n+#[deprecated]\n+#[cfg(not(test))]\n+pub extern \"C\" fn rust_free(ptr: *mut u8, size: uint, align: uint) {\n+    unsafe { exchange_free(ptr, size, align) }\n+}\n+\n+#[cfg(test)]\n+mod bench {\n+    extern crate test;\n+    use self::test::Bencher;\n+\n+    #[bench]\n+    fn alloc_owned_small(b: &mut Bencher) {\n+        b.iter(|| {\n+            box 10\n+        })\n+    }\n+\n+    #[bench]\n+    fn alloc_owned_big(b: &mut Bencher) {\n+        b.iter(|| {\n+            box [10, ..1000]\n+        })\n+    }\n+}"}, {"sha": "ece51ab99893c9953eb5d4d9af897ba66cdd52be", "filename": "src/libstd/rt/libc_heap.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibstd%2Frt%2Flibc_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibstd%2Frt%2Flibc_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flibc_heap.rs?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+//! The global (exchange) heap.\n+\n+use libc::{c_void, size_t, free, malloc, realloc};\n+use ptr::{RawPtr, mut_null};\n+use intrinsics::abort;\n+\n+/// A wrapper around libc::malloc, aborting on out-of-memory\n+#[inline]\n+pub unsafe fn malloc_raw(size: uint) -> *mut u8 {\n+    // `malloc(0)` may allocate, but it may also return a null pointer\n+    // http://pubs.opengroup.org/onlinepubs/9699919799/functions/malloc.html\n+    if size == 0 {\n+        mut_null()\n+    } else {\n+        let p = malloc(size as size_t);\n+        if p.is_null() {\n+            // we need a non-allocating way to print an error here\n+            abort();\n+        }\n+        p as *mut u8\n+    }\n+}\n+\n+/// A wrapper around libc::realloc, aborting on out-of-memory\n+#[inline]\n+pub unsafe fn realloc_raw(ptr: *mut u8, size: uint) -> *mut u8 {\n+    // `realloc(ptr, 0)` may allocate, but it may also return a null pointer\n+    // http://pubs.opengroup.org/onlinepubs/9699919799/functions/realloc.html\n+    if size == 0 {\n+        free(ptr as *mut c_void);\n+        mut_null()\n+    } else {\n+        let p = realloc(ptr as *mut c_void, size as size_t);\n+        if p.is_null() {\n+            // we need a non-allocating way to print an error here\n+            abort();\n+        }\n+        p as *mut u8\n+    }\n+}"}, {"sha": "efc8072594bbfcf1d81a6275f0a6c4b412290875", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -12,12 +12,13 @@\n \n use cast;\n use iter::Iterator;\n+use libc::{c_void, free};\n use mem;\n use ops::Drop;\n use option::{Option, None, Some};\n use ptr;\n use ptr::RawPtr;\n-use rt::global_heap;\n+use rt::libc_heap;\n use rt::local::Local;\n use rt::task::Task;\n use raw;\n@@ -58,7 +59,7 @@ impl LocalHeap {\n \n     #[inline]\n     pub fn alloc(&mut self, drop_glue: fn(*mut u8), size: uint, align: uint) -> *mut Box {\n-        let total_size = global_heap::get_box_size(size, align);\n+        let total_size = ::rt::util::get_box_size(size, align);\n         let alloc = self.memory_region.malloc(total_size);\n         {\n             // Make sure that we can't use `mybox` outside of this scope\n@@ -187,7 +188,7 @@ impl MemoryRegion {\n     fn malloc(&mut self, size: uint) -> *mut Box {\n         let total_size = size + AllocHeader::size();\n         let alloc: *AllocHeader = unsafe {\n-            global_heap::malloc_raw(total_size) as *AllocHeader\n+            libc_heap::malloc_raw(total_size) as *AllocHeader\n         };\n \n         let alloc: &mut AllocHeader = unsafe { cast::transmute(alloc) };\n@@ -206,8 +207,7 @@ impl MemoryRegion {\n \n         let total_size = size + AllocHeader::size();\n         let alloc: *AllocHeader = unsafe {\n-            global_heap::realloc_raw(orig_alloc as *mut u8,\n-                                     total_size) as *AllocHeader\n+            libc_heap::realloc_raw(orig_alloc as *mut u8, total_size) as *AllocHeader\n         };\n \n         let alloc: &mut AllocHeader = unsafe { cast::transmute(alloc) };\n@@ -226,7 +226,7 @@ impl MemoryRegion {\n             self.release(cast::transmute(alloc));\n             rtassert!(self.live_allocations > 0);\n             self.live_allocations -= 1;\n-            global_heap::exchange_free(alloc as *u8)\n+            free(alloc as *mut c_void)\n         }\n     }\n "}, {"sha": "a04cbabedd6b4485165c0e116910641cf7128675", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -26,7 +26,7 @@ language and an implementation must be provided regardless of the\n execution environment.\n \n Of foremost importance is the global exchange heap, in the module\n-`global_heap`. Very little practical Rust code can be written without\n+`heap`. Very little practical Rust code can be written without\n access to the global heap. Unlike most of `rt` the global heap is\n truly a global resource and generally operates independently of the\n rest of the runtime.\n@@ -86,10 +86,13 @@ pub mod shouldnt_be_public {\n // Internal macros used by the runtime.\n mod macros;\n \n-// The global (exchange) heap.\n-pub mod global_heap;\n+/// Wrappers around malloc / realloc aborting on out-of-memory.\n+pub mod libc_heap;\n \n-// Implementations of language-critical runtime features like @.\n+/// The low-level memory allocation API.\n+pub mod heap;\n+\n+/// Implementations of language-critical runtime features like @.\n pub mod task;\n \n // The EventLoop and internal synchronous I/O interface."}, {"sha": "e8b1acb10241f331d970058695aeeb6810e0e437", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -26,6 +26,23 @@ use slice::ImmutableVector;\n // FIXME: Once the runtime matures remove the `true` below to turn off rtassert, etc.\n pub static ENFORCE_SANITY: bool = true || !cfg!(rtopt) || cfg!(rtdebug) || cfg!(rtassert);\n \n+#[deprecated]\n+#[doc(hidden)]\n+#[inline]\n+pub fn get_box_size(body_size: uint, body_align: uint) -> uint {\n+    let header_size = ::mem::size_of::<::raw::Box<()>>();\n+    let total_size = align_to(header_size, body_align) + body_size;\n+    total_size\n+}\n+\n+// Rounds |size| to the nearest |alignment|. Invariant: |alignment| is a power\n+// of two.\n+#[inline]\n+fn align_to(size: uint, align: uint) -> uint {\n+    assert!(align != 0);\n+    (size + align - 1) & !(align - 1)\n+}\n+\n /// Get the number of cores available\n pub fn num_cpus() -> uint {\n     unsafe {"}, {"sha": "b97c55ad70139a6957bca134bd1dc28318efd457", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 55, "deletions": 5, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -110,7 +110,7 @@ use ops::Drop;\n use option::{None, Option, Some};\n use ptr::RawPtr;\n use ptr;\n-use rt::global_heap::{exchange_free};\n+use rt::heap::{exchange_malloc, exchange_free};\n use unstable::finally::try_finally;\n use vec::Vec;\n \n@@ -292,9 +292,9 @@ pub trait CloneableVector<T> {\n impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n     /// Returns a copy of `v`.\n     #[inline]\n+    #[cfg(stage0)]\n     fn to_owned(&self) -> ~[T] {\n         use RawVec = core::raw::Vec;\n-        use rt::global_heap::{malloc_raw, exchange_free};\n         use num::{CheckedAdd, CheckedMul};\n         use option::Expect;\n \n@@ -305,7 +305,8 @@ impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n         let size = size.expect(\"overflow in to_owned()\");\n \n         unsafe {\n-            let ret = malloc_raw(size) as *mut RawVec<()>;\n+            // this should pass the real required alignment\n+            let ret = exchange_malloc(size) as *mut RawVec<()>;\n \n             (*ret).fill = len * mem::nonzero_size_of::<T>();\n             (*ret).alloc = len * mem::nonzero_size_of::<T>();\n@@ -329,7 +330,55 @@ impl<'a, T: Clone> CloneableVector<T> for &'a [T] {\n                     for j in range(0, *i as int) {\n                         ptr::read(&*p.offset(j));\n                     }\n-                    exchange_free(ret as *u8);\n+                    // FIXME: #13994 (should pass align and size here)\n+                    exchange_free(ret as *mut u8, 0, 8);\n+                });\n+            cast::transmute(ret)\n+        }\n+    }\n+\n+    /// Returns a copy of `v`.\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn to_owned(&self) -> ~[T] {\n+        use RawVec = core::raw::Vec;\n+        use num::{CheckedAdd, CheckedMul};\n+        use option::Expect;\n+\n+        let len = self.len();\n+        let data_size = len.checked_mul(&mem::size_of::<T>());\n+        let data_size = data_size.expect(\"overflow in to_owned()\");\n+        let size = mem::size_of::<RawVec<()>>().checked_add(&data_size);\n+        let size = size.expect(\"overflow in to_owned()\");\n+\n+        unsafe {\n+            // this should pass the real required alignment\n+            let ret = exchange_malloc(size, 8) as *mut RawVec<()>;\n+\n+            (*ret).fill = len * mem::nonzero_size_of::<T>();\n+            (*ret).alloc = len * mem::nonzero_size_of::<T>();\n+\n+            // Be careful with the following loop. We want it to be optimized\n+            // to a memcpy (or something similarly fast) when T is Copy. LLVM\n+            // is easily confused, so any extra operations during the loop can\n+            // prevent this optimization.\n+            let mut i = 0;\n+            let p = &mut (*ret).data as *mut _ as *mut T;\n+            try_finally(\n+                &mut i, (),\n+                |i, ()| while *i < len {\n+                    mem::move_val_init(\n+                        &mut(*p.offset(*i as int)),\n+                        self.unsafe_ref(*i).clone());\n+                    *i += 1;\n+                },\n+                |i| if *i < len {\n+                    // we must be failing, clean up after ourselves\n+                    for j in range(0, *i as int) {\n+                        ptr::read(&*p.offset(j));\n+                    }\n+                    // FIXME: #13994 (should pass align and size here)\n+                    exchange_free(ret as *mut u8, 0, 8);\n                 });\n             cast::transmute(ret)\n         }\n@@ -768,7 +817,8 @@ impl<T> Drop for MoveItems<T> {\n         // destroy the remaining elements\n         for _x in *self {}\n         unsafe {\n-            exchange_free(self.allocation as *u8)\n+            // FIXME: #13994 (should pass align and size here)\n+            exchange_free(self.allocation, 0, 8)\n         }\n     }\n }"}, {"sha": "c9d70915694e532ac4ee258f88bf66bd72df3e39", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -434,7 +434,7 @@ mod imp {\n \n #[cfg(windows)]\n mod imp {\n-    use rt::global_heap::malloc_raw;\n+    use rt::libc_heap::malloc_raw;\n     use libc::{HANDLE, BOOL, LPSECURITY_ATTRIBUTES, c_void, DWORD, LPCSTR};\n     use libc;\n     use ptr;"}, {"sha": "aa10be1d1be47a26f03894c8c72c89ae5578479d", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 61, "deletions": 28, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -12,23 +12,22 @@\n \n use cast::{forget, transmute};\n use clone::Clone;\n-use cmp::{Ord, Eq, Ordering, TotalEq, TotalOrd};\n+use cmp::{Ord, Eq, Ordering, TotalEq, TotalOrd, max};\n use container::{Container, Mutable};\n use default::Default;\n use fmt;\n use iter::{DoubleEndedIterator, FromIterator, Extendable, Iterator, range};\n-use libc::{free, c_void};\n-use mem::{size_of, move_val_init};\n+use mem::{min_align_of, move_val_init, size_of};\n use mem;\n use num;\n use num::{CheckedMul, CheckedAdd};\n use ops::{Add, Drop};\n use option::{None, Option, Some, Expect};\n use ptr::RawPtr;\n use ptr;\n-use rt::global_heap::{malloc_raw, realloc_raw};\n use raw::Slice;\n use RawVec = raw::Vec;\n+use rt::heap::{allocate, reallocate, deallocate};\n use slice::{ImmutableEqVector, ImmutableVector, Items, MutItems, MutableVector};\n use slice::{MutableTotalOrdVector, OwnedVector, Vector};\n use slice::{MutableVectorAllocating};\n@@ -92,11 +91,12 @@ impl<T> Vec<T> {\n     /// let vec: Vec<int> = Vec::with_capacity(10);\n     /// ```\n     pub fn with_capacity(capacity: uint) -> Vec<T> {\n+        if size_of::<T>() == 0 { return Vec { len: 0, cap: ::uint::MAX, ptr: 0 as *mut T } }\n         if capacity == 0 {\n             Vec::new()\n         } else {\n             let size = capacity.checked_mul(&size_of::<T>()).expect(\"capacity overflow\");\n-            let ptr = unsafe { malloc_raw(size) };\n+            let ptr = unsafe { allocate(size, min_align_of::<T>()) };\n             Vec { len: 0, cap: capacity, ptr: ptr as *mut T }\n         }\n     }\n@@ -401,6 +401,23 @@ impl<T> Container for Vec<T> {\n     }\n }\n \n+// FIXME: #13996: need a way to mark the return value as `noalias`\n+#[inline(never)]\n+unsafe fn alloc_or_realloc<T>(ptr: *mut T, size: uint, old_size: uint) -> *mut T {\n+    if old_size == 0 {\n+        allocate(size, min_align_of::<T>()) as *mut T\n+    } else {\n+        reallocate(ptr as *mut u8, size, min_align_of::<T>(), old_size) as *mut T\n+    }\n+}\n+\n+#[inline]\n+unsafe fn dealloc<T>(ptr: *mut T, len: uint) {\n+    if size_of::<T>() != 0 {\n+        deallocate(ptr as *mut u8, len * size_of::<T>(), min_align_of::<T>())\n+    }\n+}\n+\n impl<T> Vec<T> {\n     /// Returns the number of elements the vector can hold without\n     /// reallocating.\n@@ -477,33 +494,38 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec.capacity(), 11);\n     /// ```\n     pub fn reserve_exact(&mut self, capacity: uint) {\n+        if size_of::<T>() == 0 { return }\n         if capacity > self.cap {\n             let size = capacity.checked_mul(&size_of::<T>()).expect(\"capacity overflow\");\n-            self.cap = capacity;\n             unsafe {\n-                self.ptr = realloc_raw(self.ptr as *mut u8, size) as *mut T;\n+                self.ptr = alloc_or_realloc(self.ptr, size, self.cap * size_of::<T>());\n             }\n+            self.cap = capacity;\n         }\n     }\n \n-    /// Shrink the capacity of the vector to match the length\n+    /// Shrink the capacity of the vector as much as possible\n     ///\n     /// # Example\n     ///\n     /// ```rust\n     /// let mut vec = vec!(1, 2, 3);\n     /// vec.shrink_to_fit();\n-    /// assert_eq!(vec.capacity(), vec.len());\n     /// ```\n     pub fn shrink_to_fit(&mut self) {\n+        if size_of::<T>() == 0 { return }\n         if self.len == 0 {\n-            unsafe { free(self.ptr as *mut c_void) };\n-            self.cap = 0;\n-            self.ptr = 0 as *mut T;\n+            if self.cap != 0 {\n+                unsafe {\n+                    dealloc(self.ptr, self.cap)\n+                }\n+                self.cap = 0;\n+            }\n         } else {\n             unsafe {\n                 // Overflow check is unnecessary as the vector is already at least this large.\n-                self.ptr = realloc_raw(self.ptr as *mut u8, self.len * size_of::<T>()) as *mut T;\n+                self.ptr = reallocate(self.ptr as *mut u8, self.len * size_of::<T>(),\n+                                      min_align_of::<T>(), self.cap * size_of::<T>()) as *mut T;\n             }\n             self.cap = self.len;\n         }\n@@ -546,15 +568,20 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     pub fn push(&mut self, value: T) {\n+        if size_of::<T>() == 0 {\n+            // zero-size types consume no memory, so we can't rely on the address space running out\n+            self.len = self.len.checked_add(&1).expect(\"length overflow\");\n+            unsafe { forget(value); }\n+            return\n+        }\n         if self.len == self.cap {\n-            if self.cap == 0 { self.cap += 2 }\n             let old_size = self.cap * size_of::<T>();\n-            self.cap = self.cap * 2;\n-            let size = old_size * 2;\n+            let size = max(old_size, 2 * size_of::<T>()) * 2;\n             if old_size > size { fail!(\"capacity overflow\") }\n             unsafe {\n-                self.ptr = realloc_raw(self.ptr as *mut u8, size) as *mut T;\n+                self.ptr = alloc_or_realloc(self.ptr, size, self.cap * size_of::<T>());\n             }\n+            self.cap = max(self.cap, 2) * 2;\n         }\n \n         unsafe {\n@@ -638,9 +665,10 @@ impl<T> Vec<T> {\n     pub fn move_iter(self) -> MoveItems<T> {\n         unsafe {\n             let iter = transmute(self.as_slice().iter());\n-            let ptr = self.ptr as *mut c_void;\n+            let ptr = self.ptr;\n+            let cap = self.cap;\n             forget(self);\n-            MoveItems { allocation: ptr, iter: iter }\n+            MoveItems { allocation: ptr, cap: cap, iter: iter }\n         }\n     }\n \n@@ -1386,11 +1414,13 @@ impl<T> Drop for Vec<T> {\n     fn drop(&mut self) {\n         // This is (and should always remain) a no-op if the fields are\n         // zeroed (when moving out, because of #[unsafe_no_drop_flag]).\n-        unsafe {\n-            for x in self.as_mut_slice().iter() {\n-                ptr::read(x);\n+        if self.cap != 0 {\n+            unsafe {\n+                for x in self.as_mut_slice().iter() {\n+                    ptr::read(x);\n+                }\n+                dealloc(self.ptr, self.cap)\n             }\n-            free(self.ptr as *mut c_void)\n         }\n     }\n }\n@@ -1409,7 +1439,8 @@ impl<T:fmt::Show> fmt::Show for Vec<T> {\n \n /// An iterator that moves out of a vector.\n pub struct MoveItems<T> {\n-    allocation: *mut c_void, // the block of memory allocated for the vector\n+    allocation: *mut T, // the block of memory allocated for the vector\n+    cap: uint, // the capacity of the vector\n     iter: Items<'static, T>\n }\n \n@@ -1440,9 +1471,11 @@ impl<T> DoubleEndedIterator<T> for MoveItems<T> {\n impl<T> Drop for MoveItems<T> {\n     fn drop(&mut self) {\n         // destroy the remaining elements\n-        for _x in *self {}\n-        unsafe {\n-            free(self.allocation)\n+        if self.cap != 0 {\n+            for _x in *self {}\n+            unsafe {\n+                dealloc(self.allocation, self.cap);\n+            }\n         }\n     }\n }\n@@ -1493,7 +1526,7 @@ impl<T> FromVec<T> for ~[T] {\n         let vp = v.as_mut_ptr();\n \n         unsafe {\n-            let ret = malloc_raw(size) as *mut RawVec<()>;\n+            let ret = allocate(size, 8) as *mut RawVec<()>;\n \n             (*ret).fill = len * mem::nonzero_size_of::<T>();\n             (*ret).alloc = len * mem::nonzero_size_of::<T>();"}, {"sha": "226eb7afb5f801f4d44cd809ff484540e3543db3", "filename": "src/libsync/arc.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f/src%2Flibsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Farc.rs?ref=adb8b0b230d5e5c79b4f873825b3d3cff8d1bc8f", "patch": "@@ -15,8 +15,9 @@\n \n use std::cast;\n use std::ptr;\n-use std::rt::global_heap;\n+use std::rt::heap::exchange_free;\n use std::sync::atomics;\n+use std::mem::{min_align_of, size_of};\n \n /// An atomically reference counted wrapper for shared state.\n ///\n@@ -190,7 +191,8 @@ impl<T: Share + Send> Drop for Arc<T> {\n \n         if self.inner().weak.fetch_sub(1, atomics::Release) == 1 {\n             atomics::fence(atomics::Acquire);\n-            unsafe { global_heap::exchange_free(self.x as *u8) }\n+            unsafe { exchange_free(self.x as *mut u8, size_of::<ArcInner<T>>(),\n+                                   min_align_of::<ArcInner<T>>()) }\n         }\n     }\n }\n@@ -240,7 +242,8 @@ impl<T: Share + Send> Drop for Weak<T> {\n         // the memory orderings\n         if self.inner().weak.fetch_sub(1, atomics::Release) == 1 {\n             atomics::fence(atomics::Acquire);\n-            unsafe { global_heap::exchange_free(self.x as *u8) }\n+            unsafe { exchange_free(self.x as *mut u8, size_of::<ArcInner<T>>(),\n+                                   min_align_of::<ArcInner<T>>()) }\n         }\n     }\n }"}]}