{"sha": "937001a1f8a05a07b16233bcfdf53d9d3381e45c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzNzAwMWExZjhhMDVhMDdiMTYyMzNiY2ZkZjUzZDlkMzM4MWU0NWM=", "commit": {"author": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-17T19:27:48Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:03:29Z"}, "message": "Refactor Callee::call to take bcx by-reference.\n\nAlso change to not return anything; nothing used the return ValueRef.\n\nInlines with_cond.", "tree": {"sha": "58ff997cdefcce756cd47e77cd2871535e69eadf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58ff997cdefcce756cd47e77cd2871535e69eadf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/937001a1f8a05a07b16233bcfdf53d9d3381e45c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/937001a1f8a05a07b16233bcfdf53d9d3381e45c", "html_url": "https://github.com/rust-lang/rust/commit/937001a1f8a05a07b16233bcfdf53d9d3381e45c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/937001a1f8a05a07b16233bcfdf53d9d3381e45c/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a198534e25516ae071357a3187e650d9b07ea8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a198534e25516ae071357a3187e650d9b07ea8b", "html_url": "https://github.com/rust-lang/rust/commit/9a198534e25516ae071357a3187e650d9b07ea8b"}], "stats": {"total": 121, "additions": 46, "deletions": 75}, "files": [{"sha": "aefdfee9d8cd003e11830c55bf459eff6d41649f", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/937001a1f8a05a07b16233bcfdf53d9d3381e45c/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/937001a1f8a05a07b16233bcfdf53d9d3381e45c/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=937001a1f8a05a07b16233bcfdf53d9d3381e45c", "patch": "@@ -480,24 +480,6 @@ pub fn to_immediate(bcx: &BlockAndBuilder, val: ValueRef, ty: Ty) -> ValueRef {\n     }\n }\n \n-pub fn with_cond<'blk, 'tcx, F>(\n-    bcx: BlockAndBuilder<'blk, 'tcx>, val: ValueRef, f: F\n-) -> BlockAndBuilder<'blk, 'tcx>\n-    where F: FnOnce(BlockAndBuilder<'blk, 'tcx>) -> BlockAndBuilder<'blk, 'tcx>\n-{\n-    if common::const_to_opt_uint(val) == Some(0) {\n-        return bcx;\n-    }\n-\n-    let fcx = bcx.fcx();\n-    let next_cx = fcx.build_new_block(\"next\");\n-    let cond_cx = fcx.build_new_block(\"cond\");\n-    bcx.cond_br(val, cond_cx.llbb(), next_cx.llbb());\n-    let after_cx = f(cond_cx);\n-    after_cx.br(next_cx.llbb());\n-    next_cx\n-}\n-\n pub enum Lifetime { Start, End }\n \n impl Lifetime {"}, {"sha": "23903d9d7f851dd8ebfe54da5db6390c9fc4a5ac", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 25, "deletions": 38, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/937001a1f8a05a07b16233bcfdf53d9d3381e45c/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/937001a1f8a05a07b16233bcfdf53d9d3381e45c/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=937001a1f8a05a07b16233bcfdf53d9d3381e45c", "patch": "@@ -189,11 +189,10 @@ impl<'tcx> Callee<'tcx> {\n     /// For non-lang items, `dest` is always Some, and hence the result is written\n     /// into memory somewhere. Nonetheless we return the actual return value of the\n     /// function.\n-    pub fn call<'a, 'blk>(self, bcx: BlockAndBuilder<'blk, 'tcx>,\n+    pub fn call<'a, 'blk>(self, bcx: &BlockAndBuilder<'blk, 'tcx>,\n                           args: &[ValueRef],\n                           dest: Option<ValueRef>,\n-                          lpad: Option<&'blk llvm::OperandBundleDef>)\n-                          -> (BlockAndBuilder<'blk, 'tcx>, ValueRef) {\n+                          lpad: Option<&'blk llvm::OperandBundleDef>) {\n         trans_call_inner(bcx, self, args, dest, lpad)\n     }\n \n@@ -538,7 +537,7 @@ fn trans_fn_pointer_shim<'a, 'tcx>(\n         data: Fn(llfnpointer),\n         ty: bare_fn_ty\n     };\n-    let bcx = callee.call(bcx, &llargs[(self_idx + 1)..], fcx.llretslotptr, None).0;\n+    callee.call(&bcx, &llargs[(self_idx + 1)..], fcx.llretslotptr, None);\n     fcx.finish(&bcx);\n \n     ccx.fn_pointer_shims().borrow_mut().insert(bare_fn_ty_maybe_ref, llfn);\n@@ -648,81 +647,69 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n // ______________________________________________________________________\n // Translating calls\n \n-fn trans_call_inner<'a, 'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n+fn trans_call_inner<'a, 'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                                     callee: Callee<'tcx>,\n                                     args: &[ValueRef],\n-                                    opt_llretslot: Option<ValueRef>,\n-                                    lpad: Option<&'blk llvm::OperandBundleDef>)\n-                                    -> (BlockAndBuilder<'blk, 'tcx>, ValueRef) {\n+                                    dest: Option<ValueRef>,\n+                                    lpad: Option<&'blk llvm::OperandBundleDef>) {\n     // Introduce a temporary cleanup scope that will contain cleanups\n     // for the arguments while they are being evaluated. The purpose\n     // this cleanup is to ensure that, should a panic occur while\n     // evaluating argument N, the values for arguments 0...N-1 are all\n     // cleaned up. If no panic occurs, the values are handed off to\n     // the callee, and hence none of the cleanups in this temporary\n     // scope will ever execute.\n-    let fcx = &bcx.fcx();\n-    let ccx = fcx.ccx;\n-\n+    let ccx = bcx.ccx();\n     let fn_ret = callee.ty.fn_ret();\n     let fn_ty = callee.direct_fn_type(ccx, &[]);\n \n-    let mut callee = match callee.data {\n-        NamedTupleConstructor(_) | Intrinsic => {\n-            bug!(\"{:?} calls should not go through Callee::call\", callee);\n-        }\n-        f => f\n-    };\n-\n     // If there no destination, return must be direct, with no cast.\n-    if opt_llretslot.is_none() {\n+    if dest.is_none() {\n         assert!(!fn_ty.ret.is_indirect() && fn_ty.ret.cast.is_none());\n     }\n \n     let mut llargs = Vec::new();\n \n     if fn_ty.ret.is_indirect() {\n-        let mut llretslot = opt_llretslot.unwrap();\n-        if let Some(ty) = fn_ty.ret.cast {\n-            llretslot = bcx.pointercast(llretslot, ty.ptr_to());\n-        }\n+        let dest = dest.unwrap();\n+        let llretslot = if let Some(ty) = fn_ty.ret.cast {\n+            bcx.pointercast(dest, ty.ptr_to())\n+        } else {\n+            dest\n+        };\n         llargs.push(llretslot);\n     }\n \n-    match callee {\n+    let llfn = match callee.data {\n+        NamedTupleConstructor(_) | Intrinsic => {\n+            bug!(\"{:?} calls should not go through Callee::call\", callee);\n+        }\n         Virtual(idx) => {\n             llargs.push(args[0]);\n \n             let fn_ptr = meth::get_virtual_method(&bcx, args[1], idx);\n             let llty = fn_ty.llvm_type(&bcx.ccx()).ptr_to();\n-            callee = Fn(bcx.pointercast(fn_ptr, llty));\n             llargs.extend_from_slice(&args[2..]);\n+            bcx.pointercast(fn_ptr, llty)\n+        }\n+        Fn(f) => {\n+            llargs.extend_from_slice(args);\n+            f\n         }\n-        _ => llargs.extend_from_slice(args)\n-    }\n-\n-    let llfn = match callee {\n-        Fn(f) => f,\n-        _ => bug!(\"expected fn pointer callee, found {:?}\", callee)\n     };\n \n     let llret = bcx.call(llfn, &llargs[..], lpad);\n     fn_ty.apply_attrs_callsite(llret);\n \n     // If the function we just called does not use an outpointer,\n-    // store the result into the rust outpointer. Cast the outpointer\n-    // type to match because some ABIs will use a different type than\n-    // the Rust type. e.g., a {u32,u32} struct could be returned as\n-    // u64.\n+    // store the result into the Rust outpointer.\n     if !fn_ty.ret.is_indirect() {\n-        if let Some(llretslot) = opt_llretslot {\n+        if let Some(llretslot) = dest {\n             fn_ty.ret.store(&bcx, llret, llretslot);\n         }\n     }\n \n     if fn_ret.0.is_never() {\n         bcx.unreachable();\n     }\n-\n-    (bcx, llret)\n }"}, {"sha": "748707b4978b2dde8be23af1e50772162dfd02c7", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/937001a1f8a05a07b16233bcfdf53d9d3381e45c/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/937001a1f8a05a07b16233bcfdf53d9d3381e45c/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=937001a1f8a05a07b16233bcfdf53d9d3381e45c", "patch": "@@ -35,21 +35,18 @@ use Disr;\n \n use syntax_pos::DUMMY_SP;\n \n-pub fn trans_exchange_free_dyn<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n+pub fn trans_exchange_free_dyn<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                                            v: ValueRef,\n                                            size: ValueRef,\n-                                           align: ValueRef)\n-                                           -> BlockAndBuilder<'blk, 'tcx> {\n+                                           align: ValueRef) {\n     let def_id = langcall(bcx.tcx(), None, \"\", ExchangeFreeFnLangItem);\n     let args = [bcx.pointercast(v, Type::i8p(bcx.ccx())), size, align];\n-    Callee::def(bcx.ccx(), def_id, bcx.tcx().intern_substs(&[]))\n-        .call(bcx, &args, None, None).0\n+    Callee::def(bcx.ccx(), def_id, bcx.tcx().intern_substs(&[])).call(&bcx, &args, None, None)\n }\n \n-pub fn trans_exchange_free_ty<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n+pub fn trans_exchange_free_ty<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n                                           ptr: ValueRef,\n-                                          content_ty: Ty<'tcx>)\n-                                          -> BlockAndBuilder<'blk, 'tcx> {\n+                                          content_ty: Ty<'tcx>) {\n     assert!(type_is_sized(bcx.ccx().tcx(), content_ty));\n     let sizing_type = sizing_type_of(bcx.ccx(), content_ty);\n     let content_size = llsize_of_alloc(bcx.ccx(), sizing_type);\n@@ -58,9 +55,7 @@ pub fn trans_exchange_free_ty<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n     if content_size != 0 {\n         let content_align = align_of(bcx.ccx(), content_ty);\n         let ccx = bcx.ccx();\n-        trans_exchange_free_dyn(bcx, ptr, C_uint(ccx, content_size), C_uint(ccx, content_align))\n-    } else {\n-        bcx\n+        trans_exchange_free_dyn(bcx, ptr, C_uint(ccx, content_size), C_uint(ccx, content_align));\n     }\n }\n \n@@ -410,14 +405,23 @@ fn make_drop_glue<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n                     llsize,\n                     C_uint(bcx.ccx(), 0u64),\n                 );\n-                with_cond(bcx, needs_free, |bcx| {\n-                    trans_exchange_free_dyn(bcx, llbox, llsize, llalign)\n-                })\n+                if const_to_opt_uint(needs_free) == Some(0) {\n+                    bcx\n+                } else {\n+                    let fcx = bcx.fcx();\n+                    let next_cx = fcx.build_new_block(\"next\");\n+                    let cond_cx = fcx.build_new_block(\"cond\");\n+                    bcx.cond_br(needs_free, cond_cx.llbb(), next_cx.llbb());\n+                    trans_exchange_free_dyn(&cond_cx, llbox, llsize, llalign);\n+                    cond_cx.br(next_cx.llbb());\n+                    next_cx\n+                }\n             } else {\n                 let llval = v0;\n                 let llbox = bcx.load(llval);\n                 drop_ty(&bcx, llbox, content_ty);\n-                trans_exchange_free_ty(bcx, llbox, content_ty)\n+                trans_exchange_free_ty(&bcx, llbox, content_ty);\n+                bcx\n             }\n         }\n         ty::TyDynamic(..) => {"}, {"sha": "88b18ecae4c67ac0a11173761fdd60030ce3e1bb", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/937001a1f8a05a07b16233bcfdf53d9d3381e45c/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/937001a1f8a05a07b16233bcfdf53d9d3381e45c/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=937001a1f8a05a07b16233bcfdf53d9d3381e45c", "patch": "@@ -82,12 +82,10 @@ pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     attributes::set_frame_pointer_elimination(ccx, llfn);\n \n     let fcx = FunctionContext::new(ccx, llfn, fn_ty, None, false);\n-    let mut bcx = fcx.get_entry_block();\n+    let bcx = fcx.get_entry_block();\n \n     let llargs = get_params(fcx.llfn);\n-    bcx = callee.call(bcx, &llargs[fcx.fn_ty.ret.is_indirect() as usize..], fcx.llretslotptr,\n-        None).0;\n-\n+    callee.call(&bcx, &llargs[fcx.fn_ty.ret.is_indirect() as usize..], fcx.llretslotptr, None);\n     fcx.finish(&bcx);\n \n     llfn"}]}