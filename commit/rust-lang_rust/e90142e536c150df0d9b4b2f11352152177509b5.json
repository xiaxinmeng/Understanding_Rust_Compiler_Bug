{"sha": "e90142e536c150df0d9b4b2f11352152177509b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5MDE0MmU1MzZjMTUwZGYwZDliNGIyZjExMzUyMTUyMTc3NTA5YjU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-15T21:10:24Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-15T21:10:24Z"}, "message": "Merge pull request #4498 from erickt/incoming\n\nMore records-to-structs conversions", "tree": {"sha": "34ded4b28bd49ec489bb7499b1fb02fd8767dcad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34ded4b28bd49ec489bb7499b1fb02fd8767dcad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e90142e536c150df0d9b4b2f11352152177509b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e90142e536c150df0d9b4b2f11352152177509b5", "html_url": "https://github.com/rust-lang/rust/commit/e90142e536c150df0d9b4b2f11352152177509b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e90142e536c150df0d9b4b2f11352152177509b5/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb8fd119c65c67f3b1b8268cc7341c22d39b7b61", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb8fd119c65c67f3b1b8268cc7341c22d39b7b61", "html_url": "https://github.com/rust-lang/rust/commit/eb8fd119c65c67f3b1b8268cc7341c22d39b7b61"}, {"sha": "293cd3480c10855de68503db36c6cc3ce8988b54", "url": "https://api.github.com/repos/rust-lang/rust/commits/293cd3480c10855de68503db36c6cc3ce8988b54", "html_url": "https://github.com/rust-lang/rust/commit/293cd3480c10855de68503db36c6cc3ce8988b54"}], "stats": {"total": 853, "additions": 512, "deletions": 341}, "files": [{"sha": "8d29ec211250473a108bbf9edd0fde84d5dcedf8", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -133,14 +133,19 @@ fn filter_stmt(cx: ctxt, &&stmt: @ast::stmt) ->\n     }\n }\n \n-fn fold_block(cx: ctxt, b: ast::blk_, fld: fold::ast_fold) ->\n-   ast::blk_ {\n+fn fold_block(\n+    cx: ctxt,\n+    b: ast::blk_,\n+    fld: fold::ast_fold\n+) -> ast::blk_ {\n     let filtered_stmts = vec::filter_map(b.stmts, |a| filter_stmt(cx, *a));\n-    return {view_items: /*bad*/copy b.view_items,\n-         stmts: vec::map(filtered_stmts, |x| fld.fold_stmt(*x)),\n-         expr: option::map(&b.expr, |x| fld.fold_expr(*x)),\n-         id: b.id,\n-         rules: b.rules};\n+    ast::blk_ {\n+        view_items: /*bad*/copy b.view_items,\n+        stmts: vec::map(filtered_stmts, |x| fld.fold_stmt(*x)),\n+        expr: option::map(&b.expr, |x| fld.fold_expr(*x)),\n+        id: b.id,\n+        rules: b.rules,\n+    }\n }\n \n fn item_in_cfg(cx: ctxt, item: @ast::item) -> bool {"}, {"sha": "7345c76fc3b1021401d8d15bfa1c32858bac6fff", "filename": "src/librustc/front/core_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fcore_inject.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -69,7 +69,7 @@ fn inject_libcore_ref(sess: Session,\n             new_module = fld.fold_mod(new_module);\n \n             // XXX: Bad copy.\n-            let new_crate = { module: new_module, ..copy crate };\n+            let new_crate = ast::crate_ { module: new_module, ..copy crate };\n             (new_crate, span)\n         },\n         fold_mod: |module, fld| {"}, {"sha": "169fe59e4b46ea8c3f810ac0c8be0b5b5279675c", "filename": "src/librustc/front/intrinsic_inject.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -37,8 +37,13 @@ fn inject_intrinsic(sess: Session, crate: @ast::crate) -> @ast::crate {\n     let items = vec::append(~[item], crate.node.module.items);\n \n     @ast::spanned {\n-        node: { module: { items: items ,.. /*bad*/copy crate.node.module },\n-                .. /*bad*/copy crate.node},\n+        node: ast::crate_ {\n+            module: {\n+                items: items,\n+                .. /*bad*/copy crate.node.module\n+            },\n+            .. /*bad*/copy crate.node\n+        },\n         .. /*bad*/copy *crate\n     }\n }"}, {"sha": "e7e3a412a9ea4798afd8d61ce7c20426aba11bd7", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -113,7 +113,8 @@ fn fold_crate(cx: test_ctxt, c: ast::crate_, fld: fold::ast_fold) ->\n \n     // Add a special __test module to the crate that will contain code\n     // generated for the test harness\n-    return {module: add_test_module(cx, /*bad*/copy folded.module),.. folded};\n+    ast::crate_ { module: add_test_module(cx, /*bad*/copy folded.module),\n+                  .. folded }\n }\n \n \n@@ -339,13 +340,13 @@ fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::Ty {\n          node: ast::ty_path(test_desc_ty_path, cx.sess.next_node_id()),\n          span: dummy_sp()};\n \n-    let vec_mt: ast::mt = {ty: @test_desc_ty, mutbl: ast::m_imm};\n+    let vec_mt = ast::mt {ty: @test_desc_ty, mutbl: ast::m_imm};\n \n     let inner_ty = @{id: cx.sess.next_node_id(),\n                      node: ast::ty_vec(vec_mt),\n                      span: dummy_sp()};\n     return @{id: cx.sess.next_node_id(),\n-          node: ast::ty_uniq({ty: inner_ty, mutbl: ast::m_imm}),\n+          node: ast::ty_uniq(ast::mt {ty: inner_ty, mutbl: ast::m_imm}),\n           span: dummy_sp()};\n }\n \n@@ -388,9 +389,11 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n                      span: dummy_sp()};\n \n \n-    let name_field: ast::field =\n-        nospan({mutbl: ast::m_imm, ident: cx.sess.ident_of(~\"name\"),\n-                expr: @name_expr});\n+    let name_field = nospan(ast::field_ {\n+        mutbl: ast::m_imm,\n+        ident: cx.sess.ident_of(~\"name\"),\n+        expr: @name_expr,\n+    });\n \n     let fn_path = path_node_global(path);\n \n@@ -402,9 +405,11 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n \n     let fn_wrapper_expr = mk_test_wrapper(cx, fn_expr, span);\n \n-    let fn_field: ast::field =\n-        nospan({mutbl: ast::m_imm, ident: cx.sess.ident_of(~\"testfn\"),\n-                expr: fn_wrapper_expr});\n+    let fn_field = nospan(ast::field_ {\n+        mutbl: ast::m_imm,\n+        ident: cx.sess.ident_of(~\"testfn\"),\n+        expr: fn_wrapper_expr,\n+    });\n \n     let ignore_lit: ast::lit = nospan(ast::lit_bool(test.ignore));\n \n@@ -414,9 +419,11 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n          node: ast::expr_lit(@ignore_lit),\n          span: span};\n \n-    let ignore_field: ast::field =\n-        nospan({mutbl: ast::m_imm, ident: cx.sess.ident_of(~\"ignore\"),\n-                expr: @ignore_expr});\n+    let ignore_field = nospan(ast::field_ {\n+        mutbl: ast::m_imm,\n+        ident: cx.sess.ident_of(~\"ignore\"),\n+        expr: @ignore_expr,\n+    });\n \n     let fail_lit: ast::lit = nospan(ast::lit_bool(test.should_fail));\n \n@@ -426,10 +433,11 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n          node: ast::expr_lit(@fail_lit),\n          span: span};\n \n-    let fail_field: ast::field =\n-        nospan({mutbl: ast::m_imm,\n-                ident: cx.sess.ident_of(~\"should_fail\"),\n-                expr: @fail_expr});\n+    let fail_field = nospan(ast::field_ {\n+        mutbl: ast::m_imm,\n+        ident: cx.sess.ident_of(~\"should_fail\"),\n+        expr: @fail_expr,\n+    });\n \n     let test_desc_path =\n         mk_path(cx, ~[cx.sess.ident_of(~\"test\"),\n@@ -468,7 +476,7 @@ fn mk_test_wrapper(cx: test_ctxt,\n         cf: ast::return_val\n     };\n \n-    let wrapper_body: ast::blk = nospan({\n+    let wrapper_body = nospan(ast::blk_ {\n         view_items: ~[],\n         stmts: ~[@call_stmt],\n         expr: option::None,"}, {"sha": "9f9e00491461ca1076027b11be3f381b4ddae31c", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -353,7 +353,7 @@ fn parse_mt(st: @pstate, conv: conv_did) -> ty::mt {\n       '?' => { next(st); m = ast::m_const; }\n       _ => { m = ast::m_imm; }\n     }\n-    return {ty: parse_ty(st, conv), mutbl: m};\n+    ty::mt { ty: parse_ty(st, conv), mutbl: m }\n }\n \n fn parse_def(st: @pstate, conv: conv_did) -> ast::def_id {"}, {"sha": "0edce246dbd763d8083a8505570adf165b464ade", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -267,7 +267,10 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n             }\n         };\n         // XXX: Bad copy.\n-        let blk_sans_items = { stmts: stmts_sans_items,.. copy blk };\n+        let blk_sans_items = ast::blk_ {\n+            stmts: stmts_sans_items,\n+            .. copy blk\n+        };\n         fold::noop_fold_block(blk_sans_items, fld)\n     }\n "}, {"sha": "ab70e8e55568fd1bdfbb8e0622a7b2730cdda22a", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -478,7 +478,7 @@ fn ctor_arity(cx: @MatchCheckCtxt, ctor: ctor, ty: ty::t) -> uint {\n }\n \n fn wild() -> @pat {\n-    @{id: 0, node: pat_wild, span: ast_util::dummy_sp()}\n+    @pat {id: 0, node: pat_wild, span: ast_util::dummy_sp()}\n }\n \n fn specialize(cx: @MatchCheckCtxt, r: ~[@pat], ctor_id: ctor, arity: uint,"}, {"sha": "13e559e6ce4caf907f3b021e81f62ad7b06fca5a", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -728,7 +728,7 @@ impl &mem_categorization_ctxt {\n         // know what type lies at the other end, so we just call it\n         // `()` (the empty tuple).\n \n-        let mt = {ty: ty::mk_tup(self.tcx, ~[]), mutbl: m_imm};\n+        let mt = ty::mt {ty: ty::mk_tup(self.tcx, ~[]), mutbl: m_imm};\n         return self.cat_deref_common(node, base_cmt, deref_cnt, mt);\n     }\n "}, {"sha": "9a5e4cb217684ad70026428f414931cf53f43374", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -499,7 +499,7 @@ fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n     let _indenter = indenter();\n \n     let tcx = bcx.tcx();\n-    let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n+    let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, tcx.def_map, m, col, val) |p| {\n         match /*bad*/copy p.node {\n             ast::pat_enum(_, subpats) => {\n@@ -600,7 +600,7 @@ fn enter_rec_or_struct(bcx: block, dm: DefMap, m: &[@Match/&r], col: uint,\n            bcx.val_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n+    let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match /*bad*/copy p.node {\n             ast::pat_rec(fpats, _) | ast::pat_struct(_, fpats, _) => {\n@@ -632,7 +632,7 @@ fn enter_tup(bcx: block, dm: DefMap, m: &[@Match/&r],\n            bcx.val_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n+    let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match /*bad*/copy p.node {\n             ast::pat_tup(elts) => {\n@@ -657,7 +657,7 @@ fn enter_tuple_struct(bcx: block, dm: DefMap, m: &[@Match/&r], col: uint,\n            bcx.val_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n+    let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match /*bad*/copy p.node {\n             ast::pat_enum(_, Some(elts)) => Some(elts),\n@@ -680,7 +680,7 @@ fn enter_box(bcx: block, dm: DefMap, m: &[@Match/&r],\n            bcx.val_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n+    let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n             ast::pat_box(sub) => {\n@@ -705,7 +705,7 @@ fn enter_uniq(bcx: block, dm: DefMap, m: &[@Match/&r],\n            bcx.val_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n+    let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n             ast::pat_uniq(sub) => {\n@@ -730,7 +730,7 @@ fn enter_region(bcx: block, dm: DefMap, m: &[@Match/&r],\n            bcx.val_str(val));\n     let _indenter = indenter();\n \n-    let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n+    let dummy = @ast::pat { id: 0, node: ast::pat_wild, span: dummy_sp() };\n     do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n             ast::pat_region(sub) => {\n@@ -857,7 +857,7 @@ fn extract_vec_elems(bcx: block, pat_id: ast::node_id,\n         let tail_begin = tvec::pointer_add(bcx, base, tail_offset);\n         let tail_len = Sub(bcx, len, tail_offset);\n         let tail_ty = ty::mk_evec(bcx.tcx(),\n-            {ty: vt.unit_ty, mutbl: ast::m_imm},\n+            ty::mt {ty: vt.unit_ty, mutbl: ast::m_imm},\n             ty::vstore_slice(ty::re_static)\n         );\n         let scratch = scratch_datum(bcx, tail_ty, false);"}, {"sha": "f66823c808196292f2e318647838cce7b78f0633", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -2184,7 +2184,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef) {\n         let unit_ty = ty::mk_estr(ccx.tcx, ty::vstore_uniq);\n         let vecarg_ty: ty::arg =\n             {mode: ast::expl(ast::by_val),\n-             ty: ty::mk_evec(ccx.tcx, {ty: unit_ty, mutbl: ast::m_imm},\n+             ty: ty::mk_evec(ccx.tcx, ty::mt {ty: unit_ty, mutbl: ast::m_imm},\n                              ty::vstore_uniq)};\n         let nt = ty::mk_nil(ccx.tcx);\n         let llfty = type_of_fn(ccx, ~[vecarg_ty], nt);"}, {"sha": "09d188b6cd2c620327b955af1ea67ef967639707", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -224,7 +224,7 @@ fn store_environment(bcx: block,\n     // tuple.  This could be a ptr in uniq or a box or on stack,\n     // whatever.\n     let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n-    let cboxptr_ty = ty::mk_ptr(tcx, {ty:cbox_ty, mutbl:ast::m_imm});\n+    let cboxptr_ty = ty::mk_ptr(tcx, ty::mt {ty:cbox_ty, mutbl:ast::m_imm});\n \n     let llbox = PointerCast(bcx, llbox, type_of(ccx, cboxptr_ty));\n     debug!(\"tuplify_box_ty = %s\", ty_to_str(tcx, cbox_ty));"}, {"sha": "4481deec3c7481fc3ef43b9c9cac44a73addcabd", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -945,7 +945,10 @@ fn T_opaque_vec(targ_cfg: @session::config) -> TypeRef {\n // representation of @T as a tuple (i.e., the ty::t version of what T_box()\n // returns).\n fn tuplify_box_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n-    let ptr = ty::mk_ptr(tcx, {ty: ty::mk_nil(tcx), mutbl: ast::m_imm});\n+    let ptr = ty::mk_ptr(\n+        tcx,\n+        ty::mt {ty: ty::mk_nil(tcx), mutbl: ast::m_imm}\n+    );\n     return ty::mk_tup(tcx, ~[ty::mk_uint(tcx), ty::mk_type(tcx),\n                          ptr, ptr,\n                          t]);"}, {"sha": "4c8bb91df4c628aa9d79ffd9c57324d7a589140e", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -251,7 +251,8 @@ fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n \n         // this type may have a different region/mutability than the\n         // real one, but it will have the same runtime representation\n-        let slice_ty = ty::mk_evec(tcx, {ty: unit_ty, mutbl: ast::m_imm},\n+        let slice_ty = ty::mk_evec(tcx,\n+                                   ty::mt { ty: unit_ty, mutbl: ast::m_imm },\n                                    ty::vstore_slice(ty::re_static));\n \n         let scratch = scratch_datum(bcx, slice_ty, false);"}, {"sha": "5c0498d5a14702e7bfdaeb61304270a44122a54b", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -26,7 +26,7 @@ use syntax::parse::token::special_idents;\n // nominal type that has pointers to itself in it.\n pub fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n     fn nilptr(tcx: ty::ctxt) -> ty::t {\n-        ty::mk_ptr(tcx, {ty: ty::mk_nil(tcx), mutbl: ast::m_imm})\n+        ty::mk_ptr(tcx, ty::mt {ty: ty::mk_nil(tcx), mutbl: ast::m_imm})\n     }\n     fn simplifier(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n         match ty::get(typ).sty {\n@@ -45,13 +45,12 @@ pub fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n             let simpl_fields = (if ty::ty_dtor(tcx, did).is_present() {\n                 // remember the drop flag\n                   ~[{ident: special_idents::dtor,\n-                     mt: {ty: ty::mk_u8(tcx),\n-                          mutbl: ast::m_mutbl}}] }\n+                     mt: ty::mt {ty: ty::mk_u8(tcx), mutbl: ast::m_mutbl}}] }\n                 else { ~[] }) +\n                 do ty::lookup_struct_fields(tcx, did).map |f| {\n                  let t = ty::lookup_field_type(tcx, did, f.id, substs);\n                  {ident: f.ident,\n-                  mt: {ty: simplify_type(tcx, t), mutbl: ast::m_const}}\n+                  mt: ty::mt {ty: simplify_type(tcx, t), mutbl: ast::m_const}}\n             };\n             ty::mk_rec(tcx, simpl_fields)\n           }"}, {"sha": "eb2fd91e6051fd8721173495cd61350a28a71cbd", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -214,7 +214,7 @@ fn trans_slice_vstore(bcx: block,\n \n     // Arrange for the backing array to be cleaned up.\n     let fixed_ty = ty::mk_evec(bcx.tcx(),\n-                               {ty: vt.unit_ty, mutbl: ast::m_mutbl},\n+                               ty::mt {ty: vt.unit_ty, mutbl: ast::m_mutbl},\n                                ty::vstore_fixed(count));\n     let llfixed_ty = T_ptr(type_of::type_of(bcx.ccx(), fixed_ty));\n     let llfixed_casted = BitCast(bcx, llfixed, llfixed_ty);"}, {"sha": "b84fbd8a38100d8e1a4a58272cef70ec7aab0521", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -258,7 +258,10 @@ type method = {ident: ast::ident,\n                vis: ast::visibility,\n                def_id: ast::def_id};\n \n-type mt = {ty: t, mutbl: ast::mutability};\n+struct mt {\n+    ty: t,\n+    mutbl: ast::mutability,\n+}\n \n #[auto_encode]\n #[auto_decode]\n@@ -1149,34 +1152,37 @@ fn mk_enum(cx: ctxt, did: ast::def_id, +substs: substs) -> t {\n \n fn mk_box(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_box(tm)) }\n \n-fn mk_imm_box(cx: ctxt, ty: t) -> t { mk_box(cx, {ty: ty,\n-                                                  mutbl: ast::m_imm}) }\n+fn mk_imm_box(cx: ctxt, ty: t) -> t {\n+    mk_box(cx, mt {ty: ty, mutbl: ast::m_imm})\n+}\n \n fn mk_uniq(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_uniq(tm)) }\n \n-fn mk_imm_uniq(cx: ctxt, ty: t) -> t { mk_uniq(cx, {ty: ty,\n-                                                    mutbl: ast::m_imm}) }\n+fn mk_imm_uniq(cx: ctxt, ty: t) -> t {\n+    mk_uniq(cx, mt {ty: ty, mutbl: ast::m_imm})\n+}\n \n fn mk_ptr(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_ptr(tm)) }\n \n fn mk_rptr(cx: ctxt, r: Region, tm: mt) -> t { mk_t(cx, ty_rptr(r, tm)) }\n \n fn mk_mut_rptr(cx: ctxt, r: Region, ty: t) -> t {\n-    mk_rptr(cx, r, {ty: ty, mutbl: ast::m_mutbl})\n+    mk_rptr(cx, r, mt {ty: ty, mutbl: ast::m_mutbl})\n }\n fn mk_imm_rptr(cx: ctxt, r: Region, ty: t) -> t {\n-    mk_rptr(cx, r, {ty: ty, mutbl: ast::m_imm})\n+    mk_rptr(cx, r, mt {ty: ty, mutbl: ast::m_imm})\n }\n \n-fn mk_mut_ptr(cx: ctxt, ty: t) -> t { mk_ptr(cx, {ty: ty,\n-                                                  mutbl: ast::m_mutbl}) }\n+fn mk_mut_ptr(cx: ctxt, ty: t) -> t {\n+    mk_ptr(cx, mt {ty: ty, mutbl: ast::m_mutbl})\n+}\n \n fn mk_imm_ptr(cx: ctxt, ty: t) -> t {\n-    mk_ptr(cx, {ty: ty, mutbl: ast::m_imm})\n+    mk_ptr(cx, mt {ty: ty, mutbl: ast::m_imm})\n }\n \n fn mk_nil_ptr(cx: ctxt) -> t {\n-    mk_ptr(cx, {ty: mk_nil(cx), mutbl: ast::m_imm})\n+    mk_ptr(cx, mt {ty: mk_nil(cx), mutbl: ast::m_imm})\n }\n \n fn mk_evec(cx: ctxt, tm: mt, t: vstore) -> t {\n@@ -1187,7 +1193,7 @@ fn mk_unboxed_vec(cx: ctxt, tm: mt) -> t {\n     mk_t(cx, ty_unboxed_vec(tm))\n }\n fn mk_mut_unboxed_vec(cx: ctxt, ty: t) -> t {\n-    mk_t(cx, ty_unboxed_vec({ty: ty, mutbl: ast::m_imm}))\n+    mk_t(cx, ty_unboxed_vec(mt {ty: ty, mutbl: ast::m_imm}))\n }\n \n fn mk_rec(cx: ctxt, +fs: ~[field]) -> t { mk_t(cx, ty_rec(fs)) }\n@@ -1353,19 +1359,19 @@ fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n \n     match /*bad*/copy *sty {\n         ty_box(tm) => {\n-            ty_box({ty: fldop(tm.ty), mutbl: tm.mutbl})\n+            ty_box(mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n         }\n         ty_uniq(tm) => {\n-            ty_uniq({ty: fldop(tm.ty), mutbl: tm.mutbl})\n+            ty_uniq(mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n         }\n         ty_ptr(tm) => {\n-            ty_ptr({ty: fldop(tm.ty), mutbl: tm.mutbl})\n+            ty_ptr(mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n         }\n         ty_unboxed_vec(tm) => {\n-            ty_unboxed_vec({ty: fldop(tm.ty), mutbl: tm.mutbl})\n+            ty_unboxed_vec(mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n         }\n         ty_evec(tm, vst) => {\n-            ty_evec({ty: fldop(tm.ty), mutbl: tm.mutbl}, vst)\n+            ty_evec(mt {ty: fldop(tm.ty), mutbl: tm.mutbl}, vst)\n         }\n         ty_enum(tid, ref substs) => {\n             ty_enum(tid, fold_substs(substs, fldop))\n@@ -1376,7 +1382,7 @@ fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n         ty_rec(fields) => {\n             let new_fields = do vec::map(fields) |fl| {\n                 let new_ty = fldop(fl.mt.ty);\n-                let new_mt = {ty: new_ty, mutbl: fl.mt.mutbl};\n+                let new_mt = mt {ty: new_ty, mutbl: fl.mt.mutbl};\n                 {ident: fl.ident, mt: new_mt}\n             };\n             ty_rec(new_fields)\n@@ -1390,7 +1396,7 @@ fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n             ty_fn(FnTyBase {meta: f.meta, sig: sig})\n         }\n         ty_rptr(r, tm) => {\n-            ty_rptr(r, {ty: fldop(tm.ty), mutbl: tm.mutbl})\n+            ty_rptr(r, mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n         }\n         ty_struct(did, ref substs) => {\n             ty_struct(did, fold_substs(substs, fldop))\n@@ -1446,7 +1452,7 @@ fn fold_regions_and_ty(\n       ty::ty_rptr(r, mt) => {\n         let m_r = fldr(r);\n         let m_t = fldt(mt.ty);\n-        ty::mk_rptr(cx, m_r, {ty: m_t, mutbl: mt.mutbl})\n+        ty::mk_rptr(cx, m_r, mt {ty: m_t, mutbl: mt.mutbl})\n       }\n       ty_estr(vstore_slice(r)) => {\n         let m_r = fldr(r);\n@@ -1455,7 +1461,7 @@ fn fold_regions_and_ty(\n       ty_evec(mt, vstore_slice(r)) => {\n         let m_r = fldr(r);\n         let m_t = fldt(mt.ty);\n-        ty::mk_evec(cx, {ty: m_t, mutbl: mt.mutbl}, vstore_slice(m_r))\n+        ty::mk_evec(cx, mt {ty: m_t, mutbl: mt.mutbl}, vstore_slice(m_r))\n       }\n       ty_enum(def_id, ref substs) => {\n         ty::mk_enum(cx, def_id, fold_substs(substs, fldr, fldt))\n@@ -1527,19 +1533,19 @@ fn fold_region(cx: ctxt, t0: t, fldop: fn(Region, bool) -> Region) -> t {\n         let tb = get(t0);\n         if !tbox_has_flag(tb, has_regions) { return t0; }\n         match tb.sty {\n-          ty_rptr(r, {ty: t1, mutbl: m}) => {\n+          ty_rptr(r, mt {ty: t1, mutbl: m}) => {\n             let m_r = fldop(r, under_r);\n             let m_t1 = do_fold(cx, t1, true, fldop);\n-            ty::mk_rptr(cx, m_r, {ty: m_t1, mutbl: m})\n+            ty::mk_rptr(cx, m_r, mt {ty: m_t1, mutbl: m})\n           }\n           ty_estr(vstore_slice(r)) => {\n             let m_r = fldop(r, under_r);\n             ty::mk_estr(cx, vstore_slice(m_r))\n           }\n-          ty_evec({ty: t1, mutbl: m}, vstore_slice(r)) => {\n+          ty_evec(mt {ty: t1, mutbl: m}, vstore_slice(r)) => {\n             let m_r = fldop(r, under_r);\n             let m_t1 = do_fold(cx, t1, true, fldop);\n-            ty::mk_evec(cx, {ty: m_t1, mutbl: m}, vstore_slice(m_r))\n+            ty::mk_evec(cx, mt {ty: m_t1, mutbl: m}, vstore_slice(m_r))\n           }\n           ty_fn(_) => {\n             // do not recurse into functions, which introduce fresh bindings\n@@ -2707,7 +2713,7 @@ fn deref_sty(cx: ctxt, sty: &sty, explicit: bool) -> Option<mt> {\n         let variants = enum_variants(cx, did);\n         if vec::len(*variants) == 1u && vec::len(variants[0].args) == 1u {\n             let v_t = subst(cx, substs, variants[0].args[0]);\n-            Some({ty: v_t, mutbl: ast::m_imm})\n+            Some(mt {ty: v_t, mutbl: ast::m_imm})\n         } else {\n             None\n         }\n@@ -2717,7 +2723,7 @@ fn deref_sty(cx: ctxt, sty: &sty, explicit: bool) -> Option<mt> {\n         let fields = struct_fields(cx, did, substs);\n         if fields.len() == 1 && fields[0].ident ==\n                 syntax::parse::token::special_idents::unnamed_field {\n-            Some({ty: fields[0].mt.ty, mutbl: ast::m_imm})\n+            Some(mt {ty: fields[0].mt.ty, mutbl: ast::m_imm})\n         } else {\n             None\n         }\n@@ -2745,7 +2751,7 @@ fn index(cx: ctxt, t: t) -> Option<mt> {\n fn index_sty(cx: ctxt, sty: &sty) -> Option<mt> {\n     match *sty {\n       ty_evec(mt, _) => Some(mt),\n-      ty_estr(_) => Some({ty: mk_u8(cx), mutbl: ast::m_imm}),\n+      ty_estr(_) => Some(mt {ty: mk_u8(cx), mutbl: ast::m_imm}),\n       _ => None\n     }\n }\n@@ -4111,15 +4117,17 @@ fn struct_item_fields(cx:ctxt,\n                      substs: &substs,\n                      frob_mutability: fn(struct_mutability) -> mutability)\n     -> ~[field] {\n-    let mut rslt = ~[];\n-    for lookup_struct_fields(cx, did).each |f| {\n+    do lookup_struct_fields(cx, did).map |f| {\n        // consider all instance vars mut, because the\n        // constructor may mutate all vars\n-       rslt.push({ident: f.ident, mt:\n-               {ty: lookup_field_type(cx, did, f.id, substs),\n-                    mutbl: frob_mutability(f.mutability)}});\n+       {\n+           ident: f.ident,\n+            mt: mt {\n+                ty: lookup_field_type(cx, did, f.id, substs),\n+                mutbl: frob_mutability(f.mutability)\n+            }\n+        }\n     }\n-    rslt\n }\n \n fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n@@ -4199,7 +4207,7 @@ fn ty_params_to_tys(tcx: ty::ctxt, tps: ~[ast::ty_param]) -> ~[t] {\n /// Returns an equivalent type with all the typedefs and self regions removed.\n fn normalize_ty(cx: ctxt, t: t) -> t {\n     fn normalize_mt(cx: ctxt, mt: mt) -> mt {\n-        { ty: normalize_ty(cx, mt.ty), mutbl: mt.mutbl }\n+        mt { ty: normalize_ty(cx, mt.ty), mutbl: mt.mutbl }\n     }\n     fn normalize_vstore(vstore: vstore) -> vstore {\n         match vstore {"}, {"sha": "7e1c5f54134e197cfe3d29ed81e3ff19b6a8eab1", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -185,7 +185,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n     fn ast_mt_to_mt<AC: ast_conv, RS: region_scope Copy Durable>(\n         self: AC, rscope: RS, mt: ast::mt) -> ty::mt {\n \n-        return {ty: ast_ty_to_ty(self, rscope, mt.ty), mutbl: mt.mutbl};\n+        ty::mt {ty: ast_ty_to_ty(self, rscope, mt.ty), mutbl: mt.mutbl}\n     }\n \n     // Handle @, ~, and & being able to mean estrs and evecs.\n@@ -204,7 +204,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n             ast::ty_vec(mt) => {\n                 let mut mt = ast_mt_to_mt(self, rscope, mt);\n                 if a_seq_ty.mutbl == ast::m_mutbl {\n-                    mt = { ty: mt.ty, mutbl: ast::m_mutbl };\n+                    mt = ty::mt { ty: mt.ty, mutbl: ast::m_mutbl };\n                 }\n                 return ty::mk_evec(tcx, mt, vst);\n             }"}, {"sha": "9861178afb0ef9c4f03b68b531aa41c4bc2b6a6e", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -377,7 +377,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             let region_var =\n                 fcx.infcx().next_region_var_with_lb(\n                     pat.span, pcx.block_region);\n-            let mt = {ty: expected, mutbl: mutbl};\n+            let mt = ty::mt {ty: expected, mutbl: mutbl};\n             let region_ty = ty::mk_rptr(tcx, region_var, mt);\n             demand::eqtype(fcx, pat.span, region_ty, typ);\n           }\n@@ -575,7 +575,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         match tail {\n             Some(tail_pat) => {\n                 let slice_ty = ty::mk_evec(tcx,\n-                    {ty: elt_type.ty, mutbl: elt_type.mutbl},\n+                    ty::mt {ty: elt_type.ty, mutbl: elt_type.mutbl},\n                     ty::vstore_slice(region_var)\n                 );\n                 check_pat(pcx, tail_pat, slice_ty);"}, {"sha": "a8e834bff435f7f78b9a628304d24ca6d2c8248e", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -731,7 +731,7 @@ impl LookupContext {\n                 let entry = self.search_for_some_kind_of_autorefd_method(\n                     AutoBorrowVec, autoderefs, [m_const, m_imm, m_mutbl],\n                     |m,r| ty::mk_evec(tcx,\n-                                      {ty:mt.ty, mutbl:m},\n+                                      ty::mt {ty:mt.ty, mutbl:m},\n                                       vstore_slice(r)));\n \n                 if entry.is_some() { return entry; }\n@@ -741,14 +741,14 @@ impl LookupContext {\n                     AutoBorrowVecRef, autoderefs, [m_const, m_imm, m_mutbl],\n                     |m,r| {\n                         let slice_ty = ty::mk_evec(tcx,\n-                                                   {ty:mt.ty, mutbl:m},\n+                                                   ty::mt {ty:mt.ty, mutbl:m},\n                                                    vstore_slice(r));\n                         // NB: we do not try to autoref to a mutable\n                         // pointer. That would be creating a pointer\n                         // to a temporary pointer (the borrowed\n                         // slice), so any update the callee makes to\n                         // it can't be observed.\n-                        ty::mk_rptr(tcx, r, {ty:slice_ty, mutbl:m_imm})\n+                        ty::mk_rptr(tcx, r, ty::mt {ty:slice_ty, mutbl:m_imm})\n                     })\n             }\n \n@@ -765,7 +765,7 @@ impl LookupContext {\n                     AutoBorrowVecRef, autoderefs, [m_imm],\n                     |m,r| {\n                         let slice_ty = ty::mk_estr(tcx, vstore_slice(r));\n-                        ty::mk_rptr(tcx, r, {ty:slice_ty, mutbl:m})\n+                        ty::mk_rptr(tcx, r, ty::mt {ty:slice_ty, mutbl:m})\n                     })\n             }\n \n@@ -802,7 +802,7 @@ impl LookupContext {\n             ty_trait(*) | ty_fn(*) => {\n                 self.search_for_some_kind_of_autorefd_method(\n                     AutoPtr, autoderefs, [m_const, m_imm, m_mutbl],\n-                    |m,r| ty::mk_rptr(tcx, r, {ty:self_ty, mutbl:m}))\n+                    |m,r| ty::mk_rptr(tcx, r, ty::mt {ty:self_ty, mutbl:m}))\n             }\n \n             ty_err => None,\n@@ -1183,20 +1183,20 @@ fn transform_self_type_for_method(tcx: ty::ctxt,\n       sty_region(mutability) => {\n         mk_rptr(tcx,\n                 self_region.expect(~\"self region missing for &self param\"),\n-                { ty: impl_ty, mutbl: mutability })\n+                ty::mt { ty: impl_ty, mutbl: mutability })\n       }\n       sty_box(mutability) => {\n         match flag {\n             TransformTypeNormally => {\n-                mk_box(tcx, { ty: impl_ty, mutbl: mutability })\n+                mk_box(tcx, ty::mt { ty: impl_ty, mutbl: mutability })\n             }\n             TransformTypeForObject => impl_ty\n         }\n       }\n       sty_uniq(mutability) => {\n         match flag {\n             TransformTypeNormally => {\n-                mk_uniq(tcx, { ty: impl_ty, mutbl: mutability })\n+                mk_uniq(tcx, ty::mt { ty: impl_ty, mutbl: mutability })\n             }\n             TransformTypeForObject => impl_ty\n         }"}, {"sha": "8365c261decee6b03dab76217a71c8faa2985076", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -1936,15 +1936,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             }\n             let t: ty::t = fcx.infcx().next_ty_var();\n             for args.each |e| { bot |= check_expr_with(fcx, *e, t); }\n-            ty::mk_evec(tcx, {ty: t, mutbl: mutability}, tt)\n+            ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutability}, tt)\n           }\n           ast::expr_repeat(element, count_expr, mutbl) => {\n             let count = ty::eval_repeat_count(tcx, count_expr, expr.span);\n             fcx.write_ty(count_expr.id, ty::mk_uint(tcx));\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, count, vst);\n             let t: ty::t = fcx.infcx().next_ty_var();\n             bot |= check_expr_with(fcx, element, t);\n-            ty::mk_evec(tcx, {ty: t, mutbl: mutbl}, tt)\n+            ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutbl}, tt)\n           }\n           _ =>\n             tcx.sess.span_bug(expr.span, ~\"vstore modifier on non-sequence\")\n@@ -1986,10 +1986,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let mut oprnd_t = fcx.expr_ty(oprnd);\n         match unop {\n           ast::box(mutbl) => {\n-            oprnd_t = ty::mk_box(tcx, {ty: oprnd_t, mutbl: mutbl});\n+            oprnd_t = ty::mk_box(tcx, ty::mt {ty: oprnd_t, mutbl: mutbl});\n           }\n           ast::uniq(mutbl) => {\n-            oprnd_t = ty::mk_uniq(tcx, {ty: oprnd_t, mutbl: mutbl});\n+            oprnd_t = ty::mk_uniq(tcx, ty::mt {ty: oprnd_t, mutbl: mutbl});\n           }\n           ast::deref => {\n             let sty = structure_of(fcx, expr.span, oprnd_t);\n@@ -2075,7 +2075,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // it needs to live.\n         let region = fcx.infcx().next_region_var(expr.span, expr.id);\n \n-        let tm = { ty: fcx.expr_ty(oprnd), mutbl: mutbl };\n+        let tm = ty::mt { ty: fcx.expr_ty(oprnd), mutbl: mutbl };\n         let oprnd_t = ty::mk_rptr(tcx, region, tm);\n         fcx.write_ty(id, oprnd_t);\n       }\n@@ -2339,7 +2339,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       ast::expr_vec(args, mutbl) => {\n         let t: ty::t = fcx.infcx().next_ty_var();\n         for args.each |e| { bot |= check_expr_with(fcx, *e, t); }\n-        let typ = ty::mk_evec(tcx, {ty: t, mutbl: mutbl},\n+        let typ = ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutbl},\n                               ty::vstore_fixed(args.len()));\n         fcx.write_ty(id, typ);\n       }\n@@ -2348,7 +2348,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         fcx.write_ty(count_expr.id, ty::mk_uint(tcx));\n         let t: ty::t = fcx.infcx().next_ty_var();\n         bot |= check_expr_with(fcx, element, t);\n-        let t = ty::mk_evec(tcx, {ty: t, mutbl: mutbl},\n+        let t = ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutbl},\n                             ty::vstore_fixed(count));\n         fcx.write_ty(id, t);\n       }\n@@ -2379,7 +2379,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 vec::find(*flds, |tf| tf.ident == f.node.ident)\n             ).map(|tf| tf.mt.ty));\n             let expr_t = fcx.expr_ty(f.node.expr);\n-            let expr_mt = {ty: expr_t, mutbl: f.node.mutbl};\n+            let expr_mt = ty::mt {ty: expr_t, mutbl: f.node.mutbl};\n             // for the most precise error message,\n             // should be f.node.expr.span, not f.span\n             respan(f.node.expr.span, {ident: f.node.ident, mt: expr_mt})\n@@ -2804,7 +2804,7 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n             region_param: None,\n             ty: ty::mk_ptr(\n                 fcx.ccx.tcx,\n-                {\n+                ty::mt {\n                     ty: ty::mk_mach_uint(fcx.ccx.tcx, ast::ty_u8),\n                     mutbl: ast::m_imm\n                 })\n@@ -3078,8 +3078,8 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n           assert ccx.tcx.intrinsic_defs.contains_key(ty_visitor_name);\n           let (_, tydesc_ty) = tcx.intrinsic_defs.get(tydesc_name);\n           let (_, visitor_trait) = tcx.intrinsic_defs.get(ty_visitor_name);\n-          let td_ptr = ty::mk_ptr(ccx.tcx, {ty: tydesc_ty,\n-                                            mutbl: ast::m_imm});\n+          let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {ty: tydesc_ty,\n+                                                   mutbl: ast::m_imm});\n           (0u, ~[arg(ast::by_val, td_ptr),\n                  arg(ast::by_ref, visitor_trait)], ty::mk_nil(tcx))\n       }"}, {"sha": "b22b061883c73c1117de850ed1eb0331cf341c82", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -63,7 +63,7 @@ pub fn replace_bound_regions_in_fn_sig(\n                                           _}, _}) => {\n         let region = ty::re_bound(ty::br_self);\n         let ty = ty::mk_rptr(tcx, region,\n-                             { ty: ty::mk_self(tcx), mutbl: m });\n+                             ty::mt { ty: ty::mk_self(tcx), mutbl: m });\n         all_tys.push(ty);\n       }\n       _ => {}"}, {"sha": "d25fed274b3e3d539f0ff7c1918cfd270d45c8a8", "filename": "src/librustc/middle/typeck/infer/assignment.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -173,14 +173,16 @@ priv impl Assign {\n                     // being assigned to a region pointer:\n                     (ty::ty_box(_), ty::ty_rptr(r_b, mt_b)) => {\n                         let nr_b = ty::mk_box(self.infcx.tcx,\n-                                              {ty: mt_b.ty, mutbl: m_const});\n+                                              ty::mt {ty: mt_b.ty,\n+                                                      mutbl: m_const});\n                         self.try_assign(1, ty::AutoPtr,\n                                         a, nr_b,\n                                         mt_b.mutbl, r_b)\n                     }\n                     (ty::ty_uniq(_), ty::ty_rptr(r_b, mt_b)) => {\n                         let nr_b = ty::mk_uniq(self.infcx.tcx,\n-                                               {ty: mt_b.ty, mutbl: m_const});\n+                                               ty::mt {ty: mt_b.ty,\n+                                                       mutbl: m_const});\n                         self.try_assign(1, ty::AutoPtr,\n                                         a, nr_b,\n                                         mt_b.mutbl, r_b)\n@@ -198,7 +200,8 @@ priv impl Assign {\n                      ty::ty_evec(mt_b, ty::vstore_slice(r_b)))\n                     if is_borrowable(vs_a) => {\n                         let nr_b = ty::mk_evec(self.infcx.tcx,\n-                                               {ty: mt_b.ty, mutbl: m_const},\n+                                               ty::mt {ty: mt_b.ty,\n+                                                       mutbl: m_const},\n                                                vs_a);\n                         self.try_assign(0, ty::AutoBorrowVec,\n                                         a, nr_b,"}, {"sha": "aa718cbe36c3d357db781eb9a2351f5d1dc3dcfb", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -50,17 +50,17 @@ impl Glb: Combine {\n           // the precise type from the mut side.\n           (m_mutbl, m_const) => {\n             Sub(*self).tys(a.ty, b.ty).chain(|_t| {\n-                Ok({ty: a.ty, mutbl: m_mutbl})\n+                Ok(ty::mt {ty: a.ty, mutbl: m_mutbl})\n             })\n           }\n           (m_const, m_mutbl) => {\n             Sub(*self).tys(b.ty, a.ty).chain(|_t| {\n-                Ok({ty: b.ty, mutbl: m_mutbl})\n+                Ok(ty::mt {ty: b.ty, mutbl: m_mutbl})\n             })\n           }\n           (m_mutbl, m_mutbl) => {\n             eq_tys(&self, a.ty, b.ty).then(|| {\n-                Ok({ty: a.ty, mutbl: m_mutbl})\n+                Ok(ty::mt {ty: a.ty, mutbl: m_mutbl})\n             })\n           }\n \n@@ -70,15 +70,15 @@ impl Glb: Combine {\n           (m_const, m_imm) |\n           (m_imm, m_imm) => {\n             self.tys(a.ty, b.ty).chain(|t| {\n-                Ok({ty: t, mutbl: m_imm})\n+                Ok(ty::mt {ty: t, mutbl: m_imm})\n             })\n           }\n \n           // If both sides are const, then we can use GLB of both\n           // sides and mutbl of only `m_const`.\n           (m_const, m_const) => {\n             self.tys(a.ty, b.ty).chain(|t| {\n-                Ok({ty: t, mutbl: m_const})\n+                Ok(ty::mt {ty: t, mutbl: m_const})\n             })\n           }\n "}, {"sha": "a6ae3cdb4fdbac1a35dadddef2167dd0fd90dc28", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -59,17 +59,17 @@ impl Lub: Combine {\n \n         match m {\n           m_imm | m_const => {\n-            self.tys(a.ty, b.ty).chain(|t| Ok({ty: t, mutbl: m}) )\n+            self.tys(a.ty, b.ty).chain(|t| Ok(ty::mt {ty: t, mutbl: m}) )\n           }\n \n           m_mutbl => {\n             self.infcx.try(|| {\n                 eq_tys(&self, a.ty, b.ty).then(|| {\n-                    Ok({ty: a.ty, mutbl: m})\n+                    Ok(ty::mt {ty: a.ty, mutbl: m})\n                 })\n             }).chain_err(|_e| {\n                 self.tys(a.ty, b.ty).chain(|t| {\n-                    Ok({ty: t, mutbl: m_const})\n+                    Ok(ty::mt {ty: t, mutbl: m_const})\n                 })\n             })\n           }"}, {"sha": "6f2ffe00849717a5d90b971e8757b8bfd5c2dff5", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 45, "deletions": 19, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -293,10 +293,11 @@ type crate_cfg = ~[@meta_item];\n \n type crate = spanned<crate_>;\n \n-type crate_ =\n-    {module: _mod,\n-     attrs: ~[attribute],\n-     config: crate_cfg};\n+struct crate_ {\n+    module: _mod,\n+    attrs: ~[attribute],\n+    config: crate_cfg,\n+}\n \n type meta_item = spanned<meta_item_>;\n \n@@ -312,19 +313,28 @@ type blk = spanned<blk_>;\n \n #[auto_encode]\n #[auto_decode]\n-type blk_ = {view_items: ~[@view_item],\n-             stmts: ~[@stmt],\n-             expr: Option<@expr>,\n-             id: node_id,\n-             rules: blk_check_mode};\n+struct blk_ {\n+    view_items: ~[@view_item],\n+    stmts: ~[@stmt],\n+    expr: Option<@expr>,\n+    id: node_id,\n+    rules: blk_check_mode,\n+}\n \n #[auto_encode]\n #[auto_decode]\n-type pat = {id: node_id, node: pat_, span: span};\n+struct pat {\n+    id: node_id,\n+    node: pat_,\n+    span: span,\n+}\n \n #[auto_encode]\n #[auto_decode]\n-type field_pat = {ident: ident, pat: @pat};\n+struct field_pat {\n+    ident: ident,\n+    pat: @pat,\n+}\n \n #[auto_encode]\n #[auto_decode]\n@@ -634,8 +644,13 @@ enum stmt_ {\n // a refinement on pat.\n #[auto_encode]\n #[auto_decode]\n-type local_ =  {is_mutbl: bool, ty: @Ty, pat: @pat,\n-                init: Option<@expr>, id: node_id};\n+struct local_ {\n+    is_mutbl: bool,\n+    ty: @Ty,\n+    pat: @pat,\n+    init: Option<@expr>,\n+    id: node_id,\n+}\n \n type local = spanned<local_>;\n \n@@ -647,11 +662,19 @@ enum decl_ { decl_local(~[@local]), decl_item(@item), }\n \n #[auto_encode]\n #[auto_decode]\n-type arm = {pats: ~[@pat], guard: Option<@expr>, body: blk};\n+struct arm {\n+    pats: ~[@pat],\n+    guard: Option<@expr>,\n+    body: blk,\n+}\n \n #[auto_encode]\n #[auto_decode]\n-type field_ = {mutbl: mutability, ident: ident, expr: @expr};\n+struct field_ {\n+    mutbl: mutability,\n+    ident: ident,\n+    expr: @expr,\n+}\n \n type field = spanned<field_>;\n \n@@ -743,12 +766,12 @@ enum expr_ {\n \n #[auto_encode]\n #[auto_decode]\n-type capture_item_ = {\n+struct capture_item_ {\n     id: int,\n     is_move: bool,\n     name: ident, // Currently, can only capture a local var.\n-    span: span\n-};\n+    span: span,\n+}\n \n type capture_item = @capture_item_;\n \n@@ -904,7 +927,10 @@ impl lit_: cmp::Eq {\n // type structure in middle/ty.rs as well.\n #[auto_encode]\n #[auto_decode]\n-type mt = {ty: @Ty, mutbl: mutability};\n+struct mt {\n+    ty: @Ty,\n+    mutbl: mutability,\n+}\n \n #[auto_encode]\n #[auto_decode]"}, {"sha": "d744a3e01ccf8a4fcc86d8e298576eb89c2550cd", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -289,10 +289,18 @@ fn block_from_expr(e: @expr) -> blk {\n     return spanned {node: blk_, span: e.span};\n }\n \n-fn default_block(+stmts1: ~[@stmt], expr1: Option<@expr>, id1: node_id) ->\n-   blk_ {\n-    {view_items: ~[], stmts: stmts1,\n-     expr: expr1, id: id1, rules: default_blk}\n+fn default_block(\n+    +stmts1: ~[@stmt],\n+    expr1: Option<@expr>,\n+    id1: node_id\n+) -> blk_ {\n+    ast::blk_ {\n+        view_items: ~[],\n+        stmts: stmts1,\n+        expr: expr1,\n+        id: id1,\n+        rules: default_blk,\n+    }\n }\n \n fn ident_to_path(s: span, +i: ident) -> @path {\n@@ -304,9 +312,9 @@ fn ident_to_path(s: span, +i: ident) -> @path {\n }\n \n fn ident_to_pat(id: node_id, s: span, +i: ident) -> @pat {\n-    @{id: id,\n-      node: pat_ident(bind_by_value, ident_to_path(s, i), None),\n-      span: s}\n+    @ast::pat { id: id,\n+                node: pat_ident(bind_by_value, ident_to_path(s, i), None),\n+                span: s }\n }\n \n pure fn is_unguarded(a: &arm) -> bool {"}, {"sha": "e241f6435d3d468d214eec68a4c6edb068a27d62", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 69, "deletions": 45, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -317,11 +317,14 @@ priv impl ext_ctxt {\n     }\n \n     fn binder_pat(span: span, nm: ast::ident) -> @ast::pat {\n-        @{id: self.next_id(),\n-          node: ast::pat_ident(ast::bind_by_ref(ast::m_imm),\n-                               self.path(span, ~[nm]),\n-                               None),\n-          span: span}\n+        @ast::pat {\n+            id: self.next_id(),\n+            node: ast::pat_ident(\n+                ast::bind_by_ref(ast::m_imm),\n+                self.path(span, ~[nm]),\n+                None),\n+            span: span,\n+        }\n     }\n \n     fn stmt(expr: @ast::expr) -> @ast::stmt {\n@@ -356,21 +359,29 @@ priv impl ext_ctxt {\n     }\n \n     fn blk(span: span, stmts: ~[@ast::stmt]) -> ast::blk {\n-        ast::spanned { node: { view_items: ~[],\n-                               stmts: stmts,\n-                               expr: None,\n-                               id: self.next_id(),\n-                               rules: ast::default_blk},\n-                       span: span }\n+        ast::spanned {\n+            node: ast::blk_ {\n+                view_items: ~[],\n+                stmts: stmts,\n+                expr: None,\n+                id: self.next_id(),\n+                rules: ast::default_blk,\n+            },\n+            span: span,\n+        }\n     }\n \n     fn expr_blk(expr: @ast::expr) -> ast::blk {\n-        ast::spanned { node: { view_items: ~[],\n-                               stmts: ~[],\n-                               expr: Some(expr),\n-                               id: self.next_id(),\n-                               rules: ast::default_blk},\n-                       span: expr.span }\n+        ast::spanned {\n+            node: ast::blk_ {\n+                view_items: ~[],\n+                stmts: ~[],\n+                expr: Some(expr),\n+                id: self.next_id(),\n+                rules: ast::default_blk,\n+            },\n+            span: expr.span,\n+        }\n     }\n \n     fn expr_path(span: span, strs: ~[ast::ident]) -> @ast::expr {\n@@ -560,7 +571,7 @@ fn mk_ser_method(\n                 id: cx.next_id(),\n                 node: ast::re_anon,\n             },\n-            {\n+            ast::mt {\n                 ty: cx.ty_path(span, ~[cx.ident_of(~\"__S\")], ~[]),\n                 mutbl: ast::m_imm\n             }\n@@ -571,12 +582,14 @@ fn mk_ser_method(\n     let ser_inputs = ~[{\n         mode: ast::infer(cx.next_id()),\n         ty: ty_s,\n-        pat: @{id: cx.next_id(),\n-               node: ast::pat_ident(\n-                    ast::bind_by_value,\n-                    ast_util::ident_to_path(span, cx.ident_of(~\"__s\")),\n-                    None),\n-               span: span},\n+        pat: @ast::pat {\n+            id: cx.next_id(),\n+            node: ast::pat_ident(\n+                ast::bind_by_value,\n+                ast_util::ident_to_path(span, cx.ident_of(~\"__s\")),\n+                None),\n+            span: span,\n+        },\n         id: cx.next_id(),\n     }];\n \n@@ -621,7 +634,7 @@ fn mk_deser_method(\n                 id: cx.next_id(),\n                 node: ast::re_anon,\n             },\n-            {\n+            ast::mt {\n                 ty: cx.ty_path(span, ~[cx.ident_of(~\"__D\")], ~[]),\n                 mutbl: ast::m_imm\n             }\n@@ -632,12 +645,14 @@ fn mk_deser_method(\n     let deser_inputs = ~[{\n         mode: ast::infer(cx.next_id()),\n         ty: ty_d,\n-        pat: @{id: cx.next_id(),\n-               node: ast::pat_ident(\n-                    ast::bind_by_value,\n-                    ast_util::ident_to_path(span, cx.ident_of(~\"__d\")),\n-                    None),\n-               span: span},\n+        pat: @ast::pat {\n+            id: cx.next_id(),\n+            node: ast::pat_ident(\n+                ast::bind_by_value,\n+                ast_util::ident_to_path(span, cx.ident_of(~\"__d\")),\n+                None),\n+            span: span,\n+        },\n         id: cx.next_id(),\n     }];\n \n@@ -893,7 +908,11 @@ fn mk_deser_fields(\n         );\n \n         ast::spanned {\n-            node: { mutbl: field.mutbl, ident: field.ident, expr: expr },\n+            node: ast::field_ {\n+                mutbl: field.mutbl,\n+                ident: field.ident,\n+                expr: expr,\n+            },\n             span: span,\n         }\n     }\n@@ -959,7 +978,7 @@ fn ser_variant(\n         )\n     };\n \n-    let pat = @{\n+    let pat = @ast::pat {\n         id: cx.next_id(),\n         node: pat_node,\n         span: span,\n@@ -1012,7 +1031,7 @@ fn ser_variant(\n         ]\n     );\n \n-    { pats: ~[pat], guard: None, body: cx.expr_blk(body) }\n+    ast::arm { pats: ~[pat], guard: None, body: cx.expr_blk(body) }\n }\n \n fn mk_enum_ser_body(\n@@ -1124,21 +1143,25 @@ fn mk_enum_deser_body(\n                 fail ~\"enum variants unimplemented\",\n         };\n \n-        let pat = @{\n+        let pat = @ast::pat {\n             id: cx.next_id(),\n             node: ast::pat_lit(cx.lit_uint(span, v_idx)),\n             span: span,\n         };\n \n-        {\n+        ast::arm {\n             pats: ~[pat],\n             guard: None,\n             body: cx.expr_blk(body),\n         }\n     };\n \n-    let impossible_case = {\n-        pats: ~[@{ id: cx.next_id(), node: ast::pat_wild, span: span}],\n+    let impossible_case = ast::arm {\n+        pats: ~[@ast::pat {\n+            id: cx.next_id(),\n+            node: ast::pat_wild,\n+            span: span,\n+        }],\n         guard: None,\n \n         // FIXME(#3198): proper error message\n@@ -1159,13 +1182,14 @@ fn mk_enum_deser_body(\n                         node: ast::ty_infer,\n                         span: span\n                     },\n-                    pat: @{id: cx.next_id(),\n-                           node: ast::pat_ident(\n-                                ast::bind_by_value,\n-                                ast_util::ident_to_path(span,\n-                                                        cx.ident_of(~\"i\")),\n-                                None),\n-                           span: span},\n+                    pat: @ast::pat {\n+                        id: cx.next_id(),\n+                        node: ast::pat_ident(\n+                            ast::bind_by_value,\n+                            ast_util::ident_to_path(span, cx.ident_of(~\"i\")),\n+                            None),\n+                        span: span,\n+                    },\n                     id: cx.next_id(),\n                 }],\n                 output: @{"}, {"sha": "cc4c58f3504ccef4875f025f8df790e94e4e2458", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 51, "deletions": 36, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -145,8 +145,10 @@ fn mk_uniq_str(cx: ext_ctxt, sp: span, s: ~str) -> @ast::expr {\n }\n fn mk_field(sp: span, f: &{ident: ast::ident, ex: @ast::expr})\n     -> ast::field {\n-    ast::spanned { node: {mutbl: ast::m_imm, ident: f.ident, expr: f.ex},\n-                   span: sp }\n+    ast::spanned {\n+        node: ast::field_ { mutbl: ast::m_imm, ident: f.ident, expr: f.ex },\n+        span: sp,\n+    }\n }\n fn mk_fields(sp: span, fields: ~[{ident: ast::ident, ex: @ast::expr}]) ->\n     ~[ast::field] {\n@@ -181,54 +183,67 @@ fn mk_glob_use(cx: ext_ctxt, sp: span,\n fn mk_local(cx: ext_ctxt, sp: span, mutbl: bool,\n             ident: ast::ident, ex: @ast::expr) -> @ast::stmt {\n \n-    let pat : @ast::pat = @{id: cx.next_id(),\n-                            node: ast::pat_ident(ast::bind_by_value,\n-                                                 mk_raw_path(sp, ~[ident]),\n-                                                 None),\n-                           span: sp};\n+    let pat = @ast::pat {\n+        id: cx.next_id(),\n+        node: ast::pat_ident(\n+            ast::bind_by_value,\n+            mk_raw_path(sp, ~[ident]),\n+            None),\n+        span: sp,\n+    };\n     let ty : @ast::Ty = @{ id: cx.next_id(), node: ast::ty_infer, span: sp };\n-    let local : @ast::local = @ast::spanned { node: { is_mutbl: mutbl,\n-                                                      ty: ty,\n-                                                      pat: pat,\n-                                                      init: Some(ex),\n-                                                      id: cx.next_id()},\n-                                              span: sp};\n+    let local = @ast::spanned {\n+        node: ast::local_ {\n+            is_mutbl: mutbl,\n+            ty: ty,\n+            pat: pat,\n+            init: Some(ex),\n+            id: cx.next_id(),\n+        },\n+        span: sp,\n+    };\n     let decl = ast::spanned {node: ast::decl_local(~[local]), span: sp};\n     @ast::spanned { node: ast::stmt_decl(@decl, cx.next_id()), span: sp }\n }\n-fn mk_block(cx: ext_ctxt, sp: span,\n+fn mk_block(cx: ext_ctxt, span: span,\n             view_items: ~[@ast::view_item],\n             stmts: ~[@ast::stmt],\n             expr: Option<@ast::expr>) -> @ast::expr {\n-    let blk = ast::spanned { node: { view_items: view_items,\n-                                     stmts: stmts,\n-                                     expr: expr,\n-                                     id: cx.next_id(),\n-                                     rules: ast::default_blk },\n-                             span: sp };\n-    mk_expr(cx, sp, ast::expr_block(blk))\n-}\n-fn mk_block_(cx: ext_ctxt, sp: span, +stmts: ~[@ast::stmt]) -> ast::blk {\n+    let blk = ast::spanned {\n+        node: ast::blk_ {\n+             view_items: view_items,\n+             stmts: stmts,\n+             expr: expr,\n+             id: cx.next_id(),\n+             rules: ast::default_blk,\n+        },\n+        span: span,\n+    };\n+    mk_expr(cx, span, ast::expr_block(blk))\n+}\n+fn mk_block_(cx: ext_ctxt, span: span, +stmts: ~[@ast::stmt]) -> ast::blk {\n     ast::spanned {\n-        node: {\n+        node: ast::blk_ {\n             view_items: ~[],\n-            stmts: move stmts,\n+            stmts: stmts,\n             expr: None,\n             id: cx.next_id(),\n-            rules: ast::default_blk\n+            rules: ast::default_blk,\n         },\n-        span: sp\n+        span: span,\n     }\n }\n fn mk_simple_block(cx: ext_ctxt, span: span, expr: @ast::expr) -> ast::blk {\n-    let block = {\n-        view_items: ~[],\n-        stmts: ~[],\n-        expr: Some(expr),\n-        id: cx.next_id(),\n-        rules: ast::default_blk\n-    };\n-    ast::spanned { node: block, span: span }\n+    ast::spanned {\n+        node: ast::blk_ {\n+            view_items: ~[],\n+            stmts: ~[],\n+            expr: Some(expr),\n+            id: cx.next_id(),\n+            rules: ast::default_blk,\n+        },\n+        span: span,\n+    }\n }\n fn mk_copy(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_copy(e))\n@@ -237,7 +252,7 @@ fn mk_managed(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_unary(ast::box(ast::m_imm), e))\n }\n fn mk_pat(cx: ext_ctxt, span: span, +pat: ast::pat_) -> @ast::pat {\n-    @{ id: cx.next_id(), node: move pat, span: span }\n+    @ast::pat { id: cx.next_id(), node: pat, span: span }\n }\n fn mk_pat_ident(cx: ext_ctxt, span: span, ident: ast::ident) -> @ast::pat {\n     let path = mk_raw_path(span, ~[ ident ]);"}, {"sha": "83d968bb2ac2af35dd6273ac2811c5a54b364430", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -136,7 +136,10 @@ fn create_eq_method(cx: ext_ctxt,\n                                                      type_ident,\n                                                      ty_params);\n     let arg_region = @{ id: cx.next_id(), node: re_anon };\n-    let arg_type = ty_rptr(arg_region, { ty: arg_path_type, mutbl: m_imm });\n+    let arg_type = ty_rptr(\n+        arg_region,\n+        ast::mt { ty: arg_path_type, mutbl: m_imm }\n+    );\n     let arg_type = @{ id: cx.next_id(), node: move arg_type, span: span };\n \n     // Create the `other` parameter.\n@@ -374,22 +377,17 @@ fn create_enum_variant_pattern(cx: ext_ctxt,\n                                              prefix,\n                                              struct_def.fields.len());\n \n-            let field_pats = dvec::DVec();\n-            for struct_def.fields.eachi |i, struct_field| {\n+            let field_pats = do struct_def.fields.mapi |i, struct_field| {\n                 let ident = match struct_field.node.kind {\n                     named_field(ident, _, _) => ident,\n                     unnamed_field => {\n                         cx.span_bug(span, ~\"unexpected unnamed field\");\n                     }\n                 };\n-                field_pats.push({ ident: ident, pat: subpats[i] });\n-            }\n-            let field_pats = dvec::unwrap(move field_pats);\n+                ast::field_pat { ident: ident, pat: subpats[i] }\n+            };\n \n-            return build::mk_pat_struct(cx,\n-                                        span,\n-                                        matching_path,\n-                                        move field_pats);\n+            build::mk_pat_struct(cx, span, matching_path, field_pats)\n         }\n         enum_variant_kind(*) => {\n             cx.span_unimpl(span, ~\"enum variants for `deriving`\");\n@@ -732,7 +730,7 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n                                                          matching_body_expr);\n \n         // Create the matching arm.\n-        let matching_arm = {\n+        let matching_arm = ast::arm {\n             pats: ~[ matching_pat ],\n             guard: None,\n             body: move matching_body_block\n@@ -743,7 +741,7 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n         // variant then there will always be a match.\n         if enum_definition.variants.len() > 1 {\n             // Create the nonmatching pattern.\n-            let nonmatching_pat = @{\n+            let nonmatching_pat = @ast::pat {\n                 id: cx.next_id(),\n                 node: pat_wild,\n                 span: span\n@@ -757,12 +755,12 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n                                        nonmatching_expr);\n \n             // Create the nonmatching arm.\n-            let nonmatching_arm = {\n+            let nonmatching_arm = ast::arm {\n                 pats: ~[ nonmatching_pat ],\n                 guard: None,\n-                body: move nonmatching_body_block\n+                body: nonmatching_body_block,\n             };\n-            other_arms.push(move nonmatching_arm);\n+            other_arms.push(nonmatching_arm);\n         }\n \n         // Create the self pattern.\n@@ -784,10 +782,10 @@ fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n                                                             other_match_expr);\n \n         // Create the self arm.\n-        let self_arm = {\n+        let self_arm = ast::arm {\n             pats: ~[ self_pat ],\n             guard: None,\n-            body: move other_match_body_block\n+            body: other_match_body_block,\n         };\n         self_arms.push(move self_arm);\n     }\n@@ -813,8 +811,7 @@ fn expand_deriving_iter_bytes_enum_method(cx: ext_ctxt,\n                                           enum_definition: &enum_def)\n                                        -> @method {\n     // Create the arms of the match in the method body.\n-    let arms = dvec::DVec();\n-    for enum_definition.variants.eachi |i, variant| {\n+    let arms = do enum_definition.variants.mapi |i, variant| {\n         // Create the matching pattern.\n         let pat = create_enum_variant_pattern(cx, span, variant, ~\"__self\");\n \n@@ -850,24 +847,22 @@ fn expand_deriving_iter_bytes_enum_method(cx: ext_ctxt,\n         let match_body_block = build::mk_block_(cx, span, move stmts);\n \n         // Create the arm.\n-        let arm = {\n+        ast::arm {\n             pats: ~[ pat ],\n             guard: None,\n-            body: move match_body_block\n-        };\n-        arms.push(move arm);\n-    }\n+            body: match_body_block,\n+        }\n+    };\n \n     // Create the method body.\n     let self_ident = cx.ident_of(~\"self\");\n     let self_expr = build::mk_path(cx, span, ~[ self_ident ]);\n     let self_expr = build::mk_unary(cx, span, deref, self_expr);\n-    let arms = dvec::unwrap(move arms);\n-    let self_match_expr = expr_match(self_expr, move arms);\n-    let self_match_expr = build::mk_expr(cx, span, move self_match_expr);\n+    let self_match_expr = expr_match(self_expr, arms);\n+    let self_match_expr = build::mk_expr(cx, span, self_match_expr);\n     let self_match_stmt = build::mk_stmt(cx, span, self_match_expr);\n \n     // Create the method.\n-    return create_iter_bytes_method(cx, span, ~[ self_match_stmt ]);\n+    create_iter_bytes_method(cx, span, ~[ self_match_stmt ])\n }\n "}, {"sha": "19cbf833c0fae5d3c582a86a415a1ee6b0a4a28f", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -146,8 +146,10 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n     }\n \n     fn field_imm(name: ident, e: @ast::expr) -> ast::field {\n-        spanned { node: { mutbl: ast::m_imm, ident: name, expr: e },\n-                  span: dummy_sp()}\n+        spanned {\n+            node: ast::field_ { mutbl: ast::m_imm, ident: name, expr: e },\n+            span: dummy_sp(),\n+        }\n     }\n \n     fn rec(+fields: ~[ast::field]) -> @ast::expr {\n@@ -158,8 +160,13 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n     }\n \n     fn ty_field_imm(name: ident, ty: @ast::Ty) -> ast::ty_field {\n-        spanned { node: { ident: name, mt: { ty: ty, mutbl: ast::m_imm } },\n-                  span: dummy_sp() }\n+        spanned {\n+            node: {\n+                ident: name,\n+                mt: ast::mt { ty: ty, mutbl: ast::m_imm },\n+            },\n+            span: dummy_sp(),\n+        }\n     }\n \n     fn ty_rec(+fields: ~[ast::ty_field]) -> @ast::Ty {\n@@ -181,23 +188,29 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n     }\n \n     fn arg(name: ident, ty: @ast::Ty) -> ast::arg {\n-        {mode: ast::infer(self.next_id()),\n-         ty: ty,\n-         pat: @{id: self.next_id(),\n+        {\n+            mode: ast::infer(self.next_id()),\n+            ty: ty,\n+            pat: @ast::pat {\n+                id: self.next_id(),\n                 node: ast::pat_ident(\n                     ast::bind_by_value,\n                     ast_util::ident_to_path(dummy_sp(), name),\n                     None),\n-                span: dummy_sp()},\n-         id: self.next_id()}\n+                span: dummy_sp(),\n+            },\n+            id: self.next_id(),\n+        }\n     }\n \n     fn block(+stmts: ~[@ast::stmt], e: @ast::expr) -> ast::blk {\n-        let blk = {view_items: ~[],\n-                   stmts: stmts,\n-                   expr: Some(e),\n-                   id: self.next_id(),\n-                   rules: ast::default_blk};\n+        let blk = ast::blk_ {\n+            view_items: ~[],\n+            stmts: stmts,\n+            expr: Some(e),\n+            id: self.next_id(),\n+            rules: ast::default_blk,\n+        };\n \n         spanned { node: blk, span: dummy_sp() }\n     }"}, {"sha": "23915ea189bbe00df72bff823640edd12dfbe7af", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 63, "deletions": 41, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -165,11 +165,11 @@ fn noop_fold_crate(c: crate_, fld: ast_fold) -> crate_ {\n     let fold_meta_item = |x| fold_meta_item_(x, fld);\n     let fold_attribute = |x| fold_attribute_(x, fld);\n \n-    return {\n+    crate_ {\n         module: fld.fold_mod(c.module),\n-        attrs: vec::map(c.attrs, |x| fold_attribute(*x)),\n-        config: vec::map(c.config, |x| fold_meta_item(*x))\n-    };\n+        attrs: c.attrs.map(|x| fold_attribute(*x)),\n+        config: c.config.map(|x| fold_meta_item(*x)),\n+    }\n }\n \n fn noop_fold_view_item(vi: view_item_, _fld: ast_fold) -> view_item_ {\n@@ -319,11 +319,13 @@ fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n \n \n fn noop_fold_block(b: blk_, fld: ast_fold) -> blk_ {\n-    return {view_items: vec::map(b.view_items, |x| fld.fold_view_item(*x)),\n-         stmts: vec::map(b.stmts, |x| fld.fold_stmt(*x)),\n-         expr: option::map(&b.expr, |x| fld.fold_expr(*x)),\n-         id: fld.new_id(b.id),\n-         rules: b.rules};\n+    ast::blk_ {\n+        view_items: b.view_items.map(|x| fld.fold_view_item(*x)),\n+        stmts: b.stmts.map(|x| fld.fold_stmt(*x)),\n+        expr: b.expr.map(|x| fld.fold_expr(*x)),\n+        id: fld.new_id(b.id),\n+        rules: b.rules,\n+    }\n }\n \n fn noop_fold_stmt(s: stmt_, fld: ast_fold) -> stmt_ {\n@@ -337,9 +339,11 @@ fn noop_fold_stmt(s: stmt_, fld: ast_fold) -> stmt_ {\n }\n \n fn noop_fold_arm(a: arm, fld: ast_fold) -> arm {\n-    return {pats: vec::map(a.pats, |x| fld.fold_pat(*x)),\n-         guard: option::map(&a.guard, |x| fld.fold_expr(*x)),\n-         body: fld.fold_block(a.body)};\n+    arm {\n+        pats: vec::map(a.pats, |x| fld.fold_pat(*x)),\n+        guard: option::map(&a.guard, |x| fld.fold_expr(*x)),\n+        body: fld.fold_block(a.body),\n+    }\n }\n \n fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n@@ -356,20 +360,22 @@ fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n                        |pats| vec::map(*pats, |x| fld.fold_pat(*x))))\n           }\n           pat_rec(fields, etc) => {\n-            let mut fs = ~[];\n-            for fields.each |f| {\n-                fs.push({ident: /* FIXME (#2543) */ copy f.ident,\n-                         pat: fld.fold_pat(f.pat)});\n-            }\n+            let fs = do fields.map |f| {\n+                ast::field_pat {\n+                    ident: /* FIXME (#2543) */ copy f.ident,\n+                    pat: fld.fold_pat(f.pat),\n+                }\n+            };\n             pat_rec(fs, etc)\n           }\n           pat_struct(pth, fields, etc) => {\n             let pth_ = fld.fold_path(pth);\n-            let mut fs = ~[];\n-            for fields.each |f| {\n-                fs.push({ident: /* FIXME (#2543) */ copy f.ident,\n-                         pat: fld.fold_pat(f.pat)});\n-            }\n+            let fs = do fields.map |f| {\n+                ast::field_pat {\n+                    ident: /* FIXME (#2543) */ copy f.ident,\n+                    pat: fld.fold_pat(f.pat)\n+                }\n+            };\n             pat_struct(pth_, fs, etc)\n           }\n           pat_tup(elts) => pat_tup(vec::map(elts, |x| fld.fold_pat(*x))),\n@@ -406,10 +412,14 @@ fn wrap<T>(f: fn@(T, ast_fold) -> T)\n \n fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n     fn fold_field_(field: field, fld: ast_fold) -> field {\n-        spanned { node: { mutbl: field.node.mutbl,\n-                          ident: fld.fold_ident(field.node.ident),\n-                          expr: fld.fold_expr(field.node.expr)},\n-                  span: fld.new_span(field.span) }\n+        spanned {\n+            node: ast::field_ {\n+                mutbl: field.node.mutbl,\n+                ident: fld.fold_ident(field.node.ident),\n+                expr: fld.fold_expr(field.node.expr),\n+            },\n+            span: fld.new_span(field.span),\n+        }\n     }\n     let fold_field = |x| fold_field_(x, fld);\n \n@@ -466,17 +476,25 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n                      vec::map((*arms), |x| fld.fold_arm(*x)))\n           }\n           expr_fn(proto, decl, ref body, captures) => {\n+            let captures = do captures.map |cap_item| {\n+                @ast::capture_item_ {\n+                    id: fld.new_id(cap_item.id),\n+                    ..**cap_item\n+                }\n+            };\n             expr_fn(proto, fold_fn_decl(decl, fld),\n                     fld.fold_block((*body)),\n-                    @((*captures).map(|cap_item| {\n-                        @({id: fld.new_id(cap_item.id),\n-                           ..**cap_item})})))\n+                    @captures)\n           }\n           expr_fn_block(decl, ref body, captures) => {\n+            let captures = do captures.map |cap_item| {\n+                @ast::capture_item_ {\n+                    id: fld.new_id(cap_item.id),\n+                    ..**cap_item\n+                }\n+            };\n             expr_fn_block(fold_fn_decl(decl, fld), fld.fold_block((*body)),\n-                          @((*captures).map(|cap_item| {\n-                              @({id: fld.new_id(cap_item.id),\n-                                 ..**cap_item})})))\n+                          @captures)\n           }\n           expr_block(ref blk) => expr_block(fld.fold_block((*blk))),\n           expr_copy(e) => expr_copy(fld.fold_expr(e)),\n@@ -520,7 +538,7 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n     let fold_mac = |x| fold_mac_(x, fld);\n     fn fold_mt(mt: mt, fld: ast_fold) -> mt {\n-        {ty: fld.fold_ty(mt.ty), mutbl: mt.mutbl}\n+        mt { ty: fld.fold_ty(mt.ty), mutbl: mt.mutbl }\n     }\n     fn fold_field(f: ty_field, fld: ast_fold) -> ty_field {\n         spanned { node: { ident: fld.fold_ident(f.node.ident),\n@@ -632,11 +650,13 @@ fn noop_fold_path(&&p: path, fld: ast_fold) -> path {\n }\n \n fn noop_fold_local(l: local_, fld: ast_fold) -> local_ {\n-    return {is_mutbl: l.is_mutbl,\n-         ty: fld.fold_ty(l.ty),\n-         pat: fld.fold_pat(l.pat),\n-         init: l.init.map(|e| fld.fold_expr(*e)),\n-         id: fld.new_id(l.id)};\n+    local_ {\n+        is_mutbl: l.is_mutbl,\n+        ty: fld.fold_ty(l.ty),\n+        pat: fld.fold_pat(l.pat),\n+        init: l.init.map(|e| fld.fold_expr(*e)),\n+        id: fld.new_id(l.id),\n+    }\n }\n \n /* temporarily eta-expand because of a compiler bug with using `fn<T>` as a\n@@ -729,9 +749,11 @@ impl ast_fold_fns: ast_fold {\n     }\n     fn fold_pat(&&x: @pat) -> @pat {\n         let (n, s) =  (self.fold_pat)(x.node, x.span, self as ast_fold);\n-        return @{id: (self.new_id)(x.id),\n-              node: n,\n-              span: (self.new_span)(s)};\n+        @pat {\n+            id: (self.new_id)(x.id),\n+            node: n,\n+            span: (self.new_span)(s),\n+        }\n     }\n     fn fold_decl(&&x: @decl) -> @decl {\n         let (n, s) = (self.fold_decl)(x.node, x.span, self as ast_fold);"}, {"sha": "f0cff630b1129682be1e7675f8b493456951f030", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -30,8 +30,9 @@ fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n \n fn expr_is_simple_block(e: @ast::expr) -> bool {\n     match e.node {\n-      ast::expr_block(ast::spanned {node: {rules: ast::default_blk, _}, _}) =>\n-        true,\n+        ast::expr_block(\n+            ast::spanned { node: ast::blk_ { rules: ast::default_blk, _ }, _ }\n+        ) => true,\n       _ => false\n     }\n }"}, {"sha": "6fba59d6a84d245eae97daaba09c7092ec75c419", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 63, "deletions": 31, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e90142e536c150df0d9b4b2f11352152177509b5/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e90142e536c150df0d9b4b2f11352152177509b5", "patch": "@@ -455,7 +455,7 @@ impl Parser {\n     fn parse_mt() -> mt {\n         let mutbl = self.parse_mutability();\n         let t = self.parse_ty(false);\n-        return {ty: t, mutbl: mutbl};\n+        mt { ty: t, mutbl: mutbl }\n     }\n \n     fn parse_ty_field() -> ty_field {\n@@ -464,9 +464,14 @@ impl Parser {\n         let id = self.parse_ident();\n         self.expect(token::COLON);\n         let ty = self.parse_ty(false);\n-        return spanned(lo, ty.span.hi, {\n-            ident: id, mt: {ty: ty, mutbl: mutbl}\n-        });\n+        spanned(\n+            lo,\n+            ty.span.hi,\n+            {\n+                ident: id,\n+                mt: ast::mt { ty: ty, mutbl: mutbl }\n+            }\n+        )\n     }\n \n     fn parse_ret_ty() -> (ret_style, @Ty) {\n@@ -673,7 +678,12 @@ impl Parser {\n         fn parse_capture_item(p:Parser, is_move: bool) -> capture_item {\n             let sp = mk_sp(p.span.lo, p.span.hi);\n             let ident = p.parse_ident();\n-            @{id: p.get_id(), is_move: is_move, name: ident, span: sp}\n+            @ast::capture_item_ {\n+                id: p.get_id(),\n+                is_move: is_move,\n+                name: ident,\n+                span: sp,\n+            }\n         }\n \n         if self.eat_keyword(~\"move\") {\n@@ -874,7 +884,7 @@ impl Parser {\n         let i = self.parse_ident();\n         self.expect(sep);\n         let e = self.parse_expr();\n-        return spanned(lo, e.span.hi, {mutbl: m, ident: i, expr: e});\n+        spanned(lo, e.span.hi, ast::field_ { mutbl: m, ident: i, expr: e })\n     }\n \n     fn mk_expr(+lo: BytePos, +hi: BytePos, +node: expr_) -> @expr {\n@@ -1574,8 +1584,13 @@ impl Parser {\n         let lo = self.last_span.lo;\n         let (decl, captures) = parse_decl();\n         let body = parse_body();\n-        let fakeblock = {view_items: ~[], stmts: ~[], expr: Some(body),\n-                         id: self.get_id(), rules: default_blk};\n+        let fakeblock = ast::blk_ {\n+            view_items: ~[],\n+            stmts: ~[],\n+            expr: Some(body),\n+            id: self.get_id(),\n+            rules: default_blk,\n+        };\n         let fakeblock = spanned(body.span.lo, body.span.hi,\n                                 fakeblock);\n         return self.mk_expr(lo, body.span.hi,\n@@ -1753,14 +1768,18 @@ impl Parser {\n                 self.eat(token::COMMA);\n             }\n \n-            let blk = spanned { node: { view_items: ~[],\n-                                        stmts: ~[],\n-                                        expr: Some(expr),\n-                                        id: self.get_id(),\n-                                        rules: default_blk},\n-                                span: expr.span };\n+            let blk = spanned {\n+                node: ast::blk_ {\n+                    view_items: ~[],\n+                    stmts: ~[],\n+                    expr: Some(expr),\n+                    id: self.get_id(),\n+                    rules: default_blk,\n+                },\n+                span: expr.span,\n+            };\n \n-            arms.push({pats: pats, guard: guard, body: blk});\n+            arms.push(ast::arm { pats: pats, guard: guard, body: blk });\n         }\n         let mut hi = self.span.hi;\n         self.bump();\n@@ -1824,9 +1843,9 @@ impl Parser {\n             let subpat = self.parse_pat(refutable);\n             if is_tail {\n                 match subpat {\n-                    @{ node: pat_wild, _ } => (),\n-                    @{ node: pat_ident(_, _, _), _ } => (),\n-                    @{ span, _ } => self.span_fatal(\n+                    @ast::pat { node: pat_wild, _ } => (),\n+                    @ast::pat { node: pat_ident(_, _, _), _ } => (),\n+                    @ast::pat { span, _ } => self.span_fatal(\n                         span, ~\"expected an identifier or `_`\"\n                     )\n                 }\n@@ -1872,13 +1891,13 @@ impl Parser {\n                 self.bump();\n                 subpat = self.parse_pat(refutable);\n             } else {\n-                subpat = @{\n+                subpat = @ast::pat {\n                     id: self.get_id(),\n                     node: pat_ident(bind_infer, fieldpath, None),\n                     span: self.last_span\n                 };\n             }\n-            fields.push({ident: fieldname, pat: subpat});\n+            fields.push(ast::field_pat { ident: fieldname, pat: subpat });\n         }\n         return (fields, etc);\n     }\n@@ -2083,7 +2102,7 @@ impl Parser {\n             hi = self.span.hi;\n           }\n         }\n-        return @{id: self.get_id(), node: pat, span: mk_sp(lo, hi)};\n+        @ast::pat { id: self.get_id(), node: pat, span: mk_sp(lo, hi) }\n     }\n \n     fn parse_pat_ident(refutable: bool,\n@@ -2122,9 +2141,17 @@ impl Parser {\n                        span: mk_sp(lo, lo)};\n         if self.eat(token::COLON) { ty = self.parse_ty(false); }\n         let init = if allow_init { self.parse_initializer() } else { None };\n-        return @spanned(lo, self.last_span.hi,\n-                     {is_mutbl: is_mutbl, ty: ty, pat: pat,\n-                      init: init, id: self.get_id()});\n+        @spanned(\n+            lo,\n+            self.last_span.hi,\n+            ast::local_ {\n+                is_mutbl: is_mutbl,\n+                ty: ty,\n+                pat: pat,\n+                init: init,\n+                id: self.get_id(),\n+            }\n+        )\n     }\n \n     fn parse_let() -> @decl {\n@@ -2378,9 +2405,14 @@ impl Parser {\n         }\n         let mut hi = self.span.hi;\n         self.bump();\n-        let bloc = {view_items: view_items, stmts: stmts, expr: expr,\n-                    id: self.get_id(), rules: s};\n-        return spanned(lo, hi, bloc);\n+        let bloc = ast::blk_ {\n+            view_items: view_items,\n+            stmts: stmts,\n+            expr: expr,\n+            id: self.get_id(),\n+            rules: s,\n+        };\n+        spanned(lo, hi, bloc)\n     }\n \n     fn mk_ty_path(i: ident) -> @Ty {\n@@ -3855,10 +3887,10 @@ impl Parser {\n         let crate_attrs = self.parse_inner_attrs_and_next();\n         let first_item_outer_attrs = crate_attrs.next;\n         let m = self.parse_mod_items(token::EOF, first_item_outer_attrs);\n-        return @spanned(lo, self.span.lo,\n-                     {module: m,\n-                      attrs: crate_attrs.inner,\n-                      config: self.cfg});\n+        @spanned(lo, self.span.lo,\n+                 ast::crate_ { module: m,\n+                               attrs: crate_attrs.inner,\n+                               config: self.cfg })\n     }\n \n     fn parse_str() -> @~str {"}]}