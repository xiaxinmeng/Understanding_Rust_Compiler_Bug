{"sha": "2aa63c95bd1590d5286bc79358397608e8d91fa4", "node_id": "C_kwDOAAsO6NoAKDJhYTYzYzk1YmQxNTkwZDUyODZiYzc5MzU4Mzk3NjA4ZThkOTFmYTQ", "commit": {"author": {"name": "Ariel Uy", "email": "ariel.b.uy@gmail.com", "date": "2022-05-06T04:13:17Z"}, "committer": {"name": "Ariel Uy", "email": "ariel.b.uy@gmail.com", "date": "2022-05-06T04:49:01Z"}, "message": "Create RangeBounds struct\n\nFor check_range_bounds return type.", "tree": {"sha": "e2614ae348dd47d4c3fe2b5f4b95a218ccc98989", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2614ae348dd47d4c3fe2b5f4b95a218ccc98989"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2aa63c95bd1590d5286bc79358397608e8d91fa4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2aa63c95bd1590d5286bc79358397608e8d91fa4", "html_url": "https://github.com/rust-lang/rust/commit/2aa63c95bd1590d5286bc79358397608e8d91fa4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2aa63c95bd1590d5286bc79358397608e8d91fa4/comments", "author": {"login": "arieluy", "id": 36049232, "node_id": "MDQ6VXNlcjM2MDQ5MjMy", "avatar_url": "https://avatars.githubusercontent.com/u/36049232?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arieluy", "html_url": "https://github.com/arieluy", "followers_url": "https://api.github.com/users/arieluy/followers", "following_url": "https://api.github.com/users/arieluy/following{/other_user}", "gists_url": "https://api.github.com/users/arieluy/gists{/gist_id}", "starred_url": "https://api.github.com/users/arieluy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arieluy/subscriptions", "organizations_url": "https://api.github.com/users/arieluy/orgs", "repos_url": "https://api.github.com/users/arieluy/repos", "events_url": "https://api.github.com/users/arieluy/events{/privacy}", "received_events_url": "https://api.github.com/users/arieluy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arieluy", "id": 36049232, "node_id": "MDQ6VXNlcjM2MDQ5MjMy", "avatar_url": "https://avatars.githubusercontent.com/u/36049232?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arieluy", "html_url": "https://github.com/arieluy", "followers_url": "https://api.github.com/users/arieluy/followers", "following_url": "https://api.github.com/users/arieluy/following{/other_user}", "gists_url": "https://api.github.com/users/arieluy/gists{/gist_id}", "starred_url": "https://api.github.com/users/arieluy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arieluy/subscriptions", "organizations_url": "https://api.github.com/users/arieluy/orgs", "repos_url": "https://api.github.com/users/arieluy/repos", "events_url": "https://api.github.com/users/arieluy/events{/privacy}", "received_events_url": "https://api.github.com/users/arieluy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d10296910f36cf51187b1b5183a3a628422dd757", "url": "https://api.github.com/repos/rust-lang/rust/commits/d10296910f36cf51187b1b5183a3a628422dd757", "html_url": "https://github.com/rust-lang/rust/commit/d10296910f36cf51187b1b5183a3a628422dd757"}], "stats": {"total": 76, "additions": 52, "deletions": 24}, "files": [{"sha": "f26f3650cb353c0f21d34baa4622a4fc4f73e669", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 52, "deletions": 24, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2aa63c95bd1590d5286bc79358397608e8d91fa4/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa63c95bd1590d5286bc79358397608e8d91fa4/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=2aa63c95bd1590d5286bc79358397608e8d91fa4", "patch": "@@ -207,7 +207,13 @@ impl<'tcx> LateLintPass<'tcx> for Ranges {\n     extract_msrv_attr!(LateContext);\n }\n \n-fn check_possible_range_contains(cx: &LateContext<'_>, op: BinOpKind, l: &Expr<'_>, r: &Expr<'_>, expr: &Expr<'_>) {\n+fn check_possible_range_contains(\n+    cx: &LateContext<'_>,\n+    op: BinOpKind,\n+    left: &Expr<'_>,\n+    right: &Expr<'_>,\n+    expr: &Expr<'_>,\n+) {\n     if in_constant(cx, expr.hir_id) {\n         return;\n     }\n@@ -219,23 +225,19 @@ fn check_possible_range_contains(cx: &LateContext<'_>, op: BinOpKind, l: &Expr<'\n         _ => return,\n     };\n     // value, name, order (higher/lower), inclusiveness\n-    if let (\n-        Some((lval, lexpr, lid, name_span, lval_span, lord, linc)),\n-        Some((rval, _, rid, _, rval_span, rord, rinc)),\n-    ) = (check_range_bounds(cx, l), check_range_bounds(cx, r))\n-    {\n+    if let (Some(l), Some(r)) = (check_range_bounds(cx, left), check_range_bounds(cx, right)) {\n         // we only lint comparisons on the same name and with different\n         // direction\n-        if lid != rid || lord == rord {\n+        if l.id != r.id || l.ord == r.ord {\n             return;\n         }\n-        let ord = Constant::partial_cmp(cx.tcx, cx.typeck_results().expr_ty(lexpr), &lval, &rval);\n-        if combine_and && ord == Some(rord) {\n+        let ord = Constant::partial_cmp(cx.tcx, cx.typeck_results().expr_ty(l.expr), &l.val, &r.val);\n+        if combine_and && ord == Some(r.ord) {\n             // order lower bound and upper bound\n-            let (l_span, u_span, l_inc, u_inc) = if rord == Ordering::Less {\n-                (lval_span, rval_span, linc, rinc)\n+            let (l_span, u_span, l_inc, u_inc) = if r.ord == Ordering::Less {\n+                (l.val_span, r.val_span, l.inc, r.inc)\n             } else {\n-                (rval_span, lval_span, rinc, linc)\n+                (r.val_span, l.val_span, r.inc, l.inc)\n             };\n             // we only lint inclusive lower bounds\n             if !l_inc {\n@@ -247,7 +249,7 @@ fn check_possible_range_contains(cx: &LateContext<'_>, op: BinOpKind, l: &Expr<'\n                 (\"Range\", \"..\")\n             };\n             let mut applicability = Applicability::MachineApplicable;\n-            let name = snippet_with_applicability(cx, name_span, \"_\", &mut applicability);\n+            let name = snippet_with_applicability(cx, l.name_span, \"_\", &mut applicability);\n             let lo = snippet_with_applicability(cx, l_span, \"_\", &mut applicability);\n             let hi = snippet_with_applicability(cx, u_span, \"_\", &mut applicability);\n             let space = if lo.ends_with('.') { \" \" } else { \"\" };\n@@ -260,13 +262,13 @@ fn check_possible_range_contains(cx: &LateContext<'_>, op: BinOpKind, l: &Expr<'\n                 format!(\"({}{}{}{}).contains(&{})\", lo, space, range_op, hi, name),\n                 applicability,\n             );\n-        } else if !combine_and && ord == Some(lord) {\n+        } else if !combine_and && ord == Some(l.ord) {\n             // `!_.contains(_)`\n             // order lower bound and upper bound\n-            let (l_span, u_span, l_inc, u_inc) = if lord == Ordering::Less {\n-                (lval_span, rval_span, linc, rinc)\n+            let (l_span, u_span, l_inc, u_inc) = if l.ord == Ordering::Less {\n+                (l.val_span, r.val_span, l.inc, r.inc)\n             } else {\n-                (rval_span, lval_span, rinc, linc)\n+                (r.val_span, l.val_span, r.inc, l.inc)\n             };\n             if l_inc {\n                 return;\n@@ -277,7 +279,7 @@ fn check_possible_range_contains(cx: &LateContext<'_>, op: BinOpKind, l: &Expr<'\n                 (\"RangeInclusive\", \"..=\")\n             };\n             let mut applicability = Applicability::MachineApplicable;\n-            let name = snippet_with_applicability(cx, name_span, \"_\", &mut applicability);\n+            let name = snippet_with_applicability(cx, l.name_span, \"_\", &mut applicability);\n             let lo = snippet_with_applicability(cx, l_span, \"_\", &mut applicability);\n             let hi = snippet_with_applicability(cx, u_span, \"_\", &mut applicability);\n             let space = if lo.ends_with('.') { \" \" } else { \"\" };\n@@ -294,10 +296,20 @@ fn check_possible_range_contains(cx: &LateContext<'_>, op: BinOpKind, l: &Expr<'\n     }\n }\n \n-fn check_range_bounds<'a>(\n-    cx: &'a LateContext<'_>,\n-    ex: &'a Expr<'_>,\n-) -> Option<(Constant, &'a Expr<'a>, HirId, Span, Span, Ordering, bool)> {\n+struct RangeBounds<'a> {\n+    val: Constant,\n+    expr: &'a Expr<'a>,\n+    id: HirId,\n+    name_span: Span,\n+    val_span: Span,\n+    ord: Ordering,\n+    inc: bool,\n+}\n+\n+// Takes a binary expression such as x <= 2 as input\n+// Breaks apart into various pieces, such as the value of the number,\n+// hir id of the variable, and direction/inclusiveness of the operator\n+fn check_range_bounds<'a>(cx: &'a LateContext<'_>, ex: &'a Expr<'_>) -> Option<RangeBounds<'a>> {\n     if let ExprKind::Binary(ref op, l, r) = ex.kind {\n         let (inclusive, ordering) = match op.node {\n             BinOpKind::Gt => (false, Ordering::Greater),\n@@ -308,11 +320,27 @@ fn check_range_bounds<'a>(\n         };\n         if let Some(id) = path_to_local(l) {\n             if let Some((c, _)) = constant(cx, cx.typeck_results(), r) {\n-                return Some((c, r, id, l.span, r.span, ordering, inclusive));\n+                return Some(RangeBounds {\n+                    val: c,\n+                    expr: r,\n+                    id,\n+                    name_span: l.span,\n+                    val_span: r.span,\n+                    ord: ordering,\n+                    inc: inclusive,\n+                });\n             }\n         } else if let Some(id) = path_to_local(r) {\n             if let Some((c, _)) = constant(cx, cx.typeck_results(), l) {\n-                return Some((c, l, id, r.span, l.span, ordering.reverse(), inclusive));\n+                return Some(RangeBounds {\n+                    val: c,\n+                    expr: l,\n+                    id,\n+                    name_span: r.span,\n+                    val_span: l.span,\n+                    ord: ordering.reverse(),\n+                    inc: inclusive,\n+                });\n             }\n         }\n     }"}]}