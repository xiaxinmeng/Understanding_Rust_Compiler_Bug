{"sha": "144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0NGFmM2U5N2FhMzBmZWJhM2QzNmE5OGFjMDRjMGYxYjJiYzBiZWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-03T00:33:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-03T00:33:34Z"}, "message": "Auto merge of #36807 - brson:pal, r=brson\n\nRestrict where in the tree platform-specific cfgs may be mentioned\n\nWith the ports of Rust never ending, it's important that we keep things tidy. The main thing this PR does is introduce  a new \"pal\" (platform abstraction layer) tidy check that limits where platform-specific CFGs may appear.\n\nThis is intended to maintain existing standards of code organization\nin hopes that the standard library will continue to be refactored to\nisolate platform-specific bits, making porting easier; where \"standard\nlibrary\" roughly means \"all the dependencies of the std and test\ncrates\".\n\nThis generally means placing restrictions on where `cfg(unix)`,\n`cfg(windows)`, `cfg(target_os)` and `cfg(target_env)` may appear,\nthe basic objective being to isolate platform-specific code to the\nplatform-specific `std::sys` modules, and to the allocation,\nunwinding, and libc crates.\n\nFollowing are the basic rules, though there are currently\nexceptions:\n\n- core may not have platform-specific code\n- liballoc_system may have platform-specific code\n- liballoc_jemalloc may have platform-specific code\n- libpanic_abort may have platform-specific code\n- libpanic_unwind may have platform-specific code\n- other crates in the std facade may not\n- std may have platform-specific code in the following places\n  - sys/unix/\n  - sys/windows/\n  - os/\n\nThere are plenty of exceptions today though, noted in the whitelist.\n\nThe end-state, IMO, is for the standard library to be portable by porting only `std::sys` (possibly extracted to its own crate), an allocator crate, an unwinder crate, and possibly a libc crate (if std depends on it); but that outcome is far off and independent of the utility of enforcing where such code lives today.\n\ncc @rust-lang/libs", "tree": {"sha": "16465fa1e28268c64ee631a0dc282564c151521c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16465fa1e28268c64ee631a0dc282564c151521c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "html_url": "https://github.com/rust-lang/rust/commit/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cdc0fb11af12c04fb4b1984615f03b11a60decc", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cdc0fb11af12c04fb4b1984615f03b11a60decc", "html_url": "https://github.com/rust-lang/rust/commit/1cdc0fb11af12c04fb4b1984615f03b11a60decc"}, {"sha": "4d76ac84922bec9ea790c1394f6959ad399d7aa1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d76ac84922bec9ea790c1394f6959ad399d7aa1", "html_url": "https://github.com/rust-lang/rust/commit/4d76ac84922bec9ea790c1394f6959ad399d7aa1"}], "stats": {"total": 2071, "additions": 1191, "deletions": 880}, "files": [{"sha": "e29dbe35c5a59a242c592fd0dc0c3c3c5adb47ab", "filename": "src/libstd/env.rs", "status": "modified", "additions": 12, "deletions": 185, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -21,6 +21,7 @@ use ffi::{OsStr, OsString};\n use fmt;\n use io;\n use path::{Path, PathBuf};\n+use sys;\n use sys::os as os_imp;\n \n /// Returns the current working directory as a `PathBuf`.\n@@ -557,7 +558,7 @@ pub struct Args { inner: ArgsOs }\n ///\n /// This structure is created through the `std::env::args_os` method.\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub struct ArgsOs { inner: os_imp::Args }\n+pub struct ArgsOs { inner: sys::args::Args }\n \n /// Returns the arguments which this program was started with (normally passed\n /// via the command line).\n@@ -606,7 +607,7 @@ pub fn args() -> Args {\n /// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub fn args_os() -> ArgsOs {\n-    ArgsOs { inner: os_imp::args() }\n+    ArgsOs { inner: sys::args::args() }\n }\n \n #[stable(feature = \"env\", since = \"1.0.0\")]\n@@ -649,6 +650,8 @@ impl DoubleEndedIterator for ArgsOs {\n /// Constants associated with the current target\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub mod consts {\n+    use sys::env::os;\n+\n     /// A string describing the architecture of the CPU that is currently\n     /// in use.\n     ///\n@@ -673,7 +676,7 @@ pub mod consts {\n     /// - unix\n     /// - windows\n     #[stable(feature = \"env\", since = \"1.0.0\")]\n-    pub const FAMILY: &'static str = super::os::FAMILY;\n+    pub const FAMILY: &'static str = os::FAMILY;\n \n     /// A string describing the specific operating system in use.\n     /// Example value is `linux`.\n@@ -692,7 +695,7 @@ pub mod consts {\n     /// - android\n     /// - windows\n     #[stable(feature = \"env\", since = \"1.0.0\")]\n-    pub const OS: &'static str = super::os::OS;\n+    pub const OS: &'static str = os::OS;\n \n     /// Specifies the filename prefix used for shared libraries on this\n     /// platform. Example value is `lib`.\n@@ -702,7 +705,7 @@ pub mod consts {\n     /// - lib\n     /// - `\"\"` (an empty string)\n     #[stable(feature = \"env\", since = \"1.0.0\")]\n-    pub const DLL_PREFIX: &'static str = super::os::DLL_PREFIX;\n+    pub const DLL_PREFIX: &'static str = os::DLL_PREFIX;\n \n     /// Specifies the filename suffix used for shared libraries on this\n     /// platform. Example value is `.so`.\n@@ -713,7 +716,7 @@ pub mod consts {\n     /// - .dylib\n     /// - .dll\n     #[stable(feature = \"env\", since = \"1.0.0\")]\n-    pub const DLL_SUFFIX: &'static str = super::os::DLL_SUFFIX;\n+    pub const DLL_SUFFIX: &'static str = os::DLL_SUFFIX;\n \n     /// Specifies the file extension used for shared libraries on this\n     /// platform that goes after the dot. Example value is `so`.\n@@ -724,7 +727,7 @@ pub mod consts {\n     /// - dylib\n     /// - dll\n     #[stable(feature = \"env\", since = \"1.0.0\")]\n-    pub const DLL_EXTENSION: &'static str = super::os::DLL_EXTENSION;\n+    pub const DLL_EXTENSION: &'static str = os::DLL_EXTENSION;\n \n     /// Specifies the filename suffix used for executable binaries on this\n     /// platform. Example value is `.exe`.\n@@ -736,7 +739,7 @@ pub mod consts {\n     /// - .pexe\n     /// - `\"\"` (an empty string)\n     #[stable(feature = \"env\", since = \"1.0.0\")]\n-    pub const EXE_SUFFIX: &'static str = super::os::EXE_SUFFIX;\n+    pub const EXE_SUFFIX: &'static str = os::EXE_SUFFIX;\n \n     /// Specifies the file extension, if any, used for executable binaries\n     /// on this platform. Example value is `exe`.\n@@ -746,183 +749,7 @@ pub mod consts {\n     /// - exe\n     /// - `\"\"` (an empty string)\n     #[stable(feature = \"env\", since = \"1.0.0\")]\n-    pub const EXE_EXTENSION: &'static str = super::os::EXE_EXTENSION;\n-\n-}\n-\n-#[cfg(target_os = \"linux\")]\n-mod os {\n-    pub const FAMILY: &'static str = \"unix\";\n-    pub const OS: &'static str = \"linux\";\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-    pub const DLL_SUFFIX: &'static str = \".so\";\n-    pub const DLL_EXTENSION: &'static str = \"so\";\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"macos\")]\n-mod os {\n-    pub const FAMILY: &'static str = \"unix\";\n-    pub const OS: &'static str = \"macos\";\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-    pub const DLL_SUFFIX: &'static str = \".dylib\";\n-    pub const DLL_EXTENSION: &'static str = \"dylib\";\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"ios\")]\n-mod os {\n-    pub const FAMILY: &'static str = \"unix\";\n-    pub const OS: &'static str = \"ios\";\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-    pub const DLL_SUFFIX: &'static str = \".dylib\";\n-    pub const DLL_EXTENSION: &'static str = \"dylib\";\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"freebsd\")]\n-mod os {\n-    pub const FAMILY: &'static str = \"unix\";\n-    pub const OS: &'static str = \"freebsd\";\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-    pub const DLL_SUFFIX: &'static str = \".so\";\n-    pub const DLL_EXTENSION: &'static str = \"so\";\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"dragonfly\")]\n-mod os {\n-    pub const FAMILY: &'static str = \"unix\";\n-    pub const OS: &'static str = \"dragonfly\";\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-    pub const DLL_SUFFIX: &'static str = \".so\";\n-    pub const DLL_EXTENSION: &'static str = \"so\";\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"bitrig\")]\n-mod os {\n-    pub const FAMILY: &'static str = \"unix\";\n-    pub const OS: &'static str = \"bitrig\";\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-    pub const DLL_SUFFIX: &'static str = \".so\";\n-    pub const DLL_EXTENSION: &'static str = \"so\";\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"netbsd\")]\n-mod os {\n-    pub const FAMILY: &'static str = \"unix\";\n-    pub const OS: &'static str = \"netbsd\";\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-    pub const DLL_SUFFIX: &'static str = \".so\";\n-    pub const DLL_EXTENSION: &'static str = \"so\";\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"openbsd\")]\n-mod os {\n-    pub const FAMILY: &'static str = \"unix\";\n-    pub const OS: &'static str = \"openbsd\";\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-    pub const DLL_SUFFIX: &'static str = \".so\";\n-    pub const DLL_EXTENSION: &'static str = \"so\";\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"android\")]\n-mod os {\n-    pub const FAMILY: &'static str = \"unix\";\n-    pub const OS: &'static str = \"android\";\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-    pub const DLL_SUFFIX: &'static str = \".so\";\n-    pub const DLL_EXTENSION: &'static str = \"so\";\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"solaris\")]\n-mod os {\n-    pub const FAMILY: &'static str = \"unix\";\n-    pub const OS: &'static str = \"solaris\";\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-    pub const DLL_SUFFIX: &'static str = \".so\";\n-    pub const DLL_EXTENSION: &'static str = \"so\";\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"windows\")]\n-mod os {\n-    pub const FAMILY: &'static str = \"windows\";\n-    pub const OS: &'static str = \"windows\";\n-    pub const DLL_PREFIX: &'static str = \"\";\n-    pub const DLL_SUFFIX: &'static str = \".dll\";\n-    pub const DLL_EXTENSION: &'static str = \"dll\";\n-    pub const EXE_SUFFIX: &'static str = \".exe\";\n-    pub const EXE_EXTENSION: &'static str = \"exe\";\n-}\n-\n-#[cfg(all(target_os = \"nacl\", not(target_arch = \"le32\")))]\n-mod os {\n-    pub const FAMILY: &'static str = \"unix\";\n-    pub const OS: &'static str = \"nacl\";\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-    pub const DLL_SUFFIX: &'static str = \".so\";\n-    pub const DLL_EXTENSION: &'static str = \"so\";\n-    pub const EXE_SUFFIX: &'static str = \".nexe\";\n-    pub const EXE_EXTENSION: &'static str = \"nexe\";\n-}\n-#[cfg(all(target_os = \"nacl\", target_arch = \"le32\"))]\n-mod os {\n-    pub const FAMILY: &'static str = \"unix\";\n-    pub const OS: &'static str = \"pnacl\";\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-    pub const DLL_SUFFIX: &'static str = \".pso\";\n-    pub const DLL_EXTENSION: &'static str = \"pso\";\n-    pub const EXE_SUFFIX: &'static str = \".pexe\";\n-    pub const EXE_EXTENSION: &'static str = \"pexe\";\n-}\n-\n-#[cfg(all(target_os = \"emscripten\", target_arch = \"asmjs\"))]\n-mod os {\n-    pub const FAMILY: &'static str = \"unix\";\n-    pub const OS: &'static str = \"emscripten\";\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-    pub const DLL_SUFFIX: &'static str = \".so\";\n-    pub const DLL_EXTENSION: &'static str = \"so\";\n-    pub const EXE_SUFFIX: &'static str = \".js\";\n-    pub const EXE_EXTENSION: &'static str = \"js\";\n-}\n-\n-#[cfg(all(target_os = \"emscripten\", target_arch = \"wasm32\"))]\n-mod os {\n-    pub const FAMILY: &'static str = \"unix\";\n-    pub const OS: &'static str = \"emscripten\";\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-    pub const DLL_SUFFIX: &'static str = \".so\";\n-    pub const DLL_EXTENSION: &'static str = \"so\";\n-    pub const EXE_SUFFIX: &'static str = \".js\";\n-    pub const EXE_EXTENSION: &'static str = \"js\";\n-}\n-\n-#[cfg(target_os = \"haiku\")]\n-mod os {\n-    pub const FAMILY: &'static str = \"unix\";\n-    pub const OS: &'static str = \"haiku\";\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-    pub const DLL_SUFFIX: &'static str = \".so\";\n-    pub const DLL_EXTENSION: &'static str = \"so\";\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-    pub const EXE_EXTENSION: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = os::EXE_EXTENSION;\n }\n \n #[cfg(target_arch = \"x86\")]"}, {"sha": "84b50f04463fe7dc8ccef469b5f02e1df007a67b", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -53,17 +53,6 @@ impl OsString {\n         OsString { inner: Buf::from_string(String::new()) }\n     }\n \n-    #[cfg(unix)]\n-    fn _from_bytes(vec: Vec<u8>) -> Option<OsString> {\n-        use os::unix::ffi::OsStringExt;\n-        Some(OsString::from_vec(vec))\n-    }\n-\n-    #[cfg(windows)]\n-    fn _from_bytes(vec: Vec<u8>) -> Option<OsString> {\n-        String::from_utf8(vec).ok().map(OsString::from)\n-    }\n-\n     /// Converts to an `OsStr` slice.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_os_str(&self) -> &OsStr {"}, {"sha": "c24ee8ff303c875530d976f01708a7d8e75cd3d9", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -125,13 +125,10 @@ impl<R: io::Read> io::Read for Maybe<R> {\n }\n \n fn handle_ebadf<T>(r: io::Result<T>, default: T) -> io::Result<T> {\n-    #[cfg(windows)]\n-    const ERR: i32 = ::sys::c::ERROR_INVALID_HANDLE as i32;\n-    #[cfg(not(windows))]\n-    const ERR: i32 = ::libc::EBADF as i32;\n+    use sys::stdio::EBADF_ERR;\n \n     match r {\n-        Err(ref e) if e.raw_os_error() == Some(ERR) => Ok(default),\n+        Err(ref e) if e.raw_os_error() == Some(EBADF_ERR) => Ok(default),\n         r => r\n     }\n }"}, {"sha": "7c8c97a6caf9cfc2dd3f188def54060449c822d4", "filename": "src/libstd/memchr.rs", "status": "modified", "additions": 4, "deletions": 271, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmemchr.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -11,8 +11,6 @@\n // Original implementation taken from rust-memchr\n // Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n \n-\n-\n /// A safe interface to `memchr`.\n ///\n /// Returns the index corresponding to the first occurrence of `needle` in\n@@ -32,32 +30,9 @@\n /// let haystack = b\"the quick brown fox\";\n /// assert_eq!(memchr(b'k', haystack), Some(8));\n /// ```\n+#[inline]\n pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n-    // libc memchr\n-    #[cfg(not(target_os = \"windows\"))]\n-    fn memchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n-        use libc;\n-\n-        let p = unsafe {\n-            libc::memchr(\n-                haystack.as_ptr() as *const libc::c_void,\n-                needle as libc::c_int,\n-                haystack.len() as libc::size_t)\n-        };\n-        if p.is_null() {\n-            None\n-        } else {\n-            Some(p as usize - (haystack.as_ptr() as usize))\n-        }\n-    }\n-\n-    // use fallback on windows, since it's faster\n-    #[cfg(target_os = \"windows\")]\n-    fn memchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n-        fallback::memchr(needle, haystack)\n-    }\n-\n-    memchr_specific(needle, haystack)\n+    ::sys::memchr::memchr(needle, haystack)\n }\n \n /// A safe interface to `memrchr`.\n@@ -75,251 +50,9 @@ pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n /// let haystack = b\"the quick brown fox\";\n /// assert_eq!(memrchr(b'o', haystack), Some(17));\n /// ```\n+#[inline]\n pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n-\n-    #[cfg(target_os = \"linux\")]\n-    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n-        use libc;\n-\n-        // GNU's memrchr() will - unlike memchr() - error if haystack is empty.\n-        if haystack.is_empty() {return None}\n-        let p = unsafe {\n-            libc::memrchr(\n-                haystack.as_ptr() as *const libc::c_void,\n-                needle as libc::c_int,\n-                haystack.len() as libc::size_t)\n-        };\n-        if p.is_null() {\n-            None\n-        } else {\n-            Some(p as usize - (haystack.as_ptr() as usize))\n-        }\n-    }\n-\n-    #[cfg(not(target_os = \"linux\"))]\n-    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n-        fallback::memrchr(needle, haystack)\n-    }\n-\n-    memrchr_specific(needle, haystack)\n-}\n-\n-#[allow(dead_code)]\n-mod fallback {\n-    use cmp;\n-    use mem;\n-\n-    const LO_U64: u64 = 0x0101010101010101;\n-    const HI_U64: u64 = 0x8080808080808080;\n-\n-    // use truncation\n-    const LO_USIZE: usize = LO_U64 as usize;\n-    const HI_USIZE: usize = HI_U64 as usize;\n-\n-    /// Return `true` if `x` contains any zero byte.\n-    ///\n-    /// From *Matters Computational*, J. Arndt\n-    ///\n-    /// \"The idea is to subtract one from each of the bytes and then look for\n-    /// bytes where the borrow propagated all the way to the most significant\n-    /// bit.\"\n-    #[inline]\n-    fn contains_zero_byte(x: usize) -> bool {\n-        x.wrapping_sub(LO_USIZE) & !x & HI_USIZE != 0\n-    }\n-\n-    #[cfg(target_pointer_width = \"32\")]\n-    #[inline]\n-    fn repeat_byte(b: u8) -> usize {\n-        let mut rep = (b as usize) << 8 | b as usize;\n-        rep = rep << 16 | rep;\n-        rep\n-    }\n-\n-    #[cfg(target_pointer_width = \"64\")]\n-    #[inline]\n-    fn repeat_byte(b: u8) -> usize {\n-        let mut rep = (b as usize) << 8 | b as usize;\n-        rep = rep << 16 | rep;\n-        rep = rep << 32 | rep;\n-        rep\n-    }\n-\n-    /// Return the first index matching the byte `a` in `text`.\n-    pub fn memchr(x: u8, text: &[u8]) -> Option<usize> {\n-        // Scan for a single byte value by reading two `usize` words at a time.\n-        //\n-        // Split `text` in three parts\n-        // - unaligned initial part, before the first word aligned address in text\n-        // - body, scan by 2 words at a time\n-        // - the last remaining part, < 2 word size\n-        let len = text.len();\n-        let ptr = text.as_ptr();\n-        let usize_bytes = mem::size_of::<usize>();\n-\n-        // search up to an aligned boundary\n-        let align = (ptr as usize) & (usize_bytes- 1);\n-        let mut offset;\n-        if align > 0 {\n-            offset = cmp::min(usize_bytes - align, len);\n-            if let Some(index) = text[..offset].iter().position(|elt| *elt == x) {\n-                return Some(index);\n-            }\n-        } else {\n-            offset = 0;\n-        }\n-\n-        // search the body of the text\n-        let repeated_x = repeat_byte(x);\n-\n-        if len >= 2 * usize_bytes {\n-            while offset <= len - 2 * usize_bytes {\n-                unsafe {\n-                    let u = *(ptr.offset(offset as isize) as *const usize);\n-                    let v = *(ptr.offset((offset + usize_bytes) as isize) as *const usize);\n-\n-                    // break if there is a matching byte\n-                    let zu = contains_zero_byte(u ^ repeated_x);\n-                    let zv = contains_zero_byte(v ^ repeated_x);\n-                    if zu || zv {\n-                        break;\n-                    }\n-                }\n-                offset += usize_bytes * 2;\n-            }\n-        }\n-\n-        // find the byte after the point the body loop stopped\n-        text[offset..].iter().position(|elt| *elt == x).map(|i| offset + i)\n-    }\n-\n-    /// Return the last index matching the byte `a` in `text`.\n-    pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {\n-        // Scan for a single byte value by reading two `usize` words at a time.\n-        //\n-        // Split `text` in three parts\n-        // - unaligned tail, after the last word aligned address in text\n-        // - body, scan by 2 words at a time\n-        // - the first remaining bytes, < 2 word size\n-        let len = text.len();\n-        let ptr = text.as_ptr();\n-        let usize_bytes = mem::size_of::<usize>();\n-\n-        // search to an aligned boundary\n-        let end_align = (ptr as usize + len) & (usize_bytes - 1);\n-        let mut offset;\n-        if end_align > 0 {\n-            offset = if end_align >= len { 0 } else { len - end_align };\n-            if let Some(index) = text[offset..].iter().rposition(|elt| *elt == x) {\n-                return Some(offset + index);\n-            }\n-        } else {\n-            offset = len;\n-        }\n-\n-        // search the body of the text\n-        let repeated_x = repeat_byte(x);\n-\n-        while offset >= 2 * usize_bytes {\n-            unsafe {\n-                let u = *(ptr.offset(offset as isize - 2 * usize_bytes as isize) as *const usize);\n-                let v = *(ptr.offset(offset as isize - usize_bytes as isize) as *const usize);\n-\n-                // break if there is a matching byte\n-                let zu = contains_zero_byte(u ^ repeated_x);\n-                let zv = contains_zero_byte(v ^ repeated_x);\n-                if zu || zv {\n-                    break;\n-                }\n-            }\n-            offset -= 2 * usize_bytes;\n-        }\n-\n-        // find the byte before the point the body loop stopped\n-        text[..offset].iter().rposition(|elt| *elt == x)\n-    }\n-\n-    // test fallback implementations on all platforms\n-    #[test]\n-    fn matches_one() {\n-        assert_eq!(Some(0), memchr(b'a', b\"a\"));\n-    }\n-\n-    #[test]\n-    fn matches_begin() {\n-        assert_eq!(Some(0), memchr(b'a', b\"aaaa\"));\n-    }\n-\n-    #[test]\n-    fn matches_end() {\n-        assert_eq!(Some(4), memchr(b'z', b\"aaaaz\"));\n-    }\n-\n-    #[test]\n-    fn matches_nul() {\n-        assert_eq!(Some(4), memchr(b'\\x00', b\"aaaa\\x00\"));\n-    }\n-\n-    #[test]\n-    fn matches_past_nul() {\n-        assert_eq!(Some(5), memchr(b'z', b\"aaaa\\x00z\"));\n-    }\n-\n-    #[test]\n-    fn no_match_empty() {\n-        assert_eq!(None, memchr(b'a', b\"\"));\n-    }\n-\n-    #[test]\n-    fn no_match() {\n-        assert_eq!(None, memchr(b'a', b\"xyz\"));\n-    }\n-\n-    #[test]\n-    fn matches_one_reversed() {\n-        assert_eq!(Some(0), memrchr(b'a', b\"a\"));\n-    }\n-\n-    #[test]\n-    fn matches_begin_reversed() {\n-        assert_eq!(Some(3), memrchr(b'a', b\"aaaa\"));\n-    }\n-\n-    #[test]\n-    fn matches_end_reversed() {\n-        assert_eq!(Some(0), memrchr(b'z', b\"zaaaa\"));\n-    }\n-\n-    #[test]\n-    fn matches_nul_reversed() {\n-        assert_eq!(Some(4), memrchr(b'\\x00', b\"aaaa\\x00\"));\n-    }\n-\n-    #[test]\n-    fn matches_past_nul_reversed() {\n-        assert_eq!(Some(0), memrchr(b'z', b\"z\\x00aaaa\"));\n-    }\n-\n-    #[test]\n-    fn no_match_empty_reversed() {\n-        assert_eq!(None, memrchr(b'a', b\"\"));\n-    }\n-\n-    #[test]\n-    fn no_match_reversed() {\n-        assert_eq!(None, memrchr(b'a', b\"xyz\"));\n-    }\n-\n-    #[test]\n-    fn each_alignment_reversed() {\n-        let mut data = [1u8; 64];\n-        let needle = 2;\n-        let pos = 40;\n-        data[pos] = needle;\n-        for start in 0..16 {\n-            assert_eq!(Some(pos - start), memrchr(needle, &data[start..]));\n-        }\n-    }\n+    ::sys::memchr::memrchr(needle, haystack)\n }\n \n #[cfg(test)]"}, {"sha": "56286fbe25399a62a322c24e815475cf6c69085a", "filename": "src/libstd/net/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fmod.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -31,7 +31,7 @@ mod addr;\n mod tcp;\n mod udp;\n mod parser;\n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n+#[cfg(test)]\n mod test;\n \n /// Possible values which can be passed to the [`shutdown`] method of"}, {"sha": "3f2eacda7d60eb11a9902255b3158dae07a69da7", "filename": "src/libstd/net/test.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fnet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fnet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftest.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(dead_code)] // not used on emscripten\n+\n use env;\n use net::{SocketAddr, SocketAddrV4, SocketAddrV6, Ipv4Addr, Ipv6Addr, ToSocketAddrs};\n use sync::atomic::{AtomicUsize, Ordering};"}, {"sha": "fdc1978b0c5012bd5be5edf1c86300b5f996525e", "filename": "src/libstd/path.rs", "status": "modified", "additions": 2, "deletions": 126, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -113,7 +113,7 @@ use ops::{self, Deref};\n \n use ffi::{OsStr, OsString};\n \n-use self::platform::{is_sep_byte, is_verbatim_sep, MAIN_SEP_STR, parse_prefix};\n+use sys::path::{is_sep_byte, is_verbatim_sep, MAIN_SEP_STR, parse_prefix};\n \n ////////////////////////////////////////////////////////////////////////////////\n // GENERAL NOTES\n@@ -125,130 +125,6 @@ use self::platform::{is_sep_byte, is_verbatim_sep, MAIN_SEP_STR, parse_prefix};\n // OsStr APIs for parsing, but it will take a while for those to become\n // available.\n \n-////////////////////////////////////////////////////////////////////////////////\n-// Platform-specific definitions\n-////////////////////////////////////////////////////////////////////////////////\n-\n-// The following modules give the most basic tools for parsing paths on various\n-// platforms. The bulk of the code is devoted to parsing prefixes on Windows.\n-\n-#[cfg(unix)]\n-mod platform {\n-    use super::Prefix;\n-    use ffi::OsStr;\n-\n-    #[inline]\n-    pub fn is_sep_byte(b: u8) -> bool {\n-        b == b'/'\n-    }\n-\n-    #[inline]\n-    pub fn is_verbatim_sep(b: u8) -> bool {\n-        b == b'/'\n-    }\n-\n-    pub fn parse_prefix(_: &OsStr) -> Option<Prefix> {\n-        None\n-    }\n-\n-    pub const MAIN_SEP_STR: &'static str = \"/\";\n-    pub const MAIN_SEP: char = '/';\n-}\n-\n-#[cfg(windows)]\n-mod platform {\n-    use ascii::*;\n-\n-    use super::{os_str_as_u8_slice, u8_slice_as_os_str, Prefix};\n-    use ffi::OsStr;\n-\n-    #[inline]\n-    pub fn is_sep_byte(b: u8) -> bool {\n-        b == b'/' || b == b'\\\\'\n-    }\n-\n-    #[inline]\n-    pub fn is_verbatim_sep(b: u8) -> bool {\n-        b == b'\\\\'\n-    }\n-\n-    pub fn parse_prefix<'a>(path: &'a OsStr) -> Option<Prefix> {\n-        use super::Prefix::*;\n-        unsafe {\n-            // The unsafety here stems from converting between &OsStr and &[u8]\n-            // and back. This is safe to do because (1) we only look at ASCII\n-            // contents of the encoding and (2) new &OsStr values are produced\n-            // only from ASCII-bounded slices of existing &OsStr values.\n-            let mut path = os_str_as_u8_slice(path);\n-\n-            if path.starts_with(br\"\\\\\") {\n-                // \\\\\n-                path = &path[2..];\n-                if path.starts_with(br\"?\\\") {\n-                    // \\\\?\\\n-                    path = &path[2..];\n-                    if path.starts_with(br\"UNC\\\") {\n-                        // \\\\?\\UNC\\server\\share\n-                        path = &path[4..];\n-                        let (server, share) = match parse_two_comps(path, is_verbatim_sep) {\n-                            Some((server, share)) =>\n-                                (u8_slice_as_os_str(server), u8_slice_as_os_str(share)),\n-                            None => (u8_slice_as_os_str(path), u8_slice_as_os_str(&[])),\n-                        };\n-                        return Some(VerbatimUNC(server, share));\n-                    } else {\n-                        // \\\\?\\path\n-                        let idx = path.iter().position(|&b| b == b'\\\\');\n-                        if idx == Some(2) && path[1] == b':' {\n-                            let c = path[0];\n-                            if c.is_ascii() && (c as char).is_alphabetic() {\n-                                // \\\\?\\C:\\ path\n-                                return Some(VerbatimDisk(c.to_ascii_uppercase()));\n-                            }\n-                        }\n-                        let slice = &path[..idx.unwrap_or(path.len())];\n-                        return Some(Verbatim(u8_slice_as_os_str(slice)));\n-                    }\n-                } else if path.starts_with(b\".\\\\\") {\n-                    // \\\\.\\path\n-                    path = &path[2..];\n-                    let pos = path.iter().position(|&b| b == b'\\\\');\n-                    let slice = &path[..pos.unwrap_or(path.len())];\n-                    return Some(DeviceNS(u8_slice_as_os_str(slice)));\n-                }\n-                match parse_two_comps(path, is_sep_byte) {\n-                    Some((server, share)) if !server.is_empty() && !share.is_empty() => {\n-                        // \\\\server\\share\n-                        return Some(UNC(u8_slice_as_os_str(server), u8_slice_as_os_str(share)));\n-                    }\n-                    _ => (),\n-                }\n-            } else if path.get(1) == Some(& b':') {\n-                // C:\n-                let c = path[0];\n-                if c.is_ascii() && (c as char).is_alphabetic() {\n-                    return Some(Disk(c.to_ascii_uppercase()));\n-                }\n-            }\n-            return None;\n-        }\n-\n-        fn parse_two_comps(mut path: &[u8], f: fn(u8) -> bool) -> Option<(&[u8], &[u8])> {\n-            let first = match path.iter().position(|x| f(*x)) {\n-                None => return None,\n-                Some(x) => &path[..x],\n-            };\n-            path = &path[(first.len() + 1)..];\n-            let idx = path.iter().position(|x| f(*x));\n-            let second = &path[..idx.unwrap_or(path.len())];\n-            Some((first, second))\n-        }\n-    }\n-\n-    pub const MAIN_SEP_STR: &'static str = \"\\\\\";\n-    pub const MAIN_SEP: char = '\\\\';\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Windows Prefixes\n ////////////////////////////////////////////////////////////////////////////////\n@@ -373,7 +249,7 @@ pub fn is_separator(c: char) -> bool {\n \n /// The primary separator for the current platform\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MAIN_SEPARATOR: char = platform::MAIN_SEP;\n+pub const MAIN_SEPARATOR: char = ::sys::path::MAIN_SEP;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Misc helpers"}, {"sha": "78d5aa597ba0df01f33a1ae000f70bc9414b7b2a", "filename": "src/libstd/rt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -51,7 +51,7 @@ fn lang_start(main: *const u8, argc: isize, argv: *const *const u8) -> isize {\n         thread_info::set(main_guard, thread);\n \n         // Store our args if necessary in a squirreled away location\n-        sys_common::args::init(argc, argv);\n+        sys::args::init(argc, argv);\n \n         // Let's run some code!\n         let res = panic::catch_unwind(mem::transmute::<_, fn()>(main));"}, {"sha": "e056a350815a79d6fa4b3af11e05fd03f6c37766", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -366,8 +366,8 @@ impl<'rx, T:Send+'rx> fmt::Debug for Handle<'rx, T> {\n     }\n }\n \n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n #[allow(unused_imports)]\n+#[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n     use thread;\n     use sync::mpsc::*;"}, {"sha": "b5330463e30c475cdfc45ed19b99dcf8854d6d9c", "filename": "src/libstd/sys/common/args.rs", "status": "removed", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/1cdc0fb11af12c04fb4b1984615f03b11a60decc/src%2Flibstd%2Fsys%2Fcommon%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cdc0fb11af12c04fb4b1984615f03b11a60decc/src%2Flibstd%2Fsys%2Fcommon%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fargs.rs?ref=1cdc0fb11af12c04fb4b1984615f03b11a60decc", "patch": "@@ -1,100 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Global storage for command line arguments\n-//!\n-//! The current incarnation of the Rust runtime expects for\n-//! the processes `argc` and `argv` arguments to be stored\n-//! in a globally-accessible location for use by the `os` module.\n-//!\n-//! Only valid to call on Linux. Mac and Windows use syscalls to\n-//! discover the command line arguments.\n-//!\n-//! FIXME #7756: Would be nice for this to not exist.\n-\n-#![allow(dead_code)] // different code on OSX/linux/etc\n-\n-/// One-time global initialization.\n-pub unsafe fn init(argc: isize, argv: *const *const u8) { imp::init(argc, argv) }\n-\n-/// One-time global cleanup.\n-pub unsafe fn cleanup() { imp::cleanup() }\n-\n-/// Make a clone of the global arguments.\n-pub fn clone() -> Option<Vec<Vec<u8>>> { imp::clone() }\n-\n-#[cfg(any(target_os = \"linux\",\n-          target_os = \"android\",\n-          target_os = \"freebsd\",\n-          target_os = \"dragonfly\",\n-          target_os = \"bitrig\",\n-          target_os = \"netbsd\",\n-          target_os = \"openbsd\",\n-          target_os = \"solaris\",\n-          target_os = \"emscripten\",\n-          target_os = \"haiku\"))]\n-mod imp {\n-    use libc::c_char;\n-    use mem;\n-    use ffi::CStr;\n-\n-    use sys_common::mutex::Mutex;\n-\n-    static mut GLOBAL_ARGS_PTR: usize = 0;\n-    static LOCK: Mutex = Mutex::new();\n-\n-    pub unsafe fn init(argc: isize, argv: *const *const u8) {\n-        let args = (0..argc).map(|i| {\n-            CStr::from_ptr(*argv.offset(i) as *const c_char).to_bytes().to_vec()\n-        }).collect();\n-\n-        LOCK.lock();\n-        let ptr = get_global_ptr();\n-        assert!((*ptr).is_none());\n-        (*ptr) = Some(box args);\n-        LOCK.unlock();\n-    }\n-\n-    pub unsafe fn cleanup() {\n-        LOCK.lock();\n-        *get_global_ptr() = None;\n-        LOCK.unlock();\n-    }\n-\n-    pub fn clone() -> Option<Vec<Vec<u8>>> {\n-        unsafe {\n-            LOCK.lock();\n-            let ptr = get_global_ptr();\n-            let ret = (*ptr).as_ref().map(|s| (**s).clone());\n-            LOCK.unlock();\n-            return ret\n-        }\n-    }\n-\n-    fn get_global_ptr() -> *mut Option<Box<Vec<Vec<u8>>>> {\n-        unsafe { mem::transmute(&GLOBAL_ARGS_PTR) }\n-    }\n-\n-}\n-\n-#[cfg(any(target_os = \"macos\",\n-          target_os = \"ios\",\n-          target_os = \"windows\"))]\n-mod imp {\n-    pub unsafe fn init(_argc: isize, _argv: *const *const u8) {\n-    }\n-\n-    pub fn cleanup() {\n-    }\n-\n-    pub fn clone() -> Option<Vec<Vec<u8>>> {\n-        panic!()\n-    }\n-}"}, {"sha": "0483725dd83bc22631aec0f0bc15a988e7ddd8f2", "filename": "src/libstd/sys/common/io.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Fcommon%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Fcommon%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fio.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -50,7 +50,8 @@ pub unsafe fn read_to_end_uninitialized(r: &mut Read, buf: &mut Vec<u8>) -> io::\n     }\n }\n \n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n+#[cfg(test)]\n+#[allow(dead_code)] // not used on emscripten\n pub mod test {\n     use path::{Path, PathBuf};\n     use env;"}, {"sha": "3824a5fb5284c85c430f148704c8a5516ddb44f1", "filename": "src/libstd/sys/common/memchr.rs", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Fcommon%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Fcommon%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmemchr.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -0,0 +1,230 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// Original implementation taken from rust-memchr\n+// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n+\n+#[allow(dead_code)]\n+pub mod fallback {\n+    use cmp;\n+    use mem;\n+\n+    const LO_U64: u64 = 0x0101010101010101;\n+    const HI_U64: u64 = 0x8080808080808080;\n+\n+    // use truncation\n+    const LO_USIZE: usize = LO_U64 as usize;\n+    const HI_USIZE: usize = HI_U64 as usize;\n+\n+    /// Return `true` if `x` contains any zero byte.\n+    ///\n+    /// From *Matters Computational*, J. Arndt\n+    ///\n+    /// \"The idea is to subtract one from each of the bytes and then look for\n+    /// bytes where the borrow propagated all the way to the most significant\n+    /// bit.\"\n+    #[inline]\n+    fn contains_zero_byte(x: usize) -> bool {\n+        x.wrapping_sub(LO_USIZE) & !x & HI_USIZE != 0\n+    }\n+\n+    #[cfg(target_pointer_width = \"32\")]\n+    #[inline]\n+    fn repeat_byte(b: u8) -> usize {\n+        let mut rep = (b as usize) << 8 | b as usize;\n+        rep = rep << 16 | rep;\n+        rep\n+    }\n+\n+    #[cfg(target_pointer_width = \"64\")]\n+    #[inline]\n+    fn repeat_byte(b: u8) -> usize {\n+        let mut rep = (b as usize) << 8 | b as usize;\n+        rep = rep << 16 | rep;\n+        rep = rep << 32 | rep;\n+        rep\n+    }\n+\n+    /// Return the first index matching the byte `a` in `text`.\n+    pub fn memchr(x: u8, text: &[u8]) -> Option<usize> {\n+        // Scan for a single byte value by reading two `usize` words at a time.\n+        //\n+        // Split `text` in three parts\n+        // - unaligned initial part, before the first word aligned address in text\n+        // - body, scan by 2 words at a time\n+        // - the last remaining part, < 2 word size\n+        let len = text.len();\n+        let ptr = text.as_ptr();\n+        let usize_bytes = mem::size_of::<usize>();\n+\n+        // search up to an aligned boundary\n+        let align = (ptr as usize) & (usize_bytes- 1);\n+        let mut offset;\n+        if align > 0 {\n+            offset = cmp::min(usize_bytes - align, len);\n+            if let Some(index) = text[..offset].iter().position(|elt| *elt == x) {\n+                return Some(index);\n+            }\n+        } else {\n+            offset = 0;\n+        }\n+\n+        // search the body of the text\n+        let repeated_x = repeat_byte(x);\n+\n+        if len >= 2 * usize_bytes {\n+            while offset <= len - 2 * usize_bytes {\n+                unsafe {\n+                    let u = *(ptr.offset(offset as isize) as *const usize);\n+                    let v = *(ptr.offset((offset + usize_bytes) as isize) as *const usize);\n+\n+                    // break if there is a matching byte\n+                    let zu = contains_zero_byte(u ^ repeated_x);\n+                    let zv = contains_zero_byte(v ^ repeated_x);\n+                    if zu || zv {\n+                        break;\n+                    }\n+                }\n+                offset += usize_bytes * 2;\n+            }\n+        }\n+\n+        // find the byte after the point the body loop stopped\n+        text[offset..].iter().position(|elt| *elt == x).map(|i| offset + i)\n+    }\n+\n+    /// Return the last index matching the byte `a` in `text`.\n+    pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {\n+        // Scan for a single byte value by reading two `usize` words at a time.\n+        //\n+        // Split `text` in three parts\n+        // - unaligned tail, after the last word aligned address in text\n+        // - body, scan by 2 words at a time\n+        // - the first remaining bytes, < 2 word size\n+        let len = text.len();\n+        let ptr = text.as_ptr();\n+        let usize_bytes = mem::size_of::<usize>();\n+\n+        // search to an aligned boundary\n+        let end_align = (ptr as usize + len) & (usize_bytes - 1);\n+        let mut offset;\n+        if end_align > 0 {\n+            offset = if end_align >= len { 0 } else { len - end_align };\n+            if let Some(index) = text[offset..].iter().rposition(|elt| *elt == x) {\n+                return Some(offset + index);\n+            }\n+        } else {\n+            offset = len;\n+        }\n+\n+        // search the body of the text\n+        let repeated_x = repeat_byte(x);\n+\n+        while offset >= 2 * usize_bytes {\n+            unsafe {\n+                let u = *(ptr.offset(offset as isize - 2 * usize_bytes as isize) as *const usize);\n+                let v = *(ptr.offset(offset as isize - usize_bytes as isize) as *const usize);\n+\n+                // break if there is a matching byte\n+                let zu = contains_zero_byte(u ^ repeated_x);\n+                let zv = contains_zero_byte(v ^ repeated_x);\n+                if zu || zv {\n+                    break;\n+                }\n+            }\n+            offset -= 2 * usize_bytes;\n+        }\n+\n+        // find the byte before the point the body loop stopped\n+        text[..offset].iter().rposition(|elt| *elt == x)\n+    }\n+\n+    // test fallback implementations on all platforms\n+    #[test]\n+    fn matches_one() {\n+        assert_eq!(Some(0), memchr(b'a', b\"a\"));\n+    }\n+\n+    #[test]\n+    fn matches_begin() {\n+        assert_eq!(Some(0), memchr(b'a', b\"aaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_end() {\n+        assert_eq!(Some(4), memchr(b'z', b\"aaaaz\"));\n+    }\n+\n+    #[test]\n+    fn matches_nul() {\n+        assert_eq!(Some(4), memchr(b'\\x00', b\"aaaa\\x00\"));\n+    }\n+\n+    #[test]\n+    fn matches_past_nul() {\n+        assert_eq!(Some(5), memchr(b'z', b\"aaaa\\x00z\"));\n+    }\n+\n+    #[test]\n+    fn no_match_empty() {\n+        assert_eq!(None, memchr(b'a', b\"\"));\n+    }\n+\n+    #[test]\n+    fn no_match() {\n+        assert_eq!(None, memchr(b'a', b\"xyz\"));\n+    }\n+\n+    #[test]\n+    fn matches_one_reversed() {\n+        assert_eq!(Some(0), memrchr(b'a', b\"a\"));\n+    }\n+\n+    #[test]\n+    fn matches_begin_reversed() {\n+        assert_eq!(Some(3), memrchr(b'a', b\"aaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_end_reversed() {\n+        assert_eq!(Some(0), memrchr(b'z', b\"zaaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_nul_reversed() {\n+        assert_eq!(Some(4), memrchr(b'\\x00', b\"aaaa\\x00\"));\n+    }\n+\n+    #[test]\n+    fn matches_past_nul_reversed() {\n+        assert_eq!(Some(0), memrchr(b'z', b\"z\\x00aaaa\"));\n+    }\n+\n+    #[test]\n+    fn no_match_empty_reversed() {\n+        assert_eq!(None, memrchr(b'a', b\"\"));\n+    }\n+\n+    #[test]\n+    fn no_match_reversed() {\n+        assert_eq!(None, memrchr(b'a', b\"xyz\"));\n+    }\n+\n+    #[test]\n+    fn each_alignment_reversed() {\n+        let mut data = [1u8; 64];\n+        let needle = 2;\n+        let pos = 40;\n+        data[pos] = needle;\n+        for start in 0..16 {\n+            assert_eq!(Some(pos - start), memrchr(needle, &data[start..]));\n+        }\n+    }\n+}"}, {"sha": "2845f895f1869e30a174b6f3fde86c6ade9f73fd", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -25,12 +25,12 @@ macro_rules! rtassert {\n     })\n }\n \n-pub mod args;\n pub mod at_exit_imp;\n #[cfg(any(not(cargobuild), feature = \"backtrace\"))]\n pub mod backtrace;\n pub mod condvar;\n pub mod io;\n+pub mod memchr;\n pub mod mutex;\n pub mod net;\n pub mod poison;\n@@ -91,7 +91,7 @@ pub fn at_exit<F: FnOnce() + Send + 'static>(f: F) -> Result<(), ()> {\n pub fn cleanup() {\n     static CLEANUP: Once = Once::new();\n     CLEANUP.call_once(|| unsafe {\n-        args::cleanup();\n+        sys::args::cleanup();\n         sys::stack_overflow::cleanup();\n         at_exit_imp::cleanup();\n     });"}, {"sha": "c64db333e5106aee09df833b2a806ff9523a5a91", "filename": "src/libstd/sys/unix/args.rs", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fargs.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -0,0 +1,211 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Global initialization and retreival of command line arguments.\n+//!\n+//! On some platforms these are stored during runtime startup,\n+//! and on some they are retrieved from the system on demand.\n+\n+#![allow(dead_code)] // runtime init functions not used during testing\n+\n+use ffi::OsString;\n+use marker::PhantomData;\n+use vec;\n+\n+/// One-time global initialization.\n+pub unsafe fn init(argc: isize, argv: *const *const u8) { imp::init(argc, argv) }\n+\n+/// One-time global cleanup.\n+pub unsafe fn cleanup() { imp::cleanup() }\n+\n+/// Returns the command line arguments\n+pub fn args() -> Args {\n+    imp::args()\n+}\n+\n+pub struct Args {\n+    iter: vec::IntoIter<OsString>,\n+    _dont_send_or_sync_me: PhantomData<*mut ()>,\n+}\n+\n+impl Iterator for Args {\n+    type Item = OsString;\n+    fn next(&mut self) -> Option<OsString> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+impl ExactSizeIterator for Args {\n+    fn len(&self) -> usize { self.iter.len() }\n+}\n+\n+impl DoubleEndedIterator for Args {\n+    fn next_back(&mut self) -> Option<OsString> { self.iter.next_back() }\n+}\n+\n+#[cfg(any(target_os = \"linux\",\n+          target_os = \"android\",\n+          target_os = \"freebsd\",\n+          target_os = \"dragonfly\",\n+          target_os = \"bitrig\",\n+          target_os = \"netbsd\",\n+          target_os = \"openbsd\",\n+          target_os = \"solaris\",\n+          target_os = \"emscripten\",\n+          target_os = \"haiku\"))]\n+mod imp {\n+    use os::unix::prelude::*;\n+    use mem;\n+    use ffi::{CStr, OsString};\n+    use marker::PhantomData;\n+    use libc;\n+    use super::Args;\n+\n+    use sys_common::mutex::Mutex;\n+\n+    static mut GLOBAL_ARGS_PTR: usize = 0;\n+    static LOCK: Mutex = Mutex::new();\n+\n+    pub unsafe fn init(argc: isize, argv: *const *const u8) {\n+        let args = (0..argc).map(|i| {\n+            CStr::from_ptr(*argv.offset(i) as *const libc::c_char).to_bytes().to_vec()\n+        }).collect();\n+\n+        LOCK.lock();\n+        let ptr = get_global_ptr();\n+        assert!((*ptr).is_none());\n+        (*ptr) = Some(box args);\n+        LOCK.unlock();\n+    }\n+\n+    pub unsafe fn cleanup() {\n+        LOCK.lock();\n+        *get_global_ptr() = None;\n+        LOCK.unlock();\n+    }\n+\n+    pub fn args() -> Args {\n+        let bytes = clone().unwrap_or(Vec::new());\n+        let v: Vec<OsString> = bytes.into_iter().map(|v| {\n+            OsStringExt::from_vec(v)\n+        }).collect();\n+        Args { iter: v.into_iter(), _dont_send_or_sync_me: PhantomData }\n+    }\n+\n+    fn clone() -> Option<Vec<Vec<u8>>> {\n+        unsafe {\n+            LOCK.lock();\n+            let ptr = get_global_ptr();\n+            let ret = (*ptr).as_ref().map(|s| (**s).clone());\n+            LOCK.unlock();\n+            return ret\n+        }\n+    }\n+\n+    fn get_global_ptr() -> *mut Option<Box<Vec<Vec<u8>>>> {\n+        unsafe { mem::transmute(&GLOBAL_ARGS_PTR) }\n+    }\n+\n+}\n+\n+#[cfg(any(target_os = \"macos\",\n+          target_os = \"ios\"))]\n+mod imp {\n+    use ffi::CStr;\n+    use marker::PhantomData;\n+    use libc;\n+    use super::Args;\n+\n+    pub unsafe fn init(_argc: isize, _argv: *const *const u8) {\n+    }\n+\n+    pub fn cleanup() {\n+    }\n+\n+    #[cfg(target_os = \"macos\")]\n+    pub fn args() -> Args {\n+        use os::unix::prelude::*;\n+        extern {\n+            // These functions are in crt_externs.h.\n+            fn _NSGetArgc() -> *mut libc::c_int;\n+            fn _NSGetArgv() -> *mut *mut *mut libc::c_char;\n+        }\n+\n+        let vec = unsafe {\n+            let (argc, argv) = (*_NSGetArgc() as isize,\n+                                *_NSGetArgv() as *const *const libc::c_char);\n+            (0.. argc as isize).map(|i| {\n+                let bytes = CStr::from_ptr(*argv.offset(i)).to_bytes().to_vec();\n+                OsStringExt::from_vec(bytes)\n+            }).collect::<Vec<_>>()\n+        };\n+        Args {\n+            iter: vec.into_iter(),\n+            _dont_send_or_sync_me: PhantomData,\n+        }\n+    }\n+\n+    // As _NSGetArgc and _NSGetArgv aren't mentioned in iOS docs\n+    // and use underscores in their names - they're most probably\n+    // are considered private and therefore should be avoided\n+    // Here is another way to get arguments using Objective C\n+    // runtime\n+    //\n+    // In general it looks like:\n+    // res = Vec::new()\n+    // let args = [[NSProcessInfo processInfo] arguments]\n+    // for i in (0..[args count])\n+    //      res.push([args objectAtIndex:i])\n+    // res\n+    #[cfg(target_os = \"ios\")]\n+    pub fn args() -> Args {\n+        use ffi::OsString;\n+        use mem;\n+        use str;\n+\n+        extern {\n+            fn sel_registerName(name: *const libc::c_uchar) -> Sel;\n+            fn objc_msgSend(obj: NsId, sel: Sel, ...) -> NsId;\n+            fn objc_getClass(class_name: *const libc::c_uchar) -> NsId;\n+        }\n+\n+        #[link(name = \"Foundation\", kind = \"framework\")]\n+        #[link(name = \"objc\")]\n+        #[cfg(not(cargobuild))]\n+        extern {}\n+\n+        type Sel = *const libc::c_void;\n+        type NsId = *const libc::c_void;\n+\n+        let mut res = Vec::new();\n+\n+        unsafe {\n+            let process_info_sel = sel_registerName(\"processInfo\\0\".as_ptr());\n+            let arguments_sel = sel_registerName(\"arguments\\0\".as_ptr());\n+            let utf8_sel = sel_registerName(\"UTF8String\\0\".as_ptr());\n+            let count_sel = sel_registerName(\"count\\0\".as_ptr());\n+            let object_at_sel = sel_registerName(\"objectAtIndex:\\0\".as_ptr());\n+\n+            let klass = objc_getClass(\"NSProcessInfo\\0\".as_ptr());\n+            let info = objc_msgSend(klass, process_info_sel);\n+            let args = objc_msgSend(info, arguments_sel);\n+\n+            let cnt: usize = mem::transmute(objc_msgSend(args, count_sel));\n+            for i in 0..cnt {\n+                let tmp = objc_msgSend(args, object_at_sel, i);\n+                let utf_c_str: *const libc::c_char =\n+                    mem::transmute(objc_msgSend(tmp, utf8_sel));\n+                let bytes = CStr::from_ptr(utf_c_str).to_bytes();\n+                res.push(OsString::from(str::from_utf8(bytes).unwrap()))\n+            }\n+        }\n+\n+        Args { iter: res.into_iter(), _dont_send_or_sync_me: PhantomData }\n+    }\n+}"}, {"sha": "92c4899b3d52a384dab51174d8bc8bae4d21cd72", "filename": "src/libstd/sys/unix/env.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Funix%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Funix%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fenv.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -0,0 +1,173 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[cfg(target_os = \"linux\")]\n+pub mod os {\n+    pub const FAMILY: &'static str = \"unix\";\n+    pub const OS: &'static str = \"linux\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n+#[cfg(target_os = \"macos\")]\n+pub mod os {\n+    pub const FAMILY: &'static str = \"unix\";\n+    pub const OS: &'static str = \"macos\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_SUFFIX: &'static str = \".dylib\";\n+    pub const DLL_EXTENSION: &'static str = \"dylib\";\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n+#[cfg(target_os = \"ios\")]\n+pub mod os {\n+    pub const FAMILY: &'static str = \"unix\";\n+    pub const OS: &'static str = \"ios\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_SUFFIX: &'static str = \".dylib\";\n+    pub const DLL_EXTENSION: &'static str = \"dylib\";\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n+#[cfg(target_os = \"freebsd\")]\n+pub mod os {\n+    pub const FAMILY: &'static str = \"unix\";\n+    pub const OS: &'static str = \"freebsd\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n+#[cfg(target_os = \"dragonfly\")]\n+pub mod os {\n+    pub const FAMILY: &'static str = \"unix\";\n+    pub const OS: &'static str = \"dragonfly\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n+#[cfg(target_os = \"bitrig\")]\n+pub mod os {\n+    pub const FAMILY: &'static str = \"unix\";\n+    pub const OS: &'static str = \"bitrig\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n+#[cfg(target_os = \"netbsd\")]\n+pub mod os {\n+    pub const FAMILY: &'static str = \"unix\";\n+    pub const OS: &'static str = \"netbsd\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n+#[cfg(target_os = \"openbsd\")]\n+pub mod os {\n+    pub const FAMILY: &'static str = \"unix\";\n+    pub const OS: &'static str = \"openbsd\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n+#[cfg(target_os = \"android\")]\n+pub mod os {\n+    pub const FAMILY: &'static str = \"unix\";\n+    pub const OS: &'static str = \"android\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n+#[cfg(target_os = \"solaris\")]\n+pub mod os {\n+    pub const FAMILY: &'static str = \"unix\";\n+    pub const OS: &'static str = \"solaris\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n+#[cfg(all(target_os = \"nacl\", not(target_arch = \"le32\")))]\n+pub mod os {\n+    pub const FAMILY: &'static str = \"unix\";\n+    pub const OS: &'static str = \"nacl\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+    pub const EXE_SUFFIX: &'static str = \".nexe\";\n+    pub const EXE_EXTENSION: &'static str = \"nexe\";\n+}\n+#[cfg(all(target_os = \"nacl\", target_arch = \"le32\"))]\n+pub mod os {\n+    pub const FAMILY: &'static str = \"unix\";\n+    pub const OS: &'static str = \"pnacl\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_SUFFIX: &'static str = \".pso\";\n+    pub const DLL_EXTENSION: &'static str = \"pso\";\n+    pub const EXE_SUFFIX: &'static str = \".pexe\";\n+    pub const EXE_EXTENSION: &'static str = \"pexe\";\n+}\n+\n+#[cfg(target_os = \"haiku\")]\n+mod os {\n+    pub const FAMILY: &'static str = \"unix\";\n+    pub const OS: &'static str = \"haiku\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}\n+\n+#[cfg(all(target_os = \"emscripten\", target_arch = \"asmjs\"))]\n+mod os {\n+    pub const FAMILY: &'static str = \"unix\";\n+    pub const OS: &'static str = \"emscripten\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+    pub const EXE_SUFFIX: &'static str = \".js\";\n+    pub const EXE_EXTENSION: &'static str = \"js\";\n+}\n+\n+#[cfg(all(target_os = \"emscripten\", target_arch = \"wasm32\"))]\n+mod os {\n+    pub const FAMILY: &'static str = \"unix\";\n+    pub const OS: &'static str = \"emscripten\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+    pub const EXE_SUFFIX: &'static str = \".js\";\n+    pub const EXE_EXTENSION: &'static str = \"js\";\n+}"}, {"sha": "5038e0750c8d22173a46a617516bf93b1100078d", "filename": "src/libstd/sys/unix/memchr.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Funix%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Funix%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmemchr.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// Original implementation taken from rust-memchr\n+// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n+\n+pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n+    use libc;\n+\n+    let p = unsafe {\n+        libc::memchr(\n+            haystack.as_ptr() as *const libc::c_void,\n+            needle as libc::c_int,\n+            haystack.len() as libc::size_t)\n+    };\n+    if p.is_null() {\n+        None\n+    } else {\n+        Some(p as usize - (haystack.as_ptr() as usize))\n+    }\n+}\n+\n+pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n+\n+    #[cfg(target_os = \"linux\")]\n+    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n+        use libc;\n+\n+        // GNU's memrchr() will - unlike memchr() - error if haystack is empty.\n+        if haystack.is_empty() {return None}\n+        let p = unsafe {\n+            libc::memrchr(\n+                haystack.as_ptr() as *const libc::c_void,\n+                needle as libc::c_int,\n+                haystack.len() as libc::size_t)\n+        };\n+        if p.is_null() {\n+            None\n+        } else {\n+            Some(p as usize - (haystack.as_ptr() as usize))\n+        }\n+    }\n+\n+    #[cfg(not(target_os = \"linux\"))]\n+    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n+        ::sys_common::memchr::fallback::memrchr(needle, haystack)\n+    }\n+\n+    memrchr_specific(needle, haystack)\n+}"}, {"sha": "dc410cba89e04e4bfb4b52a0d39d30b75921ef85", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -30,17 +30,21 @@ use libc;\n #[macro_use]\n pub mod weak;\n \n+pub mod args;\n pub mod android;\n #[cfg(any(not(cargobuild), feature = \"backtrace\"))]\n pub mod backtrace;\n pub mod condvar;\n+pub mod env;\n pub mod ext;\n pub mod fd;\n pub mod fs;\n+pub mod memchr;\n pub mod mutex;\n pub mod net;\n pub mod os;\n pub mod os_str;\n+pub mod path;\n pub mod pipe;\n pub mod process;\n pub mod rand;"}, {"sha": "c6118a333b192e5f24d2ce0b1a863c440578bec4", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -347,126 +347,6 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     }\n }\n \n-pub struct Args {\n-    iter: vec::IntoIter<OsString>,\n-    _dont_send_or_sync_me: PhantomData<*mut ()>,\n-}\n-\n-impl Iterator for Args {\n-    type Item = OsString;\n-    fn next(&mut self) -> Option<OsString> { self.iter.next() }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n-}\n-\n-impl ExactSizeIterator for Args {\n-    fn len(&self) -> usize { self.iter.len() }\n-}\n-\n-impl DoubleEndedIterator for Args {\n-    fn next_back(&mut self) -> Option<OsString> { self.iter.next_back() }\n-}\n-\n-/// Returns the command line arguments\n-///\n-/// Returns a list of the command line arguments.\n-#[cfg(target_os = \"macos\")]\n-pub fn args() -> Args {\n-    extern {\n-        // These functions are in crt_externs.h.\n-        fn _NSGetArgc() -> *mut c_int;\n-        fn _NSGetArgv() -> *mut *mut *mut c_char;\n-    }\n-\n-    let vec = unsafe {\n-        let (argc, argv) = (*_NSGetArgc() as isize,\n-                            *_NSGetArgv() as *const *const c_char);\n-        (0.. argc as isize).map(|i| {\n-            let bytes = CStr::from_ptr(*argv.offset(i)).to_bytes().to_vec();\n-            OsStringExt::from_vec(bytes)\n-        }).collect::<Vec<_>>()\n-    };\n-    Args {\n-        iter: vec.into_iter(),\n-        _dont_send_or_sync_me: PhantomData,\n-    }\n-}\n-\n-// As _NSGetArgc and _NSGetArgv aren't mentioned in iOS docs\n-// and use underscores in their names - they're most probably\n-// are considered private and therefore should be avoided\n-// Here is another way to get arguments using Objective C\n-// runtime\n-//\n-// In general it looks like:\n-// res = Vec::new()\n-// let args = [[NSProcessInfo processInfo] arguments]\n-// for i in (0..[args count])\n-//      res.push([args objectAtIndex:i])\n-// res\n-#[cfg(target_os = \"ios\")]\n-pub fn args() -> Args {\n-    use mem;\n-\n-    extern {\n-        fn sel_registerName(name: *const libc::c_uchar) -> Sel;\n-        fn objc_msgSend(obj: NsId, sel: Sel, ...) -> NsId;\n-        fn objc_getClass(class_name: *const libc::c_uchar) -> NsId;\n-    }\n-\n-    #[link(name = \"Foundation\", kind = \"framework\")]\n-    #[link(name = \"objc\")]\n-    #[cfg(not(cargobuild))]\n-    extern {}\n-\n-    type Sel = *const libc::c_void;\n-    type NsId = *const libc::c_void;\n-\n-    let mut res = Vec::new();\n-\n-    unsafe {\n-        let process_info_sel = sel_registerName(\"processInfo\\0\".as_ptr());\n-        let arguments_sel = sel_registerName(\"arguments\\0\".as_ptr());\n-        let utf8_sel = sel_registerName(\"UTF8String\\0\".as_ptr());\n-        let count_sel = sel_registerName(\"count\\0\".as_ptr());\n-        let object_at_sel = sel_registerName(\"objectAtIndex:\\0\".as_ptr());\n-\n-        let klass = objc_getClass(\"NSProcessInfo\\0\".as_ptr());\n-        let info = objc_msgSend(klass, process_info_sel);\n-        let args = objc_msgSend(info, arguments_sel);\n-\n-        let cnt: usize = mem::transmute(objc_msgSend(args, count_sel));\n-        for i in 0..cnt {\n-            let tmp = objc_msgSend(args, object_at_sel, i);\n-            let utf_c_str: *const libc::c_char =\n-                mem::transmute(objc_msgSend(tmp, utf8_sel));\n-            let bytes = CStr::from_ptr(utf_c_str).to_bytes();\n-            res.push(OsString::from(str::from_utf8(bytes).unwrap()))\n-        }\n-    }\n-\n-    Args { iter: res.into_iter(), _dont_send_or_sync_me: PhantomData }\n-}\n-\n-#[cfg(any(target_os = \"linux\",\n-          target_os = \"android\",\n-          target_os = \"freebsd\",\n-          target_os = \"dragonfly\",\n-          target_os = \"bitrig\",\n-          target_os = \"netbsd\",\n-          target_os = \"openbsd\",\n-          target_os = \"solaris\",\n-          target_os = \"nacl\",\n-          target_os = \"emscripten\",\n-          target_os = \"haiku\"))]\n-pub fn args() -> Args {\n-    use sys_common;\n-    let bytes = sys_common::args::clone().unwrap_or(Vec::new());\n-    let v: Vec<OsString> = bytes.into_iter().map(|v| {\n-        OsStringExt::from_vec(v)\n-    }).collect();\n-    Args { iter: v.into_iter(), _dont_send_or_sync_me: PhantomData }\n-}\n-\n pub struct Env {\n     iter: vec::IntoIter<(OsString, OsString)>,\n     _dont_send_or_sync_me: PhantomData<*mut ()>,"}, {"sha": "bf9af7a4353a89b67992cf63ff18709db4e48086", "filename": "src/libstd/sys/unix/path.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Funix%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Funix%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpath.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use path::Prefix;\n+use ffi::OsStr;\n+\n+#[inline]\n+pub fn is_sep_byte(b: u8) -> bool {\n+    b == b'/'\n+}\n+\n+#[inline]\n+pub fn is_verbatim_sep(b: u8) -> bool {\n+    b == b'/'\n+}\n+\n+pub fn parse_prefix(_: &OsStr) -> Option<Prefix> {\n+    None\n+}\n+\n+pub const MAIN_SEP_STR: &'static str = \"/\";\n+pub const MAIN_SEP: char = '/';"}, {"sha": "947ba2cc75232a72fdb8f0b6440c87445f55b837", "filename": "src/libstd/sys/unix/stdio.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstdio.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -65,3 +65,5 @@ impl io::Write for Stderr {\n     }\n     fn flush(&mut self) -> io::Result<()> { Ok(()) }\n }\n+\n+pub const EBADF_ERR: i32 = ::libc::EBADF as i32;"}, {"sha": "aa61f9adb824d327e1e98fadcf0fa0323b1c80b1", "filename": "src/libstd/sys/windows/args.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -0,0 +1,76 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)] // runtime init functions not used during testing\n+\n+use os::windows::prelude::*;\n+use sys::c;\n+use slice;\n+use ops::Range;\n+use ffi::OsString;\n+use libc::{c_int, c_void};\n+\n+pub unsafe fn init(_argc: isize, _argv: *const *const u8) { }\n+\n+pub unsafe fn cleanup() { }\n+\n+pub fn args() -> Args {\n+    unsafe {\n+        let mut nArgs: c_int = 0;\n+        let lpCmdLine = c::GetCommandLineW();\n+        let szArgList = c::CommandLineToArgvW(lpCmdLine, &mut nArgs);\n+\n+        // szArcList can be NULL if CommandLinToArgvW failed,\n+        // but in that case nArgs is 0 so we won't actually\n+        // try to read a null pointer\n+        Args { cur: szArgList, range: 0..(nArgs as isize) }\n+    }\n+}\n+\n+pub struct Args {\n+    range: Range<isize>,\n+    cur: *mut *mut u16,\n+}\n+\n+unsafe fn os_string_from_ptr(ptr: *mut u16) -> OsString {\n+    let mut len = 0;\n+    while *ptr.offset(len) != 0 { len += 1; }\n+\n+    // Push it onto the list.\n+    let ptr = ptr as *const u16;\n+    let buf = slice::from_raw_parts(ptr, len as usize);\n+    OsStringExt::from_wide(buf)\n+}\n+\n+impl Iterator for Args {\n+    type Item = OsString;\n+    fn next(&mut self) -> Option<OsString> {\n+        self.range.next().map(|i| unsafe { os_string_from_ptr(*self.cur.offset(i)) } )\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }\n+}\n+\n+impl DoubleEndedIterator for Args {\n+    fn next_back(&mut self) -> Option<OsString> {\n+        self.range.next_back().map(|i| unsafe { os_string_from_ptr(*self.cur.offset(i)) } )\n+    }\n+}\n+\n+impl ExactSizeIterator for Args {\n+    fn len(&self) -> usize { self.range.len() }\n+}\n+\n+impl Drop for Args {\n+    fn drop(&mut self) {\n+        // self.cur can be null if CommandLineToArgvW previously failed,\n+        // but LocalFree ignores NULL pointers\n+        unsafe { c::LocalFree(self.cur as *mut c_void); }\n+    }\n+}"}, {"sha": "e6d74895774cea73d7e646128c775cf57ec47777", "filename": "src/libstd/sys/windows/env.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Fwindows%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Fwindows%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fenv.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub mod os {\n+    pub const FAMILY: &'static str = \"windows\";\n+    pub const OS: &'static str = \"windows\";\n+    pub const DLL_PREFIX: &'static str = \"\";\n+    pub const DLL_SUFFIX: &'static str = \".dll\";\n+    pub const DLL_EXTENSION: &'static str = \"dll\";\n+    pub const EXE_SUFFIX: &'static str = \".exe\";\n+    pub const EXE_EXTENSION: &'static str = \"exe\";\n+}"}, {"sha": "5a5386acaa5311a748976be4fbc183e612b1d696", "filename": "src/libstd/sys/windows/memchr.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Fwindows%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Fwindows%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmemchr.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// Original implementation taken from rust-memchr\n+// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n+\n+// Fallback memchr is fastest on windows\n+pub use sys_common::memchr::fallback::{memchr, memrchr};"}, {"sha": "9cd6e6ca1761dfa23937f2628b27d3820d605eeb", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -18,17 +18,21 @@ use time::Duration;\n \n #[macro_use] pub mod compat;\n \n+pub mod args;\n pub mod backtrace;\n pub mod c;\n pub mod condvar;\n pub mod dynamic_lib;\n+pub mod env;\n pub mod ext;\n pub mod fs;\n pub mod handle;\n+pub mod memchr;\n pub mod mutex;\n pub mod net;\n pub mod os;\n pub mod os_str;\n+pub mod path;\n pub mod pipe;\n pub mod process;\n pub mod rand;"}, {"sha": "7e28dd1e259c8c1551e7f73fc97d2daaecc09501", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -18,8 +18,6 @@ use error::Error as StdError;\n use ffi::{OsString, OsStr};\n use fmt;\n use io;\n-use libc::{c_int, c_void};\n-use ops::Range;\n use os::windows::ffi::EncodeWide;\n use path::{self, PathBuf};\n use ptr;\n@@ -272,60 +270,6 @@ pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n     }).map(|_| ())\n }\n \n-pub struct Args {\n-    range: Range<isize>,\n-    cur: *mut *mut u16,\n-}\n-\n-unsafe fn os_string_from_ptr(ptr: *mut u16) -> OsString {\n-    let mut len = 0;\n-    while *ptr.offset(len) != 0 { len += 1; }\n-\n-    // Push it onto the list.\n-    let ptr = ptr as *const u16;\n-    let buf = slice::from_raw_parts(ptr, len as usize);\n-    OsStringExt::from_wide(buf)\n-}\n-\n-impl Iterator for Args {\n-    type Item = OsString;\n-    fn next(&mut self) -> Option<OsString> {\n-        self.range.next().map(|i| unsafe { os_string_from_ptr(*self.cur.offset(i)) } )\n-    }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }\n-}\n-\n-impl DoubleEndedIterator for Args {\n-    fn next_back(&mut self) -> Option<OsString> {\n-        self.range.next_back().map(|i| unsafe { os_string_from_ptr(*self.cur.offset(i)) } )\n-    }\n-}\n-\n-impl ExactSizeIterator for Args {\n-    fn len(&self) -> usize { self.range.len() }\n-}\n-\n-impl Drop for Args {\n-    fn drop(&mut self) {\n-        // self.cur can be null if CommandLineToArgvW previously failed,\n-        // but LocalFree ignores NULL pointers\n-        unsafe { c::LocalFree(self.cur as *mut c_void); }\n-    }\n-}\n-\n-pub fn args() -> Args {\n-    unsafe {\n-        let mut nArgs: c_int = 0;\n-        let lpCmdLine = c::GetCommandLineW();\n-        let szArgList = c::CommandLineToArgvW(lpCmdLine, &mut nArgs);\n-\n-        // szArcList can be NULL if CommandLinToArgvW failed,\n-        // but in that case nArgs is 0 so we won't actually\n-        // try to read a null pointer\n-        Args { cur: szArgList, range: 0..(nArgs as isize) }\n-    }\n-}\n-\n pub fn temp_dir() -> PathBuf {\n     super::fill_utf16_buf(|buf, sz| unsafe {\n         c::GetTempPathW(sz, buf)"}, {"sha": "2b47808451bc29ed7b629e76778d6f7c52cf9024", "filename": "src/libstd/sys/windows/path.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpath.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -0,0 +1,108 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ascii::*;\n+\n+use path::Prefix;\n+use ffi::OsStr;\n+use mem;\n+\n+fn os_str_as_u8_slice(s: &OsStr) -> &[u8] {\n+    unsafe { mem::transmute(s) }\n+}\n+unsafe fn u8_slice_as_os_str(s: &[u8]) -> &OsStr {\n+    mem::transmute(s)\n+}\n+\n+#[inline]\n+pub fn is_sep_byte(b: u8) -> bool {\n+    b == b'/' || b == b'\\\\'\n+}\n+\n+#[inline]\n+pub fn is_verbatim_sep(b: u8) -> bool {\n+    b == b'\\\\'\n+}\n+\n+pub fn parse_prefix<'a>(path: &'a OsStr) -> Option<Prefix> {\n+    use path::Prefix::*;\n+    unsafe {\n+        // The unsafety here stems from converting between &OsStr and &[u8]\n+        // and back. This is safe to do because (1) we only look at ASCII\n+        // contents of the encoding and (2) new &OsStr values are produced\n+        // only from ASCII-bounded slices of existing &OsStr values.\n+        let mut path = os_str_as_u8_slice(path);\n+\n+        if path.starts_with(br\"\\\\\") {\n+            // \\\\\n+            path = &path[2..];\n+            if path.starts_with(br\"?\\\") {\n+                // \\\\?\\\n+                path = &path[2..];\n+                if path.starts_with(br\"UNC\\\") {\n+                    // \\\\?\\UNC\\server\\share\n+                    path = &path[4..];\n+                    let (server, share) = match parse_two_comps(path, is_verbatim_sep) {\n+                        Some((server, share)) =>\n+                            (u8_slice_as_os_str(server), u8_slice_as_os_str(share)),\n+                        None => (u8_slice_as_os_str(path), u8_slice_as_os_str(&[])),\n+                    };\n+                    return Some(VerbatimUNC(server, share));\n+                } else {\n+                    // \\\\?\\path\n+                    let idx = path.iter().position(|&b| b == b'\\\\');\n+                    if idx == Some(2) && path[1] == b':' {\n+                        let c = path[0];\n+                        if c.is_ascii() && (c as char).is_alphabetic() {\n+                            // \\\\?\\C:\\ path\n+                            return Some(VerbatimDisk(c.to_ascii_uppercase()));\n+                        }\n+                    }\n+                    let slice = &path[..idx.unwrap_or(path.len())];\n+                    return Some(Verbatim(u8_slice_as_os_str(slice)));\n+                }\n+            } else if path.starts_with(b\".\\\\\") {\n+                // \\\\.\\path\n+                path = &path[2..];\n+                let pos = path.iter().position(|&b| b == b'\\\\');\n+                let slice = &path[..pos.unwrap_or(path.len())];\n+                return Some(DeviceNS(u8_slice_as_os_str(slice)));\n+            }\n+            match parse_two_comps(path, is_sep_byte) {\n+                Some((server, share)) if !server.is_empty() && !share.is_empty() => {\n+                    // \\\\server\\share\n+                    return Some(UNC(u8_slice_as_os_str(server), u8_slice_as_os_str(share)));\n+                }\n+                _ => (),\n+            }\n+        } else if path.get(1) == Some(& b':') {\n+            // C:\n+            let c = path[0];\n+            if c.is_ascii() && (c as char).is_alphabetic() {\n+                return Some(Disk(c.to_ascii_uppercase()));\n+            }\n+        }\n+        return None;\n+    }\n+\n+    fn parse_two_comps(mut path: &[u8], f: fn(u8) -> bool) -> Option<(&[u8], &[u8])> {\n+        let first = match path.iter().position(|x| f(*x)) {\n+            None => return None,\n+            Some(x) => &path[..x],\n+        };\n+        path = &path[(first.len() + 1)..];\n+        let idx = path.iter().position(|x| f(*x));\n+        let second = &path[..idx.unwrap_or(path.len())];\n+        Some((first, second))\n+    }\n+}\n+\n+pub const MAIN_SEP_STR: &'static str = \"\\\\\";\n+pub const MAIN_SEP: char = '\\\\';"}, {"sha": "5f097d2631d9558c5e1129109aa19a85b898c71e", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -205,3 +205,5 @@ impl Output {\n fn invalid_encoding() -> io::Error {\n     io::Error::new(io::ErrorKind::InvalidData, \"text was not valid unicode\")\n }\n+\n+pub const EBADF_ERR: i32 = ::sys::c::ERROR_INVALID_HANDLE as i32;"}, {"sha": "cabaee5d0600551ac1df0488456353b3ebc669b5", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -36,6 +36,7 @@ mod errors;\n mod features;\n mod cargo;\n mod cargo_lock;\n+mod pal;\n \n fn main() {\n     let path = env::args_os().skip(1).next().expect(\"need an argument\");\n@@ -48,6 +49,7 @@ fn main() {\n     cargo::check(&path, &mut bad);\n     features::check(&path, &mut bad);\n     cargo_lock::check(&path, &mut bad);\n+    pal::check(&path, &mut bad);\n \n     if bad {\n         panic!(\"some tidy checks failed\");"}, {"sha": "1d04e8fc8eb7914db8ed267d934537c2117ff71c", "filename": "src/tools/tidy/src/pal.rs", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144af3e97aa30feba3d36a98ac04c0f1b2bc0bea/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=144af3e97aa30feba3d36a98ac04c0f1b2bc0bea", "patch": "@@ -0,0 +1,230 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Tidy check to enforce rules about platform-specific code in std\n+//!\n+//! This is intended to maintain existing standards of code\n+//! organization in hopes that the standard library will continue to\n+//! be refactored to isolate platform-specific bits, making porting\n+//! easier; where \"standard library\" roughly means \"all the\n+//! dependencies of the std and test crates\".\n+//!\n+//! This generally means placing restrictions on where `cfg(unix)`,\n+//! `cfg(windows)`, `cfg(target_os)` and `cfg(target_env)` may appear,\n+//! the basic objective being to isolate platform-specific code to the\n+//! platform-specific `std::sys` modules, and to the allocation,\n+//! unwinding, and libc crates.\n+//!\n+//! Following are the basic rules, though there are currently\n+//! exceptions:\n+//!\n+//! - core may not have platform-specific code\n+//! - liballoc_system may have platform-specific code\n+//! - liballoc_jemalloc may have platform-specific code\n+//! - libpanic_abort may have platform-specific code\n+//! - libpanic_unwind may have platform-specific code\n+//! - libunwind may have platform-specific code\n+//! - other crates in the std facade may not\n+//! - std may have platform-specific code in the following places\n+//!   - sys/unix/\n+//!   - sys/windows/\n+//!   - os/\n+//!\n+//! `std/sys_common` should _not_ contain platform-specific code.\n+//! Finally, because std contains tests with platform-specific\n+//! `ignore` attributes, once the parser encounters `mod tests`,\n+//! platform-specific cfgs are allowed. Not sure yet how to deal with\n+//! this in the long term.\n+\n+use std::fs::File;\n+use std::io::Read;\n+use std::path::Path;\n+use std::iter::Iterator;\n+\n+// Paths that may contain platform-specific code\n+const EXCEPTION_PATHS: &'static [&'static str] = &[\n+    // std crates\n+    \"src/liballoc_jemalloc\",\n+    \"src/liballoc_system\",\n+    \"src/liblibc\",\n+    \"src/libpanic_abort\",\n+    \"src/libpanic_unwind\",\n+    \"src/libunwind\",\n+    \"src/libstd/sys/unix\", // This is where platform-specific code for std should live\n+    \"src/libstd/sys/windows\", // Ditto\n+    \"src/libstd/os\", // Platform-specific public interfaces\n+    \"src/rtstartup\", // Not sure what to do about this. magic stuff for mingw\n+\n+    // temporary exceptions\n+    \"src/libstd/lib.rs\", // This could probably be done within the sys directory\n+    \"src/libstd/rtdeps.rs\", // Until rustbuild replaces make\n+    \"src/libstd/path.rs\",\n+    \"src/libstd/io/stdio.rs\",\n+    \"src/libstd/num/f32.rs\",\n+    \"src/libstd/num/f64.rs\",\n+    \"src/libstd/thread/local.rs\",\n+    \"src/libstd/sys/common/mod.rs\",\n+    \"src/libstd/sys/common/net.rs\",\n+    \"src/libstd/sys/common/util.rs\",\n+    \"src/libterm\", // Not sure how to make this crate portable, but test needs it\n+    \"src/libtest\", // Probably should defer to unstable std::sys APIs\n+\n+    // std testing crates, ok for now at least\n+    \"src/libcoretest\",\n+\n+    // non-std crates\n+    \"src/test\",\n+    \"src/tools\",\n+    \"src/librustc\",\n+    \"src/librustdoc\",\n+    \"src/libsyntax\",\n+    \"src/bootstrap\",\n+];\n+\n+pub fn check(path: &Path, bad: &mut bool) {\n+    let ref mut contents = String::new();\n+    // Sanity check that the complex parsing here works\n+    let ref mut saw_target_arch = false;\n+    let ref mut saw_cfg_bang = false;\n+    super::walk(path, &mut super::filter_dirs, &mut |file| {\n+        let filestr = file.to_string_lossy().replace(\"\\\\\", \"/\");\n+        if !filestr.ends_with(\".rs\") { return }\n+\n+        let is_exception_path = EXCEPTION_PATHS.iter().any(|s| filestr.contains(&**s));\n+        if is_exception_path { return }\n+\n+        check_cfgs(contents, &file, bad, saw_target_arch, saw_cfg_bang);\n+    });\n+\n+    assert!(*saw_target_arch);\n+    assert!(*saw_cfg_bang);\n+}\n+\n+fn check_cfgs(contents: &mut String, file: &Path,\n+              bad: &mut bool, saw_target_arch: &mut bool, saw_cfg_bang: &mut bool) {\n+    contents.truncate(0);\n+    t!(t!(File::open(file), file).read_to_string(contents));\n+\n+    // For now it's ok to have platform-specific code after 'mod tests'.\n+    let mod_tests_idx = find_test_mod(contents);\n+    let contents = &contents[..mod_tests_idx];\n+    // Pull out all \"cfg(...)\" and \"cfg!(...)\" strings\n+    let cfgs = parse_cfgs(contents);\n+\n+    let mut line_numbers: Option<Vec<usize>> = None;\n+    let mut err = |idx: usize, cfg: &str| {\n+        if line_numbers.is_none() {\n+            line_numbers = Some(contents.match_indices('\\n').map(|(i, _)| i).collect());\n+        }\n+        let line_numbers = line_numbers.as_ref().expect(\"\");\n+        let line = match line_numbers.binary_search(&idx) {\n+            Ok(_) => unreachable!(),\n+            Err(i) => i + 1\n+        };\n+        println!(\"{}:{}: platform-specific cfg: {}\", file.display(), line, cfg);\n+        *bad = true;\n+    };\n+\n+    for (idx, cfg) in cfgs.into_iter() {\n+        // Sanity check that the parsing here works\n+        if !*saw_target_arch && cfg.contains(\"target_arch\") { *saw_target_arch = true }\n+        if !*saw_cfg_bang && cfg.contains(\"cfg!\") { *saw_cfg_bang = true }\n+\n+        let contains_platform_specific_cfg =\n+            cfg.contains(\"target_os\")\n+            || cfg.contains(\"target_env\")\n+            || cfg.contains(\"target_vendor\")\n+            || cfg.contains(\"unix\")\n+            || cfg.contains(\"windows\");\n+\n+        if !contains_platform_specific_cfg { continue }\n+\n+        let preceeded_by_doc_comment = {\n+            let pre_contents = &contents[..idx];\n+            let pre_newline = pre_contents.rfind('\\n');\n+            let pre_doc_comment = pre_contents.rfind(\"///\");\n+            match (pre_newline, pre_doc_comment) {\n+                (Some(n), Some(c)) => n < c,\n+                (None, Some(_)) => true,\n+                (_, None) => false,\n+            }\n+        };\n+\n+        if preceeded_by_doc_comment { continue }\n+\n+        err(idx, cfg);\n+    }\n+}\n+\n+fn find_test_mod(contents: &str) -> usize {\n+    if let Some(mod_tests_idx) = contents.find(\"mod tests\") {\n+        // Also capture a previos line indicating \"mod tests\" in cfg-ed out\n+        let prev_newline_idx = contents[..mod_tests_idx].rfind('\\n').unwrap_or(mod_tests_idx);\n+        let prev_newline_idx = contents[..prev_newline_idx].rfind('\\n');\n+        if let Some(nl) = prev_newline_idx {\n+            let prev_line = &contents[nl + 1 .. mod_tests_idx];\n+            let emcc_cfg = \"cfg(all(test, not(target_os\";\n+            if prev_line.contains(emcc_cfg) {\n+                nl\n+            } else {\n+                mod_tests_idx\n+            }\n+        } else {\n+            mod_tests_idx\n+        }\n+    } else {\n+        contents.len()\n+    }\n+}\n+\n+fn parse_cfgs<'a>(contents: &'a str) -> Vec<(usize, &'a str)> {\n+    let candidate_cfgs = contents.match_indices(\"cfg\");\n+    let candidate_cfg_idxs = candidate_cfgs.map(|(i, _)| i);\n+    // This is puling out the indexes of all \"cfg\" strings\n+    // that appear to be tokens succeeded by a paren.\n+    let cfgs = candidate_cfg_idxs.filter(|i| {\n+        let pre_idx = i.saturating_sub(*i);\n+        let succeeds_non_ident = !contents.as_bytes().get(pre_idx)\n+            .cloned()\n+            .map(char::from)\n+            .map(char::is_alphanumeric)\n+            .unwrap_or(false);\n+        let contents_after = &contents[*i..];\n+        let first_paren = contents_after.find('(');\n+        let paren_idx = first_paren.map(|ip| i + ip);\n+        let preceeds_whitespace_and_paren = paren_idx.map(|ip| {\n+            let maybe_space = &contents[*i + \"cfg\".len() .. ip];\n+            maybe_space.chars().all(|c| char::is_whitespace(c) || c == '!')\n+        }).unwrap_or(false);\n+\n+        succeeds_non_ident && preceeds_whitespace_and_paren\n+    });\n+\n+    cfgs.map(|i| {\n+        let mut depth = 0;\n+        let contents_from = &contents[i..];\n+        for (j, byte) in contents_from.bytes().enumerate() {\n+            match byte {\n+                b'(' => {\n+                    depth += 1;\n+                }\n+                b')' => {\n+                    depth -= 1;\n+                    if depth == 0 {\n+                        return (i, &contents_from[.. j + 1]);\n+                    }\n+                }\n+                _ => { }\n+            }\n+        }\n+\n+        unreachable!()\n+    }).collect()\n+}"}]}