{"sha": "d338513e95d8180702c59c4b1c95540331191a68", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzMzg1MTNlOTVkODE4MDcwMmM1OWM0YjFjOTU1NDAzMzExOTFhNjg=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-12-10T14:53:48Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-12-10T14:53:48Z"}, "message": "Remove item tree tests\n\nThey were useful during initial development of the item tree, but\nnow just cause churn", "tree": {"sha": "36ddb5fab0567a786837b2714de5f615631a3e75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36ddb5fab0567a786837b2714de5f615631a3e75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d338513e95d8180702c59c4b1c95540331191a68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d338513e95d8180702c59c4b1c95540331191a68", "html_url": "https://github.com/rust-lang/rust/commit/d338513e95d8180702c59c4b1c95540331191a68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d338513e95d8180702c59c4b1c95540331191a68/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d82292e1ce8112cfa5e42d0221a563649d067747", "url": "https://api.github.com/repos/rust-lang/rust/commits/d82292e1ce8112cfa5e42d0221a563649d067747", "html_url": "https://github.com/rust-lang/rust/commit/d82292e1ce8112cfa5e42d0221a563649d067747"}], "stats": {"total": 441, "additions": 0, "deletions": 441}, "files": [{"sha": "c017b352d86b96641d4334cc50ab988d6551784f", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d338513e95d8180702c59c4b1c95540331191a68/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d338513e95d8180702c59c4b1c95540331191a68/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=d338513e95d8180702c59c4b1c95540331191a68", "patch": "@@ -1,8 +1,6 @@\n //! A simplified AST that only contains items.\n \n mod lower;\n-#[cfg(test)]\n-mod tests;\n \n use std::{\n     any::type_name,"}, {"sha": "4b354c4c145e53948d65d6e6cad28324f16f2115", "filename": "crates/hir_def/src/item_tree/tests.rs", "status": "removed", "additions": 0, "deletions": 439, "changes": 439, "blob_url": "https://github.com/rust-lang/rust/blob/d82292e1ce8112cfa5e42d0221a563649d067747/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d82292e1ce8112cfa5e42d0221a563649d067747/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs?ref=d82292e1ce8112cfa5e42d0221a563649d067747", "patch": "@@ -1,439 +0,0 @@\n-use base_db::fixture::WithFixture;\n-use expect_test::{expect, Expect};\n-use hir_expand::{db::AstDatabase, HirFileId, InFile};\n-use rustc_hash::FxHashSet;\n-use std::sync::Arc;\n-use stdx::format_to;\n-use syntax::{ast, AstNode};\n-\n-use crate::{db::DefDatabase, test_db::TestDB};\n-\n-use super::{ItemTree, ModItem, ModKind};\n-\n-fn test_inner_items(ra_fixture: &str) {\n-    let (db, file_id) = TestDB::with_single_file(ra_fixture);\n-    let file_id = HirFileId::from(file_id);\n-    let tree = db.item_tree(file_id);\n-    let root = db.parse_or_expand(file_id).unwrap();\n-    let ast_id_map = db.ast_id_map(file_id);\n-\n-    // Traverse the item tree and collect all module/impl/trait-level items as AST nodes.\n-    let mut outer_items = FxHashSet::default();\n-    let mut worklist = tree.top_level_items().to_vec();\n-    while let Some(item) = worklist.pop() {\n-        let node: ast::Item = match item {\n-            ModItem::Import(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n-            ModItem::ExternCrate(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n-            ModItem::Function(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n-            ModItem::Struct(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n-            ModItem::Union(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n-            ModItem::Enum(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n-            ModItem::Const(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n-            ModItem::Static(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n-            ModItem::TypeAlias(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n-            ModItem::Mod(it) => {\n-                if let ModKind::Inline { items } = &tree[it].kind {\n-                    worklist.extend(&**items);\n-                }\n-                tree.source(&db, InFile::new(file_id, it)).into()\n-            }\n-            ModItem::Trait(it) => {\n-                worklist.extend(tree[it].items.iter().map(|item| ModItem::from(*item)));\n-                tree.source(&db, InFile::new(file_id, it)).into()\n-            }\n-            ModItem::Impl(it) => {\n-                worklist.extend(tree[it].items.iter().map(|item| ModItem::from(*item)));\n-                tree.source(&db, InFile::new(file_id, it)).into()\n-            }\n-            ModItem::MacroCall(_) => continue,\n-        };\n-\n-        outer_items.insert(node);\n-    }\n-\n-    // Now descend the root node and check that all `ast::ModuleItem`s are either recorded above, or\n-    // registered as inner items.\n-    for item in root.descendants().skip(1).filter_map(ast::Item::cast) {\n-        if outer_items.contains(&item) {\n-            continue;\n-        }\n-\n-        let ast_id = ast_id_map.ast_id(&item);\n-        assert!(!tree.inner_items(ast_id).is_empty());\n-    }\n-}\n-\n-fn item_tree(ra_fixture: &str) -> Arc<ItemTree> {\n-    let (db, file_id) = TestDB::with_single_file(ra_fixture);\n-    db.item_tree(file_id.into())\n-}\n-\n-fn print_item_tree(ra_fixture: &str) -> String {\n-    let tree = item_tree(ra_fixture);\n-    let mut out = String::new();\n-\n-    format_to!(out, \"inner attrs: {:?}\\n\\n\", tree.top_level_attrs());\n-    format_to!(out, \"top-level items:\\n\");\n-    for item in tree.top_level_items() {\n-        fmt_mod_item(&mut out, &tree, *item);\n-        format_to!(out, \"\\n\");\n-    }\n-\n-    if !tree.inner_items.is_empty() {\n-        format_to!(out, \"\\ninner items:\\n\\n\");\n-        for (ast_id, items) in &tree.inner_items {\n-            format_to!(out, \"for AST {:?}:\\n\", ast_id);\n-            for inner in items {\n-                fmt_mod_item(&mut out, &tree, *inner);\n-                format_to!(out, \"\\n\\n\");\n-            }\n-        }\n-    }\n-\n-    out\n-}\n-\n-fn fmt_mod_item(out: &mut String, tree: &ItemTree, item: ModItem) {\n-    let attrs = tree.attrs(item.into());\n-    if !attrs.is_empty() {\n-        format_to!(out, \"#[{:?}]\\n\", attrs);\n-    }\n-\n-    let mut children = String::new();\n-    match item {\n-        ModItem::ExternCrate(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-        }\n-        ModItem::Import(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-        }\n-        ModItem::Function(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-        }\n-        ModItem::Struct(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-        }\n-        ModItem::Union(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-        }\n-        ModItem::Enum(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-        }\n-        ModItem::Const(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-        }\n-        ModItem::Static(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-        }\n-        ModItem::Trait(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-            for item in &*tree[it].items {\n-                fmt_mod_item(&mut children, tree, ModItem::from(*item));\n-                format_to!(children, \"\\n\");\n-            }\n-        }\n-        ModItem::Impl(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-            for item in &*tree[it].items {\n-                fmt_mod_item(&mut children, tree, ModItem::from(*item));\n-                format_to!(children, \"\\n\");\n-            }\n-        }\n-        ModItem::TypeAlias(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-        }\n-        ModItem::Mod(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-            match &tree[it].kind {\n-                ModKind::Inline { items } => {\n-                    for item in &**items {\n-                        fmt_mod_item(&mut children, tree, *item);\n-                        format_to!(children, \"\\n\");\n-                    }\n-                }\n-                ModKind::Outline {} => {}\n-            }\n-        }\n-        ModItem::MacroCall(it) => {\n-            format_to!(out, \"{:?}\", tree[it]);\n-        }\n-    }\n-\n-    for line in children.lines() {\n-        format_to!(out, \"\\n> {}\", line);\n-    }\n-}\n-\n-fn check(ra_fixture: &str, expect: Expect) {\n-    let actual = print_item_tree(ra_fixture);\n-    expect.assert_eq(&actual);\n-}\n-\n-#[test]\n-fn smoke() {\n-    check(\n-        r\"\n-        #![attr]\n-\n-        #[attr_on_use]\n-        use {a, b::*};\n-\n-        #[ext_crate]\n-        extern crate krate;\n-\n-        #[on_trait]\n-        trait Tr<U> {\n-            #[assoc_ty]\n-            type AssocTy: Tr<()>;\n-\n-            #[assoc_const]\n-            const CONST: u8;\n-\n-            #[assoc_method]\n-            fn method(&self);\n-\n-            #[assoc_dfl_method]\n-            fn dfl_method(&mut self) {}\n-        }\n-\n-        #[struct0]\n-        struct Struct0<T = ()>;\n-\n-        #[struct1]\n-        struct Struct1<T>(#[struct1fld] u8);\n-\n-        #[struct2]\n-        struct Struct2<T> {\n-            #[struct2fld]\n-            fld: (T, ),\n-        }\n-\n-        #[en]\n-        enum En {\n-            #[enum_variant]\n-            Variant {\n-                #[enum_field]\n-                field: u8,\n-            },\n-        }\n-\n-        #[un]\n-        union Un {\n-            #[union_fld]\n-            fld: u16,\n-        }\n-    \",\n-        expect![[r##\"\n-            inner attrs: Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr\"))] }, input: None }]) }\n-\n-            top-level items:\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_on_use\"))] }, input: None }]) }]\n-            Import { path: ModPath { kind: Plain, segments: [Name(Text(\"a\"))] }, alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_glob: false, is_prelude: false, ast_id: FileAstId::<syntax::ast::generated::nodes::Use>(0), index: 0 }\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_on_use\"))] }, input: None }]) }]\n-            Import { path: ModPath { kind: Plain, segments: [Name(Text(\"b\"))] }, alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_glob: true, is_prelude: false, ast_id: FileAstId::<syntax::ast::generated::nodes::Use>(0), index: 1 }\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"ext_crate\"))] }, input: None }]) }]\n-            ExternCrate { name: Name(Text(\"krate\")), alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_macro_use: false, ast_id: FileAstId::<syntax::ast::generated::nodes::ExternCrate>(1) }\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"on_trait\"))] }, input: None }]) }]\n-            Trait { name: Name(Text(\"Tr\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(0), auto: false, items: [TypeAlias(Idx::<TypeAlias>(0)), Const(Idx::<Const>(0)), Function(Idx::<Function>(0)), Function(Idx::<Function>(1))], ast_id: FileAstId::<syntax::ast::generated::nodes::Trait>(2) }\n-            > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"assoc_ty\"))] }, input: None }]) }]\n-            > TypeAlias { name: Name(Text(\"AssocTy\")), visibility: RawVisibilityId(\"pub(self)\"), bounds: [Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Tr\"))] }, generic_args: [Some(GenericArgs { args: [Type(Tuple([]))], has_self_type: false, bindings: [] })] })], generic_params: GenericParamsId(4294967295), type_ref: None, is_extern: false, ast_id: FileAstId::<syntax::ast::generated::nodes::TypeAlias>(8) }\n-            > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"assoc_const\"))] }, input: None }]) }]\n-            > Const { name: Some(Name(Text(\"CONST\"))), visibility: RawVisibilityId(\"pub(self)\"), type_ref: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"u8\"))] }, generic_args: [None] }), ast_id: FileAstId::<syntax::ast::generated::nodes::Const>(9) }\n-            > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"assoc_method\"))] }, input: None }]) }]\n-            > Function { name: Name(Text(\"method\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: true, has_body: false, is_unsafe: false, params: [Reference(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Self\"))] }, generic_args: [None] }), Shared)], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(10) }\n-            > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"assoc_dfl_method\"))] }, input: None }]) }]\n-            > Function { name: Name(Text(\"dfl_method\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: true, has_body: true, is_unsafe: false, params: [Reference(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Self\"))] }, generic_args: [None] }), Mut)], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(11) }\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"struct0\"))] }, input: None }]) }]\n-            Struct { name: Name(Text(\"Struct0\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(1), fields: Unit, ast_id: FileAstId::<syntax::ast::generated::nodes::Struct>(3), kind: Unit }\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"struct1\"))] }, input: None }]) }]\n-            Struct { name: Name(Text(\"Struct1\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(2), fields: Tuple(IdRange::<hir_def::item_tree::Field>(0..1)), ast_id: FileAstId::<syntax::ast::generated::nodes::Struct>(4), kind: Tuple }\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"struct2\"))] }, input: None }]) }]\n-            Struct { name: Name(Text(\"Struct2\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(3), fields: Record(IdRange::<hir_def::item_tree::Field>(1..2)), ast_id: FileAstId::<syntax::ast::generated::nodes::Struct>(5), kind: Record }\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"en\"))] }, input: None }]) }]\n-            Enum { name: Name(Text(\"En\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), variants: IdRange::<hir_def::item_tree::Variant>(0..1), ast_id: FileAstId::<syntax::ast::generated::nodes::Enum>(6) }\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"un\"))] }, input: None }]) }]\n-            Union { name: Name(Text(\"Un\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), fields: Record(IdRange::<hir_def::item_tree::Field>(3..4)), ast_id: FileAstId::<syntax::ast::generated::nodes::Union>(7) }\n-        \"##]],\n-    );\n-}\n-\n-#[test]\n-fn simple_inner_items() {\n-    check(\n-        r\"\n-        impl<T:A> D for Response<T> {\n-            fn foo() {\n-                end();\n-                fn end<W: Write>() {\n-                    let _x: T = loop {};\n-                }\n-            }\n-        }\n-    \",\n-        expect![[r#\"\n-            inner attrs: Attrs { entries: None }\n-\n-            top-level items:\n-            Impl { generic_params: GenericParamsId(0), target_trait: Some(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"D\"))] }, generic_args: [None] })), target_type: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Response\"))] }, generic_args: [Some(GenericArgs { args: [Type(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"T\"))] }, generic_args: [None] }))], has_self_type: false, bindings: [] })] }), is_negative: false, items: [Function(Idx::<Function>(1))], ast_id: FileAstId::<syntax::ast::generated::nodes::Impl>(0) }\n-            > Function { name: Name(Text(\"foo\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, has_body: true, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(1) }\n-\n-            inner items:\n-\n-            for AST FileAstId::<syntax::ast::generated::nodes::Item>(2):\n-            Function { name: Name(Text(\"end\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(1), has_self_param: false, has_body: true, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(2) }\n-\n-        \"#]],\n-    );\n-}\n-\n-#[test]\n-fn extern_attrs() {\n-    check(\n-        r#\"\n-        #[block_attr]\n-        extern \"C\" {\n-            #[attr_a]\n-            fn a() {}\n-            #[attr_b]\n-            fn b() {}\n-        }\n-    \"#,\n-        expect![[r##\"\n-            inner attrs: Attrs { entries: None }\n-\n-            top-level items:\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_a\"))] }, input: None }, Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"block_attr\"))] }, input: None }]) }]\n-            Function { name: Name(Text(\"a\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, has_body: true, is_unsafe: true, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(1) }\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_b\"))] }, input: None }, Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"block_attr\"))] }, input: None }]) }]\n-            Function { name: Name(Text(\"b\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, has_body: true, is_unsafe: true, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(2) }\n-        \"##]],\n-    );\n-}\n-\n-#[test]\n-fn trait_attrs() {\n-    check(\n-        r#\"\n-        #[trait_attr]\n-        trait Tr {\n-            #[attr_a]\n-            fn a() {}\n-            #[attr_b]\n-            fn b() {}\n-        }\n-    \"#,\n-        expect![[r##\"\n-            inner attrs: Attrs { entries: None }\n-\n-            top-level items:\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"trait_attr\"))] }, input: None }]) }]\n-            Trait { name: Name(Text(\"Tr\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(0), auto: false, items: [Function(Idx::<Function>(0)), Function(Idx::<Function>(1))], ast_id: FileAstId::<syntax::ast::generated::nodes::Trait>(0) }\n-            > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_a\"))] }, input: None }]) }]\n-            > Function { name: Name(Text(\"a\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, has_body: true, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(1) }\n-            > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_b\"))] }, input: None }]) }]\n-            > Function { name: Name(Text(\"b\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, has_body: true, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(2) }\n-        \"##]],\n-    );\n-}\n-\n-#[test]\n-fn impl_attrs() {\n-    check(\n-        r#\"\n-        #[impl_attr]\n-        impl Ty {\n-            #[attr_a]\n-            fn a() {}\n-            #[attr_b]\n-            fn b() {}\n-        }\n-    \"#,\n-        expect![[r##\"\n-            inner attrs: Attrs { entries: None }\n-\n-            top-level items:\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"impl_attr\"))] }, input: None }]) }]\n-            Impl { generic_params: GenericParamsId(4294967295), target_trait: None, target_type: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Ty\"))] }, generic_args: [None] }), is_negative: false, items: [Function(Idx::<Function>(0)), Function(Idx::<Function>(1))], ast_id: FileAstId::<syntax::ast::generated::nodes::Impl>(0) }\n-            > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_a\"))] }, input: None }]) }]\n-            > Function { name: Name(Text(\"a\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, has_body: true, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(1) }\n-            > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_b\"))] }, input: None }]) }]\n-            > Function { name: Name(Text(\"b\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, has_body: true, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(2) }\n-        \"##]],\n-    );\n-}\n-\n-#[test]\n-fn cursed_inner_items() {\n-    test_inner_items(\n-        r\"\n-        struct S<T: Trait = [u8; { fn f() {} 0 }]>(T);\n-\n-        enum En {\n-            Var1 {\n-                t: [(); { trait Inner {} 0 }],\n-            },\n-\n-            Var2([u16; { enum Inner {} 0 }]),\n-        }\n-\n-        type Ty = [En; { struct Inner; 0 }];\n-\n-        impl En {\n-            fn assoc() {\n-                trait InnerTrait<T = [u8; { fn f() {} }]> {}\n-                struct InnerStruct<T = [u8; { fn f() {} }]> {}\n-                impl<T = [u8; { fn f() {} }]> InnerTrait for InnerStruct {}\n-            }\n-        }\n-\n-        trait Tr<T = [u8; { fn f() {} }]> {\n-            type AssocTy = [u8; { fn f() {} }];\n-\n-            const AssocConst: [u8; { fn f() {} }];\n-        }\n-    \",\n-    );\n-}\n-\n-#[test]\n-fn inner_item_attrs() {\n-    check(\n-        r\"\n-        fn foo() {\n-            #[on_inner]\n-            fn inner() {}\n-        }\n-    \",\n-        expect![[r##\"\n-            inner attrs: Attrs { entries: None }\n-\n-            top-level items:\n-            Function { name: Name(Text(\"foo\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, has_body: true, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(0) }\n-\n-            inner items:\n-\n-            for AST FileAstId::<syntax::ast::generated::nodes::Item>(1):\n-            #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"on_inner\"))] }, input: None }]) }]\n-            Function { name: Name(Text(\"inner\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, has_body: true, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(1) }\n-\n-        \"##]],\n-    );\n-}\n-\n-#[test]\n-fn assoc_item_macros() {\n-    check(\n-        r\"\n-        impl S {\n-            items!();\n-        }\n-    \",\n-        expect![[r#\"\n-            inner attrs: Attrs { entries: None }\n-\n-            top-level items:\n-            Impl { generic_params: GenericParamsId(4294967295), target_trait: None, target_type: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"S\"))] }, generic_args: [None] }), is_negative: false, items: [MacroCall(Idx::<MacroCall>(0))], ast_id: FileAstId::<syntax::ast::generated::nodes::Impl>(0) }\n-            > MacroCall { name: None, path: ModPath { kind: Plain, segments: [Name(Text(\"items\"))] }, is_export: false, is_local_inner: false, is_builtin: false, ast_id: FileAstId::<syntax::ast::generated::nodes::MacroCall>(1) }\n-        \"#]],\n-    );\n-}"}]}