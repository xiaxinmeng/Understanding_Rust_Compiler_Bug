{"sha": "be896288a366cbd165e0eac9c08fef4a019ee99d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlODk2Mjg4YTM2NmNiZDE2NWUwZWFjOWMwOGZlZjRhMDE5ZWU5OWQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-05T05:08:25Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-10T09:37:10Z"}, "message": "Migrate uv file bindings away from ~fn()", "tree": {"sha": "0f0c0a53e08a72a3147a3a4084a292b64562c2c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f0c0a53e08a72a3147a3a4084a292b64562c2c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be896288a366cbd165e0eac9c08fef4a019ee99d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be896288a366cbd165e0eac9c08fef4a019ee99d", "html_url": "https://github.com/rust-lang/rust/commit/be896288a366cbd165e0eac9c08fef4a019ee99d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be896288a366cbd165e0eac9c08fef4a019ee99d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1b5c4db8fdaec025f3ace3c69f046426d69d5db", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1b5c4db8fdaec025f3ace3c69f046426d69d5db", "html_url": "https://github.com/rust-lang/rust/commit/c1b5c4db8fdaec025f3ace3c69f046426d69d5db"}], "stats": {"total": 1080, "additions": 405, "deletions": 675}, "files": [{"sha": "1994c0a5419981b0d44cb243ac334f6f0218d3e6", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 359, "deletions": 328, "changes": 687, "blob_url": "https://github.com/rust-lang/rust/blob/be896288a366cbd165e0eac9c08fef4a019ee99d/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be896288a366cbd165e0eac9c08fef4a019ee99d/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=be896288a366cbd165e0eac9c08fef4a019ee99d", "patch": "@@ -8,406 +8,437 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::ptr::null;\n-use std::c_str;\n use std::c_str::CString;\n+use std::c_str;\n use std::cast::transmute;\n-use std::libc;\n+use std::cast;\n use std::libc::{c_int, c_char, c_void, c_uint};\n-\n-use super::{Request, NativeHandle, Loop, FsCallback, Buf,\n-            status_to_maybe_uv_error, UvError};\n+use std::libc;\n+use std::rt::BlockedTask;\n+use std::rt::io;\n+use std::rt::io::{FileStat, IoError};\n+use std::rt::rtio;\n+use std::rt::local::Local;\n+use std::rt::sched::{Scheduler, SchedHandle};\n+use std::vec;\n+\n+use super::{NativeHandle, Loop, UvError, uv_error_to_io_error};\n+use uvio::HomingIO;\n use uvll;\n-use uvll::*;\n \n-pub struct FsRequest(*uvll::uv_fs_t);\n-impl Request for FsRequest {}\n+pub struct FsRequest {\n+    req: *uvll::uv_fs_t,\n+    priv fired: bool,\n+}\n \n-pub struct RequestData {\n-    priv complete_cb: Option<FsCallback>\n+pub struct FileWatcher {\n+    priv loop_: Loop,\n+    priv fd: c_int,\n+    priv close: rtio::CloseBehavior,\n+    priv home: SchedHandle,\n }\n \n impl FsRequest {\n-    pub fn new() -> FsRequest {\n-        let fs_req = unsafe { malloc_req(UV_FS) };\n-        assert!(fs_req.is_not_null());\n-        let fs_req: FsRequest = NativeHandle::from_native_handle(fs_req);\n-        fs_req\n-    }\n-\n-    pub fn open(self, loop_: &Loop, path: &CString, flags: int, mode: int,\n-                cb: FsCallback) {\n-        let complete_cb_ptr = {\n-            let mut me = self;\n-            me.req_boilerplate(Some(cb))\n-        };\n-        let ret = path.with_ref(|p| unsafe {\n+    pub fn open(loop_: &Loop, path: &CString, flags: int, mode: int)\n+        -> Result<FileWatcher, UvError>\n+    {\n+        execute(|req, cb| unsafe {\n             uvll::uv_fs_open(loop_.native_handle(),\n-                             self.native_handle(), p, flags as c_int,\n-                             mode as c_int, complete_cb_ptr)\n-        });\n-        assert_eq!(ret, 0);\n+                             req, path.with_ref(|p| p), flags as c_int,\n+                             mode as c_int, cb)\n+        }).map(|req|\n+            FileWatcher::new(*loop_, req.get_result() as c_int,\n+                             rtio::CloseSynchronously)\n+        )\n+    }\n+\n+    pub fn unlink(loop_: &Loop, path: &CString) -> Result<(), UvError> {\n+        execute_nop(|req, cb| unsafe {\n+            uvll::uv_fs_unlink(loop_.native_handle(), req, path.with_ref(|p| p),\n+                               cb)\n+        })\n+    }\n+\n+    pub fn lstat(loop_: &Loop, path: &CString) -> Result<FileStat, UvError> {\n+        execute(|req, cb| unsafe {\n+            uvll::uv_fs_lstat(loop_.native_handle(), req, path.with_ref(|p| p),\n+                              cb)\n+        }).map(|req| req.mkstat())\n+    }\n+\n+    pub fn stat(loop_: &Loop, path: &CString) -> Result<FileStat, UvError> {\n+        execute(|req, cb| unsafe {\n+            uvll::uv_fs_stat(loop_.native_handle(), req, path.with_ref(|p| p),\n+                             cb)\n+        }).map(|req| req.mkstat())\n+    }\n+\n+    pub fn write(loop_: &Loop, fd: c_int, buf: &[u8], offset: i64)\n+        -> Result<(), UvError>\n+    {\n+        execute_nop(|req, cb| unsafe {\n+            uvll::uv_fs_write(loop_.native_handle(), req,\n+                              fd, vec::raw::to_ptr(buf) as *c_void,\n+                              buf.len() as c_uint, offset, cb)\n+        })\n+    }\n+\n+    pub fn read(loop_: &Loop, fd: c_int, buf: &mut [u8], offset: i64)\n+        -> Result<int, UvError>\n+    {\n+        do execute(|req, cb| unsafe {\n+            uvll::uv_fs_read(loop_.native_handle(), req,\n+                             fd, vec::raw::to_ptr(buf) as *c_void,\n+                             buf.len() as c_uint, offset, cb)\n+        }).map |req| {\n+            req.get_result() as int\n+        }\n     }\n \n-    pub fn open_sync(mut self, loop_: &Loop, path: &CString,\n-                     flags: int, mode: int) -> Result<c_int, UvError> {\n-        let complete_cb_ptr = self.req_boilerplate(None);\n-        let result = path.with_ref(|p| unsafe {\n-            uvll::uv_fs_open(loop_.native_handle(),\n-                             self.native_handle(), p, flags as c_int,\n-                             mode as c_int, complete_cb_ptr)\n-        });\n-        self.sync_cleanup(result)\n-    }\n-\n-    pub fn unlink(mut self, loop_: &Loop, path: &CString, cb: FsCallback) {\n-        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n-        let ret = path.with_ref(|p| unsafe {\n-            uvll::uv_fs_unlink(loop_.native_handle(),\n-                               self.native_handle(), p, complete_cb_ptr)\n-        });\n-        assert_eq!(ret, 0);\n-    }\n-\n-    pub fn unlink_sync(mut self, loop_: &Loop, path: &CString)\n-      -> Result<c_int, UvError> {\n-        let complete_cb_ptr = self.req_boilerplate(None);\n-        let result = path.with_ref(|p| unsafe {\n-            uvll::uv_fs_unlink(loop_.native_handle(),\n-                               self.native_handle(), p, complete_cb_ptr)\n-        });\n-        self.sync_cleanup(result)\n-    }\n-\n-    pub fn lstat(mut self, loop_: &Loop, path: &CString, cb: FsCallback) {\n-        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n-        let ret = path.with_ref(|p| unsafe {\n-            uvll::uv_fs_lstat(loop_.native_handle(),\n-                              self.native_handle(), p, complete_cb_ptr)\n-        });\n-        assert_eq!(ret, 0);\n-    }\n-\n-    pub fn stat(mut self, loop_: &Loop, path: &CString, cb: FsCallback) {\n-        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n-        let ret = path.with_ref(|p| unsafe {\n-            uvll::uv_fs_stat(loop_.native_handle(),\n-                             self.native_handle(), p, complete_cb_ptr)\n-        });\n-        assert_eq!(ret, 0);\n-    }\n-\n-    pub fn write(mut self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64,\n-                 cb: FsCallback) {\n-        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n-        let base_ptr = buf.base as *c_void;\n-        let len = buf.len as uint;\n-        let ret = unsafe {\n-            uvll::uv_fs_write(loop_.native_handle(), self.native_handle(),\n-                              fd, base_ptr,\n-                              len as c_uint, offset, complete_cb_ptr)\n-        };\n-        assert_eq!(ret, 0);\n-    }\n-    pub fn write_sync(mut self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64)\n-          -> Result<c_int, UvError> {\n-        let complete_cb_ptr = self.req_boilerplate(None);\n-        let base_ptr = buf.base as *c_void;\n-        let len = buf.len as uint;\n-        let result = unsafe {\n-            uvll::uv_fs_write(loop_.native_handle(), self.native_handle(),\n-                              fd, base_ptr,\n-                              len as c_uint, offset, complete_cb_ptr)\n-        };\n-        self.sync_cleanup(result)\n-    }\n-\n-    pub fn read(mut self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64,\n-                cb: FsCallback) {\n-        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n-        let buf_ptr = buf.base as *c_void;\n-        let len = buf.len as uint;\n-        let ret = unsafe {\n-            uvll::uv_fs_read(loop_.native_handle(), self.native_handle(),\n-                             fd, buf_ptr,\n-                             len as c_uint, offset, complete_cb_ptr)\n-        };\n-        assert_eq!(ret, 0);\n-    }\n-    pub fn read_sync(mut self, loop_: &Loop, fd: c_int, buf: Buf, offset: i64)\n-          -> Result<c_int, UvError> {\n-        let complete_cb_ptr = self.req_boilerplate(None);\n-        let buf_ptr = buf.base as *c_void;\n-        let len = buf.len as uint;\n-        let result = unsafe {\n-            uvll::uv_fs_read(loop_.native_handle(), self.native_handle(),\n-                             fd, buf_ptr,\n-                             len as c_uint, offset, complete_cb_ptr)\n-        };\n-        self.sync_cleanup(result)\n-    }\n-\n-    pub fn close(mut self, loop_: &Loop, fd: c_int, cb: FsCallback) {\n-        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n-        assert_eq!(unsafe {\n-            uvll::uv_fs_close(loop_.native_handle(), self.native_handle(),\n-                              fd, complete_cb_ptr)\n-        }, 0);\n-    }\n-    pub fn close_sync(mut self, loop_: &Loop,\n-                      fd: c_int) -> Result<c_int, UvError> {\n-        let complete_cb_ptr = self.req_boilerplate(None);\n-        let result = unsafe {\n-            uvll::uv_fs_close(loop_.native_handle(), self.native_handle(),\n-                              fd, complete_cb_ptr)\n-        };\n-        self.sync_cleanup(result)\n+    pub fn close(loop_: &Loop, fd: c_int, sync: bool) -> Result<(), UvError> {\n+        if sync {\n+            execute_nop(|req, cb| unsafe {\n+                uvll::uv_fs_close(loop_.native_handle(), req, fd, cb)\n+            })\n+        } else {\n+            unsafe {\n+                let req = uvll::malloc_req(uvll::UV_FS);\n+                uvll::uv_fs_close(loop_.native_handle(), req, fd, close_cb);\n+                return Ok(());\n+            }\n+\n+            extern fn close_cb(req: *uvll::uv_fs_t) {\n+                unsafe {\n+                    uvll::uv_fs_req_cleanup(req);\n+                    uvll::free_req(req);\n+                }\n+            }\n+        }\n     }\n \n-    pub fn mkdir(mut self, loop_: &Loop, path: &CString, mode: c_int,\n-                 cb: FsCallback) {\n-        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n-        assert_eq!(path.with_ref(|p| unsafe {\n-            uvll::uv_fs_mkdir(loop_.native_handle(),\n-                              self.native_handle(), p, mode, complete_cb_ptr)\n-        }), 0);\n+    pub fn mkdir(loop_: &Loop, path: &CString, mode: c_int)\n+        -> Result<(), UvError>\n+    {\n+        execute_nop(|req, cb| unsafe {\n+            uvll::uv_fs_mkdir(loop_.native_handle(), req, path.with_ref(|p| p),\n+                              mode, cb)\n+        })\n     }\n \n-    pub fn rmdir(mut self, loop_: &Loop, path: &CString, cb: FsCallback) {\n-        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n-        assert_eq!(path.with_ref(|p| unsafe {\n-            uvll::uv_fs_rmdir(loop_.native_handle(),\n-                              self.native_handle(), p, complete_cb_ptr)\n-        }), 0);\n+    pub fn rmdir(loop_: &Loop, path: &CString) -> Result<(), UvError> {\n+        execute_nop(|req, cb| unsafe {\n+            uvll::uv_fs_rmdir(loop_.native_handle(), req, path.with_ref(|p| p),\n+                              cb)\n+        })\n     }\n \n-    pub fn rename(mut self, loop_: &Loop, path: &CString, to: &CString,\n-                  cb: FsCallback) {\n-        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n-        assert_eq!(unsafe {\n+    pub fn rename(loop_: &Loop, path: &CString, to: &CString)\n+        -> Result<(), UvError>\n+    {\n+        execute_nop(|req, cb| unsafe {\n             uvll::uv_fs_rename(loop_.native_handle(),\n-                               self.native_handle(),\n+                               req,\n                                path.with_ref(|p| p),\n                                to.with_ref(|p| p),\n-                               complete_cb_ptr)\n-        }, 0);\n+                               cb)\n+        })\n     }\n \n-    pub fn chmod(mut self, loop_: &Loop, path: &CString, mode: c_int,\n-                 cb: FsCallback) {\n-        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n-        assert_eq!(path.with_ref(|p| unsafe {\n-            uvll::uv_fs_chmod(loop_.native_handle(), self.native_handle(), p,\n-                              mode, complete_cb_ptr)\n-        }), 0);\n+    pub fn chmod(loop_: &Loop, path: &CString, mode: c_int)\n+        -> Result<(), UvError>\n+    {\n+        execute_nop(|req, cb| unsafe {\n+            uvll::uv_fs_chmod(loop_.native_handle(), req, path.with_ref(|p| p),\n+                              mode, cb)\n+        })\n     }\n \n-    pub fn readdir(mut self, loop_: &Loop, path: &CString,\n-                   flags: c_int, cb: FsCallback) {\n-        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n-        assert_eq!(path.with_ref(|p| unsafe {\n+    pub fn readdir(loop_: &Loop, path: &CString, flags: c_int)\n+        -> Result<~[Path], UvError>\n+    {\n+        execute(|req, cb| unsafe {\n             uvll::uv_fs_readdir(loop_.native_handle(),\n-                                self.native_handle(), p, flags, complete_cb_ptr)\n-        }), 0);\n-    }\n-\n-    pub fn readlink(mut self, loop_: &Loop, path: &CString, cb: FsCallback) {\n-        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n-        assert_eq!(path.with_ref(|p| unsafe {\n-            uvll::uv_fs_readlink(loop_.native_handle(),\n-                                 self.native_handle(), p, complete_cb_ptr)\n-        }), 0);\n+                                req, path.with_ref(|p| p), flags, cb)\n+        }).map(|req| unsafe {\n+            let mut paths = ~[];\n+            let path = CString::new(path.with_ref(|p| p), false);\n+            let parent = Path::new(path);\n+            do c_str::from_c_multistring(req.get_ptr() as *libc::c_char,\n+                                         Some(req.get_result() as uint)) |rel| {\n+                let p = rel.as_bytes();\n+                paths.push(parent.join(p.slice_to(rel.len())));\n+            };\n+            paths\n+        })\n+    }\n+\n+    pub fn readlink(loop_: &Loop, path: &CString) -> Result<Path, UvError> {\n+        do execute(|req, cb| unsafe {\n+            uvll::uv_fs_readlink(loop_.native_handle(), req,\n+                                 path.with_ref(|p| p), cb)\n+        }).map |req| {\n+            Path::new(unsafe {\n+                CString::new(req.get_ptr() as *libc::c_char, false)\n+            })\n+        }\n     }\n \n-    pub fn chown(mut self, loop_: &Loop, path: &CString, uid: int, gid: int,\n-                 cb: FsCallback) {\n-        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n-        assert_eq!(path.with_ref(|p| unsafe {\n+    pub fn chown(loop_: &Loop, path: &CString, uid: int, gid: int)\n+        -> Result<(), UvError>\n+    {\n+        execute_nop(|req, cb| unsafe {\n             uvll::uv_fs_chown(loop_.native_handle(),\n-                              self.native_handle(), p,\n+                              req, path.with_ref(|p| p),\n                               uid as uvll::uv_uid_t,\n                               gid as uvll::uv_gid_t,\n-                              complete_cb_ptr)\n-        }), 0);\n+                              cb)\n+        })\n     }\n \n-    pub fn truncate(mut self, loop_: &Loop, file: c_int, offset: i64,\n-                    cb: FsCallback) {\n-        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n-        assert_eq!(unsafe {\n-            uvll::uv_fs_ftruncate(loop_.native_handle(),\n-                                  self.native_handle(), file, offset,\n-                                  complete_cb_ptr)\n-        }, 0);\n+    pub fn truncate(loop_: &Loop, file: c_int, offset: i64)\n+        -> Result<(), UvError>\n+    {\n+        execute_nop(|req, cb| unsafe {\n+            uvll::uv_fs_ftruncate(loop_.native_handle(), req, file, offset, cb)\n+        })\n     }\n \n-    pub fn link(mut self, loop_: &Loop, src: &CString, dst: &CString,\n-                cb: FsCallback) {\n-        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n-        assert_eq!(unsafe {\n-            uvll::uv_fs_link(loop_.native_handle(), self.native_handle(),\n+    pub fn link(loop_: &Loop, src: &CString, dst: &CString)\n+        -> Result<(), UvError>\n+    {\n+        execute_nop(|req, cb| unsafe {\n+            uvll::uv_fs_link(loop_.native_handle(), req,\n                              src.with_ref(|p| p),\n                              dst.with_ref(|p| p),\n-                             complete_cb_ptr)\n-        }, 0);\n+                             cb)\n+        })\n     }\n \n-    pub fn symlink(mut self, loop_: &Loop, src: &CString, dst: &CString,\n-                   cb: FsCallback) {\n-        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n-        assert_eq!(unsafe {\n-            uvll::uv_fs_symlink(loop_.native_handle(), self.native_handle(),\n+    pub fn symlink(loop_: &Loop, src: &CString, dst: &CString)\n+        -> Result<(), UvError>\n+    {\n+        execute_nop(|req, cb| unsafe {\n+            uvll::uv_fs_symlink(loop_.native_handle(), req,\n                                 src.with_ref(|p| p),\n                                 dst.with_ref(|p| p),\n-                                0,\n-                                complete_cb_ptr)\n-        }, 0);\n-    }\n-\n-    pub fn fsync(mut self, loop_: &Loop, fd: c_int, cb: FsCallback) {\n-        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n-        assert_eq!(unsafe {\n-            uvll::uv_fs_fsync(loop_.native_handle(), self.native_handle(), fd,\n-                              complete_cb_ptr)\n-        }, 0);\n-    }\n-\n-    pub fn datasync(mut self, loop_: &Loop, fd: c_int, cb: FsCallback) {\n-        let complete_cb_ptr = self.req_boilerplate(Some(cb));\n-        assert_eq!(unsafe {\n-            uvll::uv_fs_fdatasync(loop_.native_handle(), self.native_handle(), fd,\n-                                  complete_cb_ptr)\n-        }, 0);\n-    }\n-\n-    // accessors/utility funcs\n-    fn sync_cleanup(self, result: c_int)\n-          -> Result<c_int, UvError> {\n-        self.cleanup_and_delete();\n-        match status_to_maybe_uv_error(result as i32) {\n-            Some(err) => Err(err),\n-            None => Ok(result)\n-        }\n-    }\n-    fn req_boilerplate(&mut self, cb: Option<FsCallback>) -> uvll::uv_fs_cb {\n-        let result = match cb {\n-            Some(_) => compl_cb,\n-            None => 0 as uvll::uv_fs_cb\n-        };\n-        self.install_req_data(cb);\n-        result\n-    }\n-    pub fn install_req_data(&mut self, cb: Option<FsCallback>) {\n-        let fs_req = (self.native_handle()) as *uvll::uv_write_t;\n-        let data = ~RequestData {\n-            complete_cb: cb\n-        };\n-        unsafe {\n-            let data = transmute::<~RequestData, *c_void>(data);\n-            uvll::set_data_for_req(fs_req, data);\n-        }\n+                                0, cb)\n+        })\n     }\n \n-    fn get_req_data<'r>(&'r mut self) -> &'r mut RequestData {\n-        unsafe {\n-            let data = uvll::get_data_for_req((self.native_handle()));\n-            let data = transmute::<&*c_void, &mut ~RequestData>(&data);\n-            &mut **data\n-        }\n+    pub fn fsync(loop_: &Loop, fd: c_int) -> Result<(), UvError> {\n+        execute_nop(|req, cb| unsafe {\n+            uvll::uv_fs_fsync(loop_.native_handle(), req, fd, cb)\n+        })\n     }\n \n-    pub fn get_path(&self) -> *c_char {\n-        unsafe { uvll::get_path_from_fs_req(self.native_handle()) }\n+    pub fn datasync(loop_: &Loop, fd: c_int) -> Result<(), UvError> {\n+        execute_nop(|req, cb| unsafe {\n+            uvll::uv_fs_fdatasync(loop_.native_handle(), req, fd, cb)\n+        })\n     }\n \n     pub fn get_result(&self) -> c_int {\n-        unsafe { uvll::get_result_from_fs_req(self.native_handle()) }\n-    }\n-\n-    pub fn get_loop(&self) -> Loop {\n-        unsafe { Loop{handle:uvll::get_loop_from_fs_req(self.native_handle())} }\n+        unsafe { uvll::get_result_from_fs_req(self.req) }\n     }\n \n-    pub fn get_stat(&self) -> uv_stat_t {\n-        let stat = uv_stat_t::new();\n-        unsafe { uvll::populate_stat(self.native_handle(), &stat); }\n+    pub fn get_stat(&self) -> uvll::uv_stat_t {\n+        let stat = uvll::uv_stat_t::new();\n+        unsafe { uvll::populate_stat(self.req, &stat); }\n         stat\n     }\n \n     pub fn get_ptr(&self) -> *libc::c_void {\n-        unsafe {\n-            uvll::get_ptr_from_fs_req(self.native_handle())\n-        }\n+        unsafe { uvll::get_ptr_from_fs_req(self.req) }\n     }\n \n-    pub fn each_path(&mut self, f: &fn(&CString)) {\n-        let ptr = self.get_ptr();\n-        match self.get_result() {\n-            n if (n <= 0) => {}\n-            n => {\n-                let n_len = n as uint;\n-                // we pass in the len that uv tells us is there\n-                // for the entries and we don't continue past that..\n-                // it appears that sometimes the multistring isn't\n-                // correctly delimited and we stray into garbage memory?\n-                // in any case, passing Some(n_len) fixes it and ensures\n-                // good results\n-                unsafe {\n-                    c_str::from_c_multistring(ptr as *libc::c_char,\n-                                              Some(n_len), f);\n-                }\n+    pub fn mkstat(&self) -> FileStat {\n+        let path = unsafe { uvll::get_path_from_fs_req(self.req) };\n+        let path = unsafe { Path::new(CString::new(path, false)) };\n+        let stat = self.get_stat();\n+        fn to_msec(stat: uvll::uv_timespec_t) -> u64 {\n+            (stat.tv_sec * 1000 + stat.tv_nsec / 1000000) as u64\n+        }\n+        let kind = match (stat.st_mode as c_int) & libc::S_IFMT {\n+            libc::S_IFREG => io::TypeFile,\n+            libc::S_IFDIR => io::TypeDirectory,\n+            libc::S_IFIFO => io::TypeNamedPipe,\n+            libc::S_IFBLK => io::TypeBlockSpecial,\n+            libc::S_IFLNK => io::TypeSymlink,\n+            _ => io::TypeUnknown,\n+        };\n+        FileStat {\n+            path: path,\n+            size: stat.st_size as u64,\n+            kind: kind,\n+            perm: (stat.st_mode as io::FilePermission) & io::AllPermissions,\n+            created: to_msec(stat.st_birthtim),\n+            modified: to_msec(stat.st_mtim),\n+            accessed: to_msec(stat.st_atim),\n+            unstable: io::UnstableFileStat {\n+                device: stat.st_dev as u64,\n+                inode: stat.st_ino as u64,\n+                rdev: stat.st_rdev as u64,\n+                nlink: stat.st_nlink as u64,\n+                uid: stat.st_uid as u64,\n+                gid: stat.st_gid as u64,\n+                blksize: stat.st_blksize as u64,\n+                blocks: stat.st_blocks as u64,\n+                flags: stat.st_flags as u64,\n+                gen: stat.st_gen as u64,\n             }\n         }\n     }\n+}\n \n-    fn cleanup_and_delete(self) {\n+impl Drop for FsRequest {\n+    fn drop(&mut self) {\n         unsafe {\n-            let data = uvll::get_data_for_req(self.native_handle());\n-            let _data = transmute::<*c_void, ~RequestData>(data);\n-            uvll::set_data_for_req(self.native_handle(), null::<()>());\n-            uvll::uv_fs_req_cleanup(self.native_handle());\n-            free_req(self.native_handle() as *c_void)\n+            if self.fired {\n+                uvll::uv_fs_req_cleanup(self.req);\n+            }\n+            uvll::free_req(self.req);\n+        }\n+    }\n+}\n+\n+fn execute(f: &fn(*uvll::uv_fs_t, uvll::uv_fs_cb) -> c_int)\n+    -> Result<FsRequest, UvError>\n+{\n+    let mut req = FsRequest {\n+        fired: false,\n+        req: unsafe { uvll::malloc_req(uvll::UV_FS) }\n+    };\n+    return match f(req.req, fs_cb) {\n+        0 => {\n+            req.fired = true;\n+            let mut slot = None;\n+            unsafe { uvll::set_data_for_req(req.req, &slot) }\n+            let sched: ~Scheduler = Local::take();\n+            do sched.deschedule_running_task_and_then |_, task| {\n+                slot = Some(task);\n+            }\n+            match req.get_result() {\n+                n if n < 0 => Err(UvError(n)),\n+                _ => Ok(req),\n+            }\n         }\n+        n => Err(UvError(n))\n+\n+    };\n+\n+    extern fn fs_cb(req: *uvll::uv_fs_t) {\n+        let slot: &mut Option<BlockedTask> = unsafe {\n+            cast::transmute(uvll::get_data_for_req(req))\n+        };\n+        let sched: ~Scheduler = Local::take();\n+        sched.resume_blocked_task_immediately(slot.take_unwrap());\n     }\n }\n \n-impl NativeHandle<*uvll::uv_fs_t> for FsRequest {\n-    fn from_native_handle(handle: *uvll:: uv_fs_t) -> FsRequest {\n-        FsRequest(handle)\n+fn execute_nop(f: &fn(*uvll::uv_fs_t, uvll::uv_fs_cb) -> c_int)\n+    -> Result<(), UvError>\n+{\n+    execute(f).map(|_| {})\n+}\n+\n+impl HomingIO for FileWatcher {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n+\n+impl FileWatcher {\n+    pub fn new(loop_: Loop, fd: c_int, close: rtio::CloseBehavior) -> FileWatcher {\n+        FileWatcher {\n+            loop_: loop_,\n+            fd: fd,\n+            close: close,\n+            home: get_handle_to_current_scheduler!()\n+        }\n     }\n-    fn native_handle(&self) -> *uvll::uv_fs_t {\n-        match self { &FsRequest(ptr) => ptr }\n+\n+    fn base_read(&mut self, buf: &mut [u8], offset: i64) -> Result<int, IoError> {\n+        let _m = self.fire_missiles();\n+        let r = FsRequest::read(&self.loop_, self.fd, buf, offset);\n+        r.map_err(uv_error_to_io_error)\n+    }\n+    fn base_write(&mut self, buf: &[u8], offset: i64) -> Result<(), IoError> {\n+        let _m = self.fire_missiles();\n+        let r = FsRequest::write(&self.loop_, self.fd, buf, offset);\n+        r.map_err(uv_error_to_io_error)\n+    }\n+    fn seek_common(&mut self, pos: i64, whence: c_int) ->\n+        Result<u64, IoError>{\n+        #[fixed_stack_segment]; #[inline(never)];\n+        unsafe {\n+            match libc::lseek(self.fd, pos as libc::off_t, whence) {\n+                -1 => {\n+                    Err(IoError {\n+                        kind: io::OtherIoError,\n+                        desc: \"Failed to lseek.\",\n+                        detail: None\n+                    })\n+                },\n+                n => Ok(n as u64)\n+            }\n+        }\n     }\n }\n \n-fn sync_cleanup(result: int)\n-    -> Result<int, UvError> {\n-    match status_to_maybe_uv_error(result as i32) {\n-        Some(err) => Err(err),\n-        None => Ok(result)\n+impl Drop for FileWatcher {\n+    fn drop(&mut self) {\n+        let _m = self.fire_missiles();\n+        match self.close {\n+            rtio::DontClose => {}\n+            rtio::CloseAsynchronously => {\n+                FsRequest::close(&self.loop_, self.fd, false);\n+            }\n+            rtio::CloseSynchronously => {\n+                FsRequest::close(&self.loop_, self.fd, true);\n+            }\n+        }\n     }\n }\n \n-extern fn compl_cb(req: *uv_fs_t) {\n-    let mut req: FsRequest = NativeHandle::from_native_handle(req);\n-    // pull the user cb out of the req data\n-    let cb = {\n-        let data = req.get_req_data();\n-        assert!(data.complete_cb.is_some());\n-        // option dance, option dance. oooooh yeah.\n-        data.complete_cb.take_unwrap()\n-    };\n-    // in uv_fs_open calls, the result will be the fd in the\n-    // case of success, otherwise it's -1 indicating an error\n-    let result = req.get_result();\n-    let status = status_to_maybe_uv_error(result);\n-    // we have a req and status, call the user cb..\n-    // only giving the user a ref to the FsRequest, as we\n-    // have to clean it up, afterwards (and they aren't really\n-    // reusable, anyways\n-    cb(&mut req, status);\n-    // clean up the req (and its data!) after calling the user cb\n-    req.cleanup_and_delete();\n+impl rtio::RtioFileStream for FileWatcher {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n+        self.base_read(buf, -1)\n+    }\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        self.base_write(buf, -1)\n+    }\n+    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n+        self.base_read(buf, offset as i64)\n+    }\n+    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n+        self.base_write(buf, offset as i64)\n+    }\n+    fn seek(&mut self, pos: i64, whence: io::SeekStyle) -> Result<u64, IoError> {\n+        use std::libc::{SEEK_SET, SEEK_CUR, SEEK_END};\n+        let whence = match whence {\n+            io::SeekSet => SEEK_SET,\n+            io::SeekCur => SEEK_CUR,\n+            io::SeekEnd => SEEK_END\n+        };\n+        self.seek_common(pos, whence)\n+    }\n+    fn tell(&self) -> Result<u64, IoError> {\n+        use std::libc::SEEK_CUR;\n+        // this is temporary\n+        let self_ = unsafe { cast::transmute_mut(self) };\n+        self_.seek_common(0, SEEK_CUR)\n+    }\n+    fn fsync(&mut self) -> Result<(), IoError> {\n+        let _m = self.fire_missiles();\n+        FsRequest::fsync(&self.loop_, self.fd).map_err(uv_error_to_io_error)\n+    }\n+    fn datasync(&mut self) -> Result<(), IoError> {\n+        let _m = self.fire_missiles();\n+        FsRequest::datasync(&self.loop_, self.fd).map_err(uv_error_to_io_error)\n+    }\n+    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n+        let _m = self.fire_missiles();\n+        let r = FsRequest::truncate(&self.loop_, self.fd, offset);\n+        r.map_err(uv_error_to_io_error)\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "eb2da05506d82589d65c7f72399cb95c956d5ebf", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be896288a366cbd165e0eac9c08fef4a019ee99d/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be896288a366cbd165e0eac9c08fef4a019ee99d/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=be896288a366cbd165e0eac9c08fef4a019ee99d", "patch": "@@ -60,7 +60,7 @@ use std::rt::io::IoError;\n \n //#[cfg(test)] use unstable::run_in_bare_thread;\n \n-pub use self::file::{FsRequest};\n+pub use self::file::{FsRequest, FileWatcher};\n pub use self::net::{StreamWatcher, TcpWatcher, UdpWatcher};\n pub use self::idle::IdleWatcher;\n pub use self::timer::TimerWatcher;\n@@ -219,7 +219,6 @@ pub type AllocCallback = ~fn(uint) -> Buf;\n pub type ReadCallback = ~fn(StreamWatcher, int, Buf, Option<UvError>);\n pub type NullCallback = ~fn();\n pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n-pub type FsCallback = ~fn(&mut FsRequest, Option<UvError>);\n pub type UdpReceiveCallback = ~fn(UdpWatcher, int, Buf, SocketAddr, uint, Option<UvError>);\n pub type UdpSendCallback = ~fn(UdpWatcher, Option<UvError>);\n \n@@ -263,7 +262,6 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n                 connect_cb: None,\n                 close_cb: None,\n                 alloc_cb: None,\n-                async_cb: None,\n                 udp_recv_cb: None,\n                 udp_send_cb: None,\n             };"}, {"sha": "a857308a81b35a18baf89163c4456d25b65af974", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be896288a366cbd165e0eac9c08fef4a019ee99d/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be896288a366cbd165e0eac9c08fef4a019ee99d/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=be896288a366cbd165e0eac9c08fef4a019ee99d", "patch": "@@ -158,7 +158,7 @@ impl PipeListener {\n                 Ok(p.install())\n             }\n             n => {\n-                unsafe { uvll::free_handle(pipe) }\n+                unsafe { uvll::uv_close(pipe, pipe_close_cb) }\n                 Err(UvError(n))\n             }\n         }"}, {"sha": "1732e84be4e7079123d2771047a02de585ee887f", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/be896288a366cbd165e0eac9c08fef4a019ee99d/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be896288a366cbd165e0eac9c08fef4a019ee99d/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=be896288a366cbd165e0eac9c08fef4a019ee99d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::cell::Cell;\n-use std::comm::{oneshot, stream, PortOne, ChanOne};\n+use std::comm::{oneshot, stream, PortOne, ChanOne, SendDeferred};\n use std::libc::c_int;\n use std::rt::BlockedTask;\n use std::rt::local::Local;\n@@ -106,9 +106,9 @@ extern fn timer_cb(handle: *uvll::uv_timer_t, _status: c_int) {\n             let sched: ~Scheduler = Local::take();\n             sched.resume_blocked_task_immediately(task);\n         }\n-        SendOnce(chan) => chan.send(()),\n+        SendOnce(chan) => chan.send_deferred(()),\n         SendMany(chan) => {\n-            chan.send(());\n+            chan.send_deferred(());\n             timer.action = Some(SendMany(chan));\n         }\n     }"}, {"sha": "e06f8b5430ecab03bf91a96a942e27e86914c124", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 41, "deletions": 340, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/be896288a366cbd165e0eac9c08fef4a019ee99d/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be896288a366cbd165e0eac9c08fef4a019ee99d/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=be896288a366cbd165e0eac9c08fef4a019ee99d", "patch": "@@ -21,20 +21,18 @@ use std::str;\n use std::rt::io;\n use std::rt::io::IoError;\n use std::rt::io::net::ip::{SocketAddr, IpAddr};\n-use std::rt::io::{standard_error, OtherIoError, SeekStyle, SeekSet, SeekCur,\n-                  SeekEnd};\n+use std::rt::io::{standard_error, OtherIoError};\n use std::rt::io::process::ProcessConfig;\n use std::rt::local::Local;\n use std::rt::rtio::*;\n use std::rt::sched::{Scheduler, SchedHandle};\n use std::rt::tube::Tube;\n use std::rt::task::Task;\n-use std::path::{GenericPath, Path};\n-use std::libc::{lseek, off_t, O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY,\n-                O_WRONLY, S_IRUSR, S_IWUSR};\n-use std::rt::io::{FileMode, FileAccess, Open,\n-                  Append, Truncate, Read, Write, ReadWrite,\n-                  FileStat};\n+use std::path::Path;\n+use std::libc::{O_CREAT, O_APPEND, O_TRUNC, O_RDWR, O_RDONLY, O_WRONLY,\n+                S_IRUSR, S_IWUSR};\n+use std::rt::io::{FileMode, FileAccess, Open, Append, Truncate, Read, Write,\n+                  ReadWrite, FileStat};\n use std::rt::io::signal::Signum;\n use std::task;\n use ai = std::rt::io::net::addrinfo;\n@@ -249,76 +247,6 @@ impl UvIoFactory {\n     }\n }\n \n-/// Helper for a variety of simple uv_fs_* functions that have no ret val. This\n-/// function takes the loop that it will act on, and then invokes the specified\n-/// callback in a situation where the task wil be immediately blocked\n-/// afterwards. The `FsCallback` yielded must be invoked to reschedule the task\n-/// (once the result of the operation is known).\n-fn uv_fs_helper<T:Send>(loop_: &mut Loop,\n-                        retfn: extern \"Rust\" fn(&mut FsRequest) -> T,\n-                        cb: &fn(&mut FsRequest, &mut Loop, FsCallback))\n-                        -> Result<T, IoError> {\n-    let result_cell = Cell::new_empty();\n-    let result_cell_ptr: *Cell<Result<T, IoError>> = &result_cell;\n-    do task::unkillable { // FIXME(#8674)\n-        let scheduler: ~Scheduler = Local::take();\n-        let mut new_req = FsRequest::new();\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            do cb(&mut new_req, loop_) |req, err| {\n-                let res = match err {\n-                    None => Ok(retfn(req)),\n-                    Some(err) => Err(uv_error_to_io_error(err))\n-                };\n-                unsafe { (*result_cell_ptr).put_back(res); }\n-                let scheduler: ~Scheduler = Local::take();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n-            };\n-        }\n-    }\n-    assert!(!result_cell.is_empty());\n-    return result_cell.take();\n-}\n-\n-fn unit(_: &mut FsRequest) {}\n-\n-fn fs_mkstat(f: &mut FsRequest) -> FileStat {\n-    let path = unsafe { Path::new(CString::new(f.get_path(), false)) };\n-    let stat = f.get_stat();\n-    fn to_msec(stat: uvll::uv_timespec_t) -> u64 {\n-        (stat.tv_sec * 1000 + stat.tv_nsec / 1000000) as u64\n-    }\n-    let kind = match (stat.st_mode as c_int) & libc::S_IFMT {\n-        libc::S_IFREG => io::TypeFile,\n-        libc::S_IFDIR => io::TypeDirectory,\n-        libc::S_IFIFO => io::TypeNamedPipe,\n-        libc::S_IFBLK => io::TypeBlockSpecial,\n-        libc::S_IFLNK => io::TypeSymlink,\n-        _ => io::TypeUnknown,\n-    };\n-    FileStat {\n-        path: path,\n-        size: stat.st_size as u64,\n-        kind: kind,\n-        perm: (stat.st_mode as io::FilePermission) & io::AllPermissions,\n-        created: to_msec(stat.st_birthtim),\n-        modified: to_msec(stat.st_mtim),\n-        accessed: to_msec(stat.st_atim),\n-        unstable: io::UnstableFileStat {\n-            device: stat.st_dev as u64,\n-            inode: stat.st_ino as u64,\n-            rdev: stat.st_rdev as u64,\n-            nlink: stat.st_nlink as u64,\n-            uid: stat.st_uid as u64,\n-            gid: stat.st_gid as u64,\n-            blksize: stat.st_blksize as u64,\n-            blocks: stat.st_blocks as u64,\n-            flags: stat.st_flags as u64,\n-            gen: stat.st_gen as u64,\n-        }\n-    }\n-}\n-\n impl IoFactory for UvIoFactory {\n     // Connect to an address and return a new stream\n     // NB: This blocks the task waiting on the connection.\n@@ -456,10 +384,10 @@ impl IoFactory for UvIoFactory {\n         return result_cell.take();\n     }\n \n-    fn fs_from_raw_fd(&mut self, fd: c_int, close: CloseBehavior) -> ~RtioFileStream {\n+    fn fs_from_raw_fd(&mut self, fd: c_int,\n+                      close: CloseBehavior) -> ~RtioFileStream {\n         let loop_ = Loop {handle: self.uv_loop().native_handle()};\n-        let home = get_handle_to_current_scheduler!();\n-        ~UvFileStream::new(loop_, fd, close, home) as ~RtioFileStream\n+        ~FileWatcher::new(loop_, fd, close) as ~RtioFileStream\n     }\n \n     fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n@@ -477,138 +405,64 @@ impl IoFactory for UvIoFactory {\n             io::ReadWrite => (flags | libc::O_RDWR | libc::O_CREAT,\n                               libc::S_IRUSR | libc::S_IWUSR),\n         };\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<~RtioFileStream,\n-                                           IoError>> = &result_cell;\n-        do task::unkillable { // FIXME(#8674)\n-            let scheduler: ~Scheduler = Local::take();\n-            let open_req = file::FsRequest::new();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                do open_req.open(self.uv_loop(), path, flags as int, mode as int)\n-                      |req,err| {\n-                    if err.is_none() {\n-                        let loop_ = Loop {handle: req.get_loop().native_handle()};\n-                        let home = get_handle_to_current_scheduler!();\n-                        let fd = req.get_result() as c_int;\n-                        let fs = ~UvFileStream::new(\n-                            loop_, fd, CloseSynchronously, home) as ~RtioFileStream;\n-                        let res = Ok(fs);\n-                        unsafe { (*result_cell_ptr).put_back(res); }\n-                        let scheduler: ~Scheduler = Local::take();\n-                        scheduler.resume_blocked_task_immediately(task_cell.take());\n-                    } else {\n-                        let res = Err(uv_error_to_io_error(err.unwrap()));\n-                        unsafe { (*result_cell_ptr).put_back(res); }\n-                        let scheduler: ~Scheduler = Local::take();\n-                        scheduler.resume_blocked_task_immediately(task_cell.take());\n-                    }\n-                };\n-            };\n-        };\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n+\n+        match FsRequest::open(self.uv_loop(), path, flags as int, mode as int) {\n+            Ok(fs) => Ok(~fs as ~RtioFileStream),\n+            Err(e) => Err(uv_error_to_io_error(e))\n+        }\n     }\n \n     fn fs_unlink(&mut self, path: &CString) -> Result<(), IoError> {\n-        do uv_fs_helper(self.uv_loop(), unit) |req, l, cb| {\n-            req.unlink(l, path, cb)\n-        }\n+        let r = FsRequest::unlink(self.uv_loop(), path);\n+        r.map_err(uv_error_to_io_error)\n     }\n     fn fs_lstat(&mut self, path: &CString) -> Result<FileStat, IoError> {\n-        do uv_fs_helper(self.uv_loop(), fs_mkstat) |req, l, cb| {\n-            req.lstat(l, path, cb)\n-        }\n+        let r = FsRequest::lstat(self.uv_loop(), path);\n+        r.map_err(uv_error_to_io_error)\n     }\n     fn fs_stat(&mut self, path: &CString) -> Result<FileStat, IoError> {\n-        do uv_fs_helper(self.uv_loop(), fs_mkstat) |req, l, cb| {\n-            req.stat(l, path, cb)\n-        }\n+        let r = FsRequest::stat(self.uv_loop(), path);\n+        r.map_err(uv_error_to_io_error)\n     }\n     fn fs_mkdir(&mut self, path: &CString,\n                 perm: io::FilePermission) -> Result<(), IoError> {\n-        do uv_fs_helper(self.uv_loop(), unit) |req, l, cb| {\n-            req.mkdir(l, path, perm as c_int, cb)\n-        }\n+        let r = FsRequest::mkdir(self.uv_loop(), path, perm as c_int);\n+        r.map_err(uv_error_to_io_error)\n     }\n     fn fs_rmdir(&mut self, path: &CString) -> Result<(), IoError> {\n-        do uv_fs_helper(self.uv_loop(), unit) |req, l, cb| {\n-            req.rmdir(l, path, cb)\n-        }\n+        let r = FsRequest::rmdir(self.uv_loop(), path);\n+        r.map_err(uv_error_to_io_error)\n     }\n     fn fs_rename(&mut self, path: &CString, to: &CString) -> Result<(), IoError> {\n-        do uv_fs_helper(self.uv_loop(), unit) |req, l, cb| {\n-            req.rename(l, path, to, cb)\n-        }\n+        let r = FsRequest::rename(self.uv_loop(), path, to);\n+        r.map_err(uv_error_to_io_error)\n     }\n     fn fs_chmod(&mut self, path: &CString,\n                 perm: io::FilePermission) -> Result<(), IoError> {\n-        do uv_fs_helper(self.uv_loop(), unit) |req, l, cb| {\n-            req.chmod(l, path, perm as c_int, cb)\n-        }\n+        let r = FsRequest::chmod(self.uv_loop(), path, perm as c_int);\n+        r.map_err(uv_error_to_io_error)\n     }\n-    fn fs_readdir(&mut self, path: &CString, flags: c_int) ->\n-        Result<~[Path], IoError> {\n-        use str::StrSlice;\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<~[Path],\n-                                           IoError>> = &result_cell;\n-        let path_cell = Cell::new(path);\n-        do task::unkillable { // FIXME(#8674)\n-            let scheduler: ~Scheduler = Local::take();\n-            let stat_req = file::FsRequest::new();\n-            do scheduler.deschedule_running_task_and_then |_, task| {\n-                let task_cell = Cell::new(task);\n-                let path = path_cell.take();\n-                // Don't pick up the null byte\n-                let slice = path.as_bytes().slice(0, path.len());\n-                let path_parent = Cell::new(Path::new(slice));\n-                do stat_req.readdir(self.uv_loop(), path, flags) |req,err| {\n-                    let parent = path_parent.take();\n-                    let res = match err {\n-                        None => {\n-                            let mut paths = ~[];\n-                            do req.each_path |rel_path| {\n-                                let p = rel_path.as_bytes();\n-                                paths.push(parent.join(p.slice_to(rel_path.len())));\n-                            }\n-                            Ok(paths)\n-                        },\n-                        Some(e) => {\n-                            Err(uv_error_to_io_error(e))\n-                        }\n-                    };\n-                    unsafe { (*result_cell_ptr).put_back(res); }\n-                    let scheduler: ~Scheduler = Local::take();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                };\n-            };\n-        };\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n+    fn fs_readdir(&mut self, path: &CString, flags: c_int)\n+        -> Result<~[Path], IoError>\n+    {\n+        let r = FsRequest::readdir(self.uv_loop(), path, flags);\n+        r.map_err(uv_error_to_io_error)\n     }\n     fn fs_link(&mut self, src: &CString, dst: &CString) -> Result<(), IoError> {\n-        do uv_fs_helper(self.uv_loop(), unit) |req, l, cb| {\n-            req.link(l, src, dst, cb)\n-        }\n+        let r = FsRequest::link(self.uv_loop(), src, dst);\n+        r.map_err(uv_error_to_io_error)\n     }\n     fn fs_symlink(&mut self, src: &CString, dst: &CString) -> Result<(), IoError> {\n-        do uv_fs_helper(self.uv_loop(), unit) |req, l, cb| {\n-            req.symlink(l, src, dst, cb)\n-        }\n+        let r = FsRequest::symlink(self.uv_loop(), src, dst);\n+        r.map_err(uv_error_to_io_error)\n     }\n     fn fs_chown(&mut self, path: &CString, uid: int, gid: int) -> Result<(), IoError> {\n-        do uv_fs_helper(self.uv_loop(), unit) |req, l, cb| {\n-            req.chown(l, path, uid, gid, cb)\n-        }\n+        let r = FsRequest::chown(self.uv_loop(), path, uid, gid);\n+        r.map_err(uv_error_to_io_error)\n     }\n     fn fs_readlink(&mut self, path: &CString) -> Result<Path, IoError> {\n-        fn getlink(f: &mut FsRequest) -> Path {\n-            Path::new(unsafe { CString::new(f.get_ptr() as *libc::c_char, false) })\n-        }\n-        do uv_fs_helper(self.uv_loop(), getlink) |req, l, cb| {\n-            req.readlink(l, path, cb)\n-        }\n+        let r = FsRequest::readlink(self.uv_loop(), path);\n+        r.map_err(uv_error_to_io_error)\n     }\n \n     fn spawn(&mut self, config: ProcessConfig)\n@@ -1072,159 +926,6 @@ impl RtioUdpSocket for UvUdpSocket {\n     }\n }\n \n-pub struct UvFileStream {\n-    priv loop_: Loop,\n-    priv fd: c_int,\n-    priv close: CloseBehavior,\n-    priv home: SchedHandle,\n-}\n-\n-impl HomingIO for UvFileStream {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n-}\n-\n-impl UvFileStream {\n-    fn new(loop_: Loop, fd: c_int, close: CloseBehavior,\n-           home: SchedHandle) -> UvFileStream {\n-        UvFileStream {\n-            loop_: loop_,\n-            fd: fd,\n-            close: close,\n-            home: home,\n-        }\n-    }\n-    fn base_read(&mut self, buf: &mut [u8], offset: i64) -> Result<int, IoError> {\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<int, IoError>> = &result_cell;\n-        let buf_ptr: *&mut [u8] = &buf;\n-        let (_m, scheduler) = self.fire_homing_missile_sched();\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n-            let task_cell = Cell::new(task);\n-            let read_req = file::FsRequest::new();\n-            do read_req.read(&self.loop_, self.fd, buf, offset) |req, uverr| {\n-                let res = match uverr  {\n-                    None => Ok(req.get_result() as int),\n-                    Some(err) => Err(uv_error_to_io_error(err))\n-                };\n-                unsafe { (*result_cell_ptr).put_back(res); }\n-                let scheduler: ~Scheduler = Local::take();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n-            }\n-        }\n-        result_cell.take()\n-    }\n-    fn base_write(&mut self, buf: &[u8], offset: i64) -> Result<(), IoError> {\n-        do self.nop_req |self_, req, cb| {\n-            req.write(&self_.loop_, self_.fd, slice_to_uv_buf(buf), offset, cb)\n-        }\n-    }\n-    fn seek_common(&mut self, pos: i64, whence: c_int) ->\n-        Result<u64, IoError>{\n-        #[fixed_stack_segment]; #[inline(never)];\n-        unsafe {\n-            match lseek(self.fd, pos as off_t, whence) {\n-                -1 => {\n-                    Err(IoError {\n-                        kind: OtherIoError,\n-                        desc: \"Failed to lseek.\",\n-                        detail: None\n-                    })\n-                },\n-                n => Ok(n as u64)\n-            }\n-        }\n-    }\n-    fn nop_req(&mut self, f: &fn(&mut UvFileStream, file::FsRequest, FsCallback))\n-            -> Result<(), IoError> {\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n-        let (_m, sched) = self.fire_homing_missile_sched();\n-        do sched.deschedule_running_task_and_then |_, task| {\n-            let task = Cell::new(task);\n-            let req = file::FsRequest::new();\n-            do f(self, req) |_, uverr| {\n-                let res = match uverr  {\n-                    None => Ok(()),\n-                    Some(err) => Err(uv_error_to_io_error(err))\n-                };\n-                unsafe { (*result_cell_ptr).put_back(res); }\n-                let scheduler: ~Scheduler = Local::take();\n-                scheduler.resume_blocked_task_immediately(task.take());\n-            }\n-        }\n-        result_cell.take()\n-    }\n-}\n-\n-impl Drop for UvFileStream {\n-    fn drop(&mut self) {\n-        match self.close {\n-            DontClose => {}\n-            CloseAsynchronously => {\n-                let close_req = file::FsRequest::new();\n-                do close_req.close(&self.loop_, self.fd) |_,_| {}\n-            }\n-            CloseSynchronously => {\n-                let (_m, scheduler) = self.fire_homing_missile_sched();\n-                do scheduler.deschedule_running_task_and_then |_, task| {\n-                    let task_cell = Cell::new(task);\n-                    let close_req = file::FsRequest::new();\n-                    do close_req.close(&self.loop_, self.fd) |_,_| {\n-                        let scheduler: ~Scheduler = Local::take();\n-                        scheduler.resume_blocked_task_immediately(task_cell.take());\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl RtioFileStream for UvFileStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n-        self.base_read(buf, -1)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        self.base_write(buf, -1)\n-    }\n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n-        self.base_read(buf, offset as i64)\n-    }\n-    fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n-        self.base_write(buf, offset as i64)\n-    }\n-    fn seek(&mut self, pos: i64, whence: SeekStyle) -> Result<u64, IoError> {\n-        use std::libc::{SEEK_SET, SEEK_CUR, SEEK_END};\n-        let whence = match whence {\n-            SeekSet => SEEK_SET,\n-            SeekCur => SEEK_CUR,\n-            SeekEnd => SEEK_END\n-        };\n-        self.seek_common(pos, whence)\n-    }\n-    fn tell(&self) -> Result<u64, IoError> {\n-        use std::libc::SEEK_CUR;\n-        // this is temporary\n-        let self_ = unsafe { cast::transmute_mut(self) };\n-        self_.seek_common(0, SEEK_CUR)\n-    }\n-    fn fsync(&mut self) -> Result<(), IoError> {\n-        do self.nop_req |self_, req, cb| {\n-            req.fsync(&self_.loop_, self_.fd, cb)\n-        }\n-    }\n-    fn datasync(&mut self) -> Result<(), IoError> {\n-        do self.nop_req |self_, req, cb| {\n-            req.datasync(&self_.loop_, self_.fd, cb)\n-        }\n-    }\n-    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n-        do self.nop_req |self_, req, cb| {\n-            req.truncate(&self_.loop_, self_.fd, offset, cb)\n-        }\n-    }\n-}\n-\n // this function is full of lies\n unsafe fn local_io() -> &'static mut IoFactory {\n     do Local::borrow |sched: &mut Scheduler| {"}]}