{"sha": "24fdb1d102eaa062a8a6213ec28803885192a694", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ZmRiMWQxMDJlYWEwNjJhOGE2MjEzZWMyODgwMzg4NTE5MmE2OTQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-09-13T02:29:21Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-09-13T17:43:22Z"}, "message": "rustc/rustpkg: Use a target-specific subdirectory in build/ and lib/\n\nAs per rustpkg.md, rustpkg now builds in a target-specific\nsubdirectory of build/, and installs libraries into a target-specific\nsubdirectory of lib.\n\nCloses #8672", "tree": {"sha": "05de469605b04e25fccb45cce8faebdb9b4d159f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05de469605b04e25fccb45cce8faebdb9b4d159f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24fdb1d102eaa062a8a6213ec28803885192a694", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24fdb1d102eaa062a8a6213ec28803885192a694", "html_url": "https://github.com/rust-lang/rust/commit/24fdb1d102eaa062a8a6213ec28803885192a694", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24fdb1d102eaa062a8a6213ec28803885192a694/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c8f503ac543e0ffe18986b8d6f8548df21cefa3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c8f503ac543e0ffe18986b8d6f8548df21cefa3", "html_url": "https://github.com/rust-lang/rust/commit/7c8f503ac543e0ffe18986b8d6f8548df21cefa3"}], "stats": {"total": 149, "additions": 109, "deletions": 40}, "files": [{"sha": "399a76426654ac76dd2e82aca1cf590b6e1b2069", "filename": "doc/rustpkg.md", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/24fdb1d102eaa062a8a6213ec28803885192a694/doc%2Frustpkg.md", "raw_url": "https://github.com/rust-lang/rust/raw/24fdb1d102eaa062a8a6213ec28803885192a694/doc%2Frustpkg.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frustpkg.md?ref=24fdb1d102eaa062a8a6213ec28803885192a694", "patch": "@@ -52,13 +52,11 @@ A valid workspace must contain each of the following subdirectories:\n      rustpkg will install libraries for bar to `foo/lib/x86_64-apple-darwin/`.\n      The libraries will have names of the form `foo/lib/x86_64-apple-darwin/libbar-[hash].dylib`,\n      where [hash] is a hash of the package ID.\n-* 'bin/': `rustpkg install` installs executable binaries into a target-specific subdirectory of this directory.\n+* 'bin/': `rustpkg install` installs executable binaries into this directory.\n \n-     For example, on a 64-bit machine running Mac OS X,\n-     if `foo` is a workspace, containing the package `bar`,\n-     rustpkg will install executables for `bar` to\n-     `foo/bin/x86_64-apple-darwin/`.\n-     The executables will have names of the form `foo/bin/x86_64-apple-darwin/bar`.\n+     For example, rustpkg will install executables for `bar` to\n+     `foo/bin`.\n+     The executables will have names of the form `foo/bin/bar`.\n * 'build/': `rustpkg build` stores temporary build artifacts in a target-specific subdirectory of this directory.\n \n      For example, on a 64-bit machine running Mac OS X,\n@@ -85,6 +83,12 @@ rustpkg also interprets any dependencies on such a package ID literally\n Thus, `github.com/mozilla/rust#5c4cd30f80` is also a valid package ID,\n since git can deduce that 5c4cd30f80 refers to a revision of the desired repository.\n \n+A package identifier can name a subdirectory of another package.\n+For example, if `foo` is a workspace, and `foo/src/bar/lib.rs` exists,\n+as well as `foo/src/bar/extras/baz/lib.rs`,\n+then both `bar` and `bar/extras/baz` are valid package identifiers\n+in the workspace `foo`.\n+\n ## Source files\n \n rustpkg searches for four different fixed filenames in order to determine the crates to build:\n@@ -140,9 +144,11 @@ but not in their `lib` or `bin` directories.\n \n ## install\n \n-`rustpkg install foo` builds the libraries and/or executables that are targets for `foo`,\n-and then installs them either into `foo`'s `lib` and `bin` directories,\n-or into the `lib` and `bin` subdirectories of the first entry in `RUST_PATH`.\n+`rustpkg install foo` builds the libraries and/or executables that are targets for `foo`.\n+If `RUST_PATH` is declared as an environment variable, then rustpkg installs the\n+libraries and executables into the `lib` and `bin` subdirectories\n+of the first entry in `RUST_PATH`.\n+Otherwise, it installs them into `foo`'s `lib` and `bin` directories.\n \n ## test\n "}, {"sha": "892217988c7cb592a3139ec275c2b199377a3c20", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/24fdb1d102eaa062a8a6213ec28803885192a694/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24fdb1d102eaa062a8a6213ec28803885192a694/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=24fdb1d102eaa062a8a6213ec28803885192a694", "patch": "@@ -77,15 +77,15 @@ pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n             if !found {\n                 let rustpath = rust_path();\n                 for path in rustpath.iter() {\n-                    debug!(\"is %s in visited_dirs? %?\",\n-                            path.push(\"lib\").to_str(),\n-                            visited_dirs.contains(&path.push(\"lib\").to_str()));\n+                    let tlib_path = make_rustpkg_target_lib_path(path, self.target_triple);\n+                    debug!(\"is %s in visited_dirs? %?\", tlib_path.to_str(),\n+                            visited_dirs.contains(&tlib_path.to_str()));\n \n-                    if !visited_dirs.contains(&path.push(\"lib\").to_str()) {\n-                        visited_dirs.insert(path.push(\"lib\").to_str());\n+                    if !visited_dirs.contains(&tlib_path.to_str()) {\n+                        visited_dirs.insert(tlib_path.to_str());\n                         // Don't keep searching the RUST_PATH if one match turns up --\n                         // if we did, we'd get a \"multiple matching crates\" error\n-                        match f(&path.push(\"lib\")) {\n+                        match f(&tlib_path) {\n                            FileMatches => {\n                                break;\n                            }\n@@ -145,6 +145,11 @@ fn make_target_lib_path(sysroot: &Path,\n     sysroot.push_rel(&relative_target_lib_path(target_triple))\n }\n \n+fn make_rustpkg_target_lib_path(dir: &Path,\n+                        target_triple: &str) -> Path {\n+    dir.push_rel(&Path(libdir()).push(target_triple.to_owned()))\n+}\n+\n fn get_or_default_sysroot() -> Path {\n     match os::self_exe_path() {\n       option::Some(ref p) => (*p).pop(),"}, {"sha": "92e5adf09f612abbe30b98890bcd15915e7716a0", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 42, "deletions": 11, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/24fdb1d102eaa062a8a6213ec28803885192a694/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24fdb1d102eaa062a8a6213ec28803885192a694/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=24fdb1d102eaa062a8a6213ec28803885192a694", "patch": "@@ -14,6 +14,7 @@ pub use package_id::PkgId;\n pub use target::{OutputType, Main, Lib, Test, Bench, Target, Build, Install};\n pub use version::{Version, NoVersion, split_version_general, try_parsing_version};\n pub use rustc::metadata::filesearch::rust_path;\n+use rustc::driver::driver::host_triple;\n \n use std::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n use std::os::mkdir_recursive;\n@@ -94,10 +95,29 @@ pub fn workspace_contains_package_id_(pkgid: &PkgId, workspace: &Path,\n     found\n }\n \n+/// Return the target-specific build subdirectory, pushed onto `base`;\n+/// doesn't check that it exists or create it\n+pub fn target_build_dir(workspace: &Path) -> Path {\n+    workspace.push(\"build\").push(host_triple())\n+}\n+\n+/// Return the target-specific lib subdirectory, pushed onto `base`;\n+/// doesn't check that it exists or create it\n+fn target_lib_dir(workspace: &Path) -> Path {\n+    workspace.push(\"lib\").push(host_triple())\n+}\n+\n+/// Return the bin subdirectory, pushed onto `base`;\n+/// doesn't check that it exists or create it\n+/// note: this isn't target-specific\n+fn target_bin_dir(workspace: &Path) -> Path {\n+    workspace.push(\"bin\")\n+}\n+\n /// Figure out what the executable name for <pkgid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n pub fn built_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n-    let mut result = workspace.push(\"build\");\n+    let mut result = target_build_dir(workspace);\n     // should use a target-specific subdirectory\n     result = mk_output_path(Main, Build, pkgid, result);\n     debug!(\"built_executable_in_workspace: checking whether %s exists\",\n@@ -124,7 +144,7 @@ pub fn built_bench_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path>\n }\n \n fn output_in_workspace(pkgid: &PkgId, workspace: &Path, what: OutputType) -> Option<Path> {\n-    let mut result = workspace.push(\"build\");\n+    let mut result = target_build_dir(workspace);\n     // should use a target-specific subdirectory\n     result = mk_output_path(what, Build, pkgid, result);\n     debug!(\"output_in_workspace: checking whether %s exists\",\n@@ -172,11 +192,21 @@ pub fn library_in_workspace(path: &Path, short_name: &str, where: Target,\n             prefix = %s\", short_name, where, workspace.to_str(), prefix);\n \n     let dir_to_search = match where {\n-        Build => workspace.push(prefix).push_rel(path),\n-        Install => workspace.push(prefix)\n+        Build => target_build_dir(workspace).push_rel(path),\n+        Install => target_lib_dir(workspace)\n     };\n+\n+    library_in(short_name, version, &dir_to_search)\n+}\n+\n+// rustc doesn't use target-specific subdirectories\n+pub fn system_library(sysroot: &Path, lib_name: &str) -> Option<Path> {\n+    library_in(lib_name, &NoVersion, &sysroot.push(\"lib\"))\n+}\n+\n+fn library_in(short_name: &str, version: &Version, dir_to_search: &Path) -> Option<Path> {\n     debug!(\"Listing directory %s\", dir_to_search.to_str());\n-    let dir_contents = os::list_dir(&dir_to_search);\n+    let dir_contents = os::list_dir(dir_to_search);\n     debug!(\"dir has %? entries\", dir_contents.len());\n \n     let lib_prefix = fmt!(\"%s%s\", os::consts::DLL_PREFIX, short_name);\n@@ -298,9 +328,10 @@ fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n     };\n     // Artifacts in the build directory live in a package-ID-specific subdirectory,\n     // but installed ones don't.\n-    let result = match where {\n-                Build => workspace.push(subdir).push_rel(&pkgid.path),\n-                _     => workspace.push(subdir)\n+    let result = match (where, what) {\n+                (Build, _)         => target_build_dir(workspace).push_rel(&pkgid.path),\n+                (Install, Lib)     => target_lib_dir(workspace),\n+                (Install, _)    => target_bin_dir(workspace)\n     };\n     if !os::path_exists(&result) && !mkdir_recursive(&result, U_RWX) {\n         cond.raise((result.clone(), fmt!(\"target_file_in_workspace couldn't \\\n@@ -315,10 +346,10 @@ fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n pub fn build_pkg_id_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     use conditions::bad_path::cond;\n \n-    let mut result = workspace.push(\"build\");\n-    // n.b. Should actually use a target-specific\n-    // subdirectory of build/\n+    let mut result = target_build_dir(workspace);\n     result = result.push_rel(&pkgid.path);\n+    debug!(\"Creating build dir %s for package id %s\", result.to_str(),\n+           pkgid.to_str());\n     if os::path_exists(&result) || os::mkdir_recursive(&result, U_RWX) {\n         result\n     }"}, {"sha": "e5ca38daeb55c6baaf8c304f4807e7d45989f1e0", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/24fdb1d102eaa062a8a6213ec28803885192a694/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24fdb1d102eaa062a8a6213ec28803885192a694/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=24fdb1d102eaa062a8a6213ec28803885192a694", "patch": "@@ -27,7 +27,7 @@ use path_util::{target_executable_in_workspace, target_test_in_workspace,\n                target_bench_in_workspace, make_dir_rwx, U_RWX,\n                library_in_workspace, installed_library_in_workspace,\n                built_bench_in_workspace, built_test_in_workspace,\n-               built_library_in_workspace, built_executable_in_workspace};\n+               built_library_in_workspace, built_executable_in_workspace, target_build_dir};\n use rustc::back::link::get_cc_prog;\n use rustc::metadata::filesearch::rust_path;\n use rustc::driver::driver::{build_session, build_session_options, host_triple, optgroups};\n@@ -382,7 +382,7 @@ fn llvm_bitcode_file_exists(repo: &Path, short_name: &str) -> bool {\n }\n \n fn file_exists(repo: &Path, short_name: &str, extension: &str) -> bool {\n-    os::path_exists(&repo.push_many([~\"build\", short_name.to_owned(),\n+    os::path_exists(&target_build_dir(repo).push_many([short_name.to_owned(),\n                                      fmt!(\"%s.%s\", short_name, extension)]))\n }\n \n@@ -433,7 +433,7 @@ fn lib_output_file_name(workspace: &Path, parent: &str, short_name: &str) -> Pat\n }\n \n fn output_file_name(workspace: &Path, short_name: &str) -> Path {\n-    workspace.push(\"build\").push(short_name).push(fmt!(\"%s%s\", short_name, os::EXE_SUFFIX))\n+    target_build_dir(workspace).push(short_name).push(fmt!(\"%s%s\", short_name, os::EXE_SUFFIX))\n }\n \n fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n@@ -657,11 +657,10 @@ fn test_package_version() {\n         None    => false\n     });\n     assert!(built_executable_in_workspace(&temp_pkg_id, &ws)\n-            == Some(ws.push(\"build\").\n-                    push(\"mockgithub.com\").\n-                    push(\"catamorphism\").\n-                    push(\"test_pkg_version\").\n-                    push(\"test_pkg_version\")));\n+            == Some(target_build_dir(&ws).push_many([~\"mockgithub.com\",\n+                                                    ~\"catamorphism\",\n+                                                    ~\"test_pkg_version\",\n+                                                    ~\"test_pkg_version\"])));\n }\n \n #[test]\n@@ -755,7 +754,7 @@ fn package_script_with_default_build() {\n     }\n     command_line_test([~\"install\", ~\"fancy-lib\"], &dir);\n     assert_lib_exists(&dir, &Path(\"fancy-lib\"), NoVersion);\n-    assert!(os::path_exists(&dir.push(\"build\").push(\"fancy-lib\").push(\"generated.rs\")));\n+    assert!(os::path_exists(&target_build_dir(&dir).push_many([~\"fancy-lib\", ~\"generated.rs\"])));\n }\n \n #[test]\n@@ -1121,7 +1120,7 @@ fn test_import_rustpkg() {\n               \"extern mod rustpkg; fn main() {}\");\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n     debug!(\"workspace = %s\", workspace.to_str());\n-    assert!(os::path_exists(&workspace.push(\"build\").push(\"foo\").push(fmt!(\"pkg%s\",\n+    assert!(os::path_exists(&target_build_dir(&workspace).push(\"foo\").push(fmt!(\"pkg%s\",\n         os::EXE_SUFFIX))));\n }\n \n@@ -1133,7 +1132,7 @@ fn test_macro_pkg_script() {\n               \"extern mod rustpkg; fn main() { debug!(\\\"Hi\\\"); }\");\n     command_line_test([~\"build\", ~\"foo\"], &workspace);\n     debug!(\"workspace = %s\", workspace.to_str());\n-    assert!(os::path_exists(&workspace.push(\"build\").push(\"foo\").push(fmt!(\"pkg%s\",\n+    assert!(os::path_exists(&target_build_dir(&workspace).push(\"foo\").push(fmt!(\"pkg%s\",\n         os::EXE_SUFFIX))));\n }\n \n@@ -1622,6 +1621,33 @@ fn test_install_to_rust_path() {\n     assert!(!executable_exists(&second_workspace, \"foo\"));\n }\n \n+fn test_target_specific_build_dir() {\n+    let p_id = PkgId::new(\"foo\");\n+    let workspace = create_local_package(&p_id);\n+    command_line_test([test_sysroot().to_str(),\n+                       ~\"build\",\n+                       ~\"foo\"],\n+                      &workspace);\n+    assert!(os::path_is_dir(&target_build_dir(&workspace)));\n+    assert!(built_executable_exists(&workspace, \"foo\"));\n+    assert!(os::list_dir(&workspace.push(\"build\")).len() == 1);\n+}\n+\n+#[test]\n+fn test_target_specific_install_dir() {\n+    let p_id = PkgId::new(\"foo\");\n+    let workspace = create_local_package(&p_id);\n+    command_line_test([test_sysroot().to_str(),\n+                       ~\"install\",\n+                       ~\"foo\"],\n+                      &workspace);\n+    assert!(os::path_is_dir(&workspace.push(\"lib\").push(host_triple())));\n+    assert_lib_exists(&workspace, &Path(\"foo\"), NoVersion);\n+    assert!(os::list_dir(&workspace.push(\"lib\")).len() == 1);\n+    assert!(os::path_is_dir(&workspace.push(\"bin\")));\n+    assert_executable_exists(&workspace, \"foo\");\n+}\n+\n /// Returns true if p exists and is executable\n fn is_executable(p: &Path) -> bool {\n     use std::libc::consts::os::posix88::{S_IXUSR};"}, {"sha": "18928c3f169962821176104c018b497a100a2abc", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24fdb1d102eaa062a8a6213ec28803885192a694/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24fdb1d102eaa062a8a6213ec28803885192a694/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=24fdb1d102eaa062a8a6213ec28803885192a694", "patch": "@@ -23,7 +23,7 @@ use context::{in_target, StopBefore, Link, Assemble, BuildContext};\n use package_id::PkgId;\n use package_source::PkgSrc;\n use workspace::pkg_parent_workspaces;\n-use path_util::{installed_library_in_workspace, U_RWX, rust_path};\n+use path_util::{installed_library_in_workspace, U_RWX, rust_path, system_library, target_build_dir};\n use messages::error;\n \n pub use target::{OutputType, Main, Lib, Bench, Test};\n@@ -170,7 +170,7 @@ pub fn compile_input(context: &BuildContext,\n     // tjc: by default, use the package ID name as the link name\n     // not sure if we should support anything else\n \n-    let out_dir = workspace.push(\"build\").push_rel(&pkg_id.path);\n+    let out_dir = target_build_dir(workspace).push_rel(&pkg_id.path);\n \n     let binary = os::args()[0].to_managed();\n \n@@ -381,7 +381,8 @@ pub fn find_and_install_dependencies(context: &BuildContext,\n                     None => sess.str_of(lib_ident)\n                 };\n                 debug!(\"Finding and installing... %s\", lib_name);\n-                match installed_library_in_workspace(&Path(lib_name), &context.sysroot()) {\n+                // Check standard Rust library path first\n+                match system_library(&context.sysroot(), lib_name) {\n                     Some(ref installed_path) => {\n                         debug!(\"It exists: %s\", installed_path.to_str());\n                         // Say that [path for c] has a discovered dependency on"}]}