{"sha": "63dcc9a4df50680686bee852e82a52fbc59b3c27", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzZGNjOWE0ZGY1MDY4MDY4NmJlZTg1MmU4MmE1MmZiYzU5YjNjMjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-13T20:57:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-13T20:57:30Z"}, "message": "auto merge of #14867 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "2a5a941e0da26795babf286edf77f9f225bc906d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a5a941e0da26795babf286edf77f9f225bc906d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63dcc9a4df50680686bee852e82a52fbc59b3c27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63dcc9a4df50680686bee852e82a52fbc59b3c27", "html_url": "https://github.com/rust-lang/rust/commit/63dcc9a4df50680686bee852e82a52fbc59b3c27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63dcc9a4df50680686bee852e82a52fbc59b3c27/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7f11f20e5e72a3b22863a9913df94303321a5ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7f11f20e5e72a3b22863a9913df94303321a5ce", "html_url": "https://github.com/rust-lang/rust/commit/e7f11f20e5e72a3b22863a9913df94303321a5ce"}, {"sha": "b7af25060a1b0451cb06085ba5893980bc4e5333", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7af25060a1b0451cb06085ba5893980bc4e5333", "html_url": "https://github.com/rust-lang/rust/commit/b7af25060a1b0451cb06085ba5893980bc4e5333"}], "stats": {"total": 1576, "additions": 1165, "deletions": 411}, "files": [{"sha": "3a306085c77aab3d37838ca6eb0e02e1f550b431", "filename": "configure", "status": "modified", "additions": 19, "deletions": 54, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/configure", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -416,7 +416,6 @@ opt mingw-cross 0 \"cross-compile for win32 using mingw\"\n opt clang 0 \"prefer clang to gcc for building the runtime\"\n opt ccache 0 \"invoke gcc/clang via ccache to reuse object files between builds\"\n opt local-rust 0 \"use an installed rustc rather than downloading a snapshot\"\n-opt pax-flags 0 \"apply PaX flags to rustc binaries (required for GRSecurity/PaX-patched kernels)\"\n opt inject-std-version 1 \"inject the current compiler version of libstd into programs\"\n opt llvm-static-stdcpp 0 \"statically link to libstdc++ for LLVM\"\n opt rpath 1 \"build rpaths into rustc itself\"\n@@ -518,12 +517,6 @@ then\n     fi\n fi\n \n-if [ \"$CFG_OSTYPE\" = \"unknown-linux-gnu\" ]\n-then\n-    probe CFG_PAXCTL           paxctl /sbin/paxctl\n-    probe CFG_ZCAT             zcat\n-fi\n-\n step_msg \"looking for target specific programs\"\n \n probe CFG_ADB        adb\n@@ -546,51 +539,6 @@ then\n     fi\n fi\n \n-if [ \"$CFG_OSTYPE\" = \"unknown-linux-gnu\" ]\n-then\n-    if [ ! -z \"$CFG_ENABLE_PAX_FLAGS\" -a -z \"$CFG_PAXCTL\" ]\n-    then\n-        err \"enabled PaX markings but no paxctl binary found\"\n-    fi\n-\n-    if [ -z \"$CFG_DISABLE_PAX_FLAGS\" ]\n-    then\n-        # GRSecurity/PaX detection. This can be very flaky.\n-        GRSEC_DETECTED=\n-\n-        # /dev/grsec only exists if CONFIG_GRKERNSEC_NO_RBAC is not set.\n-        # /proc/sys/kernel/grsecurity is not available if \u00c7ONFIG_GRKERNSEC_SYSCTL is not set.\n-        if [ -e /dev/grsec -o -d /proc/sys/kernel/grsecurity ]\n-        then\n-            GRSEC_DETECTED=1\n-        # /proc/config.gz is normally only available to root, and only if CONFIG_IKCONFIG_PROC has been set.\n-        elif [ -r /proc/config.gz -a ! -z \"$CFG_ZCAT\" ]\n-        then\n-            if \"$CFG_ZCAT\" /proc/config.gz | grep --quiet \"CONFIG_GRKERNSEC=y\"\n-            then\n-                GRSEC_DETECTED=1\n-            fi\n-        # Flaky.\n-        elif grep --quiet grsec /proc/version\n-        then\n-            GRSEC_DETECTED=1\n-        fi\n-\n-        if [ ! -z \"$GRSEC_DETECTED\" ]\n-        then\n-            step_msg \"GRSecurity: yes\"\n-            if [ ! -z \"$CFG_PAXCTL\" ]\n-            then\n-                CFG_ENABLE_PAX_FLAGS=1\n-            else\n-                warn \"GRSecurity kernel detected but no paxctl binary found: not setting CFG_ENABLE_PAX_FLAGS\"\n-            fi\n-        else\n-            step_msg \"GRSecurity: no\"\n-        fi\n-    fi\n-fi\n-\n BIN_SUF=\n if [ \"$CFG_OSTYPE\" = \"pc-mingw32\" ] || [ \"$CFG_OSTYPE\" = \"w64-mingw32\" ]\n then\n@@ -942,16 +890,33 @@ then\n     msg \"git: submodule sync\"\n     \"${CFG_GIT}\" submodule sync\n \n+    msg \"git: submodule init\"\n+    \"${CFG_GIT}\" submodule init\n+\n+    # Disable submodules that we're not using\n+    if [ ! -z \"${CFG_LLVM_ROOT}\" ]; then\n+        msg \"git: submodule deinit src/llvm\"\n+        \"${CFG_GIT}\" submodule deinit src/llvm\n+    fi\n+    if [ ! -z \"${CFG_JEMALLOC_ROOT}\" ]; then\n+        msg \"git: submodule deinit src/jemalloc\"\n+        \"${CFG_GIT}\" submodule deinit src/jemalloc\n+    fi\n+    if [ ! -z \"${CFG_LIBUV_ROOT}\" ]; then\n+        msg \"git: submodule deinit src/libuv\"\n+        \"${CFG_GIT}\" submodule deinit src/libuv\n+    fi\n+\n     msg \"git: submodule update\"\n-    \"${CFG_GIT}\" submodule update --init\n+    \"${CFG_GIT}\" submodule update\n     need_ok \"git failed\"\n \n     msg \"git: submodule foreach sync\"\n     \"${CFG_GIT}\" submodule foreach --recursive 'if test -e .gitmodules; then git submodule sync; fi'\n     need_ok \"git failed\"\n \n     msg \"git: submodule foreach update\"\n-    \"${CFG_GIT}\" submodule update --init --recursive\n+    \"${CFG_GIT}\" submodule update --recursive\n     need_ok \"git failed\"\n \n     # NB: this is just for the sake of getting the submodule SHA1 values"}, {"sha": "972cfecea718aa87de4a9cb1639d4c3a26ba235e", "filename": "mk/stage0.mk", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/mk%2Fstage0.mk", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/mk%2Fstage0.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fstage0.mk?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -18,10 +18,6 @@ ifdef CFG_ENABLE_LOCAL_RUST\n \t$(Q)$(S)src/etc/local_stage0.sh $(CFG_BUILD) $(CFG_LOCAL_RUST_ROOT) rustlib\n else\n \t$(Q)$(CFG_PYTHON) $(S)src/etc/get-snapshot.py $(CFG_BUILD) $(SNAPSHOT_FILE)\n-ifdef CFG_ENABLE_PAX_FLAGS\n-\t@$(call E, apply PaX flags: $@)\n-\t@\"$(CFG_PAXCTL)\" -cm \"$@\"\n-endif\n endif\n \t$(Q)touch $@\n "}, {"sha": "086b073a9c44b0846c5d5b1ee379c1a8f889cc88", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -761,7 +761,7 @@ pub struct IntersectionItems<'a, T> {\n     b: Peekable<&'a T, SetItems<'a, T>>,\n }\n \n-/// Lazy iterator producing elements in the set intersection (in-order)\n+/// Lazy iterator producing elements in the set union (in-order)\n pub struct UnionItems<'a, T> {\n     a: Peekable<&'a T, SetItems<'a, T>>,\n     b: Peekable<&'a T, SetItems<'a, T>>,"}, {"sha": "2657cd534837231af948f40c086ab4a1da3f52b1", "filename": "src/libcore/any.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Traits for dynamic typing of any type (through runtime reflection)\n+//! Traits for dynamic typing of any `'static` type (through runtime reflection)\n //!\n //! This module implements the `Any` trait, which enables dynamic typing\n-//! of any type, through runtime reflection.\n+//! of any `'static` type through runtime reflection.\n //!\n //! `Any` itself can be used to get a `TypeId`, and has more features when used as a trait object.\n //! As `&Any` (a borrowed trait object), it has the `is` and `as_ref` methods, to test if the\n@@ -32,8 +32,10 @@ pub enum Void { }\n // Any trait\n ///////////////////////////////////////////////////////////////////////////////\n \n-/// The `Any` trait is implemented by all types, and can be used as a trait object\n-/// for dynamic typing\n+/// The `Any` trait is implemented by all `'static` types, and can be used for dynamic typing\n+///\n+/// Every type with no non-`'static` references implements `Any`, so `Any` can be used as a trait\n+/// object to emulate the effects dynamic typing.\n pub trait Any {\n     /// Get the `TypeId` of `self`\n     fn get_type_id(&self) -> TypeId;\n@@ -261,6 +263,14 @@ mod tests {\n         let s = format!(\"{}\", b);\n         assert_eq!(s.as_slice(), \"&Any\");\n     }\n+\n+    #[test]\n+    fn any_fixed_vec() {\n+        let test = [0u, ..8];\n+        let test = &test as &Any;\n+        assert!(test.is::<[uint, ..8]>());\n+        assert!(!test.is::<[uint, ..10]>());\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "33f2a49d6d560cba10c9dd49d185c1663fa312ce", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -307,6 +307,20 @@ extern \"rust-intrinsic\" {\n     /// `forget` is unsafe because the caller is responsible for\n     /// ensuring the argument is deallocated already.\n     pub fn forget<T>(_: T) -> ();\n+\n+    /// Unsafely transforms a value of one type into a value of another type.\n+    ///\n+    /// Both types must have the same size and alignment, and this guarantee\n+    /// is enforced at compile-time.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::mem;\n+    ///\n+    /// let v: &[u8] = unsafe { mem::transmute(\"L\") };\n+    /// assert!(v == [76u8]);\n+    /// ```\n     pub fn transmute<T,U>(e: T) -> U;\n \n     /// Returns `true` if a type requires drop glue."}, {"sha": "237efcd0096d0e190e7490d4cf64db62d5ff5ac0", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -17,6 +17,8 @@ use ptr;\n use intrinsics;\n use intrinsics::{bswap16, bswap32, bswap64};\n \n+pub use intrinsics::transmute;\n+\n /// Returns the size of a type in bytes.\n #[inline]\n #[stable]\n@@ -412,29 +414,6 @@ pub fn drop<T>(_x: T) { }\n #[stable]\n pub unsafe fn forget<T>(thing: T) { intrinsics::forget(thing) }\n \n-/// Unsafely transforms a value of one type into a value of another type.\n-///\n-/// Both types must have the same size and alignment, and this guarantee is\n-/// enforced at compile-time.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use std::mem;\n-///\n-/// let v: &[u8] = unsafe { mem::transmute(\"L\") };\n-/// assert!(v == [76u8]);\n-/// ```\n-#[inline]\n-#[unstable = \"this function will be modified to reject invocations of it which \\\n-              cannot statically prove that T and U are the same size. For \\\n-              example, this function, as written today, will be rejected in \\\n-              the future because the size of T and U cannot be statically \\\n-              known to be the same\"]\n-pub unsafe fn transmute<T, U>(thing: T) -> U {\n-    intrinsics::transmute(thing)\n-}\n-\n /// Interprets `src` as `&U`, and then reads `src` without moving the contained\n /// value.\n ///"}, {"sha": "1b6525c6e3877568818a38288a30c8e4480dc9fb", "filename": "src/libnative/io/c_win32.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibnative%2Fio%2Fc_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibnative%2Fio%2Fc_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_win32.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -77,15 +77,20 @@ pub mod compat {\n         fn GetProcAddress(hModule: HMODULE, lpProcName: LPCSTR) -> LPVOID;\n     }\n \n-    // store_func() is idempotent, so using relaxed ordering for the atomics should be enough.\n-    // This way, calling a function in this compatibility layer (after it's loaded) shouldn't\n-    // be any slower than a regular DLL call.\n-    unsafe fn store_func<T: Copy>(ptr: *mut T, module: &str, symbol: &str, fallback: T) {\n+    // store_func() is idempotent, so using relaxed ordering for the atomics\n+    // should be enough.  This way, calling a function in this compatibility\n+    // layer (after it's loaded) shouldn't be any slower than a regular DLL\n+    // call.\n+    unsafe fn store_func(ptr: *mut uint, module: &str, symbol: &str, fallback: uint) {\n         let module = module.to_utf16().append_one(0);\n         symbol.with_c_str(|symbol| {\n             let handle = GetModuleHandleW(module.as_ptr());\n-            let func: Option<T> = transmute(GetProcAddress(handle, symbol));\n-            atomic_store_relaxed(ptr, func.unwrap_or(fallback))\n+            let func: uint = transmute(GetProcAddress(handle, symbol));\n+            atomic_store_relaxed(ptr, if func == 0 {\n+                fallback\n+            } else {\n+                func\n+            })\n         })\n     }\n \n@@ -109,10 +114,10 @@ pub mod compat {\n \n                 extern \"system\" fn thunk($($argname: $argtype),*) -> $rettype {\n                     unsafe {\n-                        ::io::c::compat::store_func(&mut ptr,\n-                                                             stringify!($module),\n-                                                             stringify!($symbol),\n-                                                             fallback);\n+                        ::io::c::compat::store_func(&mut ptr as *mut _ as *mut uint,\n+                                                    stringify!($module),\n+                                                    stringify!($symbol),\n+                                                    fallback as uint);\n                         ::std::intrinsics::atomic_load_relaxed(&ptr)($($argname),*)\n                     }\n                 }"}, {"sha": "2268ce843658796c75cfb99b5bd57364237fe8a2", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -333,6 +333,9 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n             time(time_passes, \"privacy checking\", maps, |(a, b)|\n                  middle::privacy::check_crate(&ty_cx, &exp_map2, a, b, krate));\n \n+    time(time_passes, \"intrinsic checking\", (), |_|\n+         middle::intrinsicck::check_crate(&ty_cx, krate));\n+\n     time(time_passes, \"effect checking\", (), |_|\n          middle::effect::check_crate(&ty_cx, krate));\n "}, {"sha": "1e39aaa3a5fac61a7b0dc0a201be9acbf5d5ab77", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -85,6 +85,7 @@ pub mod middle {\n     pub mod dependency_format;\n     pub mod weak_lang_items;\n     pub mod save;\n+    pub mod intrinsicck;\n }\n \n pub mod front {"}, {"sha": "aa74614b78cd884fdb08ed2957888188259f99a7", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 39, "deletions": 21, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -55,6 +55,11 @@ struct MarkSymbolVisitor<'a> {\n     live_symbols: Box<HashSet<ast::NodeId>>,\n }\n \n+#[deriving(Clone)]\n+struct MarkSymbolVisitorContext {\n+    struct_has_extern_repr: bool\n+}\n+\n impl<'a> MarkSymbolVisitor<'a> {\n     fn new(tcx: &'a ty::ctxt,\n            worklist: Vec<ast::NodeId>) -> MarkSymbolVisitor<'a> {\n@@ -170,48 +175,61 @@ impl<'a> MarkSymbolVisitor<'a> {\n     }\n \n     fn visit_node(&mut self, node: &ast_map::Node) {\n+        let ctxt = MarkSymbolVisitorContext {\n+            struct_has_extern_repr: false\n+        };\n         match *node {\n             ast_map::NodeItem(item) => {\n                 match item.node {\n-                    ast::ItemStruct(struct_def, _) => {\n+                    ast::ItemStruct(..) => {\n                         let has_extern_repr = item.attrs.iter().fold(attr::ReprAny, |acc, attr| {\n                             attr::find_repr_attr(self.tcx.sess.diagnostic(), attr, acc)\n                         }) == attr::ReprExtern;\n-                        let live_fields = struct_def.fields.iter().filter(|f| {\n-                            has_extern_repr || match f.node.kind {\n-                                ast::NamedField(_, ast::Public) => true,\n-                                _ => false\n-                            }\n+\n+                        visit::walk_item(self, &*item, MarkSymbolVisitorContext {\n+                            struct_has_extern_repr: has_extern_repr,\n+                            ..(ctxt)\n                         });\n-                        self.live_symbols.extend(live_fields.map(|f| f.node.id));\n-                        visit::walk_item(self, &*item, ());\n                     }\n                     ast::ItemFn(..)\n-                    | ast::ItemTy(..)\n                     | ast::ItemEnum(..)\n+                    | ast::ItemTy(..)\n                     | ast::ItemStatic(..) => {\n-                        visit::walk_item(self, &*item, ());\n+                        visit::walk_item(self, &*item, ctxt);\n                     }\n                     _ => ()\n                 }\n             }\n             ast_map::NodeTraitMethod(trait_method) => {\n-                visit::walk_trait_method(self, &*trait_method, ());\n+                visit::walk_trait_method(self, &*trait_method, ctxt);\n             }\n             ast_map::NodeMethod(method) => {\n-                visit::walk_block(self, &*method.body, ());\n+                visit::walk_block(self, &*method.body, ctxt);\n             }\n             ast_map::NodeForeignItem(foreign_item) => {\n-                visit::walk_foreign_item(self, &*foreign_item, ());\n+                visit::walk_foreign_item(self, &*foreign_item, ctxt);\n             }\n             _ => ()\n         }\n     }\n }\n \n-impl<'a> Visitor<()> for MarkSymbolVisitor<'a> {\n+impl<'a> Visitor<MarkSymbolVisitorContext> for MarkSymbolVisitor<'a> {\n+\n+    fn visit_struct_def(&mut self, def: &ast::StructDef, _: ast::Ident, _: &ast::Generics,\n+                        _: ast::NodeId, ctxt: MarkSymbolVisitorContext) {\n+        let live_fields = def.fields.iter().filter(|f| {\n+            ctxt.struct_has_extern_repr || match f.node.kind {\n+                ast::NamedField(_, ast::Public) => true,\n+                _ => false\n+            }\n+        });\n+        self.live_symbols.extend(live_fields.map(|f| f.node.id));\n+\n+        visit::walk_struct_def(self, def, ctxt);\n+    }\n \n-    fn visit_expr(&mut self, expr: &ast::Expr, _: ()) {\n+    fn visit_expr(&mut self, expr: &ast::Expr, ctxt: MarkSymbolVisitorContext) {\n         match expr.node {\n             ast::ExprMethodCall(..) => {\n                 self.lookup_and_handle_method(expr.id, expr.span);\n@@ -222,26 +240,26 @@ impl<'a> Visitor<()> for MarkSymbolVisitor<'a> {\n             _ => ()\n         }\n \n-        visit::walk_expr(self, expr, ())\n+        visit::walk_expr(self, expr, ctxt);\n     }\n \n-    fn visit_pat(&mut self, pat: &ast::Pat, _: ()) {\n+    fn visit_pat(&mut self, pat: &ast::Pat, ctxt: MarkSymbolVisitorContext) {\n         match pat.node {\n             ast::PatStruct(_, ref fields, _) => {\n                 self.handle_field_pattern_match(pat, fields.as_slice());\n             }\n             _ => ()\n         }\n \n-        visit::walk_pat(self, pat, ())\n+        visit::walk_pat(self, pat, ctxt);\n     }\n \n-    fn visit_path(&mut self, path: &ast::Path, id: ast::NodeId, _: ()) {\n+    fn visit_path(&mut self, path: &ast::Path, id: ast::NodeId, ctxt: MarkSymbolVisitorContext) {\n         self.lookup_and_handle_definition(&id);\n-        visit::walk_path(self, path, ());\n+        visit::walk_path(self, path, ctxt);\n     }\n \n-    fn visit_item(&mut self, _: &ast::Item, _: ()) {\n+    fn visit_item(&mut self, _: &ast::Item, _: MarkSymbolVisitorContext) {\n         // Do not recurse into items. These items will be added to the\n         // worklist and recursed into manually if necessary.\n     }"}, {"sha": "93913f842711197bc6e032975920dfb15a3edd40", "filename": "src/librustc/middle/intrinsicck.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -0,0 +1,155 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use metadata::csearch;\n+use middle::def::DefFn;\n+use middle::subst::Subst;\n+use middle::ty::{TransmuteRestriction, ctxt, ty_bare_fn};\n+use middle::ty;\n+\n+use syntax::abi::RustIntrinsic;\n+use syntax::ast::DefId;\n+use syntax::ast;\n+use syntax::ast_map::NodeForeignItem;\n+use syntax::codemap::Span;\n+use syntax::parse::token;\n+use syntax::visit::Visitor;\n+use syntax::visit;\n+\n+fn type_size_is_affected_by_type_parameters(tcx: &ty::ctxt, typ: ty::t)\n+                                            -> bool {\n+    let mut result = false;\n+    ty::maybe_walk_ty(typ, |typ| {\n+        match ty::get(typ).sty {\n+            ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_ptr(_) |\n+            ty::ty_rptr(..) | ty::ty_bare_fn(..) | ty::ty_closure(..) => {\n+                false\n+            }\n+            ty::ty_param(_) => {\n+                result = true;\n+                // No need to continue; we now know the result.\n+                false\n+            }\n+            ty::ty_enum(did, ref substs) => {\n+                for enum_variant in (*ty::enum_variants(tcx, did)).iter() {\n+                    for argument_type in enum_variant.args.iter() {\n+                        let argument_type = argument_type.subst(tcx, substs);\n+                        result = result ||\n+                            type_size_is_affected_by_type_parameters(\n+                                tcx,\n+                                argument_type);\n+                    }\n+                }\n+\n+                // Don't traverse substitutions.\n+                false\n+            }\n+            ty::ty_struct(did, ref substs) => {\n+                for field in ty::struct_fields(tcx, did, substs).iter() {\n+                    result = result ||\n+                        type_size_is_affected_by_type_parameters(tcx,\n+                                                                 field.mt.ty);\n+                }\n+\n+                // Don't traverse substitutions.\n+                false\n+            }\n+            _ => true,\n+        }\n+    });\n+    result\n+}\n+\n+struct IntrinsicCheckingVisitor<'a> {\n+    tcx: &'a ctxt,\n+}\n+\n+impl<'a> IntrinsicCheckingVisitor<'a> {\n+    fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n+        if def_id.krate == ast::LOCAL_CRATE {\n+            match self.tcx.map.get(def_id.node) {\n+                NodeForeignItem(ref item) => {\n+                    token::get_ident(item.ident) ==\n+                        token::intern_and_get_ident(\"transmute\")\n+                }\n+                _ => false,\n+            }\n+        } else {\n+            match csearch::get_item_path(self.tcx, def_id).last() {\n+                None => false,\n+                Some(ref last) => {\n+                    token::get_name(last.name()) ==\n+                        token::intern_and_get_ident(\"transmute\")\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_transmute(&self, span: Span, from: ty::t, to: ty::t) {\n+        if type_size_is_affected_by_type_parameters(self.tcx, from) {\n+            self.tcx.sess.span_err(span,\n+                                   \"cannot transmute from a type that \\\n+                                    contains type parameters\");\n+        }\n+        if type_size_is_affected_by_type_parameters(self.tcx, to) {\n+            self.tcx.sess.span_err(span,\n+                                   \"cannot transmute to a type that contains \\\n+                                    type parameters\");\n+        }\n+\n+        let restriction = TransmuteRestriction {\n+            span: span,\n+            from: from,\n+            to: to,\n+        };\n+        self.tcx.transmute_restrictions.borrow_mut().push(restriction);\n+    }\n+}\n+\n+impl<'a> Visitor<()> for IntrinsicCheckingVisitor<'a> {\n+    fn visit_expr(&mut self, expr: &ast::Expr, (): ()) {\n+        match expr.node {\n+            ast::ExprPath(..) => {\n+                match ty::resolve_expr(self.tcx, expr) {\n+                    DefFn(did, _) if self.def_id_is_transmute(did) => {\n+                        let typ = ty::node_id_to_type(self.tcx, expr.id);\n+                        match ty::get(typ).sty {\n+                            ty_bare_fn(ref bare_fn_ty)\n+                                    if bare_fn_ty.abi == RustIntrinsic => {\n+                                let from = *bare_fn_ty.sig.inputs.get(0);\n+                                let to = bare_fn_ty.sig.output;\n+                                self.check_transmute(expr.span, from, to);\n+                            }\n+                            _ => {\n+                                self.tcx\n+                                    .sess\n+                                    .span_bug(expr.span,\n+                                              \"transmute wasn't a bare fn?!\");\n+                            }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        visit::walk_expr(self, expr, ());\n+    }\n+}\n+\n+pub fn check_crate(tcx: &ctxt, krate: &ast::Crate) {\n+    let mut visitor = IntrinsicCheckingVisitor {\n+        tcx: tcx,\n+    };\n+\n+    visit::walk_crate(&mut visitor, krate, ());\n+}\n+"}, {"sha": "8ff5331cec2319dca978cf60064224f0dddde9c4", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -165,7 +165,7 @@ impl<'a, 'b> Visitor<Scope<'a>> for LifetimeContext<'b> {\n     fn visit_lifetime_ref(&mut self,\n                           lifetime_ref: &ast::Lifetime,\n                           scope: Scope<'a>) {\n-        if lifetime_ref.name == special_idents::statik.name {\n+        if lifetime_ref.name == special_idents::static_lifetime.name {\n             self.insert_lifetime(lifetime_ref, DefStaticRegion);\n             return;\n         }\n@@ -330,15 +330,15 @@ impl<'a> LifetimeContext<'a> {\n                                lifetime_ref: &ast::Lifetime) {\n         self.sess.span_err(\n             lifetime_ref.span,\n-            format!(\"use of undeclared lifetime name `'{}`\",\n+            format!(\"use of undeclared lifetime name `{}`\",\n                     token::get_name(lifetime_ref.name)).as_slice());\n     }\n \n     fn check_lifetime_names(&self, lifetimes: &Vec<ast::Lifetime>) {\n         for i in range(0, lifetimes.len()) {\n             let lifetime_i = lifetimes.get(i);\n \n-            let special_idents = [special_idents::statik];\n+            let special_idents = [special_idents::static_lifetime];\n             for lifetime in lifetimes.iter() {\n                 if special_idents.iter().any(|&i| i.name == lifetime.name) {\n                     self.sess.span_err(\n@@ -354,7 +354,7 @@ impl<'a> LifetimeContext<'a> {\n                 if lifetime_i.name == lifetime_j.name {\n                     self.sess.span_err(\n                         lifetime_j.span,\n-                        format!(\"lifetime name `'{}` declared twice in \\\n+                        format!(\"lifetime name `{}` declared twice in \\\n                                 the same scope\",\n                                 token::get_name(lifetime_j.name)).as_slice());\n                 }"}, {"sha": "14c8d5454aac8f58f1202024460b349180f75ce9", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -59,6 +59,7 @@ use middle::trans::expr;\n use middle::trans::foreign;\n use middle::trans::glue;\n use middle::trans::inline;\n+use middle::trans::intrinsic;\n use middle::trans::machine;\n use middle::trans::machine::{llalign_of_min, llsize_of, llsize_of_real};\n use middle::trans::meth;\n@@ -2329,6 +2330,11 @@ pub fn trans_crate(krate: ast::Crate,\n \n     let ccx = CrateContext::new(llmod_id.as_slice(), tcx, exp_map2,\n                                 Sha256::new(), link_meta, reachable);\n+\n+    // First, verify intrinsics.\n+    intrinsic::check_intrinsics(&ccx);\n+\n+    // Next, translate the module.\n     {\n         let _icx = push_ctxt(\"text\");\n         trans_mod(&ccx, &krate.module);"}, {"sha": "648a2c335e6860f0121e49840b5272e37953c1bf", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -390,7 +390,7 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n                     ast_map::NodeExpr(e) => e.span,\n                     _ => fail!(\"transmute has non-expr arg\"),\n                 };\n-                ccx.sess().span_fatal(sp,\n+                ccx.sess().span_bug(sp,\n                     format!(\"transmute called on types with different sizes: \\\n                              {} ({} bit{}) to \\\n                              {} ({} bit{})\",\n@@ -564,3 +564,41 @@ pub fn trans_intrinsic(ccx: &CrateContext,\n     }\n     fcx.cleanup();\n }\n+\n+/// Performs late verification that intrinsics are used correctly. At present,\n+/// the only intrinsic that needs such verification is `transmute`.\n+pub fn check_intrinsics(ccx: &CrateContext) {\n+    for transmute_restriction in ccx.tcx\n+                                    .transmute_restrictions\n+                                    .borrow()\n+                                    .iter() {\n+        let llfromtype = type_of::sizing_type_of(ccx,\n+                                                 transmute_restriction.from);\n+        let lltotype = type_of::sizing_type_of(ccx,\n+                                               transmute_restriction.to);\n+        let from_type_size = machine::llbitsize_of_real(ccx, llfromtype);\n+        let to_type_size = machine::llbitsize_of_real(ccx, lltotype);\n+        if from_type_size != to_type_size {\n+            ccx.sess()\n+               .span_err(transmute_restriction.span,\n+                format!(\"transmute called on types with different sizes: \\\n+                         {} ({} bit{}) to {} ({} bit{})\",\n+                        ty_to_str(ccx.tcx(), transmute_restriction.from),\n+                        from_type_size as uint,\n+                        if from_type_size == 1 {\n+                            \"\"\n+                        } else {\n+                            \"s\"\n+                        },\n+                        ty_to_str(ccx.tcx(), transmute_restriction.to),\n+                        to_type_size as uint,\n+                        if to_type_size == 1 {\n+                            \"\"\n+                        } else {\n+                            \"s\"\n+                        }).as_slice());\n+        }\n+    }\n+    ccx.sess().abort_if_errors();\n+}\n+"}, {"sha": "02300fccdae16402bcadd0363ad4f4f52c3f0750", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -235,6 +235,17 @@ pub enum AutoRef {\n     AutoBorrowObj(Region, ast::Mutability),\n }\n \n+/// A restriction that certain types must be the same size. The use of\n+/// `transmute` gives rise to these restrictions.\n+pub struct TransmuteRestriction {\n+    /// The span from whence the restriction comes.\n+    pub span: Span,\n+    /// The type being transmuted from.\n+    pub from: t,\n+    /// The type being transmuted to.\n+    pub to: t,\n+}\n+\n /// The data structure to keep track of all the information that typechecker\n /// generates so that so that it can be reused and doesn't have to be redone\n /// later on.\n@@ -357,6 +368,11 @@ pub struct ctxt {\n \n     pub node_lint_levels: RefCell<HashMap<(ast::NodeId, lint::Lint),\n                                           (lint::Level, lint::LintSource)>>,\n+\n+    /// The types that must be asserted to be the same size for `transmute`\n+    /// to be valid. We gather up these restrictions in the intrinsicck pass\n+    /// and check them in trans.\n+    pub transmute_restrictions: RefCell<Vec<TransmuteRestriction>>,\n }\n \n pub enum tbox_flag {\n@@ -1118,6 +1134,7 @@ pub fn mk_ctxt(s: Session,\n         vtable_map: RefCell::new(FnvHashMap::new()),\n         dependency_formats: RefCell::new(HashMap::new()),\n         node_lint_levels: RefCell::new(HashMap::new()),\n+        transmute_restrictions: RefCell::new(Vec::new()),\n     }\n }\n \n@@ -2711,8 +2728,7 @@ pub fn pat_ty(cx: &ctxt, pat: &ast::Pat) -> t {\n //\n // NB (2): This type doesn't provide type parameter substitutions; e.g. if you\n // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&int) -> int\"\n-// instead of \"fn(t) -> T with T = int\". If this isn't what you want, see\n-// expr_ty_params_and_ty() below.\n+// instead of \"fn(t) -> T with T = int\".\n pub fn expr_ty(cx: &ctxt, expr: &ast::Expr) -> t {\n     return node_id_to_type(cx, expr.id);\n }\n@@ -4514,9 +4530,10 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n             ty_uniq(_) => {\n                 byte!(10);\n             }\n-            ty_vec(m, Some(_)) => {\n+            ty_vec(m, Some(n)) => {\n                 byte!(11);\n                 mt(&mut state, m);\n+                n.hash(&mut state);\n                 1u8.hash(&mut state);\n             }\n             ty_vec(m, None) => {"}, {"sha": "f380004fb081e7cccf564928794eed18c9396812", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -724,6 +724,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                                  .collect();\n                 ty::mk_tup(tcx, flds)\n             }\n+            ast::TyParen(ref typ) => ast_ty_to_ty(this, rscope, &**typ),\n             ast::TyBareFn(ref bf) => {\n                 if bf.decl.variadic && bf.abi != abi::C {\n                     tcx.sess.span_err(ast_ty.span,"}, {"sha": "b9933fed296d8e7ac1609723d3a367b94961524c", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -3099,9 +3099,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                         /* this cast is only allowed from &[T] to *T or\n                         &T to *T. */\n                         match (&ty::get(te).sty, &ty::get(t_1).sty) {\n-                            (&ty::ty_rptr(_, mt1), &ty::ty_ptr(mt2))\n-                            if types_compatible(fcx, e.span,\n-                                                mt1.ty, mt2.ty) => {\n+                            (&ty::ty_rptr(_, ty::mt { ty: mt1, mutbl: ast::MutImmutable }),\n+                             &ty::ty_ptr(ty::mt { ty: mt2, mutbl: ast::MutImmutable }))\n+                            if types_compatible(fcx, e.span, mt1, mt2) => {\n                                 /* this case is allowed */\n                             }\n                             _ => {"}, {"sha": "4d396ed4f6e5cccfaa7ecc6fd5ddf9b68394a2e5", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -1140,6 +1140,7 @@ impl<'a> Rebuilder<'a> {\n                     }\n                     ast::TyTup(new_tys)\n                 }\n+                ast::TyParen(ref typ) => ast::TyParen(build_to(*typ, to)),\n                 ref other => other.clone()\n             };\n             box(GC) ast::Ty { id: from.id, node: new_node, span: from.span }\n@@ -1505,7 +1506,8 @@ impl LifeGiver {\n     fn give_lifetime(&self) -> ast::Lifetime {\n         let mut lifetime;\n         loop {\n-            let s = num_to_str(self.counter.get());\n+            let mut s = String::from_str(\"'\");\n+            s.push_str(num_to_str(self.counter.get()).as_slice());\n             if !self.taken.contains(&s) {\n                 lifetime = name_to_dummy_lifetime(\n                                     token::str_to_ident(s.as_slice()).name);"}, {"sha": "7d74b8c7296522f1a5f187173a005235c41f67bd", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -126,9 +126,11 @@ impl<'a> PluginLoader<'a> {\n         };\n \n         unsafe {\n-            let registrar: PluginRegistrarFun =\n+            let registrar =\n                 match lib.symbol(symbol.as_slice()) {\n-                    Ok(registrar) => registrar,\n+                    Ok(registrar) => {\n+                        mem::transmute::<*u8,PluginRegistrarFun>(registrar)\n+                    }\n                     // again fatal if we can't register macros\n                     Err(err) => self.sess.span_fatal(vi.span, err.as_slice())\n                 };"}, {"sha": "80f3508d0cd354bd678b7fc3a8592803eba3e294", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -162,7 +162,7 @@ pub fn bound_region_to_str(cx: &ctxt,\n \n     match br {\n         BrNamed(_, name) => {\n-            format!(\"{}'{}{}\", prefix, token::get_name(name), space_str)\n+            format!(\"{}{}{}\", prefix, token::get_name(name), space_str)\n         }\n         BrAnon(_) => prefix.to_string(),\n         BrFresh(_) => prefix.to_string(),"}, {"sha": "7e68be09f1d56041d365163db73c5e3a3b8fc6e7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -60,7 +60,7 @@ impl<T: Clean<U>, U> Clean<VecPerParamSpace<U>> for VecPerParamSpace<T> {\n     }\n }\n \n-impl<T: Clean<U>, U> Clean<U> for Gc<T> {\n+impl<T: 'static + Clean<U>, U> Clean<U> for Gc<T> {\n     fn clean(&self) -> U {\n         (**self).clean()\n     }\n@@ -1198,6 +1198,7 @@ impl Clean<Type> for ast::Ty {\n             TyClosure(ref c, region) => Closure(box c.clean(), region.clean()),\n             TyProc(ref c) => Proc(box c.clean()),\n             TyBareFn(ref barefn) => BareFunction(box barefn.clean()),\n+            TyParen(ref ty) => ty.clean(),\n             TyBot => Bottom,\n             ref x => fail!(\"Unimplemented type {:?}\", x),\n         }"}, {"sha": "e5bced8038baf49f2a325a51497e6c739906d17a", "filename": "src/librustdoc/plugins.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustdoc%2Fplugins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustdoc%2Fplugins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fplugins.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -12,6 +12,7 @@ use clean;\n \n use dl = std::dynamic_lib;\n use serialize::json;\n+use std::mem;\n use std::string::String;\n \n pub type PluginJson = Option<(String, json::Json)>;\n@@ -45,9 +46,11 @@ impl PluginManager {\n         let x = self.prefix.join(libname(name));\n         let lib_result = dl::DynamicLibrary::open(Some(&x));\n         let lib = lib_result.unwrap();\n-        let plugin = unsafe { lib.symbol(\"rustdoc_plugin_entrypoint\") }.unwrap();\n+        unsafe {\n+            let plugin = lib.symbol(\"rustdoc_plugin_entrypoint\").unwrap();\n+            self.callbacks.push(mem::transmute::<*u8,PluginCallback>(plugin));\n+        }\n         self.dylibs.push(lib);\n-        self.callbacks.push(plugin);\n     }\n \n     /// Load a normal Rust function as a plugin."}, {"sha": "3fece698a1de491726f07a29255eea5935d6a985", "filename": "src/librustrt/mutex.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustrt%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustrt%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fmutex.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -115,6 +115,18 @@ impl StaticNativeMutex {\n     ///     // critical section...\n     /// } // automatically unlocked in `_guard`'s destructor\n     /// ```\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe because it will not function correctly if this\n+    /// mutex has been *moved* since it was last used. The mutex can move an\n+    /// arbitrary number of times before its first usage, but once a mutex has\n+    /// been used once it is no longer allowed to move (or otherwise it invokes\n+    /// undefined behavior).\n+    ///\n+    /// Additionally, this type does not take into account any form of\n+    /// scheduling model. This will unconditionally block the *os thread* which\n+    /// is not always desired.\n     pub unsafe fn lock<'a>(&'a self) -> LockGuard<'a> {\n         self.inner.lock();\n \n@@ -123,6 +135,10 @@ impl StaticNativeMutex {\n \n     /// Attempts to acquire the lock. The value returned is `Some` if\n     /// the attempt succeeded.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe for the same reasons as `lock`.\n     pub unsafe fn trylock<'a>(&'a self) -> Option<LockGuard<'a>> {\n         if self.inner.trylock() {\n             Some(LockGuard { lock: self })\n@@ -135,6 +151,12 @@ impl StaticNativeMutex {\n     ///\n     /// These needs to be paired with a call to `.unlock_noguard`. Prefer using\n     /// `.lock`.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe for the same reasons as `lock`. Additionally, this\n+    /// does not guarantee that the mutex will ever be unlocked, and it is\n+    /// undefined to drop an already-locked mutex.\n     pub unsafe fn lock_noguard(&self) { self.inner.lock() }\n \n     /// Attempts to acquire the lock without creating a\n@@ -143,22 +165,42 @@ impl StaticNativeMutex {\n     ///\n     /// If `true` is returned, this needs to be paired with a call to\n     /// `.unlock_noguard`. Prefer using `.trylock`.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe for the same reasons as `lock_noguard`.\n     pub unsafe fn trylock_noguard(&self) -> bool {\n         self.inner.trylock()\n     }\n \n     /// Unlocks the lock. This assumes that the current thread already holds the\n     /// lock.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe for the same reasons as `lock`. Additionally, it\n+    /// is not guaranteed that this is unlocking a previously locked mutex. It\n+    /// is undefined to unlock an unlocked mutex.\n     pub unsafe fn unlock_noguard(&self) { self.inner.unlock() }\n \n     /// Block on the internal condition variable.\n     ///\n     /// This function assumes that the lock is already held. Prefer\n     /// using `LockGuard.wait` since that guarantees that the lock is\n     /// held.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe for the same reasons as `lock`. Additionally, this\n+    /// is unsafe because the mutex may not be currently locked.\n     pub unsafe fn wait_noguard(&self) { self.inner.wait() }\n \n     /// Signals a thread in `wait` to wake up\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe for the same reasons as `lock`. Additionally, this\n+    /// is unsafe because the mutex may not be currently locked.\n     pub unsafe fn signal_noguard(&self) { self.inner.signal() }\n \n     /// This function is especially unsafe because there are no guarantees made\n@@ -181,6 +223,7 @@ impl NativeMutex {\n     /// already hold the lock.\n     ///\n     /// # Example\n+    ///\n     /// ```rust\n     /// use std::rt::mutex::NativeMutex;\n     /// unsafe {\n@@ -192,12 +235,22 @@ impl NativeMutex {\n     ///     } // automatically unlocked in `_guard`'s destructor\n     /// }\n     /// ```\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe due to the same reasons as\n+    /// `StaticNativeMutex::lock`.\n     pub unsafe fn lock<'a>(&'a self) -> LockGuard<'a> {\n         self.inner.lock()\n     }\n \n     /// Attempts to acquire the lock. The value returned is `Some` if\n     /// the attempt succeeded.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe due to the same reasons as\n+    /// `StaticNativeMutex::trylock`.\n     pub unsafe fn trylock<'a>(&'a self) -> Option<LockGuard<'a>> {\n         self.inner.trylock()\n     }\n@@ -206,6 +259,11 @@ impl NativeMutex {\n     ///\n     /// These needs to be paired with a call to `.unlock_noguard`. Prefer using\n     /// `.lock`.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe due to the same reasons as\n+    /// `StaticNativeMutex::lock_noguard`.\n     pub unsafe fn lock_noguard(&self) { self.inner.lock_noguard() }\n \n     /// Attempts to acquire the lock without creating a\n@@ -214,22 +272,42 @@ impl NativeMutex {\n     ///\n     /// If `true` is returned, this needs to be paired with a call to\n     /// `.unlock_noguard`. Prefer using `.trylock`.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe due to the same reasons as\n+    /// `StaticNativeMutex::trylock_noguard`.\n     pub unsafe fn trylock_noguard(&self) -> bool {\n         self.inner.trylock_noguard()\n     }\n \n     /// Unlocks the lock. This assumes that the current thread already holds the\n     /// lock.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe due to the same reasons as\n+    /// `StaticNativeMutex::unlock_noguard`.\n     pub unsafe fn unlock_noguard(&self) { self.inner.unlock_noguard() }\n \n     /// Block on the internal condition variable.\n     ///\n     /// This function assumes that the lock is already held. Prefer\n     /// using `LockGuard.wait` since that guarantees that the lock is\n     /// held.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe due to the same reasons as\n+    /// `StaticNativeMutex::wait_noguard`.\n     pub unsafe fn wait_noguard(&self) { self.inner.wait_noguard() }\n \n     /// Signals a thread in `wait` to wake up\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is unsafe due to the same reasons as\n+    /// `StaticNativeMutex::signal_noguard`.\n     pub unsafe fn signal_noguard(&self) { self.inner.signal_noguard() }\n }\n "}, {"sha": "aebed5a8829c5290c3acc2965ee623934c7086c7", "filename": "src/librustrt/unwind.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustrt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibrustrt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Funwind.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -73,7 +73,6 @@ use libc::c_void;\n \n use local::Local;\n use task::{Task, Result};\n-use exclusive::Exclusive;\n \n use uw = libunwind;\n \n@@ -88,7 +87,6 @@ struct Exception {\n }\n \n pub type Callback = fn(msg: &Any:Send, file: &'static str, line: uint);\n-type Queue = Exclusive<Vec<Callback>>;\n \n // Variables used for invoking callbacks when a task starts to unwind.\n //"}, {"sha": "76dbfa8c29ec35bfd88588bab7c55bb1166fca28", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -134,7 +134,7 @@ impl DynamicLibrary {\n     }\n \n     /// Access the value at the symbol of the dynamic library\n-    pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<T, String> {\n+    pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<*T, String> {\n         // This function should have a lifetime constraint of 'a on\n         // T but that feature is still unimplemented\n \n@@ -158,6 +158,7 @@ mod test {\n     use super::*;\n     use prelude::*;\n     use libc;\n+    use mem;\n \n     #[test]\n     #[ignore(cfg(windows))] // FIXME #8818\n@@ -174,7 +175,7 @@ mod test {\n         let cosine: extern fn(libc::c_double) -> libc::c_double = unsafe {\n             match libm.symbol(\"cos\") {\n                 Err(error) => fail!(\"Could not load function cos: {}\", error),\n-                Ok(cosine) => cosine\n+                Ok(cosine) => mem::transmute::<*u8, _>(cosine)\n             }\n         };\n "}, {"sha": "10dfec0f566091cab9072b7853e206c6a36f7e76", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 212, "deletions": 59, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -52,9 +52,11 @@ fs::unlink(&path);\n use c_str::ToCStr;\n use clone::Clone;\n use collections::Collection;\n+use io::standard_error;\n use io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n use io::{IoResult, IoError, FileStat, SeekStyle, Seek, Writer, Reader};\n use io::{Read, Truncate, SeekCur, SeekSet, ReadWrite, SeekEnd, Append};\n+use io::UpdateIoError;\n use io;\n use iter::Iterator;\n use kinds::Send;\n@@ -67,6 +69,7 @@ use result::{Err, Ok};\n use rt::rtio::LocalIo;\n use rt::rtio;\n use slice::ImmutableVector;\n+use string::String;\n use vec::Vec;\n \n /// Unconstrained file access type that exposes read and write operations\n@@ -128,25 +131,29 @@ impl File {\n     pub fn open_mode(path: &Path,\n                      mode: FileMode,\n                      access: FileAccess) -> IoResult<File> {\n-        let mode = match mode {\n+        let rtio_mode = match mode {\n             Open => rtio::Open,\n             Append => rtio::Append,\n             Truncate => rtio::Truncate,\n         };\n-        let access = match access {\n+        let rtio_access = match access {\n             Read => rtio::Read,\n             Write => rtio::Write,\n             ReadWrite => rtio::ReadWrite,\n         };\n-        LocalIo::maybe_raise(|io| {\n-            io.fs_open(&path.to_c_str(), mode, access).map(|fd| {\n+        let err = LocalIo::maybe_raise(|io| {\n+            io.fs_open(&path.to_c_str(), rtio_mode, rtio_access).map(|fd| {\n                 File {\n                     path: path.clone(),\n                     fd: fd,\n                     last_nread: -1\n                 }\n             })\n-        }).map_err(IoError::from_rtio_error)\n+        }).map_err(IoError::from_rtio_error);\n+        err.update_err(\"couldn't open file\", |e| {\n+            format!(\"{}; path={}; mode={}; access={}\", e, path.display(),\n+                mode_string(mode), access_string(access))\n+        })\n     }\n \n     /// Attempts to open a file in read-only mode. This function is equivalent to\n@@ -185,6 +192,7 @@ impl File {\n     /// ```\n     pub fn create(path: &Path) -> IoResult<File> {\n         File::open_mode(path, Truncate, Write)\n+            .update_desc(\"couldn't create file\")\n     }\n \n     /// Returns the original path which was used to open this file.\n@@ -196,15 +204,19 @@ impl File {\n     /// device. This will flush any internal buffers necessary to perform this\n     /// operation.\n     pub fn fsync(&mut self) -> IoResult<()> {\n-        self.fd.fsync().map_err(IoError::from_rtio_error)\n+        let err = self.fd.fsync().map_err(IoError::from_rtio_error);\n+        err.update_err(\"couldn't fsync file\",\n+                       |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n \n     /// This function is similar to `fsync`, except that it may not synchronize\n     /// file metadata to the filesystem. This is intended for use case which\n     /// must synchronize content, but don't need the metadata on disk. The goal\n     /// of this method is to reduce disk operations.\n     pub fn datasync(&mut self) -> IoResult<()> {\n-        self.fd.datasync().map_err(IoError::from_rtio_error)\n+        let err = self.fd.datasync().map_err(IoError::from_rtio_error);\n+        err.update_err(\"couldn't datasync file\",\n+                       |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n \n     /// Either truncates or extends the underlying file, updating the size of\n@@ -216,7 +228,10 @@ impl File {\n     /// will be extended to `size` and have all of the intermediate data filled\n     /// in with 0s.\n     pub fn truncate(&mut self, size: i64) -> IoResult<()> {\n-        self.fd.truncate(size).map_err(IoError::from_rtio_error)\n+        let err = self.fd.truncate(size).map_err(IoError::from_rtio_error);\n+        err.update_err(\"couldn't truncate file\", |e| {\n+            format!(\"{}; path={}; size={}\", e, self.path.display(), size)\n+        })\n     }\n \n     /// Tests whether this stream has reached EOF.\n@@ -229,10 +244,12 @@ impl File {\n \n     /// Queries information about the underlying file.\n     pub fn stat(&mut self) -> IoResult<FileStat> {\n-        match self.fd.fstat() {\n+        let err = match self.fd.fstat() {\n             Ok(s) => Ok(from_rtio(s)),\n             Err(e) => Err(IoError::from_rtio_error(e)),\n-        }\n+        };\n+        err.update_err(\"couldn't fstat file\",\n+                       |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n }\n \n@@ -258,9 +275,11 @@ impl File {\n /// user lacks permissions to remove the file, or if some other filesystem-level\n /// error occurs.\n pub fn unlink(path: &Path) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| {\n+    let err = LocalIo::maybe_raise(|io| {\n         io.fs_unlink(&path.to_c_str())\n-    }).map_err(IoError::from_rtio_error)\n+    }).map_err(IoError::from_rtio_error);\n+    err.update_err(\"couldn't unlink path\",\n+                   |e| format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Given a path, query the file system to get information about a file,\n@@ -285,10 +304,12 @@ pub fn unlink(path: &Path) -> IoResult<()> {\n /// to perform a `stat` call on the given path or if there is no entry in the\n /// filesystem at the provided path.\n pub fn stat(path: &Path) -> IoResult<FileStat> {\n-    match LocalIo::maybe_raise(|io| io.fs_stat(&path.to_c_str())) {\n+    let err = match LocalIo::maybe_raise(|io| io.fs_stat(&path.to_c_str())) {\n         Ok(s) => Ok(from_rtio(s)),\n         Err(e) => Err(IoError::from_rtio_error(e)),\n-    }\n+    };\n+    err.update_err(\"couldn't stat path\",\n+                   |e| format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Perform the same operation as the `stat` function, except that this\n@@ -300,10 +321,12 @@ pub fn stat(path: &Path) -> IoResult<FileStat> {\n ///\n /// See `stat`\n pub fn lstat(path: &Path) -> IoResult<FileStat> {\n-    match LocalIo::maybe_raise(|io| io.fs_lstat(&path.to_c_str())) {\n+    let err = match LocalIo::maybe_raise(|io| io.fs_lstat(&path.to_c_str())) {\n         Ok(s) => Ok(from_rtio(s)),\n         Err(e) => Err(IoError::from_rtio_error(e)),\n-    }\n+    };\n+    err.update_err(\"couldn't lstat path\",\n+                   |e| format!(\"{}; path={}\", e, path.display()))\n }\n \n fn from_rtio(s: rtio::FileStat) -> FileStat {\n@@ -359,9 +382,12 @@ fn from_rtio(s: rtio::FileStat) -> FileStat {\n /// permissions to view the contents, or if some other intermittent I/O error\n /// occurs.\n pub fn rename(from: &Path, to: &Path) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| {\n+    let err = LocalIo::maybe_raise(|io| {\n         io.fs_rename(&from.to_c_str(), &to.to_c_str())\n-    }).map_err(IoError::from_rtio_error)\n+    }).map_err(IoError::from_rtio_error);\n+    err.update_err(\"couldn't rename path\", |e| {\n+        format!(\"{}; from={}; to={}\", e, from.display(), to.display())\n+    })\n }\n \n /// Copies the contents of one file to another. This function will also\n@@ -393,12 +419,17 @@ pub fn rename(from: &Path, to: &Path) -> IoResult<()> {\n /// ensured to not exist, there is nothing preventing the destination from\n /// being created and then destroyed by this operation.\n pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n+    fn update_err<T>(result: IoResult<T>, from: &Path, to: &Path) -> IoResult<T> {\n+        result.update_err(\"couldn't copy path\",\n+            |e| format!(\"{}; from={}; to={}\", e, from.display(), to.display()))\n+    }\n+\n     if !from.is_file() {\n-        return Err(IoError {\n+        return update_err(Err(IoError {\n             kind: io::MismatchedFileTypeForOperation,\n             desc: \"the source path is not an existing file\",\n-            detail: None,\n-        })\n+            detail: None\n+        }), from, to)\n     }\n \n     let mut reader = try!(File::open(from));\n@@ -409,12 +440,12 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n         let amt = match reader.read(buf) {\n             Ok(n) => n,\n             Err(ref e) if e.kind == io::EndOfFile => { break }\n-            Err(e) => return Err(e)\n+            Err(e) => return update_err(Err(e), from, to)\n         };\n         try!(writer.write(buf.slice_to(amt)));\n     }\n \n-    chmod(to, try!(from.stat()).perm)\n+    chmod(to, try!(update_err(from.stat(), from, to)).perm)\n }\n \n /// Changes the permission mode bits found on a file or a directory. This\n@@ -439,33 +470,45 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n /// Some possible error situations are not having the permission to\n /// change the attributes of a file or the file not existing.\n pub fn chmod(path: &Path, mode: io::FilePermission) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| {\n+    let err = LocalIo::maybe_raise(|io| {\n         io.fs_chmod(&path.to_c_str(), mode.bits() as uint)\n-    }).map_err(IoError::from_rtio_error)\n+    }).map_err(IoError::from_rtio_error);\n+    err.update_err(\"couldn't chmod path\", |e| {\n+        format!(\"{}; path={}; mode={}\", e, path.display(), mode)\n+    })\n }\n \n /// Change the user and group owners of a file at the specified path.\n pub fn chown(path: &Path, uid: int, gid: int) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| {\n+    let err = LocalIo::maybe_raise(|io| {\n         io.fs_chown(&path.to_c_str(), uid, gid)\n-    }).map_err(IoError::from_rtio_error)\n+    }).map_err(IoError::from_rtio_error);\n+    err.update_err(\"couldn't chown path\", |e| {\n+        format!(\"{}; path={}; uid={}; gid={}\", e, path.display(), uid, gid)\n+    })\n }\n \n /// Creates a new hard link on the filesystem. The `dst` path will be a\n /// link pointing to the `src` path. Note that systems often require these\n /// two paths to both be located on the same filesystem.\n pub fn link(src: &Path, dst: &Path) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| {\n+    let err = LocalIo::maybe_raise(|io| {\n         io.fs_link(&src.to_c_str(), &dst.to_c_str())\n-    }).map_err(IoError::from_rtio_error)\n+    }).map_err(IoError::from_rtio_error);\n+    err.update_err(\"couldn't link path\", |e| {\n+        format!(\"{}; src={}; dest={}\", e, src.display(), dst.display())\n+    })\n }\n \n /// Creates a new symbolic link on the filesystem. The `dst` path will be a\n /// symlink pointing to the `src` path.\n pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| {\n+    let err = LocalIo::maybe_raise(|io| {\n         io.fs_symlink(&src.to_c_str(), &dst.to_c_str())\n-    }).map_err(IoError::from_rtio_error)\n+    }).map_err(IoError::from_rtio_error);\n+    err.update_err(\"couldn't symlink path\", |e| {\n+        format!(\"{}; src={}; dest={}\", e, src.display(), dst.display())\n+    })\n }\n \n /// Reads a symlink, returning the file that the symlink points to.\n@@ -475,9 +518,11 @@ pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n /// This function will return an error on failure. Failure conditions include\n /// reading a file that does not exist or reading a file which is not a symlink.\n pub fn readlink(path: &Path) -> IoResult<Path> {\n-    LocalIo::maybe_raise(|io| {\n+    let err = LocalIo::maybe_raise(|io| {\n         Ok(Path::new(try!(io.fs_readlink(&path.to_c_str()))))\n-    }).map_err(IoError::from_rtio_error)\n+    }).map_err(IoError::from_rtio_error);\n+    err.update_err(\"couldn't resolve symlink for path\",\n+                   |e| format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Create a new, empty directory at the provided path\n@@ -498,9 +543,12 @@ pub fn readlink(path: &Path) -> IoResult<Path> {\n /// This call will return an error if the user lacks permissions to make a new\n /// directory at the provided path, or if the directory already exists.\n pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| {\n+    let err = LocalIo::maybe_raise(|io| {\n         io.fs_mkdir(&path.to_c_str(), mode.bits() as uint)\n-    }).map_err(IoError::from_rtio_error)\n+    }).map_err(IoError::from_rtio_error);\n+    err.update_err(\"couldn't create directory\", |e| {\n+        format!(\"{}; path={}; mode={}\", e, path.display(), mode)\n+    })\n }\n \n /// Remove an existing, empty directory\n@@ -520,9 +568,11 @@ pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n /// This call will return an error if the user lacks permissions to remove the\n /// directory at the provided path, or if the directory isn't empty.\n pub fn rmdir(path: &Path) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| {\n+    let err = LocalIo::maybe_raise(|io| {\n         io.fs_rmdir(&path.to_c_str())\n-    }).map_err(IoError::from_rtio_error)\n+    }).map_err(IoError::from_rtio_error);\n+    err.update_err(\"couldn't remove directory\",\n+                   |e| format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Retrieve a vector containing all entries within a provided directory\n@@ -557,19 +607,25 @@ pub fn rmdir(path: &Path) -> IoResult<()> {\n /// permissions to view the contents or if the `path` points at a non-directory\n /// file\n pub fn readdir(path: &Path) -> IoResult<Vec<Path>> {\n-    LocalIo::maybe_raise(|io| {\n+    let err = LocalIo::maybe_raise(|io| {\n         Ok(try!(io.fs_readdir(&path.to_c_str(), 0)).move_iter().map(|a| {\n             Path::new(a)\n         }).collect())\n-    }).map_err(IoError::from_rtio_error)\n+    }).map_err(IoError::from_rtio_error);\n+    err.update_err(\"couldn't read directory\",\n+                   |e| format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Returns an iterator which will recursively walk the directory structure\n /// rooted at `path`. The path given will not be iterated over, and this will\n /// perform iteration in some top-down order.  The contents of unreadable\n /// subdirectories are ignored.\n pub fn walk_dir(path: &Path) -> IoResult<Directories> {\n-    Ok(Directories { stack: try!(readdir(path)) })\n+    Ok(Directories {\n+        stack: try!(readdir(path).update_err(\"couldn't walk directory\",\n+                                             |e| format!(\"{}; path={}\",\n+                                                         e, path.display())))\n+    })\n }\n \n /// An iterator which walks over a directory\n@@ -582,7 +638,12 @@ impl Iterator<Path> for Directories {\n         match self.stack.pop() {\n             Some(path) => {\n                 if path.is_dir() {\n-                    match readdir(&path) {\n+                    let result = readdir(&path)\n+                        .update_err(\"couldn't advance Directories iterator\",\n+                                    |e| format!(\"{}; path={}\",\n+                                                e, path.display()));\n+\n+                    match result {\n                         Ok(dirs) => { self.stack.push_all_move(dirs); }\n                         Err(..) => {}\n                     }\n@@ -614,7 +675,11 @@ pub fn mkdir_recursive(path: &Path, mode: FilePermission) -> IoResult<()> {\n     for c in comps {\n         curpath.push(c);\n \n-        match mkdir(&curpath, mode) {\n+        let result = mkdir(&curpath, mode)\n+            .update_err(\"couldn't recursively mkdir\",\n+                        |e| format!(\"{}; path={}\", e, path.display()));\n+\n+        match result {\n             Err(mkdir_err) => {\n                 // already exists ?\n                 if try!(stat(&curpath)).kind != io::TypeDirectory {\n@@ -639,26 +704,38 @@ pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n     let mut rm_stack = Vec::new();\n     rm_stack.push(path.clone());\n \n+    fn rmdir_failed(err: &IoError, path: &Path) -> String {\n+        format!(\"rmdir_recursive failed; path={}; cause={}\",\n+                path.display(), err)\n+    }\n+\n+    fn update_err<T>(err: IoResult<T>, path: &Path) -> IoResult<T> {\n+        err.update_err(\"couldn't recursively rmdir\",\n+                       |e| rmdir_failed(e, path))\n+    }\n+\n     while !rm_stack.is_empty() {\n-        let children = try!(readdir(rm_stack.last().unwrap()));\n+        let children = try!(readdir(rm_stack.last().unwrap())\n+            .update_detail(|e| rmdir_failed(e, path)));\n+\n         let mut has_child_dir = false;\n \n         // delete all regular files in the way and push subdirs\n         // on the stack\n         for child in children.move_iter() {\n             // FIXME(#12795) we should use lstat in all cases\n             let child_type = match cfg!(windows) {\n-                true => try!(stat(&child)).kind,\n-                false => try!(lstat(&child)).kind\n+                true => try!(update_err(stat(&child), path)),\n+                false => try!(update_err(lstat(&child), path))\n             };\n \n-            if child_type == io::TypeDirectory {\n+            if child_type.kind == io::TypeDirectory {\n                 rm_stack.push(child);\n                 has_child_dir = true;\n             } else {\n                 // we can carry on safely if the file is already gone\n                 // (eg: deleted by someone else since readdir)\n-                match unlink(&child) {\n+                match update_err(unlink(&child), path) {\n                     Ok(()) => (),\n                     Err(ref e) if e.kind == io::FileNotFound => (),\n                     Err(e) => return Err(e)\n@@ -668,7 +745,8 @@ pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n \n         // if no subdir was found, let's pop and delete\n         if !has_child_dir {\n-            match rmdir(&rm_stack.pop().unwrap()) {\n+            let result = update_err(rmdir(&rm_stack.pop().unwrap()), path);\n+            match result {\n                 Ok(()) => (),\n                 Err(ref e) if e.kind == io::FileNotFound => (),\n                 Err(e) => return Err(e)\n@@ -685,35 +763,50 @@ pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n /// be in milliseconds.\n // FIXME(#10301) these arguments should not be u64\n pub fn change_file_times(path: &Path, atime: u64, mtime: u64) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| {\n+    let err = LocalIo::maybe_raise(|io| {\n         io.fs_utime(&path.to_c_str(), atime, mtime)\n-    }).map_err(IoError::from_rtio_error)\n+    }).map_err(IoError::from_rtio_error);\n+    err.update_err(\"couldn't change_file_times\",\n+                   |e| format!(\"{}; path={}\", e, path.display()))\n }\n \n impl Reader for File {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        match self.fd.read(buf) {\n+        fn update_err<T>(result: IoResult<T>, file: &File) -> IoResult<T> {\n+            result.update_err(\"couldn't read file\",\n+                              |e| format!(\"{}; path={}\",\n+                                          e, file.path.display()))\n+        }\n+\n+        let result = update_err(self.fd.read(buf)\n+                                    .map_err(IoError::from_rtio_error), self);\n+\n+        match result {\n             Ok(read) => {\n                 self.last_nread = read;\n                 match read {\n-                    0 => Err(io::standard_error(io::EndOfFile)),\n+                    0 => update_err(Err(standard_error(io::EndOfFile)), self),\n                     _ => Ok(read as uint)\n                 }\n             },\n-            Err(e) => Err(IoError::from_rtio_error(e)),\n+            Err(e) => Err(e)\n         }\n     }\n }\n \n impl Writer for File {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.fd.write(buf).map_err(IoError::from_rtio_error)\n+        let err = self.fd.write(buf).map_err(IoError::from_rtio_error);\n+        err.update_err(\"couldn't write to file\",\n+                       |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n }\n \n impl Seek for File {\n     fn tell(&self) -> IoResult<u64> {\n-        self.fd.tell().map_err(IoError::from_rtio_error)\n+        let err = self.fd.tell().map_err(IoError::from_rtio_error);\n+        err.update_err(\"couldn't retrieve file cursor (`tell`)\",\n+                       |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n \n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n@@ -722,14 +815,16 @@ impl Seek for File {\n             SeekCur => rtio::SeekCur,\n             SeekEnd => rtio::SeekEnd,\n         };\n-        match self.fd.seek(pos, style) {\n+        let err = match self.fd.seek(pos, style) {\n             Ok(_) => {\n                 // successful seek resets EOF indicator\n                 self.last_nread = -1;\n                 Ok(())\n             }\n             Err(e) => Err(IoError::from_rtio_error(e)),\n-        }\n+        };\n+        err.update_err(\"couldn't seek in file\",\n+                       |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n }\n \n@@ -779,6 +874,22 @@ impl path::Path {\n     }\n }\n \n+fn mode_string(mode: FileMode) -> &'static str {\n+    match mode {\n+        super::Open => \"open\",\n+        super::Append => \"append\",\n+        super::Truncate => \"truncate\"\n+    }\n+}\n+\n+fn access_string(access: FileAccess) -> &'static str {\n+    match access {\n+        super::Read => \"read\",\n+        super::Write => \"write\",\n+        super::ReadWrite => \"readwrite\"\n+    }\n+}\n+\n #[cfg(test)]\n #[allow(unused_imports)]\n mod test {\n@@ -801,6 +912,14 @@ mod test {\n         }\n     ) )\n \n+    macro_rules! error( ($e:expr, $s:expr) => (\n+        match $e {\n+            Ok(val) => fail!(\"Should have been an error, was {:?}\", val),\n+            Err(ref err) => assert!(err.to_str().as_slice().contains($s.as_slice()),\n+                                    format!(\"`{}` did not contain `{}`\", err, $s))\n+        }\n+    ) )\n+\n     struct TempDir(Path);\n \n     impl TempDir {\n@@ -856,13 +975,25 @@ mod test {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_that_does_not_exist.txt\");\n         let result = File::open_mode(filename, Open, Read);\n-        assert!(result.is_err());\n+\n+        error!(result, \"couldn't open file\");\n+        if cfg!(unix) {\n+            error!(result, \"no such file or directory\");\n+        }\n+        error!(result, format!(\"path={}; mode=open; access=read\", filename.display()));\n     })\n \n     iotest!(fn file_test_iounlinking_invalid_path_should_raise_condition() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_another_file_that_does_not_exist.txt\");\n-        assert!(unlink(filename).is_err());\n+\n+        let result = unlink(filename);\n+\n+        error!(result, \"couldn't unlink path\");\n+        if cfg!(unix) {\n+            error!(result, \"no such file or directory\");\n+        }\n+        error!(result, format!(\"path={}\", filename.display()));\n     })\n \n     iotest!(fn file_test_io_non_positional_read() {\n@@ -1091,6 +1222,22 @@ mod test {\n         assert!(dir.is_dir())\n     })\n \n+    iotest!(fn recursive_mkdir_failure() {\n+        let tmpdir = tmpdir();\n+        let dir = tmpdir.join(\"d1\");\n+        let file = dir.join(\"f1\");\n+\n+        check!(mkdir_recursive(&dir, io::UserRWX));\n+        check!(File::create(&file));\n+\n+        let result = mkdir_recursive(&file, io::UserRWX);\n+\n+        error!(result, \"couldn't recursively mkdir\");\n+        error!(result, \"couldn't create directory\");\n+        error!(result, \"mode=FilePermission { bits: 448 }\");\n+        error!(result, format!(\"path={}\", file.display()));\n+    })\n+\n     iotest!(fn recursive_mkdir_slash() {\n         check!(mkdir_recursive(&Path::new(\"/\"), io::UserRWX));\n     })\n@@ -1147,6 +1294,12 @@ mod test {\n     iotest!(fn copy_file_does_not_exist() {\n         let from = Path::new(\"test/nonexistent-bogus-path\");\n         let to = Path::new(\"test/other-bogus-path\");\n+\n+        error!(copy(&from, &to),\n+            format!(\"couldn't copy path (the source path is not an \\\n+                    existing file; from={}; to={})\",\n+                    from.display(), to.display()));\n+\n         match copy(&from, &to) {\n             Ok(..) => fail!(),\n             Err(..) => {"}, {"sha": "a7f84899a622e1703858bab178a2fe3059a6bdbc", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -232,7 +232,7 @@ use owned::Box;\n use result::{Ok, Err, Result};\n use rt::rtio;\n use slice::{Vector, MutableVector, ImmutableVector};\n-use str::{StrSlice, StrAllocating};\n+use str::{Str, StrSlice, StrAllocating};\n use str;\n use string::String;\n use uint;\n@@ -309,6 +309,7 @@ impl IoError {\n     /// struct is filled with an allocated string describing the error\n     /// in more detail, retrieved from the operating system.\n     pub fn from_errno(errno: uint, detail: bool) -> IoError {\n+\n         #[cfg(windows)]\n         fn get_err(errno: i32) -> (IoErrorKind, &'static str) {\n             match errno {\n@@ -388,8 +389,8 @@ impl IoError {\n         IoError {\n             kind: kind,\n             desc: desc,\n-            detail: if detail {\n-                Some(os::error_string(errno))\n+            detail: if detail && kind == OtherIoError {\n+                Some(os::error_string(errno).as_slice().chars().map(|c| c.to_lowercase()).collect())\n             } else {\n                 None\n             },\n@@ -420,10 +421,13 @@ impl IoError {\n \n impl fmt::Show for IoError {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(fmt, \"{}\", self.desc));\n-        match self.detail {\n-            Some(ref s) => write!(fmt, \" ({})\", *s),\n-            None => Ok(())\n+        match *self {\n+            IoError { kind: OtherIoError, desc: \"unknown error\", detail: Some(ref detail) } =>\n+                write!(fmt, \"{}\", detail),\n+            IoError { detail: None, desc, .. } =>\n+                write!(fmt, \"{}\", desc),\n+            IoError { detail: Some(ref detail), desc, .. } =>\n+                write!(fmt, \"{} ({})\", desc, detail)\n         }\n     }\n }\n@@ -484,6 +488,37 @@ pub enum IoErrorKind {\n     NoProgress,\n }\n \n+/// A trait that lets you add a `detail` to an IoError easily\n+trait UpdateIoError<T> {\n+    /// Returns an IoError with updated description and detail\n+    fn update_err(self, desc: &'static str, detail: |&IoError| -> String) -> Self;\n+\n+    /// Returns an IoError with updated detail\n+    fn update_detail(self, detail: |&IoError| -> String) -> Self;\n+\n+    /// Returns an IoError with update description\n+    fn update_desc(self, desc: &'static str) -> Self;\n+}\n+\n+impl<T> UpdateIoError<T> for IoResult<T> {\n+    fn update_err(self, desc: &'static str, detail: |&IoError| -> String) -> IoResult<T> {\n+        self.map_err(|mut e| {\n+            let detail = detail(&e);\n+            e.desc = desc;\n+            e.detail = Some(detail);\n+            e\n+        })\n+    }\n+\n+    fn update_detail(self, detail: |&IoError| -> String) -> IoResult<T> {\n+        self.map_err(|mut e| { e.detail = Some(detail(&e)); e })\n+    }\n+\n+    fn update_desc(self, desc: &'static str) -> IoResult<T> {\n+        self.map_err(|mut e| { e.desc = desc; e })\n+    }\n+}\n+\n static NO_PROGRESS_LIMIT: uint = 1000;\n \n /// A trait for objects which are byte-oriented streams. Readers are defined by\n@@ -1577,7 +1612,7 @@ pub fn standard_error(kind: IoErrorKind) -> IoError {\n         ConnectionAborted => \"connection aborted\",\n         NotConnected => \"not connected\",\n         BrokenPipe => \"broken pipe\",\n-        PathAlreadyExists => \"file exists\",\n+        PathAlreadyExists => \"file already exists\",\n         PathDoesntExist => \"no such file\",\n         MismatchedFileTypeForOperation => \"mismatched file type\",\n         ResourceUnavailable => \"resource unavailable\","}, {"sha": "e2a963c5a878d4fc54d8c7114305dc59292e84b1", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -873,12 +873,12 @@ mod imp {\n             Err(..) => return Ok(()),\n         };\n \n-        macro_rules! sym( ($e:expr, $t:ident) => (\n-            match unsafe { lib.symbol::<$t>($e) } {\n-                Ok(f) => f,\n+        macro_rules! sym( ($e:expr, $t:ident) => (unsafe {\n+            match lib.symbol($e) {\n+                Ok(f) => mem::transmute::<*u8, $t>(f),\n                 Err(..) => return Ok(())\n             }\n-        ) )\n+        }) )\n \n         // Fetch the symbols necessary from dbghelp.dll\n         let SymFromAddr = sym!(\"SymFromAddr\", SymFromAddrFn);"}, {"sha": "ef558d3f9241bb0d04f6259cd0aa425fea457c00", "filename": "src/libsync/mutex.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmutex.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -97,7 +97,14 @@ pub static NATIVE_BLOCKED: uint = 1 << 2;\n /// drop(guard); // unlock the lock\n /// ```\n pub struct Mutex {\n-    lock: StaticMutex,\n+    // Note that this static mutex is in a *box*, not inlined into the struct\n+    // itself. This is done for memory safety reasons with the usage of a\n+    // StaticNativeMutex inside the static mutex above. Once a native mutex has\n+    // been used once, its address can never change (it can't be moved). This\n+    // mutex type can be safely moved at any time, so to ensure that the native\n+    // mutex is used correctly we box the inner lock to give it a constant\n+    // address.\n+    lock: Box<StaticMutex>,\n }\n \n #[deriving(PartialEq, Show)]\n@@ -458,7 +465,7 @@ impl Mutex {\n     /// Creates a new mutex in an unlocked state ready for use.\n     pub fn new() -> Mutex {\n         Mutex {\n-            lock: StaticMutex {\n+            lock: box StaticMutex {\n                 state: atomics::AtomicUint::new(0),\n                 flavor: Unsafe::new(Unlocked),\n                 green_blocker: Unsafe::new(0),"}, {"sha": "b8e08dab722eaa292bccfbfae387277e4b3e913c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -784,6 +784,8 @@ pub enum Ty_ {\n     TyUnboxedFn(Gc<UnboxedFnTy>),\n     TyTup(Vec<P<Ty>> ),\n     TyPath(Path, Option<OwnedSlice<TyParamBound>>, NodeId), // for #7264; see above\n+    // No-op; kept solely so that we can pretty-print faithfully\n+    TyParen(P<Ty>),\n     TyTypeof(Gc<Expr>),\n     // TyInfer means the type should be inferred instead of it having been\n     // specified. This can appear anywhere in a type."}, {"sha": "8e0a2218ea369f7f8b12d960fb977ff6ef8b98cc", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -737,6 +737,7 @@ pub fn get_inner_tys(ty: P<Ty>) -> Vec<P<Ty>> {\n         | ast::TyUniq(ty)\n         | ast::TyFixedLengthVec(ty, _) => vec!(ty),\n         ast::TyTup(ref tys) => tys.clone(),\n+        ast::TyParen(ty) => get_inner_tys(ty),\n         _ => Vec::new()\n     }\n }"}, {"sha": "4ef7796c454b6263e9f2fe19520a4ff2a6fc69ad", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -85,6 +85,7 @@ pub trait AstBuilder {\n                       typ: P<ast::Ty>,\n                       ex: Gc<ast::Expr>)\n                       -> Gc<ast::Stmt>;\n+    fn stmt_item(&self, sp: Span, item: Gc<ast::Item>) -> Gc<ast::Stmt>;\n \n     // blocks\n     fn block(&self, span: Span, stmts: Vec<Gc<ast::Stmt>>,\n@@ -239,6 +240,14 @@ pub trait AstBuilder {\n                 vi: Vec<ast::ViewItem>,\n                 items: Vec<Gc<ast::Item>>) -> Gc<ast::Item>;\n \n+    fn item_static(&self,\n+                   span: Span,\n+                   name: Ident,\n+                   ty: P<ast::Ty>,\n+                   mutbl: ast::Mutability,\n+                   expr: Gc<ast::Expr>)\n+                   -> Gc<ast::Item>;\n+\n     fn item_ty_poly(&self,\n                     span: Span,\n                     name: Ident,\n@@ -484,11 +493,19 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         box(GC) respan(sp, ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID))\n     }\n \n-    fn block(&self, span: Span, stmts: Vec<Gc<ast::Stmt>>,\n-             expr: Option<Gc<Expr>>) -> P<ast::Block> {\n+    fn block(&self,\n+             span: Span,\n+             stmts: Vec<Gc<ast::Stmt>>,\n+             expr: Option<Gc<Expr>>)\n+             -> P<ast::Block> {\n         self.block_all(span, Vec::new(), stmts, expr)\n     }\n \n+    fn stmt_item(&self, sp: Span, item: Gc<ast::Item>) -> Gc<ast::Stmt> {\n+        let decl = respan(sp, ast::DeclItem(item));\n+        box(GC) respan(sp, ast::StmtDecl(box(GC) decl, ast::DUMMY_NODE_ID))\n+    }\n+\n     fn block_expr(&self, expr: Gc<ast::Expr>) -> P<ast::Block> {\n         self.block_all(expr.span, Vec::new(), Vec::new(), Some(expr))\n     }\n@@ -942,6 +959,16 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         )\n     }\n \n+    fn item_static(&self,\n+                   span: Span,\n+                   name: Ident,\n+                   ty: P<ast::Ty>,\n+                   mutbl: ast::Mutability,\n+                   expr: Gc<ast::Expr>)\n+                   -> Gc<ast::Item> {\n+        self.item(span, name, Vec::new(), ast::ItemStatic(ty, mutbl, expr))\n+    }\n+\n     fn item_ty_poly(&self, span: Span, name: Ident, ty: P<ast::Ty>,\n                     generics: Generics) -> Gc<ast::Item> {\n         self.item(span, name, Vec::new(), ast::ItemTy(ty, generics))"}, {"sha": "b87a25d4a44a25c87baf3f2651e18265ac6d828b", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -94,6 +94,18 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     }\n \n     let e = cx.expr_vec_slice(sp, bytes);\n-    let e = quote_expr!(cx, { static BYTES: &'static [u8] = $e; BYTES});\n+    let ty = cx.ty(sp, ast::TyVec(cx.ty_ident(sp, cx.ident_of(\"u8\"))));\n+    let lifetime = cx.lifetime(sp, cx.ident_of(\"'static\").name);\n+    let item = cx.item_static(sp,\n+                              cx.ident_of(\"BYTES\"),\n+                              cx.ty_rptr(sp,\n+                                         ty,\n+                                         Some(lifetime),\n+                                         ast::MutImmutable),\n+                              ast::MutImmutable,\n+                              e);\n+    let e = cx.expr_block(cx.block(sp,\n+                                   vec!(cx.stmt_item(sp, item)),\n+                                   Some(cx.expr_ident(sp, cx.ident_of(\"BYTES\")))));\n     MacExpr::new(e)\n }"}, {"sha": "9ef7241ca24842ed38292aa1b3c27f7a563b1c85", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -43,7 +43,7 @@ pub fn expand_option_env(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                                                         cx.ident_of(\"str\")),\n                                                    Some(cx.lifetime(sp,\n                                                         cx.ident_of(\n-                                                            \"static\").name)),\n+                                                            \"'static\").name)),\n                                                    ast::MutImmutable))))\n       }\n       Some(s) => {"}, {"sha": "cfce4b1e0fc5eb54b775eab3860a9aeb69e80815", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -465,7 +465,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     self.ecx.ident_of(\"rt\"),\n                     self.ecx.ident_of(\"Piece\")),\n                 vec!(self.ecx.lifetime(self.fmtsp,\n-                                       self.ecx.ident_of(\"static\").name)),\n+                                       self.ecx.ident_of(\"'static\").name)),\n                 Vec::new()\n             ), None);\n         let ty = ast::TyFixedLengthVec("}, {"sha": "4f1e2ab356e1e794779867de5f51b5ae50e83f0c", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -358,19 +358,16 @@ pub fn expand_quote_item(cx: &mut ExtCtxt,\n                          sp: Span,\n                          tts: &[ast::TokenTree])\n                          -> Box<base::MacResult> {\n-    let e_attrs = cx.expr_vec_ng(sp);\n-    let expanded = expand_parse_call(cx, sp, \"parse_item\",\n-                                    vec!(e_attrs), tts);\n+    let expanded = expand_parse_call(cx, sp, \"parse_item_with_outer_attributes\",\n+                                    vec!(), tts);\n     base::MacExpr::new(expanded)\n }\n \n pub fn expand_quote_pat(cx: &mut ExtCtxt,\n                         sp: Span,\n                         tts: &[ast::TokenTree])\n                         -> Box<base::MacResult> {\n-    let e_refutable = cx.expr_lit(sp, ast::LitBool(true));\n-    let expanded = expand_parse_call(cx, sp, \"parse_pat\",\n-                                    vec!(e_refutable), tts);\n+    let expanded = expand_parse_call(cx, sp, \"parse_pat\", vec!(), tts);\n     base::MacExpr::new(expanded)\n }\n "}, {"sha": "72c578b87699c5b0f335ee3bad3395cc6e4fd818", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -73,8 +73,7 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n         let mut ret = SmallVector::zero();\n         loop {\n             let mut parser = self.parser.borrow_mut();\n-            let attrs = parser.parse_outer_attributes();\n-            match parser.parse_item(attrs) {\n+            match parser.parse_item_with_outer_attributes() {\n                 Some(item) => ret.push(item),\n                 None => break\n             }"}, {"sha": "d61a79e4e80be3e0a298c208640430866c5a192b", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -192,6 +192,7 @@ pub trait Folder {\n                 })\n             }\n             TyTup(ref tys) => TyTup(tys.iter().map(|&ty| self.fold_ty(ty)).collect()),\n+            TyParen(ref ty) => TyParen(self.fold_ty(*ty)),\n             TyPath(ref path, ref bounds, id) => {\n                 let id = self.new_id(id);\n                 TyPath(self.fold_path(path),"}, {"sha": "459cb6d31ed0aedd34b4ce3674b0c8adde516adc", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -757,19 +757,34 @@ impl<'a> StringReader<'a> {\n                 while ident_continue(self.curr) {\n                     self.bump();\n                 }\n+\n+                // Include the leading `'` in the real identifier, for macro\n+                // expansion purposes. See #12512 for the gory details of why\n+                // this is necessary.\n                 let ident = self.with_str_from(start, |lifetime_name| {\n-                    str_to_ident(lifetime_name)\n+                    str_to_ident(format!(\"'{}\", lifetime_name).as_slice())\n                 });\n-                let tok = &token::IDENT(ident, false);\n-\n-                if token::is_keyword(token::keywords::Self, tok) {\n-                    self.err_span(start, self.last_pos,\n-                               \"invalid lifetime name: 'self \\\n-                                is no longer a special lifetime\");\n-                } else if token::is_any_keyword(tok) &&\n-                    !token::is_keyword(token::keywords::Static, tok) {\n-                    self.err_span(start, self.last_pos,\n-                               \"invalid lifetime name\");\n+\n+                // Conjure up a \"keyword checking ident\" to make sure that\n+                // the lifetime name is not a keyword.\n+                let keyword_checking_ident =\n+                    self.with_str_from(start, |lifetime_name| {\n+                        str_to_ident(lifetime_name)\n+                    });\n+                let keyword_checking_token =\n+                    &token::IDENT(keyword_checking_ident, false);\n+                if token::is_keyword(token::keywords::Self,\n+                                     keyword_checking_token) {\n+                    self.err_span(start,\n+                                  self.last_pos,\n+                                  \"invalid lifetime name: 'self \\\n+                                   is no longer a special lifetime\");\n+                } else if token::is_any_keyword(keyword_checking_token) &&\n+                    !token::is_keyword(token::keywords::Static,\n+                                       keyword_checking_token) {\n+                    self.err_span(start,\n+                                  self.last_pos,\n+                                  \"invalid lifetime name\");\n                 }\n                 return token::LIFETIME(ident);\n             }\n@@ -1128,7 +1143,7 @@ mod test {\n \n     #[test] fn lifetime_name() {\n         assert_eq!(setup(&mk_sh(), \"'abc\".to_string()).next_token().tok,\n-                   token::LIFETIME(token::str_to_ident(\"abc\")));\n+                   token::LIFETIME(token::str_to_ident(\"'abc\")));\n     }\n \n     #[test] fn raw_string() {"}, {"sha": "1ebcbc8a7d10218452987c26a74d483aecc95e8d", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -117,8 +117,7 @@ pub fn parse_item_from_source_str(name: String,\n                                   sess: &ParseSess)\n                                   -> Option<Gc<ast::Item>> {\n     let mut p = new_parser_from_source_str(sess, cfg, name, source);\n-    let attrs = p.parse_outer_attributes();\n-    maybe_aborted(p.parse_item(attrs),p)\n+    maybe_aborted(p.parse_item_with_outer_attributes(),p)\n }\n \n pub fn parse_meta_from_source_str(name: String,"}, {"sha": "d11d303059fa1e026232afee4615f6f03e7612a6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 92, "deletions": 52, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -51,7 +51,7 @@ use ast::{TokenTree, TraitMethod, TraitRef, TTDelim, TTSeq, TTTok};\n use ast::{TTNonterminal, TupleVariantKind, Ty, Ty_, TyBot, TyBox};\n use ast::{TypeField, TyFixedLengthVec, TyClosure, TyProc, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n-use ast::{TyNil, TyParam, TyParamBound, TyPath, TyPtr, TyRptr};\n+use ast::{TyNil, TyParam, TyParamBound, TyParen, TyPath, TyPtr, TyRptr};\n use ast::{TyTup, TyU32, TyUnboxedFn, TyUniq, TyVec, UnUniq};\n use ast::{UnboxedFnTy, UnboxedFnTyParamBound, UnnamedField, UnsafeBlock};\n use ast::{UnsafeFn, ViewItem, ViewItem_, ViewItemExternCrate, ViewItemUse};\n@@ -105,7 +105,7 @@ pub enum PathParsingMode {\n     /// the type parameters; e.g. `foo::bar::<'a>::Baz::<T>`\n     LifetimeAndTypesWithColons,\n     /// A path with a lifetime and type parameters with bounds before the last\n-    /// set of type parameters only; e.g. `foo::bar<'a>::Baz:X+Y<T>` This\n+    /// set of type parameters only; e.g. `foo::bar<'a>::Baz+X+Y<T>` This\n     /// form does not use extra double colons.\n     LifetimeAndTypesAndBounds,\n }\n@@ -1015,7 +1015,14 @@ impl<'a> Parser<'a> {\n         };\n \n         let (inputs, variadic) = self.parse_fn_args(false, false);\n-        let (_, bounds) = self.parse_optional_ty_param_bounds(false);\n+        let bounds = {\n+            if self.eat(&token::COLON) {\n+                let (_, bounds) = self.parse_ty_param_bounds(false);\n+                Some(bounds)\n+            } else {\n+                None\n+            }\n+        };\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n         let decl = P(FnDecl {\n             inputs: inputs,\n@@ -1083,7 +1090,14 @@ impl<'a> Parser<'a> {\n             (is_unboxed, inputs)\n         };\n \n-        let (region, bounds) = self.parse_optional_ty_param_bounds(true);\n+        let (region, bounds) = {\n+            if self.eat(&token::COLON) {\n+                let (region, bounds) = self.parse_ty_param_bounds(true);\n+                (region, Some(bounds))\n+            } else {\n+                (None, None)\n+            }\n+        };\n \n         let (return_style, output) = self.parse_ret_ty();\n         let decl = P(FnDecl {\n@@ -1227,7 +1241,7 @@ impl<'a> Parser<'a> {\n     // parse a possibly mutable type\n     pub fn parse_mt(&mut self) -> MutTy {\n         let mutbl = self.parse_mutability();\n-        let t = self.parse_ty(false);\n+        let t = self.parse_ty(true);\n         MutTy { ty: t, mutbl: mutbl }\n     }\n \n@@ -1238,7 +1252,7 @@ impl<'a> Parser<'a> {\n         let mutbl = self.parse_mutability();\n         let id = self.parse_ident();\n         self.expect(&token::COLON);\n-        let ty = self.parse_ty(false);\n+        let ty = self.parse_ty(true);\n         let hi = ty.span.hi;\n         ast::TypeField {\n             ident: id,\n@@ -1261,7 +1275,7 @@ impl<'a> Parser<'a> {\n                     })\n                 )\n             } else {\n-                (Return, self.parse_ty(false))\n+                (Return, self.parse_ty(true))\n             }\n         } else {\n             let pos = self.span.lo;\n@@ -1276,10 +1290,11 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    // parse a type.\n-    // Useless second parameter for compatibility with quasiquote macros.\n-    // Bleh!\n-    pub fn parse_ty(&mut self, _: bool) -> P<Ty> {\n+    /// Parse a type.\n+    ///\n+    /// The second parameter specifies whether the `+` binary operator is\n+    /// allowed in the type grammar.\n+    pub fn parse_ty(&mut self, plus_allowed: bool) -> P<Ty> {\n         maybe_whole!(no_clone self, NtTy);\n \n         let lo = self.span.lo;\n@@ -1293,12 +1308,12 @@ impl<'a> Parser<'a> {\n                 // (t) is a parenthesized ty\n                 // (t,) is the type of a tuple with only one field,\n                 // of type t\n-                let mut ts = vec!(self.parse_ty(false));\n+                let mut ts = vec!(self.parse_ty(true));\n                 let mut one_tuple = false;\n                 while self.token == token::COMMA {\n                     self.bump();\n                     if self.token != token::RPAREN {\n-                        ts.push(self.parse_ty(false));\n+                        ts.push(self.parse_ty(true));\n                     }\n                     else {\n                         one_tuple = true;\n@@ -1307,17 +1322,17 @@ impl<'a> Parser<'a> {\n \n                 if ts.len() == 1 && !one_tuple {\n                     self.expect(&token::RPAREN);\n-                    return *ts.get(0)\n+                    TyParen(*ts.get(0))\n+                } else {\n+                    let t = TyTup(ts);\n+                    self.expect(&token::RPAREN);\n+                    t\n                 }\n-\n-                let t = TyTup(ts);\n-                self.expect(&token::RPAREN);\n-                t\n             }\n         } else if self.token == token::AT {\n             // MANAGED POINTER\n             self.bump();\n-            TyBox(self.parse_ty(false))\n+            TyBox(self.parse_ty(plus_allowed))\n         } else if self.token == token::TILDE {\n             // OWNED POINTER\n             self.bump();\n@@ -1326,15 +1341,15 @@ impl<'a> Parser<'a> {\n                     self.obsolete(self.last_span, ObsoleteOwnedVector),\n                 _ => self.obsolete(self.last_span, ObsoleteOwnedType),\n             };\n-            TyUniq(self.parse_ty(false))\n+            TyUniq(self.parse_ty(true))\n         } else if self.token == token::BINOP(token::STAR) {\n             // STAR POINTER (bare pointer?)\n             self.bump();\n             TyPtr(self.parse_mt())\n         } else if self.token == token::LBRACKET {\n             // VECTOR\n             self.expect(&token::LBRACKET);\n-            let t = self.parse_ty(false);\n+            let t = self.parse_ty(true);\n \n             // Parse the `, ..e` in `[ int, ..e ]`\n             // where `e` is a const expression\n@@ -1377,10 +1392,15 @@ impl<'a> Parser<'a> {\n         } else if self.token == token::MOD_SEP\n             || is_ident_or_path(&self.token) {\n             // NAMED TYPE\n+            let mode = if plus_allowed {\n+                LifetimeAndTypesAndBounds\n+            } else {\n+                LifetimeAndTypesWithoutColons\n+            };\n             let PathAndBounds {\n                 path,\n                 bounds\n-            } = self.parse_path(LifetimeAndTypesAndBounds);\n+            } = self.parse_path(mode);\n             TyPath(path, bounds, ast::DUMMY_NODE_ID)\n         } else if self.eat(&token::UNDERSCORE) {\n             // TYPE TO BE INFERRED\n@@ -1438,7 +1458,7 @@ impl<'a> Parser<'a> {\n                                    special_idents::invalid)\n         };\n \n-        let t = self.parse_ty(false);\n+        let t = self.parse_ty(true);\n \n         Arg {\n             ty: t,\n@@ -1456,7 +1476,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_fn_block_arg(&mut self) -> Arg {\n         let pat = self.parse_pat();\n         let t = if self.eat(&token::COLON) {\n-            self.parse_ty(false)\n+            self.parse_ty(true)\n         } else {\n             P(Ty {\n                 id: ast::DUMMY_NODE_ID,\n@@ -1611,9 +1631,19 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        // Next, parse a colon and bounded type parameters, if applicable.\n+        // Next, parse a plus and bounded type parameters, if applicable.\n+        //\n+        // NOTE(stage0, pcwalton): Remove `token::COLON` after a snapshot.\n         let bounds = if mode == LifetimeAndTypesAndBounds {\n-            let (_, bounds) = self.parse_optional_ty_param_bounds(false);\n+            let bounds = {\n+                if self.eat(&token::BINOP(token::PLUS)) ||\n+                        self.eat(&token::COLON) {\n+                    let (_, bounds) = self.parse_ty_param_bounds(false);\n+                    Some(bounds)\n+                } else {\n+                    None\n+                }\n+            };\n             bounds\n         } else {\n             None\n@@ -2438,7 +2468,7 @@ impl<'a> Parser<'a> {\n             }\n             None => {\n                 if as_prec > min_prec && self.eat_keyword(keywords::As) {\n-                    let rhs = self.parse_ty(true);\n+                    let rhs = self.parse_ty(false);\n                     let _as = self.mk_expr(lhs.span.lo,\n                                            rhs.span.hi,\n                                            ExprCast(lhs, rhs));\n@@ -3067,7 +3097,9 @@ impl<'a> Parser<'a> {\n             node: TyInfer,\n             span: mk_sp(lo, lo),\n         });\n-        if self.eat(&token::COLON) { ty = self.parse_ty(false); }\n+        if self.eat(&token::COLON) {\n+            ty = self.parse_ty(true);\n+        }\n         let init = self.parse_initializer();\n         box(GC) ast::Local {\n             ty: ty,\n@@ -3095,7 +3127,7 @@ impl<'a> Parser<'a> {\n         }\n         let name = self.parse_ident();\n         self.expect(&token::COLON);\n-        let ty = self.parse_ty(false);\n+        let ty = self.parse_ty(true);\n         spanned(lo, self.last_span.hi, ast::StructField_ {\n             kind: NamedField(name, pr),\n             id: ast::DUMMY_NODE_ID,\n@@ -3427,7 +3459,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    // matches optbounds = ( ( : ( boundseq )? )? )\n+    // matches bounds    = ( boundseq )?\n     // where   boundseq  = ( bound + boundseq ) | bound\n     // and     bound     = 'static | ty\n     // Returns \"None\" if there's no colon (e.g. \"T\");\n@@ -3439,20 +3471,16 @@ impl<'a> Parser<'a> {\n     // AST doesn't support arbitrary lifetimes in bounds on type parameters. In\n     // the future, this flag should be removed, and the return value of this\n     // function should be Option<~[TyParamBound]>\n-    fn parse_optional_ty_param_bounds(&mut self, allow_any_lifetime: bool)\n-        -> (Option<ast::Lifetime>, Option<OwnedSlice<TyParamBound>>)\n-    {\n-        if !self.eat(&token::COLON) {\n-            return (None, None);\n-        }\n-\n+    fn parse_ty_param_bounds(&mut self, allow_any_lifetime: bool)\n+                             -> (Option<ast::Lifetime>,\n+                                 OwnedSlice<TyParamBound>) {\n         let mut ret_lifetime = None;\n         let mut result = vec!();\n         loop {\n             match self.token {\n                 token::LIFETIME(lifetime) => {\n                     let lifetime_interned_string = token::get_ident(lifetime);\n-                    if lifetime_interned_string.equiv(&(\"static\")) {\n+                    if lifetime_interned_string.equiv(&(\"'static\")) {\n                         result.push(StaticRegionTyParamBound);\n                         if allow_any_lifetime && ret_lifetime.is_none() {\n                             ret_lifetime = Some(ast::Lifetime {\n@@ -3489,21 +3517,28 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        return (ret_lifetime, Some(OwnedSlice::from_vec(result)));\n+        return (ret_lifetime, OwnedSlice::from_vec(result));\n     }\n \n     // matches typaram = type? IDENT optbounds ( EQ ty )?\n     fn parse_ty_param(&mut self) -> TyParam {\n         let sized = self.parse_sized();\n         let span = self.span;\n         let ident = self.parse_ident();\n-        let (_, opt_bounds) = self.parse_optional_ty_param_bounds(false);\n+        let opt_bounds = {\n+            if self.eat(&token::COLON) {\n+                let (_, bounds) = self.parse_ty_param_bounds(false);\n+                Some(bounds)\n+            } else {\n+                None\n+            }\n+        };\n         // For typarams we don't care about the difference b/w \"<T>\" and \"<T:>\".\n         let bounds = opt_bounds.unwrap_or_default();\n \n         let default = if self.token == token::EQ {\n             self.bump();\n-            Some(self.parse_ty(false))\n+            Some(self.parse_ty(true))\n         }\n         else { None };\n \n@@ -3548,7 +3583,7 @@ impl<'a> Parser<'a> {\n             Some(token::COMMA),\n             |p| {\n                 p.forbid_lifetime();\n-                p.parse_ty(false)\n+                p.parse_ty(true)\n             }\n         );\n         (lifetimes, result.into_vec())\n@@ -3804,7 +3839,7 @@ impl<'a> Parser<'a> {\n             }\n         };\n         let output = if self.eat(&token::RARROW) {\n-            self.parse_ty(false)\n+            self.parse_ty(true)\n         } else {\n             P(Ty {\n                 id: ast::DUMMY_NODE_ID,\n@@ -3830,7 +3865,7 @@ impl<'a> Parser<'a> {\n                                      |p| p.parse_fn_block_arg());\n \n         let output = if self.eat(&token::RARROW) {\n-            self.parse_ty(false)\n+            self.parse_ty(true)\n         } else {\n             P(Ty {\n                 id: ast::DUMMY_NODE_ID,\n@@ -3942,7 +3977,7 @@ impl<'a> Parser<'a> {\n         let could_be_trait = self.token != token::LPAREN;\n \n         // Parse the trait.\n-        let mut ty = self.parse_ty(false);\n+        let mut ty = self.parse_ty(true);\n \n         // Parse traits, if necessary.\n         let opt_trait = if could_be_trait && self.eat_keyword(keywords::For) {\n@@ -3965,7 +4000,7 @@ impl<'a> Parser<'a> {\n                 }\n             };\n \n-            ty = self.parse_ty(false);\n+            ty = self.parse_ty(true);\n             opt_trait_ref\n         } else {\n             None\n@@ -4008,7 +4043,7 @@ impl<'a> Parser<'a> {\n         let generics = self.parse_generics();\n \n         let super_struct = if self.eat(&token::COLON) {\n-            let ty = self.parse_ty(false);\n+            let ty = self.parse_ty(true);\n             match ty.node {\n                 TyPath(_, None, _) => {\n                     Some(ty)\n@@ -4051,7 +4086,7 @@ impl<'a> Parser<'a> {\n                 let struct_field_ = ast::StructField_ {\n                     kind: UnnamedField(p.parse_visibility()),\n                     id: ast::DUMMY_NODE_ID,\n-                    ty: p.parse_ty(false),\n+                    ty: p.parse_ty(true),\n                     attrs: attrs,\n                 };\n                 spanned(lo, p.span.hi, struct_field_)\n@@ -4205,7 +4240,7 @@ impl<'a> Parser<'a> {\n         let m = if self.eat_keyword(keywords::Mut) {MutMutable} else {MutImmutable};\n         let id = self.parse_ident();\n         self.expect(&token::COLON);\n-        let ty = self.parse_ty(false);\n+        let ty = self.parse_ty(true);\n         self.expect(&token::EQ);\n         let e = self.parse_expr();\n         self.commit_expr_expecting(e, token::SEMI);\n@@ -4386,7 +4421,7 @@ impl<'a> Parser<'a> {\n \n         let ident = self.parse_ident();\n         self.expect(&token::COLON);\n-        let ty = self.parse_ty(false);\n+        let ty = self.parse_ty(true);\n         let hi = self.span.hi;\n         self.expect(&token::SEMI);\n         box(GC) ast::ForeignItem {\n@@ -4514,7 +4549,7 @@ impl<'a> Parser<'a> {\n         let ident = self.parse_ident();\n         let tps = self.parse_generics();\n         self.expect(&token::EQ);\n-        let ty = self.parse_ty(false);\n+        let ty = self.parse_ty(true);\n         self.expect(&token::SEMI);\n         (ident, ItemTy(ty, tps), None)\n     }\n@@ -4562,7 +4597,7 @@ impl<'a> Parser<'a> {\n                     &token::LPAREN,\n                     &token::RPAREN,\n                     seq_sep_trailing_disallowed(token::COMMA),\n-                    |p| p.parse_ty(false)\n+                    |p| p.parse_ty(true)\n                 );\n                 for ty in arg_tys.move_iter() {\n                     args.push(ast::VariantArg {\n@@ -4930,6 +4965,11 @@ impl<'a> Parser<'a> {\n         return IoviNone(attrs);\n     }\n \n+    pub fn parse_item_with_outer_attributes(&mut self) -> Option<Gc<Item>> {\n+        let attrs = self.parse_outer_attributes();\n+        self.parse_item(attrs)\n+    }\n+\n     pub fn parse_item(&mut self, attrs: Vec<Attribute> ) -> Option<Gc<Item>> {\n         match self.parse_item_or_view_item(attrs, true) {\n             IoviNone(_) => None,"}, {"sha": "a4a022708d95e84ee1830ebe69b70250085def1c", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 52, "deletions": 51, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -232,7 +232,7 @@ pub fn to_str(t: &Token) -> String {\n       /* Name components */\n       IDENT(s, _) => get_ident(s).get().to_string(),\n       LIFETIME(s) => {\n-          (format!(\"'{}\", get_ident(s))).to_string()\n+          (format!(\"{}\", get_ident(s))).to_string()\n       }\n       UNDERSCORE => \"_\".to_string(),\n \n@@ -433,71 +433,72 @@ declare_special_idents_and_keywords! {\n         (0,                          invalid,                \"\");\n         (super::SELF_KEYWORD_NAME,   self_,                  \"self\");\n         (super::STATIC_KEYWORD_NAME, statik,                 \"static\");\n+        (3,                          static_lifetime,        \"'static\");\n \n         // for matcher NTs\n-        (3,                          tt,                     \"tt\");\n-        (4,                          matchers,               \"matchers\");\n+        (4,                          tt,                     \"tt\");\n+        (5,                          matchers,               \"matchers\");\n \n         // outside of libsyntax\n-        (5,                          clownshoe_abi,          \"__rust_abi\");\n-        (6,                          opaque,                 \"<opaque>\");\n-        (7,                          unnamed_field,          \"<unnamed_field>\");\n-        (8,                          type_self,              \"Self\");\n+        (6,                          clownshoe_abi,          \"__rust_abi\");\n+        (7,                          opaque,                 \"<opaque>\");\n+        (8,                          unnamed_field,          \"<unnamed_field>\");\n+        (9,                          type_self,              \"Self\");\n     }\n \n     pub mod keywords {\n         // These ones are variants of the Keyword enum\n \n         'strict:\n-        (9,                          As,         \"as\");\n-        (10,                         Break,      \"break\");\n-        (11,                         Crate,      \"crate\");\n-        (12,                         Else,       \"else\");\n-        (13,                         Enum,       \"enum\");\n-        (14,                         Extern,     \"extern\");\n-        (15,                         False,      \"false\");\n-        (16,                         Fn,         \"fn\");\n-        (17,                         For,        \"for\");\n-        (18,                         If,         \"if\");\n-        (19,                         Impl,       \"impl\");\n-        (20,                         In,         \"in\");\n-        (21,                         Let,        \"let\");\n-        (22,                         Loop,       \"loop\");\n-        (23,                         Match,      \"match\");\n-        (24,                         Mod,        \"mod\");\n-        (25,                         Mut,        \"mut\");\n-        (26,                         Once,       \"once\");\n-        (27,                         Pub,        \"pub\");\n-        (28,                         Ref,        \"ref\");\n-        (29,                         Return,     \"return\");\n+        (10,                         As,         \"as\");\n+        (11,                         Break,      \"break\");\n+        (12,                         Crate,      \"crate\");\n+        (13,                         Else,       \"else\");\n+        (14,                         Enum,       \"enum\");\n+        (15,                         Extern,     \"extern\");\n+        (16,                         False,      \"false\");\n+        (17,                         Fn,         \"fn\");\n+        (18,                         For,        \"for\");\n+        (19,                         If,         \"if\");\n+        (20,                         Impl,       \"impl\");\n+        (21,                         In,         \"in\");\n+        (22,                         Let,        \"let\");\n+        (23,                         Loop,       \"loop\");\n+        (24,                         Match,      \"match\");\n+        (25,                         Mod,        \"mod\");\n+        (26,                         Mut,        \"mut\");\n+        (27,                         Once,       \"once\");\n+        (28,                         Pub,        \"pub\");\n+        (29,                         Ref,        \"ref\");\n+        (30,                         Return,     \"return\");\n         // Static and Self are also special idents (prefill de-dupes)\n         (super::STATIC_KEYWORD_NAME, Static,     \"static\");\n         (super::SELF_KEYWORD_NAME,   Self,       \"self\");\n-        (30,                         Struct,     \"struct\");\n-        (31,                         Super,      \"super\");\n-        (32,                         True,       \"true\");\n-        (33,                         Trait,      \"trait\");\n-        (34,                         Type,       \"type\");\n-        (35,                         Unsafe,     \"unsafe\");\n-        (36,                         Use,        \"use\");\n-        (37,                         Virtual,    \"virtual\");\n-        (38,                         While,      \"while\");\n-        (39,                         Continue,   \"continue\");\n-        (40,                         Proc,       \"proc\");\n-        (41,                         Box,        \"box\");\n+        (31,                         Struct,     \"struct\");\n+        (32,                         Super,      \"super\");\n+        (33,                         True,       \"true\");\n+        (34,                         Trait,      \"trait\");\n+        (35,                         Type,       \"type\");\n+        (36,                         Unsafe,     \"unsafe\");\n+        (37,                         Use,        \"use\");\n+        (38,                         Virtual,    \"virtual\");\n+        (39,                         While,      \"while\");\n+        (40,                         Continue,   \"continue\");\n+        (41,                         Proc,       \"proc\");\n+        (42,                         Box,        \"box\");\n \n         'reserved:\n-        (42,                         Alignof,    \"alignof\");\n-        (43,                         Be,         \"be\");\n-        (44,                         Const,      \"const\");\n-        (45,                         Offsetof,   \"offsetof\");\n-        (46,                         Priv,       \"priv\");\n-        (47,                         Pure,       \"pure\");\n-        (48,                         Sizeof,     \"sizeof\");\n-        (49,                         Typeof,     \"typeof\");\n-        (50,                         Unsized,    \"unsized\");\n-        (51,                         Yield,      \"yield\");\n-        (52,                         Do,         \"do\");\n+        (43,                         Alignof,    \"alignof\");\n+        (44,                         Be,         \"be\");\n+        (45,                         Const,      \"const\");\n+        (46,                         Offsetof,   \"offsetof\");\n+        (47,                         Priv,       \"priv\");\n+        (48,                         Pure,       \"pure\");\n+        (49,                         Sizeof,     \"sizeof\");\n+        (50,                         Typeof,     \"typeof\");\n+        (51,                         Unsized,    \"unsized\");\n+        (52,                         Yield,      \"yield\");\n+        (53,                         Do,         \"do\");\n     }\n }\n "}, {"sha": "63acdb1a6ca758d576e585cc630d9d932cf1aaa3", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n use abi;\n-use ast::{P, StaticRegionTyParamBound, OtherRegionTyParamBound,\n-          TraitTyParamBound, UnboxedFnTyParamBound, Required, Provided};\n+use ast::{P, StaticRegionTyParamBound, OtherRegionTyParamBound};\n+use ast::{TraitTyParamBound, UnboxedFnTyParamBound, Required, Provided};\n use ast;\n use ast_util;\n use owned_slice::OwnedSlice;\n@@ -495,6 +495,11 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.pclose());\n             }\n+            ast::TyParen(ref typ) => {\n+                try!(self.popen());\n+                try!(self.print_type(&**typ));\n+                try!(self.pclose());\n+            }\n             ast::TyBareFn(f) => {\n                 let generics = ast::Generics {\n                     lifetimes: f.lifetimes.clone(),\n@@ -1325,7 +1330,6 @@ impl<'a> State<'a> {\n             }\n             ast::ExprForLoop(ref pat, ref iter, ref blk, opt_ident) => {\n                 for ident in opt_ident.iter() {\n-                    try!(word(&mut self.s, \"'\"));\n                     try!(self.print_ident(*ident));\n                     try!(self.word_space(\":\"));\n                 }\n@@ -1339,7 +1343,6 @@ impl<'a> State<'a> {\n             }\n             ast::ExprLoop(ref blk, opt_ident) => {\n                 for ident in opt_ident.iter() {\n-                    try!(word(&mut self.s, \"'\"));\n                     try!(self.print_ident(*ident));\n                     try!(self.word_space(\":\"));\n                 }\n@@ -1504,7 +1507,6 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \"break\"));\n                 try!(space(&mut self.s));\n                 for ident in opt_ident.iter() {\n-                    try!(word(&mut self.s, \"'\"));\n                     try!(self.print_ident(*ident));\n                     try!(space(&mut self.s));\n                 }\n@@ -1513,7 +1515,6 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \"continue\"));\n                 try!(space(&mut self.s));\n                 for ident in opt_ident.iter() {\n-                    try!(word(&mut self.s, \"'\"));\n                     try!(self.print_ident(*ident));\n                     try!(space(&mut self.s))\n                 }\n@@ -1677,7 +1678,7 @@ impl<'a> State<'a> {\n \n         match *opt_bounds {\n             None => Ok(()),\n-            Some(ref bounds) => self.print_bounds(&None, bounds, true),\n+            Some(ref bounds) => self.print_bounds(&None, bounds, true, true),\n         }\n     }\n \n@@ -1936,14 +1937,21 @@ impl<'a> State<'a> {\n     pub fn print_bounds(&mut self,\n                         region: &Option<ast::Lifetime>,\n                         bounds: &OwnedSlice<ast::TyParamBound>,\n-                        print_colon_anyway: bool) -> IoResult<()> {\n+                        print_colon_anyway: bool,\n+                        print_plus_before_bounds: bool)\n+                        -> IoResult<()> {\n+        let separator = if print_plus_before_bounds {\n+            \"+\"\n+        } else {\n+            \":\"\n+        };\n         if !bounds.is_empty() || region.is_some() {\n-            try!(word(&mut self.s, \":\"));\n+            try!(word(&mut self.s, separator));\n             let mut first = true;\n             match *region {\n                 Some(ref lt) => {\n                     let token = token::get_name(lt.name);\n-                    if token.get() != \"static\" {\n+                    if token.get() != \"'static\" {\n                         try!(self.nbsp());\n                         first = false;\n                         try!(self.print_lifetime(lt));\n@@ -1980,15 +1988,14 @@ impl<'a> State<'a> {\n             }\n             Ok(())\n         } else if print_colon_anyway {\n-            word(&mut self.s, \":\")\n+            word(&mut self.s, separator)\n         } else {\n             Ok(())\n         }\n     }\n \n     pub fn print_lifetime(&mut self,\n                           lifetime: &ast::Lifetime) -> IoResult<()> {\n-        try!(word(&mut self.s, \"'\"));\n         self.print_name(lifetime.name)\n     }\n \n@@ -2016,7 +2023,10 @@ impl<'a> State<'a> {\n                             try!(s.word_space(\"type\"));\n                         }\n                         try!(s.print_ident(param.ident));\n-                        try!(s.print_bounds(&None, &param.bounds, false));\n+                        try!(s.print_bounds(&None,\n+                                            &param.bounds,\n+                                            false,\n+                                            false));\n                         match param.default {\n                             Some(ref default) => {\n                                 try!(space(&mut s.s));\n@@ -2219,7 +2229,7 @@ impl<'a> State<'a> {\n         }\n \n         opt_bounds.as_ref().map(|bounds| {\n-            self.print_bounds(opt_region, bounds, true)\n+            self.print_bounds(opt_region, bounds, true, false)\n         });\n \n         try!(self.maybe_print_comment(decl.output.span.lo));"}, {"sha": "6f0fc217533fc5070b25007d2bad6cfaa9aa9175", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -336,7 +336,7 @@ pub fn skip_ty<E, V: Visitor<E>>(_: &mut V, _: &Ty, _: E) {\n \n pub fn walk_ty<E: Clone, V: Visitor<E>>(visitor: &mut V, typ: &Ty, env: E) {\n     match typ.node {\n-        TyUniq(ty) | TyVec(ty) | TyBox(ty) => {\n+        TyUniq(ty) | TyVec(ty) | TyBox(ty) | TyParen(ty) => {\n             visitor.visit_ty(&*ty, env)\n         }\n         TyPtr(ref mutable_type) => {"}, {"sha": "1592ffb6c6790b976f02901f91088a28717f3f88", "filename": "src/test/auxiliary/plugin_crate_outlive_expansion_phase.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fauxiliary%2Fplugin_crate_outlive_expansion_phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fauxiliary%2Fplugin_crate_outlive_expansion_phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fplugin_crate_outlive_expansion_phase.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -27,7 +27,7 @@ impl Drop for Foo {\n \n #[plugin_registrar]\n pub fn registrar(_: &mut Registry) {\n-    local_data_key!(foo: Box<Any:Send>);\n-    foo.replace(Some(box Foo { foo: 10 } as Box<Any:Send>));\n+    local_data_key!(foo: Box<Any+Send>);\n+    foo.replace(Some(box Foo { foo: 10 } as Box<Any+Send>));\n }\n "}, {"sha": "0e87dc97c2631f8e0c7ffb6d20a3be14e282f4aa", "filename": "src/test/compile-fail/hygienic-label-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Fhygienic-label-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Fhygienic-label-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygienic-label-1.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -15,5 +15,5 @@ macro_rules! foo {\n }\n \n pub fn main() {\n-    'x: loop { foo!() } //~ ERROR use of undeclared label `x`\n+    'x: loop { foo!() } //~ ERROR use of undeclared label `'x`\n }"}, {"sha": "fe87e32459bb19eab3b36a75e6b15b8e27642faa", "filename": "src/test/compile-fail/hygienic-label-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Fhygienic-label-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Fhygienic-label-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygienic-label-2.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -15,5 +15,5 @@ macro_rules! foo {\n }\n \n pub fn main() {\n-    foo!(break 'x); //~ ERROR use of undeclared label `x`\n+    foo!(break 'x); //~ ERROR use of undeclared label `'x`\n }"}, {"sha": "b5954ac99303b9d47b1b8be8a8e006a810c346be", "filename": "src/test/compile-fail/hygienic-label-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Fhygienic-label-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Fhygienic-label-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygienic-label-3.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -16,6 +16,6 @@ macro_rules! foo {\n \n pub fn main() {\n     'x: for _ in range(0,1) {\n-        foo!() //~ ERROR use of undeclared label `x`\n+        foo!() //~ ERROR use of undeclared label `'x`\n     };\n }"}, {"sha": "67fa56b13067726de332a24298dc7e089dce3697", "filename": "src/test/compile-fail/hygienic-label-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Fhygienic-label-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Fhygienic-label-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygienic-label-4.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -15,5 +15,5 @@ macro_rules! foo {\n }\n \n pub fn main() {\n-    foo!(break 'x); //~ ERROR use of undeclared label `x`\n+    foo!(break 'x); //~ ERROR use of undeclared label `'x`\n }"}, {"sha": "90366d09e2deab2abbb2a8249876a0821b8f45f2", "filename": "src/test/compile-fail/issue-14845.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Fissue-14845.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Fissue-14845.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14845.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+struct X {\n+    a: [u8, ..1]\n+}\n+\n+fn main() {\n+    let x = X { a: [0] };\n+    let _f = &x.a as *mut u8;\n+    //~^ ERROR mismatched types: expected `*mut u8` but found `&[u8, .. 1]`\n+\n+    let local = [0u8];\n+    let _v = &local as *mut u8;\n+    //~^ ERROR mismatched types: expected `*mut u8` but found `&[u8, .. 1]`\n+}"}, {"sha": "3028db00f5871801fdcd0c06cc12e91ebafa522d", "filename": "src/test/compile-fail/issue-7013.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -31,7 +31,7 @@ struct A {\n }\n \n fn main() {\n-    let a = A {v: box B{v: None} as Box<Foo:Send>};\n+    let a = A {v: box B{v: None} as Box<Foo+Send>};\n     //~^ ERROR cannot pack type `~B`, which does not fulfill `Send`\n     let v = Rc::new(RefCell::new(a));\n     let w = v.clone();"}, {"sha": "651ea6abf08ccf4df8874f58b593815f014b5818", "filename": "src/test/compile-fail/kindck-copy.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-copy.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -45,15 +45,15 @@ fn test<'a,T,U:Copy>(_: &'a int) {\n \n     // borrowed object types are generally ok\n     assert_copy::<&'a Dummy>();\n-    assert_copy::<&'a Dummy:Copy>();\n-    assert_copy::<&'static Dummy:Copy>();\n+    assert_copy::<&'a Dummy+Copy>();\n+    assert_copy::<&'static Dummy+Copy>();\n \n     // owned object types are not ok\n     assert_copy::<Box<Dummy>>(); //~ ERROR does not fulfill\n-    assert_copy::<Box<Dummy:Copy>>(); //~ ERROR does not fulfill\n+    assert_copy::<Box<Dummy+Copy>>(); //~ ERROR does not fulfill\n \n     // mutable object types are not ok\n-    assert_copy::<&'a mut Dummy:Copy>();  //~ ERROR does not fulfill\n+    assert_copy::<&'a mut Dummy+Copy>();  //~ ERROR does not fulfill\n \n     // closures are like an `&mut` object\n     assert_copy::<||>(); //~ ERROR does not fulfill"}, {"sha": "0414e64f1b7bf0dbc870da2506032d131178d332", "filename": "src/test/compile-fail/kindck-send.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -39,17 +39,17 @@ fn test<'a,T,U:Send>(_: &'a int) {\n     // careful with object types, who knows what they close over...\n     assert_send::<&'static Dummy>(); //~ ERROR does not fulfill `Send`\n     assert_send::<&'a Dummy>(); //~ ERROR does not fulfill `Send`\n-    assert_send::<&'a Dummy:Send>(); //~ ERROR does not fulfill `Send`\n-    assert_send::<Box<Dummy:>>(); //~ ERROR does not fulfill `Send`\n+    assert_send::<&'a Dummy+Send>(); //~ ERROR does not fulfill `Send`\n+    assert_send::<Box<Dummy+>>(); //~ ERROR does not fulfill `Send`\n \n     // ...unless they are properly bounded\n-    assert_send::<&'static Dummy:Send>();\n-    assert_send::<Box<Dummy:Send>>();\n+    assert_send::<&'static Dummy+Send>();\n+    assert_send::<Box<Dummy+Send>>();\n \n     // but closure and object types can have lifetime bounds which make\n     // them not ok (FIXME #5121)\n     // assert_send::<proc:'a()>(); // ERROR does not fulfill `Send`\n-    // assert_send::<Box<Dummy:'a>>(); // ERROR does not fulfill `Send`\n+    // assert_send::<Box<Dummy+'a>>(); // ERROR does not fulfill `Send`\n \n     // unsafe ptrs are ok unless they point at unsendable things\n     assert_send::<*int>();"}, {"sha": "9f50ad3666025823bed9aa0c70c6117ab8973ae7", "filename": "src/test/compile-fail/regions-name-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Fregions-name-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Fregions-name-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-name-static.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct Foo<'static> { //~ ERROR illegal lifetime parameter name: `static`\n+struct Foo<'static> { //~ ERROR illegal lifetime parameter name: `'static`\n     x: &'static int\n }\n "}, {"sha": "3737025da6c121274315238753fc22dc1c5e5afa", "filename": "src/test/compile-fail/trait-bounds-cant-coerce.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -12,14 +12,14 @@\n trait Foo {\n }\n \n-fn a(_x: Box<Foo:Send>) {\n+fn a(_x: Box<Foo+Send>) {\n }\n \n-fn c(x: Box<Foo:Share+Send>) {\n+fn c(x: Box<Foo+Share+Send>) {\n     a(x);\n }\n \n-fn d(x: Box<Foo:>) {\n+fn d(x: Box<Foo+>) {\n     a(x); //~ ERROR found no bounds\n }\n "}, {"sha": "d548098ebe13ed8dadb9a9a48b7e4ac1303a0932", "filename": "src/test/compile-fail/trait-bounds-sugar.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -13,17 +13,17 @@\n \n trait Foo {}\n \n-fn a(_x: Box<Foo:Send>) {\n+fn a(_x: Box<Foo+Send>) {\n }\n \n-fn b(_x: &'static Foo) { // should be same as &'static Foo:'static\n+fn b(_x: &'static Foo) { // should be same as &'static Foo+'static\n }\n \n-fn c(x: Box<Foo:Share>) {\n+fn c(x: Box<Foo+Share>) {\n     a(x); //~ ERROR expected bounds `Send`\n }\n \n-fn d(x: &'static Foo:Share) {\n+fn d(x: &'static Foo+Share) {\n     b(x); //~ ERROR expected bounds `'static`\n }\n "}, {"sha": "abdfe983e3a8f02477952e0ef807d98e774b439e", "filename": "src/test/compile-fail/transmute-different-sizes.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Ftransmute-different-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Ftransmute-different-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-different-sizes.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that `transmute` cannot be called on types of different size.\n+\n+#![allow(warnings)]\n+\n+use std::mem::transmute;\n+\n+unsafe fn f() {\n+    let _: i8 = transmute(16i16);\n+    //~^ ERROR transmute called on types with different sizes\n+}\n+\n+unsafe fn g<T>(x: &T) {\n+    let _: i8 = transmute(x);\n+    //~^ ERROR transmute called on types with different sizes\n+}\n+\n+fn main() {}\n+\n+"}, {"sha": "53391a0e8947b9088b3d9398d88019a130279ed3", "filename": "src/test/compile-fail/transmute-type-parameters.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Ftransmute-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fcompile-fail%2Ftransmute-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-type-parameters.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that `transmute` cannot be called on type parameters.\n+\n+use std::mem::transmute;\n+\n+unsafe fn f<T>(x: T) {\n+    let _: int = transmute(x);  //~ ERROR cannot transmute\n+}\n+\n+unsafe fn g<T>(x: (T, int)) {\n+    let _: int = transmute(x);  //~ ERROR cannot transmute\n+}\n+\n+unsafe fn h<T>(x: [T, ..10]) {\n+    let _: int = transmute(x);  //~ ERROR cannot transmute\n+}\n+\n+struct Bad<T> {\n+    f: T,\n+}\n+\n+unsafe fn i<T>(x: Bad<T>) {\n+    let _: int = transmute(x);  //~ ERROR cannot transmute\n+}\n+\n+enum Worse<T> {\n+    A(T),\n+    B,\n+}\n+\n+unsafe fn j<T>(x: Worse<T>) {\n+    let _: int = transmute(x);  //~ ERROR cannot transmute\n+}\n+\n+unsafe fn k<T>(x: Option<T>) {\n+    let _: int = transmute(x);  //~ ERROR cannot transmute\n+}\n+\n+fn main() {}"}, {"sha": "f90937c34a6d68422fcce26e9d6a585f57b2facd", "filename": "src/test/pretty/path-type-bounds.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fpretty%2Fpath-type-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Fpretty%2Fpath-type-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fpath-type-bounds.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -14,11 +14,11 @@\n trait Tr { }\n impl Tr for int { }\n \n-fn foo(x: Box<Tr: Share>) -> Box<Tr: Share> { x }\n+fn foo(x: Box<Tr+ Share>) -> Box<Tr+ Share> { x }\n \n fn main() {\n-    let x: Box<Tr: Share>;\n+    let x: Box<Tr+ Share>;\n \n-    box() 1 as Box<Tr: Share>;\n+    box() 1 as Box<Tr+ Share>;\n }\n "}, {"sha": "c56eabbb3b4aae5468e9c6f9a9718079c28228ae", "filename": "src/test/run-fail/fail-macro-any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Frun-fail%2Ffail-macro-any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Frun-fail%2Ffail-macro-any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-macro-any.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -12,5 +12,5 @@\n \n \n fn main() {\n-    fail!(box 413 as Box<::std::any::Any:Send>);\n+    fail!(box 413 as Box<::std::any::Any+Send>);\n }"}, {"sha": "4b2e29135ad2e5a0314d80542af3937e27ee274b", "filename": "src/test/run-pass-fulldeps/quote-tokens.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-test\n+// ignore-android\n+// ignore-pretty: does not work well with `--test`\n \n #![feature(quote)]\n #![feature(managed_boxes)]\n@@ -18,18 +19,21 @@ extern crate syntax;\n use syntax::ext::base::ExtCtxt;\n \n fn syntax_extension(cx: &ExtCtxt) {\n-    let e_toks : Vec<syntax::ast::token_tree> = quote_tokens!(cx, 1 + 2);\n-    let p_toks : Vec<syntax::ast::token_tree> = quote_tokens!(cx, (x, 1 .. 4, *));\n+    let e_toks : Vec<syntax::ast::TokenTree> = quote_tokens!(cx, 1 + 2);\n+    let p_toks : Vec<syntax::ast::TokenTree> = quote_tokens!(cx, (x, 1 .. 4, *));\n \n     let a: @syntax::ast::Expr = quote_expr!(cx, 1 + 2);\n-    let _b: Option<@syntax::ast::item> = quote_item!(cx, static foo : int = $e_toks; );\n+    let _b: Option<@syntax::ast::Item> = quote_item!(cx, static foo : int = $e_toks; );\n     let _c: @syntax::ast::Pat = quote_pat!(cx, (x, 1 .. 4, *) );\n     let _d: @syntax::ast::Stmt = quote_stmt!(cx, let x = $a; );\n     let _e: @syntax::ast::Expr = quote_expr!(cx, match foo { $p_toks => 10 } );\n \n     let _f: @syntax::ast::Expr = quote_expr!(cx, ());\n     let _g: @syntax::ast::Expr = quote_expr!(cx, true);\n     let _h: @syntax::ast::Expr = quote_expr!(cx, 'a');\n+\n+    let i: Option<@syntax::ast::Item> = quote_item!(cx, #[deriving(Eq)] struct Foo; );\n+    assert!(i.is_some());\n }\n \n fn main() {"}, {"sha": "4fa695de5228dd89d7954ca8a77d95a97058d4da", "filename": "src/test/run-pass/alignment-gep-tup-like-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -33,7 +33,7 @@ fn f<A:Clone + 'static>(a: A, b: u16) -> Box<Invokable<A>:> {\n     box Invoker {\n         a: a,\n         b: b,\n-    } as Box<Invokable<A>>:\n+    } as (Box<Invokable<A>>+)\n }\n \n pub fn main() {"}, {"sha": "0760f13200c8fcd813d6822da432249fc61c9735", "filename": "src/test/run-pass/as-precedence.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Frun-pass%2Fas-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Frun-pass%2Fas-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fas-precedence.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    assert_eq!(3 as uint * 3, 9);\n+    assert_eq!(3 as (uint) * 3, 9);\n+    assert_eq!(3 as (uint) / 3, 1);\n+    assert_eq!(3 as uint + 3, 6);\n+    assert_eq!(3 as (uint) + 3, 6);\n+}\n+"}, {"sha": "23607e16795edba637dce9a9a5de02de8200a3af", "filename": "src/test/run-pass/capturing-logging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -41,7 +41,7 @@ fn main() {\n     let (tx, rx) = channel();\n     let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n     spawn(proc() {\n-        set_logger(box MyWriter(w) as Box<Logger:Send>);\n+        set_logger(box MyWriter(w) as Box<Logger+Send>);\n         debug!(\"debug\");\n         info!(\"info\");\n     });"}, {"sha": "3d642be082c0ab3f25a857c50fa7f541f41b8aeb", "filename": "src/test/run-pass/close-over-big-then-small-data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -33,11 +33,11 @@ impl<A:Clone> Invokable<A> for Invoker<A> {\n     }\n }\n \n-fn f<A:Clone + 'static>(a: A, b: u16) -> Box<Invokable<A>:> {\n+fn f<A:Clone + 'static>(a: A, b: u16) -> Box<Invokable<A>+> {\n     box Invoker {\n         a: a,\n         b: b,\n-    } as Box<Invokable<A>>:\n+    } as (Box<Invokable<A>>+)\n }\n \n pub fn main() {"}, {"sha": "7876fe86d47245e3a08f34ae350cf53f86544d2e", "filename": "src/test/run-pass/issue-14837.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Frun-pass%2Fissue-14837.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Frun-pass%2Fissue-14837.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14837.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(struct_variant)]\n+\n+#[deny(dead_code)]\n+pub enum Foo {\n+    Bar {\n+        pub baz: int\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "cfe51fe77589fd07c475917e5a530abe111bbac6", "filename": "src/test/run-pass/loop-label-shadowing.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Frun-pass%2Floop-label-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Frun-pass%2Floop-label-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Floop-label-shadowing.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue #12512.\n+\n+fn main() {\n+    let mut foo = Vec::new();\n+    'foo: for i in [1, 2, 3].iter() {\n+        foo.push(i);\n+    }\n+}\n+"}, {"sha": "d1bb0db511b8fea838959f520a59f1b03bff0611", "filename": "src/test/run-pass/trait-bounds-basic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -12,21 +12,21 @@\n trait Foo {\n }\n \n-fn a(_x: Box<Foo:>) {\n+fn a(_x: Box<Foo+>) {\n }\n \n-fn b(_x: Box<Foo:Send>) {\n+fn b(_x: Box<Foo+Send>) {\n }\n \n-fn c(x: Box<Foo:Share+Send>) {\n+fn c(x: Box<Foo+Share+Send>) {\n     a(x);\n }\n \n-fn d(x: Box<Foo:Send>) {\n+fn d(x: Box<Foo+Send>) {\n     b(x);\n }\n \n-fn e(x: Box<Foo>) { // sugar for Box<Foo:Owned>\n+fn e(x: Box<Foo>) { // sugar for Box<Foo+Owned>\n     a(x);\n }\n "}, {"sha": "18a0e5d471c4a91fa3134034c6334ab324fee4d6", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -71,10 +71,10 @@ pub fn main() {\n         swim_speed: 998,\n         name: \"alec_guinness\".to_string(),\n     };\n-    let arc = Arc::new(vec!(box catte  as Box<Pet:Share+Send>,\n-                            box dogge1 as Box<Pet:Share+Send>,\n-                            box fishe  as Box<Pet:Share+Send>,\n-                            box dogge2 as Box<Pet:Share+Send>));\n+    let arc = Arc::new(vec!(box catte  as Box<Pet+Share+Send>,\n+                            box dogge1 as Box<Pet+Share+Send>,\n+                            box fishe  as Box<Pet+Share+Send>,\n+                            box dogge2 as Box<Pet+Share+Send>));\n     let (tx1, rx1) = channel();\n     let arc1 = arc.clone();\n     task::spawn(proc() { check_legs(arc1); tx1.send(()); });\n@@ -89,21 +89,21 @@ pub fn main() {\n     rx3.recv();\n }\n \n-fn check_legs(arc: Arc<Vec<Box<Pet:Share+Send>>>) {\n+fn check_legs(arc: Arc<Vec<Box<Pet+Share+Send>>>) {\n     let mut legs = 0;\n     for pet in arc.iter() {\n         legs += pet.num_legs();\n     }\n     assert!(legs == 12);\n }\n-fn check_names(arc: Arc<Vec<Box<Pet:Share+Send>>>) {\n+fn check_names(arc: Arc<Vec<Box<Pet+Share+Send>>>) {\n     for pet in arc.iter() {\n         pet.name(|name| {\n             assert!(name[0] == 'a' as u8 && name[1] == 'l' as u8);\n         })\n     }\n }\n-fn check_pedigree(arc: Arc<Vec<Box<Pet:Share+Send>>>) {\n+fn check_pedigree(arc: Arc<Vec<Box<Pet+Share+Send>>>) {\n     for pet in arc.iter() {\n         assert!(pet.of_good_pedigree());\n     }"}, {"sha": "0f99998b7a6edc2eeed8de5de0c55ceb7273a07d", "filename": "src/test/run-pass/trait-cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Frun-pass%2Ftrait-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Frun-pass%2Ftrait-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-cast.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -20,7 +20,7 @@ struct Tree(@RefCell<TreeR>);\n struct TreeR {\n     left: Option<Tree>,\n     right: Option<Tree>,\n-    val: Box<to_str:Send>\n+    val: Box<to_str+Send>\n }\n \n trait to_str {\n@@ -57,10 +57,10 @@ fn foo<T:to_str>(x: T) -> String { x.to_str_() }\n pub fn main() {\n     let t1 = Tree(@RefCell::new(TreeR{left: None,\n                                       right: None,\n-                                      val: box 1 as Box<to_str:Send>}));\n+                                      val: box 1 as Box<to_str+Send>}));\n     let t2 = Tree(@RefCell::new(TreeR{left: Some(t1),\n                                       right: Some(t1),\n-                                      val: box 2 as Box<to_str:Send>}));\n+                                      val: box 2 as Box<to_str+Send>}));\n     let expected =\n         \"[2, some([1, none, none]), some([1, none, none])]\".to_string();\n     assert!(t2.to_str_() == expected);"}, {"sha": "d8df5d5600c902d98ccc995c1d0645e1c1e27bd5", "filename": "src/test/run-pass/trait-contravariant-self.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Frun-pass%2Ftrait-contravariant-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcc9a4df50680686bee852e82a52fbc59b3c27/src%2Ftest%2Frun-pass%2Ftrait-contravariant-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-contravariant-self.rs?ref=63dcc9a4df50680686bee852e82a52fbc59b3c27", "patch": "@@ -10,8 +10,8 @@\n \n // This is an interesting test case. We have a trait (Bar) that is\n // implemented for a `Box<Foo>` object (note: no bounds). And then we\n-// have a `Box<Foo:Send>` object. The impl for `Box<Foo>` is applicable\n-// to `Box<Foo:Send>` because:\n+// have a `Box<Foo+Send>` object. The impl for `Box<Foo>` is applicable\n+// to `Box<Foo+Send>` because:\n //\n // 1. The trait Bar is contravariant w/r/t Self because `Self` appears\n //    only in argument position.\n@@ -30,7 +30,7 @@ impl Bar for Box<Foo> { fn dummy(&self) { } }\n fn wants_bar<B:Bar>(b: &B) { }\n \n fn main() {\n-    let x: Box<Foo:Send> = (box SFoo);\n+    let x: Box<Foo+Send> = (box SFoo);\n     wants_bar(&x);\n }\n "}]}