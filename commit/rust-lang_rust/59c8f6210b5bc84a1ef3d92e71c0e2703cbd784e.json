{"sha": "59c8f6210b5bc84a1ef3d92e71c0e2703cbd784e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5YzhmNjIxMGI1YmM4NGExZWYzZDkyZTcxYzBlMjcwM2NiZDc4NGU=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-02-16T13:24:22Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-02-16T13:24:22Z"}, "message": "Merge pull request #669 from shssoichiro/single-char-pattern\n\nLint single-character strings as P: Pattern args", "tree": {"sha": "2bd23103c076ebb11552650d18fd360f78be8c5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2bd23103c076ebb11552650d18fd360f78be8c5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59c8f6210b5bc84a1ef3d92e71c0e2703cbd784e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59c8f6210b5bc84a1ef3d92e71c0e2703cbd784e", "html_url": "https://github.com/rust-lang/rust/commit/59c8f6210b5bc84a1ef3d92e71c0e2703cbd784e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59c8f6210b5bc84a1ef3d92e71c0e2703cbd784e/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09ef38b30b2ca04a4e194323ceb48609239fdabe", "url": "https://api.github.com/repos/rust-lang/rust/commits/09ef38b30b2ca04a4e194323ceb48609239fdabe", "html_url": "https://github.com/rust-lang/rust/commit/09ef38b30b2ca04a4e194323ceb48609239fdabe"}, {"sha": "b1e4b496e118b47be06e362286764f077c8d899d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1e4b496e118b47be06e362286764f077c8d899d", "html_url": "https://github.com/rust-lang/rust/commit/b1e4b496e118b47be06e362286764f077c8d899d"}], "stats": {"total": 162, "additions": 158, "deletions": 4}, "files": [{"sha": "7fa0a15715f4b89cb932104b2d86d1a92a2b1c20", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/59c8f6210b5bc84a1ef3d92e71c0e2703cbd784e/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/59c8f6210b5bc84a1ef3d92e71c0e2703cbd784e/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=59c8f6210b5bc84a1ef3d92e71c0e2703cbd784e", "patch": "@@ -8,7 +8,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 121 lints included in this crate:\n+There are 122 lints included in this crate:\n \n name                                                                                                           | default | meaning\n ---------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -104,6 +104,7 @@ name\n [shadow_same](https://github.com/Manishearth/rust-clippy/wiki#shadow_same)                                     | allow   | rebinding a name to itself, e.g. `let mut x = &mut x`\n [shadow_unrelated](https://github.com/Manishearth/rust-clippy/wiki#shadow_unrelated)                           | allow   | The name is re-bound without even using the original value\n [should_implement_trait](https://github.com/Manishearth/rust-clippy/wiki#should_implement_trait)               | warn    | defining a method that should be implementing a std trait\n+[single_char_pattern](https://github.com/Manishearth/rust-clippy/wiki#single_char_pattern)                     | warn    | using a single-character str where a char could be used, e.g. `_.split(\"x\")`\n [single_match](https://github.com/Manishearth/rust-clippy/wiki#single_match)                                   | warn    | a match statement with a single nontrivial arm (i.e, where the other arm is `_ => {}`) is used; recommends `if let` instead\n [single_match_else](https://github.com/Manishearth/rust-clippy/wiki#single_match_else)                         | allow   | a match statement with a two arms where the second arm's pattern is a wildcard; recommends `if let` instead\n [str_to_string](https://github.com/Manishearth/rust-clippy/wiki#str_to_string)                                 | warn    | using `to_string()` on a str, which should be `to_owned()`"}, {"sha": "5f4f6e5291d4d1005701740d8699f96acd255fb4", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59c8f6210b5bc84a1ef3d92e71c0e2703cbd784e/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59c8f6210b5bc84a1ef3d92e71c0e2703cbd784e/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=59c8f6210b5bc84a1ef3d92e71c0e2703cbd784e", "patch": "@@ -241,6 +241,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         methods::OR_FUN_CALL,\n         methods::SEARCH_IS_SOME,\n         methods::SHOULD_IMPLEMENT_TRAIT,\n+        methods::SINGLE_CHAR_PATTERN,\n         methods::STR_TO_STRING,\n         methods::STRING_TO_STRING,\n         methods::WRONG_SELF_CONVENTION,"}, {"sha": "39f69f63d7b6c25278a7074af238290d3a9c3fd3", "filename": "src/methods.rs", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/59c8f6210b5bc84a1ef3d92e71c0e2703cbd784e/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59c8f6210b5bc84a1ef3d92e71c0e2703cbd784e/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=59c8f6210b5bc84a1ef3d92e71c0e2703cbd784e", "patch": "@@ -1,4 +1,6 @@\n use rustc::lint::*;\n+use rustc::middle::const_eval::{ConstVal, eval_const_expr_partial};\n+use rustc::middle::const_eval::EvalHint::ExprTypeChecked;\n use rustc::middle::subst::{Subst, TypeSpace};\n use rustc::middle::ty;\n use rustc_front::hir::*;\n@@ -295,6 +297,20 @@ declare_lint! {\n     pub NEW_RET_NO_SELF, Warn, \"not returning `Self` in a `new` method\"\n }\n \n+/// **What it does:** This lint checks for string methods that receive a single-character `str` as an argument, e.g. `_.split(\"x\")`.\n+///\n+/// **Why is this bad?** Performing these methods using a `char` is faster than using a `str`.\n+///\n+/// **Known problems:** Does not catch multi-byte unicode characters.\n+///\n+/// **Example:** `_.split(\"x\")` could be `_.split('x')`\n+declare_lint! {\n+    pub SINGLE_CHAR_PATTERN,\n+    Warn,\n+    \"using a single-character str where a char could be used, e.g. \\\n+     `_.split(\\\"x\\\")`\"\n+}\n+\n impl LintPass for MethodsPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(EXTEND_FROM_SLICE,\n@@ -312,7 +328,8 @@ impl LintPass for MethodsPass {\n                     CHARS_NEXT_CMP,\n                     CLONE_ON_COPY,\n                     CLONE_DOUBLE_REF,\n-                    NEW_RET_NO_SELF)\n+                    NEW_RET_NO_SELF,\n+                    SINGLE_CHAR_PATTERN)\n     }\n }\n \n@@ -351,6 +368,11 @@ impl LateLintPass for MethodsPass {\n                     lint_clone_on_copy(cx, expr);\n                     lint_clone_double_ref(cx, expr, &args[0]);\n                 }\n+                for &(method, pos) in &PATTERN_METHODS {\n+                    if name.node.as_str() == method && args.len() > pos {\n+                        lint_single_char_pattern(cx, expr, &args[pos]);\n+                    }\n+                }\n             }\n             ExprBinary(op, ref lhs, ref rhs) if op.node == BiEq || op.node == BiNe => {\n                 if !lint_chars_next(cx, expr, lhs, rhs, op.node == BiEq) {\n@@ -819,6 +841,22 @@ fn lint_chars_next(cx: &LateContext, expr: &Expr, chain: &Expr, other: &Expr, eq\n     false\n }\n \n+/// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n+fn lint_single_char_pattern(cx: &LateContext, expr: &Expr, arg: &Expr) {\n+    if let Ok(ConstVal::Str(r)) = eval_const_expr_partial(cx.tcx, arg, ExprTypeChecked, None) {\n+        if r.len() == 1 {\n+            let hint = snippet(cx, expr.span, \"..\").replace(&format!(\"\\\"{}\\\"\", r), &format!(\"'{}'\", r));\n+            span_lint_and_then(cx,\n+                               SINGLE_CHAR_PATTERN,\n+                               arg.span,\n+                               \"single-character string constant used as pattern\",\n+                               |db| {\n+                                   db.span_suggestion(expr.span, \"try using a char instead:\", hint);\n+                               });\n+        }\n+    }\n+}\n+\n /// Given a `Result<T, E>` type, return its error type (`E`).\n fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n     if !match_type(cx, ty, &RESULT_PATH) {\n@@ -889,6 +927,28 @@ const TRAIT_METHODS: [(&'static str, usize, SelfKind, OutType, &'static str); 30\n     (\"sub\", 2, SelfKind::Value, OutType::Any, \"std::ops::Sub\"),\n ];\n \n+#[cfg_attr(rustfmt, rustfmt_skip)]\n+const PATTERN_METHODS: [(&'static str, usize); 17] = [\n+    (\"contains\", 1),\n+    (\"starts_with\", 1),\n+    (\"ends_with\", 1),\n+    (\"find\", 1),\n+    (\"rfind\", 1),\n+    (\"split\", 1),\n+    (\"rsplit\", 1),\n+    (\"split_terminator\", 1),\n+    (\"rsplit_terminator\", 1),\n+    (\"splitn\", 2),\n+    (\"rsplitn\", 2),\n+    (\"matches\", 1),\n+    (\"rmatches\", 1),\n+    (\"match_indices\", 1),\n+    (\"rmatch_indices\", 1),\n+    (\"trim_left_matches\", 1),\n+    (\"trim_right_matches\", 1),\n+];\n+\n+\n #[derive(Clone, Copy)]\n enum SelfKind {\n     Value,"}, {"sha": "1999d9118041aa22e89b516e71ce4e3c25ad20a1", "filename": "src/misc_early.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59c8f6210b5bc84a1ef3d92e71c0e2703cbd784e/src%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59c8f6210b5bc84a1ef3d92e71c0e2703cbd784e/src%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc_early.rs?ref=59c8f6210b5bc84a1ef3d92e71c0e2703cbd784e", "patch": "@@ -104,7 +104,7 @@ impl EarlyLintPass for MiscEarly {\n             if let PatIdent(_, sp_ident, None) = arg.pat.node {\n                 let arg_name = sp_ident.node.to_string();\n \n-                if arg_name.starts_with(\"_\") {\n+                if arg_name.starts_with('_') {\n                     if let Some(correspondance) = registered_names.get(&arg_name[1..]) {\n                         span_lint(cx,\n                                   DUPLICATE_UNDERSCORE_ARGUMENT,"}, {"sha": "c450c953284741702a677d3d167706bbe1e27f77", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 93, "deletions": 1, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/59c8f6210b5bc84a1ef3d92e71c0e2703cbd784e/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59c8f6210b5bc84a1ef3d92e71c0e2703cbd784e/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=59c8f6210b5bc84a1ef3d92e71c0e2703cbd784e", "patch": "@@ -2,7 +2,7 @@\n #![plugin(clippy)]\n \n #![deny(clippy, clippy_pedantic)]\n-#![allow(unused, print_stdout)]\n+#![allow(unused, print_stdout, non_ascii_literal)]\n \n use std::collections::BTreeMap;\n use std::collections::HashMap;\n@@ -355,3 +355,95 @@ fn clone_on_double_ref() {\n                                 //~^^^ERROR using `clone` on a `Copy` type\n     println!(\"{:p} {:p}\",*y, z);\n }\n+\n+fn single_char_pattern() {\n+    let x = \"foo\";\n+    x.split(\"x\");\n+    //~^ ERROR single-character string constant used as pattern\n+    //~| HELP try using a char instead:\n+    //~| SUGGESTION x.split('x');\n+\n+    x.split(\"xx\");\n+\n+    x.split('x');\n+\n+    let y = \"x\";\n+    x.split(y);\n+\n+    // Not yet testing for multi-byte characters\n+    // Changing `r.len() == 1` to `r.chars().count() == 1` in `lint_single_char_pattern`\n+    // should have done this but produced an ICE\n+    //\n+    // We may not want to suggest changing these anyway\n+    // See: https://github.com/Manishearth/rust-clippy/issues/650#issuecomment-184328984\n+    x.split(\"\u00df\");\n+    x.split(\"\u211d\");\n+    x.split(\"\ud83d\udca3\");\n+    // Can't use this lint for unicode code points which don't fit in a char\n+    x.split(\"\u2764\ufe0f\");\n+\n+    x.contains(\"x\");\n+    //~^ ERROR single-character string constant used as pattern\n+    //~| HELP try using a char instead:\n+    //~| SUGGESTION x.contains('x');\n+    x.starts_with(\"x\");\n+    //~^ ERROR single-character string constant used as pattern\n+    //~| HELP try using a char instead:\n+    //~| SUGGESTION x.starts_with('x');\n+    x.ends_with(\"x\");\n+    //~^ ERROR single-character string constant used as pattern\n+    //~| HELP try using a char instead:\n+    //~| SUGGESTION x.ends_with('x');\n+    x.find(\"x\");\n+    //~^ ERROR single-character string constant used as pattern\n+    //~| HELP try using a char instead:\n+    //~| SUGGESTION x.find('x');\n+    x.rfind(\"x\");\n+    //~^ ERROR single-character string constant used as pattern\n+    //~| HELP try using a char instead:\n+    //~| SUGGESTION x.rfind('x');\n+    x.rsplit(\"x\");\n+    //~^ ERROR single-character string constant used as pattern\n+    //~| HELP try using a char instead:\n+    //~| SUGGESTION x.rsplit('x');\n+    x.split_terminator(\"x\");\n+    //~^ ERROR single-character string constant used as pattern\n+    //~| HELP try using a char instead:\n+    //~| SUGGESTION x.split_terminator('x');\n+    x.rsplit_terminator(\"x\");\n+    //~^ ERROR single-character string constant used as pattern\n+    //~| HELP try using a char instead:\n+    //~| SUGGESTION x.rsplit_terminator('x');\n+    x.splitn(0, \"x\");\n+    //~^ ERROR single-character string constant used as pattern\n+    //~| HELP try using a char instead:\n+    //~| SUGGESTION x.splitn(0, 'x');\n+    x.rsplitn(0, \"x\");\n+    //~^ ERROR single-character string constant used as pattern\n+    //~| HELP try using a char instead:\n+    //~| SUGGESTION x.rsplitn(0, 'x');\n+    x.matches(\"x\");\n+    //~^ ERROR single-character string constant used as pattern\n+    //~| HELP try using a char instead:\n+    //~| SUGGESTION x.matches('x');\n+    x.rmatches(\"x\");\n+    //~^ ERROR single-character string constant used as pattern\n+    //~| HELP try using a char instead:\n+    //~| SUGGESTION x.rmatches('x');\n+    x.match_indices(\"x\");\n+    //~^ ERROR single-character string constant used as pattern\n+    //~| HELP try using a char instead:\n+    //~| SUGGESTION x.match_indices('x');\n+    x.rmatch_indices(\"x\");\n+    //~^ ERROR single-character string constant used as pattern\n+    //~| HELP try using a char instead:\n+    //~| SUGGESTION x.rmatch_indices('x');\n+    x.trim_left_matches(\"x\");\n+    //~^ ERROR single-character string constant used as pattern\n+    //~| HELP try using a char instead:\n+    //~| SUGGESTION x.trim_left_matches('x');\n+    x.trim_right_matches(\"x\");\n+    //~^ ERROR single-character string constant used as pattern\n+    //~| HELP try using a char instead:\n+    //~| SUGGESTION x.trim_right_matches('x');\n+}"}]}