{"sha": "9c86ce76e51439a39765343f2f9ac03e12f04898", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljODZjZTc2ZTUxNDM5YTM5NzY1MzQzZjJmOWFjMDNlMTJmMDQ4OTg=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-08T20:32:58Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-10T10:16:06Z"}, "message": "resolve: Turn `resolve_error` into a method on `Resolver`\n\nRename it to `report_error` and move into `diagnostics.rs`\n\nAlso turn `check_unused` into a method on `Resolver`", "tree": {"sha": "f300e8da57f0653f0fd4e19b3fb6716e19a43511", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f300e8da57f0653f0fd4e19b3fb6716e19a43511"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c86ce76e51439a39765343f2f9ac03e12f04898", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c86ce76e51439a39765343f2f9ac03e12f04898", "html_url": "https://github.com/rust-lang/rust/commit/9c86ce76e51439a39765343f2f9ac03e12f04898", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c86ce76e51439a39765343f2f9ac03e12f04898/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a347f3701665a2e01f1f762d6be3b201b73bf42", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a347f3701665a2e01f1f762d6be3b201b73bf42", "html_url": "https://github.com/rust-lang/rust/commit/6a347f3701665a2e01f1f762d6be3b201b73bf42"}], "stats": {"total": 833, "additions": 411, "deletions": 422}, "files": [{"sha": "a6fbb0babbe5faa66811f60bf1cab11ec5e39a5f", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9c86ce76e51439a39765343f2f9ac03e12f04898/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c86ce76e51439a39765343f2f9ac03e12f04898/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=9c86ce76e51439a39765343f2f9ac03e12f04898", "patch": "@@ -9,7 +9,7 @@ use crate::resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleIm\n use crate::{Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, Segment, ToNameBinding};\n use crate::{ModuleOrUniformRoot, ParentScope, PerNS, Resolver, ResolverArenas, ExternPreludeEntry};\n use crate::Namespace::{self, TypeNS, ValueNS, MacroNS};\n-use crate::{resolve_error, resolve_struct_error, ResolutionError, Determinacy};\n+use crate::{ResolutionError, Determinacy};\n \n use rustc::bug;\n use rustc::hir::def::{self, *};\n@@ -165,8 +165,7 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n                         type_ns_only = true;\n \n                         if empty_for_self(&module_path) {\n-                            resolve_error(\n-                                &self.r,\n+                            self.r.report_error(\n                                 use_tree.span,\n                                 ResolutionError::\n                                 SelfImportOnlyInImportListWithNonEmptyPrefix\n@@ -183,9 +182,9 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n                 } else {\n                     // Disallow `self`\n                     if source.ident.name == kw::SelfLower {\n-                        resolve_error(&self.r,\n-                                      use_tree.span,\n-                                      ResolutionError::SelfImportsOnlyAllowedWithin);\n+                        self.r.report_error(\n+                            use_tree.span, ResolutionError::SelfImportsOnlyAllowedWithin\n+                        );\n                     }\n \n                     // Disallow `use $crate;`\n@@ -283,7 +282,7 @@ impl<'a> BuildReducedGraphVisitor<'_, 'a> {\n                     None\n                 }).collect::<Vec<_>>();\n                 if self_spans.len() > 1 {\n-                    let mut e = resolve_struct_error(&self.r,\n+                    let mut e = self.r.into_struct_error(\n                         self_spans[0],\n                         ResolutionError::SelfImportCanOnlyAppearOnceInTheList);\n "}, {"sha": "96d44b4b4c0dcfa82a678e865d3b559b9b23d35e", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 87, "deletions": 85, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/9c86ce76e51439a39765343f2f9ac03e12f04898/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c86ce76e51439a39765343f2f9ac03e12f04898/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=9c86ce76e51439a39765343f2f9ac03e12f04898", "patch": "@@ -221,100 +221,102 @@ fn calc_unused_spans(\n     }\n }\n \n-pub fn check_crate(resolver: &mut Resolver<'_>, krate: &ast::Crate) {\n-    for directive in resolver.potentially_unused_imports.iter() {\n-        match directive.subclass {\n-            _ if directive.used.get() ||\n-                 directive.vis.get() == ty::Visibility::Public ||\n-                 directive.span.is_dummy() => {\n-                if let ImportDirectiveSubclass::MacroUse = directive.subclass {\n-                    if !directive.span.is_dummy() {\n-                        resolver.session.buffer_lint(\n-                            lint::builtin::MACRO_USE_EXTERN_CRATE,\n-                            directive.id,\n-                            directive.span,\n-                            \"deprecated `#[macro_use]` directive used to \\\n-                             import macros should be replaced at use sites \\\n-                             with a `use` statement to import the macro \\\n-                             instead\",\n-                        );\n+impl Resolver<'_> {\n+    crate fn check_unused(&mut self, krate: &ast::Crate) {\n+        for directive in self.potentially_unused_imports.iter() {\n+            match directive.subclass {\n+                _ if directive.used.get() ||\n+                    directive.vis.get() == ty::Visibility::Public ||\n+                    directive.span.is_dummy() => {\n+                    if let ImportDirectiveSubclass::MacroUse = directive.subclass {\n+                        if !directive.span.is_dummy() {\n+                            self.session.buffer_lint(\n+                                lint::builtin::MACRO_USE_EXTERN_CRATE,\n+                                directive.id,\n+                                directive.span,\n+                                \"deprecated `#[macro_use]` directive used to \\\n+                                import macros should be replaced at use sites \\\n+                                with a `use` statement to import the macro \\\n+                                instead\",\n+                            );\n+                        }\n                     }\n                 }\n+                ImportDirectiveSubclass::ExternCrate { .. } => {\n+                    self.maybe_unused_extern_crates.push((directive.id, directive.span));\n+                }\n+                ImportDirectiveSubclass::MacroUse => {\n+                    let lint = lint::builtin::UNUSED_IMPORTS;\n+                    let msg = \"unused `#[macro_use]` import\";\n+                    self.session.buffer_lint(lint, directive.id, directive.span, msg);\n+                }\n+                _ => {}\n             }\n-            ImportDirectiveSubclass::ExternCrate { .. } => {\n-                resolver.maybe_unused_extern_crates.push((directive.id, directive.span));\n-            }\n-            ImportDirectiveSubclass::MacroUse => {\n-                let lint = lint::builtin::UNUSED_IMPORTS;\n-                let msg = \"unused `#[macro_use]` import\";\n-                resolver.session.buffer_lint(lint, directive.id, directive.span, msg);\n-            }\n-            _ => {}\n         }\n-    }\n \n-    let mut visitor = UnusedImportCheckVisitor {\n-        r: resolver,\n-        unused_imports: Default::default(),\n-        base_use_tree: None,\n-        base_id: ast::DUMMY_NODE_ID,\n-        item_span: DUMMY_SP,\n-    };\n-    visit::walk_crate(&mut visitor, krate);\n-\n-    for unused in visitor.unused_imports.values() {\n-        let mut fixes = Vec::new();\n-        let mut spans = match calc_unused_spans(unused, unused.use_tree, unused.use_tree_id) {\n-            UnusedSpanResult::Used => continue,\n-            UnusedSpanResult::FlatUnused(span, remove) => {\n-                fixes.push((remove, String::new()));\n-                vec![span]\n-            }\n-            UnusedSpanResult::NestedFullUnused(spans, remove) => {\n-                fixes.push((remove, String::new()));\n-                spans\n-            }\n-            UnusedSpanResult::NestedPartialUnused(spans, remove) => {\n-                for fix in &remove {\n-                    fixes.push((*fix, String::new()));\n-                }\n-                spans\n-            }\n+        let mut visitor = UnusedImportCheckVisitor {\n+            r: self,\n+            unused_imports: Default::default(),\n+            base_use_tree: None,\n+            base_id: ast::DUMMY_NODE_ID,\n+            item_span: DUMMY_SP,\n         };\n+        visit::walk_crate(&mut visitor, krate);\n \n-        let len = spans.len();\n-        spans.sort();\n-        let ms = MultiSpan::from_spans(spans.clone());\n-        let mut span_snippets = spans.iter()\n-            .filter_map(|s| {\n-                match visitor.r.session.source_map().span_to_snippet(*s) {\n-                    Ok(s) => Some(format!(\"`{}`\", s)),\n-                    _ => None,\n+        for unused in visitor.unused_imports.values() {\n+            let mut fixes = Vec::new();\n+            let mut spans = match calc_unused_spans(unused, unused.use_tree, unused.use_tree_id) {\n+                UnusedSpanResult::Used => continue,\n+                UnusedSpanResult::FlatUnused(span, remove) => {\n+                    fixes.push((remove, String::new()));\n+                    vec![span]\n+                }\n+                UnusedSpanResult::NestedFullUnused(spans, remove) => {\n+                    fixes.push((remove, String::new()));\n+                    spans\n                 }\n-            }).collect::<Vec<String>>();\n-        span_snippets.sort();\n-        let msg = format!(\"unused import{}{}\",\n-                          if len > 1 { \"s\" } else { \"\" },\n-                          if !span_snippets.is_empty() {\n-                              format!(\": {}\", span_snippets.join(\", \"))\n-                          } else {\n-                              String::new()\n-                          });\n+                UnusedSpanResult::NestedPartialUnused(spans, remove) => {\n+                    for fix in &remove {\n+                        fixes.push((*fix, String::new()));\n+                    }\n+                    spans\n+                }\n+            };\n \n-        let fix_msg = if fixes.len() == 1 && fixes[0].0 == unused.item_span {\n-            \"remove the whole `use` item\"\n-        } else if spans.len() > 1 {\n-            \"remove the unused imports\"\n-        } else {\n-            \"remove the unused import\"\n-        };\n+            let len = spans.len();\n+            spans.sort();\n+            let ms = MultiSpan::from_spans(spans.clone());\n+            let mut span_snippets = spans.iter()\n+                .filter_map(|s| {\n+                    match visitor.r.session.source_map().span_to_snippet(*s) {\n+                        Ok(s) => Some(format!(\"`{}`\", s)),\n+                        _ => None,\n+                    }\n+                }).collect::<Vec<String>>();\n+            span_snippets.sort();\n+            let msg = format!(\"unused import{}{}\",\n+                            if len > 1 { \"s\" } else { \"\" },\n+                            if !span_snippets.is_empty() {\n+                                format!(\": {}\", span_snippets.join(\", \"))\n+                            } else {\n+                                String::new()\n+                            });\n \n-        visitor.r.session.buffer_lint_with_diagnostic(\n-            lint::builtin::UNUSED_IMPORTS,\n-            unused.use_tree_id,\n-            ms,\n-            &msg,\n-            lint::builtin::BuiltinLintDiagnostics::UnusedImports(fix_msg.into(), fixes),\n-        );\n+            let fix_msg = if fixes.len() == 1 && fixes[0].0 == unused.item_span {\n+                \"remove the whole `use` item\"\n+            } else if spans.len() > 1 {\n+                \"remove the unused imports\"\n+            } else {\n+                \"remove the unused import\"\n+            };\n+\n+            visitor.r.session.buffer_lint_with_diagnostic(\n+                lint::builtin::UNUSED_IMPORTS,\n+                unused.use_tree_id,\n+                ms,\n+                &msg,\n+                lint::builtin::BuiltinLintDiagnostics::UnusedImports(fix_msg.into(), fixes),\n+            );\n+        }\n     }\n }"}, {"sha": "01a4a3c4bb244fdbaa44f0c69680f1cf19419ab2", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 282, "deletions": 3, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/9c86ce76e51439a39765343f2f9ac03e12f04898/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c86ce76e51439a39765343f2f9ac03e12f04898/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=9c86ce76e51439a39765343f2f9ac03e12f04898", "patch": "@@ -1,7 +1,8 @@\n use std::cmp::Reverse;\n \n-use errors::{Applicability, DiagnosticBuilder};\n+use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n use log::debug;\n+use rustc::bug;\n use rustc::hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc::hir::def::Namespace::{self, *};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n@@ -11,14 +12,16 @@ use rustc::util::nodemap::FxHashSet;\n use syntax::ast::{self, Ident, Path};\n use syntax::ext::base::MacroKind;\n use syntax::feature_gate::BUILTIN_ATTRIBUTES;\n+use syntax::source_map::SourceMap;\n+use syntax::struct_span_err;\n use syntax::symbol::{Symbol, kw};\n use syntax::util::lev_distance::find_best_match_for_name;\n-use syntax_pos::{BytePos, Span};\n+use syntax_pos::{BytePos, Span, MultiSpan};\n \n use crate::resolve_imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n use crate::{path_names_to_string, KNOWN_TOOLS};\n use crate::{CrateLint, LegacyScope, Module, ModuleOrUniformRoot};\n-use crate::{PathResult, ParentScope, Resolver, Scope, ScopeSet, Segment};\n+use crate::{PathResult, ParentScope, ResolutionError, Resolver, Scope, ScopeSet, Segment};\n \n type Res = def::Res<ast::NodeId>;\n \n@@ -42,6 +45,19 @@ crate struct ImportSuggestion {\n     pub path: Path,\n }\n \n+/// Adjust the impl span so that just the `impl` keyword is taken by removing\n+/// everything after `<` (`\"impl<T> Iterator for A<T> {}\" -> \"impl\"`) and\n+/// everything after the first whitespace (`\"impl Iterator for A\" -> \"impl\"`).\n+///\n+/// *Attention*: the method used is very fragile since it essentially duplicates the work of the\n+/// parser. If you need to use this function or something similar, please consider updating the\n+/// `source_map` functions and this function to something more robust.\n+fn reduce_impl_span_to_impl_keyword(cm: &SourceMap, impl_span: Span) -> Span {\n+    let impl_span = cm.span_until_char(impl_span, '<');\n+    let impl_span = cm.span_until_whitespace(impl_span);\n+    impl_span\n+}\n+\n crate fn add_typo_suggestion(\n     err: &mut DiagnosticBuilder<'_>, suggestion: Option<TypoSuggestion>, span: Span\n ) -> bool {\n@@ -71,6 +87,269 @@ crate fn add_module_candidates(\n }\n \n impl<'a> Resolver<'a> {\n+    /// Combines an error with provided span and emits it.\n+    ///\n+    /// This takes the error provided, combines it with the span and any additional spans inside the\n+    /// error and emits it.\n+    crate fn report_error(&self, span: Span, resolution_error: ResolutionError<'_>) {\n+        self.into_struct_error(span, resolution_error).emit();\n+    }\n+\n+    crate fn into_struct_error(\n+        &self, span: Span, resolution_error: ResolutionError<'_>\n+    ) -> DiagnosticBuilder<'_> {\n+        match resolution_error {\n+            ResolutionError::GenericParamsFromOuterFunction(outer_res) => {\n+                let mut err = struct_span_err!(self.session,\n+                    span,\n+                    E0401,\n+                    \"can't use generic parameters from outer function\",\n+                );\n+                err.span_label(span, format!(\"use of generic parameter from outer function\"));\n+\n+                let cm = self.session.source_map();\n+                match outer_res {\n+                    Res::SelfTy(maybe_trait_defid, maybe_impl_defid) => {\n+                        if let Some(impl_span) = maybe_impl_defid.and_then(|def_id| {\n+                            self.definitions.opt_span(def_id)\n+                        }) {\n+                            err.span_label(\n+                                reduce_impl_span_to_impl_keyword(cm, impl_span),\n+                                \"`Self` type implicitly declared here, by this `impl`\",\n+                            );\n+                        }\n+                        match (maybe_trait_defid, maybe_impl_defid) {\n+                            (Some(_), None) => {\n+                                err.span_label(span, \"can't use `Self` here\");\n+                            }\n+                            (_, Some(_)) => {\n+                                err.span_label(span, \"use a type here instead\");\n+                            }\n+                            (None, None) => bug!(\"`impl` without trait nor type?\"),\n+                        }\n+                        return err;\n+                    },\n+                    Res::Def(DefKind::TyParam, def_id) => {\n+                        if let Some(span) = self.definitions.opt_span(def_id) {\n+                            err.span_label(span, \"type parameter from outer function\");\n+                        }\n+                    }\n+                    Res::Def(DefKind::ConstParam, def_id) => {\n+                        if let Some(span) = self.definitions.opt_span(def_id) {\n+                            err.span_label(span, \"const parameter from outer function\");\n+                        }\n+                    }\n+                    _ => {\n+                        bug!(\"GenericParamsFromOuterFunction should only be used with Res::SelfTy, \\\n+                            DefKind::TyParam\");\n+                    }\n+                }\n+\n+                // Try to retrieve the span of the function signature and generate a new message\n+                // with a local type or const parameter.\n+                let sugg_msg = &format!(\"try using a local generic parameter instead\");\n+                if let Some((sugg_span, new_snippet)) = cm.generate_local_type_param_snippet(span) {\n+                    // Suggest the modification to the user\n+                    err.span_suggestion(\n+                        sugg_span,\n+                        sugg_msg,\n+                        new_snippet,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else if let Some(sp) = cm.generate_fn_name_span(span) {\n+                    err.span_label(sp,\n+                        format!(\"try adding a local generic parameter in this method instead\"));\n+                } else {\n+                    err.help(&format!(\"try using a local generic parameter instead\"));\n+                }\n+\n+                err\n+            }\n+            ResolutionError::NameAlreadyUsedInParameterList(name, first_use_span) => {\n+                let mut err = struct_span_err!(self.session,\n+                                                span,\n+                                                E0403,\n+                                                \"the name `{}` is already used for a generic \\\n+                                                parameter in this list of generic parameters\",\n+                                                name);\n+                err.span_label(span, \"already used\");\n+                err.span_label(first_use_span, format!(\"first use of `{}`\", name));\n+                err\n+            }\n+            ResolutionError::MethodNotMemberOfTrait(method, trait_) => {\n+                let mut err = struct_span_err!(self.session,\n+                                            span,\n+                                            E0407,\n+                                            \"method `{}` is not a member of trait `{}`\",\n+                                            method,\n+                                            trait_);\n+                err.span_label(span, format!(\"not a member of trait `{}`\", trait_));\n+                err\n+            }\n+            ResolutionError::TypeNotMemberOfTrait(type_, trait_) => {\n+                let mut err = struct_span_err!(self.session,\n+                                span,\n+                                E0437,\n+                                \"type `{}` is not a member of trait `{}`\",\n+                                type_,\n+                                trait_);\n+                err.span_label(span, format!(\"not a member of trait `{}`\", trait_));\n+                err\n+            }\n+            ResolutionError::ConstNotMemberOfTrait(const_, trait_) => {\n+                let mut err = struct_span_err!(self.session,\n+                                span,\n+                                E0438,\n+                                \"const `{}` is not a member of trait `{}`\",\n+                                const_,\n+                                trait_);\n+                err.span_label(span, format!(\"not a member of trait `{}`\", trait_));\n+                err\n+            }\n+            ResolutionError::VariableNotBoundInPattern(binding_error) => {\n+                let target_sp = binding_error.target.iter().cloned().collect::<Vec<_>>();\n+                let msp = MultiSpan::from_spans(target_sp.clone());\n+                let msg = format!(\"variable `{}` is not bound in all patterns\", binding_error.name);\n+                let mut err = self.session.struct_span_err_with_code(\n+                    msp,\n+                    &msg,\n+                    DiagnosticId::Error(\"E0408\".into()),\n+                );\n+                for sp in target_sp {\n+                    err.span_label(sp, format!(\"pattern doesn't bind `{}`\", binding_error.name));\n+                }\n+                let origin_sp = binding_error.origin.iter().cloned();\n+                for sp in origin_sp {\n+                    err.span_label(sp, \"variable not in all patterns\");\n+                }\n+                err\n+            }\n+            ResolutionError::VariableBoundWithDifferentMode(variable_name,\n+                                                            first_binding_span) => {\n+                let mut err = struct_span_err!(self.session,\n+                                span,\n+                                E0409,\n+                                \"variable `{}` is bound in inconsistent \\\n+                                ways within the same match arm\",\n+                                variable_name);\n+                err.span_label(span, \"bound in different ways\");\n+                err.span_label(first_binding_span, \"first binding\");\n+                err\n+            }\n+            ResolutionError::IdentifierBoundMoreThanOnceInParameterList(identifier) => {\n+                let mut err = struct_span_err!(self.session,\n+                                span,\n+                                E0415,\n+                                \"identifier `{}` is bound more than once in this parameter list\",\n+                                identifier);\n+                err.span_label(span, \"used as parameter more than once\");\n+                err\n+            }\n+            ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(identifier) => {\n+                let mut err = struct_span_err!(self.session,\n+                                span,\n+                                E0416,\n+                                \"identifier `{}` is bound more than once in the same pattern\",\n+                                identifier);\n+                err.span_label(span, \"used in a pattern more than once\");\n+                err\n+            }\n+            ResolutionError::UndeclaredLabel(name, lev_candidate) => {\n+                let mut err = struct_span_err!(self.session,\n+                                            span,\n+                                            E0426,\n+                                            \"use of undeclared label `{}`\",\n+                                            name);\n+                if let Some(lev_candidate) = lev_candidate {\n+                    err.span_suggestion(\n+                        span,\n+                        \"a label with a similar name exists in this scope\",\n+                        lev_candidate.to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                } else {\n+                    err.span_label(span, format!(\"undeclared label `{}`\", name));\n+                }\n+                err\n+            }\n+            ResolutionError::SelfImportsOnlyAllowedWithin => {\n+                struct_span_err!(self.session,\n+                                span,\n+                                E0429,\n+                                \"{}\",\n+                                \"`self` imports are only allowed within a { } list\")\n+            }\n+            ResolutionError::SelfImportCanOnlyAppearOnceInTheList => {\n+                let mut err = struct_span_err!(self.session, span, E0430,\n+                                            \"`self` import can only appear once in an import list\");\n+                err.span_label(span, \"can only appear once in an import list\");\n+                err\n+            }\n+            ResolutionError::SelfImportOnlyInImportListWithNonEmptyPrefix => {\n+                let mut err = struct_span_err!(self.session, span, E0431,\n+                                            \"`self` import can only appear in an import list with \\\n+                                                a non-empty prefix\");\n+                err.span_label(span, \"can only appear in an import list with a non-empty prefix\");\n+                err\n+            }\n+            ResolutionError::FailedToResolve { label, suggestion } => {\n+                let mut err = struct_span_err!(self.session, span, E0433,\n+                                            \"failed to resolve: {}\", &label);\n+                err.span_label(span, label);\n+\n+                if let Some((suggestions, msg, applicability)) = suggestion {\n+                    err.multipart_suggestion(&msg, suggestions, applicability);\n+                }\n+\n+                err\n+            }\n+            ResolutionError::CannotCaptureDynamicEnvironmentInFnItem => {\n+                let mut err = struct_span_err!(self.session,\n+                                            span,\n+                                            E0434,\n+                                            \"{}\",\n+                                            \"can't capture dynamic environment in a fn item\");\n+                err.help(\"use the `|| { ... }` closure form instead\");\n+                err\n+            }\n+            ResolutionError::AttemptToUseNonConstantValueInConstant => {\n+                let mut err = struct_span_err!(self.session, span, E0435,\n+                                            \"attempt to use a non-constant value in a constant\");\n+                err.span_label(span, \"non-constant value\");\n+                err\n+            }\n+            ResolutionError::BindingShadowsSomethingUnacceptable(what_binding, name, binding) => {\n+                let shadows_what = binding.descr();\n+                let mut err = struct_span_err!(self.session, span, E0530, \"{}s cannot shadow {}s\",\n+                                            what_binding, shadows_what);\n+                err.span_label(span, format!(\"cannot be named the same as {} {}\",\n+                                            binding.article(), shadows_what));\n+                let participle = if binding.is_import() { \"imported\" } else { \"defined\" };\n+                let msg = format!(\"the {} `{}` is {} here\", shadows_what, name, participle);\n+                err.span_label(binding.span, msg);\n+                err\n+            }\n+            ResolutionError::ForwardDeclaredTyParam => {\n+                let mut err = struct_span_err!(self.session, span, E0128,\n+                                            \"type parameters with a default cannot use \\\n+                                                forward declared identifiers\");\n+                err.span_label(\n+                    span, \"defaulted type parameters cannot be forward declared\".to_string());\n+                err\n+            }\n+            ResolutionError::ConstParamDependentOnTypeParam => {\n+                let mut err = struct_span_err!(\n+                    self.session,\n+                    span,\n+                    E0671,\n+                    \"const parameters cannot depend on type parameters\"\n+                );\n+                err.span_label(span, format!(\"const parameter depends on type parameter\"));\n+                err\n+            }\n+        }\n+    }\n+\n     /// Lookup typo candidate in scope for a macro or import.\n     fn early_lookup_typo_candidate(\n         &mut self,"}, {"sha": "0f68e0c054a0601ba2e7aa26b1852ca2e47a615f", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9c86ce76e51439a39765343f2f9ac03e12f04898/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c86ce76e51439a39765343f2f9ac03e12f04898/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=9c86ce76e51439a39765343f2f9ac03e12f04898", "patch": "@@ -1,8 +1,7 @@\n use GenericParameters::*;\n \n-use crate::{path_names_to_string, resolve_error};\n-use crate::{AliasPossibility, BindingError, CrateLint, LexicalScopeBinding, Module};\n-use crate::{ModuleOrUniformRoot, NameBinding, NameBindingKind, ParentScope, PathResult};\n+use crate::{path_names_to_string, AliasPossibility, BindingError, CrateLint, LexicalScopeBinding};\n+use crate::{Module, ModuleOrUniformRoot, NameBinding, NameBindingKind, ParentScope, PathResult};\n use crate::{PathSource, ResolutionError, Resolver, Rib, RibKind, Segment, UseError};\n use crate::RibKind::*;\n \n@@ -582,7 +581,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                                     ident.name,\n                                     *span,\n                                 );\n-                                resolve_error(&self.r, param.ident.span, err);\n+                                self.r.report_error(param.ident.span, err);\n                             }\n                             seen_bindings.entry(ident).or_insert(param.ident.span);\n \n@@ -604,7 +603,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                                     ident.name,\n                                     *span,\n                                 );\n-                                resolve_error(&self.r, param.ident.span, err);\n+                                self.r.report_error(param.ident.span, err);\n                             }\n                             seen_bindings.entry(ident).or_insert(param.ident.span);\n \n@@ -873,7 +872,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                 span,\n             ).is_err() {\n                 let path = &self.current_trait_ref.as_ref().unwrap().1.path;\n-                resolve_error(&self.r, span, err(ident.name, &path_names_to_string(path)));\n+                self.r.report_error(span, err(ident.name, &path_names_to_string(path)));\n             }\n         }\n     }\n@@ -971,15 +970,14 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         let mut missing_vars = missing_vars.iter().collect::<Vec<_>>();\n         missing_vars.sort();\n         for (_, v) in missing_vars {\n-            resolve_error(&self.r,\n-                          *v.origin.iter().next().unwrap(),\n-                          ResolutionError::VariableNotBoundInPattern(v));\n+            self.r.report_error(\n+                *v.origin.iter().next().unwrap(), ResolutionError::VariableNotBoundInPattern(v)\n+            );\n         }\n         let mut inconsistent_vars = inconsistent_vars.iter().collect::<Vec<_>>();\n         inconsistent_vars.sort();\n         for (name, v) in inconsistent_vars {\n-            let err = ResolutionError::VariableBoundWithDifferentMode(*name, v.1);\n-            resolve_error(&self.r, v.0, err);\n+            self.r.report_error(v.0, ResolutionError::VariableBoundWithDifferentMode(*name, v.1));\n         }\n     }\n \n@@ -1067,17 +1065,15 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n         match bindings.get(&ident).cloned() {\n             Some(id) if id == outer_pat_id => {\n                 // `Variant(a, a)`, error\n-                resolve_error(\n-                    &self.r,\n+                self.r.report_error(\n                     ident.span,\n                     ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(\n                         &ident.as_str())\n                 );\n             }\n             Some(..) if pat_src == PatternSource::FnParam => {\n                 // `fn f(a: u8, a: u8)`, error\n-                resolve_error(\n-                    &self.r,\n+                self.r.report_error(\n                     ident.span,\n                     ResolutionError::IdentifierBoundMoreThanOnceInParameterList(\n                         &ident.as_str())\n@@ -1141,8 +1137,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                                 // to something unusable as a pattern (e.g., constructor function),\n                                 // but we still conservatively report an error, see\n                                 // issues/33118#issuecomment-233962221 for one reason why.\n-                                resolve_error(\n-                                    &self.r,\n+                                self.r.report_error(\n                                     ident.span,\n                                     ResolutionError::BindingShadowsSomethingUnacceptable(\n                                         pat_src.descr(), ident.name, binding.unwrap())\n@@ -1448,8 +1443,7 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n                 PartialRes::new(module.res().unwrap()),\n             PathResult::Failed { is_error_from_last_segment: false, span, label, suggestion } => {\n-                let err = ResolutionError::FailedToResolve { label, suggestion };\n-                resolve_error(&self.r, span, err);\n+                self.r.report_error(span, ResolutionError::FailedToResolve { label, suggestion });\n                 PartialRes::new(Res::Err)\n             }\n             PathResult::Module(..) | PathResult::Failed { .. } => return None,\n@@ -1539,10 +1533,10 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                             find_best_match_for_name(names, &*ident.as_str(), None)\n                         });\n                         self.r.record_partial_res(expr.id, PartialRes::new(Res::Err));\n-                        resolve_error(&self.r,\n-                                      label.ident.span,\n-                                      ResolutionError::UndeclaredLabel(&label.ident.as_str(),\n-                                                                       close_match));\n+                        self.r.report_error(\n+                            label.ident.span,\n+                            ResolutionError::UndeclaredLabel(&label.ident.as_str(), close_match),\n+                        );\n                     }\n                     Some(node_id) => {\n                         // Since this res is a label, it is never read."}, {"sha": "a2b1873c4f27c2a995dccd6ba3901789712fac6f", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 15, "deletions": 298, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/9c86ce76e51439a39765343f2f9ac03e12f04898/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c86ce76e51439a39765343f2f9ac03e12f04898/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9c86ce76e51439a39765343f2f9ac03e12f04898", "patch": "@@ -33,7 +33,6 @@ use rustc::{bug, span_bug};\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n \n-use syntax::source_map::SourceMap;\n use syntax::ext::hygiene::{ExpnId, Transparency, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n use syntax::ext::base::{SyntaxExtension, MacroKind, SpecialDerives};\n@@ -45,8 +44,8 @@ use syntax::ast::{CRATE_NODE_ID, Crate, Expr, ExprKind};\n use syntax::ast::{ItemKind, Path};\n use syntax::{span_err, struct_span_err, unwrap_or};\n \n-use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n-use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n+use syntax_pos::{Span, DUMMY_SP};\n+use errors::{Applicability, DiagnosticBuilder};\n \n use log::debug;\n \n@@ -200,285 +199,6 @@ enum ResolutionError<'a> {\n     ConstParamDependentOnTypeParam,\n }\n \n-/// Combines an error with provided span and emits it.\n-///\n-/// This takes the error provided, combines it with the span and any additional spans inside the\n-/// error and emits it.\n-fn resolve_error(resolver: &Resolver<'_>,\n-                 span: Span,\n-                 resolution_error: ResolutionError<'_>) {\n-    resolve_struct_error(resolver, span, resolution_error).emit();\n-}\n-\n-fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver<'_>,\n-                                   span: Span,\n-                                   resolution_error: ResolutionError<'a>)\n-                                   -> DiagnosticBuilder<'sess> {\n-    match resolution_error {\n-        ResolutionError::GenericParamsFromOuterFunction(outer_res) => {\n-            let mut err = struct_span_err!(resolver.session,\n-                span,\n-                E0401,\n-                \"can't use generic parameters from outer function\",\n-            );\n-            err.span_label(span, format!(\"use of generic parameter from outer function\"));\n-\n-            let cm = resolver.session.source_map();\n-            match outer_res {\n-                Res::SelfTy(maybe_trait_defid, maybe_impl_defid) => {\n-                    if let Some(impl_span) = maybe_impl_defid.and_then(|def_id| {\n-                        resolver.definitions.opt_span(def_id)\n-                    }) {\n-                        err.span_label(\n-                            reduce_impl_span_to_impl_keyword(cm, impl_span),\n-                            \"`Self` type implicitly declared here, by this `impl`\",\n-                        );\n-                    }\n-                    match (maybe_trait_defid, maybe_impl_defid) {\n-                        (Some(_), None) => {\n-                            err.span_label(span, \"can't use `Self` here\");\n-                        }\n-                        (_, Some(_)) => {\n-                            err.span_label(span, \"use a type here instead\");\n-                        }\n-                        (None, None) => bug!(\"`impl` without trait nor type?\"),\n-                    }\n-                    return err;\n-                },\n-                Res::Def(DefKind::TyParam, def_id) => {\n-                    if let Some(span) = resolver.definitions.opt_span(def_id) {\n-                        err.span_label(span, \"type parameter from outer function\");\n-                    }\n-                }\n-                Res::Def(DefKind::ConstParam, def_id) => {\n-                    if let Some(span) = resolver.definitions.opt_span(def_id) {\n-                        err.span_label(span, \"const parameter from outer function\");\n-                    }\n-                }\n-                _ => {\n-                    bug!(\"GenericParamsFromOuterFunction should only be used with Res::SelfTy, \\\n-                         DefKind::TyParam\");\n-                }\n-            }\n-\n-            // Try to retrieve the span of the function signature and generate a new message with\n-            // a local type or const parameter.\n-            let sugg_msg = &format!(\"try using a local generic parameter instead\");\n-            if let Some((sugg_span, new_snippet)) = cm.generate_local_type_param_snippet(span) {\n-                // Suggest the modification to the user\n-                err.span_suggestion(\n-                    sugg_span,\n-                    sugg_msg,\n-                    new_snippet,\n-                    Applicability::MachineApplicable,\n-                );\n-            } else if let Some(sp) = cm.generate_fn_name_span(span) {\n-                err.span_label(sp,\n-                    format!(\"try adding a local generic parameter in this method instead\"));\n-            } else {\n-                err.help(&format!(\"try using a local generic parameter instead\"));\n-            }\n-\n-            err\n-        }\n-        ResolutionError::NameAlreadyUsedInParameterList(name, first_use_span) => {\n-             let mut err = struct_span_err!(resolver.session,\n-                                            span,\n-                                            E0403,\n-                                            \"the name `{}` is already used for a generic \\\n-                                            parameter in this list of generic parameters\",\n-                                            name);\n-             err.span_label(span, \"already used\");\n-             err.span_label(first_use_span, format!(\"first use of `{}`\", name));\n-             err\n-        }\n-        ResolutionError::MethodNotMemberOfTrait(method, trait_) => {\n-            let mut err = struct_span_err!(resolver.session,\n-                                           span,\n-                                           E0407,\n-                                           \"method `{}` is not a member of trait `{}`\",\n-                                           method,\n-                                           trait_);\n-            err.span_label(span, format!(\"not a member of trait `{}`\", trait_));\n-            err\n-        }\n-        ResolutionError::TypeNotMemberOfTrait(type_, trait_) => {\n-            let mut err = struct_span_err!(resolver.session,\n-                             span,\n-                             E0437,\n-                             \"type `{}` is not a member of trait `{}`\",\n-                             type_,\n-                             trait_);\n-            err.span_label(span, format!(\"not a member of trait `{}`\", trait_));\n-            err\n-        }\n-        ResolutionError::ConstNotMemberOfTrait(const_, trait_) => {\n-            let mut err = struct_span_err!(resolver.session,\n-                             span,\n-                             E0438,\n-                             \"const `{}` is not a member of trait `{}`\",\n-                             const_,\n-                             trait_);\n-            err.span_label(span, format!(\"not a member of trait `{}`\", trait_));\n-            err\n-        }\n-        ResolutionError::VariableNotBoundInPattern(binding_error) => {\n-            let target_sp = binding_error.target.iter().cloned().collect::<Vec<_>>();\n-            let msp = MultiSpan::from_spans(target_sp.clone());\n-            let msg = format!(\"variable `{}` is not bound in all patterns\", binding_error.name);\n-            let mut err = resolver.session.struct_span_err_with_code(\n-                msp,\n-                &msg,\n-                DiagnosticId::Error(\"E0408\".into()),\n-            );\n-            for sp in target_sp {\n-                err.span_label(sp, format!(\"pattern doesn't bind `{}`\", binding_error.name));\n-            }\n-            let origin_sp = binding_error.origin.iter().cloned();\n-            for sp in origin_sp {\n-                err.span_label(sp, \"variable not in all patterns\");\n-            }\n-            err\n-        }\n-        ResolutionError::VariableBoundWithDifferentMode(variable_name,\n-                                                        first_binding_span) => {\n-            let mut err = struct_span_err!(resolver.session,\n-                             span,\n-                             E0409,\n-                             \"variable `{}` is bound in inconsistent \\\n-                             ways within the same match arm\",\n-                             variable_name);\n-            err.span_label(span, \"bound in different ways\");\n-            err.span_label(first_binding_span, \"first binding\");\n-            err\n-        }\n-        ResolutionError::IdentifierBoundMoreThanOnceInParameterList(identifier) => {\n-            let mut err = struct_span_err!(resolver.session,\n-                             span,\n-                             E0415,\n-                             \"identifier `{}` is bound more than once in this parameter list\",\n-                             identifier);\n-            err.span_label(span, \"used as parameter more than once\");\n-            err\n-        }\n-        ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(identifier) => {\n-            let mut err = struct_span_err!(resolver.session,\n-                             span,\n-                             E0416,\n-                             \"identifier `{}` is bound more than once in the same pattern\",\n-                             identifier);\n-            err.span_label(span, \"used in a pattern more than once\");\n-            err\n-        }\n-        ResolutionError::UndeclaredLabel(name, lev_candidate) => {\n-            let mut err = struct_span_err!(resolver.session,\n-                                           span,\n-                                           E0426,\n-                                           \"use of undeclared label `{}`\",\n-                                           name);\n-            if let Some(lev_candidate) = lev_candidate {\n-                err.span_suggestion(\n-                    span,\n-                    \"a label with a similar name exists in this scope\",\n-                    lev_candidate.to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            } else {\n-                err.span_label(span, format!(\"undeclared label `{}`\", name));\n-            }\n-            err\n-        }\n-        ResolutionError::SelfImportsOnlyAllowedWithin => {\n-            struct_span_err!(resolver.session,\n-                             span,\n-                             E0429,\n-                             \"{}\",\n-                             \"`self` imports are only allowed within a { } list\")\n-        }\n-        ResolutionError::SelfImportCanOnlyAppearOnceInTheList => {\n-            let mut err = struct_span_err!(resolver.session, span, E0430,\n-                                           \"`self` import can only appear once in an import list\");\n-            err.span_label(span, \"can only appear once in an import list\");\n-            err\n-        }\n-        ResolutionError::SelfImportOnlyInImportListWithNonEmptyPrefix => {\n-            let mut err = struct_span_err!(resolver.session, span, E0431,\n-                                           \"`self` import can only appear in an import list with \\\n-                                            a non-empty prefix\");\n-            err.span_label(span, \"can only appear in an import list with a non-empty prefix\");\n-            err\n-        }\n-        ResolutionError::FailedToResolve { label, suggestion } => {\n-            let mut err = struct_span_err!(resolver.session, span, E0433,\n-                                           \"failed to resolve: {}\", &label);\n-            err.span_label(span, label);\n-\n-            if let Some((suggestions, msg, applicability)) = suggestion {\n-                err.multipart_suggestion(&msg, suggestions, applicability);\n-            }\n-\n-            err\n-        }\n-        ResolutionError::CannotCaptureDynamicEnvironmentInFnItem => {\n-            let mut err = struct_span_err!(resolver.session,\n-                                           span,\n-                                           E0434,\n-                                           \"{}\",\n-                                           \"can't capture dynamic environment in a fn item\");\n-            err.help(\"use the `|| { ... }` closure form instead\");\n-            err\n-        }\n-        ResolutionError::AttemptToUseNonConstantValueInConstant => {\n-            let mut err = struct_span_err!(resolver.session, span, E0435,\n-                                           \"attempt to use a non-constant value in a constant\");\n-            err.span_label(span, \"non-constant value\");\n-            err\n-        }\n-        ResolutionError::BindingShadowsSomethingUnacceptable(what_binding, name, binding) => {\n-            let shadows_what = binding.descr();\n-            let mut err = struct_span_err!(resolver.session, span, E0530, \"{}s cannot shadow {}s\",\n-                                           what_binding, shadows_what);\n-            err.span_label(span, format!(\"cannot be named the same as {} {}\",\n-                                         binding.article(), shadows_what));\n-            let participle = if binding.is_import() { \"imported\" } else { \"defined\" };\n-            let msg = format!(\"the {} `{}` is {} here\", shadows_what, name, participle);\n-            err.span_label(binding.span, msg);\n-            err\n-        }\n-        ResolutionError::ForwardDeclaredTyParam => {\n-            let mut err = struct_span_err!(resolver.session, span, E0128,\n-                                           \"type parameters with a default cannot use \\\n-                                            forward declared identifiers\");\n-            err.span_label(\n-                span, \"defaulted type parameters cannot be forward declared\".to_string());\n-            err\n-        }\n-        ResolutionError::ConstParamDependentOnTypeParam => {\n-            let mut err = struct_span_err!(\n-                resolver.session,\n-                span,\n-                E0671,\n-                \"const parameters cannot depend on type parameters\"\n-            );\n-            err.span_label(span, format!(\"const parameter depends on type parameter\"));\n-            err\n-        }\n-    }\n-}\n-\n-/// Adjust the impl span so that just the `impl` keyword is taken by removing\n-/// everything after `<` (`\"impl<T> Iterator for A<T> {}\" -> \"impl\"`) and\n-/// everything after the first whitespace (`\"impl Iterator for A\" -> \"impl\"`).\n-///\n-/// *Attention*: the method used is very fragile since it essentially duplicates the work of the\n-/// parser. If you need to use this function or something similar, please consider updating the\n-/// `source_map` functions and this function to something more robust.\n-fn reduce_impl_span_to_impl_keyword(cm: &SourceMap, impl_span: Span) -> Span {\n-    let impl_span = cm.span_until_char(impl_span, '<');\n-    let impl_span = cm.span_until_whitespace(impl_span);\n-    impl_span\n-}\n-\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum AliasPossibility {\n     No,\n@@ -1503,7 +1223,7 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         match self.resolve_ast_path_inner(path, is_value) {\n             Ok(r) => r,\n             Err((span, error)) => {\n-                resolve_error(self, span, error);\n+                self.report_error(span, error);\n                 Res::Err\n             }\n         }\n@@ -1736,7 +1456,7 @@ impl<'a> Resolver<'a> {\n \n         self.late_resolve_crate(krate);\n \n-        check_unused::check_crate(self, krate);\n+        self.check_unused(krate);\n         self.report_errors(krate);\n         self.crate_loader.postprocess(krate);\n     }\n@@ -2581,7 +2301,7 @@ impl<'a> Resolver<'a> {\n         // An invalid forward use of a type parameter from a previous default.\n         if let ForwardTyParamBanRibKind = all_ribs[rib_index].kind {\n             if record_used {\n-                resolve_error(self, span, ResolutionError::ForwardDeclaredTyParam);\n+                self.report_error(span, ResolutionError::ForwardDeclaredTyParam);\n             }\n             assert_eq!(res, Res::Err);\n             return Res::Err;\n@@ -2590,7 +2310,7 @@ impl<'a> Resolver<'a> {\n         // An invalid use of a type parameter as the type of a const parameter.\n         if let TyParamAsConstParamTy = all_ribs[rib_index].kind {\n             if record_used {\n-                resolve_error(self, span, ResolutionError::ConstParamDependentOnTypeParam);\n+                self.report_error(span, ResolutionError::ConstParamDependentOnTypeParam);\n             }\n             assert_eq!(res, Res::Err);\n             return Res::Err;\n@@ -2622,14 +2342,14 @@ impl<'a> Resolver<'a> {\n                         ConstantItemRibKind => {\n                             // Still doesn't deal with upvars\n                             if record_used {\n-                                resolve_error(self, span, AttemptToUseNonConstantValueInConstant);\n+                                self.report_error(span, AttemptToUseNonConstantValueInConstant);\n                             }\n                             return Res::Err;\n                         }\n                     }\n                 }\n                 if let Some(res_err) = res_err {\n-                     resolve_error(self, span, res_err);\n+                     self.report_error(span, res_err);\n                      return Res::Err;\n                 }\n             }\n@@ -2644,10 +2364,8 @@ impl<'a> Resolver<'a> {\n                         ItemRibKind | FnItemRibKind => {\n                             // This was an attempt to use a type parameter outside its scope.\n                             if record_used {\n-                                resolve_error(\n-                                    self,\n-                                    span,\n-                                    ResolutionError::GenericParamsFromOuterFunction(res),\n+                                self.report_error(\n+                                    span, ResolutionError::GenericParamsFromOuterFunction(res)\n                                 );\n                             }\n                             return Res::Err;\n@@ -2667,10 +2385,8 @@ impl<'a> Resolver<'a> {\n                     if let ItemRibKind | FnItemRibKind = rib.kind {\n                         // This was an attempt to use a const parameter outside its scope.\n                         if record_used {\n-                            resolve_error(\n-                                self,\n-                                span,\n-                                ResolutionError::GenericParamsFromOuterFunction(res),\n+                            self.report_error(\n+                                span, ResolutionError::GenericParamsFromOuterFunction(res)\n                             );\n                         }\n                         return Res::Err;\n@@ -2773,8 +2489,9 @@ impl<'a> Resolver<'a> {\n                         ty::Visibility::Public\n                     }\n                     PathResult::Failed { span, label, suggestion, .. } => {\n-                        let err = ResolutionError::FailedToResolve { label, suggestion };\n-                        resolve_error(self, span, err);\n+                        self.report_error(\n+                            span, ResolutionError::FailedToResolve { label, suggestion }\n+                        );\n                         ty::Visibility::Public\n                     }\n                     PathResult::Indeterminate => {"}, {"sha": "78edb685eddac9092be7fbd06df59828525fbe75", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c86ce76e51439a39765343f2f9ac03e12f04898/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c86ce76e51439a39765343f2f9ac03e12f04898/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=9c86ce76e51439a39765343f2f9ac03e12f04898", "patch": "@@ -1,8 +1,7 @@\n use crate::{AmbiguityError, AmbiguityKind, AmbiguityErrorMisc, Determinacy};\n use crate::{CrateLint, Resolver, ResolutionError, Scope, ScopeSet, ParentScope, Weak};\n use crate::{Module, ModuleKind, NameBinding, PathResult, Segment, ToNameBinding};\n-use crate::{resolve_error, KNOWN_TOOLS};\n-use crate::ModuleOrUniformRoot;\n+use crate::{ModuleOrUniformRoot, KNOWN_TOOLS};\n use crate::Namespace::*;\n use crate::build_reduced_graph::{BuildReducedGraphVisitor, IsMacroExport};\n use crate::resolve_imports::ImportResolver;\n@@ -768,7 +767,7 @@ impl<'a> Resolver<'a> {\n                         (path_span, format!(\"partially resolved path in {} {}\",\n                                             kind.article(), kind.descr()))\n                     };\n-                    resolve_error(self, span, ResolutionError::FailedToResolve {\n+                    self.report_error(span, ResolutionError::FailedToResolve {\n                         label,\n                         suggestion: None\n                     });"}, {"sha": "aef586fe43c033564110c3ca3119d168ef83d78b", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c86ce76e51439a39765343f2f9ac03e12f04898/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c86ce76e51439a39765343f2f9ac03e12f04898/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=9c86ce76e51439a39765343f2f9ac03e12f04898", "patch": "@@ -5,9 +5,8 @@ use crate::{CrateLint, Module, ModuleOrUniformRoot, PerNS, ScopeSet, ParentScope\n use crate::Determinacy::{self, *};\n use crate::Namespace::{self, TypeNS, MacroNS};\n use crate::{NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n-use crate::{Resolver, Segment};\n+use crate::{Resolver, ResolutionError, Segment};\n use crate::{names_to_string, module_to_string};\n-use crate::{resolve_error, ResolutionError};\n use crate::ModuleKind;\n use crate::build_reduced_graph::BuildReducedGraphVisitor;\n use crate::diagnostics::Suggestion;\n@@ -913,7 +912,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             PathResult::Failed { is_error_from_last_segment: false, span, label, suggestion } => {\n                 if no_ambiguity {\n                     assert!(directive.imported_module.get().is_none());\n-                    resolve_error(&self.r, span, ResolutionError::FailedToResolve {\n+                    self.r.report_error(span, ResolutionError::FailedToResolve {\n                         label,\n                         suggestion,\n                     });"}]}