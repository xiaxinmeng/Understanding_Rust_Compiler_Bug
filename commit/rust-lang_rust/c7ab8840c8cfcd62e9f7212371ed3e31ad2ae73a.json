{"sha": "c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3YWI4ODQwYzhjZmNkNjJlOWY3MjEyMzcxZWQzZTMxYWQyYWU3M2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-11T06:40:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-11T06:40:09Z"}, "message": "Auto merge of #33425 - eddyb:rift, r=nikomatsakis\n\nSplit the type context into a global and a local (inference-only) one.\n\nAfter this change, each `InferCtxt` creates its own local type interner for types with inference by-products.\nMost of the code which handles both a global and a local interner uses `'gcx` and `'tcx` for them.\nA reference to the type context in that situation (e.g. `infcx.tcx`) is `TyCtxt<'a, 'gcx, 'tcx>`.\nThe global type context which used to be `&'a TyCtxt<'tcx>` is now `TyCtxt<'a, 'tcx, 'tcx>`.\n\nIn order to minimize the number of extra lifetime parameters, many functions became methods.\nWhere possible (some inherent impls), lifetime parameters were added on the impl, not each method.\n\nAs inference by-products no longer escape their inference contexts, memory usage is lower.\nExample of `-Z time-passes` excerpt for `librustc`, stage1 (~100MB gains):\nBefore \"rustc: Split local type contexts interners from the global one.\":\n```\ntime: 0.395; rss: 335MB item-types checking\ntime: 15.392; rss: 472MB        item-bodies checking\ntime: 0.000; rss: 472MB drop-impl checking\ntime: 1.140; rss: 478MB const checking\ntime: 0.139; rss: 478MB privacy checking\ntime: 0.024; rss: 478MB stability index\ntime: 0.072; rss: 478MB intrinsic checking\ntime: 0.038; rss: 478MB effect checking\ntime: 0.255; rss: 478MB match checking\ntime: 0.128; rss: 484MB liveness checking\ntime: 1.372; rss: 484MB rvalue checking\ntime: 1.404; rss: 597MB MIR dump\ntime: 0.809; rss: 599MB MIR passes\n```\nAfter:\n```\ntime: 0.467; rss: 337MB item-types checking\ntime: 17.443; rss: 395MB        item-bodies checking\ntime: 0.000; rss: 395MB drop-impl checking\ntime: 1.423; rss: 401MB const checking\ntime: 0.141; rss: 401MB privacy checking\ntime: 0.024; rss: 401MB stability index\ntime: 0.116; rss: 401MB intrinsic checking\ntime: 0.038; rss: 401MB effect checking\ntime: 0.382; rss: 401MB match checking\ntime: 0.132; rss: 407MB liveness checking\ntime: 1.678; rss: 407MB rvalue checking\ntime: 1.614; rss: 503MB MIR dump\ntime: 0.957; rss: 512MB MIR passes\n```\n\n**NOTE**: Functions changed to methods weren't re-indented to keep this PR easier to review.\nOnce approved, the changes will be mechanically performed.\nHowever, indentation changes of function arguments are there - and I believe there's a way to hide whitespace-only changes in diffs on GitHub.", "tree": {"sha": "59f7a6c566aec947e71f2521a704ce93f0ff9184", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59f7a6c566aec947e71f2521a704ce93f0ff9184"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "html_url": "https://github.com/rust-lang/rust/commit/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80ec1b9f1040fba67846924234167feeb24d1f68", "url": "https://api.github.com/repos/rust-lang/rust/commits/80ec1b9f1040fba67846924234167feeb24d1f68", "html_url": "https://github.com/rust-lang/rust/commit/80ec1b9f1040fba67846924234167feeb24d1f68"}, {"sha": "42eb7032fab11aca9228d42969f471b581444c56", "url": "https://api.github.com/repos/rust-lang/rust/commits/42eb7032fab11aca9228d42969f471b581444c56", "html_url": "https://github.com/rust-lang/rust/commit/42eb7032fab11aca9228d42969f471b581444c56"}], "stats": {"total": 29956, "additions": 15089, "deletions": 14867}, "files": [{"sha": "64c51c9432853546992a0238615880c44d57a5ad", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -19,7 +19,7 @@ use syntax::ptr::P;\n use hir::{self, PatKind};\n \n struct CFGBuilder<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     graph: CFGGraph,\n     fn_exit: CFGIndex,\n     loop_scopes: Vec<LoopScope>,\n@@ -32,8 +32,8 @@ struct LoopScope {\n     break_index: CFGIndex,    // where to go on a `break\n }\n \n-pub fn construct(tcx: &TyCtxt,\n-                 blk: &hir::Block) -> CFG {\n+pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           blk: &hir::Block) -> CFG {\n     let mut graph = graph::Graph::new();\n     let entry = graph.add_node(CFGNodeData::Entry);\n "}, {"sha": "617e2ed2f1aebfb5abd2cc859f6236c0c4856da5", "filename": "src/librustc/cfg/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fmod.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -58,8 +58,8 @@ pub type CFGNode = graph::Node<CFGNodeData>;\n pub type CFGEdge = graph::Edge<CFGEdgeData>;\n \n impl CFG {\n-    pub fn new(tcx: &TyCtxt,\n-               blk: &hir::Block) -> CFG {\n+    pub fn new<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                         blk: &hir::Block) -> CFG {\n         construct::construct(tcx, blk)\n     }\n "}, {"sha": "321d109ca0e726f8ce689f643ca09b4c22968599", "filename": "src/librustc/dep_graph/visit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -22,13 +22,13 @@ use super::dep_node::DepNode;\n /// read edge from the corresponding AST node. This is used in\n /// compiler passes to automatically record the item that they are\n /// working on.\n-pub fn visit_all_items_in_krate<'tcx,V,F>(tcx: &TyCtxt<'tcx>,\n-                                          mut dep_node_fn: F,\n-                                          visitor: &mut V)\n+pub fn visit_all_items_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                mut dep_node_fn: F,\n+                                                visitor: &mut V)\n     where F: FnMut(DefId) -> DepNode<DefId>, V: Visitor<'tcx>\n {\n     struct TrackingVisitor<'visit, 'tcx: 'visit, F: 'visit, V: 'visit> {\n-        tcx: &'visit TyCtxt<'tcx>,\n+        tcx: TyCtxt<'visit, 'tcx, 'tcx>,\n         dep_node_fn: &'visit mut F,\n         visitor: &'visit mut V\n     }"}, {"sha": "a056ba588b807998d4675e4fe18156b1c0cb7a42", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -17,8 +17,7 @@ use hir;\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Def {\n     Fn(DefId),\n-    SelfTy(Option<DefId>,                    // trait id\n-              Option<(ast::NodeId, ast::NodeId)>),   // (impl id, self type id)\n+    SelfTy(Option<DefId> /* trait */, Option<ast::NodeId> /* impl */),\n     Mod(DefId),\n     ForeignMod(DefId),\n     Static(DefId, bool /* is_mutbl */),"}, {"sha": "6bbd6a207ee0477cb3adf896d92965284b2a1632", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -209,7 +209,7 @@ pub fn simple_name<'a>(pat: &'a hir::Pat) -> Option<ast::Name> {\n     }\n }\n \n-pub fn def_to_path(tcx: &TyCtxt, id: DefId) -> hir::Path {\n+pub fn def_to_path<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> hir::Path {\n     let name = tcx.item_name(id);\n     hir::Path::from_ident(DUMMY_SP, hir::Ident::from_name(name))\n }"}, {"sha": "96b14a6c321cd2a5d99fbc309416033f9927c932", "filename": "src/librustc/infer/bivariate.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fbivariate.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -25,35 +25,35 @@\n //! In particular, it might be enough to say (A,B) are bivariant for\n //! all (A,B).\n \n-use super::combine::{self, CombineFields};\n+use super::combine::CombineFields;\n use super::type_variable::{BiTo};\n \n use ty::{self, Ty, TyCtxt};\n use ty::TyVar;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n \n-pub struct Bivariate<'a, 'tcx: 'a> {\n-    fields: CombineFields<'a, 'tcx>\n+pub struct Bivariate<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'gcx, 'tcx>\n }\n \n-impl<'a, 'tcx> Bivariate<'a, 'tcx> {\n-    pub fn new(fields: CombineFields<'a, 'tcx>) -> Bivariate<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Bivariate<'a, 'gcx, 'tcx> {\n+    pub fn new(fields: CombineFields<'a, 'gcx, 'tcx>) -> Bivariate<'a, 'gcx, 'tcx> {\n         Bivariate { fields: fields }\n     }\n }\n \n-impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Bivariate<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Bivariate<'a, 'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Bivariate\" }\n \n-    fn tcx(&self) -> &'a TyCtxt<'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n-    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n-                                               variance: ty::Variance,\n-                                               a: &T,\n-                                               b: &T)\n-                                               -> RelateResult<'tcx, T>\n+    fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n+                                             variance: ty::Variance,\n+                                             a: &T,\n+                                             b: &T)\n+                                             -> RelateResult<'tcx, T>\n     {\n         match variance {\n             // If we have Foo<A> and Foo is invariant w/r/t A,\n@@ -96,7 +96,7 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Bivariate<'a, 'tcx> {\n             }\n \n             _ => {\n-                combine::super_combine_tys(self.fields.infcx, self, a, b)\n+                self.fields.infcx.super_combine_tys(self, a, b)\n             }\n         }\n     }\n@@ -107,7 +107,7 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Bivariate<'a, 'tcx> {\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n-        where T: Relate<'a,'tcx>\n+        where T: Relate<'tcx>\n     {\n         let a1 = self.tcx().erase_late_bound_regions(a);\n         let b1 = self.tcx().erase_late_bound_regions(b);"}, {"sha": "e2f27074dbfc9206a2fe466a0546ef53e9fa4b82", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 93, "deletions": 91, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -52,131 +52,133 @@ use syntax::ast;\n use syntax::codemap::Span;\n \n #[derive(Clone)]\n-pub struct CombineFields<'a, 'tcx: 'a> {\n-    pub infcx: &'a InferCtxt<'a, 'tcx>,\n+pub struct CombineFields<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    pub infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     pub a_is_expected: bool,\n     pub trace: TypeTrace<'tcx>,\n     pub cause: Option<ty::relate::Cause>,\n     pub obligations: PredicateObligations<'tcx>,\n }\n \n-pub fn super_combine_tys<'a,'tcx:'a,R>(infcx: &InferCtxt<'a, 'tcx>,\n-                                       relation: &mut R,\n-                                       a: Ty<'tcx>,\n-                                       b: Ty<'tcx>)\n-                                       -> RelateResult<'tcx, Ty<'tcx>>\n-    where R: TypeRelation<'a,'tcx>\n-{\n-    let a_is_expected = relation.a_is_expected();\n-\n-    match (&a.sty, &b.sty) {\n-        // Relate integral variables to other types\n-        (&ty::TyInfer(ty::IntVar(a_id)), &ty::TyInfer(ty::IntVar(b_id))) => {\n-            infcx.int_unification_table\n-                 .borrow_mut()\n-                 .unify_var_var(a_id, b_id)\n-                 .map_err(|e| int_unification_error(a_is_expected, e))?;\n-            Ok(a)\n-        }\n-        (&ty::TyInfer(ty::IntVar(v_id)), &ty::TyInt(v)) => {\n-            unify_integral_variable(infcx, a_is_expected, v_id, IntType(v))\n-        }\n-        (&ty::TyInt(v), &ty::TyInfer(ty::IntVar(v_id))) => {\n-            unify_integral_variable(infcx, !a_is_expected, v_id, IntType(v))\n-        }\n-        (&ty::TyInfer(ty::IntVar(v_id)), &ty::TyUint(v)) => {\n-            unify_integral_variable(infcx, a_is_expected, v_id, UintType(v))\n-        }\n-        (&ty::TyUint(v), &ty::TyInfer(ty::IntVar(v_id))) => {\n-            unify_integral_variable(infcx, !a_is_expected, v_id, UintType(v))\n-        }\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    pub fn super_combine_tys<R>(&self,\n+                                relation: &mut R,\n+                                a: Ty<'tcx>,\n+                                b: Ty<'tcx>)\n+                                -> RelateResult<'tcx, Ty<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>\n+    {\n+        let a_is_expected = relation.a_is_expected();\n+\n+        match (&a.sty, &b.sty) {\n+            // Relate integral variables to other types\n+            (&ty::TyInfer(ty::IntVar(a_id)), &ty::TyInfer(ty::IntVar(b_id))) => {\n+                self.int_unification_table\n+                    .borrow_mut()\n+                    .unify_var_var(a_id, b_id)\n+                    .map_err(|e| int_unification_error(a_is_expected, e))?;\n+                Ok(a)\n+            }\n+            (&ty::TyInfer(ty::IntVar(v_id)), &ty::TyInt(v)) => {\n+                self.unify_integral_variable(a_is_expected, v_id, IntType(v))\n+            }\n+            (&ty::TyInt(v), &ty::TyInfer(ty::IntVar(v_id))) => {\n+                self.unify_integral_variable(!a_is_expected, v_id, IntType(v))\n+            }\n+            (&ty::TyInfer(ty::IntVar(v_id)), &ty::TyUint(v)) => {\n+                self.unify_integral_variable(a_is_expected, v_id, UintType(v))\n+            }\n+            (&ty::TyUint(v), &ty::TyInfer(ty::IntVar(v_id))) => {\n+                self.unify_integral_variable(!a_is_expected, v_id, UintType(v))\n+            }\n \n-        // Relate floating-point variables to other types\n-        (&ty::TyInfer(ty::FloatVar(a_id)), &ty::TyInfer(ty::FloatVar(b_id))) => {\n-            infcx.float_unification_table\n-                 .borrow_mut()\n-                 .unify_var_var(a_id, b_id)\n-                 .map_err(|e| float_unification_error(relation.a_is_expected(), e))?;\n-            Ok(a)\n-        }\n-        (&ty::TyInfer(ty::FloatVar(v_id)), &ty::TyFloat(v)) => {\n-            unify_float_variable(infcx, a_is_expected, v_id, v)\n-        }\n-        (&ty::TyFloat(v), &ty::TyInfer(ty::FloatVar(v_id))) => {\n-            unify_float_variable(infcx, !a_is_expected, v_id, v)\n-        }\n+            // Relate floating-point variables to other types\n+            (&ty::TyInfer(ty::FloatVar(a_id)), &ty::TyInfer(ty::FloatVar(b_id))) => {\n+                self.float_unification_table\n+                    .borrow_mut()\n+                    .unify_var_var(a_id, b_id)\n+                    .map_err(|e| float_unification_error(relation.a_is_expected(), e))?;\n+                Ok(a)\n+            }\n+            (&ty::TyInfer(ty::FloatVar(v_id)), &ty::TyFloat(v)) => {\n+                self.unify_float_variable(a_is_expected, v_id, v)\n+            }\n+            (&ty::TyFloat(v), &ty::TyInfer(ty::FloatVar(v_id))) => {\n+                self.unify_float_variable(!a_is_expected, v_id, v)\n+            }\n \n-        // All other cases of inference are errors\n-        (&ty::TyInfer(_), _) |\n-        (_, &ty::TyInfer(_)) => {\n-            Err(TypeError::Sorts(ty::relate::expected_found(relation, &a, &b)))\n-        }\n+            // All other cases of inference are errors\n+            (&ty::TyInfer(_), _) |\n+            (_, &ty::TyInfer(_)) => {\n+                Err(TypeError::Sorts(ty::relate::expected_found(relation, &a, &b)))\n+            }\n \n \n-        _ => {\n-            ty::relate::super_relate_tys(relation, a, b)\n+            _ => {\n+                ty::relate::super_relate_tys(relation, a, b)\n+            }\n         }\n     }\n-}\n \n-fn unify_integral_variable<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                                    vid_is_expected: bool,\n-                                    vid: ty::IntVid,\n-                                    val: ty::IntVarValue)\n-                                    -> RelateResult<'tcx, Ty<'tcx>>\n-{\n-    infcx.int_unification_table\n-         .borrow_mut()\n-         .unify_var_value(vid, val)\n-         .map_err(|e| int_unification_error(vid_is_expected, e))?;\n-    match val {\n-        IntType(v) => Ok(infcx.tcx.mk_mach_int(v)),\n-        UintType(v) => Ok(infcx.tcx.mk_mach_uint(v)),\n+    fn unify_integral_variable(&self,\n+                               vid_is_expected: bool,\n+                               vid: ty::IntVid,\n+                               val: ty::IntVarValue)\n+                               -> RelateResult<'tcx, Ty<'tcx>>\n+    {\n+        self.int_unification_table\n+            .borrow_mut()\n+            .unify_var_value(vid, val)\n+            .map_err(|e| int_unification_error(vid_is_expected, e))?;\n+        match val {\n+            IntType(v) => Ok(self.tcx.mk_mach_int(v)),\n+            UintType(v) => Ok(self.tcx.mk_mach_uint(v)),\n+        }\n     }\n-}\n \n-fn unify_float_variable<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                                 vid_is_expected: bool,\n-                                 vid: ty::FloatVid,\n-                                 val: ast::FloatTy)\n-                                 -> RelateResult<'tcx, Ty<'tcx>>\n-{\n-    infcx.float_unification_table\n-         .borrow_mut()\n-         .unify_var_value(vid, val)\n-         .map_err(|e| float_unification_error(vid_is_expected, e))?;\n-    Ok(infcx.tcx.mk_mach_float(val))\n+    fn unify_float_variable(&self,\n+                            vid_is_expected: bool,\n+                            vid: ty::FloatVid,\n+                            val: ast::FloatTy)\n+                            -> RelateResult<'tcx, Ty<'tcx>>\n+    {\n+        self.float_unification_table\n+            .borrow_mut()\n+            .unify_var_value(vid, val)\n+            .map_err(|e| float_unification_error(vid_is_expected, e))?;\n+        Ok(self.tcx.mk_mach_float(val))\n+    }\n }\n \n-impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n-    pub fn tcx(&self) -> &'a TyCtxt<'tcx> {\n+impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn switch_expected(&self) -> CombineFields<'a, 'tcx> {\n+    pub fn switch_expected(&self) -> CombineFields<'a, 'gcx, 'tcx> {\n         CombineFields {\n             a_is_expected: !self.a_is_expected,\n             ..(*self).clone()\n         }\n     }\n \n-    pub fn equate(&self) -> Equate<'a, 'tcx> {\n+    pub fn equate(&self) -> Equate<'a, 'gcx, 'tcx> {\n         Equate::new(self.clone())\n     }\n \n-    pub fn bivariate(&self) -> Bivariate<'a, 'tcx> {\n+    pub fn bivariate(&self) -> Bivariate<'a, 'gcx, 'tcx> {\n         Bivariate::new(self.clone())\n     }\n \n-    pub fn sub(&self) -> Sub<'a, 'tcx> {\n+    pub fn sub(&self) -> Sub<'a, 'gcx, 'tcx> {\n         Sub::new(self.clone())\n     }\n \n-    pub fn lub(&self) -> Lub<'a, 'tcx> {\n+    pub fn lub(&self) -> Lub<'a, 'gcx, 'tcx> {\n         Lub::new(self.clone())\n     }\n \n-    pub fn glb(&self) -> Glb<'a, 'tcx> {\n+    pub fn glb(&self) -> Glb<'a, 'gcx, 'tcx> {\n         Glb::new(self.clone())\n     }\n \n@@ -289,16 +291,16 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n     }\n }\n \n-struct Generalizer<'cx, 'tcx:'cx> {\n-    infcx: &'cx InferCtxt<'cx, 'tcx>,\n+struct Generalizer<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n     span: Span,\n     for_vid: ty::TyVid,\n     make_region_vars: bool,\n     cycle_detected: bool,\n }\n \n-impl<'cx, 'tcx> ty::fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n-    fn tcx(&self) -> &TyCtxt<'tcx> {\n+impl<'cx, 'gcx, 'tcx> ty::fold::TypeFolder<'gcx, 'tcx> for Generalizer<'cx, 'gcx, 'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "408f22cf15c77dfa46afb74826ca2e16b8672678", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::combine::{self, CombineFields};\n-use super::higher_ranked::HigherRankedRelations;\n+use super::combine::CombineFields;\n use super::{Subtype};\n use super::type_variable::{EqTo};\n \n@@ -19,12 +18,12 @@ use ty::relate::{Relate, RelateResult, TypeRelation};\n use traits::PredicateObligations;\n \n /// Ensures `a` is made equal to `b`. Returns `a` on success.\n-pub struct Equate<'a, 'tcx: 'a> {\n-    fields: CombineFields<'a, 'tcx>\n+pub struct Equate<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'gcx, 'tcx>\n }\n \n-impl<'a, 'tcx> Equate<'a, 'tcx> {\n-    pub fn new(fields: CombineFields<'a, 'tcx>) -> Equate<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Equate<'a, 'gcx, 'tcx> {\n+    pub fn new(fields: CombineFields<'a, 'gcx, 'tcx>) -> Equate<'a, 'gcx, 'tcx> {\n         Equate { fields: fields }\n     }\n \n@@ -33,18 +32,18 @@ impl<'a, 'tcx> Equate<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Equate<'a, 'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Equate\" }\n \n-    fn tcx(&self) -> &'a TyCtxt<'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n-    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n-                                               _: ty::Variance,\n-                                               a: &T,\n-                                               b: &T)\n-                                               -> RelateResult<'tcx, T>\n+    fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n+                                             _: ty::Variance,\n+                                             a: &T,\n+                                             b: &T)\n+                                             -> RelateResult<'tcx, T>\n     {\n         self.relate(a, b)\n     }\n@@ -74,7 +73,7 @@ impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx> {\n             }\n \n             _ => {\n-                combine::super_combine_tys(self.fields.infcx, self, a, b)?;\n+                self.fields.infcx.super_combine_tys(self, a, b)?;\n                 Ok(a)\n             }\n         }\n@@ -92,7 +91,7 @@ impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx> {\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n-        where T: Relate<'a, 'tcx>\n+        where T: Relate<'tcx>\n     {\n         self.fields.higher_ranked_sub(a, b)?;\n         self.fields.higher_ranked_sub(b, a)"}, {"sha": "3900fab2d930a3e6e71483fe7e7c391988e10287", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 32, "deletions": 105, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -95,8 +95,8 @@ use syntax::codemap::{self, Pos, Span};\n use syntax::parse::token;\n use syntax::ptr::P;\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn note_and_explain_region(&self,\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    pub fn note_and_explain_region(self,\n                                    err: &mut DiagnosticBuilder,\n                                    prefix: &str,\n                                    region: ty::Region,\n@@ -112,8 +112,9 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n         }\n \n-        fn explain_span(tcx: &TyCtxt, heading: &str, span: Span)\n-                        -> (String, Option<Span>) {\n+        fn explain_span<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                        heading: &str, span: Span)\n+                                        -> (String, Option<Span>) {\n             let lo = tcx.sess.codemap().lookup_char_pos_adj(span.lo);\n             (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize()),\n              Some(span))\n@@ -227,83 +228,9 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-pub trait ErrorReporting<'tcx> {\n-    fn report_region_errors(&self,\n-                            errors: &Vec<RegionResolutionError<'tcx>>);\n-\n-    fn process_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>)\n-                      -> Option<Vec<RegionResolutionError<'tcx>>>;\n-\n-    fn report_type_error(&self,\n-                         trace: TypeTrace<'tcx>,\n-                         terr: &TypeError<'tcx>)\n-                         -> DiagnosticBuilder<'tcx>;\n-\n-    fn check_and_note_conflicting_crates(&self,\n-                                         err: &mut DiagnosticBuilder,\n-                                         terr: &TypeError<'tcx>,\n-                                         sp: Span);\n-\n-    fn report_and_explain_type_error(&self,\n-                                     trace: TypeTrace<'tcx>,\n-                                     terr: &TypeError<'tcx>)\n-                                     -> DiagnosticBuilder<'tcx>;\n-\n-    fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<(String, String)>;\n-\n-    fn expected_found_str<T: fmt::Display + Resolvable<'tcx> + TypeFoldable<'tcx>>(\n-        &self,\n-        exp_found: &ty::error::ExpectedFound<T>)\n-        -> Option<(String, String)>;\n-\n-    fn report_concrete_failure(&self,\n-                               origin: SubregionOrigin<'tcx>,\n-                               sub: Region,\n-                               sup: Region)\n-                                -> DiagnosticBuilder<'tcx>;\n-\n-    fn report_generic_bound_failure(&self,\n-                                    origin: SubregionOrigin<'tcx>,\n-                                    kind: GenericKind<'tcx>,\n-                                    sub: Region);\n-\n-    fn report_sub_sup_conflict(&self,\n-                               var_origin: RegionVariableOrigin,\n-                               sub_origin: SubregionOrigin<'tcx>,\n-                               sub_region: Region,\n-                               sup_origin: SubregionOrigin<'tcx>,\n-                               sup_region: Region);\n-\n-    fn report_processed_errors(&self,\n-                               origins: &[ProcessedErrorOrigin<'tcx>],\n-                               same_regions: &[SameRegions]);\n-\n-    fn give_suggestion(&self, err: &mut DiagnosticBuilder, same_regions: &[SameRegions]);\n-}\n-\n-trait ErrorReportingHelpers<'tcx> {\n-    fn report_inference_failure(&self,\n-                                var_origin: RegionVariableOrigin)\n-                                -> DiagnosticBuilder<'tcx>;\n-\n-    fn note_region_origin(&self,\n-                          err: &mut DiagnosticBuilder,\n-                          origin: &SubregionOrigin<'tcx>);\n-\n-    fn give_expl_lifetime_param(&self,\n-                                err: &mut DiagnosticBuilder,\n-                                decl: &hir::FnDecl,\n-                                unsafety: hir::Unsafety,\n-                                constness: hir::Constness,\n-                                name: ast::Name,\n-                                opt_explicit_self: Option<&hir::ExplicitSelf_>,\n-                                generics: &hir::Generics,\n-                                span: Span);\n-}\n-\n-impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n-    fn report_region_errors(&self,\n-                            errors: &Vec<RegionResolutionError<'tcx>>) {\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    pub fn report_region_errors(&self,\n+                                errors: &Vec<RegionResolutionError<'tcx>>) {\n         debug!(\"report_region_errors(): {} errors to start\", errors.len());\n \n         // try to pre-process the errors, which will group some of them\n@@ -474,10 +401,10 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         }\n \n-        fn free_regions_from_same_fn(tcx: &TyCtxt,\n-                                     sub: Region,\n-                                     sup: Region)\n-                                     -> Option<FreeRegionsFromSameFn> {\n+        fn free_regions_from_same_fn<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                                     sub: Region,\n+                                                     sup: Region)\n+                                                     -> Option<FreeRegionsFromSameFn> {\n             debug!(\"free_regions_from_same_fn(sub={:?}, sup={:?})\", sub, sup);\n             let (scope_id, fr1, fr2) = match (sub, sup) {\n                 (ReFree(fr1), ReFree(fr2)) => {\n@@ -619,10 +546,10 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn report_and_explain_type_error(&self,\n-                                     trace: TypeTrace<'tcx>,\n-                                     terr: &TypeError<'tcx>)\n-                                     -> DiagnosticBuilder<'tcx> {\n+    pub fn report_and_explain_type_error(&self,\n+                                         trace: TypeTrace<'tcx>,\n+                                         terr: &TypeError<'tcx>)\n+                                         -> DiagnosticBuilder<'tcx> {\n         let span = trace.origin.span();\n         let mut err = self.report_type_error(trace, terr);\n         self.tcx.note_and_explain_type_err(&mut err, terr, span);\n@@ -1108,8 +1035,8 @@ struct RebuildPathInfo<'a> {\n     region_names: &'a HashSet<ast::Name>\n }\n \n-struct Rebuilder<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+struct Rebuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     fn_decl: &'a hir::FnDecl,\n     expl_self_opt: Option<&'a hir::ExplicitSelf_>,\n     generics: &'a hir::Generics,\n@@ -1124,14 +1051,14 @@ enum FreshOrKept {\n     Kept\n }\n \n-impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n-    fn new(tcx: &'a TyCtxt<'tcx>,\n+impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n+    fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n            fn_decl: &'a hir::FnDecl,\n            expl_self_opt: Option<&'a hir::ExplicitSelf_>,\n            generics: &'a hir::Generics,\n            same_regions: &'a [SameRegions],\n            life_giver: &'a LifeGiver)\n-           -> Rebuilder<'a, 'tcx> {\n+           -> Rebuilder<'a, 'gcx, 'tcx> {\n         Rebuilder {\n             tcx: tcx,\n             fn_decl: fn_decl,\n@@ -1641,7 +1568,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn give_expl_lifetime_param(&self,\n                                 err: &mut DiagnosticBuilder,\n                                 decl: &hir::FnDecl,\n@@ -1904,34 +1831,34 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n }\n \n pub trait Resolvable<'tcx> {\n-    fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>) -> Self;\n+    fn resolve<'a, 'gcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>) -> Self;\n }\n \n impl<'tcx> Resolvable<'tcx> for Ty<'tcx> {\n-    fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>) -> Ty<'tcx> {\n+    fn resolve<'a, 'gcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         infcx.resolve_type_vars_if_possible(self)\n     }\n }\n \n impl<'tcx> Resolvable<'tcx> for ty::TraitRef<'tcx> {\n-    fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>)\n-                   -> ty::TraitRef<'tcx> {\n+    fn resolve<'a, 'gcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n+                         -> ty::TraitRef<'tcx> {\n         infcx.resolve_type_vars_if_possible(self)\n     }\n }\n \n impl<'tcx> Resolvable<'tcx> for ty::PolyTraitRef<'tcx> {\n-    fn resolve<'a>(&self,\n-                   infcx: &InferCtxt<'a, 'tcx>)\n-                   -> ty::PolyTraitRef<'tcx>\n+    fn resolve<'a, 'gcx>(&self,\n+                         infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n+                         -> ty::PolyTraitRef<'tcx>\n     {\n         infcx.resolve_type_vars_if_possible(self)\n     }\n }\n \n-fn lifetimes_in_scope(tcx: &TyCtxt,\n-                      scope_id: ast::NodeId)\n-                      -> Vec<hir::LifetimeDef> {\n+fn lifetimes_in_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                      scope_id: ast::NodeId)\n+                                      -> Vec<hir::LifetimeDef> {\n     let mut taken = Vec::new();\n     let parent = tcx.map.get_parent(scope_id);\n     let method_id_opt = match tcx.map.find(parent) {"}, {"sha": "5ded6dc73646ea04f5920446cdfb9385693d8b82", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -37,14 +37,15 @@ use std::collections::hash_map::{self, Entry};\n use super::InferCtxt;\n use super::unify_key::ToType;\n \n-pub struct TypeFreshener<'a, 'tcx:'a> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+pub struct TypeFreshener<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     freshen_count: u32,\n     freshen_map: hash_map::HashMap<ty::InferTy, Ty<'tcx>>,\n }\n \n-impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> TypeFreshener<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>)\n+               -> TypeFreshener<'a, 'gcx, 'tcx> {\n         TypeFreshener {\n             infcx: infcx,\n             freshen_count: 0,\n@@ -77,8 +78,8 @@ impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n-    fn tcx<'b>(&'b self) -> &'b TyCtxt<'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "b7085f0829f8a51239eb35364e5c0e3dce1db454", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use super::combine::CombineFields;\n-use super::higher_ranked::HigherRankedRelations;\n use super::InferCtxt;\n use super::lattice::{self, LatticeDir};\n use super::Subtype;\n@@ -19,12 +18,12 @@ use ty::relate::{Relate, RelateResult, TypeRelation};\n use traits::PredicateObligations;\n \n /// \"Greatest lower bound\" (common subtype)\n-pub struct Glb<'a, 'tcx: 'a> {\n-    fields: CombineFields<'a, 'tcx>\n+pub struct Glb<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'gcx, 'tcx>\n }\n \n-impl<'a, 'tcx> Glb<'a, 'tcx> {\n-    pub fn new(fields: CombineFields<'a, 'tcx>) -> Glb<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Glb<'a, 'gcx, 'tcx> {\n+    pub fn new(fields: CombineFields<'a, 'gcx, 'tcx>) -> Glb<'a, 'gcx, 'tcx> {\n         Glb { fields: fields }\n     }\n \n@@ -33,18 +32,18 @@ impl<'a, 'tcx> Glb<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Glb<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Glb<'a, 'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Glb\" }\n \n-    fn tcx(&self) -> &'a TyCtxt<'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n-    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n-                                               variance: ty::Variance,\n-                                               a: &T,\n-                                               b: &T)\n-                                               -> RelateResult<'tcx, T>\n+    fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n+                                             variance: ty::Variance,\n+                                             a: &T,\n+                                             b: &T)\n+                                             -> RelateResult<'tcx, T>\n     {\n         match variance {\n             ty::Invariant => self.fields.equate().relate(a, b),\n@@ -70,14 +69,14 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Glb<'a, 'tcx> {\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n-        where T: Relate<'a, 'tcx>\n+        where T: Relate<'tcx>\n     {\n         self.fields.higher_ranked_glb(a, b)\n     }\n }\n \n-impl<'a, 'tcx> LatticeDir<'a,'tcx> for Glb<'a, 'tcx> {\n-    fn infcx(&self) -> &'a InferCtxt<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> LatticeDir<'a, 'gcx, 'tcx> for Glb<'a, 'gcx, 'tcx> {\n+    fn infcx(&self) -> &'a InferCtxt<'a, 'gcx, 'tcx> {\n         self.fields.infcx\n     }\n "}, {"sha": "6814d50107f6848fb95faab14abd786690698963", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 193, "deletions": 217, "changes": 410, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -20,29 +20,10 @@ use ty::relate::{Relate, RelateResult, TypeRelation};\n use syntax::codemap::Span;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n-pub trait HigherRankedRelations<'a,'tcx> {\n-    fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n-        where T: Relate<'a,'tcx>;\n-\n-    fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n-        where T: Relate<'a,'tcx>;\n-\n-    fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n-        where T: Relate<'a,'tcx>;\n-}\n-\n-trait InferCtxtExt {\n-    fn tainted_regions(&self, snapshot: &CombinedSnapshot, r: ty::Region) -> Vec<ty::Region>;\n-\n-    fn region_vars_confined_to_snapshot(&self,\n-                                        snapshot: &CombinedSnapshot)\n-                                        -> Vec<ty::RegionVid>;\n-}\n-\n-impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n-    fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>)\n-                            -> RelateResult<'tcx, Binder<T>>\n-        where T: Relate<'a,'tcx>\n+impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n+    pub fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>)\n+                                -> RelateResult<'tcx, Binder<T>>\n+        where T: Relate<'tcx>\n     {\n         debug!(\"higher_ranked_sub(a={:?}, b={:?})\",\n                a, b);\n@@ -79,30 +60,17 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n \n             // Presuming type comparison succeeds, we need to check\n             // that the skolemized regions do not \"leak\".\n-            match leak_check(self.infcx, &skol_map, snapshot) {\n-                Ok(()) => { }\n-                Err((skol_br, tainted_region)) => {\n-                    if self.a_is_expected {\n-                        debug!(\"Not as polymorphic!\");\n-                        return Err(TypeError::RegionsInsufficientlyPolymorphic(skol_br,\n-                                                                               tainted_region));\n-                    } else {\n-                        debug!(\"Overly polymorphic!\");\n-                        return Err(TypeError::RegionsOverlyPolymorphic(skol_br,\n-                                                                       tainted_region));\n-                    }\n-                }\n-            }\n+            self.infcx.leak_check(!self.a_is_expected, &skol_map, snapshot)?;\n \n-            debug!(\"higher_ranked_sub: OK result={:?}\",\n-                   result);\n+            debug!(\"higher_ranked_sub: OK result={:?}\", result);\n \n             Ok(ty::Binder(result))\n         });\n     }\n \n-    fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n-        where T: Relate<'a,'tcx>\n+    pub fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>)\n+                                -> RelateResult<'tcx, Binder<T>>\n+        where T: Relate<'tcx>\n     {\n         // Start a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n@@ -141,14 +109,14 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n             Ok(ty::Binder(result1))\n         });\n \n-        fn generalize_region(infcx: &InferCtxt,\n-                             span: Span,\n-                             snapshot: &CombinedSnapshot,\n-                             debruijn: ty::DebruijnIndex,\n-                             new_vars: &[ty::RegionVid],\n-                             a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n-                             r0: ty::Region)\n-                             -> ty::Region {\n+        fn generalize_region<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                             span: Span,\n+                                             snapshot: &CombinedSnapshot,\n+                                             debruijn: ty::DebruijnIndex,\n+                                             new_vars: &[ty::RegionVid],\n+                                             a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n+                                             r0: ty::Region)\n+                                             -> ty::Region {\n             // Regions that pre-dated the LUB computation stay as they are.\n             if !is_var_in_set(new_vars, r0) {\n                 assert!(!r0.is_bound());\n@@ -190,8 +158,9 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n         }\n     }\n \n-    fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n-        where T: Relate<'a,'tcx>\n+    pub fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>)\n+                                -> RelateResult<'tcx, Binder<T>>\n+        where T: Relate<'tcx>\n     {\n         debug!(\"higher_ranked_glb({:?}, {:?})\",\n                a, b);\n@@ -236,15 +205,15 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n             Ok(ty::Binder(result1))\n         });\n \n-        fn generalize_region(infcx: &InferCtxt,\n-                             span: Span,\n-                             snapshot: &CombinedSnapshot,\n-                             debruijn: ty::DebruijnIndex,\n-                             new_vars: &[ty::RegionVid],\n-                             a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n-                             a_vars: &[ty::RegionVid],\n-                             b_vars: &[ty::RegionVid],\n-                             r0: ty::Region) -> ty::Region {\n+        fn generalize_region<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                             span: Span,\n+                                             snapshot: &CombinedSnapshot,\n+                                             debruijn: ty::DebruijnIndex,\n+                                             new_vars: &[ty::RegionVid],\n+                                             a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n+                                             a_vars: &[ty::RegionVid],\n+                                             b_vars: &[ty::RegionVid],\n+                                             r0: ty::Region) -> ty::Region {\n             if !is_var_in_set(new_vars, r0) {\n                 assert!(!r0.is_bound());\n                 return r0;\n@@ -328,9 +297,9 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n     }\n }\n \n-fn var_ids<'a, 'tcx>(fields: &CombineFields<'a, 'tcx>,\n-                      map: &FnvHashMap<ty::BoundRegion, ty::Region>)\n-                     -> Vec<ty::RegionVid> {\n+fn var_ids<'a, 'gcx, 'tcx>(fields: &CombineFields<'a, 'gcx, 'tcx>,\n+                           map: &FnvHashMap<ty::BoundRegion, ty::Region>)\n+                           -> Vec<ty::RegionVid> {\n     map.iter()\n        .map(|(_, r)| match *r {\n            ty::ReVar(r) => { r }\n@@ -351,10 +320,10 @@ fn is_var_in_set(new_vars: &[ty::RegionVid], r: ty::Region) -> bool {\n     }\n }\n \n-fn fold_regions_in<'tcx, T, F>(tcx: &TyCtxt<'tcx>,\n-                               unbound_value: &T,\n-                               mut fldr: F)\n-                               -> T\n+fn fold_regions_in<'a, 'gcx, 'tcx, T, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                         unbound_value: &T,\n+                                         mut fldr: F)\n+                                         -> T\n     where T: TypeFoldable<'tcx>,\n           F: FnMut(ty::Region, ty::DebruijnIndex) -> ty::Region,\n {\n@@ -371,7 +340,7 @@ fn fold_regions_in<'tcx, T, F>(tcx: &TyCtxt<'tcx>,\n     })\n }\n \n-impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn tainted_regions(&self, snapshot: &CombinedSnapshot, r: ty::Region) -> Vec<ty::Region> {\n         self.region_vars.tainted(&snapshot.region_vars_snapshot, r)\n     }\n@@ -452,163 +421,170 @@ impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n \n         region_vars\n     }\n-}\n \n-pub fn skolemize_late_bound_regions<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n-                                               binder: &ty::Binder<T>,\n-                                               snapshot: &CombinedSnapshot)\n-                                               -> (T, SkolemizationMap)\n-    where T : TypeFoldable<'tcx>\n-{\n-    /*!\n-     * Replace all regions bound by `binder` with skolemized regions and\n-     * return a map indicating which bound-region was replaced with what\n-     * skolemized region. This is the first step of checking subtyping\n-     * when higher-ranked things are involved. See `README.md` for more\n-     * details.\n-     */\n-\n-    let (result, map) = infcx.tcx.replace_late_bound_regions(binder, |br| {\n-        infcx.region_vars.new_skolemized(br, &snapshot.region_vars_snapshot)\n-    });\n-\n-    debug!(\"skolemize_bound_regions(binder={:?}, result={:?}, map={:?})\",\n-           binder,\n-           result,\n-           map);\n-\n-    (result, map)\n-}\n+    pub fn skolemize_late_bound_regions<T>(&self,\n+                                           binder: &ty::Binder<T>,\n+                                           snapshot: &CombinedSnapshot)\n+                                           -> (T, SkolemizationMap)\n+        where T : TypeFoldable<'tcx>\n+    {\n+        /*!\n+         * Replace all regions bound by `binder` with skolemized regions and\n+         * return a map indicating which bound-region was replaced with what\n+         * skolemized region. This is the first step of checking subtyping\n+         * when higher-ranked things are involved. See `README.md` for more\n+         * details.\n+         */\n \n-pub fn leak_check<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                           skol_map: &SkolemizationMap,\n-                           snapshot: &CombinedSnapshot)\n-                           -> Result<(),(ty::BoundRegion,ty::Region)>\n-{\n-    /*!\n-     * Searches the region constriants created since `snapshot` was started\n-     * and checks to determine whether any of the skolemized regions created\n-     * in `skol_map` would \"escape\" -- meaning that they are related to\n-     * other regions in some way. If so, the higher-ranked subtyping doesn't\n-     * hold. See `README.md` for more details.\n-     */\n-\n-    debug!(\"leak_check: skol_map={:?}\",\n-           skol_map);\n-\n-    let new_vars = infcx.region_vars_confined_to_snapshot(snapshot);\n-    for (&skol_br, &skol) in skol_map {\n-        let tainted = infcx.tainted_regions(snapshot, skol);\n-        for &tainted_region in &tainted {\n-            // Each skolemized should only be relatable to itself\n-            // or new variables:\n-            match tainted_region {\n-                ty::ReVar(vid) => {\n-                    if new_vars.iter().any(|&x| x == vid) { continue; }\n-                }\n-                _ => {\n-                    if tainted_region == skol { continue; }\n-                }\n-            };\n+        let (result, map) = self.tcx.replace_late_bound_regions(binder, |br| {\n+            self.region_vars.new_skolemized(br, &snapshot.region_vars_snapshot)\n+        });\n \n-            debug!(\"{:?} (which replaced {:?}) is tainted by {:?}\",\n-                   skol,\n-                   skol_br,\n-                   tainted_region);\n+        debug!(\"skolemize_bound_regions(binder={:?}, result={:?}, map={:?})\",\n+               binder,\n+               result,\n+               map);\n \n-            // A is not as polymorphic as B:\n-            return Err((skol_br, tainted_region));\n-        }\n+        (result, map)\n     }\n-    Ok(())\n-}\n \n-/// This code converts from skolemized regions back to late-bound\n-/// regions. It works by replacing each region in the taint set of a\n-/// skolemized region with a bound-region. The bound region will be bound\n-/// by the outer-most binder in `value`; the caller must ensure that there is\n-/// such a binder and it is the right place.\n-///\n-/// This routine is only intended to be used when the leak-check has\n-/// passed; currently, it's used in the trait matching code to create\n-/// a set of nested obligations frmo an impl that matches against\n-/// something higher-ranked.  More details can be found in\n-/// `librustc/middle/traits/README.md`.\n-///\n-/// As a brief example, consider the obligation `for<'a> Fn(&'a int)\n-/// -> &'a int`, and the impl:\n-///\n-///     impl<A,R> Fn<A,R> for SomethingOrOther\n-///         where A : Clone\n-///     { ... }\n-///\n-/// Here we will have replaced `'a` with a skolemized region\n-/// `'0`. This means that our substitution will be `{A=>&'0\n-/// int, R=>&'0 int}`.\n-///\n-/// When we apply the substitution to the bounds, we will wind up with\n-/// `&'0 int : Clone` as a predicate. As a last step, we then go and\n-/// replace `'0` with a late-bound region `'a`.  The depth is matched\n-/// to the depth of the predicate, in this case 1, so that the final\n-/// predicate is `for<'a> &'a int : Clone`.\n-pub fn plug_leaks<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n-                             skol_map: SkolemizationMap,\n-                             snapshot: &CombinedSnapshot,\n-                             value: &T)\n-                             -> T\n-    where T : TypeFoldable<'tcx>\n-{\n-    debug_assert!(leak_check(infcx, &skol_map, snapshot).is_ok());\n-\n-    debug!(\"plug_leaks(skol_map={:?}, value={:?})\",\n-           skol_map,\n-           value);\n-\n-    // Compute a mapping from the \"taint set\" of each skolemized\n-    // region back to the `ty::BoundRegion` that it originally\n-    // represented. Because `leak_check` passed, we know that\n-    // these taint sets are mutually disjoint.\n-    let inv_skol_map: FnvHashMap<ty::Region, ty::BoundRegion> =\n-        skol_map\n-        .into_iter()\n-        .flat_map(|(skol_br, skol)| {\n-            infcx.tainted_regions(snapshot, skol)\n-                .into_iter()\n-                .map(move |tainted_region| (tainted_region, skol_br))\n-        })\n-        .collect();\n-\n-    debug!(\"plug_leaks: inv_skol_map={:?}\",\n-           inv_skol_map);\n-\n-    // Remove any instantiated type variables from `value`; those can hide\n-    // references to regions from the `fold_regions` code below.\n-    let value = infcx.resolve_type_vars_if_possible(value);\n-\n-    // Map any skolemization byproducts back to a late-bound\n-    // region. Put that late-bound region at whatever the outermost\n-    // binder is that we encountered in `value`. The caller is\n-    // responsible for ensuring that (a) `value` contains at least one\n-    // binder and (b) that binder is the one we want to use.\n-    let result = infcx.tcx.fold_regions(&value, &mut false, |r, current_depth| {\n-        match inv_skol_map.get(&r) {\n-            None => r,\n-            Some(br) => {\n-                // It is the responsibility of the caller to ensure\n-                // that each skolemized region appears within a\n-                // binder. In practice, this routine is only used by\n-                // trait checking, and all of the skolemized regions\n-                // appear inside predicates, which always have\n-                // binders, so this assert is satisfied.\n-                assert!(current_depth > 1);\n-\n-                ty::ReLateBound(ty::DebruijnIndex::new(current_depth - 1), br.clone())\n+    pub fn leak_check(&self,\n+                      overly_polymorphic: bool,\n+                      skol_map: &SkolemizationMap,\n+                      snapshot: &CombinedSnapshot)\n+                      -> RelateResult<'tcx, ()>\n+    {\n+        /*!\n+         * Searches the region constriants created since `snapshot` was started\n+         * and checks to determine whether any of the skolemized regions created\n+         * in `skol_map` would \"escape\" -- meaning that they are related to\n+         * other regions in some way. If so, the higher-ranked subtyping doesn't\n+         * hold. See `README.md` for more details.\n+         */\n+\n+        debug!(\"leak_check: skol_map={:?}\",\n+               skol_map);\n+\n+        let new_vars = self.region_vars_confined_to_snapshot(snapshot);\n+        for (&skol_br, &skol) in skol_map {\n+            let tainted = self.tainted_regions(snapshot, skol);\n+            for &tainted_region in &tainted {\n+                // Each skolemized should only be relatable to itself\n+                // or new variables:\n+                match tainted_region {\n+                    ty::ReVar(vid) => {\n+                        if new_vars.iter().any(|&x| x == vid) { continue; }\n+                    }\n+                    _ => {\n+                        if tainted_region == skol { continue; }\n+                    }\n+                };\n+\n+                debug!(\"{:?} (which replaced {:?}) is tainted by {:?}\",\n+                       skol,\n+                       skol_br,\n+                       tainted_region);\n+\n+                if overly_polymorphic {\n+                    debug!(\"Overly polymorphic!\");\n+                    return Err(TypeError::RegionsOverlyPolymorphic(skol_br,\n+                                                                   tainted_region));\n+                } else {\n+                    debug!(\"Not as polymorphic!\");\n+                    return Err(TypeError::RegionsInsufficientlyPolymorphic(skol_br,\n+                                                                           tainted_region));\n+                }\n             }\n         }\n-    });\n+        Ok(())\n+    }\n+\n+    /// This code converts from skolemized regions back to late-bound\n+    /// regions. It works by replacing each region in the taint set of a\n+    /// skolemized region with a bound-region. The bound region will be bound\n+    /// by the outer-most binder in `value`; the caller must ensure that there is\n+    /// such a binder and it is the right place.\n+    ///\n+    /// This routine is only intended to be used when the leak-check has\n+    /// passed; currently, it's used in the trait matching code to create\n+    /// a set of nested obligations frmo an impl that matches against\n+    /// something higher-ranked.  More details can be found in\n+    /// `librustc/middle/traits/README.md`.\n+    ///\n+    /// As a brief example, consider the obligation `for<'a> Fn(&'a int)\n+    /// -> &'a int`, and the impl:\n+    ///\n+    ///     impl<A,R> Fn<A,R> for SomethingOrOther\n+    ///         where A : Clone\n+    ///     { ... }\n+    ///\n+    /// Here we will have replaced `'a` with a skolemized region\n+    /// `'0`. This means that our substitution will be `{A=>&'0\n+    /// int, R=>&'0 int}`.\n+    ///\n+    /// When we apply the substitution to the bounds, we will wind up with\n+    /// `&'0 int : Clone` as a predicate. As a last step, we then go and\n+    /// replace `'0` with a late-bound region `'a`.  The depth is matched\n+    /// to the depth of the predicate, in this case 1, so that the final\n+    /// predicate is `for<'a> &'a int : Clone`.\n+    pub fn plug_leaks<T>(&self,\n+                         skol_map: SkolemizationMap,\n+                         snapshot: &CombinedSnapshot,\n+                         value: &T) -> T\n+        where T : TypeFoldable<'tcx>\n+    {\n+        debug_assert!(self.leak_check(false, &skol_map, snapshot).is_ok());\n+\n+        debug!(\"plug_leaks(skol_map={:?}, value={:?})\",\n+               skol_map,\n+               value);\n+\n+        // Compute a mapping from the \"taint set\" of each skolemized\n+        // region back to the `ty::BoundRegion` that it originally\n+        // represented. Because `leak_check` passed, we know that\n+        // these taint sets are mutually disjoint.\n+        let inv_skol_map: FnvHashMap<ty::Region, ty::BoundRegion> =\n+            skol_map\n+            .into_iter()\n+            .flat_map(|(skol_br, skol)| {\n+                self.tainted_regions(snapshot, skol)\n+                    .into_iter()\n+                    .map(move |tainted_region| (tainted_region, skol_br))\n+            })\n+            .collect();\n+\n+        debug!(\"plug_leaks: inv_skol_map={:?}\",\n+               inv_skol_map);\n+\n+        // Remove any instantiated type variables from `value`; those can hide\n+        // references to regions from the `fold_regions` code below.\n+        let value = self.resolve_type_vars_if_possible(value);\n+\n+        // Map any skolemization byproducts back to a late-bound\n+        // region. Put that late-bound region at whatever the outermost\n+        // binder is that we encountered in `value`. The caller is\n+        // responsible for ensuring that (a) `value` contains at least one\n+        // binder and (b) that binder is the one we want to use.\n+        let result = self.tcx.fold_regions(&value, &mut false, |r, current_depth| {\n+            match inv_skol_map.get(&r) {\n+                None => r,\n+                Some(br) => {\n+                    // It is the responsibility of the caller to ensure\n+                    // that each skolemized region appears within a\n+                    // binder. In practice, this routine is only used by\n+                    // trait checking, and all of the skolemized regions\n+                    // appear inside predicates, which always have\n+                    // binders, so this assert is satisfied.\n+                    assert!(current_depth > 1);\n+\n+                    ty::ReLateBound(ty::DebruijnIndex::new(current_depth - 1), br.clone())\n+                }\n+            }\n+        });\n \n-    debug!(\"plug_leaks: result={:?}\",\n-           result);\n+        debug!(\"plug_leaks: result={:?}\",\n+               result);\n \n-    result\n+        result\n+    }\n }"}, {"sha": "1a2bc4b5cf2e18b7690e2d942aec2a183260a06d", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -29,26 +29,25 @@\n //! over a `LatticeValue`, which is a value defined with respect to\n //! a lattice.\n \n-use super::combine;\n use super::InferCtxt;\n \n use ty::TyVar;\n use ty::{self, Ty};\n use ty::relate::{RelateResult, TypeRelation};\n \n-pub trait LatticeDir<'f,'tcx> : TypeRelation<'f,'tcx> {\n-    fn infcx(&self) -> &'f InferCtxt<'f, 'tcx>;\n+pub trait LatticeDir<'f, 'gcx: 'f+'tcx, 'tcx: 'f> : TypeRelation<'f, 'gcx, 'tcx> {\n+    fn infcx(&self) -> &'f InferCtxt<'f, 'gcx, 'tcx>;\n \n     // Relates the type `v` to `a` and `b` such that `v` represents\n     // the LUB/GLB of `a` and `b` as appropriate.\n     fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()>;\n }\n \n-pub fn super_lattice_tys<'a,'tcx,L:LatticeDir<'a,'tcx>>(this: &mut L,\n-                                                        a: Ty<'tcx>,\n-                                                        b: Ty<'tcx>)\n-                                                        -> RelateResult<'tcx, Ty<'tcx>>\n-    where 'tcx: 'a\n+pub fn super_lattice_tys<'a, 'gcx, 'tcx, L>(this: &mut L,\n+                                            a: Ty<'tcx>,\n+                                            b: Ty<'tcx>)\n+                                            -> RelateResult<'tcx, Ty<'tcx>>\n+    where L: LatticeDir<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     debug!(\"{}.lattice_tys({:?}, {:?})\",\n            this.tag(),\n@@ -78,7 +77,7 @@ pub fn super_lattice_tys<'a,'tcx,L:LatticeDir<'a,'tcx>>(this: &mut L,\n         }\n \n         _ => {\n-            combine::super_combine_tys(this.infcx(), this, a, b)\n+            infcx.super_combine_tys(this, a, b)\n         }\n     }\n }"}, {"sha": "bd46f3a26a2def175852a5026a87d0e2ee8cf6f0", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use super::combine::CombineFields;\n-use super::higher_ranked::HigherRankedRelations;\n use super::InferCtxt;\n use super::lattice::{self, LatticeDir};\n use super::Subtype;\n@@ -19,12 +18,12 @@ use ty::relate::{Relate, RelateResult, TypeRelation};\n use traits::PredicateObligations;\n \n /// \"Least upper bound\" (common supertype)\n-pub struct Lub<'a, 'tcx: 'a> {\n-    fields: CombineFields<'a, 'tcx>\n+pub struct Lub<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'gcx, 'tcx>\n }\n \n-impl<'a, 'tcx> Lub<'a, 'tcx> {\n-    pub fn new(fields: CombineFields<'a, 'tcx>) -> Lub<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Lub<'a, 'gcx, 'tcx> {\n+    pub fn new(fields: CombineFields<'a, 'gcx, 'tcx>) -> Lub<'a, 'gcx, 'tcx> {\n         Lub { fields: fields }\n     }\n \n@@ -33,18 +32,18 @@ impl<'a, 'tcx> Lub<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Lub<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Lub<'a, 'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Lub\" }\n \n-    fn tcx(&self) -> &'a TyCtxt<'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n-    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n-                                               variance: ty::Variance,\n-                                               a: &T,\n-                                               b: &T)\n-                                               -> RelateResult<'tcx, T>\n+    fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n+                                             variance: ty::Variance,\n+                                             a: &T,\n+                                             b: &T)\n+                                             -> RelateResult<'tcx, T>\n     {\n         match variance {\n             ty::Invariant => self.fields.equate().relate(a, b),\n@@ -70,14 +69,14 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Lub<'a, 'tcx> {\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n-        where T: Relate<'a, 'tcx>\n+        where T: Relate<'tcx>\n     {\n         self.fields.higher_ranked_lub(a, b)\n     }\n }\n \n-impl<'a, 'tcx> LatticeDir<'a,'tcx> for Lub<'a, 'tcx> {\n-    fn infcx(&self) -> &'a InferCtxt<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> LatticeDir<'a, 'gcx, 'tcx> for Lub<'a, 'gcx, 'tcx> {\n+    fn infcx(&self) -> &'a InferCtxt<'a, 'gcx, 'tcx> {\n         self.fields.infcx\n     }\n "}, {"sha": "29d8a808de5f04f7924f2ac8aa03c9d8c1e102d9", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 359, "deletions": 292, "changes": 651, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -24,6 +24,7 @@ use middle::free_region::FreeRegionMap;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n use middle::region::CodeExtent;\n+use mir::tcx::LvalueTy;\n use ty::subst;\n use ty::subst::Substs;\n use ty::subst::Subst;\n@@ -35,7 +36,7 @@ use ty::fold::TypeFoldable;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n use traits::{self, PredicateObligations, ProjectionMode};\n use rustc_data_structures::unify::{self, UnificationTable};\n-use std::cell::{Cell, RefCell, Ref};\n+use std::cell::{Cell, RefCell, Ref, RefMut};\n use std::fmt;\n use syntax::ast;\n use syntax::codemap;\n@@ -45,7 +46,6 @@ use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n \n use self::combine::CombineFields;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n-use self::error_reporting::ErrorReporting;\n use self::unify_key::ToType;\n \n pub mod bivariate;\n@@ -73,10 +73,36 @@ pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n pub type FixupResult<T> = Result<T, FixupError>; // \"fixup result\"\n \n-pub struct InferCtxt<'a, 'tcx: 'a> {\n-    pub tcx: &'a TyCtxt<'tcx>,\n+/// A version of &ty::Tables which can be global or local.\n+/// Only the local version supports borrow_mut.\n+#[derive(Copy, Clone)]\n+pub enum InferTables<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    Global(&'a RefCell<ty::Tables<'gcx>>),\n+    Local(&'a RefCell<ty::Tables<'tcx>>)\n+}\n \n-    pub tables: &'a RefCell<ty::Tables<'tcx>>,\n+impl<'a, 'gcx, 'tcx> InferTables<'a, 'gcx, 'tcx> {\n+    pub fn borrow(self) -> Ref<'a, ty::Tables<'tcx>> {\n+        match self {\n+            InferTables::Global(tables) => tables.borrow(),\n+            InferTables::Local(tables) => tables.borrow()\n+        }\n+    }\n+\n+    pub fn borrow_mut(self) -> RefMut<'a, ty::Tables<'tcx>> {\n+        match self {\n+            InferTables::Global(_) => {\n+                bug!(\"InferTables: infcx.tables.borrow_mut() outside of type-checking\");\n+            }\n+            InferTables::Local(tables) => tables.borrow_mut()\n+        }\n+    }\n+}\n+\n+pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+\n+    pub tables: InferTables<'a, 'gcx, 'tcx>,\n \n     // We instantiate UnificationTable with bounds<Ty> because the\n     // types that might instantiate a general type variable have an\n@@ -90,9 +116,16 @@ pub struct InferCtxt<'a, 'tcx: 'a> {\n     float_unification_table: RefCell<UnificationTable<ty::FloatVid>>,\n \n     // For region variables.\n-    region_vars: RegionVarBindings<'a, 'tcx>,\n+    region_vars: RegionVarBindings<'a, 'gcx, 'tcx>,\n+\n+    pub parameter_environment: ty::ParameterEnvironment<'gcx>,\n \n-    pub parameter_environment: ty::ParameterEnvironment<'a, 'tcx>,\n+    /// Caches the results of trait selection. This cache is used\n+    /// for things that have to do with the parameters in scope.\n+    pub selection_cache: traits::SelectionCache<'tcx>,\n+\n+    /// Caches the results of trait evaluation.\n+    pub evaluation_cache: traits::EvaluationCache<'tcx>,\n \n     // the set of predicates on which errors have been reported, to\n     // avoid reporting the same error twice.\n@@ -366,149 +399,140 @@ pub enum FixupError {\n     UnresolvedTy(TyVid)\n }\n \n-pub fn fixup_err_to_string(f: FixupError) -> String {\n-    use self::FixupError::*;\n-\n-    match f {\n-      UnresolvedIntTy(_) => {\n-          \"cannot determine the type of this integer; add a suffix to \\\n-           specify the type explicitly\".to_string()\n-      }\n-      UnresolvedFloatTy(_) => {\n-          \"cannot determine the type of this number; add a suffix to specify \\\n-           the type explicitly\".to_string()\n-      }\n-      UnresolvedTy(_) => \"unconstrained type\".to_string(),\n-    }\n-}\n+impl fmt::Display for FixupError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        use self::FixupError::*;\n \n-pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a TyCtxt<'tcx>,\n-                                tables: &'a RefCell<ty::Tables<'tcx>>,\n-                                param_env: Option<ty::ParameterEnvironment<'a, 'tcx>>,\n-                                projection_mode: ProjectionMode)\n-                                -> InferCtxt<'a, 'tcx> {\n-    InferCtxt {\n-        tcx: tcx,\n-        tables: tables,\n-        type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n-        int_unification_table: RefCell::new(UnificationTable::new()),\n-        float_unification_table: RefCell::new(UnificationTable::new()),\n-        region_vars: RegionVarBindings::new(tcx),\n-        parameter_environment: param_env.unwrap_or(tcx.empty_parameter_environment()),\n-        reported_trait_errors: RefCell::new(FnvHashSet()),\n-        normalize: false,\n-        projection_mode: projection_mode,\n-        tainted_by_errors_flag: Cell::new(false),\n-        err_count_on_creation: tcx.sess.err_count()\n+        match *self {\n+            UnresolvedIntTy(_) => {\n+                write!(f, \"cannot determine the type of this integer; \\\n+                           add a suffix to specify the type explicitly\")\n+            }\n+            UnresolvedFloatTy(_) => {\n+                write!(f, \"cannot determine the type of this number; \\\n+                           add a suffix to specify the type explicitly\")\n+            }\n+            UnresolvedTy(_) => write!(f, \"unconstrained type\")\n+        }\n     }\n }\n \n-pub fn normalizing_infer_ctxt<'a, 'tcx>(tcx: &'a TyCtxt<'tcx>,\n-                                        tables: &'a RefCell<ty::Tables<'tcx>>,\n-                                        projection_mode: ProjectionMode)\n-                                        -> InferCtxt<'a, 'tcx> {\n-    let mut infcx = new_infer_ctxt(tcx, tables, None, projection_mode);\n-    infcx.normalize = true;\n-    infcx\n-}\n-\n-pub fn mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                          a_is_expected: bool,\n-                          origin: TypeOrigin,\n-                          a: Ty<'tcx>,\n-                          b: Ty<'tcx>)\n-    -> InferResult<'tcx, ()>\n-{\n-    debug!(\"mk_subty({:?} <: {:?})\", a, b);\n-    cx.sub_types(a_is_expected, origin, a, b)\n-}\n-\n-pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>)\n-    -> UnitResult<'tcx>\n-{\n-    debug!(\"can_mk_subty({:?} <: {:?})\", a, b);\n-    cx.probe(|_| {\n-        let trace = TypeTrace {\n-            origin: TypeOrigin::Misc(codemap::DUMMY_SP),\n-            values: Types(expected_found(true, a, b))\n-        };\n-        cx.sub(true, trace, &a, &b).map(|_| ())\n-    })\n-}\n-\n-pub fn can_mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>)\n-    -> UnitResult<'tcx>\n-{\n-    cx.can_equate(&a, &b)\n+/// Helper type of a temporary returned by tcx.infer_ctxt(...).\n+/// Necessary because we can't write the following bound:\n+/// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(InferCtxt<'b, 'gcx, 'tcx>).\n+pub struct InferCtxtBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    global_tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+    arenas: ty::CtxtArenas<'tcx>,\n+    tables: Option<RefCell<ty::Tables<'tcx>>>,\n+    param_env: Option<ty::ParameterEnvironment<'gcx>>,\n+    projection_mode: ProjectionMode,\n+    normalize: bool\n }\n \n-pub fn mk_subr<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                         origin: SubregionOrigin<'tcx>,\n-                         a: ty::Region,\n-                         b: ty::Region) {\n-    debug!(\"mk_subr({:?} <: {:?})\", a, b);\n-    let snapshot = cx.region_vars.start_snapshot();\n-    cx.region_vars.make_subregion(origin, a, b);\n-    cx.region_vars.commit(snapshot);\n-}\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n+    pub fn infer_ctxt(self,\n+                      tables: Option<ty::Tables<'tcx>>,\n+                      param_env: Option<ty::ParameterEnvironment<'gcx>>,\n+                      projection_mode: ProjectionMode)\n+                      -> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n+        InferCtxtBuilder {\n+            global_tcx: self,\n+            arenas: ty::CtxtArenas::new(),\n+            tables: tables.map(RefCell::new),\n+            param_env: param_env,\n+            projection_mode: projection_mode,\n+            normalize: false\n+        }\n+    }\n \n-pub fn mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                         a_is_expected: bool,\n-                         origin: TypeOrigin,\n-                         a: Ty<'tcx>,\n-                         b: Ty<'tcx>)\n-    -> InferResult<'tcx, ()>\n-{\n-    debug!(\"mk_eqty({:?} <: {:?})\", a, b);\n-    cx.eq_types(a_is_expected, origin, a, b)\n-}\n+    pub fn normalizing_infer_ctxt(self, projection_mode: ProjectionMode)\n+                                  -> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n+        InferCtxtBuilder {\n+            global_tcx: self,\n+            arenas: ty::CtxtArenas::new(),\n+            tables: None,\n+            param_env: None,\n+            projection_mode: projection_mode,\n+            normalize: false\n+        }\n+    }\n \n-pub fn mk_eq_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                                  a_is_expected: bool,\n-                                  origin: TypeOrigin,\n-                                  a: ty::TraitRef<'tcx>,\n-                                  b: ty::TraitRef<'tcx>)\n-    -> InferResult<'tcx, ()>\n-{\n-    debug!(\"mk_eq_trait_refs({:?} = {:?})\", a, b);\n-    cx.eq_trait_refs(a_is_expected, origin, a, b)\n+    /// Fake InferCtxt with the global tcx. Used by pre-MIR borrowck\n+    /// for MemCategorizationContext/ExprUseVisitor.\n+    /// If any inference functionality is used, ICEs will occur.\n+    pub fn borrowck_fake_infer_ctxt(self, param_env: ty::ParameterEnvironment<'gcx>)\n+                                    -> InferCtxt<'a, 'gcx, 'gcx> {\n+        InferCtxt {\n+            tcx: self,\n+            tables: InferTables::Global(&self.tables),\n+            type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n+            int_unification_table: RefCell::new(UnificationTable::new()),\n+            float_unification_table: RefCell::new(UnificationTable::new()),\n+            region_vars: RegionVarBindings::new(self),\n+            parameter_environment: param_env,\n+            selection_cache: traits::SelectionCache::new(),\n+            evaluation_cache: traits::EvaluationCache::new(),\n+            reported_trait_errors: RefCell::new(FnvHashSet()),\n+            normalize: false,\n+            projection_mode: ProjectionMode::AnyFinal,\n+            tainted_by_errors_flag: Cell::new(false),\n+            err_count_on_creation: self.sess.err_count()\n+        }\n+    }\n }\n \n-pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                                        a_is_expected: bool,\n-                                        origin: TypeOrigin,\n-                                        a: ty::PolyTraitRef<'tcx>,\n-                                        b: ty::PolyTraitRef<'tcx>)\n-    -> InferResult<'tcx, ()>\n-{\n-    debug!(\"mk_sub_poly_trait_refs({:?} <: {:?})\", a, b);\n-    cx.sub_poly_trait_refs(a_is_expected, origin, a, b)\n+impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n+    pub fn enter<F, R>(&'tcx mut self, f: F) -> R\n+        where F: for<'b> FnOnce(InferCtxt<'b, 'gcx, 'tcx>) -> R\n+    {\n+        let InferCtxtBuilder {\n+            global_tcx,\n+            ref arenas,\n+            ref tables,\n+            ref mut param_env,\n+            projection_mode,\n+            normalize\n+        } = *self;\n+        let tables = if let Some(ref tables) = *tables {\n+            InferTables::Local(tables)\n+        } else {\n+            InferTables::Global(&global_tcx.tables)\n+        };\n+        let param_env = param_env.take().unwrap_or_else(|| {\n+            global_tcx.empty_parameter_environment()\n+        });\n+        global_tcx.enter_local(arenas, |tcx| f(InferCtxt {\n+            tcx: tcx,\n+            tables: tables,\n+            type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n+            int_unification_table: RefCell::new(UnificationTable::new()),\n+            float_unification_table: RefCell::new(UnificationTable::new()),\n+            region_vars: RegionVarBindings::new(tcx),\n+            parameter_environment: param_env,\n+            selection_cache: traits::SelectionCache::new(),\n+            evaluation_cache: traits::EvaluationCache::new(),\n+            reported_trait_errors: RefCell::new(FnvHashSet()),\n+            normalize: normalize,\n+            projection_mode: projection_mode,\n+            tainted_by_errors_flag: Cell::new(false),\n+            err_count_on_creation: tcx.sess.err_count()\n+        }))\n+    }\n }\n \n-pub fn mk_eq_impl_headers<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                                    a_is_expected: bool,\n-                                    origin: TypeOrigin,\n-                                    a: &ty::ImplHeader<'tcx>,\n-                                    b: &ty::ImplHeader<'tcx>)\n-    -> InferResult<'tcx, ()>\n-{\n-    debug!(\"mk_eq_impl_header({:?} = {:?})\", a, b);\n-    match (a.trait_ref, b.trait_ref) {\n-        (Some(a_ref), Some(b_ref)) => mk_eq_trait_refs(cx, a_is_expected, origin, a_ref, b_ref),\n-        (None, None) => mk_eqty(cx, a_is_expected, origin, a.self_ty, b.self_ty),\n-        _ => bug!(\"mk_eq_impl_headers given mismatched impl kinds\"),\n+impl<T> ExpectedFound<T> {\n+    fn new(a_is_expected: bool, a: T, b: T) -> Self {\n+        if a_is_expected {\n+            ExpectedFound {expected: a, found: b}\n+        } else {\n+            ExpectedFound {expected: b, found: a}\n+        }\n     }\n }\n \n-fn expected_found<T>(a_is_expected: bool,\n-                     a: T,\n-                     b: T)\n-                     -> ExpectedFound<T>\n-{\n-    if a_is_expected {\n-        ExpectedFound {expected: a, found: b}\n-    } else {\n-        ExpectedFound {expected: b, found: a}\n+impl<'tcx, T> InferOk<'tcx, T> {\n+    fn unit(self) -> InferOk<'tcx, ()> {\n+        InferOk { value: (), obligations: self.obligations }\n     }\n }\n \n@@ -520,92 +544,138 @@ pub struct CombinedSnapshot {\n     region_vars_snapshot: RegionSnapshot,\n }\n \n-// NOTE: Callable from trans only!\n-pub fn normalize_associated_type<'tcx,T>(tcx: &TyCtxt<'tcx>, value: &T) -> T\n-    where T : TypeFoldable<'tcx>\n-{\n-    debug!(\"normalize_associated_type(t={:?})\", value);\n+/// Helper trait for shortening the lifetimes inside a\n+/// value for post-type-checking normalization.\n+pub trait TransNormalize<'gcx>: TypeFoldable<'gcx> {\n+    fn trans_normalize<'a, 'tcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>) -> Self;\n+}\n \n-    let value = tcx.erase_regions(value);\n+macro_rules! items { ($($item:item)+) => ($($item)+) }\n+macro_rules! impl_trans_normalize {\n+    ($lt_gcx:tt, $($ty:ty),+) => {\n+        items!($(impl<$lt_gcx> TransNormalize<$lt_gcx> for $ty {\n+            fn trans_normalize<'a, 'tcx>(&self,\n+                                         infcx: &InferCtxt<'a, $lt_gcx, 'tcx>)\n+                                         -> Self {\n+                infcx.normalize_projections_in(self)\n+            }\n+        })+);\n+    }\n+}\n \n-    if !value.has_projection_types() {\n-        return value;\n+impl_trans_normalize!('gcx,\n+    Ty<'gcx>,\n+    &'gcx Substs<'gcx>,\n+    ty::FnSig<'gcx>,\n+    ty::FnOutput<'gcx>,\n+    &'gcx ty::BareFnTy<'gcx>,\n+    ty::ClosureSubsts<'gcx>,\n+    ty::PolyTraitRef<'gcx>\n+);\n+\n+impl<'gcx> TransNormalize<'gcx> for LvalueTy<'gcx> {\n+    fn trans_normalize<'a, 'tcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n+        match *self {\n+            LvalueTy::Ty { ty } => LvalueTy::Ty { ty: ty.trans_normalize(infcx) },\n+            LvalueTy::Downcast { adt_def, substs, variant_index } => {\n+                LvalueTy::Downcast {\n+                    adt_def: adt_def,\n+                    substs: substs.trans_normalize(infcx),\n+                    variant_index: variant_index\n+                }\n+            }\n+        }\n     }\n+}\n \n-    let infcx = new_infer_ctxt(tcx, &tcx.tables, None, ProjectionMode::Any);\n-    let mut selcx = traits::SelectionContext::new(&infcx);\n-    let cause = traits::ObligationCause::dummy();\n-    let traits::Normalized { value: result, obligations } =\n-        traits::normalize(&mut selcx, cause, &value);\n+// NOTE: Callable from trans only!\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+    pub fn normalize_associated_type<T>(self, value: &T) -> T\n+        where T: TransNormalize<'tcx>\n+    {\n+        debug!(\"normalize_associated_type(t={:?})\", value);\n \n-    debug!(\"normalize_associated_type: result={:?} obligations={:?}\",\n-           result,\n-           obligations);\n+        let value = self.erase_regions(value);\n \n-    let mut fulfill_cx = traits::FulfillmentContext::new();\n+        if !value.has_projection_types() {\n+            return value;\n+        }\n \n-    for obligation in obligations {\n-        fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+        self.infer_ctxt(None, None, ProjectionMode::Any).enter(|infcx| {\n+            value.trans_normalize(&infcx)\n+        })\n     }\n-\n-    drain_fulfillment_cx_or_panic(DUMMY_SP, &infcx, &mut fulfill_cx, &result)\n }\n \n-pub fn drain_fulfillment_cx_or_panic<'a,'tcx,T>(span: Span,\n-                                                infcx: &InferCtxt<'a,'tcx>,\n-                                                fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n-                                                result: &T)\n-                                                -> T\n-    where T : TypeFoldable<'tcx>\n-{\n-    match drain_fulfillment_cx(infcx, fulfill_cx, result) {\n-        Ok(v) => v,\n-        Err(errors) => {\n-            span_bug!(\n-                span,\n-                \"Encountered errors `{:?}` fulfilling during trans\",\n-                errors);\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    fn normalize_projections_in<T>(&self, value: &T) -> T::Lifted\n+        where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n+    {\n+        let mut selcx = traits::SelectionContext::new(self);\n+        let cause = traits::ObligationCause::dummy();\n+        let traits::Normalized { value: result, obligations } =\n+            traits::normalize(&mut selcx, cause, value);\n+\n+        debug!(\"normalize_projections_in: result={:?} obligations={:?}\",\n+                result, obligations);\n+\n+        let mut fulfill_cx = traits::FulfillmentContext::new();\n+\n+        for obligation in obligations {\n+            fulfill_cx.register_predicate_obligation(self, obligation);\n         }\n+\n+        self.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &result)\n     }\n-}\n \n-/// Finishes processes any obligations that remain in the fulfillment\n-/// context, and then \"freshens\" and returns `result`. This is\n-/// primarily used during normalization and other cases where\n-/// processing the obligations in `fulfill_cx` may cause type\n-/// inference variables that appear in `result` to be unified, and\n-/// hence we need to process those obligations to get the complete\n-/// picture of the type.\n-pub fn drain_fulfillment_cx<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n-                                       fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n-                                       result: &T)\n-                                       -> Result<T,Vec<traits::FulfillmentError<'tcx>>>\n-    where T : TypeFoldable<'tcx>\n-{\n-    debug!(\"drain_fulfillment_cx(result={:?})\",\n-           result);\n-\n-    // In principle, we only need to do this so long as `result`\n-    // contains unbound type parameters. It could be a slight\n-    // optimization to stop iterating early.\n-    match fulfill_cx.select_all_or_error(infcx) {\n-        Ok(()) => { }\n-        Err(errors) => {\n-            return Err(errors);\n+    pub fn drain_fulfillment_cx_or_panic<T>(&self,\n+                                            span: Span,\n+                                            fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n+                                            result: &T)\n+                                            -> T::Lifted\n+        where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n+    {\n+        let when = \"resolving bounds after type-checking\";\n+        let v = match self.drain_fulfillment_cx(fulfill_cx, result) {\n+            Ok(v) => v,\n+            Err(errors) => {\n+                span_bug!(span, \"Encountered errors `{:?}` {}\", errors, when);\n+            }\n+        };\n+\n+        match self.tcx.lift_to_global(&v) {\n+            Some(v) => v,\n+            None => {\n+                span_bug!(span, \"Uninferred types/regions in `{:?}` {}\", v, when);\n+            }\n         }\n     }\n \n-    let result = infcx.resolve_type_vars_if_possible(result);\n-    Ok(infcx.tcx.erase_regions(&result))\n-}\n+    /// Finishes processes any obligations that remain in the fulfillment\n+    /// context, and then \"freshens\" and returns `result`. This is\n+    /// primarily used during normalization and other cases where\n+    /// processing the obligations in `fulfill_cx` may cause type\n+    /// inference variables that appear in `result` to be unified, and\n+    /// hence we need to process those obligations to get the complete\n+    /// picture of the type.\n+    pub fn drain_fulfillment_cx<T>(&self,\n+                                   fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n+                                   result: &T)\n+                                   -> Result<T,Vec<traits::FulfillmentError<'tcx>>>\n+        where T : TypeFoldable<'tcx>\n+    {\n+        debug!(\"drain_fulfillment_cx(result={:?})\",\n+               result);\n \n-impl<'tcx, T> InferOk<'tcx, T> {\n-    fn unit(self) -> InferOk<'tcx, ()> {\n-        InferOk { value: (), obligations: self.obligations }\n+        // In principle, we only need to do this so long as `result`\n+        // contains unbound type parameters. It could be a slight\n+        // optimization to stop iterating early.\n+        fulfill_cx.select_all_or_error(self)?;\n+\n+        let result = self.resolve_type_vars_if_possible(result);\n+        Ok(self.tcx.erase_regions(&result))\n     }\n-}\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn projection_mode(&self) -> ProjectionMode {\n         self.projection_mode\n     }\n@@ -621,7 +691,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn freshener<'b>(&'b self) -> TypeFreshener<'b, 'tcx> {\n+    pub fn freshener<'b>(&'b self) -> TypeFreshener<'b, 'gcx, 'tcx> {\n         freshen::TypeFreshener::new(self)\n     }\n \n@@ -692,8 +762,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     fn combine_fields(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-        -> CombineFields<'a, 'tcx>\n-    {\n+                      -> CombineFields<'a, 'gcx, 'tcx> {\n         CombineFields {\n             infcx: self,\n             a_is_expected: a_is_expected,\n@@ -705,7 +774,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn equate<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n         -> InferResult<'tcx, T>\n-        where T: Relate<'a, 'tcx>\n+        where T: Relate<'tcx>\n     {\n         let mut equate = self.combine_fields(a_is_expected, trace).equate();\n         let result = equate.relate(a, b);\n@@ -714,7 +783,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn sub<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n         -> InferResult<'tcx, T>\n-        where T: Relate<'a, 'tcx>\n+        where T: Relate<'tcx>\n     {\n         let mut sub = self.combine_fields(a_is_expected, trace).sub();\n         let result = sub.relate(a, b);\n@@ -723,7 +792,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn lub<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n         -> InferResult<'tcx, T>\n-        where T: Relate<'a, 'tcx>\n+        where T: Relate<'tcx>\n     {\n         let mut lub = self.combine_fields(a_is_expected, trace).lub();\n         let result = lub.relate(a, b);\n@@ -732,7 +801,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn glb<T>(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>, a: &T, b: &T)\n         -> InferResult<'tcx, T>\n-        where T: Relate<'a, 'tcx>\n+        where T: Relate<'tcx>\n     {\n         let mut glb = self.combine_fields(a_is_expected, trace).glb();\n         let result = glb.relate(a, b);\n@@ -892,6 +961,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         })\n     }\n \n+    pub fn can_sub_types(&self,\n+                         a: Ty<'tcx>,\n+                         b: Ty<'tcx>)\n+                         -> UnitResult<'tcx>\n+    {\n+        self.probe(|_| {\n+            let origin = TypeOrigin::Misc(codemap::DUMMY_SP);\n+            let trace = TypeTrace::types(origin, true, a, b);\n+            self.sub(true, trace, &a, &b).map(|_| ())\n+        })\n+    }\n+\n     pub fn eq_types(&self,\n                     a_is_expected: bool,\n                     origin: TypeOrigin,\n@@ -912,71 +993,54 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                           b: ty::TraitRef<'tcx>)\n         -> InferResult<'tcx, ()>\n     {\n-        debug!(\"eq_trait_refs({:?} <: {:?})\",\n-               a,\n-               b);\n+        debug!(\"eq_trait_refs({:?} = {:?})\", a, b);\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace {\n                 origin: origin,\n-                values: TraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n+                values: TraitRefs(ExpectedFound::new(a_is_expected, a, b))\n             };\n             self.equate(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n         })\n     }\n \n+    pub fn eq_impl_headers(&self,\n+                           a_is_expected: bool,\n+                           origin: TypeOrigin,\n+                           a: &ty::ImplHeader<'tcx>,\n+                           b: &ty::ImplHeader<'tcx>)\n+                           -> InferResult<'tcx, ()>\n+    {\n+        debug!(\"eq_impl_header({:?} = {:?})\", a, b);\n+        match (a.trait_ref, b.trait_ref) {\n+            (Some(a_ref), Some(b_ref)) => self.eq_trait_refs(a_is_expected, origin, a_ref, b_ref),\n+            (None, None) => self.eq_types(a_is_expected, origin, a.self_ty, b.self_ty),\n+            _ => bug!(\"mk_eq_impl_headers given mismatched impl kinds\"),\n+        }\n+    }\n+\n     pub fn sub_poly_trait_refs(&self,\n                                a_is_expected: bool,\n                                origin: TypeOrigin,\n                                a: ty::PolyTraitRef<'tcx>,\n                                b: ty::PolyTraitRef<'tcx>)\n         -> InferResult<'tcx, ()>\n     {\n-        debug!(\"sub_poly_trait_refs({:?} <: {:?})\",\n-               a,\n-               b);\n+        debug!(\"sub_poly_trait_refs({:?} <: {:?})\", a, b);\n         self.commit_if_ok(|_| {\n             let trace = TypeTrace {\n                 origin: origin,\n-                values: PolyTraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n+                values: PolyTraitRefs(ExpectedFound::new(a_is_expected, a, b))\n             };\n             self.sub(a_is_expected, trace, &a, &b).map(|ok| ok.unit())\n         })\n     }\n \n-    pub fn skolemize_late_bound_regions<T>(&self,\n-                                           value: &ty::Binder<T>,\n-                                           snapshot: &CombinedSnapshot)\n-                                           -> (T, SkolemizationMap)\n-        where T : TypeFoldable<'tcx>\n-    {\n-        /*! See `higher_ranked::skolemize_late_bound_regions` */\n-\n-        higher_ranked::skolemize_late_bound_regions(self, value, snapshot)\n-    }\n-\n-    pub fn leak_check(&self,\n-                      skol_map: &SkolemizationMap,\n-                      snapshot: &CombinedSnapshot)\n-                      -> UnitResult<'tcx>\n-    {\n-        /*! See `higher_ranked::leak_check` */\n-\n-        match higher_ranked::leak_check(self, skol_map, snapshot) {\n-            Ok(()) => Ok(()),\n-            Err((br, r)) => Err(TypeError::RegionsInsufficientlyPolymorphic(br, r))\n-        }\n-    }\n-\n-    pub fn plug_leaks<T>(&self,\n-                         skol_map: SkolemizationMap,\n-                         snapshot: &CombinedSnapshot,\n-                         value: &T)\n-                         -> T\n-        where T : TypeFoldable<'tcx>\n-    {\n-        /*! See `higher_ranked::plug_leaks` */\n-\n-        higher_ranked::plug_leaks(self, skol_map, snapshot, value)\n+    pub fn sub_regions(&self,\n+                       origin: SubregionOrigin<'tcx>,\n+                       a: ty::Region,\n+                       b: ty::Region) {\n+        debug!(\"sub_regions({:?} <: {:?})\", a, b);\n+        self.region_vars.make_subregion(origin, a, b);\n     }\n \n     pub fn equality_predicate(&self,\n@@ -988,8 +1052,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let (ty::EquatePredicate(a, b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n             let origin = TypeOrigin::EquatePredicate(span);\n-            let eqty_ok = mk_eqty(self, false, origin, a, b)?;\n-            self.leak_check(&skol_map, snapshot).map(|_| eqty_ok.unit())\n+            let eqty_ok = self.eq_types(false, origin, a, b)?;\n+            self.leak_check(false, &skol_map, snapshot).map(|_| eqty_ok.unit())\n         })\n     }\n \n@@ -1002,8 +1066,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let (ty::OutlivesPredicate(r_a, r_b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n             let origin = RelateRegionParamBound(span);\n-            let () = mk_subr(self, origin, r_b, r_a); // `b : a` ==> `a <= b`\n-            self.leak_check(&skol_map, snapshot)\n+            self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n+            self.leak_check(false, &skol_map, snapshot)\n         })\n     }\n \n@@ -1086,7 +1150,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn fresh_substs_for_generics(&self,\n                                      span: Span,\n                                      generics: &ty::Generics<'tcx>)\n-                                     -> subst::Substs<'tcx>\n+                                     -> &'tcx subst::Substs<'tcx>\n     {\n         let type_params = subst::VecPerParamSpace::empty();\n \n@@ -1104,7 +1168,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 generics.types.get_slice(*space));\n         }\n \n-        return substs;\n+        self.tcx.mk_substs(substs)\n     }\n \n     /// Given a set of generics defined on a trait, returns a substitution mapping each output\n@@ -1496,21 +1560,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.region_vars.verify_generic_bound(origin, kind, a, bound);\n     }\n \n-    pub fn can_equate<'b,T>(&'b self, a: &T, b: &T) -> UnitResult<'tcx>\n-        where T: Relate<'b,'tcx> + fmt::Debug\n+    pub fn can_equate<T>(&self, a: &T, b: &T) -> UnitResult<'tcx>\n+        where T: Relate<'tcx> + fmt::Debug\n     {\n         debug!(\"can_equate({:?}, {:?})\", a, b);\n         self.probe(|_| {\n             // Gin up a dummy trace, since this won't be committed\n             // anyhow. We should make this typetrace stuff more\n             // generic so we don't have to do anything quite this\n             // terrible.\n-            let e = self.tcx.types.err;\n-            let trace = TypeTrace {\n-                origin: TypeOrigin::Misc(codemap::DUMMY_SP),\n-                values: Types(expected_found(true, e, e))\n-            };\n-            self.equate(true, trace, a, b)\n+            self.equate(true, TypeTrace::dummy(self.tcx), a, b)\n         }).map(|_| ())\n     }\n \n@@ -1524,24 +1583,25 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.resolve_type_vars_or_error(&ty)\n     }\n \n-    pub fn tables_are_tcx_tables(&self) -> bool {\n-        let tables: &RefCell<ty::Tables> = &self.tables;\n-        let tcx_tables: &RefCell<ty::Tables> = &self.tcx.tables;\n-        tables as *const _ == tcx_tables as *const _\n-    }\n-\n     pub fn type_moves_by_default(&self, ty: Ty<'tcx>, span: Span) -> bool {\n         let ty = self.resolve_type_vars_if_possible(&ty);\n-        if ty.needs_infer() ||\n-            (ty.has_closure_types() && !self.tables_are_tcx_tables()) {\n-            // this can get called from typeck (by euv), and moves_by_default\n-            // rightly refuses to work with inference variables, but\n-            // moves_by_default has a cache, which we want to use in other\n-            // cases.\n-            !traits::type_known_to_meet_builtin_bound(self, ty, ty::BoundCopy, span)\n-        } else {\n-            ty.moves_by_default(&self.parameter_environment, span)\n+        if let Some(ty) = self.tcx.lift_to_global(&ty) {\n+            // Even if the type may have no inference variables, during\n+            // type-checking closure types are in local tables only.\n+            let local_closures = match self.tables {\n+                InferTables::Local(_) => ty.has_closure_types(),\n+                InferTables::Global(_) => false\n+            };\n+            if !local_closures {\n+                return ty.moves_by_default(self.tcx.global_tcx(), self.param_env(), span);\n+            }\n         }\n+\n+        // this can get called from typeck (by euv), and moves_by_default\n+        // rightly refuses to work with inference variables, but\n+        // moves_by_default has a cache, which we want to use in other\n+        // cases.\n+        !traits::type_known_to_meet_builtin_bound(self, ty, ty::BoundCopy, span)\n     }\n \n     pub fn node_method_ty(&self, method_call: ty::MethodCall)\n@@ -1584,7 +1644,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.tables.borrow().upvar_capture_map.get(&upvar_id).cloned()\n     }\n \n-    pub fn param_env<'b>(&'b self) -> &'b ty::ParameterEnvironment<'b,'tcx> {\n+    pub fn param_env(&self) -> &ty::ParameterEnvironment<'gcx> {\n         &self.parameter_environment\n     }\n \n@@ -1599,30 +1659,37 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             // during trans, we see closure ids from other traits.\n             // That may require loading the closure data out of the\n             // cstore.\n-            Some(ty::Tables::closure_kind(&self.tables, self.tcx, def_id))\n+            Some(self.tcx.closure_kind(def_id))\n         }\n     }\n \n     pub fn closure_type(&self,\n                         def_id: DefId,\n-                        substs: &ty::ClosureSubsts<'tcx>)\n+                        substs: ty::ClosureSubsts<'tcx>)\n                         -> ty::ClosureTy<'tcx>\n     {\n-        let closure_ty =\n-            ty::Tables::closure_type(self.tables,\n-                                     self.tcx,\n-                                     def_id,\n-                                     substs);\n+        if let InferTables::Local(tables) = self.tables {\n+            if let Some(ty) = tables.borrow().closure_tys.get(&def_id) {\n+                return ty.subst(self.tcx, substs.func_substs);\n+            }\n+        }\n \n+        let closure_ty = self.tcx.closure_type(def_id, substs);\n         if self.normalize {\n-            normalize_associated_type(&self.tcx, &closure_ty)\n+            let closure_ty = self.tcx.erase_regions(&closure_ty);\n+\n+            if !closure_ty.has_projection_types() {\n+                return closure_ty;\n+            }\n+\n+            self.normalize_projections_in(&closure_ty)\n         } else {\n             closure_ty\n         }\n     }\n }\n \n-impl<'tcx> TypeTrace<'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {\n     pub fn span(&self) -> Span {\n         self.origin.span()\n     }\n@@ -1634,11 +1701,11 @@ impl<'tcx> TypeTrace<'tcx> {\n                  -> TypeTrace<'tcx> {\n         TypeTrace {\n             origin: origin,\n-            values: Types(expected_found(a_is_expected, a, b))\n+            values: Types(ExpectedFound::new(a_is_expected, a, b))\n         }\n     }\n \n-    pub fn dummy(tcx: &TyCtxt<'tcx>) -> TypeTrace<'tcx> {\n+    pub fn dummy(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> TypeTrace<'tcx> {\n         TypeTrace {\n             origin: TypeOrigin::Misc(codemap::DUMMY_SP),\n             values: Types(ExpectedFound {"}, {"sha": "c9037d6b12aa8ee7302a4e1cae6d7417a881e83b", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -53,8 +53,10 @@ graphs will be printed.                                                     \\n\\\n \");\n }\n \n-pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a, 'tcx>,\n-                                             subject_node: ast::NodeId) {\n+pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n+    region_vars: &RegionVarBindings<'a, 'gcx, 'tcx>,\n+    subject_node: ast::NodeId)\n+{\n     let tcx = region_vars.tcx;\n \n     if !region_vars.tcx.sess.opts.debugging_opts.print_region_graph {\n@@ -118,8 +120,8 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n     }\n }\n \n-struct ConstraintGraph<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+struct ConstraintGraph<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     graph_name: String,\n     map: &'a FnvHashMap<Constraint, SubregionOrigin<'tcx>>,\n     node_ids: FnvHashMap<Node, usize>,\n@@ -138,11 +140,11 @@ enum Edge {\n     EnclScope(CodeExtent, CodeExtent),\n }\n \n-impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n-    fn new(tcx: &'a TyCtxt<'tcx>,\n+impl<'a, 'gcx, 'tcx> ConstraintGraph<'a, 'gcx, 'tcx> {\n+    fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n            name: String,\n            map: &'a ConstraintMap<'tcx>)\n-           -> ConstraintGraph<'a, 'tcx> {\n+           -> ConstraintGraph<'a, 'gcx, 'tcx> {\n         let mut i = 0;\n         let mut node_ids = FnvHashMap();\n         {\n@@ -173,7 +175,7 @@ impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n     type Node = Node;\n     type Edge = Edge;\n     fn graph_id(&self) -> dot::Id {\n@@ -226,7 +228,7 @@ fn edge_to_nodes(e: &Edge) -> (Node, Node) {\n     }\n }\n \n-impl<'a, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n     type Node = Node;\n     type Edge = Edge;\n     fn nodes(&self) -> dot::Nodes<Node> {\n@@ -258,10 +260,10 @@ impl<'a, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'tcx> {\n \n pub type ConstraintMap<'tcx> = FnvHashMap<Constraint, SubregionOrigin<'tcx>>;\n \n-fn dump_region_constraints_to<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n-                                            map: &ConstraintMap<'tcx>,\n-                                            path: &str)\n-                                            -> io::Result<()> {\n+fn dump_region_constraints_to<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                              map: &ConstraintMap<'tcx>,\n+                                              path: &str)\n+                                              -> io::Result<()> {\n     debug!(\"dump_region_constraints map (len: {}) path: {}\",\n            map.len(),\n            path);"}, {"sha": "b889d0a9daab6259037fffa03cf6bc348c59da20", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -190,8 +190,8 @@ impl SameRegions {\n \n pub type CombineMap = FnvHashMap<TwoRegions, RegionVid>;\n \n-pub struct RegionVarBindings<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     var_origins: RefCell<Vec<RegionVariableOrigin>>,\n \n     // Constraints of the form `A <= B` introduced by the region\n@@ -253,8 +253,8 @@ pub struct RegionSnapshot {\n     skolemization_count: u32,\n }\n \n-impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n-    pub fn new(tcx: &'a TyCtxt<'tcx>) -> RegionVarBindings<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> RegionVarBindings<'a, 'gcx, 'tcx> {\n         RegionVarBindings {\n             tcx: tcx,\n             var_origins: RefCell::new(Vec::new()),\n@@ -600,7 +600,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                            origin: SubregionOrigin<'tcx>,\n                            mut relate: F)\n                            -> Region\n-        where F: FnMut(&RegionVarBindings<'a, 'tcx>, Region, Region)\n+        where F: FnMut(&RegionVarBindings<'a, 'gcx, 'tcx>, Region, Region)\n     {\n         let vars = TwoRegions { a: a, b: b };\n         match self.combine_map(t).borrow().get(&vars) {\n@@ -816,7 +816,7 @@ struct RegionAndOrigin<'tcx> {\n \n type RegionGraph = graph::Graph<(), Constraint>;\n \n-impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     fn infer_variable_values(&self,\n                              free_regions: &FreeRegionMap,\n                              errors: &mut Vec<RegionResolutionError<'tcx>>,\n@@ -1249,11 +1249,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         let WalkState {result, dup_found, ..} = state;\n         return (result, dup_found);\n \n-        fn process_edges<'a, 'tcx>(this: &RegionVarBindings<'a, 'tcx>,\n-                                   state: &mut WalkState<'tcx>,\n-                                   graph: &RegionGraph,\n-                                   source_vid: RegionVid,\n-                                   dir: Direction) {\n+        fn process_edges<'a, 'gcx, 'tcx>(this: &RegionVarBindings<'a, 'gcx, 'tcx>,\n+                                         state: &mut WalkState<'tcx>,\n+                                         graph: &RegionGraph,\n+                                         source_vid: RegionVid,\n+                                         dir: Direction) {\n             debug!(\"process_edges(source_vid={:?}, dir={:?})\", source_vid, dir);\n \n             let source_node_index = NodeIndex(source_vid.index as usize);\n@@ -1362,16 +1362,16 @@ impl<'tcx> fmt::Display for GenericKind<'tcx> {\n     }\n }\n \n-impl<'tcx> GenericKind<'tcx> {\n-    pub fn to_ty(&self, tcx: &TyCtxt<'tcx>) -> Ty<'tcx> {\n+impl<'a, 'gcx, 'tcx> GenericKind<'tcx> {\n+    pub fn to_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n             GenericKind::Param(ref p) => p.to_ty(tcx),\n             GenericKind::Projection(ref p) => tcx.mk_projection(p.trait_ref.clone(), p.item_name),\n         }\n     }\n }\n \n-impl VerifyBound {\n+impl<'a, 'gcx, 'tcx> VerifyBound {\n     fn for_each_region(&self, f: &mut FnMut(ty::Region)) {\n         match self {\n             &VerifyBound::AnyRegion(ref rs) |\n@@ -1424,12 +1424,11 @@ impl VerifyBound {\n         }\n     }\n \n-    fn is_met<'tcx>(&self,\n-                    tcx: &TyCtxt<'tcx>,\n-                    free_regions: &FreeRegionMap,\n-                    var_values: &Vec<VarValue>,\n-                    min: ty::Region)\n-                    -> bool {\n+    fn is_met(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+              free_regions: &FreeRegionMap,\n+              var_values: &Vec<VarValue>,\n+              min: ty::Region)\n+              -> bool {\n         match self {\n             &VerifyBound::AnyRegion(ref rs) =>\n                 rs.iter()"}, {"sha": "5f550b427e21aed275e47d59357bbfdb9de613d8", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -10,6 +10,7 @@\n \n use super::{InferCtxt, FixupError, FixupResult};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::fold::TypeFolder;\n \n ///////////////////////////////////////////////////////////////////////////\n // OPPORTUNISTIC TYPE RESOLVER\n@@ -19,18 +20,18 @@ use ty::{self, Ty, TyCtxt, TypeFoldable};\n /// been unified with (similar to `shallow_resolve`, but deep). This is\n /// useful for printing messages etc but also required at various\n /// points for correctness.\n-pub struct OpportunisticTypeResolver<'a, 'tcx:'a> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+pub struct OpportunisticTypeResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> OpportunisticTypeResolver<'a, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> OpportunisticTypeResolver<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> OpportunisticTypeResolver<'a, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n         OpportunisticTypeResolver { infcx: infcx }\n     }\n }\n \n-impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for OpportunisticTypeResolver<'a, 'tcx> {\n-    fn tcx(&self) -> &TyCtxt<'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeResolver<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -47,18 +48,18 @@ impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for OpportunisticTypeResolver<'a, 'tcx\n /// The opportunistic type and region resolver is similar to the\n /// opportunistic type resolver, but also opportunistly resolves\n /// regions. It is useful for canonicalization.\n-pub struct OpportunisticTypeAndRegionResolver<'a, 'tcx:'a> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+pub struct OpportunisticTypeAndRegionResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> OpportunisticTypeAndRegionResolver<'a, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n+impl<'a, 'gcx, 'tcx> OpportunisticTypeAndRegionResolver<'a, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n         OpportunisticTypeAndRegionResolver { infcx: infcx }\n     }\n }\n \n-impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for OpportunisticTypeAndRegionResolver<'a, 'tcx> {\n-    fn tcx(&self) -> &TyCtxt<'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeAndRegionResolver<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -85,7 +86,8 @@ impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for OpportunisticTypeAndRegionResolver\n /// Full type resolution replaces all type and region variables with\n /// their concrete results. If any variable cannot be replaced (never unified, etc)\n /// then an `Err` result is returned.\n-pub fn fully_resolve<'a, 'tcx, T>(infcx: &InferCtxt<'a,'tcx>, value: &T) -> FixupResult<T>\n+pub fn fully_resolve<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                        value: &T) -> FixupResult<T>\n     where T : TypeFoldable<'tcx>\n {\n     let mut full_resolver = FullTypeResolver { infcx: infcx, err: None };\n@@ -98,13 +100,13 @@ pub fn fully_resolve<'a, 'tcx, T>(infcx: &InferCtxt<'a,'tcx>, value: &T) -> Fixu\n \n // N.B. This type is not public because the protocol around checking the\n // `err` field is not enforcable otherwise.\n-struct FullTypeResolver<'a, 'tcx:'a> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+struct FullTypeResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     err: Option<FixupError>,\n }\n \n-impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n-    fn tcx(&self) -> &TyCtxt<'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "680dd0d63556b6fe661f51fb2ff0a9d164b6dab1", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::combine::{self, CombineFields};\n-use super::higher_ranked::HigherRankedRelations;\n+use super::combine::CombineFields;\n use super::SubregionOrigin;\n use super::type_variable::{SubtypeOf, SupertypeOf};\n \n@@ -20,12 +19,12 @@ use traits::PredicateObligations;\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success.\n-pub struct Sub<'a, 'tcx: 'a> {\n-    fields: CombineFields<'a, 'tcx>,\n+pub struct Sub<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'gcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> Sub<'a, 'tcx> {\n-    pub fn new(f: CombineFields<'a, 'tcx>) -> Sub<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Sub<'a, 'gcx, 'tcx> {\n+    pub fn new(f: CombineFields<'a, 'gcx, 'tcx>) -> Sub<'a, 'gcx, 'tcx> {\n         Sub { fields: f }\n     }\n \n@@ -34,9 +33,9 @@ impl<'a, 'tcx> Sub<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Sub<'a, 'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Sub\" }\n-    fn tcx(&self) -> &'a TyCtxt<'tcx> { self.fields.infcx.tcx }\n+    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.fields.infcx.tcx }\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n     fn with_cause<F,R>(&mut self, cause: Cause, f: F) -> R\n@@ -50,11 +49,11 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n         r\n     }\n \n-    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n-                                               variance: ty::Variance,\n-                                               a: &T,\n-                                               b: &T)\n-                                               -> RelateResult<'tcx, T>\n+    fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n+                                             variance: ty::Variance,\n+                                             a: &T,\n+                                             b: &T)\n+                                             -> RelateResult<'tcx, T>\n     {\n         match variance {\n             ty::Invariant => self.fields.equate().relate(a, b),\n@@ -96,7 +95,7 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n             }\n \n             _ => {\n-                combine::super_combine_tys(self.fields.infcx, self, a, b)?;\n+                self.fields.infcx.super_combine_tys(self, a, b)?;\n                 Ok(a)\n             }\n         }\n@@ -115,7 +114,7 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n-        where T: Relate<'a,'tcx>\n+        where T: Relate<'tcx>\n     {\n         self.fields.higher_ranked_sub(a, b)\n     }"}, {"sha": "d7e3a53ff25c92dca5f4129e81480fbfb3873287", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -12,8 +12,8 @@ use syntax::ast;\n use ty::{self, IntVarValue, Ty, TyCtxt};\n use rustc_data_structures::unify::{Combine, UnifyKey};\n \n-pub trait ToType<'tcx> {\n-    fn to_type(&self, tcx: &TyCtxt<'tcx>) -> Ty<'tcx>;\n+pub trait ToType {\n+    fn to_type<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>;\n }\n \n impl UnifyKey for ty::IntVid {\n@@ -50,8 +50,8 @@ impl UnifyKey for ty::RegionVid {\n     fn tag(_: Option<ty::RegionVid>) -> &'static str { \"RegionVid\" }\n }\n \n-impl<'tcx> ToType<'tcx> for IntVarValue {\n-    fn to_type(&self, tcx: &TyCtxt<'tcx>) -> Ty<'tcx> {\n+impl ToType for IntVarValue {\n+    fn to_type<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n             ty::IntType(i) => tcx.mk_mach_int(i),\n             ty::UintType(i) => tcx.mk_mach_uint(i),\n@@ -68,8 +68,8 @@ impl UnifyKey for ty::FloatVid {\n     fn tag(_: Option<ty::FloatVid>) -> &'static str { \"FloatVid\" }\n }\n \n-impl<'tcx> ToType<'tcx> for ast::FloatTy {\n-    fn to_type(&self, tcx: &TyCtxt<'tcx>) -> Ty<'tcx> {\n+impl ToType for ast::FloatTy {\n+    fn to_type<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         tcx.mk_mach_float(*self)\n     }\n }"}, {"sha": "a4b9b5f45563f4e18f864e6a45acc73514b6d680", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -297,7 +297,7 @@ impl LintStore {\n /// Context for lint checking after type checking.\n pub struct LateContext<'a, 'tcx: 'a> {\n     /// Type context we're checking in.\n-    pub tcx: &'a TyCtxt<'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     /// The crate being checked.\n     pub krate: &'a hir::Crate,\n@@ -652,7 +652,7 @@ impl<'a> EarlyContext<'a> {\n }\n \n impl<'a, 'tcx> LateContext<'a, 'tcx> {\n-    fn new(tcx: &'a TyCtxt<'tcx>,\n+    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            krate: &'a hir::Crate,\n            access_levels: &'a AccessLevels) -> LateContext<'a, 'tcx> {\n         // We want to own the lint store, so move it out of the session.\n@@ -740,7 +740,8 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     /// items in the context of the outer item, so enable\n     /// deep-walking.\n     fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        self.visit_item(self.tcx.map.expect_item(item.id))\n+        let tcx = self.tcx;\n+        self.visit_item(tcx.map.expect_item(item.id))\n     }\n \n     fn visit_item(&mut self, it: &hir::Item) {\n@@ -1219,7 +1220,8 @@ fn check_lint_name_cmdline(sess: &Session, lint_cx: &LintStore,\n /// Perform lint checking on a crate.\n ///\n /// Consumes the `lint_store` field of the `Session`.\n-pub fn check_crate(tcx: &TyCtxt, access_levels: &AccessLevels) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             access_levels: &AccessLevels) {\n     let _task = tcx.dep_graph.in_task(DepNode::LateLintCheck);\n \n     let krate = tcx.map.krate();"}, {"sha": "8f97a89e6547e321cdccf347598a4219dae82dc4", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 49, "deletions": 48, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -20,63 +20,64 @@ use ty::{Ty, TyCtxt};\n use syntax::codemap::Span;\n use hir as ast;\n \n-pub fn prohibit_type_params(tcx: &TyCtxt, segments: &[ast::PathSegment]) {\n-    for segment in segments {\n-        for typ in segment.parameters.types() {\n-            span_err!(tcx.sess, typ.span, E0109,\n-                      \"type parameters are not allowed on this type\");\n-            break;\n-        }\n-        for lifetime in segment.parameters.lifetimes() {\n-            span_err!(tcx.sess, lifetime.span, E0110,\n-                      \"lifetime parameters are not allowed on this type\");\n-            break;\n-        }\n-        for binding in segment.parameters.bindings() {\n-            prohibit_projection(tcx, binding.span);\n-            break;\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    pub fn prohibit_type_params(self, segments: &[ast::PathSegment]) {\n+        for segment in segments {\n+            for typ in segment.parameters.types() {\n+                span_err!(self.sess, typ.span, E0109,\n+                          \"type parameters are not allowed on this type\");\n+                break;\n+            }\n+            for lifetime in segment.parameters.lifetimes() {\n+                span_err!(self.sess, lifetime.span, E0110,\n+                          \"lifetime parameters are not allowed on this type\");\n+                break;\n+            }\n+            for binding in segment.parameters.bindings() {\n+                self.prohibit_projection(binding.span);\n+                break;\n+            }\n         }\n     }\n-}\n \n-pub fn prohibit_projection(tcx: &TyCtxt, span: Span)\n-{\n-    span_err!(tcx.sess, span, E0229,\n-              \"associated type bindings are not allowed here\");\n-}\n+    pub fn prohibit_projection(self, span: Span)\n+    {\n+        span_err!(self.sess, span, E0229,\n+                  \"associated type bindings are not allowed here\");\n+    }\n \n-pub fn prim_ty_to_ty<'tcx>(tcx: &TyCtxt<'tcx>,\n-                           segments: &[ast::PathSegment],\n-                           nty: ast::PrimTy)\n-                           -> Ty<'tcx> {\n-    prohibit_type_params(tcx, segments);\n-    match nty {\n-        ast::TyBool => tcx.types.bool,\n-        ast::TyChar => tcx.types.char,\n-        ast::TyInt(it) => tcx.mk_mach_int(it),\n-        ast::TyUint(uit) => tcx.mk_mach_uint(uit),\n-        ast::TyFloat(ft) => tcx.mk_mach_float(ft),\n-        ast::TyStr => tcx.mk_str()\n+    pub fn prim_ty_to_ty(self,\n+                         segments: &[ast::PathSegment],\n+                         nty: ast::PrimTy)\n+                         -> Ty<'tcx> {\n+        self.prohibit_type_params(segments);\n+        match nty {\n+            ast::TyBool => self.types.bool,\n+            ast::TyChar => self.types.char,\n+            ast::TyInt(it) => self.mk_mach_int(it),\n+            ast::TyUint(uit) => self.mk_mach_uint(uit),\n+            ast::TyFloat(ft) => self.mk_mach_float(ft),\n+            ast::TyStr => self.mk_str()\n+        }\n     }\n-}\n \n-/// If a type in the AST is a primitive type, return the ty::Ty corresponding\n-/// to it.\n-pub fn ast_ty_to_prim_ty<'tcx>(tcx: &TyCtxt<'tcx>, ast_ty: &ast::Ty)\n-                               -> Option<Ty<'tcx>> {\n-    if let ast::TyPath(None, ref path) = ast_ty.node {\n-        let def = match tcx.def_map.borrow().get(&ast_ty.id) {\n-            None => {\n-                span_bug!(ast_ty.span, \"unbound path {:?}\", path)\n+    /// If a type in the AST is a primitive type, return the ty::Ty corresponding\n+    /// to it.\n+    pub fn ast_ty_to_prim_ty(self, ast_ty: &ast::Ty) -> Option<Ty<'tcx>> {\n+        if let ast::TyPath(None, ref path) = ast_ty.node {\n+            let def = match self.def_map.borrow().get(&ast_ty.id) {\n+                None => {\n+                    span_bug!(ast_ty.span, \"unbound path {:?}\", path)\n+                }\n+                Some(d) => d.full_def()\n+            };\n+            if let Def::PrimTy(nty) = def {\n+                Some(self.prim_ty_to_ty(&path.segments, nty))\n+            } else {\n+                None\n             }\n-            Some(d) => d.full_def()\n-        };\n-        if let Def::PrimTy(nty) = def {\n-            Some(prim_ty_to_ty(tcx, &path.segments, nty))\n         } else {\n             None\n         }\n-    } else {\n-        None\n     }\n }"}, {"sha": "c0af457ed236c3bcdc733dd38b2ee86589d95b5f", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 79, "deletions": 82, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -160,57 +160,56 @@ pub trait CrateStore<'tcx> : Any {\n     fn stability(&self, def: DefId) -> Option<attr::Stability>;\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation>;\n     fn visibility(&self, def: DefId) -> ty::Visibility;\n-    fn closure_kind(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n-                    -> ty::ClosureKind;\n-    fn closure_ty(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n-                  -> ty::ClosureTy<'tcx>;\n+    fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind;\n+    fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n+                      -> ty::ClosureTy<'tcx>;\n     fn item_variances(&self, def: DefId) -> ty::ItemVariances;\n     fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr>;\n-    fn item_type(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                 -> ty::TypeScheme<'tcx>;\n+    fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                     -> ty::TypeScheme<'tcx>;\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>>;\n     fn item_name(&self, def: DefId) -> ast::Name;\n-    fn item_predicates(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                       -> ty::GenericPredicates<'tcx>;\n-    fn item_super_predicates(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                             -> ty::GenericPredicates<'tcx>;\n+    fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                           -> ty::GenericPredicates<'tcx>;\n+    fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                                 -> ty::GenericPredicates<'tcx>;\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n     fn item_symbol(&self, def: DefId) -> String;\n-    fn trait_def(&self, tcx: &TyCtxt<'tcx>, def: DefId)-> ty::TraitDef<'tcx>;\n-    fn adt_def(&self, tcx: &TyCtxt<'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>;\n+    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>;\n+    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>;\n     fn method_arg_names(&self, did: DefId) -> Vec<String>;\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>;\n \n     // trait info\n     fn implementations_of_trait(&self, def_id: DefId) -> Vec<DefId>;\n-    fn provided_trait_methods(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                              -> Vec<Rc<ty::Method<'tcx>>>;\n+    fn provided_trait_methods<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                                  -> Vec<Rc<ty::Method<'tcx>>>;\n     fn trait_item_def_ids(&self, def: DefId)\n                           -> Vec<ty::ImplOrTraitItemId>;\n \n     // impl info\n     fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>;\n-    fn impl_trait_ref(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                      -> Option<ty::TraitRef<'tcx>>;\n+    fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                          -> Option<ty::TraitRef<'tcx>>;\n     fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity>;\n     fn custom_coerce_unsized_kind(&self, def: DefId)\n                                   -> Option<ty::adjustment::CustomCoerceUnsized>;\n-    fn associated_consts(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                         -> Vec<Rc<ty::AssociatedConst<'tcx>>>;\n+    fn associated_consts<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                             -> Vec<Rc<ty::AssociatedConst<'tcx>>>;\n     fn impl_parent(&self, impl_def_id: DefId) -> Option<DefId>;\n \n     // trait/impl-item info\n-    fn trait_of_item(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n-                     -> Option<DefId>;\n-    fn impl_or_trait_item(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> Option<ty::ImplOrTraitItem<'tcx>>;\n+    fn trait_of_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n+                         -> Option<DefId>;\n+    fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                              -> Option<ty::ImplOrTraitItem<'tcx>>;\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool;\n     fn is_defaulted_trait(&self, did: DefId) -> bool;\n     fn is_impl(&self, did: DefId) -> bool;\n     fn is_default_impl(&self, impl_did: DefId) -> bool;\n-    fn is_extern_item(&self, tcx: &TyCtxt<'tcx>, did: DefId) -> bool;\n+    fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool;\n     fn is_static_method(&self, did: DefId) -> bool;\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool;\n     fn is_typedef(&self, did: DefId) -> bool;\n@@ -251,10 +250,10 @@ pub trait CrateStore<'tcx> : Any {\n     fn crate_top_level_items(&self, cnum: ast::CrateNum) -> Vec<ChildItem>;\n \n     // misc. metadata\n-    fn maybe_get_item_ast(&'tcx self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> FoundAst<'tcx>;\n-    fn maybe_get_item_mir(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> Option<Mir<'tcx>>;\n+    fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                              -> FoundAst<'tcx>;\n+    fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                              -> Option<Mir<'tcx>>;\n     fn is_item_mir_available(&self, def: DefId) -> bool;\n \n     // This is basically a 1-based range of ints, which is a little\n@@ -266,22 +265,21 @@ pub trait CrateStore<'tcx> : Any {\n     // utility functions\n     fn metadata_filename(&self) -> &str;\n     fn metadata_section_name(&self, target: &Target) -> &str;\n-    fn encode_type(&self,\n-                   tcx: &TyCtxt<'tcx>,\n-                   ty: Ty<'tcx>,\n-                   def_id_to_string: fn(&TyCtxt<'tcx>, DefId) -> String)\n-                   -> Vec<u8>;\n+    fn encode_type<'a>(&self,\n+                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                       ty: Ty<'tcx>,\n+                       def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String)\n+                       -> Vec<u8>;\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>;\n     fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource;\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum>;\n-    fn encode_metadata(&self,\n-                       tcx: &TyCtxt<'tcx>,\n-                       reexports: &def::ExportMap,\n-                       item_symbols: &RefCell<NodeMap<String>>,\n-                       link_meta: &LinkMeta,\n-                       reachable: &NodeSet,\n-                       mir_map: &MirMap<'tcx>,\n-                       krate: &hir::Crate) -> Vec<u8>;\n+    fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           reexports: &def::ExportMap,\n+                           item_symbols: &RefCell<NodeMap<String>>,\n+                           link_meta: &LinkMeta,\n+                           reachable: &NodeSet,\n+                           mir_map: &MirMap<'tcx>,\n+                           krate: &hir::Crate) -> Vec<u8>;\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n \n@@ -339,63 +337,63 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn stability(&self, def: DefId) -> Option<attr::Stability> { bug!(\"stability\") }\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> { bug!(\"deprecation\") }\n     fn visibility(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }\n-    fn closure_kind(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n-                    -> ty::ClosureKind  { bug!(\"closure_kind\") }\n-    fn closure_ty(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n-                  -> ty::ClosureTy<'tcx>  { bug!(\"closure_ty\") }\n+    fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind  { bug!(\"closure_kind\") }\n+    fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n+                      -> ty::ClosureTy<'tcx>  { bug!(\"closure_ty\") }\n     fn item_variances(&self, def: DefId) -> ty::ItemVariances { bug!(\"item_variances\") }\n     fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr> { bug!(\"repr_attrs\") }\n-    fn item_type(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                 -> ty::TypeScheme<'tcx> { bug!(\"item_type\") }\n+    fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                     -> ty::TypeScheme<'tcx> { bug!(\"item_type\") }\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>> {\n         bug!(\"visible_parent_map\")\n     }\n     fn item_name(&self, def: DefId) -> ast::Name { bug!(\"item_name\") }\n-    fn item_predicates(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                       -> ty::GenericPredicates<'tcx> { bug!(\"item_predicates\") }\n-    fn item_super_predicates(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                             -> ty::GenericPredicates<'tcx> { bug!(\"item_super_predicates\") }\n+    fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                           -> ty::GenericPredicates<'tcx> { bug!(\"item_predicates\") }\n+    fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                                 -> ty::GenericPredicates<'tcx> { bug!(\"item_super_predicates\") }\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n     fn item_symbol(&self, def: DefId) -> String { bug!(\"item_symbol\") }\n-    fn trait_def(&self, tcx: &TyCtxt<'tcx>, def: DefId)-> ty::TraitDef<'tcx>\n+    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>\n         { bug!(\"trait_def\") }\n-    fn adt_def(&self, tcx: &TyCtxt<'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n+    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n         { bug!(\"adt_def\") }\n     fn method_arg_names(&self, did: DefId) -> Vec<String> { bug!(\"method_arg_names\") }\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n \n     // trait info\n     fn implementations_of_trait(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n-    fn provided_trait_methods(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                              -> Vec<Rc<ty::Method<'tcx>>> { bug!(\"provided_trait_methods\") }\n+    fn provided_trait_methods<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                                  -> Vec<Rc<ty::Method<'tcx>>> { bug!(\"provided_trait_methods\") }\n     fn trait_item_def_ids(&self, def: DefId)\n                           -> Vec<ty::ImplOrTraitItemId> { bug!(\"trait_item_def_ids\") }\n \n     // impl info\n     fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>\n         { bug!(\"impl_items\") }\n-    fn impl_trait_ref(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                      -> Option<ty::TraitRef<'tcx>> { bug!(\"impl_trait_ref\") }\n+    fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                          -> Option<ty::TraitRef<'tcx>> { bug!(\"impl_trait_ref\") }\n     fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity> { bug!(\"impl_polarity\") }\n     fn custom_coerce_unsized_kind(&self, def: DefId)\n                                   -> Option<ty::adjustment::CustomCoerceUnsized>\n         { bug!(\"custom_coerce_unsized_kind\") }\n-    fn associated_consts(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                         -> Vec<Rc<ty::AssociatedConst<'tcx>>> { bug!(\"associated_consts\") }\n+    fn associated_consts<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                             -> Vec<Rc<ty::AssociatedConst<'tcx>>> { bug!(\"associated_consts\") }\n     fn impl_parent(&self, def: DefId) -> Option<DefId> { bug!(\"impl_parent\") }\n \n     // trait/impl-item info\n-    fn trait_of_item(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n-                     -> Option<DefId> { bug!(\"trait_of_item\") }\n-    fn impl_or_trait_item(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> Option<ty::ImplOrTraitItem<'tcx>> { bug!(\"impl_or_trait_item\") }\n+    fn trait_of_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n+                         -> Option<DefId> { bug!(\"trait_of_item\") }\n+    fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                              -> Option<ty::ImplOrTraitItem<'tcx>> { bug!(\"impl_or_trait_item\") }\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool { bug!(\"is_const_fn\") }\n     fn is_defaulted_trait(&self, did: DefId) -> bool { bug!(\"is_defaulted_trait\") }\n     fn is_impl(&self, did: DefId) -> bool { bug!(\"is_impl\") }\n     fn is_default_impl(&self, impl_did: DefId) -> bool { bug!(\"is_default_impl\") }\n-    fn is_extern_item(&self, tcx: &TyCtxt<'tcx>, did: DefId) -> bool { bug!(\"is_extern_item\") }\n+    fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool\n+        { bug!(\"is_extern_item\") }\n     fn is_static_method(&self, did: DefId) -> bool { bug!(\"is_static_method\") }\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool { false }\n     fn is_typedef(&self, did: DefId) -> bool { bug!(\"is_typedef\") }\n@@ -448,10 +446,10 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n         { bug!(\"crate_top_level_items\") }\n \n     // misc. metadata\n-    fn maybe_get_item_ast(&'tcx self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> FoundAst<'tcx> { bug!(\"maybe_get_item_ast\") }\n-    fn maybe_get_item_mir(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> Option<Mir<'tcx>> { bug!(\"maybe_get_item_mir\") }\n+    fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                              -> FoundAst<'tcx> { bug!(\"maybe_get_item_ast\") }\n+    fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                              -> Option<Mir<'tcx>> { bug!(\"maybe_get_item_mir\") }\n     fn is_item_mir_available(&self, def: DefId) -> bool {\n         bug!(\"is_item_mir_available\")\n     }\n@@ -465,25 +463,24 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // utility functions\n     fn metadata_filename(&self) -> &str { bug!(\"metadata_filename\") }\n     fn metadata_section_name(&self, target: &Target) -> &str { bug!(\"metadata_section_name\") }\n-    fn encode_type(&self,\n-                   tcx: &TyCtxt<'tcx>,\n-                   ty: Ty<'tcx>,\n-                   def_id_to_string: fn(&TyCtxt<'tcx>, DefId) -> String)\n-                   -> Vec<u8> {\n+    fn encode_type<'a>(&self,\n+                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                       ty: Ty<'tcx>,\n+                       def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String)\n+                       -> Vec<u8> {\n         bug!(\"encode_type\")\n     }\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>\n         { vec![] }\n     fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum> { None }\n-    fn encode_metadata(&self,\n-                       tcx: &TyCtxt<'tcx>,\n-                       reexports: &def::ExportMap,\n-                       item_symbols: &RefCell<NodeMap<String>>,\n-                       link_meta: &LinkMeta,\n-                       reachable: &NodeSet,\n-                       mir_map: &MirMap<'tcx>,\n-                       krate: &hir::Crate) -> Vec<u8> { vec![] }\n+    fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           reexports: &def::ExportMap,\n+                           item_symbols: &RefCell<NodeMap<String>>,\n+                           link_meta: &LinkMeta,\n+                           reachable: &NodeSet,\n+                           mir_map: &MirMap<'tcx>,\n+                           krate: &hir::Crate) -> Vec<u8> { vec![] }\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n }\n \n@@ -510,7 +507,7 @@ pub mod tls {\n     use hir::def_id::DefId;\n \n     pub trait EncodingContext<'tcx> {\n-        fn tcx<'a>(&'a self) -> &'a TyCtxt<'tcx>;\n+        fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n         fn encode_ty(&self, encoder: &mut OpaqueEncoder, t: Ty<'tcx>);\n         fn encode_substs(&self, encoder: &mut OpaqueEncoder, substs: &Substs<'tcx>);\n     }\n@@ -577,7 +574,7 @@ pub mod tls {\n     }\n \n     pub trait DecodingContext<'tcx> {\n-        fn tcx<'a>(&'a self) -> &'a TyCtxt<'tcx>;\n+        fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n         fn decode_ty(&self, decoder: &mut OpaqueDecoder) -> ty::Ty<'tcx>;\n         fn decode_substs(&self, decoder: &mut OpaqueDecoder) -> Substs<'tcx>;\n         fn translate_def_id(&self, def_id: DefId) -> DefId;"}, {"sha": "41b27a48b29f8b789775eb60b7e09d1ed4a2dd6a", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -37,7 +37,7 @@ pub enum EntryOrExit {\n \n #[derive(Clone)]\n pub struct DataFlowContext<'a, 'tcx: 'a, O> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     /// a name for the analysis using this dataflow instance\n     analysis_name: &'static str,\n@@ -222,7 +222,7 @@ pub enum KillFrom {\n }\n \n impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n-    pub fn new(tcx: &'a TyCtxt<'tcx>,\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                analysis_name: &'static str,\n                decl: Option<&hir::FnDecl>,\n                cfg: &cfg::CFG,"}, {"sha": "cc6b83fccf92cdd5e8813a9d5323dc8ddd7c7dc6", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -31,7 +31,8 @@ use syntax::attr;\n // explored. For example, if it's a live NodeItem that is a\n // function, then we should explore its block to check for codes that\n // may need to be marked as live.\n-fn should_explore(tcx: &TyCtxt, node_id: ast::NodeId) -> bool {\n+fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            node_id: ast::NodeId) -> bool {\n     match tcx.map.find(node_id) {\n         Some(ast_map::NodeItem(..)) |\n         Some(ast_map::NodeImplItem(..)) |\n@@ -45,7 +46,7 @@ fn should_explore(tcx: &TyCtxt, node_id: ast::NodeId) -> bool {\n \n struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n     worklist: Vec<ast::NodeId>,\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     live_symbols: Box<HashSet<ast::NodeId>>,\n     struct_has_extern_repr: bool,\n     ignore_non_const_paths: bool,\n@@ -54,7 +55,7 @@ struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n-    fn new(tcx: &'a TyCtxt<'tcx>,\n+    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            worklist: Vec<ast::NodeId>) -> MarkSymbolVisitor<'a, 'tcx> {\n         MarkSymbolVisitor {\n             worklist: worklist,\n@@ -362,9 +363,10 @@ impl<'v> Visitor<'v> for LifeSeeder {\n     }\n }\n \n-fn create_and_seed_worklist(tcx: &TyCtxt,\n-                            access_levels: &privacy::AccessLevels,\n-                            krate: &hir::Crate) -> Vec<ast::NodeId> {\n+fn create_and_seed_worklist<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      access_levels: &privacy::AccessLevels,\n+                                      krate: &hir::Crate)\n+                                      -> Vec<ast::NodeId> {\n     let mut worklist = Vec::new();\n     for (id, _) in &access_levels.map {\n         worklist.push(*id);\n@@ -385,10 +387,10 @@ fn create_and_seed_worklist(tcx: &TyCtxt,\n     return life_seeder.worklist;\n }\n \n-fn find_live(tcx: &TyCtxt,\n-             access_levels: &privacy::AccessLevels,\n-             krate: &hir::Crate)\n-             -> Box<HashSet<ast::NodeId>> {\n+fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                       access_levels: &privacy::AccessLevels,\n+                       krate: &hir::Crate)\n+                       -> Box<HashSet<ast::NodeId>> {\n     let worklist = create_and_seed_worklist(tcx, access_levels, krate);\n     let mut symbol_visitor = MarkSymbolVisitor::new(tcx, worklist);\n     symbol_visitor.mark_live_symbols();\n@@ -405,7 +407,7 @@ fn get_struct_ctor_id(item: &hir::Item) -> Option<ast::NodeId> {\n }\n \n struct DeadVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     live_symbols: Box<HashSet<ast::NodeId>>,\n }\n \n@@ -504,7 +506,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n     /// an error. We could do this also by checking the parents, but\n     /// this is how the code is setup and it seems harmless enough.\n     fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        self.visit_item(self.tcx.map.expect_item(item.id))\n+        let tcx = self.tcx;\n+        self.visit_item(tcx.map.expect_item(item.id))\n     }\n \n     fn visit_item(&mut self, item: &hir::Item) {\n@@ -582,7 +585,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: &TyCtxt, access_levels: &privacy::AccessLevels) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             access_levels: &privacy::AccessLevels) {\n     let _task = tcx.dep_graph.in_task(DepNode::DeadCheck);\n     let krate = tcx.map.krate();\n     let live_symbols = find_live(tcx, access_levels, krate);"}, {"sha": "b62368c2a98781e33b2ad5d9dfef2fe887dfb299", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -51,7 +51,7 @@ fn type_is_unsafe_function(ty: Ty) -> bool {\n }\n \n struct EffectCheckVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     /// Whether we're in an unsafe context.\n     unsafe_context: UnsafeContext,\n@@ -183,7 +183,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: &TyCtxt) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _task = tcx.dep_graph.in_task(DepNode::EffectCheck);\n \n     let mut visitor = EffectCheckVisitor {"}, {"sha": "4cee8c5d89ae62e9f8b8a0f946e7a1e9d9c45a98", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 38, "deletions": 41, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -22,7 +22,7 @@ use self::OverloadedCallType::*;\n use hir::pat_util;\n use hir::def::Def;\n use hir::def_id::{DefId};\n-use infer;\n+use infer::InferCtxt;\n use middle::mem_categorization as mc;\n use ty::{self, TyCtxt, adjustment};\n \n@@ -209,8 +209,7 @@ enum OverloadedCallType {\n }\n \n impl OverloadedCallType {\n-    fn from_trait_id(tcx: &TyCtxt, trait_id: DefId)\n-                     -> OverloadedCallType {\n+    fn from_trait_id(tcx: TyCtxt, trait_id: DefId) -> OverloadedCallType {\n         for &(maybe_function_trait, overloaded_call_type) in &[\n             (tcx.lang_items.fn_once_trait(), FnOnceOverloadedCall),\n             (tcx.lang_items.fn_mut_trait(), FnMutOverloadedCall),\n@@ -227,8 +226,7 @@ impl OverloadedCallType {\n         bug!(\"overloaded call didn't map to known function trait\")\n     }\n \n-    fn from_method_id(tcx: &TyCtxt, method_id: DefId)\n-                      -> OverloadedCallType {\n+    fn from_method_id(tcx: TyCtxt, method_id: DefId) -> OverloadedCallType {\n         let method = tcx.impl_or_trait_item(method_id);\n         OverloadedCallType::from_trait_id(tcx, method.container().id())\n     }\n@@ -241,10 +239,9 @@ impl OverloadedCallType {\n // mem_categorization, it requires a TYPER, which is a type that\n // supplies types from the tree. After type checking is complete, you\n // can just use the tcx as the typer.\n-pub struct ExprUseVisitor<'d, 't, 'a: 't, 'tcx:'a+'d> {\n-    typer: &'t infer::InferCtxt<'a, 'tcx>,\n-    mc: mc::MemCategorizationContext<'t, 'a, 'tcx>,\n-    delegate: &'d mut Delegate<'tcx>,\n+pub struct ExprUseVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    mc: mc::MemCategorizationContext<'a, 'gcx, 'tcx>,\n+    delegate: &'a mut Delegate<'tcx>,\n }\n \n // If the TYPER results in an error, it's because the type check\n@@ -272,14 +269,14 @@ enum PassArgs {\n     ByRef,\n }\n \n-impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n-    pub fn new(delegate: &'d mut (Delegate<'tcx>+'d),\n-               typer: &'t infer::InferCtxt<'a, 'tcx>)\n-               -> ExprUseVisitor<'d,'t,'a,'tcx> where 'tcx:'a+'d\n+impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n+    pub fn new(delegate: &'a mut (Delegate<'tcx>+'a),\n+               infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self\n     {\n-        let mc: mc::MemCategorizationContext<'t, 'a, 'tcx> =\n-            mc::MemCategorizationContext::new(typer);\n-        ExprUseVisitor { typer: typer, mc: mc, delegate: delegate }\n+        ExprUseVisitor {\n+            mc: mc::MemCategorizationContext::new(infcx),\n+            delegate: delegate\n+        }\n     }\n \n     pub fn walk_fn(&mut self,\n@@ -293,7 +290,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                          decl: &hir::FnDecl,\n                          body: &hir::Block) {\n         for arg in &decl.inputs {\n-            let arg_ty = return_if_err!(self.typer.node_ty(arg.pat.id));\n+            let arg_ty = return_if_err!(self.mc.infcx.node_ty(arg.pat.id));\n \n             let fn_body_scope = self.tcx().region_maps.node_extent(body.id);\n             let arg_cmt = self.mc.cat_rvalue(\n@@ -306,8 +303,8 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         }\n     }\n \n-    fn tcx(&self) -> &'t TyCtxt<'tcx> {\n-        self.typer.tcx\n+    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+        self.mc.infcx.tcx\n     }\n \n     fn delegate_consume(&mut self,\n@@ -317,7 +314,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         debug!(\"delegate_consume(consume_id={}, cmt={:?})\",\n                consume_id, cmt);\n \n-        let mode = copy_or_move(self.typer, &cmt, DirectRefMove);\n+        let mode = copy_or_move(self.mc.infcx, &cmt, DirectRefMove);\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n \n@@ -442,7 +439,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             hir::ExprAddrOf(m, ref base) => {   // &base\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n-                let expr_ty = return_if_err!(self.typer.node_ty(expr.id));\n+                let expr_ty = return_if_err!(self.mc.infcx.node_ty(expr.id));\n                 if let ty::TyRef(&r, _) = expr_ty.sty {\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.borrow_expr(&base, r, bk, AddrOf);\n@@ -548,7 +545,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n     }\n \n     fn walk_callee(&mut self, call: &hir::Expr, callee: &hir::Expr) {\n-        let callee_ty = return_if_err!(self.typer.expr_ty_adjusted(callee));\n+        let callee_ty = return_if_err!(self.mc.infcx.expr_ty_adjusted(callee));\n         debug!(\"walk_callee: callee={:?} callee_ty={:?}\",\n                callee, callee_ty);\n         let call_scope = self.tcx().region_maps.node_extent(call.id);\n@@ -559,7 +556,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             ty::TyError => { }\n             _ => {\n                 let overloaded_call_type =\n-                    match self.typer.node_method_id(ty::MethodCall::expr(call.id)) {\n+                    match self.mc.infcx.node_method_id(ty::MethodCall::expr(call.id)) {\n                         Some(method_id) => {\n                             OverloadedCallType::from_method_id(self.tcx(), method_id)\n                         }\n@@ -615,7 +612,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         match local.init {\n             None => {\n                 let delegate = &mut self.delegate;\n-                pat_util::pat_bindings(&self.typer.tcx.def_map, &local.pat,\n+                pat_util::pat_bindings(&self.mc.infcx.tcx.def_map, &local.pat,\n                                        |_, id, span, _| {\n                     delegate.decl_without_init(id, span);\n                 })\n@@ -707,9 +704,9 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n     // consumed or borrowed as part of the automatic adjustment\n     // process.\n     fn walk_adjustment(&mut self, expr: &hir::Expr) {\n-        let typer = self.typer;\n+        let infcx = self.mc.infcx;\n         //NOTE(@jroesch): mixed RefCell borrow causes crash\n-        let adj = typer.adjustments().get(&expr.id).map(|x| x.clone());\n+        let adj = infcx.adjustments().get(&expr.id).map(|x| x.clone());\n         if let Some(adjustment) = adj {\n             match adjustment {\n                 adjustment::AdjustReifyFnPointer |\n@@ -739,7 +736,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n \n         for i in 0..autoderefs {\n             let deref_id = ty::MethodCall::autoderef(expr.id, i as u32);\n-            match self.typer.node_method_ty(deref_id) {\n+            match self.mc.infcx.node_method_ty(deref_id) {\n                 None => {}\n                 Some(method_ty) => {\n                     let cmt = return_if_err!(self.mc.cat_expr_autoderefd(expr, i));\n@@ -865,7 +862,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                                 pass_args: PassArgs)\n                                 -> bool\n     {\n-        if !self.typer.is_method_call(expr.id) {\n+        if !self.mc.infcx.is_method_call(expr.id) {\n             return false;\n         }\n \n@@ -941,7 +938,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                     PatKind::Ident(hir::BindByRef(_), _, _) =>\n                         mode.lub(BorrowingMatch),\n                     PatKind::Ident(hir::BindByValue(_), _, _) => {\n-                        match copy_or_move(self.typer, &cmt_pat, PatBindingMove) {\n+                        match copy_or_move(self.mc.infcx, &cmt_pat, PatBindingMove) {\n                             Copy => mode.lub(CopyingMatch),\n                             Move(_) => mode.lub(MovingMatch),\n                         }\n@@ -967,7 +964,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                pat);\n \n         let mc = &self.mc;\n-        let typer = self.typer;\n+        let infcx = self.mc.infcx;\n         let def_map = &self.tcx().def_map;\n         let delegate = &mut self.delegate;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n@@ -978,7 +975,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                        match_mode);\n \n                 // pat_ty: the type of the binding being produced.\n-                let pat_ty = return_if_err!(typer.node_ty(pat.id));\n+                let pat_ty = return_if_err!(infcx.node_ty(pat.id));\n \n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n@@ -1000,7 +997,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                         }\n                     }\n                     PatKind::Ident(hir::BindByValue(_), _, _) => {\n-                        let mode = copy_or_move(typer, &cmt_pat, PatBindingMove);\n+                        let mode = copy_or_move(infcx, &cmt_pat, PatBindingMove);\n                         debug!(\"walk_pat binding consuming pat\");\n                         delegate.consume_pat(pat, cmt_pat, mode);\n                     }\n@@ -1057,7 +1054,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         // the leaves of the pattern tree structure.\n         return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n             let def_map = def_map.borrow();\n-            let tcx = typer.tcx;\n+            let tcx = infcx.tcx;\n \n             match pat.node {\n                 PatKind::TupleStruct(..) | PatKind::Path(..) | PatKind::QPath(..) |\n@@ -1150,13 +1147,13 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                 let id_var = freevar.def.var_id();\n                 let upvar_id = ty::UpvarId { var_id: id_var,\n                                              closure_expr_id: closure_expr.id };\n-                let upvar_capture = self.typer.upvar_capture(upvar_id).unwrap();\n+                let upvar_capture = self.mc.infcx.upvar_capture(upvar_id).unwrap();\n                 let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n                                                                    fn_decl_span,\n                                                                    freevar.def));\n                 match upvar_capture {\n                     ty::UpvarCapture::ByValue => {\n-                        let mode = copy_or_move(self.typer, &cmt_var, CaptureMove);\n+                        let mode = copy_or_move(self.mc.infcx, &cmt_var, CaptureMove);\n                         self.delegate.consume(closure_expr.id, freevar.span, cmt_var, mode);\n                     }\n                     ty::UpvarCapture::ByRef(upvar_borrow) => {\n@@ -1180,17 +1177,17 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n         let var_id = upvar_def.var_id();\n-        let var_ty = self.typer.node_ty(var_id)?;\n+        let var_ty = self.mc.infcx.node_ty(var_id)?;\n         self.mc.cat_def(closure_id, closure_span, var_ty, upvar_def)\n     }\n }\n \n-fn copy_or_move<'a, 'tcx>(typer: &infer::InferCtxt<'a, 'tcx>,\n-                      cmt: &mc::cmt<'tcx>,\n-                      move_reason: MoveReason)\n-                      -> ConsumeMode\n+fn copy_or_move<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                cmt: &mc::cmt<'tcx>,\n+                                move_reason: MoveReason)\n+                                -> ConsumeMode\n {\n-    if typer.type_moves_by_default(cmt.ty, cmt.span) {\n+    if infcx.type_moves_by_default(cmt.ty, cmt.span) {\n         Move(move_reason)\n     } else {\n         Copy"}, {"sha": "e4ce89767139a23157a2f29543d288f4ae0dd724", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -48,9 +48,8 @@ impl FreeRegionMap {\n         }\n     }\n \n-    pub fn relate_free_regions_from_predicates<'tcx>(&mut self,\n-                                                     _tcx: &TyCtxt<'tcx>,\n-                                                     predicates: &[ty::Predicate<'tcx>]) {\n+    pub fn relate_free_regions_from_predicates(&mut self,\n+                                               predicates: &[ty::Predicate]) {\n         debug!(\"relate_free_regions_from_predicates(predicates={:?})\", predicates);\n         for predicate in predicates {\n             match *predicate {\n@@ -122,7 +121,7 @@ impl FreeRegionMap {\n     /// Determines whether one region is a subregion of another.  This is intended to run *after\n     /// inference* and sadly the logic is somewhat duplicated with the code in infer.rs.\n     pub fn is_subregion_of(&self,\n-                           tcx: &TyCtxt,\n+                           tcx: TyCtxt,\n                            sub_region: ty::Region,\n                            super_region: ty::Region)\n                            -> bool {"}, {"sha": "07e69d85ff41bb811f451d7f96d69bbea1206767", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 30, "deletions": 36, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -11,7 +11,7 @@\n use dep_graph::DepNode;\n use hir::def::Def;\n use hir::def_id::DefId;\n-use infer::{InferCtxt, new_infer_ctxt};\n+use infer::InferCtxt;\n use traits::ProjectionMode;\n use ty::{self, Ty, TyCtxt};\n use ty::layout::{LayoutError, Pointer, SizeSkeleton};\n@@ -22,35 +22,34 @@ use syntax::codemap::Span;\n use hir::intravisit::{self, Visitor, FnKind};\n use hir;\n \n-pub fn check_crate(tcx: &TyCtxt) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut visitor = ItemVisitor {\n         tcx: tcx\n     };\n     tcx.visit_all_items_in_krate(DepNode::IntrinsicCheck, &mut visitor);\n }\n \n struct ItemVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>\n }\n \n impl<'a, 'tcx> ItemVisitor<'a, 'tcx> {\n     fn visit_const(&mut self, item_id: ast::NodeId, expr: &hir::Expr) {\n         let param_env = ty::ParameterEnvironment::for_item(self.tcx, item_id);\n-        let infcx = new_infer_ctxt(self.tcx, &self.tcx.tables,\n-                                   Some(param_env),\n-                                   ProjectionMode::Any);\n-        let mut visitor = ExprVisitor {\n-            infcx: &infcx\n-        };\n-        visitor.visit_expr(expr);\n+        self.tcx.infer_ctxt(None, Some(param_env), ProjectionMode::Any).enter(|infcx| {\n+            let mut visitor = ExprVisitor {\n+                infcx: &infcx\n+            };\n+            visitor.visit_expr(expr);\n+        });\n     }\n }\n \n-struct ExprVisitor<'a, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'tcx>\n+struct ExprVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>\n }\n \n-impl<'a, 'tcx> ExprVisitor<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n         let intrinsic = match self.infcx.tcx.lookup_item_type(def_id).ty.sty {\n             ty::TyFnDef(_, _, ref bfty) => bfty.abi == RustIntrinsic,\n@@ -59,7 +58,7 @@ impl<'a, 'tcx> ExprVisitor<'a, 'tcx> {\n         intrinsic && self.infcx.tcx.item_name(def_id).as_str() == \"transmute\"\n     }\n \n-    fn check_transmute(&self, span: Span, from: Ty<'tcx>, to: Ty<'tcx>, id: ast::NodeId) {\n+    fn check_transmute(&self, span: Span, from: Ty<'gcx>, to: Ty<'gcx>, id: ast::NodeId) {\n         let sk_from = SizeSkeleton::compute(from, self.infcx);\n         let sk_to = SizeSkeleton::compute(to, self.infcx);\n \n@@ -85,7 +84,7 @@ impl<'a, 'tcx> ExprVisitor<'a, 'tcx> {\n         }\n \n         // Try to display a sensible error with as much information as possible.\n-        let skeleton_string = |ty: Ty<'tcx>, sk| {\n+        let skeleton_string = |ty: Ty<'gcx>, sk| {\n             match sk {\n                 Ok(SizeSkeleton::Known(size)) => {\n                     format!(\"{} bits\", size.bits())\n@@ -115,12 +114,12 @@ impl<'a, 'tcx> ExprVisitor<'a, 'tcx> {\n impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n     // const, static and N in [T; N].\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n-        let infcx = new_infer_ctxt(self.tcx, &self.tcx.tables,\n-                                   None, ProjectionMode::Any);\n-        let mut visitor = ExprVisitor {\n-            infcx: &infcx\n-        };\n-        visitor.visit_expr(expr);\n+        self.tcx.infer_ctxt(None, None, ProjectionMode::Any).enter(|infcx| {\n+            let mut visitor = ExprVisitor {\n+                infcx: &infcx\n+            };\n+            visitor.visit_expr(expr);\n+        });\n     }\n \n     fn visit_trait_item(&mut self, item: &hir::TraitItem) {\n@@ -141,25 +140,20 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n \n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n                 b: &'v hir::Block, s: Span, id: ast::NodeId) {\n-        match fk {\n-            FnKind::ItemFn(..) | FnKind::Method(..) => {\n-                let param_env = ty::ParameterEnvironment::for_item(self.tcx, id);\n-                let infcx = new_infer_ctxt(self.tcx, &self.tcx.tables,\n-                                           Some(param_env),\n-                                           ProjectionMode::Any);\n-                let mut visitor = ExprVisitor {\n-                    infcx: &infcx\n-                };\n-                visitor.visit_fn(fk, fd, b, s, id);\n-            }\n-            FnKind::Closure(..) => {\n-                span_bug!(s, \"intrinsicck: closure outside of function\")\n-            }\n+        if let FnKind::Closure(..) = fk {\n+            span_bug!(s, \"intrinsicck: closure outside of function\")\n         }\n+        let param_env = ty::ParameterEnvironment::for_item(self.tcx, id);\n+        self.tcx.infer_ctxt(None, Some(param_env), ProjectionMode::Any).enter(|infcx| {\n+            let mut visitor = ExprVisitor {\n+                infcx: &infcx\n+            };\n+            visitor.visit_fn(fk, fd, b, s, id);\n+        });\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for ExprVisitor<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for ExprVisitor<'a, 'gcx, 'tcx> {\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         if let hir::ExprPath(..) = expr.node {\n             match self.infcx.tcx.resolve_expr(expr) {"}, {"sha": "473fd7d9be65473f7fdf02bd422ce99fedc847d0", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -114,7 +114,6 @@ use hir::def::*;\n use hir::pat_util;\n use ty::{self, TyCtxt, ParameterEnvironment};\n use traits::{self, ProjectionMode};\n-use infer;\n use ty::subst::Subst;\n use lint;\n use util::nodemap::NodeMap;\n@@ -169,8 +168,8 @@ enum LiveNodeKind {\n     ExitNode\n }\n \n-fn live_node_kind_to_string(lnk: LiveNodeKind, cx: &TyCtxt) -> String {\n-    let cm = cx.sess.codemap();\n+fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt) -> String {\n+    let cm = tcx.sess.codemap();\n     match lnk {\n         FreeVarNode(s) => {\n             format!(\"Free var node [{}]\", cm.span_to_string(s))\n@@ -195,7 +194,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IrMaps<'a, 'tcx> {\n     fn visit_arm(&mut self, a: &hir::Arm) { visit_arm(self, a); }\n }\n \n-pub fn check_crate(tcx: &TyCtxt) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _task = tcx.dep_graph.in_task(DepNode::Liveness);\n     tcx.map.krate().visit_all_items(&mut IrMaps::new(tcx));\n     tcx.sess.abort_if_errors();\n@@ -263,7 +262,7 @@ enum VarKind {\n }\n \n struct IrMaps<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     num_live_nodes: usize,\n     num_vars: usize,\n@@ -275,7 +274,7 @@ struct IrMaps<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n-    fn new(tcx: &'a TyCtxt<'tcx>) -> IrMaps<'a, 'tcx> {\n+    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> IrMaps<'a, 'tcx> {\n         IrMaps {\n             tcx: tcx,\n             num_live_nodes: 0,\n@@ -1462,7 +1461,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn fn_ret(&self, id: NodeId) -> ty::PolyFnOutput<'tcx> {\n         let fn_ty = self.ir.tcx.node_id_to_type(id);\n         match fn_ty.sty {\n-            ty::TyClosure(closure_def_id, ref substs) =>\n+            ty::TyClosure(closure_def_id, substs) =>\n                 self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n             _ => fn_ty.fn_ret()\n         }\n@@ -1486,20 +1485,16 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             ty::FnConverging(t_ret)\n                     if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() => {\n \n-                let param_env = ParameterEnvironment::for_item(&self.ir.tcx, id);\n-                let t_ret_subst = t_ret.subst(&self.ir.tcx, &param_env.free_substs);\n-                let infcx = infer::new_infer_ctxt(&self.ir.tcx,\n-                                                  &self.ir.tcx.tables,\n-                                                  Some(param_env),\n-                                                  ProjectionMode::Any);\n-                let cause = traits::ObligationCause::dummy();\n-                let norm = traits::fully_normalize(&infcx,\n-                                                   cause,\n-                                                   &t_ret_subst);\n-\n-                if norm.unwrap().is_nil() {\n-                    // for nil return types, it is ok to not return a value expl.\n-                } else {\n+                let param_env = ParameterEnvironment::for_item(self.ir.tcx, id);\n+                let t_ret_subst = t_ret.subst(self.ir.tcx, &param_env.free_substs);\n+                let is_nil = self.ir.tcx.infer_ctxt(None, Some(param_env),\n+                                                    ProjectionMode::Any).enter(|infcx| {\n+                    let cause = traits::ObligationCause::dummy();\n+                    traits::fully_normalize(&infcx, cause, &t_ret_subst).unwrap().is_nil()\n+                });\n+\n+                // for nil return types, it is ok to not return a value expl.\n+                if !is_nil {\n                     let ends_with_stmt = match body.expr {\n                         None if !body.stmts.is_empty() =>\n                             match body.stmts.last().unwrap().node {"}, {"sha": "3999b02425de6737d6e84ef9d2d653b0001fefe6", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 31, "deletions": 35, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -73,7 +73,7 @@ use self::Aliasability::*;\n \n use hir::def_id::DefId;\n use hir::map as ast_map;\n-use infer;\n+use infer::InferCtxt;\n use middle::const_qualif::ConstQualif;\n use hir::def::Def;\n use ty::adjustment;\n@@ -256,8 +256,8 @@ impl ast_node for hir::Pat {\n }\n \n #[derive(Copy, Clone)]\n-pub struct MemCategorizationContext<'t, 'a: 't, 'tcx : 'a> {\n-    pub typer: &'t infer::InferCtxt<'a, 'tcx>,\n+pub struct MemCategorizationContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    pub infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n pub type McResult<T> = Result<T, ()>;\n@@ -302,7 +302,7 @@ impl MutabilityCategory {\n         ret\n     }\n \n-    fn from_local(tcx: &TyCtxt, id: ast::NodeId) -> MutabilityCategory {\n+    fn from_local(tcx: TyCtxt, id: ast::NodeId) -> MutabilityCategory {\n         let ret = match tcx.map.get(id) {\n             ast_map::NodeLocal(p) => match p.node {\n                 PatKind::Ident(bind_mode, _, _) => {\n@@ -358,17 +358,18 @@ impl MutabilityCategory {\n     }\n }\n \n-impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n-    pub fn new(typer: &'t infer::InferCtxt<'a, 'tcx>) -> MemCategorizationContext<'t, 'a, 'tcx> {\n-        MemCategorizationContext { typer: typer }\n+impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>)\n+               -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n+        MemCategorizationContext { infcx: infcx }\n     }\n \n-    fn tcx(&self) -> &'a TyCtxt<'tcx> {\n-        self.typer.tcx\n+    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+        self.infcx.tcx\n     }\n \n     fn expr_ty(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        match self.typer.node_ty(expr.id) {\n+        match self.infcx.node_ty(expr.id) {\n             Ok(t) => Ok(t),\n             Err(()) => {\n                 debug!(\"expr_ty({:?}) yielded Err\", expr);\n@@ -381,16 +382,16 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         let unadjusted_ty = self.expr_ty(expr)?;\n         Ok(unadjusted_ty.adjust(\n             self.tcx(), expr.span, expr.id,\n-            self.typer.adjustments().get(&expr.id),\n-            |method_call| self.typer.node_method_ty(method_call)))\n+            self.infcx.adjustments().get(&expr.id),\n+            |method_call| self.infcx.node_method_ty(method_call)))\n     }\n \n     fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n-        self.typer.node_ty(id)\n+        self.infcx.node_ty(id)\n     }\n \n     fn pat_ty(&self, pat: &hir::Pat) -> McResult<Ty<'tcx>> {\n-        let base_ty = self.typer.node_ty(pat.id)?;\n+        let base_ty = self.infcx.node_ty(pat.id)?;\n         // FIXME (Issue #18207): This code detects whether we are\n         // looking at a `ref x`, and if so, figures out what the type\n         // *being borrowed* is.  But ideally we would put in a more\n@@ -413,7 +414,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n     }\n \n     pub fn cat_expr(&self, expr: &hir::Expr) -> McResult<cmt<'tcx>> {\n-        match self.typer.adjustments().get(&expr.id) {\n+        match self.infcx.adjustments().get(&expr.id) {\n             None => {\n                 // No adjustments.\n                 self.cat_expr_unadjusted(expr)\n@@ -485,7 +486,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n           hir::ExprIndex(ref base, _) => {\n             let method_call = ty::MethodCall::expr(expr.id());\n             let context = InteriorOffsetKind::Index;\n-            match self.typer.node_method_ty(method_call) {\n+            match self.infcx.node_method_ty(method_call) {\n                 Some(method_ty) => {\n                     // If this is an index implemented by a method call, then it\n                     // will include an implicit deref of the result.\n@@ -578,7 +579,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n               let ty = self.node_ty(fn_node_id)?;\n               match ty.sty {\n                   ty::TyClosure(closure_id, _) => {\n-                      match self.typer.closure_kind(closure_id) {\n+                      match self.infcx.closure_kind(closure_id) {\n                           Some(kind) => {\n                               self.cat_upvar(id, span, var_id, fn_node_id, kind)\n                           }\n@@ -687,7 +688,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         // for that.\n         let upvar_id = ty::UpvarId { var_id: var_id,\n                                      closure_expr_id: fn_node_id };\n-        let upvar_capture = self.typer.upvar_capture(upvar_id).unwrap();\n+        let upvar_capture = self.infcx.upvar_capture(upvar_id).unwrap();\n         let cmt_result = match upvar_capture {\n             ty::UpvarCapture::ByValue => {\n                 cmt_result\n@@ -785,7 +786,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n     /// Returns the lifetime of a temporary created by expr with id `id`.\n     /// This could be `'static` if `id` is part of a constant expression.\n     pub fn temporary_scope(&self, id: ast::NodeId) -> ty::Region {\n-        match self.typer.temporary_scope(id) {\n+        match self.infcx.temporary_scope(id) {\n             Some(scope) => ty::ReScope(scope),\n             None => ty::ReStatic\n         }\n@@ -882,7 +883,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             expr_id: node.id(),\n             autoderef: deref_cnt as u32\n         };\n-        let method_ty = self.typer.node_method_ty(method_call);\n+        let method_ty = self.infcx.node_method_ty(method_call);\n \n         debug!(\"cat_deref: method_call={:?} method_ty={:?}\",\n                method_call, method_ty.map(|ty| ty));\n@@ -977,7 +978,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         //! - `base_cmt`: the cmt of `elt`\n \n         let method_call = ty::MethodCall::expr(elt.id());\n-        let method_ty = self.typer.node_method_ty(method_call);\n+        let method_ty = self.infcx.node_method_ty(method_call);\n \n         let element_ty = match method_ty {\n             Some(method_ty) => {\n@@ -1071,9 +1072,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                              slice_pat: &hir::Pat)\n                              -> McResult<(cmt<'tcx>, hir::Mutability, ty::Region)> {\n         let slice_ty = self.node_ty(slice_pat.id)?;\n-        let (slice_mutbl, slice_r) = vec_slice_info(self.tcx(),\n-                                                    slice_pat,\n-                                                    slice_ty);\n+        let (slice_mutbl, slice_r) = vec_slice_info(slice_pat, slice_ty);\n         let context = InteriorOffsetKind::Pattern;\n         let cmt_vec = self.deref_vec(slice_pat, vec_cmt, context)?;\n         let cmt_slice = self.cat_index(slice_pat, cmt_vec, context)?;\n@@ -1082,14 +1081,12 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         /// In a pattern like [a, b, ..c], normally `c` has slice type, but if you have [a, b,\n         /// ..ref c], then the type of `ref c` will be `&&[]`, so to extract the slice details we\n         /// have to recurse through rptrs.\n-        fn vec_slice_info(tcx: &TyCtxt,\n-                          pat: &hir::Pat,\n-                          slice_ty: Ty)\n+        fn vec_slice_info(pat: &hir::Pat, slice_ty: Ty)\n                           -> (hir::Mutability, ty::Region) {\n             match slice_ty.sty {\n                 ty::TyRef(r, ref mt) => match mt.ty.sty {\n                     ty::TySlice(_) => (mt.mutbl, *r),\n-                    _ => vec_slice_info(tcx, pat, mt.ty),\n+                    _ => vec_slice_info(pat, mt.ty),\n                 },\n \n                 _ => {\n@@ -1137,15 +1134,15 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n     }\n \n     pub fn cat_pattern<F>(&self, cmt: cmt<'tcx>, pat: &hir::Pat, mut op: F) -> McResult<()>\n-        where F: FnMut(&MemCategorizationContext<'t, 'a, 'tcx>, cmt<'tcx>, &hir::Pat),\n+        where F: FnMut(&MemCategorizationContext<'a, 'gcx, 'tcx>, cmt<'tcx>, &hir::Pat),\n     {\n         self.cat_pattern_(cmt, pat, &mut op)\n     }\n \n     // FIXME(#19596) This is a workaround, but there should be a better way to do this\n     fn cat_pattern_<F>(&self, cmt: cmt<'tcx>, pat: &hir::Pat, op: &mut F)\n                        -> McResult<()>\n-        where F : FnMut(&MemCategorizationContext<'t, 'a, 'tcx>, cmt<'tcx>, &hir::Pat),\n+        where F : FnMut(&MemCategorizationContext<'a, 'gcx, 'tcx>, cmt<'tcx>, &hir::Pat),\n     {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n@@ -1389,8 +1386,7 @@ impl<'tcx> cmt_<'tcx> {\n     }\n \n     /// Returns `FreelyAliasable(_)` if this lvalue represents a freely aliasable pointer type.\n-    pub fn freely_aliasable(&self, ctxt: &TyCtxt<'tcx>)\n-                            -> Aliasability {\n+    pub fn freely_aliasable(&self) -> Aliasability {\n         // Maybe non-obvious: copied upvars can only be considered\n         // non-aliasable in once closures, since any other kind can be\n         // aliased and eventually recused.\n@@ -1403,11 +1399,11 @@ impl<'tcx> cmt_<'tcx> {\n             Categorization::Downcast(ref b, _) |\n             Categorization::Interior(ref b, _) => {\n                 // Aliasability depends on base cmt\n-                b.freely_aliasable(ctxt)\n+                b.freely_aliasable()\n             }\n \n             Categorization::Deref(ref b, _, Unique) => {\n-                let sub = b.freely_aliasable(ctxt);\n+                let sub = b.freely_aliasable();\n                 if b.mutbl.is_mutable() {\n                     // Aliasability depends on base cmt alone\n                     sub\n@@ -1464,7 +1460,7 @@ impl<'tcx> cmt_<'tcx> {\n     }\n \n \n-    pub fn descriptive_string(&self, tcx: &TyCtxt) -> String {\n+    pub fn descriptive_string(&self, tcx: TyCtxt) -> String {\n         match self.cat {\n             Categorization::StaticItem => {\n                 \"static item\".to_string()"}, {"sha": "bca5af69edfd033e9db4f93905ada8f123aa6731", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -55,9 +55,10 @@ fn item_might_be_inlined(item: &hir::Item) -> bool {\n     }\n }\n \n-fn method_might_be_inlined(tcx: &TyCtxt, sig: &hir::MethodSig,\n-                           impl_item: &hir::ImplItem,\n-                           impl_src: DefId) -> bool {\n+fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     sig: &hir::MethodSig,\n+                                     impl_item: &hir::ImplItem,\n+                                     impl_src: DefId) -> bool {\n     if attr::requests_inline(&impl_item.attrs) ||\n         generics_require_inlining(&sig.generics) {\n         return true\n@@ -77,7 +78,7 @@ fn method_might_be_inlined(tcx: &TyCtxt, sig: &hir::MethodSig,\n // Information needed while computing reachability.\n struct ReachableContext<'a, 'tcx: 'a> {\n     // The type context.\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // The set of items which must be exported in the linkage sense.\n     reachable_symbols: NodeSet,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n@@ -142,7 +143,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n \n impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     // Creates a new reachability computation context.\n-    fn new(tcx: &'a TyCtxt<'tcx>) -> ReachableContext<'a, 'tcx> {\n+    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ReachableContext<'a, 'tcx> {\n         let any_library = tcx.sess.crate_types.borrow().iter().any(|ty| {\n             *ty != config::CrateTypeExecutable\n         });\n@@ -344,9 +345,9 @@ impl<'a, 'v> Visitor<'v> for CollectPrivateImplItemsVisitor<'a> {\n     }\n }\n \n-pub fn find_reachable(tcx: &TyCtxt,\n-                      access_levels: &privacy::AccessLevels)\n-                      -> NodeSet {\n+pub fn find_reachable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                access_levels: &privacy::AccessLevels)\n+                                -> NodeSet {\n     let _task = tcx.dep_graph.in_task(DepNode::Reachability);\n \n     let mut reachable_context = ReachableContext::new(tcx);"}, {"sha": "c2db6de03700e254c0a93d35b5093e3509030e2f", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 75, "deletions": 55, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -72,7 +72,7 @@ pub struct Index<'tcx> {\n \n // A private tree-walker for producing an Index.\n struct Annotator<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     index: &'a mut Index<'tcx>,\n     parent_stab: Option<&'tcx Stability>,\n     parent_depr: Option<Deprecation>,\n@@ -203,7 +203,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n     /// nested items in the context of the outer item, so enable\n     /// deep-walking.\n     fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        self.visit_item(self.tcx.map.expect_item(item.id))\n+        let tcx = self.tcx;\n+        self.visit_item(tcx.map.expect_item(item.id))\n     }\n \n     fn visit_item(&mut self, i: &Item) {\n@@ -277,9 +278,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n     }\n }\n \n-impl<'tcx> Index<'tcx> {\n+impl<'a, 'tcx> Index<'tcx> {\n     /// Construct the stability index for a crate being compiled.\n-    pub fn build(&mut self, tcx: &TyCtxt<'tcx>, access_levels: &AccessLevels) {\n+    pub fn build(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, access_levels: &AccessLevels) {\n         let _task = tcx.dep_graph.in_task(DepNode::StabilityIndex);\n         let krate = tcx.map.krate();\n         let mut annotator = Annotator {\n@@ -319,8 +320,8 @@ impl<'tcx> Index<'tcx> {\n /// Cross-references the feature names of unstable APIs with enabled\n /// features and possibly prints errors. Returns a list of all\n /// features used.\n-pub fn check_unstable_api_usage(tcx: &TyCtxt)\n-                                -> FnvHashMap<InternedString, StabilityLevel> {\n+pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                          -> FnvHashMap<InternedString, StabilityLevel> {\n     let _task = tcx.dep_graph.in_task(DepNode::StabilityCheck);\n     let ref active_lib_features = tcx.sess.features.borrow().declared_lib_features;\n \n@@ -339,7 +340,7 @@ pub fn check_unstable_api_usage(tcx: &TyCtxt)\n }\n \n struct Checker<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     active_features: FnvHashSet<InternedString>,\n     used_features: FnvHashMap<InternedString, StabilityLevel>,\n     // Within a block where feature gate checking can be skipped.\n@@ -411,7 +412,8 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n     /// nested items in the context of the outer item, so enable\n     /// deep-walking.\n     fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        self.visit_item(self.tcx.map.expect_item(item.id))\n+        let tcx = self.tcx;\n+        self.visit_item(tcx.map.expect_item(item.id))\n     }\n \n     fn visit_item(&mut self, item: &hir::Item) {\n@@ -466,8 +468,12 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n }\n \n /// Helper for discovering nodes to check for stability\n-pub fn check_item(tcx: &TyCtxt, item: &hir::Item, warn_about_defns: bool,\n-                  cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n+pub fn check_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            item: &hir::Item,\n+                            warn_about_defns: bool,\n+                            cb: &mut FnMut(DefId, Span,\n+                                           &Option<&Stability>,\n+                                           &Option<Deprecation>)) {\n     match item.node {\n         hir::ItemExternCrate(_) => {\n             // compiler-generated `extern crate` items have a dummy span.\n@@ -503,8 +509,10 @@ pub fn check_item(tcx: &TyCtxt, item: &hir::Item, warn_about_defns: bool,\n }\n \n /// Helper for discovering nodes to check for stability\n-pub fn check_expr(tcx: &TyCtxt, e: &hir::Expr,\n-                  cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n+pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n+                            cb: &mut FnMut(DefId, Span,\n+                                           &Option<&Stability>,\n+                                           &Option<Deprecation>)) {\n     let span;\n     let id = match e.node {\n         hir::ExprMethodCall(i, _, _) => {\n@@ -564,8 +572,11 @@ pub fn check_expr(tcx: &TyCtxt, e: &hir::Expr,\n     maybe_do_stability_check(tcx, id, span, cb);\n }\n \n-pub fn check_path(tcx: &TyCtxt, path: &hir::Path, id: ast::NodeId,\n-                  cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n+pub fn check_path<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            path: &hir::Path, id: ast::NodeId,\n+                            cb: &mut FnMut(DefId, Span,\n+                                           &Option<&Stability>,\n+                                           &Option<Deprecation>)) {\n     match tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n         Some(Def::PrimTy(..)) => {}\n         Some(Def::SelfTy(..)) => {}\n@@ -576,8 +587,11 @@ pub fn check_path(tcx: &TyCtxt, path: &hir::Path, id: ast::NodeId,\n     }\n }\n \n-pub fn check_path_list_item(tcx: &TyCtxt, item: &hir::PathListItem,\n-                  cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n+pub fn check_path_list_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      item: &hir::PathListItem,\n+                                      cb: &mut FnMut(DefId, Span,\n+                                                     &Option<&Stability>,\n+                                                     &Option<Deprecation>)) {\n     match tcx.def_map.borrow().get(&item.node.id()).map(|d| d.full_def()) {\n         Some(Def::PrimTy(..)) => {}\n         Some(def) => {\n@@ -587,8 +601,10 @@ pub fn check_path_list_item(tcx: &TyCtxt, item: &hir::PathListItem,\n     }\n }\n \n-pub fn check_pat(tcx: &TyCtxt, pat: &hir::Pat,\n-                 cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n+pub fn check_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &hir::Pat,\n+                           cb: &mut FnMut(DefId, Span,\n+                                          &Option<&Stability>,\n+                                          &Option<Deprecation>)) {\n     debug!(\"check_pat(pat = {:?})\", pat);\n     if is_internal(tcx, pat.span) { return; }\n \n@@ -616,29 +632,31 @@ pub fn check_pat(tcx: &TyCtxt, pat: &hir::Pat,\n     }\n }\n \n-fn maybe_do_stability_check(tcx: &TyCtxt, id: DefId, span: Span,\n-                            cb: &mut FnMut(DefId, Span,\n-                                           &Option<&Stability>, &Option<Deprecation>)) {\n+fn maybe_do_stability_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      id: DefId, span: Span,\n+                                      cb: &mut FnMut(DefId, Span,\n+                                                     &Option<&Stability>,\n+                                                     &Option<Deprecation>)) {\n     if is_internal(tcx, span) {\n         debug!(\"maybe_do_stability_check: \\\n                 skipping span={:?} since it is internal\", span);\n         return;\n     }\n     let (stability, deprecation) = if is_staged_api(tcx, id) {\n-        (lookup_stability(tcx, id), None)\n+        (tcx.lookup_stability(id), None)\n     } else {\n-        (None, lookup_deprecation(tcx, id))\n+        (None, tcx.lookup_deprecation(id))\n     };\n     debug!(\"maybe_do_stability_check: \\\n             inspecting id={:?} span={:?} of stability={:?}\", id, span, stability);\n     cb(id, span, &stability, &deprecation);\n }\n \n-fn is_internal(tcx: &TyCtxt, span: Span) -> bool {\n+fn is_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span) -> bool {\n     tcx.sess.codemap().span_allows_unstable(span)\n }\n \n-fn is_staged_api(tcx: &TyCtxt, id: DefId) -> bool {\n+fn is_staged_api<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> bool {\n     match tcx.trait_item_of_item(id) {\n         Some(ty::MethodTraitItemId(trait_method_id))\n             if trait_method_id != id => {\n@@ -651,43 +669,45 @@ fn is_staged_api(tcx: &TyCtxt, id: DefId) -> bool {\n     }\n }\n \n-/// Lookup the stability for a node, loading external crate\n-/// metadata as necessary.\n-pub fn lookup_stability<'tcx>(tcx: &TyCtxt<'tcx>, id: DefId) -> Option<&'tcx Stability> {\n-    if let Some(st) = tcx.stability.borrow().stab_map.get(&id) {\n-        return *st;\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+    /// Lookup the stability for a node, loading external crate\n+    /// metadata as necessary.\n+    pub fn lookup_stability(self, id: DefId) -> Option<&'tcx Stability> {\n+        if let Some(st) = self.stability.borrow().stab_map.get(&id) {\n+            return *st;\n+        }\n+\n+        let st = self.lookup_stability_uncached(id);\n+        self.stability.borrow_mut().stab_map.insert(id, st);\n+        st\n     }\n \n-    let st = lookup_stability_uncached(tcx, id);\n-    tcx.stability.borrow_mut().stab_map.insert(id, st);\n-    st\n-}\n+    pub fn lookup_deprecation(self, id: DefId) -> Option<Deprecation> {\n+        if let Some(depr) = self.stability.borrow().depr_map.get(&id) {\n+            return depr.clone();\n+        }\n \n-pub fn lookup_deprecation<'tcx>(tcx: &TyCtxt<'tcx>, id: DefId) -> Option<Deprecation> {\n-    if let Some(depr) = tcx.stability.borrow().depr_map.get(&id) {\n-        return depr.clone();\n+        let depr = self.lookup_deprecation_uncached(id);\n+        self.stability.borrow_mut().depr_map.insert(id, depr.clone());\n+        depr\n     }\n \n-    let depr = lookup_deprecation_uncached(tcx, id);\n-    tcx.stability.borrow_mut().depr_map.insert(id, depr.clone());\n-    depr\n-}\n-\n-fn lookup_stability_uncached<'tcx>(tcx: &TyCtxt<'tcx>, id: DefId) -> Option<&'tcx Stability> {\n-    debug!(\"lookup(id={:?})\", id);\n-    if id.is_local() {\n-        None // The stability cache is filled partially lazily\n-    } else {\n-        tcx.sess.cstore.stability(id).map(|st| tcx.intern_stability(st))\n+    fn lookup_stability_uncached(self, id: DefId) -> Option<&'tcx Stability> {\n+        debug!(\"lookup(id={:?})\", id);\n+        if id.is_local() {\n+            None // The stability cache is filled partially lazily\n+        } else {\n+            self.sess.cstore.stability(id).map(|st| self.intern_stability(st))\n+        }\n     }\n-}\n \n-fn lookup_deprecation_uncached<'tcx>(tcx: &TyCtxt<'tcx>, id: DefId) -> Option<Deprecation> {\n-    debug!(\"lookup(id={:?})\", id);\n-    if id.is_local() {\n-        None // The stability cache is filled partially lazily\n-    } else {\n-        tcx.sess.cstore.deprecation(id)\n+    fn lookup_deprecation_uncached(self, id: DefId) -> Option<Deprecation> {\n+        debug!(\"lookup(id={:?})\", id);\n+        if id.is_local() {\n+            None // The stability cache is filled partially lazily\n+        } else {\n+            self.sess.cstore.deprecation(id)\n+        }\n     }\n }\n "}, {"sha": "458cb28144adbced7573fad926b5568d1c70154e", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -816,7 +816,7 @@ pub enum AggregateKind<'tcx> {\n     Vec,\n     Tuple,\n     Adt(AdtDef<'tcx>, usize, &'tcx Substs<'tcx>),\n-    Closure(DefId, &'tcx ClosureSubsts<'tcx>),\n+    Closure(DefId, ClosureSubsts<'tcx>),\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]"}, {"sha": "a1c0d92f60cd63c874e5ea9fc528249ba13362eb", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -30,12 +30,12 @@ pub enum LvalueTy<'tcx> {\n                variant_index: usize },\n }\n \n-impl<'tcx> LvalueTy<'tcx> {\n+impl<'a, 'gcx, 'tcx> LvalueTy<'tcx> {\n     pub fn from_ty(ty: Ty<'tcx>) -> LvalueTy<'tcx> {\n         LvalueTy::Ty { ty: ty }\n     }\n \n-    pub fn to_ty(&self, tcx: &TyCtxt<'tcx>) -> Ty<'tcx> {\n+    pub fn to_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n             LvalueTy::Ty { ty } =>\n                 ty,\n@@ -44,8 +44,7 @@ impl<'tcx> LvalueTy<'tcx> {\n         }\n     }\n \n-    pub fn projection_ty(self,\n-                         tcx: &TyCtxt<'tcx>,\n+    pub fn projection_ty(self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                          elem: &LvalueElem<'tcx>)\n                          -> LvalueTy<'tcx>\n     {\n@@ -79,14 +78,13 @@ impl<'tcx> LvalueTy<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for LvalueTy<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n             LvalueTy::Ty { ty } => LvalueTy::Ty { ty: ty.fold_with(folder) },\n             LvalueTy::Downcast { adt_def, substs, variant_index } => {\n-                let substs = substs.fold_with(folder);\n                 LvalueTy::Downcast {\n                     adt_def: adt_def,\n-                    substs: folder.tcx().mk_substs(substs),\n+                    substs: substs.fold_with(folder),\n                     variant_index: variant_index\n                 }\n             }\n@@ -101,9 +99,8 @@ impl<'tcx> TypeFoldable<'tcx> for LvalueTy<'tcx> {\n     }\n }\n \n-impl<'tcx> Mir<'tcx> {\n-    pub fn operand_ty(&self,\n-                      tcx: &TyCtxt<'tcx>,\n+impl<'a, 'gcx, 'tcx> Mir<'tcx> {\n+    pub fn operand_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                       operand: &Operand<'tcx>)\n                       -> Ty<'tcx>\n     {\n@@ -113,8 +110,7 @@ impl<'tcx> Mir<'tcx> {\n         }\n     }\n \n-    pub fn binop_ty(&self,\n-                    tcx: &TyCtxt<'tcx>,\n+    pub fn binop_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                     op: BinOp,\n                     lhs_ty: Ty<'tcx>,\n                     rhs_ty: Ty<'tcx>)\n@@ -138,8 +134,7 @@ impl<'tcx> Mir<'tcx> {\n         }\n     }\n \n-    pub fn lvalue_ty(&self,\n-                     tcx: &TyCtxt<'tcx>,\n+    pub fn lvalue_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                      lvalue: &Lvalue<'tcx>)\n                      -> LvalueTy<'tcx>\n     {\n@@ -159,8 +154,7 @@ impl<'tcx> Mir<'tcx> {\n         }\n     }\n \n-    pub fn rvalue_ty(&self,\n-                     tcx: &TyCtxt<'tcx>,\n+    pub fn rvalue_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                      rvalue: &Rvalue<'tcx>)\n                      -> Option<Ty<'tcx>>\n     {\n@@ -211,11 +205,10 @@ impl<'tcx> Mir<'tcx> {\n                         ))\n                     }\n                     AggregateKind::Adt(def, _, substs) => {\n-                        Some(def.type_scheme(tcx).ty.subst(tcx, substs))\n+                        Some(tcx.lookup_item_type(def.did).ty.subst(tcx, substs))\n                     }\n                     AggregateKind::Closure(did, substs) => {\n-                        Some(tcx.mk_closure_from_closure_substs(\n-                            did, Box::new(substs.clone())))\n+                        Some(tcx.mk_closure_from_closure_substs(did, substs))\n                     }\n                 }\n             }"}, {"sha": "79c44b2b851c72a86c284673be235d165bcfc2da", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -33,8 +33,8 @@ pub enum MirSource {\n     Promoted(NodeId, usize)\n }\n \n-impl MirSource {\n-    pub fn from_node(tcx: &TyCtxt, id: NodeId) -> MirSource {\n+impl<'a, 'tcx> MirSource {\n+    pub fn from_node(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: NodeId) -> MirSource {\n         use hir::*;\n \n         // Handle constants in enum discriminants, types, and repeat expressions.\n@@ -79,21 +79,22 @@ pub trait Pass {\n \n /// A pass which inspects the whole MirMap.\n pub trait MirMapPass<'tcx>: Pass {\n-    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, map: &mut MirMap<'tcx>);\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, map: &mut MirMap<'tcx>);\n }\n \n /// A pass which inspects Mir of functions in isolation.\n pub trait MirPass<'tcx>: Pass {\n-    fn run_pass_on_promoted(&mut self, tcx: &TyCtxt<'tcx>,\n-                            item_id: NodeId, index: usize,\n-                            mir: &mut Mir<'tcx>) {\n+    fn run_pass_on_promoted<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                item_id: NodeId, index: usize,\n+                                mir: &mut Mir<'tcx>) {\n         self.run_pass(tcx, MirSource::Promoted(item_id, index), mir);\n     }\n-    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, src: MirSource, mir: &mut Mir<'tcx>);\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    src: MirSource, mir: &mut Mir<'tcx>);\n }\n \n impl<'tcx, T: MirPass<'tcx>> MirMapPass<'tcx> for T {\n-    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, map: &mut MirMap<'tcx>) {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, map: &mut MirMap<'tcx>) {\n         for (&id, mir) in &mut map.map {\n             let def_id = tcx.map.local_def_id(id);\n             let _task = tcx.dep_graph.in_task(self.dep_node(def_id));\n@@ -114,7 +115,7 @@ pub struct Passes {\n     plugin_passes: Vec<Box<for<'tcx> MirMapPass<'tcx>>>\n }\n \n-impl Passes {\n+impl<'a, 'tcx> Passes {\n     pub fn new() -> Passes {\n         let passes = Passes {\n             passes: Vec::new(),\n@@ -123,17 +124,17 @@ impl Passes {\n         passes\n     }\n \n-    pub fn run_passes<'tcx>(&mut self, pcx: &TyCtxt<'tcx>, map: &mut MirMap<'tcx>) {\n+    pub fn run_passes(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, map: &mut MirMap<'tcx>) {\n         for pass in &mut self.plugin_passes {\n-            pass.run_pass(pcx, map);\n+            pass.run_pass(tcx, map);\n         }\n         for pass in &mut self.passes {\n-            pass.run_pass(pcx, map);\n+            pass.run_pass(tcx, map);\n         }\n     }\n \n     /// Pushes a built-in pass.\n-    pub fn push_pass(&mut self, pass: Box<for<'a> MirMapPass<'a>>) {\n+    pub fn push_pass(&mut self, pass: Box<for<'b> MirMapPass<'b>>) {\n         self.passes.push(pass);\n     }\n }"}, {"sha": "88460651352537357a6b7e0183110aa8a1e76681", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -197,7 +197,7 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_closure_substs(&mut self,\n-                                    substs: & $($mutability)* &'tcx ClosureSubsts<'tcx>) {\n+                                    substs: & $($mutability)* ClosureSubsts<'tcx>) {\n                 self.super_closure_substs(substs);\n             }\n \n@@ -681,7 +681,7 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_closure_substs(&mut self,\n-                                    _substs: & $($mutability)* &'tcx ClosureSubsts<'tcx>) {\n+                                    _substs: & $($mutability)* ClosureSubsts<'tcx>) {\n             }\n \n             fn super_const_val(&mut self, _substs: & $($mutability)* ConstVal) {"}, {"sha": "414b9fa70c3026381307da3aeeab2076d5be1065", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 25, "deletions": 34, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -16,18 +16,18 @@ use middle::cstore::LOCAL_CRATE;\n use hir::def_id::DefId;\n use ty::subst::TypeSpace;\n use ty::{self, Ty, TyCtxt};\n-use infer::{self, InferCtxt, TypeOrigin};\n+use infer::{InferCtxt, TypeOrigin};\n use syntax::codemap::DUMMY_SP;\n \n #[derive(Copy, Clone)]\n struct InferIsLocal(bool);\n \n /// If there are types that satisfy both impls, returns a suitably-freshened\n /// `ImplHeader` with those types substituted\n-pub fn overlapping_impls<'cx, 'tcx>(infcx: &InferCtxt<'cx, 'tcx>,\n-                                    impl1_def_id: DefId,\n-                                    impl2_def_id: DefId)\n-                                    -> Option<ty::ImplHeader<'tcx>>\n+pub fn overlapping_impls<'cx, 'gcx, 'tcx>(infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n+                                          impl1_def_id: DefId,\n+                                          impl2_def_id: DefId)\n+                                          -> Option<ty::ImplHeader<'tcx>>\n {\n     debug!(\"impl_can_satisfy(\\\n            impl1_def_id={:?}, \\\n@@ -41,10 +41,10 @@ pub fn overlapping_impls<'cx, 'tcx>(infcx: &InferCtxt<'cx, 'tcx>,\n \n /// Can both impl `a` and impl `b` be satisfied by a common type (including\n /// `where` clauses)? If so, returns an `ImplHeader` that unifies the two impls.\n-fn overlap<'cx, 'tcx>(selcx: &mut SelectionContext<'cx, 'tcx>,\n-                      a_def_id: DefId,\n-                      b_def_id: DefId)\n-                      -> Option<ty::ImplHeader<'tcx>>\n+fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+                            a_def_id: DefId,\n+                            b_def_id: DefId)\n+                            -> Option<ty::ImplHeader<'tcx>>\n {\n     debug!(\"overlap(a_def_id={:?}, b_def_id={:?})\",\n            a_def_id,\n@@ -57,11 +57,10 @@ fn overlap<'cx, 'tcx>(selcx: &mut SelectionContext<'cx, 'tcx>,\n     debug!(\"overlap: b_impl_header={:?}\", b_impl_header);\n \n     // Do `a` and `b` unify? If not, no overlap.\n-    if let Err(_) = infer::mk_eq_impl_headers(selcx.infcx(),\n-                                              true,\n-                                              TypeOrigin::Misc(DUMMY_SP),\n-                                              &a_impl_header,\n-                                              &b_impl_header) {\n+    if let Err(_) = selcx.infcx().eq_impl_headers(true,\n+                                                  TypeOrigin::Misc(DUMMY_SP),\n+                                                  &a_impl_header,\n+                                                  &b_impl_header) {\n         return None;\n     }\n \n@@ -87,7 +86,8 @@ fn overlap<'cx, 'tcx>(selcx: &mut SelectionContext<'cx, 'tcx>,\n     Some(selcx.infcx().resolve_type_vars_if_possible(&a_impl_header))\n }\n \n-pub fn trait_ref_is_knowable<'tcx>(tcx: &TyCtxt<'tcx>, trait_ref: &ty::TraitRef<'tcx>) -> bool\n+pub fn trait_ref_is_knowable<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                             trait_ref: &ty::TraitRef<'tcx>) -> bool\n {\n     debug!(\"trait_ref_is_knowable(trait_ref={:?})\", trait_ref);\n \n@@ -129,9 +129,9 @@ pub enum OrphanCheckErr<'tcx> {\n ///\n /// 1. All type parameters in `Self` must be \"covered\" by some local type constructor.\n /// 2. Some local type must appear in `Self`.\n-pub fn orphan_check<'tcx>(tcx: &TyCtxt<'tcx>,\n-                          impl_def_id: DefId)\n-                          -> Result<(), OrphanCheckErr<'tcx>>\n+pub fn orphan_check<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                    impl_def_id: DefId)\n+                                    -> Result<(), OrphanCheckErr<'tcx>>\n {\n     debug!(\"orphan_check({:?})\", impl_def_id);\n \n@@ -150,7 +150,7 @@ pub fn orphan_check<'tcx>(tcx: &TyCtxt<'tcx>,\n     orphan_check_trait_ref(tcx, &trait_ref, InferIsLocal(false))\n }\n \n-fn orphan_check_trait_ref<'tcx>(tcx: &TyCtxt<'tcx>,\n+fn orphan_check_trait_ref<'tcx>(tcx: TyCtxt,\n                                 trait_ref: &ty::TraitRef<'tcx>,\n                                 infer_is_local: InferIsLocal)\n                                 -> Result<(), OrphanCheckErr<'tcx>>\n@@ -198,11 +198,8 @@ fn orphan_check_trait_ref<'tcx>(tcx: &TyCtxt<'tcx>,\n     return Err(OrphanCheckErr::NoLocalInputType);\n }\n \n-fn uncovered_tys<'tcx>(tcx: &TyCtxt<'tcx>,\n-                       ty: Ty<'tcx>,\n-                       infer_is_local: InferIsLocal)\n-                       -> Vec<Ty<'tcx>>\n-{\n+fn uncovered_tys<'tcx>(tcx: TyCtxt, ty: Ty<'tcx>, infer_is_local: InferIsLocal)\n+                       -> Vec<Ty<'tcx>> {\n     if ty_is_local_constructor(tcx, ty, infer_is_local) {\n         vec![]\n     } else if fundamental_ty(tcx, ty) {\n@@ -214,22 +211,20 @@ fn uncovered_tys<'tcx>(tcx: &TyCtxt<'tcx>,\n     }\n }\n \n-fn is_type_parameter<'tcx>(ty: Ty<'tcx>) -> bool {\n+fn is_type_parameter(ty: Ty) -> bool {\n     match ty.sty {\n         // FIXME(#20590) straighten story about projection types\n         ty::TyProjection(..) | ty::TyParam(..) => true,\n         _ => false,\n     }\n }\n \n-fn ty_is_local<'tcx>(tcx: &TyCtxt<'tcx>, ty: Ty<'tcx>, infer_is_local: InferIsLocal) -> bool\n-{\n+fn ty_is_local(tcx: TyCtxt, ty: Ty, infer_is_local: InferIsLocal) -> bool {\n     ty_is_local_constructor(tcx, ty, infer_is_local) ||\n         fundamental_ty(tcx, ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, infer_is_local))\n }\n \n-fn fundamental_ty<'tcx>(tcx: &TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool\n-{\n+fn fundamental_ty(tcx: TyCtxt, ty: Ty) -> bool {\n     match ty.sty {\n         ty::TyBox(..) | ty::TyRef(..) =>\n             true,\n@@ -242,11 +237,7 @@ fn fundamental_ty<'tcx>(tcx: &TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool\n     }\n }\n \n-fn ty_is_local_constructor<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                 ty: Ty<'tcx>,\n-                                 infer_is_local: InferIsLocal)\n-                                 -> bool\n-{\n+fn ty_is_local_constructor(tcx: TyCtxt, ty: Ty, infer_is_local: InferIsLocal)-> bool {\n     debug!(\"ty_is_local_constructor({:?})\", ty);\n \n     match ty.sty {"}, {"sha": "6c037ebd2bc73a78d7d4170d8d1eb5aa038ccec3", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 737, "deletions": 763, "changes": 1500, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -22,7 +22,6 @@ use super::{\n     SelectionError,\n     ObjectSafetyViolation,\n     MethodViolationCode,\n-    object_safety_violations,\n };\n \n use fmt_macros::{Parser, Piece, Position};\n@@ -47,10 +46,10 @@ pub struct TraitErrorKey<'tcx> {\n     predicate: ty::Predicate<'tcx>\n }\n \n-impl<'tcx> TraitErrorKey<'tcx> {\n-    fn from_error<'a>(infcx: &InferCtxt<'a, 'tcx>,\n-                      e: &FulfillmentError<'tcx>,\n-                      warning_node_id: Option<ast::NodeId>) -> Self {\n+impl<'a, 'gcx, 'tcx> TraitErrorKey<'tcx> {\n+    fn from_error(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                  e: &FulfillmentError<'tcx>,\n+                  warning_node_id: Option<ast::NodeId>) -> Self {\n         let predicate =\n             infcx.resolve_type_vars_if_possible(&e.obligation.predicate);\n         TraitErrorKey {\n@@ -61,870 +60,845 @@ impl<'tcx> TraitErrorKey<'tcx> {\n     }\n }\n \n-pub fn report_fulfillment_errors<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                           errors: &Vec<FulfillmentError<'tcx>>) {\n-    for error in errors {\n-        report_fulfillment_error(infcx, error, None);\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    pub fn report_fulfillment_errors(&self, errors: &Vec<FulfillmentError<'tcx>>) {\n+        for error in errors {\n+            self.report_fulfillment_error(error, None);\n+        }\n     }\n-}\n \n-pub fn report_fulfillment_errors_as_warnings<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                                       errors: &Vec<FulfillmentError<'tcx>>,\n-                                                       node_id: ast::NodeId)\n-{\n-    for error in errors {\n-        report_fulfillment_error(infcx, error, Some(node_id));\n+    pub fn report_fulfillment_errors_as_warnings(&self,\n+                                                 errors: &Vec<FulfillmentError<'tcx>>,\n+                                                 node_id: ast::NodeId) {\n+        for error in errors {\n+            self.report_fulfillment_error(error, Some(node_id));\n+        }\n     }\n-}\n \n-fn report_fulfillment_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                      error: &FulfillmentError<'tcx>,\n-                                      warning_node_id: Option<ast::NodeId>) {\n-    let error_key = TraitErrorKey::from_error(infcx, error, warning_node_id);\n-    debug!(\"report_fulfillment_errors({:?}) - key={:?}\",\n-           error, error_key);\n-    if !infcx.reported_trait_errors.borrow_mut().insert(error_key) {\n-        debug!(\"report_fulfillment_errors: skipping duplicate\");\n-        return;\n-    }\n-    match error.code {\n-        FulfillmentErrorCode::CodeSelectionError(ref e) => {\n-            report_selection_error(infcx, &error.obligation, e, warning_node_id);\n-        }\n-        FulfillmentErrorCode::CodeProjectionError(ref e) => {\n-            report_projection_error(infcx, &error.obligation, e, warning_node_id);\n-        }\n-        FulfillmentErrorCode::CodeAmbiguity => {\n-            maybe_report_ambiguity(infcx, &error.obligation);\n+    fn report_fulfillment_error(&self,\n+                                error: &FulfillmentError<'tcx>,\n+                                warning_node_id: Option<ast::NodeId>) {\n+        let error_key = TraitErrorKey::from_error(self, error, warning_node_id);\n+        debug!(\"report_fulfillment_errors({:?}) - key={:?}\",\n+               error, error_key);\n+        if !self.reported_trait_errors.borrow_mut().insert(error_key) {\n+            debug!(\"report_fulfillment_errors: skipping duplicate\");\n+            return;\n+        }\n+        match error.code {\n+            FulfillmentErrorCode::CodeSelectionError(ref e) => {\n+                self.report_selection_error(&error.obligation, e, warning_node_id);\n+            }\n+            FulfillmentErrorCode::CodeProjectionError(ref e) => {\n+                self.report_projection_error(&error.obligation, e, warning_node_id);\n+            }\n+            FulfillmentErrorCode::CodeAmbiguity => {\n+                self.maybe_report_ambiguity(&error.obligation);\n+            }\n         }\n     }\n-}\n \n-pub fn report_projection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                         obligation: &PredicateObligation<'tcx>,\n-                                         error: &MismatchedProjectionTypes<'tcx>,\n-                                         warning_node_id: Option<ast::NodeId>)\n-{\n-    let predicate =\n-        infcx.resolve_type_vars_if_possible(&obligation.predicate);\n-\n-    if !predicate.references_error() {\n-        if let Some(warning_node_id) = warning_node_id {\n-            infcx.tcx.sess.add_lint(\n-                ::lint::builtin::UNSIZED_IN_TUPLE,\n-                warning_node_id,\n-                obligation.cause.span,\n-                format!(\"type mismatch resolving `{}`: {}\",\n-                        predicate,\n-                        error.err));\n-        } else {\n-            let mut err = struct_span_err!(infcx.tcx.sess, obligation.cause.span, E0271,\n-                                           \"type mismatch resolving `{}`: {}\",\n-                                           predicate,\n-                                           error.err);\n-            note_obligation_cause(infcx, &mut err, obligation);\n-            err.emit();\n+    fn report_projection_error(&self,\n+                               obligation: &PredicateObligation<'tcx>,\n+                               error: &MismatchedProjectionTypes<'tcx>,\n+                               warning_node_id: Option<ast::NodeId>)\n+    {\n+        let predicate =\n+            self.resolve_type_vars_if_possible(&obligation.predicate);\n+\n+        if !predicate.references_error() {\n+            if let Some(warning_node_id) = warning_node_id {\n+                self.tcx.sess.add_lint(\n+                    ::lint::builtin::UNSIZED_IN_TUPLE,\n+                    warning_node_id,\n+                    obligation.cause.span,\n+                    format!(\"type mismatch resolving `{}`: {}\",\n+                            predicate,\n+                            error.err));\n+            } else {\n+                let mut err = struct_span_err!(self.tcx.sess, obligation.cause.span, E0271,\n+                                               \"type mismatch resolving `{}`: {}\",\n+                                               predicate,\n+                                               error.err);\n+                self.note_obligation_cause(&mut err, obligation);\n+                err.emit();\n+            }\n         }\n     }\n-}\n \n-fn on_unimplemented_note<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                   trait_ref: ty::PolyTraitRef<'tcx>,\n-                                   span: Span) -> Option<String> {\n-    let trait_ref = trait_ref.skip_binder();\n-    let def_id = trait_ref.def_id;\n-    let mut report = None;\n-    for item in infcx.tcx.get_attrs(def_id).iter() {\n-        if item.check_name(\"rustc_on_unimplemented\") {\n-            let err_sp = item.meta().span.substitute_dummy(span);\n-            let def = infcx.tcx.lookup_trait_def(def_id);\n-            let trait_str = def.trait_ref.to_string();\n-            if let Some(ref istring) = item.value_str() {\n-                let mut generic_map = def.generics.types.iter_enumerated()\n-                                         .map(|(param, i, gen)| {\n-                                               (gen.name.as_str().to_string(),\n-                                                trait_ref.substs.types.get(param, i)\n-                                                         .to_string())\n-                                              }).collect::<FnvHashMap<String, String>>();\n-                generic_map.insert(\"Self\".to_string(),\n-                                   trait_ref.self_ty().to_string());\n-                let parser = Parser::new(&istring);\n-                let mut errored = false;\n-                let err: String = parser.filter_map(|p| {\n-                    match p {\n-                        Piece::String(s) => Some(s),\n-                        Piece::NextArgument(a) => match a.position {\n-                            Position::ArgumentNamed(s) => match generic_map.get(s) {\n-                                Some(val) => Some(val),\n-                                None => {\n-                                    span_err!(infcx.tcx.sess, err_sp, E0272,\n-                                                   \"the #[rustc_on_unimplemented] \\\n-                                                            attribute on \\\n-                                                            trait definition for {} refers to \\\n-                                                            non-existent type parameter {}\",\n-                                                           trait_str, s);\n+    fn on_unimplemented_note(&self,\n+                             trait_ref: ty::PolyTraitRef<'tcx>,\n+                             span: Span) -> Option<String> {\n+        let trait_ref = trait_ref.skip_binder();\n+        let def_id = trait_ref.def_id;\n+        let mut report = None;\n+        for item in self.tcx.get_attrs(def_id).iter() {\n+            if item.check_name(\"rustc_on_unimplemented\") {\n+                let err_sp = item.meta().span.substitute_dummy(span);\n+                let def = self.tcx.lookup_trait_def(def_id);\n+                let trait_str = def.trait_ref.to_string();\n+                if let Some(ref istring) = item.value_str() {\n+                    let mut generic_map = def.generics.types.iter_enumerated()\n+                                             .map(|(param, i, gen)| {\n+                                                   (gen.name.as_str().to_string(),\n+                                                    trait_ref.substs.types.get(param, i)\n+                                                             .to_string())\n+                                                  }).collect::<FnvHashMap<String, String>>();\n+                    generic_map.insert(\"Self\".to_string(),\n+                                       trait_ref.self_ty().to_string());\n+                    let parser = Parser::new(&istring);\n+                    let mut errored = false;\n+                    let err: String = parser.filter_map(|p| {\n+                        match p {\n+                            Piece::String(s) => Some(s),\n+                            Piece::NextArgument(a) => match a.position {\n+                                Position::ArgumentNamed(s) => match generic_map.get(s) {\n+                                    Some(val) => Some(val),\n+                                    None => {\n+                                        span_err!(self.tcx.sess, err_sp, E0272,\n+                                                       \"the #[rustc_on_unimplemented] \\\n+                                                                attribute on \\\n+                                                                trait definition for {} refers to \\\n+                                                                non-existent type parameter {}\",\n+                                                               trait_str, s);\n+                                        errored = true;\n+                                        None\n+                                    }\n+                                },\n+                                _ => {\n+                                    span_err!(self.tcx.sess, err_sp, E0273,\n+                                              \"the #[rustc_on_unimplemented] attribute \\\n+                                               on trait definition for {} must have \\\n+                                               named format arguments, eg \\\n+                                               `#[rustc_on_unimplemented = \\\n+                                                \\\"foo {{T}}\\\"]`\", trait_str);\n                                     errored = true;\n                                     None\n                                 }\n-                            },\n-                            _ => {\n-                                     span_err!(infcx.tcx.sess, err_sp, E0273,\n-                                               \"the #[rustc_on_unimplemented] \\\n-                                                        attribute on \\\n-                                                        trait definition for {} must have named \\\n-                                                        format arguments, \\\n-                                                        eg `#[rustc_on_unimplemented = \\\n-                                                        \\\"foo {{T}}\\\"]`\",\n-                                                       trait_str);\n-                                errored = true;\n-                                None\n                             }\n                         }\n+                    }).collect();\n+                    // Report only if the format string checks out\n+                    if !errored {\n+                        report = Some(err);\n                     }\n-                }).collect();\n-                // Report only if the format string checks out\n-                if !errored {\n-                    report = Some(err);\n+                } else {\n+                    span_err!(self.tcx.sess, err_sp, E0274,\n+                                            \"the #[rustc_on_unimplemented] attribute on \\\n+                                                     trait definition for {} must have a value, \\\n+                                                     eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\",\n+                                                     trait_str);\n                 }\n-            } else {\n-                span_err!(infcx.tcx.sess, err_sp, E0274,\n-                                        \"the #[rustc_on_unimplemented] attribute on \\\n-                                                 trait definition for {} must have a value, \\\n-                                                 eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\",\n-                                                 trait_str);\n+                break;\n             }\n-            break;\n         }\n+        report\n     }\n-    report\n-}\n \n-fn find_similar_impl_candidates<'a, 'tcx>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>)\n-    -> Vec<ty::TraitRef<'tcx>>\n-{\n-    let simp = fast_reject::simplify_type(infcx.tcx,\n-                                          trait_ref.skip_binder().self_ty(),\n-                                          true);\n-    let mut impl_candidates = Vec::new();\n-    let trait_def = infcx.tcx.lookup_trait_def(trait_ref.def_id());\n-\n-    match simp {\n-        Some(simp) => trait_def.for_each_impl(infcx.tcx, |def_id| {\n-            let imp = infcx.tcx.impl_trait_ref(def_id).unwrap();\n-            let imp_simp = fast_reject::simplify_type(infcx.tcx,\n-                                                      imp.self_ty(),\n-                                                      true);\n-            if let Some(imp_simp) = imp_simp {\n-                if simp != imp_simp {\n-                    return;\n+    fn report_similar_impl_candidates(&self,\n+                                      trait_ref: ty::PolyTraitRef<'tcx>,\n+                                      err: &mut DiagnosticBuilder)\n+    {\n+        let simp = fast_reject::simplify_type(self.tcx,\n+                                              trait_ref.skip_binder().self_ty(),\n+                                              true);\n+        let mut impl_candidates = Vec::new();\n+        let trait_def = self.tcx.lookup_trait_def(trait_ref.def_id());\n+\n+        match simp {\n+            Some(simp) => trait_def.for_each_impl(self.tcx, |def_id| {\n+                let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n+                let imp_simp = fast_reject::simplify_type(self.tcx,\n+                                                          imp.self_ty(),\n+                                                          true);\n+                if let Some(imp_simp) = imp_simp {\n+                    if simp != imp_simp {\n+                        return;\n+                    }\n                 }\n-            }\n-            impl_candidates.push(imp);\n-        }),\n-        None => trait_def.for_each_impl(infcx.tcx, |def_id| {\n-            impl_candidates.push(\n-                infcx.tcx.impl_trait_ref(def_id).unwrap());\n-        })\n-    };\n-    impl_candidates\n-}\n+                impl_candidates.push(imp);\n+            }),\n+            None => trait_def.for_each_impl(self.tcx, |def_id| {\n+                impl_candidates.push(\n+                    self.tcx.impl_trait_ref(def_id).unwrap());\n+            })\n+        };\n \n-fn report_similar_impl_candidates(err: &mut DiagnosticBuilder,\n-                                  impl_candidates: &[ty::TraitRef])\n-{\n-    err.help(&format!(\"the following implementations were found:\"));\n+        if impl_candidates.is_empty() {\n+            return;\n+        }\n \n-    let end = cmp::min(4, impl_candidates.len());\n-    for candidate in &impl_candidates[0..end] {\n-        err.help(&format!(\"  {:?}\", candidate));\n-    }\n-    if impl_candidates.len() > 4 {\n-        err.help(&format!(\"and {} others\", impl_candidates.len()-4));\n-    }\n-}\n+        err.help(&format!(\"the following implementations were found:\"));\n \n-/// Reports that an overflow has occurred and halts compilation. We\n-/// halt compilation unconditionally because it is important that\n-/// overflows never be masked -- they basically represent computations\n-/// whose result could not be truly determined and thus we can't say\n-/// if the program type checks or not -- and they are unusual\n-/// occurrences in any case.\n-pub fn report_overflow_error<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n-                                          obligation: &Obligation<'tcx, T>,\n-                                          suggest_increasing_limit: bool)\n-                                          -> !\n-    where T: fmt::Display + TypeFoldable<'tcx>\n-{\n-    let predicate =\n-        infcx.resolve_type_vars_if_possible(&obligation.predicate);\n-    let mut err = struct_span_err!(infcx.tcx.sess, obligation.cause.span, E0275,\n-                                   \"overflow evaluating the requirement `{}`\",\n-                                   predicate);\n-\n-    if suggest_increasing_limit {\n-        suggest_new_overflow_limit(infcx.tcx, &mut err);\n+        let end = cmp::min(4, impl_candidates.len());\n+        for candidate in &impl_candidates[0..end] {\n+            err.help(&format!(\"  {:?}\", candidate));\n+        }\n+        if impl_candidates.len() > 4 {\n+            err.help(&format!(\"and {} others\", impl_candidates.len()-4));\n+        }\n     }\n \n-    note_obligation_cause(infcx, &mut err, obligation);\n+    /// Reports that an overflow has occurred and halts compilation. We\n+    /// halt compilation unconditionally because it is important that\n+    /// overflows never be masked -- they basically represent computations\n+    /// whose result could not be truly determined and thus we can't say\n+    /// if the program type checks or not -- and they are unusual\n+    /// occurrences in any case.\n+    pub fn report_overflow_error<T>(&self,\n+                                    obligation: &Obligation<'tcx, T>,\n+                                    suggest_increasing_limit: bool) -> !\n+        where T: fmt::Display + TypeFoldable<'tcx>\n+    {\n+        let predicate =\n+            self.resolve_type_vars_if_possible(&obligation.predicate);\n+        let mut err = struct_span_err!(self.tcx.sess, obligation.cause.span, E0275,\n+                                       \"overflow evaluating the requirement `{}`\",\n+                                       predicate);\n \n-    err.emit();\n-    infcx.tcx.sess.abort_if_errors();\n-    bug!();\n-}\n+        if suggest_increasing_limit {\n+            self.suggest_new_overflow_limit(&mut err);\n+        }\n \n-/// Reports that a cycle was detected which led to overflow and halts\n-/// compilation. This is equivalent to `report_overflow_error` except\n-/// that we can give a more helpful error message (and, in particular,\n-/// we do not suggest increasing the overflow limit, which is not\n-/// going to help).\n-pub fn report_overflow_error_cycle<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                             cycle: &Vec<PredicateObligation<'tcx>>)\n-                                             -> !\n-{\n-    assert!(cycle.len() > 1);\n+        self.note_obligation_cause(&mut err, obligation);\n \n-    debug!(\"report_overflow_error_cycle(cycle length = {})\", cycle.len());\n+        err.emit();\n+        self.tcx.sess.abort_if_errors();\n+        bug!();\n+    }\n \n-    let cycle = infcx.resolve_type_vars_if_possible(cycle);\n+    /// Reports that a cycle was detected which led to overflow and halts\n+    /// compilation. This is equivalent to `report_overflow_error` except\n+    /// that we can give a more helpful error message (and, in particular,\n+    /// we do not suggest increasing the overflow limit, which is not\n+    /// going to help).\n+    pub fn report_overflow_error_cycle(&self, cycle: &Vec<PredicateObligation<'tcx>>) -> ! {\n+        assert!(cycle.len() > 1);\n \n-    debug!(\"report_overflow_error_cycle: cycle={:?}\", cycle);\n+        debug!(\"report_overflow_error_cycle(cycle length = {})\", cycle.len());\n \n-    assert_eq!(&cycle[0].predicate, &cycle.last().unwrap().predicate);\n+        let cycle = self.resolve_type_vars_if_possible(cycle);\n \n-    try_report_overflow_error_type_of_infinite_size(infcx, &cycle);\n-    report_overflow_error(infcx, &cycle[0], false);\n-}\n+        debug!(\"report_overflow_error_cycle: cycle={:?}\", cycle);\n \n-/// If a cycle results from evaluated whether something is Sized, that\n-/// is a particular special case that always results from a struct or\n-/// enum definition that lacks indirection (e.g., `struct Foo { x: Foo\n-/// }`). We wish to report a targeted error for this case.\n-pub fn try_report_overflow_error_type_of_infinite_size<'a, 'tcx>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n-    cycle: &[PredicateObligation<'tcx>])\n-{\n-    let sized_trait = match infcx.tcx.lang_items.sized_trait() {\n-        Some(v) => v,\n-        None => return,\n-    };\n-    let top_is_sized = {\n-        match cycle[0].predicate {\n-            ty::Predicate::Trait(ref data) => data.def_id() == sized_trait,\n-            _ => false,\n-        }\n-    };\n-    if !top_is_sized {\n-        return;\n+        assert_eq!(&cycle[0].predicate, &cycle.last().unwrap().predicate);\n+\n+        self.try_report_overflow_error_type_of_infinite_size(&cycle);\n+        self.report_overflow_error(&cycle[0], false);\n     }\n \n-    // The only way to have a type of infinite size is to have,\n-    // somewhere, a struct/enum type involved. Identify all such types\n-    // and report the cycle to the user.\n-\n-    let struct_enum_tys: Vec<_> =\n-        cycle.iter()\n-             .flat_map(|obligation| match obligation.predicate {\n-                 ty::Predicate::Trait(ref data) => {\n-                     assert_eq!(data.def_id(), sized_trait);\n-                     let self_ty = data.skip_binder().trait_ref.self_ty(); // (*)\n-                     // (*) ok to skip binder because this is just\n-                     // error reporting and regions don't really\n-                     // matter\n-                     match self_ty.sty {\n-                         ty::TyEnum(..) | ty::TyStruct(..) => Some(self_ty),\n-                         _ => None,\n+    /// If a cycle results from evaluated whether something is Sized, that\n+    /// is a particular special case that always results from a struct or\n+    /// enum definition that lacks indirection (e.g., `struct Foo { x: Foo\n+    /// }`). We wish to report a targeted error for this case.\n+    pub fn try_report_overflow_error_type_of_infinite_size(&self,\n+        cycle: &[PredicateObligation<'tcx>])\n+    {\n+        let sized_trait = match self.tcx.lang_items.sized_trait() {\n+            Some(v) => v,\n+            None => return,\n+        };\n+        let top_is_sized = {\n+            match cycle[0].predicate {\n+                ty::Predicate::Trait(ref data) => data.def_id() == sized_trait,\n+                _ => false,\n+            }\n+        };\n+        if !top_is_sized {\n+            return;\n+        }\n+\n+        // The only way to have a type of infinite size is to have,\n+        // somewhere, a struct/enum type involved. Identify all such types\n+        // and report the cycle to the user.\n+\n+        let struct_enum_tys: Vec<_> =\n+            cycle.iter()\n+                 .flat_map(|obligation| match obligation.predicate {\n+                     ty::Predicate::Trait(ref data) => {\n+                         assert_eq!(data.def_id(), sized_trait);\n+                         let self_ty = data.skip_binder().trait_ref.self_ty(); // (*)\n+                         // (*) ok to skip binder because this is just\n+                         // error reporting and regions don't really\n+                         // matter\n+                         match self_ty.sty {\n+                             ty::TyEnum(..) | ty::TyStruct(..) => Some(self_ty),\n+                             _ => None,\n+                         }\n                      }\n-                 }\n-                 _ => {\n-                     span_bug!(obligation.cause.span,\n-                               \"Sized cycle involving non-trait-ref: {:?}\",\n-                               obligation.predicate);\n-                 }\n-             })\n-             .collect();\n-\n-    assert!(!struct_enum_tys.is_empty());\n-\n-    // This is a bit tricky. We want to pick a \"main type\" in the\n-    // listing that is local to the current crate, so we can give a\n-    // good span to the user. But it might not be the first one in our\n-    // cycle list. So find the first one that is local and then\n-    // rotate.\n-    let (main_index, main_def_id) =\n-        struct_enum_tys.iter()\n-                       .enumerate()\n-                       .filter_map(|(index, ty)| match ty.sty {\n-                           ty::TyEnum(adt_def, _) | ty::TyStruct(adt_def, _)\n-                               if adt_def.did.is_local() =>\n-                               Some((index, adt_def.did)),\n-                           _ =>\n-                               None,\n-                       })\n-                       .next()\n-                       .unwrap(); // should always be SOME local type involved!\n-\n-    // Rotate so that the \"main\" type is at index 0.\n-    let struct_enum_tys: Vec<_> =\n-        struct_enum_tys.iter()\n-                       .cloned()\n-                       .skip(main_index)\n-                       .chain(struct_enum_tys.iter().cloned().take(main_index))\n-                       .collect();\n-\n-    let tcx = infcx.tcx;\n-    let mut err = recursive_type_with_infinite_size_error(tcx, main_def_id);\n-    let len = struct_enum_tys.len();\n-    if len > 2 {\n-        err.note(&format!(\"type `{}` is embedded within `{}`...\",\n-                 struct_enum_tys[0],\n-                 struct_enum_tys[1]));\n-        for &next_ty in &struct_enum_tys[1..len-1] {\n-            err.note(&format!(\"...which in turn is embedded within `{}`...\", next_ty));\n+                     _ => {\n+                         span_bug!(obligation.cause.span,\n+                                   \"Sized cycle involving non-trait-ref: {:?}\",\n+                                   obligation.predicate);\n+                     }\n+                 })\n+                 .collect();\n+\n+        assert!(!struct_enum_tys.is_empty());\n+\n+        // This is a bit tricky. We want to pick a \"main type\" in the\n+        // listing that is local to the current crate, so we can give a\n+        // good span to the user. But it might not be the first one in our\n+        // cycle list. So find the first one that is local and then\n+        // rotate.\n+        let (main_index, main_def_id) =\n+            struct_enum_tys.iter()\n+                           .enumerate()\n+                           .filter_map(|(index, ty)| match ty.sty {\n+                               ty::TyEnum(adt_def, _) | ty::TyStruct(adt_def, _)\n+                                   if adt_def.did.is_local() =>\n+                                   Some((index, adt_def.did)),\n+                               _ =>\n+                                   None,\n+                           })\n+                           .next()\n+                           .unwrap(); // should always be SOME local type involved!\n+\n+        // Rotate so that the \"main\" type is at index 0.\n+        let struct_enum_tys: Vec<_> =\n+            struct_enum_tys.iter()\n+                           .cloned()\n+                           .skip(main_index)\n+                           .chain(struct_enum_tys.iter().cloned().take(main_index))\n+                           .collect();\n+\n+        let tcx = self.tcx;\n+        let mut err = tcx.recursive_type_with_infinite_size_error(main_def_id);\n+        let len = struct_enum_tys.len();\n+        if len > 2 {\n+            err.note(&format!(\"type `{}` is embedded within `{}`...\",\n+                     struct_enum_tys[0],\n+                     struct_enum_tys[1]));\n+            for &next_ty in &struct_enum_tys[1..len-1] {\n+                err.note(&format!(\"...which in turn is embedded within `{}`...\", next_ty));\n+            }\n+            err.note(&format!(\"...which in turn is embedded within `{}`, \\\n+                               completing the cycle.\",\n+                              struct_enum_tys[len-1]));\n         }\n-        err.note(&format!(\"...which in turn is embedded within `{}`, \\\n-                           completing the cycle.\",\n-                          struct_enum_tys[len-1]));\n+        err.emit();\n+        self.tcx.sess.abort_if_errors();\n+        bug!();\n     }\n-    err.emit();\n-    infcx.tcx.sess.abort_if_errors();\n-    bug!();\n-}\n \n-pub fn recursive_type_with_infinite_size_error<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                                     type_def_id: DefId)\n-                                                     -> DiagnosticBuilder<'tcx>\n-{\n-    assert!(type_def_id.is_local());\n-    let span = tcx.map.span_if_local(type_def_id).unwrap();\n-    let mut err = struct_span_err!(tcx.sess, span, E0072, \"recursive type `{}` has infinite size\",\n-                                   tcx.item_path_str(type_def_id));\n-    err.help(&format!(\"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n-                       at some point to make `{}` representable\",\n-                      tcx.item_path_str(type_def_id)));\n-    err\n-}\n+    pub fn report_selection_error(&self,\n+                                  obligation: &PredicateObligation<'tcx>,\n+                                  error: &SelectionError<'tcx>,\n+                                  warning_node_id: Option<ast::NodeId>)\n+    {\n+        let span = obligation.cause.span;\n+        let mut err = match *error {\n+            SelectionError::Unimplemented => {\n+                if let ObligationCauseCode::CompareImplMethodObligation = obligation.cause.code {\n+                    span_err!(\n+                        self.tcx.sess, span, E0276,\n+                        \"the requirement `{}` appears on the impl \\\n+                         method but not on the corresponding trait method\",\n+                        obligation.predicate);\n+                    return;\n+                } else {\n+                    match obligation.predicate {\n+                        ty::Predicate::Trait(ref trait_predicate) => {\n+                            let trait_predicate =\n+                                self.resolve_type_vars_if_possible(trait_predicate);\n \n-pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                        obligation: &PredicateObligation<'tcx>,\n-                                        error: &SelectionError<'tcx>,\n-                                        warning_node_id: Option<ast::NodeId>)\n-{\n-    match *error {\n-        SelectionError::Unimplemented => {\n-            if let ObligationCauseCode::CompareImplMethodObligation = obligation.cause.code {\n-                span_err!(\n-                    infcx.tcx.sess, obligation.cause.span, E0276,\n-                    \"the requirement `{}` appears on the impl \\\n-                     method but not on the corresponding trait method\",\n-                    obligation.predicate);\n-            } else {\n-                match obligation.predicate {\n-                    ty::Predicate::Trait(ref trait_predicate) => {\n-                        let trait_predicate =\n-                            infcx.resolve_type_vars_if_possible(trait_predicate);\n-\n-                        if !infcx.tcx.sess.has_errors() || !trait_predicate.references_error() {\n-                            let trait_ref = trait_predicate.to_poly_trait_ref();\n-\n-                            if let Some(warning_node_id) = warning_node_id {\n-                                infcx.tcx.sess.add_lint(\n-                                    ::lint::builtin::UNSIZED_IN_TUPLE,\n-                                    warning_node_id,\n-                                    obligation.cause.span,\n-                                    format!(\"the trait bound `{}` is not satisfied\",\n-                                            trait_ref.to_predicate()));\n+                            if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n                                 return;\n-                            }\n-\n-                            let mut err = struct_span_err!(\n-                                infcx.tcx.sess, obligation.cause.span, E0277,\n-                                \"the trait bound `{}` is not satisfied\",\n-                                trait_ref.to_predicate());\n-\n-                            // Try to report a help message\n-\n-                            if !trait_ref.has_infer_types() &&\n-                                predicate_can_apply(infcx, trait_ref)\n-                            {\n-                                // If a where-clause may be useful, remind the\n-                                // user that they can add it.\n-                                //\n-                                // don't display an on-unimplemented note, as\n-                                // these notes will often be of the form\n-                                //     \"the type `T` can't be frobnicated\"\n-                                // which is somewhat confusing.\n-                                err.help(&format!(\"consider adding a `where {}` bound\",\n-                                    trait_ref.to_predicate()\n-                                    ));\n-                            } else if let Some(s) = on_unimplemented_note(infcx, trait_ref,\n-                                                                          obligation.cause.span) {\n-                                // Otherwise, if there is an on-unimplemented note,\n-                                // display it.\n-                                err.note(&s);\n                             } else {\n-                                // If we can't show anything useful, try to find\n-                                // similar impls.\n+                                let trait_ref = trait_predicate.to_poly_trait_ref();\n+\n+                                if let Some(warning_node_id) = warning_node_id {\n+                                    self.tcx.sess.add_lint(\n+                                        ::lint::builtin::UNSIZED_IN_TUPLE,\n+                                        warning_node_id,\n+                                        obligation.cause.span,\n+                                        format!(\"the trait bound `{}` is not satisfied\",\n+                                                trait_ref.to_predicate()));\n+                                    return;\n+                                }\n \n-                                let impl_candidates =\n-                                    find_similar_impl_candidates(infcx, trait_ref);\n-                                if impl_candidates.len() > 0 {\n-                                    report_similar_impl_candidates(&mut err, &impl_candidates);\n+                                let mut err = struct_span_err!(\n+                                    self.tcx.sess, span, E0277,\n+                                    \"the trait bound `{}` is not satisfied\",\n+                                    trait_ref.to_predicate());\n+\n+                                // Try to report a help message\n+\n+                                if !trait_ref.has_infer_types() &&\n+                                    self.predicate_can_apply(trait_ref)\n+                                {\n+                                    // If a where-clause may be useful, remind the\n+                                    // user that they can add it.\n+                                    //\n+                                    // don't display an on-unimplemented note, as\n+                                    // these notes will often be of the form\n+                                    //     \"the type `T` can't be frobnicated\"\n+                                    // which is somewhat confusing.\n+                                    err.help(&format!(\"consider adding a `where {}` bound\",\n+                                        trait_ref.to_predicate()\n+                                        ));\n+                                } else if let Some(s) =\n+                                        self.on_unimplemented_note(trait_ref, span) {\n+                                    // Otherwise, if there is an on-unimplemented note,\n+                                    // display it.\n+                                    err.note(&s);\n+                                } else {\n+                                    // If we can't show anything useful, try to find\n+                                    // similar impls.\n+\n+                                    self.report_similar_impl_candidates(trait_ref, &mut err);\n                                 }\n+                                err\n                             }\n-                            note_obligation_cause(infcx, &mut err, obligation);\n-                            err.emit();\n+                        },\n+                        ty::Predicate::Equate(ref predicate) => {\n+                            let predicate = self.resolve_type_vars_if_possible(predicate);\n+                            let err = self.equality_predicate(span,\n+                                                              &predicate).err().unwrap();\n+                            struct_span_err!(self.tcx.sess, span, E0278,\n+                                \"the requirement `{}` is not satisfied (`{}`)\",\n+                                predicate, err)\n                         }\n-                    },\n-                    ty::Predicate::Equate(ref predicate) => {\n-                        let predicate = infcx.resolve_type_vars_if_possible(predicate);\n-                        let err = infcx.equality_predicate(obligation.cause.span,\n-                                                           &predicate).err().unwrap();\n-                        let mut err = struct_span_err!(\n-                            infcx.tcx.sess, obligation.cause.span, E0278,\n-                            \"the requirement `{}` is not satisfied (`{}`)\",\n-                            predicate,\n-                            err);\n-                        note_obligation_cause(infcx, &mut err, obligation);\n-                        err.emit();\n-                    }\n \n-                    ty::Predicate::RegionOutlives(ref predicate) => {\n-                        let predicate = infcx.resolve_type_vars_if_possible(predicate);\n-                        let err = infcx.region_outlives_predicate(obligation.cause.span,\n-                                                                  &predicate).err().unwrap();\n-                        let mut err = struct_span_err!(\n-                            infcx.tcx.sess, obligation.cause.span, E0279,\n-                            \"the requirement `{}` is not satisfied (`{}`)\",\n-                            predicate,\n-                            err);\n-                        note_obligation_cause(infcx, &mut err, obligation);\n-                        err.emit();\n-                    }\n+                        ty::Predicate::RegionOutlives(ref predicate) => {\n+                            let predicate = self.resolve_type_vars_if_possible(predicate);\n+                            let err = self.region_outlives_predicate(span,\n+                                                                     &predicate).err().unwrap();\n+                            struct_span_err!(self.tcx.sess, span, E0279,\n+                                \"the requirement `{}` is not satisfied (`{}`)\",\n+                                predicate, err)\n+                        }\n \n-                    ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n-                        let predicate =\n-                            infcx.resolve_type_vars_if_possible(&obligation.predicate);\n-                        let mut err = struct_span_err!(\n-                            infcx.tcx.sess, obligation.cause.span, E0280,\n-                            \"the requirement `{}` is not satisfied\",\n-                            predicate);\n-                        note_obligation_cause(infcx, &mut err, obligation);\n-                        err.emit();\n-                    }\n+                        ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n+                            let predicate =\n+                                self.resolve_type_vars_if_possible(&obligation.predicate);\n+                            struct_span_err!(self.tcx.sess, span, E0280,\n+                                \"the requirement `{}` is not satisfied\",\n+                                predicate)\n+                        }\n \n-                    ty::Predicate::ObjectSafe(trait_def_id) => {\n-                        let violations = object_safety_violations(\n-                            infcx.tcx, trait_def_id);\n-                        let err = report_object_safety_error(infcx.tcx,\n-                                                             obligation.cause.span,\n-                                                             trait_def_id,\n-                                                             warning_node_id,\n-                                                             violations);\n-                        if let Some(mut err) = err {\n-                            note_obligation_cause(infcx, &mut err, obligation);\n-                            err.emit();\n+                        ty::Predicate::ObjectSafe(trait_def_id) => {\n+                            let violations = self.tcx.object_safety_violations(trait_def_id);\n+                            let err = self.tcx.report_object_safety_error(span,\n+                                                                          trait_def_id,\n+                                                                          warning_node_id,\n+                                                                          violations);\n+                            if let Some(err) = err {\n+                                err\n+                            } else {\n+                                return;\n+                            }\n                         }\n-                    }\n \n-                    ty::Predicate::ClosureKind(closure_def_id, kind) => {\n-                        let found_kind = infcx.closure_kind(closure_def_id).unwrap();\n-                        let closure_span = infcx.tcx.map.span_if_local(closure_def_id).unwrap();\n-                        let mut err = struct_span_err!(\n-                            infcx.tcx.sess, closure_span, E0525,\n-                            \"expected a closure that implements the `{}` trait, but this closure \\\n-                             only implements `{}`\",\n-                            kind,\n-                            found_kind);\n-                        err.span_note(\n-                            obligation.cause.span,\n-                            &format!(\"the requirement to implement `{}` derives from here\", kind));\n-                        err.emit();\n-                    }\n+                        ty::Predicate::ClosureKind(closure_def_id, kind) => {\n+                            let found_kind = self.closure_kind(closure_def_id).unwrap();\n+                            let closure_span = self.tcx.map.span_if_local(closure_def_id).unwrap();\n+                            let mut err = struct_span_err!(\n+                                self.tcx.sess, closure_span, E0525,\n+                                \"expected a closure that implements the `{}` trait, \\\n+                                 but this closure only implements `{}`\",\n+                                kind,\n+                                found_kind);\n+                            err.span_note(\n+                                obligation.cause.span,\n+                                &format!(\"the requirement to implement \\\n+                                          `{}` derives from here\", kind));\n+                            err.emit();\n+                            return;\n+                        }\n \n-                    ty::Predicate::WellFormed(ty) => {\n-                        // WF predicates cannot themselves make\n-                        // errors. They can only block due to\n-                        // ambiguity; otherwise, they always\n-                        // degenerate into other obligations\n-                        // (which may fail).\n-                        span_bug!(\n-                            obligation.cause.span,\n-                            \"WF predicate not satisfied for {:?}\",\n-                            ty);\n-                    }\n+                        ty::Predicate::WellFormed(ty) => {\n+                            // WF predicates cannot themselves make\n+                            // errors. They can only block due to\n+                            // ambiguity; otherwise, they always\n+                            // degenerate into other obligations\n+                            // (which may fail).\n+                            span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n+                        }\n \n-                    ty::Predicate::Rfc1592(ref data) => {\n-                        span_bug!(\n-                            obligation.cause.span,\n-                            \"RFC1592 predicate not satisfied for {:?}\",\n-                            data);\n+                        ty::Predicate::Rfc1592(ref data) => {\n+                            span_bug!(\n+                                obligation.cause.span,\n+                                \"RFC1592 predicate not satisfied for {:?}\",\n+                                data);\n+                        }\n                     }\n                 }\n             }\n-        }\n \n-        OutputTypeParameterMismatch(ref expected_trait_ref, ref actual_trait_ref, ref e) => {\n-            let expected_trait_ref = infcx.resolve_type_vars_if_possible(&*expected_trait_ref);\n-            let actual_trait_ref = infcx.resolve_type_vars_if_possible(&*actual_trait_ref);\n-            if !actual_trait_ref.self_ty().references_error() {\n-                let mut err = struct_span_err!(\n-                    infcx.tcx.sess, obligation.cause.span, E0281,\n+            OutputTypeParameterMismatch(ref expected_trait_ref, ref actual_trait_ref, ref e) => {\n+                let expected_trait_ref = self.resolve_type_vars_if_possible(&*expected_trait_ref);\n+                let actual_trait_ref = self.resolve_type_vars_if_possible(&*actual_trait_ref);\n+                if actual_trait_ref.self_ty().references_error() {\n+                    return;\n+                }\n+                struct_span_err!(self.tcx.sess, span, E0281,\n                     \"type mismatch: the type `{}` implements the trait `{}`, \\\n                      but the trait `{}` is required ({})\",\n                     expected_trait_ref.self_ty(),\n                     expected_trait_ref,\n                     actual_trait_ref,\n-                    e);\n-                note_obligation_cause(infcx, &mut err, obligation);\n-                err.emit();\n+                    e)\n             }\n-        }\n \n-        TraitNotObjectSafe(did) => {\n-            let violations = object_safety_violations(infcx.tcx, did);\n-            let err = report_object_safety_error(infcx.tcx, obligation.cause.span, did,\n-                                                 warning_node_id,\n-                                                 violations);\n-            if let Some(mut err) = err {\n-                note_obligation_cause(infcx, &mut err, obligation);\n-                err.emit();\n+            TraitNotObjectSafe(did) => {\n+                let violations = self.tcx.object_safety_violations(did);\n+                let err = self.tcx.report_object_safety_error(span, did,\n+                                                              warning_node_id,\n+                                                              violations);\n+                if let Some(err) = err {\n+                    err\n+                } else {\n+                    return;\n+                }\n             }\n-        }\n+        };\n+        self.note_obligation_cause(&mut err, obligation);\n+        err.emit();\n     }\n }\n \n-pub fn report_object_safety_error<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                        span: Span,\n-                                        trait_def_id: DefId,\n-                                        warning_node_id: Option<ast::NodeId>,\n-                                        violations: Vec<ObjectSafetyViolation>)\n-                                        -> Option<DiagnosticBuilder<'tcx>>\n-{\n-    let mut err = match warning_node_id {\n-        Some(_) => None,\n-        None => {\n-            Some(struct_span_err!(\n-                tcx.sess, span, E0038,\n-                \"the trait `{}` cannot be made into an object\",\n-                tcx.item_path_str(trait_def_id)))\n-        }\n-    };\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    pub fn recursive_type_with_infinite_size_error(self,\n+                                                   type_def_id: DefId)\n+                                                   -> DiagnosticBuilder<'tcx>\n+    {\n+        assert!(type_def_id.is_local());\n+        let span = self.map.span_if_local(type_def_id).unwrap();\n+        let mut err = struct_span_err!(self.sess, span, E0072,\n+                                       \"recursive type `{}` has infinite size\",\n+                                       self.item_path_str(type_def_id));\n+        err.help(&format!(\"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n+                           at some point to make `{}` representable\",\n+                          self.item_path_str(type_def_id)));\n+        err\n+    }\n \n-    let mut reported_violations = FnvHashSet();\n-    for violation in violations {\n-        if !reported_violations.insert(violation.clone()) {\n-            continue;\n-        }\n-        let buf;\n-        let note = match violation {\n-            ObjectSafetyViolation::SizedSelf => {\n-                \"the trait cannot require that `Self : Sized`\"\n+    pub fn report_object_safety_error(self,\n+                                      span: Span,\n+                                      trait_def_id: DefId,\n+                                      warning_node_id: Option<ast::NodeId>,\n+                                      violations: Vec<ObjectSafetyViolation>)\n+                                      -> Option<DiagnosticBuilder<'tcx>>\n+    {\n+        let mut err = match warning_node_id {\n+            Some(_) => None,\n+            None => {\n+                Some(struct_span_err!(\n+                    self.sess, span, E0038,\n+                    \"the trait `{}` cannot be made into an object\",\n+                    self.item_path_str(trait_def_id)))\n             }\n+        };\n \n-            ObjectSafetyViolation::SupertraitSelf => {\n-                \"the trait cannot use `Self` as a type parameter \\\n-                     in the supertrait listing\"\n+        let mut reported_violations = FnvHashSet();\n+        for violation in violations {\n+            if !reported_violations.insert(violation.clone()) {\n+                continue;\n             }\n+            let buf;\n+            let note = match violation {\n+                ObjectSafetyViolation::SizedSelf => {\n+                    \"the trait cannot require that `Self : Sized`\"\n+                }\n \n-            ObjectSafetyViolation::Method(method,\n-                                          MethodViolationCode::StaticMethod) => {\n-                buf = format!(\"method `{}` has no receiver\",\n-                              method.name);\n-                &buf\n-            }\n+                ObjectSafetyViolation::SupertraitSelf => {\n+                    \"the trait cannot use `Self` as a type parameter \\\n+                         in the supertrait listing\"\n+                }\n \n-            ObjectSafetyViolation::Method(method,\n-                                          MethodViolationCode::ReferencesSelf) => {\n-                buf = format!(\"method `{}` references the `Self` type \\\n-                                   in its arguments or return type\",\n-                              method.name);\n-                &buf\n-            }\n+                ObjectSafetyViolation::Method(method,\n+                                              MethodViolationCode::StaticMethod) => {\n+                    buf = format!(\"method `{}` has no receiver\",\n+                                  method.name);\n+                    &buf\n+                }\n \n-            ObjectSafetyViolation::Method(method,\n-                                          MethodViolationCode::Generic) => {\n-                buf = format!(\"method `{}` has generic type parameters\",\n-                              method.name);\n-                &buf\n+                ObjectSafetyViolation::Method(method,\n+                                              MethodViolationCode::ReferencesSelf) => {\n+                    buf = format!(\"method `{}` references the `Self` type \\\n+                                       in its arguments or return type\",\n+                                  method.name);\n+                    &buf\n+                }\n+\n+                ObjectSafetyViolation::Method(method,\n+                                              MethodViolationCode::Generic) => {\n+                    buf = format!(\"method `{}` has generic type parameters\",\n+                                  method.name);\n+                    &buf\n+                }\n+            };\n+            match (warning_node_id, &mut err) {\n+                (Some(node_id), &mut None) => {\n+                    self.sess.add_lint(\n+                        ::lint::builtin::OBJECT_UNSAFE_FRAGMENT,\n+                        node_id,\n+                        span,\n+                        note.to_string());\n+                }\n+                (None, &mut Some(ref mut err)) => {\n+                    err.note(note);\n+                }\n+                _ => unreachable!()\n             }\n-        };\n-        match (warning_node_id, &mut err) {\n-            (Some(node_id), &mut None) => {\n-                tcx.sess.add_lint(\n-                    ::lint::builtin::OBJECT_UNSAFE_FRAGMENT,\n-                    node_id,\n-                    span,\n-                    note.to_string());\n-            }\n-            (None, &mut Some(ref mut err)) => {\n-                err.note(note);\n-            }\n-            _ => unreachable!()\n         }\n+        err\n     }\n-    err\n }\n \n-pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                        obligation: &PredicateObligation<'tcx>) {\n-    // Unable to successfully determine, probably means\n-    // insufficient type information, but could mean\n-    // ambiguous impls. The latter *ought* to be a\n-    // coherence violation, so we don't report it here.\n-\n-    let predicate = infcx.resolve_type_vars_if_possible(&obligation.predicate);\n-\n-    debug!(\"maybe_report_ambiguity(predicate={:?}, obligation={:?})\",\n-           predicate,\n-           obligation);\n-\n-    // Ambiguity errors are often caused as fallout from earlier\n-    // errors. So just ignore them if this infcx is tainted.\n-    if infcx.is_tainted_by_errors() {\n-        return;\n-    }\n-\n-    match predicate {\n-        ty::Predicate::Trait(ref data) => {\n-            let trait_ref = data.to_poly_trait_ref();\n-            let self_ty = trait_ref.self_ty();\n-            let all_types = &trait_ref.substs().types;\n-            if all_types.references_error() {\n-            } else {\n-                // Typically, this ambiguity should only happen if\n-                // there are unresolved type inference variables\n-                // (otherwise it would suggest a coherence\n-                // failure). But given #21974 that is not necessarily\n-                // the case -- we can have multiple where clauses that\n-                // are only distinguished by a region, which results\n-                // in an ambiguity even when all types are fully\n-                // known, since we don't dispatch based on region\n-                // relationships.\n-\n-                // This is kind of a hack: it frequently happens that some earlier\n-                // error prevents types from being fully inferred, and then we get\n-                // a bunch of uninteresting errors saying something like \"<generic\n-                // #0> doesn't implement Sized\".  It may even be true that we\n-                // could just skip over all checks where the self-ty is an\n-                // inference variable, but I was afraid that there might be an\n-                // inference variable created, registered as an obligation, and\n-                // then never forced by writeback, and hence by skipping here we'd\n-                // be ignoring the fact that we don't KNOW the type works\n-                // out. Though even that would probably be harmless, given that\n-                // we're only talking about builtin traits, which are known to be\n-                // inhabited. But in any case I just threw in this check for\n-                // has_errors() to be sure that compilation isn't happening\n-                // anyway. In that case, why inundate the user.\n-                if !infcx.tcx.sess.has_errors() {\n-                    if\n-                        infcx.tcx.lang_items.sized_trait()\n-                        .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n-                    {\n-                        need_type_info(infcx, obligation.cause.span, self_ty);\n-                    } else {\n-                        let mut err = struct_span_err!(infcx.tcx.sess, obligation.cause.span, E0283,\n-                                                       \"type annotations required: \\\n-                                                        cannot resolve `{}`\",\n-                                                       predicate);\n-                        note_obligation_cause(infcx, &mut err, obligation);\n-                        err.emit();\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    fn maybe_report_ambiguity(&self, obligation: &PredicateObligation<'tcx>) {\n+        // Unable to successfully determine, probably means\n+        // insufficient type information, but could mean\n+        // ambiguous impls. The latter *ought* to be a\n+        // coherence violation, so we don't report it here.\n+\n+        let predicate = self.resolve_type_vars_if_possible(&obligation.predicate);\n+\n+        debug!(\"maybe_report_ambiguity(predicate={:?}, obligation={:?})\",\n+               predicate,\n+               obligation);\n+\n+        // Ambiguity errors are often caused as fallout from earlier\n+        // errors. So just ignore them if this infcx is tainted.\n+        if self.is_tainted_by_errors() {\n+            return;\n+        }\n+\n+        match predicate {\n+            ty::Predicate::Trait(ref data) => {\n+                let trait_ref = data.to_poly_trait_ref();\n+                let self_ty = trait_ref.self_ty();\n+                let all_types = &trait_ref.substs().types;\n+                if all_types.references_error() {\n+                } else {\n+                    // Typically, this ambiguity should only happen if\n+                    // there are unresolved type inference variables\n+                    // (otherwise it would suggest a coherence\n+                    // failure). But given #21974 that is not necessarily\n+                    // the case -- we can have multiple where clauses that\n+                    // are only distinguished by a region, which results\n+                    // in an ambiguity even when all types are fully\n+                    // known, since we don't dispatch based on region\n+                    // relationships.\n+\n+                    // This is kind of a hack: it frequently happens that some earlier\n+                    // error prevents types from being fully inferred, and then we get\n+                    // a bunch of uninteresting errors saying something like \"<generic\n+                    // #0> doesn't implement Sized\".  It may even be true that we\n+                    // could just skip over all checks where the self-ty is an\n+                    // inference variable, but I was afraid that there might be an\n+                    // inference variable created, registered as an obligation, and\n+                    // then never forced by writeback, and hence by skipping here we'd\n+                    // be ignoring the fact that we don't KNOW the type works\n+                    // out. Though even that would probably be harmless, given that\n+                    // we're only talking about builtin traits, which are known to be\n+                    // inhabited. But in any case I just threw in this check for\n+                    // has_errors() to be sure that compilation isn't happening\n+                    // anyway. In that case, why inundate the user.\n+                    if !self.tcx.sess.has_errors() {\n+                        if\n+                            self.tcx.lang_items.sized_trait()\n+                            .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n+                        {\n+                            self.need_type_info(obligation.cause.span, self_ty);\n+                        } else {\n+                            let mut err = struct_span_err!(self.tcx.sess,\n+                                                           obligation.cause.span, E0283,\n+                                                           \"type annotations required: \\\n+                                                            cannot resolve `{}`\",\n+                                                           predicate);\n+                            self.note_obligation_cause(&mut err, obligation);\n+                            err.emit();\n+                        }\n                     }\n                 }\n             }\n-        }\n \n-        ty::Predicate::WellFormed(ty) => {\n-            // Same hacky approach as above to avoid deluging user\n-            // with error messages.\n-            if !ty.references_error() && !infcx.tcx.sess.has_errors() {\n-                need_type_info(infcx, obligation.cause.span, ty);\n+            ty::Predicate::WellFormed(ty) => {\n+                // Same hacky approach as above to avoid deluging user\n+                // with error messages.\n+                if !ty.references_error() && !self.tcx.sess.has_errors() {\n+                    self.need_type_info(obligation.cause.span, ty);\n+                }\n             }\n-        }\n \n-        _ => {\n-            if !infcx.tcx.sess.has_errors() {\n-                let mut err = struct_span_err!(infcx.tcx.sess, obligation.cause.span, E0284,\n-                                               \"type annotations required: cannot resolve `{}`\",\n-                                               predicate);\n-                note_obligation_cause(infcx, &mut err, obligation);\n-                err.emit();\n+            _ => {\n+                if !self.tcx.sess.has_errors() {\n+                    let mut err = struct_span_err!(self.tcx.sess,\n+                                                   obligation.cause.span, E0284,\n+                                                   \"type annotations required: \\\n+                                                    cannot resolve `{}`\",\n+                                                   predicate);\n+                    self.note_obligation_cause(&mut err, obligation);\n+                    err.emit();\n+                }\n             }\n         }\n     }\n-}\n \n-/// Returns whether the trait predicate may apply for *some* assignment\n-/// to the type parameters.\n-fn predicate_can_apply<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                 pred: ty::PolyTraitRef<'tcx>)\n-                                 -> bool\n-{\n-    struct ParamToVarFolder<'a, 'tcx: 'a> {\n-        infcx: &'a InferCtxt<'a, 'tcx>,\n-        var_map: FnvHashMap<Ty<'tcx>, Ty<'tcx>>\n-    }\n+    /// Returns whether the trait predicate may apply for *some* assignment\n+    /// to the type parameters.\n+    fn predicate_can_apply(&self, pred: ty::PolyTraitRef<'tcx>) -> bool {\n+        struct ParamToVarFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+            infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+            var_map: FnvHashMap<Ty<'tcx>, Ty<'tcx>>\n+        }\n \n-    impl<'a, 'tcx> TypeFolder<'tcx> for ParamToVarFolder<'a, 'tcx>\n-    {\n-        fn tcx(&self) -> &TyCtxt<'tcx> { self.infcx.tcx }\n+        impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ParamToVarFolder<'a, 'gcx, 'tcx> {\n+            fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.infcx.tcx }\n \n-        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-            if let ty::TyParam(..) = ty.sty {\n-                let infcx = self.infcx;\n-                self.var_map.entry(ty).or_insert_with(|| infcx.next_ty_var())\n-            } else {\n-                ty.super_fold_with(self)\n+            fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+                if let ty::TyParam(..) = ty.sty {\n+                    let infcx = self.infcx;\n+                    self.var_map.entry(ty).or_insert_with(|| infcx.next_ty_var())\n+                } else {\n+                    ty.super_fold_with(self)\n+                }\n             }\n         }\n-    }\n \n-    infcx.probe(|_| {\n-        let mut selcx = SelectionContext::new(infcx);\n+        self.probe(|_| {\n+            let mut selcx = SelectionContext::new(self);\n \n-        let cleaned_pred = pred.fold_with(&mut ParamToVarFolder {\n-            infcx: infcx,\n-            var_map: FnvHashMap()\n-        });\n+            let cleaned_pred = pred.fold_with(&mut ParamToVarFolder {\n+                infcx: self,\n+                var_map: FnvHashMap()\n+            });\n \n-        let cleaned_pred = super::project::normalize(\n-            &mut selcx,\n-            ObligationCause::dummy(),\n-            &cleaned_pred\n-        ).value;\n+            let cleaned_pred = super::project::normalize(\n+                &mut selcx,\n+                ObligationCause::dummy(),\n+                &cleaned_pred\n+            ).value;\n \n-        let obligation = Obligation::new(\n-            ObligationCause::dummy(),\n-            cleaned_pred.to_predicate()\n-        );\n+            let obligation = Obligation::new(\n+                ObligationCause::dummy(),\n+                cleaned_pred.to_predicate()\n+            );\n \n-        selcx.evaluate_obligation(&obligation)\n-    })\n-}\n+            selcx.evaluate_obligation(&obligation)\n+        })\n+    }\n \n \n-fn need_type_info<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                            span: Span,\n-                            ty: Ty<'tcx>)\n-{\n-    span_err!(infcx.tcx.sess, span, E0282,\n-              \"unable to infer enough type information about `{}`; \\\n-               type annotations or generic parameter binding required\",\n-              ty);\n-}\n+    fn need_type_info(&self, span: Span, ty: Ty<'tcx>) {\n+        span_err!(self.tcx.sess, span, E0282,\n+                  \"unable to infer enough type information about `{}`; \\\n+                   type annotations or generic parameter binding required\",\n+                  ty);\n+    }\n \n-fn note_obligation_cause<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n-                                      err: &mut DiagnosticBuilder,\n-                                      obligation: &Obligation<'tcx, T>)\n-    where T: fmt::Display\n-{\n-    note_obligation_cause_code(infcx,\n-                               err,\n-                               &obligation.predicate,\n-                               &obligation.cause.code);\n-}\n+    fn note_obligation_cause<T>(&self,\n+                                err: &mut DiagnosticBuilder,\n+                                obligation: &Obligation<'tcx, T>)\n+        where T: fmt::Display\n+    {\n+        self.note_obligation_cause_code(err,\n+                                        &obligation.predicate,\n+                                        &obligation.cause.code);\n+    }\n \n-fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n-                                           err: &mut DiagnosticBuilder,\n-                                           predicate: &T,\n-                                           cause_code: &ObligationCauseCode<'tcx>)\n-    where T: fmt::Display\n-{\n-    let tcx = infcx.tcx;\n-    match *cause_code {\n-        ObligationCauseCode::MiscObligation => { }\n-        ObligationCauseCode::SliceOrArrayElem => {\n-            err.note(\"slice and array elements must have `Sized` type\");\n-        }\n-        ObligationCauseCode::TupleElem => {\n-            err.note(\"tuple elements must have `Sized` type\");\n-        }\n-        ObligationCauseCode::ProjectionWf(data) => {\n-            err.note(&format!(\"required so that the projection `{}` is well-formed\",\n-                              data));\n-        }\n-        ObligationCauseCode::ReferenceOutlivesReferent(ref_ty) => {\n-            err.note(&format!(\"required so that reference `{}` does not outlive its referent\",\n-                              ref_ty));\n-        }\n-        ObligationCauseCode::ItemObligation(item_def_id) => {\n-            let item_name = tcx.item_path_str(item_def_id);\n-            err.note(&format!(\"required by `{}`\", item_name));\n-        }\n-        ObligationCauseCode::ObjectCastObligation(object_ty) => {\n-            err.note(&format!(\"required for the cast to the object type `{}`\",\n-                              infcx.ty_to_string(object_ty)));\n-        }\n-        ObligationCauseCode::RepeatVec => {\n-            err.note(\"the `Copy` trait is required because the \\\n-                      repeated element will be copied\");\n-        }\n-        ObligationCauseCode::VariableType(_) => {\n-            err.note(\"all local variables must have a statically known size\");\n-        }\n-        ObligationCauseCode::ReturnType => {\n-            err.note(\"the return type of a function must have a \\\n-                      statically known size\");\n-        }\n-        ObligationCauseCode::AssignmentLhsSized => {\n-            err.note(\"the left-hand-side of an assignment must have a statically known size\");\n-        }\n-        ObligationCauseCode::StructInitializerSized => {\n-            err.note(\"structs must have a statically known size to be initialized\");\n-        }\n-        ObligationCauseCode::ClosureCapture(var_id, _, builtin_bound) => {\n-            let def_id = tcx.lang_items.from_builtin_kind(builtin_bound).unwrap();\n-            let trait_name = tcx.item_path_str(def_id);\n-            let name = tcx.local_var_name_str(var_id);\n-            err.note(\n-                &format!(\"the closure that captures `{}` requires that all captured variables \\\n-                          implement the trait `{}`\",\n-                         name,\n-                         trait_name));\n-        }\n-        ObligationCauseCode::FieldSized => {\n-            err.note(\"only the last field of a struct or enum variant \\\n-                      may have a dynamically sized type\");\n-        }\n-        ObligationCauseCode::SharedStatic => {\n-            err.note(\"shared static variables must have a type that implements `Sync`\");\n-        }\n-        ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n-            let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n-            err.note(&format!(\"required because it appears within the type `{}`\",\n-                              parent_trait_ref.0.self_ty()));\n-            let parent_predicate = parent_trait_ref.to_predicate();\n-            note_obligation_cause_code(infcx,\n-                                       err,\n-                                       &parent_predicate,\n-                                       &data.parent_code);\n-        }\n-        ObligationCauseCode::ImplDerivedObligation(ref data) => {\n-            let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n-            err.note(\n-                &format!(\"required because of the requirements on the impl of `{}` for `{}`\",\n-                         parent_trait_ref,\n-                         parent_trait_ref.0.self_ty()));\n-            let parent_predicate = parent_trait_ref.to_predicate();\n-            note_obligation_cause_code(infcx,\n-                                       err,\n-                                       &parent_predicate,\n-                                       &data.parent_code);\n-        }\n-        ObligationCauseCode::CompareImplMethodObligation => {\n-            err.note(\n-                &format!(\"the requirement `{}` appears on the impl method \\\n-                          but not on the corresponding trait method\",\n-                         predicate));\n+    fn note_obligation_cause_code<T>(&self,\n+                                     err: &mut DiagnosticBuilder,\n+                                     predicate: &T,\n+                                     cause_code: &ObligationCauseCode<'tcx>)\n+        where T: fmt::Display\n+    {\n+        let tcx = self.tcx;\n+        match *cause_code {\n+            ObligationCauseCode::MiscObligation => { }\n+            ObligationCauseCode::SliceOrArrayElem => {\n+                err.note(\"slice and array elements must have `Sized` type\");\n+            }\n+            ObligationCauseCode::TupleElem => {\n+                err.note(\"tuple elements must have `Sized` type\");\n+            }\n+            ObligationCauseCode::ProjectionWf(data) => {\n+                err.note(&format!(\"required so that the projection `{}` is well-formed\",\n+                                  data));\n+            }\n+            ObligationCauseCode::ReferenceOutlivesReferent(ref_ty) => {\n+                err.note(&format!(\"required so that reference `{}` does not outlive its referent\",\n+                                  ref_ty));\n+            }\n+            ObligationCauseCode::ItemObligation(item_def_id) => {\n+                let item_name = tcx.item_path_str(item_def_id);\n+                err.note(&format!(\"required by `{}`\", item_name));\n+            }\n+            ObligationCauseCode::ObjectCastObligation(object_ty) => {\n+                err.note(&format!(\"required for the cast to the object type `{}`\",\n+                                  self.ty_to_string(object_ty)));\n+            }\n+            ObligationCauseCode::RepeatVec => {\n+                err.note(\"the `Copy` trait is required because the \\\n+                          repeated element will be copied\");\n+            }\n+            ObligationCauseCode::VariableType(_) => {\n+                err.note(\"all local variables must have a statically known size\");\n+            }\n+            ObligationCauseCode::ReturnType => {\n+                err.note(\"the return type of a function must have a \\\n+                          statically known size\");\n+            }\n+            ObligationCauseCode::AssignmentLhsSized => {\n+                err.note(\"the left-hand-side of an assignment must have a statically known size\");\n+            }\n+            ObligationCauseCode::StructInitializerSized => {\n+                err.note(\"structs must have a statically known size to be initialized\");\n+            }\n+            ObligationCauseCode::ClosureCapture(var_id, _, builtin_bound) => {\n+                let def_id = tcx.lang_items.from_builtin_kind(builtin_bound).unwrap();\n+                let trait_name = tcx.item_path_str(def_id);\n+                let name = tcx.local_var_name_str(var_id);\n+                err.note(\n+                    &format!(\"the closure that captures `{}` requires that all captured variables \\\n+                              implement the trait `{}`\",\n+                             name,\n+                             trait_name));\n+            }\n+            ObligationCauseCode::FieldSized => {\n+                err.note(\"only the last field of a struct or enum variant \\\n+                          may have a dynamically sized type\");\n+            }\n+            ObligationCauseCode::SharedStatic => {\n+                err.note(\"shared static variables must have a type that implements `Sync`\");\n+            }\n+            ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n+                let parent_trait_ref = self.resolve_type_vars_if_possible(&data.parent_trait_ref);\n+                err.note(&format!(\"required because it appears within the type `{}`\",\n+                                  parent_trait_ref.0.self_ty()));\n+                let parent_predicate = parent_trait_ref.to_predicate();\n+                self.note_obligation_cause_code(err,\n+                                                &parent_predicate,\n+                                                &data.parent_code);\n+            }\n+            ObligationCauseCode::ImplDerivedObligation(ref data) => {\n+                let parent_trait_ref = self.resolve_type_vars_if_possible(&data.parent_trait_ref);\n+                err.note(\n+                    &format!(\"required because of the requirements on the impl of `{}` for `{}`\",\n+                             parent_trait_ref,\n+                             parent_trait_ref.0.self_ty()));\n+                let parent_predicate = parent_trait_ref.to_predicate();\n+                self.note_obligation_cause_code(err,\n+                                                &parent_predicate,\n+                                                &data.parent_code);\n+            }\n+            ObligationCauseCode::CompareImplMethodObligation => {\n+                err.note(\n+                    &format!(\"the requirement `{}` appears on the impl method \\\n+                              but not on the corresponding trait method\",\n+                             predicate));\n+            }\n         }\n     }\n-}\n \n-fn suggest_new_overflow_limit(tcx: &TyCtxt, err:&mut DiagnosticBuilder) {\n-    let current_limit = tcx.sess.recursion_limit.get();\n-    let suggested_limit = current_limit * 2;\n-    err.note(&format!(\n-                      \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n-                      suggested_limit));\n+    fn suggest_new_overflow_limit(&self, err: &mut DiagnosticBuilder) {\n+        let current_limit = self.tcx.sess.recursion_limit.get();\n+        let suggested_limit = current_limit * 2;\n+        err.note(&format!(\n+                          \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n+                          suggested_limit));\n+    }\n }"}, {"sha": "756318f8d9252a43e96ab5765116b52183c165d9", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -21,16 +21,13 @@ use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n use super::CodeSelectionError;\n-use super::is_object_safe;\n use super::FulfillmentError;\n use super::FulfillmentErrorCode;\n use super::ObligationCause;\n use super::PredicateObligation;\n use super::project;\n-use super::report_overflow_error_cycle;\n use super::select::SelectionContext;\n use super::Unimplemented;\n-use super::util::predicate_for_builtin_bound;\n \n pub struct GlobalFulfilledPredicates<'tcx> {\n     set: FnvHashSet<ty::PolyTraitPredicate<'tcx>>,\n@@ -114,7 +111,7 @@ pub struct PendingPredicateObligation<'tcx> {\n     pub stalled_on: Vec<Ty<'tcx>>,\n }\n \n-impl<'tcx> FulfillmentContext<'tcx> {\n+impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     /// Creates a new fulfillment context.\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n@@ -132,11 +129,11 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     /// `SomeTrait` or a where clause that lets us unify `$0` with\n     /// something concrete. If this fails, we'll unify `$0` with\n     /// `projection_ty` again.\n-    pub fn normalize_projection_type<'a>(&mut self,\n-                                         infcx: &InferCtxt<'a,'tcx>,\n-                                         projection_ty: ty::ProjectionTy<'tcx>,\n-                                         cause: ObligationCause<'tcx>)\n-                                         -> Ty<'tcx>\n+    pub fn normalize_projection_type(&mut self,\n+                                     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                     projection_ty: ty::ProjectionTy<'tcx>,\n+                                     cause: ObligationCause<'tcx>)\n+                                     -> Ty<'tcx>\n     {\n         debug!(\"normalize_projection_type(projection_ty={:?})\",\n                projection_ty);\n@@ -157,31 +154,31 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         normalized.value\n     }\n \n-    pub fn register_builtin_bound<'a>(&mut self,\n-                                      infcx: &InferCtxt<'a,'tcx>,\n-                                      ty: Ty<'tcx>,\n-                                      builtin_bound: ty::BuiltinBound,\n-                                      cause: ObligationCause<'tcx>)\n+    pub fn register_builtin_bound(&mut self,\n+                                  infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                  ty: Ty<'tcx>,\n+                                  builtin_bound: ty::BuiltinBound,\n+                                  cause: ObligationCause<'tcx>)\n     {\n-        match predicate_for_builtin_bound(infcx.tcx, cause, builtin_bound, 0, ty) {\n+        match infcx.tcx.predicate_for_builtin_bound(cause, builtin_bound, 0, ty) {\n             Ok(predicate) => {\n                 self.register_predicate_obligation(infcx, predicate);\n             }\n             Err(ErrorReported) => { }\n         }\n     }\n \n-    pub fn register_region_obligation<'a>(&mut self,\n-                                          t_a: Ty<'tcx>,\n-                                          r_b: ty::Region,\n-                                          cause: ObligationCause<'tcx>)\n+    pub fn register_region_obligation(&mut self,\n+                                      t_a: Ty<'tcx>,\n+                                      r_b: ty::Region,\n+                                      cause: ObligationCause<'tcx>)\n     {\n         register_region_obligation(t_a, r_b, cause, &mut self.region_obligations);\n     }\n \n-    pub fn register_predicate_obligation<'a>(&mut self,\n-                                             infcx: &InferCtxt<'a,'tcx>,\n-                                             obligation: PredicateObligation<'tcx>)\n+    pub fn register_predicate_obligation(&mut self,\n+                                         infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                         obligation: PredicateObligation<'tcx>)\n     {\n         // this helps to reduce duplicate errors, as well as making\n         // debug output much nicer to read and so on.\n@@ -202,9 +199,9 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         self.predicates.push_tree(obligation, LocalFulfilledPredicates::new());\n     }\n \n-    pub fn register_rfc1592_obligation<'a>(&mut self,\n-                                           _infcx: &InferCtxt<'a,'tcx>,\n-                                           obligation: PredicateObligation<'tcx>)\n+    pub fn register_rfc1592_obligation(&mut self,\n+                                       _infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                       obligation: PredicateObligation<'tcx>)\n     {\n         self.rfc1592_obligations.push(obligation);\n     }\n@@ -219,8 +216,8 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         }\n     }\n \n-    pub fn select_rfc1592_obligations<'a>(&mut self,\n-                                      infcx: &InferCtxt<'a,'tcx>)\n+    pub fn select_rfc1592_obligations(&mut self,\n+                                      infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n                                       -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         while !self.rfc1592_obligations.is_empty() {\n@@ -233,9 +230,10 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n         Ok(())\n     }\n-    pub fn select_all_or_error<'a>(&mut self,\n-                                   infcx: &InferCtxt<'a,'tcx>)\n-                                   -> Result<(),Vec<FulfillmentError<'tcx>>>\n+\n+    pub fn select_all_or_error(&mut self,\n+                               infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n+                               -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         self.select_where_possible(infcx)?;\n \n@@ -251,9 +249,9 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         }\n     }\n \n-    pub fn select_where_possible<'a>(&mut self,\n-                                     infcx: &InferCtxt<'a,'tcx>)\n-                                     -> Result<(),Vec<FulfillmentError<'tcx>>>\n+    pub fn select_where_possible(&mut self,\n+                                 infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n+                                 -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         let mut selcx = SelectionContext::new(infcx);\n         self.select(&mut selcx)\n@@ -263,8 +261,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         self.predicates.pending_obligations()\n     }\n \n-    fn is_duplicate_or_add(&mut self,\n-                           tcx: &TyCtxt<'tcx>,\n+    fn is_duplicate_or_add(&mut self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                            predicate: &ty::Predicate<'tcx>)\n                            -> bool {\n         // For \"global\" predicates -- that is, predicates that don't\n@@ -292,10 +289,8 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n     /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n     /// only attempts to select obligations that haven't been seen before.\n-    fn select<'a>(&mut self,\n-                  selcx: &mut SelectionContext<'a, 'tcx>)\n-                  -> Result<(),Vec<FulfillmentError<'tcx>>>\n-    {\n+    fn select(&mut self, selcx: &mut SelectionContext<'a, 'gcx, 'tcx>)\n+              -> Result<(),Vec<FulfillmentError<'tcx>>> {\n         debug!(\"select(obligation-forest-size={})\", self.predicates.len());\n \n         let mut errors = Vec::new();\n@@ -321,7 +316,8 @@ impl<'tcx> FulfillmentContext<'tcx> {\n             // these are obligations that were proven to be true.\n             for pending_obligation in outcome.completed {\n                 let predicate = &pending_obligation.obligation.predicate;\n-                selcx.tcx().fulfilled_predicates.borrow_mut().add_if_global(predicate);\n+                selcx.tcx().fulfilled_predicates.borrow_mut()\n+                           .add_if_global(selcx.tcx(), predicate);\n             }\n \n             errors.extend(\n@@ -346,14 +342,15 @@ impl<'tcx> FulfillmentContext<'tcx> {\n }\n \n /// Like `process_predicate1`, but wrap result into a pending predicate.\n-fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n-                              tree_cache: &mut LocalFulfilledPredicates<'tcx>,\n-                              pending_obligation: &mut PendingPredicateObligation<'tcx>,\n-                              backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n-                              region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>,\n-                              rfc1592_obligations: &mut Vec<PredicateObligation<'tcx>>)\n-                              -> Result<Option<Vec<PendingPredicateObligation<'tcx>>>,\n-                                        FulfillmentErrorCode<'tcx>>\n+fn process_predicate<'a, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n+    tree_cache: &mut LocalFulfilledPredicates<'tcx>,\n+    pending_obligation: &mut PendingPredicateObligation<'tcx>,\n+    backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n+    region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>,\n+    rfc1592_obligations: &mut Vec<PredicateObligation<'tcx>>)\n+    -> Result<Option<Vec<PendingPredicateObligation<'tcx>>>,\n+              FulfillmentErrorCode<'tcx>>\n {\n     match process_predicate1(selcx, pending_obligation, region_obligations,\n                              rfc1592_obligations) {\n@@ -367,8 +364,8 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n     }\n }\n \n-fn process_child_obligations<'a,'tcx>(\n-    selcx: &mut SelectionContext<'a,'tcx>,\n+fn process_child_obligations<'a, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n     tree_cache: &mut LocalFulfilledPredicates<'tcx>,\n     pending_obligation: &PredicateObligation<'tcx>,\n     backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n@@ -449,7 +446,7 @@ fn process_child_obligations<'a,'tcx>(\n                     debug!(\"process_child_obligations: coinductive match\");\n                     None\n                 } else {\n-                    report_overflow_error_cycle(selcx.infcx(), &cycle);\n+                    selcx.infcx().report_overflow_error_cycle(&cycle);\n                 }\n             } else {\n                 // Not a cycle. Just ignore this obligation then,\n@@ -469,7 +466,7 @@ struct AncestorSet<'b, 'tcx: 'b> {\n     backtrace: Backtrace<'b, PendingPredicateObligation<'tcx>>,\n }\n \n-impl<'b, 'tcx> AncestorSet<'b, 'tcx> {\n+impl<'a, 'b, 'gcx, 'tcx> AncestorSet<'b, 'tcx> {\n     fn new(backtrace: &Backtrace<'b, PendingPredicateObligation<'tcx>>) -> Self {\n         AncestorSet {\n             populated: false,\n@@ -482,10 +479,10 @@ impl<'b, 'tcx> AncestorSet<'b, 'tcx> {\n     /// to `predicate` (`predicate` is assumed to be fully\n     /// type-resolved).  Returns `None` if not; otherwise, returns\n     /// `Some` with the index within the backtrace.\n-    fn has<'a>(&mut self,\n-               infcx: &InferCtxt<'a, 'tcx>,\n-               predicate: &ty::Predicate<'tcx>)\n-               -> Option<usize> {\n+    fn has(&mut self,\n+           infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+           predicate: &ty::Predicate<'tcx>)\n+           -> Option<usize> {\n         // the first time, we have to populate the cache\n         if !self.populated {\n             let backtrace = self.backtrace.clone();\n@@ -519,8 +516,8 @@ impl<'b, 'tcx> AncestorSet<'b, 'tcx> {\n }\n \n /// Return the set of type variables contained in a trait ref\n-fn trait_ref_type_vars<'a, 'tcx>(selcx: &mut SelectionContext<'a, 'tcx>,\n-                                 t: ty::PolyTraitRef<'tcx>) -> Vec<Ty<'tcx>>\n+fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n+                                       t: ty::PolyTraitRef<'tcx>) -> Vec<Ty<'tcx>>\n {\n     t.skip_binder() // ok b/c this check doesn't care about regions\n      .input_types()\n@@ -536,12 +533,13 @@ fn trait_ref_type_vars<'a, 'tcx>(selcx: &mut SelectionContext<'a, 'tcx>,\n /// - `Ok(Some(v))` if the predicate is true, presuming that `v` are also true\n /// - `Ok(None)` if we don't have enough info to be sure\n /// - `Err` if the predicate does not hold\n-fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n-                               pending_obligation: &mut PendingPredicateObligation<'tcx>,\n-                               region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>,\n-                               rfc1592_obligations: &mut Vec<PredicateObligation<'tcx>>)\n-                               -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n-                                         FulfillmentErrorCode<'tcx>>\n+fn process_predicate1<'a, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n+    pending_obligation: &mut PendingPredicateObligation<'tcx>,\n+    region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>,\n+    rfc1592_obligations: &mut Vec<PredicateObligation<'tcx>>)\n+    -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n+              FulfillmentErrorCode<'tcx>>\n {\n     // if we were stalled on some unresolved variables, first check\n     // whether any of them have been resolved; if not, don't bother\n@@ -677,7 +675,7 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n         }\n \n         ty::Predicate::ObjectSafe(trait_def_id) => {\n-            if !is_object_safe(selcx.tcx(), trait_def_id) {\n+            if !selcx.tcx().is_object_safe(trait_def_id) {\n                 Err(CodeSelectionError(Unimplemented))\n             } else {\n                 Ok(Some(Vec::new()))\n@@ -727,9 +725,9 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n /// - it also appears in the backtrace at some position `X`; and,\n /// - all the predicates at positions `X..` between `X` an the top are\n ///   also defaulted traits.\n-fn coinductive_match<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n-                              cycle: &[PredicateObligation<'tcx>])\n-                              -> bool\n+fn coinductive_match<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n+                                     cycle: &[PredicateObligation<'tcx>])\n+                                     -> bool\n {\n     let len = cycle.len();\n \n@@ -745,9 +743,9 @@ fn coinductive_match<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n         })\n }\n \n-fn coinductive_obligation<'a, 'tcx>(selcx: &SelectionContext<'a, 'tcx>,\n-                                    obligation: &PredicateObligation<'tcx>)\n-                                    -> bool {\n+fn coinductive_obligation<'a, 'gcx, 'tcx>(selcx: &SelectionContext<'a, 'gcx, 'tcx>,\n+                                          obligation: &PredicateObligation<'tcx>)\n+                                          -> bool {\n     match obligation.predicate {\n         ty::Predicate::Trait(ref data) => {\n             selcx.tcx().trait_has_default_impl(data.def_id())\n@@ -795,8 +793,8 @@ impl<'tcx> LocalFulfilledPredicates<'tcx> {\n     }\n }\n \n-impl<'tcx> GlobalFulfilledPredicates<'tcx> {\n-    pub fn new(dep_graph: DepGraph) -> GlobalFulfilledPredicates<'tcx> {\n+impl<'a, 'gcx, 'tcx> GlobalFulfilledPredicates<'gcx> {\n+    pub fn new(dep_graph: DepGraph) -> GlobalFulfilledPredicates<'gcx> {\n         GlobalFulfilledPredicates {\n             set: FnvHashSet(),\n             dep_graph: dep_graph,\n@@ -827,15 +825,17 @@ impl<'tcx> GlobalFulfilledPredicates<'tcx> {\n         }\n     }\n \n-    fn add_if_global(&mut self, key: &ty::Predicate<'tcx>) {\n+    fn add_if_global(&mut self, tcx: TyCtxt<'a, 'gcx, 'tcx>, key: &ty::Predicate<'tcx>) {\n         if let ty::Predicate::Trait(ref data) = *key {\n             // We only add things to the global predicate registry\n             // after the current task has proved them, and hence\n             // already has the required read edges, so we don't need\n             // to add any more edges here.\n             if data.is_global() {\n-                if self.set.insert(data.clone()) {\n-                    debug!(\"add_if_global: global predicate `{:?}` added\", data);\n+                if let Some(data) = tcx.lift_to_global(data) {\n+                    if self.set.insert(data.clone()) {\n+                        debug!(\"add_if_global: global predicate `{:?}` added\", data);\n+                    }\n                 }\n             }\n         }"}, {"sha": "f606d73a5493f9f62469d40f5fdfd046795d1339", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 56, "deletions": 68, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -18,47 +18,32 @@ pub use self::ObligationCauseCode::*;\n use hir::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n use ty::subst;\n-use ty::{self, Ty, TypeFoldable};\n-use infer::{self, fixup_err_to_string, InferCtxt};\n+use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use infer::InferCtxt;\n \n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n \n pub use self::error_reporting::TraitErrorKey;\n-pub use self::error_reporting::recursive_type_with_infinite_size_error;\n-pub use self::error_reporting::report_fulfillment_errors;\n-pub use self::error_reporting::report_fulfillment_errors_as_warnings;\n-pub use self::error_reporting::report_overflow_error;\n-pub use self::error_reporting::report_overflow_error_cycle;\n-pub use self::error_reporting::report_selection_error;\n-pub use self::error_reporting::report_object_safety_error;\n pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;\n pub use self::fulfill::{FulfillmentContext, GlobalFulfilledPredicates, RegionObligation};\n pub use self::project::{MismatchedProjectionTypes, ProjectionMode};\n pub use self::project::{normalize, Normalized};\n-pub use self::object_safety::is_object_safe;\n-pub use self::object_safety::astconv_object_safety_violations;\n-pub use self::object_safety::object_safety_violations;\n pub use self::object_safety::ObjectSafetyViolation;\n pub use self::object_safety::MethodViolationCode;\n-pub use self::object_safety::is_vtable_safe_method;\n pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n pub use self::select::{MethodMatchedData}; // intentionally don't export variants\n-pub use self::specialize::{Overlap, specialization_graph, specializes, translate_substs};\n+pub use self::specialize::{OverlapError, specialization_graph, specializes, translate_substs};\n pub use self::util::elaborate_predicates;\n-pub use self::util::get_vtable_index_of_object_method;\n-pub use self::util::trait_ref_for_builtin_bound;\n-pub use self::util::predicate_for_trait_def;\n pub use self::util::supertraits;\n pub use self::util::Supertraits;\n pub use self::util::supertrait_def_ids;\n pub use self::util::SupertraitDefIds;\n pub use self::util::transitive_bounds;\n-pub use self::util::upcast;\n \n mod coherence;\n mod error_reporting;\n@@ -331,19 +316,19 @@ pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n /// `bound` or is not known to meet bound (note that this is\n /// conservative towards *no impl*, which is the opposite of the\n /// `evaluate` methods).\n-pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                                                 ty: Ty<'tcx>,\n-                                                 bound: ty::BuiltinBound,\n-                                                 span: Span)\n-                                                 -> bool\n+pub fn type_known_to_meet_builtin_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                                        ty: Ty<'tcx>,\n+                                                        bound: ty::BuiltinBound,\n+                                                        span: Span)\n+                                                        -> bool\n {\n     debug!(\"type_known_to_meet_builtin_bound(ty={:?}, bound={:?})\",\n            ty,\n            bound);\n \n     let cause = ObligationCause::misc(span, ast::DUMMY_NODE_ID);\n     let obligation =\n-        util::predicate_for_builtin_bound(infcx.tcx, cause, bound, 0, ty);\n+        infcx.tcx.predicate_for_builtin_bound(cause, bound, 0, ty);\n     let obligation = match obligation {\n         Ok(o) => o,\n         Err(..) => return false\n@@ -393,9 +378,10 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n \n // FIXME: this is gonna need to be removed ...\n /// Normalizes the parameter environment, reporting errors if they occur.\n-pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvironment<'a,'tcx>,\n-                                             cause: ObligationCause<'tcx>)\n-                                             -> ty::ParameterEnvironment<'a,'tcx>\n+pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    unnormalized_env: ty::ParameterEnvironment<'tcx>,\n+    cause: ObligationCause<'tcx>)\n+    -> ty::ParameterEnvironment<'tcx>\n {\n     // I'm not wild about reporting errors here; I'd prefer to\n     // have the errors get reported at a defined place (e.g.,\n@@ -412,7 +398,6 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n     // and errors will get reported then; so after typeck we\n     // can be sure that no errors should occur.\n \n-    let tcx = unnormalized_env.tcx;\n     let span = cause.span;\n     let body_id = cause.body_id;\n \n@@ -437,51 +422,54 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n \n     let elaborated_env = unnormalized_env.with_caller_bounds(predicates);\n \n-    let infcx = infer::new_infer_ctxt(tcx,\n-                                      &tcx.tables,\n-                                      Some(elaborated_env),\n-                                      ProjectionMode::AnyFinal);\n-    let predicates = match fully_normalize(&infcx,\n-                                           cause,\n-                                           &infcx.parameter_environment.caller_bounds) {\n-        Ok(predicates) => predicates,\n-        Err(errors) => {\n-            report_fulfillment_errors(&infcx, &errors);\n-            return infcx.parameter_environment; // an unnormalized env is better than nothing\n-        }\n-    };\n-\n-    debug!(\"normalize_param_env_or_error: normalized predicates={:?}\",\n-           predicates);\n+    tcx.infer_ctxt(None, Some(elaborated_env), ProjectionMode::AnyFinal).enter(|infcx| {\n+        let predicates = match fully_normalize(&infcx, cause,\n+                                               &infcx.parameter_environment.caller_bounds) {\n+            Ok(predicates) => predicates,\n+            Err(errors) => {\n+                infcx.report_fulfillment_errors(&errors);\n+                // An unnormalized env is better than nothing.\n+                return infcx.parameter_environment;\n+            }\n+        };\n+\n+        debug!(\"normalize_param_env_or_error: normalized predicates={:?}\",\n+            predicates);\n+\n+        let free_regions = FreeRegionMap::new();\n+        infcx.resolve_regions_and_report_errors(&free_regions, body_id);\n+        let predicates = match infcx.fully_resolve(&predicates) {\n+            Ok(predicates) => predicates,\n+            Err(fixup_err) => {\n+                // If we encounter a fixup error, it means that some type\n+                // variable wound up unconstrained. I actually don't know\n+                // if this can happen, and I certainly don't expect it to\n+                // happen often, but if it did happen it probably\n+                // represents a legitimate failure due to some kind of\n+                // unconstrained variable, and it seems better not to ICE,\n+                // all things considered.\n+                tcx.sess.span_err(span, &fixup_err.to_string());\n+                // An unnormalized env is better than nothing.\n+                return infcx.parameter_environment;\n+            }\n+        };\n \n-    let free_regions = FreeRegionMap::new();\n-    infcx.resolve_regions_and_report_errors(&free_regions, body_id);\n-    let predicates = match infcx.fully_resolve(&predicates) {\n-        Ok(predicates) => predicates,\n-        Err(fixup_err) => {\n-            // If we encounter a fixup error, it means that some type\n-            // variable wound up unconstrained. I actually don't know\n-            // if this can happen, and I certainly don't expect it to\n-            // happen often, but if it did happen it probably\n-            // represents a legitimate failure due to some kind of\n-            // unconstrained variable, and it seems better not to ICE,\n-            // all things considered.\n-            let err_msg = fixup_err_to_string(fixup_err);\n-            tcx.sess.span_err(span, &err_msg);\n-            return infcx.parameter_environment; // an unnormalized env is better than nothing\n-        }\n-    };\n+        let predicates = match tcx.lift_to_global(&predicates) {\n+            Some(predicates) => predicates,\n+            None => return infcx.parameter_environment\n+        };\n \n-    debug!(\"normalize_param_env_or_error: resolved predicates={:?}\",\n-           predicates);\n+        debug!(\"normalize_param_env_or_error: resolved predicates={:?}\",\n+            predicates);\n \n-    infcx.parameter_environment.with_caller_bounds(predicates)\n+        infcx.parameter_environment.with_caller_bounds(predicates)\n+    })\n }\n \n-pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n-                                  cause: ObligationCause<'tcx>,\n-                                  value: &T)\n-                                  -> Result<T, Vec<FulfillmentError<'tcx>>>\n+pub fn fully_normalize<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                          cause: ObligationCause<'tcx>,\n+                                          value: &T)\n+                                          -> Result<T, Vec<FulfillmentError<'tcx>>>\n     where T : TypeFoldable<'tcx>\n {\n     debug!(\"fully_normalize(value={:?})\", value);"}, {"sha": "8cafa779739090236b47f55c97eae1aefb6af89e", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 278, "deletions": 288, "changes": 566, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -53,331 +53,321 @@ pub enum MethodViolationCode {\n     Generic,\n }\n \n-pub fn is_object_safe<'tcx>(tcx: &TyCtxt<'tcx>,\n-                            trait_def_id: DefId)\n-                            -> bool\n-{\n-    // Because we query yes/no results frequently, we keep a cache:\n-    let def = tcx.lookup_trait_def(trait_def_id);\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    pub fn is_object_safe(self, trait_def_id: DefId) -> bool {\n+        // Because we query yes/no results frequently, we keep a cache:\n+        let def = self.lookup_trait_def(trait_def_id);\n \n-    let result = def.object_safety().unwrap_or_else(|| {\n-        let result = object_safety_violations(tcx, trait_def_id).is_empty();\n+        let result = def.object_safety().unwrap_or_else(|| {\n+            let result = self.object_safety_violations(trait_def_id).is_empty();\n \n-        // Record just a yes/no result in the cache; this is what is\n-        // queried most frequently. Note that this may overwrite a\n-        // previous result, but always with the same thing.\n-        def.set_object_safety(result);\n+            // Record just a yes/no result in the cache; this is what is\n+            // queried most frequently. Note that this may overwrite a\n+            // previous result, but always with the same thing.\n+            def.set_object_safety(result);\n \n-        result\n-    });\n-\n-    debug!(\"is_object_safe({:?}) = {}\", trait_def_id, result);\n+            result\n+        });\n \n-    result\n-}\n+        debug!(\"is_object_safe({:?}) = {}\", trait_def_id, result);\n \n-/// Returns the object safety violations that affect\n-/// astconv - currently, Self in supertraits. This is needed\n-/// because `object_safety_violations` can't be used during\n-/// type collection.\n-pub fn astconv_object_safety_violations<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                              trait_def_id: DefId)\n-                                              -> Vec<ObjectSafetyViolation<'tcx>>\n-{\n-    let mut violations = vec![];\n-\n-    if supertraits_reference_self(tcx, trait_def_id) {\n-        violations.push(ObjectSafetyViolation::SupertraitSelf);\n+        result\n     }\n \n-    debug!(\"object_safety_violations_for_trait(trait_def_id={:?}) = {:?}\",\n-           trait_def_id,\n-           violations);\n-\n-    violations\n-}\n+    /// Returns the object safety violations that affect\n+    /// astconv - currently, Self in supertraits. This is needed\n+    /// because `object_safety_violations` can't be used during\n+    /// type collection.\n+    pub fn astconv_object_safety_violations(self, trait_def_id: DefId)\n+                                            -> Vec<ObjectSafetyViolation<'tcx>>\n+    {\n+        let mut violations = vec![];\n \n-pub fn object_safety_violations<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                      trait_def_id: DefId)\n-                                      -> Vec<ObjectSafetyViolation<'tcx>>\n-{\n-    traits::supertrait_def_ids(tcx, trait_def_id)\n-        .flat_map(|def_id| object_safety_violations_for_trait(tcx, def_id))\n-        .collect()\n-}\n+        if self.supertraits_reference_self(trait_def_id) {\n+            violations.push(ObjectSafetyViolation::SupertraitSelf);\n+        }\n \n-fn object_safety_violations_for_trait<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                            trait_def_id: DefId)\n-                                            -> Vec<ObjectSafetyViolation<'tcx>>\n-{\n-    // Check methods for violations.\n-    let mut violations: Vec<_> =\n-        tcx.trait_items(trait_def_id).iter()\n-        .filter_map(|item| {\n-            match *item {\n-                ty::MethodTraitItem(ref m) => {\n-                    object_safety_violation_for_method(tcx, trait_def_id, &m)\n-                        .map(|code| ObjectSafetyViolation::Method(m.clone(), code))\n-                }\n-                _ => None,\n-            }\n-        })\n-        .collect();\n+        debug!(\"astconv_object_safety_violations(trait_def_id={:?}) = {:?}\",\n+               trait_def_id,\n+               violations);\n \n-    // Check the trait itself.\n-    if trait_has_sized_self(tcx, trait_def_id) {\n-        violations.push(ObjectSafetyViolation::SizedSelf);\n+        violations\n     }\n-    if supertraits_reference_self(tcx, trait_def_id) {\n-        violations.push(ObjectSafetyViolation::SupertraitSelf);\n+\n+    pub fn object_safety_violations(self, trait_def_id: DefId)\n+                                    -> Vec<ObjectSafetyViolation<'tcx>>\n+    {\n+        traits::supertrait_def_ids(self, trait_def_id)\n+            .flat_map(|def_id| self.object_safety_violations_for_trait(def_id))\n+            .collect()\n     }\n \n-    debug!(\"object_safety_violations_for_trait(trait_def_id={:?}) = {:?}\",\n-           trait_def_id,\n-           violations);\n+    fn object_safety_violations_for_trait(self, trait_def_id: DefId)\n+                                          -> Vec<ObjectSafetyViolation<'tcx>>\n+    {\n+        // Check methods for violations.\n+        let mut violations: Vec<_> =\n+            self.trait_items(trait_def_id).iter()\n+            .filter_map(|item| {\n+                match *item {\n+                    ty::MethodTraitItem(ref m) => {\n+                        self.object_safety_violation_for_method(trait_def_id, &m)\n+                            .map(|code| ObjectSafetyViolation::Method(m.clone(), code))\n+                    }\n+                    _ => None,\n+                }\n+            })\n+            .collect();\n \n-    violations\n-}\n+        // Check the trait itself.\n+        if self.trait_has_sized_self(trait_def_id) {\n+            violations.push(ObjectSafetyViolation::SizedSelf);\n+        }\n+        if self.supertraits_reference_self(trait_def_id) {\n+            violations.push(ObjectSafetyViolation::SupertraitSelf);\n+        }\n \n-pub fn supertraits_reference_self<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                        trait_def_id: DefId)\n-                                        -> bool\n-{\n-    let trait_def = tcx.lookup_trait_def(trait_def_id);\n-    let trait_ref = trait_def.trait_ref.clone();\n-    let trait_ref = trait_ref.to_poly_trait_ref();\n-    let predicates = tcx.lookup_super_predicates(trait_def_id);\n-    predicates\n-        .predicates\n-        .into_iter()\n-        .map(|predicate| predicate.subst_supertrait(tcx, &trait_ref))\n-        .any(|predicate| {\n-            match predicate {\n-                ty::Predicate::Trait(ref data) => {\n-                    // In the case of a trait predicate, we can skip the \"self\" type.\n-                    data.0.trait_ref.substs.types.get_slice(TypeSpace)\n-                                                 .iter()\n-                                                 .cloned()\n-                                                 .any(|t| t.has_self_ty())\n-                }\n-                ty::Predicate::Projection(..) |\n-                ty::Predicate::WellFormed(..) |\n-                ty::Predicate::ObjectSafe(..) |\n-                ty::Predicate::TypeOutlives(..) |\n-                ty::Predicate::RegionOutlives(..) |\n-                ty::Predicate::ClosureKind(..) |\n-                ty::Predicate::Rfc1592(..) |\n-                ty::Predicate::Equate(..) => {\n-                    false\n-                }\n-            }\n-        })\n-}\n+        debug!(\"object_safety_violations_for_trait(trait_def_id={:?}) = {:?}\",\n+               trait_def_id,\n+               violations);\n \n-fn trait_has_sized_self<'tcx>(tcx: &TyCtxt<'tcx>,\n-                              trait_def_id: DefId)\n-                              -> bool\n-{\n-    let trait_def = tcx.lookup_trait_def(trait_def_id);\n-    let trait_predicates = tcx.lookup_predicates(trait_def_id);\n-    generics_require_sized_self(tcx, &trait_def.generics, &trait_predicates)\n-}\n+        violations\n+    }\n \n-fn generics_require_sized_self<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                     generics: &ty::Generics<'tcx>,\n-                                     predicates: &ty::GenericPredicates<'tcx>)\n-                                     -> bool\n-{\n-    let sized_def_id = match tcx.lang_items.sized_trait() {\n-        Some(def_id) => def_id,\n-        None => { return false; /* No Sized trait, can't require it! */ }\n-    };\n-\n-    // Search for a predicate like `Self : Sized` amongst the trait bounds.\n-    let free_substs = tcx.construct_free_substs(generics,\n-                                                tcx.region_maps.node_extent(ast::DUMMY_NODE_ID));\n-    let predicates = predicates.instantiate(tcx, &free_substs).predicates.into_vec();\n-    elaborate_predicates(tcx, predicates)\n-        .any(|predicate| {\n-            match predicate {\n-                ty::Predicate::Trait(ref trait_pred) if trait_pred.def_id() == sized_def_id => {\n-                    trait_pred.0.self_ty().is_self()\n+    fn supertraits_reference_self(self, trait_def_id: DefId) -> bool {\n+        let trait_def = self.lookup_trait_def(trait_def_id);\n+        let trait_ref = trait_def.trait_ref.clone();\n+        let trait_ref = trait_ref.to_poly_trait_ref();\n+        let predicates = self.lookup_super_predicates(trait_def_id);\n+        predicates\n+            .predicates\n+            .into_iter()\n+            .map(|predicate| predicate.subst_supertrait(self, &trait_ref))\n+            .any(|predicate| {\n+                match predicate {\n+                    ty::Predicate::Trait(ref data) => {\n+                        // In the case of a trait predicate, we can skip the \"self\" type.\n+                        data.0.trait_ref.substs.types.get_slice(TypeSpace)\n+                                                     .iter()\n+                                                     .cloned()\n+                                                     .any(|t| t.has_self_ty())\n+                    }\n+                    ty::Predicate::Projection(..) |\n+                    ty::Predicate::WellFormed(..) |\n+                    ty::Predicate::ObjectSafe(..) |\n+                    ty::Predicate::TypeOutlives(..) |\n+                    ty::Predicate::RegionOutlives(..) |\n+                    ty::Predicate::ClosureKind(..) |\n+                    ty::Predicate::Rfc1592(..) |\n+                    ty::Predicate::Equate(..) => {\n+                        false\n+                    }\n                 }\n-                ty::Predicate::Projection(..) |\n-                ty::Predicate::Trait(..) |\n-                ty::Predicate::Rfc1592(..) |\n-                ty::Predicate::Equate(..) |\n-                ty::Predicate::RegionOutlives(..) |\n-                ty::Predicate::WellFormed(..) |\n-                ty::Predicate::ObjectSafe(..) |\n-                ty::Predicate::ClosureKind(..) |\n-                ty::Predicate::TypeOutlives(..) => {\n-                    false\n-                }\n-            }\n-        })\n-}\n-\n-/// Returns `Some(_)` if this method makes the containing trait not object safe.\n-fn object_safety_violation_for_method<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                            trait_def_id: DefId,\n-                                            method: &ty::Method<'tcx>)\n-                                            -> Option<MethodViolationCode>\n-{\n-    // Any method that has a `Self : Sized` requisite is otherwise\n-    // exempt from the regulations.\n-    if generics_require_sized_self(tcx, &method.generics, &method.predicates) {\n-        return None;\n+            })\n     }\n \n-    virtual_call_violation_for_method(tcx, trait_def_id, method)\n-}\n+    fn trait_has_sized_self(self, trait_def_id: DefId) -> bool {\n+        let trait_def = self.lookup_trait_def(trait_def_id);\n+        let trait_predicates = self.lookup_predicates(trait_def_id);\n+        self.generics_require_sized_self(&trait_def.generics, &trait_predicates)\n+    }\n \n-/// We say a method is *vtable safe* if it can be invoked on a trait\n-/// object.  Note that object-safe traits can have some\n-/// non-vtable-safe methods, so long as they require `Self:Sized` or\n-/// otherwise ensure that they cannot be used when `Self=Trait`.\n-pub fn is_vtable_safe_method<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                   trait_def_id: DefId,\n-                                   method: &ty::Method<'tcx>)\n+    fn generics_require_sized_self(self,\n+                                   generics: &ty::Generics<'gcx>,\n+                                   predicates: &ty::GenericPredicates<'gcx>)\n                                    -> bool\n-{\n-    virtual_call_violation_for_method(tcx, trait_def_id, method).is_none()\n-}\n-\n-/// Returns `Some(_)` if this method cannot be called on a trait\n-/// object; this does not necessarily imply that the enclosing trait\n-/// is not object safe, because the method might have a where clause\n-/// `Self:Sized`.\n-fn virtual_call_violation_for_method<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                           trait_def_id: DefId,\n-                                           method: &ty::Method<'tcx>)\n-                                           -> Option<MethodViolationCode>\n-{\n-    // The method's first parameter must be something that derefs (or\n-    // autorefs) to `&self`. For now, we only accept `self`, `&self`\n-    // and `Box<Self>`.\n-    match method.explicit_self {\n-        ty::ExplicitSelfCategory::Static => {\n-            return Some(MethodViolationCode::StaticMethod);\n-        }\n-\n-        ty::ExplicitSelfCategory::ByValue |\n-        ty::ExplicitSelfCategory::ByReference(..) |\n-        ty::ExplicitSelfCategory::ByBox => {\n-        }\n+    {\n+        let sized_def_id = match self.lang_items.sized_trait() {\n+            Some(def_id) => def_id,\n+            None => { return false; /* No Sized trait, can't require it! */ }\n+        };\n+\n+        // Search for a predicate like `Self : Sized` amongst the trait bounds.\n+        let free_substs = self.construct_free_substs(generics,\n+            self.region_maps.node_extent(ast::DUMMY_NODE_ID));\n+        let predicates = predicates.instantiate(self, &free_substs).predicates.into_vec();\n+        elaborate_predicates(self, predicates)\n+            .any(|predicate| {\n+                match predicate {\n+                    ty::Predicate::Trait(ref trait_pred) if trait_pred.def_id() == sized_def_id => {\n+                        trait_pred.0.self_ty().is_self()\n+                    }\n+                    ty::Predicate::Projection(..) |\n+                    ty::Predicate::Trait(..) |\n+                    ty::Predicate::Rfc1592(..) |\n+                    ty::Predicate::Equate(..) |\n+                    ty::Predicate::RegionOutlives(..) |\n+                    ty::Predicate::WellFormed(..) |\n+                    ty::Predicate::ObjectSafe(..) |\n+                    ty::Predicate::ClosureKind(..) |\n+                    ty::Predicate::TypeOutlives(..) => {\n+                        false\n+                    }\n+                }\n+            })\n     }\n \n-    // The `Self` type is erased, so it should not appear in list of\n-    // arguments or return type apart from the receiver.\n-    let ref sig = method.fty.sig;\n-    for &input_ty in &sig.0.inputs[1..] {\n-        if contains_illegal_self_type_reference(tcx, trait_def_id, input_ty) {\n-            return Some(MethodViolationCode::ReferencesSelf);\n-        }\n-    }\n-    if let ty::FnConverging(result_type) = sig.0.output {\n-        if contains_illegal_self_type_reference(tcx, trait_def_id, result_type) {\n-            return Some(MethodViolationCode::ReferencesSelf);\n+    /// Returns `Some(_)` if this method makes the containing trait not object safe.\n+    fn object_safety_violation_for_method(self,\n+                                          trait_def_id: DefId,\n+                                          method: &ty::Method<'gcx>)\n+                                          -> Option<MethodViolationCode>\n+    {\n+        // Any method that has a `Self : Sized` requisite is otherwise\n+        // exempt from the regulations.\n+        if self.generics_require_sized_self(&method.generics, &method.predicates) {\n+            return None;\n         }\n+\n+        self.virtual_call_violation_for_method(trait_def_id, method)\n     }\n \n-    // We can't monomorphize things like `fn foo<A>(...)`.\n-    if !method.generics.types.is_empty_in(subst::FnSpace) {\n-        return Some(MethodViolationCode::Generic);\n+    /// We say a method is *vtable safe* if it can be invoked on a trait\n+    /// object.  Note that object-safe traits can have some\n+    /// non-vtable-safe methods, so long as they require `Self:Sized` or\n+    /// otherwise ensure that they cannot be used when `Self=Trait`.\n+    pub fn is_vtable_safe_method(self,\n+                                 trait_def_id: DefId,\n+                                 method: &ty::Method<'tcx>)\n+                                 -> bool\n+    {\n+        self.virtual_call_violation_for_method(trait_def_id, method).is_none()\n     }\n \n-    None\n-}\n+    /// Returns `Some(_)` if this method cannot be called on a trait\n+    /// object; this does not necessarily imply that the enclosing trait\n+    /// is not object safe, because the method might have a where clause\n+    /// `Self:Sized`.\n+    fn virtual_call_violation_for_method(self,\n+                                         trait_def_id: DefId,\n+                                         method: &ty::Method<'tcx>)\n+                                         -> Option<MethodViolationCode>\n+    {\n+        // The method's first parameter must be something that derefs (or\n+        // autorefs) to `&self`. For now, we only accept `self`, `&self`\n+        // and `Box<Self>`.\n+        match method.explicit_self {\n+            ty::ExplicitSelfCategory::Static => {\n+                return Some(MethodViolationCode::StaticMethod);\n+            }\n \n-fn contains_illegal_self_type_reference<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                              trait_def_id: DefId,\n-                                              ty: Ty<'tcx>)\n-                                              -> bool\n-{\n-    // This is somewhat subtle. In general, we want to forbid\n-    // references to `Self` in the argument and return types,\n-    // since the value of `Self` is erased. However, there is one\n-    // exception: it is ok to reference `Self` in order to access\n-    // an associated type of the current trait, since we retain\n-    // the value of those associated types in the object type\n-    // itself.\n-    //\n-    // ```rust\n-    // trait SuperTrait {\n-    //     type X;\n-    // }\n-    //\n-    // trait Trait : SuperTrait {\n-    //     type Y;\n-    //     fn foo(&self, x: Self) // bad\n-    //     fn foo(&self) -> Self // bad\n-    //     fn foo(&self) -> Option<Self> // bad\n-    //     fn foo(&self) -> Self::Y // OK, desugars to next example\n-    //     fn foo(&self) -> <Self as Trait>::Y // OK\n-    //     fn foo(&self) -> Self::X // OK, desugars to next example\n-    //     fn foo(&self) -> <Self as SuperTrait>::X // OK\n-    // }\n-    // ```\n-    //\n-    // However, it is not as simple as allowing `Self` in a projected\n-    // type, because there are illegal ways to use `Self` as well:\n-    //\n-    // ```rust\n-    // trait Trait : SuperTrait {\n-    //     ...\n-    //     fn foo(&self) -> <Self as SomeOtherTrait>::X;\n-    // }\n-    // ```\n-    //\n-    // Here we will not have the type of `X` recorded in the\n-    // object type, and we cannot resolve `Self as SomeOtherTrait`\n-    // without knowing what `Self` is.\n-\n-    let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n-    let mut error = false;\n-    ty.maybe_walk(|ty| {\n-        match ty.sty {\n-            ty::TyParam(ref param_ty) => {\n-                if param_ty.space == SelfSpace {\n-                    error = true;\n-                }\n+            ty::ExplicitSelfCategory::ByValue |\n+            ty::ExplicitSelfCategory::ByReference(..) |\n+            ty::ExplicitSelfCategory::ByBox => {\n+            }\n+        }\n \n-                false // no contained types to walk\n+        // The `Self` type is erased, so it should not appear in list of\n+        // arguments or return type apart from the receiver.\n+        let ref sig = method.fty.sig;\n+        for &input_ty in &sig.0.inputs[1..] {\n+            if self.contains_illegal_self_type_reference(trait_def_id, input_ty) {\n+                return Some(MethodViolationCode::ReferencesSelf);\n+            }\n+        }\n+        if let ty::FnConverging(result_type) = sig.0.output {\n+            if self.contains_illegal_self_type_reference(trait_def_id, result_type) {\n+                return Some(MethodViolationCode::ReferencesSelf);\n             }\n+        }\n \n-            ty::TyProjection(ref data) => {\n-                // This is a projected type `<Foo as SomeTrait>::X`.\n+        // We can't monomorphize things like `fn foo<A>(...)`.\n+        if !method.generics.types.is_empty_in(subst::FnSpace) {\n+            return Some(MethodViolationCode::Generic);\n+        }\n \n-                // Compute supertraits of current trait lazily.\n-                if supertraits.is_none() {\n-                    let trait_def = tcx.lookup_trait_def(trait_def_id);\n-                    let trait_ref = ty::Binder(trait_def.trait_ref.clone());\n-                    supertraits = Some(traits::supertraits(tcx, trait_ref).collect());\n+        None\n+    }\n+\n+    fn contains_illegal_self_type_reference(self,\n+                                            trait_def_id: DefId,\n+                                            ty: Ty<'tcx>)\n+                                            -> bool\n+    {\n+        // This is somewhat subtle. In general, we want to forbid\n+        // references to `Self` in the argument and return types,\n+        // since the value of `Self` is erased. However, there is one\n+        // exception: it is ok to reference `Self` in order to access\n+        // an associated type of the current trait, since we retain\n+        // the value of those associated types in the object type\n+        // itself.\n+        //\n+        // ```rust\n+        // trait SuperTrait {\n+        //     type X;\n+        // }\n+        //\n+        // trait Trait : SuperTrait {\n+        //     type Y;\n+        //     fn foo(&self, x: Self) // bad\n+        //     fn foo(&self) -> Self // bad\n+        //     fn foo(&self) -> Option<Self> // bad\n+        //     fn foo(&self) -> Self::Y // OK, desugars to next example\n+        //     fn foo(&self) -> <Self as Trait>::Y // OK\n+        //     fn foo(&self) -> Self::X // OK, desugars to next example\n+        //     fn foo(&self) -> <Self as SuperTrait>::X // OK\n+        // }\n+        // ```\n+        //\n+        // However, it is not as simple as allowing `Self` in a projected\n+        // type, because there are illegal ways to use `Self` as well:\n+        //\n+        // ```rust\n+        // trait Trait : SuperTrait {\n+        //     ...\n+        //     fn foo(&self) -> <Self as SomeOtherTrait>::X;\n+        // }\n+        // ```\n+        //\n+        // Here we will not have the type of `X` recorded in the\n+        // object type, and we cannot resolve `Self as SomeOtherTrait`\n+        // without knowing what `Self` is.\n+\n+        let mut supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>> = None;\n+        let mut error = false;\n+        ty.maybe_walk(|ty| {\n+            match ty.sty {\n+                ty::TyParam(ref param_ty) => {\n+                    if param_ty.space == SelfSpace {\n+                        error = true;\n+                    }\n+\n+                    false // no contained types to walk\n                 }\n \n-                // Determine whether the trait reference `Foo as\n-                // SomeTrait` is in fact a supertrait of the\n-                // current trait. In that case, this type is\n-                // legal, because the type `X` will be specified\n-                // in the object type.  Note that we can just use\n-                // direct equality here because all of these types\n-                // are part of the formal parameter listing, and\n-                // hence there should be no inference variables.\n-                let projection_trait_ref = ty::Binder(data.trait_ref.clone());\n-                let is_supertrait_of_current_trait =\n-                    supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n-\n-                if is_supertrait_of_current_trait {\n-                    false // do not walk contained types, do not report error, do collect $200\n-                } else {\n-                    true // DO walk contained types, POSSIBLY reporting an error\n+                ty::TyProjection(ref data) => {\n+                    // This is a projected type `<Foo as SomeTrait>::X`.\n+\n+                    // Compute supertraits of current trait lazily.\n+                    if supertraits.is_none() {\n+                        let trait_def = self.lookup_trait_def(trait_def_id);\n+                        let trait_ref = ty::Binder(trait_def.trait_ref.clone());\n+                        supertraits = Some(traits::supertraits(self, trait_ref).collect());\n+                    }\n+\n+                    // Determine whether the trait reference `Foo as\n+                    // SomeTrait` is in fact a supertrait of the\n+                    // current trait. In that case, this type is\n+                    // legal, because the type `X` will be specified\n+                    // in the object type.  Note that we can just use\n+                    // direct equality here because all of these types\n+                    // are part of the formal parameter listing, and\n+                    // hence there should be no inference variables.\n+                    let projection_trait_ref = ty::Binder(data.trait_ref.clone());\n+                    let is_supertrait_of_current_trait =\n+                        supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n+\n+                    if is_supertrait_of_current_trait {\n+                        false // do not walk contained types, do not report error, do collect $200\n+                    } else {\n+                        true // DO walk contained types, POSSIBLY reporting an error\n+                    }\n                 }\n-            }\n \n-            _ => true, // walk contained types, if any\n-        }\n-    });\n+                _ => true, // walk contained types, if any\n+            }\n+        });\n \n-    error\n+        error\n+    }\n }"}, {"sha": "4c338219ffbf7faa00fe8a70991e3d79a2b291fd", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 78, "deletions": 76, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -11,7 +11,6 @@\n //! Code for projecting associated types out of trait references.\n \n use super::elaborate_predicates;\n-use super::report_overflow_error;\n use super::specialization_graph;\n use super::translate_substs;\n use super::Obligation;\n@@ -172,8 +171,8 @@ struct ProjectionTyCandidateSet<'tcx> {\n ///     for<...> <T as Trait>::U == V\n ///\n /// If successful, this may result in additional obligations.\n-pub fn poly_project_and_unify_type<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+pub fn poly_project_and_unify_type<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &PolyProjectionObligation<'tcx>)\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>>\n {\n@@ -188,7 +187,7 @@ pub fn poly_project_and_unify_type<'cx,'tcx>(\n         let skol_obligation = obligation.with(skol_predicate);\n         match project_and_unify_type(selcx, &skol_obligation) {\n             Ok(result) => {\n-                match infcx.leak_check(&skol_map, snapshot) {\n+                match infcx.leak_check(false, &skol_map, snapshot) {\n                     Ok(()) => Ok(infcx.plug_leaks(skol_map, snapshot, &result)),\n                     Err(e) => Err(MismatchedProjectionTypes { err: e }),\n                 }\n@@ -205,8 +204,8 @@ pub fn poly_project_and_unify_type<'cx,'tcx>(\n ///     <T as Trait>::U == V\n ///\n /// If successful, this may result in additional obligations.\n-fn project_and_unify_type<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+fn project_and_unify_type<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionObligation<'tcx>)\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>>\n {\n@@ -231,7 +230,7 @@ fn project_and_unify_type<'cx,'tcx>(\n \n     let infcx = selcx.infcx();\n     let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n-    match infer::mk_eqty(infcx, true, origin, normalized_ty, obligation.predicate.ty) {\n+    match infcx.eq_types(true, origin, normalized_ty, obligation.predicate.ty) {\n         Ok(InferOk { obligations: inferred_obligations, .. }) => {\n             // FIXME(#32730) propagate obligations\n             assert!(inferred_obligations.is_empty());\n@@ -241,8 +240,10 @@ fn project_and_unify_type<'cx,'tcx>(\n     }\n }\n \n-fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext<'cx,'tcx>,\n-                                                    obligation: &ProjectionObligation<'tcx>) {\n+fn consider_unification_despite_ambiguity<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n+    obligation: &ProjectionObligation<'tcx>)\n+{\n     debug!(\"consider_unification_despite_ambiguity(obligation={:?})\",\n            obligation);\n \n@@ -258,15 +259,14 @@ fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext\n     debug!(\"consider_unification_despite_ambiguity: self_ty.sty={:?}\",\n            self_ty.sty);\n     match self_ty.sty {\n-        ty::TyClosure(closure_def_id, ref substs) => {\n+        ty::TyClosure(closure_def_id, substs) => {\n             let closure_typer = selcx.closure_typer();\n             let closure_type = closure_typer.closure_type(closure_def_id, substs);\n             let ty::Binder((_, ret_type)) =\n-                util::closure_trait_ref_and_return_type(infcx.tcx,\n-                                                        def_id,\n-                                                        self_ty,\n-                                                        &closure_type.sig,\n-                                                        util::TupleArgumentsFlag::No);\n+                infcx.tcx.closure_trait_ref_and_return_type(def_id,\n+                                                            self_ty,\n+                                                            &closure_type.sig,\n+                                                            util::TupleArgumentsFlag::No);\n             // We don't have to normalize the return type here - this is only\n             // reached for TyClosure: Fn inputs where the closure kind is\n             // still unknown, which should only occur in typeck where the\n@@ -281,7 +281,7 @@ fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext\n                    ret_type);\n             let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n             let obligation_ty = obligation.predicate.ty;\n-            match infer::mk_eqty(infcx, true, origin, obligation_ty, ret_type) {\n+            match infcx.eq_types(true, origin, obligation_ty, ret_type) {\n                 Ok(InferOk { obligations, .. }) => {\n                     // FIXME(#32730) propagate obligations\n                     assert!(obligations.is_empty());\n@@ -297,21 +297,23 @@ fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext\n /// them with a fully resolved type where possible. The return value\n /// combines the normalized result and any additional obligations that\n /// were incurred as result.\n-pub fn normalize<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n-                               cause: ObligationCause<'tcx>,\n-                               value: &T)\n-                               -> Normalized<'tcx, T>\n+pub fn normalize<'a, 'b, 'gcx, 'tcx, T>(selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n+                                        cause: ObligationCause<'tcx>,\n+                                        value: &T)\n+                                        -> Normalized<'tcx, T>\n     where T : TypeFoldable<'tcx>\n {\n     normalize_with_depth(selcx, cause, 0, value)\n }\n \n /// As `normalize`, but with a custom depth.\n-pub fn normalize_with_depth<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n-                                          cause: ObligationCause<'tcx>,\n-                                          depth: usize,\n-                                          value: &T)\n-                                          -> Normalized<'tcx, T>\n+pub fn normalize_with_depth<'a, 'b, 'gcx, 'tcx, T>(\n+    selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: usize,\n+    value: &T)\n+    -> Normalized<'tcx, T>\n+\n     where T : TypeFoldable<'tcx>\n {\n     let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, depth);\n@@ -323,18 +325,18 @@ pub fn normalize_with_depth<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tc\n     }\n }\n \n-struct AssociatedTypeNormalizer<'a,'b:'a,'tcx:'b> {\n-    selcx: &'a mut SelectionContext<'b,'tcx>,\n+struct AssociatedTypeNormalizer<'a, 'b: 'a, 'gcx: 'b+'tcx, 'tcx: 'b> {\n+    selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n     cause: ObligationCause<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,\n     depth: usize,\n }\n \n-impl<'a,'b,'tcx> AssociatedTypeNormalizer<'a,'b,'tcx> {\n-    fn new(selcx: &'a mut SelectionContext<'b,'tcx>,\n+impl<'a, 'b, 'gcx, 'tcx> AssociatedTypeNormalizer<'a, 'b, 'gcx, 'tcx> {\n+    fn new(selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n            cause: ObligationCause<'tcx>,\n            depth: usize)\n-           -> AssociatedTypeNormalizer<'a,'b,'tcx>\n+           -> AssociatedTypeNormalizer<'a, 'b, 'gcx, 'tcx>\n     {\n         AssociatedTypeNormalizer {\n             selcx: selcx,\n@@ -355,8 +357,8 @@ impl<'a,'b,'tcx> AssociatedTypeNormalizer<'a,'b,'tcx> {\n     }\n }\n \n-impl<'a,'b,'tcx> TypeFolder<'tcx> for AssociatedTypeNormalizer<'a,'b,'tcx> {\n-    fn tcx(&self) -> &TyCtxt<'tcx> {\n+impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a, 'b, 'gcx, 'tcx> {\n+    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'gcx, 'tcx> {\n         self.selcx.tcx()\n     }\n \n@@ -424,8 +426,8 @@ impl<'tcx,T> Normalized<'tcx,T> {\n /// there are unresolved type variables in the projection, we will\n /// substitute a fresh type variable `$X` and generate a new\n /// obligation `<T as Trait>::Item == $X` for later.\n-pub fn normalize_projection_type<'a,'b,'tcx>(\n-    selcx: &'a mut SelectionContext<'b,'tcx>,\n+pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n+    selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n     depth: usize)\n@@ -455,8 +457,8 @@ pub fn normalize_projection_type<'a,'b,'tcx>(\n /// as Trait>::Item`. The result is always a type (and possibly\n /// additional obligations). Returns `None` in the case of ambiguity,\n /// which indicates that there are unbound type variables.\n-fn opt_normalize_projection_type<'a,'b,'tcx>(\n-    selcx: &'a mut SelectionContext<'b,'tcx>,\n+fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n+    selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n     depth: usize)\n@@ -544,11 +546,11 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n /// an error for this obligation, but we legitimately should not,\n /// because it contains `[type error]`. Yuck! (See issue #29857 for\n /// one case where this arose.)\n-fn normalize_to_error<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n-                               projection_ty: ty::ProjectionTy<'tcx>,\n-                               cause: ObligationCause<'tcx>,\n-                               depth: usize)\n-                               -> NormalizedTy<'tcx>\n+fn normalize_to_error<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n+                                      projection_ty: ty::ProjectionTy<'tcx>,\n+                                      cause: ObligationCause<'tcx>,\n+                                      depth: usize)\n+                                      -> NormalizedTy<'tcx>\n {\n     let trait_ref = projection_ty.trait_ref.to_poly_trait_ref();\n     let trait_obligation = Obligation { cause: cause,\n@@ -567,8 +569,8 @@ enum ProjectedTy<'tcx> {\n }\n \n /// Compute the result of a projection type (if we can).\n-fn project_type<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+fn project_type<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>)\n     -> Result<ProjectedTy<'tcx>, ProjectionTyError<'tcx>>\n {\n@@ -578,7 +580,7 @@ fn project_type<'cx,'tcx>(\n     let recursion_limit = selcx.tcx().sess.recursion_limit.get();\n     if obligation.recursion_depth >= recursion_limit {\n         debug!(\"project: overflow!\");\n-        report_overflow_error(selcx.infcx(), &obligation, true);\n+        selcx.infcx().report_overflow_error(&obligation, true);\n     }\n \n     let obligation_trait_ref =\n@@ -750,8 +752,8 @@ fn project_type<'cx,'tcx>(\n /// The first thing we have to do is scan through the parameter\n /// environment to see whether there are any projection predicates\n /// there that can answer this question.\n-fn assemble_candidates_from_param_env<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+fn assemble_candidates_from_param_env<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n@@ -776,8 +778,8 @@ fn assemble_candidates_from_param_env<'cx,'tcx>(\n /// ```\n ///\n /// Here, for example, we could conclude that the result is `i32`.\n-fn assemble_candidates_from_trait_def<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+fn assemble_candidates_from_trait_def<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n@@ -808,8 +810,8 @@ fn assemble_candidates_from_trait_def<'cx,'tcx>(\n                                         bounds)\n }\n \n-fn assemble_candidates_from_predicates<'cx,'tcx,I>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n@@ -855,8 +857,8 @@ fn assemble_candidates_from_predicates<'cx,'tcx,I>(\n     }\n }\n \n-fn assemble_candidates_from_object_type<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+fn assemble_candidates_from_object_type<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation:  &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n@@ -887,8 +889,8 @@ fn assemble_candidates_from_object_type<'cx,'tcx>(\n                                         env_predicates)\n }\n \n-fn assemble_candidates_from_impls<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n@@ -971,8 +973,8 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n     Ok(())\n }\n \n-fn confirm_candidate<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+fn confirm_candidate<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     candidate: ProjectionTyCandidate<'tcx>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n@@ -1001,8 +1003,8 @@ fn confirm_candidate<'cx,'tcx>(\n     }\n }\n \n-fn confirm_fn_pointer_candidate<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+fn confirm_fn_pointer_candidate<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     fn_type: Ty<'tcx>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n@@ -1012,14 +1014,14 @@ fn confirm_fn_pointer_candidate<'cx,'tcx>(\n     confirm_callable_candidate(selcx, obligation, sig, util::TupleArgumentsFlag::Yes)\n }\n \n-fn confirm_closure_candidate<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     vtable: VtableClosureData<'tcx, PredicateObligation<'tcx>>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n {\n     let closure_typer = selcx.closure_typer();\n-    let closure_type = closure_typer.closure_type(vtable.closure_def_id, &vtable.substs);\n+    let closure_type = closure_typer.closure_type(vtable.closure_def_id, vtable.substs);\n     let Normalized {\n         value: closure_type,\n         mut obligations\n@@ -1035,8 +1037,8 @@ fn confirm_closure_candidate<'cx,'tcx>(\n     (ty, obligations)\n }\n \n-fn confirm_callable_candidate<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+fn confirm_callable_candidate<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     fn_sig: &ty::PolyFnSig<'tcx>,\n     flag: util::TupleArgumentsFlag)\n@@ -1053,11 +1055,10 @@ fn confirm_callable_candidate<'cx,'tcx>(\n \n     // Note: we unwrap the binder here but re-create it below (1)\n     let ty::Binder((trait_ref, ret_type)) =\n-        util::closure_trait_ref_and_return_type(tcx,\n-                                                fn_once_def_id,\n-                                                obligation.predicate.trait_ref.self_ty(),\n-                                                fn_sig,\n-                                                flag);\n+        tcx.closure_trait_ref_and_return_type(fn_once_def_id,\n+                                              obligation.predicate.trait_ref.self_ty(),\n+                                              fn_sig,\n+                                              flag);\n \n     let predicate = ty::Binder(ty::ProjectionPredicate { // (1) recreate binder here\n         projection_ty: ty::ProjectionTy {\n@@ -1070,8 +1071,8 @@ fn confirm_callable_candidate<'cx,'tcx>(\n     confirm_param_env_candidate(selcx, obligation, predicate)\n }\n \n-fn confirm_param_env_candidate<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+fn confirm_param_env_candidate<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     poly_projection: ty::PolyProjectionPredicate<'tcx>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n@@ -1109,8 +1110,8 @@ fn confirm_param_env_candidate<'cx,'tcx>(\n     (projection.ty, vec!())\n }\n \n-fn confirm_impl_candidate<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     impl_vtable: VtableImplData<'tcx, PredicateObligation<'tcx>>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n@@ -1149,10 +1150,11 @@ fn confirm_impl_candidate<'cx,'tcx>(\n ///\n /// Based on the \"projection mode\", this lookup may in fact only examine the\n /// topmost impl. See the comments for `ProjectionMode` for more details.\n-fn assoc_ty_def<'cx, 'tcx>(selcx: &SelectionContext<'cx, 'tcx>,\n-                           impl_def_id: DefId,\n-                           assoc_ty_name: ast::Name)\n-                           -> Option<specialization_graph::NodeItem<Rc<ty::AssociatedType<'tcx>>>>\n+fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n+    selcx: &SelectionContext<'cx, 'gcx, 'tcx>,\n+    impl_def_id: DefId,\n+    assoc_ty_name: ast::Name)\n+    -> Option<specialization_graph::NodeItem<Rc<ty::AssociatedType<'tcx>>>>\n {\n     let trait_def_id = selcx.tcx().impl_trait_ref(impl_def_id).unwrap().def_id;\n "}, {"sha": "7d9a256a6e080a19c525b6cef79071b06d1c29aa", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 121, "deletions": 75, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -20,7 +20,6 @@ use super::DerivedObligationCause;\n use super::project;\n use super::project::{normalize_with_depth, Normalized};\n use super::{PredicateObligation, TraitObligation, ObligationCause};\n-use super::report_overflow_error;\n use super::{ObligationCauseCode, BuiltinDerivedObligation, ImplDerivedObligation};\n use super::{SelectionError, Unimplemented, OutputTypeParameterMismatch};\n use super::{ObjectCastObligation, Obligation};\n@@ -32,7 +31,6 @@ use super::{VtableBuiltin, VtableImpl, VtableParam, VtableClosure,\n             VtableFnPointer, VtableObject, VtableDefaultImpl};\n use super::{VtableImplData, VtableObjectData, VtableBuiltinData,\n             VtableClosureData, VtableDefaultImplData};\n-use super::object_safety;\n use super::util;\n \n use hir::def_id::DefId;\n@@ -51,15 +49,15 @@ use syntax::abi::Abi;\n use hir;\n use util::nodemap::FnvHashMap;\n \n-pub struct SelectionContext<'cx, 'tcx:'cx> {\n-    infcx: &'cx InferCtxt<'cx, 'tcx>,\n+pub struct SelectionContext<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n \n     /// Freshener used specifically for skolemizing entries on the\n     /// obligation stack. This ensures that all entries on the stack\n     /// at one time will have the same set of skolemized entries,\n     /// which is important for checking for trait bounds that\n     /// recursively require themselves.\n-    freshener: TypeFreshener<'cx, 'tcx>,\n+    freshener: TypeFreshener<'cx, 'gcx, 'tcx>,\n \n     /// If true, indicates that the evaluation should be conservative\n     /// and consider the possibility of types outside this crate.\n@@ -199,7 +197,7 @@ enum SelectionCandidate<'tcx> {\n     /// Implementation of a `Fn`-family trait by one of the anonymous types\n     /// generated for a `||` expression. The ty::ClosureKind informs the\n     /// confirmation step what ClosureKind obligation to emit.\n-    ClosureCandidate(/* closure */ DefId, &'tcx ty::ClosureSubsts<'tcx>, ty::ClosureKind),\n+    ClosureCandidate(/* closure */ DefId, ty::ClosureSubsts<'tcx>, ty::ClosureKind),\n \n     /// Implementation of a `Fn`-family trait by one of the anonymous\n     /// types generated for a fn pointer type (e.g., `fn(int)->int`)\n@@ -212,6 +210,38 @@ enum SelectionCandidate<'tcx> {\n     BuiltinUnsizeCandidate,\n }\n \n+impl<'a, 'tcx> ty::Lift<'tcx> for SelectionCandidate<'a> {\n+    type Lifted = SelectionCandidate<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        Some(match *self {\n+            BuiltinCandidate { has_nested } => {\n+                BuiltinCandidate {\n+                    has_nested: has_nested\n+                }\n+            }\n+            ImplCandidate(def_id) => ImplCandidate(def_id),\n+            DefaultImplCandidate(def_id) => DefaultImplCandidate(def_id),\n+            DefaultImplObjectCandidate(def_id) => {\n+                DefaultImplObjectCandidate(def_id)\n+            }\n+            ProjectionCandidate => ProjectionCandidate,\n+            FnPointerCandidate => FnPointerCandidate,\n+            ObjectCandidate => ObjectCandidate,\n+            BuiltinObjectCandidate => BuiltinObjectCandidate,\n+            BuiltinUnsizeCandidate => BuiltinUnsizeCandidate,\n+\n+            ParamCandidate(ref trait_ref) => {\n+                return tcx.lift(trait_ref).map(ParamCandidate);\n+            }\n+            ClosureCandidate(def_id, ref substs, kind) => {\n+                return tcx.lift(substs).map(|substs| {\n+                    ClosureCandidate(def_id, substs, kind)\n+                });\n+            }\n+        })\n+    }\n+}\n+\n struct SelectionCandidateSet<'tcx> {\n     // a list of candidates that definitely apply to the current\n     // obligation (meaning: types unify).\n@@ -264,36 +294,36 @@ pub struct EvaluationCache<'tcx> {\n     hashmap: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, EvaluationResult>>\n }\n \n-impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n-    pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>) -> SelectionContext<'cx, 'tcx> {\n+impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>) -> SelectionContext<'cx, 'gcx, 'tcx> {\n         SelectionContext {\n             infcx: infcx,\n             freshener: infcx.freshener(),\n             intercrate: false,\n         }\n     }\n \n-    pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'tcx>) -> SelectionContext<'cx, 'tcx> {\n+    pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>) -> SelectionContext<'cx, 'gcx, 'tcx> {\n         SelectionContext {\n             infcx: infcx,\n             freshener: infcx.freshener(),\n             intercrate: true,\n         }\n     }\n \n-    pub fn infcx(&self) -> &'cx InferCtxt<'cx, 'tcx> {\n+    pub fn infcx(&self) -> &'cx InferCtxt<'cx, 'gcx, 'tcx> {\n         self.infcx\n     }\n \n-    pub fn tcx(&self) -> &'cx TyCtxt<'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn param_env(&self) -> &'cx ty::ParameterEnvironment<'cx, 'tcx> {\n+    pub fn param_env(&self) -> &'cx ty::ParameterEnvironment<'tcx> {\n         self.infcx.param_env()\n     }\n \n-    pub fn closure_typer(&self) -> &'cx InferCtxt<'cx, 'tcx> {\n+    pub fn closure_typer(&self) -> &'cx InferCtxt<'cx, 'gcx, 'tcx> {\n         self.infcx\n     }\n \n@@ -455,7 +485,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ty::Predicate::ObjectSafe(trait_def_id) => {\n-                if object_safety::is_object_safe(self.tcx(), trait_def_id) {\n+                if self.tcx().is_object_safe(trait_def_id) {\n                     EvaluatedToOk\n                 } else {\n                     EvaluatedToErr\n@@ -629,23 +659,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         result\n     }\n \n-    fn pick_evaluation_cache(&self) -> &EvaluationCache<'tcx> {\n-        // see comment in `pick_candidate_cache`\n-        if self.intercrate ||\n-            !self.param_env().caller_bounds.is_empty()\n-        {\n-            &self.param_env().evaluation_cache\n-        } else\n-        {\n-            &self.tcx().evaluation_cache\n-        }\n-    }\n-\n     fn check_evaluation_cache(&self, trait_ref: ty::PolyTraitRef<'tcx>)\n                               -> Option<EvaluationResult>\n     {\n-        let cache = self.pick_evaluation_cache();\n-        cache.hashmap.borrow().get(&trait_ref).cloned()\n+        if self.can_use_global_caches() {\n+            let cache = self.tcx().evaluation_cache.hashmap.borrow();\n+            if let Some(cached) = cache.get(&trait_ref) {\n+                return Some(cached.clone());\n+            }\n+        }\n+        self.infcx.evaluation_cache.hashmap.borrow().get(&trait_ref).cloned()\n     }\n \n     fn insert_evaluation_cache(&mut self,\n@@ -663,8 +686,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return;\n         }\n \n-        let cache = self.pick_evaluation_cache();\n-        cache.hashmap.borrow_mut().insert(trait_ref, result);\n+        if self.can_use_global_caches() {\n+            let mut cache = self.tcx().evaluation_cache.hashmap.borrow_mut();\n+            if let Some(trait_ref) = self.tcx().lift_to_global(&trait_ref) {\n+                cache.insert(trait_ref, result);\n+                return;\n+            }\n+        }\n+\n+        self.infcx.evaluation_cache.hashmap.borrow_mut().insert(trait_ref, result);\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -683,7 +713,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // not update) the cache.\n         let recursion_limit = self.infcx.tcx.sess.recursion_limit.get();\n         if stack.obligation.recursion_depth >= recursion_limit {\n-            report_overflow_error(self.infcx(), &stack.obligation, true);\n+            self.infcx().report_overflow_error(&stack.obligation, true);\n         }\n \n         // Check the cache. Note that we skolemize the trait-ref\n@@ -873,7 +903,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         coherence::trait_ref_is_knowable(self.tcx(), trait_ref)\n     }\n \n-    fn pick_candidate_cache(&self) -> &SelectionCache<'tcx> {\n+    /// Returns true if the global caches can be used.\n+    /// Do note that if the type itself is not in the\n+    /// global tcx, the local caches will be used.\n+    fn can_use_global_caches(&self) -> bool {\n         // If there are any where-clauses in scope, then we always use\n         // a cache local to this particular scope. Otherwise, we\n         // switch to a global cache. We used to try and draw\n@@ -882,7 +915,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // rule seems to be pretty clearly safe and also still retains\n         // a very high hit rate (~95% when compiling rustc).\n         if !self.param_env().caller_bounds.is_empty() {\n-            return &self.param_env().selection_cache;\n+            return false;\n         }\n \n         // Avoid using the master cache during coherence and just rely\n@@ -893,29 +926,43 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // it's not worth going to more trouble to increase the\n         // hit-rate I don't think.\n         if self.intercrate {\n-            return &self.param_env().selection_cache;\n+            return false;\n         }\n \n         // Otherwise, we can use the global cache.\n-        &self.tcx().selection_cache\n+        true\n     }\n \n     fn check_candidate_cache(&mut self,\n                              cache_fresh_trait_pred: &ty::PolyTraitPredicate<'tcx>)\n                              -> Option<SelectionResult<'tcx, SelectionCandidate<'tcx>>>\n     {\n-        let cache = self.pick_candidate_cache();\n-        let hashmap = cache.hashmap.borrow();\n-        hashmap.get(&cache_fresh_trait_pred.0.trait_ref).cloned()\n+        let trait_ref = &cache_fresh_trait_pred.0.trait_ref;\n+        if self.can_use_global_caches() {\n+            let cache = self.tcx().selection_cache.hashmap.borrow();\n+            if let Some(cached) = cache.get(&trait_ref) {\n+                return Some(cached.clone());\n+            }\n+        }\n+        self.infcx.selection_cache.hashmap.borrow().get(trait_ref).cloned()\n     }\n \n     fn insert_candidate_cache(&mut self,\n                               cache_fresh_trait_pred: ty::PolyTraitPredicate<'tcx>,\n                               candidate: SelectionResult<'tcx, SelectionCandidate<'tcx>>)\n     {\n-        let cache = self.pick_candidate_cache();\n-        let mut hashmap = cache.hashmap.borrow_mut();\n-        hashmap.insert(cache_fresh_trait_pred.0.trait_ref.clone(), candidate);\n+        let trait_ref = cache_fresh_trait_pred.0.trait_ref;\n+        if self.can_use_global_caches() {\n+            let mut cache = self.tcx().selection_cache.hashmap.borrow_mut();\n+            if let Some(trait_ref) = self.tcx().lift_to_global(&trait_ref) {\n+                if let Some(candidate) = self.tcx().lift_to_global(&candidate) {\n+                    cache.insert(trait_ref, candidate);\n+                    return;\n+                }\n+            }\n+        }\n+\n+        self.infcx.selection_cache.hashmap.borrow_mut().insert(trait_ref, candidate);\n     }\n \n     fn should_update_candidate_cache(&mut self,\n@@ -1155,7 +1202,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             Err(_) => { return false; }\n         }\n \n-        self.infcx.leak_check(skol_map, snapshot).is_ok()\n+        self.infcx.leak_check(false, skol_map, snapshot).is_ok()\n     }\n \n     /// Given an obligation like `<SomeTrait for T>`, search the obligations that the caller\n@@ -1223,7 +1270,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // type/region parameters\n         let self_ty = *obligation.self_ty().skip_binder();\n         let (closure_def_id, substs) = match self_ty.sty {\n-            ty::TyClosure(id, ref substs) => (id, substs),\n+            ty::TyClosure(id, substs) => (id, substs),\n             ty::TyInfer(ty::TyVar(_)) => {\n                 debug!(\"assemble_unboxed_closure_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true;\n@@ -1397,7 +1444,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // these cases wind up being considered ambiguous due to a\n         // (spurious) ambiguity introduced here.\n         let predicate_trait_ref = obligation.predicate.to_poly_trait_ref();\n-        if !object_safety::is_object_safe(self.tcx(), predicate_trait_ref.def_id()) {\n+        if !self.tcx().is_object_safe(predicate_trait_ref.def_id()) {\n             return;\n         }\n \n@@ -1594,7 +1641,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // i.e. EvaluatedToOk:\n                 if other.evaluation == EvaluatedToOk {\n                     if let ImplCandidate(victim_def) = victim.candidate {\n-                        return traits::specializes(self.tcx(), other_def, victim_def);\n+                        let tcx = self.tcx().global_tcx();\n+                        return traits::specializes(tcx, other_def, victim_def);\n                     }\n                 }\n \n@@ -1659,16 +1707,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::TyStr | ty::TySlice(_) | ty::TyTrait(..) => Never,\n \n-            ty::TyTuple(ref tys) => {\n+            ty::TyTuple(tys) => {\n                 // FIXME(#33242) we only need to constrain the last field\n-                Where(ty::Binder(tys.clone()))\n+                Where(ty::Binder(tys.to_vec()))\n             }\n \n             ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n                 let sized_crit = def.sized_constraint(self.tcx());\n                 // (*) binder moved here\n                 Where(ty::Binder(match sized_crit.sty {\n-                    ty::TyTuple(ref tys) => tys.to_owned().subst(self.tcx(), substs),\n+                    ty::TyTuple(tys) => tys.to_vec().subst(self.tcx(), substs),\n                     ty::TyBool => vec![],\n                     _ => vec![sized_crit.subst(self.tcx(), substs)]\n                 }))\n@@ -1715,9 +1763,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Where(ty::Binder(vec![element_ty]))\n             }\n \n-            ty::TyTuple(ref tys) => {\n+            ty::TyTuple(tys) => {\n                 // (*) binder moved here\n-                Where(ty::Binder(tys.clone()))\n+                Where(ty::Binder(tys.to_vec()))\n             }\n \n             ty::TyStruct(..) | ty::TyEnum(..) | ty::TyProjection(..) | ty::TyParam(..) => {\n@@ -1794,7 +1842,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::TyTuple(ref tys) => {\n                 // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n-                tys.clone()\n+                tys.to_vec()\n             }\n \n             ty::TyClosure(_, ref substs) => {\n@@ -1806,7 +1854,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // OIBIT interact? That is, there is no way to say\n                 // \"make me invariant with respect to this TYPE, but\n                 // do not act as though I can reach it\"\n-                substs.upvar_tys.clone()\n+                substs.upvar_tys.to_vec()\n             }\n \n             // for `PhantomData<T>`, we pass `T`\n@@ -1855,7 +1903,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                   recursion_depth,\n                                                   &skol_ty);\n                 let skol_obligation =\n-                    util::predicate_for_trait_def(self.tcx(),\n+                    self.tcx().predicate_for_trait_def(\n                                                   cause.clone(),\n                                                   trait_def_id,\n                                                   recursion_depth,\n@@ -2140,7 +2188,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn vtable_impl(&mut self,\n                    impl_def_id: DefId,\n-                   mut substs: Normalized<'tcx, Substs<'tcx>>,\n+                   mut substs: Normalized<'tcx, &'tcx Substs<'tcx>>,\n                    cause: ObligationCause<'tcx>,\n                    recursion_depth: usize,\n                    skol_map: infer::SkolemizationMap,\n@@ -2173,7 +2221,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         impl_obligations.append(&mut substs.obligations);\n \n         VtableImplData { impl_def_id: impl_def_id,\n-                         substs: self.tcx().mk_substs(substs.value),\n+                         substs: substs.value,\n                          nested: impl_obligations }\n     }\n \n@@ -2226,7 +2274,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // entries, so that we can compute the offset for the selected\n             // trait.\n             vtable_base =\n-                nonmatching.map(|t| util::count_own_vtable_entries(self.tcx(), t))\n+                nonmatching.map(|t| self.tcx().count_own_vtable_entries(t))\n                            .sum();\n \n         }\n@@ -2248,11 +2296,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let sig = self_ty.fn_sig();\n         let trait_ref =\n-            util::closure_trait_ref_and_return_type(self.tcx(),\n-                                                    obligation.predicate.def_id(),\n-                                                    self_ty,\n-                                                    sig,\n-                                                    util::TupleArgumentsFlag::Yes)\n+            self.tcx().closure_trait_ref_and_return_type(obligation.predicate.def_id(),\n+                                                         self_ty,\n+                                                         sig,\n+                                                         util::TupleArgumentsFlag::Yes)\n             .map_bound(|(trait_ref, _)| trait_ref);\n \n         self.confirm_poly_trait_refs(obligation.cause.clone(),\n@@ -2264,7 +2311,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn confirm_closure_candidate(&mut self,\n                                  obligation: &TraitObligation<'tcx>,\n                                  closure_def_id: DefId,\n-                                 substs: &ty::ClosureSubsts<'tcx>,\n+                                 substs: ty::ClosureSubsts<'tcx>,\n                                  kind: ty::ClosureKind)\n                                  -> Result<VtableClosureData<'tcx, PredicateObligation<'tcx>>,\n                                            SelectionError<'tcx>>\n@@ -2396,7 +2443,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n //                    })\n //                    .chain(Some(data.principal_def_id()));\n                 if let Some(did) = object_dids.find(|did| {\n-                    !object_safety::is_object_safe(tcx, *did)\n+                    !tcx.is_object_safe(*did)\n                 }) {\n                     return Err(TraitNotObjectSafe(did))\n                 }\n@@ -2422,7 +2469,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // object type is Foo+Send, this would create an obligation\n                 // for the Send check.)\n                 for bound in &builtin_bounds {\n-                    if let Ok(tr) = util::trait_ref_for_builtin_bound(tcx, bound, source) {\n+                    if let Ok(tr) = tcx.trait_ref_for_builtin_bound(bound, source) {\n                         push(tr.to_predicate());\n                     } else {\n                         return Err(Unimplemented);\n@@ -2511,7 +2558,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 assert!(obligations.is_empty());\n \n                 // Construct the nested Field<T>: Unsize<Field<U>> predicate.\n-                nested.push(util::predicate_for_trait_def(tcx,\n+                nested.push(tcx.predicate_for_trait_def(\n                     obligation.cause.clone(),\n                     obligation.predicate.def_id(),\n                     obligation.recursion_depth + 1,\n@@ -2539,7 +2586,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     impl_def_id: DefId,\n                     obligation: &TraitObligation<'tcx>,\n                     snapshot: &infer::CombinedSnapshot)\n-                    -> (Normalized<'tcx, Substs<'tcx>>, infer::SkolemizationMap)\n+                    -> (Normalized<'tcx, &'tcx Substs<'tcx>>, infer::SkolemizationMap)\n     {\n         match self.match_impl(impl_def_id, obligation, snapshot) {\n             Ok((substs, skol_map)) => (substs, skol_map),\n@@ -2555,7 +2602,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                   impl_def_id: DefId,\n                   obligation: &TraitObligation<'tcx>,\n                   snapshot: &infer::CombinedSnapshot)\n-                  -> Result<(Normalized<'tcx, Substs<'tcx>>,\n+                  -> Result<(Normalized<'tcx, &'tcx Substs<'tcx>>,\n                              infer::SkolemizationMap), ()>\n     {\n         let impl_trait_ref = self.tcx().impl_trait_ref(impl_def_id).unwrap();\n@@ -2605,7 +2652,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // FIXME(#32730) propagate obligations\n         assert!(obligations.is_empty());\n \n-        if let Err(e) = self.infcx.leak_check(&skol_map, snapshot) {\n+        if let Err(e) = self.infcx.leak_check(false, &skol_map, snapshot) {\n             debug!(\"match_impl: failed leak check due to `{}`\", e);\n             return Err(());\n         }\n@@ -2705,16 +2752,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn closure_trait_ref_unnormalized(&mut self,\n                                       obligation: &TraitObligation<'tcx>,\n                                       closure_def_id: DefId,\n-                                      substs: &ty::ClosureSubsts<'tcx>)\n+                                      substs: ty::ClosureSubsts<'tcx>)\n                                       -> ty::PolyTraitRef<'tcx>\n     {\n         let closure_type = self.infcx.closure_type(closure_def_id, substs);\n         let ty::Binder((trait_ref, _)) =\n-            util::closure_trait_ref_and_return_type(self.tcx(),\n-                                                    obligation.predicate.def_id(),\n-                                                    obligation.predicate.0.self_ty(), // (1)\n-                                                    &closure_type.sig,\n-                                                    util::TupleArgumentsFlag::No);\n+            self.tcx().closure_trait_ref_and_return_type(obligation.predicate.def_id(),\n+                                                         obligation.predicate.0.self_ty(), // (1)\n+                                                         &closure_type.sig,\n+                                                         util::TupleArgumentsFlag::No);\n         // (1) Feels icky to skip the binder here, but OTOH we know\n         // that the self-type is an unboxed closure type and hence is\n         // in fact unparameterized (or at least does not reference any\n@@ -2727,7 +2773,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn closure_trait_ref(&mut self,\n                          obligation: &TraitObligation<'tcx>,\n                          closure_def_id: DefId,\n-                         substs: &ty::ClosureSubsts<'tcx>)\n+                         substs: ty::ClosureSubsts<'tcx>)\n                          -> Normalized<'tcx, ty::PolyTraitRef<'tcx>>\n     {\n         let trait_ref = self.closure_trait_ref_unnormalized("}, {"sha": "d43d2de1f1fbcdb6f73b6ea80c1e2da0a1864ce8", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 42, "deletions": 33, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -21,7 +21,7 @@ use super::{SelectionContext, FulfillmentContext};\n use super::util::{fresh_type_vars_for_impl, impl_trait_ref_and_oblig};\n \n use hir::def_id::DefId;\n-use infer::{self, InferCtxt, TypeOrigin};\n+use infer::{InferCtxt, TypeOrigin};\n use middle::region;\n use ty::subst::{Subst, Substs};\n use traits::{self, ProjectionMode, ObligationCause, Normalized};\n@@ -31,10 +31,10 @@ use syntax::codemap::DUMMY_SP;\n pub mod specialization_graph;\n \n /// Information pertinent to an overlapping impl error.\n-pub struct Overlap<'a, 'tcx: 'a> {\n-    pub in_context: InferCtxt<'a, 'tcx>,\n+pub struct OverlapError {\n     pub with_impl: DefId,\n-    pub on_trait_ref: ty::TraitRef<'tcx>,\n+    pub trait_desc: String,\n+    pub self_desc: Option<String>\n }\n \n /// Given a subst for the requested impl, translate it to a subst\n@@ -72,11 +72,11 @@ pub struct Overlap<'a, 'tcx: 'a> {\n /// through associated type projection. We deal with such cases by using\n /// *fulfillment* to relate the two impls, requiring that all projections are\n /// resolved.\n-pub fn translate_substs<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                  source_impl: DefId,\n-                                  source_substs: &'tcx Substs<'tcx>,\n-                                  target_node: specialization_graph::Node)\n-                                  -> &'tcx Substs<'tcx> {\n+pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                        source_impl: DefId,\n+                                        source_substs: &'tcx Substs<'tcx>,\n+                                        target_node: specialization_graph::Node)\n+                                        -> &'tcx Substs<'tcx> {\n     let source_trait_ref = infcx.tcx\n                                 .impl_trait_ref(source_impl)\n                                 .unwrap()\n@@ -96,7 +96,7 @@ pub fn translate_substs<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                       specializaiton failed to hold\")\n             })\n         }\n-        specialization_graph::Node::Trait(..) => source_trait_ref.substs.clone(),\n+        specialization_graph::Node::Trait(..) => source_trait_ref.substs,\n     };\n \n     // directly inherent the method generics, since those do not vary across impls\n@@ -108,7 +108,9 @@ pub fn translate_substs<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n /// Specialization is determined by the sets of types to which the impls apply;\n /// impl1 specializes impl2 if it applies to a subset of the types impl2 applies\n /// to.\n-pub fn specializes(tcx: &TyCtxt, impl1_def_id: DefId, impl2_def_id: DefId) -> bool {\n+pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             impl1_def_id: DefId,\n+                             impl2_def_id: DefId) -> bool {\n     // The feature gate should prevent introducing new specializations, but not\n     // taking advantage of upstream ones.\n     if !tcx.sess.features.borrow().specialization &&\n@@ -133,8 +135,6 @@ pub fn specializes(tcx: &TyCtxt, impl1_def_id: DefId, impl2_def_id: DefId) -> bo\n         return false;\n     }\n \n-    let mut infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables, ProjectionMode::Topmost);\n-\n     // create a parameter environment corresponding to a (skolemized) instantiation of impl1\n     let scheme = tcx.lookup_item_type(impl1_def_id);\n     let predicates = tcx.lookup_predicates(impl1_def_id);\n@@ -146,29 +146,39 @@ pub fn specializes(tcx: &TyCtxt, impl1_def_id: DefId, impl2_def_id: DefId) -> bo\n                              .unwrap()\n                              .subst(tcx, &penv.free_substs);\n \n-    // Normalize the trait reference, adding any obligations that arise into the impl1 assumptions\n-    let Normalized { value: impl1_trait_ref, obligations: normalization_obligations } = {\n-        let selcx = &mut SelectionContext::new(&infcx);\n-        traits::normalize(selcx, ObligationCause::dummy(), &impl1_trait_ref)\n-    };\n-    penv.caller_bounds.extend(normalization_obligations.into_iter().map(|o| o.predicate));\n+    tcx.normalizing_infer_ctxt(ProjectionMode::Topmost).enter(|mut infcx| {\n+        // Normalize the trait reference, adding any obligations\n+        // that arise into the impl1 assumptions.\n+        let Normalized { value: impl1_trait_ref, obligations: normalization_obligations } = {\n+            let selcx = &mut SelectionContext::new(&infcx);\n+            traits::normalize(selcx, ObligationCause::dummy(), &impl1_trait_ref)\n+        };\n+        penv.caller_bounds.extend(normalization_obligations.into_iter().map(|o| {\n+            match tcx.lift_to_global(&o.predicate) {\n+                Some(predicate) => predicate,\n+                None => {\n+                    bug!(\"specializes: obligation `{:?}` has inference types/regions\", o);\n+                }\n+            }\n+        }));\n \n-    // Install the parameter environment, taking the predicates of impl1 as assumptions:\n-    infcx.parameter_environment = penv;\n+        // Install the parameter environment, taking the predicates of impl1 as assumptions:\n+        infcx.parameter_environment = penv;\n \n-    // Attempt to prove that impl2 applies, given all of the above.\n-    fulfill_implication(&infcx, impl1_trait_ref, impl2_def_id).is_ok()\n+        // Attempt to prove that impl2 applies, given all of the above.\n+        fulfill_implication(&infcx, impl1_trait_ref, impl2_def_id).is_ok()\n+    })\n }\n \n /// Attempt to fulfill all obligations of `target_impl` after unification with\n /// `source_trait_ref`. If successful, returns a substitution for *all* the\n /// generics of `target_impl`, including both those needed to unify with\n /// `source_trait_ref` and those whose identity is determined via a where\n /// clause in the impl.\n-fn fulfill_implication<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                 source_trait_ref: ty::TraitRef<'tcx>,\n-                                 target_impl: DefId)\n-                                 -> Result<Substs<'tcx>, ()> {\n+fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                       source_trait_ref: ty::TraitRef<'tcx>,\n+                                       target_impl: DefId)\n+                                       -> Result<&'tcx Substs<'tcx>, ()> {\n     infcx.commit_if_ok(|_| {\n         let selcx = &mut SelectionContext::new(&infcx);\n         let target_substs = fresh_type_vars_for_impl(&infcx, DUMMY_SP, target_impl);\n@@ -177,11 +187,10 @@ fn fulfill_implication<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                                                                        &target_substs);\n \n         // do the impls unify? If not, no specialization.\n-        if let Err(_) = infer::mk_eq_trait_refs(&infcx,\n-                                                true,\n-                                                TypeOrigin::Misc(DUMMY_SP),\n-                                                source_trait_ref,\n-                                                target_trait_ref) {\n+        if let Err(_) = infcx.eq_trait_refs(true,\n+                                            TypeOrigin::Misc(DUMMY_SP),\n+                                            source_trait_ref,\n+                                            target_trait_ref) {\n             debug!(\"fulfill_implication: {:?} does not unify with {:?}\",\n                    source_trait_ref,\n                    target_trait_ref);\n@@ -196,7 +205,7 @@ fn fulfill_implication<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             fulfill_cx.register_predicate_obligation(&infcx, oblig);\n         }\n \n-        if let Err(errors) = infer::drain_fulfillment_cx(&infcx, &mut fulfill_cx, &()) {\n+        if let Err(errors) = infcx.drain_fulfillment_cx(&mut fulfill_cx, &()) {\n             // no dice!\n             debug!(\"fulfill_implication: for impls on {:?} and {:?}, could not fulfill: {:?} given \\\n                     {:?}\","}, {"sha": "ae7deb48f8677900ab93a6558bd20a0b29fa093a", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 79, "deletions": 60, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -11,10 +11,9 @@\n use std::cell;\n use std::rc::Rc;\n \n-use super::{Overlap, specializes};\n+use super::{OverlapError, specializes};\n \n use hir::def_id::DefId;\n-use infer;\n use traits::{self, ProjectionMode};\n use ty::{self, TyCtxt, ImplOrTraitItem, TraitDef, TypeFoldable};\n use ty::fast_reject::{self, SimplifiedType};\n@@ -66,7 +65,7 @@ struct Children {\n }\n \n /// The result of attempting to insert an impl into a group of children.\n-enum InsertResult<'a, 'tcx: 'a> {\n+enum Inserted {\n     /// The impl was inserted as a new child in this group of children.\n     BecameNewSibling,\n \n@@ -75,13 +74,9 @@ enum InsertResult<'a, 'tcx: 'a> {\n \n     /// The impl is a specialization of an existing child.\n     ShouldRecurseOn(DefId),\n-\n-    /// The impl has an unresolvable overlap with an existing child (neither\n-    /// specializes the other).\n-    Overlapped(Overlap<'a, 'tcx>),\n }\n \n-impl Children {\n+impl<'a, 'gcx, 'tcx> Children {\n     fn new() -> Children {\n         Children {\n             nonblanket_impls: FnvHashMap(),\n@@ -90,7 +85,9 @@ impl Children {\n     }\n \n     /// Insert an impl into this set of children without comparing to any existing impls\n-    fn insert_blindly(&mut self, tcx: &TyCtxt, impl_def_id: DefId) {\n+    fn insert_blindly(&mut self,\n+                      tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                      impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         if let Some(sty) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false) {\n             self.nonblanket_impls.entry(sty).or_insert(vec![]).push(impl_def_id)\n@@ -101,68 +98,90 @@ impl Children {\n \n     /// Attempt to insert an impl into this set of children, while comparing for\n     /// specialiation relationships.\n-    fn insert<'a, 'tcx>(&mut self,\n-                        tcx: &'a TyCtxt<'tcx>,\n-                        impl_def_id: DefId,\n-                        simplified_self: Option<SimplifiedType>)\n-                        -> InsertResult<'a, 'tcx>\n+    fn insert(&mut self,\n+              tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+              impl_def_id: DefId,\n+              simplified_self: Option<SimplifiedType>)\n+              -> Result<Inserted, OverlapError>\n     {\n         for slot in match simplified_self {\n             Some(sty) => self.filtered_mut(sty),\n             None => self.iter_mut(),\n         } {\n             let possible_sibling = *slot;\n \n-            let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, ProjectionMode::Topmost);\n-            let overlap = traits::overlapping_impls(&infcx, possible_sibling, impl_def_id);\n-\n-            if let Some(impl_header) = overlap {\n-                let le = specializes(tcx, impl_def_id, possible_sibling);\n-                let ge = specializes(tcx, possible_sibling, impl_def_id);\n+            let tcx = tcx.global_tcx();\n+            let (le, ge) = tcx.infer_ctxt(None, None,\n+                                          ProjectionMode::Topmost).enter(|infcx| {\n+                let overlap = traits::overlapping_impls(&infcx,\n+                                                        possible_sibling,\n+                                                        impl_def_id);\n+                if let Some(impl_header) = overlap {\n+                    let le = specializes(tcx, impl_def_id, possible_sibling);\n+                    let ge = specializes(tcx, possible_sibling, impl_def_id);\n+\n+                    if le == ge {\n+                        // overlap, but no specialization; error out\n+                        let trait_ref = impl_header.trait_ref.unwrap();\n+                        Err(OverlapError {\n+                            with_impl: possible_sibling,\n+                            trait_desc: trait_ref.to_string(),\n+                            self_desc: trait_ref.substs.self_ty().and_then(|ty| {\n+                                // only report the Self type if it has at least\n+                                // some outer concrete shell; otherwise, it's\n+                                // not adding much information.\n+                                if ty.has_concrete_skeleton() {\n+                                    Some(ty.to_string())\n+                                } else {\n+                                    None\n+                                }\n+                            })\n+                        })\n+                    } else {\n+                        Ok((le, ge))\n+                    }\n+                } else {\n+                    Ok((false, false))\n+                }\n+            })?;\n \n-                if le && !ge {\n-                    debug!(\"descending as child of TraitRef {:?}\",\n-                           tcx.impl_trait_ref(possible_sibling).unwrap());\n+            if le && !ge {\n+                debug!(\"descending as child of TraitRef {:?}\",\n+                       tcx.impl_trait_ref(possible_sibling).unwrap());\n \n-                    // the impl specializes possible_sibling\n-                    return InsertResult::ShouldRecurseOn(possible_sibling);\n-                } else if ge && !le {\n-                    debug!(\"placing as parent of TraitRef {:?}\",\n-                           tcx.impl_trait_ref(possible_sibling).unwrap());\n+                // the impl specializes possible_sibling\n+                return Ok(Inserted::ShouldRecurseOn(possible_sibling));\n+            } else if ge && !le {\n+                debug!(\"placing as parent of TraitRef {:?}\",\n+                       tcx.impl_trait_ref(possible_sibling).unwrap());\n \n                     // possible_sibling specializes the impl\n                     *slot = impl_def_id;\n-                    return InsertResult::Replaced(possible_sibling);\n-                } else {\n-                    // overlap, but no specialization; error out\n-                    return InsertResult::Overlapped(Overlap {\n-                        with_impl: possible_sibling,\n-                        on_trait_ref: impl_header.trait_ref.unwrap(),\n-                        in_context: infcx,\n-                    });\n-                }\n+                return Ok(Inserted::Replaced(possible_sibling));\n+            } else {\n+                // no overlap (error bailed already via ?)\n             }\n         }\n \n         // no overlap with any potential siblings, so add as a new sibling\n         debug!(\"placing as new sibling\");\n         self.insert_blindly(tcx, impl_def_id);\n-        InsertResult::BecameNewSibling\n+        Ok(Inserted::BecameNewSibling)\n     }\n \n-    fn iter_mut<'a>(&'a mut self) -> Box<Iterator<Item = &'a mut DefId> + 'a> {\n+    fn iter_mut(&'a mut self) -> Box<Iterator<Item = &'a mut DefId> + 'a> {\n         let nonblanket = self.nonblanket_impls.iter_mut().flat_map(|(_, v)| v.iter_mut());\n         Box::new(self.blanket_impls.iter_mut().chain(nonblanket))\n     }\n \n-    fn filtered_mut<'a>(&'a mut self, sty: SimplifiedType)\n-                        -> Box<Iterator<Item = &'a mut DefId> + 'a> {\n+    fn filtered_mut(&'a mut self, sty: SimplifiedType)\n+                    -> Box<Iterator<Item = &'a mut DefId> + 'a> {\n         let nonblanket = self.nonblanket_impls.entry(sty).or_insert(vec![]).iter_mut();\n         Box::new(self.blanket_impls.iter_mut().chain(nonblanket))\n     }\n }\n \n-impl Graph {\n+impl<'a, 'gcx, 'tcx> Graph {\n     pub fn new() -> Graph {\n         Graph {\n             parent: Default::default(),\n@@ -173,10 +192,10 @@ impl Graph {\n     /// Insert a local impl into the specialization graph. If an existing impl\n     /// conflicts with it (has overlap, but neither specializes the other),\n     /// information about the area of overlap is returned in the `Err`.\n-    pub fn insert<'a, 'tcx>(&mut self,\n-                            tcx: &'a TyCtxt<'tcx>,\n-                            impl_def_id: DefId)\n-                            -> Result<(), Overlap<'a, 'tcx>> {\n+    pub fn insert(&mut self,\n+                  tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                  impl_def_id: DefId)\n+                  -> Result<(), OverlapError> {\n         assert!(impl_def_id.is_local());\n \n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n@@ -205,10 +224,10 @@ impl Graph {\n \n         // Descend the specialization tree, where `parent` is the current parent node\n         loop {\n-            use self::InsertResult::*;\n+            use self::Inserted::*;\n \n             let insert_result = self.children.entry(parent).or_insert(Children::new())\n-                .insert(tcx, impl_def_id, simplified);\n+                .insert(tcx, impl_def_id, simplified)?;\n \n             match insert_result {\n                 BecameNewSibling => {\n@@ -224,9 +243,6 @@ impl Graph {\n                 ShouldRecurseOn(new_parent) => {\n                     parent = new_parent;\n                 }\n-                Overlapped(error) => {\n-                    return Err(error);\n-                }\n             }\n         }\n \n@@ -235,7 +251,10 @@ impl Graph {\n     }\n \n     /// Insert cached metadata mapping from a child impl back to its parent.\n-    pub fn record_impl_from_cstore(&mut self, tcx: &TyCtxt, parent: DefId, child: DefId) {\n+    pub fn record_impl_from_cstore(&mut self,\n+                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                   parent: DefId,\n+                                   child: DefId) {\n         if self.parent.insert(child, parent).is_some() {\n             bug!(\"When recording an impl from the crate store, information about its parent \\\n                   was already present.\");\n@@ -260,7 +279,7 @@ pub enum Node {\n     Trait(DefId),\n }\n \n-impl Node {\n+impl<'a, 'gcx, 'tcx> Node {\n     pub fn is_from_trait(&self) -> bool {\n         match *self {\n             Node::Trait(..) => true,\n@@ -269,11 +288,11 @@ impl Node {\n     }\n \n     /// Iterate over the items defined directly by the given (impl or trait) node.\n-    pub fn items<'a, 'tcx>(&self, tcx: &'a TyCtxt<'tcx>) -> NodeItems<'a, 'tcx> {\n+    pub fn items(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> NodeItems<'a, 'gcx> {\n         match *self {\n             Node::Impl(impl_def_id) => {\n                 NodeItems::Impl {\n-                    tcx: tcx,\n+                    tcx: tcx.global_tcx(),\n                     items: cell::Ref::map(tcx.impl_items.borrow(),\n                                           |impl_items| &impl_items[&impl_def_id]),\n                     idx: 0,\n@@ -299,7 +318,7 @@ impl Node {\n /// An iterator over the items defined within a trait or impl.\n pub enum NodeItems<'a, 'tcx: 'a> {\n     Impl {\n-        tcx: &'a TyCtxt<'tcx>,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         items: cell::Ref<'a, Vec<ty::ImplOrTraitItemId>>,\n         idx: usize,\n     },\n@@ -408,10 +427,10 @@ impl<'a, 'tcx> Iterator for ConstDefs<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Ancestors<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Ancestors<'a, 'tcx> {\n     /// Search the items from the given ancestors, returning each type definition\n     /// with the given name.\n-    pub fn type_defs(self, tcx: &'a TyCtxt<'tcx>, name: Name) -> TypeDefs<'a, 'tcx> {\n+    pub fn type_defs(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, name: Name) -> TypeDefs<'a, 'gcx> {\n         let iter = self.flat_map(move |node| {\n             node.items(tcx)\n                 .filter_map(move |item| {\n@@ -432,7 +451,7 @@ impl<'a, 'tcx> Ancestors<'a, 'tcx> {\n \n     /// Search the items from the given ancestors, returning each fn definition\n     /// with the given name.\n-    pub fn fn_defs(self, tcx: &'a TyCtxt<'tcx>, name: Name) -> FnDefs<'a, 'tcx> {\n+    pub fn fn_defs(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, name: Name) -> FnDefs<'a, 'gcx> {\n         let iter = self.flat_map(move |node| {\n             node.items(tcx)\n                 .filter_map(move |item| {\n@@ -453,7 +472,7 @@ impl<'a, 'tcx> Ancestors<'a, 'tcx> {\n \n     /// Search the items from the given ancestors, returning each const\n     /// definition with the given name.\n-    pub fn const_defs(self, tcx: &'a TyCtxt<'tcx>, name: Name) -> ConstDefs<'a, 'tcx> {\n+    pub fn const_defs(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, name: Name) -> ConstDefs<'a, 'gcx> {\n         let iter = self.flat_map(move |node| {\n             node.items(tcx)\n                 .filter_map(move |item| {"}, {"sha": "1495ae72ab34448d50d2754566c51d5c8480e50a", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 87, "deletions": 10, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -10,6 +10,7 @@\n \n use traits;\n use traits::project::Normalized;\n+use ty::{Lift, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use std::fmt;\n@@ -130,9 +131,86 @@ impl<'tcx> fmt::Debug for traits::MismatchedProjectionTypes<'tcx> {\n     }\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+// Lift implementations\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n+    type Lifted = traits::SelectionError<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            super::Unimplemented => Some(super::Unimplemented),\n+            super::OutputTypeParameterMismatch(a, b, ref err) => {\n+                tcx.lift(&(a, b)).and_then(|(a, b)| {\n+                    tcx.lift(err).map(|err| {\n+                        super::OutputTypeParameterMismatch(a, b, err)\n+                    })\n+                })\n+            }\n+            super::TraitNotObjectSafe(def_id) => {\n+                Some(super::TraitNotObjectSafe(def_id))\n+            }\n+        }\n+    }\n+}\n+\n+// For trans only.\n+impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n+    type Lifted = traits::Vtable<'tcx, ()>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match self.clone() {\n+            traits::VtableImpl(traits::VtableImplData {\n+                impl_def_id,\n+                substs,\n+                nested\n+            }) => {\n+                tcx.lift(&substs).map(|substs| {\n+                    traits::VtableImpl(traits::VtableImplData {\n+                        impl_def_id: impl_def_id,\n+                        substs: substs,\n+                        nested: nested\n+                    })\n+                })\n+            }\n+            traits::VtableDefaultImpl(t) => Some(traits::VtableDefaultImpl(t)),\n+            traits::VtableClosure(traits::VtableClosureData {\n+                closure_def_id,\n+                substs,\n+                nested\n+            }) => {\n+                tcx.lift(&substs).map(|substs| {\n+                    traits::VtableClosure(traits::VtableClosureData {\n+                        closure_def_id: closure_def_id,\n+                        substs: substs,\n+                        nested: nested\n+                    })\n+                })\n+            }\n+            traits::VtableFnPointer(ty) => {\n+                tcx.lift(&ty).map(traits::VtableFnPointer)\n+            }\n+            traits::VtableParam(n) => Some(traits::VtableParam(n)),\n+            traits::VtableBuiltin(d) => Some(traits::VtableBuiltin(d)),\n+            traits::VtableObject(traits::VtableObjectData {\n+                upcast_trait_ref,\n+                vtable_base\n+            }) => {\n+                tcx.lift(&upcast_trait_ref).map(|trait_ref| {\n+                    traits::VtableObject(traits::VtableObjectData {\n+                        upcast_trait_ref: trait_ref,\n+                        vtable_base: vtable_base\n+                    })\n+                })\n+            }\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// TypeFoldable implementations.\n+\n impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx, O>\n {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         traits::Obligation {\n             cause: self.cause.clone(),\n             recursion_depth: self.recursion_depth,\n@@ -146,11 +224,10 @@ impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx\n }\n \n impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableImplData<'tcx, N> {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let substs = self.substs.fold_with(folder);\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         traits::VtableImplData {\n             impl_def_id: self.impl_def_id,\n-            substs: folder.tcx().mk_substs(substs),\n+            substs: self.substs.fold_with(folder),\n             nested: self.nested.fold_with(folder),\n         }\n     }\n@@ -161,7 +238,7 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableImplData<\n }\n \n impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableClosureData<'tcx, N> {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         traits::VtableClosureData {\n             closure_def_id: self.closure_def_id,\n             substs: self.substs.fold_with(folder),\n@@ -175,7 +252,7 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableClosureDa\n }\n \n impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableDefaultImplData<N> {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         traits::VtableDefaultImplData {\n             trait_def_id: self.trait_def_id,\n             nested: self.nested.fold_with(folder),\n@@ -188,7 +265,7 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableDefaultIm\n }\n \n impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableBuiltinData<N> {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         traits::VtableBuiltinData {\n             nested: self.nested.fold_with(folder),\n         }\n@@ -200,7 +277,7 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableBuiltinDa\n }\n \n impl<'tcx> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx> {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         traits::VtableObjectData {\n             upcast_trait_ref: self.upcast_trait_ref.fold_with(folder),\n             vtable_base: self.vtable_base\n@@ -213,7 +290,7 @@ impl<'tcx> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx> {\n }\n \n impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N> {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n             traits::VtableImpl(ref v) => traits::VtableImpl(v.fold_with(folder)),\n             traits::VtableDefaultImpl(ref t) => traits::VtableDefaultImpl(t.fold_with(folder)),\n@@ -243,7 +320,7 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N>\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         Normalized {\n             value: self.value.fold_with(folder),\n             obligations: self.obligations.fold_with(folder),"}, {"sha": "010add012379d8de17e009472549e6ed62b6aab2", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 161, "deletions": 164, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -18,8 +18,9 @@ use util::nodemap::FnvHashSet;\n \n use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext, Normalized};\n \n-fn anonymize_predicate<'tcx>(tcx: &TyCtxt<'tcx>, pred: &ty::Predicate<'tcx>)\n-                             -> ty::Predicate<'tcx> {\n+fn anonymize_predicate<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                       pred: &ty::Predicate<'tcx>)\n+                                       -> ty::Predicate<'tcx> {\n     match *pred {\n         ty::Predicate::Trait(ref data) =>\n             ty::Predicate::Trait(tcx.anonymize_late_bound_regions(data)),\n@@ -51,13 +52,13 @@ fn anonymize_predicate<'tcx>(tcx: &TyCtxt<'tcx>, pred: &ty::Predicate<'tcx>)\n }\n \n \n-struct PredicateSet<'a,'tcx:'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+struct PredicateSet<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     set: FnvHashSet<ty::Predicate<'tcx>>,\n }\n \n-impl<'a,'tcx> PredicateSet<'a,'tcx> {\n-    fn new(tcx: &'a TyCtxt<'tcx>) -> PredicateSet<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> PredicateSet<'a, 'gcx, 'tcx> {\n+    fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> PredicateSet<'a, 'gcx, 'tcx> {\n         PredicateSet { tcx: tcx, set: FnvHashSet() }\n     }\n \n@@ -87,56 +88,56 @@ impl<'a,'tcx> PredicateSet<'a,'tcx> {\n /// that `T : PartialOrd` holds as well. Similarly, if we have `trait\n /// Foo : 'static`, and we know that `T : Foo`, then we know that `T :\n /// 'static`.\n-pub struct Elaborator<'cx, 'tcx:'cx> {\n-    tcx: &'cx TyCtxt<'tcx>,\n+pub struct Elaborator<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     stack: Vec<ty::Predicate<'tcx>>,\n-    visited: PredicateSet<'cx,'tcx>,\n+    visited: PredicateSet<'a, 'gcx, 'tcx>,\n }\n \n-pub fn elaborate_trait_ref<'cx, 'tcx>(\n-    tcx: &'cx TyCtxt<'tcx>,\n+pub fn elaborate_trait_ref<'cx, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>)\n-    -> Elaborator<'cx, 'tcx>\n+    -> Elaborator<'cx, 'gcx, 'tcx>\n {\n     elaborate_predicates(tcx, vec![trait_ref.to_predicate()])\n }\n \n-pub fn elaborate_trait_refs<'cx, 'tcx>(\n-    tcx: &'cx TyCtxt<'tcx>,\n+pub fn elaborate_trait_refs<'cx, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     trait_refs: &[ty::PolyTraitRef<'tcx>])\n-    -> Elaborator<'cx, 'tcx>\n+    -> Elaborator<'cx, 'gcx, 'tcx>\n {\n     let predicates = trait_refs.iter()\n                                .map(|trait_ref| trait_ref.to_predicate())\n                                .collect();\n     elaborate_predicates(tcx, predicates)\n }\n \n-pub fn elaborate_predicates<'cx, 'tcx>(\n-    tcx: &'cx TyCtxt<'tcx>,\n+pub fn elaborate_predicates<'cx, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     mut predicates: Vec<ty::Predicate<'tcx>>)\n-    -> Elaborator<'cx, 'tcx>\n+    -> Elaborator<'cx, 'gcx, 'tcx>\n {\n     let mut visited = PredicateSet::new(tcx);\n     predicates.retain(|pred| visited.insert(pred));\n-    Elaborator { tcx: tcx, stack: predicates, visited: visited }\n+    Elaborator { stack: predicates, visited: visited }\n }\n \n-impl<'cx, 'tcx> Elaborator<'cx, 'tcx> {\n-    pub fn filter_to_traits(self) -> FilterToTraits<Elaborator<'cx, 'tcx>> {\n+impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n+    pub fn filter_to_traits(self) -> FilterToTraits<Self> {\n         FilterToTraits::new(self)\n     }\n \n     fn push(&mut self, predicate: &ty::Predicate<'tcx>) {\n+        let tcx = self.visited.tcx;\n         match *predicate {\n             ty::Predicate::Trait(ref data) => {\n                 // Predicates declared on the trait.\n-                let predicates = self.tcx.lookup_super_predicates(data.def_id());\n+                let predicates = tcx.lookup_super_predicates(data.def_id());\n \n                 let mut predicates: Vec<_> =\n                     predicates.predicates\n                               .iter()\n-                              .map(|p| p.subst_supertrait(self.tcx, &data.to_poly_trait_ref()))\n+                              .map(|p| p.subst_supertrait(tcx, &data.to_poly_trait_ref()))\n                               .collect();\n \n                 debug!(\"super_predicates: data={:?} predicates={:?}\",\n@@ -199,7 +200,7 @@ impl<'cx, 'tcx> Elaborator<'cx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'tcx> Iterator for Elaborator<'cx, 'tcx> {\n+impl<'cx, 'gcx, 'tcx> Iterator for Elaborator<'cx, 'gcx, 'tcx> {\n     type Item = ty::Predicate<'tcx>;\n \n     fn next(&mut self) -> Option<ty::Predicate<'tcx>> {\n@@ -220,34 +221,34 @@ impl<'cx, 'tcx> Iterator for Elaborator<'cx, 'tcx> {\n // Supertrait iterator\n ///////////////////////////////////////////////////////////////////////////\n \n-pub type Supertraits<'cx, 'tcx> = FilterToTraits<Elaborator<'cx, 'tcx>>;\n+pub type Supertraits<'cx, 'gcx, 'tcx> = FilterToTraits<Elaborator<'cx, 'gcx, 'tcx>>;\n \n-pub fn supertraits<'cx, 'tcx>(tcx: &'cx TyCtxt<'tcx>,\n-                              trait_ref: ty::PolyTraitRef<'tcx>)\n-                              -> Supertraits<'cx, 'tcx>\n+pub fn supertraits<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+                                    trait_ref: ty::PolyTraitRef<'tcx>)\n+                                    -> Supertraits<'cx, 'gcx, 'tcx>\n {\n     elaborate_trait_ref(tcx, trait_ref).filter_to_traits()\n }\n \n-pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx TyCtxt<'tcx>,\n-                                    bounds: &[ty::PolyTraitRef<'tcx>])\n-                                    -> Supertraits<'cx, 'tcx>\n+pub fn transitive_bounds<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+                                          bounds: &[ty::PolyTraitRef<'tcx>])\n+                                          -> Supertraits<'cx, 'gcx, 'tcx>\n {\n     elaborate_trait_refs(tcx, bounds).filter_to_traits()\n }\n \n ///////////////////////////////////////////////////////////////////////////\n // Iterator over def-ids of supertraits\n \n-pub struct SupertraitDefIds<'cx, 'tcx:'cx> {\n-    tcx: &'cx TyCtxt<'tcx>,\n+pub struct SupertraitDefIds<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     stack: Vec<DefId>,\n     visited: FnvHashSet<DefId>,\n }\n \n-pub fn supertrait_def_ids<'cx, 'tcx>(tcx: &'cx TyCtxt<'tcx>,\n-                                     trait_def_id: DefId)\n-                                     -> SupertraitDefIds<'cx, 'tcx>\n+pub fn supertrait_def_ids<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+                                           trait_def_id: DefId)\n+                                           -> SupertraitDefIds<'cx, 'gcx, 'tcx>\n {\n     SupertraitDefIds {\n         tcx: tcx,\n@@ -256,7 +257,7 @@ pub fn supertrait_def_ids<'cx, 'tcx>(tcx: &'cx TyCtxt<'tcx>,\n     }\n }\n \n-impl<'cx, 'tcx> Iterator for SupertraitDefIds<'cx, 'tcx> {\n+impl<'cx, 'gcx, 'tcx> Iterator for SupertraitDefIds<'cx, 'gcx, 'tcx> {\n     type Item = DefId;\n \n     fn next(&mut self) -> Option<DefId> {\n@@ -319,11 +320,11 @@ impl<'tcx,I:Iterator<Item=ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n /// Instantiate all bound parameters of the impl with the given substs,\n /// returning the resulting trait ref and all obligations that arise.\n /// The obligations are closed under normalization.\n-pub fn impl_trait_ref_and_oblig<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n-                                         impl_def_id: DefId,\n-                                         impl_substs: &Substs<'tcx>)\n-                                         -> (ty::TraitRef<'tcx>,\n-                                             Vec<PredicateObligation<'tcx>>)\n+pub fn impl_trait_ref_and_oblig<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n+                                                impl_def_id: DefId,\n+                                                impl_substs: &Substs<'tcx>)\n+                                                -> (ty::TraitRef<'tcx>,\n+                                                    Vec<PredicateObligation<'tcx>>)\n {\n     let impl_trait_ref =\n         selcx.tcx().impl_trait_ref(impl_def_id).unwrap();\n@@ -352,10 +353,10 @@ pub fn impl_trait_ref_and_oblig<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n // declared on the impl declaration e.g., `impl<A,B> for Box<[(A,B)]>`\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n // variables.\n-pub fn fresh_type_vars_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                          span: Span,\n-                                          impl_def_id: DefId)\n-                                          -> Substs<'tcx>\n+pub fn fresh_type_vars_for_impl<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                                span: Span,\n+                                                impl_def_id: DefId)\n+                                                -> &'tcx Substs<'tcx>\n {\n     let tcx = infcx.tcx;\n     let impl_generics = tcx.lookup_item_type(impl_def_id).generics;\n@@ -378,26 +379,6 @@ pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n     }).collect()\n }\n \n-pub fn trait_ref_for_builtin_bound<'tcx>(\n-    tcx: &TyCtxt<'tcx>,\n-    builtin_bound: ty::BuiltinBound,\n-    param_ty: Ty<'tcx>)\n-    -> Result<ty::TraitRef<'tcx>, ErrorReported>\n-{\n-    match tcx.lang_items.from_builtin_kind(builtin_bound) {\n-        Ok(def_id) => {\n-            Ok(ty::TraitRef {\n-                def_id: def_id,\n-                substs: tcx.mk_substs(Substs::empty().with_self_ty(param_ty))\n-            })\n-        }\n-        Err(e) => {\n-            tcx.sess.err(&e);\n-            Err(ErrorReported)\n-        }\n-    }\n-}\n-\n pub fn predicate_for_trait_ref<'tcx>(\n     cause: ObligationCause<'tcx>,\n     trait_ref: ty::TraitRef<'tcx>,\n@@ -411,115 +392,131 @@ pub fn predicate_for_trait_ref<'tcx>(\n     }\n }\n \n-pub fn predicate_for_trait_def<'tcx>(\n-    tcx: &TyCtxt<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    trait_def_id: DefId,\n-    recursion_depth: usize,\n-    param_ty: Ty<'tcx>,\n-    ty_params: Vec<Ty<'tcx>>)\n-    -> PredicateObligation<'tcx>\n-{\n-    let trait_ref = ty::TraitRef {\n-        def_id: trait_def_id,\n-        substs: tcx.mk_substs(Substs::new_trait(ty_params, vec![], param_ty))\n-    };\n-    predicate_for_trait_ref(cause, trait_ref, recursion_depth)\n-}\n-\n-pub fn predicate_for_builtin_bound<'tcx>(\n-    tcx: &TyCtxt<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    builtin_bound: ty::BuiltinBound,\n-    recursion_depth: usize,\n-    param_ty: Ty<'tcx>)\n-    -> Result<PredicateObligation<'tcx>, ErrorReported>\n-{\n-    let trait_ref = trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty)?;\n-    Ok(predicate_for_trait_ref(cause, trait_ref, recursion_depth))\n-}\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    pub fn trait_ref_for_builtin_bound(self,\n+        builtin_bound: ty::BuiltinBound,\n+        param_ty: Ty<'tcx>)\n+        -> Result<ty::TraitRef<'tcx>, ErrorReported>\n+    {\n+        match self.lang_items.from_builtin_kind(builtin_bound) {\n+            Ok(def_id) => {\n+                Ok(ty::TraitRef {\n+                    def_id: def_id,\n+                    substs: self.mk_substs(Substs::empty().with_self_ty(param_ty))\n+                })\n+            }\n+            Err(e) => {\n+                self.sess.err(&e);\n+                Err(ErrorReported)\n+            }\n+        }\n+    }\n \n-/// Cast a trait reference into a reference to one of its super\n-/// traits; returns `None` if `target_trait_def_id` is not a\n-/// supertrait.\n-pub fn upcast<'tcx>(tcx: &TyCtxt<'tcx>,\n-                    source_trait_ref: ty::PolyTraitRef<'tcx>,\n-                    target_trait_def_id: DefId)\n-                    -> Vec<ty::PolyTraitRef<'tcx>>\n-{\n-    if source_trait_ref.def_id() == target_trait_def_id {\n-        return vec![source_trait_ref]; // shorcut the most common case\n+    pub fn predicate_for_trait_def(self,\n+        cause: ObligationCause<'tcx>,\n+        trait_def_id: DefId,\n+        recursion_depth: usize,\n+        param_ty: Ty<'tcx>,\n+        ty_params: Vec<Ty<'tcx>>)\n+        -> PredicateObligation<'tcx>\n+    {\n+        let trait_ref = ty::TraitRef {\n+            def_id: trait_def_id,\n+            substs: self.mk_substs(Substs::new_trait(ty_params, vec![], param_ty))\n+        };\n+        predicate_for_trait_ref(cause, trait_ref, recursion_depth)\n     }\n \n-    supertraits(tcx, source_trait_ref)\n-        .filter(|r| r.def_id() == target_trait_def_id)\n-        .collect()\n-}\n+    pub fn predicate_for_builtin_bound(self,\n+        cause: ObligationCause<'tcx>,\n+        builtin_bound: ty::BuiltinBound,\n+        recursion_depth: usize,\n+        param_ty: Ty<'tcx>)\n+        -> Result<PredicateObligation<'tcx>, ErrorReported>\n+    {\n+        let trait_ref = self.trait_ref_for_builtin_bound(builtin_bound, param_ty)?;\n+        Ok(predicate_for_trait_ref(cause, trait_ref, recursion_depth))\n+    }\n \n-/// Given a trait `trait_ref`, returns the number of vtable entries\n-/// that come from `trait_ref`, excluding its supertraits. Used in\n-/// computing the vtable base for an upcast trait of a trait object.\n-pub fn count_own_vtable_entries<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                      trait_ref: ty::PolyTraitRef<'tcx>)\n-                                      -> usize {\n-    let mut entries = 0;\n-    // Count number of methods and add them to the total offset.\n-    // Skip over associated types and constants.\n-    for trait_item in &tcx.trait_items(trait_ref.def_id())[..] {\n-        if let ty::MethodTraitItem(_) = *trait_item {\n-            entries += 1;\n+    /// Cast a trait reference into a reference to one of its super\n+    /// traits; returns `None` if `target_trait_def_id` is not a\n+    /// supertrait.\n+    pub fn upcast_choices(self,\n+                          source_trait_ref: ty::PolyTraitRef<'tcx>,\n+                          target_trait_def_id: DefId)\n+                          -> Vec<ty::PolyTraitRef<'tcx>>\n+    {\n+        if source_trait_ref.def_id() == target_trait_def_id {\n+            return vec![source_trait_ref]; // shorcut the most common case\n         }\n+\n+        supertraits(self, source_trait_ref)\n+            .filter(|r| r.def_id() == target_trait_def_id)\n+            .collect()\n     }\n-    entries\n-}\n \n-/// Given an upcast trait object described by `object`, returns the\n-/// index of the method `method_def_id` (which should be part of\n-/// `object.upcast_trait_ref`) within the vtable for `object`.\n-pub fn get_vtable_index_of_object_method<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                               object: &super::VtableObjectData<'tcx>,\n-                                               method_def_id: DefId) -> usize {\n-    // Count number of methods preceding the one we are selecting and\n-    // add them to the total offset.\n-    // Skip over associated types and constants.\n-    let mut entries = object.vtable_base;\n-    for trait_item in &tcx.trait_items(object.upcast_trait_ref.def_id())[..] {\n-        if trait_item.def_id() == method_def_id {\n-            // The item with the ID we were given really ought to be a method.\n-            assert!(match *trait_item {\n-                ty::MethodTraitItem(_) => true,\n-                _ => false\n-            });\n-\n-            return entries;\n+    /// Given a trait `trait_ref`, returns the number of vtable entries\n+    /// that come from `trait_ref`, excluding its supertraits. Used in\n+    /// computing the vtable base for an upcast trait of a trait object.\n+    pub fn count_own_vtable_entries(self, trait_ref: ty::PolyTraitRef<'tcx>) -> usize {\n+        let mut entries = 0;\n+        // Count number of methods and add them to the total offset.\n+        // Skip over associated types and constants.\n+        for trait_item in &self.trait_items(trait_ref.def_id())[..] {\n+            if let ty::MethodTraitItem(_) = *trait_item {\n+                entries += 1;\n+            }\n         }\n-        if let ty::MethodTraitItem(_) = *trait_item {\n-            entries += 1;\n+        entries\n+    }\n+\n+    /// Given an upcast trait object described by `object`, returns the\n+    /// index of the method `method_def_id` (which should be part of\n+    /// `object.upcast_trait_ref`) within the vtable for `object`.\n+    pub fn get_vtable_index_of_object_method(self,\n+                                             object: &super::VtableObjectData<'tcx>,\n+                                             method_def_id: DefId) -> usize {\n+        // Count number of methods preceding the one we are selecting and\n+        // add them to the total offset.\n+        // Skip over associated types and constants.\n+        let mut entries = object.vtable_base;\n+        for trait_item in &self.trait_items(object.upcast_trait_ref.def_id())[..] {\n+            if trait_item.def_id() == method_def_id {\n+                // The item with the ID we were given really ought to be a method.\n+                assert!(match *trait_item {\n+                    ty::MethodTraitItem(_) => true,\n+                    _ => false\n+                });\n+\n+                return entries;\n+            }\n+            if let ty::MethodTraitItem(_) = *trait_item {\n+                entries += 1;\n+            }\n         }\n+\n+        bug!(\"get_vtable_index_of_object_method: {:?} was not found\",\n+             method_def_id);\n     }\n \n-    bug!(\"get_vtable_index_of_object_method: {:?} was not found\",\n-         method_def_id);\n+    pub fn closure_trait_ref_and_return_type(self,\n+        fn_trait_def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+        sig: &ty::PolyFnSig<'tcx>,\n+        tuple_arguments: TupleArgumentsFlag)\n+        -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>)>\n+    {\n+        let arguments_tuple = match tuple_arguments {\n+            TupleArgumentsFlag::No => sig.0.inputs[0],\n+            TupleArgumentsFlag::Yes => self.mk_tup(sig.0.inputs.to_vec()),\n+        };\n+        let trait_substs = Substs::new_trait(vec![arguments_tuple], vec![], self_ty);\n+        let trait_ref = ty::TraitRef {\n+            def_id: fn_trait_def_id,\n+            substs: self.mk_substs(trait_substs),\n+        };\n+        ty::Binder((trait_ref, sig.0.output.unwrap_or(self.mk_nil())))\n+    }\n }\n \n pub enum TupleArgumentsFlag { Yes, No }\n-\n-pub fn closure_trait_ref_and_return_type<'tcx>(\n-    tcx: &TyCtxt<'tcx>,\n-    fn_trait_def_id: DefId,\n-    self_ty: Ty<'tcx>,\n-    sig: &ty::PolyFnSig<'tcx>,\n-    tuple_arguments: TupleArgumentsFlag)\n-    -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>)>\n-{\n-    let arguments_tuple = match tuple_arguments {\n-        TupleArgumentsFlag::No => sig.0.inputs[0],\n-        TupleArgumentsFlag::Yes => tcx.mk_tup(sig.0.inputs.to_vec()),\n-    };\n-    let trait_substs = Substs::new_trait(vec![arguments_tuple], vec![], self_ty);\n-    let trait_ref = ty::TraitRef {\n-        def_id: fn_trait_def_id,\n-        substs: tcx.mk_substs(trait_substs),\n-    };\n-    ty::Binder((trait_ref, sig.0.output.unwrap_or(tcx.mk_nil())))\n-}"}, {"sha": "39dba57c47b7c855fe1bf6cad60dc778dad0aa6c", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -28,26 +28,26 @@ use ty::relate::{self, Relate, TypeRelation, RelateResult};\n /// Like subtyping, matching is really a binary relation, so the only\n /// important thing about the result is Ok/Err. Also, matching never\n /// affects any type variables or unification state.\n-pub struct Match<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>\n+pub struct Match<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>\n }\n \n-impl<'a, 'tcx> Match<'a, 'tcx> {\n-    pub fn new(tcx: &'a TyCtxt<'tcx>) -> Match<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Match<'a, 'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Match<'a, 'gcx, 'tcx> {\n         Match { tcx: tcx }\n     }\n }\n \n-impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Match<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Match<'a, 'gcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Match\" }\n-    fn tcx(&self) -> &'a TyCtxt<'tcx> { self.tcx }\n+    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> { self.tcx }\n     fn a_is_expected(&self) -> bool { true } // irrelevant\n \n-    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n-                                               _: ty::Variance,\n-                                               a: &T,\n-                                               b: &T)\n-                                               -> RelateResult<'tcx, T>\n+    fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n+                                             _: ty::Variance,\n+                                             a: &T,\n+                                             b: &T)\n+                                             -> RelateResult<'tcx, T>\n     {\n         self.relate(a, b)\n     }\n@@ -89,7 +89,7 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Match<'a, 'tcx> {\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n-        where T: Relate<'a,'tcx>\n+        where T: Relate<'tcx>\n     {\n         Ok(ty::Binder(self.relate(a.skip_binder(), b.skip_binder())?))\n     }"}, {"sha": "71e49031347b8fcb4514070e1939e324e012be9a", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -136,9 +136,10 @@ pub enum CustomCoerceUnsized {\n     Struct(usize)\n }\n \n-impl<'tcx> ty::TyS<'tcx> {\n+impl<'a, 'gcx, 'tcx> ty::TyS<'tcx> {\n     /// See `expr_ty_adjusted`\n-    pub fn adjust<F>(&'tcx self, cx: &TyCtxt<'tcx>,\n+    pub fn adjust<F>(&'tcx self,\n+                     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                      span: Span,\n                      expr_id: ast::NodeId,\n                      adjustment: Option<&AutoAdjustment<'tcx>>,\n@@ -155,9 +156,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                 match *adjustment {\n                     AdjustReifyFnPointer => {\n                         match self.sty {\n-                            ty::TyFnDef(_, _, b) => {\n-                                cx.mk_ty(ty::TyFnPtr(b))\n-                            }\n+                            ty::TyFnDef(_, _, f) => tcx.mk_fn_ptr(f),\n                             _ => {\n                                 bug!(\"AdjustReifyFnPointer adjustment on non-fn-item: {:?}\",\n                                      self);\n@@ -167,7 +166,7 @@ impl<'tcx> ty::TyS<'tcx> {\n \n                     AdjustUnsafeFnPointer => {\n                         match self.sty {\n-                            ty::TyFnPtr(b) => cx.safe_to_unsafe_fn_ty(b),\n+                            ty::TyFnPtr(b) => tcx.safe_to_unsafe_fn_ty(b),\n                             ref b => {\n                                 bug!(\"AdjustUnsafeFnPointer adjustment on non-fn-ptr: {:?}\",\n                                      b);\n@@ -177,7 +176,7 @@ impl<'tcx> ty::TyS<'tcx> {\n \n                     AdjustMutToConstPointer => {\n                         match self.sty {\n-                            ty::TyRawPtr(mt) => cx.mk_ptr(ty::TypeAndMut {\n+                            ty::TyRawPtr(mt) => tcx.mk_ptr(ty::TypeAndMut {\n                                 ty: mt.ty,\n                                 mutbl: hir::MutImmutable\n                             }),\n@@ -194,7 +193,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                         if !adjusted_ty.references_error() {\n                             for i in 0..adj.autoderefs {\n                                 adjusted_ty =\n-                                    adjusted_ty.adjust_for_autoderef(cx,\n+                                    adjusted_ty.adjust_for_autoderef(tcx,\n                                                                      expr_id,\n                                                                      span,\n                                                                      i as u32,\n@@ -205,7 +204,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                         if let Some(target) = adj.unsize {\n                             target\n                         } else {\n-                            adjusted_ty.adjust_for_autoref(cx, adj.autoref)\n+                            adjusted_ty.adjust_for_autoref(tcx, adj.autoref)\n                         }\n                     }\n                 }\n@@ -215,7 +214,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     }\n \n     pub fn adjust_for_autoderef<F>(&'tcx self,\n-                                   cx: &TyCtxt<'tcx>,\n+                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                    expr_id: ast::NodeId,\n                                    expr_span: Span,\n                                    autoderef: u32, // how many autoderefs so far?\n@@ -228,7 +227,7 @@ impl<'tcx> ty::TyS<'tcx> {\n         if let Some(method_ty) = method_type(method_call) {\n             // Method calls always have all late-bound regions\n             // fully instantiated.\n-            let fn_ret = cx.no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n+            let fn_ret = tcx.no_late_bound_regions(&method_ty.fn_ret()).unwrap();\n             adjusted_ty = fn_ret.unwrap();\n         }\n         match adjusted_ty.builtin_deref(true, NoPreference) {\n@@ -243,16 +242,16 @@ impl<'tcx> ty::TyS<'tcx> {\n         }\n     }\n \n-    pub fn adjust_for_autoref(&'tcx self, cx: &TyCtxt<'tcx>,\n+    pub fn adjust_for_autoref(&'tcx self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                               autoref: Option<AutoRef<'tcx>>)\n                               -> Ty<'tcx> {\n         match autoref {\n             None => self,\n             Some(AutoPtr(r, m)) => {\n-                cx.mk_ref(r, TypeAndMut { ty: self, mutbl: m })\n+                tcx.mk_ref(r, TypeAndMut { ty: self, mutbl: m })\n             }\n             Some(AutoUnsafe(m)) => {\n-                cx.mk_ptr(TypeAndMut { ty: self, mutbl: m })\n+                tcx.mk_ptr(TypeAndMut { ty: self, mutbl: m })\n             }\n         }\n     }"}, {"sha": "33b33092b25c04c672558f9411904c891be416ec", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -89,7 +89,7 @@ impl TypeContents {\n         self.intersects(TC::InteriorUnsafe)\n     }\n \n-    pub fn needs_drop(&self, _: &TyCtxt) -> bool {\n+    pub fn needs_drop(&self, _: TyCtxt) -> bool {\n         self.intersects(TC::NeedsDrop)\n     }\n \n@@ -139,15 +139,15 @@ impl fmt::Debug for TypeContents {\n     }\n }\n \n-impl<'tcx> ty::TyS<'tcx> {\n-    pub fn type_contents(&'tcx self, cx: &TyCtxt<'tcx>) -> TypeContents {\n-        return cx.tc_cache.memoize(self, || tc_ty(cx, self, &mut FnvHashMap()));\n+impl<'a, 'tcx> ty::TyS<'tcx> {\n+    pub fn type_contents(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> TypeContents {\n+        return tcx.tc_cache.memoize(self, || tc_ty(tcx, self, &mut FnvHashMap()));\n \n-        fn tc_ty<'tcx>(cx: &TyCtxt<'tcx>,\n-                       ty: Ty<'tcx>,\n-                       cache: &mut FnvHashMap<Ty<'tcx>, TypeContents>) -> TypeContents\n+        fn tc_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           ty: Ty<'tcx>,\n+                           cache: &mut FnvHashMap<Ty<'tcx>, TypeContents>) -> TypeContents\n         {\n-            // Subtle: Note that we are *not* using cx.tc_cache here but rather a\n+            // Subtle: Note that we are *not* using tcx.tc_cache here but rather a\n             // private cache for this walk.  This is needed in the case of cyclic\n             // types like:\n             //\n@@ -163,7 +163,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             // The problem is, as we are doing the computation, we will also\n             // compute an *intermediate* contents for, e.g., Option<List> of\n             // TC::None.  This is ok during the computation of List itself, but if\n-            // we stored this intermediate value into cx.tc_cache, then later\n+            // we stored this intermediate value into tcx.tc_cache, then later\n             // requests for the contents of Option<List> would also yield TC::None\n             // which is incorrect.  This value was computed based on the crutch\n             // value for the type contents of list.  The correct value is\n@@ -172,7 +172,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                 Some(tc) => { return *tc; }\n                 None => {}\n             }\n-            match cx.tc_cache.borrow().get(&ty) {    // Must check both caches!\n+            match tcx.tc_cache.borrow().get(&ty) {    // Must check both caches!\n                 Some(tc) => { return *tc; }\n                 None => {}\n             }\n@@ -192,7 +192,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                 }\n \n                 ty::TyBox(typ) => {\n-                    tc_ty(cx, typ, cache).owned_pointer()\n+                    tc_ty(tcx, typ, cache).owned_pointer()\n                 }\n \n                 ty::TyTrait(_) => {\n@@ -208,36 +208,36 @@ impl<'tcx> ty::TyS<'tcx> {\n                 }\n \n                 ty::TyArray(ty, _) => {\n-                    tc_ty(cx, ty, cache)\n+                    tc_ty(tcx, ty, cache)\n                 }\n \n                 ty::TySlice(ty) => {\n-                    tc_ty(cx, ty, cache)\n+                    tc_ty(tcx, ty, cache)\n                 }\n                 ty::TyStr => TC::None,\n \n                 ty::TyClosure(_, ref substs) => {\n-                    TypeContents::union(&substs.upvar_tys, |ty| tc_ty(cx, &ty, cache))\n+                    TypeContents::union(&substs.upvar_tys, |ty| tc_ty(tcx, &ty, cache))\n                 }\n \n                 ty::TyTuple(ref tys) => {\n                     TypeContents::union(&tys[..],\n-                                        |ty| tc_ty(cx, *ty, cache))\n+                                        |ty| tc_ty(tcx, *ty, cache))\n                 }\n \n                 ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n                     let mut res =\n                         TypeContents::union(&def.variants, |v| {\n                             TypeContents::union(&v.fields, |f| {\n-                                tc_ty(cx, f.ty(cx, substs), cache)\n+                                tc_ty(tcx, f.ty(tcx, substs), cache)\n                             })\n                         });\n \n                     if def.has_dtor() {\n                         res = res | TC::OwnsDtor;\n                     }\n \n-                    apply_lang_items(cx, def.did, res)\n+                    apply_lang_items(tcx, def.did, res)\n                 }\n \n                 ty::TyProjection(..) |\n@@ -255,9 +255,10 @@ impl<'tcx> ty::TyS<'tcx> {\n             result\n         }\n \n-        fn apply_lang_items(cx: &TyCtxt, did: DefId, tc: TypeContents)\n-                            -> TypeContents {\n-            if Some(did) == cx.lang_items.unsafe_cell_type() {\n+        fn apply_lang_items<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      did: DefId, tc: TypeContents)\n+                                      -> TypeContents {\n+            if Some(did) == tcx.lang_items.unsafe_cell_type() {\n                 tc | TC::InteriorUnsafe\n             } else {\n                 tc"}, {"sha": "39fe744c67d01528f865e96728918c589d6e2b45", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 474, "deletions": 261, "changes": 735, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -22,7 +22,7 @@ use middle::free_region::FreeRegionMap;\n use middle::region::RegionMaps;\n use middle::resolve_lifetime;\n use middle::stability;\n-use ty::subst::{self, Subst, Substs};\n+use ty::subst::{self, Substs};\n use traits;\n use ty::{self, TraitRef, Ty, TypeAndMut};\n use ty::{TyS, TypeVariants};\n@@ -35,12 +35,14 @@ use ty::layout::{Layout, TargetDataLayout};\n use ty::maps;\n use util::common::MemoizationMap;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::{FnvHashMap, FnvHashSet};\n \n use arena::TypedArena;\n use std::borrow::Borrow;\n use std::cell::{Cell, RefCell, Ref};\n use std::hash::{Hash, Hasher};\n+use std::mem;\n+use std::ops::Deref;\n use std::rc::Rc;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n@@ -52,6 +54,7 @@ use hir;\n pub struct CtxtArenas<'tcx> {\n     // internings\n     type_: TypedArena<TyS<'tcx>>,\n+    type_list: TypedArena<Vec<Ty<'tcx>>>,\n     substs: TypedArena<Substs<'tcx>>,\n     bare_fn: TypedArena<BareFnTy<'tcx>>,\n     region: TypedArena<Region>,\n@@ -67,6 +70,7 @@ impl<'tcx> CtxtArenas<'tcx> {\n     pub fn new() -> CtxtArenas<'tcx> {\n         CtxtArenas {\n             type_: TypedArena::new(),\n+            type_list: TypedArena::new(),\n             substs: TypedArena::new(),\n             bare_fn: TypedArena::new(),\n             region: TypedArena::new(),\n@@ -79,6 +83,97 @@ impl<'tcx> CtxtArenas<'tcx> {\n     }\n }\n \n+pub struct CtxtInterners<'tcx> {\n+    /// The arenas that types etc are allocated from.\n+    arenas: &'tcx CtxtArenas<'tcx>,\n+\n+    /// Specifically use a speedy hash algorithm for these hash sets,\n+    /// they're accessed quite often.\n+    type_: RefCell<FnvHashSet<Interned<'tcx, TyS<'tcx>>>>,\n+    type_list: RefCell<FnvHashSet<Interned<'tcx, [Ty<'tcx>]>>>,\n+    substs: RefCell<FnvHashSet<Interned<'tcx, Substs<'tcx>>>>,\n+    bare_fn: RefCell<FnvHashSet<Interned<'tcx, BareFnTy<'tcx>>>>,\n+    region: RefCell<FnvHashSet<Interned<'tcx, Region>>>,\n+    stability: RefCell<FnvHashSet<&'tcx attr::Stability>>,\n+    layout: RefCell<FnvHashSet<&'tcx Layout>>,\n+}\n+\n+impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n+    fn new(arenas: &'tcx CtxtArenas<'tcx>) -> CtxtInterners<'tcx> {\n+        CtxtInterners {\n+            arenas: arenas,\n+            type_: RefCell::new(FnvHashSet()),\n+            type_list: RefCell::new(FnvHashSet()),\n+            substs: RefCell::new(FnvHashSet()),\n+            bare_fn: RefCell::new(FnvHashSet()),\n+            region: RefCell::new(FnvHashSet()),\n+            stability: RefCell::new(FnvHashSet()),\n+            layout: RefCell::new(FnvHashSet())\n+        }\n+    }\n+\n+    /// Intern a type. global_interners is Some only if this is\n+    /// a local interner and global_interners is its counterpart.\n+    fn intern_ty(&self, st: TypeVariants<'tcx>,\n+                 global_interners: Option<&CtxtInterners<'gcx>>)\n+                 -> Ty<'tcx> {\n+        let ty = {\n+            let mut interner = self.type_.borrow_mut();\n+            let global_interner = global_interners.map(|interners| {\n+                interners.type_.borrow_mut()\n+            });\n+            if let Some(&Interned(ty)) = interner.get(&st) {\n+                return ty;\n+            }\n+            if let Some(ref interner) = global_interner {\n+                if let Some(&Interned(ty)) = interner.get(&st) {\n+                    return ty;\n+                }\n+            }\n+\n+            let flags = super::flags::FlagComputation::for_sty(&st);\n+            let ty_struct = TyS {\n+                sty: st,\n+                flags: Cell::new(flags.flags),\n+                region_depth: flags.depth,\n+            };\n+\n+            // HACK(eddyb) Depend on flags being accurate to\n+            // determine that all contents are in the global tcx.\n+            // See comments on Lift for why we can't use that.\n+            if !flags.flags.intersects(ty::TypeFlags::KEEP_IN_LOCAL_TCX) {\n+                if let Some(interner) = global_interners {\n+                    let ty_struct: TyS<'gcx> = unsafe {\n+                        mem::transmute(ty_struct)\n+                    };\n+                    let ty: Ty<'gcx> = interner.arenas.type_.alloc(ty_struct);\n+                    global_interner.unwrap().insert(Interned(ty));\n+                    return ty;\n+                }\n+            } else {\n+                // Make sure we don't end up with inference\n+                // types/regions in the global tcx.\n+                if global_interners.is_none() {\n+                    drop(interner);\n+                    bug!(\"Attempted to intern `{:?}` which contains \\\n+                          inference types/regions in the global type context\",\n+                         &ty_struct);\n+                }\n+            }\n+\n+            // Don't be &mut TyS.\n+            let ty: Ty<'tcx> = self.arenas.type_.alloc(ty_struct);\n+            interner.insert(Interned(ty));\n+            ty\n+        };\n+\n+        debug!(\"Interned type: {:?} Pointer: {:?}\",\n+            ty, ty as *const TyS);\n+        ty\n+    }\n+\n+}\n+\n pub struct CommonTypes<'tcx> {\n     pub bool: Ty<'tcx>,\n     pub char: Ty<'tcx>,\n@@ -138,7 +233,7 @@ pub struct Tables<'tcx> {\n     pub fru_field_types: NodeMap<Vec<Ty<'tcx>>>\n }\n \n-impl<'tcx> Tables<'tcx> {\n+impl<'a, 'gcx, 'tcx> Tables<'tcx> {\n     pub fn empty() -> Tables<'tcx> {\n         Tables {\n             node_types: FnvHashMap(),\n@@ -152,48 +247,11 @@ impl<'tcx> Tables<'tcx> {\n             fru_field_types: NodeMap()\n         }\n     }\n-\n-    pub fn closure_kind(this: &RefCell<Self>,\n-                        tcx: &TyCtxt<'tcx>,\n-                        def_id: DefId)\n-                        -> ty::ClosureKind {\n-        // If this is a local def-id, it should be inserted into the\n-        // tables by typeck; else, it will be retreived from\n-        // the external crate metadata.\n-        if let Some(&kind) = this.borrow().closure_kinds.get(&def_id) {\n-            return kind;\n-        }\n-\n-        let kind = tcx.sess.cstore.closure_kind(tcx, def_id);\n-        this.borrow_mut().closure_kinds.insert(def_id, kind);\n-        kind\n-    }\n-\n-    pub fn closure_type(this: &RefCell<Self>,\n-                        tcx: &TyCtxt<'tcx>,\n-                        def_id: DefId,\n-                        substs: &ClosureSubsts<'tcx>)\n-                        -> ty::ClosureTy<'tcx>\n-    {\n-        // If this is a local def-id, it should be inserted into the\n-        // tables by typeck; else, it will be retreived from\n-        // the external crate metadata.\n-        if let Some(ty) = this.borrow().closure_tys.get(&def_id) {\n-            return ty.subst(tcx, &substs.func_substs);\n-        }\n-\n-        let ty = tcx.sess.cstore.closure_ty(tcx, def_id);\n-        this.borrow_mut().closure_tys.insert(def_id, ty.clone());\n-        ty.subst(tcx, &substs.func_substs)\n-    }\n }\n \n impl<'tcx> CommonTypes<'tcx> {\n-    fn new(arena: &'tcx TypedArena<TyS<'tcx>>,\n-           interner: &RefCell<FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>>)\n-           -> CommonTypes<'tcx>\n-    {\n-        let mk = |sty| TyCtxt::intern_ty(arena, interner, sty);\n+    fn new(interners: &CtxtInterners<'tcx>) -> CommonTypes<'tcx> {\n+        let mk = |sty| interners.intern_ty(sty, None);\n         CommonTypes {\n             bool: mk(TyBool),\n             char: mk(TyChar),\n@@ -217,22 +275,21 @@ impl<'tcx> CommonTypes<'tcx> {\n /// The data structure to keep track of all the information that typechecker\n /// generates so that so that it can be reused and doesn't have to be redone\n /// later on.\n-pub struct TyCtxt<'tcx> {\n-    /// The arenas that types etc are allocated from.\n-    arenas: &'tcx CtxtArenas<'tcx>,\n+#[derive(Copy, Clone)]\n+pub struct TyCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    gcx: &'a GlobalCtxt<'gcx>,\n+    interners: &'a CtxtInterners<'tcx>\n+}\n \n-    /// Specifically use a speedy hash algorithm for this hash map, it's used\n-    /// quite often.\n-    // FIXME(eddyb) use a FnvHashSet<InternedTy<'tcx>> when equivalent keys can\n-    // queried from a HashSet.\n-    interner: RefCell<FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>>,\n+impl<'a, 'gcx, 'tcx> Deref for TyCtxt<'a, 'gcx, 'tcx> {\n+    type Target = &'a GlobalCtxt<'gcx>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.gcx\n+    }\n+}\n \n-    // FIXME as above, use a hashset if equivalent elements can be queried.\n-    substs_interner: RefCell<FnvHashMap<&'tcx Substs<'tcx>, &'tcx Substs<'tcx>>>,\n-    bare_fn_interner: RefCell<FnvHashMap<&'tcx BareFnTy<'tcx>, &'tcx BareFnTy<'tcx>>>,\n-    region_interner: RefCell<FnvHashMap<&'tcx Region, &'tcx Region>>,\n-    stability_interner: RefCell<FnvHashMap<&'tcx attr::Stability, &'tcx attr::Stability>>,\n-    layout_interner: RefCell<FnvHashMap<&'tcx Layout, &'tcx Layout>>,\n+pub struct GlobalCtxt<'tcx> {\n+    global_interners: CtxtInterners<'tcx>,\n \n     pub dep_graph: DepGraph,\n \n@@ -300,11 +357,6 @@ pub struct TyCtxt<'tcx> {\n     // Cache for the type-contents routine. FIXME -- track deps?\n     pub tc_cache: RefCell<FnvHashMap<Ty<'tcx>, ty::contents::TypeContents>>,\n \n-    // Cache for various types within a method body and so forth.\n-    //\n-    // FIXME this should be made local to typeck, but it is currently used by one lint\n-    pub ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n-\n     // FIXME no dep tracking, but we should be able to remove this\n     pub ty_param_defs: RefCell<NodeMap<ty::TypeParameterDef<'tcx>>>,\n \n@@ -432,144 +484,160 @@ pub struct TyCtxt<'tcx> {\n     pub layout_cache: RefCell<FnvHashMap<Ty<'tcx>, &'tcx Layout>>,\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn crate_name(&self, cnum: ast::CrateNum) -> token::InternedString {\n+impl<'tcx> GlobalCtxt<'tcx> {\n+    /// Get the global TyCtxt.\n+    pub fn global_tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        TyCtxt {\n+            gcx: self,\n+            interners: &self.global_interners\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    pub fn crate_name(self, cnum: ast::CrateNum) -> token::InternedString {\n         if cnum == LOCAL_CRATE {\n             self.crate_name.clone()\n         } else {\n             self.sess.cstore.crate_name(cnum)\n         }\n     }\n \n-    pub fn crate_disambiguator(&self, cnum: ast::CrateNum) -> token::InternedString {\n+    pub fn crate_disambiguator(self, cnum: ast::CrateNum) -> token::InternedString {\n         if cnum == LOCAL_CRATE {\n             self.sess.crate_disambiguator.get().as_str()\n         } else {\n             self.sess.cstore.crate_disambiguator(cnum)\n         }\n     }\n \n-    pub fn type_parameter_def(&self,\n+    pub fn type_parameter_def(self,\n                               node_id: NodeId)\n                               -> ty::TypeParameterDef<'tcx>\n     {\n         self.ty_param_defs.borrow().get(&node_id).unwrap().clone()\n     }\n \n-    pub fn node_types(&self) -> Ref<NodeMap<Ty<'tcx>>> {\n+    pub fn node_types(self) -> Ref<'a, NodeMap<Ty<'tcx>>> {\n         fn projection<'a, 'tcx>(tables: &'a Tables<'tcx>) -> &'a NodeMap<Ty<'tcx>> {\n             &tables.node_types\n         }\n \n         Ref::map(self.tables.borrow(), projection)\n     }\n \n-    pub fn node_type_insert(&self, id: NodeId, ty: Ty<'tcx>) {\n+    pub fn node_type_insert(self, id: NodeId, ty: Ty<'gcx>) {\n         self.tables.borrow_mut().node_types.insert(id, ty);\n     }\n \n-    pub fn intern_trait_def(&self, def: ty::TraitDef<'tcx>)\n-                            -> &'tcx ty::TraitDef<'tcx> {\n+    pub fn intern_trait_def(self, def: ty::TraitDef<'gcx>)\n+                            -> &'gcx ty::TraitDef<'gcx> {\n         let did = def.trait_ref.def_id;\n-        let interned = self.arenas.trait_defs.alloc(def);\n+        let interned = self.global_interners.arenas.trait_defs.alloc(def);\n         if let Some(prev) = self.trait_defs.borrow_mut().insert(did, interned) {\n             bug!(\"Tried to overwrite interned TraitDef: {:?}\", prev)\n         }\n         interned\n     }\n \n-    pub fn alloc_trait_def(&self, def: ty::TraitDef<'tcx>)\n-                           -> &'tcx ty::TraitDef<'tcx> {\n-        self.arenas.trait_defs.alloc(def)\n+    pub fn alloc_trait_def(self, def: ty::TraitDef<'gcx>)\n+                           -> &'gcx ty::TraitDef<'gcx> {\n+        self.global_interners.arenas.trait_defs.alloc(def)\n     }\n \n-    pub fn intern_adt_def(&self,\n+    pub fn intern_adt_def(self,\n                           did: DefId,\n                           kind: ty::AdtKind,\n-                          variants: Vec<ty::VariantDefData<'tcx, 'tcx>>)\n-                          -> ty::AdtDefMaster<'tcx> {\n+                          variants: Vec<ty::VariantDefData<'gcx, 'gcx>>)\n+                          -> ty::AdtDefMaster<'gcx> {\n         let def = ty::AdtDefData::new(self, did, kind, variants);\n-        let interned = self.arenas.adt_defs.alloc(def);\n+        let interned = self.global_interners.arenas.adt_defs.alloc(def);\n         // this will need a transmute when reverse-variance is removed\n         if let Some(prev) = self.adt_defs.borrow_mut().insert(did, interned) {\n             bug!(\"Tried to overwrite interned AdtDef: {:?}\", prev)\n         }\n         interned\n     }\n \n-    pub fn intern_stability(&self, stab: attr::Stability) -> &'tcx attr::Stability {\n-        if let Some(st) = self.stability_interner.borrow().get(&stab) {\n+    pub fn intern_stability(self, stab: attr::Stability) -> &'gcx attr::Stability {\n+        if let Some(st) = self.global_interners.stability.borrow().get(&stab) {\n             return st;\n         }\n \n-        let interned = self.arenas.stability.alloc(stab);\n-        if let Some(prev) = self.stability_interner\n+        let interned = self.global_interners.arenas.stability.alloc(stab);\n+        if let Some(prev) = self.global_interners.stability\n                                 .borrow_mut()\n-                                .insert(interned, interned) {\n+                                .replace(interned) {\n             bug!(\"Tried to overwrite interned Stability: {:?}\", prev)\n         }\n         interned\n     }\n \n-    pub fn intern_layout(&self, layout: Layout) -> &'tcx Layout {\n-        if let Some(layout) = self.layout_interner.borrow().get(&layout) {\n+    pub fn intern_layout(self, layout: Layout) -> &'gcx Layout {\n+        if let Some(layout) = self.global_interners.layout.borrow().get(&layout) {\n             return layout;\n         }\n \n-        let interned = self.arenas.layout.alloc(layout);\n-        if let Some(prev) = self.layout_interner\n+        let interned = self.global_interners.arenas.layout.alloc(layout);\n+        if let Some(prev) = self.global_interners.layout\n                                 .borrow_mut()\n-                                .insert(interned, interned) {\n+                                .replace(interned) {\n             bug!(\"Tried to overwrite interned Layout: {:?}\", prev)\n         }\n         interned\n     }\n \n-    pub fn store_free_region_map(&self, id: NodeId, map: FreeRegionMap) {\n+    pub fn store_free_region_map(self, id: NodeId, map: FreeRegionMap) {\n         if self.free_region_maps.borrow_mut().insert(id, map).is_some() {\n             bug!(\"Tried to overwrite interned FreeRegionMap for NodeId {:?}\", id)\n         }\n     }\n \n-    pub fn free_region_map(&self, id: NodeId) -> FreeRegionMap {\n+    pub fn free_region_map(self, id: NodeId) -> FreeRegionMap {\n         self.free_region_maps.borrow()[&id].clone()\n     }\n \n-    pub fn lift<T: ?Sized + Lift<'tcx>>(&self, value: &T) -> Option<T::Lifted> {\n+    pub fn lift<T: ?Sized + Lift<'tcx>>(self, value: &T) -> Option<T::Lifted> {\n         value.lift_to_tcx(self)\n     }\n \n-    /// Create a type context and call the closure with a `&TyCtxt` reference\n+    /// Like lift, but only tries in the global tcx.\n+    pub fn lift_to_global<T: ?Sized + Lift<'gcx>>(self, value: &T) -> Option<T::Lifted> {\n+        value.lift_to_tcx(self.global_tcx())\n+    }\n+\n+    /// Returns true if self is the same as self.global_tcx().\n+    fn is_global(self) -> bool {\n+        let local = self.interners as *const _;\n+        let global = &self.global_interners as *const _;\n+        local as usize == global as usize\n+    }\n+\n+    /// Create a type context and call the closure with a `TyCtxt` reference\n     /// to the context. The closure enforces that the type context and any interned\n     /// value (types, substs, etc.) can only be used while `ty::tls` has a valid\n     /// reference to the context, to allow formatting values that need it.\n     pub fn create_and_enter<F, R>(s: &'tcx Session,\n-                                 arenas: &'tcx CtxtArenas<'tcx>,\n-                                 def_map: RefCell<DefMap>,\n-                                 named_region_map: resolve_lifetime::NamedRegionMap,\n-                                 map: ast_map::Map<'tcx>,\n-                                 freevars: FreevarMap,\n+                                  arenas: &'tcx CtxtArenas<'tcx>,\n+                                  def_map: RefCell<DefMap>,\n+                                  named_region_map: resolve_lifetime::NamedRegionMap,\n+                                  map: ast_map::Map<'tcx>,\n+                                  freevars: FreevarMap,\n                                  maybe_unused_trait_imports: NodeSet,\n-                                 region_maps: RegionMaps,\n-                                 lang_items: middle::lang_items::LanguageItems,\n-                                 stability: stability::Index<'tcx>,\n+                                  region_maps: RegionMaps,\n+                                  lang_items: middle::lang_items::LanguageItems,\n+                                  stability: stability::Index<'tcx>,\n                                  crate_name: &str,\n-                                 f: F) -> R\n-                                 where F: FnOnce(&TyCtxt<'tcx>) -> R\n+                                  f: F) -> R\n+                                  where F: for<'b> FnOnce(TyCtxt<'b, 'tcx, 'tcx>) -> R\n     {\n         let data_layout = TargetDataLayout::parse(s);\n-        let interner = RefCell::new(FnvHashMap());\n-        let common_types = CommonTypes::new(&arenas.type_, &interner);\n+        let interners = CtxtInterners::new(arenas);\n+        let common_types = CommonTypes::new(&interners);\n         let dep_graph = map.dep_graph.clone();\n         let fulfilled_predicates = traits::GlobalFulfilledPredicates::new(dep_graph.clone());\n-        tls::enter(TyCtxt {\n-            arenas: arenas,\n-            interner: interner,\n-            substs_interner: RefCell::new(FnvHashMap()),\n-            bare_fn_interner: RefCell::new(FnvHashMap()),\n-            region_interner: RefCell::new(FnvHashMap()),\n-            stability_interner: RefCell::new(FnvHashMap()),\n-            layout_interner: RefCell::new(FnvHashMap()),\n+        tls::enter_global(GlobalCtxt {\n+            global_interners: interners,\n             dep_graph: dep_graph.clone(),\n             types: common_types,\n             named_region_map: named_region_map,\n@@ -592,7 +660,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             tcache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             rcache: RefCell::new(FnvHashMap()),\n             tc_cache: RefCell::new(FnvHashMap()),\n-            ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n             impl_or_trait_items: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             trait_item_def_ids: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             trait_items_cache: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n@@ -624,11 +691,27 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n+impl<'gcx: 'tcx, 'tcx> GlobalCtxt<'gcx> {\n+    /// Call the closure with a local `TyCtxt` using the given arenas.\n+    pub fn enter_local<F, R>(&self, arenas: &'tcx CtxtArenas<'tcx>, f: F) -> R\n+        where F: for<'a> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n+    {\n+        let interners = CtxtInterners::new(arenas);\n+        tls::enter(self, &interners, f)\n+    }\n+}\n+\n /// A trait implemented for all X<'a> types which can be safely and\n /// efficiently converted to X<'tcx> as long as they are part of the\n /// provided TyCtxt<'tcx>.\n /// This can be done, for example, for Ty<'tcx> or &'tcx Substs<'tcx>\n /// by looking them up in their respective interners.\n+///\n+/// However, this is still not the best implementation as it does\n+/// need to compare the components, even for interned values.\n+/// It would be more efficient if TypedArena provided a way to\n+/// determine whether the address is in the allocated range.\n+///\n /// None is returned if the value or one of the components is not part\n /// of the provided context.\n /// For Ty, None can be returned if either the type interner doesn't\n@@ -637,48 +720,112 @@ impl<'tcx> TyCtxt<'tcx> {\n /// e.g. `()` or `u8`, was interned in a different context.\n pub trait Lift<'tcx> {\n     type Lifted;\n-    fn lift_to_tcx(&self, tcx: &TyCtxt<'tcx>) -> Option<Self::Lifted>;\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted>;\n }\n \n impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n     type Lifted = Ty<'tcx>;\n-    fn lift_to_tcx(&self, tcx: &TyCtxt<'tcx>) -> Option<Ty<'tcx>> {\n-        if let Some(&ty) = tcx.interner.borrow().get(&self.sty) {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Ty<'tcx>> {\n+        if let Some(&Interned(ty)) = tcx.interners.type_.borrow().get(&self.sty) {\n             if *self as *const _ == ty as *const _ {\n                 return Some(ty);\n             }\n         }\n-        None\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n     type Lifted = &'tcx Substs<'tcx>;\n-    fn lift_to_tcx(&self, tcx: &TyCtxt<'tcx>) -> Option<&'tcx Substs<'tcx>> {\n-        if let Some(&substs) = tcx.substs_interner.borrow().get(*self) {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Substs<'tcx>> {\n+        if let Some(&Interned(substs)) = tcx.interners.substs.borrow().get(*self) {\n             if *self as *const _ == substs as *const _ {\n                 return Some(substs);\n             }\n         }\n-        None\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for &'a Region {\n+    type Lifted = &'tcx Region;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Region> {\n+        if let Some(&Interned(region)) = tcx.interners.region.borrow().get(*self) {\n+            if *self as *const _ == region as *const _ {\n+                return Some(region);\n+            }\n+        }\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for &'a [Ty<'a>] {\n+    type Lifted = &'tcx [Ty<'tcx>];\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx [Ty<'tcx>]> {\n+        if let Some(&Interned(list)) = tcx.interners.type_list.borrow().get(*self) {\n+            if *self as *const _ == list as *const _ {\n+                return Some(list);\n+            }\n+        }\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for &'a BareFnTy<'a> {\n+    type Lifted = &'tcx BareFnTy<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n+                             -> Option<&'tcx BareFnTy<'tcx>> {\n+        if let Some(&Interned(fty)) = tcx.interners.bare_fn.borrow().get(*self) {\n+            if *self as *const _ == fty as *const _ {\n+                return Some(fty);\n+            }\n+        }\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n     }\n }\n \n \n pub mod tls {\n-    use ty::TyCtxt;\n+    use super::{CtxtInterners, GlobalCtxt, TyCtxt};\n \n     use std::cell::Cell;\n     use std::fmt;\n     use syntax::codemap;\n \n-    /// Marker type used for the scoped TLS slot.\n+    /// Marker types used for the scoped TLS slot.\n     /// The type context cannot be used directly because the scoped TLS\n     /// in libstd doesn't allow types generic over lifetimes.\n-    struct ThreadLocalTyCx;\n+    enum ThreadLocalGlobalCtxt {}\n+    enum ThreadLocalInterners {}\n \n     thread_local! {\n-        static TLS_TCX: Cell<Option<*const ThreadLocalTyCx>> = Cell::new(None)\n+        static TLS_TCX: Cell<Option<(*const ThreadLocalGlobalCtxt,\n+                                     *const ThreadLocalInterners)>> = Cell::new(None)\n     }\n \n     fn span_debug(span: codemap::Span, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -687,31 +834,54 @@ pub mod tls {\n         })\n     }\n \n-    pub fn enter<'tcx, F: FnOnce(&TyCtxt<'tcx>) -> R, R>(tcx: TyCtxt<'tcx>, f: F) -> R {\n+    pub fn enter_global<'gcx, F, R>(gcx: GlobalCtxt<'gcx>, f: F) -> R\n+        where F: for<'a> FnOnce(TyCtxt<'a, 'gcx, 'gcx>) -> R\n+    {\n         codemap::SPAN_DEBUG.with(|span_dbg| {\n             let original_span_debug = span_dbg.get();\n             span_dbg.set(span_debug);\n-            let tls_ptr = &tcx as *const _ as *const ThreadLocalTyCx;\n-            let result = TLS_TCX.with(|tls| {\n-                let prev = tls.get();\n-                tls.set(Some(tls_ptr));\n-                let ret = f(&tcx);\n-                tls.set(prev);\n-                ret\n-            });\n+            let result = enter(&gcx, &gcx.global_interners, f);\n             span_dbg.set(original_span_debug);\n             result\n         })\n     }\n \n-    pub fn with<F: FnOnce(&TyCtxt) -> R, R>(f: F) -> R {\n+    pub fn enter<'a, 'gcx: 'tcx, 'tcx, F, R>(gcx: &'a GlobalCtxt<'gcx>,\n+                                             interners: &'a CtxtInterners<'tcx>,\n+                                             f: F) -> R\n+        where F: FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n+    {\n+        let gcx_ptr = gcx as *const _ as *const ThreadLocalGlobalCtxt;\n+        let interners_ptr = interners as *const _ as *const ThreadLocalInterners;\n+        TLS_TCX.with(|tls| {\n+            let prev = tls.get();\n+            tls.set(Some((gcx_ptr, interners_ptr)));\n+            let ret = f(TyCtxt {\n+                gcx: gcx,\n+                interners: interners\n+            });\n+            tls.set(prev);\n+            ret\n+        })\n+    }\n+\n+    pub fn with<F, R>(f: F) -> R\n+        where F: for<'a, 'gcx, 'tcx> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n+    {\n         TLS_TCX.with(|tcx| {\n-            let tcx = tcx.get().unwrap();\n-            f(unsafe { &*(tcx as *const TyCtxt) })\n+            let (gcx, interners) = tcx.get().unwrap();\n+            let gcx = unsafe { &*(gcx as *const GlobalCtxt) };\n+            let interners = unsafe { &*(interners as *const CtxtInterners) };\n+            f(TyCtxt {\n+                gcx: gcx,\n+                interners: interners\n+            })\n         })\n     }\n \n-    pub fn with_opt<F: FnOnce(Option<&TyCtxt>) -> R, R>(f: F) -> R {\n+    pub fn with_opt<F, R>(f: F) -> R\n+        where F: for<'a, 'gcx, 'tcx> FnOnce(Option<TyCtxt<'a, 'gcx, 'tcx>>) -> R\n+    {\n         if TLS_TCX.with(|tcx| tcx.get().is_some()) {\n             with(|v| f(Some(v)))\n         } else {\n@@ -727,6 +897,8 @@ macro_rules! sty_debug_print {\n         #[allow(non_snake_case)]\n         mod inner {\n             use ty::{self, TyCtxt};\n+            use ty::context::Interned;\n+\n             #[derive(Copy, Clone)]\n             struct DebugStat {\n                 total: usize,\n@@ -735,15 +907,15 @@ macro_rules! sty_debug_print {\n                 both_infer: usize,\n             }\n \n-            pub fn go(tcx: &TyCtxt) {\n+            pub fn go(tcx: TyCtxt) {\n                 let mut total = DebugStat {\n                     total: 0,\n                     region_infer: 0, ty_infer: 0, both_infer: 0,\n                 };\n                 $(let mut $variant = total;)*\n \n \n-                for (_, t) in tcx.interner.borrow().iter() {\n+                for &Interned(t) in tcx.interners.type_.borrow().iter() {\n                     let variant = match t.sty {\n                         ty::TyBool | ty::TyChar | ty::TyInt(..) | ty::TyUint(..) |\n                             ty::TyFloat(..) | ty::TyStr => continue,\n@@ -782,131 +954,172 @@ macro_rules! sty_debug_print {\n     }}\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn print_debug_stats(&self) {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+    pub fn print_debug_stats(self) {\n         sty_debug_print!(\n             self,\n             TyEnum, TyBox, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr,\n             TyTrait, TyStruct, TyClosure, TyTuple, TyParam, TyInfer, TyProjection);\n \n-        println!(\"Substs interner: #{}\", self.substs_interner.borrow().len());\n-        println!(\"BareFnTy interner: #{}\", self.bare_fn_interner.borrow().len());\n-        println!(\"Region interner: #{}\", self.region_interner.borrow().len());\n-        println!(\"Stability interner: #{}\", self.stability_interner.borrow().len());\n-        println!(\"Layout interner: #{}\", self.layout_interner.borrow().len());\n+        println!(\"Substs interner: #{}\", self.interners.substs.borrow().len());\n+        println!(\"BareFnTy interner: #{}\", self.interners.bare_fn.borrow().len());\n+        println!(\"Region interner: #{}\", self.interners.region.borrow().len());\n+        println!(\"Stability interner: #{}\", self.interners.stability.borrow().len());\n+        println!(\"Layout interner: #{}\", self.interners.layout.borrow().len());\n     }\n }\n \n \n-/// An entry in the type interner.\n-pub struct InternedTy<'tcx> {\n-    ty: Ty<'tcx>\n-}\n+/// An entry in an interner.\n+struct Interned<'tcx, T: 'tcx+?Sized>(&'tcx T);\n \n-// NB: An InternedTy compares and hashes as a sty.\n-impl<'tcx> PartialEq for InternedTy<'tcx> {\n-    fn eq(&self, other: &InternedTy<'tcx>) -> bool {\n-        self.ty.sty == other.ty.sty\n+// NB: An Interned<Ty> compares and hashes as a sty.\n+impl<'tcx> PartialEq for Interned<'tcx, TyS<'tcx>> {\n+    fn eq(&self, other: &Interned<'tcx, TyS<'tcx>>) -> bool {\n+        self.0.sty == other.0.sty\n     }\n }\n \n-impl<'tcx> Eq for InternedTy<'tcx> {}\n+impl<'tcx> Eq for Interned<'tcx, TyS<'tcx>> {}\n \n-impl<'tcx> Hash for InternedTy<'tcx> {\n+impl<'tcx> Hash for Interned<'tcx, TyS<'tcx>> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n-        self.ty.sty.hash(s)\n+        self.0.sty.hash(s)\n     }\n }\n \n-impl<'tcx> Borrow<TypeVariants<'tcx>> for InternedTy<'tcx> {\n-    fn borrow<'a>(&'a self) -> &'a TypeVariants<'tcx> {\n-        &self.ty.sty\n+impl<'tcx: 'lcx, 'lcx> Borrow<TypeVariants<'lcx>> for Interned<'tcx, TyS<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a TypeVariants<'lcx> {\n+        &self.0.sty\n     }\n }\n \n-fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n-    bounds.is_empty() ||\n-        bounds[1..].iter().enumerate().all(\n-            |(index, bound)| bounds[index].sort_key() <= bound.sort_key())\n+impl<'tcx: 'lcx, 'lcx> Borrow<[Ty<'lcx>]> for Interned<'tcx, [Ty<'tcx>]> {\n+    fn borrow<'a>(&'a self) -> &'a [Ty<'lcx>] {\n+        self.0\n+    }\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    // Type constructors\n-    pub fn mk_substs(&self, substs: Substs<'tcx>) -> &'tcx Substs<'tcx> {\n-        if let Some(substs) = self.substs_interner.borrow().get(&substs) {\n-            return *substs;\n-        }\n+impl<'tcx: 'lcx, 'lcx> Borrow<Substs<'lcx>> for Interned<'tcx, Substs<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a Substs<'lcx> {\n+        self.0\n+    }\n+}\n \n-        let substs = self.arenas.substs.alloc(substs);\n-        self.substs_interner.borrow_mut().insert(substs, substs);\n-        substs\n+impl<'tcx: 'lcx, 'lcx> Borrow<BareFnTy<'lcx>> for Interned<'tcx, BareFnTy<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a BareFnTy<'lcx> {\n+        self.0\n     }\n+}\n \n-    /// Create an unsafe fn ty based on a safe fn ty.\n-    pub fn safe_to_unsafe_fn_ty(&self, bare_fn: &BareFnTy<'tcx>) -> Ty<'tcx> {\n-        assert_eq!(bare_fn.unsafety, hir::Unsafety::Normal);\n-        self.mk_fn_ptr(ty::BareFnTy {\n-            unsafety: hir::Unsafety::Unsafe,\n-            abi: bare_fn.abi,\n-            sig: bare_fn.sig.clone()\n-        })\n+impl<'tcx> Borrow<Region> for Interned<'tcx, Region> {\n+    fn borrow<'a>(&'a self) -> &'a Region {\n+        self.0\n     }\n+}\n \n-    pub fn mk_bare_fn(&self, bare_fn: BareFnTy<'tcx>) -> &'tcx BareFnTy<'tcx> {\n-        if let Some(bare_fn) = self.bare_fn_interner.borrow().get(&bare_fn) {\n-            return *bare_fn;\n+macro_rules! items { ($($item:item)+) => ($($item)+) }\n+macro_rules! impl_interners {\n+    ($lt_tcx:tt, $($name:ident: $method:ident($alloc:ty, $needs_infer:expr)-> $ty:ty),+) => {\n+        items!($(impl<$lt_tcx> PartialEq for Interned<$lt_tcx, $ty> {\n+            fn eq(&self, other: &Self) -> bool {\n+                self.0 == other.0\n+            }\n         }\n \n-        let bare_fn = self.arenas.bare_fn.alloc(bare_fn);\n-        self.bare_fn_interner.borrow_mut().insert(bare_fn, bare_fn);\n-        bare_fn\n-    }\n+        impl<$lt_tcx> Eq for Interned<$lt_tcx, $ty> {}\n \n-    pub fn mk_region(&self, region: Region) -> &'tcx Region {\n-        if let Some(region) = self.region_interner.borrow().get(&region) {\n-            return *region;\n+        impl<$lt_tcx> Hash for Interned<$lt_tcx, $ty> {\n+            fn hash<H: Hasher>(&self, s: &mut H) {\n+                self.0.hash(s)\n+            }\n         }\n \n-        let region = self.arenas.region.alloc(region);\n-        self.region_interner.borrow_mut().insert(region, region);\n-        region\n-    }\n+        impl<'a, 'gcx, $lt_tcx> TyCtxt<'a, 'gcx, $lt_tcx> {\n+            pub fn $method(self, v: $alloc) -> &$lt_tcx $ty {\n+                if let Some(i) = self.interners.$name.borrow().get::<$ty>(&v) {\n+                    return i.0;\n+                }\n+                if !self.is_global() {\n+                    if let Some(i) = self.global_interners.$name.borrow().get::<$ty>(&v) {\n+                        return i.0;\n+                    }\n+                }\n \n-    fn intern_ty(type_arena: &'tcx TypedArena<TyS<'tcx>>,\n-                 interner: &RefCell<FnvHashMap<InternedTy<'tcx>, Ty<'tcx>>>,\n-                 st: TypeVariants<'tcx>)\n-                 -> Ty<'tcx> {\n-        let ty: Ty /* don't be &mut TyS */ = {\n-            let mut interner = interner.borrow_mut();\n-            match interner.get(&st) {\n-                Some(ty) => return *ty,\n-                _ => ()\n+                // HACK(eddyb) Depend on flags being accurate to\n+                // determine that all contents are in the global tcx.\n+                // See comments on Lift for why we can't use that.\n+                if !($needs_infer)(&v) {\n+                    if !self.is_global() {\n+                        let v = unsafe {\n+                            mem::transmute(v)\n+                        };\n+                        let i = self.global_interners.arenas.$name.alloc(v);\n+                        self.global_interners.$name.borrow_mut().insert(Interned(i));\n+                        return i;\n+                    }\n+                } else {\n+                    // Make sure we don't end up with inference\n+                    // types/regions in the global tcx.\n+                    if self.is_global() {\n+                        bug!(\"Attempted to intern `{:?}` which contains \\\n+                              inference types/regions in the global type context\",\n+                             v);\n+                    }\n+                }\n+\n+                let i = self.interners.arenas.$name.alloc(v);\n+                self.interners.$name.borrow_mut().insert(Interned(i));\n+                i\n             }\n+        })+);\n+    }\n+}\n \n-            let flags = super::flags::FlagComputation::for_sty(&st);\n+fn keep_local<'tcx, T: ty::TypeFoldable<'tcx>>(x: &T) -> bool {\n+    x.has_type_flags(ty::TypeFlags::KEEP_IN_LOCAL_TCX)\n+}\n \n-            let ty = match () {\n-                () => type_arena.alloc(TyS { sty: st,\n-                                             flags: Cell::new(flags.flags),\n-                                             region_depth: flags.depth, }),\n-            };\n+impl_interners!('tcx,\n+    type_list: mk_type_list(Vec<Ty<'tcx>>, keep_local) -> [Ty<'tcx>],\n+    substs: mk_substs(Substs<'tcx>, |substs: &Substs| {\n+        keep_local(&substs.types) || keep_local(&substs.regions)\n+    }) -> Substs<'tcx>,\n+    bare_fn: mk_bare_fn(BareFnTy<'tcx>, |fty: &BareFnTy| {\n+        keep_local(&fty.sig)\n+    }) -> BareFnTy<'tcx>,\n+    region: mk_region(Region, keep_local) -> Region\n+);\n \n-            interner.insert(InternedTy { ty: ty }, ty);\n-            ty\n-        };\n+fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n+    bounds.is_empty() ||\n+        bounds[1..].iter().enumerate().all(\n+            |(index, bound)| bounds[index].sort_key() <= bound.sort_key())\n+}\n \n-        debug!(\"Interned type: {:?} Pointer: {:?}\",\n-            ty, ty as *const TyS);\n-        ty\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    /// Create an unsafe fn ty based on a safe fn ty.\n+    pub fn safe_to_unsafe_fn_ty(self, bare_fn: &BareFnTy<'tcx>) -> Ty<'tcx> {\n+        assert_eq!(bare_fn.unsafety, hir::Unsafety::Normal);\n+        self.mk_fn_ptr(self.mk_bare_fn(ty::BareFnTy {\n+            unsafety: hir::Unsafety::Unsafe,\n+            abi: bare_fn.abi,\n+            sig: bare_fn.sig.clone()\n+        }))\n     }\n \n-    // Interns a type/name combination, stores the resulting box in cx.interner,\n+    // Interns a type/name combination, stores the resulting box in cx.interners,\n     // and returns the box as cast to an unsafe ptr (see comments for Ty above).\n-    pub fn mk_ty(&self, st: TypeVariants<'tcx>) -> Ty<'tcx> {\n-        TyCtxt::intern_ty(&self.arenas.type_, &self.interner, st)\n+    pub fn mk_ty(self, st: TypeVariants<'tcx>) -> Ty<'tcx> {\n+        let global_interners = if !self.is_global() {\n+            Some(&self.global_interners)\n+        } else {\n+            None\n+        };\n+        self.interners.intern_ty(st, global_interners)\n     }\n \n-    pub fn mk_mach_int(&self, tm: ast::IntTy) -> Ty<'tcx> {\n+    pub fn mk_mach_int(self, tm: ast::IntTy) -> Ty<'tcx> {\n         match tm {\n             ast::IntTy::Is   => self.types.isize,\n             ast::IntTy::I8   => self.types.i8,\n@@ -916,7 +1129,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn mk_mach_uint(&self, tm: ast::UintTy) -> Ty<'tcx> {\n+    pub fn mk_mach_uint(self, tm: ast::UintTy) -> Ty<'tcx> {\n         match tm {\n             ast::UintTy::Us   => self.types.usize,\n             ast::UintTy::U8   => self.types.u8,\n@@ -926,89 +1139,89 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn mk_mach_float(&self, tm: ast::FloatTy) -> Ty<'tcx> {\n+    pub fn mk_mach_float(self, tm: ast::FloatTy) -> Ty<'tcx> {\n         match tm {\n             ast::FloatTy::F32  => self.types.f32,\n             ast::FloatTy::F64  => self.types.f64,\n         }\n     }\n \n-    pub fn mk_str(&self) -> Ty<'tcx> {\n+    pub fn mk_str(self) -> Ty<'tcx> {\n         self.mk_ty(TyStr)\n     }\n \n-    pub fn mk_static_str(&self) -> Ty<'tcx> {\n+    pub fn mk_static_str(self) -> Ty<'tcx> {\n         self.mk_imm_ref(self.mk_region(ty::ReStatic), self.mk_str())\n     }\n \n-    pub fn mk_enum(&self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_enum(self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n         // take a copy of substs so that we own the vectors inside\n         self.mk_ty(TyEnum(def, substs))\n     }\n \n-    pub fn mk_box(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_box(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(TyBox(ty))\n     }\n \n-    pub fn mk_ptr(&self, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_ptr(self, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(TyRawPtr(tm))\n     }\n \n-    pub fn mk_ref(&self, r: &'tcx Region, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_ref(self, r: &'tcx Region, tm: TypeAndMut<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(TyRef(r, tm))\n     }\n \n-    pub fn mk_mut_ref(&self, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_mut_ref(self, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n         self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::MutMutable})\n     }\n \n-    pub fn mk_imm_ref(&self, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_imm_ref(self, r: &'tcx Region, ty: Ty<'tcx>) -> Ty<'tcx> {\n         self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::MutImmutable})\n     }\n \n-    pub fn mk_mut_ptr(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_mut_ptr(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::MutMutable})\n     }\n \n-    pub fn mk_imm_ptr(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_imm_ptr(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::MutImmutable})\n     }\n \n-    pub fn mk_nil_ptr(&self) -> Ty<'tcx> {\n+    pub fn mk_nil_ptr(self) -> Ty<'tcx> {\n         self.mk_imm_ptr(self.mk_nil())\n     }\n \n-    pub fn mk_array(&self, ty: Ty<'tcx>, n: usize) -> Ty<'tcx> {\n+    pub fn mk_array(self, ty: Ty<'tcx>, n: usize) -> Ty<'tcx> {\n         self.mk_ty(TyArray(ty, n))\n     }\n \n-    pub fn mk_slice(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_slice(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(TySlice(ty))\n     }\n \n-    pub fn mk_tup(&self, ts: Vec<Ty<'tcx>>) -> Ty<'tcx> {\n-        self.mk_ty(TyTuple(ts))\n+    pub fn mk_tup(self, ts: Vec<Ty<'tcx>>) -> Ty<'tcx> {\n+        self.mk_ty(TyTuple(self.mk_type_list(ts)))\n     }\n \n-    pub fn mk_nil(&self) -> Ty<'tcx> {\n+    pub fn mk_nil(self) -> Ty<'tcx> {\n         self.mk_tup(Vec::new())\n     }\n \n-    pub fn mk_bool(&self) -> Ty<'tcx> {\n+    pub fn mk_bool(self) -> Ty<'tcx> {\n         self.mk_ty(TyBool)\n     }\n \n-    pub fn mk_fn_def(&self, def_id: DefId,\n+    pub fn mk_fn_def(self, def_id: DefId,\n                      substs: &'tcx Substs<'tcx>,\n-                     fty: BareFnTy<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(TyFnDef(def_id, substs, self.mk_bare_fn(fty)))\n+                     fty: &'tcx BareFnTy<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TyFnDef(def_id, substs, fty))\n     }\n \n-    pub fn mk_fn_ptr(&self, fty: BareFnTy<'tcx>) -> Ty<'tcx> {\n-        self.mk_ty(TyFnPtr(self.mk_bare_fn(fty)))\n+    pub fn mk_fn_ptr(self, fty: &'tcx BareFnTy<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TyFnPtr(fty))\n     }\n \n-    pub fn mk_trait(&self,\n+    pub fn mk_trait(self,\n                     principal: ty::PolyTraitRef<'tcx>,\n                     bounds: ExistentialBounds<'tcx>)\n                     -> Ty<'tcx>\n@@ -1022,7 +1235,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_ty(TyTrait(inner))\n     }\n \n-    pub fn mk_projection(&self,\n+    pub fn mk_projection(self,\n                          trait_ref: TraitRef<'tcx>,\n                          item_name: Name)\n                          -> Ty<'tcx> {\n@@ -1031,61 +1244,61 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_ty(TyProjection(inner))\n     }\n \n-    pub fn mk_struct(&self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_struct(self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n         // take a copy of substs so that we own the vectors inside\n         self.mk_ty(TyStruct(def, substs))\n     }\n \n-    pub fn mk_closure(&self,\n+    pub fn mk_closure(self,\n                       closure_id: DefId,\n                       substs: &'tcx Substs<'tcx>,\n                       tys: Vec<Ty<'tcx>>)\n                       -> Ty<'tcx> {\n-        self.mk_closure_from_closure_substs(closure_id, Box::new(ClosureSubsts {\n+        self.mk_closure_from_closure_substs(closure_id, ClosureSubsts {\n             func_substs: substs,\n-            upvar_tys: tys\n-        }))\n+            upvar_tys: self.mk_type_list(tys)\n+        })\n     }\n \n-    pub fn mk_closure_from_closure_substs(&self,\n+    pub fn mk_closure_from_closure_substs(self,\n                                           closure_id: DefId,\n-                                          closure_substs: Box<ClosureSubsts<'tcx>>)\n+                                          closure_substs: ClosureSubsts<'tcx>)\n                                           -> Ty<'tcx> {\n         self.mk_ty(TyClosure(closure_id, closure_substs))\n     }\n \n-    pub fn mk_var(&self, v: TyVid) -> Ty<'tcx> {\n+    pub fn mk_var(self, v: TyVid) -> Ty<'tcx> {\n         self.mk_infer(TyVar(v))\n     }\n \n-    pub fn mk_int_var(&self, v: IntVid) -> Ty<'tcx> {\n+    pub fn mk_int_var(self, v: IntVid) -> Ty<'tcx> {\n         self.mk_infer(IntVar(v))\n     }\n \n-    pub fn mk_float_var(&self, v: FloatVid) -> Ty<'tcx> {\n+    pub fn mk_float_var(self, v: FloatVid) -> Ty<'tcx> {\n         self.mk_infer(FloatVar(v))\n     }\n \n-    pub fn mk_infer(&self, it: InferTy) -> Ty<'tcx> {\n+    pub fn mk_infer(self, it: InferTy) -> Ty<'tcx> {\n         self.mk_ty(TyInfer(it))\n     }\n \n-    pub fn mk_param(&self,\n+    pub fn mk_param(self,\n                     space: subst::ParamSpace,\n                     index: u32,\n                     name: Name) -> Ty<'tcx> {\n         self.mk_ty(TyParam(ParamTy { space: space, idx: index, name: name }))\n     }\n \n-    pub fn mk_self_type(&self) -> Ty<'tcx> {\n+    pub fn mk_self_type(self) -> Ty<'tcx> {\n         self.mk_param(subst::SelfSpace, 0, keywords::SelfType.name())\n     }\n \n-    pub fn mk_param_from_def(&self, def: &ty::TypeParameterDef) -> Ty<'tcx> {\n+    pub fn mk_param_from_def(self, def: &ty::TypeParameterDef) -> Ty<'tcx> {\n         self.mk_param(def.space, def.index, def.name)\n     }\n \n-    pub fn trait_items(&self, trait_did: DefId) -> Rc<Vec<ty::ImplOrTraitItem<'tcx>>> {\n+    pub fn trait_items(self, trait_did: DefId) -> Rc<Vec<ty::ImplOrTraitItem<'gcx>>> {\n         self.trait_items_cache.memoize(trait_did, || {\n             let def_ids = self.trait_item_def_ids(trait_did);\n             Rc::new(def_ids.iter()\n@@ -1095,7 +1308,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Obtain the representation annotation for a struct definition.\n-    pub fn lookup_repr_hints(&self, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n+    pub fn lookup_repr_hints(self, did: DefId) -> Rc<Vec<attr::ReprAttr>> {\n         self.repr_hint_cache.memoize(did, || {\n             Rc::new(if did.is_local() {\n                 self.get_attrs(did).iter().flat_map(|meta| {"}, {"sha": "b5190f313309fe18a4a9f79358adfb38e6fe3486", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -210,14 +210,14 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n     }\n }\n \n-impl<'tcx> ty::TyS<'tcx> {\n-    fn sort_string(&self, cx: &TyCtxt) -> String {\n+impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n+    fn sort_string(&self, tcx: TyCtxt<'a, 'gcx, 'lcx>) -> String {\n         match self.sty {\n             ty::TyBool | ty::TyChar | ty::TyInt(_) |\n             ty::TyUint(_) | ty::TyFloat(_) | ty::TyStr => self.to_string(),\n             ty::TyTuple(ref tys) if tys.is_empty() => self.to_string(),\n \n-            ty::TyEnum(def, _) => format!(\"enum `{}`\", cx.item_path_str(def.did)),\n+            ty::TyEnum(def, _) => format!(\"enum `{}`\", tcx.item_path_str(def.did)),\n             ty::TyBox(_) => \"box\".to_string(),\n             ty::TyArray(_, n) => format!(\"array of {} elements\", n),\n             ty::TySlice(_) => \"slice\".to_string(),\n@@ -226,10 +226,10 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::TyFnDef(..) => format!(\"fn item\"),\n             ty::TyFnPtr(_) => \"fn pointer\".to_string(),\n             ty::TyTrait(ref inner) => {\n-                format!(\"trait {}\", cx.item_path_str(inner.principal_def_id()))\n+                format!(\"trait {}\", tcx.item_path_str(inner.principal_def_id()))\n             }\n             ty::TyStruct(def, _) => {\n-                format!(\"struct `{}`\", cx.item_path_str(def.did))\n+                format!(\"struct `{}`\", tcx.item_path_str(def.did))\n             }\n             ty::TyClosure(..) => \"closure\".to_string(),\n             ty::TyTuple(_) => \"tuple\".to_string(),\n@@ -252,8 +252,8 @@ impl<'tcx> ty::TyS<'tcx> {\n     }\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn note_and_explain_type_err(&self,\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    pub fn note_and_explain_type_err(self,\n                                      db: &mut DiagnosticBuilder,\n                                      err: &TypeError<'tcx>,\n                                      sp: Span) {"}, {"sha": "25f3552b565e720cccd1a0ec86b9bda1b759d1b2", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -43,10 +43,10 @@ pub enum SimplifiedType {\n /// then we can't say much about whether two types would unify. Put another way,\n /// `can_simplify_params` should be true if type parameters appear free in `ty` and `false` if they\n /// are to be considered bound.\n-pub fn simplify_type(tcx: &TyCtxt,\n-                     ty: Ty,\n-                     can_simplify_params: bool)\n-                     -> Option<SimplifiedType>\n+pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                     ty: Ty,\n+                                     can_simplify_params: bool)\n+                                     -> Option<SimplifiedType>\n {\n     match ty.sty {\n         ty::TyBool => Some(BoolSimplifiedType),"}, {"sha": "a1da3017fcd043f9eff961ab05be01da47777f51", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -90,9 +90,15 @@ impl FlagComputation {\n                 self.add_tys(&substs.upvar_tys);\n             }\n \n-            &ty::TyInfer(_) => {\n+            &ty::TyInfer(infer) => {\n                 self.add_flags(TypeFlags::HAS_LOCAL_NAMES); // it might, right?\n-                self.add_flags(TypeFlags::HAS_TY_INFER)\n+                self.add_flags(TypeFlags::HAS_TY_INFER);\n+                match infer {\n+                    ty::FreshTy(_) |\n+                    ty::FreshIntTy(_) |\n+                    ty::FreshFloatTy(_) => {}\n+                    _ => self.add_flags(TypeFlags::KEEP_IN_LOCAL_TCX)\n+                }\n             }\n \n             &ty::TyEnum(_, substs) | &ty::TyStruct(_, substs) => {\n@@ -171,7 +177,10 @@ impl FlagComputation {\n     fn add_region(&mut self, r: ty::Region) {\n         match r {\n             ty::ReVar(..) |\n-            ty::ReSkolemized(..) => { self.add_flags(TypeFlags::HAS_RE_INFER); }\n+            ty::ReSkolemized(..) => {\n+                self.add_flags(TypeFlags::HAS_RE_INFER);\n+                self.add_flags(TypeFlags::KEEP_IN_LOCAL_TCX);\n+            }\n             ty::ReLateBound(debruijn, _) => { self.add_depth(debruijn.depth); }\n             ty::ReEarlyBound(..) => { self.add_flags(TypeFlags::HAS_RE_EARLY_BOUND); }\n             ty::ReStatic => {}"}, {"sha": "14b369f244d49a77e9ed8bd1ea75cb8ca83249b3", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 57, "deletions": 55, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -50,8 +50,8 @@ use util::nodemap::{FnvHashMap, FnvHashSet};\n /// The TypeFoldable trait is implemented for every type that can be folded.\n /// Basically, every type that has a corresponding method in TypeFolder.\n pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self;\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         self.super_fold_with(folder)\n     }\n \n@@ -113,8 +113,8 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n /// default implementation that does an \"identity\" fold. Within each\n /// identity fold, it should invoke `foo.fold_with(self)` to fold each\n /// sub-item.\n-pub trait TypeFolder<'tcx> : Sized {\n-    fn tcx<'a>(&'a self) -> &'a TyCtxt<'tcx>;\n+pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n \n     fn fold_binder<T>(&mut self, t: &Binder<T>) -> Binder<T>\n         where T : TypeFoldable<'tcx>\n@@ -139,8 +139,8 @@ pub trait TypeFolder<'tcx> : Sized {\n     }\n \n     fn fold_substs(&mut self,\n-                   substs: &subst::Substs<'tcx>)\n-                   -> subst::Substs<'tcx> {\n+                   substs: &'tcx subst::Substs<'tcx>)\n+                   -> &'tcx subst::Substs<'tcx> {\n         substs.super_fold_with(self)\n     }\n \n@@ -157,8 +157,8 @@ pub trait TypeFolder<'tcx> : Sized {\n     }\n \n     fn fold_bare_fn_ty(&mut self,\n-                       fty: &ty::BareFnTy<'tcx>)\n-                       -> ty::BareFnTy<'tcx>\n+                       fty: &'tcx ty::BareFnTy<'tcx>)\n+                       -> &'tcx ty::BareFnTy<'tcx>\n     {\n         fty.super_fold_with(self)\n     }\n@@ -201,15 +201,17 @@ pub trait TypeVisitor<'tcx> : Sized {\n ///////////////////////////////////////////////////////////////////////////\n // Some sample folders\n \n-pub struct BottomUpFolder<'a, 'tcx: 'a, F> where F: FnMut(Ty<'tcx>) -> Ty<'tcx> {\n-    pub tcx: &'a TyCtxt<'tcx>,\n+pub struct BottomUpFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a, F>\n+    where F: FnMut(Ty<'tcx>) -> Ty<'tcx>\n+{\n+    pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     pub fldop: F,\n }\n \n-impl<'a, 'tcx, F> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx, F> where\n-    F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n+impl<'a, 'gcx, 'tcx, F> TypeFolder<'gcx, 'tcx> for BottomUpFolder<'a, 'gcx, 'tcx, F>\n+    where F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n {\n-    fn tcx(&self) -> &TyCtxt<'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let t1 = ty.super_fold_with(self);\n@@ -220,10 +222,10 @@ impl<'a, 'tcx, F> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx, F> where\n ///////////////////////////////////////////////////////////////////////////\n // Region folder\n \n-impl<'tcx> TyCtxt<'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Collects the free and escaping regions in `value` into `region_set`. Returns\n     /// whether any late-bound regions were skipped\n-    pub fn collect_regions<T>(&self,\n+    pub fn collect_regions<T>(self,\n         value: &T,\n         region_set: &mut FnvHashSet<ty::Region>)\n         -> bool\n@@ -238,7 +240,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Folds the escaping and free regions in `value` using `f`, and\n     /// sets `skipped_regions` to true if any late-bound region was found\n     /// and skipped.\n-    pub fn fold_regions<T,F>(&self,\n+    pub fn fold_regions<T,F>(self,\n         value: &T,\n         skipped_regions: &mut bool,\n         mut f: F)\n@@ -259,17 +261,17 @@ impl<'tcx> TyCtxt<'tcx> {\n /// visited by this folder; only regions that occur free will be\n /// visited by `fld_r`.\n \n-pub struct RegionFolder<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+pub struct RegionFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     skipped_regions: &'a mut bool,\n     current_depth: u32,\n     fld_r: &'a mut (FnMut(ty::Region, u32) -> ty::Region + 'a),\n }\n \n-impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n-    pub fn new<F>(tcx: &'a TyCtxt<'tcx>,\n+impl<'a, 'gcx, 'tcx> RegionFolder<'a, 'gcx, 'tcx> {\n+    pub fn new<F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                   skipped_regions: &'a mut bool,\n-                  fld_r: &'a mut F) -> RegionFolder<'a, 'tcx>\n+                  fld_r: &'a mut F) -> RegionFolder<'a, 'gcx, 'tcx>\n         where F : FnMut(ty::Region, u32) -> ty::Region\n     {\n         RegionFolder {\n@@ -281,9 +283,8 @@ impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx>\n-{\n-    fn tcx(&self) -> &TyCtxt<'tcx> { self.tcx }\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFolder<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.current_depth += 1;\n@@ -314,15 +315,15 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx>\n \n // Replaces the escaping regions in a type.\n \n-struct RegionReplacer<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+struct RegionReplacer<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     current_depth: u32,\n     fld_r: &'a mut (FnMut(ty::BoundRegion) -> ty::Region + 'a),\n     map: FnvHashMap<ty::BoundRegion, ty::Region>\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn replace_late_bound_regions<T,F>(&self,\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    pub fn replace_late_bound_regions<T,F>(self,\n         value: &Binder<T>,\n         mut f: F)\n         -> (T, FnvHashMap<ty::BoundRegion, ty::Region>)\n@@ -337,7 +338,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Replace any late-bound regions bound in `value` with free variants attached to scope-id\n     /// `scope_id`.\n-    pub fn liberate_late_bound_regions<T>(&self,\n+    pub fn liberate_late_bound_regions<T>(self,\n         all_outlive_scope: region::CodeExtent,\n         value: &Binder<T>)\n         -> T\n@@ -350,7 +351,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Flattens two binding levels into one. So `for<'a> for<'b> Foo`\n     /// becomes `for<'a,'b> Foo`.\n-    pub fn flatten_late_bound_regions<T>(&self, bound2_value: &Binder<Binder<T>>)\n+    pub fn flatten_late_bound_regions<T>(self, bound2_value: &Binder<Binder<T>>)\n                                          -> Binder<T>\n         where T: TypeFoldable<'tcx>\n     {\n@@ -371,7 +372,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         Binder(value)\n     }\n \n-    pub fn no_late_bound_regions<T>(&self, value: &Binder<T>) -> Option<T>\n+    pub fn no_late_bound_regions<T>(self, value: &Binder<T>) -> Option<T>\n         where T : TypeFoldable<'tcx>\n     {\n         if value.0.has_escaping_regions() {\n@@ -383,7 +384,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Replace any late-bound regions bound in `value` with `'static`. Useful in trans but also\n     /// method lookup and a few other places where precise region relationships are not required.\n-    pub fn erase_late_bound_regions<T>(&self, value: &Binder<T>) -> T\n+    pub fn erase_late_bound_regions<T>(self, value: &Binder<T>) -> T\n         where T : TypeFoldable<'tcx>\n     {\n         self.replace_late_bound_regions(value, |_| ty::ReStatic).0\n@@ -397,7 +398,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// `FnSig`s or `TraitRef`s which are equivalent up to region naming will become\n     /// structurally identical.  For example, `for<'a, 'b> fn(&'a isize, &'b isize)` and\n     /// `for<'a, 'b> fn(&'b isize, &'a isize)` will become identical after anonymization.\n-    pub fn anonymize_late_bound_regions<T>(&self, sig: &Binder<T>) -> Binder<T>\n+    pub fn anonymize_late_bound_regions<T>(self, sig: &Binder<T>) -> Binder<T>\n         where T : TypeFoldable<'tcx>,\n     {\n         let mut counter = 0;\n@@ -408,8 +409,9 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> RegionReplacer<'a, 'tcx> {\n-    fn new<F>(tcx: &'a TyCtxt<'tcx>, fld_r: &'a mut F) -> RegionReplacer<'a, 'tcx>\n+impl<'a, 'gcx, 'tcx> RegionReplacer<'a, 'gcx, 'tcx> {\n+    fn new<F>(tcx: TyCtxt<'a, 'gcx, 'tcx>, fld_r: &'a mut F)\n+              -> RegionReplacer<'a, 'gcx, 'tcx>\n         where F : FnMut(ty::BoundRegion) -> ty::Region\n     {\n         RegionReplacer {\n@@ -421,9 +423,8 @@ impl<'a, 'tcx> RegionReplacer<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx>\n-{\n-    fn tcx(&self) -> &TyCtxt<'tcx> { self.tcx }\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionReplacer<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.current_depth += 1;\n@@ -463,32 +464,38 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx>\n ///////////////////////////////////////////////////////////////////////////\n // Region eraser\n \n-impl<'tcx> TyCtxt<'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns an equivalent value with all free regions removed (note\n     /// that late-bound regions remain, because they are important for\n     /// subtyping, but they are anonymized and normalized as well)..\n-    pub fn erase_regions<T>(&self, value: &T) -> T\n+    pub fn erase_regions<T>(self, value: &T) -> T\n         where T : TypeFoldable<'tcx>\n     {\n         let value1 = value.fold_with(&mut RegionEraser(self));\n         debug!(\"erase_regions({:?}) = {:?}\",\n                value, value1);\n         return value1;\n \n-        struct RegionEraser<'a, 'tcx: 'a>(&'a TyCtxt<'tcx>);\n+        struct RegionEraser<'a, 'gcx: 'a+'tcx, 'tcx: 'a>(TyCtxt<'a, 'gcx, 'tcx>);\n \n-        impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n-            fn tcx(&self) -> &TyCtxt<'tcx> { self.0 }\n+        impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionEraser<'a, 'gcx, 'tcx> {\n+            fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.0 }\n \n             fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n                 match self.tcx().normalized_cache.borrow().get(&ty).cloned() {\n                     None => {}\n                     Some(u) => return u\n                 }\n \n-                let t_norm = ty.super_fold_with(self);\n-                self.tcx().normalized_cache.borrow_mut().insert(ty, t_norm);\n-                return t_norm;\n+                // FIXME(eddyb) should local contexts have a cache too?\n+                if let Some(ty_lifted) = self.tcx().lift_to_global(&ty) {\n+                    let tcx = self.tcx().global_tcx();\n+                    let t_norm = ty_lifted.super_fold_with(&mut RegionEraser(tcx));\n+                    tcx.normalized_cache.borrow_mut().insert(ty_lifted, t_norm);\n+                    t_norm\n+                } else {\n+                    ty.super_fold_with(self)\n+                }\n             }\n \n             fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n@@ -512,13 +519,6 @@ impl<'tcx> TyCtxt<'tcx> {\n                     _ => ty::ReStatic\n                 }\n             }\n-\n-            fn fold_substs(&mut self,\n-                           substs: &subst::Substs<'tcx>)\n-                           -> subst::Substs<'tcx> {\n-                subst::Substs { regions: substs.regions.fold_with(self),\n-                                types: substs.types.fold_with(self) }\n-            }\n         }\n     }\n }\n@@ -543,8 +543,10 @@ pub fn shift_region(region: ty::Region, amount: u32) -> ty::Region {\n     }\n }\n \n-pub fn shift_regions<'tcx, T:TypeFoldable<'tcx>>(tcx: &TyCtxt<'tcx>,\n-                                                 amount: u32, value: &T) -> T {\n+pub fn shift_regions<'a, 'gcx, 'tcx, T>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                        amount: u32, value: &T) -> T\n+    where T: TypeFoldable<'tcx>\n+{\n     debug!(\"shift_regions(value={:?}, amount={})\",\n            value, amount);\n "}, {"sha": "5246c6739d9609ed9918f038eca0175dc3a29798", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -14,24 +14,24 @@ use hir::def_id::{DefId, CRATE_DEF_INDEX};\n use ty::{self, Ty, TyCtxt};\n use syntax::ast;\n \n-impl<'tcx> TyCtxt<'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Returns a string identifying this def-id. This string is\n     /// suitable for user output. It is relative to the current crate\n     /// root.\n-    pub fn item_path_str(&self, def_id: DefId) -> String {\n+    pub fn item_path_str(self, def_id: DefId) -> String {\n         let mut buffer = LocalPathBuffer::new(RootMode::Local);\n         self.push_item_path(&mut buffer, def_id);\n         buffer.into_string()\n     }\n \n     /// Returns a string identifying this local node-id.\n-    pub fn node_path_str(&self, id: ast::NodeId) -> String {\n+    pub fn node_path_str(self, id: ast::NodeId) -> String {\n         self.item_path_str(self.map.local_def_id(id))\n     }\n \n     /// Returns a string identifying this def-id. This string is\n     /// suitable for user output. It always begins with a crate identifier.\n-    pub fn absolute_item_path_str(&self, def_id: DefId) -> String {\n+    pub fn absolute_item_path_str(self, def_id: DefId) -> String {\n         let mut buffer = LocalPathBuffer::new(RootMode::Absolute);\n         self.push_item_path(&mut buffer, def_id);\n         buffer.into_string()\n@@ -40,7 +40,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Returns the \"path\" to a particular crate. This can proceed in\n     /// various ways, depending on the `root_mode` of the `buffer`.\n     /// (See `RootMode` enum for more details.)\n-    pub fn push_krate_path<T>(&self, buffer: &mut T, cnum: ast::CrateNum)\n+    pub fn push_krate_path<T>(self, buffer: &mut T, cnum: ast::CrateNum)\n         where T: ItemPathBuffer\n     {\n         match *buffer.root_mode() {\n@@ -83,7 +83,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// If possible, this pushes a global path resolving to `external_def_id` that is visible\n     /// from at least one local module and returns true. If the crate defining `external_def_id` is\n     /// declared with an `extern crate`, the path is guarenteed to use the `extern crate`.\n-    pub fn try_push_visible_item_path<T>(&self, buffer: &mut T, external_def_id: DefId) -> bool\n+    pub fn try_push_visible_item_path<T>(self, buffer: &mut T, external_def_id: DefId) -> bool\n         where T: ItemPathBuffer\n     {\n         let visible_parent_map = self.sess.cstore.visible_parent_map();\n@@ -116,7 +116,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn push_item_path<T>(&self, buffer: &mut T, def_id: DefId)\n+    pub fn push_item_path<T>(self, buffer: &mut T, def_id: DefId)\n         where T: ItemPathBuffer\n     {\n         match *buffer.root_mode() {\n@@ -164,7 +164,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    fn push_impl_path<T>(&self,\n+    fn push_impl_path<T>(self,\n                          buffer: &mut T,\n                          impl_def_id: DefId)\n         where T: ItemPathBuffer\n@@ -253,7 +253,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    fn push_impl_path_fallback<T>(&self,\n+    fn push_impl_path_fallback<T>(self,\n                                   buffer: &mut T,\n                                   impl_def_id: DefId)\n         where T: ItemPathBuffer\n@@ -284,7 +284,7 @@ impl<'tcx> TyCtxt<'tcx> {\n /// function tries to find a \"characteristic def-id\" for a\n /// type. It's just a heuristic so it makes some questionable\n /// decisions and we may want to adjust it later.\n-pub fn characteristic_def_id_of_type<'tcx>(ty: Ty<'tcx>) -> Option<DefId> {\n+pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n     match ty.sty {\n         ty::TyStruct(adt_def, _) |\n         ty::TyEnum(adt_def, _) => Some(adt_def.did),"}, {"sha": "82a3b0b8db28467c7d32097ec3ca66da4e0d64a2", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -12,7 +12,7 @@ pub use self::Integer::*;\n pub use self::Layout::*;\n pub use self::Primitive::*;\n \n-use infer::{InferCtxt, drain_fulfillment_cx_or_panic};\n+use infer::InferCtxt;\n use session::Session;\n use traits;\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -364,7 +364,7 @@ impl Integer {\n     /// signed discriminant range and #[repr] attribute.\n     /// N.B.: u64 values above i64::MAX will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n-    pub fn repr_discr(tcx: &TyCtxt, hint: attr::ReprAttr, min: i64, max: i64)\n+    pub fn repr_discr(tcx: TyCtxt, hint: attr::ReprAttr, min: i64, max: i64)\n                       -> (Integer, bool) {\n         // Theoretically, negative values could be larger in unsigned representation\n         // than the unsigned representation of the signed minimum. However, if there\n@@ -466,7 +466,7 @@ pub struct Struct {\n     pub offset_after_field: Vec<Size>\n }\n \n-impl Struct {\n+impl<'a, 'gcx, 'tcx> Struct {\n     pub fn new(dl: &TargetDataLayout, packed: bool) -> Struct {\n         Struct {\n             align: if packed { dl.i8_align } else { dl.aggregate_align },\n@@ -477,11 +477,11 @@ impl Struct {\n     }\n \n     /// Extend the Struct with more fields.\n-    pub fn extend<'a, 'tcx, I>(&mut self, dl: &TargetDataLayout,\n-                               fields: I,\n-                               scapegoat: Ty<'tcx>)\n-                               -> Result<(), LayoutError<'tcx>>\n-    where I: Iterator<Item=Result<&'a Layout, LayoutError<'tcx>>> {\n+    pub fn extend<I>(&mut self, dl: &TargetDataLayout,\n+                     fields: I,\n+                     scapegoat: Ty<'gcx>)\n+                     -> Result<(), LayoutError<'gcx>>\n+    where I: Iterator<Item=Result<&'a Layout, LayoutError<'gcx>>> {\n         self.offset_after_field.reserve(fields.size_hint().0);\n \n         for field in fields {\n@@ -527,9 +527,9 @@ impl Struct {\n     }\n \n     /// Determine whether a structure would be zero-sized, given its fields.\n-    pub fn would_be_zero_sized<'a, 'tcx, I>(dl: &TargetDataLayout, fields: I)\n-                                            -> Result<bool, LayoutError<'tcx>>\n-    where I: Iterator<Item=Result<&'a Layout, LayoutError<'tcx>>> {\n+    pub fn would_be_zero_sized<I>(dl: &TargetDataLayout, fields: I)\n+                                  -> Result<bool, LayoutError<'gcx>>\n+    where I: Iterator<Item=Result<&'a Layout, LayoutError<'gcx>>> {\n         for field in fields {\n             let field = field?;\n             if field.is_unsized() || field.size(dl).bytes() > 0 {\n@@ -542,10 +542,10 @@ impl Struct {\n     /// Find the path leading to a non-zero leaf field, starting from\n     /// the given type and recursing through aggregates.\n     // FIXME(eddyb) track value ranges and traverse already optimized enums.\n-    pub fn non_zero_field_in_type<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                            ty: Ty<'tcx>)\n-                                            -> Result<Option<FieldPath>, LayoutError<'tcx>> {\n-        let tcx = infcx.tcx;\n+    pub fn non_zero_field_in_type(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                  ty: Ty<'gcx>)\n+                                  -> Result<Option<FieldPath>, LayoutError<'gcx>> {\n+        let tcx = infcx.tcx.global_tcx();\n         match (ty.layout(infcx)?, &ty.sty) {\n             (&Scalar { non_zero: true, .. }, _) => Ok(Some(vec![])),\n             (&FatPointer { non_zero: true, .. }, _) => {\n@@ -581,9 +581,9 @@ impl Struct {\n \n             // Perhaps one of the upvars of this closure is non-zero\n             // Let's recurse and find out!\n-            (_, &ty::TyClosure(_, box ty::ClosureSubsts { upvar_tys: ref tys, .. })) |\n+            (_, &ty::TyClosure(_, ty::ClosureSubsts { upvar_tys: tys, .. })) |\n             // Can we use one of the fields in this tuple?\n-            (_, &ty::TyTuple(ref tys)) => {\n+            (_, &ty::TyTuple(tys)) => {\n                 Struct::non_zero_field_path(infcx, tys.iter().cloned())\n             }\n \n@@ -600,10 +600,10 @@ impl Struct {\n \n     /// Find the path leading to a non-zero leaf field, starting from\n     /// the given set of fields and recursing through aggregates.\n-    pub fn non_zero_field_path<'a, 'tcx, I>(infcx: &InferCtxt<'a, 'tcx>,\n-                                            fields: I)\n-                                            -> Result<Option<FieldPath>, LayoutError<'tcx>>\n-    where I: Iterator<Item=Ty<'tcx>> {\n+    pub fn non_zero_field_path<I>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                  fields: I)\n+                                  -> Result<Option<FieldPath>, LayoutError<'gcx>>\n+    where I: Iterator<Item=Ty<'gcx>> {\n         for (i, ty) in fields.enumerate() {\n             if let Some(mut path) = Struct::non_zero_field_in_type(infcx, ty)? {\n                 path.push(i as u32);\n@@ -736,9 +736,9 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n }\n \n /// Helper function for normalizing associated types in an inference context.\n-fn normalize_associated_type<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                       ty: Ty<'tcx>)\n-                                       -> Ty<'tcx> {\n+fn normalize_associated_type<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                             ty: Ty<'gcx>)\n+                                             -> Ty<'gcx> {\n     if !ty.has_projection_types() {\n         return ty;\n     }\n@@ -754,14 +754,14 @@ fn normalize_associated_type<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n         fulfill_cx.register_predicate_obligation(infcx, obligation);\n     }\n \n-    drain_fulfillment_cx_or_panic(DUMMY_SP, infcx, &mut fulfill_cx, &result)\n+    infcx.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &result)\n }\n \n-impl Layout {\n-    pub fn compute_uncached<'a, 'tcx>(ty: Ty<'tcx>,\n-                                      infcx: &InferCtxt<'a, 'tcx>)\n-                                      -> Result<Layout, LayoutError<'tcx>> {\n-        let tcx = infcx.tcx;\n+impl<'a, 'gcx, 'tcx> Layout {\n+    pub fn compute_uncached(ty: Ty<'gcx>,\n+                            infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n+                            -> Result<Layout, LayoutError<'gcx>> {\n+        let tcx = infcx.tcx.global_tcx();\n         let dl = &tcx.data_layout;\n         assert!(!ty.has_infer_types());\n \n@@ -790,7 +790,7 @@ impl Layout {\n             ty::TyRef(_, ty::TypeAndMut { ty: pointee, .. }) |\n             ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 let non_zero = !ty.is_unsafe_ptr();\n-                if pointee.is_sized(&infcx.parameter_environment, DUMMY_SP) {\n+                if pointee.is_sized(tcx, &infcx.parameter_environment, DUMMY_SP) {\n                     Scalar { value: Pointer, non_zero: non_zero }\n                 } else {\n                     let unsized_part = tcx.struct_tail(pointee);\n@@ -844,8 +844,8 @@ impl Layout {\n             }\n \n             // Tuples.\n-            ty::TyClosure(_, box ty::ClosureSubsts { upvar_tys: ref tys, .. }) |\n-            ty::TyTuple(ref tys) => {\n+            ty::TyClosure(_, ty::ClosureSubsts { upvar_tys: tys, .. }) |\n+            ty::TyTuple(tys) => {\n                 let mut st = Struct::new(dl, false);\n                 st.extend(dl, tys.iter().map(|ty| ty.layout(infcx)), ty)?;\n                 Univariant { variant: st, non_zero: false }\n@@ -883,7 +883,7 @@ impl Layout {\n                 // the unsized field. Several other pieces of code assume that the unsized\n                 // field is definitely the last one.\n                 if def.dtor_kind().has_drop_flag() &&\n-                   ty.is_sized(&infcx.parameter_environment, DUMMY_SP) {\n+                   ty.is_sized(tcx, &infcx.parameter_environment, DUMMY_SP) {\n                     st.extend(dl, Some(Ok(&Scalar {\n                         value: Int(I8),\n                         non_zero: false\n@@ -1220,10 +1220,10 @@ pub enum SizeSkeleton<'tcx> {\n     }\n }\n \n-impl<'tcx> SizeSkeleton<'tcx> {\n-    pub fn compute<'a>(ty: Ty<'tcx>, infcx: &InferCtxt<'a, 'tcx>)\n-                       -> Result<SizeSkeleton<'tcx>, LayoutError<'tcx>> {\n-        let tcx = infcx.tcx;\n+impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n+    pub fn compute(ty: Ty<'gcx>, infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n+                   -> Result<SizeSkeleton<'gcx>, LayoutError<'gcx>> {\n+        let tcx = infcx.tcx.global_tcx();\n         assert!(!ty.has_infer_types());\n \n         // First try computing a static layout."}, {"sha": "005d83da38dbf87dd13f2a443742733bc0a8dd3a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 257, "deletions": 246, "changes": 503, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -165,10 +165,10 @@ pub struct ImplHeader<'tcx> {\n     pub predicates: Vec<Predicate<'tcx>>,\n }\n \n-impl<'tcx> ImplHeader<'tcx> {\n-    pub fn with_fresh_ty_vars<'a>(selcx: &mut traits::SelectionContext<'a, 'tcx>,\n-                                  impl_def_id: DefId)\n-                                  -> ImplHeader<'tcx>\n+impl<'a, 'gcx, 'tcx> ImplHeader<'tcx> {\n+    pub fn with_fresh_ty_vars(selcx: &mut traits::SelectionContext<'a, 'gcx, 'tcx>,\n+                              impl_def_id: DefId)\n+                              -> ImplHeader<'tcx>\n     {\n         let tcx = selcx.tcx();\n         let impl_generics = tcx.lookup_item_type(impl_def_id).generics;\n@@ -303,7 +303,7 @@ impl<'a> NodeIdTree for ast_map::Map<'a> {\n }\n \n impl Visibility {\n-    pub fn from_hir(visibility: &hir::Visibility, id: NodeId, tcx: &TyCtxt) -> Self {\n+    pub fn from_hir(visibility: &hir::Visibility, id: NodeId, tcx: TyCtxt) -> Self {\n         match *visibility {\n             hir::Public => Visibility::Public,\n             hir::Visibility::Crate => Visibility::Restricted(ast::CRATE_NODE_ID),\n@@ -350,7 +350,7 @@ pub struct Method<'tcx> {\n     pub name: Name,\n     pub generics: Generics<'tcx>,\n     pub predicates: GenericPredicates<'tcx>,\n-    pub fty: BareFnTy<'tcx>,\n+    pub fty: &'tcx BareFnTy<'tcx>,\n     pub explicit_self: ExplicitSelfCategory,\n     pub vis: Visibility,\n     pub defaultness: hir::Defaultness,\n@@ -362,7 +362,7 @@ impl<'tcx> Method<'tcx> {\n     pub fn new(name: Name,\n                generics: ty::Generics<'tcx>,\n                predicates: GenericPredicates<'tcx>,\n-               fty: BareFnTy<'tcx>,\n+               fty: &'tcx BareFnTy<'tcx>,\n                explicit_self: ExplicitSelfCategory,\n                vis: Visibility,\n                defaultness: hir::Defaultness,\n@@ -524,6 +524,10 @@ bitflags! {\n         // that are local to a particular fn\n         const HAS_LOCAL_NAMES   = 1 << 9,\n \n+        // Present if the type belongs in a local type context.\n+        // Only set for TyInfer other than Fresh.\n+        const KEEP_IN_LOCAL_TCX = 1 << 10,\n+\n         const NEEDS_SUBST        = TypeFlags::HAS_PARAMS.bits |\n                                    TypeFlags::HAS_SELF.bits |\n                                    TypeFlags::HAS_RE_EARLY_BOUND.bits,\n@@ -540,7 +544,8 @@ bitflags! {\n                                   TypeFlags::HAS_TY_ERR.bits |\n                                   TypeFlags::HAS_PROJECTION.bits |\n                                   TypeFlags::HAS_TY_CLOSURE.bits |\n-                                  TypeFlags::HAS_LOCAL_NAMES.bits,\n+                                  TypeFlags::HAS_LOCAL_NAMES.bits |\n+                                  TypeFlags::KEEP_IN_LOCAL_TCX.bits,\n \n         // Caches for type_is_sized, type_moves_by_default\n         const SIZEDNESS_CACHED  = 1 << 16,\n@@ -773,27 +778,28 @@ pub struct GenericPredicates<'tcx> {\n     pub predicates: VecPerParamSpace<Predicate<'tcx>>,\n }\n \n-impl<'tcx> GenericPredicates<'tcx> {\n+impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n     pub fn empty() -> GenericPredicates<'tcx> {\n         GenericPredicates {\n             predicates: VecPerParamSpace::empty(),\n         }\n     }\n \n-    pub fn instantiate(&self, tcx: &TyCtxt<'tcx>, substs: &Substs<'tcx>)\n+    pub fn instantiate(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, substs: &Substs<'tcx>)\n                        -> InstantiatedPredicates<'tcx> {\n         InstantiatedPredicates {\n             predicates: self.predicates.subst(tcx, substs),\n         }\n     }\n \n-    pub fn instantiate_supertrait(&self,\n-                                  tcx: &TyCtxt<'tcx>,\n+    pub fn instantiate_supertrait(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                   poly_trait_ref: &ty::PolyTraitRef<'tcx>)\n                                   -> InstantiatedPredicates<'tcx>\n     {\n         InstantiatedPredicates {\n-            predicates: self.predicates.map(|pred| pred.subst_supertrait(tcx, poly_trait_ref))\n+            predicates: self.predicates.map(|pred| {\n+                pred.subst_supertrait(tcx, poly_trait_ref)\n+            })\n         }\n     }\n }\n@@ -833,14 +839,13 @@ pub enum Predicate<'tcx> {\n     ClosureKind(DefId, ClosureKind),\n }\n \n-impl<'tcx> Predicate<'tcx> {\n+impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n     /// Performs a substitution suitable for going from a\n     /// poly-trait-ref to supertraits that must hold if that\n     /// poly-trait-ref holds. This is slightly different from a normal\n     /// substitution in terms of what happens with bound regions.  See\n     /// lengthy comment below for details.\n-    pub fn subst_supertrait(&self,\n-                            tcx: &TyCtxt<'tcx>,\n+    pub fn subst_supertrait(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                             trait_ref: &ty::PolyTraitRef<'tcx>)\n                             -> ty::Predicate<'tcx>\n     {\n@@ -1211,11 +1216,9 @@ impl<'tcx> TraitRef<'tcx> {\n /// future I hope to refine the representation of types so as to make\n /// more distinctions clearer.\n #[derive(Clone)]\n-pub struct ParameterEnvironment<'a, 'tcx:'a> {\n-    pub tcx: &'a TyCtxt<'tcx>,\n-\n+pub struct ParameterEnvironment<'tcx> {\n     /// See `construct_free_substs` for details.\n-    pub free_substs: Substs<'tcx>,\n+    pub free_substs: &'tcx Substs<'tcx>,\n \n     /// Each type parameter has an implicit region bound that\n     /// indicates it must outlive at least the function body (the user\n@@ -1228,13 +1231,6 @@ pub struct ParameterEnvironment<'a, 'tcx:'a> {\n     /// into Obligations, and elaborated and normalized.\n     pub caller_bounds: Vec<ty::Predicate<'tcx>>,\n \n-    /// Caches the results of trait selection. This cache is used\n-    /// for things that have to do with the parameters in scope.\n-    pub selection_cache: traits::SelectionCache<'tcx>,\n-\n-    /// Caches the results of trait evaluation.\n-    pub evaluation_cache: traits::EvaluationCache<'tcx>,\n-\n     /// Scope that is attached to free regions for this scope. This\n     /// is usually the id of the fn body, but for more abstract scopes\n     /// like structs we often use the node-id of the struct.\n@@ -1245,59 +1241,57 @@ pub struct ParameterEnvironment<'a, 'tcx:'a> {\n     pub free_id_outlive: CodeExtent,\n }\n \n-impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n+impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n     pub fn with_caller_bounds(&self,\n                               caller_bounds: Vec<ty::Predicate<'tcx>>)\n-                              -> ParameterEnvironment<'a,'tcx>\n+                              -> ParameterEnvironment<'tcx>\n     {\n         ParameterEnvironment {\n-            tcx: self.tcx,\n-            free_substs: self.free_substs.clone(),\n+            free_substs: self.free_substs,\n             implicit_region_bound: self.implicit_region_bound,\n             caller_bounds: caller_bounds,\n-            selection_cache: traits::SelectionCache::new(),\n-            evaluation_cache: traits::EvaluationCache::new(),\n             free_id_outlive: self.free_id_outlive,\n         }\n     }\n \n     /// Construct a parameter environment given an item, impl item, or trait item\n-    pub fn for_item(cx: &'a TyCtxt<'tcx>, id: NodeId) -> ParameterEnvironment<'a, 'tcx> {\n-        match cx.map.find(id) {\n+    pub fn for_item(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: NodeId)\n+                    -> ParameterEnvironment<'tcx> {\n+        match tcx.map.find(id) {\n             Some(ast_map::NodeImplItem(ref impl_item)) => {\n                 match impl_item.node {\n                     hir::ImplItemKind::Type(_) => {\n                         // associated types don't have their own entry (for some reason),\n                         // so for now just grab environment for the impl\n-                        let impl_id = cx.map.get_parent(id);\n-                        let impl_def_id = cx.map.local_def_id(impl_id);\n-                        let scheme = cx.lookup_item_type(impl_def_id);\n-                        let predicates = cx.lookup_predicates(impl_def_id);\n-                        cx.construct_parameter_environment(impl_item.span,\n-                                                           &scheme.generics,\n-                                                           &predicates,\n-                                                           cx.region_maps.item_extent(id))\n+                        let impl_id = tcx.map.get_parent(id);\n+                        let impl_def_id = tcx.map.local_def_id(impl_id);\n+                        let scheme = tcx.lookup_item_type(impl_def_id);\n+                        let predicates = tcx.lookup_predicates(impl_def_id);\n+                        tcx.construct_parameter_environment(impl_item.span,\n+                                                            &scheme.generics,\n+                                                            &predicates,\n+                                                            tcx.region_maps.item_extent(id))\n                     }\n                     hir::ImplItemKind::Const(_, _) => {\n-                        let def_id = cx.map.local_def_id(id);\n-                        let scheme = cx.lookup_item_type(def_id);\n-                        let predicates = cx.lookup_predicates(def_id);\n-                        cx.construct_parameter_environment(impl_item.span,\n-                                                           &scheme.generics,\n-                                                           &predicates,\n-                                                           cx.region_maps.item_extent(id))\n+                        let def_id = tcx.map.local_def_id(id);\n+                        let scheme = tcx.lookup_item_type(def_id);\n+                        let predicates = tcx.lookup_predicates(def_id);\n+                        tcx.construct_parameter_environment(impl_item.span,\n+                                                            &scheme.generics,\n+                                                            &predicates,\n+                                                            tcx.region_maps.item_extent(id))\n                     }\n                     hir::ImplItemKind::Method(_, ref body) => {\n-                        let method_def_id = cx.map.local_def_id(id);\n-                        match cx.impl_or_trait_item(method_def_id) {\n+                        let method_def_id = tcx.map.local_def_id(id);\n+                        match tcx.impl_or_trait_item(method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n                                 let method_generics = &method_ty.generics;\n                                 let method_bounds = &method_ty.predicates;\n-                                cx.construct_parameter_environment(\n+                                tcx.construct_parameter_environment(\n                                     impl_item.span,\n                                     method_generics,\n                                     method_bounds,\n-                                    cx.region_maps.call_site_extent(id, body.id))\n+                                    tcx.region_maps.call_site_extent(id, body.id))\n                             }\n                             _ => {\n                                 bug!(\"ParameterEnvironment::for_item(): \\\n@@ -1312,41 +1306,41 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                     hir::TypeTraitItem(..) => {\n                         // associated types don't have their own entry (for some reason),\n                         // so for now just grab environment for the trait\n-                        let trait_id = cx.map.get_parent(id);\n-                        let trait_def_id = cx.map.local_def_id(trait_id);\n-                        let trait_def = cx.lookup_trait_def(trait_def_id);\n-                        let predicates = cx.lookup_predicates(trait_def_id);\n-                        cx.construct_parameter_environment(trait_item.span,\n-                                                           &trait_def.generics,\n-                                                           &predicates,\n-                                                           cx.region_maps.item_extent(id))\n+                        let trait_id = tcx.map.get_parent(id);\n+                        let trait_def_id = tcx.map.local_def_id(trait_id);\n+                        let trait_def = tcx.lookup_trait_def(trait_def_id);\n+                        let predicates = tcx.lookup_predicates(trait_def_id);\n+                        tcx.construct_parameter_environment(trait_item.span,\n+                                                            &trait_def.generics,\n+                                                            &predicates,\n+                                                            tcx.region_maps.item_extent(id))\n                     }\n                     hir::ConstTraitItem(..) => {\n-                        let def_id = cx.map.local_def_id(id);\n-                        let scheme = cx.lookup_item_type(def_id);\n-                        let predicates = cx.lookup_predicates(def_id);\n-                        cx.construct_parameter_environment(trait_item.span,\n-                                                           &scheme.generics,\n-                                                           &predicates,\n-                                                           cx.region_maps.item_extent(id))\n+                        let def_id = tcx.map.local_def_id(id);\n+                        let scheme = tcx.lookup_item_type(def_id);\n+                        let predicates = tcx.lookup_predicates(def_id);\n+                        tcx.construct_parameter_environment(trait_item.span,\n+                                                            &scheme.generics,\n+                                                            &predicates,\n+                                                            tcx.region_maps.item_extent(id))\n                     }\n                     hir::MethodTraitItem(_, ref body) => {\n                         // Use call-site for extent (unless this is a\n                         // trait method with no default; then fallback\n                         // to the method id).\n-                        let method_def_id = cx.map.local_def_id(id);\n-                        match cx.impl_or_trait_item(method_def_id) {\n+                        let method_def_id = tcx.map.local_def_id(id);\n+                        match tcx.impl_or_trait_item(method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n                                 let method_generics = &method_ty.generics;\n                                 let method_bounds = &method_ty.predicates;\n                                 let extent = if let Some(ref body) = *body {\n                                     // default impl: use call_site extent as free_id_outlive bound.\n-                                    cx.region_maps.call_site_extent(id, body.id)\n+                                    tcx.region_maps.call_site_extent(id, body.id)\n                                 } else {\n                                     // no default impl: use item extent as free_id_outlive bound.\n-                                    cx.region_maps.item_extent(id)\n+                                    tcx.region_maps.item_extent(id)\n                                 };\n-                                cx.construct_parameter_environment(\n+                                tcx.construct_parameter_environment(\n                                     trait_item.span,\n                                     method_generics,\n                                     method_bounds,\n@@ -1365,38 +1359,38 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                 match item.node {\n                     hir::ItemFn(_, _, _, _, _, ref body) => {\n                         // We assume this is a function.\n-                        let fn_def_id = cx.map.local_def_id(id);\n-                        let fn_scheme = cx.lookup_item_type(fn_def_id);\n-                        let fn_predicates = cx.lookup_predicates(fn_def_id);\n-\n-                        cx.construct_parameter_environment(item.span,\n-                                                           &fn_scheme.generics,\n-                                                           &fn_predicates,\n-                                                           cx.region_maps.call_site_extent(id,\n-                                                                                           body.id))\n+                        let fn_def_id = tcx.map.local_def_id(id);\n+                        let fn_scheme = tcx.lookup_item_type(fn_def_id);\n+                        let fn_predicates = tcx.lookup_predicates(fn_def_id);\n+\n+                        tcx.construct_parameter_environment(\n+                            item.span,\n+                            &fn_scheme.generics,\n+                            &fn_predicates,\n+                            tcx.region_maps.call_site_extent(id, body.id))\n                     }\n                     hir::ItemEnum(..) |\n                     hir::ItemStruct(..) |\n                     hir::ItemTy(..) |\n                     hir::ItemImpl(..) |\n                     hir::ItemConst(..) |\n                     hir::ItemStatic(..) => {\n-                        let def_id = cx.map.local_def_id(id);\n-                        let scheme = cx.lookup_item_type(def_id);\n-                        let predicates = cx.lookup_predicates(def_id);\n-                        cx.construct_parameter_environment(item.span,\n-                                                           &scheme.generics,\n-                                                           &predicates,\n-                                                           cx.region_maps.item_extent(id))\n+                        let def_id = tcx.map.local_def_id(id);\n+                        let scheme = tcx.lookup_item_type(def_id);\n+                        let predicates = tcx.lookup_predicates(def_id);\n+                        tcx.construct_parameter_environment(item.span,\n+                                                            &scheme.generics,\n+                                                            &predicates,\n+                                                            tcx.region_maps.item_extent(id))\n                     }\n                     hir::ItemTrait(..) => {\n-                        let def_id = cx.map.local_def_id(id);\n-                        let trait_def = cx.lookup_trait_def(def_id);\n-                        let predicates = cx.lookup_predicates(def_id);\n-                        cx.construct_parameter_environment(item.span,\n-                                                           &trait_def.generics,\n-                                                           &predicates,\n-                                                           cx.region_maps.item_extent(id))\n+                        let def_id = tcx.map.local_def_id(id);\n+                        let trait_def = tcx.lookup_trait_def(def_id);\n+                        let predicates = tcx.lookup_predicates(def_id);\n+                        tcx.construct_parameter_environment(item.span,\n+                                                            &trait_def.generics,\n+                                                            &predicates,\n+                                                            tcx.region_maps.item_extent(id))\n                     }\n                     _ => {\n                         span_bug!(item.span,\n@@ -1408,21 +1402,21 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n             }\n             Some(ast_map::NodeExpr(..)) => {\n                 // This is a convenience to allow closures to work.\n-                ParameterEnvironment::for_item(cx, cx.map.get_parent(id))\n+                ParameterEnvironment::for_item(tcx, tcx.map.get_parent(id))\n             }\n             Some(ast_map::NodeForeignItem(item)) => {\n-                let def_id = cx.map.local_def_id(id);\n-                let scheme = cx.lookup_item_type(def_id);\n-                let predicates = cx.lookup_predicates(def_id);\n-                cx.construct_parameter_environment(item.span,\n-                                                   &scheme.generics,\n-                                                   &predicates,\n-                                                   ROOT_CODE_EXTENT)\n+                let def_id = tcx.map.local_def_id(id);\n+                let scheme = tcx.lookup_item_type(def_id);\n+                let predicates = tcx.lookup_predicates(def_id);\n+                tcx.construct_parameter_environment(item.span,\n+                                                    &scheme.generics,\n+                                                    &predicates,\n+                                                    ROOT_CODE_EXTENT)\n             }\n             _ => {\n                 bug!(\"ParameterEnvironment::from_item(): \\\n                       `{}` is not an item\",\n-                     cx.map.node_to_string(id))\n+                     tcx.map.node_to_string(id))\n             }\n         }\n     }\n@@ -1570,11 +1564,11 @@ impl VariantKind {\n     }\n }\n \n-impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n-    fn new(tcx: &TyCtxt<'tcx>,\n+impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n+    fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n            did: DefId,\n            kind: AdtKind,\n-           variants: Vec<VariantDefData<'tcx, 'container>>) -> Self {\n+           variants: Vec<VariantDefData<'gcx, 'container>>) -> Self {\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n         let attrs = tcx.get_attrs(did);\n         if attr::contains_name(&attrs, \"fundamental\") {\n@@ -1601,7 +1595,7 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n         }\n     }\n \n-    fn calculate_dtorck(&'tcx self, tcx: &TyCtxt<'tcx>) {\n+    fn calculate_dtorck(&'gcx self, tcx: TyCtxt) {\n         if tcx.is_adt_dtorck(self) {\n             self.flags.set(self.flags.get() | AdtFlags::IS_DTORCK);\n         }\n@@ -1622,7 +1616,7 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n     /// true, this type being safe for destruction requires it to be\n     /// alive; Otherwise, only the contents are required to be.\n     #[inline]\n-    pub fn is_dtorck(&'tcx self, tcx: &TyCtxt<'tcx>) -> bool {\n+    pub fn is_dtorck(&'gcx self, tcx: TyCtxt) -> bool {\n         if !self.flags.get().intersects(AdtFlags::IS_DTORCK_VALID) {\n             self.calculate_dtorck(tcx)\n         }\n@@ -1657,18 +1651,18 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n \n     /// Asserts this is a struct and returns the struct's unique\n     /// variant.\n-    pub fn struct_variant(&self) -> &VariantDefData<'tcx, 'container> {\n+    pub fn struct_variant(&self) -> &VariantDefData<'gcx, 'container> {\n         assert_eq!(self.adt_kind(), AdtKind::Struct);\n         &self.variants[0]\n     }\n \n     #[inline]\n-    pub fn type_scheme(&self, tcx: &TyCtxt<'tcx>) -> TypeScheme<'tcx> {\n+    pub fn type_scheme(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> TypeScheme<'gcx> {\n         tcx.lookup_item_type(self.did)\n     }\n \n     #[inline]\n-    pub fn predicates(&self, tcx: &TyCtxt<'tcx>) -> GenericPredicates<'tcx> {\n+    pub fn predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> GenericPredicates<'gcx> {\n         tcx.lookup_predicates(self.did)\n     }\n \n@@ -1677,10 +1671,10 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n     #[inline]\n     pub fn all_fields(&self) ->\n             iter::FlatMap<\n-                slice::Iter<VariantDefData<'tcx, 'container>>,\n-                slice::Iter<FieldDefData<'tcx, 'container>>,\n-                for<'s> fn(&'s VariantDefData<'tcx, 'container>)\n-                    -> slice::Iter<'s, FieldDefData<'tcx, 'container>>\n+                slice::Iter<VariantDefData<'gcx, 'container>>,\n+                slice::Iter<FieldDefData<'gcx, 'container>>,\n+                for<'s> fn(&'s VariantDefData<'gcx, 'container>)\n+                    -> slice::Iter<'s, FieldDefData<'gcx, 'container>>\n             > {\n         self.variants.iter().flat_map(VariantDefData::fields_iter)\n     }\n@@ -1700,7 +1694,7 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n             self.variants.iter().all(|v| v.fields.is_empty())\n     }\n \n-    pub fn variant_with_id(&self, vid: DefId) -> &VariantDefData<'tcx, 'container> {\n+    pub fn variant_with_id(&self, vid: DefId) -> &VariantDefData<'gcx, 'container> {\n         self.variants\n             .iter()\n             .find(|v| v.did == vid)\n@@ -1714,7 +1708,7 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n             .expect(\"variant_index_with_id: unknown variant\")\n     }\n \n-    pub fn variant_of_def(&self, def: Def) -> &VariantDefData<'tcx, 'container> {\n+    pub fn variant_of_def(&self, def: Def) -> &VariantDefData<'gcx, 'container> {\n         match def {\n             Def::Variant(_, vid) => self.variant_with_id(vid),\n             Def::Struct(..) | Def::TyAlias(..) => self.struct_variant(),\n@@ -1738,7 +1732,9 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n             None => NoDtor,\n         }\n     }\n+}\n \n+impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'tcx, 'container> {\n     /// Returns a simpler type such that `Self: Sized` if and only\n     /// if that type is Sized, or `TyErr` if this type is recursive.\n     ///\n@@ -1756,20 +1752,21 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n     ///\n     /// Due to normalization being eager, this applies even if\n     /// the associated type is behind a pointer, e.g. issue #31299.\n-    pub fn sized_constraint(&self, tcx: &ty::TyCtxt<'tcx>) -> Ty<'tcx> {\n+    pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         let dep_node = DepNode::SizedConstraint(self.did);\n         match self.sized_constraint.get(dep_node) {\n             None => {\n-                let this = tcx.lookup_adt_def_master(self.did);\n-                this.calculate_sized_constraint_inner(tcx, &mut Vec::new());\n+                let global_tcx = tcx.global_tcx();\n+                let this = global_tcx.lookup_adt_def_master(self.did);\n+                this.calculate_sized_constraint_inner(global_tcx, &mut Vec::new());\n                 self.sized_constraint(tcx)\n             }\n             Some(ty) => ty\n         }\n     }\n }\n \n-impl<'tcx> AdtDefData<'tcx, 'tcx> {\n+impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n     /// Calculates the Sized-constraint.\n     ///\n     /// As the Sized-constraint of enums can be a *set* of types,\n@@ -1785,7 +1782,7 @@ impl<'tcx> AdtDefData<'tcx, 'tcx> {\n     ///       such.\n     ///     - a TyError, if a type contained itself. The representability\n     ///       check should catch this case.\n-    fn calculate_sized_constraint_inner(&'tcx self, tcx: &ty::TyCtxt<'tcx>,\n+    fn calculate_sized_constraint_inner(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         stack: &mut Vec<AdtDefMaster<'tcx>>)\n     {\n \n@@ -1838,7 +1835,7 @@ impl<'tcx> AdtDefData<'tcx, 'tcx> {\n \n     fn sized_constraint_for_ty(\n         &'tcx self,\n-        tcx: &ty::TyCtxt<'tcx>,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         stack: &mut Vec<AdtDefMaster<'tcx>>,\n         ty: Ty<'tcx>\n     ) -> Vec<Ty<'tcx>> {\n@@ -1953,7 +1950,7 @@ impl<'tcx, 'container> VariantDefData<'tcx, 'container> {\n     }\n }\n \n-impl<'tcx, 'container> FieldDefData<'tcx, 'container> {\n+impl<'a, 'gcx, 'tcx, 'container> FieldDefData<'tcx, 'container> {\n     pub fn new(did: DefId,\n                name: Name,\n                vis: Visibility) -> Self {\n@@ -1965,7 +1962,7 @@ impl<'tcx, 'container> FieldDefData<'tcx, 'container> {\n         }\n     }\n \n-    pub fn ty(&self, tcx: &TyCtxt<'tcx>, subst: &Substs<'tcx>) -> Ty<'tcx> {\n+    pub fn ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, subst: &Substs<'tcx>) -> Ty<'tcx> {\n         self.unsubst_ty().subst(tcx, subst)\n     }\n \n@@ -1982,7 +1979,7 @@ impl<'tcx, 'container> FieldDefData<'tcx, 'container> {\n /// item into the monotype of an item reference.\n #[derive(Clone)]\n pub struct ItemSubsts<'tcx> {\n-    pub substs: Substs<'tcx>,\n+    pub substs: &'tcx Substs<'tcx>,\n }\n \n #[derive(Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n@@ -1995,20 +1992,20 @@ pub enum ClosureKind {\n     FnOnce,\n }\n \n-impl ClosureKind {\n-    pub fn trait_did(&self, cx: &TyCtxt) -> DefId {\n+impl<'a, 'tcx> ClosureKind {\n+    pub fn trait_did(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> DefId {\n         let result = match *self {\n-            ClosureKind::Fn => cx.lang_items.require(FnTraitLangItem),\n+            ClosureKind::Fn => tcx.lang_items.require(FnTraitLangItem),\n             ClosureKind::FnMut => {\n-                cx.lang_items.require(FnMutTraitLangItem)\n+                tcx.lang_items.require(FnMutTraitLangItem)\n             }\n             ClosureKind::FnOnce => {\n-                cx.lang_items.require(FnOnceTraitLangItem)\n+                tcx.lang_items.require(FnOnceTraitLangItem)\n             }\n         };\n         match result {\n             Ok(trait_did) => trait_did,\n-            Err(err) => cx.sess.fatal(&err[..]),\n+            Err(err) => tcx.sess.fatal(&err[..]),\n         }\n     }\n \n@@ -2067,10 +2064,6 @@ impl<'tcx> TyS<'tcx> {\n }\n \n impl<'tcx> ItemSubsts<'tcx> {\n-    pub fn empty() -> ItemSubsts<'tcx> {\n-        ItemSubsts { substs: Substs::empty() }\n-    }\n-\n     pub fn is_noop(&self) -> bool {\n         self.substs.is_noop()\n     }\n@@ -2092,7 +2085,7 @@ impl LvaluePreference {\n }\n \n /// Helper for looking things up in the various maps that are populated during\n-/// typeck::collect (e.g., `cx.impl_or_trait_items`, `cx.tcache`, etc).  All of\n+/// typeck::collect (e.g., `tcx.impl_or_trait_items`, `tcx.tcache`, etc).  All of\n /// these share the pattern that if the id is local, it should have been loaded\n /// into the map by the `typeck::collect` phase.  If the def-id is external,\n /// then we have to go consult the crate loading code (and cache the result for\n@@ -2146,32 +2139,34 @@ impl BorrowKind {\n     }\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn node_id_to_type(&self, id: NodeId) -> Ty<'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    pub fn node_id_to_type(self, id: NodeId) -> Ty<'gcx> {\n         match self.node_id_to_type_opt(id) {\n            Some(ty) => ty,\n            None => bug!(\"node_id_to_type: no type for node `{}`\",\n                         self.map.node_to_string(id))\n         }\n     }\n \n-    pub fn node_id_to_type_opt(&self, id: NodeId) -> Option<Ty<'tcx>> {\n+    pub fn node_id_to_type_opt(self, id: NodeId) -> Option<Ty<'gcx>> {\n         self.tables.borrow().node_types.get(&id).cloned()\n     }\n \n-    pub fn node_id_item_substs(&self, id: NodeId) -> ItemSubsts<'tcx> {\n+    pub fn node_id_item_substs(self, id: NodeId) -> ItemSubsts<'gcx> {\n         match self.tables.borrow().item_substs.get(&id) {\n-            None => ItemSubsts::empty(),\n+            None => ItemSubsts {\n+                substs: self.global_tcx().mk_substs(Substs::empty())\n+            },\n             Some(ts) => ts.clone(),\n         }\n     }\n \n     // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n     // doesn't provide type parameter substitutions.\n-    pub fn pat_ty(&self, pat: &hir::Pat) -> Ty<'tcx> {\n+    pub fn pat_ty(self, pat: &hir::Pat) -> Ty<'gcx> {\n         self.node_id_to_type(pat.id)\n     }\n-    pub fn pat_ty_opt(&self, pat: &hir::Pat) -> Option<Ty<'tcx>> {\n+    pub fn pat_ty_opt(self, pat: &hir::Pat) -> Option<Ty<'gcx>> {\n         self.node_id_to_type_opt(pat.id)\n     }\n \n@@ -2185,11 +2180,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     // NB (2): This type doesn't provide type parameter substitutions; e.g. if you\n     // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&isize) -> isize\"\n     // instead of \"fn(ty) -> T with T = isize\".\n-    pub fn expr_ty(&self, expr: &hir::Expr) -> Ty<'tcx> {\n+    pub fn expr_ty(self, expr: &hir::Expr) -> Ty<'gcx> {\n         self.node_id_to_type(expr.id)\n     }\n \n-    pub fn expr_ty_opt(&self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n+    pub fn expr_ty_opt(self, expr: &hir::Expr) -> Option<Ty<'gcx>> {\n         self.node_id_to_type_opt(expr.id)\n     }\n \n@@ -2202,17 +2197,17 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// hard to do, I just hate that code so much I didn't want to touch it\n     /// unless it was to fix it properly, which seemed a distraction from the\n     /// thread at hand! -nmatsakis\n-    pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> Ty<'tcx> {\n+    pub fn expr_ty_adjusted(self, expr: &hir::Expr) -> Ty<'gcx> {\n         self.expr_ty(expr)\n-            .adjust(self, expr.span, expr.id,\n+            .adjust(self.global_tcx(), expr.span, expr.id,\n                     self.tables.borrow().adjustments.get(&expr.id),\n                     |method_call| {\n             self.tables.borrow().method_map.get(&method_call).map(|method| method.ty)\n         })\n     }\n \n-    pub fn expr_ty_adjusted_opt(&self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n-        self.expr_ty_opt(expr).map(|t| t.adjust(self,\n+    pub fn expr_ty_adjusted_opt(self, expr: &hir::Expr) -> Option<Ty<'gcx>> {\n+        self.expr_ty_opt(expr).map(|t| t.adjust(self.global_tcx(),\n                                                 expr.span,\n                                                 expr.id,\n                                                 self.tables.borrow().adjustments.get(&expr.id),\n@@ -2221,7 +2216,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }))\n     }\n \n-    pub fn expr_span(&self, id: NodeId) -> Span {\n+    pub fn expr_span(self, id: NodeId) -> Span {\n         match self.map.find(id) {\n             Some(ast_map::NodeExpr(e)) => {\n                 e.span\n@@ -2235,7 +2230,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn local_var_name_str(&self, id: NodeId) -> InternedString {\n+    pub fn local_var_name_str(self, id: NodeId) -> InternedString {\n         match self.map.find(id) {\n             Some(ast_map::NodeLocal(pat)) => {\n                 match pat.node {\n@@ -2249,7 +2244,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn resolve_expr(&self, expr: &hir::Expr) -> Def {\n+    pub fn resolve_expr(self, expr: &hir::Expr) -> Def {\n         match self.def_map.borrow().get(&expr.id) {\n             Some(def) => def.full_def(),\n             None => {\n@@ -2258,7 +2253,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn expr_is_lval(&self, expr: &hir::Expr) -> bool {\n+    pub fn expr_is_lval(self, expr: &hir::Expr) -> bool {\n          match expr.node {\n             hir::ExprPath(..) => {\n                 // We can't use resolve_expr here, as this needs to run on broken\n@@ -2320,7 +2315,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn provided_trait_methods(&self, id: DefId) -> Vec<Rc<Method<'tcx>>> {\n+    pub fn provided_trait_methods(self, id: DefId) -> Vec<Rc<Method<'gcx>>> {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             if let ItemTrait(_, _, _, ref ms) = self.map.expect_item(id).node {\n                 ms.iter().filter_map(|ti| {\n@@ -2341,11 +2336,11 @@ impl<'tcx> TyCtxt<'tcx> {\n                 bug!(\"provided_trait_methods: `{:?}` is not a trait\", id)\n             }\n         } else {\n-            self.sess.cstore.provided_trait_methods(self, id)\n+            self.sess.cstore.provided_trait_methods(self.global_tcx(), id)\n         }\n     }\n \n-    pub fn associated_consts(&self, id: DefId) -> Vec<Rc<AssociatedConst<'tcx>>> {\n+    pub fn associated_consts(self, id: DefId) -> Vec<Rc<AssociatedConst<'gcx>>> {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             match self.map.expect_item(id).node {\n                 ItemTrait(_, _, _, ref tis) => {\n@@ -2385,11 +2380,11 @@ impl<'tcx> TyCtxt<'tcx> {\n                 }\n             }\n         } else {\n-            self.sess.cstore.associated_consts(self, id)\n+            self.sess.cstore.associated_consts(self.global_tcx(), id)\n         }\n     }\n \n-    pub fn trait_impl_polarity(&self, id: DefId) -> Option<hir::ImplPolarity> {\n+    pub fn trait_impl_polarity(self, id: DefId) -> Option<hir::ImplPolarity> {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             match self.map.find(id) {\n                 Some(ast_map::NodeItem(item)) => {\n@@ -2405,7 +2400,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn custom_coerce_unsized_kind(&self, did: DefId) -> adjustment::CustomCoerceUnsized {\n+    pub fn custom_coerce_unsized_kind(self, did: DefId) -> adjustment::CustomCoerceUnsized {\n         self.custom_coerce_unsized_kinds.memoize(did, || {\n             let (kind, src) = if did.krate != LOCAL_CRATE {\n                 (self.sess.cstore.custom_coerce_unsized_kind(did), \"external\")\n@@ -2424,29 +2419,29 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    pub fn impl_or_trait_item(&self, id: DefId) -> ImplOrTraitItem<'tcx> {\n+    pub fn impl_or_trait_item(self, id: DefId) -> ImplOrTraitItem<'gcx> {\n         lookup_locally_or_in_crate_store(\n             \"impl_or_trait_items\", id, &self.impl_or_trait_items,\n-            || self.sess.cstore.impl_or_trait_item(self, id)\n+            || self.sess.cstore.impl_or_trait_item(self.global_tcx(), id)\n                    .expect(\"missing ImplOrTraitItem in metadata\"))\n     }\n \n-    pub fn trait_item_def_ids(&self, id: DefId) -> Rc<Vec<ImplOrTraitItemId>> {\n+    pub fn trait_item_def_ids(self, id: DefId) -> Rc<Vec<ImplOrTraitItemId>> {\n         lookup_locally_or_in_crate_store(\n             \"trait_item_def_ids\", id, &self.trait_item_def_ids,\n             || Rc::new(self.sess.cstore.trait_item_def_ids(id)))\n     }\n \n     /// Returns the trait-ref corresponding to a given impl, or None if it is\n     /// an inherent impl.\n-    pub fn impl_trait_ref(&self, id: DefId) -> Option<TraitRef<'tcx>> {\n+    pub fn impl_trait_ref(self, id: DefId) -> Option<TraitRef<'gcx>> {\n         lookup_locally_or_in_crate_store(\n             \"impl_trait_refs\", id, &self.impl_trait_refs,\n-            || self.sess.cstore.impl_trait_ref(self, id))\n+            || self.sess.cstore.impl_trait_ref(self.global_tcx(), id))\n     }\n \n     /// Returns whether this DefId refers to an impl\n-    pub fn is_impl(&self, id: DefId) -> bool {\n+    pub fn is_impl(self, id: DefId) -> bool {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             if let Some(ast_map::NodeItem(\n                 &hir::Item { node: hir::ItemImpl(..), .. })) = self.map.find(id) {\n@@ -2459,11 +2454,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn trait_ref_to_def_id(&self, tr: &hir::TraitRef) -> DefId {\n+    pub fn trait_ref_to_def_id(self, tr: &hir::TraitRef) -> DefId {\n         self.def_map.borrow().get(&tr.ref_id).expect(\"no def-map entry for trait\").def_id()\n     }\n \n-    pub fn def_key(&self, id: DefId) -> ast_map::DefKey {\n+    pub fn def_key(self, id: DefId) -> ast_map::DefKey {\n         if id.is_local() {\n             self.map.def_key(id)\n         } else {\n@@ -2474,15 +2469,15 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Returns the `DefPath` of an item. Note that if `id` is not\n     /// local to this crate -- or is inlined into this crate -- the\n     /// result will be a non-local `DefPath`.\n-    pub fn def_path(&self, id: DefId) -> ast_map::DefPath {\n+    pub fn def_path(self, id: DefId) -> ast_map::DefPath {\n         if id.is_local() {\n             self.map.def_path(id)\n         } else {\n             self.sess.cstore.relative_def_path(id)\n         }\n     }\n \n-    pub fn item_name(&self, id: DefId) -> ast::Name {\n+    pub fn item_name(self, id: DefId) -> ast::Name {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             self.map.name(id)\n         } else {\n@@ -2491,55 +2486,55 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     // Register a given item type\n-    pub fn register_item_type(&self, did: DefId, ty: TypeScheme<'tcx>) {\n+    pub fn register_item_type(self, did: DefId, ty: TypeScheme<'gcx>) {\n         self.tcache.borrow_mut().insert(did, ty);\n     }\n \n     // If the given item is in an external crate, looks up its type and adds it to\n     // the type cache. Returns the type parameters and type.\n-    pub fn lookup_item_type(&self, did: DefId) -> TypeScheme<'tcx> {\n+    pub fn lookup_item_type(self, did: DefId) -> TypeScheme<'gcx> {\n         lookup_locally_or_in_crate_store(\n             \"tcache\", did, &self.tcache,\n-            || self.sess.cstore.item_type(self, did))\n+            || self.sess.cstore.item_type(self.global_tcx(), did))\n     }\n \n     /// Given the did of a trait, returns its canonical trait ref.\n-    pub fn lookup_trait_def(&self, did: DefId) -> &'tcx TraitDef<'tcx> {\n+    pub fn lookup_trait_def(self, did: DefId) -> &'gcx TraitDef<'gcx> {\n         lookup_locally_or_in_crate_store(\n             \"trait_defs\", did, &self.trait_defs,\n-            || self.alloc_trait_def(self.sess.cstore.trait_def(self, did))\n+            || self.alloc_trait_def(self.sess.cstore.trait_def(self.global_tcx(), did))\n         )\n     }\n \n     /// Given the did of an ADT, return a master reference to its\n     /// definition. Unless you are planning on fulfilling the ADT's fields,\n     /// use lookup_adt_def instead.\n-    pub fn lookup_adt_def_master(&self, did: DefId) -> AdtDefMaster<'tcx> {\n+    pub fn lookup_adt_def_master(self, did: DefId) -> AdtDefMaster<'gcx> {\n         lookup_locally_or_in_crate_store(\n             \"adt_defs\", did, &self.adt_defs,\n-            || self.sess.cstore.adt_def(self, did)\n+            || self.sess.cstore.adt_def(self.global_tcx(), did)\n         )\n     }\n \n     /// Given the did of an ADT, return a reference to its definition.\n-    pub fn lookup_adt_def(&self, did: DefId) -> AdtDef<'tcx> {\n+    pub fn lookup_adt_def(self, did: DefId) -> AdtDef<'gcx> {\n         // when reverse-variance goes away, a transmute::<AdtDefMaster,AdtDef>\n         // would be needed here.\n         self.lookup_adt_def_master(did)\n     }\n \n     /// Given the did of an item, returns its full set of predicates.\n-    pub fn lookup_predicates(&self, did: DefId) -> GenericPredicates<'tcx> {\n+    pub fn lookup_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n         lookup_locally_or_in_crate_store(\n             \"predicates\", did, &self.predicates,\n-            || self.sess.cstore.item_predicates(self, did))\n+            || self.sess.cstore.item_predicates(self.global_tcx(), did))\n     }\n \n     /// Given the did of a trait, returns its superpredicates.\n-    pub fn lookup_super_predicates(&self, did: DefId) -> GenericPredicates<'tcx> {\n+    pub fn lookup_super_predicates(self, did: DefId) -> GenericPredicates<'gcx> {\n         lookup_locally_or_in_crate_store(\n             \"super_predicates\", did, &self.super_predicates,\n-            || self.sess.cstore.item_super_predicates(self, did))\n+            || self.sess.cstore.item_super_predicates(self.global_tcx(), did))\n     }\n \n     /// If `type_needs_drop` returns true, then `ty` is definitely\n@@ -2548,14 +2543,15 @@ impl<'tcx> TyCtxt<'tcx> {\n     ///\n     /// (Note that this implies that if `ty` has a destructor attached,\n     /// then `type_needs_drop` will definitely return `true` for `ty`.)\n-    pub fn type_needs_drop_given_env<'a>(&self,\n-                                         ty: Ty<'tcx>,\n-                                         param_env: &ty::ParameterEnvironment<'a,'tcx>) -> bool {\n+    pub fn type_needs_drop_given_env(self,\n+                                     ty: Ty<'gcx>,\n+                                     param_env: &ty::ParameterEnvironment<'gcx>) -> bool {\n         // Issue #22536: We first query type_moves_by_default.  It sees a\n         // normalized version of the type, and therefore will definitely\n         // know whether the type implements Copy (and thus needs no\n         // cleanup/drop/zeroing) ...\n-        let implements_copy = !ty.moves_by_default(param_env, DUMMY_SP);\n+        let tcx = self.global_tcx();\n+        let implements_copy = !ty.moves_by_default(tcx, param_env, DUMMY_SP);\n \n         if implements_copy { return false; }\n \n@@ -2570,13 +2566,13 @@ impl<'tcx> TyCtxt<'tcx> {\n         // bound attached (see above), it is sound to treat it as having a\n         // destructor (e.g. zero its memory on move).\n \n-        let contents = ty.type_contents(self);\n+        let contents = ty.type_contents(tcx);\n         debug!(\"type_needs_drop ty={:?} contents={:?}\", ty, contents);\n-        contents.needs_drop(self)\n+        contents.needs_drop(tcx)\n     }\n \n     /// Get the attributes of a definition.\n-    pub fn get_attrs(&self, did: DefId) -> Cow<'tcx, [ast::Attribute]> {\n+    pub fn get_attrs(self, did: DefId) -> Cow<'gcx, [ast::Attribute]> {\n         if let Some(id) = self.map.as_local_node_id(did) {\n             Cow::Borrowed(self.map.attrs(id))\n         } else {\n@@ -2585,42 +2581,42 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Determine whether an item is annotated with an attribute\n-    pub fn has_attr(&self, did: DefId, attr: &str) -> bool {\n+    pub fn has_attr(self, did: DefId, attr: &str) -> bool {\n         self.get_attrs(did).iter().any(|item| item.check_name(attr))\n     }\n \n     /// Determine whether an item is annotated with `#[repr(packed)]`\n-    pub fn lookup_packed(&self, did: DefId) -> bool {\n+    pub fn lookup_packed(self, did: DefId) -> bool {\n         self.lookup_repr_hints(did).contains(&attr::ReprPacked)\n     }\n \n     /// Determine whether an item is annotated with `#[simd]`\n-    pub fn lookup_simd(&self, did: DefId) -> bool {\n+    pub fn lookup_simd(self, did: DefId) -> bool {\n         self.has_attr(did, \"simd\")\n             || self.lookup_repr_hints(did).contains(&attr::ReprSimd)\n     }\n \n-    pub fn item_variances(&self, item_id: DefId) -> Rc<ItemVariances> {\n+    pub fn item_variances(self, item_id: DefId) -> Rc<ItemVariances> {\n         lookup_locally_or_in_crate_store(\n             \"item_variance_map\", item_id, &self.item_variance_map,\n             || Rc::new(self.sess.cstore.item_variances(item_id)))\n     }\n \n-    pub fn trait_has_default_impl(&self, trait_def_id: DefId) -> bool {\n+    pub fn trait_has_default_impl(self, trait_def_id: DefId) -> bool {\n         self.populate_implementations_for_trait_if_necessary(trait_def_id);\n \n         let def = self.lookup_trait_def(trait_def_id);\n         def.flags.get().intersects(TraitFlags::HAS_DEFAULT_IMPL)\n     }\n \n     /// Records a trait-to-implementation mapping.\n-    pub fn record_trait_has_default_impl(&self, trait_def_id: DefId) {\n+    pub fn record_trait_has_default_impl(self, trait_def_id: DefId) {\n         let def = self.lookup_trait_def(trait_def_id);\n         def.flags.set(def.flags.get() | TraitFlags::HAS_DEFAULT_IMPL)\n     }\n \n     /// Load primitive inherent implementations if necessary\n-    pub fn populate_implementations_for_primitive_if_necessary(&self,\n+    pub fn populate_implementations_for_primitive_if_necessary(self,\n                                                                primitive_def_id: DefId) {\n         if primitive_def_id.is_local() {\n             return\n@@ -2646,7 +2642,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Populates the type context with all the inherent implementations for\n     /// the given type if necessary.\n-    pub fn populate_inherent_implementations_for_type_if_necessary(&self,\n+    pub fn populate_inherent_implementations_for_type_if_necessary(self,\n                                                                    type_id: DefId) {\n         if type_id.is_local() {\n             return\n@@ -2676,7 +2672,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Populates the type context with all the implementations for the given\n     /// trait if necessary.\n-    pub fn populate_implementations_for_trait_if_necessary(&self, trait_id: DefId) {\n+    pub fn populate_implementations_for_trait_if_necessary(self, trait_id: DefId) {\n         if trait_id.is_local() {\n             return\n         }\n@@ -2723,29 +2719,48 @@ impl<'tcx> TyCtxt<'tcx> {\n         def.flags.set(def.flags.get() | TraitFlags::IMPLS_VALID);\n     }\n \n-    pub fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind {\n-        Tables::closure_kind(&self.tables, self, def_id)\n+    pub fn closure_kind(self, def_id: DefId) -> ty::ClosureKind {\n+        // If this is a local def-id, it should be inserted into the\n+        // tables by typeck; else, it will be retreived from\n+        // the external crate metadata.\n+        if let Some(&kind) = self.tables.borrow().closure_kinds.get(&def_id) {\n+            return kind;\n+        }\n+\n+        let kind = self.sess.cstore.closure_kind(def_id);\n+        self.tables.borrow_mut().closure_kinds.insert(def_id, kind);\n+        kind\n     }\n \n-    pub fn closure_type(&self,\n+    pub fn closure_type(self,\n                         def_id: DefId,\n-                        substs: &ClosureSubsts<'tcx>)\n+                        substs: ClosureSubsts<'tcx>)\n                         -> ty::ClosureTy<'tcx>\n     {\n-        Tables::closure_type(&self.tables, self, def_id, substs)\n+        // If this is a local def-id, it should be inserted into the\n+        // tables by typeck; else, it will be retreived from\n+        // the external crate metadata.\n+        if let Some(ty) = self.tables.borrow().closure_tys.get(&def_id) {\n+            return ty.subst(self, substs.func_substs);\n+        }\n+\n+        let ty = self.sess.cstore.closure_ty(self.global_tcx(), def_id);\n+        self.tables.borrow_mut().closure_tys.insert(def_id, ty.clone());\n+        ty.subst(self, substs.func_substs)\n     }\n \n     /// Given the def_id of an impl, return the def_id of the trait it implements.\n     /// If it implements no trait, return `None`.\n-    pub fn trait_id_of_impl(&self, def_id: DefId) -> Option<DefId> {\n+    pub fn trait_id_of_impl(self, def_id: DefId) -> Option<DefId> {\n         self.impl_trait_ref(def_id).map(|tr| tr.def_id)\n     }\n \n     /// If the given def ID describes a method belonging to an impl, return the\n     /// ID of the impl that the method belongs to. Otherwise, return `None`.\n-    pub fn impl_of_method(&self, def_id: DefId) -> Option<DefId> {\n+    pub fn impl_of_method(self, def_id: DefId) -> Option<DefId> {\n         if def_id.krate != LOCAL_CRATE {\n-            return self.sess.cstore.impl_or_trait_item(self, def_id).and_then(|item| {\n+            return self.sess.cstore.impl_or_trait_item(self.global_tcx(), def_id)\n+                       .and_then(|item| {\n                 match item.container() {\n                     TraitContainer(_) => None,\n                     ImplContainer(def_id) => Some(def_id),\n@@ -2766,9 +2781,9 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// If the given def ID describes an item belonging to a trait (either a\n     /// default method or an implementation of a trait method), return the ID of\n     /// the trait that the method belongs to. Otherwise, return `None`.\n-    pub fn trait_of_item(&self, def_id: DefId) -> Option<DefId> {\n+    pub fn trait_of_item(self, def_id: DefId) -> Option<DefId> {\n         if def_id.krate != LOCAL_CRATE {\n-            return self.sess.cstore.trait_of_item(self, def_id);\n+            return self.sess.cstore.trait_of_item(self.global_tcx(), def_id);\n         }\n         match self.impl_or_trait_items.borrow().get(&def_id).cloned() {\n             Some(impl_or_trait_item) => {\n@@ -2787,7 +2802,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// is already that of the original trait method, then the return value is\n     /// the same).\n     /// Otherwise, return `None`.\n-    pub fn trait_item_of_item(&self, def_id: DefId) -> Option<ImplOrTraitItemId> {\n+    pub fn trait_item_of_item(self, def_id: DefId) -> Option<ImplOrTraitItemId> {\n         let impl_item = match self.impl_or_trait_items.borrow().get(&def_id) {\n             Some(m) => m.clone(),\n             None => return None,\n@@ -2805,34 +2820,32 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Construct a parameter environment suitable for static contexts or other contexts where there\n     /// are no free type/lifetime parameters in scope.\n-    pub fn empty_parameter_environment<'a>(&'a self)\n-                                           -> ParameterEnvironment<'a,'tcx> {\n+    pub fn empty_parameter_environment(self) -> ParameterEnvironment<'tcx> {\n \n         // for an empty parameter environment, there ARE no free\n         // regions, so it shouldn't matter what we use for the free id\n         let free_id_outlive = self.region_maps.node_extent(ast::DUMMY_NODE_ID);\n-        ty::ParameterEnvironment { tcx: self,\n-                                   free_substs: Substs::empty(),\n-                                   caller_bounds: Vec::new(),\n-                                   implicit_region_bound: ty::ReEmpty,\n-                                   selection_cache: traits::SelectionCache::new(),\n-                                   evaluation_cache: traits::EvaluationCache::new(),\n-                                   free_id_outlive: free_id_outlive }\n+        ty::ParameterEnvironment {\n+            free_substs: self.mk_substs(Substs::empty()),\n+            caller_bounds: Vec::new(),\n+            implicit_region_bound: ty::ReEmpty,\n+            free_id_outlive: free_id_outlive\n+        }\n     }\n \n     /// Constructs and returns a substitution that can be applied to move from\n     /// the \"outer\" view of a type or method to the \"inner\" view.\n     /// In general, this means converting from bound parameters to\n     /// free parameters. Since we currently represent bound/free type\n     /// parameters in the same way, this only has an effect on regions.\n-    pub fn construct_free_substs(&self, generics: &Generics<'tcx>,\n-                                 free_id_outlive: CodeExtent) -> Substs<'tcx> {\n+    pub fn construct_free_substs(self, generics: &Generics<'gcx>,\n+                                 free_id_outlive: CodeExtent) -> Substs<'gcx> {\n         // map T => T\n         let mut types = VecPerParamSpace::empty();\n         for def in generics.types.as_slice() {\n             debug!(\"construct_parameter_environment(): push_types_from_defs: def={:?}\",\n                     def);\n-            types.push(def.space, self.mk_param_from_def(def));\n+            types.push(def.space, self.global_tcx().mk_param_from_def(def));\n         }\n \n         // map bound 'a => free 'a\n@@ -2854,12 +2867,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// See `ParameterEnvironment` struct def'n for details.\n     /// If you were using `free_id: NodeId`, you might try `self.region_maps.item_extent(free_id)`\n     /// for the `free_id_outlive` parameter. (But note that that is not always quite right.)\n-    pub fn construct_parameter_environment<'a>(&'a self,\n-                                               span: Span,\n-                                               generics: &ty::Generics<'tcx>,\n-                                               generic_predicates: &ty::GenericPredicates<'tcx>,\n-                                               free_id_outlive: CodeExtent)\n-                                               -> ParameterEnvironment<'a, 'tcx>\n+    pub fn construct_parameter_environment(self,\n+                                           span: Span,\n+                                           generics: &ty::Generics<'gcx>,\n+                                           generic_predicates: &ty::GenericPredicates<'gcx>,\n+                                           free_id_outlive: CodeExtent)\n+                                           -> ParameterEnvironment<'gcx>\n     {\n         //\n         // Construct the free substs.\n@@ -2871,8 +2884,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         // Compute the bounds on Self and the type parameters.\n         //\n \n-        let bounds = generic_predicates.instantiate(self, &free_substs);\n-        let bounds = self.liberate_late_bound_regions(free_id_outlive, &ty::Binder(bounds));\n+        let tcx = self.global_tcx();\n+        let bounds = generic_predicates.instantiate(tcx, &free_substs);\n+        let bounds = tcx.liberate_late_bound_regions(free_id_outlive, &ty::Binder(bounds));\n         let predicates = bounds.predicates.into_vec();\n \n         // Finally, we have to normalize the bounds in the environment, in\n@@ -2889,43 +2903,40 @@ impl<'tcx> TyCtxt<'tcx> {\n         //\n \n         let unnormalized_env = ty::ParameterEnvironment {\n-            tcx: self,\n-            free_substs: free_substs,\n+            free_substs: tcx.mk_substs(free_substs),\n             implicit_region_bound: ty::ReScope(free_id_outlive),\n             caller_bounds: predicates,\n-            selection_cache: traits::SelectionCache::new(),\n-            evaluation_cache: traits::EvaluationCache::new(),\n             free_id_outlive: free_id_outlive,\n         };\n \n         let cause = traits::ObligationCause::misc(span, free_id_outlive.node_id(&self.region_maps));\n-        traits::normalize_param_env_or_error(unnormalized_env, cause)\n+        traits::normalize_param_env_or_error(tcx, unnormalized_env, cause)\n     }\n \n-    pub fn is_method_call(&self, expr_id: NodeId) -> bool {\n+    pub fn is_method_call(self, expr_id: NodeId) -> bool {\n         self.tables.borrow().method_map.contains_key(&MethodCall::expr(expr_id))\n     }\n \n-    pub fn is_overloaded_autoderef(&self, expr_id: NodeId, autoderefs: u32) -> bool {\n+    pub fn is_overloaded_autoderef(self, expr_id: NodeId, autoderefs: u32) -> bool {\n         self.tables.borrow().method_map.contains_key(&MethodCall::autoderef(expr_id,\n                                                                             autoderefs))\n     }\n \n-    pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n+    pub fn upvar_capture(self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n         Some(self.tables.borrow().upvar_capture_map.get(&upvar_id).unwrap().clone())\n     }\n \n-    pub fn visit_all_items_in_krate<V,F>(&self,\n+    pub fn visit_all_items_in_krate<V,F>(self,\n                                          dep_node_fn: F,\n                                          visitor: &mut V)\n-        where F: FnMut(DefId) -> DepNode<DefId>, V: Visitor<'tcx>\n+        where F: FnMut(DefId) -> DepNode<DefId>, V: Visitor<'gcx>\n     {\n-        dep_graph::visit_all_items_in_krate(self, dep_node_fn, visitor);\n+        dep_graph::visit_all_items_in_krate(self.global_tcx(), dep_node_fn, visitor);\n     }\n \n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`\n     /// with the name of the crate containing the impl.\n-    pub fn span_of_impl(&self, impl_did: DefId) -> Result<Span, InternedString> {\n+    pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, InternedString> {\n         if impl_did.is_local() {\n             let node_id = self.map.as_local_node_id(impl_did).unwrap();\n             Ok(self.map.span(node_id))\n@@ -2944,8 +2955,8 @@ pub enum ExplicitSelfCategory {\n     ByBox,\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn with_freevars<T, F>(&self, fid: NodeId, f: F) -> T where\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    pub fn with_freevars<T, F>(self, fid: NodeId, f: F) -> T where\n         F: FnOnce(&[hir::Freevar]) -> T,\n     {\n         match self.freevars.borrow().get(&fid) {"}, {"sha": "9ae3325c2588f5f7749206f780b1be0a72b609ed", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 136, "deletions": 139, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -55,160 +55,157 @@ pub enum Component<'tcx> {\n     EscapingProjection(Vec<Component<'tcx>>),\n }\n \n-/// Returns all the things that must outlive `'a` for the condition\n-/// `ty0: 'a` to hold.\n-pub fn components<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                           ty0: Ty<'tcx>)\n-                           -> Vec<Component<'tcx>> {\n-    let mut components = vec![];\n-    compute_components(infcx, ty0, &mut components);\n-    debug!(\"components({:?}) = {:?}\", ty0, components);\n-    components\n-}\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    /// Returns all the things that must outlive `'a` for the condition\n+    /// `ty0: 'a` to hold.\n+    pub fn outlives_components(&self, ty0: Ty<'tcx>)\n+                               -> Vec<Component<'tcx>> {\n+        let mut components = vec![];\n+        self.compute_components(ty0, &mut components);\n+        debug!(\"components({:?}) = {:?}\", ty0, components);\n+        components\n+    }\n \n-fn compute_components<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                               ty: Ty<'tcx>,\n-                               out: &mut Vec<Component<'tcx>>) {\n-    // Descend through the types, looking for the various \"base\"\n-    // components and collecting them into `out`. This is not written\n-    // with `collect()` because of the need to sometimes skip subtrees\n-    // in the `subtys` iterator (e.g., when encountering a\n-    // projection).\n-    match ty.sty {\n-        ty::TyClosure(_, ref substs) => {\n-            // FIXME(#27086). We do not accumulate from substs, since they\n-            // don't represent reachable data. This means that, in\n-            // practice, some of the lifetime parameters might not\n-            // be in scope when the body runs, so long as there is\n-            // no reachable data with that lifetime. For better or\n-            // worse, this is consistent with fn types, however,\n-            // which can also encapsulate data in this fashion\n-            // (though it's somewhat harder, and typically\n-            // requires virtual dispatch).\n-            //\n-            // Note that changing this (in a naive way, at least)\n-            // causes regressions for what appears to be perfectly\n-            // reasonable code like this:\n-            //\n-            // ```\n-            // fn foo<'a>(p: &Data<'a>) {\n-            //    bar(|q: &mut Parser| q.read_addr())\n-            // }\n-            // fn bar(p: Box<FnMut(&mut Parser)+'static>) {\n-            // }\n-            // ```\n-            //\n-            // Note that `p` (and `'a`) are not used in the\n-            // closure at all, but to meet the requirement that\n-            // the closure type `C: 'static` (so it can be coerced\n-            // to the object type), we get the requirement that\n-            // `'a: 'static` since `'a` appears in the closure\n-            // type `C`.\n-            //\n-            // A smarter fix might \"prune\" unused `func_substs` --\n-            // this would avoid breaking simple examples like\n-            // this, but would still break others (which might\n-            // indeed be invalid, depending on your POV). Pruning\n-            // would be a subtle process, since we have to see\n-            // what func/type parameters are used and unused,\n-            // taking into consideration UFCS and so forth.\n+    fn compute_components(&self, ty: Ty<'tcx>, out: &mut Vec<Component<'tcx>>) {\n+        // Descend through the types, looking for the various \"base\"\n+        // components and collecting them into `out`. This is not written\n+        // with `collect()` because of the need to sometimes skip subtrees\n+        // in the `subtys` iterator (e.g., when encountering a\n+        // projection).\n+        match ty.sty {\n+            ty::TyClosure(_, ref substs) => {\n+                // FIXME(#27086). We do not accumulate from substs, since they\n+                // don't represent reachable data. This means that, in\n+                // practice, some of the lifetime parameters might not\n+                // be in scope when the body runs, so long as there is\n+                // no reachable data with that lifetime. For better or\n+                // worse, this is consistent with fn types, however,\n+                // which can also encapsulate data in this fashion\n+                // (though it's somewhat harder, and typically\n+                // requires virtual dispatch).\n+                //\n+                // Note that changing this (in a naive way, at least)\n+                // causes regressions for what appears to be perfectly\n+                // reasonable code like this:\n+                //\n+                // ```\n+                // fn foo<'a>(p: &Data<'a>) {\n+                //    bar(|q: &mut Parser| q.read_addr())\n+                // }\n+                // fn bar(p: Box<FnMut(&mut Parser)+'static>) {\n+                // }\n+                // ```\n+                //\n+                // Note that `p` (and `'a`) are not used in the\n+                // closure at all, but to meet the requirement that\n+                // the closure type `C: 'static` (so it can be coerced\n+                // to the object type), we get the requirement that\n+                // `'a: 'static` since `'a` appears in the closure\n+                // type `C`.\n+                //\n+                // A smarter fix might \"prune\" unused `func_substs` --\n+                // this would avoid breaking simple examples like\n+                // this, but would still break others (which might\n+                // indeed be invalid, depending on your POV). Pruning\n+                // would be a subtle process, since we have to see\n+                // what func/type parameters are used and unused,\n+                // taking into consideration UFCS and so forth.\n \n-            for &upvar_ty in &substs.upvar_tys {\n-                compute_components(infcx, upvar_ty, out);\n+                for &upvar_ty in substs.upvar_tys {\n+                    self.compute_components(upvar_ty, out);\n+                }\n             }\n-        }\n \n-        // OutlivesTypeParameterEnv -- the actual checking that `X:'a`\n-        // is implied by the environment is done in regionck.\n-        ty::TyParam(p) => {\n-            out.push(Component::Param(p));\n-        }\n+            // OutlivesTypeParameterEnv -- the actual checking that `X:'a`\n+            // is implied by the environment is done in regionck.\n+            ty::TyParam(p) => {\n+                out.push(Component::Param(p));\n+            }\n \n-        // For projections, we prefer to generate an obligation like\n-        // `<P0 as Trait<P1...Pn>>::Foo: 'a`, because this gives the\n-        // regionck more ways to prove that it holds. However,\n-        // regionck is not (at least currently) prepared to deal with\n-        // higher-ranked regions that may appear in the\n-        // trait-ref. Therefore, if we see any higher-ranke regions,\n-        // we simply fallback to the most restrictive rule, which\n-        // requires that `Pi: 'a` for all `i`.\n-        ty::TyProjection(ref data) => {\n-            if !data.has_escaping_regions() {\n-                // best case: no escaping regions, so push the\n-                // projection and skip the subtree (thus generating no\n-                // constraints for Pi). This defers the choice between\n-                // the rules OutlivesProjectionEnv,\n-                // OutlivesProjectionTraitDef, and\n-                // OutlivesProjectionComponents to regionck.\n-                out.push(Component::Projection(*data));\n-            } else {\n-                // fallback case: hard code\n-                // OutlivesProjectionComponents.  Continue walking\n-                // through and constrain Pi.\n-                let subcomponents = capture_components(infcx, ty);\n-                out.push(Component::EscapingProjection(subcomponents));\n+            // For projections, we prefer to generate an obligation like\n+            // `<P0 as Trait<P1...Pn>>::Foo: 'a`, because this gives the\n+            // regionck more ways to prove that it holds. However,\n+            // regionck is not (at least currently) prepared to deal with\n+            // higher-ranked regions that may appear in the\n+            // trait-ref. Therefore, if we see any higher-ranke regions,\n+            // we simply fallback to the most restrictive rule, which\n+            // requires that `Pi: 'a` for all `i`.\n+            ty::TyProjection(ref data) => {\n+                if !data.has_escaping_regions() {\n+                    // best case: no escaping regions, so push the\n+                    // projection and skip the subtree (thus generating no\n+                    // constraints for Pi). This defers the choice between\n+                    // the rules OutlivesProjectionEnv,\n+                    // OutlivesProjectionTraitDef, and\n+                    // OutlivesProjectionComponents to regionck.\n+                    out.push(Component::Projection(*data));\n+                } else {\n+                    // fallback case: hard code\n+                    // OutlivesProjectionComponents.  Continue walking\n+                    // through and constrain Pi.\n+                    let subcomponents = self.capture_components(ty);\n+                    out.push(Component::EscapingProjection(subcomponents));\n+                }\n             }\n-        }\n \n-        // If we encounter an inference variable, try to resolve it\n-        // and proceed with resolved version. If we cannot resolve it,\n-        // then record the unresolved variable as a component.\n-        ty::TyInfer(_) => {\n-            let ty = infcx.resolve_type_vars_if_possible(&ty);\n-            if let ty::TyInfer(infer_ty) = ty.sty {\n-                out.push(Component::UnresolvedInferenceVariable(infer_ty));\n-            } else {\n-                compute_components(infcx, ty, out);\n+            // If we encounter an inference variable, try to resolve it\n+            // and proceed with resolved version. If we cannot resolve it,\n+            // then record the unresolved variable as a component.\n+            ty::TyInfer(_) => {\n+                let ty = self.resolve_type_vars_if_possible(&ty);\n+                if let ty::TyInfer(infer_ty) = ty.sty {\n+                    out.push(Component::UnresolvedInferenceVariable(infer_ty));\n+                } else {\n+                    self.compute_components(ty, out);\n+                }\n             }\n-        }\n \n-        // Most types do not introduce any region binders, nor\n-        // involve any other subtle cases, and so the WF relation\n-        // simply constraints any regions referenced directly by\n-        // the type and then visits the types that are lexically\n-        // contained within. (The comments refer to relevant rules\n-        // from RFC1214.)\n-        ty::TyBool |            // OutlivesScalar\n-        ty::TyChar |            // OutlivesScalar\n-        ty::TyInt(..) |         // OutlivesScalar\n-        ty::TyUint(..) |        // OutlivesScalar\n-        ty::TyFloat(..) |       // OutlivesScalar\n-        ty::TyEnum(..) |        // OutlivesNominalType\n-        ty::TyStruct(..) |      // OutlivesNominalType\n-        ty::TyBox(..) |         // OutlivesNominalType (ish)\n-        ty::TyStr |             // OutlivesScalar (ish)\n-        ty::TyArray(..) |       // ...\n-        ty::TySlice(..) |       // ...\n-        ty::TyRawPtr(..) |      // ...\n-        ty::TyRef(..) |         // OutlivesReference\n-        ty::TyTuple(..) |       // ...\n-        ty::TyFnDef(..) |       // OutlivesFunction (*)\n-        ty::TyFnPtr(_) |        // OutlivesFunction (*)\n-        ty::TyTrait(..) |       // OutlivesObject, OutlivesFragment (*)\n-        ty::TyError => {\n-            // (*) Bare functions and traits are both binders. In the\n-            // RFC, this means we would add the bound regions to the\n-            // \"bound regions list\".  In our representation, no such\n-            // list is maintained explicitly, because bound regions\n-            // themselves can be readily identified.\n+            // Most types do not introduce any region binders, nor\n+            // involve any other subtle cases, and so the WF relation\n+            // simply constraints any regions referenced directly by\n+            // the type and then visits the types that are lexically\n+            // contained within. (The comments refer to relevant rules\n+            // from RFC1214.)\n+            ty::TyBool |            // OutlivesScalar\n+            ty::TyChar |            // OutlivesScalar\n+            ty::TyInt(..) |         // OutlivesScalar\n+            ty::TyUint(..) |        // OutlivesScalar\n+            ty::TyFloat(..) |       // OutlivesScalar\n+            ty::TyEnum(..) |        // OutlivesNominalType\n+            ty::TyStruct(..) |      // OutlivesNominalType\n+            ty::TyBox(..) |         // OutlivesNominalType (ish)\n+            ty::TyStr |             // OutlivesScalar (ish)\n+            ty::TyArray(..) |       // ...\n+            ty::TySlice(..) |       // ...\n+            ty::TyRawPtr(..) |      // ...\n+            ty::TyRef(..) |         // OutlivesReference\n+            ty::TyTuple(..) |       // ...\n+            ty::TyFnDef(..) |       // OutlivesFunction (*)\n+            ty::TyFnPtr(_) |        // OutlivesFunction (*)\n+            ty::TyTrait(..) |       // OutlivesObject, OutlivesFragment (*)\n+            ty::TyError => {\n+                // (*) Bare functions and traits are both binders. In the\n+                // RFC, this means we would add the bound regions to the\n+                // \"bound regions list\".  In our representation, no such\n+                // list is maintained explicitly, because bound regions\n+                // themselves can be readily identified.\n \n-            push_region_constraints(out, ty.regions());\n-            for subty in ty.walk_shallow() {\n-                compute_components(infcx, subty, out);\n+                push_region_constraints(out, ty.regions());\n+                for subty in ty.walk_shallow() {\n+                    self.compute_components(subty, out);\n+                }\n             }\n         }\n     }\n-}\n \n-fn capture_components<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                               ty: Ty<'tcx>)\n-                               -> Vec<Component<'tcx>> {\n-    let mut temp = vec![];\n-    push_region_constraints(&mut temp, ty.regions());\n-    for subty in ty.walk_shallow() {\n-        compute_components(infcx, subty, &mut temp);\n+    fn capture_components(&self, ty: Ty<'tcx>) -> Vec<Component<'tcx>> {\n+        let mut temp = vec![];\n+        push_region_constraints(&mut temp, ty.regions());\n+        for subty in ty.walk_shallow() {\n+            self.compute_components(subty, &mut temp);\n+        }\n+        temp\n     }\n-    temp\n }\n \n fn push_region_constraints<'tcx>(out: &mut Vec<Component<'tcx>>, regions: Vec<ty::Region>) {"}, {"sha": "80c727f022127745809e6e299b2725486a76d0fb", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 182, "deletions": 185, "changes": 367, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -28,8 +28,8 @@ pub enum Cause {\n     ExistentialRegionBound, // relating an existential region bound\n }\n \n-pub trait TypeRelation<'a,'tcx> : Sized {\n-    fn tcx(&self) -> &'a TyCtxt<'tcx>;\n+pub trait TypeRelation<'a, 'gcx: 'a+'tcx, 'tcx: 'a> : Sized {\n+    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx>;\n \n     /// Returns a static string we can use for printouts.\n     fn tag(&self) -> &'static str;\n@@ -45,22 +45,22 @@ pub trait TypeRelation<'a,'tcx> : Sized {\n     }\n \n     /// Generic relation routine suitable for most anything.\n-    fn relate<T:Relate<'a,'tcx>>(&mut self, a: &T, b: &T) -> RelateResult<'tcx, T> {\n+    fn relate<T: Relate<'tcx>>(&mut self, a: &T, b: &T) -> RelateResult<'tcx, T> {\n         Relate::relate(self, a, b)\n     }\n \n     /// Relete elements of two slices pairwise.\n-    fn relate_zip<T:Relate<'a,'tcx>>(&mut self, a: &[T], b: &[T]) -> RelateResult<'tcx, Vec<T>> {\n+    fn relate_zip<T: Relate<'tcx>>(&mut self, a: &[T], b: &[T]) -> RelateResult<'tcx, Vec<T>> {\n         assert_eq!(a.len(), b.len());\n         a.iter().zip(b).map(|(a, b)| self.relate(a, b)).collect()\n     }\n \n     /// Switch variance for the purpose of relating `a` and `b`.\n-    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n-                                               variance: ty::Variance,\n-                                               a: &T,\n-                                               b: &T)\n-                                               -> RelateResult<'tcx, T>;\n+    fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n+                                             variance: ty::Variance,\n+                                             a: &T,\n+                                             b: &T)\n+                                             -> RelateResult<'tcx, T>;\n \n     // Overrideable relations. You shouldn't typically call these\n     // directly, instead call `relate()`, which in turn calls\n@@ -76,25 +76,24 @@ pub trait TypeRelation<'a,'tcx> : Sized {\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n-        where T: Relate<'a,'tcx>;\n+        where T: Relate<'tcx>;\n }\n \n-pub trait Relate<'a,'tcx>: TypeFoldable<'tcx> {\n-    fn relate<R:TypeRelation<'a,'tcx>>(relation: &mut R,\n-                                       a: &Self,\n-                                       b: &Self)\n-                                       -> RelateResult<'tcx, Self>;\n+pub trait Relate<'tcx>: TypeFoldable<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R, a: &Self, b: &Self)\n+                           -> RelateResult<'tcx, Self>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a;\n }\n \n ///////////////////////////////////////////////////////////////////////////\n // Relate impls\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::TypeAndMut<'tcx> {\n-    fn relate<R>(relation: &mut R,\n-                 a: &ty::TypeAndMut<'tcx>,\n-                 b: &ty::TypeAndMut<'tcx>)\n-                 -> RelateResult<'tcx, ty::TypeAndMut<'tcx>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::TypeAndMut<'tcx>,\n+                           b: &ty::TypeAndMut<'tcx>)\n+                           -> RelateResult<'tcx, ty::TypeAndMut<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         debug!(\"{}.mts({:?}, {:?})\",\n                relation.tag(),\n@@ -117,12 +116,12 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::TypeAndMut<'tcx> {\n // substitutions are not themselves relatable without more context,\n // but they is an important subroutine for things that ARE relatable,\n // like traits etc.\n-fn relate_item_substs<'a,'tcx:'a,R>(relation: &mut R,\n-                                    item_def_id: DefId,\n-                                    a_subst: &Substs<'tcx>,\n-                                    b_subst: &Substs<'tcx>)\n-                                    -> RelateResult<'tcx, Substs<'tcx>>\n-    where R: TypeRelation<'a,'tcx>\n+fn relate_item_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n+                                         item_def_id: DefId,\n+                                         a_subst: &'tcx Substs<'tcx>,\n+                                         b_subst: &'tcx Substs<'tcx>)\n+                                         -> RelateResult<'tcx, &'tcx Substs<'tcx>>\n+    where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     debug!(\"substs: item_def_id={:?} a_subst={:?} b_subst={:?}\",\n            item_def_id,\n@@ -139,12 +138,12 @@ fn relate_item_substs<'a,'tcx:'a,R>(relation: &mut R,\n     relate_substs(relation, opt_variances, a_subst, b_subst)\n }\n \n-pub fn relate_substs<'a,'tcx:'a,R>(relation: &mut R,\n-                                   variances: Option<&ty::ItemVariances>,\n-                                   a_subst: &Substs<'tcx>,\n-                                   b_subst: &Substs<'tcx>)\n-                                   -> RelateResult<'tcx, Substs<'tcx>>\n-    where R: TypeRelation<'a,'tcx>\n+pub fn relate_substs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n+                                        variances: Option<&ty::ItemVariances>,\n+                                        a_subst: &'tcx Substs<'tcx>,\n+                                        b_subst: &'tcx Substs<'tcx>)\n+                                        -> RelateResult<'tcx, &'tcx Substs<'tcx>>\n+    where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     let mut substs = Substs::empty();\n \n@@ -167,15 +166,15 @@ pub fn relate_substs<'a,'tcx:'a,R>(relation: &mut R,\n         substs.regions.replace(space, regions);\n     }\n \n-    Ok(substs)\n+    Ok(relation.tcx().mk_substs(substs))\n }\n \n-fn relate_type_params<'a,'tcx:'a,R>(relation: &mut R,\n-                                    variances: Option<&[ty::Variance]>,\n-                                    a_tys: &[Ty<'tcx>],\n-                                    b_tys: &[Ty<'tcx>])\n-                                    -> RelateResult<'tcx, Vec<Ty<'tcx>>>\n-    where R: TypeRelation<'a,'tcx>\n+fn relate_type_params<'a, 'gcx, 'tcx, R>(relation: &mut R,\n+                                         variances: Option<&[ty::Variance]>,\n+                                         a_tys: &[Ty<'tcx>],\n+                                         b_tys: &[Ty<'tcx>])\n+                                         -> RelateResult<'tcx, Vec<Ty<'tcx>>>\n+    where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     if a_tys.len() != b_tys.len() {\n         return Err(TypeError::TyParamSize(expected_found(relation,\n@@ -193,12 +192,12 @@ fn relate_type_params<'a,'tcx:'a,R>(relation: &mut R,\n         .collect()\n }\n \n-fn relate_region_params<'a,'tcx:'a,R>(relation: &mut R,\n-                                      variances: Option<&[ty::Variance]>,\n-                                      a_rs: &[ty::Region],\n-                                      b_rs: &[ty::Region])\n-                                      -> RelateResult<'tcx, Vec<ty::Region>>\n-    where R: TypeRelation<'a,'tcx>\n+fn relate_region_params<'a, 'gcx, 'tcx, R>(relation: &mut R,\n+                                           variances: Option<&[ty::Variance]>,\n+                                           a_rs: &[ty::Region],\n+                                           b_rs: &[ty::Region])\n+                                           -> RelateResult<'tcx, Vec<ty::Region>>\n+    where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     let num_region_params = a_rs.len();\n \n@@ -224,28 +223,30 @@ fn relate_region_params<'a,'tcx:'a,R>(relation: &mut R,\n         .collect()\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::BareFnTy<'tcx> {\n-    fn relate<R>(relation: &mut R,\n-                 a: &ty::BareFnTy<'tcx>,\n-                 b: &ty::BareFnTy<'tcx>)\n-                 -> RelateResult<'tcx, ty::BareFnTy<'tcx>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for &'tcx ty::BareFnTy<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &&'tcx ty::BareFnTy<'tcx>,\n+                           b: &&'tcx ty::BareFnTy<'tcx>)\n+                           -> RelateResult<'tcx, &'tcx ty::BareFnTy<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         let unsafety = relation.relate(&a.unsafety, &b.unsafety)?;\n         let abi = relation.relate(&a.abi, &b.abi)?;\n         let sig = relation.relate(&a.sig, &b.sig)?;\n-        Ok(ty::BareFnTy {unsafety: unsafety,\n-                         abi: abi,\n-                         sig: sig})\n+        Ok(relation.tcx().mk_bare_fn(ty::BareFnTy {\n+            unsafety: unsafety,\n+            abi: abi,\n+            sig: sig\n+        }))\n     }\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::FnSig<'tcx> {\n-    fn relate<R>(relation: &mut R,\n-                 a: &ty::FnSig<'tcx>,\n-                 b: &ty::FnSig<'tcx>)\n-                 -> RelateResult<'tcx, ty::FnSig<'tcx>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::FnSig<'tcx>,\n+                           b: &ty::FnSig<'tcx>)\n+                           -> RelateResult<'tcx, ty::FnSig<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         if a.variadic != b.variadic {\n             return Err(TypeError::VariadicMismatch(\n@@ -272,11 +273,11 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::FnSig<'tcx> {\n     }\n }\n \n-fn relate_arg_vecs<'a,'tcx:'a,R>(relation: &mut R,\n-                                 a_args: &[Ty<'tcx>],\n-                                 b_args: &[Ty<'tcx>])\n-                                 -> RelateResult<'tcx, Vec<Ty<'tcx>>>\n-    where R: TypeRelation<'a,'tcx>\n+fn relate_arg_vecs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n+                                      a_args: &[Ty<'tcx>],\n+                                      b_args: &[Ty<'tcx>])\n+                                      -> RelateResult<'tcx, Vec<Ty<'tcx>>>\n+    where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     if a_args.len() != b_args.len() {\n         return Err(TypeError::ArgCount);\n@@ -287,12 +288,12 @@ fn relate_arg_vecs<'a,'tcx:'a,R>(relation: &mut R,\n           .collect()\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for ast::Unsafety {\n-    fn relate<R>(relation: &mut R,\n-                 a: &ast::Unsafety,\n-                 b: &ast::Unsafety)\n-                 -> RelateResult<'tcx, ast::Unsafety>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for ast::Unsafety {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ast::Unsafety,\n+                           b: &ast::Unsafety)\n+                           -> RelateResult<'tcx, ast::Unsafety>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         if a != b {\n             Err(TypeError::UnsafetyMismatch(expected_found(relation, a, b)))\n@@ -302,12 +303,12 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ast::Unsafety {\n     }\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for abi::Abi {\n-    fn relate<R>(relation: &mut R,\n-                 a: &abi::Abi,\n-                 b: &abi::Abi)\n-                 -> RelateResult<'tcx, abi::Abi>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for abi::Abi {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &abi::Abi,\n+                           b: &abi::Abi)\n+                           -> RelateResult<'tcx, abi::Abi>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         if a == b {\n             Ok(*a)\n@@ -317,12 +318,12 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for abi::Abi {\n     }\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ProjectionTy<'tcx> {\n-    fn relate<R>(relation: &mut R,\n-                 a: &ty::ProjectionTy<'tcx>,\n-                 b: &ty::ProjectionTy<'tcx>)\n-                 -> RelateResult<'tcx, ty::ProjectionTy<'tcx>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for ty::ProjectionTy<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::ProjectionTy<'tcx>,\n+                           b: &ty::ProjectionTy<'tcx>)\n+                           -> RelateResult<'tcx, ty::ProjectionTy<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         if a.item_name != b.item_name {\n             Err(TypeError::ProjectionNameMismatched(\n@@ -334,25 +335,25 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ProjectionTy<'tcx> {\n     }\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ProjectionPredicate<'tcx> {\n-    fn relate<R>(relation: &mut R,\n-                 a: &ty::ProjectionPredicate<'tcx>,\n-                 b: &ty::ProjectionPredicate<'tcx>)\n-                 -> RelateResult<'tcx, ty::ProjectionPredicate<'tcx>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for ty::ProjectionPredicate<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::ProjectionPredicate<'tcx>,\n+                           b: &ty::ProjectionPredicate<'tcx>)\n+                           -> RelateResult<'tcx, ty::ProjectionPredicate<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         let projection_ty = relation.relate(&a.projection_ty, &b.projection_ty)?;\n         let ty = relation.relate(&a.ty, &b.ty)?;\n         Ok(ty::ProjectionPredicate { projection_ty: projection_ty, ty: ty })\n     }\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for Vec<ty::PolyProjectionPredicate<'tcx>> {\n-    fn relate<R>(relation: &mut R,\n-                 a: &Vec<ty::PolyProjectionPredicate<'tcx>>,\n-                 b: &Vec<ty::PolyProjectionPredicate<'tcx>>)\n-                 -> RelateResult<'tcx, Vec<ty::PolyProjectionPredicate<'tcx>>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for Vec<ty::PolyProjectionPredicate<'tcx>> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &Vec<ty::PolyProjectionPredicate<'tcx>>,\n+                           b: &Vec<ty::PolyProjectionPredicate<'tcx>>)\n+                           -> RelateResult<'tcx, Vec<ty::PolyProjectionPredicate<'tcx>>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         // To be compatible, `a` and `b` must be for precisely the\n         // same set of traits and item names. We always require that\n@@ -369,12 +370,12 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for Vec<ty::PolyProjectionPredicate<'tcx>> {\n     }\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ExistentialBounds<'tcx> {\n-    fn relate<R>(relation: &mut R,\n-                 a: &ty::ExistentialBounds<'tcx>,\n-                 b: &ty::ExistentialBounds<'tcx>)\n-                 -> RelateResult<'tcx, ty::ExistentialBounds<'tcx>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for ty::ExistentialBounds<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::ExistentialBounds<'tcx>,\n+                           b: &ty::ExistentialBounds<'tcx>)\n+                           -> RelateResult<'tcx, ty::ExistentialBounds<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         let r =\n             relation.with_cause(\n@@ -390,12 +391,12 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ExistentialBounds<'tcx> {\n     }\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::BuiltinBounds {\n-    fn relate<R>(relation: &mut R,\n-                 a: &ty::BuiltinBounds,\n-                 b: &ty::BuiltinBounds)\n-                 -> RelateResult<'tcx, ty::BuiltinBounds>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for ty::BuiltinBounds {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::BuiltinBounds,\n+                           b: &ty::BuiltinBounds)\n+                           -> RelateResult<'tcx, ty::BuiltinBounds>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         // Two sets of builtin bounds are only relatable if they are\n         // precisely the same (but see the coercion code).\n@@ -407,29 +408,29 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::BuiltinBounds {\n     }\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::TraitRef<'tcx> {\n-    fn relate<R>(relation: &mut R,\n-                 a: &ty::TraitRef<'tcx>,\n-                 b: &ty::TraitRef<'tcx>)\n-                 -> RelateResult<'tcx, ty::TraitRef<'tcx>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::TraitRef<'tcx>,\n+                           b: &ty::TraitRef<'tcx>)\n+                           -> RelateResult<'tcx, ty::TraitRef<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         // Different traits cannot be related\n         if a.def_id != b.def_id {\n             Err(TypeError::Traits(expected_found(relation, &a.def_id, &b.def_id)))\n         } else {\n             let substs = relate_item_substs(relation, a.def_id, a.substs, b.substs)?;\n-            Ok(ty::TraitRef { def_id: a.def_id, substs: relation.tcx().mk_substs(substs) })\n+            Ok(ty::TraitRef { def_id: a.def_id, substs: substs })\n         }\n     }\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for Ty<'tcx> {\n-    fn relate<R>(relation: &mut R,\n-                 a: &Ty<'tcx>,\n-                 b: &Ty<'tcx>)\n-                 -> RelateResult<'tcx, Ty<'tcx>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for Ty<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &Ty<'tcx>,\n+                           b: &Ty<'tcx>)\n+                           -> RelateResult<'tcx, Ty<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         relation.tys(a, b)\n     }\n@@ -438,11 +439,11 @@ impl<'a,'tcx:'a> Relate<'a,'tcx> for Ty<'tcx> {\n /// The main \"type relation\" routine. Note that this does not handle\n /// inference artifacts, so you should filter those out before calling\n /// it.\n-pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n-                                      a: Ty<'tcx>,\n-                                      b: Ty<'tcx>)\n-                                      -> RelateResult<'tcx, Ty<'tcx>>\n-    where R: TypeRelation<'a,'tcx>\n+pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n+                                           a: Ty<'tcx>,\n+                                           b: Ty<'tcx>)\n+                                           -> RelateResult<'tcx, Ty<'tcx>>\n+    where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     let tcx = relation.tcx();\n     let a_sty = &a.sty;\n@@ -482,7 +483,7 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n             if a_def == b_def =>\n         {\n             let substs = relate_item_substs(relation, a_def.did, a_substs, b_substs)?;\n-            Ok(tcx.mk_enum(a_def, tcx.mk_substs(substs)))\n+            Ok(tcx.mk_enum(a_def, substs))\n         }\n \n         (&ty::TyTrait(ref a_), &ty::TyTrait(ref b_)) =>\n@@ -496,17 +497,17 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n             if a_def == b_def =>\n         {\n             let substs = relate_item_substs(relation, a_def.did, a_substs, b_substs)?;\n-            Ok(tcx.mk_struct(a_def, tcx.mk_substs(substs)))\n+            Ok(tcx.mk_struct(a_def, substs))\n         }\n \n-        (&ty::TyClosure(a_id, ref a_substs),\n-         &ty::TyClosure(b_id, ref b_substs))\n+        (&ty::TyClosure(a_id, a_substs),\n+         &ty::TyClosure(b_id, b_substs))\n             if a_id == b_id =>\n         {\n             // All TyClosure types with the same id represent\n             // the (anonymous) type of the same closure expression. So\n             // all of their regions should be equated.\n-            let substs = relation.relate(a_substs, b_substs)?;\n+            let substs = relation.relate(&a_substs, &b_substs)?;\n             Ok(tcx.mk_closure_from_closure_substs(a_id, substs))\n         }\n \n@@ -545,7 +546,7 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n             Ok(tcx.mk_slice(t))\n         }\n \n-        (&ty::TyTuple(ref as_), &ty::TyTuple(ref bs)) =>\n+        (&ty::TyTuple(as_), &ty::TyTuple(bs)) =>\n         {\n             if as_.len() == bs.len() {\n                 let ts = as_.iter().zip(bs)\n@@ -565,13 +566,13 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n             if a_def_id == b_def_id =>\n         {\n             let substs = relate_substs(relation, None, a_substs, b_substs)?;\n-            let fty = relation.relate(a_fty, b_fty)?;\n-            Ok(tcx.mk_fn_def(a_def_id, tcx.mk_substs(substs), fty))\n+            let fty = relation.relate(&a_fty, &b_fty)?;\n+            Ok(tcx.mk_fn_def(a_def_id, substs, fty))\n         }\n \n         (&ty::TyFnPtr(a_fty), &ty::TyFnPtr(b_fty)) =>\n         {\n-            let fty = relation.relate(a_fty, b_fty)?;\n+            let fty = relation.relate(&a_fty, &b_fty)?;\n             Ok(tcx.mk_fn_ptr(fty))\n         }\n \n@@ -588,78 +589,74 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n     }\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ClosureSubsts<'tcx> {\n-    fn relate<R>(relation: &mut R,\n-                 a: &ty::ClosureSubsts<'tcx>,\n-                 b: &ty::ClosureSubsts<'tcx>)\n-                 -> RelateResult<'tcx, ty::ClosureSubsts<'tcx>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for ty::ClosureSubsts<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::ClosureSubsts<'tcx>,\n+                           b: &ty::ClosureSubsts<'tcx>)\n+                           -> RelateResult<'tcx, ty::ClosureSubsts<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n-        let func_substs = relate_substs(relation, None, a.func_substs, b.func_substs)?;\n+        let substs = relate_substs(relation, None, a.func_substs, b.func_substs)?;\n         let upvar_tys = relation.relate_zip(&a.upvar_tys, &b.upvar_tys)?;\n-        Ok(ty::ClosureSubsts { func_substs: relation.tcx().mk_substs(func_substs),\n-                               upvar_tys: upvar_tys })\n+        Ok(ty::ClosureSubsts {\n+            func_substs: substs,\n+            upvar_tys: relation.tcx().mk_type_list(upvar_tys)\n+        })\n     }\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for Substs<'tcx> {\n-    fn relate<R>(relation: &mut R,\n-                 a: &Substs<'tcx>,\n-                 b: &Substs<'tcx>)\n-                 -> RelateResult<'tcx, Substs<'tcx>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for &'tcx Substs<'tcx> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &&'tcx Substs<'tcx>,\n+                           b: &&'tcx Substs<'tcx>)\n+                           -> RelateResult<'tcx, &'tcx Substs<'tcx>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         relate_substs(relation, None, a, b)\n     }\n }\n \n-impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::Region {\n-    fn relate<R>(relation: &mut R,\n-                 a: &ty::Region,\n-                 b: &ty::Region)\n-                 -> RelateResult<'tcx, ty::Region>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx> Relate<'tcx> for ty::Region {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::Region,\n+                           b: &ty::Region)\n+                           -> RelateResult<'tcx, ty::Region>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         relation.regions(*a, *b)\n     }\n }\n \n-impl<'a,'tcx:'a,T> Relate<'a,'tcx> for ty::Binder<T>\n-    where T: Relate<'a,'tcx>\n-{\n-    fn relate<R>(relation: &mut R,\n-                 a: &ty::Binder<T>,\n-                 b: &ty::Binder<T>)\n-                 -> RelateResult<'tcx, ty::Binder<T>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for ty::Binder<T> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &ty::Binder<T>,\n+                           b: &ty::Binder<T>)\n+                           -> RelateResult<'tcx, ty::Binder<T>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         relation.binders(a, b)\n     }\n }\n \n-impl<'a,'tcx:'a,T> Relate<'a,'tcx> for Rc<T>\n-    where T: Relate<'a,'tcx>\n-{\n-    fn relate<R>(relation: &mut R,\n-                 a: &Rc<T>,\n-                 b: &Rc<T>)\n-                 -> RelateResult<'tcx, Rc<T>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for Rc<T> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &Rc<T>,\n+                           b: &Rc<T>)\n+                           -> RelateResult<'tcx, Rc<T>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         let a: &T = a;\n         let b: &T = b;\n         Ok(Rc::new(relation.relate(a, b)?))\n     }\n }\n \n-impl<'a,'tcx:'a,T> Relate<'a,'tcx> for Box<T>\n-    where T: Relate<'a,'tcx>\n-{\n-    fn relate<R>(relation: &mut R,\n-                 a: &Box<T>,\n-                 b: &Box<T>)\n-                 -> RelateResult<'tcx, Box<T>>\n-        where R: TypeRelation<'a,'tcx>\n+impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for Box<T> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &Box<T>,\n+                           b: &Box<T>)\n+                           -> RelateResult<'tcx, Box<T>>\n+        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         let a: &T = a;\n         let b: &T = b;\n@@ -670,11 +667,11 @@ impl<'a,'tcx:'a,T> Relate<'a,'tcx> for Box<T>\n ///////////////////////////////////////////////////////////////////////////\n // Error handling\n \n-pub fn expected_found<'a,'tcx:'a,R,T>(relation: &mut R,\n-                                      a: &T,\n-                                      b: &T)\n-                                      -> ExpectedFound<T>\n-    where R: TypeRelation<'a,'tcx>, T: Clone\n+pub fn expected_found<'a, 'gcx, 'tcx, R, T>(relation: &mut R,\n+                                            a: &T,\n+                                            b: &T)\n+                                            -> ExpectedFound<T>\n+    where R: TypeRelation<'a, 'gcx, 'tcx>, T: Clone, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n     expected_found_bool(relation.a_is_expected(), a, b)\n }"}, {"sha": "77e980ff3196520c05600cf42bcf5245c56c7e6e", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 336, "deletions": 107, "changes": 443, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use infer::type_variable;\n use ty::subst::{self, VecPerParamSpace};\n-use traits;\n use ty::{self, Lift, TraitRef, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n@@ -24,14 +24,34 @@ use hir;\n \n impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>> Lift<'tcx> for (A, B) {\n     type Lifted = (A::Lifted, B::Lifted);\n-    fn lift_to_tcx(&self, tcx: &TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.0).and_then(|a| tcx.lift(&self.1).map(|b| (a, b)))\n     }\n }\n \n+impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Option<T> {\n+    type Lifted = Option<T::Lifted>;\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            Some(ref x) => tcx.lift(x).map(Some),\n+            None => Some(None)\n+        }\n+    }\n+}\n+\n+impl<'tcx, T: Lift<'tcx>, E: Lift<'tcx>> Lift<'tcx> for Result<T, E> {\n+    type Lifted = Result<T::Lifted, E::Lifted>;\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            Ok(ref x) => tcx.lift(x).map(Ok),\n+            Err(ref e) => tcx.lift(e).map(Err)\n+        }\n+    }\n+}\n+\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for [T] {\n     type Lifted = Vec<T::Lifted>;\n-    fn lift_to_tcx(&self, tcx: &TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         // type annotation needed to inform `projection_must_outlive`\n         let mut result : Vec<<T as Lift<'tcx>>::Lifted>\n             = Vec::with_capacity(self.len());\n@@ -46,16 +66,23 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for [T] {\n     }\n }\n \n+impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Vec<T> {\n+    type Lifted = Vec<T::Lifted>;\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self[..])\n+    }\n+}\n+\n impl<'tcx> Lift<'tcx> for ty::Region {\n     type Lifted = Self;\n-    fn lift_to_tcx(&self, _: &TyCtxt<'tcx>) -> Option<ty::Region> {\n+    fn lift_to_tcx(&self, _: TyCtxt) -> Option<ty::Region> {\n         Some(*self)\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for TraitRef<'a> {\n     type Lifted = TraitRef<'tcx>;\n-    fn lift_to_tcx(&self, tcx: &TyCtxt<'tcx>) -> Option<TraitRef<'tcx>> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<TraitRef<'tcx>> {\n         tcx.lift(&self.substs).map(|substs| TraitRef {\n             def_id: self.def_id,\n             substs: substs\n@@ -65,7 +92,8 @@ impl<'a, 'tcx> Lift<'tcx> for TraitRef<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n     type Lifted = ty::TraitPredicate<'tcx>;\n-    fn lift_to_tcx(&self, tcx: &TyCtxt<'tcx>) -> Option<ty::TraitPredicate<'tcx>> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n+                             -> Option<ty::TraitPredicate<'tcx>> {\n         tcx.lift(&self.trait_ref).map(|trait_ref| ty::TraitPredicate {\n             trait_ref: trait_ref\n         })\n@@ -74,21 +102,23 @@ impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::EquatePredicate<'a> {\n     type Lifted = ty::EquatePredicate<'tcx>;\n-    fn lift_to_tcx(&self, tcx: &TyCtxt<'tcx>) -> Option<ty::EquatePredicate<'tcx>> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n+                             -> Option<ty::EquatePredicate<'tcx>> {\n         tcx.lift(&(self.0, self.1)).map(|(a, b)| ty::EquatePredicate(a, b))\n     }\n }\n \n impl<'tcx, A: Copy+Lift<'tcx>, B: Copy+Lift<'tcx>> Lift<'tcx> for ty::OutlivesPredicate<A, B> {\n     type Lifted = ty::OutlivesPredicate<A::Lifted, B::Lifted>;\n-    fn lift_to_tcx(&self, tcx: &TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&(self.0, self.1)).map(|(a, b)| ty::OutlivesPredicate(a, b))\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n     type Lifted = ty::ProjectionPredicate<'tcx>;\n-    fn lift_to_tcx(&self, tcx: &TyCtxt<'tcx>) -> Option<ty::ProjectionPredicate<'tcx>> {\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n+                             -> Option<ty::ProjectionPredicate<'tcx>> {\n         tcx.lift(&(self.projection_ty.trait_ref, self.ty)).map(|(trait_ref, ty)| {\n             ty::ProjectionPredicate {\n                 projection_ty: ty::ProjectionTy {\n@@ -101,13 +131,196 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ty::Predicate<'a> {\n+    type Lifted = ty::Predicate<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            ty::Predicate::Trait(ref binder) => {\n+                tcx.lift(binder).map(ty::Predicate::Trait)\n+            }\n+            ty::Predicate::Equate(ref binder) => {\n+                tcx.lift(binder).map(ty::Predicate::Equate)\n+            }\n+            ty::Predicate::RegionOutlives(ref binder) => {\n+                tcx.lift(binder).map(ty::Predicate::RegionOutlives)\n+            }\n+            ty::Predicate::TypeOutlives(ref binder) => {\n+                tcx.lift(binder).map(ty::Predicate::TypeOutlives)\n+            }\n+            ty::Predicate::Projection(ref binder) => {\n+                tcx.lift(binder).map(ty::Predicate::Projection)\n+            }\n+            ty::Predicate::WellFormed(ty) => {\n+                tcx.lift(&ty).map(ty::Predicate::WellFormed)\n+            }\n+            ty::Predicate::Rfc1592(box ref a) => {\n+                tcx.lift(a).map(|a| ty::Predicate::Rfc1592(Box::new(a)))\n+            }\n+            ty::Predicate::ClosureKind(closure_def_id, kind) => {\n+                Some(ty::Predicate::ClosureKind(closure_def_id, kind))\n+            }\n+            ty::Predicate::ObjectSafe(trait_def_id) => {\n+                Some(ty::Predicate::ObjectSafe(trait_def_id))\n+            }\n+        }\n+    }\n+}\n+\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n     type Lifted = ty::Binder<T::Lifted>;\n-    fn lift_to_tcx(&self, tcx: &TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.0).map(|x| ty::Binder(x))\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ty::ClosureSubsts<'a> {\n+    type Lifted = ty::ClosureSubsts<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&(self.func_substs, self.upvar_tys)).map(|(substs, upvar_tys)| {\n+            ty::ClosureSubsts {\n+                func_substs: substs,\n+                upvar_tys: upvar_tys\n+            }\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::ItemSubsts<'a> {\n+    type Lifted = ty::ItemSubsts<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.substs).map(|substs| {\n+            ty::ItemSubsts {\n+                substs: substs\n+            }\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoRef<'a> {\n+    type Lifted = ty::adjustment::AutoRef<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            ty::adjustment::AutoPtr(r, m) => {\n+                tcx.lift(&r).map(|r| ty::adjustment::AutoPtr(r, m))\n+            }\n+            ty::adjustment::AutoUnsafe(m) => {\n+                Some(ty::adjustment::AutoUnsafe(m))\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::FnOutput<'a> {\n+    type Lifted = ty::FnOutput<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            ty::FnConverging(ty) => {\n+                tcx.lift(&ty).map(ty::FnConverging)\n+            }\n+            ty::FnDiverging => Some(ty::FnDiverging)\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::FnSig<'a> {\n+    type Lifted = ty::FnSig<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.inputs[..]).and_then(|inputs| {\n+            tcx.lift(&self.output).map(|output| {\n+                ty::FnSig {\n+                    inputs: inputs,\n+                    output: output,\n+                    variadic: self.variadic\n+                }\n+            })\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::ClosureTy<'a> {\n+    type Lifted = ty::ClosureTy<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.sig).map(|sig| {\n+            ty::ClosureTy {\n+                sig: sig,\n+                unsafety: self.unsafety,\n+                abi: self.abi\n+            }\n+        })\n+    }\n+}\n+\n+impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::error::ExpectedFound<T> {\n+    type Lifted = ty::error::ExpectedFound<T::Lifted>;\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.expected).and_then(|expected| {\n+            tcx.lift(&self.found).map(|found| {\n+                ty::error::ExpectedFound {\n+                    expected: expected,\n+                    found: found\n+                }\n+            })\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for type_variable::Default<'a> {\n+    type Lifted = type_variable::Default<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.ty).map(|ty| {\n+            type_variable::Default {\n+                ty: ty,\n+                origin_span: self.origin_span,\n+                def_id: self.def_id\n+            }\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n+    type Lifted = ty::error::TypeError<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        use ty::error::TypeError::*;\n+\n+        Some(match *self {\n+            Mismatch => Mismatch,\n+            UnsafetyMismatch(x) => UnsafetyMismatch(x),\n+            AbiMismatch(x) => AbiMismatch(x),\n+            Mutability => Mutability,\n+            BoxMutability => BoxMutability,\n+            PtrMutability => PtrMutability,\n+            RefMutability => RefMutability,\n+            VecMutability => VecMutability,\n+            TupleSize(x) => TupleSize(x),\n+            FixedArraySize(x) => FixedArraySize(x),\n+            TyParamSize(x) => TyParamSize(x),\n+            ArgCount => ArgCount,\n+            RegionsDoesNotOutlive(a, b) => RegionsDoesNotOutlive(a, b),\n+            RegionsNotSame(a, b) => RegionsNotSame(a, b),\n+            RegionsNoOverlap(a, b) => RegionsNoOverlap(a, b),\n+            RegionsInsufficientlyPolymorphic(a, b) => {\n+                RegionsInsufficientlyPolymorphic(a, b)\n+            }\n+            RegionsOverlyPolymorphic(a, b) => RegionsOverlyPolymorphic(a, b),\n+            IntegerAsChar => IntegerAsChar,\n+            IntMismatch(x) => IntMismatch(x),\n+            FloatMismatch(x) => FloatMismatch(x),\n+            Traits(x) => Traits(x),\n+            BuiltinBoundsMismatch(x) => BuiltinBoundsMismatch(x),\n+            VariadicMismatch(x) => VariadicMismatch(x),\n+            CyclicTy => CyclicTy,\n+            ConvergenceMismatch(x) => ConvergenceMismatch(x),\n+            ProjectionNameMismatched(x) => ProjectionNameMismatched(x),\n+            ProjectionBoundsLength(x) => ProjectionBoundsLength(x),\n+\n+            Sorts(ref x) => return tcx.lift(x).map(Sorts),\n+            TyParamDefaultMismatch(ref x) => {\n+                return tcx.lift(x).map(TyParamDefaultMismatch)\n+            }\n+        })\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // TypeFoldable implementations.\n //\n@@ -123,7 +336,7 @@ macro_rules! CopyImpls {\n     ($($ty:ty),+) => {\n         $(\n             impl<'tcx> TypeFoldable<'tcx> for $ty {\n-                fn super_fold_with<F:TypeFolder<'tcx>>(&self, _: &mut F) -> $ty {\n+                fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _: &mut F) -> $ty {\n                     *self\n                 }\n \n@@ -138,7 +351,7 @@ macro_rules! CopyImpls {\n CopyImpls! { (), hir::Unsafety, abi::Abi }\n \n impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> (T, U) {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> (T, U) {\n         (self.0.fold_with(folder), self.1.fold_with(folder))\n     }\n \n@@ -148,7 +361,7 @@ impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Option<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         self.as_ref().map(|t| t.fold_with(folder))\n     }\n \n@@ -158,7 +371,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Option<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         Rc::new((**self).fold_with(folder))\n     }\n \n@@ -168,7 +381,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let content: T = (**self).fold_with(folder);\n         box content\n     }\n@@ -179,7 +392,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         self.iter().map(|t| t.fold_with(folder)).collect()\n     }\n \n@@ -189,11 +402,11 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n }\n \n impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::Binder(self.0.fold_with(folder))\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_binder(self)\n     }\n \n@@ -207,7 +420,7 @@ impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for P<[T]> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         self.iter().map(|t| t.fold_with(folder)).collect()\n     }\n \n@@ -217,7 +430,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for P<[T]> {\n }\n \n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for VecPerParamSpace<T> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         self.map(|elem| elem.fold_with(folder))\n     }\n \n@@ -227,7 +440,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for VecPerParamSpace<T> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::TraitTy<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::TraitTy {\n             principal: self.principal.fold_with(folder),\n             bounds: self.bounds.fold_with(folder),\n@@ -239,41 +452,38 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TraitTy<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for &'tcx [Ty<'tcx>] {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        let tys = self.iter().map(|t| t.fold_with(folder)).collect();\n+        folder.tcx().mk_type_list(tys)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.iter().any(|t| t.visit_with(visitor))\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let sty = match self.sty {\n             ty::TyBox(typ) => ty::TyBox(typ.fold_with(folder)),\n-            ty::TyRawPtr(ref tm) => ty::TyRawPtr(tm.fold_with(folder)),\n+            ty::TyRawPtr(tm) => ty::TyRawPtr(tm.fold_with(folder)),\n             ty::TyArray(typ, sz) => ty::TyArray(typ.fold_with(folder), sz),\n             ty::TySlice(typ) => ty::TySlice(typ.fold_with(folder)),\n-            ty::TyEnum(tid, ref substs) => {\n-                let substs = substs.fold_with(folder);\n-                ty::TyEnum(tid, folder.tcx().mk_substs(substs))\n-            }\n+            ty::TyEnum(tid, substs) => ty::TyEnum(tid, substs.fold_with(folder)),\n             ty::TyTrait(ref trait_ty) => ty::TyTrait(trait_ty.fold_with(folder)),\n-            ty::TyTuple(ref ts) => ty::TyTuple(ts.fold_with(folder)),\n-            ty::TyFnDef(def_id, substs, ref f) => {\n-                let substs = substs.fold_with(folder);\n-                let bfn = f.fold_with(folder);\n+            ty::TyTuple(ts) => ty::TyTuple(ts.fold_with(folder)),\n+            ty::TyFnDef(def_id, substs, f) => {\n                 ty::TyFnDef(def_id,\n-                            folder.tcx().mk_substs(substs),\n-                            folder.tcx().mk_bare_fn(bfn))\n-            }\n-            ty::TyFnPtr(ref f) => {\n-                let bfn = f.fold_with(folder);\n-                ty::TyFnPtr(folder.tcx().mk_bare_fn(bfn))\n-            }\n-            ty::TyRef(r, ref tm) => {\n-                let r = r.fold_with(folder);\n-                ty::TyRef(folder.tcx().mk_region(r), tm.fold_with(folder))\n-            }\n-            ty::TyStruct(did, ref substs) => {\n-                let substs = substs.fold_with(folder);\n-                ty::TyStruct(did, folder.tcx().mk_substs(substs))\n+                            substs.fold_with(folder),\n+                            f.fold_with(folder))\n             }\n-            ty::TyClosure(did, ref substs) => {\n-                ty::TyClosure(did, substs.fold_with(folder))\n+            ty::TyFnPtr(f) => ty::TyFnPtr(f.fold_with(folder)),\n+            ty::TyRef(ref r, tm) => {\n+                ty::TyRef(r.fold_with(folder), tm.fold_with(folder))\n             }\n+            ty::TyStruct(did, substs) => ty::TyStruct(did, substs.fold_with(folder)),\n+            ty::TyClosure(did, substs) => ty::TyClosure(did, substs.fold_with(folder)),\n             ty::TyProjection(ref data) => ty::TyProjection(data.fold_with(folder)),\n             ty::TyBool | ty::TyChar | ty::TyStr | ty::TyInt(_) |\n             ty::TyUint(_) | ty::TyFloat(_) | ty::TyError | ty::TyInfer(_) |\n@@ -282,7 +492,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n         folder.tcx().mk_ty(sty)\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_ty(*self)\n     }\n \n@@ -294,7 +504,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TySlice(typ) => typ.visit_with(visitor),\n             ty::TyEnum(_tid, ref substs) => substs.visit_with(visitor),\n             ty::TyTrait(ref trait_ty) => trait_ty.visit_with(visitor),\n-            ty::TyTuple(ref ts) => ts.visit_with(visitor),\n+            ty::TyTuple(ts) => ts.visit_with(visitor),\n             ty::TyFnDef(_, substs, ref f) => {\n                 substs.visit_with(visitor) || f.visit_with(visitor)\n             }\n@@ -314,14 +524,17 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::BareFnTy<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::BareFnTy { sig: self.sig.fold_with(folder),\n-                       abi: self.abi,\n-                       unsafety: self.unsafety }\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::BareFnTy<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        let fty = ty::BareFnTy {\n+            sig: self.sig.fold_with(folder),\n+            abi: self.abi,\n+            unsafety: self.unsafety\n+        };\n+        folder.tcx().mk_bare_fn(fty)\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_bare_fn_ty(self)\n     }\n \n@@ -331,15 +544,15 @@ impl<'tcx> TypeFoldable<'tcx> for ty::BareFnTy<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ClosureTy<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n        ty::ClosureTy {\n             sig: self.sig.fold_with(folder),\n             unsafety: self.unsafety,\n             abi: self.abi,\n         }\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_closure_ty(self)\n     }\n \n@@ -349,11 +562,11 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ClosureTy<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::TypeAndMut<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::TypeAndMut { ty: self.ty.fold_with(folder), mutbl: self.mutbl }\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_mt(self)\n     }\n \n@@ -363,14 +576,14 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeAndMut<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::FnOutput<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n             ty::FnConverging(ref ty) => ty::FnConverging(ty.fold_with(folder)),\n             ty::FnDiverging => ty::FnDiverging\n         }\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_output(self)\n     }\n \n@@ -383,13 +596,13 @@ impl<'tcx> TypeFoldable<'tcx> for ty::FnOutput<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::FnSig { inputs: self.inputs.fold_with(folder),\n                     output: self.output.fold_with(folder),\n                     variadic: self.variadic }\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_fn_sig(self)\n     }\n \n@@ -399,15 +612,14 @@ impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let substs = self.substs.fold_with(folder);\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::TraitRef {\n             def_id: self.def_id,\n-            substs: folder.tcx().mk_substs(substs),\n+            substs: self.substs.fold_with(folder),\n         }\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_trait_ref(self)\n     }\n \n@@ -417,7 +629,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ImplHeader<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::ImplHeader {\n             impl_def_id: self.impl_def_id,\n             self_ty: self.self_ty.fold_with(folder),\n@@ -426,7 +638,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ImplHeader<'tcx> {\n         }\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_impl_header(self)\n     }\n \n@@ -438,11 +650,11 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ImplHeader<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Region {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n         *self\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_region(*self)\n     }\n \n@@ -455,13 +667,35 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Region {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for subst::Substs<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        subst::Substs { regions: self.regions.fold_with(folder),\n-                        types: self.types.fold_with(folder) }\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Region {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n+        *self\n+    }\n+\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        let region = folder.fold_region(**self);\n+        folder.tcx().mk_region(region)\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> bool {\n+        false\n+    }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        visitor.visit_region(**self)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx subst::Substs<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        let substs = subst::Substs {\n+            regions: self.regions.fold_with(folder),\n+            types: self.types.fold_with(folder)\n+        };\n+        folder.tcx().mk_substs(substs)\n+    }\n+\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_substs(self)\n     }\n \n@@ -471,10 +705,9 @@ impl<'tcx> TypeFoldable<'tcx> for subst::Substs<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let func_substs = self.func_substs.fold_with(folder);\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::ClosureSubsts {\n-            func_substs: folder.tcx().mk_substs(func_substs),\n+            func_substs: self.func_substs.fold_with(folder),\n             upvar_tys: self.upvar_tys.fold_with(folder),\n         }\n     }\n@@ -485,7 +718,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ItemSubsts<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::ItemSubsts {\n             substs: self.substs.fold_with(folder),\n         }\n@@ -497,17 +730,16 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ItemSubsts<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoRef<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n-            ty::adjustment::AutoPtr(r, m) => {\n-                let r = r.fold_with(folder);\n-                ty::adjustment::AutoPtr(folder.tcx().mk_region(r), m)\n+            ty::adjustment::AutoPtr(ref r, m) => {\n+                ty::adjustment::AutoPtr(r.fold_with(folder), m)\n             }\n             ty::adjustment::AutoUnsafe(m) => ty::adjustment::AutoUnsafe(m)\n         }\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_autoref(self)\n     }\n \n@@ -520,7 +752,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoRef<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::BuiltinBounds {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n         *self\n     }\n \n@@ -530,15 +762,15 @@ impl<'tcx> TypeFoldable<'tcx> for ty::BuiltinBounds {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialBounds<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::ExistentialBounds {\n             region_bound: self.region_bound.fold_with(folder),\n             builtin_bounds: self.builtin_bounds,\n             projection_bounds: self.projection_bounds.fold_with(folder),\n         }\n     }\n \n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_existential_bounds(self)\n     }\n \n@@ -548,7 +780,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialBounds<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::TypeParameterDef {\n             name: self.name,\n             def_id: self.def_id,\n@@ -567,7 +799,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ObjectLifetimeDefault {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n             ty::ObjectLifetimeDefault::Ambiguous =>\n                 ty::ObjectLifetimeDefault::Ambiguous,\n@@ -589,7 +821,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ObjectLifetimeDefault {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::RegionParameterDef {\n             name: self.name,\n             def_id: self.def_id,\n@@ -605,7 +837,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Generics<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::Generics {\n             types: self.types.fold_with(folder),\n             regions: self.regions.fold_with(folder),\n@@ -618,7 +850,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Generics<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::GenericPredicates {\n             predicates: self.predicates.fold_with(folder),\n         }\n@@ -630,7 +862,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n             ty::Predicate::Trait(ref a) =>\n                 ty::Predicate::Trait(a.fold_with(folder)),\n@@ -669,7 +901,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionPredicate<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::ProjectionPredicate {\n             projection_ty: self.projection_ty.fold_with(folder),\n             ty: self.ty.fold_with(folder),\n@@ -682,7 +914,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionPredicate<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionTy<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::ProjectionTy {\n             trait_ref: self.trait_ref.fold_with(folder),\n             item_name: self.item_name,\n@@ -695,7 +927,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionTy<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::InstantiatedPredicates<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::InstantiatedPredicates {\n             predicates: self.predicates.fold_with(folder),\n         }\n@@ -707,7 +939,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::InstantiatedPredicates<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::EquatePredicate<'tcx> {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::EquatePredicate(self.0.fold_with(folder),\n                             self.1.fold_with(folder))\n     }\n@@ -718,7 +950,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::EquatePredicate<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::TraitPredicate<'tcx> {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::TraitPredicate {\n             trait_ref: self.trait_ref.fold_with(folder)\n         }\n@@ -733,7 +965,7 @@ impl<'tcx,T,U> TypeFoldable<'tcx> for ty::OutlivesPredicate<T,U>\n     where T : TypeFoldable<'tcx>,\n           U : TypeFoldable<'tcx>,\n {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::OutlivesPredicate(self.0.fold_with(folder),\n                               self.1.fold_with(folder))\n     }\n@@ -744,7 +976,7 @@ impl<'tcx,T,U> TypeFoldable<'tcx> for ty::OutlivesPredicate<T,U>\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ClosureUpvar<'tcx> {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::ClosureUpvar {\n             def: self.def,\n             span: self.span,\n@@ -757,15 +989,12 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ClosureUpvar<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeFoldable<'tcx> for ty::ParameterEnvironment<'a, 'tcx> where 'tcx: 'a {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+impl<'tcx> TypeFoldable<'tcx> for ty::ParameterEnvironment<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::ParameterEnvironment {\n-            tcx: self.tcx,\n             free_substs: self.free_substs.fold_with(folder),\n             implicit_region_bound: self.implicit_region_bound.fold_with(folder),\n             caller_bounds: self.caller_bounds.fold_with(folder),\n-            selection_cache: traits::SelectionCache::new(),\n-            evaluation_cache: traits::EvaluationCache::new(),\n             free_id_outlive: self.free_id_outlive,\n         }\n     }\n@@ -778,7 +1007,7 @@ impl<'a, 'tcx> TypeFoldable<'tcx> for ty::ParameterEnvironment<'a, 'tcx> where '\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::TypeScheme<'tcx>  {\n-    fn super_fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::TypeScheme {\n             generics: self.generics.fold_with(folder),\n             ty: self.ty.fold_with(folder),"}, {"sha": "32434d40e61a9d4ece268d69dcc99162bb41f16b", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 41, "deletions": 45, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -14,7 +14,6 @@ use middle::cstore;\n use hir::def_id::DefId;\n use middle::region;\n use ty::subst::{self, Substs};\n-use traits;\n use ty::{self, AdtDef, ToPredicate, TypeFlags, Ty, TyCtxt, TyS, TypeFoldable};\n use util::common::ErrorReported;\n \n@@ -26,7 +25,7 @@ use syntax::abi;\n use syntax::ast::{self, Name};\n use syntax::parse::token::keywords;\n \n-use serialize::{Decodable, Decoder};\n+use serialize::{Decodable, Decoder, Encodable, Encoder};\n \n use hir;\n \n@@ -94,10 +93,8 @@ pub enum TypeVariants<'tcx> {\n     /// Substs here, possibly against intuition, *may* contain `TyParam`s.\n     /// That is, even after substitution it is possible that there are type\n     /// variables. This happens when the `TyEnum` corresponds to an enum\n-    /// definition and not a concrete use of it. To get the correct `TyEnum`\n-    /// from the tcx, use the `NodeId` from the `ast::Ty` and look it up in\n-    /// the `ast_ty_to_ty_cache`. This is probably true for `TyStruct` as\n-    /// well.\n+    /// definition and not a concrete use of it. This is true for `TyStruct`\n+    /// as well.\n     TyEnum(AdtDef<'tcx>, &'tcx Substs<'tcx>),\n \n     /// A structure type, defined with `struct`.\n@@ -141,10 +138,10 @@ pub enum TypeVariants<'tcx> {\n \n     /// The anonymous type of a closure. Used to represent the type of\n     /// `|a| a`.\n-    TyClosure(DefId, Box<ClosureSubsts<'tcx>>),\n+    TyClosure(DefId, ClosureSubsts<'tcx>),\n \n     /// A tuple type.  For example, `(i32, bool)`.\n-    TyTuple(Vec<Ty<'tcx>>),\n+    TyTuple(&'tcx [Ty<'tcx>]),\n \n     /// The projection of an associated type.  For example,\n     /// `<T as Trait<..>>::N`.\n@@ -235,7 +232,7 @@ pub enum TypeVariants<'tcx> {\n /// closure C wind up influencing the decisions we ought to make for\n /// closure C (which would then require fixed point iteration to\n /// handle). Plus it fixes an ICE. :P\n-#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct ClosureSubsts<'tcx> {\n     /// Lifetime and type parameters from the enclosing function.\n     /// These are separated out because trans wants to pass them around\n@@ -245,22 +242,23 @@ pub struct ClosureSubsts<'tcx> {\n     /// The types of the upvars. The list parallels the freevars and\n     /// `upvar_borrows` lists. These are kept distinct so that we can\n     /// easily index into them.\n-    pub upvar_tys: Vec<Ty<'tcx>>\n+    pub upvar_tys: &'tcx [Ty<'tcx>]\n }\n \n-impl<'tcx> Decodable for &'tcx ClosureSubsts<'tcx> {\n-    fn decode<S: Decoder>(s: &mut S) -> Result<&'tcx ClosureSubsts<'tcx>, S::Error> {\n-        let closure_substs = Decodable::decode(s)?;\n-        let dummy_def_id: DefId = unsafe { mem::zeroed() };\n-\n-        cstore::tls::with_decoding_context(s, |dcx, _| {\n-            // Intern the value\n-            let ty = dcx.tcx().mk_closure_from_closure_substs(dummy_def_id,\n-                                                              Box::new(closure_substs));\n-            match ty.sty {\n-                TyClosure(_, ref closure_substs) => Ok(&**closure_substs),\n-                _ => bug!()\n-            }\n+impl<'tcx> Encodable for ClosureSubsts<'tcx> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        (self.func_substs, self.upvar_tys).encode(s)\n+    }\n+}\n+\n+impl<'tcx> Decodable for ClosureSubsts<'tcx> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<ClosureSubsts<'tcx>, D::Error> {\n+        let (func_substs, upvar_tys) = Decodable::decode(d)?;\n+        cstore::tls::with_decoding_context(d, |dcx, _| {\n+            Ok(ClosureSubsts {\n+                func_substs: func_substs,\n+                upvar_tys: dcx.tcx().mk_type_list(upvar_tys)\n+            })\n         })\n     }\n }\n@@ -271,7 +269,7 @@ pub struct TraitTy<'tcx> {\n     pub bounds: ExistentialBounds<'tcx>,\n }\n \n-impl<'tcx> TraitTy<'tcx> {\n+impl<'a, 'gcx, 'tcx> TraitTy<'tcx> {\n     pub fn principal_def_id(&self) -> DefId {\n         self.principal.0.def_id\n     }\n@@ -280,8 +278,7 @@ impl<'tcx> TraitTy<'tcx> {\n     /// we convert the principal trait-ref into a normal trait-ref,\n     /// you must give *some* self-type. A common choice is `mk_err()`\n     /// or some skolemized type.\n-    pub fn principal_trait_ref_with_self_ty(&self,\n-                                            tcx: &TyCtxt<'tcx>,\n+    pub fn principal_trait_ref_with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                             self_ty: Ty<'tcx>)\n                                             -> ty::PolyTraitRef<'tcx>\n     {\n@@ -294,8 +291,7 @@ impl<'tcx> TraitTy<'tcx> {\n         })\n     }\n \n-    pub fn projection_bounds_with_self_ty(&self,\n-                                          tcx: &TyCtxt<'tcx>,\n+    pub fn projection_bounds_with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                           self_ty: Ty<'tcx>)\n                                           -> Vec<ty::PolyProjectionPredicate<'tcx>>\n     {\n@@ -524,7 +520,7 @@ pub struct ParamTy {\n     pub name: Name,\n }\n \n-impl ParamTy {\n+impl<'a, 'gcx, 'tcx> ParamTy {\n     pub fn new(space: subst::ParamSpace,\n                index: u32,\n                name: Name)\n@@ -540,7 +536,7 @@ impl ParamTy {\n         ParamTy::new(def.space, def.index, def.name)\n     }\n \n-    pub fn to_ty<'tcx>(self, tcx: &TyCtxt<'tcx>) -> Ty<'tcx> {\n+    pub fn to_ty(self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         tcx.mk_param(self.space, self.idx, self.name)\n     }\n \n@@ -633,7 +629,7 @@ pub struct DebruijnIndex {\n /// to be used. These also support explicit bounds: both the internally-stored\n /// *scope*, which the region is assumed to outlive, as well as other\n /// relations stored in the `FreeRegionMap`. Note that these relations\n-/// aren't checked when you `make_subregion` (or `mk_eqty`), only by\n+/// aren't checked when you `make_subregion` (or `eq_types`), only by\n /// `resolve_regions_and_report_errors`.\n ///\n /// When working with higher-ranked types, some region relations aren't\n@@ -765,7 +761,7 @@ impl<'tcx> ExistentialBounds<'tcx> {\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub struct BuiltinBounds(EnumSet<BuiltinBound>);\n \n-impl BuiltinBounds {\n+impl<'a, 'gcx, 'tcx> BuiltinBounds {\n     pub fn empty() -> BuiltinBounds {\n         BuiltinBounds(EnumSet::new())\n     }\n@@ -774,11 +770,11 @@ impl BuiltinBounds {\n         self.into_iter()\n     }\n \n-    pub fn to_predicates<'tcx>(&self,\n-                               tcx: &TyCtxt<'tcx>,\n-                               self_ty: Ty<'tcx>) -> Vec<ty::Predicate<'tcx>> {\n+    pub fn to_predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                         self_ty: Ty<'tcx>)\n+                         -> Vec<ty::Predicate<'tcx>> {\n         self.iter().filter_map(|builtin_bound|\n-            match traits::trait_ref_for_builtin_bound(tcx, builtin_bound, self_ty) {\n+            match tcx.trait_ref_for_builtin_bound(builtin_bound, self_ty) {\n                 Ok(trait_ref) => Some(trait_ref.to_predicate()),\n                 Err(ErrorReported) => { None }\n             }\n@@ -822,8 +818,8 @@ impl CLike for BuiltinBound {\n     }\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn try_add_builtin_trait(&self,\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    pub fn try_add_builtin_trait(self,\n                                  trait_def_id: DefId,\n                                  builtin_bounds: &mut EnumSet<BuiltinBound>)\n                                  -> bool\n@@ -887,7 +883,7 @@ impl Region {\n }\n \n // Type utilities\n-impl<'tcx> TyS<'tcx> {\n+impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     pub fn as_opt_param_ty(&self) -> Option<ty::ParamTy> {\n         match self.sty {\n             ty::TyParam(ref d) => Some(d.clone()),\n@@ -902,7 +898,7 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn is_empty(&self, _cx: &TyCtxt) -> bool {\n+    pub fn is_empty(&self, _cx: TyCtxt) -> bool {\n         // FIXME(#24885): be smarter here\n         match self.sty {\n             TyEnum(def, _) | TyStruct(def, _) => def.is_empty(),\n@@ -974,24 +970,24 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn sequence_element_type(&self, cx: &TyCtxt<'tcx>) -> Ty<'tcx> {\n+    pub fn sequence_element_type(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match self.sty {\n             TyArray(ty, _) | TySlice(ty) => ty,\n-            TyStr => cx.mk_mach_uint(ast::UintTy::U8),\n+            TyStr => tcx.mk_mach_uint(ast::UintTy::U8),\n             _ => bug!(\"sequence_element_type called on non-sequence value: {}\", self),\n         }\n     }\n \n-    pub fn simd_type(&self, cx: &TyCtxt<'tcx>) -> Ty<'tcx> {\n+    pub fn simd_type(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match self.sty {\n             TyStruct(def, substs) => {\n-                def.struct_variant().fields[0].ty(cx, substs)\n+                def.struct_variant().fields[0].ty(tcx, substs)\n             }\n             _ => bug!(\"simd_type called on invalid type\")\n         }\n     }\n \n-    pub fn simd_size(&self, _cx: &TyCtxt) -> usize {\n+    pub fn simd_size(&self, _cx: TyCtxt) -> usize {\n         match self.sty {\n             TyStruct(def, _) => def.struct_variant().fields.len(),\n             _ => bug!(\"simd_size called on invalid type\")"}, {"sha": "9aec6b35997780bfbf3a4685307ddec30e212d1a", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -36,7 +36,7 @@ pub struct Substs<'tcx> {\n     pub regions: VecPerParamSpace<ty::Region>,\n }\n \n-impl<'tcx> Substs<'tcx> {\n+impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     pub fn new(t: VecPerParamSpace<Ty<'tcx>>,\n                r: VecPerParamSpace<ty::Region>)\n                -> Substs<'tcx>\n@@ -114,15 +114,15 @@ impl<'tcx> Substs<'tcx> {\n         Substs { types: types, regions: regions }\n     }\n \n-    pub fn with_method_from_subst(self, other: &Substs<'tcx>) -> Substs<'tcx> {\n-        let Substs { types, regions } = self;\n+    pub fn with_method_from_subst(&self, other: &Substs<'tcx>) -> Substs<'tcx> {\n+        let Substs { types, regions } = self.clone();\n         let types = types.with_slice(FnSpace, other.types.get_slice(FnSpace));\n         let regions = regions.with_slice(FnSpace, other.regions.get_slice(FnSpace));\n         Substs { types: types, regions: regions }\n     }\n \n     /// Creates a trait-ref out of this substs, ignoring the FnSpace substs\n-    pub fn to_trait_ref(&self, tcx: &TyCtxt<'tcx>, trait_id: DefId)\n+    pub fn to_trait_ref(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, trait_id: DefId)\n                         -> ty::TraitRef<'tcx> {\n         let Substs { mut types, mut regions } = self.clone();\n         types.truncate(FnSpace, 0);\n@@ -532,22 +532,22 @@ impl<'a,T> IntoIterator for &'a VecPerParamSpace<T> {\n // there is more information available (for better errors).\n \n pub trait Subst<'tcx> : Sized {\n-    fn subst(&self, tcx: &TyCtxt<'tcx>, substs: &Substs<'tcx>) -> Self {\n+    fn subst<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                      substs: &Substs<'tcx>) -> Self {\n         self.subst_spanned(tcx, substs, None)\n     }\n \n-    fn subst_spanned(&self, tcx: &TyCtxt<'tcx>,\n-                     substs: &Substs<'tcx>,\n-                     span: Option<Span>)\n-                     -> Self;\n+    fn subst_spanned<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                               substs: &Substs<'tcx>,\n+                               span: Option<Span>)\n+                               -> Self;\n }\n \n impl<'tcx, T:TypeFoldable<'tcx>> Subst<'tcx> for T {\n-    fn subst_spanned(&self,\n-                     tcx: &TyCtxt<'tcx>,\n-                     substs: &Substs<'tcx>,\n-                     span: Option<Span>)\n-                     -> T\n+    fn subst_spanned<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                               substs: &Substs<'tcx>,\n+                               span: Option<Span>)\n+                               -> T\n     {\n         let mut folder = SubstFolder { tcx: tcx,\n                                        substs: substs,\n@@ -562,8 +562,8 @@ impl<'tcx, T:TypeFoldable<'tcx>> Subst<'tcx> for T {\n ///////////////////////////////////////////////////////////////////////////\n // The actual substitution engine itself is a type folder.\n \n-struct SubstFolder<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+struct SubstFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     substs: &'a Substs<'tcx>,\n \n     // The location for which the substitution is performed, if available.\n@@ -579,8 +579,8 @@ struct SubstFolder<'a, 'tcx: 'a> {\n     region_binders_passed: u32,\n }\n \n-impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n-    fn tcx(&self) -> &TyCtxt<'tcx> { self.tcx }\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.region_binders_passed += 1;\n@@ -650,7 +650,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n     }\n }\n \n-impl<'a,'tcx> SubstFolder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n     fn ty_for_param(&self, p: ty::ParamTy, source_ty: Ty<'tcx>) -> Ty<'tcx> {\n         // Look up the type in the substitutions. It really should be in there.\n         let opt_ty = self.substs.types.opt_get(p.space, p.idx as usize);"}, {"sha": "a76dfc35dc1d3897ed10589c949d19ea20a57fa5", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -73,7 +73,7 @@ pub struct TraitDef<'tcx> {\n     pub flags: Cell<TraitFlags>\n }\n \n-impl<'tcx> TraitDef<'tcx> {\n+impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n     pub fn new(unsafety: hir::Unsafety,\n                paren_sugar: bool,\n                generics: ty::Generics<'tcx>,\n@@ -117,19 +117,18 @@ impl<'tcx> TraitDef<'tcx> {\n         );\n     }\n \n-    fn write_trait_impls(&self, tcx: &TyCtxt<'tcx>) {\n+    fn write_trait_impls(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) {\n         tcx.dep_graph.write(DepNode::TraitImpls(self.trait_ref.def_id));\n     }\n \n-    fn read_trait_impls(&self, tcx: &TyCtxt<'tcx>) {\n+    fn read_trait_impls(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) {\n         tcx.dep_graph.read(DepNode::TraitImpls(self.trait_ref.def_id));\n     }\n \n     /// Records a basic trait-to-implementation mapping.\n     ///\n     /// Returns `true` iff the impl has not previously been recorded.\n-    fn record_impl(&self,\n-                   tcx: &TyCtxt<'tcx>,\n+    fn record_impl(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                    impl_def_id: DefId,\n                    impl_trait_ref: TraitRef<'tcx>)\n                    -> bool {\n@@ -164,8 +163,7 @@ impl<'tcx> TraitDef<'tcx> {\n     }\n \n     /// Records a trait-to-implementation mapping for a crate-local impl.\n-    pub fn record_local_impl(&self,\n-                             tcx: &TyCtxt<'tcx>,\n+    pub fn record_local_impl(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                              impl_def_id: DefId,\n                              impl_trait_ref: TraitRef<'tcx>) {\n         assert!(impl_def_id.is_local());\n@@ -178,8 +176,7 @@ impl<'tcx> TraitDef<'tcx> {\n     /// The `parent_impl` is the immediately-less-specialized impl, or the\n     /// trait's def ID if the impl is not a specialization -- information that\n     /// should be pulled from the metadata.\n-    pub fn record_remote_impl(&self,\n-                              tcx: &TyCtxt<'tcx>,\n+    pub fn record_remote_impl(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                               impl_def_id: DefId,\n                               impl_trait_ref: TraitRef<'tcx>,\n                               parent_impl: DefId) {\n@@ -197,22 +194,22 @@ impl<'tcx> TraitDef<'tcx> {\n     /// Adds a local impl into the specialization graph, returning an error with\n     /// overlap information if the impl overlaps but does not specialize an\n     /// existing impl.\n-    pub fn add_impl_for_specialization<'a>(&self,\n-                                           tcx: &'a TyCtxt<'tcx>,\n-                                           impl_def_id: DefId)\n-                                           -> Result<(), traits::Overlap<'a, 'tcx>> {\n+    pub fn add_impl_for_specialization(&self,\n+                                       tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                       impl_def_id: DefId)\n+                                       -> Result<(), traits::OverlapError> {\n         assert!(impl_def_id.is_local());\n \n         self.specialization_graph.borrow_mut()\n             .insert(tcx, impl_def_id)\n     }\n \n-    pub fn ancestors<'a>(&'a self, of_impl: DefId) -> specialization_graph::Ancestors<'a, 'tcx> {\n+    pub fn ancestors(&'a self, of_impl: DefId) -> specialization_graph::Ancestors<'a, 'tcx> {\n         specialization_graph::ancestors(self, of_impl)\n     }\n \n-        pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: &TyCtxt<'tcx>, mut f: F)  {\n-            self.read_trait_impls(tcx);\n+    pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, mut f: F) {\n+        self.read_trait_impls(tcx);\n         tcx.populate_implementations_for_trait_if_necessary(self.trait_ref.def_id);\n \n         for &impl_def_id in self.blanket_impls.borrow().iter() {\n@@ -229,7 +226,7 @@ impl<'tcx> TraitDef<'tcx> {\n     /// Iterate over every impl that could possibly match the\n     /// self-type `self_ty`.\n     pub fn for_each_relevant_impl<F: FnMut(DefId)>(&self,\n-                                                   tcx: &TyCtxt<'tcx>,\n+                                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                                    self_ty: Ty<'tcx>,\n                                                    mut f: F)\n     {"}, {"sha": "08909861d3f68adcbd0af8574c13207bfdd1d097", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 118, "deletions": 119, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -13,7 +13,7 @@\n use hir::svh::Svh;\n use hir::def_id::DefId;\n use ty::subst;\n-use infer;\n+use infer::InferCtxt;\n use hir::pat_util;\n use traits::{self, ProjectionMode};\n use ty::{self, Ty, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n@@ -32,29 +32,30 @@ use syntax::codemap::Span;\n use hir;\n \n pub trait IntTypeExt {\n-    fn to_ty<'tcx>(&self, cx: &TyCtxt<'tcx>) -> Ty<'tcx>;\n-    fn disr_incr(&self, val: Disr) -> Option<Disr>;\n+    fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx>;\n+    fn disr_incr<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, val: Option<Disr>)\n+                           -> Option<Disr>;\n     fn assert_ty_matches(&self, val: Disr);\n-    fn initial_discriminant(&self, tcx: &TyCtxt) -> Disr;\n+    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Disr;\n }\n \n impl IntTypeExt for attr::IntType {\n-    fn to_ty<'tcx>(&self, cx: &TyCtxt<'tcx>) -> Ty<'tcx> {\n+    fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n-            SignedInt(ast::IntTy::I8)      => cx.types.i8,\n-            SignedInt(ast::IntTy::I16)     => cx.types.i16,\n-            SignedInt(ast::IntTy::I32)     => cx.types.i32,\n-            SignedInt(ast::IntTy::I64)     => cx.types.i64,\n-            SignedInt(ast::IntTy::Is)   => cx.types.isize,\n-            UnsignedInt(ast::UintTy::U8)    => cx.types.u8,\n-            UnsignedInt(ast::UintTy::U16)   => cx.types.u16,\n-            UnsignedInt(ast::UintTy::U32)   => cx.types.u32,\n-            UnsignedInt(ast::UintTy::U64)   => cx.types.u64,\n-            UnsignedInt(ast::UintTy::Us) => cx.types.usize,\n+            SignedInt(ast::IntTy::I8)      => tcx.types.i8,\n+            SignedInt(ast::IntTy::I16)     => tcx.types.i16,\n+            SignedInt(ast::IntTy::I32)     => tcx.types.i32,\n+            SignedInt(ast::IntTy::I64)     => tcx.types.i64,\n+            SignedInt(ast::IntTy::Is)   => tcx.types.isize,\n+            UnsignedInt(ast::UintTy::U8)    => tcx.types.u8,\n+            UnsignedInt(ast::UintTy::U16)   => tcx.types.u16,\n+            UnsignedInt(ast::UintTy::U32)   => tcx.types.u32,\n+            UnsignedInt(ast::UintTy::U64)   => tcx.types.u64,\n+            UnsignedInt(ast::UintTy::Us) => tcx.types.usize,\n         }\n     }\n \n-    fn initial_discriminant(&self, tcx: &TyCtxt) -> Disr {\n+    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Disr {\n         match *self {\n             SignedInt(ast::IntTy::I8)    => ConstInt::I8(0),\n             SignedInt(ast::IntTy::I16)   => ConstInt::I16(0),\n@@ -93,9 +94,14 @@ impl IntTypeExt for attr::IntType {\n         }\n     }\n \n-    fn disr_incr(&self, val: Disr) -> Option<Disr> {\n-        self.assert_ty_matches(val);\n-        (val + ConstInt::Infer(1)).ok()\n+    fn disr_incr<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, val: Option<Disr>)\n+                           -> Option<Disr> {\n+        if let Some(val) = val {\n+            self.assert_ty_matches(val);\n+            (val + ConstInt::Infer(1)).ok()\n+        } else {\n+            Some(self.initial_discriminant(tcx))\n+        }\n     }\n }\n \n@@ -123,63 +129,60 @@ pub enum Representability {\n     SelfRecursive,\n }\n \n-impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n-    pub fn can_type_implement_copy(&self, self_type: Ty<'tcx>, span: Span)\n-                                   -> Result<(),CopyImplementationError> {\n-        let tcx = self.tcx;\n-\n+impl<'tcx> ParameterEnvironment<'tcx> {\n+    pub fn can_type_implement_copy<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                       self_type: Ty<'tcx>, span: Span)\n+                                       -> Result<(),CopyImplementationError> {\n         // FIXME: (@jroesch) float this code up\n-        let infcx = infer::new_infer_ctxt(tcx,\n-                                          &tcx.tables,\n-                                          Some(self.clone()),\n-                                          ProjectionMode::Topmost);\n-\n-        let adt = match self_type.sty {\n-            ty::TyStruct(struct_def, substs) => {\n-                for field in struct_def.all_fields() {\n-                    let field_ty = field.ty(tcx, substs);\n-                    if infcx.type_moves_by_default(field_ty, span) {\n-                        return Err(CopyImplementationError::InfrigingField(\n-                            field.name))\n-                    }\n-                }\n-                struct_def\n-            }\n-            ty::TyEnum(enum_def, substs) => {\n-                for variant in &enum_def.variants {\n-                    for field in &variant.fields {\n+        tcx.infer_ctxt(None, Some(self.clone()),\n+                       ProjectionMode::Topmost).enter(|infcx| {\n+            let adt = match self_type.sty {\n+                ty::TyStruct(struct_def, substs) => {\n+                    for field in struct_def.all_fields() {\n                         let field_ty = field.ty(tcx, substs);\n                         if infcx.type_moves_by_default(field_ty, span) {\n-                            return Err(CopyImplementationError::InfrigingVariant(\n-                                variant.name))\n+                            return Err(CopyImplementationError::InfrigingField(\n+                                field.name))\n                         }\n                     }\n+                    struct_def\n                 }\n-                enum_def\n-            }\n-            _ => return Err(CopyImplementationError::NotAnAdt),\n-        };\n+                ty::TyEnum(enum_def, substs) => {\n+                    for variant in &enum_def.variants {\n+                        for field in &variant.fields {\n+                            let field_ty = field.ty(tcx, substs);\n+                            if infcx.type_moves_by_default(field_ty, span) {\n+                                return Err(CopyImplementationError::InfrigingVariant(\n+                                    variant.name))\n+                            }\n+                        }\n+                    }\n+                    enum_def\n+                }\n+                _ => return Err(CopyImplementationError::NotAnAdt)\n+            };\n \n-        if adt.has_dtor() {\n-            return Err(CopyImplementationError::HasDestructor)\n-        }\n+            if adt.has_dtor() {\n+                return Err(CopyImplementationError::HasDestructor);\n+            }\n \n-        Ok(())\n+            Ok(())\n+        })\n     }\n }\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn pat_contains_ref_binding(&self, pat: &hir::Pat) -> Option<hir::Mutability> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    pub fn pat_contains_ref_binding(self, pat: &hir::Pat) -> Option<hir::Mutability> {\n         pat_util::pat_contains_ref_binding(&self.def_map, pat)\n     }\n \n-    pub fn arm_contains_ref_binding(&self, arm: &hir::Arm) -> Option<hir::Mutability> {\n+    pub fn arm_contains_ref_binding(self, arm: &hir::Arm) -> Option<hir::Mutability> {\n         pat_util::arm_contains_ref_binding(&self.def_map, arm)\n     }\n \n     /// Returns the type of element at index `i` in tuple or tuple-like type `t`.\n     /// For an enum `t`, `variant` is None only if `t` is a univariant enum.\n-    pub fn positional_element_ty(&self,\n+    pub fn positional_element_ty(self,\n                                  ty: Ty<'tcx>,\n                                  i: usize,\n                                  variant: Option<DefId>) -> Option<Ty<'tcx>> {\n@@ -201,7 +204,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Returns the type of element at field `n` in struct or struct-like type `t`.\n     /// For an enum `t`, `variant` must be some def id.\n-    pub fn named_element_ty(&self,\n+    pub fn named_element_ty(self,\n                             ty: Ty<'tcx>,\n                             n: Name,\n                             variant: Option<DefId>) -> Option<Ty<'tcx>> {\n@@ -219,7 +222,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Returns the IntType representation.\n     /// This used to ensure `int_ty` doesn't contain `usize` and `isize`\n     /// by converting them to their actual types. That doesn't happen anymore.\n-    pub fn enum_repr_type(&self, opt_hint: Option<&attr::ReprAttr>) -> attr::IntType {\n+    pub fn enum_repr_type(self, opt_hint: Option<&attr::ReprAttr>) -> attr::IntType {\n         match opt_hint {\n             // Feed in the given type\n             Some(&attr::ReprInt(_, int_t)) => int_t,\n@@ -234,7 +237,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Returns the deeply last field of nested structures, or the same type,\n     /// if not a structure at all. Corresponds to the only possible unsized\n     /// field, and its type can be used to determine unsizing strategy.\n-    pub fn struct_tail(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn struct_tail(self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n         while let TyStruct(def, substs) = ty.sty {\n             match def.struct_variant().fields.last() {\n                 Some(f) => ty = f.ty(self, substs),\n@@ -249,7 +252,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// structure definitions.\n     /// For `(Foo<Foo<T>>, Foo<Trait>)`, the result will be `(Foo<T>, Trait)`,\n     /// whereas struct_tail produces `T`, and `Trait`, respectively.\n-    pub fn struct_lockstep_tails(&self,\n+    pub fn struct_lockstep_tails(self,\n                                  source: Ty<'tcx>,\n                                  target: Ty<'tcx>)\n                                  -> (Ty<'tcx>, Ty<'tcx>) {\n@@ -284,7 +287,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     ///\n     /// Requires that trait definitions have been processed so that we can\n     /// elaborate predicates and walk supertraits.\n-    pub fn required_region_bounds(&self,\n+    pub fn required_region_bounds(self,\n                                   erased_self_ty: Ty<'tcx>,\n                                   predicates: Vec<ty::Predicate<'tcx>>)\n                                   -> Vec<ty::Region>    {\n@@ -330,13 +333,14 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Creates a hash of the type `Ty` which will be the same no matter what crate\n     /// context it's calculated within. This is used by the `type_id` intrinsic.\n-    pub fn hash_crate_independent(&self, ty: Ty<'tcx>, svh: &Svh) -> u64 {\n+    pub fn hash_crate_independent(self, ty: Ty<'tcx>, svh: &Svh) -> u64 {\n         let mut state = SipHasher::new();\n         helper(self, ty, svh, &mut state);\n         return state.finish();\n \n-        fn helper<'tcx>(tcx: &TyCtxt<'tcx>, ty: Ty<'tcx>, svh: &Svh,\n-                        state: &mut SipHasher) {\n+        fn helper<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                  ty: Ty<'tcx>, svh: &Svh,\n+                                  state: &mut SipHasher) {\n             macro_rules! byte { ($b:expr) => { ($b as u8).hash(state) } }\n             macro_rules! hash { ($e:expr) => { $e.hash(state) }  }\n \n@@ -485,7 +489,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// `adt` that do not strictly outlive the adt value itself.\n     /// (This allows programs to make cyclic structures without\n     /// resorting to unasfe means; see RFCs 769 and 1238).\n-    pub fn is_adt_dtorck(&self, adt: ty::AdtDef<'tcx>) -> bool {\n+    pub fn is_adt_dtorck(self, adt: ty::AdtDef) -> bool {\n         let dtor_method = match adt.destructor() {\n             Some(dtor) => dtor,\n             None => return false\n@@ -504,30 +508,20 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n-impl<'tcx> ty::TyS<'tcx> {\n-    fn impls_bound<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n-                       bound: ty::BuiltinBound,\n-                       span: Span)\n-                       -> bool\n+impl<'a, 'tcx> ty::TyS<'tcx> {\n+    fn impls_bound(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                   param_env: &ParameterEnvironment<'tcx>,\n+                   bound: ty::BuiltinBound, span: Span) -> bool\n     {\n-        let tcx = param_env.tcx;\n-        let infcx = infer::new_infer_ctxt(tcx,\n-                                          &tcx.tables,\n-                                          Some(param_env.clone()),\n-                                          ProjectionMode::Topmost);\n-\n-        let is_impld = traits::type_known_to_meet_builtin_bound(&infcx,\n-                                                                self, bound, span);\n-\n-        debug!(\"Ty::impls_bound({:?}, {:?}) = {:?}\",\n-               self, bound, is_impld);\n-\n-        is_impld\n+        tcx.infer_ctxt(None, Some(param_env.clone()), ProjectionMode::Topmost).enter(|infcx| {\n+            traits::type_known_to_meet_builtin_bound(&infcx, self, bound, span)\n+        })\n     }\n \n     // FIXME (@jroesch): I made this public to use it, not sure if should be private\n-    pub fn moves_by_default<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n-                           span: Span) -> bool {\n+    pub fn moves_by_default(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            param_env: &ParameterEnvironment<'tcx>,\n+                            span: Span) -> bool {\n         if self.flags.get().intersects(TypeFlags::MOVENESS_CACHED) {\n             return self.flags.get().intersects(TypeFlags::MOVES_BY_DEFAULT);\n         }\n@@ -548,7 +542,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             TyArray(..) | TySlice(_) | TyTrait(..) | TyTuple(..) |\n             TyClosure(..) | TyEnum(..) | TyStruct(..) |\n             TyProjection(..) | TyParam(..) | TyInfer(..) | TyError => None\n-        }.unwrap_or_else(|| !self.impls_bound(param_env, ty::BoundCopy, span));\n+        }.unwrap_or_else(|| !self.impls_bound(tcx, param_env, ty::BoundCopy, span));\n \n         if !self.has_param_types() && !self.has_self_ty() {\n             self.flags.set(self.flags.get() | if result {\n@@ -562,18 +556,20 @@ impl<'tcx> ty::TyS<'tcx> {\n     }\n \n     #[inline]\n-    pub fn is_sized<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n-                        span: Span) -> bool\n+    pub fn is_sized(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    param_env: &ParameterEnvironment<'tcx>,\n+                    span: Span) -> bool\n     {\n         if self.flags.get().intersects(TypeFlags::SIZEDNESS_CACHED) {\n             return self.flags.get().intersects(TypeFlags::IS_SIZED);\n         }\n \n-        self.is_sized_uncached(param_env, span)\n+        self.is_sized_uncached(tcx, param_env, span)\n     }\n \n-    fn is_sized_uncached<'a>(&'tcx self, param_env: &ParameterEnvironment<'a,'tcx>,\n-                             span: Span) -> bool {\n+    fn is_sized_uncached(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                         param_env: &ParameterEnvironment<'tcx>,\n+                         span: Span) -> bool {\n         assert!(!self.needs_infer());\n \n         // Fast-path for primitive types\n@@ -586,7 +582,7 @@ impl<'tcx> ty::TyS<'tcx> {\n \n             TyEnum(..) | TyStruct(..) | TyProjection(..) | TyParam(..) |\n             TyInfer(..) | TyError => None\n-        }.unwrap_or_else(|| self.impls_bound(param_env, ty::BoundSized, span));\n+        }.unwrap_or_else(|| self.impls_bound(tcx, param_env, ty::BoundSized, span));\n \n         if !self.has_param_types() && !self.has_self_ty() {\n             self.flags.set(self.flags.get() | if result {\n@@ -600,55 +596,58 @@ impl<'tcx> ty::TyS<'tcx> {\n     }\n \n     #[inline]\n-    pub fn layout<'a>(&'tcx self, infcx: &infer::InferCtxt<'a, 'tcx>)\n-                      -> Result<&'tcx Layout, LayoutError<'tcx>> {\n+    pub fn layout<'lcx>(&'tcx self, infcx: &InferCtxt<'a, 'tcx, 'lcx>)\n+                        -> Result<&'tcx Layout, LayoutError<'tcx>> {\n+        let tcx = infcx.tcx.global_tcx();\n         let can_cache = !self.has_param_types() && !self.has_self_ty();\n         if can_cache {\n-            if let Some(&cached) = infcx.tcx.layout_cache.borrow().get(&self) {\n+            if let Some(&cached) = tcx.layout_cache.borrow().get(&self) {\n                 return Ok(cached);\n             }\n         }\n \n         let layout = Layout::compute_uncached(self, infcx)?;\n-        let layout = infcx.tcx.intern_layout(layout);\n+        let layout = tcx.intern_layout(layout);\n         if can_cache {\n-            infcx.tcx.layout_cache.borrow_mut().insert(self, layout);\n+            tcx.layout_cache.borrow_mut().insert(self, layout);\n         }\n         Ok(layout)\n     }\n \n \n     /// Check whether a type is representable. This means it cannot contain unboxed\n     /// structural recursion. This check is needed for structs and enums.\n-    pub fn is_representable(&'tcx self, cx: &TyCtxt<'tcx>, sp: Span) -> Representability {\n+    pub fn is_representable(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span)\n+                            -> Representability {\n \n         // Iterate until something non-representable is found\n-        fn find_nonrepresentable<'tcx, It: Iterator<Item=Ty<'tcx>>>(cx: &TyCtxt<'tcx>,\n-                                                                    sp: Span,\n-                                                                    seen: &mut Vec<Ty<'tcx>>,\n-                                                                    iter: It)\n-                                                                    -> Representability {\n+        fn find_nonrepresentable<'a, 'tcx, It>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                               sp: Span,\n+                                               seen: &mut Vec<Ty<'tcx>>,\n+                                               iter: It)\n+                                               -> Representability\n+        where It: Iterator<Item=Ty<'tcx>> {\n             iter.fold(Representability::Representable,\n-                      |r, ty| cmp::max(r, is_type_structurally_recursive(cx, sp, seen, ty)))\n+                      |r, ty| cmp::max(r, is_type_structurally_recursive(tcx, sp, seen, ty)))\n         }\n \n-        fn are_inner_types_recursive<'tcx>(cx: &TyCtxt<'tcx>, sp: Span,\n-                                           seen: &mut Vec<Ty<'tcx>>, ty: Ty<'tcx>)\n-                                           -> Representability {\n+        fn are_inner_types_recursive<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span,\n+                                               seen: &mut Vec<Ty<'tcx>>, ty: Ty<'tcx>)\n+                                               -> Representability {\n             match ty.sty {\n                 TyTuple(ref ts) => {\n-                    find_nonrepresentable(cx, sp, seen, ts.iter().cloned())\n+                    find_nonrepresentable(tcx, sp, seen, ts.iter().cloned())\n                 }\n                 // Fixed-length vectors.\n                 // FIXME(#11924) Behavior undecided for zero-length vectors.\n                 TyArray(ty, _) => {\n-                    is_type_structurally_recursive(cx, sp, seen, ty)\n+                    is_type_structurally_recursive(tcx, sp, seen, ty)\n                 }\n                 TyStruct(def, substs) | TyEnum(def, substs) => {\n-                    find_nonrepresentable(cx,\n+                    find_nonrepresentable(tcx,\n                                           sp,\n                                           seen,\n-                                          def.all_fields().map(|f| f.ty(cx, substs)))\n+                                          def.all_fields().map(|f| f.ty(tcx, substs)))\n                 }\n                 TyClosure(..) => {\n                     // this check is run on type definitions, so we don't expect\n@@ -691,10 +690,10 @@ impl<'tcx> ty::TyS<'tcx> {\n \n         // Does the type `ty` directly (without indirection through a pointer)\n         // contain any types on stack `seen`?\n-        fn is_type_structurally_recursive<'tcx>(cx: &TyCtxt<'tcx>,\n-                                                sp: Span,\n-                                                seen: &mut Vec<Ty<'tcx>>,\n-                                                ty: Ty<'tcx>) -> Representability {\n+        fn is_type_structurally_recursive<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                    sp: Span,\n+                                                    seen: &mut Vec<Ty<'tcx>>,\n+                                                    ty: Ty<'tcx>) -> Representability {\n             debug!(\"is_type_structurally_recursive: {:?}\", ty);\n \n             match ty.sty {\n@@ -746,13 +745,13 @@ impl<'tcx> ty::TyS<'tcx> {\n                     // For structs and enums, track all previously seen types by pushing them\n                     // onto the 'seen' stack.\n                     seen.push(ty);\n-                    let out = are_inner_types_recursive(cx, sp, seen, ty);\n+                    let out = are_inner_types_recursive(tcx, sp, seen, ty);\n                     seen.pop();\n                     out\n                 }\n                 _ => {\n                     // No need to push in other cases.\n-                    are_inner_types_recursive(cx, sp, seen, ty)\n+                    are_inner_types_recursive(tcx, sp, seen, ty)\n                 }\n             }\n         }\n@@ -763,7 +762,7 @@ impl<'tcx> ty::TyS<'tcx> {\n         // contains a different, structurally recursive type, maintain a stack\n         // of seen types and check recursion for each of them (issues #3008, #3779).\n         let mut seen: Vec<Ty> = Vec::new();\n-        let r = is_type_structurally_recursive(cx, sp, &mut seen, self);\n+        let r = is_type_structurally_recursive(tcx, sp, &mut seen, self);\n         debug!(\"is_type_representable: {:?} is {:?}\", self, r);\n         r\n     }"}, {"sha": "a25994ea69981f23dc7f9eb1cc0bd764c48b2c2b", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -10,7 +10,7 @@\n \n use hir::def_id::DefId;\n use infer::InferCtxt;\n-use ty::outlives::{self, Component};\n+use ty::outlives::Component;\n use ty::subst::Substs;\n use traits;\n use ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n@@ -25,11 +25,11 @@ use util::common::ErrorReported;\n /// inference variable, returns `None`, because we are not able to\n /// make any progress at all. This is to prevent \"livelock\" where we\n /// say \"$0 is WF if $0 is WF\".\n-pub fn obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                            body_id: ast::NodeId,\n-                            ty: Ty<'tcx>,\n-                            span: Span)\n-                            -> Option<Vec<traits::PredicateObligation<'tcx>>>\n+pub fn obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                   body_id: ast::NodeId,\n+                                   ty: Ty<'tcx>,\n+                                   span: Span)\n+                                   -> Option<Vec<traits::PredicateObligation<'tcx>>>\n {\n     let mut wf = WfPredicates { infcx: infcx,\n                                 body_id: body_id,\n@@ -49,22 +49,22 @@ pub fn obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n /// well-formed.  For example, if there is a trait `Set` defined like\n /// `trait Set<K:Eq>`, then the trait reference `Foo: Set<Bar>` is WF\n /// if `Bar: Eq`.\n-pub fn trait_obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                  body_id: ast::NodeId,\n-                                  trait_ref: &ty::TraitRef<'tcx>,\n-                                  span: Span)\n-                                  -> Vec<traits::PredicateObligation<'tcx>>\n+pub fn trait_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                         body_id: ast::NodeId,\n+                                         trait_ref: &ty::TraitRef<'tcx>,\n+                                         span: Span)\n+                                         -> Vec<traits::PredicateObligation<'tcx>>\n {\n     let mut wf = WfPredicates { infcx: infcx, body_id: body_id, span: span, out: vec![] };\n     wf.compute_trait_ref(trait_ref);\n     wf.normalize()\n }\n \n-pub fn predicate_obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                      body_id: ast::NodeId,\n-                                      predicate: &ty::Predicate<'tcx>,\n-                                      span: Span)\n-                                      -> Vec<traits::PredicateObligation<'tcx>>\n+pub fn predicate_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                             body_id: ast::NodeId,\n+                                             predicate: &ty::Predicate<'tcx>,\n+                                             span: Span)\n+                                             -> Vec<traits::PredicateObligation<'tcx>>\n {\n     let mut wf = WfPredicates { infcx: infcx, body_id: body_id, span: span, out: vec![] };\n \n@@ -123,8 +123,8 @@ pub enum ImpliedBound<'tcx> {\n /// Compute the implied bounds that a callee/impl can assume based on\n /// the fact that caller/projector has ensured that `ty` is WF.  See\n /// the `ImpliedBound` type for more details.\n-pub fn implied_bounds<'a,'tcx>(\n-    infcx: &'a InferCtxt<'a,'tcx>,\n+pub fn implied_bounds<'a, 'gcx, 'tcx>(\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     body_id: ast::NodeId,\n     ty: Ty<'tcx>,\n     span: Span)\n@@ -182,7 +182,7 @@ pub fn implied_bounds<'a,'tcx>(\n                         match infcx.tcx.no_late_bound_regions(data) {\n                             None => vec![],\n                             Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                                let components = outlives::components(infcx, ty_a);\n+                                let components = infcx.outlives_components(ty_a);\n                                 implied_bounds_from_components(r_b, components)\n                             }\n                         },\n@@ -227,14 +227,14 @@ fn implied_bounds_from_components<'tcx>(sub_region: ty::Region,\n         .collect()\n }\n \n-struct WfPredicates<'a,'tcx:'a> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+struct WfPredicates<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     body_id: ast::NodeId,\n     span: Span,\n     out: Vec<traits::PredicateObligation<'tcx>>,\n }\n \n-impl<'a,'tcx> WfPredicates<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n     fn cause(&mut self, code: traits::ObligationCauseCode<'tcx>) -> traits::ObligationCause<'tcx> {\n         traits::ObligationCause::new(self.span, self.body_id, code)\n     }\n@@ -288,9 +288,7 @@ impl<'a,'tcx> WfPredicates<'a,'tcx> {\n                      rfc1592: bool) {\n         if !subty.has_escaping_regions() {\n             let cause = self.cause(cause);\n-            match traits::trait_ref_for_builtin_bound(self.infcx.tcx,\n-                                                      ty::BoundSized,\n-                                                      subty) {\n+            match self.infcx.tcx.trait_ref_for_builtin_bound(ty::BoundSized, subty) {\n                 Ok(trait_ref) => {\n                     let predicate = trait_ref.to_predicate();\n                     let predicate = if rfc1592 {\n@@ -527,8 +525,8 @@ impl<'a,'tcx> WfPredicates<'a,'tcx> {\n /// they declare `trait SomeTrait : 'static`, for example, then\n /// `'static` would appear in the list. The hard work is done by\n /// `ty::required_region_bounds`, see that for more information.\n-pub fn object_region_bounds<'tcx>(\n-    tcx: &TyCtxt<'tcx>,\n+pub fn object_region_bounds<'a, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     principal: &ty::PolyTraitRef<'tcx>,\n     others: ty::BuiltinBounds)\n     -> Vec<ty::Region>"}, {"sha": "1a802064b61270d253ae8c9a669e1ba856deb2cf", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -18,6 +18,7 @@ use ty::{TyParam, TyRawPtr, TyRef, TyTuple};\n use ty::TyClosure;\n use ty::{TyBox, TyTrait, TyInt, TyUint, TyInfer};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::fold::{TypeFolder, TypeVisitor};\n \n use std::cell::Cell;\n use std::fmt;\n@@ -68,12 +69,12 @@ pub enum Ns {\n     Value\n }\n \n-fn number_of_supplied_defaults<'tcx, GG>(tcx: &ty::TyCtxt<'tcx>,\n-                                         substs: &subst::Substs,\n-                                         space: subst::ParamSpace,\n-                                         get_generics: GG)\n-                                         -> usize\n-    where GG: FnOnce(&TyCtxt<'tcx>) -> ty::Generics<'tcx>\n+fn number_of_supplied_defaults<'a, 'gcx, 'tcx, GG>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                                   substs: &subst::Substs,\n+                                                   space: subst::ParamSpace,\n+                                                   get_generics: GG)\n+                                                   -> usize\n+    where GG: FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> ty::Generics<'tcx>\n {\n     let generics = get_generics(tcx);\n \n@@ -114,7 +115,7 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n                          projections: &[ty::ProjectionPredicate],\n                          get_generics: GG)\n                          -> fmt::Result\n-    where GG: for<'tcx> FnOnce(&TyCtxt<'tcx>) -> ty::Generics<'tcx>\n+    where GG: for<'a, 'gcx, 'tcx> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> ty::Generics<'tcx>\n {\n     if let (Ns::Value, Some(self_ty)) = (ns, substs.self_ty()) {\n         write!(f, \"<{} as \", self_ty)?;\n@@ -230,10 +231,10 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n     Ok(())\n }\n \n-fn in_binder<'tcx, T, U>(f: &mut fmt::Formatter,\n-                         tcx: &TyCtxt<'tcx>,\n-                         original: &ty::Binder<T>,\n-                         lifted: Option<ty::Binder<U>>) -> fmt::Result\n+fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n+                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                   original: &ty::Binder<T>,\n+                                   lifted: Option<ty::Binder<U>>) -> fmt::Result\n     where T: fmt::Display, U: fmt::Display + TypeFoldable<'tcx>\n {\n     // Replace any anonymous late-bound regions with named\n@@ -293,11 +294,11 @@ fn in_binder<'tcx, T, U>(f: &mut fmt::Formatter,\n struct TraitAndProjections<'tcx>(ty::TraitRef<'tcx>, Vec<ty::ProjectionPredicate<'tcx>>);\n \n impl<'tcx> TypeFoldable<'tcx> for TraitAndProjections<'tcx> {\n-    fn super_fold_with<F:ty::fold::TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         TraitAndProjections(self.0.fold_with(folder), self.1.fold_with(folder))\n     }\n \n-    fn super_visit_with<V: ty::fold::TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         self.0.visit_with(visitor) || self.1.visit_with(visitor)\n     }\n }\n@@ -557,7 +558,7 @@ impl<'tcx> fmt::Debug for ty::ClosureUpvar<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> fmt::Debug for ty::ParameterEnvironment<'a, 'tcx> {\n+impl<'tcx> fmt::Debug for ty::ParameterEnvironment<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"ParameterEnvironment(\\\n             free_substs={:?}, \\\n@@ -894,14 +895,14 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyTrait(ref data) => write!(f, \"{}\", data),\n             ty::TyProjection(ref data) => write!(f, \"{}\", data),\n             TyStr => write!(f, \"str\"),\n-            TyClosure(did, ref substs) => ty::tls::with(|tcx| {\n+            TyClosure(did, substs) => ty::tls::with(|tcx| {\n                 write!(f, \"[closure\")?;\n \n                 if let Some(node_id) = tcx.map.as_local_node_id(did) {\n                     write!(f, \"@{:?}\", tcx.map.span(node_id))?;\n                     let mut sep = \" \";\n                     tcx.with_freevars(node_id, |freevars| {\n-                        for (freevar, upvar_ty) in freevars.iter().zip(&substs.upvar_tys) {\n+                        for (freevar, upvar_ty) in freevars.iter().zip(substs.upvar_tys) {\n                             let node_id = freevar.def.var_id();\n                             write!(f,\n                                         \"{}{}:{}\","}, {"sha": "bf5bce8fc3ba3b16b7c7f500dd09372393aca263", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -22,12 +22,10 @@ use borrowck::*;\n use borrowck::InteriorKind::{InteriorElement, InteriorField};\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::expr_use_visitor::MutateMode;\n-use rustc::infer;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::region;\n use rustc::ty::{self, TyCtxt};\n-use rustc::traits::ProjectionMode;\n use syntax::ast;\n use syntax::codemap::Span;\n use rustc::hir;\n@@ -92,7 +90,7 @@ struct CheckLoanCtxt<'a, 'tcx: 'a> {\n     dfcx_loans: &'a LoanDataFlow<'a, 'tcx>,\n     move_data: &'a move_data::FlowedMoveData<'a, 'tcx>,\n     all_loans: &'a [Loan<'tcx>],\n-    param_env: &'a ty::ParameterEnvironment<'a, 'tcx>,\n+    param_env: &'a ty::ParameterEnvironment<'tcx>,\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n@@ -203,23 +201,15 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     debug!(\"check_loans(body id={})\", body.id);\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n-    let infcx = infer::new_infer_ctxt(bccx.tcx,\n-                                      &bccx.tcx.tables,\n-                                      Some(param_env),\n-                                      ProjectionMode::AnyFinal);\n-\n+    let infcx = bccx.tcx.borrowck_fake_infer_ctxt(param_env);\n     let mut clcx = CheckLoanCtxt {\n         bccx: bccx,\n         dfcx_loans: dfcx_loans,\n         move_data: move_data,\n         all_loans: all_loans,\n         param_env: &infcx.parameter_environment\n     };\n-\n-    {\n-        let mut euv = euv::ExprUseVisitor::new(&mut clcx, &infcx);\n-        euv.walk_fn(decl, body);\n-    }\n+    euv::ExprUseVisitor::new(&mut clcx, &infcx).walk_fn(decl, body);\n }\n \n #[derive(PartialEq)]\n@@ -235,7 +225,7 @@ fn compatible_borrow_kinds(borrow_kind1: ty::BorrowKind,\n }\n \n impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n-    pub fn tcx(&self) -> &'a TyCtxt<'tcx> { self.bccx.tcx }\n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.bccx.tcx }\n \n     pub fn each_issued_loan<F>(&self, node: ast::NodeId, mut op: F) -> bool where\n         F: FnMut(&Loan<'tcx>) -> bool,"}, {"sha": "6ab85d7d449dc7c2000c6a13c3923fe50ad3cfe9", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -199,10 +199,10 @@ impl FragmentSets {\n     }\n }\n \n-pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n-                                       tcx: &TyCtxt<'tcx>,\n-                                       sp: Span,\n-                                       id: ast::NodeId) {\n+pub fn instrument_move_fragments<'a, 'tcx>(this: &MoveData<'tcx>,\n+                                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                           sp: Span,\n+                                           id: ast::NodeId) {\n     let span_err = tcx.map.attrs(id).iter()\n                           .any(|a| a.check_name(\"rustc_move_fragments\"));\n     let print = tcx.sess.opts.debugging_opts.print_move_fragments;\n@@ -245,7 +245,7 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n ///\n /// Note: \"left-over fragments\" means paths that were not directly referenced in moves nor\n /// assignments, but must nonetheless be tracked as potential drop obligations.\n-pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &TyCtxt<'tcx>) {\n+pub fn fixup_fragment_sets<'a, 'tcx>(this: &MoveData<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n     let mut fragments = this.fragments.borrow_mut();\n \n@@ -346,11 +346,11 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &TyCtxt<'tcx>) {\n /// Adds all of the precisely-tracked siblings of `lp` as potential move paths of interest. For\n /// example, if `lp` represents `s.x.j`, then adds moves paths for `s.x.i` and `s.x.k`, the\n /// siblings of `s.x.j`.\n-fn add_fragment_siblings<'tcx>(this: &MoveData<'tcx>,\n-                               tcx: &TyCtxt<'tcx>,\n-                               gathered_fragments: &mut Vec<Fragment>,\n-                               lp: Rc<LoanPath<'tcx>>,\n-                               origin_id: Option<ast::NodeId>) {\n+fn add_fragment_siblings<'a, 'tcx>(this: &MoveData<'tcx>,\n+                                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   gathered_fragments: &mut Vec<Fragment>,\n+                                   lp: Rc<LoanPath<'tcx>>,\n+                                   origin_id: Option<ast::NodeId>) {\n     match lp.kind {\n         LpVar(_) | LpUpvar(..) => {} // Local variables have no siblings.\n \n@@ -405,16 +405,16 @@ fn add_fragment_siblings<'tcx>(this: &MoveData<'tcx>,\n \n /// We have determined that `origin_lp` destructures to LpExtend(parent, original_field_name).\n /// Based on this, add move paths for all of the siblings of `origin_lp`.\n-fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n-                                             tcx: &TyCtxt<'tcx>,\n-                                             gathered_fragments: &mut Vec<Fragment>,\n-                                             parent_lp: &Rc<LoanPath<'tcx>>,\n-                                             mc: mc::MutabilityCategory,\n-                                             origin_field_name: &mc::FieldName,\n-                                             origin_lp: &Rc<LoanPath<'tcx>>,\n-                                             origin_id: Option<ast::NodeId>,\n-                                             enum_variant_info: Option<(DefId,\n-                                                                        Rc<LoanPath<'tcx>>)>) {\n+fn add_fragment_siblings_for_extension<'a, 'tcx>(this: &MoveData<'tcx>,\n+                                                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                 gathered_fragments: &mut Vec<Fragment>,\n+                                                 parent_lp: &Rc<LoanPath<'tcx>>,\n+                                                 mc: mc::MutabilityCategory,\n+                                                 origin_field_name: &mc::FieldName,\n+                                                 origin_lp: &Rc<LoanPath<'tcx>>,\n+                                                 origin_id: Option<ast::NodeId>,\n+                                                 enum_variant_info: Option<(DefId,\n+                                                    Rc<LoanPath<'tcx>>)>) {\n     let parent_ty = parent_lp.to_type();\n \n     let mut add_fragment_sibling_local = |field_name, variant_did| {\n@@ -504,14 +504,15 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n \n /// Adds the single sibling `LpExtend(parent, new_field_name)` of `origin_lp` (the original\n /// loan-path).\n-fn add_fragment_sibling_core<'tcx>(this: &MoveData<'tcx>,\n-                                   tcx: &TyCtxt<'tcx>,\n-                                   gathered_fragments: &mut Vec<Fragment>,\n-                                   parent: Rc<LoanPath<'tcx>>,\n-                                   mc: mc::MutabilityCategory,\n-                                   new_field_name: mc::FieldName,\n-                                   origin_lp: &Rc<LoanPath<'tcx>>,\n-                                   enum_variant_did: Option<DefId>) -> MovePathIndex {\n+fn add_fragment_sibling_core<'a, 'tcx>(this: &MoveData<'tcx>,\n+                                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                       gathered_fragments: &mut Vec<Fragment>,\n+                                       parent: Rc<LoanPath<'tcx>>,\n+                                       mc: mc::MutabilityCategory,\n+                                       new_field_name: mc::FieldName,\n+                                       origin_lp: &Rc<LoanPath<'tcx>>,\n+                                       enum_variant_did: Option<DefId>)\n+                                       -> MovePathIndex {\n     let opt_variant_did = match parent.kind {\n         LpDowncast(_, variant_did) => Some(variant_did),\n         LpVar(..) | LpUpvar(..) | LpExtend(..) => enum_variant_did,"}, {"sha": "7d4f02bfe1109cdb9bd1a9dc4717d813b742bc57", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -19,12 +19,10 @@\n use borrowck::*;\n use borrowck::move_data::MoveData;\n use rustc::middle::expr_use_visitor as euv;\n-use rustc::infer;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::region;\n use rustc::ty::{self, TyCtxt};\n-use rustc::traits::ProjectionMode;\n \n use syntax::ast;\n use syntax::codemap::Span;\n@@ -56,14 +54,8 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     };\n \n     let param_env = ty::ParameterEnvironment::for_item(bccx.tcx, fn_id);\n-    let infcx = infer::new_infer_ctxt(bccx.tcx,\n-                                      &bccx.tcx.tables,\n-                                      Some(param_env),\n-                                      ProjectionMode::AnyFinal);\n-    {\n-        let mut euv = euv::ExprUseVisitor::new(&mut glcx, &infcx);\n-        euv.walk_fn(decl, body);\n-    }\n+    let infcx = bccx.tcx.borrowck_fake_infer_ctxt(param_env);\n+    euv::ExprUseVisitor::new(&mut glcx, &infcx).walk_fn(decl, body);\n \n     glcx.report_potential_errors();\n     let GatherLoanCtxt { all_loans, move_data, .. } = glcx;\n@@ -180,7 +172,7 @@ fn check_aliasability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                 req_kind: ty::BorrowKind)\n                                 -> Result<(),()> {\n \n-    let aliasability = cmt.freely_aliasable(bccx.tcx);\n+    let aliasability = cmt.freely_aliasable();\n     debug!(\"check_aliasability aliasability={:?} req_kind={:?}\",\n            aliasability, req_kind);\n \n@@ -257,7 +249,7 @@ fn check_mutability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n-    pub fn tcx(&self) -> &'a TyCtxt<'tcx> { self.bccx.tcx }\n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.bccx.tcx }\n \n     /// Guarantees that `cmt` is assignable, or reports an error.\n     fn guarantee_assignment_valid(&mut self,\n@@ -524,22 +516,23 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n /// sure the loans being taken are sound.\n struct StaticInitializerCtxt<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n+    item_id: ast::NodeId\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &Expr) {\n         if let hir::ExprAddrOf(mutbl, ref base) = ex.node {\n-            let infcx = infer::new_infer_ctxt(self.bccx.tcx,\n-                                              &self.bccx.tcx.tables,\n-                                              None,\n-                                              ProjectionMode::AnyFinal);\n+            let param_env = ty::ParameterEnvironment::for_item(self.bccx.tcx,\n+                                                               self.item_id);\n+            let infcx = self.bccx.tcx.borrowck_fake_infer_ctxt(param_env);\n             let mc = mc::MemCategorizationContext::new(&infcx);\n             let base_cmt = mc.cat_expr(&base).unwrap();\n             let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);\n             // Check that we don't allow borrows of unsafe static items.\n-            if check_aliasability(self.bccx, ex.span,\n-                                  BorrowViolation(euv::AddrOf),\n-                                  base_cmt, borrow_kind).is_err() {\n+            let err = check_aliasability(self.bccx, ex.span,\n+                                         BorrowViolation(euv::AddrOf),\n+                                         base_cmt, borrow_kind).is_err();\n+            if err {\n                 return; // reported an error, no sense in reporting more.\n             }\n         }\n@@ -548,12 +541,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn gather_loans_in_static_initializer(bccx: &mut BorrowckCtxt, expr: &hir::Expr) {\n+pub fn gather_loans_in_static_initializer(bccx: &mut BorrowckCtxt,\n+                                          item_id: ast::NodeId,\n+                                          expr: &hir::Expr) {\n \n     debug!(\"gather_loans_in_static_initializer(expr={:?})\", expr);\n \n     let mut sicx = StaticInitializerCtxt {\n-        bccx: bccx\n+        bccx: bccx,\n+        item_id: item_id\n     };\n \n     sicx.visit_expr(expr);"}, {"sha": "d6dd176e3ba288b4cabf600c5723621f69b79ff3", "filename": "src/librustc_borrowck/borrowck/mir/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -458,8 +458,8 @@ impl<D: BitDenotation> DataflowState<D> {\n }\n \n \n-impl<'tcx> DataflowState<MoveData<'tcx>> {\n-    pub fn new_move_analysis(mir: &Mir<'tcx>, tcx: &TyCtxt<'tcx>) -> Self {\n+impl<'a, 'tcx> DataflowState<MoveData<'tcx>> {\n+    pub fn new_move_analysis(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n         let move_data = MoveData::gather_moves(mir, tcx);\n         DataflowState::new(mir, move_data)\n     }"}, {"sha": "bf3d671bdb5af5611e28d55e2d022ced7793cd98", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -482,8 +482,8 @@ impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n     }\n }\n \n-impl<'tcx> MoveData<'tcx> {\n-    pub fn gather_moves(mir: &Mir<'tcx>, tcx: &TyCtxt<'tcx>) -> Self {\n+impl<'a, 'tcx> MoveData<'tcx> {\n+    pub fn gather_moves(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n         gather_moves(mir, tcx)\n     }\n }\n@@ -494,7 +494,7 @@ enum StmtKind {\n     Aggregate, Drop, CallFn, CallArg, Return,\n }\n \n-fn gather_moves<'tcx>(mir: &Mir<'tcx>, tcx: &TyCtxt<'tcx>) -> MoveData<'tcx> {\n+fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveData<'tcx> {\n     use self::StmtKind as SK;\n \n     let bbs = mir.all_basic_blocks();\n@@ -667,7 +667,7 @@ fn gather_moves<'tcx>(mir: &Mir<'tcx>, tcx: &TyCtxt<'tcx>) -> MoveData<'tcx> {\n }\n \n struct BlockContext<'b, 'a: 'b, 'tcx: 'a> {\n-    tcx: &'b TyCtxt<'tcx>,\n+    tcx: TyCtxt<'b, 'tcx, 'tcx>,\n     moves: &'b mut Vec<MoveOut>,\n     builder: MovePathDataBuilder<'a, 'tcx>,\n     path_map: &'b mut Vec<Vec<MoveOutIndex>>,"}, {"sha": "bec5ae03d3d4de8ee80cb9835244f0c8f0273cdb", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -46,11 +46,11 @@ pub fn borrowck_mir<'b, 'a: 'b, 'tcx: 'a>(\n     }\n \n     let mut mbcx = MirBorrowckCtxt {\n+        flow_state: DataflowState::new_move_analysis(mir, bcx.tcx),\n         bcx: bcx,\n         mir: mir,\n         node_id: id,\n         attributes: attributes,\n-        flow_state: DataflowState::new_move_analysis(mir, bcx.tcx),\n     };\n \n     for bb in mir.all_basic_blocks() {"}, {"sha": "f0ea69c8a6b3d32733f15015136ba9aeb8bf6bfe", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -87,20 +87,20 @@ impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n \n     fn visit_trait_item(&mut self, ti: &hir::TraitItem) {\n         if let hir::ConstTraitItem(_, Some(ref expr)) = ti.node {\n-            gather_loans::gather_loans_in_static_initializer(self, &expr);\n+            gather_loans::gather_loans_in_static_initializer(self, ti.id, &expr);\n         }\n         intravisit::walk_trait_item(self, ti);\n     }\n \n     fn visit_impl_item(&mut self, ii: &hir::ImplItem) {\n         if let hir::ImplItemKind::Const(_, ref expr) = ii.node {\n-            gather_loans::gather_loans_in_static_initializer(self, &expr);\n+            gather_loans::gather_loans_in_static_initializer(self, ii.id, &expr);\n         }\n         intravisit::walk_impl_item(self, ii);\n     }\n }\n \n-pub fn check_crate<'tcx>(tcx: &TyCtxt<'tcx>, mir_map: &MirMap<'tcx>) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir_map: &MirMap<'tcx>) {\n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n         mir_map: Some(mir_map),\n@@ -142,7 +142,7 @@ fn borrowck_item(this: &mut BorrowckCtxt, item: &hir::Item) {\n     match item.node {\n         hir::ItemStatic(_, _, ref ex) |\n         hir::ItemConst(_, ref ex) => {\n-            gather_loans::gather_loans_in_static_initializer(this, &ex);\n+            gather_loans::gather_loans_in_static_initializer(this, item.id, &ex);\n         }\n         _ => { }\n     }\n@@ -244,7 +244,7 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n /// Accessor for introspective clients inspecting `AnalysisData` and\n /// the `BorrowckCtxt` itself , e.g. the flowgraph visualizer.\n pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir_map: Option<&'a MirMap<'tcx>>,\n     fn_parts: FnParts<'a>,\n     cfg: &cfg::CFG)\n@@ -278,7 +278,7 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n // Type definitions\n \n pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Hacky. As we visit various fns, we have to load up the\n     // free-region map for each one. This map is computed by during\n@@ -412,7 +412,7 @@ pub enum LoanPathElem {\n }\n \n pub fn closure_to_block(closure_id: ast::NodeId,\n-                        tcx: &TyCtxt) -> ast::NodeId {\n+                        tcx: TyCtxt) -> ast::NodeId {\n     match tcx.map.get(closure_id) {\n         hir_map::NodeExpr(expr) => match expr.node {\n             hir::ExprClosure(_, _, ref block, _) => {\n@@ -426,8 +426,8 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n     }\n }\n \n-impl<'tcx> LoanPath<'tcx> {\n-    pub fn kill_scope(&self, tcx: &TyCtxt<'tcx>) -> region::CodeExtent {\n+impl<'a, 'tcx> LoanPath<'tcx> {\n+    pub fn kill_scope(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> region::CodeExtent {\n         match self.kind {\n             LpVar(local_id) => tcx.region_maps.var_scope(local_id),\n             LpUpvar(upvar_id) => {\n@@ -627,13 +627,13 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         db.emit();\n     }\n \n-    pub fn report_use_of_moved_value<'b>(&self,\n-                                         use_span: Span,\n-                                         use_kind: MovedValueUseKind,\n-                                         lp: &LoanPath<'tcx>,\n-                                         the_move: &move_data::Move,\n-                                         moved_lp: &LoanPath<'tcx>,\n-                                         _param_env: &ty::ParameterEnvironment<'b,'tcx>) {\n+    pub fn report_use_of_moved_value(&self,\n+                                     use_span: Span,\n+                                     use_kind: MovedValueUseKind,\n+                                     lp: &LoanPath<'tcx>,\n+                                     the_move: &move_data::Move,\n+                                     moved_lp: &LoanPath<'tcx>,\n+                                     _param_env: &ty::ParameterEnvironment<'tcx>) {\n         let (verb, verb_participle) = match use_kind {\n             MovedInUse => (\"use\", \"used\"),\n             MovedInCapture => (\"capture\", \"captured\"),\n@@ -1109,7 +1109,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n }\n \n-fn statement_scope_span(tcx: &TyCtxt, region: ty::Region) -> Option<Span> {\n+fn statement_scope_span(tcx: TyCtxt, region: ty::Region) -> Option<Span> {\n     match region {\n         ty::ReScope(scope) => {\n             match tcx.map.find(scope.node_id(&tcx.region_maps)) {"}, {"sha": "a742260018676257766e8e8afa878bc514dc4f40", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -212,7 +212,7 @@ fn loan_path_is_precise(loan_path: &LoanPath) -> bool {\n     }\n }\n \n-impl<'tcx> MoveData<'tcx> {\n+impl<'a, 'tcx> MoveData<'tcx> {\n     pub fn new() -> MoveData<'tcx> {\n         MoveData {\n             paths: RefCell::new(Vec::new()),\n@@ -272,8 +272,7 @@ impl<'tcx> MoveData<'tcx> {\n \n     /// Returns the existing move path index for `lp`, if any, and otherwise adds a new index for\n     /// `lp` and any of its base paths that do not yet have an index.\n-    pub fn move_path(&self,\n-                     tcx: &TyCtxt<'tcx>,\n+    pub fn move_path(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                      lp: Rc<LoanPath<'tcx>>) -> MovePathIndex {\n         match self.path_map.borrow().get(&lp) {\n             Some(&index) => {\n@@ -364,8 +363,7 @@ impl<'tcx> MoveData<'tcx> {\n     }\n \n     /// Adds a new move entry for a move of `lp` that occurs at location `id` with kind `kind`.\n-    pub fn add_move(&self,\n-                    tcx: &TyCtxt<'tcx>,\n+    pub fn add_move(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     lp: Rc<LoanPath<'tcx>>,\n                     id: ast::NodeId,\n                     kind: MoveKind) {\n@@ -392,8 +390,7 @@ impl<'tcx> MoveData<'tcx> {\n \n     /// Adds a new record for an assignment to `lp` that occurs at location `id` with the given\n     /// `span`.\n-    pub fn add_assignment(&self,\n-                          tcx: &TyCtxt<'tcx>,\n+    pub fn add_assignment(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           lp: Rc<LoanPath<'tcx>>,\n                           assign_id: ast::NodeId,\n                           span: Span,\n@@ -437,8 +434,7 @@ impl<'tcx> MoveData<'tcx> {\n     /// variant `lp`, that occurs at location `pattern_id`.  (One\n     /// should be able to recover the span info from the\n     /// `pattern_id` and the ast_map, I think.)\n-    pub fn add_variant_match(&self,\n-                             tcx: &TyCtxt<'tcx>,\n+    pub fn add_variant_match(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              lp: Rc<LoanPath<'tcx>>,\n                              pattern_id: ast::NodeId,\n                              base_lp: Rc<LoanPath<'tcx>>,\n@@ -461,7 +457,7 @@ impl<'tcx> MoveData<'tcx> {\n         self.variant_matches.borrow_mut().push(variant_match);\n     }\n \n-    fn fixup_fragment_sets(&self, tcx: &TyCtxt<'tcx>) {\n+    fn fixup_fragment_sets(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         fragments::fixup_fragment_sets(self, tcx)\n     }\n \n@@ -470,8 +466,7 @@ impl<'tcx> MoveData<'tcx> {\n     /// Moves are generated by moves and killed by assignments and\n     /// scoping. Assignments are generated by assignment to variables and\n     /// killed by scoping. See `README.md` for more details.\n-    fn add_gen_kills(&self,\n-                     tcx: &TyCtxt<'tcx>,\n+    fn add_gen_kills(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                      dfcx_moves: &mut MoveDataFlow,\n                      dfcx_assign: &mut AssignDataFlow) {\n         for (i, the_move) in self.moves.borrow().iter().enumerate() {\n@@ -600,7 +595,7 @@ impl<'tcx> MoveData<'tcx> {\n \n impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n     pub fn new(move_data: MoveData<'tcx>,\n-               tcx: &'a TyCtxt<'tcx>,\n+               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                cfg: &cfg::CFG,\n                id_range: IdRange,\n                decl: &hir::FnDecl,"}, {"sha": "61d2408d5bfbb00eca6fc49200884535eed2b3ba", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -22,7 +22,6 @@ use rustc::hir::def_id::{DefId};\n use rustc::middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor};\n use rustc::middle::expr_use_visitor::{LoanCause, MutateMode};\n use rustc::middle::expr_use_visitor as euv;\n-use rustc::infer;\n use rustc::middle::mem_categorization::{cmt};\n use rustc::hir::pat_util::*;\n use rustc::traits::ProjectionMode;\n@@ -106,8 +105,8 @@ impl<'a> FromIterator<Vec<&'a Pat>> for Matrix<'a> {\n \n //NOTE: appears to be the only place other then InferCtxt to contain a ParamEnv\n pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n-    pub tcx: &'a TyCtxt<'tcx>,\n-    pub param_env: ParameterEnvironment<'a, 'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub param_env: ParameterEnvironment<'tcx>,\n }\n \n #[derive(Clone, PartialEq)]\n@@ -153,7 +152,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MatchCheckCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: &TyCtxt) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.visit_all_items_in_krate(DepNode::MatchCheck, &mut MatchCheckCtxt {\n         tcx: tcx,\n         param_env: tcx.empty_parameter_environment(),\n@@ -455,13 +454,13 @@ fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n }\n \n pub struct StaticInliner<'a, 'tcx: 'a> {\n-    pub tcx: &'a TyCtxt<'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub failed: bool,\n     pub renaming_map: Option<&'a mut FnvHashMap<(NodeId, Span), NodeId>>,\n }\n \n impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n-    pub fn new<'b>(tcx: &'b TyCtxt<'tcx>,\n+    pub fn new<'b>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                    renaming_map: Option<&'b mut FnvHashMap<(NodeId, Span), NodeId>>)\n                    -> StaticInliner<'b, 'tcx> {\n         StaticInliner {\n@@ -1123,13 +1122,12 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                     PatKind::Ident(hir::BindByValue(_), _, ref sub) => {\n                         let pat_ty = tcx.node_id_to_type(p.id);\n                         //FIXME: (@jroesch) this code should be floated up as well\n-                        let infcx = infer::new_infer_ctxt(cx.tcx,\n-                                                          &cx.tcx.tables,\n-                                                          Some(cx.param_env.clone()),\n-                                                          ProjectionMode::AnyFinal);\n-                        if infcx.type_moves_by_default(pat_ty, pat.span) {\n-                            check_move(p, sub.as_ref().map(|p| &**p));\n-                        }\n+                        cx.tcx.infer_ctxt(None, Some(cx.param_env.clone()),\n+                                          ProjectionMode::AnyFinal).enter(|infcx| {\n+                            if infcx.type_moves_by_default(pat_ty, pat.span) {\n+                                check_move(p, sub.as_ref().map(|p| &**p));\n+                            }\n+                        });\n                     }\n                     PatKind::Ident(hir::BindByRef(_), _, _) => {\n                     }\n@@ -1151,24 +1149,21 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n /// assign.\n fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>,\n                                          guard: &hir::Expr) {\n-    let mut checker = MutationChecker {\n-        cx: cx,\n-    };\n-\n-    let infcx = infer::new_infer_ctxt(cx.tcx,\n-                                      &cx.tcx.tables,\n-                                      Some(checker.cx.param_env.clone()),\n-                                      ProjectionMode::AnyFinal);\n-\n-    let mut visitor = ExprUseVisitor::new(&mut checker, &infcx);\n-    visitor.walk_expr(guard);\n+    cx.tcx.infer_ctxt(None, Some(cx.param_env.clone()),\n+                      ProjectionMode::AnyFinal).enter(|infcx| {\n+        let mut checker = MutationChecker {\n+            cx: cx,\n+        };\n+        let mut visitor = ExprUseVisitor::new(&mut checker, &infcx);\n+        visitor.walk_expr(guard);\n+    });\n }\n \n-struct MutationChecker<'a, 'tcx: 'a> {\n-    cx: &'a MatchCheckCtxt<'a, 'tcx>,\n+struct MutationChecker<'a, 'gcx: 'a> {\n+    cx: &'a MatchCheckCtxt<'a, 'gcx>,\n }\n \n-impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'gcx> {\n     fn matched_pat(&mut self, _: &Pat, _: cmt, _: euv::MatchMode) {}\n     fn consume(&mut self, _: NodeId, _: Span, _: cmt, _: ConsumeMode) {}\n     fn consume_pat(&mut self, _: &Pat, _: cmt, _: ConsumeMode) {}"}, {"sha": "9db24fa4770fe6f1a176c640fe2def881cf99b3e", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 85, "deletions": 82, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -18,14 +18,13 @@ use self::EvalHint::*;\n use rustc::hir::map as ast_map;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::middle::cstore::{self, InlinedItem};\n-use rustc::{infer, traits};\n+use rustc::traits;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::hir::pat_util::def_to_path;\n use rustc::ty::{self, Ty, TyCtxt, subst};\n use rustc::ty::util::IntTypeExt;\n use rustc::traits::ProjectionMode;\n-use rustc::middle::astconv_util::ast_ty_to_prim_ty;\n use rustc::util::nodemap::NodeMap;\n use rustc::lint;\n \n@@ -54,10 +53,10 @@ macro_rules! math {\n     }\n }\n \n-fn lookup_variant_by_id<'a>(tcx: &'a ty::TyCtxt,\n-                            enum_def: DefId,\n-                            variant_def: DefId)\n-                            -> Option<&'a Expr> {\n+fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  enum_def: DefId,\n+                                  variant_def: DefId)\n+                                  -> Option<&'tcx Expr> {\n     fn variant_expr<'a>(variants: &'a [hir::Variant], id: ast::NodeId)\n                         -> Option<&'a Expr> {\n         for variant in variants {\n@@ -90,16 +89,16 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::TyCtxt,\n ///\n /// `substs` is optional and is used for associated constants.\n /// This generally happens in late/trans const evaluation.\n-pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n+pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         def_id: DefId,\n-                                        substs: Option<subst::Substs<'tcx>>)\n+                                        substs: Option<&'tcx subst::Substs<'tcx>>)\n                                         -> Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)> {\n     if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n         match tcx.map.find(node_id) {\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n                 hir::ItemConst(ref ty, ref const_expr) => {\n-                    Some((&const_expr, ast_ty_to_prim_ty(tcx, ty)))\n+                    Some((&const_expr, tcx.ast_ty_to_prim_ty(ty)))\n                 }\n                 _ => None\n             },\n@@ -125,7 +124,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n             },\n             Some(ast_map::NodeImplItem(ii)) => match ii.node {\n                 hir::ImplItemKind::Const(ref ty, ref expr) => {\n-                    Some((&expr, ast_ty_to_prim_ty(tcx, ty)))\n+                    Some((&expr, tcx.ast_ty_to_prim_ty(ty)))\n                 }\n                 _ => None\n             },\n@@ -143,7 +142,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n         let expr_ty = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n             cstore::FoundAst::Found(&InlinedItem::Item(ref item)) => match item.node {\n                 hir::ItemConst(ref ty, ref const_expr) => {\n-                    Some((&**const_expr, ast_ty_to_prim_ty(tcx, ty)))\n+                    Some((&**const_expr, tcx.ast_ty_to_prim_ty(ty)))\n                 },\n                 _ => None\n             },\n@@ -164,7 +163,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n             },\n             cstore::FoundAst::Found(&InlinedItem::ImplItem(_, ref ii)) => match ii.node {\n                 hir::ImplItemKind::Const(ref ty, ref expr) => {\n-                    Some((&**expr, ast_ty_to_prim_ty(tcx, ty)))\n+                    Some((&**expr, tcx.ast_ty_to_prim_ty(ty)))\n                 },\n                 _ => None\n             },\n@@ -182,8 +181,9 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n     }\n }\n \n-fn inline_const_fn_from_external_crate(tcx: &TyCtxt, def_id: DefId)\n-                                       -> Option<ast::NodeId> {\n+fn inline_const_fn_from_external_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                 def_id: DefId)\n+                                                 -> Option<ast::NodeId> {\n     match tcx.extern_const_fns.borrow().get(&def_id) {\n         Some(&ast::DUMMY_NODE_ID) => return None,\n         Some(&fn_id) => return Some(fn_id),\n@@ -205,8 +205,8 @@ fn inline_const_fn_from_external_crate(tcx: &TyCtxt, def_id: DefId)\n     fn_id\n }\n \n-pub fn lookup_const_fn_by_id<'tcx>(tcx: &TyCtxt<'tcx>, def_id: DefId)\n-                                   -> Option<FnLikeNode<'tcx>>\n+pub fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n+                                       -> Option<FnLikeNode<'tcx>>\n {\n     let fn_id = if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n         node_id\n@@ -238,8 +238,11 @@ pub fn lookup_const_fn_by_id<'tcx>(tcx: &TyCtxt<'tcx>, def_id: DefId)\n     }\n }\n \n-pub fn const_expr_to_pat(tcx: &ty::TyCtxt, expr: &Expr, pat_id: ast::NodeId, span: Span)\n-                         -> Result<P<hir::Pat>, DefId> {\n+pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   expr: &Expr,\n+                                   pat_id: ast::NodeId,\n+                                   span: Span)\n+                                   -> Result<P<hir::Pat>, DefId> {\n     let pat_ty = tcx.expr_ty(expr);\n     debug!(\"expr={:?} pat_ty={:?} pat_id={}\", expr, pat_ty, pat_id);\n     match pat_ty.sty {\n@@ -339,7 +342,8 @@ pub fn const_expr_to_pat(tcx: &ty::TyCtxt, expr: &Expr, pat_id: ast::NodeId, spa\n     Ok(P(hir::Pat { id: expr.id, node: pat, span: span }))\n }\n \n-pub fn eval_const_expr(tcx: &TyCtxt, e: &Expr) -> ConstVal {\n+pub fn eval_const_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 e: &Expr) -> ConstVal {\n     match eval_const_expr_partial(tcx, e, ExprTypeChecked, None) {\n         Ok(r) => r,\n         // non-const path still needs to be a fatal error, because enums are funky\n@@ -526,10 +530,10 @@ macro_rules! signal {\n /// guaranteed to be evaluatable. `ty_hint` is usually ExprTypeChecked,\n /// but a few places need to evaluate constants during type-checking, like\n /// computing the length of an array. (See also the FIXME above EvalHint.)\n-pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                     e: &Expr,\n-                                     ty_hint: EvalHint<'tcx>,\n-                                     fn_args: FnArgMap) -> EvalResult {\n+pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                         e: &Expr,\n+                                         ty_hint: EvalHint<'tcx>,\n+                                         fn_args: FnArgMap) -> EvalResult {\n     // Try to compute the type of the expression based on the EvalHint.\n     // (See also the definition of EvalHint, and the FIXME above EvalHint.)\n     let ety = match ty_hint {\n@@ -678,7 +682,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n         }\n       }\n       hir::ExprCast(ref base, ref target_ty) => {\n-        let ety = ast_ty_to_prim_ty(tcx, &target_ty).or_else(|| ety)\n+        let ety = tcx.ast_ty_to_prim_ty(&target_ty).or(ety)\n                 .unwrap_or_else(|| {\n                     tcx.sess.span_fatal(target_ty.span,\n                                         \"target type not found for const cast\")\n@@ -931,11 +935,10 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n     }\n }\n \n-fn infer<'tcx>(\n-    i: ConstInt,\n-    tcx: &TyCtxt<'tcx>,\n-    ty_hint: &ty::TypeVariants<'tcx>,\n-) -> Result<ConstInt, ErrKind> {\n+fn infer<'a, 'tcx>(i: ConstInt,\n+                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                   ty_hint: &ty::TypeVariants<'tcx>)\n+                   -> Result<ConstInt, ErrKind> {\n     use syntax::ast::*;\n \n     match (ty_hint, i) {\n@@ -997,64 +1000,63 @@ fn infer<'tcx>(\n     }\n }\n \n-fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n+fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 ti: &'tcx hir::TraitItem,\n                                                 trait_id: DefId,\n-                                                rcvr_substs: subst::Substs<'tcx>)\n+                                                rcvr_substs: &'tcx subst::Substs<'tcx>)\n                                                 -> Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)>\n {\n     let trait_ref = ty::Binder(\n-        rcvr_substs.erase_regions().to_trait_ref(tcx, trait_id)\n+        rcvr_substs.clone().erase_regions().to_trait_ref(tcx, trait_id)\n     );\n     debug!(\"resolve_trait_associated_const: trait_ref={:?}\",\n            trait_ref);\n \n     tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n-    let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, ProjectionMode::AnyFinal);\n-\n-    let mut selcx = traits::SelectionContext::new(&infcx);\n-    let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n-                                             trait_ref.to_poly_trait_predicate());\n-    let selection = match selcx.select(&obligation) {\n-        Ok(Some(vtable)) => vtable,\n-        // Still ambiguous, so give up and let the caller decide whether this\n-        // expression is really needed yet. Some associated constant values\n-        // can't be evaluated until monomorphization is done in trans.\n-        Ok(None) => {\n-            return None\n-        }\n-        Err(_) => {\n-            return None\n-        }\n-    };\n+    tcx.infer_ctxt(None, None, ProjectionMode::AnyFinal).enter(|infcx| {\n+        let mut selcx = traits::SelectionContext::new(&infcx);\n+        let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n+                                                 trait_ref.to_poly_trait_predicate());\n+        let selection = match selcx.select(&obligation) {\n+            Ok(Some(vtable)) => vtable,\n+            // Still ambiguous, so give up and let the caller decide whether this\n+            // expression is really needed yet. Some associated constant values\n+            // can't be evaluated until monomorphization is done in trans.\n+            Ok(None) => {\n+                return None\n+            }\n+            Err(_) => {\n+                return None\n+            }\n+        };\n \n-    // NOTE: this code does not currently account for specialization, but when\n-    // it does so, it should hook into the ProjectionMode to determine when the\n-    // constant should resolve; this will also require plumbing through to this\n-    // function whether we are in \"trans mode\" to pick the right ProjectionMode\n-    // when constructing the inference context above.\n-    match selection {\n-        traits::VtableImpl(ref impl_data) => {\n-            match tcx.associated_consts(impl_data.impl_def_id)\n-                     .iter().find(|ic| ic.name == ti.name) {\n-                Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n-                None => match ti.node {\n-                    hir::ConstTraitItem(ref ty, Some(ref expr)) => {\n-                        Some((&*expr, ast_ty_to_prim_ty(tcx, ty)))\n+        // NOTE: this code does not currently account for specialization, but when\n+        // it does so, it should hook into the ProjectionMode to determine when the\n+        // constant should resolve; this will also require plumbing through to this\n+        // function whether we are in \"trans mode\" to pick the right ProjectionMode\n+        // when constructing the inference context above.\n+        match selection {\n+            traits::VtableImpl(ref impl_data) => {\n+                match tcx.associated_consts(impl_data.impl_def_id)\n+                        .iter().find(|ic| ic.name == ti.name) {\n+                    Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n+                    None => match ti.node {\n+                        hir::ConstTraitItem(ref ty, Some(ref expr)) => {\n+                            Some((&*expr, tcx.ast_ty_to_prim_ty(ty)))\n+                        },\n+                        _ => None,\n                     },\n-                    _ => None,\n-                },\n+                }\n+            }\n+            _ => {\n+            span_bug!(ti.span,\n+                      \"resolve_trait_associated_const: unexpected vtable type\")\n             }\n         }\n-        _ => {\n-            span_bug!(\n-                ti.span,\n-                \"resolve_trait_associated_const: unexpected vtable type\")\n-        }\n-    }\n+    })\n }\n \n-fn cast_const_int<'tcx>(tcx: &TyCtxt<'tcx>, val: ConstInt, ty: ty::Ty) -> CastResult {\n+fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, val: ConstInt, ty: ty::Ty) -> CastResult {\n     let v = val.to_u64_unchecked();\n     match ty.sty {\n         ty::TyBool if v == 0 => Ok(Bool(false)),\n@@ -1099,7 +1101,7 @@ fn cast_const_int<'tcx>(tcx: &TyCtxt<'tcx>, val: ConstInt, ty: ty::Ty) -> CastRe\n     }\n }\n \n-fn cast_const_float<'tcx>(tcx: &TyCtxt<'tcx>, f: f64, ty: ty::Ty) -> CastResult {\n+fn cast_const_float<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, f: f64, ty: ty::Ty) -> CastResult {\n     match ty.sty {\n         ty::TyInt(_) if f >= 0.0 => cast_const_int(tcx, Infer(f as u64), ty),\n         ty::TyInt(_) => cast_const_int(tcx, InferSigned(f as i64), ty),\n@@ -1110,7 +1112,7 @@ fn cast_const_float<'tcx>(tcx: &TyCtxt<'tcx>, f: f64, ty: ty::Ty) -> CastResult\n     }\n }\n \n-fn cast_const<'tcx>(tcx: &TyCtxt<'tcx>, val: ConstVal, ty: ty::Ty) -> CastResult {\n+fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, val: ConstVal, ty: ty::Ty) -> CastResult {\n     match val {\n         Integral(i) => cast_const_int(tcx, i, ty),\n         Bool(b) => cast_const_int(tcx, Infer(b as u64), ty),\n@@ -1127,11 +1129,11 @@ fn cast_const<'tcx>(tcx: &TyCtxt<'tcx>, val: ConstVal, ty: ty::Ty) -> CastResult\n     }\n }\n \n-fn lit_to_const<'tcx>(lit: &ast::LitKind,\n-                      tcx: &TyCtxt<'tcx>,\n-                      ty_hint: Option<Ty<'tcx>>,\n-                      span: Span,\n-                      ) -> Result<ConstVal, ErrKind> {\n+fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          ty_hint: Option<Ty<'tcx>>,\n+                          span: Span)\n+                          -> Result<ConstVal, ErrKind> {\n     use syntax::ast::*;\n     use syntax::ast::LitIntType::*;\n     match *lit {\n@@ -1198,9 +1200,9 @@ pub fn compare_const_vals(a: &ConstVal, b: &ConstVal) -> Option<Ordering> {\n     }\n }\n \n-pub fn compare_lit_exprs<'tcx>(tcx: &TyCtxt<'tcx>,\n-                               a: &Expr,\n-                               b: &Expr) -> Option<Ordering> {\n+pub fn compare_lit_exprs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   a: &Expr,\n+                                   b: &Expr) -> Option<Ordering> {\n     let a = match eval_const_expr_partial(tcx, a, ExprTypeChecked, None) {\n         Ok(a) => a,\n         Err(e) => {\n@@ -1220,7 +1222,8 @@ pub fn compare_lit_exprs<'tcx>(tcx: &TyCtxt<'tcx>,\n \n \n /// Returns the repeat count for a repeating vector expression.\n-pub fn eval_repeat_count(tcx: &TyCtxt, count_expr: &hir::Expr) -> usize {\n+pub fn eval_repeat_count<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   count_expr: &hir::Expr) -> usize {\n     let hint = UncheckedExprHint(tcx.types.usize);\n     match eval_const_expr_partial(tcx, count_expr, hint, None) {\n         Ok(Integral(Usize(count))) => {"}, {"sha": "f0c2de293277580fd3c778b6d423547c7ddc1e99", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -367,7 +367,7 @@ pub struct CompileState<'a, 'b, 'ast: 'a, 'tcx: 'b> where 'ast: 'tcx {\n     pub resolutions: Option<&'a Resolutions>,\n     pub mir_map: Option<&'b MirMap<'tcx>>,\n     pub analysis: Option<&'a ty::CrateAnalysis<'a>>,\n-    pub tcx: Option<&'b TyCtxt<'tcx>>,\n+    pub tcx: Option<TyCtxt<'b, 'tcx, 'tcx>>,\n     pub trans: Option<&'a trans::CrateTranslation>,\n }\n \n@@ -464,7 +464,7 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n                             hir_crate: &'a hir::Crate,\n                             analysis: &'a ty::CrateAnalysis<'a>,\n                             mir_map: Option<&'b MirMap<'tcx>>,\n-                            tcx: &'b TyCtxt<'tcx>,\n+                            tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                             crate_name: &'a str)\n                             -> CompileState<'a, 'b, 'ast, 'tcx> {\n         CompileState {\n@@ -817,7 +817,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                name: &str,\n                                                f: F)\n                                                -> Result<R, usize>\n-    where F: FnOnce(&TyCtxt<'tcx>, Option<MirMap<'tcx>>, ty::CrateAnalysis, CompileResult) -> R\n+    where F: for<'a> FnOnce(TyCtxt<'a, 'tcx, 'tcx>,\n+                            Option<MirMap<'tcx>>,\n+                            ty::CrateAnalysis,\n+                            CompileResult) -> R\n {\n     macro_rules! try_with_f {\n         ($e: expr, ($t: expr, $m: expr, $a: expr)) => {\n@@ -989,9 +992,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n }\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n-pub fn phase_4_translate_to_llvm<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                       mut mir_map: MirMap<'tcx>,\n-                                       analysis: ty::CrateAnalysis) -> trans::CrateTranslation {\n+pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                           mut mir_map: MirMap<'tcx>,\n+                                           analysis: ty::CrateAnalysis)\n+                                           -> trans::CrateTranslation {\n     let time_passes = tcx.sess.time_passes();\n \n     time(time_passes,"}, {"sha": "d841f7c86a93e3228ba42bdba8e09e9747b7961a", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -469,7 +469,7 @@ impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n \n \n struct TypedAnnotation<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n@@ -689,13 +689,13 @@ impl fold::Folder for ReplaceBodyWithLoop {\n     }\n }\n \n-fn print_flowgraph<'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n-                                   tcx: &TyCtxt<'tcx>,\n-                                   mir_map: Option<&MirMap<'tcx>>,\n-                                   code: blocks::Code,\n-                                   mode: PpFlowGraphMode,\n-                                   mut out: W)\n-                                   -> io::Result<()> {\n+fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n+                                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                       mir_map: Option<&MirMap<'tcx>>,\n+                                       code: blocks::Code,\n+                                       mode: PpFlowGraphMode,\n+                                       mut out: W)\n+                                       -> io::Result<()> {\n     let cfg = match code {\n         blocks::BlockCode(block) => cfg::CFG::new(tcx, &block),\n         blocks::FnLikeCode(fn_like) => cfg::CFG::new(tcx, &fn_like.body()),"}, {"sha": "9bbf250b9714eda7d2c34b803a86598aa76e171f", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 37, "deletions": 42, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -42,8 +42,8 @@ use syntax::feature_gate::UnstableFeatures;\n \n use rustc::hir;\n \n-struct Env<'a, 'tcx: 'a> {\n-    infcx: &'a infer::InferCtxt<'a, 'tcx>,\n+struct Env<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    infcx: &'a infer::InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n struct RH<'a> {\n@@ -138,31 +138,29 @@ fn test_env<F>(source_string: &str,\n     let region_map = region::resolve_crate(&sess, &ast_map);\n     let index = stability::Index::new(&ast_map);\n     TyCtxt::create_and_enter(&sess,\n-                               &arenas,\n-                               resolutions.def_map,\n-                               named_region_map.unwrap(),\n-                               ast_map,\n-                               resolutions.freevars,\n-                               resolutions.maybe_unused_trait_imports,\n-                               region_map,\n-                               lang_items,\n-                               index,\n-                               \"test_crate\",\n-                               |tcx| {\n-                                   let infcx = infer::new_infer_ctxt(tcx,\n-                                                                     &tcx.tables,\n-                                                                     None,\n-                                                                     ProjectionMode::AnyFinal);\n-                                   body(Env { infcx: &infcx });\n-                                   let free_regions = FreeRegionMap::new();\n-                                   infcx.resolve_regions_and_report_errors(&free_regions,\n-                                                                           ast::CRATE_NODE_ID);\n-                                   assert_eq!(tcx.sess.err_count(), expected_err_count);\n-                               });\n+                             &arenas,\n+                             resolutions.def_map,\n+                             named_region_map.unwrap(),\n+                             ast_map,\n+                             resolutions.freevars,\n+                             resolutions.maybe_unused_trait_imports,\n+                             region_map,\n+                             lang_items,\n+                             index,\n+                             \"test_crate\",\n+                             |tcx| {\n+        tcx.infer_ctxt(None, None, ProjectionMode::AnyFinal).enter(|infcx| {\n+\n+            body(Env { infcx: &infcx });\n+            let free_regions = FreeRegionMap::new();\n+            infcx.resolve_regions_and_report_errors(&free_regions, ast::CRATE_NODE_ID);\n+            assert_eq!(tcx.sess.err_count(), expected_err_count);\n+        });\n+    });\n }\n \n-impl<'a, 'tcx> Env<'a, 'tcx> {\n-    pub fn tcx(&self) -> &TyCtxt<'tcx> {\n+impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -244,17 +242,14 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     pub fn make_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-        match infer::mk_subty(self.infcx, true, TypeOrigin::Misc(DUMMY_SP), a, b) {\n+        match self.infcx.sub_types(true, TypeOrigin::Misc(DUMMY_SP), a, b) {\n             Ok(_) => true,\n             Err(ref e) => panic!(\"Encountered error: {}\", e),\n         }\n     }\n \n     pub fn is_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-        match infer::can_mk_subty(self.infcx, a, b) {\n-            Ok(_) => true,\n-            Err(_) => false,\n-        }\n+        self.infcx.can_sub_types(a, b).is_ok()\n     }\n \n     pub fn assert_subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) {\n@@ -270,15 +265,15 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     pub fn t_fn(&self, input_tys: &[Ty<'tcx>], output_ty: Ty<'tcx>) -> Ty<'tcx> {\n         let input_args = input_tys.iter().cloned().collect();\n-        self.infcx.tcx.mk_fn_ptr(ty::BareFnTy {\n+        self.infcx.tcx.mk_fn_ptr(self.infcx.tcx.mk_bare_fn(ty::BareFnTy {\n             unsafety: hir::Unsafety::Normal,\n             abi: Abi::Rust,\n             sig: ty::Binder(ty::FnSig {\n                 inputs: input_args,\n                 output: ty::FnConverging(output_ty),\n                 variadic: false,\n             }),\n-        })\n+        }))\n     }\n \n     pub fn t_nil(&self) -> Ty<'tcx> {\n@@ -359,25 +354,25 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         infer::TypeTrace::dummy(self.tcx())\n     }\n \n-    pub fn sub(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n+    pub fn sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         let trace = self.dummy_type_trace();\n-        self.infcx.sub(true, trace, t1, t2)\n+        self.infcx.sub(true, trace, &t1, &t2)\n     }\n \n-    pub fn lub(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n+    pub fn lub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         let trace = self.dummy_type_trace();\n-        self.infcx.lub(true, trace, t1, t2)\n+        self.infcx.lub(true, trace, &t1, &t2)\n     }\n \n-    pub fn glb(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n+    pub fn glb(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         let trace = self.dummy_type_trace();\n-        self.infcx.glb(true, trace, t1, t2)\n+        self.infcx.glb(true, trace, &t1, &t2)\n     }\n \n     /// Checks that `t1 <: t2` is true (this may register additional\n     /// region checks).\n     pub fn check_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n-        match self.sub(&t1, &t2) {\n+        match self.sub(t1, t2) {\n             Ok(InferOk { obligations, .. }) => {\n                 // FIXME(#32730) once obligations are being propagated, assert the right thing.\n                 assert!(obligations.is_empty());\n@@ -391,7 +386,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     /// Checks that `t1 <: t2` is false (this may register additional\n     /// region checks).\n     pub fn check_not_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n-        match self.sub(&t1, &t2) {\n+        match self.sub(t1, t2) {\n             Err(_) => {}\n             Ok(_) => {\n                 panic!(\"unexpected success computing sub({:?},{:?})\", t1, t2);\n@@ -401,7 +396,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     /// Checks that `LUB(t1,t2) == t_lub`\n     pub fn check_lub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_lub: Ty<'tcx>) {\n-        match self.lub(&t1, &t2) {\n+        match self.lub(t1, t2) {\n             Ok(InferOk { obligations, value: t }) => {\n                 // FIXME(#32730) once obligations are being propagated, assert the right thing.\n                 assert!(obligations.is_empty());\n@@ -417,7 +412,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     /// Checks that `GLB(t1,t2) == t_glb`\n     pub fn check_glb(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_glb: Ty<'tcx>) {\n         debug!(\"check_glb(t1={}, t2={}, t_glb={})\", t1, t2, t_glb);\n-        match self.glb(&t1, &t2) {\n+        match self.glb(t1, t2) {\n             Err(e) => {\n                 panic!(\"unexpected error computing LUB: {:?}\", e)\n             }"}, {"sha": "b74e7e212262585dc8a763820129964e3cb703be", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -63,7 +63,7 @@ const IF_THIS_CHANGED: &'static str = \"rustc_if_this_changed\";\n const THEN_THIS_WOULD_NEED: &'static str = \"rustc_then_this_would_need\";\n const ID: &'static str = \"id\";\n \n-pub fn assert_dep_graph(tcx: &TyCtxt) {\n+pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _ignore = tcx.dep_graph.in_ignore();\n \n     if tcx.sess.opts.debugging_opts.dump_dep_graph {\n@@ -98,7 +98,7 @@ type TargetHashMap =\n                FnvHashSet<(Span, InternedString, ast::NodeId, DepNode<DefId>)>>;\n \n struct IfThisChanged<'a, 'tcx:'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if_this_changed: SourceHashMap,\n     then_this_would_need: TargetHashMap,\n }\n@@ -172,9 +172,9 @@ impl<'a, 'tcx> Visitor<'tcx> for IfThisChanged<'a, 'tcx> {\n     }\n }\n \n-fn check_paths(tcx: &TyCtxt,\n-               if_this_changed: &SourceHashMap,\n-               then_this_would_need: &TargetHashMap)\n+fn check_paths<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                         if_this_changed: &SourceHashMap,\n+                         then_this_would_need: &TargetHashMap)\n {\n     // Return early here so as not to construct the query, which is not cheap.\n     if if_this_changed.is_empty() {\n@@ -213,7 +213,7 @@ fn check_paths(tcx: &TyCtxt,\n     }\n }\n \n-fn dump_graph(tcx: &TyCtxt) {\n+fn dump_graph(tcx: TyCtxt) {\n     let path: String = env::var(\"RUST_DEP_GRAPH\").unwrap_or_else(|_| format!(\"dep_graph\"));\n     let query = tcx.dep_graph.query();\n "}, {"sha": "ef3ac4c342690d9fb565225c63651604389dbd4f", "filename": "src/librustc_incremental/calculate_svh.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -14,21 +14,21 @@\n use std::hash::{Hash, SipHasher, Hasher};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::svh::Svh;\n-use rustc::ty;\n+use rustc::ty::TyCtxt;\n use rustc::hir::intravisit::{self, Visitor};\n \n use self::svh_visitor::StrictVersionHashVisitor;\n \n pub trait SvhCalculate {\n     /// Calculate the SVH for an entire krate.\n-    fn calculate_krate_hash(&self) -> Svh;\n+    fn calculate_krate_hash(self) -> Svh;\n \n     /// Calculate the SVH for a particular item.\n-    fn calculate_item_hash(&self, def_id: DefId) -> u64;\n+    fn calculate_item_hash(self, def_id: DefId) -> u64;\n }\n \n-impl<'tcx> SvhCalculate for ty::TyCtxt<'tcx> {\n-    fn calculate_krate_hash(&self) -> Svh {\n+impl<'a, 'tcx> SvhCalculate for TyCtxt<'a, 'tcx, 'tcx> {\n+    fn calculate_krate_hash(self) -> Svh {\n         // FIXME (#14132): This is better than it used to be, but it still not\n         // ideal. We now attempt to hash only the relevant portions of the\n         // Crate AST as well as the top-level crate attributes. (However,\n@@ -75,7 +75,7 @@ impl<'tcx> SvhCalculate for ty::TyCtxt<'tcx> {\n         Svh::from_hash(state.finish())\n     }\n \n-    fn calculate_item_hash(&self, def_id: DefId) -> u64 {\n+    fn calculate_item_hash(self, def_id: DefId) -> u64 {\n         assert!(def_id.is_local());\n \n         let mut state = SipHasher::new();\n@@ -109,7 +109,7 @@ mod svh_visitor {\n     use syntax::ast::{self, Name, NodeId};\n     use syntax::codemap::Span;\n     use syntax::parse::token;\n-    use rustc::ty;\n+    use rustc::ty::TyCtxt;\n     use rustc::hir;\n     use rustc::hir::*;\n     use rustc::hir::intravisit as visit;\n@@ -118,13 +118,13 @@ mod svh_visitor {\n     use std::hash::{Hash, SipHasher};\n \n     pub struct StrictVersionHashVisitor<'a, 'tcx: 'a> {\n-        pub tcx: &'a ty::TyCtxt<'tcx>,\n+        pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         pub st: &'a mut SipHasher,\n     }\n \n     impl<'a, 'tcx> StrictVersionHashVisitor<'a, 'tcx> {\n         pub fn new(st: &'a mut SipHasher,\n-                   tcx: &'a ty::TyCtxt<'tcx>)\n+                   tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                    -> Self {\n             StrictVersionHashVisitor { st: st, tcx: tcx }\n         }"}, {"sha": "e256b7cf7d0e111099bd2d751a6abb84b56fe528", "filename": "src/librustc_incremental/persist/directory.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -16,7 +16,7 @@\n use rustc::dep_graph::DepNode;\n use rustc::hir::map::DefPath;\n use rustc::hir::def_id::DefId;\n-use rustc::ty;\n+use rustc::ty::TyCtxt;\n use rustc::util::nodemap::DefIdMap;\n use std::fmt::{self, Debug};\n \n@@ -39,7 +39,7 @@ impl DefIdDirectory {\n         DefIdDirectory { paths: vec![] }\n     }\n \n-    pub fn retrace(&self, tcx: &ty::TyCtxt) -> RetracedDefIdDirectory {\n+    pub fn retrace(&self, tcx: TyCtxt) -> RetracedDefIdDirectory {\n         let ids = self.paths.iter()\n                             .map(|path| tcx.map.retrace_path(path))\n                             .collect();\n@@ -63,13 +63,13 @@ impl RetracedDefIdDirectory {\n }\n \n pub struct DefIdDirectoryBuilder<'a,'tcx:'a> {\n-    tcx: &'a ty::TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     hash: DefIdMap<Option<DefPathIndex>>,\n     directory: DefIdDirectory,\n }\n \n impl<'a,'tcx> DefIdDirectoryBuilder<'a,'tcx> {\n-    pub fn new(tcx: &'a ty::TyCtxt<'tcx>) -> DefIdDirectoryBuilder<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> DefIdDirectoryBuilder<'a, 'tcx> {\n         DefIdDirectoryBuilder {\n             tcx: tcx,\n             hash: DefIdMap(),"}, {"sha": "dee4d667b8d95c6b1a23b740455cda4e2d58d2b8", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -31,14 +31,14 @@ use rustc::hir::intravisit::Visitor;\n use syntax::ast::{self, Attribute, MetaItem};\n use syntax::attr::AttrMetaMethods;\n use syntax::parse::token::InternedString;\n-use rustc::ty;\n+use rustc::ty::TyCtxt;\n \n const DIRTY: &'static str = \"rustc_dirty\";\n const CLEAN: &'static str = \"rustc_clean\";\n const LABEL: &'static str = \"label\";\n const CFG: &'static str = \"cfg\";\n \n-pub fn check_dirty_clean_annotations(tcx: &ty::TyCtxt) {\n+pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _ignore = tcx.dep_graph.in_ignore();\n     let query = tcx.dep_graph.query();\n     let krate = tcx.map.krate();\n@@ -49,7 +49,7 @@ pub fn check_dirty_clean_annotations(tcx: &ty::TyCtxt) {\n }\n \n pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n-    tcx: &'a ty::TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     query: &'a DepGraphQuery<DefId>,\n }\n "}, {"sha": "f9e479745d10f902ac5506bc0ddc657b54786476", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -15,7 +15,7 @@ use rbml::Error;\n use rbml::opaque::Decoder;\n use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n-use rustc::ty;\n+use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv::FnvHashSet;\n use rustc_serialize::Decodable as RustcDecodable;\n use std::io::Read;\n@@ -37,7 +37,7 @@ type CleanEdges = Vec<(DepNode<DefId>, DepNode<DefId>)>;\n /// early in compilation, before we've really done any work, but\n /// actually it doesn't matter all that much.) See `README.md` for\n /// more general overview.\n-pub fn load_dep_graph<'tcx>(tcx: &ty::TyCtxt<'tcx>) {\n+pub fn load_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _ignore = tcx.dep_graph.in_ignore();\n \n     if let Some(dep_graph) = dep_graph_path(tcx) {\n@@ -47,7 +47,7 @@ pub fn load_dep_graph<'tcx>(tcx: &ty::TyCtxt<'tcx>) {\n     }\n }\n \n-pub fn load_dep_graph_if_exists<'tcx>(tcx: &ty::TyCtxt<'tcx>, path: &Path) {\n+pub fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, path: &Path) {\n     if !path.exists() {\n         return;\n     }\n@@ -74,8 +74,9 @@ pub fn load_dep_graph_if_exists<'tcx>(tcx: &ty::TyCtxt<'tcx>, path: &Path) {\n     }\n }\n \n-pub fn decode_dep_graph<'tcx>(tcx: &ty::TyCtxt<'tcx>, data: &[u8])\n-                              -> Result<(), Error>\n+pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  data: &[u8])\n+                                  -> Result<(), Error>\n {\n     // Deserialize the directory and dep-graph.\n     let mut decoder = Decoder::new(data, 0);\n@@ -129,10 +130,10 @@ pub fn decode_dep_graph<'tcx>(tcx: &ty::TyCtxt<'tcx>, data: &[u8])\n     Ok(())\n }\n \n-fn initial_dirty_nodes<'tcx>(tcx: &ty::TyCtxt<'tcx>,\n-                             hashed_items: &[SerializedHash],\n-                             retraced: &RetracedDefIdDirectory)\n-                             -> DirtyNodes {\n+fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 hashed_items: &[SerializedHash],\n+                                 retraced: &RetracedDefIdDirectory)\n+                                 -> DirtyNodes {\n     let mut items_removed = false;\n     let mut dirty_nodes = FnvHashSet();\n     for hashed_item in hashed_items {"}, {"sha": "cbb3464f3ef4ae8be8f94736369fa5aba8d75539", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -11,7 +11,7 @@\n use calculate_svh::SvhCalculate;\n use rbml::opaque::Encoder;\n use rustc::dep_graph::DepNode;\n-use rustc::ty;\n+use rustc::ty::TyCtxt;\n use rustc_serialize::{Encodable as RustcEncodable};\n use std::io::{self, Cursor, Write};\n use std::fs::{self, File};\n@@ -20,7 +20,7 @@ use super::data::*;\n use super::directory::*;\n use super::util::*;\n \n-pub fn save_dep_graph<'tcx>(tcx: &ty::TyCtxt<'tcx>) {\n+pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _ignore = tcx.dep_graph.in_ignore();\n \n     if let Some(dep_graph) = dep_graph_path(tcx) {\n@@ -68,10 +68,9 @@ pub fn save_dep_graph<'tcx>(tcx: &ty::TyCtxt<'tcx>) {\n     }\n }\n \n-pub fn encode_dep_graph<'tcx>(tcx: &ty::TyCtxt<'tcx>,\n-                              encoder: &mut Encoder)\n-                              -> io::Result<()>\n-{\n+pub fn encode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  encoder: &mut Encoder)\n+                                  -> io::Result<()> {\n     // Here we take advantage of how RBML allows us to skip around\n     // and encode the depgraph as a two-part structure:\n     //"}, {"sha": "8ebcbc0466f343238cb71edd05a141da0f991c19", "filename": "src/librustc_incremental/persist/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_incremental%2Fpersist%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_incremental%2Fpersist%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Futil.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::ty;\n+use rustc::ty::TyCtxt;\n \n use std::fs;\n use std::io;\n use std::path::{PathBuf, Path};\n \n-pub fn dep_graph_path<'tcx>(tcx: &ty::TyCtxt<'tcx>) -> Option<PathBuf> {\n+pub fn dep_graph_path(tcx: TyCtxt) -> Option<PathBuf> {\n     // For now, just save/load dep-graph from\n     // directory/dep_graph.rbml\n     tcx.sess.opts.incremental.as_ref().and_then(|incr_dir| {"}, {"sha": "d1eba5b3f4a4cd349b0ef61c2fa61fe19013d69a", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 42, "deletions": 48, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -31,7 +31,7 @@\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use middle::stability;\n-use rustc::{cfg, infer};\n+use rustc::cfg;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::adjustment;\n@@ -496,10 +496,10 @@ impl LateLintPass for MissingCopyImplementations {\n         let parameter_environment = cx.tcx.empty_parameter_environment();\n         // FIXME (@jroesch) should probably inver this so that the parameter env still impls this\n         // method\n-        if !ty.moves_by_default(&parameter_environment, item.span) {\n+        if !ty.moves_by_default(cx.tcx, &parameter_environment, item.span) {\n             return;\n         }\n-        if parameter_environment.can_type_implement_copy(ty, item.span).is_ok() {\n+        if parameter_environment.can_type_implement_copy(cx.tcx, ty, item.span).is_ok() {\n             cx.span_lint(MISSING_COPY_IMPLEMENTATIONS,\n                          item.span,\n                          \"type could implement `Copy`; consider adding `impl \\\n@@ -775,7 +775,7 @@ impl LateLintPass for UnconditionalRecursion {\n         // Functions for identifying if the given Expr NodeId `id`\n         // represents a call to the function `fn_id`/method `method`.\n \n-        fn expr_refers_to_this_fn(tcx: &TyCtxt,\n+        fn expr_refers_to_this_fn(tcx: TyCtxt,\n                                   fn_id: ast::NodeId,\n                                   id: ast::NodeId) -> bool {\n             match tcx.map.get(id) {\n@@ -791,9 +791,9 @@ impl LateLintPass for UnconditionalRecursion {\n         }\n \n         // Check if the expression `id` performs a call to `method`.\n-        fn expr_refers_to_this_method(tcx: &TyCtxt,\n-                                      method: &ty::Method,\n-                                      id: ast::NodeId) -> bool {\n+        fn expr_refers_to_this_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                method: &ty::Method,\n+                                                id: ast::NodeId) -> bool {\n             // Check for method calls and overloaded operators.\n             let opt_m = tcx.tables.borrow().method_map.get(&ty::MethodCall::expr(id)).cloned();\n             if let Some(m) = opt_m {\n@@ -822,11 +822,7 @@ impl LateLintPass for UnconditionalRecursion {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n                     match tcx.def_map.borrow().get(&callee.id).map(|d| d.full_def()) {\n                         Some(Def::Method(def_id)) => {\n-                            let item_substs =\n-                                tcx.tables.borrow().item_substs\n-                                                   .get(&callee.id)\n-                                                   .cloned()\n-                                                   .unwrap_or_else(|| ty::ItemSubsts::empty());\n+                            let item_substs = tcx.node_id_item_substs(callee.id);\n                             method_call_refers_to_method(\n                                 tcx, method, def_id, &item_substs.substs, id)\n                         }\n@@ -839,11 +835,11 @@ impl LateLintPass for UnconditionalRecursion {\n \n         // Check if the method call to the method with the ID `callee_id`\n         // and instantiated with `callee_substs` refers to method `method`.\n-        fn method_call_refers_to_method<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                              method: &ty::Method,\n-                                              callee_id: DefId,\n-                                              callee_substs: &Substs<'tcx>,\n-                                              expr_id: ast::NodeId) -> bool {\n+        fn method_call_refers_to_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                  method: &ty::Method,\n+                                                  callee_id: DefId,\n+                                                  callee_substs: &Substs<'tcx>,\n+                                                  expr_id: ast::NodeId) -> bool {\n             let callee_item = tcx.impl_or_trait_item(callee_id);\n \n             match callee_item.container() {\n@@ -868,39 +864,37 @@ impl LateLintPass for UnconditionalRecursion {\n                     // checking, so it's always local\n                     let node_id = tcx.map.as_local_node_id(method.def_id).unwrap();\n \n-                    let param_env = ty::ParameterEnvironment::for_item(tcx, node_id);\n-                    let infcx = infer::new_infer_ctxt(tcx,\n-                                                      &tcx.tables,\n-                                                      Some(param_env),\n-                                                      ProjectionMode::AnyFinal);\n-                    let mut selcx = traits::SelectionContext::new(&infcx);\n-                    match selcx.select(&obligation) {\n-                        // The method comes from a `T: Trait` bound.\n-                        // If `T` is `Self`, then this call is inside\n-                        // a default method definition.\n-                        Ok(Some(traits::VtableParam(_))) => {\n-                            let self_ty = callee_substs.self_ty();\n-                            let on_self = self_ty.map_or(false, |t| t.is_self());\n-                            // We can only be recurring in a default\n-                            // method if we're being called literally\n-                            // on the `Self` type.\n-                            on_self && callee_id == method.def_id\n-                        }\n+                    let param_env = Some(ty::ParameterEnvironment::for_item(tcx, node_id));\n+                    tcx.infer_ctxt(None, param_env, ProjectionMode::AnyFinal).enter(|infcx| {\n+                        let mut selcx = traits::SelectionContext::new(&infcx);\n+                        match selcx.select(&obligation) {\n+                            // The method comes from a `T: Trait` bound.\n+                            // If `T` is `Self`, then this call is inside\n+                            // a default method definition.\n+                            Ok(Some(traits::VtableParam(_))) => {\n+                                let self_ty = callee_substs.self_ty();\n+                                let on_self = self_ty.map_or(false, |t| t.is_self());\n+                                // We can only be recurring in a default\n+                                // method if we're being called literally\n+                                // on the `Self` type.\n+                                on_self && callee_id == method.def_id\n+                            }\n \n-                        // The `impl` is known, so we check that with a\n-                        // special case:\n-                        Ok(Some(traits::VtableImpl(vtable_impl))) => {\n-                            let container = ty::ImplContainer(vtable_impl.impl_def_id);\n-                            // It matches if it comes from the same impl,\n-                            // and has the same method name.\n-                            container == method.container\n-                                && callee_item.name() == method.name\n-                        }\n+                            // The `impl` is known, so we check that with a\n+                            // special case:\n+                            Ok(Some(traits::VtableImpl(vtable_impl))) => {\n+                                let container = ty::ImplContainer(vtable_impl.impl_def_id);\n+                                // It matches if it comes from the same impl,\n+                                // and has the same method name.\n+                                container == method.container\n+                                    && callee_item.name() == method.name\n+                            }\n \n-                        // There's no way to know if this call is\n-                        // recursive, so we assume it's not.\n-                        _ => return false\n-                    }\n+                            // There's no way to know if this call is\n+                            // recursive, so we assume it's not.\n+                            _ => false\n+                        }\n+                    })\n                 }\n             }\n         }"}, {"sha": "892924db6fad86c57fab9f90265b8eb4ff615e21", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -11,7 +11,6 @@\n #![allow(non_snake_case)]\n \n use rustc::hir::def_id::DefId;\n-use rustc::infer;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use middle::const_val::ConstVal;\n@@ -295,8 +294,10 @@ impl LateLintPass for TypeLimits {\n             }\n         }\n \n-        fn check_limits(tcx: &TyCtxt, binop: hir::BinOp,\n-                        l: &hir::Expr, r: &hir::Expr) -> bool {\n+        fn check_limits<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  binop: hir::BinOp,\n+                                  l: &hir::Expr,\n+                                  r: &hir::Expr) -> bool {\n             let (lit, expr, swap) = match (&l.node, &r.node) {\n                 (&hir::ExprLit(_), _) => (l, r, true),\n                 (_, &hir::ExprLit(_)) => (r, l, false),\n@@ -376,10 +377,10 @@ enum FfiResult {\n /// to function pointers and references, but could be\n /// expanded to cover NonZero raw pointers and newtypes.\n /// FIXME: This duplicates code in trans.\n-fn is_repr_nullable_ptr<'tcx>(tcx: &TyCtxt<'tcx>,\n-                              def: ty::AdtDef<'tcx>,\n-                              substs: &Substs<'tcx>)\n-                              -> bool {\n+fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  def: ty::AdtDef<'tcx>,\n+                                  substs: &Substs<'tcx>)\n+                                  -> bool {\n     if def.variants.len() == 2 {\n         let data_idx;\n \n@@ -410,7 +411,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                           ty: Ty<'tcx>)\n                           -> FfiResult {\n         use self::FfiResult::*;\n-        let cx = &self.cx.tcx;\n+        let cx = self.cx.tcx;\n \n         // Protect against infinite recursion, for example\n         // `struct S(*mut S);`.\n@@ -439,7 +440,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 }\n \n                 for field in &def.struct_variant().fields {\n-                    let field_ty = infer::normalize_associated_type(cx, &field.ty(cx, substs));\n+                    let field_ty = cx.normalize_associated_type(&field.ty(cx, substs));\n                     let r = self.check_type_for_ffi(cache, field_ty);\n                     match r {\n                         FfiSafe => {}\n@@ -494,7 +495,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 // Check the contained variants.\n                 for variant in &def.variants {\n                     for field in &variant.fields {\n-                        let arg = infer::normalize_associated_type(cx, &field.ty(cx, substs));\n+                        let arg = cx.normalize_associated_type(&field.ty(cx, substs));\n                         let r = self.check_type_for_ffi(cache, arg);\n                         match r {\n                             FfiSafe => {}\n@@ -596,7 +597,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     fn check_type_for_ffi_and_report_errors(&mut self, sp: Span, ty: Ty<'tcx>) {\n         // it is only OK to use this function because extern fns cannot have\n         // any generic types right now:\n-        let ty = infer::normalize_associated_type(self.cx.tcx, &ty);\n+        let ty = self.cx.tcx.normalize_associated_type(&ty);\n \n         match self.check_type_for_ffi(&mut FnvHashSet(), ty) {\n             FfiResult::FfiSafe => {}"}, {"sha": "6da2e5b17a5e8ebd8d45381fa27a4bfe37b3840c", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 26, "deletions": 33, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -60,7 +60,7 @@ use rustc_serialize::{Encodable, EncoderHelpers};\n #[cfg(test)] use rustc::hir::lowering::{lower_item, LoweringContext, DummyResolver};\n \n struct DecodeContext<'a, 'b, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cdata: &'b cstore::crate_metadata,\n     from_id_range: IdRange,\n     to_id_range: IdRange,\n@@ -122,13 +122,13 @@ impl<'a, 'b, 'c, 'tcx> ast_map::FoldOps for &'a DecodeContext<'b, 'c, 'tcx> {\n \n /// Decodes an item from its AST in the cdata's metadata and adds it to the\n /// ast-map.\n-pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n-                                 tcx: &TyCtxt<'tcx>,\n-                                 parent_def_path: ast_map::DefPath,\n-                                 parent_did: DefId,\n-                                 ast_doc: rbml::Doc,\n-                                 orig_did: DefId)\n-                                 -> &'tcx InlinedItem {\n+pub fn decode_inlined_item<'a, 'tcx>(cdata: &cstore::crate_metadata,\n+                                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     parent_def_path: ast_map::DefPath,\n+                                     parent_did: DefId,\n+                                     ast_doc: rbml::Doc,\n+                                     orig_did: DefId)\n+                                     -> &'tcx InlinedItem {\n     debug!(\"> Decoding inlined fn: {:?}\", tcx.item_path_str(orig_did));\n     let mut ast_dsr = reader::Decoder::new(ast_doc);\n     let from_id_range = Decodable::decode(&mut ast_dsr).unwrap();\n@@ -362,11 +362,8 @@ impl tr for Def {\n         match *self {\n           Def::Fn(did) => Def::Fn(did.tr(dcx)),\n           Def::Method(did) => Def::Method(did.tr(dcx)),\n-          Def::SelfTy(opt_did, impl_ids) => { Def::SelfTy(opt_did.map(|did| did.tr(dcx)),\n-                                                                impl_ids.map(|(nid1, nid2)| {\n-                                                                    (dcx.tr_id(nid1),\n-                                                                     dcx.tr_id(nid2))\n-                                                                })) }\n+          Def::SelfTy(opt_did, impl_id) => { Def::SelfTy(opt_did.map(|did| did.tr(dcx)),\n+                                                         impl_id.map(|id| dcx.tr_id(id))) }\n           Def::Mod(did) => { Def::Mod(did.tr(dcx)) }\n           Def::ForeignMod(did) => { Def::ForeignMod(did.tr(dcx)) }\n           Def::Static(did, m) => { Def::Static(did.tr(dcx), m) }\n@@ -861,21 +858,19 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n \n     // Versions of the type reading functions that don't need the full\n     // DecodeContext.\n-    fn read_ty_nodcx(&mut self,\n-                     tcx: &TyCtxt<'tcx>, cdata: &cstore::crate_metadata) -> Ty<'tcx>;\n-    fn read_tys_nodcx(&mut self,\n-                      tcx: &TyCtxt<'tcx>,\n-                      cdata: &cstore::crate_metadata) -> Vec<Ty<'tcx>>;\n-    fn read_substs_nodcx(&mut self, tcx: &TyCtxt<'tcx>,\n-                         cdata: &cstore::crate_metadata)\n-                         -> subst::Substs<'tcx>;\n+    fn read_ty_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                         cdata: &cstore::crate_metadata) -> Ty<'tcx>;\n+    fn read_tys_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          cdata: &cstore::crate_metadata) -> Vec<Ty<'tcx>>;\n+    fn read_substs_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             cdata: &cstore::crate_metadata)\n+                             -> subst::Substs<'tcx>;\n }\n \n impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n-    fn read_ty_nodcx(&mut self,\n-                     tcx: &TyCtxt<'tcx>,\n-                     cdata: &cstore::crate_metadata)\n-                     -> Ty<'tcx> {\n+    fn read_ty_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx, 'tcx>,\n+                         cdata: &cstore::crate_metadata)\n+                         -> Ty<'tcx> {\n         self.read_opaque(|_, doc| {\n             Ok(\n                 tydecode::TyDecoder::with_doc(tcx, cdata.cnum, doc,\n@@ -884,19 +879,17 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_tys_nodcx(&mut self,\n-                      tcx: &TyCtxt<'tcx>,\n-                      cdata: &cstore::crate_metadata) -> Vec<Ty<'tcx>> {\n+    fn read_tys_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx, 'tcx>,\n+                          cdata: &cstore::crate_metadata) -> Vec<Ty<'tcx>> {\n         self.read_to_vec(|this| Ok(this.read_ty_nodcx(tcx, cdata)) )\n             .unwrap()\n             .into_iter()\n             .collect()\n     }\n \n-    fn read_substs_nodcx(&mut self,\n-                         tcx: &TyCtxt<'tcx>,\n-                         cdata: &cstore::crate_metadata)\n-                         -> subst::Substs<'tcx>\n+    fn read_substs_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx, 'tcx>,\n+                             cdata: &cstore::crate_metadata)\n+                             -> subst::Substs<'tcx>\n     {\n         self.read_opaque(|_, doc| {\n             Ok(\n@@ -1153,7 +1146,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     }\n                     c::tag_table_item_subst => {\n                         let item_substs = ty::ItemSubsts {\n-                            substs: val_dsr.read_substs(dcx)\n+                            substs: dcx.tcx.mk_substs(val_dsr.read_substs(dcx))\n                         };\n                         dcx.tcx.tables.borrow_mut().item_substs.insert(\n                             id, item_substs);"}, {"sha": "8d464099783a6554d209fc8cdcdbcf01ab329558", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -54,14 +54,14 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_visibility(&cdata, def.index)\n     }\n \n-    fn closure_kind(&self, _tcx: &TyCtxt<'tcx>, def_id: DefId) -> ty::ClosureKind\n+    fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind\n     {\n         assert!(!def_id.is_local());\n         let cdata = self.get_crate_data(def_id.krate);\n         decoder::closure_kind(&cdata, def_id.index)\n     }\n \n-    fn closure_ty(&self, tcx: &TyCtxt<'tcx>, def_id: DefId) -> ty::ClosureTy<'tcx>\n+    fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::ClosureTy<'tcx>\n     {\n         assert!(!def_id.is_local());\n         let cdata = self.get_crate_data(def_id.krate);\n@@ -78,22 +78,22 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_repr_attrs(&cdata, def.index)\n     }\n \n-    fn item_type(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                 -> ty::TypeScheme<'tcx>\n+    fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                     -> ty::TypeScheme<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_type(&cdata, def.index, tcx)\n     }\n \n-    fn item_predicates(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                       -> ty::GenericPredicates<'tcx>\n+    fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                           -> ty::GenericPredicates<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_predicates(&cdata, def.index, tcx)\n     }\n \n-    fn item_super_predicates(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                             -> ty::GenericPredicates<'tcx>\n+    fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                                 -> ty::GenericPredicates<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_super_predicates(&cdata, def.index, tcx)\n@@ -111,13 +111,13 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_symbol(&cdata, def.index)\n     }\n \n-    fn trait_def(&self, tcx: &TyCtxt<'tcx>, def: DefId) -> ty::TraitDef<'tcx>\n+    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::TraitDef<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_trait_def(&cdata, def.index, tcx)\n     }\n \n-    fn adt_def(&self, tcx: &TyCtxt<'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n+    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_adt_def(&self.intr, &cdata, def.index, tcx)\n@@ -155,8 +155,8 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         result\n     }\n \n-    fn provided_trait_methods(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                              -> Vec<Rc<ty::Method<'tcx>>>\n+    fn provided_trait_methods<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                                  -> Vec<Rc<ty::Method<'tcx>>>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_provided_trait_methods(self.intr.clone(), &cdata, def.index, tcx)\n@@ -181,8 +181,8 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_impl_polarity(&cdata, def.index)\n     }\n \n-    fn impl_trait_ref(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                      -> Option<ty::TraitRef<'tcx>>\n+    fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                          -> Option<ty::TraitRef<'tcx>>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_impl_trait(&cdata, def.index, tcx)\n@@ -196,8 +196,8 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     }\n \n     // FIXME: killme\n-    fn associated_consts(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                         -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n+    fn associated_consts<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                             -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_associated_consts(self.intr.clone(), &cdata, def.index, tcx)\n     }\n@@ -207,14 +207,14 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_parent_impl(&*cdata, impl_def.index)\n     }\n \n-    fn trait_of_item(&self, tcx: &TyCtxt<'tcx>, def_id: DefId) -> Option<DefId>\n+    fn trait_of_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option<DefId>\n     {\n         let cdata = self.get_crate_data(def_id.krate);\n         decoder::get_trait_of_item(&cdata, def_id.index, tcx)\n     }\n \n-    fn impl_or_trait_item(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> Option<ty::ImplOrTraitItem<'tcx>>\n+    fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                              -> Option<ty::ImplOrTraitItem<'tcx>>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_impl_or_trait_item(\n@@ -247,7 +247,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::is_default_impl(&cdata, impl_did.index)\n     }\n \n-    fn is_extern_item(&self, tcx: &TyCtxt<'tcx>, did: DefId) -> bool {\n+    fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool {\n         let cdata = self.get_crate_data(did.krate);\n         decoder::is_extern_item(&cdata, did.index, tcx)\n     }\n@@ -442,15 +442,15 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         result\n     }\n \n-    fn maybe_get_item_ast(&'tcx self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> FoundAst<'tcx>\n+    fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                              -> FoundAst<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::maybe_get_item_ast(&cdata, tcx, def.index)\n     }\n \n-    fn maybe_get_item_mir(&self, tcx: &TyCtxt<'tcx>, def: DefId)\n-                          -> Option<Mir<'tcx>> {\n+    fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n+                              -> Option<Mir<'tcx>> {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::maybe_get_item_mir(&cdata, tcx, def.index)\n     }\n@@ -486,11 +486,11 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     {\n         loader::meta_section_name(target)\n     }\n-    fn encode_type(&self,\n-                   tcx: &TyCtxt<'tcx>,\n-                   ty: Ty<'tcx>,\n-                   def_id_to_string: fn(&TyCtxt<'tcx>, DefId) -> String)\n-                   -> Vec<u8>\n+    fn encode_type<'a>(&self,\n+                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                       ty: Ty<'tcx>,\n+                       def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String)\n+                       -> Vec<u8>\n     {\n         encoder::encoded_ty(tcx, ty, def_id_to_string)\n     }\n@@ -510,14 +510,13 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.do_extern_mod_stmt_cnum(emod_id)\n     }\n \n-    fn encode_metadata(&self,\n-                       tcx: &TyCtxt<'tcx>,\n-                       reexports: &def::ExportMap,\n-                       item_symbols: &RefCell<NodeMap<String>>,\n-                       link_meta: &LinkMeta,\n-                       reachable: &NodeSet,\n-                       mir_map: &MirMap<'tcx>,\n-                       krate: &hir::Crate) -> Vec<u8>\n+    fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           reexports: &def::ExportMap,\n+                           item_symbols: &RefCell<NodeMap<String>>,\n+                           link_meta: &LinkMeta,\n+                           reachable: &NodeSet,\n+                           mir_map: &MirMap<'tcx>,\n+                           krate: &hir::Crate) -> Vec<u8>\n     {\n         let ecx = encoder::EncodeContext {\n             diag: tcx.sess.diagnostic(),"}, {"sha": "e233dda7e91eeb91a99627601bd9ae8ee57d4c9e", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 77, "deletions": 70, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -223,35 +223,36 @@ fn variant_disr_val(d: rbml::Doc) -> Option<u64> {\n     })\n }\n \n-fn doc_type<'tcx>(doc: rbml::Doc, tcx: &TyCtxt<'tcx>, cdata: Cmd) -> Ty<'tcx> {\n+fn doc_type<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd) -> Ty<'tcx> {\n     let tp = reader::get_doc(doc, tag_items_data_item_type);\n     TyDecoder::with_doc(tcx, cdata.cnum, tp,\n                         &mut |did| translate_def_id(cdata, did))\n         .parse_ty()\n }\n \n-fn maybe_doc_type<'tcx>(doc: rbml::Doc, tcx: &TyCtxt<'tcx>, cdata: Cmd) -> Option<Ty<'tcx>> {\n+fn maybe_doc_type<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd)\n+                            -> Option<Ty<'tcx>> {\n     reader::maybe_get_doc(doc, tag_items_data_item_type).map(|tp| {\n         TyDecoder::with_doc(tcx, cdata.cnum, tp,\n                             &mut |did| translate_def_id(cdata, did))\n             .parse_ty()\n     })\n }\n \n-pub fn item_type<'tcx>(_item_id: DefId, item: rbml::Doc,\n-                       tcx: &TyCtxt<'tcx>, cdata: Cmd) -> Ty<'tcx> {\n+pub fn item_type<'a, 'tcx>(_item_id: DefId, item: rbml::Doc,\n+                           tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd) -> Ty<'tcx> {\n     doc_type(item, tcx, cdata)\n }\n \n-fn doc_trait_ref<'tcx>(doc: rbml::Doc, tcx: &TyCtxt<'tcx>, cdata: Cmd)\n-                       -> ty::TraitRef<'tcx> {\n+fn doc_trait_ref<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd)\n+                           -> ty::TraitRef<'tcx> {\n     TyDecoder::with_doc(tcx, cdata.cnum, doc,\n                         &mut |did| translate_def_id(cdata, did))\n         .parse_trait_ref()\n }\n \n-fn item_trait_ref<'tcx>(doc: rbml::Doc, tcx: &TyCtxt<'tcx>, cdata: Cmd)\n-                        -> ty::TraitRef<'tcx> {\n+fn item_trait_ref<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd)\n+                            -> ty::TraitRef<'tcx> {\n     let tp = reader::get_doc(doc, tag_item_trait_ref);\n     doc_trait_ref(tp, tcx, cdata)\n }\n@@ -350,9 +351,9 @@ fn parse_associated_type_names(item_doc: rbml::Doc) -> Vec<ast::Name> {\n         .collect()\n }\n \n-pub fn get_trait_def<'tcx>(cdata: Cmd,\n-                           item_id: DefIndex,\n-                           tcx: &TyCtxt<'tcx>) -> ty::TraitDef<'tcx>\n+pub fn get_trait_def<'a, 'tcx>(cdata: Cmd,\n+                               item_id: DefIndex,\n+                               tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::TraitDef<'tcx>\n {\n     let item_doc = cdata.lookup_item(item_id);\n     let generics = doc_generics(item_doc, tcx, cdata, tag_item_generics);\n@@ -367,10 +368,11 @@ pub fn get_trait_def<'tcx>(cdata: Cmd,\n                       associated_type_names)\n }\n \n-pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n-                         cdata: Cmd,\n-                         item_id: DefIndex,\n-                         tcx: &TyCtxt<'tcx>) -> ty::AdtDefMaster<'tcx>\n+pub fn get_adt_def<'a, 'tcx>(intr: &IdentInterner,\n+                             cdata: Cmd,\n+                             item_id: DefIndex,\n+                             tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                             -> ty::AdtDefMaster<'tcx>\n {\n     fn expect_variant_kind(family: Family) -> ty::VariantKind {\n         match family_to_variant_kind(family) {\n@@ -495,26 +497,26 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n     adt\n }\n \n-pub fn get_predicates<'tcx>(cdata: Cmd,\n-                            item_id: DefIndex,\n-                            tcx: &TyCtxt<'tcx>)\n-                            -> ty::GenericPredicates<'tcx>\n+pub fn get_predicates<'a, 'tcx>(cdata: Cmd,\n+                                item_id: DefIndex,\n+                                tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                -> ty::GenericPredicates<'tcx>\n {\n     let item_doc = cdata.lookup_item(item_id);\n     doc_predicates(item_doc, tcx, cdata, tag_item_generics)\n }\n \n-pub fn get_super_predicates<'tcx>(cdata: Cmd,\n-                                  item_id: DefIndex,\n-                                  tcx: &TyCtxt<'tcx>)\n-                                  -> ty::GenericPredicates<'tcx>\n+pub fn get_super_predicates<'a, 'tcx>(cdata: Cmd,\n+                                      item_id: DefIndex,\n+                                      tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                      -> ty::GenericPredicates<'tcx>\n {\n     let item_doc = cdata.lookup_item(item_id);\n     doc_predicates(item_doc, tcx, cdata, tag_item_super_predicates)\n }\n \n-pub fn get_type<'tcx>(cdata: Cmd, id: DefIndex, tcx: &TyCtxt<'tcx>)\n-                      -> ty::TypeScheme<'tcx>\n+pub fn get_type<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                          -> ty::TypeScheme<'tcx>\n {\n     let item_doc = cdata.lookup_item(id);\n     let t = item_type(DefId { krate: cdata.cnum, index: id }, item_doc, tcx,\n@@ -590,10 +592,10 @@ pub fn get_custom_coerce_unsized_kind<'tcx>(\n     })\n }\n \n-pub fn get_impl_trait<'tcx>(cdata: Cmd,\n-                            id: DefIndex,\n-                            tcx: &TyCtxt<'tcx>)\n-                            -> Option<ty::TraitRef<'tcx>>\n+pub fn get_impl_trait<'a, 'tcx>(cdata: Cmd,\n+                                id: DefIndex,\n+                                tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                -> Option<ty::TraitRef<'tcx>>\n {\n     let item_doc = cdata.lookup_item(id);\n     let fam = item_family(item_doc);\n@@ -775,8 +777,8 @@ pub fn get_item_name(intr: &IdentInterner, cdata: Cmd, id: DefIndex) -> ast::Nam\n     item_name(intr, cdata.lookup_item(id))\n }\n \n-pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &TyCtxt<'tcx>, id: DefIndex)\n-                                -> FoundAst<'tcx> {\n+pub fn maybe_get_item_ast<'a, 'tcx>(cdata: Cmd, tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefIndex)\n+                                    -> FoundAst<'tcx> {\n     debug!(\"Looking up item: {:?}\", id);\n     let item_doc = cdata.lookup_item(id);\n     let item_did = item_def_id(item_doc, cdata);\n@@ -827,10 +829,10 @@ pub fn is_item_mir_available<'tcx>(cdata: Cmd, id: DefIndex) -> bool {\n     false\n }\n \n-pub fn maybe_get_item_mir<'tcx>(cdata: Cmd,\n-                                tcx: &TyCtxt<'tcx>,\n-                                id: DefIndex)\n-                                -> Option<mir::repr::Mir<'tcx>> {\n+pub fn maybe_get_item_mir<'a, 'tcx>(cdata: Cmd,\n+                                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                    id: DefIndex)\n+                                    -> Option<mir::repr::Mir<'tcx>> {\n     let item_doc = cdata.lookup_item(id);\n \n     return reader::maybe_get_doc(item_doc, tag_mir as usize).map(|mir_doc| {\n@@ -943,11 +945,11 @@ pub fn is_static_method(cdata: Cmd, id: DefIndex) -> bool {\n     }\n }\n \n-pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n-                                    cdata: Cmd,\n-                                    id: DefIndex,\n-                                    tcx: &TyCtxt<'tcx>)\n-                                    -> Option<ty::ImplOrTraitItem<'tcx>> {\n+pub fn get_impl_or_trait_item<'a, 'tcx>(intr: Rc<IdentInterner>,\n+                                        cdata: Cmd,\n+                                        id: DefIndex,\n+                                        tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                        -> Option<ty::ImplOrTraitItem<'tcx>> {\n     let item_doc = cdata.lookup_item(id);\n \n     let def_id = item_def_id(item_doc, cdata);\n@@ -985,7 +987,7 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n             let predicates = doc_predicates(item_doc, tcx, cdata, tag_method_ty_generics);\n             let ity = tcx.lookup_item_type(def_id).ty;\n             let fty = match ity.sty {\n-                ty::TyFnDef(_, _, fty) => fty.clone(),\n+                ty::TyFnDef(_, _, fty) => fty,\n                 _ => bug!(\n                     \"the type {:?} of the method {:?} is not a function?\",\n                     ity, name)\n@@ -1038,11 +1040,11 @@ pub fn get_item_variances(cdata: Cmd, id: DefIndex) -> ty::ItemVariances {\n     Decodable::decode(&mut decoder).unwrap()\n }\n \n-pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n-                                        cdata: Cmd,\n-                                        id: DefIndex,\n-                                        tcx: &TyCtxt<'tcx>)\n-                                        -> Vec<Rc<ty::Method<'tcx>>> {\n+pub fn get_provided_trait_methods<'a, 'tcx>(intr: Rc<IdentInterner>,\n+                                            cdata: Cmd,\n+                                            id: DefIndex,\n+                                            tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                            -> Vec<Rc<ty::Method<'tcx>>> {\n     let item = cdata.lookup_item(id);\n \n     reader::tagged_docs(item, tag_item_trait_item).filter_map(|mth_id| {\n@@ -1065,11 +1067,11 @@ pub fn get_provided_trait_methods<'tcx>(intr: Rc<IdentInterner>,\n     }).collect()\n }\n \n-pub fn get_associated_consts<'tcx>(intr: Rc<IdentInterner>,\n-                                   cdata: Cmd,\n-                                   id: DefIndex,\n-                                   tcx: &TyCtxt<'tcx>)\n-                                   -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n+pub fn get_associated_consts<'a, 'tcx>(intr: Rc<IdentInterner>,\n+                                       cdata: Cmd,\n+                                       id: DefIndex,\n+                                       tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                       -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n     let item = cdata.lookup_item(id);\n \n     [tag_item_trait_item, tag_item_impl_item].iter().flat_map(|&tag| {\n@@ -1442,8 +1444,10 @@ pub fn each_implementation_for_trait<F>(cdata: Cmd,\n     }\n }\n \n-pub fn get_trait_of_item(cdata: Cmd, id: DefIndex, tcx: &TyCtxt)\n-                         -> Option<DefId> {\n+pub fn get_trait_of_item<'a, 'tcx>(cdata: Cmd,\n+                                   id: DefIndex,\n+                                   tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                   -> Option<DefId> {\n     let item_doc = cdata.lookup_item(id);\n     let parent_item_id = match item_parent_item(cdata, item_doc) {\n         None => return None,\n@@ -1577,7 +1581,10 @@ pub fn is_const_fn(cdata: Cmd, id: DefIndex) -> bool {\n     }\n }\n \n-pub fn is_extern_item(cdata: Cmd, id: DefIndex, tcx: &TyCtxt) -> bool {\n+pub fn is_extern_item<'a, 'tcx>(cdata: Cmd,\n+                                id: DefIndex,\n+                                tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                -> bool {\n     let item_doc = match cdata.get_item(id) {\n         Some(doc) => doc,\n         None => return false,\n@@ -1612,11 +1619,11 @@ pub fn is_impl(cdata: Cmd, id: DefIndex) -> bool {\n     }\n }\n \n-fn doc_generics<'tcx>(base_doc: rbml::Doc,\n-                      tcx: &TyCtxt<'tcx>,\n-                      cdata: Cmd,\n-                      tag: usize)\n-                      -> ty::Generics<'tcx>\n+fn doc_generics<'a, 'tcx>(base_doc: rbml::Doc,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          cdata: Cmd,\n+                          tag: usize)\n+                          -> ty::Generics<'tcx>\n {\n     let doc = reader::get_doc(base_doc, tag);\n \n@@ -1660,10 +1667,10 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n     ty::Generics { types: types, regions: regions }\n }\n \n-fn doc_predicate<'tcx>(cdata: Cmd,\n-                       doc: rbml::Doc,\n-                       tcx: &TyCtxt<'tcx>)\n-                       -> ty::Predicate<'tcx>\n+fn doc_predicate<'a, 'tcx>(cdata: Cmd,\n+                           doc: rbml::Doc,\n+                           tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                           -> ty::Predicate<'tcx>\n {\n     let predicate_pos = cdata.xref_index.lookup(\n         cdata.data(), reader::doc_as_u32(doc)).unwrap() as usize;\n@@ -1673,11 +1680,11 @@ fn doc_predicate<'tcx>(cdata: Cmd,\n     ).parse_predicate()\n }\n \n-fn doc_predicates<'tcx>(base_doc: rbml::Doc,\n-                        tcx: &TyCtxt<'tcx>,\n-                        cdata: Cmd,\n-                        tag: usize)\n-                        -> ty::GenericPredicates<'tcx>\n+fn doc_predicates<'a, 'tcx>(base_doc: rbml::Doc,\n+                            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            cdata: Cmd,\n+                            tag: usize)\n+                            -> ty::GenericPredicates<'tcx>\n {\n     let doc = reader::get_doc(base_doc, tag);\n \n@@ -1729,8 +1736,8 @@ pub fn closure_kind(cdata: Cmd, closure_id: DefIndex) -> ty::ClosureKind {\n     ty::ClosureKind::decode(&mut decoder).unwrap()\n }\n \n-pub fn closure_ty<'tcx>(cdata: Cmd, closure_id: DefIndex, tcx: &TyCtxt<'tcx>)\n-                        -> ty::ClosureTy<'tcx> {\n+pub fn closure_ty<'a, 'tcx>(cdata: Cmd, closure_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                            -> ty::ClosureTy<'tcx> {\n     let closure_doc = cdata.lookup_item(closure_id);\n     let closure_ty_doc = reader::get_doc(closure_doc, tag_items_closure_ty);\n     TyDecoder::with_doc(tcx, cdata.cnum, closure_ty_doc, &mut |did| translate_def_id(cdata, did))"}, {"sha": "020f12d753e63c6ab55e3a12024eb690f3bd2100", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -25,7 +25,6 @@ use middle::cstore::{LOCAL_CRATE, InlinedItemRef, LinkMeta, tls};\n use rustc::hir::def;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::dependency_format::Linkage;\n-use middle::stability;\n use rustc::ty::subst;\n use rustc::traits::specialization_graph;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -57,7 +56,7 @@ use rustc::hir::map::DefKey;\n \n pub struct EncodeContext<'a, 'tcx: 'a> {\n     pub diag: &'a Handler,\n-    pub tcx: &'a TyCtxt<'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub reexports: &'a def::ExportMap,\n     pub item_symbols: &'a RefCell<NodeMap<String>>,\n     pub link_meta: &'a LinkMeta,\n@@ -140,7 +139,7 @@ pub fn def_to_u64(did: DefId) -> u64 {\n     (did.krate as u64) << 32 | (did.index.as_usize() as u64)\n }\n \n-pub fn def_to_string(_tcx: &TyCtxt, did: DefId) -> String {\n+pub fn def_to_string(_tcx: TyCtxt, did: DefId) -> String {\n     format!(\"{}:{}\", did.krate, did.index.as_usize())\n }\n \n@@ -253,7 +252,7 @@ fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     debug!(\"encode_enum_variant_info(did={:?})\", did);\n     let repr_hints = ecx.tcx.lookup_repr_hints(did);\n     let repr_type = ecx.tcx.enum_repr_type(repr_hints.get(0));\n-    let mut disr_val = repr_type.initial_discriminant(&ecx.tcx);\n+    let mut disr_val = repr_type.initial_discriminant(ecx.tcx);\n     let def = ecx.tcx.lookup_adt_def(did);\n     for variant in &def.variants {\n         let vid = variant.did;\n@@ -283,8 +282,8 @@ fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_attributes(rbml_w, &attrs);\n         encode_repr_attrs(rbml_w, ecx, &attrs);\n \n-        let stab = stability::lookup_stability(ecx.tcx, vid);\n-        let depr = stability::lookup_deprecation(ecx.tcx, vid);\n+        let stab = ecx.tcx.lookup_stability(vid);\n+        let depr = ecx.tcx.lookup_deprecation(vid);\n         encode_stability(rbml_w, stab);\n         encode_deprecation(rbml_w, depr);\n \n@@ -376,8 +375,8 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n \n     encode_visibility(rbml_w, vis);\n \n-    let stab = stability::lookup_stability(ecx.tcx, ecx.tcx.map.local_def_id(id));\n-    let depr = stability::lookup_deprecation(ecx.tcx, ecx.tcx.map.local_def_id(id));\n+    let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(id));\n+    let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(id));\n     encode_stability(rbml_w, stab);\n     encode_deprecation(rbml_w, depr);\n \n@@ -484,8 +483,8 @@ fn encode_field<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_bounds_and_type_for_item(rbml_w, ecx, index, id);\n     encode_def_id_and_key(ecx, rbml_w, field.did);\n \n-    let stab = stability::lookup_stability(ecx.tcx, field.did);\n-    let depr = stability::lookup_deprecation(ecx.tcx, field.did);\n+    let stab = ecx.tcx.lookup_stability(field.did);\n+    let depr = ecx.tcx.lookup_deprecation(field.did);\n     encode_stability(rbml_w, stab);\n     encode_deprecation(rbml_w, depr);\n \n@@ -517,8 +516,8 @@ fn encode_info_for_struct_ctor<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_symbol(ecx, rbml_w, ctor_id);\n     }\n \n-    let stab = stability::lookup_stability(ecx.tcx, ecx.tcx.map.local_def_id(ctor_id));\n-    let depr= stability::lookup_deprecation(ecx.tcx, ecx.tcx.map.local_def_id(ctor_id));\n+    let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(ctor_id));\n+    let depr= ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(ctor_id));\n     encode_stability(rbml_w, stab);\n     encode_deprecation(rbml_w, depr);\n \n@@ -646,8 +645,8 @@ fn encode_info_for_associated_const<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_bounds_and_type_for_item(rbml_w, ecx, index,\n                                     ecx.local_id(associated_const.def_id));\n \n-    let stab = stability::lookup_stability(ecx.tcx, associated_const.def_id);\n-    let depr = stability::lookup_deprecation(ecx.tcx, associated_const.def_id);\n+    let stab = ecx.tcx.lookup_stability(associated_const.def_id);\n+    let depr = ecx.tcx.lookup_deprecation(associated_const.def_id);\n     encode_stability(rbml_w, stab);\n     encode_deprecation(rbml_w, depr);\n \n@@ -681,8 +680,8 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n     encode_item_sort(rbml_w, 'r');\n \n-    let stab = stability::lookup_stability(ecx.tcx, m.def_id);\n-    let depr = stability::lookup_deprecation(ecx.tcx, m.def_id);\n+    let stab = ecx.tcx.lookup_stability(m.def_id);\n+    let depr = ecx.tcx.lookup_deprecation(m.def_id);\n     encode_stability(rbml_w, stab);\n     encode_deprecation(rbml_w, depr);\n \n@@ -736,8 +735,8 @@ fn encode_info_for_associated_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_parent_item(rbml_w, ecx.tcx.map.local_def_id(parent_id));\n     encode_item_sort(rbml_w, 't');\n \n-    let stab = stability::lookup_stability(ecx.tcx, associated_type.def_id);\n-    let depr = stability::lookup_deprecation(ecx.tcx, associated_type.def_id);\n+    let stab = ecx.tcx.lookup_stability(associated_type.def_id);\n+    let depr = ecx.tcx.lookup_deprecation(associated_type.def_id);\n     encode_stability(rbml_w, stab);\n     encode_deprecation(rbml_w, depr);\n \n@@ -872,8 +871,8 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n     let vis = &item.vis;\n     let def_id = ecx.tcx.map.local_def_id(item.id);\n-    let stab = stability::lookup_stability(tcx, ecx.tcx.map.local_def_id(item.id));\n-    let depr = stability::lookup_deprecation(tcx, ecx.tcx.map.local_def_id(item.id));\n+    let stab = tcx.lookup_stability(ecx.tcx.map.local_def_id(item.id));\n+    let depr = tcx.lookup_deprecation(ecx.tcx.map.local_def_id(item.id));\n \n     match item.node {\n       hir::ItemStatic(_, m, _) => {\n@@ -1231,8 +1230,8 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n             encode_parent_item(rbml_w, def_id);\n \n-            let stab = stability::lookup_stability(tcx, item_def_id.def_id());\n-            let depr = stability::lookup_deprecation(tcx, item_def_id.def_id());\n+            let stab = tcx.lookup_stability(item_def_id.def_id());\n+            let depr = tcx.lookup_deprecation(item_def_id.def_id());\n             encode_stability(rbml_w, stab);\n             encode_deprecation(rbml_w, depr);\n \n@@ -1358,8 +1357,8 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             encode_symbol(ecx, rbml_w, nitem.id);\n         }\n         encode_attributes(rbml_w, &nitem.attrs);\n-        let stab = stability::lookup_stability(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n-        let depr = stability::lookup_deprecation(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n+        let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n+        let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n         encode_stability(rbml_w, stab);\n         encode_deprecation(rbml_w, depr);\n         encode_method_argument_names(rbml_w, &fndecl);\n@@ -1372,8 +1371,8 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         }\n         encode_bounds_and_type_for_item(rbml_w, ecx, index, nitem.id);\n         encode_attributes(rbml_w, &nitem.attrs);\n-        let stab = stability::lookup_stability(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n-        let depr = stability::lookup_deprecation(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n+        let stab = ecx.tcx.lookup_stability(ecx.tcx.map.local_def_id(nitem.id));\n+        let depr = ecx.tcx.lookup_deprecation(ecx.tcx.map.local_def_id(nitem.id));\n         encode_stability(rbml_w, stab);\n         encode_deprecation(rbml_w, depr);\n         encode_symbol(ecx, rbml_w, nitem.id);\n@@ -1698,7 +1697,7 @@ fn encode_struct_field_attrs(ecx: &EncodeContext,\n \n \n struct ImplVisitor<'a, 'tcx:'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     impls: FnvHashMap<DefId, Vec<DefId>>\n }\n \n@@ -2017,10 +2016,10 @@ fn encode_metadata_inner(rbml_w: &mut Encoder,\n }\n \n // Get the encoded string for a type\n-pub fn encoded_ty<'tcx>(tcx: &TyCtxt<'tcx>,\n-                        t: Ty<'tcx>,\n-                        def_id_to_string: fn(&TyCtxt<'tcx>, DefId) -> String)\n-                        -> Vec<u8> {\n+pub fn encoded_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            t: Ty<'tcx>,\n+                            def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String)\n+                            -> Vec<u8> {\n     let mut wr = Cursor::new(Vec::new());\n     tyencode::enc_ty(&mut wr, &tyencode::ctxt {\n         diag: tcx.sess.diagnostic(),"}, {"sha": "23142ca80ef0ecc695c088650263b15c5d2eb26c", "filename": "src/librustc_metadata/tls_context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_metadata%2Ftls_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_metadata%2Ftls_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftls_context.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -25,8 +25,8 @@ use tyencode;\n \n impl<'a, 'tcx: 'a> tls::EncodingContext<'tcx> for encoder::EncodeContext<'a, 'tcx> {\n \n-    fn tcx<'s>(&'s self) -> &'s TyCtxt<'tcx> {\n-        &self.tcx\n+    fn tcx<'s>(&'s self) -> TyCtxt<'s, 'tcx, 'tcx> {\n+        self.tcx\n     }\n \n     fn encode_ty(&self, encoder: &mut OpaqueEncoder, t: ty::Ty<'tcx>) {\n@@ -40,13 +40,13 @@ impl<'a, 'tcx: 'a> tls::EncodingContext<'tcx> for encoder::EncodeContext<'a, 'tc\n \n pub struct DecodingContext<'a, 'tcx: 'a> {\n     pub crate_metadata: Cmd<'a>,\n-    pub tcx: &'a TyCtxt<'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n impl<'a, 'tcx: 'a> tls::DecodingContext<'tcx> for DecodingContext<'a, 'tcx> {\n \n-    fn tcx<'s>(&'s self) -> &'s TyCtxt<'tcx> {\n-        &self.tcx\n+    fn tcx<'s>(&'s self) -> TyCtxt<'s, 'tcx, 'tcx> {\n+        self.tcx\n     }\n \n     fn decode_ty(&self, decoder: &mut OpaqueDecoder) -> ty::Ty<'tcx> {"}, {"sha": "c94af9c5b3ae318d64332c35cc05650a275d3d45", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -41,12 +41,12 @@ pub struct TyDecoder<'a, 'tcx: 'a> {\n     data: &'a [u8],\n     krate: ast::CrateNum,\n     pos: usize,\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     conv_def_id: DefIdConvert<'a>,\n }\n \n impl<'a,'tcx> TyDecoder<'a,'tcx> {\n-    pub fn with_doc(tcx: &'a TyCtxt<'tcx>,\n+    pub fn with_doc(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     crate_num: ast::CrateNum,\n                     doc: rbml::Doc<'a>,\n                     conv: DefIdConvert<'a>)\n@@ -57,7 +57,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n     pub fn new(data: &'a [u8],\n                crate_num: ast::CrateNum,\n                pos: usize,\n-               tcx: &'a TyCtxt<'tcx>,\n+               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                conv: DefIdConvert<'a>)\n                -> TyDecoder<'a, 'tcx> {\n         TyDecoder {\n@@ -502,15 +502,15 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         }\n     }\n \n-    pub fn parse_bare_fn_ty(&mut self) -> ty::BareFnTy<'tcx> {\n+    pub fn parse_bare_fn_ty(&mut self) -> &'tcx ty::BareFnTy<'tcx> {\n         let unsafety = parse_unsafety(self.next());\n         let abi = self.parse_abi_set();\n         let sig = self.parse_sig();\n-        ty::BareFnTy {\n+        self.tcx.mk_bare_fn(ty::BareFnTy {\n             unsafety: unsafety,\n             abi: abi,\n             sig: sig\n-        }\n+        })\n     }\n \n     fn parse_sig(&mut self) -> ty::PolyFnSig<'tcx> {"}, {"sha": "343c452f89165aa3a12085cd3ff7e768cec7ca6e", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -37,9 +37,9 @@ use encoder;\n pub struct ctxt<'a, 'tcx: 'a> {\n     pub diag: &'a Handler,\n     // Def -> str Callback:\n-    pub ds: fn(&TyCtxt<'tcx>, DefId) -> String,\n+    pub ds: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String,\n     // The type context.\n-    pub tcx: &'a TyCtxt<'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub abbrevs: &'a abbrev_map<'tcx>\n }\n \n@@ -110,7 +110,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx\n             enc_existential_bounds(w, cx, bounds);\n             write!(w, \"]\");\n         }\n-        ty::TyTuple(ref ts) => {\n+        ty::TyTuple(ts) => {\n             write!(w, \"T[\");\n             for t in ts { enc_ty(w, cx, *t); }\n             write!(w, \"]\");\n@@ -156,10 +156,10 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx\n             enc_substs(w, cx, substs);\n             write!(w, \"]\");\n         }\n-        ty::TyClosure(def, ref substs) => {\n+        ty::TyClosure(def, substs) => {\n             write!(w, \"k[{}|\", (cx.ds)(cx.tcx, def));\n-            enc_substs(w, cx, &substs.func_substs);\n-            for ty in &substs.upvar_tys {\n+            enc_substs(w, cx, substs.func_substs);\n+            for ty in substs.upvar_tys {\n                 enc_ty(w, cx, ty);\n             }\n             write!(w, \".\");"}, {"sha": "c1626b93f0c4181f1f9c18d4729fd04a2c9e01c6", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -13,7 +13,7 @@ use hair::*;\n use rustc::mir::repr::*;\n use rustc::hir;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn ast_block(&mut self,\n                      destination: &Lvalue<'tcx>,\n                      // FIXME(#32959): temporary measure for the issue"}, {"sha": "a08d14d9e20564b3f9bab9465afb022385d79a50", "filename": "src/librustc_mir/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -14,7 +14,7 @@ use build::Builder;\n use hair::*;\n use rustc::mir::repr::*;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr`, yielding a compile-time constant. Assumes that\n     /// `expr` is a valid compile-time constant!\n     pub fn as_constant<M>(&mut self, expr: M) -> Constant<'tcx>"}, {"sha": "15ea3f0e6e8675ce065c509277ce58cb01cdb398", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -15,7 +15,7 @@ use build::expr::category::Category;\n use hair::*;\n use rustc::mir::repr::*;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr`, yielding an lvalue that we can move from etc.\n     pub fn as_lvalue<M>(&mut self,\n                         block: BasicBlock,"}, {"sha": "a059f2bdde9c733608dd56dd708feea84e8775fd", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -15,7 +15,7 @@ use build::expr::category::Category;\n use hair::*;\n use rustc::mir::repr::*;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr` into a value that can be used as an operand.\n     /// If `expr` is an lvalue like `x`, this will introduce a\n     /// temporary `tmp = x`, so that we capture the value of `x` at"}, {"sha": "2a73346240898fc89282223fb801d7edbb94c158", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -17,7 +17,7 @@ use build::expr::category::{Category, RvalueFunc};\n use hair::*;\n use rustc::mir::repr::*;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr`, yielding an rvalue.\n     pub fn as_rvalue<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Rvalue<'tcx>>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>"}, {"sha": "38d32ec6777e08d62ede1e7b5d7133239441eae6", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -15,7 +15,7 @@ use build::expr::category::Category;\n use hair::*;\n use rustc::mir::repr::*;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr` into a fresh temporary. This is used when building\n     /// up rvalues so as to freeze the value that will be consumed.\n     pub fn as_temp<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Lvalue<'tcx>>"}, {"sha": "41610c90377b52af4119c22ffae705d7e4b3d164", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -16,7 +16,7 @@ use hair::*;\n use rustc::ty;\n use rustc::mir::repr::*;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n     /// is assumed to be uninitialized.\n     pub fn into_expr(&mut self,"}, {"sha": "9629396f48b50f1274b364e7021ade9a835d20af", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -15,7 +15,7 @@ use rustc::middle::region::CodeExtent;\n use rustc::mir::repr::*;\n use syntax::codemap::Span;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     pub fn stmt_expr(&mut self, mut block: BasicBlock, expr: Expr<'tcx>) -> BlockAnd<()> {\n         let this = self;"}, {"sha": "17ccb701c2b7a2acbdf392917d656cd08c9cad27", "filename": "src/librustc_mir/build/into.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Finto.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -19,14 +19,14 @@ use hair::*;\n use rustc::mir::repr::*;\n \n pub trait EvalInto<'tcx> {\n-    fn eval_into<'a>(self,\n-                     builder: &mut Builder<'a, 'tcx>,\n-                     destination: &Lvalue<'tcx>,\n-                     block: BasicBlock)\n-                     -> BlockAnd<()>;\n+    fn eval_into<'a, 'gcx>(self,\n+                           builder: &mut Builder<'a, 'gcx, 'tcx>,\n+                           destination: &Lvalue<'tcx>,\n+                           block: BasicBlock)\n+                           -> BlockAnd<()>;\n }\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn into<E>(&mut self,\n                    destination: &Lvalue<'tcx>,\n                    block: BasicBlock,\n@@ -39,22 +39,22 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n }\n \n impl<'tcx> EvalInto<'tcx> for ExprRef<'tcx> {\n-    fn eval_into<'a>(self,\n-                     builder: &mut Builder<'a, 'tcx>,\n-                     destination: &Lvalue<'tcx>,\n-                     block: BasicBlock)\n-                     -> BlockAnd<()> {\n+    fn eval_into<'a, 'gcx>(self,\n+                           builder: &mut Builder<'a, 'gcx, 'tcx>,\n+                           destination: &Lvalue<'tcx>,\n+                           block: BasicBlock)\n+                           -> BlockAnd<()> {\n         let expr = builder.hir.mirror(self);\n         builder.into_expr(destination, block, expr)\n     }\n }\n \n impl<'tcx> EvalInto<'tcx> for Expr<'tcx> {\n-    fn eval_into<'a>(self,\n-                     builder: &mut Builder<'a, 'tcx>,\n-                     destination: &Lvalue<'tcx>,\n-                     block: BasicBlock)\n-                     -> BlockAnd<()> {\n+    fn eval_into<'a, 'gcx>(self,\n+                           builder: &mut Builder<'a, 'gcx, 'tcx>,\n+                           destination: &Lvalue<'tcx>,\n+                           block: BasicBlock)\n+                           -> BlockAnd<()> {\n         builder.into_expr(destination, block, self)\n     }\n }"}, {"sha": "c1a0e1f9a6900b622122e2b153cce60180a30eed", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -27,7 +27,7 @@ mod simplify;\n mod test;\n mod util;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn match_expr(&mut self,\n                       destination: &Lvalue<'tcx>,\n                       span: Span,\n@@ -304,7 +304,7 @@ pub struct Test<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Main matching algorithm\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// The main match algorithm. It begins with a set of candidates\n     /// `candidates` and has the job of generating code to determine\n     /// which of these candidates, if any, is the correct one. The"}, {"sha": "c707bb8a27b6f53983e7eececd0c78bfc93cbf0d", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -29,7 +29,7 @@ use rustc::mir::repr::*;\n \n use std::mem;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn simplify_candidate<'pat>(&mut self,\n                                     mut block: BasicBlock,\n                                     candidate: &mut Candidate<'pat, 'tcx>)"}, {"sha": "e53584a3f8b11ee42b733572caaa30f1b1da8631", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -24,7 +24,7 @@ use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n use syntax::codemap::Span;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Identifies what test is needed to decide if `match_pair` is applicable.\n     ///\n     /// It is a bug to call this with a simplifyable pattern."}, {"sha": "5eb58f7612d744c5b9e38943bd5d1020190751a2", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -14,7 +14,7 @@ use hair::*;\n use rustc::mir::repr::*;\n use std::u32;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn field_match_pairs<'pat>(&mut self,\n                                    lvalue: Lvalue<'tcx>,\n                                    subpatterns: &'pat [FieldPattern<'tcx>])"}, {"sha": "7317c6f9b31336149a0a54acb83206a4a59653d1", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -17,7 +17,7 @@ use rustc::mir::repr::*;\n use std::u32;\n use syntax::codemap::Span;\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Add a new temporary value of type `ty` storing the result of\n     /// evaluating `expr`.\n     ///"}, {"sha": "77499a0f96cde47efb3c87f3b047db16efea6b75", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -21,8 +21,8 @@ use syntax::ast;\n use syntax::codemap::Span;\n use syntax::parse::token::keywords;\n \n-pub struct Builder<'a, 'tcx: 'a> {\n-    hir: Cx<'a, 'tcx>,\n+pub struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    hir: Cx<'a, 'gcx, 'tcx>,\n     cfg: CFG<'tcx>,\n \n     fn_span: Span,\n@@ -160,13 +160,13 @@ macro_rules! unpack {\n ///////////////////////////////////////////////////////////////////////////\n /// the main entry point for building MIR for a function\n \n-pub fn construct_fn<'a, 'tcx, A>(hir: Cx<'a,'tcx>,\n-                                 fn_id: ast::NodeId,\n-                                 arguments: A,\n-                                 return_ty: ty::FnOutput<'tcx>,\n-                                 ast_block: &'tcx hir::Block)\n-                                 -> (Mir<'tcx>, ScopeAuxiliaryVec)\n-    where A: Iterator<Item=(Ty<'tcx>, Option<&'tcx hir::Pat>)>\n+pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n+                                       fn_id: ast::NodeId,\n+                                       arguments: A,\n+                                       return_ty: ty::FnOutput<'gcx>,\n+                                       ast_block: &'gcx hir::Block)\n+                                       -> (Mir<'tcx>, ScopeAuxiliaryVec)\n+    where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n {\n     let tcx = hir.tcx();\n     let span = tcx.map.span(fn_id);\n@@ -232,10 +232,10 @@ pub fn construct_fn<'a, 'tcx, A>(hir: Cx<'a,'tcx>,\n     builder.finish(upvar_decls, arg_decls, return_ty)\n }\n \n-pub fn construct_const<'a, 'tcx>(hir: Cx<'a,'tcx>,\n-                                 item_id: ast::NodeId,\n-                                 ast_expr: &'tcx hir::Expr)\n-                                 -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n+pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n+                                       item_id: ast::NodeId,\n+                                       ast_expr: &'tcx hir::Expr)\n+                                       -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n     let tcx = hir.tcx();\n     let span = tcx.map.span(item_id);\n     let mut builder = Builder::new(hir, span);\n@@ -259,8 +259,8 @@ pub fn construct_const<'a, 'tcx>(hir: Cx<'a,'tcx>,\n     builder.finish(vec![], vec![], ty::FnConverging(ty))\n }\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n-    fn new(hir: Cx<'a, 'tcx>, span: Span) -> Builder<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n+    fn new(hir: Cx<'a, 'gcx, 'tcx>, span: Span) -> Builder<'a, 'gcx, 'tcx> {\n         let mut builder = Builder {\n             hir: hir,\n             cfg: CFG { basic_blocks: vec![] },\n@@ -311,9 +311,9 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                         return_ty: ty::FnOutput<'tcx>,\n                         arguments: A,\n                         argument_scope_id: ScopeId,\n-                        ast_block: &'tcx hir::Block)\n+                        ast_block: &'gcx hir::Block)\n                         -> BlockAnd<Vec<ArgDecl<'tcx>>>\n-        where A: Iterator<Item=(Ty<'tcx>, Option<&'tcx hir::Pat>)>\n+        where A: Iterator<Item=(Ty<'gcx>, Option<&'gcx hir::Pat>)>\n     {\n         // to start, translate the argument patterns and collect the argument types.\n         let arg_decls = arguments.enumerate().map(|(index, (ty, pattern))| {"}, {"sha": "071c8d618c845faaccd32bf643ab5da874ac3285", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -206,7 +206,7 @@ impl<'tcx> Scope<'tcx> {\n     }\n }\n \n-impl<'a,'tcx> Builder<'a,'tcx> {\n+impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     // Adding and removing scopes\n     // ==========================\n     /// Start a loop scope, which tracks where `continue` and `break`\n@@ -218,7 +218,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                break_block: BasicBlock,\n                                f: F)\n                                -> bool\n-        where F: FnOnce(&mut Builder<'a, 'tcx>)\n+        where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>)\n     {\n         let extent = self.extent_of_innermost_scope();\n         let loop_scope = LoopScope {\n@@ -237,7 +237,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// Convenience wrapper that pushes a scope and then executes `f`\n     /// to build its contents, popping the scope afterwards.\n     pub fn in_scope<F, R>(&mut self, extent: CodeExtent, mut block: BasicBlock, f: F) -> BlockAnd<R>\n-        where F: FnOnce(&mut Builder<'a, 'tcx>, ScopeId) -> BlockAnd<R>\n+        where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>, ScopeId) -> BlockAnd<R>\n     {\n         debug!(\"in_scope(extent={:?}, block={:?})\", extent, block);\n         let id = self.push_scope(extent, block);\n@@ -662,12 +662,12 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n     block.unit()\n }\n \n-fn build_diverge_scope<'tcx>(tcx: &TyCtxt<'tcx>,\n-                             cfg: &mut CFG<'tcx>,\n-                             unit_temp: &Lvalue<'tcx>,\n-                             scope: &mut Scope<'tcx>,\n-                             mut target: BasicBlock)\n-                             -> BasicBlock\n+fn build_diverge_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                       cfg: &mut CFG<'tcx>,\n+                                       unit_temp: &Lvalue<'tcx>,\n+                                       scope: &mut Scope<'tcx>,\n+                                       mut target: BasicBlock)\n+                                       -> BasicBlock\n {\n     // Build up the drops in **reverse** order. The end result will\n     // look like:\n@@ -721,11 +721,11 @@ fn build_diverge_scope<'tcx>(tcx: &TyCtxt<'tcx>,\n     target\n }\n \n-fn build_free<'tcx>(tcx: &TyCtxt<'tcx>,\n-                    unit_temp: &Lvalue<'tcx>,\n-                    data: &FreeData<'tcx>,\n-                    target: BasicBlock)\n-                    -> TerminatorKind<'tcx> {\n+fn build_free<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                              unit_temp: &Lvalue<'tcx>,\n+                              data: &FreeData<'tcx>,\n+                              target: BasicBlock)\n+                              -> TerminatorKind<'tcx> {\n     let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n                        .unwrap_or_else(|e| tcx.sess.fatal(&e));\n     let substs = tcx.mk_substs(Substs::new("}, {"sha": "6a34d9ff0b4c4ed1cdfda7474bb6569efafb802d", "filename": "src/librustc_mir/graphviz.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -10,13 +10,15 @@\n \n use dot;\n use rustc::mir::repr::*;\n-use rustc::ty;\n+use rustc::ty::{self, TyCtxt};\n use std::fmt::Debug;\n use std::io::{self, Write};\n use syntax::ast::NodeId;\n \n /// Write a graphviz DOT graph of a list of MIRs.\n-pub fn write_mir_graphviz<'a, 't, W, I>(tcx: &ty::TyCtxt<'t>, iter: I, w: &mut W) -> io::Result<()>\n+pub fn write_mir_graphviz<'a, 'b, 'tcx, W, I>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n+                                              iter: I, w: &mut W)\n+                                              -> io::Result<()>\n where W: Write, I: Iterator<Item=(&'a NodeId, &'a Mir<'a>)> {\n     for (&nodeid, mir) in iter {\n         writeln!(w, \"digraph Mir_{} {{\", nodeid)?;\n@@ -116,8 +118,11 @@ fn write_edges<W: Write>(source: BasicBlock, mir: &Mir, w: &mut W) -> io::Result\n /// Write the graphviz DOT label for the overall graph. This is essentially a block of text that\n /// will appear below the graph, showing the type of the `fn` this MIR represents and the types of\n /// all the variables and temporaries.\n-fn write_graph_label<W: Write>(tcx: &ty::TyCtxt, nid: NodeId, mir: &Mir, w: &mut W)\n--> io::Result<()> {\n+fn write_graph_label<'a, 'tcx, W: Write>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                         nid: NodeId,\n+                                         mir: &Mir,\n+                                         w: &mut W)\n+                                         -> io::Result<()> {\n     write!(w, \"    label=<fn {}(\", dot::escape_html(&tcx.node_path_str(nid)))?;\n \n     // fn argument types."}, {"sha": "52d54f2cc85724db2203964e0dfa6800115c320f", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -18,7 +18,7 @@ use syntax::ast;\n impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n     type Output = Block<'tcx>;\n \n-    fn make_mirror<'a>(self, cx: &mut Cx<'a, 'tcx>) -> Block<'tcx> {\n+    fn make_mirror<'a, 'gcx>(self, cx: &mut Cx<'a, 'gcx, 'tcx>) -> Block<'tcx> {\n         // We have to eagerly translate the \"spine\" of the statements\n         // in order to get the lexical scoping correctly.\n         let stmts = mirror_stmts(cx, self.id, &*self.stmts);\n@@ -31,10 +31,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n     }\n }\n \n-fn mirror_stmts<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n-                            block_id: ast::NodeId,\n-                            stmts: &'tcx [hir::Stmt])\n-                            -> Vec<StmtRef<'tcx>>\n+fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                                block_id: ast::NodeId,\n+                                stmts: &'tcx [hir::Stmt])\n+                                -> Vec<StmtRef<'tcx>>\n {\n     let mut result = vec![];\n     for (index, stmt) in stmts.iter().enumerate() {\n@@ -74,7 +74,9 @@ fn mirror_stmts<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n     return result;\n }\n \n-pub fn to_expr_ref<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, block: &'tcx hir::Block) -> ExprRef<'tcx> {\n+pub fn to_expr_ref<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                                   block: &'tcx hir::Block)\n+                                   -> ExprRef<'tcx> {\n     let block_ty = cx.tcx.node_id_to_type(block.id);\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(block.id);\n     let expr = Expr {"}, {"sha": "1e7164a62c070d8ea2020ea2b9a4fbd8b17947e5", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 45, "deletions": 38, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -29,7 +29,7 @@ use syntax::ptr::P;\n impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     type Output = Expr<'tcx>;\n \n-    fn make_mirror<'a>(self, cx: &mut Cx<'a, 'tcx>) -> Expr<'tcx> {\n+    fn make_mirror<'a, 'gcx>(self, cx: &mut Cx<'a, 'gcx, 'tcx>) -> Expr<'tcx> {\n         let temp_lifetime = cx.tcx.region_maps.temporary_scope(self.id);\n         let expr_extent = cx.tcx.region_maps.node_extent(self.id);\n \n@@ -202,7 +202,9 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     }\n }\n \n-fn make_mirror_unadjusted<'a, 'tcx>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr) -> Expr<'tcx> {\n+fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                                          expr: &'tcx hir::Expr)\n+                                          -> Expr<'tcx> {\n     let expr_ty = cx.tcx.expr_ty(expr);\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n \n@@ -273,7 +275,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr\n                     })\n                 } else { None };\n                 if let Some((adt_def, index)) = adt_data {\n-                    let substs = cx.tcx.mk_substs(cx.tcx.node_id_item_substs(fun.id).substs);\n+                    let substs = cx.tcx.node_id_item_substs(fun.id).substs;\n                     let field_refs = args.iter().enumerate().map(|(idx, e)| FieldExprRef {\n                         name: Field::new(idx),\n                         expr: e.to_ref()\n@@ -504,7 +506,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr\n         hir::ExprClosure(..) => {\n             let closure_ty = cx.tcx.expr_ty(expr);\n             let (def_id, substs) = match closure_ty.sty {\n-                ty::TyClosure(def_id, ref substs) => (def_id, substs),\n+                ty::TyClosure(def_id, substs) => (def_id, substs),\n                 _ => {\n                     span_bug!(expr.span,\n                               \"closure expr w/o closure type: {:?}\",\n@@ -519,7 +521,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr\n             });\n             ExprKind::Closure {\n                 closure_id: def_id,\n-                substs: &substs,\n+                substs: substs,\n                 upvars: upvars,\n             }\n         }\n@@ -543,7 +545,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr\n             count: TypedConstVal {\n                 ty: cx.tcx.expr_ty(c),\n                 span: c.span,\n-                value: match const_eval::eval_const_expr(cx.tcx, c) {\n+                value: match const_eval::eval_const_expr(cx.tcx.global_tcx(), c) {\n                     ConstVal::Integral(ConstInt::Usize(u)) => u,\n                     other => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n                 },\n@@ -620,10 +622,10 @@ fn make_mirror_unadjusted<'a, 'tcx>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr\n     }\n }\n \n-fn method_callee<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n-                               expr: &hir::Expr,\n-                               method_call: ty::MethodCall)\n-                               -> Expr<'tcx> {\n+fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                                 expr: &hir::Expr,\n+                                 method_call: ty::MethodCall)\n+                                 -> Expr<'tcx> {\n     let tables = cx.tcx.tables.borrow();\n     let callee = &tables.method_map[&method_call];\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n@@ -647,7 +649,8 @@ fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n     }\n }\n \n-fn convert_arm<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n+fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                               arm: &'tcx hir::Arm) -> Arm<'tcx> {\n     let mut map;\n     let opt_map = if arm.pats.len() == 1 {\n         None\n@@ -666,8 +669,10 @@ fn convert_arm<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, arm: &'tcx hir::Arm) -> Arm<\n     }\n }\n \n-fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr) -> ExprKind<'tcx> {\n-    let substs = cx.tcx.mk_substs(cx.tcx.node_id_item_substs(expr.id).substs);\n+fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                                     expr: &'tcx hir::Expr)\n+                                     -> ExprKind<'tcx> {\n+    let substs = cx.tcx.node_id_item_substs(expr.id).substs;\n     // Otherwise there may be def_map borrow conflicts\n     let def = cx.tcx.def_map.borrow()[&expr.id].full_def();\n     let def_id = match def {\n@@ -709,7 +714,8 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n         Def::Const(def_id) |\n         Def::AssociatedConst(def_id) => {\n             let substs = Some(cx.tcx.node_id_item_substs(expr.id).substs);\n-            if let Some((e, _)) = const_eval::lookup_const_by_id(cx.tcx, def_id, substs) {\n+            let tcx = cx.tcx.global_tcx();\n+            if let Some((e, _)) = const_eval::lookup_const_by_id(tcx, def_id, substs) {\n                 // FIXME ConstVal can't be yet used with adjustments, as they would be lost.\n                 if !cx.tcx.tables.borrow().adjustments.contains_key(&e.id) {\n                     if let Some(v) = cx.try_const_eval_literal(e) {\n@@ -738,10 +744,10 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n     }\n }\n \n-fn convert_var<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n-                             expr: &'tcx hir::Expr,\n-                             def: Def)\n-                             -> ExprKind<'tcx> {\n+fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                               expr: &'tcx hir::Expr,\n+                               def: Def)\n+                               -> ExprKind<'tcx> {\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n \n     match def {\n@@ -903,13 +909,13 @@ enum PassArgs {\n     ByRef,\n }\n \n-fn overloaded_operator<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n-                                     expr: &'tcx hir::Expr,\n-                                     method_call: ty::MethodCall,\n-                                     pass_args: PassArgs,\n-                                     receiver: ExprRef<'tcx>,\n-                                     args: Vec<&'tcx P<hir::Expr>>)\n-                                     -> ExprKind<'tcx> {\n+fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                                       expr: &'tcx hir::Expr,\n+                                       method_call: ty::MethodCall,\n+                                       pass_args: PassArgs,\n+                                       receiver: ExprRef<'tcx>,\n+                                       args: Vec<&'tcx P<hir::Expr>>)\n+                                       -> ExprKind<'tcx> {\n     // the receiver has all the adjustments that are needed, so we can\n     // just push a reference to it\n     let mut argrefs = vec![receiver];\n@@ -954,13 +960,13 @@ fn overloaded_operator<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n     }\n }\n \n-fn overloaded_lvalue<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n-                                   expr: &'tcx hir::Expr,\n-                                   method_call: ty::MethodCall,\n-                                   pass_args: PassArgs,\n-                                   receiver: ExprRef<'tcx>,\n-                                   args: Vec<&'tcx P<hir::Expr>>)\n-                                   -> ExprKind<'tcx> {\n+fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                                     expr: &'tcx hir::Expr,\n+                                     method_call: ty::MethodCall,\n+                                     pass_args: PassArgs,\n+                                     receiver: ExprRef<'tcx>,\n+                                     args: Vec<&'tcx P<hir::Expr>>)\n+                                     -> ExprKind<'tcx> {\n     // For an overloaded *x or x[y] expression of type T, the method\n     // call returns an &T and we must add the deref so that the types\n     // line up (this is because `*x` and `x[y]` represent lvalues):\n@@ -989,11 +995,11 @@ fn overloaded_lvalue<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n     ExprKind::Deref { arg: ref_expr.to_ref() }\n }\n \n-fn capture_freevar<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n-                                 closure_expr: &'tcx hir::Expr,\n-                                 freevar: &hir::Freevar,\n-                                 freevar_ty: Ty<'tcx>)\n-                                 -> ExprRef<'tcx> {\n+fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                                   closure_expr: &'tcx hir::Expr,\n+                                   freevar: &hir::Freevar,\n+                                   freevar_ty: Ty<'tcx>)\n+                                   -> ExprRef<'tcx> {\n     let id_var = freevar.def.var_id();\n     let upvar_id = ty::UpvarId {\n         var_id: id_var,\n@@ -1030,7 +1036,8 @@ fn capture_freevar<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n     }\n }\n \n-fn loop_label<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr) -> CodeExtent {\n+fn loop_label<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+                              expr: &'tcx hir::Expr) -> CodeExtent {\n     match cx.tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def()) {\n         Some(Def::Label(loop_id)) => cx.tcx.region_maps.node_extent(loop_id),\n         d => {"}, {"sha": "fad6cfb7ae1aab784d84ebf4f603deddf5d674b2", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -29,16 +29,16 @@ use rustc::hir;\n use rustc_const_math::{ConstInt, ConstUsize};\n \n #[derive(Copy, Clone)]\n-pub struct Cx<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+pub struct Cx<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     constness: hir::Constness\n }\n \n-impl<'a,'tcx> Cx<'a,'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>,\n+impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n                constness: hir::Constness)\n-               -> Cx<'a, 'tcx> {\n+               -> Cx<'a, 'gcx, 'tcx> {\n         Cx {\n             tcx: infcx.tcx,\n             infcx: infcx,\n@@ -47,7 +47,7 @@ impl<'a,'tcx> Cx<'a,'tcx> {\n     }\n }\n \n-impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     /// Normalizes `ast` into the appropriate `mirror` type.\n     pub fn mirror<M: Mirror<'tcx>>(&mut self, ast: M) -> M::Output {\n         ast.make_mirror(self)\n@@ -85,12 +85,15 @@ impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n     }\n \n     pub fn const_eval_literal(&mut self, e: &hir::Expr) -> Literal<'tcx> {\n-        Literal::Value { value: const_eval::eval_const_expr(self.tcx, e) }\n+        Literal::Value {\n+            value: const_eval::eval_const_expr(self.tcx.global_tcx(), e)\n+        }\n     }\n \n     pub fn try_const_eval_literal(&mut self, e: &hir::Expr) -> Option<Literal<'tcx>> {\n         let hint = const_eval::EvalHint::ExprTypeChecked;\n-        const_eval::eval_const_expr_partial(self.tcx, e, hint, None).ok().and_then(|v| {\n+        let tcx = self.tcx.global_tcx();\n+        const_eval::eval_const_expr_partial(tcx, e, hint, None).ok().and_then(|v| {\n             match v {\n                 // All of these contain local IDs, unsuitable for storing in MIR.\n                 ConstVal::Struct(_) | ConstVal::Tuple(_) |\n@@ -130,21 +133,25 @@ impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n         bug!(\"found no method `{}` in `{:?}`\", method_name, trait_def_id);\n     }\n \n-    pub fn num_variants(&mut self, adt_def: ty::AdtDef<'tcx>) -> usize {\n+    pub fn num_variants(&mut self, adt_def: ty::AdtDef) -> usize {\n         adt_def.variants.len()\n     }\n \n-    pub fn all_fields(&mut self, adt_def: ty::AdtDef<'tcx>, variant_index: usize) -> Vec<Field> {\n+    pub fn all_fields(&mut self, adt_def: ty::AdtDef, variant_index: usize) -> Vec<Field> {\n         (0..adt_def.variants[variant_index].fields.len())\n             .map(Field::new)\n             .collect()\n     }\n \n     pub fn needs_drop(&mut self, ty: Ty<'tcx>) -> bool {\n+        let ty = self.tcx.lift_to_global(&ty).unwrap_or_else(|| {\n+            bug!(\"MIR: Cx::needs_drop({}) got \\\n+                  type with inference types/regions\", ty);\n+        });\n         self.tcx.type_needs_drop_given_env(ty, &self.infcx.parameter_environment)\n     }\n \n-    pub fn tcx(&self) -> &'a TyCtxt<'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.tcx\n     }\n }"}, {"sha": "9e08e7b62d3bf9e6fe9baefea30aa2ef72375c5f", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -34,12 +34,12 @@ use syntax::ptr::P;\n ///    _ => { ... }\n /// }\n /// ```\n-struct PatCx<'patcx, 'cx: 'patcx, 'tcx: 'cx> {\n-    cx: &'patcx mut Cx<'cx, 'tcx>,\n+struct PatCx<'patcx, 'cx: 'patcx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n+    cx: &'patcx mut Cx<'cx, 'gcx, 'tcx>,\n     binding_map: Option<&'patcx FnvHashMap<ast::Name, ast::NodeId>>,\n }\n \n-impl<'cx, 'tcx> Cx<'cx, 'tcx> {\n+impl<'cx, 'gcx, 'tcx> Cx<'cx, 'gcx, 'tcx> {\n     pub fn irrefutable_pat(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n         PatCx::new(self, None).to_pattern(pat)\n     }\n@@ -52,10 +52,10 @@ impl<'cx, 'tcx> Cx<'cx, 'tcx> {\n     }\n }\n \n-impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n-    fn new(cx: &'patcx mut Cx<'cx, 'tcx>,\n+impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n+    fn new(cx: &'patcx mut Cx<'cx, 'gcx, 'tcx>,\n                binding_map: Option<&'patcx FnvHashMap<ast::Name, ast::NodeId>>)\n-               -> PatCx<'patcx, 'cx, 'tcx> {\n+               -> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n         PatCx {\n             cx: cx,\n             binding_map: binding_map,\n@@ -69,14 +69,14 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n             PatKind::Wild => PatternKind::Wild,\n \n             PatKind::Lit(ref value) => {\n-                let value = const_eval::eval_const_expr(self.cx.tcx, value);\n+                let value = const_eval::eval_const_expr(self.cx.tcx.global_tcx(), value);\n                 PatternKind::Constant { value: value }\n             }\n \n             PatKind::Range(ref lo, ref hi) => {\n-                let lo = const_eval::eval_const_expr(self.cx.tcx, lo);\n+                let lo = const_eval::eval_const_expr(self.cx.tcx.global_tcx(), lo);\n                 let lo = Literal::Value { value: lo };\n-                let hi = const_eval::eval_const_expr(self.cx.tcx, hi);\n+                let hi = const_eval::eval_const_expr(self.cx.tcx.global_tcx(), hi);\n                 let hi = Literal::Value { value: hi };\n                 PatternKind::Range { lo: lo, hi: hi }\n             },\n@@ -87,10 +87,11 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                 let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n                 match def {\n                     Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n+                        let tcx = self.cx.tcx.global_tcx();\n                         let substs = Some(self.cx.tcx.node_id_item_substs(pat.id).substs);\n-                        match const_eval::lookup_const_by_id(self.cx.tcx, def_id, substs) {\n+                        match const_eval::lookup_const_by_id(tcx, def_id, substs) {\n                             Some((const_expr, _const_ty)) => {\n-                                match const_eval::const_expr_to_pat(self.cx.tcx,\n+                                match const_eval::const_expr_to_pat(tcx,\n                                                                     const_expr,\n                                                                     pat.id,\n                                                                     pat.span) {"}, {"sha": "020fbb6fcd19c66bb0aae0105a90fbfddb7c12fe", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -222,7 +222,7 @@ pub enum ExprKind<'tcx> {\n     },\n     Closure {\n         closure_id: DefId,\n-        substs: &'tcx ClosureSubsts<'tcx>,\n+        substs: ClosureSubsts<'tcx>,\n         upvars: Vec<ExprRef<'tcx>>,\n     },\n     Literal {\n@@ -358,21 +358,21 @@ pub struct FieldPattern<'tcx> {\n pub trait Mirror<'tcx> {\n     type Output;\n \n-    fn make_mirror<'a>(self, cx: &mut Cx<'a, 'tcx>) -> Self::Output;\n+    fn make_mirror<'a, 'gcx>(self, cx: &mut Cx<'a, 'gcx, 'tcx>) -> Self::Output;\n }\n \n impl<'tcx> Mirror<'tcx> for Expr<'tcx> {\n     type Output = Expr<'tcx>;\n \n-    fn make_mirror<'a>(self, _: &mut Cx<'a, 'tcx>) -> Expr<'tcx> {\n+    fn make_mirror<'a, 'gcx>(self, _: &mut Cx<'a, 'gcx, 'tcx>) -> Expr<'tcx> {\n         self\n     }\n }\n \n impl<'tcx> Mirror<'tcx> for ExprRef<'tcx> {\n     type Output = Expr<'tcx>;\n \n-    fn make_mirror<'a>(self, hir: &mut Cx<'a, 'tcx>) -> Expr<'tcx> {\n+    fn make_mirror<'a, 'gcx>(self, hir: &mut Cx<'a, 'gcx, 'tcx>) -> Expr<'tcx> {\n         match self {\n             ExprRef::Hair(h) => h.make_mirror(hir),\n             ExprRef::Mirror(m) => *m,\n@@ -383,15 +383,15 @@ impl<'tcx> Mirror<'tcx> for ExprRef<'tcx> {\n impl<'tcx> Mirror<'tcx> for Stmt<'tcx> {\n     type Output = Stmt<'tcx>;\n \n-    fn make_mirror<'a>(self, _: &mut Cx<'a, 'tcx>) -> Stmt<'tcx> {\n+    fn make_mirror<'a, 'gcx>(self, _: &mut Cx<'a, 'gcx, 'tcx>) -> Stmt<'tcx> {\n         self\n     }\n }\n \n impl<'tcx> Mirror<'tcx> for StmtRef<'tcx> {\n     type Output = Stmt<'tcx>;\n \n-    fn make_mirror<'a>(self, _: &mut Cx<'a,'tcx>) -> Stmt<'tcx> {\n+    fn make_mirror<'a, 'gcx>(self, _: &mut Cx<'a, 'gcx, 'tcx>) -> Stmt<'tcx> {\n         match self {\n             StmtRef::Mirror(m) => *m,\n         }\n@@ -401,7 +401,7 @@ impl<'tcx> Mirror<'tcx> for StmtRef<'tcx> {\n impl<'tcx> Mirror<'tcx> for Block<'tcx> {\n     type Output = Block<'tcx>;\n \n-    fn make_mirror<'a>(self, _: &mut Cx<'a, 'tcx>) -> Block<'tcx> {\n+    fn make_mirror<'a, 'gcx>(self, _: &mut Cx<'a, 'gcx, 'tcx>) -> Block<'tcx> {\n         self\n     }\n }"}, {"sha": "73cfdeda74a885ab14e4f9a89af6789acc50d350", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 100, "deletions": 35, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -20,21 +20,25 @@ use build;\n use rustc::dep_graph::DepNode;\n use rustc::mir::repr::Mir;\n use rustc::mir::transform::MirSource;\n+use rustc::mir::visit::MutVisitor;\n use pretty;\n use hair::cx::Cx;\n \n use rustc::mir::mir_map::MirMap;\n-use rustc::infer;\n+use rustc::infer::InferCtxtBuilder;\n use rustc::traits::ProjectionMode;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::subst::Substs;\n use rustc::util::nodemap::NodeMap;\n use rustc::hir;\n use rustc::hir::intravisit::{self, FnKind, Visitor};\n use rustc::hir::map::blocks::FnLikeNode;\n use syntax::ast;\n use syntax::codemap::Span;\n \n-pub fn build_mir_for_crate<'tcx>(tcx: &TyCtxt<'tcx>) -> MirMap<'tcx> {\n+use std::mem;\n+\n+pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MirMap<'tcx> {\n     let mut map = MirMap {\n         map: NodeMap(),\n     };\n@@ -48,54 +52,115 @@ pub fn build_mir_for_crate<'tcx>(tcx: &TyCtxt<'tcx>) -> MirMap<'tcx> {\n     map\n }\n \n+/// A pass to lift all the types and substitutions in a Mir\n+/// to the global tcx. Sadly, we don't have a \"folder\" that\n+/// can change 'tcx so we have to transmute afterwards.\n+struct GlobalizeMir<'a, 'gcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+    span: Span\n+}\n+\n+impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n+    fn visit_ty(&mut self, ty: &mut Ty<'tcx>) {\n+        if let Some(lifted) = self.tcx.lift(ty) {\n+            *ty = lifted;\n+        } else {\n+            span_bug!(self.span,\n+                      \"found type `{:?}` with inference types/regions in MIR\",\n+                      ty);\n+        }\n+    }\n+\n+    fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>) {\n+        if let Some(lifted) = self.tcx.lift(substs) {\n+            *substs = lifted;\n+        } else {\n+            span_bug!(self.span,\n+                      \"found substs `{:?}` with inference types/regions in MIR\",\n+                      substs);\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n \n struct BuildMir<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     map: &'a mut MirMap<'tcx>,\n }\n \n-impl<'a, 'tcx> BuildMir<'a, 'tcx> {\n-    fn build<F>(&mut self, src: MirSource, f: F)\n-        where F: for<'b> FnOnce(Cx<'b, 'tcx>) -> (Mir<'tcx>, build::ScopeAuxiliaryVec)\n+/// Helper type of a temporary returned by BuildMir::cx(...).\n+/// Necessary because we can't write the following bound:\n+/// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(Cx<'b, 'gcx, 'tcx>).\n+struct CxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    src: MirSource,\n+    infcx: InferCtxtBuilder<'a, 'gcx, 'tcx>,\n+    map: &'a mut MirMap<'gcx>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> BuildMir<'a, 'gcx> {\n+    fn cx<'b>(&'b mut self, src: MirSource) -> CxBuilder<'b, 'gcx, 'tcx> {\n+        let param_env = ty::ParameterEnvironment::for_item(self.tcx, src.item_id());\n+        CxBuilder {\n+            src: src,\n+            infcx: self.tcx.infer_ctxt(None, Some(param_env), ProjectionMode::AnyFinal),\n+            map: self.map\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> CxBuilder<'a, 'gcx, 'tcx> {\n+    fn build<F>(&'tcx mut self, f: F)\n+        where F: for<'b> FnOnce(Cx<'b, 'gcx, 'tcx>) -> (Mir<'tcx>, build::ScopeAuxiliaryVec)\n     {\n-        let constness = match src {\n-            MirSource::Const(_) |\n-            MirSource::Static(..) => hir::Constness::Const,\n-            MirSource::Fn(id) => {\n-                let fn_like = FnLikeNode::from_node(self.tcx.map.get(id));\n-                match fn_like.map(|f| f.kind()) {\n-                    Some(FnKind::ItemFn(_, _, _, c, _, _, _)) => c,\n-                    Some(FnKind::Method(_, m, _, _)) => m.constness,\n-                    _ => hir::Constness::NotConst\n+        let src = self.src;\n+        let mir = self.infcx.enter(|infcx| {\n+            let constness = match src {\n+                MirSource::Const(_) |\n+                MirSource::Static(..) => hir::Constness::Const,\n+                MirSource::Fn(id) => {\n+                    let fn_like = FnLikeNode::from_node(infcx.tcx.map.get(id));\n+                    match fn_like.map(|f| f.kind()) {\n+                        Some(FnKind::ItemFn(_, _, _, c, _, _, _)) => c,\n+                        Some(FnKind::Method(_, m, _, _)) => m.constness,\n+                        _ => hir::Constness::NotConst\n+                    }\n                 }\n-            }\n-            MirSource::Promoted(..) => bug!()\n-        };\n+                MirSource::Promoted(..) => bug!()\n+            };\n+            let (mut mir, scope_auxiliary) = f(Cx::new(&infcx, constness));\n \n-        let param_env = ty::ParameterEnvironment::for_item(self.tcx, src.item_id());\n-        let infcx = infer::new_infer_ctxt(self.tcx,\n-                                          &self.tcx.tables,\n-                                          Some(param_env),\n-                                          ProjectionMode::AnyFinal);\n+            // Convert the Mir to global types.\n+            let mut globalizer = GlobalizeMir {\n+                tcx: infcx.tcx.global_tcx(),\n+                span: mir.span\n+            };\n+            globalizer.visit_mir(&mut mir);\n+            let mir = unsafe {\n+                mem::transmute::<Mir, Mir<'gcx>>(mir)\n+            };\n \n-        let (mir, scope_auxiliary) = f(Cx::new(&infcx, constness));\n+            pretty::dump_mir(infcx.tcx.global_tcx(), \"mir_map\", &0,\n+                             src, &mir, Some(&scope_auxiliary));\n \n-        pretty::dump_mir(self.tcx, \"mir_map\", &0, src, &mir, Some(&scope_auxiliary));\n+            mir\n+        });\n \n         assert!(self.map.map.insert(src.item_id(), mir).is_none())\n     }\n+}\n \n-    fn build_const_integer(&mut self, expr: &'tcx hir::Expr) {\n+impl<'a, 'gcx> BuildMir<'a, 'gcx> {\n+    fn build_const_integer(&mut self, expr: &'gcx hir::Expr) {\n         // FIXME(eddyb) Closures should have separate\n         // function definition IDs and expression IDs.\n         // Type-checking should not let closures get\n         // this far in an integer constant position.\n         if let hir::ExprClosure(..) = expr.node {\n             return;\n         }\n-        self.build(MirSource::Const(expr.id), |cx| {\n+        self.cx(MirSource::Const(expr.id)).build(|cx| {\n             build::construct_const(cx, expr.id, expr)\n         });\n     }\n@@ -106,12 +171,12 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n             hir::ItemConst(_, ref expr) => {\n-                self.build(MirSource::Const(item.id), |cx| {\n+                self.cx(MirSource::Const(item.id)).build(|cx| {\n                     build::construct_const(cx, item.id, expr)\n                 });\n             }\n             hir::ItemStatic(_, m, ref expr) => {\n-                self.build(MirSource::Static(item.id, m), |cx| {\n+                self.cx(MirSource::Static(item.id, m)).build(|cx| {\n                     build::construct_const(cx, item.id, expr)\n                 });\n             }\n@@ -123,7 +188,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     // Trait associated const defaults.\n     fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n         if let hir::ConstTraitItem(_, Some(ref expr)) = item.node {\n-            self.build(MirSource::Const(item.id), |cx| {\n+            self.cx(MirSource::Const(item.id)).build(|cx| {\n                 build::construct_const(cx, item.id, expr)\n             });\n         }\n@@ -133,7 +198,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     // Impl associated const.\n     fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n         if let hir::ImplItemKind::Const(_, ref expr) = item.node {\n-            self.build(MirSource::Const(item.id), |cx| {\n+            self.cx(MirSource::Const(item.id)).build(|cx| {\n                 build::construct_const(cx, item.id, expr)\n             });\n         }\n@@ -181,7 +246,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n         };\n \n         let implicit_argument = if let FnKind::Closure(..) = fk {\n-            Some((closure_self_ty(&self.tcx, id, body.id), None))\n+            Some((closure_self_ty(self.tcx, id, body.id), None))\n         } else {\n             None\n         };\n@@ -194,16 +259,16 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n                     (fn_sig.inputs[index], Some(&*arg.pat))\n                 });\n \n-        self.build(MirSource::Fn(id), |cx| {\n-            let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n+        let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n+        self.cx(MirSource::Fn(id)).build(|cx| {\n             build::construct_fn(cx, id, arguments, fn_sig.output, body)\n         });\n \n         intravisit::walk_fn(self, fk, decl, body, span);\n     }\n }\n \n-fn closure_self_ty<'a, 'tcx>(tcx: &TyCtxt<'tcx>,\n+fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              closure_expr_id: ast::NodeId,\n                              body_id: ast::NodeId)\n                              -> Ty<'tcx> {"}, {"sha": "bf6689de236ce1ff240a394f56ac1ea6b1273fac", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -36,7 +36,7 @@ const INDENT: &'static str = \"    \";\n /// - `substring1&substring2,...` -- `&`-separated list of substrings\n ///   that can appear in the pass-name or the `item_path_str` for the given\n ///   node-id. If any one of the substrings match, the data is dumped out.\n-pub fn dump_mir<'a, 'tcx>(tcx: &TyCtxt<'tcx>,\n+pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           pass_name: &str,\n                           disambiguator: &Display,\n                           src: MirSource,\n@@ -73,10 +73,10 @@ pub fn dump_mir<'a, 'tcx>(tcx: &TyCtxt<'tcx>,\n }\n \n /// Write out a human-readable textual representation for the given MIR.\n-pub fn write_mir_pretty<'a, 'tcx, I>(tcx: &TyCtxt<'tcx>,\n-                                     iter: I,\n-                                     w: &mut Write)\n-                                     -> io::Result<()>\n+pub fn write_mir_pretty<'a, 'b, 'tcx, I>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n+                                         iter: I,\n+                                         w: &mut Write)\n+                                         -> io::Result<()>\n     where I: Iterator<Item=(&'a NodeId, &'a Mir<'tcx>)>, 'tcx: 'a\n {\n     for (&id, mir) in iter {\n@@ -95,12 +95,12 @@ enum Annotation {\n     ExitScope(ScopeId),\n }\n \n-pub fn write_mir_fn<'tcx>(tcx: &TyCtxt<'tcx>,\n-                          src: MirSource,\n-                          mir: &Mir<'tcx>,\n-                          w: &mut Write,\n-                          auxiliary: Option<&ScopeAuxiliaryVec>)\n-                          -> io::Result<()> {\n+pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              src: MirSource,\n+                              mir: &Mir<'tcx>,\n+                              w: &mut Write,\n+                              auxiliary: Option<&ScopeAuxiliaryVec>)\n+                              -> io::Result<()> {\n     // compute scope/entry exit annotations\n     let mut annotations = FnvHashMap();\n     if let Some(auxiliary) = auxiliary {\n@@ -138,7 +138,7 @@ pub fn write_mir_fn<'tcx>(tcx: &TyCtxt<'tcx>,\n }\n \n /// Write out a human-readable textual representation for the given basic block.\n-fn write_basic_block(tcx: &TyCtxt,\n+fn write_basic_block(tcx: TyCtxt,\n                      block: BasicBlock,\n                      mir: &Mir,\n                      w: &mut Write,\n@@ -182,14 +182,11 @@ fn write_basic_block(tcx: &TyCtxt,\n     writeln!(w, \"{}}}\", INDENT)\n }\n \n-fn comment(tcx: &TyCtxt,\n-           scope: ScopeId,\n-           span: Span)\n-           -> String {\n+fn comment(tcx: TyCtxt, scope: ScopeId, span: Span) -> String {\n     format!(\"Scope({}) at {}\", scope.index(), tcx.sess.codemap().span_to_string(span))\n }\n \n-fn write_scope_tree(tcx: &TyCtxt,\n+fn write_scope_tree(tcx: TyCtxt,\n                     mir: &Mir,\n                     auxiliary: Option<&ScopeAuxiliaryVec>,\n                     scope_tree: &FnvHashMap<Option<ScopeId>, Vec<ScopeId>>,\n@@ -222,8 +219,11 @@ fn write_scope_tree(tcx: &TyCtxt,\n \n /// Write out a human-readable textual representation of the MIR's `fn` type and the types of its\n /// local variables (both user-defined bindings and compiler temporaries).\n-fn write_mir_intro(tcx: &TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n-                   -> io::Result<()> {\n+fn write_mir_intro<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             src: MirSource,\n+                             mir: &Mir,\n+                             w: &mut Write)\n+                             -> io::Result<()> {\n     match src {\n         MirSource::Fn(_) => write!(w, \"fn\")?,\n         MirSource::Const(_) => write!(w, \"const\")?,"}, {"sha": "a6af30b7eec08e6cb83a0f9e497d3572242ec682", "filename": "src/librustc_mir/transform/break_critical_edges.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -42,7 +42,8 @@ pub struct BreakCriticalEdges;\n  */\n \n impl<'tcx> MirPass<'tcx> for BreakCriticalEdges {\n-    fn run_pass(&mut self, _: &TyCtxt<'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n+    fn run_pass<'a>(&mut self, _: TyCtxt<'a, 'tcx, 'tcx>,\n+                    _: MirSource, mir: &mut Mir<'tcx>) {\n         break_critical_edges(mir);\n     }\n }"}, {"sha": "485ca3ea84a7e8d2f093e58464781a0ed92522ec", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -19,11 +19,11 @@ use rustc::mir::visit::MutVisitor;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n \n struct EraseRegionsVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n impl<'a, 'tcx> EraseRegionsVisitor<'a, 'tcx> {\n-    pub fn new(tcx: &'a TyCtxt<'tcx>) -> Self {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n         EraseRegionsVisitor {\n             tcx: tcx\n         }\n@@ -37,7 +37,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n     }\n \n     fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>) {\n-        *substs = self.tcx.mk_substs(self.tcx.erase_regions(*substs));\n+        *substs = self.tcx.erase_regions(&{*substs});\n     }\n }\n \n@@ -46,7 +46,8 @@ pub struct EraseRegions;\n impl Pass for EraseRegions {}\n \n impl<'tcx> MirPass<'tcx> for EraseRegions {\n-    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    _: MirSource, mir: &mut Mir<'tcx>) {\n         EraseRegionsVisitor::new(tcx).visit_mir(mir);\n     }\n }"}, {"sha": "de05032fa558624e90f40206504bd942a1ca6db3", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -41,7 +41,8 @@ impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n }\n \n impl<'tcx> MirPass<'tcx> for NoLandingPads {\n-    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    _: MirSource, mir: &mut Mir<'tcx>) {\n         if tcx.sess.no_landing_pads() {\n             self.visit_mir(mir);\n         }"}, {"sha": "431568b004d3ddbda6ec75e2680e9c5efa18c8d2", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -330,10 +330,10 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n     }\n }\n \n-pub fn promote_candidates<'tcx>(mir: &mut Mir<'tcx>,\n-                                tcx: &TyCtxt<'tcx>,\n-                                mut temps: Vec<TempState>,\n-                                candidates: Vec<Candidate>) {\n+pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n+                                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                    mut temps: Vec<TempState>,\n+                                    candidates: Vec<Candidate>) {\n     // Visit candidates in reverse, in case they're nested.\n     for candidate in candidates.into_iter().rev() {\n         let (span, ty) = match candidate {"}, {"sha": "54ac04bea9c4cf8e98a2ba6015b4971b11db0d02", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -19,7 +19,6 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::FnKind;\n use rustc::hir::map::blocks::FnLikeNode;\n-use rustc::infer;\n use rustc::traits::{self, ProjectionMode};\n use rustc::ty::{self, TyCtxt, Ty};\n use rustc::ty::cast::CastTy;\n@@ -75,14 +74,15 @@ bitflags! {\n     }\n }\n \n-impl Qualif {\n+impl<'a, 'tcx> Qualif {\n     /// Remove flags which are impossible for the given type.\n-    fn restrict<'a, 'tcx>(&mut self, ty: Ty<'tcx>,\n-                          param_env: &ty::ParameterEnvironment<'a, 'tcx>) {\n-        if !ty.type_contents(param_env.tcx).interior_unsafe() {\n+    fn restrict(&mut self, ty: Ty<'tcx>,\n+                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                param_env: &ty::ParameterEnvironment<'tcx>) {\n+        if !ty.type_contents(tcx).interior_unsafe() {\n             *self = *self - Qualif::MUTABLE_INTERIOR;\n         }\n-        if !param_env.tcx.type_needs_drop_given_env(ty, param_env) {\n+        if !tcx.type_needs_drop_given_env(ty, param_env) {\n             *self = *self - Qualif::NEEDS_DROP;\n         }\n     }\n@@ -109,7 +109,7 @@ impl fmt::Display for Mode {\n     }\n }\n \n-fn is_const_fn(tcx: &TyCtxt, def_id: DefId) -> bool {\n+fn is_const_fn(tcx: TyCtxt, def_id: DefId) -> bool {\n     if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n         let fn_like = FnLikeNode::from_node(tcx.map.get(node_id));\n         match fn_like.map(|f| f.kind()) {\n@@ -126,14 +126,14 @@ fn is_const_fn(tcx: &TyCtxt, def_id: DefId) -> bool {\n     }\n }\n \n-struct Qualifier<'a, 'tcx: 'a> {\n+struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     mode: Mode,\n     span: Span,\n     def_id: DefId,\n     mir: &'a Mir<'tcx>,\n     rpo: ReversePostorder<'a, 'tcx>,\n-    tcx: &'a TyCtxt<'tcx>,\n-    param_env: ty::ParameterEnvironment<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    param_env: ty::ParameterEnvironment<'tcx>,\n     qualif_map: &'a mut DefIdMap<Qualif>,\n     mir_map: Option<&'a MirMap<'tcx>>,\n     temp_qualif: Vec<Option<Qualif>>,\n@@ -145,14 +145,15 @@ struct Qualifier<'a, 'tcx: 'a> {\n     promotion_candidates: Vec<Candidate>\n }\n \n-impl<'a, 'tcx> Qualifier<'a, 'tcx> {\n-    fn new(param_env: ty::ParameterEnvironment<'a, 'tcx>,\n+impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n+    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+           param_env: ty::ParameterEnvironment<'tcx>,\n            qualif_map: &'a mut DefIdMap<Qualif>,\n            mir_map: Option<&'a MirMap<'tcx>>,\n            def_id: DefId,\n            mir: &'a Mir<'tcx>,\n            mode: Mode)\n-           -> Qualifier<'a, 'tcx> {\n+           -> Qualifier<'a, 'tcx, 'tcx> {\n         let mut rpo = traversal::reverse_postorder(mir);\n         let temps = promote_consts::collect_temps(mir, &mut rpo);\n         rpo.reset();\n@@ -162,7 +163,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx> {\n             def_id: def_id,\n             mir: mir,\n             rpo: rpo,\n-            tcx: param_env.tcx,\n+            tcx: tcx,\n             param_env: param_env,\n             qualif_map: qualif_map,\n             mir_map: mir_map,\n@@ -208,7 +209,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx> {\n     /// Add the given type's qualification to self.qualif.\n     fn add_type(&mut self, ty: Ty<'tcx>) {\n         self.add(Qualif::MUTABLE_INTERIOR | Qualif::NEEDS_DROP);\n-        self.qualif.restrict(ty, &self.param_env);\n+        self.qualif.restrict(ty, self.tcx, &self.param_env);\n     }\n \n     /// Within the provided closure, self.qualif will start\n@@ -492,7 +493,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx> {\n /// Accumulates an Rvalue or Call's effects in self.qualif.\n /// For functions (constant or not), it also records\n /// candidates for promotion in promotion_candidates.\n-impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n     fn visit_lvalue(&mut self, lvalue: &Lvalue<'tcx>, context: LvalueContext) {\n         match *lvalue {\n             Lvalue::Arg(_) => {\n@@ -555,7 +556,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx> {\n                             }\n                             let ty = this.mir.lvalue_ty(this.tcx, lvalue)\n                                          .to_ty(this.tcx);\n-                            this.qualif.restrict(ty, &this.param_env);\n+                            this.qualif.restrict(ty, this.tcx, &this.param_env);\n                         }\n \n                         ProjectionElem::ConstantIndex {..} |\n@@ -908,11 +909,11 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx> {\n     }\n }\n \n-fn qualify_const_item_cached<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                   qualif_map: &mut DefIdMap<Qualif>,\n-                                   mir_map: Option<&MirMap<'tcx>>,\n-                                   def_id: DefId)\n-                                   -> Qualif {\n+fn qualify_const_item_cached<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                       qualif_map: &mut DefIdMap<Qualif>,\n+                                       mir_map: Option<&MirMap<'tcx>>,\n+                                       def_id: DefId)\n+                                       -> Qualif {\n     match qualif_map.entry(def_id) {\n         Entry::Occupied(entry) => return *entry.get(),\n         Entry::Vacant(entry) => {\n@@ -939,7 +940,7 @@ fn qualify_const_item_cached<'tcx>(tcx: &TyCtxt<'tcx>,\n         bug!(\"missing constant MIR for {}\", tcx.item_path_str(def_id))\n     });\n \n-    let mut qualifier = Qualifier::new(param_env, qualif_map, mir_map,\n+    let mut qualifier = Qualifier::new(tcx, param_env, qualif_map, mir_map,\n                                        def_id, mir, Mode::Const);\n     let qualif = qualifier.qualify_const();\n     qualifier.qualif_map.insert(def_id, qualif);\n@@ -951,7 +952,7 @@ pub struct QualifyAndPromoteConstants;\n impl Pass for QualifyAndPromoteConstants {}\n \n impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n-    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, map: &mut MirMap<'tcx>) {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, map: &mut MirMap<'tcx>) {\n         let mut qualif_map = DefIdMap();\n \n         // First, visit `const` items, potentially recursing, to get\n@@ -991,7 +992,7 @@ impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n                 // This is ugly because Qualifier holds onto mir,\n                 // which can't be mutated until its scope ends.\n                 let (temps, candidates) = {\n-                    let mut qualifier = Qualifier::new(param_env, &mut qualif_map,\n+                    let mut qualifier = Qualifier::new(tcx, param_env, &mut qualif_map,\n                                                        None, def_id, mir, mode);\n                     if mode == Mode::ConstFn {\n                         // Enforce a constant-like CFG for `const fn`.\n@@ -1009,28 +1010,26 @@ impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n                 // Do the actual promotion, now that we know what's viable.\n                 promote_consts::promote_candidates(mir, tcx, temps, candidates);\n             } else {\n-                let mut qualifier = Qualifier::new(param_env, &mut qualif_map,\n+                let mut qualifier = Qualifier::new(tcx, param_env, &mut qualif_map,\n                                                    None, def_id, mir, mode);\n                 qualifier.qualify_const();\n             }\n \n             // Statics must be Sync.\n             if mode == Mode::Static {\n                 let ty = mir.return_ty.unwrap();\n-                let infcx = infer::new_infer_ctxt(tcx,\n-                                                  &tcx.tables,\n-                                                  None,\n-                                                  ProjectionMode::AnyFinal);\n-                let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n-                let mut fulfillment_cx = traits::FulfillmentContext::new();\n-                fulfillment_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n-                if let Err(err) = fulfillment_cx.select_all_or_error(&infcx) {\n-                    traits::report_fulfillment_errors(&infcx, &err);\n-                }\n+                tcx.infer_ctxt(None, None, ProjectionMode::AnyFinal).enter(|infcx| {\n+                    let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n+                    let mut fulfillment_cx = traits::FulfillmentContext::new();\n+                    fulfillment_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n+                    if let Err(err) = fulfillment_cx.select_all_or_error(&infcx) {\n+                        infcx.report_fulfillment_errors(&err);\n+                    }\n \n-                if let Err(ref errors) = fulfillment_cx.select_rfc1592_obligations(&infcx) {\n-                   traits::report_fulfillment_errors_as_warnings(&infcx, errors, id);\n-                }\n+                    if let Err(errors) = fulfillment_cx.select_rfc1592_obligations(&infcx) {\n+                        infcx.report_fulfillment_errors_as_warnings(&errors, id);\n+                    }\n+                });\n             }\n         }\n     }"}, {"sha": "44f3ce7361cf49f18b7eb14e5d13c505f0eb97ef", "filename": "src/librustc_mir/transform/remove_dead_blocks.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -40,7 +40,8 @@ use rustc::mir::transform::{Pass, MirPass, MirSource};\n pub struct RemoveDeadBlocks;\n \n impl<'tcx> MirPass<'tcx> for RemoveDeadBlocks {\n-    fn run_pass(&mut self, _: &TyCtxt<'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n+    fn run_pass<'a>(&mut self, _: TyCtxt<'a, 'tcx, 'tcx>,\n+                    _: MirSource, mir: &mut Mir<'tcx>) {\n         let mut seen = BitVector::new(mir.basic_blocks.len());\n         // This block is always required.\n         seen.insert(START_BLOCK.index());"}, {"sha": "fa897384a542a39508274884e4eb857082601fb9", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -111,7 +111,8 @@ impl SimplifyCfg {\n }\n \n impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n-    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    src: MirSource, mir: &mut Mir<'tcx>) {\n         let mut counter = 0;\n         let mut changed = true;\n         while changed {"}, {"sha": "40157aa934c6571999263021aaa3fcfe4974f084", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 39, "deletions": 42, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -54,14 +54,14 @@ enum FieldAccessError {\n /// The sanitize_XYZ methods here take an MIR object and compute its\n /// type, calling `span_mirbug` and returning an error type if there\n /// is a problem.\n-struct TypeVerifier<'a, 'b: 'a, 'tcx: 'b> {\n-    cx: &'a mut TypeChecker<'b, 'tcx>,\n+struct TypeVerifier<'a, 'b: 'a, 'gcx: 'b+'tcx, 'tcx: 'b> {\n+    cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     last_span: Span,\n     errors_reported: bool\n }\n \n-impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n+impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     fn visit_span(&mut self, span: &Span) {\n         if *span != DUMMY_SP {\n             self.last_span = *span;\n@@ -104,8 +104,8 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n     }\n }\n \n-impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n-    fn new(cx: &'a mut TypeChecker<'b, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n+impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n+    fn new(cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n         TypeVerifier {\n             cx: cx,\n             mir: mir,\n@@ -114,11 +114,11 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn tcx(&self) -> &'a TyCtxt<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.cx.infcx.tcx\n     }\n \n-    fn infcx(&self) -> &'a InferCtxt<'a, 'tcx> {\n+    fn infcx(&self) -> &'a InferCtxt<'a, 'gcx, 'tcx> {\n         self.cx.infcx\n     }\n \n@@ -237,7 +237,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 let fty = self.sanitize_type(lvalue, fty);\n                 match self.field_ty(lvalue, base, field) {\n                     Ok(ty) => {\n-                        if let Err(terr) = self.cx.mk_eqty(span, ty, fty) {\n+                        if let Err(terr) = self.cx.eq_types(span, ty, fty) {\n                             span_mirbug!(\n                                 self, lvalue, \"bad field access ({:?}: {:?}): {:?}\",\n                                 ty, fty, terr);\n@@ -276,8 +276,8 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                     if adt_def.is_univariant() => {\n                         (&adt_def.variants[0], substs)\n                     }\n-                ty::TyTuple(ref tys) | ty::TyClosure(_, box ty::ClosureSubsts {\n-                    upvar_tys: ref tys, ..\n+                ty::TyTuple(tys) | ty::TyClosure(_, ty::ClosureSubsts {\n+                    upvar_tys: tys, ..\n                 }) => {\n                     return match tys.get(field.index()) {\n                         Some(&ty) => Ok(ty),\n@@ -318,40 +318,38 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     }\n }\n \n-pub struct TypeChecker<'a, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+pub struct TypeChecker<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     fulfillment_cx: traits::FulfillmentContext<'tcx>,\n     last_span: Span\n }\n \n-impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n-    fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n+impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n+    fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n         TypeChecker {\n             infcx: infcx,\n             fulfillment_cx: traits::FulfillmentContext::new(),\n             last_span: DUMMY_SP\n         }\n     }\n \n-    fn mk_subty(&self, span: Span, sup: Ty<'tcx>, sub: Ty<'tcx>)\n-                -> infer::UnitResult<'tcx>\n+    fn sub_types(&self, span: Span, sup: Ty<'tcx>, sub: Ty<'tcx>)\n+                 -> infer::UnitResult<'tcx>\n     {\n-        infer::mk_subty(self.infcx, false, infer::TypeOrigin::Misc(span),\n-                        sup, sub)\n+        self.infcx.sub_types(false, infer::TypeOrigin::Misc(span), sup, sub)\n             // FIXME(#32730) propagate obligations\n             .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n     }\n \n-    fn mk_eqty(&self, span: Span, a: Ty<'tcx>, b: Ty<'tcx>)\n+    fn eq_types(&self, span: Span, a: Ty<'tcx>, b: Ty<'tcx>)\n                 -> infer::UnitResult<'tcx>\n     {\n-        infer::mk_eqty(self.infcx, false, infer::TypeOrigin::Misc(span),\n-                       a, b)\n+        self.infcx.eq_types(false, infer::TypeOrigin::Misc(span), a, b)\n             // FIXME(#32730) propagate obligations\n             .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n     }\n \n-    fn tcx(&self) -> &'a TyCtxt<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -363,7 +361,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 let lv_ty = mir.lvalue_ty(tcx, lv).to_ty(tcx);\n                 let rv_ty = mir.rvalue_ty(tcx, rv);\n                 if let Some(rv_ty) = rv_ty {\n-                    if let Err(terr) = self.mk_subty(self.last_span, rv_ty, lv_ty) {\n+                    if let Err(terr) = self.sub_types(self.last_span, rv_ty, lv_ty) {\n                         span_mirbug!(self, stmt, \"bad assignment ({:?} = {:?}): {:?}\",\n                                      lv_ty, rv_ty, terr);\n                     }\n@@ -399,7 +397,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n             TerminatorKind::SwitchInt { ref discr, switch_ty, .. } => {\n                 let discr_ty = mir.lvalue_ty(tcx, discr).to_ty(tcx);\n-                if let Err(terr) = self.mk_subty(self.last_span, discr_ty, switch_ty) {\n+                if let Err(terr) = self.sub_types(self.last_span, discr_ty, switch_ty) {\n                     span_mirbug!(self, term, \"bad SwitchInt ({:?} on {:?}): {:?}\",\n                                  switch_ty, discr_ty, terr);\n                 }\n@@ -456,7 +454,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n             (&Some((ref dest, _)), ty::FnConverging(ty)) => {\n                 let dest_ty = mir.lvalue_ty(tcx, dest).to_ty(tcx);\n-                if let Err(terr) = self.mk_subty(self.last_span, ty, dest_ty) {\n+                if let Err(terr) = self.sub_types(self.last_span, ty, dest_ty) {\n                     span_mirbug!(self, term,\n                                  \"call dest mismatch ({:?} <- {:?}): {:?}\",\n                                  dest_ty, ty, terr);\n@@ -482,7 +480,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         }\n         for (n, (fn_arg, op_arg)) in sig.inputs.iter().zip(args).enumerate() {\n             let op_arg_ty = mir.operand_ty(self.tcx(), op_arg);\n-            if let Err(terr) = self.mk_subty(self.last_span, op_arg_ty, fn_arg) {\n+            if let Err(terr) = self.sub_types(self.last_span, op_arg_ty, fn_arg) {\n                 span_mirbug!(self, term, \"bad arg #{:?} ({:?} <- {:?}): {:?}\",\n                              n, fn_arg, op_arg_ty, terr);\n             }\n@@ -537,7 +535,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n         };\n \n-        if let Err(terr) = self.mk_subty(self.last_span, arg_ty, pointee_ty) {\n+        if let Err(terr) = self.sub_types(self.last_span, arg_ty, pointee_ty) {\n             span_mirbug!(self, term, \"bad box_free arg ({:?} <- {:?}): {:?}\",\n                          pointee_ty, arg_ty, terr);\n         }\n@@ -578,28 +576,27 @@ impl TypeckMir {\n }\n \n impl<'tcx> MirPass<'tcx> for TypeckMir {\n-    fn run_pass(&mut self, tcx: &TyCtxt<'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    src: MirSource, mir: &mut Mir<'tcx>) {\n         if tcx.sess.err_count() > 0 {\n             // compiling a broken program can obviously result in a\n             // broken MIR, so try not to report duplicate errors.\n             return;\n         }\n         let param_env = ty::ParameterEnvironment::for_item(tcx, src.item_id());\n-        let infcx = infer::new_infer_ctxt(tcx,\n-                                          &tcx.tables,\n-                                          Some(param_env),\n-                                          ProjectionMode::AnyFinal);\n-        let mut checker = TypeChecker::new(&infcx);\n-        {\n-            let mut verifier = TypeVerifier::new(&mut checker, mir);\n-            verifier.visit_mir(mir);\n-            if verifier.errors_reported {\n-                // don't do further checks to avoid ICEs\n-                return;\n+        tcx.infer_ctxt(None, Some(param_env), ProjectionMode::AnyFinal).enter(|infcx| {\n+            let mut checker = TypeChecker::new(&infcx);\n+            {\n+                let mut verifier = TypeVerifier::new(&mut checker, mir);\n+                verifier.visit_mir(mir);\n+                if verifier.errors_reported {\n+                    // don't do further checks to avoid ICEs\n+                    return;\n+                }\n             }\n-        }\n-        checker.typeck_mir(mir);\n-        checker.verify_obligations(mir);\n+            checker.typeck_mir(mir);\n+            checker.verify_obligations(mir);\n+        });\n     }\n }\n "}, {"sha": "b1bb48aacee9ff2892071e9a0c9333d8edef3ed0", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -36,7 +36,6 @@ use rustc_const_math::{ConstMathErr, Op};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::middle::expr_use_visitor as euv;\n-use rustc::infer;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -68,15 +67,15 @@ enum Mode {\n }\n \n struct CheckCrateVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mode: Mode,\n     qualif: ConstQualif,\n     rvalue_borrows: NodeMap<hir::Mutability>\n }\n \n-impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n+impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     fn with_mode<F, R>(&mut self, mode: Mode, f: F) -> R where\n-        F: FnOnce(&mut CheckCrateVisitor<'a, 'tcx>) -> R,\n+        F: FnOnce(&mut CheckCrateVisitor<'a, 'gcx>) -> R,\n     {\n         let (old_mode, old_qualif) = (self.mode, self.qualif);\n         self.mode = mode;\n@@ -87,20 +86,17 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n         r\n     }\n \n-    fn with_euv<'b, F, R>(&'b mut self, item_id: Option<ast::NodeId>, f: F) -> R where\n-        F: for<'t> FnOnce(&mut euv::ExprUseVisitor<'b, 't, 'b, 'tcx>) -> R,\n+    fn with_euv<F, R>(&mut self, item_id: Option<ast::NodeId>, f: F) -> R where\n+        F: for<'b, 'tcx> FnOnce(&mut euv::ExprUseVisitor<'b, 'gcx, 'tcx>) -> R,\n     {\n         let param_env = match item_id {\n             Some(item_id) => ty::ParameterEnvironment::for_item(self.tcx, item_id),\n             None => self.tcx.empty_parameter_environment()\n         };\n \n-        let infcx = infer::new_infer_ctxt(self.tcx,\n-                                          &self.tcx.tables,\n-                                          Some(param_env),\n-                                          ProjectionMode::AnyFinal);\n-\n-        f(&mut euv::ExprUseVisitor::new(self, &infcx))\n+        self.tcx.infer_ctxt(None, Some(param_env), ProjectionMode::AnyFinal).enter(|infcx| {\n+            f(&mut euv::ExprUseVisitor::new(self, &infcx))\n+        })\n     }\n \n     fn global_expr(&mut self, mode: Mode, expr: &hir::Expr) -> ConstQualif {\n@@ -181,7 +177,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     fn handle_const_fn_call(&mut self,\n                             _expr: &hir::Expr,\n                             def_id: DefId,\n-                            ret_ty: Ty<'tcx>)\n+                            ret_ty: Ty<'gcx>)\n                             -> bool {\n         if let Some(fn_like) = lookup_const_fn_by_id(self.tcx, def_id) {\n             let qualif = self.fn_like(fn_like.kind(),\n@@ -665,7 +661,7 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n     }\n }\n \n-pub fn check_crate(tcx: &TyCtxt) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.visit_all_items_in_krate(DepNode::CheckConst, &mut CheckCrateVisitor {\n         tcx: tcx,\n         mode: Mode::Var,\n@@ -675,7 +671,7 @@ pub fn check_crate(tcx: &TyCtxt) {\n     tcx.sess.abort_if_errors();\n }\n \n-impl<'a, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n     fn consume(&mut self,\n                _consume_id: ast::NodeId,\n                _consume_span: Span,"}, {"sha": "137a50642fcf4be2f8ff781355e5cad43add1738", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -13,7 +13,6 @@\n \n use rustc::dep_graph::DepNode;\n use rustc::middle::expr_use_visitor as euv;\n-use rustc::infer;\n use rustc::middle::mem_categorization as mc;\n use rustc::ty::{self, TyCtxt, ParameterEnvironment};\n use rustc::traits::ProjectionMode;\n@@ -23,13 +22,13 @@ use rustc::hir::intravisit;\n use syntax::ast;\n use syntax::codemap::Span;\n \n-pub fn check_crate(tcx: &TyCtxt) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut rvcx = RvalueContext { tcx: tcx };\n     tcx.visit_all_items_in_krate(DepNode::RvalueCheck, &mut rvcx);\n }\n \n struct RvalueContext<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n@@ -39,37 +38,38 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n                 b: &'v hir::Block,\n                 s: Span,\n                 fn_id: ast::NodeId) {\n-        {\n-            // FIXME (@jroesch) change this to be an inference context\n-            let param_env = ParameterEnvironment::for_item(self.tcx, fn_id);\n-            let infcx = infer::new_infer_ctxt(self.tcx,\n-                                              &self.tcx.tables,\n-                                              Some(param_env.clone()),\n-                                              ProjectionMode::AnyFinal);\n-            let mut delegate = RvalueContextDelegate { tcx: self.tcx, param_env: &param_env };\n+        // FIXME (@jroesch) change this to be an inference context\n+        let param_env = ParameterEnvironment::for_item(self.tcx, fn_id);\n+        self.tcx.infer_ctxt(None, Some(param_env.clone()),\n+                            ProjectionMode::AnyFinal).enter(|infcx| {\n+            let mut delegate = RvalueContextDelegate {\n+                tcx: infcx.tcx,\n+                param_env: &param_env\n+            };\n             let mut euv = euv::ExprUseVisitor::new(&mut delegate, &infcx);\n             euv.walk_fn(fd, b);\n-        }\n+        });\n         intravisit::walk_fn(self, fk, fd, b, s)\n     }\n }\n \n-struct RvalueContextDelegate<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n-    param_env: &'a ty::ParameterEnvironment<'a,'tcx>,\n+struct RvalueContextDelegate<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    param_env: &'a ty::ParameterEnvironment<'gcx>,\n }\n \n-impl<'a, 'tcx> euv::Delegate<'tcx> for RvalueContextDelegate<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for RvalueContextDelegate<'a, 'gcx, 'tcx> {\n     fn consume(&mut self,\n                _: ast::NodeId,\n                span: Span,\n                cmt: mc::cmt<'tcx>,\n                _: euv::ConsumeMode) {\n         debug!(\"consume; cmt: {:?}; type: {:?}\", *cmt, cmt.ty);\n-        if !cmt.ty.is_sized(self.param_env, span) {\n+        let ty = self.tcx.lift_to_global(&cmt.ty).unwrap();\n+        if !ty.is_sized(self.tcx.global_tcx(), self.param_env, span) {\n             span_err!(self.tcx.sess, span, E0161,\n                 \"cannot move a value of type {0}: the size of {0} cannot be statically determined\",\n-                cmt.ty);\n+                ty);\n         }\n     }\n "}, {"sha": "0b2763baf4f67a90c719d7e828069d3109f9a67f", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -58,7 +58,7 @@ type CheckResult = Option<(Span, String, Option<(Span, String)>)>;\n ////////////////////////////////////////////////////////////////////////////////\n \n struct EmbargoVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     export_map: &'a def::ExportMap,\n \n     // Accessibility levels for reachable nodes\n@@ -128,7 +128,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n     fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        self.visit_item(self.tcx.map.expect_item(item.id))\n+        let tcx = self.tcx;\n+        self.visit_item(tcx.map.expect_item(item.id))\n     }\n \n     fn visit_item(&mut self, item: &hir::Item) {\n@@ -375,7 +376,7 @@ impl<'b, 'a, 'tcx: 'a, 'v> Visitor<'v> for ReachEverythingInTheInterfaceVisitor<\n ////////////////////////////////////////////////////////////////////////////////\n \n struct PrivacyVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     curitem: ast::NodeId,\n     in_foreign: bool,\n }\n@@ -417,7 +418,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n     fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        self.visit_item(self.tcx.map.expect_item(item.id))\n+        let tcx = self.tcx;\n+        self.visit_item(tcx.map.expect_item(item.id))\n     }\n \n     fn visit_item(&mut self, item: &hir::Item) {\n@@ -524,7 +526,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n ////////////////////////////////////////////////////////////////////////////////\n \n struct SanePrivacyVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for SanePrivacyVisitor<'a, 'tcx> {\n@@ -595,7 +597,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n ///////////////////////////////////////////////////////////////////////////////\n \n struct ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     access_levels: &'a AccessLevels,\n     in_variant: bool,\n     // set of errors produced by this obsolete visitor\n@@ -679,7 +681,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n     fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        self.visit_item(self.tcx.map.expect_item(item.id))\n+        let tcx = self.tcx;\n+        self.visit_item(tcx.map.expect_item(item.id))\n     }\n \n     fn visit_item(&mut self, item: &hir::Item) {\n@@ -934,7 +937,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n ///////////////////////////////////////////////////////////////////////////////\n \n struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     /// The visitor checks that each component type is at least this visible\n     required_visibility: ty::Visibility,\n     /// The visibility of the least visible component that has been visited\n@@ -943,7 +946,7 @@ struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n-    fn new(tcx: &'a TyCtxt<'tcx>, old_error_set: &'a NodeSet) -> Self {\n+    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, old_error_set: &'a NodeSet) -> Self {\n         SearchInterfaceForPrivateItemsVisitor {\n             tcx: tcx,\n             min_visibility: ty::Visibility::Public,\n@@ -1015,7 +1018,7 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n                         let item = self.tcx.map.expect_item(node_id);\n                         let vis = match self.substituted_alias_visibility(item, path) {\n                             Some(vis) => vis,\n-                            None => ty::Visibility::from_hir(&item.vis, node_id, &self.tcx),\n+                            None => ty::Visibility::from_hir(&item.vis, node_id, self.tcx),\n                         };\n \n                         if !vis.is_at_least(self.min_visibility, &self.tcx.map) {\n@@ -1047,7 +1050,7 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n         let def_id = self.tcx.trait_ref_to_def_id(trait_ref);\n         if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n             let item = self.tcx.map.expect_item(node_id);\n-            let vis = ty::Visibility::from_hir(&item.vis, node_id, &self.tcx);\n+            let vis = ty::Visibility::from_hir(&item.vis, node_id, self.tcx);\n \n             if !vis.is_at_least(self.min_visibility, &self.tcx.map) {\n                 self.min_visibility = vis;\n@@ -1079,7 +1082,7 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n }\n \n struct PrivateItemsInPublicInterfacesVisitor<'a, 'tcx: 'a> {\n-    tcx: &'a TyCtxt<'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     old_error_set: &'a NodeSet,\n }\n \n@@ -1106,7 +1109,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tc\n         };\n \n         let mut check = SearchInterfaceForPrivateItemsVisitor::new(self.tcx, self.old_error_set);\n-        let item_visibility = ty::Visibility::from_hir(&item.vis, item.id, &self.tcx);\n+        let item_visibility = ty::Visibility::from_hir(&item.vis, item.id, self.tcx);\n \n         match item.node {\n             // Crates are always public\n@@ -1125,7 +1128,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tc\n             hir::ItemForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n                     check.required_visibility =\n-                        ty::Visibility::from_hir(&foreign_item.vis, item.id, &self.tcx);\n+                        ty::Visibility::from_hir(&foreign_item.vis, item.id, self.tcx);\n                     check.visit_foreign_item(foreign_item);\n                 }\n             }\n@@ -1135,7 +1138,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tc\n                 check.visit_generics(generics);\n \n                 for field in struct_def.fields() {\n-                    let field_visibility = ty::Visibility::from_hir(&field.vis, item.id, &self.tcx);\n+                    let field_visibility = ty::Visibility::from_hir(&field.vis, item.id, self.tcx);\n                     check.required_visibility = min(item_visibility, field_visibility);\n                     check.visit_struct_field(field);\n                 }\n@@ -1151,7 +1154,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tc\n \n                 for impl_item in impl_items {\n                     let impl_item_vis =\n-                        ty::Visibility::from_hir(&impl_item.vis, item.id, &self.tcx);\n+                        ty::Visibility::from_hir(&impl_item.vis, item.id, self.tcx);\n                     check.required_visibility = min(impl_item_vis, ty_vis);\n                     check.visit_impl_item(impl_item);\n                 }\n@@ -1170,7 +1173,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tc\n     }\n }\n \n-pub fn check_crate(tcx: &TyCtxt, export_map: &def::ExportMap) -> AccessLevels {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             export_map: &def::ExportMap)\n+                             -> AccessLevels {\n     let _task = tcx.dep_graph.in_task(DepNode::Privacy);\n \n     let krate = tcx.map.krate();"}, {"sha": "fc048c86dc9ddff838ffe77d09451ffbb625b730", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -1938,7 +1938,7 @@ impl<'a> Resolver<'a> {\n                 // Resolve the self type.\n                 this.visit_ty(self_type);\n \n-                this.with_self_rib(Def::SelfTy(trait_id, Some((item_id, self_type.id))), |this| {\n+                this.with_self_rib(Def::SelfTy(trait_id, Some(item_id)), |this| {\n                     this.with_current_self_type(self_type, |this| {\n                         for impl_item in impl_items {\n                             this.resolve_visibility(&impl_item.vis);"}, {"sha": "f0dd7b8b9bba1c11c1f9970ba2c5001571f52391", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a", "patch": "@@ -62,7 +62,7 @@ macro_rules! down_cast_data {\n pub struct DumpVisitor<'l, 'tcx: 'l, 'll, D: 'll> {\n     save_ctxt: SaveContext<'l, 'tcx>,\n     sess: &'l Session,\n-    tcx: &'l TyCtxt<'tcx>,\n+    tcx: TyCtxt<'l, 'tcx, 'tcx>,\n     analysis: &'l ty::CrateAnalysis<'l>,\n     dumper: &'ll mut D,\n \n@@ -79,7 +79,7 @@ pub struct DumpVisitor<'l, 'tcx: 'l, 'll, D: 'll> {\n }\n \n impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n-    pub fn new(tcx: &'l TyCtxt<'tcx>,\n+    pub fn new(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n                save_ctxt: SaveContext<'l, 'tcx>,\n                analysis: &'l ty::CrateAnalysis<'l>,\n                dumper: &'ll mut D)"}, {"sha": "51134f8383b368a5d7d18de4a83381208e6b7a75", "filename": "src/librustc_save_analysis/external_data.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fexternal_data.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "d62c14d2c575ecbf4ede5a1a8b4972d6569a9dff", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "6df308d5e624a6d13c3ffc54559980caf539a7b7", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "49775388038afb172d4084f8e1ec322d7e820280", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "00d9658cb59439a719b6c5b368679a0161392953", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "0cf82d66b2b682add653f9340e784bdf517739e8", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "7665b730caddf940a6a73dbc7a6ae1b7640e97f1", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "3fb8605412075ed957a6e6e99f64497ee6e9c1bb", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "3081f055bb4dd1065b975e7d99153f1856dd3052", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "1c393f8091eee996eb58e3f5151097b5b5682c6f", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 26, "deletions": 31, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "dfab2bdbf644ec505a89086ddb29efb06ccf2ce1", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 64, "deletions": 65, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "c1685e6a749046b8c8f7ee42ee737b4b648cbdf9", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 74, "deletions": 81, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "7775ed3fc68ae015e0d58b8866ff57194be31a9b", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "61137d7f377c295ca1d88c606d550d73514360d5", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "eda3ce1d1062c2f2cc900c6d7567d41362517395", "filename": "src/librustc_trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdatum.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "7826693c827101a0139f1fcaba87ab9e770a8feb", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "db4a82c7b0be7b90d04804f702c96ffabc3d2060", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "63f460e4693d56be227fb0daf7a09d20018d4afa", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "e6db695943bbee5b5ae940255b31ed3e108f2c5b", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "b87456318cd169e95ab3f477b9b5d4bc9c1e272c", "filename": "src/librustc_trans/expr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fexpr.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "a29ff95851d7600ec31a633fed41cc37125e7de6", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "640ac25a5e31cc666556f6982c71dd20073a178a", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "9b279a397f8649d6164252cd1170a4127b8a999e", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "039304ece60b0da01e4b100bbc3d32885049d315", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "3fb22c6bd55da6c390cf462297319a1220c8bc7b", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "8b1809e40233a92edcb04236bcd7636a2b1ca948", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "18a860f9357b906005467f2e5b4d9f9cf2d7997b", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "98ec87ebbcf6ff81864235cb1a4b5929448454b4", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "725d40889ceecb3ba8dbaee4d044e1a3a62014a1", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1656, "deletions": 1730, "changes": 3386, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "d55ca803c64ca500faaae1bd9eb262a2536e9d0f", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 701, "deletions": 704, "changes": 1405, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "04b0248ccdac25ac2b4e8efce1b8dc0e0fda3b62", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "7493ca70f556711dda8017735426446b71f91fed", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 258, "deletions": 277, "changes": 535, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "690250edb8cb457ea76f30ac66e56b0ae90437a1", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 89, "deletions": 99, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "d3396eb4c1baf480236e9298302cda45101628ac", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 204, "deletions": 227, "changes": 431, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "4861ab15e2c0147f1b39ccb9fdab5fb3ed38b6d8", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 188, "deletions": 185, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "a1a6a83d34ff2c8ebf46d6cf3d7e9f533ff02bde", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 254, "deletions": 250, "changes": 504, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "7c8eb62b0e749e8998b3360492fe6b6509298a64", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 44, "deletions": 35, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "ae614d7b02157ec7ae5252aeb53ab18fd3902222", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 67, "deletions": 65, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "c02139140aed5fa1079be3b692563fa44d134fdb", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 24, "deletions": 36, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "6faf6f415c266b5eff11705f0dbbcf5a17af3bde", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 119, "deletions": 125, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "f27ae181f77e33cd9d23b19a46691e060beb989e", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 286, "deletions": 280, "changes": 566, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "08c041225171ab36166d0def0da199874131f9c3", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 194, "deletions": 212, "changes": 406, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "540af8b04bf0ee8802de926e07c7f75c850877f4", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 313, "deletions": 321, "changes": 634, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "f428023da9b8248628146e9220e6f5a3b25433be", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2303, "deletions": 2423, "changes": 4726, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "8604dadf46dff2f4011aa22f67fb948f0a634ea0", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 298, "deletions": 303, "changes": 601, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "7b79f2ec9bfe62a176159c9356ad6dd36ee78a81", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1239, "deletions": 1270, "changes": 2509, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "19964d736f5925763e0a29d3b3730d20809bae75", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 57, "deletions": 67, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "e0a34189773b13d87eafd3b604590220ae76492a", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 154, "deletions": 144, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "e6500747c05b3e775a2c86de0c6dd2555e2b0a7a", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 88, "deletions": 84, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "c3538ace347491b3346cb3d4bd8f18181d87e415", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "8bee0467f11b3cd7f3688d42f2e59ea1e3f28b16", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 151, "deletions": 156, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "d9ad03222029d765c27364f8ad00f871c9625008", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "dcaa5cfb20a46ff73a8c8f3509ec0bce51be717d", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 16, "deletions": 30, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "53ec72abac05fff64c5677a1304cd950d8e14f36", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "797a1509ebee51001ca797a884bc7a8e8e8b8465", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 189, "deletions": 208, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "08c1b5fcc82c3dc9e72d7ec0f6d35e17f4dd2756", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "b88b3c9802d30bbd3bff3273aa824ae3ba3b1f58", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "a532f9744f49813346a6c7a686540a1b1fc4f729", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "13ed6cf7641405194950c2acf92f1e6ff70c987e", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "d9e7e8cbf7df4eb16c948e1666bf239366605784", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "c9df54dfef267ad83638f05988a35d0e099e514b", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 41, "deletions": 39, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "a89609fad6b6ecaf5bc7564193b35f3108db0af5", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "895c0bb8490108336d46ed763efb05d626200219", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "d5309d7433449713940a2d1fc97735d90bad001c", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}, {"sha": "0abf71ba444aefa49a236485305d5684fed997ee", "filename": "src/test/run-pass-fulldeps/auxiliary/dummy_mir_pass.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fdummy_mir_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fdummy_mir_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fdummy_mir_pass.rs?ref=c7ab8840c8cfcd62e9f7212371ed3e31ad2ae73a"}]}