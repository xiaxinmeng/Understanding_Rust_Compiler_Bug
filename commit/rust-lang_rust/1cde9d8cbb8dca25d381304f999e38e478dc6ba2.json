{"sha": "1cde9d8cbb8dca25d381304f999e38e478dc6ba2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjZGU5ZDhjYmI4ZGNhMjVkMzgxMzA0Zjk5OWUzOGU0NzhkYzZiYTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-14T01:11:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-14T01:11:44Z"}, "message": "auto merge of #14866 : bjz/rust/bitwise, r=alexcrichton", "tree": {"sha": "3dd7d619113510cd18e5cab9819e949dfecfe7be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3dd7d619113510cd18e5cab9819e949dfecfe7be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cde9d8cbb8dca25d381304f999e38e478dc6ba2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cde9d8cbb8dca25d381304f999e38e478dc6ba2", "html_url": "https://github.com/rust-lang/rust/commit/1cde9d8cbb8dca25d381304f999e38e478dc6ba2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cde9d8cbb8dca25d381304f999e38e478dc6ba2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3851d68a27d41dfd15e12a75b590f362a0675870", "url": "https://api.github.com/repos/rust-lang/rust/commits/3851d68a27d41dfd15e12a75b590f362a0675870", "html_url": "https://github.com/rust-lang/rust/commit/3851d68a27d41dfd15e12a75b590f362a0675870"}, {"sha": "ffa4ae81e4b5d1ada347eb7c0edb6a872c87ca83", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffa4ae81e4b5d1ada347eb7c0edb6a872c87ca83", "html_url": "https://github.com/rust-lang/rust/commit/ffa4ae81e4b5d1ada347eb7c0edb6a872c87ca83"}], "stats": {"total": 172, "additions": 152, "deletions": 20}, "files": [{"sha": "20bb12db694c0f1dcfbe5c1229ab26771829ffb0", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1cde9d8cbb8dca25d381304f999e38e478dc6ba2/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cde9d8cbb8dca25d381304f999e38e478dc6ba2/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=1cde9d8cbb8dca25d381304f999e38e478dc6ba2", "patch": "@@ -113,6 +113,33 @@ mod tests {\n         assert!((0b1111001 as $T).count_zeros() == BITS as $T - 5);\n     }\n \n+    #[test]\n+    fn test_swap_bytes() {\n+        let n: $T = 0b0101100; assert_eq!(n.swap_bytes().swap_bytes(), n);\n+        let n: $T = 0b0100001; assert_eq!(n.swap_bytes().swap_bytes(), n);\n+        let n: $T = 0b1111001; assert_eq!(n.swap_bytes().swap_bytes(), n);\n+\n+        // Swapping these should make no difference\n+        let n: $T = 0;   assert_eq!(n.swap_bytes(), n);\n+        let n: $T = -1;  assert_eq!(n.swap_bytes(), n);\n+    }\n+\n+    #[test]\n+    fn test_rotate() {\n+        let n: $T = 0b0101100; assert_eq!(n.rotate_left(6).rotate_right(2).rotate_right(4), n);\n+        let n: $T = 0b0100001; assert_eq!(n.rotate_left(3).rotate_left(2).rotate_right(5),  n);\n+        let n: $T = 0b1111001; assert_eq!(n.rotate_left(6).rotate_right(2).rotate_right(4), n);\n+\n+        // Rotating these should make no difference\n+        //\n+        // We test using 124 bits because to ensure that overlong bit shifts do\n+        // not cause undefined behaviour. See #10183.\n+        let n: $T = 0;   assert_eq!(n.rotate_left(124), n);\n+        let n: $T = -1;  assert_eq!(n.rotate_left(124), n);\n+        let n: $T = 0;   assert_eq!(n.rotate_right(124), n);\n+        let n: $T = -1;  assert_eq!(n.rotate_right(124), n);\n+    }\n+\n     #[test]\n     fn test_signed_checked_div() {\n         assert!(10i.checked_div(&2) == Some(5));"}, {"sha": "eaa632be6d04c42fe749f39c1b5267fe945890de", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 98, "deletions": 20, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/1cde9d8cbb8dca25d381304f999e38e478dc6ba2/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cde9d8cbb8dca25d381304f999e38e478dc6ba2/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=1cde9d8cbb8dca25d381304f999e38e478dc6ba2", "patch": "@@ -436,57 +436,135 @@ pub trait Bitwise: Bounded\n     /// assert_eq!(n.trailing_zeros(), 3);\n     /// ```\n     fn trailing_zeros(&self) -> Self;\n+\n+    /// Reverses the byte order of a binary number.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::num::Bitwise;\n+    ///\n+    /// let n = 0x0123456789ABCDEFu64;\n+    /// let m = 0xEFCDAB8967452301u64;\n+    /// assert_eq!(n.swap_bytes(), m);\n+    /// ```\n+    fn swap_bytes(&self) -> Self;\n+\n+    /// Shifts the bits to the left by a specified amount amount, `r`, wrapping\n+    /// the truncated bits to the end of the resulting value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::num::Bitwise;\n+    ///\n+    /// let n = 0x0123456789ABCDEFu64;\n+    /// let m = 0x3456789ABCDEF012u64;\n+    /// assert_eq!(n.rotate_left(12), m);\n+    /// ```\n+    fn rotate_left(&self, r: uint) -> Self;\n+\n+    /// Shifts the bits to the right by a specified amount amount, `r`, wrapping\n+    /// the truncated bits to the beginning of the resulting value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::num::Bitwise;\n+    ///\n+    /// let n = 0x0123456789ABCDEFu64;\n+    /// let m = 0xDEF0123456789ABCu64;\n+    /// assert_eq!(n.rotate_right(12), m);\n+    /// ```\n+    fn rotate_right(&self, r: uint) -> Self;\n }\n \n+/// Swapping a single byte does nothing. This is unsafe to be consistent with\n+/// the other `bswap` intrinsics.\n+#[inline]\n+unsafe fn bswap8(x: u8) -> u8 { x }\n+\n macro_rules! bitwise_impl(\n-    ($t:ty, $co:path, $lz:path, $tz:path) => {\n+    ($t:ty, $bits:expr, $co:ident, $lz:ident, $tz:ident, $bs:path) => {\n         impl Bitwise for $t {\n             #[inline]\n-            fn count_ones(&self) -> $t { unsafe { $co(*self) } }\n+            fn count_ones(&self) -> $t { unsafe { intrinsics::$co(*self) } }\n \n             #[inline]\n-            fn leading_zeros(&self) -> $t { unsafe { $lz(*self) } }\n+            fn leading_zeros(&self) -> $t { unsafe { intrinsics::$lz(*self) } }\n \n             #[inline]\n-            fn trailing_zeros(&self) -> $t { unsafe { $tz(*self) } }\n+            fn trailing_zeros(&self) -> $t { unsafe { intrinsics::$tz(*self) } }\n+\n+            #[inline]\n+            fn swap_bytes(&self) -> $t { unsafe { $bs(*self) } }\n+\n+            #[inline]\n+            fn rotate_left(&self, r: uint) -> $t {\n+                // Protect against undefined behaviour for overlong bit shifts\n+                let r = r % $bits;\n+                (*self << r) | (*self >> ($bits - r))\n+            }\n+\n+            #[inline]\n+            fn rotate_right(&self, r: uint) -> $t {\n+                // Protect against undefined behaviour for overlong bit shifts\n+                let r = r % $bits;\n+                (*self >> r) | (*self << ($bits - r))\n+            }\n         }\n     }\n )\n \n macro_rules! bitwise_cast_impl(\n-    ($t:ty, $t_cast:ty,  $co:path, $lz:path, $tz:path) => {\n+    ($t:ty, $t_cast:ty, $bits:expr,  $co:ident, $lz:ident, $tz:ident, $bs:path) => {\n         impl Bitwise for $t {\n             #[inline]\n-            fn count_ones(&self) -> $t { unsafe { $co(*self as $t_cast) as $t } }\n+            fn count_ones(&self) -> $t { unsafe { intrinsics::$co(*self as $t_cast) as $t } }\n+\n+            #[inline]\n+            fn leading_zeros(&self) -> $t { unsafe { intrinsics::$lz(*self as $t_cast) as $t } }\n+\n+            #[inline]\n+            fn trailing_zeros(&self) -> $t { unsafe { intrinsics::$tz(*self as $t_cast) as $t } }\n \n             #[inline]\n-            fn leading_zeros(&self) -> $t { unsafe { $lz(*self as $t_cast) as $t } }\n+            fn swap_bytes(&self) -> $t { unsafe { $bs(*self as $t_cast) as $t } }\n \n             #[inline]\n-            fn trailing_zeros(&self) -> $t { unsafe { $tz(*self as $t_cast) as $t } }\n+            fn rotate_left(&self, r: uint) -> $t {\n+                // cast to prevent the sign bit from being corrupted\n+                (*self as $t_cast).rotate_left(r) as $t\n+            }\n+\n+            #[inline]\n+            fn rotate_right(&self, r: uint) -> $t {\n+                // cast to prevent the sign bit from being corrupted\n+                (*self as $t_cast).rotate_right(r) as $t\n+            }\n         }\n     }\n )\n \n #[cfg(target_word_size = \"32\")]\n-bitwise_cast_impl!(uint, u32, intrinsics::ctpop32, intrinsics::ctlz32, intrinsics::cttz32)\n+bitwise_cast_impl!(uint, u32, 32, ctpop32, ctlz32, cttz32, intrinsics::bswap32)\n #[cfg(target_word_size = \"64\")]\n-bitwise_cast_impl!(uint, u64, intrinsics::ctpop64, intrinsics::ctlz64, intrinsics::cttz64)\n+bitwise_cast_impl!(uint, u64, 64, ctpop64, ctlz64, cttz64, intrinsics::bswap64)\n \n-bitwise_impl!(u8, intrinsics::ctpop8, intrinsics::ctlz8, intrinsics::cttz8)\n-bitwise_impl!(u16, intrinsics::ctpop16, intrinsics::ctlz16, intrinsics::cttz16)\n-bitwise_impl!(u32, intrinsics::ctpop32, intrinsics::ctlz32, intrinsics::cttz32)\n-bitwise_impl!(u64, intrinsics::ctpop64, intrinsics::ctlz64, intrinsics::cttz64)\n+bitwise_impl!(u8, 8, ctpop8, ctlz8, cttz8, bswap8)\n+bitwise_impl!(u16, 16, ctpop16, ctlz16, cttz16, intrinsics::bswap16)\n+bitwise_impl!(u32, 32, ctpop32, ctlz32, cttz32, intrinsics::bswap32)\n+bitwise_impl!(u64, 64, ctpop64, ctlz64, cttz64, intrinsics::bswap64)\n \n #[cfg(target_word_size = \"32\")]\n-bitwise_cast_impl!(int, u32, intrinsics::ctpop32, intrinsics::ctlz32, intrinsics::cttz32)\n+bitwise_cast_impl!(int, u32, 32, ctpop32, ctlz32, cttz32, intrinsics::bswap32)\n #[cfg(target_word_size = \"64\")]\n-bitwise_cast_impl!(int, u64, intrinsics::ctpop64, intrinsics::ctlz64, intrinsics::cttz64)\n+bitwise_cast_impl!(int, u64, 64, ctpop64, ctlz64, cttz64, intrinsics::bswap64)\n \n-bitwise_cast_impl!(i8, u8, intrinsics::ctpop8, intrinsics::ctlz8, intrinsics::cttz8)\n-bitwise_cast_impl!(i16, u16, intrinsics::ctpop16, intrinsics::ctlz16, intrinsics::cttz16)\n-bitwise_cast_impl!(i32, u32, intrinsics::ctpop32, intrinsics::ctlz32, intrinsics::cttz32)\n-bitwise_cast_impl!(i64, u64, intrinsics::ctpop64, intrinsics::ctlz64, intrinsics::cttz64)\n+bitwise_cast_impl!(i8, u8, 8, ctpop8, ctlz8, cttz8, bswap8)\n+bitwise_cast_impl!(i16, u16, 16, ctpop16, ctlz16, cttz16, intrinsics::bswap16)\n+bitwise_cast_impl!(i32, u32, 32, ctpop32, ctlz32, cttz32, intrinsics::bswap32)\n+bitwise_cast_impl!(i64, u64, 64, ctpop64, ctlz64, cttz64, intrinsics::bswap64)\n \n /// Specifies the available operations common to all of Rust's core numeric primitives.\n /// These may not always make sense from a purely mathematical point of view, but"}, {"sha": "8e4ba10154244958dc6cef41e0c10af6f62e2c73", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1cde9d8cbb8dca25d381304f999e38e478dc6ba2/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cde9d8cbb8dca25d381304f999e38e478dc6ba2/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=1cde9d8cbb8dca25d381304f999e38e478dc6ba2", "patch": "@@ -64,6 +64,33 @@ mod tests {\n         assert!((0b1111001 as $T).count_zeros() == BITS as $T - 5);\n     }\n \n+    #[test]\n+    fn test_swap_bytes() {\n+        let n: $T = 0b0101100; assert_eq!(n.swap_bytes().swap_bytes(), n);\n+        let n: $T = 0b0100001; assert_eq!(n.swap_bytes().swap_bytes(), n);\n+        let n: $T = 0b1111001; assert_eq!(n.swap_bytes().swap_bytes(), n);\n+\n+        // Swapping these should make no difference\n+        let n: $T = 0;   assert_eq!(n.swap_bytes(), n);\n+        let n: $T = MAX; assert_eq!(n.swap_bytes(), n);\n+    }\n+\n+    #[test]\n+    fn test_rotate() {\n+        let n: $T = 0b0101100; assert_eq!(n.rotate_left(6).rotate_right(2).rotate_right(4), n);\n+        let n: $T = 0b0100001; assert_eq!(n.rotate_left(3).rotate_left(2).rotate_right(5),  n);\n+        let n: $T = 0b1111001; assert_eq!(n.rotate_left(6).rotate_right(2).rotate_right(4), n);\n+\n+        // Rotating these should make no difference\n+        //\n+        // We test using 124 bits because to ensure that overlong bit shifts do\n+        // not cause undefined behaviour. See #10183.\n+        let n: $T = 0;   assert_eq!(n.rotate_left(124), n);\n+        let n: $T = MAX; assert_eq!(n.rotate_left(124), n);\n+        let n: $T = 0;   assert_eq!(n.rotate_right(124), n);\n+        let n: $T = MAX; assert_eq!(n.rotate_right(124), n);\n+    }\n+\n     #[test]\n     fn test_unsigned_checked_div() {\n         assert!(10u.checked_div(&2) == Some(5));"}]}