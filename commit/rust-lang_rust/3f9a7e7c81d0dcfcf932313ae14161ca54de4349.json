{"sha": "3f9a7e7c81d0dcfcf932313ae14161ca54de4349", "node_id": "C_kwDOAAsO6NoAKDNmOWE3ZTdjODFkMGRjZmNmOTMyMzEzYWUxNDE2MWNhNTRkZTQzNDk", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2023-05-20T13:37:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-20T13:37:24Z"}, "message": "Rollup merge of #111746 - Zoxc:query-impl-mod, r=cjgillot\n\nMerge some query impl modules into one\n\nThis merges some modules in `rustc_query_impl` into one per query, analogous to https://github.com/rust-lang/rust/pull/111703.\n\nr? `@cjgillot`", "tree": {"sha": "bc92028b74ab69138b5504403773b814937ce69d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc92028b74ab69138b5504403773b814937ce69d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f9a7e7c81d0dcfcf932313ae14161ca54de4349", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkaM0UCRBK7hj4Ov3rIwAA5iEIABF6LtvBvQoBcC28UPUFZale\nyAsXz1PwDPEGxCw/x9rAC2WbopmUnh3rck5WKoskJ5X/xCim/XxigJabMBXiGDId\n4CnOfdYqY/9CKesrjE8DlrlutY96Ecq3mO56YjuUo+O6HvSYKbQpIZPxoHH02JBo\nHN7h6XFwFM6t05xJa5Ru0ww4Otkjm2FWrAP9kj5/ipzGl2Qc4oc1EvL5lXaRDjWa\nC7Anjk5Q7cWfoRS7EKpTIqP90SdzySH1wqgPvZ0JSKiqQYquYr/ReOXDgDArLONs\ntNEE7Q37Rp28zicQFkT3VWQ2RXVmnbeOyB4glOUUjXi/BaSlQPmntVwc2gNUss8=\n=DLMW\n-----END PGP SIGNATURE-----\n", "payload": "tree bc92028b74ab69138b5504403773b814937ce69d\nparent 7597d572ed81781447f23c9a634581be119e2930\nparent 9e755d98cc626992d7f02a8ff0cb9def998a59a9\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1684589844 +0200\ncommitter GitHub <noreply@github.com> 1684589844 +0200\n\nRollup merge of #111746 - Zoxc:query-impl-mod, r=cjgillot\n\nMerge some query impl modules into one\n\nThis merges some modules in `rustc_query_impl` into one per query, analogous to https://github.com/rust-lang/rust/pull/111703.\n\nr? `@cjgillot`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f9a7e7c81d0dcfcf932313ae14161ca54de4349", "html_url": "https://github.com/rust-lang/rust/commit/3f9a7e7c81d0dcfcf932313ae14161ca54de4349", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f9a7e7c81d0dcfcf932313ae14161ca54de4349/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7597d572ed81781447f23c9a634581be119e2930", "url": "https://api.github.com/repos/rust-lang/rust/commits/7597d572ed81781447f23c9a634581be119e2930", "html_url": "https://github.com/rust-lang/rust/commit/7597d572ed81781447f23c9a634581be119e2930"}, {"sha": "9e755d98cc626992d7f02a8ff0cb9def998a59a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e755d98cc626992d7f02a8ff0cb9def998a59a9", "html_url": "https://github.com/rust-lang/rust/commit/9e755d98cc626992d7f02a8ff0cb9def998a59a9"}], "stats": {"total": 268, "additions": 125, "deletions": 143}, "files": [{"sha": "a9056edc4cf0eea0e7b902b861882fdddf681280", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 125, "deletions": 143, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/3f9a7e7c81d0dcfcf932313ae14161ca54de4349/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f9a7e7c81d0dcfcf932313ae14161ca54de4349/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=3f9a7e7c81d0dcfcf932313ae14161ca54de4349", "patch": "@@ -506,169 +506,151 @@ macro_rules! define_queries {\n     (\n      $($(#[$attr:meta])*\n         [$($modifiers:tt)*] fn $name:ident($($K:tt)*) -> $V:ty,)*) => {\n-        mod get_query_incr {\n-            use super::*;\n \n-            $(\n+        pub(crate) mod query_impl { $(pub mod $name {\n+            use super::super::*;\n+            use std::marker::PhantomData;\n+\n+            pub mod get_query_incr {\n+                use super::*;\n+\n                 // Adding `__rust_end_short_backtrace` marker to backtraces so that we emit the frames\n                 // when `RUST_BACKTRACE=1`, add a new mod with `$name` here is to allow duplicate naming\n-                pub mod $name {\n-                    use super::*;\n-                    #[inline(never)]\n-                    pub fn __rust_end_short_backtrace<'tcx>(\n-                        tcx: TyCtxt<'tcx>,\n-                        span: Span,\n-                        key: queries::$name::Key<'tcx>,\n-                        mode: QueryMode,\n-                    ) -> Option<Erase<queries::$name::Value<'tcx>>> {\n-                        get_query_incr(\n-                            query_config::$name::config(tcx),\n-                            QueryCtxt::new(tcx),\n-                            span,\n-                            key,\n-                            mode\n+                #[inline(never)]\n+                pub fn __rust_end_short_backtrace<'tcx>(\n+                    tcx: TyCtxt<'tcx>,\n+                    span: Span,\n+                    key: queries::$name::Key<'tcx>,\n+                    mode: QueryMode,\n+                ) -> Option<Erase<queries::$name::Value<'tcx>>> {\n+                    get_query_incr(\n+                        QueryType::config(tcx),\n+                        QueryCtxt::new(tcx),\n+                        span,\n+                        key,\n+                        mode\n+                    )\n+                }\n+            }\n+\n+            pub mod get_query_non_incr {\n+                use super::*;\n+\n+                #[inline(never)]\n+                pub fn __rust_end_short_backtrace<'tcx>(\n+                    tcx: TyCtxt<'tcx>,\n+                    span: Span,\n+                    key: queries::$name::Key<'tcx>,\n+                    __mode: QueryMode,\n+                ) -> Option<Erase<queries::$name::Value<'tcx>>> {\n+                    Some(get_query_non_incr(\n+                        QueryType::config(tcx),\n+                        QueryCtxt::new(tcx),\n+                        span,\n+                        key,\n+                    ))\n+                }\n+            }\n+\n+            pub fn dynamic_query<'tcx>() -> DynamicQuery<'tcx, queries::$name::Storage<'tcx>> {\n+                DynamicQuery {\n+                    name: stringify!($name),\n+                    eval_always: is_eval_always!([$($modifiers)*]),\n+                    dep_kind: dep_graph::DepKind::$name,\n+                    handle_cycle_error: handle_cycle_error!([$($modifiers)*]),\n+                    query_state: offset_of!(QueryStates<'tcx> => $name),\n+                    query_cache: offset_of!(QueryCaches<'tcx> => $name),\n+                    cache_on_disk: |tcx, key| ::rustc_middle::query::cached::$name(tcx, key),\n+                    execute_query: |tcx, key| erase(tcx.$name(key)),\n+                    compute: |tcx, key| {\n+                        __rust_begin_short_backtrace(||\n+                            queries::$name::provided_to_erased(\n+                                tcx,\n+                                call_provider!([$($modifiers)*][tcx, $name, key])\n+                            )\n                         )\n-                    }\n+                    },\n+                    can_load_from_disk: should_ever_cache_on_disk!([$($modifiers)*] true false),\n+                    try_load_from_disk: should_ever_cache_on_disk!([$($modifiers)*] {\n+                        |tcx, key, prev_index, index| {\n+                            if ::rustc_middle::query::cached::$name(tcx, key) {\n+                                let value = $crate::plumbing::try_load_from_disk::<\n+                                    queries::$name::ProvidedValue<'tcx>\n+                                >(\n+                                    tcx,\n+                                    prev_index,\n+                                    index,\n+                                );\n+                                value.map(|value| queries::$name::provided_to_erased(tcx, value))\n+                            } else {\n+                                None\n+                            }\n+                        }\n+                    } {\n+                        |_tcx, _key, _prev_index, _index| None\n+                    }),\n+                    value_from_cycle_error: |tcx, cycle| {\n+                        let result: queries::$name::Value<'tcx> = Value::from_cycle_error(tcx, cycle);\n+                        erase(result)\n+                    },\n+                    loadable_from_disk: |_tcx, _key, _index| {\n+                        should_ever_cache_on_disk!([$($modifiers)*] {\n+                            ::rustc_middle::query::cached::$name(_tcx, _key) &&\n+                                $crate::plumbing::loadable_from_disk(_tcx, _index)\n+                        } {\n+                            false\n+                        })\n+                    },\n+                    hash_result: hash_result!([$($modifiers)*][queries::$name::Value<'tcx>]),\n+                    format_value: |value| format!(\"{:?}\", restore::<queries::$name::Value<'tcx>>(*value)),\n                 }\n-            )*\n-        }\n+            }\n \n-        mod get_query_non_incr {\n-            use super::*;\n+            #[derive(Copy, Clone, Default)]\n+            pub struct QueryType<'tcx> {\n+                data: PhantomData<&'tcx ()>\n+            }\n \n-            $(\n-                pub mod $name {\n-                    use super::*;\n-                    #[inline(never)]\n-                    pub fn __rust_end_short_backtrace<'tcx>(\n-                        tcx: TyCtxt<'tcx>,\n-                        span: Span,\n-                        key: queries::$name::Key<'tcx>,\n-                        __mode: QueryMode,\n-                    ) -> Option<Erase<queries::$name::Value<'tcx>>> {\n-                        Some(get_query_non_incr(\n-                            query_config::$name::config(tcx),\n-                            QueryCtxt::new(tcx),\n-                            span,\n-                            key,\n-                        ))\n+            impl<'tcx> QueryConfigRestored<'tcx> for QueryType<'tcx> {\n+                type RestoredValue = queries::$name::Value<'tcx>;\n+                type Config = DynamicConfig<\n+                    'tcx,\n+                    queries::$name::Storage<'tcx>,\n+                    { is_anon!([$($modifiers)*]) },\n+                    { depth_limit!([$($modifiers)*]) },\n+                    { feedable!([$($modifiers)*]) },\n+                >;\n+\n+                #[inline(always)]\n+                fn config(tcx: TyCtxt<'tcx>) -> Self::Config {\n+                    DynamicConfig {\n+                        dynamic: &tcx.query_system.dynamic_queries.$name,\n                     }\n                 }\n-            )*\n-        }\n+\n+                #[inline(always)]\n+                fn restore(value: <Self::Config as QueryConfig<QueryCtxt<'tcx>>>::Value) -> Self::RestoredValue {\n+                    restore::<queries::$name::Value<'tcx>>(value)\n+                }\n+            }\n+        })*}\n \n         pub(crate) fn engine(incremental: bool) -> QueryEngine {\n             if incremental {\n                 QueryEngine {\n-                    $($name: get_query_incr::$name::__rust_end_short_backtrace,)*\n+                    $($name: query_impl::$name::get_query_incr::__rust_end_short_backtrace,)*\n                 }\n             } else {\n                 QueryEngine {\n-                    $($name: get_query_non_incr::$name::__rust_end_short_backtrace,)*\n+                    $($name: query_impl::$name::get_query_non_incr::__rust_end_short_backtrace,)*\n                 }\n             }\n         }\n \n-        #[allow(nonstandard_style)]\n-        mod query_config {\n-            use std::marker::PhantomData;\n-\n-            $(\n-                #[derive(Copy, Clone, Default)]\n-                pub struct $name<'tcx> {\n-                    data: PhantomData<&'tcx ()>\n-                }\n-            )*\n-        }\n-\n-        #[allow(nonstandard_style)]\n-        mod dynamic_query {\n-            use super::*;\n-\n-            $(\n-                pub(super) fn $name<'tcx>() -> DynamicQuery<'tcx, queries::$name::Storage<'tcx>> {\n-                    DynamicQuery {\n-                        name: stringify!($name),\n-                        eval_always: is_eval_always!([$($modifiers)*]),\n-                        dep_kind: dep_graph::DepKind::$name,\n-                        handle_cycle_error: handle_cycle_error!([$($modifiers)*]),\n-                        query_state: offset_of!(QueryStates<'tcx> => $name),\n-                        query_cache: offset_of!(QueryCaches<'tcx> => $name),\n-                        cache_on_disk: |tcx, key| ::rustc_middle::query::cached::$name(tcx, key),\n-                        execute_query: |tcx, key| erase(tcx.$name(key)),\n-                        compute: |tcx, key| {\n-                            __rust_begin_short_backtrace(||\n-                                queries::$name::provided_to_erased(\n-                                    tcx,\n-                                    call_provider!([$($modifiers)*][tcx, $name, key])\n-                                )\n-                            )\n-                        },\n-                        can_load_from_disk: should_ever_cache_on_disk!([$($modifiers)*] true false),\n-                        try_load_from_disk: should_ever_cache_on_disk!([$($modifiers)*] {\n-                            |tcx, key, prev_index, index| {\n-                                if ::rustc_middle::query::cached::$name(tcx, key) {\n-                                    let value = $crate::plumbing::try_load_from_disk::<\n-                                        queries::$name::ProvidedValue<'tcx>\n-                                    >(\n-                                        tcx,\n-                                        prev_index,\n-                                        index,\n-                                    );\n-                                    value.map(|value| queries::$name::provided_to_erased(tcx, value))\n-                                } else {\n-                                    None\n-                                }\n-                            }\n-                        } {\n-                            |_tcx, _key, _prev_index, _index| None\n-                        }),\n-                        value_from_cycle_error: |tcx, cycle| {\n-                            let result: queries::$name::Value<'tcx> = Value::from_cycle_error(tcx, cycle);\n-                            erase(result)\n-                        },\n-                        loadable_from_disk: |_tcx, _key, _index| {\n-                            should_ever_cache_on_disk!([$($modifiers)*] {\n-                                ::rustc_middle::query::cached::$name(_tcx, _key) &&\n-                                    $crate::plumbing::loadable_from_disk(_tcx, _index)\n-                            } {\n-                                false\n-                            })\n-                        },\n-                        hash_result: hash_result!([$($modifiers)*][queries::$name::Value<'tcx>]),\n-                        format_value: |value| format!(\"{:?}\", restore::<queries::$name::Value<'tcx>>(*value)),\n-                    }\n-                }\n-            )*\n-        }\n-\n-        $(impl<'tcx> QueryConfigRestored<'tcx> for query_config::$name<'tcx> {\n-            type RestoredValue = queries::$name::Value<'tcx>;\n-            type Config = DynamicConfig<\n-                'tcx,\n-                queries::$name::Storage<'tcx>,\n-                { is_anon!([$($modifiers)*]) },\n-                { depth_limit!([$($modifiers)*]) },\n-                { feedable!([$($modifiers)*]) },\n-            >;\n-\n-            #[inline(always)]\n-            fn config(tcx: TyCtxt<'tcx>) -> Self::Config {\n-                DynamicConfig {\n-                    dynamic: &tcx.query_system.dynamic_queries.$name,\n-                }\n-            }\n-\n-            #[inline(always)]\n-            fn restore(value: <Self::Config as QueryConfig<QueryCtxt<'tcx>>>::Value) -> Self::RestoredValue {\n-                restore::<queries::$name::Value<'tcx>>(value)\n-            }\n-        })*\n-\n         pub fn dynamic_queries<'tcx>() -> DynamicQueries<'tcx> {\n             DynamicQueries {\n                 $(\n-                    $name: dynamic_query::$name(),\n+                    $name: query_impl::$name::dynamic_query(),\n                 )*\n             }\n         }\n@@ -731,7 +713,7 @@ macro_rules! define_queries {\n             }\n \n             $(pub(crate) fn $name<'tcx>()-> DepKindStruct<'tcx> {\n-                $crate::plumbing::query_callback::<query_config::$name<'tcx>>(\n+                $crate::plumbing::query_callback::<query_impl::$name::QueryType<'tcx>>(\n                     is_anon!([$($modifiers)*]),\n                     is_eval_always!([$($modifiers)*]),\n                 )\n@@ -786,8 +768,8 @@ macro_rules! define_queries {\n                     )\n                 },\n                 encode_query_results: expand_if_cached!([$($modifiers)*], |tcx, encoder, query_result_index|\n-                    $crate::plumbing::encode_query_results::<super::query_config::$name<'tcx>>(\n-                        super::query_config::$name::config(tcx),\n+                    $crate::plumbing::encode_query_results::<query_impl::$name::QueryType<'tcx>>(\n+                        query_impl::$name::QueryType::config(tcx),\n                         QueryCtxt::new(tcx),\n                         encoder,\n                         query_result_index,"}]}