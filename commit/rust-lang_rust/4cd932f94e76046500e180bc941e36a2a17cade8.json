{"sha": "4cd932f94e76046500e180bc941e36a2a17cade8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjZDkzMmY5NGU3NjA0NjUwMGUxODBiYzk0MWUzNmEyYTE3Y2FkZTg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-14T06:23:31Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-17T01:15:48Z"}, "message": "alloc: Allow disabling jemalloc", "tree": {"sha": "2599677dd8c573cbebf1a3e4d124b38e1d8fc77a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2599677dd8c573cbebf1a3e4d124b38e1d8fc77a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cd932f94e76046500e180bc941e36a2a17cade8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cd932f94e76046500e180bc941e36a2a17cade8", "html_url": "https://github.com/rust-lang/rust/commit/4cd932f94e76046500e180bc941e36a2a17cade8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cd932f94e76046500e180bc941e36a2a17cade8/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7613c9dd59aa771bf02a00c77af0ba4266392373", "url": "https://api.github.com/repos/rust-lang/rust/commits/7613c9dd59aa771bf02a00c77af0ba4266392373", "html_url": "https://github.com/rust-lang/rust/commit/7613c9dd59aa771bf02a00c77af0ba4266392373"}], "stats": {"total": 256, "additions": 208, "deletions": 48}, "files": [{"sha": "bdcfecd8ce903588b0512e9a81bf02dfa677887c", "filename": "configure", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4cd932f94e76046500e180bc941e36a2a17cade8/configure", "raw_url": "https://github.com/rust-lang/rust/raw/4cd932f94e76046500e180bc941e36a2a17cade8/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=4cd932f94e76046500e180bc941e36a2a17cade8", "patch": "@@ -421,6 +421,7 @@ opt llvm-static-stdcpp 0 \"statically link to libstdc++ for LLVM\"\n opt rpath 1 \"build rpaths into rustc itself\"\n opt nightly 0 \"build nightly packages\"\n opt verify-install 1 \"verify installed binaries work\"\n+opt jemalloc 1 \"build liballoc with jemalloc\"\n valopt prefix \"/usr/local\" \"set installation prefix\"\n valopt local-rust-root \"/usr/local\" \"set prefix for local rust binary\"\n valopt llvm-root \"\" \"set LLVM root\"\n@@ -1167,6 +1168,7 @@ putvar CFG_MANDIR\n putvar CFG_DISABLE_INJECT_STD_VERSION\n putvar CFG_JEMALLOC_ROOT\n putvar CFG_LIBUV_ROOT\n+putvar CFG_DISABLE_JEMALLOC\n \n # Avoid spurious warnings from clang by feeding it original source on\n # ccache-miss rather than preprocessed input."}, {"sha": "49b9d2aad8d2906026fe17f0468d4092e3e11a4d", "filename": "mk/rt.mk", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4cd932f94e76046500e180bc941e36a2a17cade8/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4cd932f94e76046500e180bc941e36a2a17cade8/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=4cd932f94e76046500e180bc941e36a2a17cade8", "patch": "@@ -306,6 +306,8 @@ $$(JEMALLOC_LOCAL_$(1)): $$(JEMALLOC_DEPS) $$(MKFILE_DEPS)\n \t\tEXTRA_CFLAGS=\"$$(CFG_CFLAGS_$(1)) $$(CFG_JEMALLOC_CFLAGS_$(1)) -g1\"\n \t$$(Q)$$(MAKE) -C \"$$(JEMALLOC_BUILD_DIR_$(1))\" build_lib_static\n \n+ifeq ($$(CFG_DISABLE_JEMALLOC),)\n+RUSTFLAGS_alloc := --cfg jemalloc\n ifeq ($(1),$$(CFG_BUILD))\n ifneq ($$(CFG_JEMALLOC_ROOT),)\n $$(JEMALLOC_LIB_$(1)): $$(CFG_JEMALLOC_ROOT)/libjemalloc_pic.a\n@@ -319,6 +321,10 @@ else\n $$(JEMALLOC_LIB_$(1)): $$(JEMALLOC_LOCAL_$(1))\n \t$$(Q)cp $$< $$@\n endif\n+else\n+$$(JEMALLOC_LIB_$(1)): $$(MKFILE_DEPS)\n+\t$$(Q)touch $$@\n+endif\n \n ################################################################################\n # compiler-rt"}, {"sha": "0f63ef9a430d0424323b0f69c8b55f9a664d8e90", "filename": "mk/target.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4cd932f94e76046500e180bc941e36a2a17cade8/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/4cd932f94e76046500e180bc941e36a2a17cade8/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=4cd932f94e76046500e180bc941e36a2a17cade8", "patch": "@@ -84,6 +84,7 @@ $$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$(4):\t\t\t\t    \\\n \t\t-L \"$$(RT_OUTPUT_DIR_$(2))\" \\\n \t\t-L \"$$(LLVM_LIBDIR_$(2))\" \\\n \t\t-L \"$$(dir $$(LLVM_STDCPP_LOCATION_$(2)))\" \\\n+\t\t$$(RUSTFLAGS_$(4)) \\\n \t\t--out-dir $$(@D) $$<\n \t@touch $$@\n \t$$(call LIST_ALL_OLD_GLOB_MATCHES,\\"}, {"sha": "0e7445e737c378f4336730e788afce636031f2b0", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 199, "deletions": 48, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/4cd932f94e76046500e180bc941e36a2a17cade8/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cd932f94e76046500e180bc941e36a2a17cade8/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=4cd932f94e76046500e180bc941e36a2a17cade8", "patch": "@@ -12,48 +12,17 @@\n // FIXME: #13996: mark the `allocate` and `reallocate` return value as `noalias`\n //                and `nonnull`\n \n-use core::intrinsics::{abort, cttz32};\n-use core::option::{None, Option};\n-use core::ptr::{RawPtr, mut_null, null};\n-use libc::{c_char, c_int, c_void, size_t};\n-\n #[cfg(not(test))] use core::raw;\n #[cfg(not(test))] use util;\n \n-#[link(name = \"jemalloc\", kind = \"static\")]\n-extern {\n-    fn je_mallocx(size: size_t, flags: c_int) -> *mut c_void;\n-    fn je_rallocx(ptr: *mut c_void, size: size_t, flags: c_int) -> *mut c_void;\n-    fn je_xallocx(ptr: *mut c_void, size: size_t, extra: size_t,\n-                  flags: c_int) -> size_t;\n-    fn je_dallocx(ptr: *mut c_void, flags: c_int);\n-    fn je_nallocx(size: size_t, flags: c_int) -> size_t;\n-    fn je_malloc_stats_print(write_cb: Option<extern \"C\" fn(cbopaque: *mut c_void, *c_char)>,\n-                             cbopaque: *mut c_void,\n-                             opts: *c_char);\n-}\n-\n-// -lpthread needs to occur after -ljemalloc, the earlier argument isn't enough\n-#[cfg(not(windows), not(target_os = \"android\"))]\n-#[link(name = \"pthread\")]\n-extern {}\n-\n-// MALLOCX_ALIGN(a) macro\n-#[inline(always)]\n-fn mallocx_align(a: uint) -> c_int { unsafe { cttz32(a as u32) as c_int } }\n-\n /// Return a pointer to `size` bytes of memory.\n ///\n /// Behavior is undefined if the requested size is 0 or the alignment is not a\n /// power of 2. The alignment must be no larger than the largest supported page\n /// size on the platform.\n #[inline]\n pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n-    let ptr = je_mallocx(size as size_t, mallocx_align(align)) as *mut u8;\n-    if ptr.is_null() {\n-        abort()\n-    }\n-    ptr\n+    imp::allocate(size, align)\n }\n \n /// Extend or shrink the allocation referenced by `ptr` to `size` bytes of\n@@ -67,15 +36,9 @@ pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n /// create the allocation referenced by `ptr`. The `old_size` parameter may also\n /// be the value returned by `usable_size` for the requested size.\n #[inline]\n-#[allow(unused_variable)] // for the parameter names in the documentation\n pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n                          old_size: uint) -> *mut u8 {\n-    let ptr = je_rallocx(ptr as *mut c_void, size as size_t,\n-                         mallocx_align(align)) as *mut u8;\n-    if ptr.is_null() {\n-        abort()\n-    }\n-    ptr\n+    imp::reallocate(ptr, size, align, old_size)\n }\n \n /// Extend or shrink the allocation referenced by `ptr` to `size` bytes of\n@@ -92,11 +55,9 @@ pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n /// create the allocation referenced by `ptr`. The `old_size` parameter may be\n /// any value in range_inclusive(requested_size, usable_size).\n #[inline]\n-#[allow(unused_variable)] // for the parameter names in the documentation\n pub unsafe fn reallocate_inplace(ptr: *mut u8, size: uint, align: uint,\n                                  old_size: uint) -> bool {\n-    je_xallocx(ptr as *mut c_void, size as size_t, 0,\n-               mallocx_align(align)) == size as size_t\n+    imp::reallocate_inplace(ptr, size, align, old_size)\n }\n \n /// Deallocate the memory referenced by `ptr`.\n@@ -107,16 +68,15 @@ pub unsafe fn reallocate_inplace(ptr: *mut u8, size: uint, align: uint,\n /// create the allocation referenced by `ptr`. The `size` parameter may also be\n /// the value returned by `usable_size` for the requested size.\n #[inline]\n-#[allow(unused_variable)] // for the parameter names in the documentation\n pub unsafe fn deallocate(ptr: *mut u8, size: uint, align: uint) {\n-    je_dallocx(ptr as *mut c_void, mallocx_align(align))\n+    imp::deallocate(ptr, size, align)\n }\n \n /// Return the usable size of an allocation created with the specified the\n /// `size` and `align`.\n #[inline]\n pub fn usable_size(size: uint, align: uint) -> uint {\n-    unsafe { je_nallocx(size as size_t, mallocx_align(align)) as uint }\n+    imp::usable_size(size, align)\n }\n \n /// Print implementation-defined allocator statistics.\n@@ -125,9 +85,7 @@ pub fn usable_size(size: uint, align: uint) -> uint {\n /// during the call.\n #[unstable]\n pub fn stats_print() {\n-    unsafe {\n-        je_malloc_stats_print(None, mut_null(), null())\n-    }\n+    imp::stats_print();\n }\n \n // The compiler never calls `exchange_free` on ~ZeroSizeType, so zero-size\n@@ -170,6 +128,199 @@ unsafe fn closure_exchange_malloc(drop_glue: fn(*mut u8), size: uint,\n     alloc as *mut u8\n }\n \n+#[cfg(jemalloc)]\n+mod imp {\n+    use core::intrinsics::abort;\n+    use core::option::{None, Option};\n+    use core::ptr::{RawPtr, mut_null, null};\n+    use core::num::Bitwise;\n+    use libc::{c_char, c_int, c_void, size_t};\n+\n+    #[link(name = \"jemalloc\", kind = \"static\")]\n+    extern {\n+        fn je_mallocx(size: size_t, flags: c_int) -> *mut c_void;\n+        fn je_rallocx(ptr: *mut c_void, size: size_t,\n+                      flags: c_int) -> *mut c_void;\n+        fn je_xallocx(ptr: *mut c_void, size: size_t, extra: size_t,\n+                      flags: c_int) -> size_t;\n+        fn je_dallocx(ptr: *mut c_void, flags: c_int);\n+        fn je_nallocx(size: size_t, flags: c_int) -> size_t;\n+        fn je_malloc_stats_print(write_cb: Option<extern \"C\" fn(cbopaque: *mut c_void, *c_char)>,\n+                                 cbopaque: *mut c_void,\n+                                 opts: *c_char);\n+    }\n+\n+    // -lpthread needs to occur after -ljemalloc, the earlier argument isn't enough\n+    #[cfg(not(windows), not(target_os = \"android\"))]\n+    #[link(name = \"pthread\")]\n+    extern {}\n+\n+    // MALLOCX_ALIGN(a) macro\n+    #[inline(always)]\n+    fn mallocx_align(a: uint) -> c_int { a.trailing_zeros() as c_int }\n+\n+    #[inline]\n+    pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n+        let ptr = je_mallocx(size as size_t, mallocx_align(align)) as *mut u8;\n+        if ptr.is_null() {\n+            abort()\n+        }\n+        ptr\n+    }\n+\n+    #[inline]\n+    pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n+                             _old_size: uint) -> *mut u8 {\n+        let ptr = je_rallocx(ptr as *mut c_void, size as size_t,\n+                             mallocx_align(align)) as *mut u8;\n+        if ptr.is_null() {\n+            abort()\n+        }\n+        ptr\n+    }\n+\n+    #[inline]\n+    pub unsafe fn reallocate_inplace(ptr: *mut u8, size: uint, align: uint,\n+                                     _old_size: uint) -> bool {\n+        je_xallocx(ptr as *mut c_void, size as size_t, 0,\n+                   mallocx_align(align)) == size as size_t\n+    }\n+\n+    #[inline]\n+    pub unsafe fn deallocate(ptr: *mut u8, _size: uint, align: uint) {\n+        je_dallocx(ptr as *mut c_void, mallocx_align(align))\n+    }\n+\n+    #[inline]\n+    pub fn usable_size(size: uint, align: uint) -> uint {\n+        unsafe { je_nallocx(size as size_t, mallocx_align(align)) as uint }\n+    }\n+\n+    pub fn stats_print() {\n+        unsafe {\n+            je_malloc_stats_print(None, mut_null(), null())\n+        }\n+    }\n+}\n+\n+#[cfg(not(jemalloc), unix)]\n+mod imp {\n+    use core::mem;\n+    use core::ptr;\n+    use libc;\n+    use libc_heap;\n+\n+    extern {\n+        fn posix_memalign(memptr: *mut *mut libc::c_void,\n+                          align: libc::size_t,\n+                          size: libc::size_t) -> libc::c_int;\n+    }\n+\n+    #[inline]\n+    pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n+        // The posix_memalign manpage states\n+        //\n+        //      alignment [...] must be a power of and a multiple of\n+        //      sizeof(void *)\n+        //\n+        // The `align` parameter to this function is the *minimum* alignment for\n+        // a block of memory, so we special case everything under `*uint` to\n+        // just pass it to malloc, which is guaranteed to align to at least the\n+        // size of `*uint`.\n+        if align < mem::size_of::<*uint>() {\n+            libc_heap::malloc_raw(size)\n+        } else {\n+            let mut out = 0 as *mut libc::c_void;\n+            let ret = posix_memalign(&mut out,\n+                                     align as libc::size_t,\n+                                     size as libc::size_t);\n+            if ret != 0 {\n+                ::oom();\n+            }\n+            out as *mut u8\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n+                             old_size: uint) -> *mut u8 {\n+        let new_ptr = allocate(size, align);\n+        ptr::copy_memory(new_ptr, ptr as *u8, old_size);\n+        deallocate(ptr, old_size, align);\n+        return new_ptr;\n+    }\n+\n+    #[inline]\n+    pub unsafe fn reallocate_inplace(_ptr: *mut u8, _size: uint, _align: uint,\n+                                     _old_size: uint) -> bool {\n+        false\n+    }\n+\n+    #[inline]\n+    pub unsafe fn deallocate(ptr: *mut u8, _size: uint, _align: uint) {\n+        libc::free(ptr as *mut libc::c_void)\n+    }\n+\n+    #[inline]\n+    pub fn usable_size(size: uint, _align: uint) -> uint {\n+        size\n+    }\n+\n+    pub fn stats_print() {\n+    }\n+}\n+\n+#[cfg(not(jemalloc), windows)]\n+mod imp {\n+    use libc::{c_void, size_t};\n+    use core::ptr::RawPtr;\n+\n+    extern {\n+        fn _aligned_malloc(size: size_t, align: size_t) -> *mut c_void;\n+        fn _aligned_realloc(block: *mut c_void, size: size_t,\n+                            align: size_t) -> *mut c_void;\n+        fn _aligned_free(ptr: *mut c_void);\n+    }\n+\n+    #[inline]\n+    pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n+        let ptr = _aligned_malloc(size as size_t, align as size_t);\n+        if ptr.is_null() {\n+            ::oom();\n+        }\n+        ptr as *mut u8\n+    }\n+\n+    #[inline]\n+    pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n+                             _old_size: uint) -> *mut u8 {\n+        let ptr = _aligned_realloc(ptr as *mut c_void, size as size_t,\n+                                   align as size_t);\n+        if ptr.is_null() {\n+            ::oom();\n+        }\n+        ptr as *mut u8\n+    }\n+\n+    #[inline]\n+    pub unsafe fn reallocate_inplace(_ptr: *mut u8, _size: uint, _align: uint,\n+                                     _old_size: uint) -> bool {\n+        false\n+    }\n+\n+    #[inline]\n+    pub unsafe fn deallocate(ptr: *mut u8, _size: uint, _align: uint) {\n+        _aligned_free(ptr as *mut c_void)\n+    }\n+\n+    #[inline]\n+    pub fn usable_size(size: uint, _align: uint) -> uint {\n+        size\n+    }\n+\n+    pub fn stats_print() {}\n+}\n+\n #[cfg(test)]\n mod bench {\n     extern crate test;"}]}