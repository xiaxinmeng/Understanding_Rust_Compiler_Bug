{"sha": "6aa611a84c6f383e52ba4167dfda2910e122ef8f", "node_id": "C_kwDOAAsO6NoAKDZhYTYxMWE4NGM2ZjM4M2U1MmJhNDE2N2RmZGEyOTEwZTEyMmVmOGY", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-11-15T12:42:14Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-11-15T12:50:13Z"}, "message": "mv utility methods into separate module", "tree": {"sha": "52f457bda6d4ddc11a6d2be4b201c220a9e3d26f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52f457bda6d4ddc11a6d2be4b201c220a9e3d26f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6aa611a84c6f383e52ba4167dfda2910e122ef8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6aa611a84c6f383e52ba4167dfda2910e122ef8f", "html_url": "https://github.com/rust-lang/rust/commit/6aa611a84c6f383e52ba4167dfda2910e122ef8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6aa611a84c6f383e52ba4167dfda2910e122ef8f/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45f441a7b41d09bb78b0ba3e260d2c868ef6add7", "url": "https://api.github.com/repos/rust-lang/rust/commits/45f441a7b41d09bb78b0ba3e260d2c868ef6add7", "html_url": "https://github.com/rust-lang/rust/commit/45f441a7b41d09bb78b0ba3e260d2c868ef6add7"}], "stats": {"total": 137, "additions": 72, "deletions": 65}, "files": [{"sha": "b5df63790cb07dab506359ddf0c86b9bdee6d431", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6aa611a84c6f383e52ba4167dfda2910e122ef8f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa611a84c6f383e52ba4167dfda2910e122ef8f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=6aa611a84c6f383e52ba4167dfda2910e122ef8f", "patch": "@@ -23,7 +23,7 @@ use super::{\n     MemPlaceMeta, Memory, MemoryKind, Operand, Place, PlaceTy, PointerArithmetic, Provenance,\n     Scalar, StackPopJump,\n };\n-use crate::transform::validate;\n+use crate::util;\n \n pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// Stores the `Machine` instance.\n@@ -355,7 +355,7 @@ pub(super) fn mir_assign_valid_types<'tcx>(\n     // all normal lifetimes are erased, higher-ranked types with their\n     // late-bound lifetimes are still around and can lead to type\n     // differences.\n-    if validate::is_subtype(tcx, param_env, src.ty, dest.ty) {\n+    if util::is_subtype(tcx, param_env, src.ty, dest.ty) {\n         // Make sure the layout is equal, too -- just to be safe. Miri really\n         // needs layout equality. For performance reason we skip this check when\n         // the types are equal. Equal types *can* have different layouts when"}, {"sha": "860dee589805780addc061110736fa9db4c888af", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 1, "deletions": 53, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6aa611a84c6f383e52ba4167dfda2910e122ef8f/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa611a84c6f383e52ba4167dfda2910e122ef8f/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=6aa611a84c6f383e52ba4167dfda2910e122ef8f", "patch": "@@ -2,8 +2,6 @@\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_index::bit_set::BitSet;\n-use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n-use rustc_infer::traits::ObligationCause;\n use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::mir::visit::NonUseContext::VarDebugInfo;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n@@ -18,7 +16,6 @@ use rustc_mir_dataflow::impls::MaybeStorageLive;\n use rustc_mir_dataflow::storage::always_storage_live_locals;\n use rustc_mir_dataflow::{Analysis, ResultsCursor};\n use rustc_target::abi::{Size, VariantIdx};\n-use rustc_trait_selection::traits::ObligationCtxt;\n \n #[derive(Copy, Clone, Debug)]\n enum EdgeKind {\n@@ -71,55 +68,6 @@ impl<'tcx> MirPass<'tcx> for Validator {\n     }\n }\n \n-/// Returns whether the two types are equal up to subtyping.\n-///\n-/// This is used in case we don't know the expected subtyping direction\n-/// and still want to check whether anything is broken.\n-pub fn is_equal_up_to_subtyping<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ParamEnv<'tcx>,\n-    src: Ty<'tcx>,\n-    dest: Ty<'tcx>,\n-) -> bool {\n-    // Fast path.\n-    if src == dest {\n-        return true;\n-    }\n-\n-    // Check for subtyping in either direction.\n-    is_subtype(tcx, param_env, src, dest) || is_subtype(tcx, param_env, dest, src)\n-}\n-\n-pub fn is_subtype<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ParamEnv<'tcx>,\n-    src: Ty<'tcx>,\n-    dest: Ty<'tcx>,\n-) -> bool {\n-    if src == dest {\n-        return true;\n-    }\n-\n-    let mut builder =\n-        tcx.infer_ctxt().ignoring_regions().with_opaque_type_inference(DefiningAnchor::Bubble);\n-    let infcx = builder.build();\n-    let ocx = ObligationCtxt::new(&infcx);\n-    let cause = ObligationCause::dummy();\n-    let src = ocx.normalize(cause.clone(), param_env, src);\n-    let dest = ocx.normalize(cause.clone(), param_env, dest);\n-    let Ok(infer_ok) = infcx.at(&cause, param_env).sub(src, dest) else {\n-        return false;\n-    };\n-    let () = ocx.register_infer_ok_obligations(infer_ok);\n-    let errors = ocx.select_all_or_error();\n-    // With `Reveal::All`, opaque types get normalized away, with `Reveal::UserFacing`\n-    // we would get unification errors because we're unable to look into opaque types,\n-    // even if they're constrained in our current function.\n-    //\n-    // It seems very unlikely that this hides any bugs.\n-    let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n-    errors.is_empty()\n-}\n struct TypeChecker<'a, 'tcx> {\n     when: &'a str,\n     body: &'a Body<'tcx>,\n@@ -195,7 +143,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             return true;\n         }\n \n-        is_subtype(self.tcx, self.param_env, src, dest)\n+        crate::util::is_subtype(self.tcx, self.param_env, src, dest)\n     }\n }\n "}, {"sha": "a1fce8cbd0f09ce030ff593d55e284673a41c27b", "filename": "compiler/rustc_const_eval/src/util/compare_types.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6aa611a84c6f383e52ba4167dfda2910e122ef8f/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcompare_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa611a84c6f383e52ba4167dfda2910e122ef8f/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcompare_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcompare_types.rs?ref=6aa611a84c6f383e52ba4167dfda2910e122ef8f", "patch": "@@ -0,0 +1,60 @@\n+//! Routines to check for relations between fully inferred types.\n+//!\n+//! FIXME: Move this to a more general place. The utility of this extends to\n+//! other areas of the compiler as well.\n+\n+use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n+use rustc_infer::traits::ObligationCause;\n+use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n+use rustc_trait_selection::traits::ObligationCtxt;\n+\n+/// Returns whether the two types are equal up to subtyping.\n+///\n+/// This is used in case we don't know the expected subtyping direction\n+/// and still want to check whether anything is broken.\n+pub fn is_equal_up_to_subtyping<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    src: Ty<'tcx>,\n+    dest: Ty<'tcx>,\n+) -> bool {\n+    // Fast path.\n+    if src == dest {\n+        return true;\n+    }\n+\n+    // Check for subtyping in either direction.\n+    is_subtype(tcx, param_env, src, dest) || is_subtype(tcx, param_env, dest, src)\n+}\n+\n+/// Returns whether `src` is a subtype of `dest`, i.e. `src <: dest`.\n+pub fn is_subtype<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    src: Ty<'tcx>,\n+    dest: Ty<'tcx>,\n+) -> bool {\n+    if src == dest {\n+        return true;\n+    }\n+\n+    let mut builder =\n+        tcx.infer_ctxt().ignoring_regions().with_opaque_type_inference(DefiningAnchor::Bubble);\n+    let infcx = builder.build();\n+    let ocx = ObligationCtxt::new(&infcx);\n+    let cause = ObligationCause::dummy();\n+    let src = ocx.normalize(cause.clone(), param_env, src);\n+    let dest = ocx.normalize(cause.clone(), param_env, dest);\n+    let Ok(infer_ok) = infcx.at(&cause, param_env).sub(src, dest) else {\n+        return false;\n+    };\n+    let () = ocx.register_infer_ok_obligations(infer_ok);\n+    let errors = ocx.select_all_or_error();\n+    // With `Reveal::All`, opaque types get normalized away, with `Reveal::UserFacing`\n+    // we would get unification errors because we're unable to look into opaque types,\n+    // even if they're constrained in our current function.\n+    //\n+    // It seems very unlikely that this hides any bugs.\n+    let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+    errors.is_empty()\n+}"}, {"sha": "76ea5a24e69edd8c1bd09cab7ece7e05eb345302", "filename": "compiler/rustc_const_eval/src/util/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aa611a84c6f383e52ba4167dfda2910e122ef8f/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa611a84c6f383e52ba4167dfda2910e122ef8f/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs?ref=6aa611a84c6f383e52ba4167dfda2910e122ef8f", "patch": "@@ -2,13 +2,15 @@ pub mod aggregate;\n mod alignment;\n mod call_kind;\n pub mod collect_writes;\n+mod compare_types;\n mod find_self_call;\n mod might_permit_raw_init;\n mod type_name;\n \n pub use self::aggregate::expand_aggregate;\n pub use self::alignment::is_disaligned;\n pub use self::call_kind::{call_kind, CallDesugaringKind, CallKind};\n+pub use self::compare_types::{is_equal_up_to_subtyping, is_subtype};\n pub use self::find_self_call::find_self_call;\n pub use self::might_permit_raw_init::might_permit_raw_init;\n pub use self::type_name::type_name;"}, {"sha": "167a82d4499a188603895a21b2bfe9349d628341", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6aa611a84c6f383e52ba4167dfda2910e122ef8f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa611a84c6f383e52ba4167dfda2910e122ef8f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=6aa611a84c6f383e52ba4167dfda2910e122ef8f", "patch": "@@ -557,11 +557,8 @@ where\n \n         debug!(?self.ambient_variance);\n         // In a bivariant context this always succeeds.\n-        let r = if self.ambient_variance == ty::Variance::Bivariant {\n-            a\n-        } else {\n-            self.relate(a, b)?\n-        };\n+        let r =\n+            if self.ambient_variance == ty::Variance::Bivariant { a } else { self.relate(a, b)? };\n \n         self.ambient_variance = old_ambient_variance;\n "}, {"sha": "d7dd5fc8528454ca76c0a78ce2f1decdbedb437f", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6aa611a84c6f383e52ba4167dfda2910e122ef8f/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aa611a84c6f383e52ba4167dfda2910e122ef8f/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=6aa611a84c6f383e52ba4167dfda2910e122ef8f", "patch": "@@ -14,7 +14,7 @@ use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;\n \n use crate::simplify::{remove_dead_blocks, CfgSimplifier};\n-use crate::validate;\n+use crate::util;\n use crate::MirPass;\n use std::iter;\n use std::ops::{Range, RangeFrom};\n@@ -180,7 +180,7 @@ impl<'tcx> Inliner<'tcx> {\n         let TerminatorKind::Call { args, destination, .. } = &terminator.kind else { bug!() };\n         let destination_ty = destination.ty(&caller_body.local_decls, self.tcx).ty;\n         let output_type = callee_body.return_ty();\n-        if !validate::is_subtype(self.tcx, self.param_env, output_type, destination_ty) {\n+        if !util::is_subtype(self.tcx, self.param_env, output_type, destination_ty) {\n             trace!(?output_type, ?destination_ty);\n             return Err(\"failed to normalize return type\");\n         }\n@@ -200,7 +200,7 @@ impl<'tcx> Inliner<'tcx> {\n                 arg_tuple_tys.iter().zip(callee_body.args_iter().skip(skipped_args))\n             {\n                 let input_type = callee_body.local_decls[input].ty;\n-                if !validate::is_subtype(self.tcx, self.param_env, input_type, arg_ty) {\n+                if !util::is_subtype(self.tcx, self.param_env, input_type, arg_ty) {\n                     trace!(?arg_ty, ?input_type);\n                     return Err(\"failed to normalize tuple argument type\");\n                 }\n@@ -209,7 +209,7 @@ impl<'tcx> Inliner<'tcx> {\n             for (arg, input) in args.iter().zip(callee_body.args_iter()) {\n                 let input_type = callee_body.local_decls[input].ty;\n                 let arg_ty = arg.ty(&caller_body.local_decls, self.tcx);\n-                if !validate::is_subtype(self.tcx, self.param_env, input_type, arg_ty) {\n+                if !util::is_subtype(self.tcx, self.param_env, input_type, arg_ty) {\n                     trace!(?arg_ty, ?input_type);\n                     return Err(\"failed to normalize argument type\");\n                 }\n@@ -847,7 +847,7 @@ impl<'tcx> Visitor<'tcx> for CostChecker<'_, 'tcx> {\n             let parent = Place { local, projection: self.tcx.intern_place_elems(proj_base) };\n             let parent_ty = parent.ty(&self.callee_body.local_decls, self.tcx);\n             let check_equal = |this: &mut Self, f_ty| {\n-                if !validate::is_equal_up_to_subtyping(this.tcx, this.param_env, ty, f_ty) {\n+                if !util::is_equal_up_to_subtyping(this.tcx, this.param_env, ty, f_ty) {\n                     trace!(?ty, ?f_ty);\n                     this.validation = Err(\"failed to normalize projection type\");\n                     return;"}]}