{"sha": "feefbe79185baa2601ca0cb9634cdc997d137b71", "node_id": "C_kwDOAAsO6NoAKGZlZWZiZTc5MTg1YmFhMjYwMWNhMGNiOTYzNGNkYzk5N2QxMzdiNzE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-26T12:06:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-26T12:06:26Z"}, "message": "Auto merge of #13475 - lowr:fix/lookup-impl-method-trait-ref, r=flodiebold\n\nfix: Test all generic args for trait when finding matching impl\n\nAddresses https://github.com/rust-lang/rust-analyzer/pull/13463#issuecomment-1287816680\n\nWhen finding matching impl for a trait method, we've been testing the unifiability of self type. However, there can be multiple impl of a trait for the same type with different generic arguments for the trait. This patch takes it into account and tests the unifiability of all type arguments for the trait (the first being the self type) thus enables rust-analyzer to find the correct impl even in such cases.", "tree": {"sha": "9d02f4893eacd70ea7dc43650f9677415cbcc212", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d02f4893eacd70ea7dc43650f9677415cbcc212"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/feefbe79185baa2601ca0cb9634cdc997d137b71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/feefbe79185baa2601ca0cb9634cdc997d137b71", "html_url": "https://github.com/rust-lang/rust/commit/feefbe79185baa2601ca0cb9634cdc997d137b71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/feefbe79185baa2601ca0cb9634cdc997d137b71/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53b6d69e931a52cca44ef94c3b713b4d255754b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/53b6d69e931a52cca44ef94c3b713b4d255754b8", "html_url": "https://github.com/rust-lang/rust/commit/53b6d69e931a52cca44ef94c3b713b4d255754b8"}, {"sha": "67f1d8fe2cfc3da4170cd031e835404811734df5", "url": "https://api.github.com/repos/rust-lang/rust/commits/67f1d8fe2cfc3da4170cd031e835404811734df5", "html_url": "https://github.com/rust-lang/rust/commit/67f1d8fe2cfc3da4170cd031e835404811734df5"}], "stats": {"total": 243, "additions": 170, "deletions": 73}, "files": [{"sha": "12f45f00f9c4dce9a1052c39fe7e6f6c2f6b70fa", "filename": "crates/hir-ty/src/infer/unify.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/feefbe79185baa2601ca0cb9634cdc997d137b71/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feefbe79185baa2601ca0cb9634cdc997d137b71/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=feefbe79185baa2601ca0cb9634cdc997d137b71", "patch": "@@ -340,8 +340,8 @@ impl<'a> InferenceTable<'a> {\n         self.resolve_with_fallback(t, &|_, _, d, _| d)\n     }\n \n-    /// Unify two types and register new trait goals that arise from that.\n-    pub(crate) fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n+    /// Unify two relatable values (e.g. `Ty`) and register new trait goals that arise from that.\n+    pub(crate) fn unify<T: ?Sized + Zip<Interner>>(&mut self, ty1: &T, ty2: &T) -> bool {\n         let result = match self.try_unify(ty1, ty2) {\n             Ok(r) => r,\n             Err(_) => return false,\n@@ -350,9 +350,13 @@ impl<'a> InferenceTable<'a> {\n         true\n     }\n \n-    /// Unify two types and return new trait goals arising from it, so the\n+    /// Unify two relatable values (e.g. `Ty`) and return new trait goals arising from it, so the\n     /// caller needs to deal with them.\n-    pub(crate) fn try_unify<T: Zip<Interner>>(&mut self, t1: &T, t2: &T) -> InferResult<()> {\n+    pub(crate) fn try_unify<T: ?Sized + Zip<Interner>>(\n+        &mut self,\n+        t1: &T,\n+        t2: &T,\n+    ) -> InferResult<()> {\n         match self.var_unification_table.relate(\n             Interner,\n             &self.db,"}, {"sha": "b1178ba0d2af78d8a80e274c58f0989003445327", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 54, "deletions": 30, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/feefbe79185baa2601ca0cb9634cdc997d137b71/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feefbe79185baa2601ca0cb9634cdc997d137b71/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=feefbe79185baa2601ca0cb9634cdc997d137b71", "patch": "@@ -22,10 +22,10 @@ use crate::{\n     from_foreign_def_id,\n     infer::{unify::InferenceTable, Adjust, Adjustment, AutoBorrow, OverloadedDeref, PointerCast},\n     primitive::{FloatTy, IntTy, UintTy},\n-    static_lifetime,\n+    static_lifetime, to_chalk_trait_id,\n     utils::all_super_traits,\n     AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, ForeignDefId, InEnvironment, Interner,\n-    Scalar, TraitEnvironment, TraitRefExt, Ty, TyBuilder, TyExt, TyKind,\n+    Scalar, Substitution, TraitEnvironment, TraitRef, TraitRefExt, Ty, TyBuilder, TyExt, TyKind,\n };\n \n /// This is used as a key for indexing impls.\n@@ -624,52 +624,76 @@ pub(crate) fn iterate_method_candidates<T>(\n     slot\n }\n \n+/// Looks up the impl method that actually runs for the trait method `func`.\n+///\n+/// Returns `func` if it's not a method defined in a trait or the lookup failed.\n pub fn lookup_impl_method(\n-    self_ty: &Ty,\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n-    trait_: TraitId,\n+    func: FunctionId,\n+    fn_subst: Substitution,\n+) -> FunctionId {\n+    let trait_id = match func.lookup(db.upcast()).container {\n+        ItemContainerId::TraitId(id) => id,\n+        _ => return func,\n+    };\n+    let trait_params = db.generic_params(trait_id.into()).type_or_consts.len();\n+    let fn_params = fn_subst.len(Interner) - trait_params;\n+    let trait_ref = TraitRef {\n+        trait_id: to_chalk_trait_id(trait_id),\n+        substitution: Substitution::from_iter(Interner, fn_subst.iter(Interner).skip(fn_params)),\n+    };\n+\n+    let name = &db.function_data(func).name;\n+    lookup_impl_method_for_trait_ref(trait_ref, db, env, name).unwrap_or(func)\n+}\n+\n+fn lookup_impl_method_for_trait_ref(\n+    trait_ref: TraitRef,\n+    db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n     name: &Name,\n ) -> Option<FunctionId> {\n-    let self_ty_fp = TyFingerprint::for_trait_impl(self_ty)?;\n-    let trait_impls = db.trait_impls_in_deps(env.krate);\n-    let impls = trait_impls.for_trait_and_self_ty(trait_, self_ty_fp);\n-    let mut table = InferenceTable::new(db, env.clone());\n-    find_matching_impl(impls, &mut table, &self_ty).and_then(|data| {\n-        data.items.iter().find_map(|it| match it {\n-            AssocItemId::FunctionId(f) => (db.function_data(*f).name == *name).then(|| *f),\n-            _ => None,\n-        })\n+    let self_ty = trait_ref.self_type_parameter(Interner);\n+    let self_ty_fp = TyFingerprint::for_trait_impl(&self_ty)?;\n+    let impls = db.trait_impls_in_deps(env.krate);\n+    let impls = impls.for_trait_and_self_ty(trait_ref.hir_trait_id(), self_ty_fp);\n+\n+    let table = InferenceTable::new(db, env);\n+\n+    let impl_data = find_matching_impl(impls, table, trait_ref)?;\n+    impl_data.items.iter().find_map(|it| match it {\n+        AssocItemId::FunctionId(f) => (db.function_data(*f).name == *name).then(|| *f),\n+        _ => None,\n     })\n }\n \n fn find_matching_impl(\n     mut impls: impl Iterator<Item = ImplId>,\n-    table: &mut InferenceTable<'_>,\n-    self_ty: &Ty,\n+    mut table: InferenceTable<'_>,\n+    actual_trait_ref: TraitRef,\n ) -> Option<Arc<ImplData>> {\n     let db = table.db;\n     loop {\n         let impl_ = impls.next()?;\n         let r = table.run_in_snapshot(|table| {\n             let impl_data = db.impl_data(impl_);\n-            let substs =\n+            let impl_substs =\n                 TyBuilder::subst_for_def(db, impl_, None).fill_with_inference_vars(table).build();\n-            let impl_ty = db.impl_self_ty(impl_).substitute(Interner, &substs);\n-\n-            table\n-                .unify(self_ty, &impl_ty)\n-                .then(|| {\n-                    let wh_goals =\n-                        crate::chalk_db::convert_where_clauses(db, impl_.into(), &substs)\n-                            .into_iter()\n-                            .map(|b| b.cast(Interner));\n+            let trait_ref = db\n+                .impl_trait(impl_)\n+                .expect(\"non-trait method in find_matching_impl\")\n+                .substitute(Interner, &impl_substs);\n \n-                    let goal = crate::Goal::all(Interner, wh_goals);\n+            if !table.unify(&trait_ref, &actual_trait_ref) {\n+                return None;\n+            }\n \n-                    table.try_obligation(goal).map(|_| impl_data)\n-                })\n-                .flatten()\n+            let wcs = crate::chalk_db::convert_where_clauses(db, impl_.into(), &impl_substs)\n+                .into_iter()\n+                .map(|b| b.cast(Interner));\n+            let goal = crate::Goal::all(Interner, wcs);\n+            table.try_obligation(goal).map(|_| impl_data)\n         });\n         if r.is_some() {\n             break r;\n@@ -1214,7 +1238,7 @@ fn is_valid_fn_candidate(\n             let expected_receiver =\n                 sig.map(|s| s.params()[0].clone()).substitute(Interner, &fn_subst);\n \n-            check_that!(table.unify(&receiver_ty, &expected_receiver));\n+            check_that!(table.unify(receiver_ty, &expected_receiver));\n         }\n \n         if let ItemContainerId::ImplId(impl_id) = container {"}, {"sha": "f86c571005367e5b4015472c55d1b8fd694c2d99", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 26, "deletions": 39, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/feefbe79185baa2601ca0cb9634cdc997d137b71/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feefbe79185baa2601ca0cb9634cdc997d137b71/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=feefbe79185baa2601ca0cb9634cdc997d137b71", "patch": "@@ -270,7 +270,7 @@ impl SourceAnalyzer {\n         let expr_id = self.expr_id(db, &call.clone().into())?;\n         let (f_in_trait, substs) = self.infer.as_ref()?.method_resolution(expr_id)?;\n \n-        Some(self.resolve_impl_method_or_trait_def(db, f_in_trait, &substs))\n+        Some(self.resolve_impl_method_or_trait_def(db, f_in_trait, substs))\n     }\n \n     pub(crate) fn resolve_await_to_poll(\n@@ -311,7 +311,7 @@ impl SourceAnalyzer {\n         // HACK: subst for `poll()` coincides with that for `Future` because `poll()` itself\n         // doesn't have any generic parameters, so we skip building another subst for `poll()`.\n         let substs = hir_ty::TyBuilder::subst_for_def(db, future_trait, None).push(ty).build();\n-        Some(self.resolve_impl_method_or_trait_def(db, poll_fn, &substs))\n+        Some(self.resolve_impl_method_or_trait_def(db, poll_fn, substs))\n     }\n \n     pub(crate) fn resolve_prefix_expr(\n@@ -331,7 +331,7 @@ impl SourceAnalyzer {\n         // don't have any generic parameters, so we skip building another subst for the methods.\n         let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None).push(ty.clone()).build();\n \n-        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, substs))\n     }\n \n     pub(crate) fn resolve_index_expr(\n@@ -351,7 +351,7 @@ impl SourceAnalyzer {\n             .push(base_ty.clone())\n             .push(index_ty.clone())\n             .build();\n-        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, substs))\n     }\n \n     pub(crate) fn resolve_bin_expr(\n@@ -372,7 +372,7 @@ impl SourceAnalyzer {\n             .push(rhs.clone())\n             .build();\n \n-        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, substs))\n     }\n \n     pub(crate) fn resolve_try_expr(\n@@ -392,7 +392,7 @@ impl SourceAnalyzer {\n         // doesn't have any generic parameters, so we skip building another subst for `branch()`.\n         let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None).push(ty.clone()).build();\n \n-        Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n+        Some(self.resolve_impl_method_or_trait_def(db, op_fn, substs))\n     }\n \n     pub(crate) fn resolve_field(\n@@ -487,19 +487,22 @@ impl SourceAnalyzer {\n \n         let mut prefer_value_ns = false;\n         let resolved = (|| {\n+            let infer = self.infer.as_deref()?;\n             if let Some(path_expr) = parent().and_then(ast::PathExpr::cast) {\n                 let expr_id = self.expr_id(db, &path_expr.into())?;\n-                let infer = self.infer.as_ref()?;\n                 if let Some(assoc) = infer.assoc_resolutions_for_expr(expr_id) {\n                     let assoc = match assoc {\n                         AssocItemId::FunctionId(f_in_trait) => {\n                             match infer.type_of_expr.get(expr_id) {\n                                 None => assoc,\n                                 Some(func_ty) => {\n                                     if let TyKind::FnDef(_fn_def, subs) = func_ty.kind(Interner) {\n-                                        self.resolve_impl_method(db, f_in_trait, subs)\n-                                            .map(AssocItemId::FunctionId)\n-                                            .unwrap_or(assoc)\n+                                        self.resolve_impl_method_or_trait_def(\n+                                            db,\n+                                            f_in_trait,\n+                                            subs.clone(),\n+                                        )\n+                                        .into()\n                                     } else {\n                                         assoc\n                                     }\n@@ -520,18 +523,18 @@ impl SourceAnalyzer {\n                 prefer_value_ns = true;\n             } else if let Some(path_pat) = parent().and_then(ast::PathPat::cast) {\n                 let pat_id = self.pat_id(&path_pat.into())?;\n-                if let Some(assoc) = self.infer.as_ref()?.assoc_resolutions_for_pat(pat_id) {\n+                if let Some(assoc) = infer.assoc_resolutions_for_pat(pat_id) {\n                     return Some(PathResolution::Def(AssocItem::from(assoc).into()));\n                 }\n                 if let Some(VariantId::EnumVariantId(variant)) =\n-                    self.infer.as_ref()?.variant_resolution_for_pat(pat_id)\n+                    infer.variant_resolution_for_pat(pat_id)\n                 {\n                     return Some(PathResolution::Def(ModuleDef::Variant(variant.into())));\n                 }\n             } else if let Some(rec_lit) = parent().and_then(ast::RecordExpr::cast) {\n                 let expr_id = self.expr_id(db, &rec_lit.into())?;\n                 if let Some(VariantId::EnumVariantId(variant)) =\n-                    self.infer.as_ref()?.variant_resolution_for_expr(expr_id)\n+                    infer.variant_resolution_for_expr(expr_id)\n                 {\n                     return Some(PathResolution::Def(ModuleDef::Variant(variant.into())));\n                 }\n@@ -541,8 +544,7 @@ impl SourceAnalyzer {\n                     || parent().and_then(ast::TupleStructPat::cast).map(ast::Pat::from);\n                 if let Some(pat) = record_pat.or_else(tuple_struct_pat) {\n                     let pat_id = self.pat_id(&pat)?;\n-                    let variant_res_for_pat =\n-                        self.infer.as_ref()?.variant_resolution_for_pat(pat_id);\n+                    let variant_res_for_pat = infer.variant_resolution_for_pat(pat_id);\n                     if let Some(VariantId::EnumVariantId(variant)) = variant_res_for_pat {\n                         return Some(PathResolution::Def(ModuleDef::Variant(variant.into())));\n                     }\n@@ -780,37 +782,22 @@ impl SourceAnalyzer {\n         false\n     }\n \n-    fn resolve_impl_method(\n+    fn resolve_impl_method_or_trait_def(\n         &self,\n         db: &dyn HirDatabase,\n         func: FunctionId,\n-        substs: &Substitution,\n-    ) -> Option<FunctionId> {\n-        let impled_trait = match func.lookup(db.upcast()).container {\n-            ItemContainerId::TraitId(trait_id) => trait_id,\n-            _ => return None,\n-        };\n-        if substs.is_empty(Interner) {\n-            return None;\n-        }\n-        let self_ty = substs.at(Interner, 0).ty(Interner)?;\n+        substs: Substitution,\n+    ) -> FunctionId {\n         let krate = self.resolver.krate();\n-        let trait_env = self.resolver.body_owner()?.as_generic_def_id().map_or_else(\n+        let owner = match self.resolver.body_owner() {\n+            Some(it) => it,\n+            None => return func,\n+        };\n+        let env = owner.as_generic_def_id().map_or_else(\n             || Arc::new(hir_ty::TraitEnvironment::empty(krate)),\n             |d| db.trait_environment(d),\n         );\n-\n-        let fun_data = db.function_data(func);\n-        method_resolution::lookup_impl_method(self_ty, db, trait_env, impled_trait, &fun_data.name)\n-    }\n-\n-    fn resolve_impl_method_or_trait_def(\n-        &self,\n-        db: &dyn HirDatabase,\n-        func: FunctionId,\n-        substs: &Substitution,\n-    ) -> FunctionId {\n-        self.resolve_impl_method(db, func, substs).unwrap_or(func)\n+        method_resolution::lookup_impl_method(db, env, func, substs)\n     }\n \n     fn lang_trait_fn("}, {"sha": "f97c67b144ac15e4c67d8ee86d2a6563ebdda77d", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/feefbe79185baa2601ca0cb9634cdc997d137b71/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/feefbe79185baa2601ca0cb9634cdc997d137b71/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=feefbe79185baa2601ca0cb9634cdc997d137b71", "patch": "@@ -1834,4 +1834,86 @@ fn f() {\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn goto_bin_op_multiple_impl() {\n+        check(\n+            r#\"\n+//- minicore: add\n+struct S;\n+impl core::ops::Add for S {\n+    fn add(\n+     //^^^\n+    ) {}\n+}\n+impl core::ops::Add<usize> for S {\n+    fn add(\n+    ) {}\n+}\n+\n+fn f() {\n+    S +$0 S\n+}\n+\"#,\n+        );\n+\n+        check(\n+            r#\"\n+//- minicore: add\n+struct S;\n+impl core::ops::Add for S {\n+    fn add(\n+    ) {}\n+}\n+impl core::ops::Add<usize> for S {\n+    fn add(\n+     //^^^\n+    ) {}\n+}\n+\n+fn f() {\n+    S +$0 0usize\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn path_call_multiple_trait_impl() {\n+        check(\n+            r#\"\n+trait Trait<T> {\n+    fn f(_: T);\n+}\n+impl Trait<i32> for usize {\n+    fn f(_: i32) {}\n+     //^\n+}\n+impl Trait<i64> for usize {\n+    fn f(_: i64) {}\n+}\n+fn main() {\n+    usize::f$0(0i32);\n+}\n+\"#,\n+        );\n+\n+        check(\n+            r#\"\n+trait Trait<T> {\n+    fn f(_: T);\n+}\n+impl Trait<i32> for usize {\n+    fn f(_: i32) {}\n+}\n+impl Trait<i64> for usize {\n+    fn f(_: i64) {}\n+     //^\n+}\n+fn main() {\n+    usize::f$0(0i64);\n+}\n+\"#,\n+        )\n+    }\n }"}]}