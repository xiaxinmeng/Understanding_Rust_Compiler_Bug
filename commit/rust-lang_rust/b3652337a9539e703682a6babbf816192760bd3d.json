{"sha": "b3652337a9539e703682a6babbf816192760bd3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzNjUyMzM3YTk1MzllNzAzNjgyYTZiYWJiZjgxNjE5Mjc2MGJkM2Q=", "commit": {"author": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2020-06-30T15:18:13Z"}, "committer": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2020-06-30T15:37:53Z"}, "message": "Deny unsafe ops in unsafe fns, part 5", "tree": {"sha": "32dc34ae8b959074e0451520427e19a3cc7852c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32dc34ae8b959074e0451520427e19a3cc7852c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3652337a9539e703682a6babbf816192760bd3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3652337a9539e703682a6babbf816192760bd3d", "html_url": "https://github.com/rust-lang/rust/commit/b3652337a9539e703682a6babbf816192760bd3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3652337a9539e703682a6babbf816192760bd3d/comments", "author": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c68f478131a94f5a69d91db1af35cb506f673ec2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c68f478131a94f5a69d91db1af35cb506f673ec2", "html_url": "https://github.com/rust-lang/rust/commit/c68f478131a94f5a69d91db1af35cb506f673ec2"}], "stats": {"total": 155, "additions": 108, "deletions": 47}, "files": [{"sha": "dda1d3467b66f707a2009889c90266cb3141ce9e", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b3652337a9539e703682a6babbf816192760bd3d/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3652337a9539e703682a6babbf816192760bd3d/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=b3652337a9539e703682a6babbf816192760bd3d", "patch": "@@ -1,5 +1,6 @@\n #![stable(feature = \"\", since = \"1.30.0\")]\n #![allow(non_camel_case_types)]\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n //! Utilities related to FFI bindings.\n \n@@ -333,7 +334,8 @@ impl<'f> VaListImpl<'f> {\n     /// Advance to the next arg.\n     #[inline]\n     pub unsafe fn arg<T: sealed_trait::VaArgSafe>(&mut self) -> T {\n-        va_arg(self)\n+        // SAFETY: the caller must uphold the safety contract for `va_arg`.\n+        unsafe { va_arg(self) }\n     }\n \n     /// Copies the `va_list` at the current location.\n@@ -343,7 +345,10 @@ impl<'f> VaListImpl<'f> {\n     {\n         let mut ap = self.clone();\n         let ret = f(ap.as_va_list());\n-        va_end(&mut ap);\n+        // SAFETY: the caller must uphold the safety contract for `va_end`.\n+        unsafe {\n+            va_end(&mut ap);\n+        }\n         ret\n     }\n }"}, {"sha": "ad9c43eccc12e22b6f74ab8b154f94059b4bf8f9", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 101, "deletions": 43, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/b3652337a9539e703682a6babbf816192760bd3d/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3652337a9539e703682a6babbf816192760bd3d/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=b3652337a9539e703682a6babbf816192760bd3d", "patch": "@@ -8,6 +8,7 @@\n //! [`std::slice`]: ../../std/slice/index.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n // How this module is organized.\n //\n@@ -310,7 +311,8 @@ impl<T> [T] {\n     where\n         I: SliceIndex<Self>,\n     {\n-        index.get_unchecked(self)\n+        // SAFETY: the caller must uphold the safety requirements for `get_unchecked`.\n+        unsafe { index.get_unchecked(self) }\n     }\n \n     /// Returns a mutable reference to an element or subslice, without doing\n@@ -341,7 +343,8 @@ impl<T> [T] {\n     where\n         I: SliceIndex<Self>,\n     {\n-        index.get_unchecked_mut(self)\n+        // SAFETY: the caller must uphold the safety requirements for `get_unchecked_mut`.\n+        unsafe { index.get_unchecked_mut(self) }\n     }\n \n     /// Returns a raw pointer to the slice's buffer.\n@@ -2519,18 +2522,21 @@ impl<T> [T] {\n         // First, find at what point do we split between the first and 2nd slice. Easy with\n         // ptr.align_offset.\n         let ptr = self.as_ptr();\n-        let offset = crate::ptr::align_offset(ptr, mem::align_of::<U>());\n+        let offset = unsafe { crate::ptr::align_offset(ptr, mem::align_of::<U>()) };\n         if offset > self.len() {\n             (self, &[], &[])\n         } else {\n             let (left, rest) = self.split_at(offset);\n-            // now `rest` is definitely aligned, so `from_raw_parts_mut` below is okay\n             let (us_len, ts_len) = rest.align_to_offsets::<U>();\n-            (\n-                left,\n-                from_raw_parts(rest.as_ptr() as *const U, us_len),\n-                from_raw_parts(rest.as_ptr().add(rest.len() - ts_len), ts_len),\n-            )\n+            // SAFETY: now `rest` is definitely aligned, so `from_raw_parts` below is okay,\n+            // since the caller guarantees that we can transmute `T` to `U` safely.\n+            unsafe {\n+                (\n+                    left,\n+                    from_raw_parts(rest.as_ptr() as *const U, us_len),\n+                    from_raw_parts(rest.as_ptr().add(rest.len() - ts_len), ts_len),\n+                )\n+            }\n         }\n     }\n \n@@ -2575,21 +2581,23 @@ impl<T> [T] {\n         // First, find at what point do we split between the first and 2nd slice. Easy with\n         // ptr.align_offset.\n         let ptr = self.as_ptr();\n-        let offset = crate::ptr::align_offset(ptr, mem::align_of::<U>());\n+        let offset = unsafe { crate::ptr::align_offset(ptr, mem::align_of::<U>()) };\n         if offset > self.len() {\n             (self, &mut [], &mut [])\n         } else {\n             let (left, rest) = self.split_at_mut(offset);\n-            // now `rest` is definitely aligned, so `from_raw_parts_mut` below is okay\n             let (us_len, ts_len) = rest.align_to_offsets::<U>();\n             let rest_len = rest.len();\n             let mut_ptr = rest.as_mut_ptr();\n             // We can't use `rest` again after this, that would invalidate its alias `mut_ptr`!\n-            (\n-                left,\n-                from_raw_parts_mut(mut_ptr as *mut U, us_len),\n-                from_raw_parts_mut(mut_ptr.add(rest_len - ts_len), ts_len),\n-            )\n+            // SAFETY: see comments for `align_to`.\n+            unsafe {\n+                (\n+                    left,\n+                    from_raw_parts_mut(mut_ptr as *mut U, us_len),\n+                    from_raw_parts_mut(mut_ptr.add(rest_len - ts_len), ts_len),\n+                )\n+            }\n         }\n     }\n \n@@ -2914,12 +2922,18 @@ impl<T> SliceIndex<[T]> for usize {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &T {\n-        &*slice.as_ptr().add(self)\n+        // SAFETY: `slice` cannot be longer than `isize::MAX` and\n+        // the caller guarantees that `self` is in bounds of `slice`\n+        // so `self` cannot overflow an `isize`, so the call to `add` is safe.\n+        // The obtained pointer comes from a reference which is guaranteed\n+        // to be valid.\n+        unsafe { &*slice.as_ptr().add(self) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut T {\n-        &mut *slice.as_mut_ptr().add(self)\n+        // SAFETY: see comments for `get_unchecked` above.\n+        unsafe { &mut *slice.as_mut_ptr().add(self) }\n     }\n \n     #[inline]\n@@ -2959,12 +2973,18 @@ impl<T> SliceIndex<[T]> for ops::Range<usize> {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start)\n+        // SAFETY: `slice` cannot be longer than `isize::MAX` and\n+        // the caller guarantees that `self` is in bounds of `slice`\n+        // so `self` cannot overflow an `isize`, so the call to `add` is safe.\n+        // Also, since the caller guarantees that `self` is in bounds of `slice`,\n+        // `from_raw_parts` will give a subslice of `slice` which is always safe.\n+        unsafe { from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n-        from_raw_parts_mut(slice.as_mut_ptr().add(self.start), self.end - self.start)\n+        // SAFETY: see comments for `get_unchecked` above.\n+        unsafe { from_raw_parts_mut(slice.as_mut_ptr().add(self.start), self.end - self.start) }\n     }\n \n     #[inline]\n@@ -3004,12 +3024,14 @@ impl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        (0..self.end).get_unchecked(slice)\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n+        unsafe { (0..self.end).get_unchecked(slice) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n-        (0..self.end).get_unchecked_mut(slice)\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (0..self.end).get_unchecked_mut(slice) }\n     }\n \n     #[inline]\n@@ -3039,12 +3061,14 @@ impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        (self.start..slice.len()).get_unchecked(slice)\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n+        unsafe { (self.start..slice.len()).get_unchecked(slice) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n-        (self.start..slice.len()).get_unchecked_mut(slice)\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (self.start..slice.len()).get_unchecked_mut(slice) }\n     }\n \n     #[inline]\n@@ -3113,12 +3137,14 @@ impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        (*self.start()..self.end() + 1).get_unchecked(slice)\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n+        unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n-        (*self.start()..self.end() + 1).get_unchecked_mut(slice)\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n     }\n \n     #[inline]\n@@ -3154,12 +3180,14 @@ impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        (0..=self.end).get_unchecked(slice)\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n+        unsafe { (0..=self.end).get_unchecked(slice) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n-        (0..=self.end).get_unchecked_mut(slice)\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (0..=self.end).get_unchecked_mut(slice) }\n     }\n \n     #[inline]\n@@ -3308,7 +3336,9 @@ macro_rules! iterator {\n                     self.ptr.as_ptr()\n                 } else {\n                     let old = self.ptr.as_ptr();\n-                    self.ptr = NonNull::new_unchecked(self.ptr.as_ptr().offset(offset));\n+                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n+                    // so this new pointer is inside `self` and thus guaranteed to be non-null.\n+                    self.ptr = unsafe { NonNull::new_unchecked(self.ptr.as_ptr().offset(offset)) };\n                     old\n                 }\n             }\n@@ -3322,7 +3352,10 @@ macro_rules! iterator {\n                     zst_shrink!(self, offset);\n                     self.ptr.as_ptr()\n                 } else {\n-                    self.end = self.end.offset(-offset);\n+                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n+                    // which is guaranteed to not overflow an `isize`. Also, the resulting pointer\n+                    // is in bounds of `slice`, which fulfills the other requirements for `offset`.\n+                    self.end = unsafe { self.end.offset(-offset) };\n                     self.end\n                 }\n             }\n@@ -4640,7 +4673,11 @@ impl<T> FusedIterator for Windows<'_, T> {}\n #[doc(hidden)]\n unsafe impl<'a, T> TrustedRandomAccess for Windows<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n-        from_raw_parts(self.v.as_ptr().add(i), self.size)\n+        // SAFETY: since the caller guarantees that `i` is in bounds,\n+        // which means that `i` cannot overflow an `isize`, and the\n+        // slice created by `from_raw_parts` is a subslice of `self.v`\n+        // thus is guaranteed to be valid for the lifetime `'a` of `self.v`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(i), self.size) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -4784,7 +4821,14 @@ unsafe impl<'a, T> TrustedRandomAccess for Chunks<'a, T> {\n             None => self.v.len(),\n             Some(end) => cmp::min(end, self.v.len()),\n         };\n-        from_raw_parts(self.v.as_ptr().add(start), end - start)\n+        // SAFETY: the caller guarantees that `i` is in bounds,\n+        // which means that `start` must be in bounds of the\n+        // underlying `self.v` slice, and we made sure that `end`\n+        // is also in bounds of `self.v`. Thus, `start` cannot overflow\n+        // an `isize`, and the slice constructed by `from_raw_parts`\n+        // is a subslice of `self.v` which is guaranteed to be valid\n+        // for the lifetime `'a` of `self.v`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(start), end - start) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -4926,7 +4970,8 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksMut<'a, T> {\n             None => self.v.len(),\n             Some(end) => cmp::min(end, self.v.len()),\n         };\n-        from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start)\n+        // SAFETY: see comments for `Chunks::get_unchecked`.\n+        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -5063,7 +5108,8 @@ impl<T> FusedIterator for ChunksExact<'_, T> {}\n unsafe impl<'a, T> TrustedRandomAccess for ChunksExact<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n         let start = i * self.chunk_size;\n-        from_raw_parts(self.v.as_ptr().add(start), self.chunk_size)\n+        // SAFETY: mostly identical to `Chunks::get_unchecked`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(start), self.chunk_size) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -5197,7 +5243,8 @@ impl<T> FusedIterator for ChunksExactMut<'_, T> {}\n unsafe impl<'a, T> TrustedRandomAccess for ChunksExactMut<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T] {\n         let start = i * self.chunk_size;\n-        from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size)\n+        // SAFETY: see comments for `ChunksExactMut::get_unchecked`.\n+        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -5344,7 +5391,8 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunks<'a, T> {\n             None => 0,\n             Some(start) => start,\n         };\n-        from_raw_parts(self.v.as_ptr().add(start), end - start)\n+        // SAFETY: mostly identical to `Chunks::get_unchecked`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(start), end - start) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -5489,7 +5537,8 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksMut<'a, T> {\n             None => 0,\n             Some(start) => start,\n         };\n-        from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start)\n+        // SAFETY: see comments for `RChunks::get_unchecked`.\n+        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -5630,7 +5679,8 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksExact<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n         let end = self.v.len() - i * self.chunk_size;\n         let start = end - self.chunk_size;\n-        from_raw_parts(self.v.as_ptr().add(start), self.chunk_size)\n+        // SAFETY: mostmy identical to `Chunks::get_unchecked`.\n+        unsafe { from_raw_parts(self.v.as_ptr().add(start), self.chunk_size) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -5769,7 +5819,8 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksExactMut<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T] {\n         let end = self.v.len() - i * self.chunk_size;\n         let start = end - self.chunk_size;\n-        from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size)\n+        // SAFETY: see comments for `RChunksExact::get_unchecked`.\n+        unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -5865,7 +5916,8 @@ pub unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n         mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize,\n         \"attempt to create slice covering at least half the address space\"\n     );\n-    &*ptr::slice_from_raw_parts(data, len)\n+    // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n+    unsafe { &*ptr::slice_from_raw_parts(data, len) }\n }\n \n /// Performs the same functionality as [`from_raw_parts`], except that a\n@@ -5905,7 +5957,8 @@ pub unsafe fn from_raw_parts_mut<'a, T>(data: *mut T, len: usize) -> &'a mut [T]\n         mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize,\n         \"attempt to create slice covering at least half the address space\"\n     );\n-    &mut *ptr::slice_from_raw_parts_mut(data, len)\n+    // SAFETY: the caller must uphold the safety contract for `from_raw_parts_mut`.\n+    unsafe { &mut *ptr::slice_from_raw_parts_mut(data, len) }\n }\n \n /// Converts a reference to T into a slice of length 1 (without copying).\n@@ -6181,7 +6234,11 @@ impl_marker_for!(BytewiseEquality,\n #[doc(hidden)]\n unsafe impl<'a, T> TrustedRandomAccess for Iter<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a T {\n-        &*self.ptr.as_ptr().add(i)\n+        // SAFETY: the caller must guarantee that `i` is in bounds\n+        // of the underlying slice, so `i` cannot overflow an `isize`,\n+        // and the returned references is guaranteed to refer to an element\n+        // of the slice and thus guaranteed to be valid.\n+        unsafe { &*self.ptr.as_ptr().add(i) }\n     }\n     fn may_have_side_effect() -> bool {\n         false\n@@ -6191,7 +6248,8 @@ unsafe impl<'a, T> TrustedRandomAccess for Iter<'a, T> {\n #[doc(hidden)]\n unsafe impl<'a, T> TrustedRandomAccess for IterMut<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut T {\n-        &mut *self.ptr.as_ptr().add(i)\n+        // SAFETY: see comments for `Iter::get_unchecked`.\n+        unsafe { &mut *self.ptr.as_ptr().add(i) }\n     }\n     fn may_have_side_effect() -> bool {\n         false"}, {"sha": "a89596b15ef94c31122c845e3f6041449f6018e8", "filename": "src/libcore/slice/rotate.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3652337a9539e703682a6babbf816192760bd3d/src%2Flibcore%2Fslice%2Frotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3652337a9539e703682a6babbf816192760bd3d/src%2Flibcore%2Fslice%2Frotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Frotate.rs?ref=b3652337a9539e703682a6babbf816192760bd3d", "patch": "@@ -1,7 +1,5 @@\n // ignore-tidy-undocumented-unsafe\n \n-#![deny(unsafe_op_in_unsafe_fn)]\n-\n use crate::cmp;\n use crate::mem::{self, MaybeUninit};\n use crate::ptr;"}]}