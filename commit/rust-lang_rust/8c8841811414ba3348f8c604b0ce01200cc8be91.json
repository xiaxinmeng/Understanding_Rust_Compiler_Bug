{"sha": "8c8841811414ba3348f8c604b0ce01200cc8be91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjODg0MTgxMTQxNGJhMzM0OGY4YzYwNGIwY2UwMTIwMGNjOGJlOTE=", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2021-03-25T03:26:18Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2021-03-25T04:14:00Z"}, "message": "Try to make Vec benchmarks only run code they are benchmarking\n\nMany of the Vec benchmarks assert what values should be produced by the\nbenchmarked code. In some cases, these asserts dominate the runtime of\nthe benchmarks they are in, causing the benchmarks to understate the\nimpact of an optimization or regression.", "tree": {"sha": "bfe9b7838754e58ba4cabca790347d8c9df1b1d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfe9b7838754e58ba4cabca790347d8c9df1b1d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c8841811414ba3348f8c604b0ce01200cc8be91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c8841811414ba3348f8c604b0ce01200cc8be91", "html_url": "https://github.com/rust-lang/rust/commit/8c8841811414ba3348f8c604b0ce01200cc8be91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c8841811414ba3348f8c604b0ce01200cc8be91/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07e0e2ec268c140e607e1ac7f49f145612d0f597", "url": "https://api.github.com/repos/rust-lang/rust/commits/07e0e2ec268c140e607e1ac7f49f145612d0f597", "html_url": "https://github.com/rust-lang/rust/commit/07e0e2ec268c140e607e1ac7f49f145612d0f597"}], "stats": {"total": 93, "additions": 25, "deletions": 68}, "files": [{"sha": "48709e89823d8b850b3ae55967d55fb0ed82227f", "filename": "library/alloc/benches/vec.rs", "status": "modified", "additions": 25, "deletions": 68, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/8c8841811414ba3348f8c604b0ce01200cc8be91/library%2Falloc%2Fbenches%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c8841811414ba3348f8c604b0ce01200cc8be91/library%2Falloc%2Fbenches%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fvec.rs?ref=8c8841811414ba3348f8c604b0ce01200cc8be91", "patch": "@@ -4,23 +4,13 @@ use test::{black_box, Bencher};\n \n #[bench]\n fn bench_new(b: &mut Bencher) {\n-    b.iter(|| {\n-        let v: Vec<u32> = Vec::new();\n-        assert_eq!(v.len(), 0);\n-        assert_eq!(v.capacity(), 0);\n-        v\n-    })\n+    b.iter(|| Vec::<u32>::new())\n }\n \n fn do_bench_with_capacity(b: &mut Bencher, src_len: usize) {\n     b.bytes = src_len as u64;\n \n-    b.iter(|| {\n-        let v: Vec<u32> = Vec::with_capacity(src_len);\n-        assert_eq!(v.len(), 0);\n-        assert_eq!(v.capacity(), src_len);\n-        v\n-    })\n+    b.iter(|| Vec::<u32>::with_capacity(src_len))\n }\n \n #[bench]\n@@ -46,12 +36,7 @@ fn bench_with_capacity_1000(b: &mut Bencher) {\n fn do_bench_from_fn(b: &mut Bencher, src_len: usize) {\n     b.bytes = src_len as u64;\n \n-    b.iter(|| {\n-        let dst = (0..src_len).collect::<Vec<_>>();\n-        assert_eq!(dst.len(), src_len);\n-        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n-        dst\n-    })\n+    b.iter(|| (0..src_len).collect::<Vec<_>>())\n }\n \n #[bench]\n@@ -77,12 +62,7 @@ fn bench_from_fn_1000(b: &mut Bencher) {\n fn do_bench_from_elem(b: &mut Bencher, src_len: usize) {\n     b.bytes = src_len as u64;\n \n-    b.iter(|| {\n-        let dst: Vec<usize> = repeat(5).take(src_len).collect();\n-        assert_eq!(dst.len(), src_len);\n-        assert!(dst.iter().all(|x| *x == 5));\n-        dst\n-    })\n+    b.iter(|| repeat(5).take(src_len).collect::<Vec<usize>>())\n }\n \n #[bench]\n@@ -110,12 +90,7 @@ fn do_bench_from_slice(b: &mut Bencher, src_len: usize) {\n \n     b.bytes = src_len as u64;\n \n-    b.iter(|| {\n-        let dst = src.clone()[..].to_vec();\n-        assert_eq!(dst.len(), src_len);\n-        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n-        dst\n-    });\n+    b.iter(|| src.as_slice().to_vec());\n }\n \n #[bench]\n@@ -144,9 +119,7 @@ fn do_bench_from_iter(b: &mut Bencher, src_len: usize) {\n     b.bytes = src_len as u64;\n \n     b.iter(|| {\n-        let dst: Vec<_> = FromIterator::from_iter(src.clone());\n-        assert_eq!(dst.len(), src_len);\n-        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+        let dst: Vec<_> = FromIterator::from_iter(src.iter().cloned());\n         dst\n     });\n }\n@@ -180,8 +153,6 @@ fn do_bench_extend(b: &mut Bencher, dst_len: usize, src_len: usize) {\n     b.iter(|| {\n         let mut dst = dst.clone();\n         dst.extend(src.clone());\n-        assert_eq!(dst.len(), dst_len + src_len);\n-        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n         dst\n     });\n }\n@@ -230,8 +201,6 @@ fn do_bench_extend_from_slice(b: &mut Bencher, dst_len: usize, src_len: usize) {\n     b.iter(|| {\n         let mut dst = dst.clone();\n         dst.extend_from_slice(&src);\n-        assert_eq!(dst.len(), dst_len + src_len);\n-        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n         dst\n     });\n }\n@@ -290,12 +259,7 @@ fn do_bench_clone(b: &mut Bencher, src_len: usize) {\n \n     b.bytes = src_len as u64;\n \n-    b.iter(|| {\n-        let dst = src.clone();\n-        assert_eq!(dst.len(), src_len);\n-        assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n-        dst\n-    });\n+    b.iter(|| src.clone());\n }\n \n #[bench]\n@@ -329,8 +293,7 @@ fn do_bench_clone_from(b: &mut Bencher, times: usize, dst_len: usize, src_len: u\n \n         for _ in 0..times {\n             dst.clone_from(&src);\n-            assert_eq!(dst.len(), src_len);\n-            assert!(dst.iter().enumerate().all(|(i, x)| dst_len + i == *x));\n+            dst = black_box(dst);\n         }\n         dst\n     });\n@@ -463,11 +426,10 @@ macro_rules! bench_in_place {\n             fn $fname(b: &mut Bencher) {\n                 b.iter(|| {\n                     let src: Vec<$type> = black_box(vec![$init; $count]);\n-                    let mut sink = src.into_iter()\n+                    src.into_iter()\n                         .enumerate()\n                         .map(|(idx, e)| idx as $type ^ e)\n-                        .collect::<Vec<$type>>();\n-                    black_box(sink.as_mut_ptr())\n+                        .collect::<Vec<$type>>()\n                 });\n             }\n         )+\n@@ -527,7 +489,6 @@ fn bench_in_place_zip_recycle(b: &mut Bencher) {\n             .enumerate()\n             .map(|(i, (d, s))| d.wrapping_add(i as u8) ^ s)\n             .collect::<Vec<_>>();\n-        assert_eq!(mangled.len(), 1000);\n         data = black_box(mangled);\n     });\n }\n@@ -614,23 +575,6 @@ fn bench_nest_chain_chain_collect(b: &mut Bencher) {\n     });\n }\n \n-pub fn example_plain_slow(l: &[u32]) -> Vec<u32> {\n-    let mut result = Vec::with_capacity(l.len());\n-    result.extend(l.iter().rev());\n-    result\n-}\n-\n-pub fn map_fast(l: &[(u32, u32)]) -> Vec<u32> {\n-    let mut result = Vec::with_capacity(l.len());\n-    for i in 0..l.len() {\n-        unsafe {\n-            *result.get_unchecked_mut(i) = l[i].0;\n-            result.set_len(i);\n-        }\n-    }\n-    result\n-}\n-\n #[bench]\n fn bench_range_map_collect(b: &mut Bencher) {\n     b.iter(|| (0..LEN).map(|_| u32::default()).collect::<Vec<_>>());\n@@ -669,7 +613,11 @@ fn bench_rev_1(b: &mut Bencher) {\n #[bench]\n fn bench_rev_2(b: &mut Bencher) {\n     let data = black_box([0; LEN]);\n-    b.iter(|| example_plain_slow(&data));\n+    b.iter(|| {\n+        let mut v = Vec::<u32>::with_capacity(data.len());\n+        v.extend(data.iter().rev());\n+        v\n+    });\n }\n \n #[bench]\n@@ -685,7 +633,16 @@ fn bench_map_regular(b: &mut Bencher) {\n #[bench]\n fn bench_map_fast(b: &mut Bencher) {\n     let data = black_box([(0, 0); LEN]);\n-    b.iter(|| map_fast(&data));\n+    b.iter(|| {\n+        let mut result = Vec::with_capacity(data.len());\n+        for i in 0..data.len() {\n+            unsafe {\n+                *result.get_unchecked_mut(i) = data[i].0;\n+                result.set_len(i);\n+            }\n+        }\n+        result\n+    });\n }\n \n fn random_sorted_fill(mut seed: u32, buf: &mut [u32]) {"}]}