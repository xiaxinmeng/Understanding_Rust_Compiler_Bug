{"sha": "fbd34efb32b9efb574899e4335bdc8c6525ac27e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiZDM0ZWZiMzJiOWVmYjU3NDg5OWU0MzM1YmRjOGM2NTI1YWMyN2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-26T17:25:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-26T17:25:16Z"}, "message": "Auto merge of #59433 - Centril:rollup, r=Centril\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #59150 (Expand suggestions for type ascription parse errors)\n - #59232 (Merge `Promoted` and `Static` in `mir::Place`)\n - #59267 (Provide suggestion when using field access instead of path)\n - #59315 (Add no_hash to query macro and move some queries over)\n - #59334 (Update build instructions in README.md)\n - #59362 (Demo `FromIterator` short-circuiting)\n - #59374 (Simplify checked_duration_since)\n - #59389 (replace redundant note in deprecation warning)\n - #59410 (Clarify `{Ord,f32,f64}::clamp` docs a little)\n - #59419 (Utilize `?` instead of `return None`.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "53ca160f6c731c05e092002bae40e03b22dae376", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53ca160f6c731c05e092002bae40e03b22dae376"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbd34efb32b9efb574899e4335bdc8c6525ac27e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbd34efb32b9efb574899e4335bdc8c6525ac27e", "html_url": "https://github.com/rust-lang/rust/commit/fbd34efb32b9efb574899e4335bdc8c6525ac27e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbd34efb32b9efb574899e4335bdc8c6525ac27e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07d350897c7f95bb40ae9762ad1e945f95fc37ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/07d350897c7f95bb40ae9762ad1e945f95fc37ae", "html_url": "https://github.com/rust-lang/rust/commit/07d350897c7f95bb40ae9762ad1e945f95fc37ae"}, {"sha": "822b4fcb3bb583240c47158ee91d8ed6ae805e45", "url": "https://api.github.com/repos/rust-lang/rust/commits/822b4fcb3bb583240c47158ee91d8ed6ae805e45", "html_url": "https://github.com/rust-lang/rust/commit/822b4fcb3bb583240c47158ee91d8ed6ae805e45"}], "stats": {"total": 1889, "additions": 1191, "deletions": 698}, "files": [{"sha": "7fd39bd1f6eb637c072f8542075a7667e2f7b8d2", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -2811,6 +2811,7 @@ dependencies = [\n name = \"rustc_macros\"\n version = \"0.1.0\"\n dependencies = [\n+ \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syn 0.15.22 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "55e6e8d7f188925804bc82aa14e68a7b63e65a15", "filename": "README.md", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -45,6 +45,22 @@ of the rustc-guide instead._\n     $ ./x.py build && sudo ./x.py install\n     ```\n \n+    If after running `sudo ./x.py install` you see an error message like\n+\n+    ```\n+    error: failed to load source for a dependency on 'cc'\n+    ```\n+\n+    then run these two commands and then try `sudo ./x.py install` again:\n+\n+    ```\n+    $ cargo install cargo-vendor\n+    ```\n+\n+    ```\n+    $ cargo vendor\n+    ```\n+\n     > ***Note:*** Install locations can be adjusted by copying the config file\n     > from `./config.toml.example` to `./config.toml`, and\n     > adjusting the `prefix` option under `[install]`. Various other options, such"}, {"sha": "807b35e1af10b1e35350751408a83516dee349f1", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -568,8 +568,14 @@ pub trait Ord: Eq + PartialOrd<Self> {\n         if self <= other { self } else { other }\n     }\n \n-    /// Returns max if self is greater than max, and min if self is less than min.\n-    /// Otherwise this will return self.  Panics if min > max.\n+    /// Restrict a value to a certain interval.\n+    ///\n+    /// Returns `max` if `self` is greater than `max`, and `min` if `self` is\n+    /// less than `min`. Otherwise this returns `self`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `min > max`.\n     ///\n     /// # Examples\n     ///\n@@ -586,8 +592,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n         assert!(min <= max);\n         if self < min {\n             min\n-        }\n-        else if self > max {\n+        } else if self > max {\n             max\n         } else {\n             self"}, {"sha": "c9a9375ec590e7032dd42b80f1d5db602e3152f8", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -239,10 +239,8 @@ impl<'a> Formatted<'a> {\n \n         let mut written = self.sign.len();\n         for part in self.parts {\n-            match part.write(&mut out[written..]) {\n-                Some(len) => { written += len; }\n-                None => { return None; }\n-            }\n+            let len = part.write(&mut out[written..])?;\n+            written += len;\n         }\n         Some(written)\n     }"}, {"sha": "3da92c0a05ac4ece408b25b610df2a07fbe18ff4", "filename": "src/libcore/option.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -1315,6 +1315,26 @@ impl<A, V: FromIterator<A>> FromIterator<Option<A>> for Option<V> {\n     /// Since the last element is zero, it would underflow. Thus, the resulting\n     /// value is `None`.\n     ///\n+    /// Here is a variation on the previous example, showing that no\n+    /// further elements are taken from `iter` after the first `None`.\n+    ///\n+    /// ```\n+    /// let items = vec![3_u16, 2, 1, 10];\n+    ///\n+    /// let mut shared = 0;\n+    ///\n+    /// let res: Option<Vec<u16>> = items\n+    ///     .iter()\n+    ///     .map(|x| { shared += x; x.checked_sub(2) })\n+    ///     .collect();\n+    ///\n+    /// assert_eq!(res, None);\n+    /// assert_eq!(shared, 6);\n+    /// ```\n+    ///\n+    /// Since the third element caused an underflow, no further elements were taken,\n+    /// so the final value of `shared` is 6 (= `3 + 2 + 1`), not 16.\n+    ///\n     /// [`Iterator`]: ../iter/trait.Iterator.html\n     #[inline]\n     fn from_iter<I: IntoIterator<Item=Option<A>>>(iter: I) -> Option<V> {"}, {"sha": "9b7b83689861bca2bdea241c7ceb392c7a5c4ef8", "filename": "src/libcore/result.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -1202,6 +1202,34 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n     /// ).collect();\n     /// assert_eq!(res, Ok(vec![2, 3]));\n     /// ```\n+    ///\n+    /// Here is another example that tries to subtract one from another list\n+    /// of integers, this time checking for underflow:\n+    ///\n+    /// ```\n+    /// let v = vec![1, 2, 0];\n+    /// let res: Result<Vec<u32>, &'static str> = v.iter().map(|x: &u32|\n+    ///     x.checked_sub(1).ok_or(\"Underflow!\")\n+    /// ).collect();\n+    /// assert_eq!(res, Err(\"Underflow!\"));\n+    /// ```\n+    ///\n+    /// Here is a variation on the previous example, showing that no\n+    /// further elements are taken from `iter` after the first `Err`.\n+    ///\n+    /// ```\n+    /// let v = vec![3, 2, 1, 10];\n+    /// let mut shared = 0;\n+    /// let res: Result<Vec<u32>, &'static str> = v.iter().map(|x: &u32| {\n+    ///     shared += x;\n+    ///     x.checked_sub(2).ok_or(\"Underflow!\")\n+    /// }).collect();\n+    /// assert_eq!(res, Err(\"Underflow!\"));\n+    /// assert_eq!(shared, 6);\n+    /// ```\n+    ///\n+    /// Since the third element caused an underflow, no further elements were taken,\n+    /// so the final value of `shared` is 6 (= `3 + 2 + 1`), not 16.\n     #[inline]\n     fn from_iter<I: IntoIterator<Item=Result<A, E>>>(iter: I) -> Result<V, E> {\n         // FIXME(#11084): This could be replaced with Iterator::scan when this"}, {"sha": "4babadb67bce6e428131310885be27f5e86f0e0a", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -461,11 +461,6 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n \n     // Represents the MIR for a fn; also used as the task node for\n     // things read/modify that MIR.\n-    [] MirConstQualif(DefId),\n-    [] MirBuilt(DefId),\n-    [] MirConst(DefId),\n-    [] MirValidated(DefId),\n-    [] MirOptimized(DefId),\n     [] MirShim { instance_def: InstanceDef<'tcx> },\n \n     [] BorrowCheckKrate,\n@@ -485,7 +480,6 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n     [] CollectModItemTypes(DefId),\n \n     [] Reachability,\n-    [] MirKeys,\n     [eval_always] CrateVariances,\n \n     // Nodes representing bits of computed IR in the tcx. Each shared\n@@ -544,7 +538,6 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n     [anon] TraitSelect,\n \n     [] ParamEnv(DefId),\n-    [] Environment(DefId),\n     [] DescribeDef(DefId),\n \n     // FIXME(mw): DefSpans are not really inputs since they are derived from\n@@ -571,7 +564,6 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n     [] HasGlobalAllocator(CrateNum),\n     [] HasPanicHandler(CrateNum),\n     [input] ExternCrate(DefId),\n-    [eval_always] LintLevels,\n     [] Specializes { impl1: DefId, impl2: DefId },\n     [input] InScopeTraits(DefIndex),\n     [input] ModuleExports(DefId),\n@@ -621,14 +613,6 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n     [input] UsedCrateSource(CrateNum),\n     [input] PostorderCnums,\n \n-    // These queries are not expected to have inputs -- as a result, they\n-    // are not good candidates for \"replay\" because they are essentially\n-    // pure functions of their input (and hence the expectation is that\n-    // no caller would be green **apart** from just these\n-    // queries). Making them anonymous avoids hashing the result, which\n-    // may save a bit of time.\n-    [anon] EraseRegionsTy { ty: Ty<'tcx> },\n-\n     [input] Freevars(DefId),\n     [input] MaybeUnusedTraitImport(DefId),\n     [input] MaybeUnusedExternCrates,\n@@ -667,9 +651,6 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n \n     [input] Features,\n \n-    [] ProgramClausesFor(DefId),\n-    [] ProgramClausesForEnv(traits::Environment<'tcx>),\n-    [] WasmImportModuleMap(CrateNum),\n     [] ForeignModules(CrateNum),\n \n     [] UpstreamMonomorphizations(CrateNum),"}, {"sha": "ef1270d304523949f46b9e7a7544284cf2847162", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -582,7 +582,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 if let hir::Node::Expr(_) = self.hir().get_by_hir_id(id) {\n                     diag.span_suggestion(\n                         span,\n-                        &msg,\n+                        \"replace the use of the deprecated item\",\n                         suggestion.to_string(),\n                         Applicability::MachineApplicable,\n                     );"}, {"sha": "d35ee1e57d5ce35d72f23ea3af7830cf37a62525", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -1913,22 +1913,24 @@ pub enum PlaceBase<'tcx> {\n \n     /// static or static mut variable\n     Static(Box<Static<'tcx>>),\n-\n-    /// Constant code promoted to an injected static\n-    Promoted(Box<(Promoted, Ty<'tcx>)>),\n }\n \n-/// The `DefId` of a static, along with its normalized type (which is\n-/// stored to avoid requiring normalization when reading MIR).\n+/// We store the normalized type to avoid requiring normalization when reading MIR\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct Static<'tcx> {\n-    pub def_id: DefId,\n     pub ty: Ty<'tcx>,\n+    pub kind: StaticKind,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable, RustcEncodable, RustcDecodable)]\n+pub enum StaticKind {\n+    Promoted(Promoted),\n+    Static(DefId),\n }\n \n impl_stable_hash_for!(struct Static<'tcx> {\n-    def_id,\n-    ty\n+    ty,\n+    kind\n });\n \n /// The `Projection` data structure defines things of the form `B.x`\n@@ -2048,7 +2050,7 @@ impl<'tcx> Place<'tcx> {\n         match self {\n             Place::Base(PlaceBase::Local(local)) => Some(*local),\n             Place::Projection(box Projection { base, elem: _ }) => base.base_local(),\n-            Place::Base(PlaceBase::Promoted(..)) | Place::Base(PlaceBase::Static(..)) => None,\n+            Place::Base(PlaceBase::Static(..)) => None,\n         }\n     }\n }\n@@ -2059,18 +2061,24 @@ impl<'tcx> Debug for Place<'tcx> {\n \n         match *self {\n             Base(PlaceBase::Local(id)) => write!(fmt, \"{:?}\", id),\n-            Base(PlaceBase::Static(box self::Static { def_id, ty })) => write!(\n-                fmt,\n-                \"({}: {:?})\",\n-                ty::tls::with(|tcx| tcx.def_path_str(def_id)),\n-                ty\n-            ),\n-            Base(PlaceBase::Promoted(ref promoted)) => write!(\n-                fmt,\n-                \"({:?}: {:?})\",\n-                promoted.0,\n-                promoted.1\n-            ),\n+            Base(PlaceBase::Static(box self::Static { ty, kind: StaticKind::Static(def_id) })) => {\n+                write!(\n+                    fmt,\n+                    \"({}: {:?})\",\n+                    ty::tls::with(|tcx| tcx.def_path_str(def_id)),\n+                    ty\n+                )\n+            },\n+            Base(PlaceBase::Static(\n+                box self::Static { ty, kind: StaticKind::Promoted(promoted) })\n+            ) => {\n+                write!(\n+                    fmt,\n+                    \"({:?}: {:?})\",\n+                    promoted,\n+                    ty\n+                )\n+            },\n             Projection(ref data) => match data.elem {\n                 ProjectionElem::Downcast(ref adt_def, index) => {\n                     write!(fmt, \"({:?} as {})\", data.base, adt_def.variants[index].ident)"}, {"sha": "ac42eacacd7bfff0adbdd96c5f1f4f5446727de8", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -160,7 +160,6 @@ impl<'tcx> Place<'tcx> {\n         match *self {\n             Place::Base(PlaceBase::Local(index)) =>\n                 PlaceTy::Ty { ty: local_decls.local_decls()[index].ty },\n-            Place::Base(PlaceBase::Promoted(ref data)) => PlaceTy::Ty { ty: data.1 },\n             Place::Base(PlaceBase::Static(ref data)) =>\n                 PlaceTy::Ty { ty: data.ty },\n             Place::Projection(ref proj) =>"}, {"sha": "54e5bfc4397e8be33144ebceb7d3235c55b30ae1", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -156,13 +156,6 @@ macro_rules! make_mir_visitor {\n                 self.super_place(place, context, location);\n             }\n \n-            fn visit_static(&mut self,\n-                            static_: & $($mutability)? Static<'tcx>,\n-                            context: PlaceContext<'tcx>,\n-                            location: Location) {\n-                self.super_static(static_, context, location);\n-            }\n-\n             fn visit_projection(&mut self,\n                                 place: & $($mutability)? PlaceProjection<'tcx>,\n                                 context: PlaceContext<'tcx>,\n@@ -736,27 +729,18 @@ macro_rules! make_mir_visitor {\n                     Place::Base(PlaceBase::Local(local)) => {\n                         self.visit_local(local, context, location);\n                     }\n-                    Place::Base(PlaceBase::Static(static_)) => {\n-                        self.visit_static(static_, context, location);\n+                    Place::Base(PlaceBase::Static(box Static { kind, ty })) => {\n+                        if let StaticKind::Static(def_id) = kind {\n+                            self.visit_def_id(& $($mutability)? *def_id, location)\n+                        }\n+                        self.visit_ty(& $($mutability)? *ty, TyContext::Location(location));\n                     }\n-                    Place::Base(PlaceBase::Promoted(promoted)) => {\n-                        self.visit_ty(& $($mutability)? promoted.1, TyContext::Location(location));\n-                    },\n                     Place::Projection(proj) => {\n                         self.visit_projection(proj, context, location);\n                     }\n                 }\n             }\n \n-            fn super_static(&mut self,\n-                            static_: & $($mutability)? Static<'tcx>,\n-                            _context: PlaceContext<'tcx>,\n-                            location: Location) {\n-                let Static { def_id, ty } = static_;\n-                self.visit_def_id(def_id, location);\n-                self.visit_ty(ty, TyContext::Location(location));\n-            }\n-\n             fn super_projection(&mut self,\n                                 proj: & $($mutability)? PlaceProjection<'tcx>,\n                                 context: PlaceContext<'tcx>,"}, {"sha": "8d64818f49b18a752086794ad1448a0f107d5f88", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 88, "deletions": 3, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -1,9 +1,9 @@\n use crate::ty::query::QueryDescription;\n use crate::ty::query::queries;\n-use crate::ty::TyCtxt;\n-use crate::ty;\n-use crate::hir::def_id::CrateNum;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::hir::def_id::{DefId, CrateNum};\n use crate::dep_graph::SerializedDepNodeIndex;\n+use crate::traits;\n use std::borrow::Cow;\n \n // Each of these queries corresponds to a function pointer field in the\n@@ -55,6 +55,11 @@ rustc_queries! {\n         query native_libraries(_: CrateNum) -> Lrc<Vec<NativeLibrary>> {\n             desc { \"looking up the native libraries of a linked crate\" }\n         }\n+\n+        query lint_levels(_: CrateNum) -> Lrc<lint::LintLevelMap> {\n+            eval_always\n+            desc { \"computing the lint levels for items in this crate\" }\n+        }\n     }\n \n     Codegen {\n@@ -63,4 +68,84 @@ rustc_queries! {\n             desc { \"checking if the crate is_panic_runtime\" }\n         }\n     }\n+\n+    Codegen {\n+        /// Set of all the `DefId`s in this crate that have MIR associated with\n+        /// them. This includes all the body owners, but also things like struct\n+        /// constructors.\n+        query mir_keys(_: CrateNum) -> Lrc<DefIdSet> {\n+            desc { \"getting a list of all mir_keys\" }\n+        }\n+\n+        /// Maps DefId's that have an associated Mir to the result\n+        /// of the MIR qualify_consts pass. The actual meaning of\n+        /// the value isn't known except to the pass itself.\n+        query mir_const_qualif(key: DefId) -> (u8, Lrc<BitSet<mir::Local>>) {\n+            cache { key.is_local() }\n+        }\n+\n+        /// Fetch the MIR for a given `DefId` right after it's built - this includes\n+        /// unreachable code.\n+        query mir_built(_: DefId) -> &'tcx Steal<mir::Mir<'tcx>> {}\n+\n+        /// Fetch the MIR for a given `DefId` up till the point where it is\n+        /// ready for const evaluation.\n+        ///\n+        /// See the README for the `mir` module for details.\n+        query mir_const(_: DefId) -> &'tcx Steal<mir::Mir<'tcx>> {\n+            no_hash\n+        }\n+\n+        query mir_validated(_: DefId) -> &'tcx Steal<mir::Mir<'tcx>> {\n+            no_hash\n+        }\n+\n+        /// MIR after our optimization passes have run. This is MIR that is ready\n+        /// for codegen. This is also the only query that can fetch non-local MIR, at present.\n+        query optimized_mir(key: DefId) -> &'tcx mir::Mir<'tcx> {\n+            cache { key.is_local() }\n+            load_cached(tcx, id) {\n+                let mir: Option<crate::mir::Mir<'tcx>> = tcx.queries.on_disk_cache\n+                                                            .try_load_query_result(tcx, id);\n+                mir.map(|x| tcx.alloc_mir(x))\n+            }\n+        }\n+    }\n+\n+    TypeChecking {\n+        // Erases regions from `ty` to yield a new type.\n+        // Normally you would just use `tcx.erase_regions(&value)`,\n+        // however, which uses this query as a kind of cache.\n+        query erase_regions_ty(ty: Ty<'tcx>) -> Ty<'tcx> {\n+            // This query is not expected to have input -- as a result, it\n+            // is not a good candidates for \"replay\" because it is essentially a\n+            // pure function of its input (and hence the expectation is that\n+            // no caller would be green **apart** from just these\n+            // queries). Making it anonymous avoids hashing the result, which\n+            // may save a bit of time.\n+            anon\n+            no_force\n+            desc { \"erasing regions from `{:?}`\", ty }\n+        }\n+\n+        query program_clauses_for(_: DefId) -> Clauses<'tcx> {\n+            desc { \"generating chalk-style clauses\" }\n+        }\n+\n+        query program_clauses_for_env(_: traits::Environment<'tcx>) -> Clauses<'tcx> {\n+            no_force\n+            desc { \"generating chalk-style clauses for environment\" }\n+        }\n+\n+        // Get the chalk-style environment of the given item.\n+        query environment(_: DefId) -> traits::Environment<'tcx> {\n+            desc { \"return a chalk-style environment\" }\n+        }\n+    }\n+\n+    Linking {\n+        query wasm_import_module_map(_: CrateNum) -> Lrc<FxHashMap<DefId, String>> {\n+            desc { \"wasm import module map\" }\n+        }\n+    }\n }"}, {"sha": "90f62a4d132c7c1731a9c93d751090cda5ff70f7", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -292,11 +292,7 @@ impl<'cx, 'gcx, 'tcx> Iterator for SupertraitDefIds<'cx, 'gcx, 'tcx> {\n     type Item = DefId;\n \n     fn next(&mut self) -> Option<DefId> {\n-        let def_id = match self.stack.pop() {\n-            Some(def_id) => def_id,\n-            None => { return None; }\n-        };\n-\n+        let def_id = self.stack.pop()?;\n         let predicates = self.tcx.super_predicates_of(def_id);\n         let visited = &mut self.visited;\n         self.stack.extend("}, {"sha": "5cb5a0030f4eb916f63d3c3a10e73036540e41e6", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 1, "deletions": 59, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -305,12 +305,6 @@ impl<'tcx> QueryDescription<'tcx> for queries::super_predicates_of<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::erase_regions_ty<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, ty: Ty<'tcx>) -> Cow<'static, str> {\n-        format!(\"erasing regions from `{:?}`\", ty).into()\n-    }\n-}\n-\n impl<'tcx> QueryDescription<'tcx> for queries::type_param_predicates<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, (_, def_id): (DefId, DefId)) -> Cow<'static, str> {\n         let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n@@ -431,12 +425,6 @@ impl<'tcx> QueryDescription<'tcx> for queries::const_eval_raw<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::mir_keys<'tcx> {\n-    fn describe(_: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"getting a list of all mir_keys\".into()\n-    }\n-}\n-\n impl<'tcx> QueryDescription<'tcx> for queries::symbol_name<'tcx> {\n     fn describe(_tcx: TyCtxt<'_, '_, '_>, instance: ty::Instance<'tcx>) -> Cow<'static, str> {\n         format!(\"computing the symbol for `{}`\", instance).into()\n@@ -617,12 +605,6 @@ impl<'tcx> QueryDescription<'tcx> for queries::analysis<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::lint_levels<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"computing the lint levels for items in this crate\".into()\n-    }\n-}\n-\n impl<'tcx> QueryDescription<'tcx> for queries::specializes<'tcx> {\n     fn describe(_tcx: TyCtxt<'_, '_, '_>, _: (DefId, DefId)) -> Cow<'static, str> {\n         \"computing whether impls specialize one another\".into()\n@@ -898,21 +880,6 @@ impl<'tcx> QueryDescription<'tcx> for queries::typeck_tables_of<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::optimized_mir<'tcx> {\n-    #[inline]\n-    fn cache_on_disk(_: TyCtxt<'_, 'tcx, 'tcx>, def_id: Self::Key) -> bool {\n-        def_id.is_local()\n-    }\n-\n-    fn try_load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              id: SerializedDepNodeIndex)\n-                              -> Option<Self::Value> {\n-        let mir: Option<crate::mir::Mir<'tcx>> = tcx.queries.on_disk_cache\n-                                               .try_load_query_result(tcx, id);\n-        mir.map(|x| tcx.alloc_mir(x))\n-    }\n-}\n-\n impl<'tcx> QueryDescription<'tcx> for queries::substitute_normalize_and_test_predicates<'tcx> {\n     fn describe(tcx: TyCtxt<'_, '_, '_>, key: (DefId, SubstsRef<'tcx>)) -> Cow<'static, str> {\n         format!(\"testing substituted normalized predicates:`{}`\", tcx.def_path_str(key.0)).into()\n@@ -937,33 +904,9 @@ impl<'tcx> QueryDescription<'tcx> for queries::instance_def_size_estimate<'tcx>\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::program_clauses_for<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n-        \"generating chalk-style clauses\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::program_clauses_for_env<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: traits::Environment<'tcx>) -> Cow<'static, str> {\n-        \"generating chalk-style clauses for environment\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::environment<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: DefId) -> Cow<'static, str> {\n-        \"return a chalk-style environment\".into()\n-    }\n-}\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::wasm_import_module_map<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"wasm import module map\".into()\n-    }\n-}\n-\n impl<'tcx> QueryDescription<'tcx> for queries::dllimport_foreign_items<'tcx> {\n     fn describe(_tcx: TyCtxt<'_, '_, '_>, _: CrateNum) -> Cow<'static, str> {\n-        \"wasm import module map\".into()\n+        \"dllimport_foreign_items\".into()\n     }\n }\n \n@@ -997,7 +940,6 @@ impl_disk_cacheable_query!(mir_borrowck, |tcx, def_id| {\n \n impl_disk_cacheable_query!(unsafety_check_result, |_, def_id| def_id.is_local());\n impl_disk_cacheable_query!(borrowck, |_, def_id| def_id.is_local());\n-impl_disk_cacheable_query!(mir_const_qualif, |_, def_id| def_id.is_local());\n impl_disk_cacheable_query!(check_match, |_, def_id| def_id.is_local());\n impl_disk_cacheable_query!(def_symbol_name, |_, _| true);\n impl_disk_cacheable_query!(predicates_of, |_, def_id| def_id.is_local());"}, {"sha": "85c2afd1159a1ec421a6586e078fcc4125deddff", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -205,34 +205,6 @@ rustc_query_append! { [define_queries!][ <'tcx>\n         [] fn inherent_impls: InherentImpls(DefId) -> Lrc<Vec<DefId>>,\n     },\n \n-    Codegen {\n-        /// Set of all the `DefId`s in this crate that have MIR associated with\n-        /// them. This includes all the body owners, but also things like struct\n-        /// constructors.\n-        [] fn mir_keys: mir_keys(CrateNum) -> Lrc<DefIdSet>,\n-\n-        /// Maps DefId's that have an associated Mir to the result\n-        /// of the MIR qualify_consts pass. The actual meaning of\n-        /// the value isn't known except to the pass itself.\n-        [] fn mir_const_qualif: MirConstQualif(DefId) -> (u8, Lrc<BitSet<mir::Local>>),\n-\n-        /// Fetch the MIR for a given `DefId` right after it's built - this includes\n-        /// unreachable code.\n-        [] fn mir_built: MirBuilt(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n-\n-        /// Fetch the MIR for a given `DefId` up till the point where it is\n-        /// ready for const evaluation.\n-        ///\n-        /// See the README for the `mir` module for details.\n-        [no_hash] fn mir_const: MirConst(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n-\n-        [no_hash] fn mir_validated: MirValidated(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n-\n-        /// MIR after our optimization passes have run. This is MIR that is ready\n-        /// for codegen. This is also the only query that can fetch non-local MIR, at present.\n-        [] fn optimized_mir: MirOptimized(DefId) -> &'tcx mir::Mir<'tcx>,\n-    },\n-\n     TypeChecking {\n         /// The result of unsafety-checking this `DefId`.\n         [] fn unsafety_check_result: UnsafetyCheckResult(DefId) -> mir::UnsafetyCheckResult,\n@@ -442,7 +414,6 @@ rustc_query_append! { [define_queries!][ <'tcx>\n \n     Other {\n         [] fn module_exports: ModuleExports(DefId) -> Option<Lrc<Vec<Export>>>,\n-        [] fn lint_levels: lint_levels_node(CrateNum) -> Lrc<lint::LintLevelMap>,\n     },\n \n     TypeChecking {\n@@ -582,11 +553,6 @@ rustc_query_append! { [define_queries!][ <'tcx>\n     },\n \n     TypeChecking {\n-        // Erases regions from `ty` to yield a new type.\n-        // Normally you would just use `tcx.erase_regions(&value)`,\n-        // however, which uses this query as a kind of cache.\n-        [] fn erase_regions_ty: erase_regions_ty(Ty<'tcx>) -> Ty<'tcx>,\n-\n         /// Do not call this query directly: invoke `normalize` instead.\n         [] fn normalize_projection_ty: NormalizeProjectionTy(\n             CanonicalProjectionGoal<'tcx>\n@@ -710,22 +676,6 @@ rustc_query_append! { [define_queries!][ <'tcx>\n \n         [] fn features_query: features_node(CrateNum) -> Lrc<feature_gate::Features>,\n     },\n-\n-    TypeChecking {\n-        [] fn program_clauses_for: ProgramClausesFor(DefId) -> Clauses<'tcx>,\n-\n-        [] fn program_clauses_for_env: ProgramClausesForEnv(\n-            traits::Environment<'tcx>\n-        ) -> Clauses<'tcx>,\n-\n-        // Get the chalk-style environment of the given item.\n-        [] fn environment: Environment(DefId) -> traits::Environment<'tcx>,\n-    },\n-\n-    Linking {\n-        [] fn wasm_import_module_map: WasmImportModuleMap(CrateNum)\n-            -> Lrc<FxHashMap<DefId, String>>,\n-    },\n ]}\n \n //////////////////////////////////////////////////////////////////////\n@@ -741,10 +691,6 @@ fn codegen_fn_attrs<'tcx>(id: DefId) -> DepConstructor<'tcx> {\n     DepConstructor::CodegenFnAttrs { 0: id }\n }\n \n-fn erase_regions_ty<'tcx>(ty: Ty<'tcx>) -> DepConstructor<'tcx> {\n-    DepConstructor::EraseRegionsTy { ty }\n-}\n-\n fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {\n     DepConstructor::TypeParamPredicates {\n         item_id,\n@@ -795,10 +741,6 @@ fn const_eval_raw_dep_node<'tcx>(param_env: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>\n     DepConstructor::ConstEvalRaw { param_env }\n }\n \n-fn mir_keys<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::MirKeys\n-}\n-\n fn crate_variances<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::CrateVariances\n }\n@@ -823,10 +765,6 @@ fn layout_dep_node<'tcx>(param_env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConst\n     DepConstructor::Layout { param_env }\n }\n \n-fn lint_levels_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n-    DepConstructor::LintLevels\n-}\n-\n fn specializes_node<'tcx>((a, b): (DefId, DefId)) -> DepConstructor<'tcx> {\n     DepConstructor::Specializes { impl1: a, impl2: b }\n }"}, {"sha": "adac19d3410b22e71e925d29aeadeb3df48269ad", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -1223,7 +1223,6 @@ pub fn force_from_dep_node<'tcx>(\n         DepKind::CompileCodegenUnit |\n         DepKind::FulfillObligation |\n         DepKind::VtableMethods |\n-        DepKind::EraseRegionsTy |\n         DepKind::NormalizeProjectionTy |\n         DepKind::NormalizeTyAfterErasingRegions |\n         DepKind::ImpliedOutlivesBounds |\n@@ -1240,11 +1239,7 @@ pub fn force_from_dep_node<'tcx>(\n         DepKind::TypeOpNormalizeFnSig |\n         DepKind::SubstituteNormalizeAndTestPredicates |\n         DepKind::MethodAutoderefSteps |\n-        DepKind::InstanceDefSizeEstimate |\n-        DepKind::ProgramClausesForEnv |\n-\n-        // This one should never occur in this context\n-        DepKind::Null => {\n+        DepKind::InstanceDefSizeEstimate => {\n             bug!(\"force_from_dep_node() - Encountered {:?}\", dep_node)\n         }\n \n@@ -1262,11 +1257,6 @@ pub fn force_from_dep_node<'tcx>(\n         },\n         DepKind::PrivacyAccessLevels => { force!(privacy_access_levels, LOCAL_CRATE); }\n         DepKind::CheckPrivateInPublic => { force!(check_private_in_public, LOCAL_CRATE); }\n-        DepKind::MirBuilt => { force!(mir_built, def_id!()); }\n-        DepKind::MirConstQualif => { force!(mir_const_qualif, def_id!()); }\n-        DepKind::MirConst => { force!(mir_const, def_id!()); }\n-        DepKind::MirValidated => { force!(mir_validated, def_id!()); }\n-        DepKind::MirOptimized => { force!(optimized_mir, def_id!()); }\n \n         DepKind::BorrowCheck => { force!(borrowck, def_id!()); }\n         DepKind::MirBorrowCheck => { force!(mir_borrowck, def_id!()); }\n@@ -1282,7 +1272,6 @@ pub fn force_from_dep_node<'tcx>(\n         DepKind::CheckModImplWf => { force!(check_mod_impl_wf, def_id!()); }\n         DepKind::CollectModItemTypes => { force!(collect_mod_item_types, def_id!()); }\n         DepKind::Reachability => { force!(reachable_set, LOCAL_CRATE); }\n-        DepKind::MirKeys => { force!(mir_keys, LOCAL_CRATE); }\n         DepKind::CrateVariances => { force!(crate_variances, LOCAL_CRATE); }\n         DepKind::AssociatedItems => { force!(associated_item, def_id!()); }\n         DepKind::PredicatesDefinedOnItem => { force!(predicates_defined_on, def_id!()); }\n@@ -1317,7 +1306,6 @@ pub fn force_from_dep_node<'tcx>(\n         DepKind::CheckMatch => { force!(check_match, def_id!()); }\n \n         DepKind::ParamEnv => { force!(param_env, def_id!()); }\n-        DepKind::Environment => { force!(environment, def_id!()); }\n         DepKind::DescribeDef => { force!(describe_def, def_id!()); }\n         DepKind::DefSpan => { force!(def_span, def_id!()); }\n         DepKind::LookupStability => { force!(lookup_stability, def_id!()); }\n@@ -1344,7 +1332,6 @@ pub fn force_from_dep_node<'tcx>(\n         DepKind::HasGlobalAllocator => { force!(has_global_allocator, krate!()); }\n         DepKind::HasPanicHandler => { force!(has_panic_handler, krate!()); }\n         DepKind::ExternCrate => { force!(extern_crate, def_id!()); }\n-        DepKind::LintLevels => { force!(lint_levels, LOCAL_CRATE); }\n         DepKind::InScopeTraits => { force!(in_scope_traits_map, def_id!().index); }\n         DepKind::ModuleExports => { force!(module_exports, def_id!()); }\n         DepKind::IsSanitizerRuntime => { force!(is_sanitizer_runtime, krate!()); }\n@@ -1425,8 +1412,6 @@ pub fn force_from_dep_node<'tcx>(\n \n         DepKind::Features => { force!(features_query, LOCAL_CRATE); }\n \n-        DepKind::ProgramClausesFor => { force!(program_clauses_for, def_id!()); }\n-        DepKind::WasmImportModuleMap => { force!(wasm_import_module_map, krate!()); }\n         DepKind::ForeignModules => { force!(foreign_modules, krate!()); }\n \n         DepKind::UpstreamMonomorphizations => {\n@@ -1491,11 +1476,11 @@ macro_rules! impl_load_from_cache {\n \n impl_load_from_cache!(\n     TypeckTables => typeck_tables_of,\n-    MirOptimized => optimized_mir,\n+    optimized_mir => optimized_mir,\n     UnsafetyCheckResult => unsafety_check_result,\n     BorrowCheck => borrowck,\n     MirBorrowCheck => mir_borrowck,\n-    MirConstQualif => mir_const_qualif,\n+    mir_const_qualif => mir_const_qualif,\n     SymbolName => def_symbol_name,\n     ConstIsRvaluePromotableToStatic => const_is_rvalue_promotable_to_static,\n     CheckMatch => check_match,"}, {"sha": "4774f8fe5a380b97bc4aad9a406e50bd8d27d8bf", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -1,7 +1,7 @@\n use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{self, LayoutOf, HasTyCtxt};\n-use rustc::mir;\n+use rustc::mir::{self, Place, PlaceBase, Static, StaticKind};\n use rustc::mir::interpret::EvalErrorKind;\n use rustc_target::abi::call::{ArgType, FnType, PassMode, IgnoreMode};\n use rustc_target::spec::abi::Abi;\n@@ -621,15 +621,23 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         // but specified directly in the code. This means it gets promoted\n                         // and we can then extract the value by evaluating the promoted.\n                         mir::Operand::Copy(\n-                            mir::Place::Base(mir::PlaceBase::Promoted(box(index, ty)))\n+                            Place::Base(\n+                                PlaceBase::Static(\n+                                    box Static { kind: StaticKind::Promoted(promoted), ty }\n+                                )\n+                            )\n                         ) |\n                         mir::Operand::Move(\n-                            mir::Place::Base(mir::PlaceBase::Promoted(box(index, ty)))\n+                            Place::Base(\n+                                PlaceBase::Static(\n+                                    box Static { kind: StaticKind::Promoted(promoted), ty }\n+                                )\n+                            )\n                         ) => {\n                             let param_env = ty::ParamEnv::reveal_all();\n                             let cid = mir::interpret::GlobalId {\n                                 instance: self.instance,\n-                                promoted: Some(index),\n+                                promoted: Some(promoted),\n                             };\n                             let c = bx.tcx().const_eval(param_env.and(cid));\n                             let (llval, ty) = self.simd_shuffle_indices("}, {"sha": "7cafa0088a01270961b763c7827f0822fb7f8f5f", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -408,11 +408,15 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         let result = match *place {\n             mir::Place::Base(mir::PlaceBase::Local(_)) => bug!(), // handled above\n-            mir::Place::Base(mir::PlaceBase::Promoted(box (index, ty))) => {\n+            mir::Place::Base(\n+                mir::PlaceBase::Static(\n+                    box mir::Static { ty, kind: mir::StaticKind::Promoted(promoted) }\n+                )\n+            ) => {\n                 let param_env = ty::ParamEnv::reveal_all();\n                 let cid = mir::interpret::GlobalId {\n                     instance: self.instance,\n-                    promoted: Some(index),\n+                    promoted: Some(promoted),\n                 };\n                 let layout = cx.layout_of(self.monomorphize(&ty));\n                 match bx.tcx().const_eval(param_env.and(cid)) {\n@@ -435,7 +439,11 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     }\n                 }\n             }\n-            mir::Place::Base(mir::PlaceBase::Static(box mir::Static { def_id, ty })) => {\n+            mir::Place::Base(\n+                mir::PlaceBase::Static(\n+                    box mir::Static { ty, kind: mir::StaticKind::Static(def_id) }\n+                )\n+            ) => {\n                 // NB: The layout of a static may be unsized as is the case when working\n                 // with a static that is an extern_type.\n                 let layout = cx.layout_of(self.monomorphize(&ty));"}, {"sha": "46e2582ac3ba00f4de09a1ccac7f11167db62e04", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -66,11 +66,11 @@ const BASE_IMPL: &[&str] = &[\n     label_strs::ImplTraitRef,\n ];\n \n-/// DepNodes for MirBuilt/Optimized, which is relevant in \"executable\"\n+/// DepNodes for mir_built/Optimized, which is relevant in \"executable\"\n /// code, i.e., functions+methods\n const BASE_MIR: &[&str] = &[\n-    label_strs::MirOptimized,\n-    label_strs::MirBuilt,\n+    label_strs::optimized_mir,\n+    label_strs::mir_built,\n ];\n \n /// Struct, Enum and Union DepNodes"}, {"sha": "6e32a53c364a6502eb20fda0763111a78f7d63ef", "filename": "src/librustc_macros/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2FCargo.toml?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -12,3 +12,4 @@ synstructure = \"0.10.1\"\n syn = { version = \"0.15.22\", features = [\"full\"] }\n proc-macro2 = \"0.4.24\"\n quote = \"0.6.10\"\n+itertools = \"0.8\""}, {"sha": "bd5be831ff68d537dc72ba82a487fc08cef9f6c3", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 124, "deletions": 16, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -8,6 +8,7 @@ use syn::parse::{Result, Parse, ParseStream};\n use syn::punctuated::Punctuated;\n use syn;\n use quote::quote;\n+use itertools::Itertools;\n \n #[allow(non_camel_case_types)]\n mod kw {\n@@ -41,6 +42,18 @@ enum QueryModifier {\n \n     /// A cycle error for this query aborting the compilation with a fatal error.\n     FatalCycle,\n+\n+    /// Don't hash the result, instead just mark a query red if it runs\n+    NoHash,\n+\n+    /// Don't force the query\n+    NoForce,\n+\n+    /// Generate a dep node based on the dependencies of the query\n+    Anon,\n+\n+    // Always evaluate the query, ignoring its depdendencies\n+    EvalAlways,\n }\n \n impl Parse for QueryModifier {\n@@ -88,6 +101,14 @@ impl Parse for QueryModifier {\n             Ok(QueryModifier::LoadCached(tcx, id, block))\n         } else if modifier == \"fatal_cycle\" {\n             Ok(QueryModifier::FatalCycle)\n+        } else if modifier == \"no_hash\" {\n+            Ok(QueryModifier::NoHash)\n+        } else if modifier == \"no_force\" {\n+            Ok(QueryModifier::NoForce)\n+        } else if modifier == \"anon\" {\n+            Ok(QueryModifier::Anon)\n+        } else if modifier == \"eval_always\" {\n+            Ok(QueryModifier::EvalAlways)\n         } else {\n             Err(Error::new(modifier.span(), \"unknown query modifier\"))\n         }\n@@ -185,6 +206,18 @@ struct QueryModifiers {\n \n     /// A cycle error for this query aborting the compilation with a fatal error.\n     fatal_cycle: bool,\n+\n+    /// Don't hash the result, instead just mark a query red if it runs\n+    no_hash: bool,\n+\n+    /// Don't force the query\n+    no_force: bool,\n+\n+    /// Generate a dep node based on the dependencies of the query\n+    anon: bool,\n+\n+    // Always evaluate the query, ignoring its depdendencies\n+    eval_always: bool,\n }\n \n /// Process query modifiers into a struct, erroring on duplicates\n@@ -193,6 +226,10 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n     let mut cache = None;\n     let mut desc = None;\n     let mut fatal_cycle = false;\n+    let mut no_hash = false;\n+    let mut no_force = false;\n+    let mut anon = false;\n+    let mut eval_always = false;\n     for modifier in query.modifiers.0.drain(..) {\n         match modifier {\n             QueryModifier::LoadCached(tcx, id, block) => {\n@@ -219,13 +256,41 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n                 }\n                 fatal_cycle = true;\n             }\n+            QueryModifier::NoHash => {\n+                if no_hash {\n+                    panic!(\"duplicate modifier `no_hash` for query `{}`\", query.name);\n+                }\n+                no_hash = true;\n+            }\n+            QueryModifier::NoForce => {\n+                if no_force {\n+                    panic!(\"duplicate modifier `no_force` for query `{}`\", query.name);\n+                }\n+                no_force = true;\n+            }\n+            QueryModifier::Anon => {\n+                if anon {\n+                    panic!(\"duplicate modifier `anon` for query `{}`\", query.name);\n+                }\n+                anon = true;\n+            }\n+            QueryModifier::EvalAlways => {\n+                if eval_always {\n+                    panic!(\"duplicate modifier `eval_always` for query `{}`\", query.name);\n+                }\n+                eval_always = true;\n+            }\n         }\n     }\n     QueryModifiers {\n         load_cached,\n         cache,\n         desc,\n         fatal_cycle,\n+        no_hash,\n+        no_force,\n+        anon,\n+        eval_always,\n     }\n }\n \n@@ -312,6 +377,7 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n     let mut query_description_stream = quote! {};\n     let mut dep_node_def_stream = quote! {};\n     let mut dep_node_force_stream = quote! {};\n+    let mut no_force_queries = Vec::new();\n \n     for group in groups.0 {\n         let mut group_stream = quote! {};\n@@ -325,41 +391,83 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 _ => quote! { #result_full },\n             };\n \n+            let mut attributes = Vec::new();\n+\n             // Pass on the fatal_cycle modifier\n-            let fatal_cycle = if modifiers.fatal_cycle {\n-                quote! { fatal_cycle }\n-            } else {\n-                quote! {}\n+            if modifiers.fatal_cycle {\n+                attributes.push(quote! { fatal_cycle });\n             };\n+            // Pass on the no_hash modifier\n+            if modifiers.no_hash {\n+                attributes.push(quote! { no_hash });\n+            };\n+\n+            let mut attribute_stream = quote! {};\n+\n+            for e in attributes.into_iter().intersperse(quote! {,}) {\n+                attribute_stream.extend(e);\n+            }\n \n             // Add the query to the group\n             group_stream.extend(quote! {\n-                [#fatal_cycle] fn #name: #name(#arg) #result,\n+                [#attribute_stream] fn #name: #name(#arg) #result,\n             });\n \n-            add_query_description_impl(&query, modifiers, &mut query_description_stream);\n+            let mut attributes = Vec::new();\n+\n+            // Pass on the anon modifier\n+            if modifiers.anon {\n+                attributes.push(quote! { anon });\n+            };\n+            // Pass on the eval_always modifier\n+            if modifiers.eval_always {\n+                attributes.push(quote! { eval_always });\n+            };\n \n+            let mut attribute_stream = quote! {};\n+            for e in attributes.into_iter().intersperse(quote! {,}) {\n+                attribute_stream.extend(e);\n+            }\n             // Create a dep node for the query\n             dep_node_def_stream.extend(quote! {\n-                [] #name(#arg),\n+                [#attribute_stream] #name(#arg),\n             });\n \n-            // Add a match arm to force the query given the dep node\n-            dep_node_force_stream.extend(quote! {\n-                DepKind::#name => {\n-                    if let Some(key) = RecoverKey::recover($tcx, $dep_node) {\n-                        force_ex!($tcx, #name, key);\n-                    } else {\n-                        return false;\n+            if modifiers.no_force {\n+                no_force_queries.push(name.clone());\n+            } else {\n+                // Add a match arm to force the query given the dep node\n+                dep_node_force_stream.extend(quote! {\n+                    DepKind::#name => {\n+                        if let Some(key) = RecoverKey::recover($tcx, $dep_node) {\n+                            force_ex!($tcx, #name, key);\n+                        } else {\n+                            return false;\n+                        }\n                     }\n-                }\n-            });\n+                });\n+            }\n+\n+            add_query_description_impl(&query, modifiers, &mut query_description_stream);\n         }\n         let name = &group.name;\n         query_stream.extend(quote! {\n             #name { #group_stream },\n         });\n     }\n+\n+    // Add an arm for the no force queries to panic when trying to force them\n+    for query in no_force_queries {\n+        dep_node_force_stream.extend(quote! {\n+            DepKind::#query |\n+        });\n+    }\n+    dep_node_force_stream.extend(quote! {\n+        DepKind::Null => {\n+            bug!(\"Cannot force dep node: {:?}\", $dep_node)\n+        }\n+    });\n+\n     TokenStream::from(quote! {\n         macro_rules! rustc_query_append {\n             ([$($macro:tt)*][$($other:tt)*]) => {"}, {"sha": "fac75989aa59034d7f0e15fc4eea912a2f15222a", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -10,7 +10,7 @@ use rustc::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, Constant,\n     ConstraintCategory, Field, Local, LocalDecl, LocalKind, Location, Operand,\n     Place, PlaceBase, PlaceProjection, ProjectionElem, Rvalue, Statement, StatementKind,\n-    TerminatorKind, VarBindingForm,\n+    Static, StaticKind, TerminatorKind, VarBindingForm,\n };\n use rustc::ty::{self, DefIdTree};\n use rustc::ty::print::Print;\n@@ -1598,14 +1598,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         including_downcast: &IncludingDowncast,\n     ) -> Result<(), ()> {\n         match *place {\n-            Place::Base(PlaceBase::Promoted(_)) => {\n-                buf.push_str(\"promoted\");\n-            }\n             Place::Base(PlaceBase::Local(local)) => {\n                 self.append_local_to_string(local, buf)?;\n             }\n-            Place::Base(PlaceBase::Static(ref static_)) => {\n-                buf.push_str(&self.infcx.tcx.item_name(static_.def_id).to_string());\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) => {\n+                buf.push_str(\"promoted\");\n+            }\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })) => {\n+                buf.push_str(&self.infcx.tcx.item_name(def_id).to_string());\n             }\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n@@ -1744,8 +1744,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let local = &self.mir.local_decls[local];\n                 self.describe_field_from_ty(&local.ty, field)\n             }\n-            Place::Base(PlaceBase::Promoted(ref prom)) =>\n-                self.describe_field_from_ty(&prom.1, field),\n             Place::Base(PlaceBase::Static(ref static_)) =>\n                 self.describe_field_from_ty(&static_.ty, field),\n             Place::Projection(ref proj) => match proj.elem {\n@@ -1809,8 +1807,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     /// Checks if a place is a thread-local static.\n     pub fn is_place_thread_local(&self, place: &Place<'tcx>) -> bool {\n-        if let Place::Base(PlaceBase::Static(statik)) = place {\n-            let attrs = self.infcx.tcx.get_attrs(statik.def_id);\n+        if let Place::Base(\n+            PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })\n+        ) = place {\n+            let attrs = self.infcx.tcx.get_attrs(*def_id);\n             let is_thread_local = attrs.iter().any(|attr| attr.check_name(\"thread_local\"));\n \n             debug!(\n@@ -1828,8 +1828,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let tcx = self.infcx.tcx;\n         match place {\n             Place::Base(PlaceBase::Local(_)) |\n-            Place::Base(PlaceBase::Static(_)) |\n-            Place::Base(PlaceBase::Promoted(_)) => {\n+            Place::Base(PlaceBase::Static(_)) => {\n                 StorageDeadOrDrop::LocalStorageDead\n             }\n             Place::Projection(box PlaceProjection { base, elem }) => {"}, {"sha": "5c159cda141a517923cde5bf5af04d82ed740021", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -8,7 +8,9 @@ use rustc::infer::InferCtxt;\n use rustc::lint::builtin::UNUSED_MUT;\n use rustc::middle::borrowck::SignalledError;\n use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n-use rustc::mir::{ClearCrossCrate, Local, Location, Mir, Mutability, Operand, Place, PlaceBase};\n+use rustc::mir::{\n+    ClearCrossCrate, Local, Location, Mir, Mutability, Operand, Place, PlaceBase, Static, StaticKind\n+};\n use rustc::mir::{Field, Projection, ProjectionElem, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n use rustc::ty::query::Providers;\n@@ -1226,8 +1228,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 }\n                                 Operand::Move(Place::Base(PlaceBase::Static(..)))\n                                 | Operand::Copy(Place::Base(PlaceBase::Static(..)))\n-                                | Operand::Move(Place::Base(PlaceBase::Promoted(..)))\n-                                | Operand::Copy(Place::Base(PlaceBase::Promoted(..)))\n                                 | Operand::Constant(..) => {}\n                             }\n                         }\n@@ -1310,12 +1310,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         //\n         // FIXME: allow thread-locals to borrow other thread locals?\n         let (might_be_alive, will_be_dropped) = match root_place {\n-            Place::Base(PlaceBase::Promoted(_)) => (true, false),\n-            Place::Base(PlaceBase::Static(_)) => {\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) => {\n+                (true, false)\n+            }\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Static(_), .. })) => {\n                 // Thread-locals might be dropped after the function exits, but\n                 // \"true\" statics will never be.\n-                let is_thread_local = self.is_place_thread_local(&root_place);\n-                (true, is_thread_local)\n+                (true, self.is_place_thread_local(&root_place))\n             }\n             Place::Base(PlaceBase::Local(_)) => {\n                 // Locals are always dropped at function exit, and if they\n@@ -1578,7 +1579,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         match *last_prefix {\n             Place::Base(PlaceBase::Local(_)) => panic!(\"should have move path for every Local\"),\n             Place::Projection(_) => panic!(\"PrefixSet::All meant don't stop for Projection\"),\n-            Place::Base(PlaceBase::Promoted(_)) |\n             Place::Base(PlaceBase::Static(_)) => Err(NoMovePathFound::ReachedStatic),\n         }\n     }\n@@ -1605,7 +1605,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let mut place = place;\n         loop {\n             match *place {\n-                Place::Base(PlaceBase::Promoted(_)) |\n                 Place::Base(PlaceBase::Local(_)) | Place::Base(PlaceBase::Static(_)) => {\n                     // assigning to `x` does not require `x` be initialized.\n                     break;\n@@ -1953,10 +1952,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     self.used_mut_upvars.push(field);\n                 }\n             }\n-            RootPlace {\n-                place: Place::Base(PlaceBase::Promoted(..)),\n-                is_local_mutation_allowed: _,\n-            } => {}\n             RootPlace {\n                 place: Place::Base(PlaceBase::Static(..)),\n                 is_local_mutation_allowed: _,\n@@ -1994,12 +1989,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n             // The rules for promotion are made by `qualify_consts`, there wouldn't even be a\n             // `Place::Promoted` if the promotion weren't 100% legal. So we just forward this\n-            Place::Base(PlaceBase::Promoted(_)) => Ok(RootPlace {\n-                place,\n-                is_local_mutation_allowed,\n-            }),\n-            Place::Base(PlaceBase::Static(ref static_)) => {\n-                if self.infcx.tcx.is_static(static_.def_id) != Some(hir::Mutability::MutMutable) {\n+            Place::Base(PlaceBase::Static(box Static{kind: StaticKind::Promoted(_), ..})) =>\n+                Ok(RootPlace {\n+                    place,\n+                    is_local_mutation_allowed,\n+                }),\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })) => {\n+                if self.infcx.tcx.is_static(def_id) != Some(hir::Mutability::MutMutable) {\n                     Err(place)\n                 } else {\n                     Ok(RootPlace {"}, {"sha": "f351212e9d5876f990c4d2d1896c05faa3450534", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -1,7 +1,9 @@\n use rustc::hir;\n use rustc::hir::Node;\n use rustc::mir::{self, BindingForm, Constant, ClearCrossCrate, Local, Location, Mir};\n-use rustc::mir::{Mutability, Operand, Place, PlaceBase, Projection, ProjectionElem, Static};\n+use rustc::mir::{\n+    Mutability, Operand, Place, PlaceBase, Projection, ProjectionElem, Static, StaticKind,\n+};\n use rustc::mir::{Terminator, TerminatorKind};\n use rustc::ty::{self, Const, DefIdTree, TyS, TyKind, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n@@ -129,9 +131,10 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            Place::Base(PlaceBase::Promoted(_)) => unreachable!(),\n+            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. })) =>\n+                unreachable!(),\n \n-            Place::Base(PlaceBase::Static(box Static { def_id, ty: _ })) => {\n+            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Static(def_id), .. })) => {\n                 if let Place::Base(PlaceBase::Static(_)) = access_place {\n                     item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n                     reason = String::new();"}, {"sha": "a3561515aaa31f3e7ebaae3092b748f7bb5c0528", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 34, "deletions": 38, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -449,53 +449,49 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         context: PlaceContext<'_>,\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_place: {:?}\", place);\n-        let place_ty = match *place {\n+        let place_ty = match place {\n             Place::Base(PlaceBase::Local(index)) => PlaceTy::Ty {\n-                ty: self.mir.local_decls[index].ty,\n+                ty: self.mir.local_decls[*index].ty,\n             },\n-            Place::Base(PlaceBase::Promoted(box (index, sty))) => {\n+            Place::Base(PlaceBase::Static(box Static { kind, ty: sty })) => {\n                 let sty = self.sanitize_type(place, sty);\n-\n-                if !self.errors_reported {\n-                    let promoted_mir = &self.mir.promoted[index];\n-                    self.sanitize_promoted(promoted_mir, location);\n-\n-                    let promoted_ty = promoted_mir.return_ty();\n-\n-                    if let Err(terr) = self.cx.eq_types(\n-                        sty,\n-                        promoted_ty,\n-                        location.to_locations(),\n-                        ConstraintCategory::Boring,\n-                    ) {\n-                        span_mirbug!(\n-                            self,\n+                let check_err =\n+                    |verifier: &mut TypeVerifier<'a, 'b, 'gcx, 'tcx>,\n+                     place: &Place<'tcx>,\n+                     ty,\n+                     sty| {\n+                        if let Err(terr) = verifier.cx.eq_types(\n+                            sty,\n+                            ty,\n+                            location.to_locations(),\n+                            ConstraintCategory::Boring,\n+                        ) {\n+                            span_mirbug!(\n+                            verifier,\n                             place,\n                             \"bad promoted type ({:?}: {:?}): {:?}\",\n-                            promoted_ty,\n+                            ty,\n                             sty,\n                             terr\n                         );\n+                        };\n                     };\n-                }\n-                PlaceTy::Ty { ty: sty }\n-            }\n-            Place::Base(PlaceBase::Static(box Static { def_id, ty: sty })) => {\n-                let sty = self.sanitize_type(place, sty);\n-                let ty = self.tcx().type_of(def_id);\n-                let ty = self.cx.normalize(ty, location);\n-                if let Err(terr) =\n-                    self.cx\n-                        .eq_types(ty, sty, location.to_locations(), ConstraintCategory::Boring)\n-                {\n-                    span_mirbug!(\n-                        self,\n-                        place,\n-                        \"bad static type ({:?}: {:?}): {:?}\",\n-                        ty,\n-                        sty,\n-                        terr\n-                    );\n+                match kind {\n+                    StaticKind::Promoted(promoted) => {\n+                        if !self.errors_reported {\n+                            let promoted_mir = &self.mir.promoted[*promoted];\n+                            self.sanitize_promoted(promoted_mir, location);\n+\n+                            let promoted_ty = promoted_mir.return_ty();\n+                            check_err(self, place, promoted_ty, sty);\n+                        }\n+                    }\n+                    StaticKind::Static(def_id) => {\n+                        let ty = self.tcx().type_of(*def_id);\n+                        let ty = self.cx.normalize(ty, location);\n+\n+                        check_err(self, place, ty, sty);\n+                    }\n                 }\n                 PlaceTy::Ty { ty: sty }\n             }"}, {"sha": "42eb502b9076d6636d42d3c7d61904e6e13f1e92", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -138,7 +138,6 @@ pub(super) fn is_active<'tcx>(\n /// This is called for all Yield statements on movable generators\n pub(super) fn borrow_of_local_data<'tcx>(place: &Place<'tcx>) -> bool {\n     match place {\n-        Place::Base(PlaceBase::Promoted(_)) |\n         Place::Base(PlaceBase::Static(..)) => false,\n         Place::Base(PlaceBase::Local(..)) => true,\n         Place::Projection(box proj) => {"}, {"sha": "6bc56ab721f985711792ff270cd5bb920c5a8657", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -1,6 +1,6 @@\n use rustc::hir;\n use rustc::mir::ProjectionElem;\n-use rustc::mir::{Local, Mir, Place, PlaceBase, Mutability};\n+use rustc::mir::{Local, Mir, Place, PlaceBase, Mutability, Static, StaticKind};\n use rustc::ty::{self, TyCtxt};\n use crate::borrow_check::borrow_set::LocalsStateAtExit;\n \n@@ -30,8 +30,6 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n         locals_state_at_exit: &LocalsStateAtExit,\n     ) -> bool {\n         match self {\n-            Place::Base(PlaceBase::Promoted(_)) => false,\n-\n             // If a local variable is immutable, then we only need to track borrows to guard\n             // against two kinds of errors:\n             // * The variable being dropped while still borrowed (e.g., because the fn returns\n@@ -51,8 +49,10 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n                     }\n                 }\n             }\n-            Place::Base(PlaceBase::Static(static_)) => {\n-                tcx.is_static(static_.def_id) == Some(hir::Mutability::MutMutable)\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) =>\n+                false,\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })) => {\n+                tcx.is_static(*def_id) == Some(hir::Mutability::MutMutable)\n             }\n             Place::Projection(proj) => match proj.elem {\n                 ProjectionElem::Field(..)\n@@ -88,7 +88,6 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n         loop {\n             match p {\n                 Place::Projection(pi) => p = &pi.base,\n-                Place::Base(PlaceBase::Promoted(_)) |\n                 Place::Base(PlaceBase::Static(_)) => return None,\n                 Place::Base(PlaceBase::Local(l)) => return Some(*l),\n             }"}, {"sha": "52119d6b19bc06d5d4dc48cd8f1cf814de9b2548", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 36, "deletions": 33, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -2,7 +2,7 @@ use crate::borrow_check::ArtificialField;\n use crate::borrow_check::Overlap;\n use crate::borrow_check::{Deep, Shallow, AccessDepth};\n use rustc::hir;\n-use rustc::mir::{BorrowKind, Mir, Place, PlaceBase, Projection, ProjectionElem};\n+use rustc::mir::{BorrowKind, Mir, Place, PlaceBase, Projection, ProjectionElem, StaticKind};\n use rustc::ty::{self, TyCtxt};\n use std::cmp::max;\n \n@@ -338,7 +338,6 @@ fn unroll_place<'tcx, R>(\n             op,\n         ),\n \n-        Place::Base(PlaceBase::Promoted(_)) |\n         Place::Base(PlaceBase::Local(_)) | Place::Base(PlaceBase::Static(_)) => {\n             let list = PlaceComponents {\n                 component: place,\n@@ -371,41 +370,45 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n                 Overlap::Disjoint\n             }\n         }\n-        (Place::Base(PlaceBase::Static(static1)), Place::Base(PlaceBase::Static(static2))) => {\n-            if static1.def_id != static2.def_id {\n-                debug!(\"place_element_conflict: DISJOINT-STATIC\");\n-                Overlap::Disjoint\n-            } else if tcx.is_static(static1.def_id) == Some(hir::Mutability::MutMutable) {\n-                // We ignore mutable statics - they can only be unsafe code.\n-                debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n-                Overlap::Disjoint\n-            } else {\n-                debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n-                Overlap::EqualOrDisjoint\n-            }\n-        }\n-        (Place::Base(PlaceBase::Promoted(p1)), Place::Base(PlaceBase::Promoted(p2))) => {\n-            if p1.0 == p2.0 {\n-                if let ty::Array(_, size) = p1.1.sty {\n-                    if size.unwrap_usize(tcx) == 0 {\n-                        // Ignore conflicts with promoted [T; 0].\n-                        debug!(\"place_element_conflict: IGNORE-LEN-0-PROMOTED\");\n-                        return Overlap::Disjoint;\n+        (Place::Base(PlaceBase::Static(s1)), Place::Base(PlaceBase::Static(s2))) => {\n+            match (&s1.kind, &s2.kind) {\n+                (StaticKind::Static(def_id_1), StaticKind::Static(def_id_2)) => {\n+                    if def_id_1 != def_id_2 {\n+                        debug!(\"place_element_conflict: DISJOINT-STATIC\");\n+                        Overlap::Disjoint\n+                    } else if tcx.is_static(*def_id_1) == Some(hir::Mutability::MutMutable) {\n+                        // We ignore mutable statics - they can only be unsafe code.\n+                        debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n+                        Overlap::Disjoint\n+                    } else {\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n+                        Overlap::EqualOrDisjoint\n                     }\n+                },\n+                (StaticKind::Promoted(promoted_1), StaticKind::Promoted(promoted_2)) => {\n+                    if promoted_1 == promoted_2 {\n+                        if let ty::Array(_, size) = s1.ty.sty {\n+                            if size.unwrap_usize(tcx) == 0 {\n+                                // Ignore conflicts with promoted [T; 0].\n+                                debug!(\"place_element_conflict: IGNORE-LEN-0-PROMOTED\");\n+                                return Overlap::Disjoint;\n+                            }\n+                        }\n+                        // the same promoted - base case, equal\n+                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-PROMOTED\");\n+                        Overlap::EqualOrDisjoint\n+                    } else {\n+                        // different promoteds - base case, disjoint\n+                        debug!(\"place_element_conflict: DISJOINT-PROMOTED\");\n+                        Overlap::Disjoint\n+                    }\n+                },\n+                (_, _) => {\n+                    debug!(\"place_element_conflict: DISJOINT-STATIC-PROMOTED\");\n+                    Overlap::Disjoint\n                 }\n-                // the same promoted - base case, equal\n-                debug!(\"place_element_conflict: DISJOINT-OR-EQ-PROMOTED\");\n-                Overlap::EqualOrDisjoint\n-            } else {\n-                // different promoteds - base case, disjoint\n-                debug!(\"place_element_conflict: DISJOINT-PROMOTED\");\n-                Overlap::Disjoint\n             }\n         }\n-        (Place::Base(PlaceBase::Local(_)), Place::Base(PlaceBase::Promoted(_))) |\n-        (Place::Base(PlaceBase::Promoted(_)), Place::Base(PlaceBase::Local(_))) |\n-        (Place::Base(PlaceBase::Promoted(_)), Place::Base(PlaceBase::Static(_))) |\n-        (Place::Base(PlaceBase::Static(_)), Place::Base(PlaceBase::Promoted(_))) |\n         (Place::Base(PlaceBase::Local(_)), Place::Base(PlaceBase::Static(_))) |\n         (Place::Base(PlaceBase::Static(_)), Place::Base(PlaceBase::Local(_))) => {\n             debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL-PROMOTED\");"}, {"sha": "e70c9e81ebd16b8beff33970851e172eb2d2eaef", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -26,7 +26,6 @@ impl<'tcx> IsPrefixOf<'tcx> for Place<'tcx> {\n             }\n \n             match *cursor {\n-                Place::Base(PlaceBase::Promoted(_)) |\n                 Place::Base(PlaceBase::Local(_)) |\n                 Place::Base(PlaceBase::Static(_)) => return false,\n                 Place::Projection(ref proj) => {\n@@ -87,7 +86,6 @@ impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n \n         'cursor: loop {\n             let proj = match *cursor {\n-                Place::Base(PlaceBase::Promoted(_)) |\n                 Place::Base(PlaceBase::Local(_)) | // search yielded this leaf\n                 Place::Base(PlaceBase::Static(_)) => {\n                     self.next = None;"}, {"sha": "199d03ac445ba51441bcd877e9d5b392a81a5ac0", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -126,8 +126,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block.and(place)\n             }\n             ExprKind::StaticRef { id } => block.and(Place::Base(PlaceBase::Static(Box::new(Static {\n-                def_id: id,\n                 ty: expr.ty,\n+                kind: StaticKind::Static(id),\n             })))),\n \n             ExprKind::PlaceTypeAscription { source, user_ty } => {"}, {"sha": "9d4600d13ac138a169daf3cb6476abdb2a797f50", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -93,7 +93,6 @@ struct BorrowedLocalsVisitor<'b, 'c: 'b> {\n fn find_local<'tcx>(place: &Place<'tcx>) -> Option<Local> {\n     match *place {\n         Place::Base(PlaceBase::Local(l)) => Some(l),\n-        Place::Base(PlaceBase::Promoted(_)) |\n         Place::Base(PlaceBase::Static(..)) => None,\n         Place::Projection(ref proj) => {\n             match proj.elem {"}, {"sha": "71805fd02b85714e650ced49e7e590a363c91996", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -97,7 +97,6 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n         debug!(\"lookup({:?})\", place);\n         match *place {\n             Place::Base(PlaceBase::Local(local)) => Ok(self.builder.data.rev_lookup.locals[local]),\n-            Place::Base(PlaceBase::Promoted(..)) |\n             Place::Base(PlaceBase::Static(..)) => {\n                 Err(MoveError::cannot_move_out_of(self.loc, Static))\n             }"}, {"sha": "7eef68e5f807350dcd59491eaf314a03e7a822be", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -286,7 +286,6 @@ impl<'tcx> MovePathLookup<'tcx> {\n     pub fn find(&self, place: &Place<'tcx>) -> LookupResult {\n         match *place {\n             Place::Base(PlaceBase::Local(local)) => LookupResult::Exact(self.locals[local]),\n-            Place::Base(PlaceBase::Promoted(_)) |\n             Place::Base(PlaceBase::Static(..)) => LookupResult::Parent(None),\n             Place::Projection(ref proj) => {\n                 match self.find(&proj.base) {"}, {"sha": "d2c279e48fe280669638c817e7fab7c76216157d", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -582,19 +582,20 @@ where\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::Place::*;\n         use rustc::mir::PlaceBase;\n+        use rustc::mir::{Static, StaticKind};\n         Ok(match *mir_place {\n-            Base(PlaceBase::Promoted(ref promoted)) => {\n+            Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(promoted), .. })) => {\n                 let instance = self.frame().instance;\n                 self.const_eval_raw(GlobalId {\n                     instance,\n-                    promoted: Some(promoted.0),\n+                    promoted: Some(promoted),\n                 })?\n             }\n \n-            Base(PlaceBase::Static(ref static_)) => {\n-                assert!(!static_.ty.needs_subst());\n-                let layout = self.layout_of(static_.ty)?;\n-                let instance = ty::Instance::mono(*self.tcx, static_.def_id);\n+            Base(PlaceBase::Static(box Static { kind: StaticKind::Static(def_id), ty })) => {\n+                assert!(!ty.needs_subst());\n+                let layout = self.layout_of(ty)?;\n+                let instance = ty::Instance::mono(*self.tcx, def_id);\n                 let cid = GlobalId {\n                     instance,\n                     promoted: None"}, {"sha": "0ad6962cc4ac57b6fdd495650bcab44785395dac", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -184,7 +184,7 @@ use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::ty::{self, TypeFoldable, Ty, TyCtxt, GenericParamDefKind};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::session::config::EntryFnType;\n-use rustc::mir::{self, Location, Promoted};\n+use rustc::mir::{self, Location, Place, PlaceBase, Promoted, Static, StaticKind};\n use rustc::mir::visit::Visitor as MirVisitor;\n use rustc::mir::mono::MonoItem;\n use rustc::mir::interpret::{Scalar, GlobalId, AllocKind, ErrorHandled};\n@@ -650,19 +650,26 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         self.super_terminator_kind(block, kind, location);\n     }\n \n-    fn visit_static(&mut self,\n-                    static_: &mir::Static<'tcx>,\n+    fn visit_place(&mut self,\n+                    place: &mir::Place<'tcx>,\n                     context: mir::visit::PlaceContext<'tcx>,\n                     location: Location) {\n-        debug!(\"visiting static {:?} @ {:?}\", static_.def_id, location);\n+        match place {\n+            Place::Base(\n+                PlaceBase::Static(box Static{ kind:StaticKind::Static(def_id), .. })\n+            ) => {\n+                debug!(\"visiting static {:?} @ {:?}\", def_id, location);\n \n-        let tcx = self.tcx;\n-        let instance = Instance::mono(tcx, static_.def_id);\n-        if should_monomorphize_locally(tcx, &instance) {\n-            self.output.push(MonoItem::Static(static_.def_id));\n+                let tcx = self.tcx;\n+                let instance = Instance::mono(tcx, *def_id);\n+                if should_monomorphize_locally(tcx, &instance) {\n+                    self.output.push(MonoItem::Static(*def_id));\n+                }\n+            }\n+            _ => {}\n         }\n \n-        self.super_static(static_, context, location);\n+        self.super_place(place, context, location);\n     }\n }\n "}, {"sha": "b13a5fd2fd1c0994fc1c603539504472b04b73f1", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -22,7 +22,6 @@ fn is_stable<'tcx>(\n     match *place {\n         // Locals and statics have stable addresses, for sure\n         Base(PlaceBase::Local { .. }) |\n-        Base(PlaceBase::Promoted { .. }) |\n         Base(PlaceBase::Static { .. }) =>\n             true,\n         // Recurse for projections"}, {"sha": "0e31515e4af9038fc7a6dbc75e28fccc3a112d2a", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -300,10 +300,12 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             &Place::Base(PlaceBase::Local(..)) => {\n                 // locals are safe\n             }\n-            &Place::Base(PlaceBase::Promoted(_)) => {\n+            &Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. })) => {\n                 bug!(\"unsafety checking should happen before promotion\")\n             }\n-            &Place::Base(PlaceBase::Static(box Static { def_id, ty: _ })) => {\n+            &Place::Base(\n+                PlaceBase::Static(box Static { kind: StaticKind::Static(def_id), .. })\n+            ) => {\n                 if self.tcx.is_static(def_id) == Some(hir::Mutability::MutMutable) {\n                     self.require_unsafe(\"use of mutable static\",\n                         \"mutable statics can be mutated by multiple threads: aliasing violations \\"}, {"sha": "102d03d7baac4bce4cefb00c44b7b13dd804b7fb", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -4,7 +4,7 @@\n \n use rustc::hir::def::Def;\n use rustc::mir::{Constant, Location, Place, PlaceBase, Mir, Operand, Rvalue, Local};\n-use rustc::mir::{NullOp, UnOp, StatementKind, Statement, BasicBlock, LocalKind};\n+use rustc::mir::{NullOp, UnOp, StatementKind, Statement, BasicBlock, LocalKind, Static, StaticKind};\n use rustc::mir::{TerminatorKind, ClearCrossCrate, SourceInfo, BinOp, ProjectionElem};\n use rustc::mir::visit::{Visitor, PlaceContext, MutatingUseContext, NonMutatingUseContext};\n use rustc::mir::interpret::{EvalErrorKind, Scalar, GlobalId, EvalResult};\n@@ -283,7 +283,9 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 // an `Index` projection would throw us off-track.\n                 _ => None,\n             },\n-            Place::Base(PlaceBase::Promoted(ref promoted)) => {\n+            Place::Base(\n+                PlaceBase::Static(box Static {kind: StaticKind::Promoted(promoted), ..})\n+            ) => {\n                 let generics = self.tcx.generics_of(self.source.def_id());\n                 if generics.requires_monomorphization(self.tcx) {\n                     // FIXME: can't handle code with generics\n@@ -293,7 +295,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 let instance = Instance::new(self.source.def_id(), substs);\n                 let cid = GlobalId {\n                     instance,\n-                    promoted: Some(promoted.0),\n+                    promoted: Some(promoted),\n                 };\n                 // cannot use `const_eval` here, because that would require having the MIR\n                 // for the current function available, but we're producing said MIR right now"}, {"sha": "1063381d6aa57899fac01a7c113399fa3953c9a7", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -692,12 +692,14 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n                 // Return pointer; update the place itself\n                 *place = self.destination.clone();\n             },\n-            Place::Base(PlaceBase::Promoted(ref mut promoted)) => {\n-                if let Some(p) = self.promoted_map.get(promoted.0).cloned() {\n-                    promoted.0 = p;\n+            Place::Base(\n+                PlaceBase::Static(box Static { kind: StaticKind::Promoted(promoted), .. })\n+            ) => {\n+                if let Some(p) = self.promoted_map.get(*promoted).cloned() {\n+                    *promoted = p;\n                 }\n             },\n-            _ => self.super_place(place, _ctxt, _location),\n+            _ => self.super_place(place, _ctxt, _location)\n         }\n     }\n "}, {"sha": "73b88e9904bf23cbd1a202343eb0d0acf5406faa", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -292,9 +292,10 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n             let promoted_id = Promoted::new(self.source.promoted.len());\n             let mut promoted_place = |ty, span| {\n                 promoted.span = span;\n-                promoted.local_decls[RETURN_PLACE] =\n-                    LocalDecl::new_return_place(ty, span);\n-                Place::Base(PlaceBase::Promoted(box (promoted_id, ty)))\n+                promoted.local_decls[RETURN_PLACE] = LocalDecl::new_return_place(ty, span);\n+                Place::Base(\n+                    PlaceBase::Static(box Static{ kind: StaticKind::Promoted(promoted_id), ty })\n+                )\n             };\n             let (blocks, local_decls) = self.source.basic_blocks_and_local_decls_mut();\n             match candidate {"}, {"sha": "0b9ad85e6b1c7c3585744e6e29ea0e84535926a0", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -188,8 +188,11 @@ trait Qualif {\n     fn in_place(cx: &ConstCx<'_, 'tcx>, place: &Place<'tcx>) -> bool {\n         match *place {\n             Place::Base(PlaceBase::Local(local)) => Self::in_local(cx, local),\n-            Place::Base(PlaceBase::Promoted(_)) => bug!(\"qualifying already promoted MIR\"),\n-            Place::Base(PlaceBase::Static(ref static_)) => Self::in_static(cx, static_),\n+            Place::Base(PlaceBase::Static(box Static {kind: StaticKind::Promoted(_), .. })) =>\n+                bug!(\"qualifying already promoted MIR\"),\n+            Place::Base(PlaceBase::Static(ref static_)) => {\n+                Self::in_static(cx, static_)\n+            },\n             Place::Projection(ref proj) => Self::in_projection(cx, proj),\n         }\n     }\n@@ -370,11 +373,18 @@ impl Qualif for IsNotConst {\n     const IDX: usize = 2;\n \n     fn in_static(cx: &ConstCx<'_, 'tcx>, static_: &Static<'tcx>) -> bool {\n-        // Only allow statics (not consts) to refer to other statics.\n-        let allowed = cx.mode == Mode::Static || cx.mode == Mode::StaticMut;\n+        match static_.kind {\n+            StaticKind::Promoted(_) => unreachable!(),\n+            StaticKind::Static(def_id) => {\n+                // Only allow statics (not consts) to refer to other statics.\n+                let allowed = cx.mode == Mode::Static || cx.mode == Mode::StaticMut;\n \n-        !allowed ||\n-            cx.tcx.get_attrs(static_.def_id).iter().any(|attr| attr.check_name(\"thread_local\"))\n+                !allowed ||\n+                    cx.tcx.get_attrs(def_id).iter().any(\n+                        |attr| attr.check_name(\"thread_local\"\n+                    ))\n+            }\n+        }\n     }\n \n     fn in_projection(cx: &ConstCx<'_, 'tcx>, proj: &PlaceProjection<'tcx>) -> bool {\n@@ -768,9 +778,9 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     );\n                     dest = &proj.base;\n                 },\n-                Place::Base(PlaceBase::Promoted(..)) =>\n+                Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) =>\n                     bug!(\"promoteds don't exist yet during promotion\"),\n-                Place::Base(PlaceBase::Static(..)) => {\n+                Place::Base(PlaceBase::Static(box Static{ kind: _, .. })) => {\n                     // Catch more errors in the destination. `visit_place` also checks that we\n                     // do not try to access statics from constants or try to mutate statics\n                     self.visit_place(\n@@ -919,11 +929,13 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         debug!(\"visit_place: place={:?} context={:?} location={:?}\", place, context, location);\n         self.super_place(place, context, location);\n         match *place {\n-            Place::Base(PlaceBase::Local(_)) |\n-            Place::Base(PlaceBase::Promoted(_)) => {}\n-            Place::Base(PlaceBase::Static(ref global)) => {\n+            Place::Base(PlaceBase::Local(_)) => {}\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) => {\n+                unreachable!()\n+            }\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })) => {\n                 if self.tcx\n-                       .get_attrs(global.def_id)\n+                       .get_attrs(def_id)\n                        .iter()\n                        .any(|attr| attr.check_name(\"thread_local\")) {\n                     if self.mode != Mode::Fn {"}, {"sha": "8742c5d759c8f33feace505aee318a8d5c336a78", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -257,8 +257,8 @@ fn check_place(\n     match place {\n         Place::Base(PlaceBase::Local(_)) => Ok(()),\n         // promoteds are always fine, they are essentially constants\n-        Place::Base(PlaceBase::Promoted(_)) => Ok(()),\n-        Place::Base(PlaceBase::Static(_)) =>\n+        Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. })) => Ok(()),\n+        Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Static(_), .. })) =>\n             Err((span, \"cannot access `static` items in const fn\".into())),\n         Place::Projection(proj) => {\n             match proj.elem {"}, {"sha": "461d02e515d38dcfdacd6a66c9a218f3e8a885e2", "filename": "src/librustc_resolve/error_reporting.rs", "status": "modified", "additions": 41, "deletions": 54, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -5,7 +5,7 @@ use log::debug;\n use rustc::hir::def::{Def, CtorKind, Namespace::*};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::session::config::nightly_options;\n-use syntax::ast::{ExprKind};\n+use syntax::ast::{Expr, ExprKind};\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n@@ -250,6 +250,29 @@ impl<'a> Resolver<'a> {\n         let ns = source.namespace();\n         let is_expected = &|def| source.is_expected(def);\n \n+        let path_sep = |err: &mut DiagnosticBuilder<'_>, expr: &Expr| match expr.node {\n+            ExprKind::Field(_, ident) => {\n+                err.span_suggestion(\n+                    expr.span,\n+                    \"use the path separator to refer to an item\",\n+                    format!(\"{}::{}\", path_str, ident),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                true\n+            }\n+            ExprKind::MethodCall(ref segment, ..) => {\n+                let span = expr.span.with_hi(segment.ident.span.hi());\n+                err.span_suggestion(\n+                    span,\n+                    \"use the path separator to refer to an item\",\n+                    format!(\"{}::{}\", path_str, segment.ident),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                true\n+            }\n+            _ => false,\n+        };\n+\n         match (def, source) {\n             (Def::Macro(..), _) => {\n                 err.span_suggestion(\n@@ -259,8 +282,7 @@ impl<'a> Resolver<'a> {\n                     Applicability::MaybeIncorrect,\n                 );\n                 if path_str == \"try\" && span.rust_2015() {\n-                    err.note(\"if you want the `try` keyword, \\\n-                        you need to be in the 2018 edition\");\n+                    err.note(\"if you want the `try` keyword, you need to be in the 2018 edition\");\n                 }\n             }\n             (Def::TyAlias(..), PathSource::Trait(_)) => {\n@@ -269,25 +291,8 @@ impl<'a> Resolver<'a> {\n                     err.note(\"did you mean to use a trait alias?\");\n                 }\n             }\n-            (Def::Mod(..), PathSource::Expr(Some(parent))) => match parent.node {\n-                ExprKind::Field(_, ident) => {\n-                    err.span_suggestion(\n-                        parent.span,\n-                        \"use the path separator to refer to an item\",\n-                        format!(\"{}::{}\", path_str, ident),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                ExprKind::MethodCall(ref segment, ..) => {\n-                    let span = parent.span.with_hi(segment.ident.span.hi());\n-                    err.span_suggestion(\n-                        span,\n-                        \"use the path separator to refer to an item\",\n-                        format!(\"{}::{}\", path_str, segment.ident),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                _ => return false,\n+            (Def::Mod(..), PathSource::Expr(Some(parent))) => if !path_sep(err, &parent) {\n+                return false;\n             },\n             (Def::Enum(..), PathSource::TupleStruct)\n                 | (Def::Enum(..), PathSource::Expr(..))  => {\n@@ -315,8 +320,10 @@ impl<'a> Resolver<'a> {\n                         = self.struct_constructors.get(&def_id).cloned() {\n                     let accessible_ctor = self.is_accessible(ctor_vis);\n                     if is_expected(ctor_def) && !accessible_ctor {\n-                        err.span_label(span, format!(\"constructor is not visible \\\n-                                                      here due to private fields\"));\n+                        err.span_label(\n+                            span,\n+                            format!(\"constructor is not visible here due to private fields\"),\n+                        );\n                     }\n                 } else {\n                     // HACK(estebank): find a better way to figure out that this was a\n@@ -366,28 +373,12 @@ impl<'a> Resolver<'a> {\n                         }\n                     }\n                     match source {\n-                        PathSource::Expr(Some(parent)) => {\n-                            match parent.node {\n-                                ExprKind::MethodCall(ref path_assignment, _)  => {\n-                                    err.span_suggestion(\n-                                        sm.start_point(parent.span)\n-                                            .to(path_assignment.ident.span),\n-                                        \"use `::` to access an associated function\",\n-                                        format!(\"{}::{}\",\n-                                                path_str,\n-                                                path_assignment.ident),\n-                                        Applicability::MaybeIncorrect\n-                                    );\n-                                },\n-                                _ => {\n-                                    err.span_label(\n-                                        span,\n-                                        format!(\"did you mean `{} {{ /* fields */ }}`?\",\n-                                                path_str),\n-                                    );\n-                                },\n-                            }\n-                        },\n+                        PathSource::Expr(Some(parent)) => if !path_sep(err, &parent) {\n+                            err.span_label(\n+                                span,\n+                                format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str),\n+                            );\n+                        }\n                         PathSource::Expr(None) if followed_by_brace == true => {\n                             if let Some((sp, snippet)) = closing_brace {\n                                 err.span_suggestion(\n@@ -399,16 +390,14 @@ impl<'a> Resolver<'a> {\n                             } else {\n                                 err.span_label(\n                                     span,\n-                                    format!(\"did you mean `({} {{ /* fields */ }})`?\",\n-                                            path_str),\n+                                    format!(\"did you mean `({} {{ /* fields */ }})`?\", path_str),\n                                 );\n                             }\n                         },\n                         _ => {\n                             err.span_label(\n                                 span,\n-                                format!(\"did you mean `{} {{ /* fields */ }}`?\",\n-                                        path_str),\n+                                format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str),\n                             );\n                         },\n                     }\n@@ -417,13 +406,11 @@ impl<'a> Resolver<'a> {\n             (Def::Union(..), _) |\n             (Def::Variant(..), _) |\n             (Def::Ctor(_, _, CtorKind::Fictive), _) if ns == ValueNS => {\n-                err.span_label(span, format!(\"did you mean `{} {{ /* fields */ }}`?\",\n-                                             path_str));\n+                err.span_label(span, format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str));\n             }\n             (Def::SelfTy(..), _) if ns == ValueNS => {\n                 err.span_label(span, fallback_label);\n-                err.note(\"can't use `Self` as a constructor, you must use the \\\n-                          implemented struct\");\n+                err.note(\"can't use `Self` as a constructor, you must use the implemented struct\");\n             }\n             (Def::TyAlias(_), _) | (Def::AssociatedTy(..), _) if ns == ValueNS => {\n                 err.note(\"can't use a type alias as a constructor\");"}, {"sha": "f48cfa0b1479f2f66dc42dfb2c4edc8f1e64c06d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 57, "deletions": 7, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -3262,32 +3262,82 @@ impl<'a> Resolver<'a> {\n         resolution\n     }\n \n-    fn type_ascription_suggestion(&self,\n-                                  err: &mut DiagnosticBuilder<'_>,\n-                                  base_span: Span) {\n+    /// Only used in a specific case of type ascription suggestions\n+    #[doc(hidden)]\n+    fn get_colon_suggestion_span(&self, start: Span) -> Span {\n+        let cm = self.session.source_map();\n+        start.to(cm.next_point(start))\n+    }\n+\n+    fn type_ascription_suggestion(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        base_span: Span,\n+    ) {\n         debug!(\"type_ascription_suggetion {:?}\", base_span);\n         let cm = self.session.source_map();\n+        let base_snippet = cm.span_to_snippet(base_span);\n         debug!(\"self.current_type_ascription {:?}\", self.current_type_ascription);\n         if let Some(sp) = self.current_type_ascription.last() {\n             let mut sp = *sp;\n             loop {\n                 // Try to find the `:`; bail on first non-':' / non-whitespace.\n                 sp = cm.next_point(sp);\n                 if let Ok(snippet) = cm.span_to_snippet(sp.to(cm.next_point(sp))) {\n-                    debug!(\"snippet {:?}\", snippet);\n                     let line_sp = cm.lookup_char_pos(sp.hi()).line;\n                     let line_base_sp = cm.lookup_char_pos(base_span.lo()).line;\n-                    debug!(\"{:?} {:?}\", line_sp, line_base_sp);\n                     if snippet == \":\" {\n-                        err.span_label(base_span,\n-                                       \"expecting a type here because of type ascription\");\n+                        let mut show_label = true;\n                         if line_sp != line_base_sp {\n                             err.span_suggestion_short(\n                                 sp,\n                                 \"did you mean to use `;` here instead?\",\n                                 \";\".to_string(),\n                                 Applicability::MaybeIncorrect,\n                             );\n+                        } else {\n+                            let colon_sp = self.get_colon_suggestion_span(sp);\n+                            let after_colon_sp = self.get_colon_suggestion_span(\n+                                colon_sp.shrink_to_hi(),\n+                            );\n+                            if !cm.span_to_snippet(after_colon_sp).map(|s| s == \" \")\n+                                .unwrap_or(false)\n+                            {\n+                                err.span_suggestion(\n+                                    colon_sp,\n+                                    \"maybe you meant to write a path separator here\",\n+                                    \"::\".to_string(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                                show_label = false;\n+                            }\n+                            if let Ok(base_snippet) = base_snippet {\n+                                let mut sp = after_colon_sp;\n+                                for _ in 0..100 {\n+                                    // Try to find an assignment\n+                                    sp = cm.next_point(sp);\n+                                    let snippet = cm.span_to_snippet(sp.to(cm.next_point(sp)));\n+                                    match snippet {\n+                                        Ok(ref x) if x.as_str() == \"=\" => {\n+                                            err.span_suggestion(\n+                                                base_span,\n+                                                \"maybe you meant to write an assignment here\",\n+                                                format!(\"let {}\", base_snippet),\n+                                                Applicability::MaybeIncorrect,\n+                                            );\n+                                            show_label = false;\n+                                            break;\n+                                        }\n+                                        Ok(ref x) if x.as_str() == \"\\n\" => break,\n+                                        Err(_) => break,\n+                                        Ok(_) => {}\n+                                    }\n+                                }\n+                            }\n+                        }\n+                        if show_label {\n+                            err.span_label(base_span,\n+                                           \"expecting a type here because of type ascription\");\n                         }\n                         break;\n                     } else if !snippet.trim().is_empty() {"}, {"sha": "b11bd9c2408bf75506a5e25e4105ce25cbf42b24", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -5318,10 +5318,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     ) -> Option<Span> {\n         // Be helpful when the user wrote `{... expr;}` and\n         // taking the `;` off is enough to fix the error.\n-        let last_stmt = match blk.stmts.last() {\n-            Some(s) => s,\n-            None => return None,\n-        };\n+        let last_stmt = blk.stmts.last()?;\n         let last_expr = match last_stmt.node {\n             hir::StmtKind::Semi(ref e) => e,\n             _ => return None,"}, {"sha": "796908b0df943cd6526668bca1eae3e29557e26f", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -960,17 +960,27 @@ impl f32 {\n     pub fn atanh(self) -> f32 {\n         0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n     }\n-    /// Returns max if self is greater than max, and min if self is less than min.\n-    /// Otherwise this returns self.  Panics if min > max, min equals NaN, or max equals NaN.\n+\n+    /// Restrict a value to a certain interval unless it is NaN.\n+    ///\n+    /// Returns `max` if `self` is greater than `max`, and `min` if `self` is\n+    /// less than `min`. Otherwise this returns `self`.\n+    ///\n+    /// Not that this function returns NaN if the initial value was NaN as\n+    /// well.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `min > max`, `min` is NaN, or `max` is NaN.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(clamp)]\n-    /// assert!((-3.0f32).clamp(-2.0f32, 1.0f32) == -2.0f32);\n-    /// assert!((0.0f32).clamp(-2.0f32, 1.0f32) == 0.0f32);\n-    /// assert!((2.0f32).clamp(-2.0f32, 1.0f32) == 1.0f32);\n-    /// assert!((std::f32::NAN).clamp(-2.0f32, 1.0f32).is_nan());\n+    /// assert!((-3.0f32).clamp(-2.0, 1.0) == -2.0);\n+    /// assert!((0.0f32).clamp(-2.0, 1.0) == 0.0);\n+    /// assert!((2.0f32).clamp(-2.0, 1.0) == 1.0);\n+    /// assert!((std::f32::NAN).clamp(-2.0, 1.0).is_nan());\n     /// ```\n     #[unstable(feature = \"clamp\", issue = \"44095\")]\n     #[inline]"}, {"sha": "e679a7d2e8c0455591527b5f5fcb478bd1dd74eb", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -882,17 +882,26 @@ impl f64 {\n         0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n     }\n \n-    /// Returns max if self is greater than max, and min if self is less than min.\n-    /// Otherwise this returns self.  Panics if min > max, min equals NaN, or max equals NaN.\n+    /// Restrict a value to a certain interval unless it is NaN.\n+    ///\n+    /// Returns `max` if `self` is greater than `max`, and `min` if `self` is\n+    /// less than `min`. Otherwise this returns `self`.\n+    ///\n+    /// Not that this function returns NaN if the initial value was NaN as\n+    /// well.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `min > max`, `min` is NaN, or `max` is NaN.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(clamp)]\n-    /// assert!((-3.0f64).clamp(-2.0f64, 1.0f64) == -2.0f64);\n-    /// assert!((0.0f64).clamp(-2.0f64, 1.0f64) == 0.0f64);\n-    /// assert!((2.0f64).clamp(-2.0f64, 1.0f64) == 1.0f64);\n-    /// assert!((std::f64::NAN).clamp(-2.0f64, 1.0f64).is_nan());\n+    /// assert!((-3.0f64).clamp(-2.0, 1.0) == -2.0);\n+    /// assert!((0.0f64).clamp(-2.0, 1.0) == 0.0);\n+    /// assert!((2.0f64).clamp(-2.0, 1.0) == 1.0);\n+    /// assert!((std::f64::NAN).clamp(-2.0, 1.0).is_nan());\n     /// ```\n     #[unstable(feature = \"clamp\", issue = \"44095\")]\n     #[inline]"}, {"sha": "49a234e1158044b4de1f4f76ea4e67ab30f86ca4", "filename": "src/libstd/sys/cloudabi/time.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibstd%2Fsys%2Fcloudabi%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibstd%2Fsys%2Fcloudabi%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Ftime.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -33,11 +33,9 @@ impl Instant {\n         Instant { t: 0 }\n     }\n \n-    pub fn sub_instant(&self, other: &Instant) -> Duration {\n-        let diff = self.t\n-            .checked_sub(other.t)\n-            .expect(\"second instant is later than self\");\n-        Duration::new(diff / NSEC_PER_SEC, (diff % NSEC_PER_SEC) as u32)\n+    pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n+        let diff = self.t.checked_sub(other.t)?;\n+        Some(Duration::new(diff / NSEC_PER_SEC, (diff % NSEC_PER_SEC) as u32))\n     }\n \n     pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {"}, {"sha": "881ad5c0aeb14b849b1347e62b1005440567becb", "filename": "src/libstd/sys/redox/time.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibstd%2Fsys%2Fredox%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibstd%2Fsys%2Fredox%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ftime.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -137,10 +137,8 @@ impl Instant {\n         false\n     }\n \n-    pub fn sub_instant(&self, other: &Instant) -> Duration {\n-        self.t.sub_timespec(&other.t).unwrap_or_else(|_| {\n-            panic!(\"specified instant was later than self\")\n-        })\n+    pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n+        self.t.sub_timespec(&other.t).ok()\n     }\n \n     pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {"}, {"sha": "4659f7ba71fe07a50ba895aa8bffc9236c258f56", "filename": "src/libstd/sys/sgx/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibstd%2Fsys%2Fsgx%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibstd%2Fsys%2Fsgx%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Ftime.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -14,8 +14,8 @@ impl Instant {\n         Instant(usercalls::insecure_time())\n     }\n \n-    pub fn sub_instant(&self, other: &Instant) -> Duration {\n-        self.0 - other.0\n+    pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n+        self.0.checked_sub(other.0)\n     }\n \n     pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {"}, {"sha": "6b5a89aee7d690e3229f79b165cd4e6c5f3344b6", "filename": "src/libstd/sys/unix/time.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftime.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -149,12 +149,11 @@ mod inner {\n             true\n         }\n \n-        pub fn sub_instant(&self, other: &Instant) -> Duration {\n+        pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n+            let diff = self.t.checked_sub(other.t)?;\n             let info = info();\n-            let diff = self.t.checked_sub(other.t)\n-                           .expect(\"second instant is later than self\");\n             let nanos = mul_div_u64(diff, info.numer as u64, info.denom as u64);\n-            Duration::new(nanos / NSEC_PER_SEC, (nanos % NSEC_PER_SEC) as u32)\n+            Some(Duration::new(nanos / NSEC_PER_SEC, (nanos % NSEC_PER_SEC) as u32))\n         }\n \n         pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n@@ -285,10 +284,8 @@ mod inner {\n             false // last clause, used so `||` is always trailing above\n         }\n \n-        pub fn sub_instant(&self, other: &Instant) -> Duration {\n-            self.t.sub_timespec(&other.t).unwrap_or_else(|_| {\n-                panic!(\"specified instant was later than self\")\n-            })\n+        pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n+            self.t.sub_timespec(&other.t).ok()\n         }\n \n         pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {"}, {"sha": "3f71461eea4872f2a422b2dc86085b30eb135bb9", "filename": "src/libstd/sys/wasm/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Ftime.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -22,8 +22,8 @@ impl Instant {\n         false\n     }\n \n-    pub fn sub_instant(&self, other: &Instant) -> Duration {\n-        self.0 - other.0\n+    pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n+        self.0.checked_sub(other.0)\n     }\n \n     pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {"}, {"sha": "aa53f1194fdb43b8f8ff20a38aefe708252971d4", "filename": "src/libstd/sys/windows/time.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -49,17 +49,17 @@ impl Instant {\n         Instant { t: Duration::from_secs(0) }\n     }\n \n-    pub fn sub_instant(&self, other: &Instant) -> Duration {\n+    pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n         // On windows there's a threshold below which we consider two timestamps\n         // equivalent due to measurement error. For more details + doc link,\n         // check the docs on epsilon.\n         let epsilon =\n             perf_counter::PerformanceCounterInstant::epsilon();\n         if other.t > self.t && other.t - self.t <= epsilon {\n-            return Duration::new(0, 0)\n+            Some(Duration::new(0, 0))\n+        } else {\n+            self.t.checked_sub(other.t)\n         }\n-        self.t.checked_sub(other.t)\n-              .expect(\"specified instant was later than self\")\n     }\n \n     pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {"}, {"sha": "ab1a43d6672e405296298262b05aa6fc6e169d1e", "filename": "src/libstd/time.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -212,7 +212,7 @@ impl Instant {\n     /// ```\n     #[stable(feature = \"time2\", since = \"1.8.0\")]\n     pub fn duration_since(&self, earlier: Instant) -> Duration {\n-        self.0.sub_instant(&earlier.0)\n+        self.0.checked_sub_instant(&earlier.0).expect(\"supplied instant is later than self\")\n     }\n \n     /// Returns the amount of time elapsed from another instant to this one,\n@@ -233,11 +233,7 @@ impl Instant {\n     /// ```\n     #[unstable(feature = \"checked_duration_since\", issue = \"58402\")]\n     pub fn checked_duration_since(&self, earlier: Instant) -> Option<Duration> {\n-        if self >= &earlier {\n-            Some(self.0.sub_instant(&earlier.0))\n-        } else {\n-            None\n-        }\n+        self.0.checked_sub_instant(&earlier.0)\n     }\n \n     /// Returns the amount of time elapsed from another instant to this one,\n@@ -664,20 +660,23 @@ mod tests {\n \n     #[test]\n     #[should_panic]\n-    fn instant_duration_panic() {\n+    fn instant_duration_since_panic() {\n         let a = Instant::now();\n         (a - Duration::new(1, 0)).duration_since(a);\n     }\n \n     #[test]\n-    fn checked_instant_duration_nopanic() {\n-        let a = Instant::now();\n-        let ret = (a - Duration::new(1, 0)).checked_duration_since(a);\n-        assert_eq!(ret, None);\n+    fn instant_checked_duration_since_nopanic() {\n+        let now = Instant::now();\n+        let earlier = now - Duration::new(1, 0);\n+        let later = now + Duration::new(1, 0);\n+        assert_eq!(earlier.checked_duration_since(now), None);\n+        assert_eq!(later.checked_duration_since(now), Some(Duration::new(1, 0)));\n+        assert_eq!(now.checked_duration_since(now), Some(Duration::new(0, 0)));\n     }\n \n     #[test]\n-    fn saturating_instant_duration_nopanic() {\n+    fn instant_saturating_duration_since_nopanic() {\n         let a = Instant::now();\n         let ret = (a - Duration::new(1, 0)).saturating_duration_since(a);\n         assert_eq!(ret, Duration::new(0,0));"}, {"sha": "96c89d3176ab60ad035ccf39410a064a5b502cb2", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -1836,8 +1836,12 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 gate_feature_post!(&self, box_syntax, e.span, EXPLAIN_BOX_SYNTAX);\n             }\n             ast::ExprKind::Type(..) => {\n-                gate_feature_post!(&self, type_ascription, e.span,\n-                                  \"type ascription is experimental\");\n+                // To avoid noise about type ascription in common syntax errors, only emit if it\n+                // is the *only* error.\n+                if self.context.parse_sess.span_diagnostic.err_count() == 0 {\n+                    gate_feature_post!(&self, type_ascription, e.span,\n+                                       \"type ascription is experimental\");\n+                }\n             }\n             ast::ExprKind::ObsoleteInPlace(..) => {\n                 // these get a hard error in ast-validation"}, {"sha": "a0c3fe356083f76bb6031d85f11d26b933b98d76", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 62, "deletions": 13, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -3538,22 +3538,19 @@ impl<'a> Parser<'a> {\n                 lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Cast)?;\n                 continue\n             } else if op == AssocOp::Colon {\n+                let maybe_path = self.could_ascription_be_path(&lhs.node);\n+                let next_sp = self.span;\n+\n                 lhs = match self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Type) {\n                     Ok(lhs) => lhs,\n                     Err(mut err) => {\n-                        err.span_label(self.span,\n-                                       \"expecting a type here because of type ascription\");\n-                        let cm = self.sess.source_map();\n-                        let cur_pos = cm.lookup_char_pos(self.span.lo());\n-                        let op_pos = cm.lookup_char_pos(cur_op_span.hi());\n-                        if cur_pos.line != op_pos.line {\n-                            err.span_suggestion(\n-                                cur_op_span,\n-                                \"try using a semicolon\",\n-                                \";\".to_string(),\n-                                Applicability::MaybeIncorrect // speculative\n-                            );\n-                        }\n+                        self.bad_type_ascription(\n+                            &mut err,\n+                            lhs_span,\n+                            cur_op_span,\n+                            next_sp,\n+                            maybe_path,\n+                        );\n                         return Err(err);\n                     }\n                 };\n@@ -3658,6 +3655,58 @@ impl<'a> Parser<'a> {\n         Ok(lhs)\n     }\n \n+    fn could_ascription_be_path(&self, node: &ast::ExprKind) -> bool {\n+        self.token.is_ident() &&\n+            if let ast::ExprKind::Path(..) = node { true } else { false } &&\n+            !self.token.is_reserved_ident() &&           // v `foo:bar(baz)`\n+            self.look_ahead(1, |t| t == &token::OpenDelim(token::Paren)) ||\n+            self.look_ahead(1, |t| t == &token::Lt) &&     // `foo:bar<baz`\n+            self.look_ahead(2, |t| t.is_ident()) ||\n+            self.look_ahead(1, |t| t == &token::Colon) &&  // `foo:bar:baz`\n+            self.look_ahead(2, |t| t.is_ident()) ||\n+            self.look_ahead(1, |t| t == &token::ModSep) &&  // `foo:bar::baz`\n+            self.look_ahead(2, |t| t.is_ident())\n+    }\n+\n+    fn bad_type_ascription(\n+        &self,\n+        err: &mut DiagnosticBuilder<'a>,\n+        lhs_span: Span,\n+        cur_op_span: Span,\n+        next_sp: Span,\n+        maybe_path: bool,\n+    ) {\n+        err.span_label(self.span, \"expecting a type here because of type ascription\");\n+        let cm = self.sess.source_map();\n+        let next_pos = cm.lookup_char_pos(next_sp.lo());\n+        let op_pos = cm.lookup_char_pos(cur_op_span.hi());\n+        if op_pos.line != next_pos.line {\n+            err.span_suggestion(\n+                cur_op_span,\n+                \"try using a semicolon\",\n+                \";\".to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        } else {\n+            if maybe_path {\n+                err.span_suggestion(\n+                    cur_op_span,\n+                    \"maybe you meant to write a path separator here\",\n+                    \"::\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            } else {\n+                err.note(\"type ascription is a nightly-only feature that lets \\\n+                          you annotate an expression with a type: `<expr>: <type>`\");\n+                err.span_note(\n+                    lhs_span,\n+                    \"this expression expects an ascribed type after the colon\",\n+                );\n+                err.help(\"this might be indicative of a syntax error elsewhere\");\n+            }\n+        }\n+    }\n+\n     fn parse_assoc_op_cast(&mut self, lhs: P<Expr>, lhs_span: Span,\n                            expr_kind: fn(P<Expr>, P<Ty>) -> ExprKind)\n                            -> PResult<'a, P<Expr>> {"}, {"sha": "05cc945bbaf0098175fe0d03b29be69126b46acc", "filename": "src/test/incremental/hashes/call_expressions.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Fcall_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Fcall_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fcall_expressions.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -25,7 +25,7 @@ pub fn change_callee_function() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_callee_function() {\n     callee2(1, 2)\n@@ -40,7 +40,7 @@ pub fn change_argument_function() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_argument_function() {\n     callee1(1, 3)\n@@ -81,7 +81,7 @@ pub fn change_callee_method() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_callee_method() {\n     let s = Struct;\n@@ -98,7 +98,7 @@ pub fn change_argument_method() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_argument_method() {\n     let s = Struct;\n@@ -115,7 +115,7 @@ pub fn change_ufcs_callee_method() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_ufcs_callee_method() {\n     let s = Struct;\n@@ -132,7 +132,7 @@ pub fn change_argument_method_ufcs() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_argument_method_ufcs() {\n     let s = Struct;\n@@ -149,7 +149,7 @@ pub fn change_to_ufcs() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n // One might think this would be expanded in the HirBody/Mir, but it actually\n // results in slightly different Hir/Mir.\n@@ -171,7 +171,7 @@ pub mod change_ufcs_callee_indirectly {\n     #[cfg(not(cfail1))]\n     use super::Struct2 as Struct;\n \n-    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized,TypeckTables\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n \n "}, {"sha": "b8e84173ec06ce03da0ea4b7831c3d77990bb74d", "filename": "src/test/incremental/hashes/closure_expressions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fclosure_expressions.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -37,7 +37,7 @@ pub fn add_parameter() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_parameter() {\n     let x = 0u32;\n@@ -53,7 +53,7 @@ pub fn change_parameter_pattern() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_parameter_pattern() {\n     let _ = |&x: &u32| x;\n@@ -84,7 +84,7 @@ pub fn add_type_ascription_to_parameter() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_type_ascription_to_parameter() {\n     let closure = |x: u32| x + 1u32;\n@@ -101,7 +101,7 @@ pub fn change_parameter_type() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_parameter_type() {\n     let closure = |x: u16| (x as u64) + 1;"}, {"sha": "d3f96c9947b89379aa58625e614c3daf8212a820", "filename": "src/test/incremental/hashes/enum_constructors.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Fenum_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Fenum_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fenum_constructors.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -34,7 +34,7 @@ pub fn change_field_value_struct_like() -> Enum {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirBuilt\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_field_value_struct_like() -> Enum {\n     Enum::Struct {\n@@ -96,7 +96,7 @@ pub fn change_constructor_path_struct_like() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirBuilt,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_constructor_path_struct_like() {\n     let _ = Enum2::Struct {\n@@ -119,7 +119,7 @@ pub fn change_constructor_variant_struct_like() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirBuilt\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_constructor_variant_struct_like() {\n     let _ = Enum2::Struct2 {\n@@ -139,7 +139,7 @@ pub mod change_constructor_path_indirectly_struct_like {\n \n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"FnSignature,Hir,HirBody,MirOptimized,MirBuilt,\\\n+        except=\"FnSignature,Hir,HirBody,optimized_mir,mir_built,\\\n                 TypeckTables\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n@@ -161,7 +161,7 @@ pub mod change_constructor_variant_indirectly_struct_like {\n     #[cfg(not(cfail1))]\n     use super::Enum2::Struct2 as Variant;\n \n-    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirBuilt\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn function() -> Enum2 {\n         Variant {\n@@ -180,7 +180,7 @@ pub fn change_field_value_tuple_like() -> Enum {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirBuilt\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_field_value_tuple_like() -> Enum {\n     Enum::Tuple(0, 1, 3)\n@@ -197,7 +197,7 @@ pub fn change_constructor_path_tuple_like() {\n #[cfg(not(cfail1))]\n #[rustc_clean(\n     cfg=\"cfail2\",\n-    except=\"HirBody,MirOptimized,MirBuilt,TypeckTables\"\n+    except=\"HirBody,optimized_mir,mir_built,TypeckTables\"\n )]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_constructor_path_tuple_like() {\n@@ -215,7 +215,7 @@ pub fn change_constructor_variant_tuple_like() {\n #[cfg(not(cfail1))]\n #[rustc_clean(\n     cfg=\"cfail2\",\n-    except=\"HirBody,MirOptimized,MirBuilt,TypeckTables\"\n+    except=\"HirBody,optimized_mir,mir_built,TypeckTables\"\n )]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_constructor_variant_tuple_like() {\n@@ -232,7 +232,7 @@ pub mod change_constructor_path_indirectly_tuple_like {\n \n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"FnSignature,Hir,HirBody,MirOptimized,MirBuilt,\\\n+        except=\"FnSignature,Hir,HirBody,optimized_mir,mir_built,\\\n                 TypeckTables\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n@@ -251,7 +251,7 @@ pub mod change_constructor_variant_indirectly_tuple_like {\n     #[cfg(not(cfail1))]\n     use super::Enum2::Tuple2 as Variant;\n \n-    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirBuilt,TypeckTables\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,TypeckTables\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn function() -> Enum2 {\n         Variant(0, 1, 2)\n@@ -278,7 +278,7 @@ pub fn change_constructor_path_c_like() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirBuilt,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_constructor_path_c_like() {\n     let _ = Clike2::B;\n@@ -293,7 +293,7 @@ pub fn change_constructor_variant_c_like() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirBuilt\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_constructor_variant_c_like() {\n     let _ = Clike::C;\n@@ -309,7 +309,7 @@ pub mod change_constructor_path_indirectly_c_like {\n \n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"FnSignature,Hir,HirBody,MirOptimized,MirBuilt,\\\n+        except=\"FnSignature,Hir,HirBody,optimized_mir,mir_built,\\\n                 TypeckTables\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n@@ -328,7 +328,7 @@ pub mod change_constructor_variant_indirectly_c_like {\n     #[cfg(not(cfail1))]\n     use super::Clike::B as Variant;\n \n-    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirBuilt\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn function() -> Clike {\n         Variant"}, {"sha": "dc919abc02d44311bf190811f1fd5242f18b1dc4", "filename": "src/test/incremental/hashes/exported_vs_not.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Fexported_vs_not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Fexported_vs_not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fexported_vs_not.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -16,7 +16,7 @@ pub fn body_not_exported_to_metadata() -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn body_not_exported_to_metadata() -> u32 {\n     2\n@@ -35,7 +35,7 @@ pub fn body_exported_to_metadata_because_of_inline() -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n #[inline]\n pub fn body_exported_to_metadata_because_of_inline() -> u32 {\n@@ -55,7 +55,7 @@ pub fn body_exported_to_metadata_because_of_generic() -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n #[inline]\n pub fn body_exported_to_metadata_because_of_generic() -> u32 {"}, {"sha": "91abca3312bc27ad6381c66d8a022415840d0f47", "filename": "src/test/incremental/hashes/for_loops.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffor_loops.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -25,7 +25,7 @@ pub fn change_loop_body() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_loop_body() {\n     let mut _x = 0;\n@@ -48,7 +48,7 @@ pub fn change_iteration_variable_name() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_iteration_variable_name() {\n     let mut _x = 0;\n@@ -71,7 +71,7 @@ pub fn change_iteration_variable_pattern() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_iteration_variable_pattern() {\n     let mut _x = 0;\n@@ -94,7 +94,7 @@ pub fn change_iterable() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_iterable() {\n     let mut _x = 0;\n@@ -116,7 +116,7 @@ pub fn add_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_break() {\n     let mut _x = 0;\n@@ -187,7 +187,7 @@ pub fn change_break_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_break_label() {\n     let mut _x = 0;\n@@ -237,7 +237,7 @@ pub fn change_continue_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_continue_label() {\n     let mut _x = 0;\n@@ -262,7 +262,7 @@ pub fn change_continue_to_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_continue_to_break() {\n     let mut _x = 0;"}, {"sha": "db8fa9ced113ce05c0bd669275d30a126b1f3309", "filename": "src/test/incremental/hashes/function_interfaces.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -24,7 +24,7 @@ pub fn add_parameter() {}\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg = \"cfail2\",\n-              except = \"Hir, HirBody, MirBuilt, MirOptimized, TypeckTables, FnSignature\")]\n+              except = \"Hir, HirBody, mir_built, optimized_mir, TypeckTables, FnSignature\")]\n #[rustc_clean(cfg = \"cfail3\")]\n pub fn add_parameter(p: i32) {}\n \n@@ -47,7 +47,7 @@ pub fn type_of_parameter(p: i32) {}\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg = \"cfail2\",\n-              except = \"Hir, HirBody, MirBuilt, MirOptimized, TypeckTables, FnSignature\")]\n+              except = \"Hir, HirBody, mir_built, optimized_mir, TypeckTables, FnSignature\")]\n #[rustc_clean(cfg = \"cfail3\")]\n pub fn type_of_parameter(p: i64) {}\n \n@@ -59,7 +59,7 @@ pub fn type_of_parameter_ref(p: &i32) {}\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg = \"cfail2\",\n-              except = \"Hir, HirBody, MirBuilt, MirOptimized, TypeckTables, FnSignature\")]\n+              except = \"Hir, HirBody, mir_built, optimized_mir, TypeckTables, FnSignature\")]\n #[rustc_clean(cfg = \"cfail3\")]\n pub fn type_of_parameter_ref(p: &mut i32) {}\n \n@@ -71,7 +71,7 @@ pub fn order_of_parameters(p1: i32, p2: i64) {}\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg = \"cfail2\",\n-              except = \"Hir, HirBody, MirBuilt, MirOptimized, TypeckTables, FnSignature\")]\n+              except = \"Hir, HirBody, mir_built, optimized_mir, TypeckTables, FnSignature\")]\n #[rustc_clean(cfg = \"cfail3\")]\n pub fn order_of_parameters(p2: i64, p1: i32) {}\n \n@@ -83,7 +83,7 @@ pub fn make_unsafe() {}\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg = \"cfail2\",\n-              except = \"Hir, HirBody, MirBuilt, MirOptimized, TypeckTables, FnSignature\")]\n+              except = \"Hir, HirBody, mir_built, optimized_mir, TypeckTables, FnSignature\")]\n #[rustc_clean(cfg = \"cfail3\")]\n pub unsafe fn make_unsafe() {}\n \n@@ -94,7 +94,7 @@ pub unsafe fn make_unsafe() {}\n pub fn make_extern() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody, MirBuilt, TypeckTables, FnSignature\")]\n+#[rustc_clean(cfg = \"cfail2\", except = \"Hir, HirBody, mir_built, TypeckTables, FnSignature\")]\n #[rustc_clean(cfg = \"cfail3\")]\n pub extern \"C\" fn make_extern() {}\n \n@@ -292,7 +292,7 @@ pub mod change_return_type_indirectly {\n     use super::ReferencedType2 as ReturnType;\n \n     #[rustc_clean(cfg = \"cfail2\",\n-                  except = \"Hir, HirBody, MirBuilt, MirOptimized, TypeckTables, FnSignature\")]\n+                  except = \"Hir, HirBody, mir_built, optimized_mir, TypeckTables, FnSignature\")]\n     #[rustc_clean(cfg = \"cfail3\")]\n     pub fn indirect_return_type() -> ReturnType {\n         ReturnType {}\n@@ -309,7 +309,7 @@ pub mod change_parameter_type_indirectly {\n     use super::ReferencedType2 as ParameterType;\n \n     #[rustc_clean(cfg = \"cfail2\",\n-                  except = \"Hir, HirBody, MirBuilt, MirOptimized, TypeckTables, FnSignature\")]\n+                  except = \"Hir, HirBody, mir_built, optimized_mir, TypeckTables, FnSignature\")]\n     #[rustc_clean(cfg = \"cfail3\")]\n     pub fn indirect_parameter_type(p: ParameterType) {}\n }"}, {"sha": "32a0c8b6b7e797d2a3ae1050e864cc52ba250457", "filename": "src/test/incremental/hashes/if_expressions.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fif_expressions.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -25,7 +25,7 @@ pub fn change_condition(x: bool) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_condition(x: bool) -> u32 {\n     if !x {\n@@ -46,7 +46,7 @@ pub fn change_then_branch(x: bool) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_then_branch(x: bool) -> u32 {\n     if x {\n@@ -69,7 +69,7 @@ pub fn change_else_branch(x: bool) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_else_branch(x: bool) -> u32 {\n     if x {\n@@ -120,7 +120,7 @@ pub fn change_condition_if_let(x: Option<u32>) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_condition_if_let(x: Option<u32>) -> u32 {\n     if let Some(_) = x {\n@@ -143,7 +143,7 @@ pub fn change_then_branch_if_let(x: Option<u32>) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_then_branch_if_let(x: Option<u32>) -> u32 {\n     if let Some(x) = x {\n@@ -166,7 +166,7 @@ pub fn change_else_branch_if_let(x: Option<u32>) -> u32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_else_branch_if_let(x: Option<u32>) -> u32 {\n     if let Some(x) = x {"}, {"sha": "1b6b41ce05b789baeac7750a7e0083b8dab71445", "filename": "src/test/incremental/hashes/inherent_impls.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -42,7 +42,7 @@ impl Foo {\n #[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirBuilt,TypeckTables\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,TypeckTables\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn method_body() {\n         println!(\"Hello, world!\");\n@@ -63,7 +63,7 @@ impl Foo {\n #[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirBuilt,TypeckTables\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,TypeckTables\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     #[inline]\n     pub fn method_body_inlined() {\n@@ -114,7 +114,7 @@ impl Foo {\n impl Foo {\n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"Hir,HirBody,FnSignature,TypeckTables,MirOptimized,MirBuilt\"\n+        except=\"Hir,HirBody,FnSignature,TypeckTables,optimized_mir,mir_built\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn method_selfmutness(&mut self) { }\n@@ -154,7 +154,7 @@ impl Foo {\n impl Foo {\n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"Hir,HirBody,FnSignature,TypeckTables,MirOptimized,MirBuilt\"\n+        except=\"Hir,HirBody,FnSignature,TypeckTables,optimized_mir,mir_built\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn add_method_parameter(&self, _: i32) { }\n@@ -172,7 +172,7 @@ impl Foo {\n #[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirBuilt\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn change_method_parameter_name(&self, b: i64) { }\n }\n@@ -191,7 +191,7 @@ impl Foo {\n impl Foo {\n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"Hir,HirBody,FnSignature,MirOptimized,MirBuilt,TypeckTables\")]\n+        except=\"Hir,HirBody,FnSignature,optimized_mir,mir_built,TypeckTables\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn change_method_return_type(&self) -> u8 { 0 }\n }\n@@ -226,7 +226,7 @@ impl Foo {\n #[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirBuilt\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn change_method_parameter_order(&self, b: i64, a: i64) { }\n }\n@@ -245,7 +245,7 @@ impl Foo {\n impl Foo {\n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"Hir,HirBody,FnSignature,TypeckTables,MirOptimized,MirBuilt\"\n+        except=\"Hir,HirBody,FnSignature,TypeckTables,optimized_mir,mir_built\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub unsafe fn make_method_unsafe(&self) { }\n@@ -263,7 +263,7 @@ impl Foo {\n #[rustc_clean(cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Foo {\n-    #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,MirBuilt,FnSignature,TypeckTables\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody,mir_built,FnSignature,TypeckTables\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub extern fn make_method_extern(&self) { }\n }\n@@ -447,7 +447,7 @@ impl Bar<u32> {\n impl<T> Bar<T> {\n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"generics_of,FnSignature,TypeckTables,type_of,MirOptimized,MirBuilt\"\n+        except=\"generics_of,FnSignature,TypeckTables,type_of,optimized_mir,mir_built\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn add_type_parameter_to_impl(&self) { }\n@@ -465,7 +465,7 @@ impl Bar<u32> {\n #[rustc_clean(cfg=\"cfail2\", except=\"Hir,HirBody\")]\n #[rustc_clean(cfg=\"cfail3\")]\n impl Bar<u64> {\n-    #[rustc_clean(cfg=\"cfail2\", except=\"FnSignature,MirOptimized,MirBuilt,TypeckTables\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"FnSignature,optimized_mir,mir_built,TypeckTables\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn change_impl_self_type(&self) { }\n }"}, {"sha": "53e77a370a334ab99c5d78122c3cf1dd01037e16", "filename": "src/test/incremental/hashes/inline_asm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Finline_asm.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -33,7 +33,7 @@ pub fn change_template(a: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n pub fn change_template(a: i32) -> i32 {\n@@ -69,7 +69,7 @@ pub fn change_output(a: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n pub fn change_output(a: i32) -> i32 {\n@@ -105,7 +105,7 @@ pub fn change_input(_a: i32, _b: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n pub fn change_input(_a: i32, _b: i32) -> i32 {\n@@ -140,7 +140,7 @@ pub fn change_input_constraint(_a: i32, _b: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n pub fn change_input_constraint(_a: i32, _b: i32) -> i32 {\n@@ -175,7 +175,7 @@ pub fn change_clobber(_a: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n pub fn change_clobber(_a: i32) -> i32 {\n@@ -210,7 +210,7 @@ pub fn change_options(_a: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n pub fn change_options(_a: i32) -> i32 {"}, {"sha": "76be2ccbf608c8db23f49f175f47a41abf5e0d99", "filename": "src/test/incremental/hashes/let_expressions.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -22,7 +22,7 @@ pub fn change_name() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,MirBuilt,MirOptimized\")]\n+    except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_name() {\n     let _y = 2u64;\n@@ -38,7 +38,7 @@ pub fn add_type() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,TypeckTables,MirBuilt,MirOptimized\")]\n+    except=\"HirBody,TypeckTables,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_type() {\n     let _x: u32 = 2u32;\n@@ -54,7 +54,7 @@ pub fn change_type() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,TypeckTables,MirBuilt,MirOptimized\")]\n+    except=\"HirBody,TypeckTables,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_type() {\n     let _x: u8 = 2;\n@@ -70,7 +70,7 @@ pub fn change_mutability_of_reference_type() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,TypeckTables,MirBuilt,MirOptimized\")]\n+    except=\"HirBody,TypeckTables,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_mutability_of_reference_type() {\n     let _x: &mut u64;\n@@ -86,7 +86,7 @@ pub fn change_mutability_of_slot() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,TypeckTables,MirBuilt,MirOptimized\")]\n+    except=\"HirBody,TypeckTables,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_mutability_of_slot() {\n     let _x: u64 = 0;\n@@ -102,7 +102,7 @@ pub fn change_simple_binding_to_pattern() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,TypeckTables,MirBuilt,MirOptimized\")]\n+    except=\"HirBody,TypeckTables,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_simple_binding_to_pattern() {\n     let (_a, _b) = (0u8, 'x');\n@@ -118,7 +118,7 @@ pub fn change_name_in_pattern() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,MirBuilt,MirOptimized\")]\n+    except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_name_in_pattern() {\n     let (_a, _c) = (1u8, 'y');\n@@ -134,7 +134,7 @@ pub fn add_ref_in_pattern() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,TypeckTables,MirBuilt,MirOptimized\")]\n+    except=\"HirBody,TypeckTables,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_ref_in_pattern() {\n     let (ref _a, _b) = (1u8, 'y');\n@@ -150,7 +150,7 @@ pub fn add_amp_in_pattern() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,TypeckTables,MirBuilt,MirOptimized\")]\n+    except=\"HirBody,TypeckTables,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_amp_in_pattern() {\n     let (&_a, _b) = (&1u8, 'y');\n@@ -166,7 +166,7 @@ pub fn change_mutability_of_binding_in_pattern() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,TypeckTables,MirBuilt,MirOptimized\")]\n+    except=\"HirBody,TypeckTables,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_mutability_of_binding_in_pattern() {\n     let (mut _a, _b) = (99u8, 'q');\n@@ -182,7 +182,7 @@ pub fn add_initializer() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,TypeckTables,MirBuilt,MirOptimized\")]\n+    except=\"HirBody,TypeckTables,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_initializer() {\n     let _x: i16 = 3i16;\n@@ -198,7 +198,7 @@ pub fn change_initializer() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,MirBuilt,MirOptimized\")]\n+    except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_initializer() {\n     let _x = 5u16;"}, {"sha": "63cf1e9d5e826819e30416c9cf31e4485e5bc571", "filename": "src/test/incremental/hashes/loop_expressions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Floop_expressions.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -25,7 +25,7 @@ pub fn change_loop_body() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_loop_body() {\n     let mut _x = 0;\n@@ -47,7 +47,7 @@ pub fn add_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_break() {\n     let mut _x = 0;\n@@ -118,7 +118,7 @@ pub fn change_break_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_break_label() {\n     let mut _x = 0;\n@@ -168,7 +168,7 @@ pub fn change_continue_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_continue_label() {\n     let mut _x = 0;\n@@ -193,7 +193,7 @@ pub fn change_continue_to_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_continue_to_break() {\n     let mut _x = 0;"}, {"sha": "37f6aa9ee9bdc86d328e2acc020ef9b5fdd1496e", "filename": "src/test/incremental/hashes/match_expressions.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Fmatch_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Fmatch_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fmatch_expressions.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -26,7 +26,7 @@ pub fn add_arm(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,MirBuilt,MirOptimized,TypeckTables\")]\n+    except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_arm(x: u32) -> u32 {\n     match x {\n@@ -51,7 +51,7 @@ pub fn change_order_of_arms(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,MirBuilt,MirOptimized\")]\n+    except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_order_of_arms(x: u32) -> u32 {\n     match x {\n@@ -75,7 +75,7 @@ pub fn add_guard_clause(x: u32, y: bool) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,MirBuilt,MirOptimized,TypeckTables\")]\n+    except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_guard_clause(x: u32, y: bool) -> u32 {\n     match x {\n@@ -99,7 +99,7 @@ pub fn change_guard_clause(x: u32, y: bool) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,MirBuilt,MirOptimized,TypeckTables\")]\n+    except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_guard_clause(x: u32, y: bool) -> u32 {\n     match x {\n@@ -123,7 +123,7 @@ pub fn add_at_binding(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,MirBuilt,MirOptimized,TypeckTables\")]\n+    except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_at_binding(x: u32) -> u32 {\n     match x {\n@@ -147,7 +147,7 @@ pub fn change_name_of_at_binding(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,MirBuilt,MirOptimized\")]\n+    except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_name_of_at_binding(x: u32) -> u32 {\n     match x {\n@@ -170,7 +170,7 @@ pub fn change_simple_name_to_pattern(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,MirBuilt,MirOptimized,TypeckTables\")]\n+    except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_simple_name_to_pattern(x: u32) -> u32 {\n     match (x, x & 1) {\n@@ -193,7 +193,7 @@ pub fn change_name_in_pattern(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,MirBuilt,MirOptimized\")]\n+    except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_name_in_pattern(x: u32) -> u32 {\n     match (x, x & 1) {\n@@ -216,7 +216,7 @@ pub fn change_mutability_of_binding_in_pattern(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,MirBuilt,MirOptimized,TypeckTables\")]\n+    except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_mutability_of_binding_in_pattern(x: u32) -> u32 {\n     match (x, x & 1) {\n@@ -238,7 +238,7 @@ pub fn add_ref_to_binding_in_pattern(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,MirBuilt,MirOptimized,TypeckTables\")]\n+    except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_ref_to_binding_in_pattern(x: u32) -> u32 {\n     match (x, x & 1) {\n@@ -260,7 +260,7 @@ pub fn add_amp_to_binding_in_pattern(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-except=\"HirBody,MirBuilt,MirOptimized,TypeckTables\")]\n+except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_amp_to_binding_in_pattern(x: u32) -> u32 {\n     match (&x, x & 1) {\n@@ -283,7 +283,7 @@ pub fn change_rhs_of_arm(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,MirBuilt,MirOptimized\")]\n+    except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_rhs_of_arm(x: u32) -> u32 {\n     match x {\n@@ -307,7 +307,7 @@ pub fn add_alternative_to_arm(x: u32) -> u32 {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,MirBuilt,MirOptimized,TypeckTables\")]\n+    except=\"HirBody,mir_built,optimized_mir,TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_alternative_to_arm(x: u32) -> u32 {\n     match x {"}, {"sha": "0803f4e01d63b1775f5e37f01dfb0462876b5d5c", "filename": "src/test/incremental/hashes/panic_exprs.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fpanic_exprs.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -18,7 +18,7 @@\n \n \n // Indexing expression ---------------------------------------------------------\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn indexing(slice: &[u8]) -> u8 {\n     #[cfg(cfail1)]\n@@ -33,7 +33,7 @@ pub fn indexing(slice: &[u8]) -> u8 {\n \n \n // Arithmetic overflow plus ----------------------------------------------------\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn arithmetic_overflow_plus(val: i32) -> i32 {\n     #[cfg(cfail1)]\n@@ -48,7 +48,7 @@ pub fn arithmetic_overflow_plus(val: i32) -> i32 {\n \n \n // Arithmetic overflow minus ----------------------------------------------------\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn arithmetic_overflow_minus(val: i32) -> i32 {\n     #[cfg(cfail1)]\n@@ -63,7 +63,7 @@ pub fn arithmetic_overflow_minus(val: i32) -> i32 {\n \n \n // Arithmetic overflow mult ----------------------------------------------------\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn arithmetic_overflow_mult(val: i32) -> i32 {\n     #[cfg(cfail1)]\n@@ -78,7 +78,7 @@ pub fn arithmetic_overflow_mult(val: i32) -> i32 {\n \n \n // Arithmetic overflow negation ------------------------------------------------\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn arithmetic_overflow_negation(val: i32) -> i32 {\n     #[cfg(cfail1)]\n@@ -93,7 +93,7 @@ pub fn arithmetic_overflow_negation(val: i32) -> i32 {\n \n \n // Division by zero ------------------------------------------------------------\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn division_by_zero(val: i32) -> i32 {\n     #[cfg(cfail1)]\n@@ -107,7 +107,7 @@ pub fn division_by_zero(val: i32) -> i32 {\n }\n \n // Division by zero ------------------------------------------------------------\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn mod_by_zero(val: i32) -> i32 {\n     #[cfg(cfail1)]\n@@ -122,7 +122,7 @@ pub fn mod_by_zero(val: i32) -> i32 {\n \n \n // shift left ------------------------------------------------------------------\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn shift_left(val: i32, shift: usize) -> i32 {\n     #[cfg(cfail1)]\n@@ -137,7 +137,7 @@ pub fn shift_left(val: i32, shift: usize) -> i32 {\n \n \n // shift right ------------------------------------------------------------------\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirBuilt,MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,mir_built,optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn shift_right(val: i32, shift: usize) -> i32 {\n     #[cfg(cfail1)]"}, {"sha": "3190f65a8173130a50506164231aa1136327d646", "filename": "src/test/incremental/hashes/struct_constructors.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_constructors.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -31,7 +31,7 @@ pub fn change_field_value_regular_struct() -> RegularStruct {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirBuilt\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_field_value_regular_struct() -> RegularStruct {\n     RegularStruct {\n@@ -82,7 +82,7 @@ pub fn add_field_regular_struct() -> RegularStruct {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirBuilt,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_field_regular_struct() -> RegularStruct {\n     let struct1 = RegularStruct {\n@@ -117,7 +117,7 @@ pub fn change_field_label_regular_struct() -> RegularStruct {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirBuilt,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_field_label_regular_struct() -> RegularStruct {\n     let struct1 = RegularStruct {\n@@ -152,7 +152,7 @@ pub fn change_constructor_path_regular_struct() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirBuilt,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_constructor_path_regular_struct() {\n     let _ = RegularStruct2 {\n@@ -173,7 +173,7 @@ pub mod change_constructor_path_indirectly_regular_struct {\n \n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"FnSignature,Hir,HirBody,MirOptimized,MirBuilt,TypeckTables\"\n+        except=\"FnSignature,Hir,HirBody,optimized_mir,mir_built,TypeckTables\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn function() -> Struct {\n@@ -196,7 +196,7 @@ pub fn change_field_value_tuple_struct() -> TupleStruct {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirBuilt\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_field_value_tuple_struct() -> TupleStruct {\n     TupleStruct(0, 1, 3)\n@@ -213,7 +213,7 @@ pub fn change_constructor_path_tuple_struct() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,MirOptimized,MirBuilt,TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody,optimized_mir,mir_built,TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_constructor_path_tuple_struct() {\n     let _ = TupleStruct2(0, 1, 2);\n@@ -230,7 +230,7 @@ pub mod change_constructor_path_indirectly_tuple_struct {\n \n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"FnSignature,Hir,HirBody,MirOptimized,MirBuilt,TypeckTables\"\n+        except=\"FnSignature,Hir,HirBody,optimized_mir,mir_built,TypeckTables\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn function() -> Struct {"}, {"sha": "f3331ec61cb6a4cc6379b4e33614a755bae201a1", "filename": "src/test/incremental/hashes/unary_and_binary_exprs.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Funary_and_binary_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Funary_and_binary_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Funary_and_binary_exprs.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -21,7 +21,7 @@ pub fn const_negation() -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn const_negation() -> i32 {\n     -1\n@@ -36,7 +36,7 @@ pub fn const_bitwise_not() -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn const_bitwise_not() -> i32 {\n     !99\n@@ -51,7 +51,7 @@ pub fn var_negation(x: i32, y: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn var_negation(x: i32, y: i32) -> i32 {\n     -y\n@@ -66,7 +66,7 @@ pub fn var_bitwise_not(x: i32, y: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn var_bitwise_not(x: i32, y: i32) -> i32 {\n     !y\n@@ -81,7 +81,7 @@ pub fn var_deref(x: &i32, y: &i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt,TypeckTables\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built,TypeckTables\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn var_deref(x: &i32, y: &i32) -> i32 {\n     *y\n@@ -96,7 +96,7 @@ pub fn first_const_add() -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn first_const_add() -> i32 {\n     2 + 3\n@@ -111,7 +111,7 @@ pub fn second_const_add() -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn second_const_add() -> i32 {\n     1 + 3\n@@ -126,7 +126,7 @@ pub fn first_var_add(a: i32, b: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn first_var_add(a: i32, b: i32) -> i32 {\n     b + 2\n@@ -141,7 +141,7 @@ pub fn second_var_add(a: i32, b: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn second_var_add(a: i32, b: i32) -> i32 {\n     1 + b\n@@ -156,7 +156,7 @@ pub fn plus_to_minus(a: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn plus_to_minus(a: i32) -> i32 {\n     1 - a\n@@ -171,7 +171,7 @@ pub fn plus_to_mult(a: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn plus_to_mult(a: i32) -> i32 {\n     1 * a\n@@ -186,7 +186,7 @@ pub fn plus_to_div(a: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn plus_to_div(a: i32) -> i32 {\n     1 / a\n@@ -201,7 +201,7 @@ pub fn plus_to_mod(a: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn plus_to_mod(a: i32) -> i32 {\n     1 % a\n@@ -216,7 +216,7 @@ pub fn and_to_or(a: bool, b: bool) -> bool {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn and_to_or(a: bool, b: bool) -> bool {\n     a || b\n@@ -231,7 +231,7 @@ pub fn bitwise_and_to_bitwise_or(a: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn bitwise_and_to_bitwise_or(a: i32) -> i32 {\n     1 | a\n@@ -246,7 +246,7 @@ pub fn bitwise_and_to_bitwise_xor(a: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn bitwise_and_to_bitwise_xor(a: i32) -> i32 {\n     1 ^ a\n@@ -261,7 +261,7 @@ pub fn bitwise_and_to_lshift(a: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn bitwise_and_to_lshift(a: i32) -> i32 {\n     a << 1\n@@ -276,7 +276,7 @@ pub fn bitwise_and_to_rshift(a: i32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn bitwise_and_to_rshift(a: i32) -> i32 {\n     a >> 1\n@@ -291,7 +291,7 @@ pub fn eq_to_uneq(a: i32) -> bool {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn eq_to_uneq(a: i32) -> bool {\n     a != 1\n@@ -306,7 +306,7 @@ pub fn eq_to_lt(a: i32) -> bool {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn eq_to_lt(a: i32) -> bool {\n     a < 1\n@@ -321,7 +321,7 @@ pub fn eq_to_gt(a: i32) -> bool {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn eq_to_gt(a: i32) -> bool {\n     a > 1\n@@ -336,7 +336,7 @@ pub fn eq_to_le(a: i32) -> bool {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn eq_to_le(a: i32) -> bool {\n     a <= 1\n@@ -351,7 +351,7 @@ pub fn eq_to_ge(a: i32) -> bool {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn eq_to_ge(a: i32) -> bool {\n     a >= 1\n@@ -368,7 +368,7 @@ pub fn type_cast(a: u8) -> u64 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt,TypeckTables\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built,TypeckTables\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn type_cast(a: u8) -> u64 {\n     let b = a as u32;\n@@ -385,7 +385,7 @@ pub fn value_cast(a: u32) -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn value_cast(a: u32) -> i32 {\n     2 as i32\n@@ -403,7 +403,7 @@ pub fn place() -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn place() -> i32 {\n     let mut x = 10;\n@@ -423,7 +423,7 @@ pub fn rvalue() -> i32 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn rvalue() -> i32 {\n     let mut x = 10;\n@@ -440,7 +440,7 @@ pub fn index_to_slice(s: &[u8], i: usize, j: usize) -> u8 {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(except=\"HirBody,MirOptimized,MirBuilt\", cfg=\"cfail2\")]\n+#[rustc_clean(except=\"HirBody,optimized_mir,mir_built\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn index_to_slice(s: &[u8], i: usize, j: usize) -> u8 {\n     s[j]"}, {"sha": "7e866ae925ed90cb67adda376472450a7ab11581", "filename": "src/test/incremental/hashes/while_let_loops.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_let_loops.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -25,7 +25,7 @@ pub fn change_loop_body() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_loop_body() {\n     let mut _x = 0;\n@@ -48,7 +48,7 @@ pub fn change_loop_condition() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_loop_condition() {\n     let mut _x = 0;\n@@ -70,7 +70,7 @@ pub fn add_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_break() {\n     let mut _x = 0;\n@@ -141,7 +141,7 @@ pub fn change_break_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_break_label() {\n     let mut _x = 0;\n@@ -191,7 +191,7 @@ pub fn change_continue_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_continue_label() {\n     let mut _x = 0;\n@@ -216,7 +216,7 @@ pub fn change_continue_to_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_continue_to_break() {\n     let mut _x = 0;"}, {"sha": "cbd1341fdd4fb1fc68d9dc9d228da2df600138d0", "filename": "src/test/incremental/hashes/while_loops.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fwhile_loops.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -25,7 +25,7 @@ pub fn change_loop_body() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_loop_body() {\n     let mut _x = 0;\n@@ -48,7 +48,7 @@ pub fn change_loop_condition() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_loop_condition() {\n     let mut _x = 0;\n@@ -70,7 +70,7 @@ pub fn add_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized, TypeckTables\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir, TypeckTables\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_break() {\n     let mut _x = 0;\n@@ -141,7 +141,7 @@ pub fn change_break_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_break_label() {\n     let mut _x = 0;\n@@ -191,7 +191,7 @@ pub fn change_continue_label() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_continue_label() {\n     let mut _x = 0;\n@@ -216,7 +216,7 @@ pub fn change_continue_to_break() {\n }\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, MirBuilt, MirOptimized\")]\n+#[rustc_clean(cfg=\"cfail2\", except=\"HirBody, mir_built, optimized_mir\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_continue_to_break() {\n     let mut _x = 0;"}, {"sha": "2574ef5199c867785e6cb6b5dbcacbf01d27f9b7", "filename": "src/test/incremental/spans_significant_w_panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fspans_significant_w_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fspans_significant_w_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspans_significant_w_panic.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -13,7 +13,7 @@ pub fn main() {\n }\n \n #[cfg(rpass2)]\n-#[rustc_dirty(label=\"MirOptimized\", cfg=\"rpass2\")]\n+#[rustc_dirty(label=\"optimized_mir\", cfg=\"rpass2\")]\n pub fn main() {\n     let _ = 0u8 + 1;\n }"}, {"sha": "db2660bb66129ce8540e9b783ee1ae789842f175", "filename": "src/test/incremental/string_constant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fstring_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fincremental%2Fstring_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstring_constant.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -19,7 +19,7 @@ pub mod x {\n \n     #[cfg(cfail2)]\n     #[rustc_dirty(label=\"HirBody\", cfg=\"cfail2\")]\n-    #[rustc_dirty(label=\"MirOptimized\", cfg=\"cfail2\")]\n+    #[rustc_dirty(label=\"optimized_mir\", cfg=\"cfail2\")]\n     pub fn x() {\n         println!(\"{}\", \"2\");\n     }\n@@ -29,7 +29,7 @@ pub mod y {\n     use x;\n \n     #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"MirOptimized\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"optimized_mir\", cfg=\"cfail2\")]\n     pub fn y() {\n         x::x();\n     }\n@@ -39,7 +39,7 @@ pub mod z {\n     use y;\n \n     #[rustc_clean(label=\"TypeckTables\", cfg=\"cfail2\")]\n-    #[rustc_clean(label=\"MirOptimized\", cfg=\"cfail2\")]\n+    #[rustc_clean(label=\"optimized_mir\", cfg=\"cfail2\")]\n     pub fn z() {\n         y::y();\n     }"}, {"sha": "b009ff9486be2bc17918e0924204f5fb864d646d", "filename": "src/test/ui/deprecation/atomic_initializers.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fdeprecation%2Fatomic_initializers.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fdeprecation%2Fatomic_initializers.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fatomic_initializers.stderr?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -2,11 +2,7 @@ warning: use of deprecated item 'std::sync::atomic::ATOMIC_ISIZE_INIT': the `new\n   --> $DIR/atomic_initializers.rs:8:27\n    |\n LL | static FOO: AtomicIsize = ATOMIC_ISIZE_INIT;\n-   |                           ^^^^^^^^^^^^^^^^^\n+   |                           ^^^^^^^^^^^^^^^^^ help: replace the use of the deprecated item: `AtomicIsize::new(0)`\n    |\n    = note: #[warn(deprecated)] on by default\n-help: use of deprecated item 'std::sync::atomic::ATOMIC_ISIZE_INIT': the `new` function is now preferred\n-   |\n-LL | static FOO: AtomicIsize = AtomicIsize::new(0);\n-   |                           ^^^^^^^^^^^^^^^^^^^\n "}, {"sha": "eba72f88a89115cefd1c018221477a124d41d7f4", "filename": "src/test/ui/deprecation/suggestion.fixed", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fdeprecation%2Fsuggestion.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fdeprecation%2Fsuggestion.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fsuggestion.fixed?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -0,0 +1,28 @@\n+// run-rustfix\n+\n+#![feature(staged_api)]\n+\n+#![stable(since = \"1.0.0\", feature = \"test\")]\n+\n+#![deny(deprecated)]\n+#![allow(dead_code)]\n+\n+struct Foo;\n+\n+impl Foo {\n+    #[rustc_deprecated(\n+        since = \"1.0.0\",\n+        reason = \"replaced by `replacement`\",\n+        suggestion = \"replacement\",\n+    )]\n+    #[stable(since = \"1.0.0\", feature = \"test\")]\n+    fn deprecated(&self) {}\n+\n+    fn replacement(&self) {}\n+}\n+\n+fn main() {\n+    let foo = Foo;\n+\n+    foo.replacement(); //~ ERROR use of deprecated\n+}"}, {"sha": "8f9791c13e8563651988f115e89a17c5fdc3ff16", "filename": "src/test/ui/deprecation/suggestion.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fdeprecation%2Fsuggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fdeprecation%2Fsuggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fsuggestion.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -0,0 +1,28 @@\n+// run-rustfix\n+\n+#![feature(staged_api)]\n+\n+#![stable(since = \"1.0.0\", feature = \"test\")]\n+\n+#![deny(deprecated)]\n+#![allow(dead_code)]\n+\n+struct Foo;\n+\n+impl Foo {\n+    #[rustc_deprecated(\n+        since = \"1.0.0\",\n+        reason = \"replaced by `replacement`\",\n+        suggestion = \"replacement\",\n+    )]\n+    #[stable(since = \"1.0.0\", feature = \"test\")]\n+    fn deprecated(&self) {}\n+\n+    fn replacement(&self) {}\n+}\n+\n+fn main() {\n+    let foo = Foo;\n+\n+    foo.deprecated(); //~ ERROR use of deprecated\n+}"}, {"sha": "6aaabfe957517472bd7d90a6ebffbafe6bc44985", "filename": "src/test/ui/deprecation/suggestion.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fdeprecation%2Fsuggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fdeprecation%2Fsuggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fsuggestion.stderr?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -0,0 +1,14 @@\n+error: use of deprecated item 'Foo::deprecated': replaced by `replacement`\n+  --> $DIR/suggestion.rs:27:9\n+   |\n+LL |     foo.deprecated();\n+   |         ^^^^^^^^^^ help: replace the use of the deprecated item: `replacement`\n+   |\n+note: lint level defined here\n+  --> $DIR/suggestion.rs:7:9\n+   |\n+LL | #![deny(deprecated)]\n+   |         ^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "b0ef4e1b25413c315c8de5df707a3ded89ec11ec", "filename": "src/test/ui/error-codes/E0423.stderr", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Ferror-codes%2FE0423.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Ferror-codes%2FE0423.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0423.stderr?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -3,6 +3,14 @@ error: expected type, found `1`\n    |\n LL |     if let S { x: _x, y: 2 } = S { x: 1, y: 2 } { println!(\"Ok\"); }\n    |                                       ^ expecting a type here because of type ascription\n+   |\n+   = note: type ascription is a nightly-only feature that lets you annotate an expression with a type: `<expr>: <type>`\n+note: this expression expects an ascribed type after the colon\n+  --> $DIR/E0423.rs:12:36\n+   |\n+LL |     if let S { x: _x, y: 2 } = S { x: 1, y: 2 } { println!(\"Ok\"); }\n+   |                                    ^\n+   = help: this might be indicative of a syntax error elsewhere\n \n error: expected expression, found `==`\n   --> $DIR/E0423.rs:15:13\n@@ -15,6 +23,14 @@ error: expected type, found `0`\n    |\n LL |     for _ in std::ops::Range { start: 0, end: 10 } {}\n    |                                       ^ expecting a type here because of type ascription\n+   |\n+   = note: type ascription is a nightly-only feature that lets you annotate an expression with a type: `<expr>: <type>`\n+note: this expression expects an ascribed type after the colon\n+  --> $DIR/E0423.rs:21:32\n+   |\n+LL |     for _ in std::ops::Range { start: 0, end: 10 } {}\n+   |                                ^^^^^\n+   = help: this might be indicative of a syntax error elsewhere\n \n error[E0423]: expected function, found struct `Foo`\n   --> $DIR/E0423.rs:4:13"}, {"sha": "a28ea0d09f8f0fca7452fabb99118a15dc7155b0", "filename": "src/test/ui/issues/issue-22644.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fissues%2Fissue-22644.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fissues%2Fissue-22644.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22644.stderr?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -88,6 +88,14 @@ error: expected type, found `4`\n    |\n LL |     println!(\"{}\", a: &mut 4);\n    |                            ^ expecting a type here because of type ascription\n+   |\n+   = note: type ascription is a nightly-only feature that lets you annotate an expression with a type: `<expr>: <type>`\n+note: this expression expects an ascribed type after the colon\n+  --> $DIR/issue-22644.rs:34:20\n+   |\n+LL |     println!(\"{}\", a: &mut 4);\n+   |                    ^\n+   = help: this might be indicative of a syntax error elsewhere\n \n error: aborting due to 9 previous errors\n "}, {"sha": "b1071934bb2f3cea0aeb98e1833e4412da85f23e", "filename": "src/test/ui/issues/issue-34255-1.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fissues%2Fissue-34255-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fissues%2Fissue-34255-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34255-1.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -0,0 +1,10 @@\n+enum Test {\n+    Drill {\n+        field: i32,\n+    }\n+}\n+\n+fn main() {\n+    Test::Drill(field: 42);\n+    //~^ ERROR expected type, found\n+}"}, {"sha": "7899c8d30f1ddca60eea74c71ded0ba3b83918c1", "filename": "src/test/ui/issues/issue-34255-1.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fissues%2Fissue-34255-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fissues%2Fissue-34255-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34255-1.stderr?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -0,0 +1,16 @@\n+error: expected type, found `42`\n+  --> $DIR/issue-34255-1.rs:8:24\n+   |\n+LL |     Test::Drill(field: 42);\n+   |                        ^^ expecting a type here because of type ascription\n+   |\n+   = note: type ascription is a nightly-only feature that lets you annotate an expression with a type: `<expr>: <type>`\n+note: this expression expects an ascribed type after the colon\n+  --> $DIR/issue-34255-1.rs:8:17\n+   |\n+LL |     Test::Drill(field: 42);\n+   |                 ^^^^^\n+   = help: this might be indicative of a syntax error elsewhere\n+\n+error: aborting due to previous error\n+"}, {"sha": "cb5a52a3e081a75668a83902803fca0418b88ddb", "filename": "src/test/ui/lifetime_starts_expressions.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Flifetime_starts_expressions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Flifetime_starts_expressions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime_starts_expressions.stderr?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -13,6 +13,14 @@ error: expected type, found keyword `loop`\n    |\n LL |     loop { break 'label: loop { break 'label 42; }; }\n    |                          ^^^^ expecting a type here because of type ascription\n+   |\n+   = note: type ascription is a nightly-only feature that lets you annotate an expression with a type: `<expr>: <type>`\n+note: this expression expects an ascribed type after the colon\n+  --> $DIR/lifetime_starts_expressions.rs:6:12\n+   |\n+LL |     loop { break 'label: loop { break 'label 42; }; }\n+   |            ^^^^^^^^^^^^\n+   = help: this might be indicative of a syntax error elsewhere\n \n error: aborting due to 2 previous errors\n "}, {"sha": "07f2e41ac4fb036e5ffc546feac71947a2ca4191", "filename": "src/test/ui/parser/struct-literal-in-for.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-for.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-for.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-for.stderr?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -3,6 +3,14 @@ error: expected type, found `3`\n    |\n LL |         x: 3\n    |            ^ expecting a type here because of type ascription\n+   |\n+   = note: type ascription is a nightly-only feature that lets you annotate an expression with a type: `<expr>: <type>`\n+note: this expression expects an ascribed type after the colon\n+  --> $DIR/struct-literal-in-for.rs:13:9\n+   |\n+LL |         x: 3\n+   |         ^\n+   = help: this might be indicative of a syntax error elsewhere\n \n error: expected one of `.`, `;`, `?`, `}`, or an operator, found `{`\n   --> $DIR/struct-literal-in-for.rs:14:12"}, {"sha": "3dd61e74f12eda67e9808948cc727bda1b915b25", "filename": "src/test/ui/parser/struct-literal-in-if.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-if.stderr?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -3,6 +3,14 @@ error: expected type, found `3`\n    |\n LL |         x: 3\n    |            ^ expecting a type here because of type ascription\n+   |\n+   = note: type ascription is a nightly-only feature that lets you annotate an expression with a type: `<expr>: <type>`\n+note: this expression expects an ascribed type after the colon\n+  --> $DIR/struct-literal-in-if.rs:13:9\n+   |\n+LL |         x: 3\n+   |         ^\n+   = help: this might be indicative of a syntax error elsewhere\n \n error: expected one of `.`, `;`, `?`, `}`, or an operator, found `{`\n   --> $DIR/struct-literal-in-if.rs:14:12"}, {"sha": "d48244654cd023dd43250ecc39e446d45132d8da", "filename": "src/test/ui/parser/struct-literal-in-while.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-while.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-while.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-in-while.stderr?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -3,6 +3,14 @@ error: expected type, found `3`\n    |\n LL |         x: 3\n    |            ^ expecting a type here because of type ascription\n+   |\n+   = note: type ascription is a nightly-only feature that lets you annotate an expression with a type: `<expr>: <type>`\n+note: this expression expects an ascribed type after the colon\n+  --> $DIR/struct-literal-in-while.rs:13:9\n+   |\n+LL |         x: 3\n+   |         ^\n+   = help: this might be indicative of a syntax error elsewhere\n \n error: expected one of `.`, `;`, `?`, `}`, or an operator, found `{`\n   --> $DIR/struct-literal-in-while.rs:14:12"}, {"sha": "a8c93233dbc535408b4e55e670dcc5aa52cdb19d", "filename": "src/test/ui/parser/struct-literal-restrictions-in-lamda.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-restrictions-in-lamda.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-restrictions-in-lamda.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-literal-restrictions-in-lamda.stderr?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -3,6 +3,14 @@ error: expected type, found `3`\n    |\n LL |         x: 3\n    |            ^ expecting a type here because of type ascription\n+   |\n+   = note: type ascription is a nightly-only feature that lets you annotate an expression with a type: `<expr>: <type>`\n+note: this expression expects an ascribed type after the colon\n+  --> $DIR/struct-literal-restrictions-in-lamda.rs:13:9\n+   |\n+LL |         x: 3\n+   |         ^\n+   = help: this might be indicative of a syntax error elsewhere\n \n error: expected one of `.`, `;`, `?`, `}`, or an operator, found `{`\n   --> $DIR/struct-literal-restrictions-in-lamda.rs:14:12"}, {"sha": "e076419f68d47b9449960cdc01f2da6e7460324b", "filename": "src/test/ui/resolve/issue-22692.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fresolve%2Fissue-22692.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fresolve%2Fissue-22692.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-22692.stderr?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -4,7 +4,7 @@ error[E0423]: expected value, found struct `String`\n LL |     let _ = String.new();\n    |             ^^^^^^----\n    |             |\n-   |             help: use `::` to access an associated function: `String::new`\n+   |             help: use the path separator to refer to an item: `String::new`\n \n error: aborting due to previous error\n "}, {"sha": "678b58936a8d6922cf109ac0b2f6d82b33af0e3d", "filename": "src/test/ui/suggestions/assoc-const-as-field.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-const-as-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-const-as-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-const-as-field.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -0,0 +1,13 @@\n+pub mod Mod {\n+    pub struct Foo {}\n+    impl Foo {\n+        pub const BAR: usize = 42;\n+    }\n+}\n+\n+fn foo(_: usize) {}\n+\n+fn main() {\n+    foo(Mod::Foo.Bar);\n+    //~^ ERROR expected value, found\n+}"}, {"sha": "5e746ecb2f28fca8c2bf9e817eb3700dbaa34253", "filename": "src/test/ui/suggestions/assoc-const-as-field.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-const-as-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-const-as-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-const-as-field.stderr?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -0,0 +1,11 @@\n+error[E0423]: expected value, found struct `Mod::Foo`\n+  --> $DIR/assoc-const-as-field.rs:11:9\n+   |\n+LL |     foo(Mod::Foo.Bar);\n+   |         ^^^^^^^^----\n+   |         |\n+   |         help: use the path separator to refer to an item: `Mod::Foo::Bar`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0423`."}, {"sha": "0e1c307502728c7c8bedf38e64887a2e894be3d2", "filename": "src/test/ui/suggestions/type-ascription-instead-of-let.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -0,0 +1,10 @@\n+fn fun(x: i32) -> i32 { x }\n+\n+fn main() {\n+    let closure_annotated = |value: i32| -> i32 {\n+        temp: i32 = fun(5i32);\n+        //~^ ERROR cannot find value `temp` in this scope\n+        temp + value + 1\n+        //~^ ERROR cannot find value `temp` in this scope\n+    };\n+}"}, {"sha": "92e4b5798c88944db86f6afeb97669b913b3ca14", "filename": "src/test/ui/suggestions/type-ascription-instead-of-let.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-let.stderr?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -0,0 +1,18 @@\n+error[E0425]: cannot find value `temp` in this scope\n+  --> $DIR/type-ascription-instead-of-let.rs:5:9\n+   |\n+LL |         temp: i32 = fun(5i32);\n+   |         ^^^^\n+   |         |\n+   |         not found in this scope\n+   |         help: maybe you meant to write an assignment here: `let temp`\n+\n+error[E0425]: cannot find value `temp` in this scope\n+  --> $DIR/type-ascription-instead-of-let.rs:7:9\n+   |\n+LL |         temp + value + 1\n+   |         ^^^^ not found in this scope\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "361729d50c2f393fd386bdc8d4d966bba5c95379", "filename": "src/test/ui/suggestions/type-ascription-instead-of-method.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    Box:new(\"foo\".to_string())\n+    //~^ ERROR expected type, found\n+}"}, {"sha": "15ec087b1cc01d790083c55d356776c1fe2e037f", "filename": "src/test/ui/suggestions/type-ascription-instead-of-method.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-method.stderr?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -0,0 +1,10 @@\n+error: expected type, found `\"foo\"`\n+  --> $DIR/type-ascription-instead-of-method.rs:2:13\n+   |\n+LL |     Box:new(\"foo\".to_string())\n+   |        -    ^^^^^ expecting a type here because of type ascription\n+   |        |\n+   |        help: maybe you meant to write a path separator here: `::`\n+\n+error: aborting due to previous error\n+"}, {"sha": "4c0fe6d8b5b4e29a3c65d4c882d31a049fb41be4", "filename": "src/test/ui/suggestions/type-ascription-instead-of-path.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    std:io::stdin();\n+    //~^ ERROR failed to resolve: use of undeclared type or module `io`\n+    //~| ERROR expected value, found module\n+}"}, {"sha": "1beb822d6a74946ec91823e537001384718bdef4", "filename": "src/test/ui/suggestions/type-ascription-instead-of-path.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-path.stderr?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -0,0 +1,18 @@\n+error[E0433]: failed to resolve: use of undeclared type or module `io`\n+  --> $DIR/type-ascription-instead-of-path.rs:2:9\n+   |\n+LL |     std:io::stdin();\n+   |         ^^ use of undeclared type or module `io`\n+\n+error[E0423]: expected value, found module `std`\n+  --> $DIR/type-ascription-instead-of-path.rs:2:5\n+   |\n+LL |     std:io::stdin();\n+   |     ^^^- help: maybe you meant to write a path separator here: `::`\n+   |     |\n+   |     not a value\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors occurred: E0423, E0433.\n+For more information about an error, try `rustc --explain E0423`."}, {"sha": "b90867fef6b51d4fa365e31870956d4c402a6b33", "filename": "src/test/ui/suggestions/type-ascription-instead-of-variant.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let _ = Option:Some(\"\");\n+    //~^ ERROR expected type, found\n+}"}, {"sha": "5719a667a841509b4f16a3425f5d45930b019649", "filename": "src/test/ui/suggestions/type-ascription-instead-of-variant.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-instead-of-variant.stderr?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -0,0 +1,10 @@\n+error: expected type, found `\"\"`\n+  --> $DIR/type-ascription-instead-of-variant.rs:2:25\n+   |\n+LL |     let _ = Option:Some(\"\");\n+   |                   -     ^^ expecting a type here because of type ascription\n+   |                   |\n+   |                   help: maybe you meant to write a path separator here: `::`\n+\n+error: aborting due to previous error\n+"}, {"sha": "2084cbcce4f6253ddd17027f2864c8b7498c288c", "filename": "src/test/ui/type/type-ascription-instead-of-statement-end.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Ftype%2Ftype-ascription-instead-of-statement-end.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftest%2Fui%2Ftype%2Ftype-ascription-instead-of-statement-end.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-ascription-instead-of-statement-end.stderr?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -11,6 +11,14 @@ error: expected type, found `0`\n    |\n LL |     println!(\"test\"): 0;\n    |                       ^ expecting a type here because of type ascription\n+   |\n+   = note: type ascription is a nightly-only feature that lets you annotate an expression with a type: `<expr>: <type>`\n+note: this expression expects an ascribed type after the colon\n+  --> $DIR/type-ascription-instead-of-statement-end.rs:9:5\n+   |\n+LL |     println!(\"test\"): 0;\n+   |     ^^^^^^^^^^^^^^^^\n+   = help: this might be indicative of a syntax error elsewhere\n \n error: aborting due to 2 previous errors\n "}, {"sha": "30fe327cac4ff59d0abc4dfd5c2f082d62804f62", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd34efb32b9efb574899e4335bdc8c6525ac27e/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=fbd34efb32b9efb574899e4335bdc8c6525ac27e", "patch": "@@ -87,6 +87,7 @@ const WHITELIST: &[Crate<'_>] = &[\n     Crate(\"fuchsia-zircon-sys\"),\n     Crate(\"getopts\"),\n     Crate(\"humantime\"),\n+    Crate(\"itertools\"),\n     Crate(\"jobserver\"),\n     Crate(\"kernel32-sys\"),\n     Crate(\"lazy_static\"),"}]}