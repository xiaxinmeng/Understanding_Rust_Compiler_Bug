{"sha": "67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3Y2M4OWYzOGQyZTc1Y2IwZGNkNjMwM2ZiZTRiYjRmNjU5Mjc3YTc=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-15T08:40:42Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-15T14:47:42Z"}, "message": "Rewrite exhaustiveness checker\n\nIssue #352\nCloses #1720\n\nThe old checker would happily accept things like 'alt x { @some(a) { a } }'.\nIt now properly descends into patterns, checks exhaustiveness of booleans,\nand complains when number/string patterns aren't exhaustive.", "tree": {"sha": "99caacd6c05c72beb28e73a9aa759b5db1d88114", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99caacd6c05c72beb28e73a9aa759b5db1d88114"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "html_url": "https://github.com/rust-lang/rust/commit/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc", "html_url": "https://github.com/rust-lang/rust/commit/4b63826050dfc579b9ac65a6b72ad0ca6f6b51fc"}], "stats": {"total": 316, "additions": 192, "deletions": 124}, "files": [{"sha": "867497f37fdabb2eabbe36142ff7a5dc044ba498", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -218,7 +218,7 @@ fn lookup_def(cnum: ast::crate_num, data: @[u8], did_: ast::def_id) ->\n     let fam_ch = item_family(item);\n     let did = {crate: cnum, node: did_.node};\n     // We treat references to enums as references to types.\n-    alt fam_ch {\n+    alt check fam_ch {\n       'c' { ast::def_const(did) }\n       'u' { ast::def_fn(did, ast::unsafe_fn) }\n       'f' { ast::def_fn(did, ast::impure_fn) }\n@@ -336,7 +336,7 @@ fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n           _ { tcx.sess.bug(\"get_iface_methods: id has non-function type\");\n         } };\n         result += [{ident: name, tps: bounds, fty: fty,\n-                    purity: alt item_family(mth) {\n+                    purity: alt check item_family(mth) {\n                       'u' { ast::unsafe_fn }\n                       'f' { ast::impure_fn }\n                       'p' { ast::pure_fn }\n@@ -346,7 +346,7 @@ fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n }\n \n fn family_has_type_params(fam_ch: char) -> bool {\n-    alt fam_ch {\n+    alt check fam_ch {\n       'c' | 'T' | 'm' | 'n' { false }\n       'f' | 'u' | 'p' | 'F' | 'U' | 'P' | 'y' | 't' | 'v' | 'i' | 'I' { true }\n     }\n@@ -370,7 +370,7 @@ fn describe_def(items: ebml::doc, id: ast::def_id) -> str {\n }\n \n fn item_family_to_str(fam: char) -> str {\n-    alt fam {\n+    alt check fam {\n       'c' { ret \"const\"; }\n       'f' { ret \"fn\"; }\n       'u' { ret \"unsafe fn\"; }"}, {"sha": "c7d434b3c1cf445df93877a4926514b19d1cf717", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -177,15 +177,15 @@ fn parse_proto(c: char) -> ast::proto {\n }\n \n fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n-    alt next(st) {\n+    alt check next(st) {\n       'n' { ret ty::mk_nil(st.tcx); }\n       'z' { ret ty::mk_bot(st.tcx); }\n       'b' { ret ty::mk_bool(st.tcx); }\n       'i' { ret ty::mk_int(st.tcx); }\n       'u' { ret ty::mk_uint(st.tcx); }\n       'l' { ret ty::mk_float(st.tcx); }\n       'M' {\n-        alt next(st) {\n+        alt check next(st) {\n           'b' { ret ty::mk_mach_uint(st.tcx, ast::ty_u8); }\n           'w' { ret ty::mk_mach_uint(st.tcx, ast::ty_u16); }\n           'l' { ret ty::mk_mach_uint(st.tcx, ast::ty_u32); }\n@@ -269,7 +269,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n       'Y' { ret ty::mk_type(st.tcx); }\n       'y' { ret ty::mk_send_type(st.tcx); }\n       'C' {\n-        let ck = alt next(st) {\n+        let ck = alt check next(st) {\n           '&' { ty::ck_block }\n           '@' { ty::ck_box }\n           '~' { ty::ck_uniq }\n@@ -355,7 +355,7 @@ fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::fn_ty {\n     assert (next(st) == '[');\n     let inputs: [ty::arg] = [];\n     while peek(st) != ']' {\n-        let mode = alt peek(st) {\n+        let mode = alt check peek(st) {\n           '&' { ast::by_mut_ref }\n           '-' { ast::by_move }\n           '+' { ast::by_copy }\n@@ -405,7 +405,7 @@ fn parse_bounds_data(data: @[u8], start: uint,\n fn parse_bounds(st: @pstate, conv: conv_did) -> @[ty::param_bound] {\n     let bounds = [];\n     while true {\n-        bounds += [alt next(st) {\n+        bounds += [alt check next(st) {\n           'S' { ty::bound_send }\n           'C' { ty::bound_copy }\n           'I' { ty::bound_iface(parse_ty(st, conv)) }"}, {"sha": "e1bf34ce5e47d77b7ee2d2ffcbe5b9a822deb963", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 118, "deletions": 71, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -27,7 +27,7 @@ fn check_expr(tcx: ty::ctxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n         /* Check for exhaustiveness */\n         if mode == alt_exhaustive {\n             let arms = vec::concat(vec::filter_map(arms, unguarded_pat));\n-            check_exhaustive(tcx, ex.span, expr_ty(tcx, scrut), arms);\n+            check_exhaustive(tcx, ex.span, arms);\n         }\n       }\n       _ { }\n@@ -59,89 +59,136 @@ fn check_arms(tcx: ty::ctxt, arms: [arm]) {\n     }\n }\n \n+fn raw_pat(p: @pat) -> @pat {\n+    alt p.node {\n+      pat_ident(_, some(s)) { raw_pat(s) }\n+      _ { p }\n+    }\n+}\n+\n // Precondition: patterns have been normalized\n // (not checked statically yet)\n-fn check_exhaustive(tcx: ty::ctxt, sp:span, scrut_ty:ty::t, pats:[@pat]) {\n-    let represented : [def_id] = [];\n-    /* Determine the type of the scrutinee */\n-    /* If it's not an enum, exit (bailing out on checking non-enum alts\n-       for now) */\n-    /* Otherwise, get the list of variants and make sure each one is\n-     represented. Then recurse on the columns. */\n-\n-    let ty_def_id = alt ty::get(scrut_ty).struct {\n-            ty_enum(id, _) { id }\n-            _ { ret; } };\n+fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: [@pat]) {\n+    if pats.len() == 0u {\n+        tcx.sess.span_err(sp, \"non-exhaustive patterns\");\n+        ret;\n+    }\n+    // If there a non-refutable pattern in the set, we're okay.\n+    for pat in pats { if !is_refutable(tcx, pat) { ret; } }\n \n-    let variants = *enum_variants(tcx, ty_def_id);\n-    for pat in pats {\n-        if !is_refutable(tcx, pat) {\n-                /* automatically makes this alt complete */ ret;\n+    alt ty::get(ty::node_id_to_type(tcx, pats[0].id)).struct {\n+      ty::ty_enum(id, _) {\n+        check_exhaustive_enum(tcx, id, sp, pats);\n+      }\n+      ty::ty_box(_) {\n+        check_exhaustive(tcx, sp, vec::filter_map(pats, {|p|\n+            alt raw_pat(p).node { pat_box(sub) { some(sub) } _ { none } }\n+        }));\n+      }\n+      ty::ty_uniq(_) {\n+        check_exhaustive(tcx, sp, vec::filter_map(pats, {|p|\n+            alt raw_pat(p).node { pat_uniq(sub) { some(sub) } _ { none } }\n+        }));\n+      }\n+      ty::ty_tup(ts) {\n+        let cols = vec::init_elt_mut(ts.len(), []);\n+        for p in pats {\n+            alt raw_pat(p).node {\n+              pat_tup(sub) {\n+                vec::iteri(sub) {|i, sp| cols[i] += [sp];}\n+              }\n+              _ {}\n+            }\n         }\n-        alt pat.node {\n-                // want the def_id for the constructor\n-            pat_enum(id,_) {\n-                alt tcx.def_map.find(pat.id) {\n-                    some(def_variant(_, variant_def_id)) {\n-                        represented += [variant_def_id];\n+        vec::iter(cols) {|col| check_exhaustive(tcx, sp, col); }\n+      }\n+      ty::ty_rec(fs) {\n+        let cols = vec::init_elt(fs.len(), {mutable wild: false,\n+                                            mutable pats: []});\n+        for p in pats {\n+            alt raw_pat(p).node {\n+              pat_rec(sub, _) {\n+                vec::iteri(fs) {|i, field|\n+                    alt vec::find(sub, {|pf| pf.ident == field.ident }) {\n+                      some(pf) { cols[i].pats += [pf.pat]; }\n+                      none { cols[i].wild = true; }\n                     }\n-                    _ { tcx.sess.span_bug(pat.span, \"check_exhaustive:\n-                          pat_tag not bound to a variant\"); }\n                 }\n+              }\n+              _ {}\n+            }\n+        }\n+        vec::iter(cols) {|col|\n+            if !col.wild { check_exhaustive(tcx, sp, copy col.pats); }\n+        }\n+      }\n+      ty::ty_bool {\n+        let saw_true = false, saw_false = false;\n+        for p in pats {\n+            alt raw_pat(p).node {\n+              pat_lit(@{node: expr_lit(@{node: lit_bool(b), _}), _}) {\n+                if b { saw_true = true; }\n+                else { saw_false = true; }\n+              }\n+              _ {}\n             }\n-            _ { tcx.sess.span_bug(pat.span, \"check_exhaustive: ill-typed \\\n-                  pattern\");   // we know this has enum type,\n-            }                  // so anything else should be impossible\n-         }\n-    }\n-    fn not_represented(v: [def_id], &&vinfo: variant_info) -> bool {\n-        !vec::contains(v, vinfo.id)\n-    }\n-    // Could be more efficient (bitvectors?)\n-    alt vec::find(variants, bind not_represented(represented,_)) {\n-        some(bad) {\n-        // complain\n-        // TODO: give examples of cases that aren't covered\n-            tcx.sess.note(\"Patterns not covered include:\");\n-            tcx.sess.note(bad.name);\n-            tcx.sess.span_err(sp, \"Non-exhaustive pattern\");\n         }\n-        _ {}\n+        if !saw_true { tcx.sess.span_err(\n+            sp, \"non-exhaustive bool patterns: true not covered\"); }\n+        if !saw_false { tcx.sess.span_err(\n+            sp, \"non-exhaustive bool patterns: false not covered\"); }\n+      }\n+      ty::ty_nil {\n+        let seen = vec::any(pats, {|p|\n+            alt raw_pat(p).node {\n+              pat_lit(@{node: expr_lit(@{node: lit_nil, _}), _}) { true }\n+              _ { false }\n+            }\n+        });\n+        if !seen { tcx.sess.span_err(sp, \"non-exhaustive patterns\"); }\n+      }\n+      // Literal patterns are always considered non-exhaustive\n+      _ {\n+        tcx.sess.span_err(sp, \"non-exhaustive literal patterns\");\n+      }\n     }\n-    // Otherwise, check subpatterns\n-    // inefficient\n-    for variant in variants {\n-        // rows consists of the argument list for each pat that's an enum\n-        let rows : [[@pat]] = [];\n-        for pat in pats {\n+}\n+\n+fn check_exhaustive_enum(tcx: ty::ctxt, enum_id: def_id, sp: span,\n+                         pats: [@pat]) {\n+    let variants = enum_variants(tcx, enum_id);\n+    let columns_by_variant = vec::map(*variants, {|v|\n+        {mutable seen: false,\n+         cols: vec::init_elt_mut(v.args.len(), [])}\n+    });\n+\n+    for pat in pats {\n+        let pat = raw_pat(pat);\n+        alt tcx.def_map.get(pat.id) {\n+          def_variant(_, id) {\n+            let variant_idx =\n+                option::get(vec::position(*variants, {|v| v.id == id}));\n+            columns_by_variant[variant_idx].seen = true;\n             alt pat.node {\n-               pat_enum(id, args) {\n-                  alt tcx.def_map.find(pat.id) {\n-                      some(def_variant(_,variant_id))\n-                        if variant_id == variant.id { rows += [args]; }\n-                      _ { }\n-                  }\n-               }\n-               _ {}\n+              pat_enum(_, args) {\n+                vec::iteri(args) {|i, p|\n+                    columns_by_variant[variant_idx].cols[i] += [p];\n+                }\n+              }\n+              _ {}\n             }\n+          }\n+          _ {}\n         }\n-        if check vec::is_not_empty(rows) {\n-             let i = 0u;\n-             for it in rows[0] {\n-                let column = [it];\n-                // Annoying -- see comment in\n-                // tstate::states::find_pre_post_state_loop\n-                check vec::is_not_empty(rows);\n-                for row in vec::tail(rows) {\n-                  column += [row[i]];\n-                }\n-                check_exhaustive(tcx, sp, pat_ty(tcx, it), column);\n-                i += 1u;\n-             }\n+    }\n+\n+    vec::iteri(columns_by_variant) {|i, cv|\n+        if !cv.seen {\n+            tcx.sess.span_err(sp, \"non-exhaustive patterns: variant `\" +\n+                              variants[i].name + \"` not covered\");\n+        } else {\n+            vec::iter(cv.cols) {|col| check_exhaustive(tcx, sp, col); }\n         }\n-        // This shouldn't actually happen, since there were no\n-        // irrefutable patterns if we got here.\n-        else { cont; }\n     }\n }\n "}, {"sha": "f46a50ea4a1914c1f2591bf1acbc22303327a326", "filename": "src/comp/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Fcomp%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Fcomp%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flint.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -40,7 +40,7 @@ fn time(do_it: bool, what: str, thunk: fn()) {\n fn merge_opts(attrs: [ast::attribute], cmd_opts: [(option, bool)]) ->\n     [(option, bool)] {\n     fn str_to_option(name: str) -> (option, bool) {\n-        ret alt name {\n+        ret alt check name {\n           \"ctypes\" { (ctypes, true) }\n           \"no_ctypes\" { (ctypes, false) }\n         }"}, {"sha": "23cea66e8db39d39e23213dc78d8bc70e6ba2e4c", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -1023,7 +1023,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n       }\n       ast::expr_be(result) { word_nbsp(s, \"be\"); print_expr(s, result); }\n       ast::expr_log(lvl, lexp, expr) {\n-        alt lvl {\n+        alt check lvl {\n           1 { word_nbsp(s, \"log\"); print_expr(s, expr); }\n           0 { word_nbsp(s, \"log_err\"); print_expr(s, expr); }\n           2 {"}, {"sha": "b856b092e7a7e39823fc14039f167a0d7d96f835", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -68,7 +68,7 @@ fn run(lib_path: str, prog: str, args: [str],\n     let count = 2;\n     while count > 0 {\n         let stream = comm::recv(p);\n-        alt stream {\n+        alt check stream {\n             (1, s) {\n                 outs = s;\n             }"}, {"sha": "cc4efe54dfc2cdbcb240118281fb06ce6dbb56c0", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -60,9 +60,10 @@ pure fn is_false(v: t) -> bool { !v }\n   brief = \"Parse logic value from `s`\"\n )]\n pure fn from_str(s: str) -> t {\n-    alt s {\n+    alt check s {\n       \"true\" { true }\n       \"false\" { false }\n+      _ { fail \"'\" + s + \"' is not a valid boolean string\"; }\n     }\n }\n "}, {"sha": "f79594a3023e03a0016a8ea054531b28f493b2e0", "filename": "src/libcore/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -2140,7 +2140,7 @@ mod tests {\n     fn test_chars_iter() {\n         let i = 0;\n         chars_iter(\"x\\u03c0y\") {|ch|\n-            alt i {\n+            alt check i {\n               0 { assert ch == 'x'; }\n               1 { assert ch == '\\u03c0'; }\n               2 { assert ch == 'y'; }\n@@ -2156,7 +2156,7 @@ mod tests {\n         let i = 0;\n \n         bytes_iter(\"xyz\") {|bb|\n-            alt i {\n+            alt check i {\n               0 { assert bb == 'x' as u8; }\n               1 { assert bb == 'y' as u8; }\n               2 { assert bb == 'z' as u8; }"}, {"sha": "e1804be2b9190757814c2ed95ac9af6dcac612aa", "filename": "src/libstd/four.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Flibstd%2Ffour.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Flibstd%2Ffour.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffour.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -166,7 +166,7 @@ Function: from_str\n Parse logic value from `s`\n */\n pure fn from_str(s: str) -> t {\n-    alt s {\n+    alt check s {\n       \"none\" { none }\n       \"false\" { four::false }\n       \"true\" { four::true }\n@@ -181,7 +181,7 @@ Convert `v` into a string\n */\n pure fn to_str(v: t) -> str {\n     // FIXME replace with consts as soon as that works\n-    alt v {\n+    alt check v {\n       0u8 { \"none\" }\n       1u8 { \"true\" }\n       2u8 { \"false\" }\n@@ -265,7 +265,7 @@ mod tests {\n     }\n \n     fn to_tup(v: four::t) -> (bool, bool) {\n-        alt v {\n+        alt check v {\n           0u8 { (false, false) }\n           1u8 { (false, true) }\n           2u8 { (true, false) }"}, {"sha": "1cc8cb529d8228b544084e29c0c4217ec4faf70d", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -241,7 +241,7 @@ fn test_option_int() {\n     fn deserialize_0<S: deserializer>(s: S) -> option<int> {\n         s.read_enum(\"option\") {||\n             s.read_enum_variant {|i|\n-                alt i {\n+                alt check i {\n                   0u { none }\n                   1u {\n                     let v0 = s.read_enum_variant_arg(0u) {||"}, {"sha": "1647ea8f97769d7f3346becd14d2ff582fb91888", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -52,8 +52,12 @@ fn insert<K: copy, V: copy>(m: treemap<K, V>, k: K, v: V) {\n         // We have to name left and right individually, because\n         // otherwise the alias checker complains.\n         if k < kk {\n-            alt m { @node(_, _, left, _) { insert(left, k, v); } }\n-        } else { alt m { @node(_, _, _, right) { insert(right, k, v); } } }\n+            alt check m { @node(_, _, left, _) { insert(left, k, v); } }\n+        } else {\n+            alt check m {\n+              @node(_, _, _, right) { insert(right, k, v); }\n+            }\n+        }\n       }\n     }\n }"}, {"sha": "5835dbf8c42107a2290fd1eaaedbab4b6278eb84", "filename": "src/libstd/tri.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Flibstd%2Ftri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Flibstd%2Ftri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftri.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -137,7 +137,7 @@ Function: from_str\n Parse logic value from `s`\n */\n pure fn from_str(s: str) -> t {\n-    alt s {\n+    alt check s {\n       \"unknown\" { unknown }\n       \"true\" { tri::true }\n       \"false\" { tri::false }\n@@ -151,7 +151,7 @@ Convert `v` into a string\n */\n pure fn to_str(v: t) -> str {\n     // FIXME replace with consts as soon as that works\n-    alt v {\n+    alt check v {\n       0u8 { \"unknown\" }\n       1u8 { \"true\" }\n       2u8 { \"false\" }"}, {"sha": "54d8de63014e20d4807ed72e2e0cc61f60a9dd4c", "filename": "src/test/compile-fail/missing-return2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Fcompile-fail%2Fmissing-return2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Fcompile-fail%2Fmissing-return2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-return2.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -3,7 +3,7 @@\n fn f() -> int {\n     // Make sure typestate doesn't interpret this alt expression\n     // as the function result\n-    alt true { true { } };\n+    alt check true { true { } };\n }\n \n fn main() { }"}, {"sha": "a4efbb5684c2c104bd78c3cb97047bef4352eccb", "filename": "src/test/compile-fail/non-exhaustive-match-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match-nested.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -1,5 +1,5 @@\n // -*- rust -*-\n-// error-pattern: Non-exhaustive pattern\n+// error-pattern: non-exhaustive patterns\n enum t { a(u), b }\n enum u { c, d }\n "}, {"sha": "b2fec6c0c5d4890f0a03627a56336644f5a7ae3c", "filename": "src/test/compile-fail/non-exhaustive-match.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -1,5 +1,15 @@\n-// -*- rust -*-\n-// error-pattern: Non-exhaustive pattern\n enum t { a, b, }\n \n-fn main() { let x = a; alt x { b { } } }\n+fn main() {\n+    let x = a;\n+    alt x { b { } } //! ERROR non-exhaustive patterns\n+    alt true { //! ERROR non-exhaustive bool patterns\n+      true {}\n+    }\n+    alt @some(10) { //! ERROR non-exhaustive patterns\n+      @none {}\n+    }\n+    alt (2, 3, 4) { //! ERROR non-exhaustive literal patterns\n+      (_, _, 4) {}\n+    }\n+}"}, {"sha": "647525059523476f2d7e0d396e576ea20795a295", "filename": "src/test/pretty/block-disambig.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Fpretty%2Fblock-disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-disambig.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -8,7 +8,7 @@ fn test2() -> int { let val = @0; { } *val }\n \n fn test3() {\n     let regs = @{mutable eax: 0};\n-    alt true { true { } }\n+    alt check true { true { } }\n     (*regs).eax = 1;\n }\n \n@@ -20,13 +20,13 @@ fn test6() -> bool { { } (true || false) && true }\n \n fn test7() -> uint {\n     let regs = @0;\n-    alt true { true { } }\n+    alt check true { true { } }\n     (*regs < 2) as uint\n }\n \n fn test8() -> int {\n     let val = @0;\n-    alt true {\n+    alt check true {\n         true { }\n     }\n     if *val < 1 {\n@@ -36,11 +36,11 @@ fn test8() -> int {\n     }\n }\n \n-fn test9() { let regs = @mutable 0; alt true { true { } } *regs += 1; }\n+fn test9() { let regs = @mutable 0; alt check true { true { } } *regs += 1; }\n \n fn test10() -> int {\n     let regs = @mutable [0];\n-    alt true { true { } }\n+    alt check true { true { } }\n     (*regs)[0]\n }\n "}, {"sha": "e9fd2c2dc2cb4f8a569f9be6f5f272caf77bdfb7", "filename": "src/test/pretty/unary-op-disambig.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Fpretty%2Funary-op-disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Fpretty%2Funary-op-disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Funary-op-disambig.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -10,8 +10,8 @@ fn if_semi() -> int { if true { f() } else { f() }; -1 }\n \n fn if_nosemi() -> int { (if true { 0 } else { 0 }) - 1 }\n \n-fn alt_semi() -> int { alt true { true { f() } }; -1 }\n+fn alt_semi() -> int { alt check true { true { f() } }; -1 }\n \n-fn alt_no_semi() -> int { (alt true { true { 0 } }) - 1 }\n+fn alt_no_semi() -> int { (alt check true { true { 0 } }) - 1 }\n \n fn stmt() { { f() }; -1; }"}, {"sha": "1cd512cfc41beb5fb0848b1ca6801f8f40504f05", "filename": "src/test/run-fail/unwind-alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-fail%2Funwind-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-fail%2Funwind-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-alt.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -4,7 +4,7 @@ fn test_box() {\n     @0;\n }\n fn test_str() {\n-    let res = alt false { true { \"happy\" } };\n+    let res = alt check false { true { \"happy\" } };\n     assert res == \"happy\";\n }\n fn main() {"}, {"sha": "e3fd606c2d8459b0aca36597a50e99b06e7d89a4", "filename": "src/test/run-pass/alt-bot-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Falt-bot-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Falt-bot-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-bot-2.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -1,3 +1,3 @@\n // n.b. This was only ever failing with optimization disabled.\n-fn a() -> int { alt ret 1 { 2 { 3 } } }\n+fn a() -> int { alt check ret 1 { 2 { 3 } } }\n fn main() { a(); }"}, {"sha": "d266a63418f11751658720121af6e4f27a6cad86", "filename": "src/test/run-pass/alt-pattern-lit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -1,7 +1,7 @@\n \n \n fn altlit(f: int) -> int {\n-    alt f {\n+    alt check f {\n       10 { #debug(\"case 10\"); ret 20; }\n       11 { #debug(\"case 11\"); ret 22; }\n     }"}, {"sha": "e85a82a2fd44e7e9dc010de1027af5e4ceed9229", "filename": "src/test/run-pass/alt-range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Falt-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Falt-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-range.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -7,7 +7,7 @@ fn main() {\n       6u to 7u { fail \"shouldn't match range\"; }\n       _ {}\n     }\n-    alt 5u {\n+    alt check 5u {\n       1u { fail \"should match non-first range\"; }\n       2u to 6u {}\n     }"}, {"sha": "c0a096cc2c9415fa6c1faecef9e9c2a6aa0df956", "filename": "src/test/run-pass/alt-str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Falt-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Falt-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-str.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -1,7 +1,7 @@\n // Issue #53\n \n fn main() {\n-    alt \"test\" { \"not-test\" { fail; } \"test\" { } _ { fail; } }\n+    alt check \"test\" { \"not-test\" { fail; } \"test\" { } _ { fail; } }\n \n     enum t { tag1(str), tag2, }\n \n@@ -13,9 +13,9 @@ fn main() {\n       _ { fail; }\n     }\n \n-    let x = alt \"a\" { \"a\" { 1 } \"b\" { 2 } };\n+    let x = alt check \"a\" { \"a\" { 1 } \"b\" { 2 } };\n     assert (x == 1);\n \n-    alt \"a\" { \"a\" { } \"b\" { } }\n+    alt check \"a\" { \"a\" { } \"b\" { } }\n \n }"}, {"sha": "79627d5501d1c01ef3c4e4604a17a8dc2f2a1b2c", "filename": "src/test/run-pass/binary-minus-without-space.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Fbinary-minus-without-space.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Fbinary-minus-without-space.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinary-minus-without-space.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -1,6 +1,6 @@\n // Check that issue #954 stays fixed\n \n fn main() {\n-    alt -1 { -1 {} }\n+    alt check -1 { -1 {} }\n     assert 1-1 == 0;\n }"}, {"sha": "93a65d6297762de77181ac2a5a5c9117839f1043", "filename": "src/test/run-pass/expr-alt-box.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Fexpr-alt-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Fexpr-alt-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-box.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -4,10 +4,13 @@\n // -*- rust -*-\n \n // Tests for alt as expressions resulting in boxed types\n-fn test_box() { let res = alt true { true { @100 } }; assert (*res == 100); }\n+fn test_box() {\n+    let res = alt check true { true { @100 } };\n+    assert (*res == 100);\n+}\n \n fn test_str() {\n-    let res = alt true { true { \"happy\" } };\n+    let res = alt check true { true { \"happy\" } };\n     assert (res == \"happy\");\n }\n "}, {"sha": "bdaa676954b70f79576e90f342f737a0d7d49292", "filename": "src/test/run-pass/expr-alt-generic-box1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -5,7 +5,7 @@\n type compare<T> = fn@(@T, @T) -> bool;\n \n fn test_generic<T>(expected: @T, eq: compare<T>) {\n-    let actual: @T = alt true { true { expected } };\n+    let actual: @T = alt check true { true { expected } };\n     assert (eq(expected, actual));\n }\n "}, {"sha": "de1143464c8546103abb4a1ccebdd3d5526e9c55", "filename": "src/test/run-pass/expr-alt-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -5,7 +5,7 @@\n type compare<T> = fn@(T, T) -> bool;\n \n fn test_generic<T: copy>(expected: T, eq: compare<T>) {\n-    let actual: T = alt true { true { expected } };\n+    let actual: T = alt check true { true { expected } };\n     assert (eq(expected, actual));\n }\n "}, {"sha": "55e332637765e1828334061caecaf72b5d03b358", "filename": "src/test/run-pass/expr-alt-generic-unique1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique1.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -4,7 +4,7 @@\n type compare<T> = fn@(~T, ~T) -> bool;\n \n fn test_generic<T: copy>(expected: ~T, eq: compare<T>) {\n-    let actual: ~T = alt true { true { expected } };\n+    let actual: ~T = alt check true { true { expected } };\n     assert (eq(expected, actual));\n }\n "}, {"sha": "9dc580ed3b0f7ef5051f3afde03c40b1d360747d", "filename": "src/test/run-pass/expr-alt-generic-unique2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique2.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -5,7 +5,7 @@\n type compare<T> = fn@(T, T) -> bool;\n \n fn test_generic<T: copy>(expected: T, eq: compare<T>) {\n-    let actual: T = alt true { true { expected } };\n+    let actual: T = alt check true { true { expected } };\n     assert (eq(expected, actual));\n }\n "}, {"sha": "84324a00db758120428c071999ecc255998f80dd", "filename": "src/test/run-pass/expr-alt-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -5,7 +5,7 @@\n type compare<T> = fn@(T, T) -> bool;\n \n fn test_generic<T: copy>(expected: T, eq: compare<T>) {\n-    let actual: T = alt true { true { expected } };\n+    let actual: T = alt check true { true { expected } };\n     assert (eq(expected, actual));\n }\n "}, {"sha": "52ec91884f68405ae63a2b049d5b6469e45c3af4", "filename": "src/test/run-pass/expr-alt-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-struct.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -5,7 +5,7 @@\n \n // Tests for alt as expressions resulting in structural types\n fn test_rec() {\n-    let rs = alt true { true { {i: 100} } };\n+    let rs = alt check true { true { {i: 100} } };\n     assert (rs == {i: 100});\n }\n "}, {"sha": "e3a55892955e45847042decb4fd550d0806038bb", "filename": "src/test/run-pass/expr-alt-unique.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Fexpr-alt-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Fexpr-alt-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-unique.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -4,6 +4,9 @@\n // -*- rust -*-\n \n // Tests for alt as expressions resulting in boxed types\n-fn test_box() { let res = alt true { true { ~100 } }; assert (*res == 100); }\n+fn test_box() {\n+    let res = alt check true { true { ~100 } };\n+    assert (*res == 100);\n+}\n \n fn main() { test_box(); }"}, {"sha": "d5f896d36d39223cd4cc9c65248afb7113c56384", "filename": "src/test/run-pass/unreachable-code.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Funreachable-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7/src%2Ftest%2Frun-pass%2Funreachable-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funreachable-code.rs?ref=67cc89f38d2e75cb0dcd6303fbe4bb4f659277a7", "patch": "@@ -30,7 +30,7 @@ fn log_cont() { do { log(error, cont); } while false }\n fn ret_ret() -> int { ret (ret 2) + 3; }\n \n fn ret_guard() {\n-    alt 2 {\n+    alt check 2 {\n       x if (ret) { x; }\n     }\n }"}]}