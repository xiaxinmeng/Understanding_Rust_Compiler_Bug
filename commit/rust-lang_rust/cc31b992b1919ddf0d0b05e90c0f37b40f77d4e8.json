{"sha": "cc31b992b1919ddf0d0b05e90c0f37b40f77d4e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjMzFiOTkyYjE5MTlkZGYwZDBiMDVlOTBjMGYzN2I0MGY3N2Q0ZTg=", "commit": {"author": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2020-11-30T22:16:50Z"}, "committer": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2020-12-14T10:00:53Z"}, "message": "Review suggestions", "tree": {"sha": "4062a1081d010bf7e688c6a926098d4e0c0a92d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4062a1081d010bf7e688c6a926098d4e0c0a92d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc31b992b1919ddf0d0b05e90c0f37b40f77d4e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc31b992b1919ddf0d0b05e90c0f37b40f77d4e8", "html_url": "https://github.com/rust-lang/rust/commit/cc31b992b1919ddf0d0b05e90c0f37b40f77d4e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc31b992b1919ddf0d0b05e90c0f37b40f77d4e8/comments", "author": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "850437b6f9915a5281c5085d45480b7d29f4e1e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/850437b6f9915a5281c5085d45480b7d29f4e1e6", "html_url": "https://github.com/rust-lang/rust/commit/850437b6f9915a5281c5085d45480b7d29f4e1e6"}], "stats": {"total": 166, "additions": 87, "deletions": 79}, "files": [{"sha": "167eb07a690bc89b50a5fd8345ffbf11108e39c8", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 87, "deletions": 79, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/cc31b992b1919ddf0d0b05e90c0f37b40f77d4e8/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc31b992b1919ddf0d0b05e90c0f37b40f77d4e8/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=cc31b992b1919ddf0d0b05e90c0f37b40f77d4e8", "patch": "@@ -169,22 +169,18 @@ enum AnchorFailure {\n }\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n-struct CacheKey {\n+struct ResolutionInfo {\n     module_id: DefId,\n     dis: Option<Disambiguator>,\n     path_str: String,\n     extra_fragment: Option<String>,\n }\n \n-impl CacheKey {\n-    fn new(\n-        module_id: DefId,\n-        dis: Option<Disambiguator>,\n-        path_str: String,\n-        extra_fragment: Option<String>,\n-    ) -> Self {\n-        Self { module_id, dis, path_str, extra_fragment }\n-    }\n+struct DiagnosticInfo<'a> {\n+    item: &'a Item,\n+    dox: &'a str,\n+    ori_link: &'a str,\n+    link_range: Option<Range<usize>>,\n }\n \n #[derive(Clone, Debug, Hash)]\n@@ -205,7 +201,7 @@ struct LinkCollector<'a, 'tcx> {\n     /// See the code for associated items on inherent impls for details.\n     kind_side_channel: Cell<Option<(DefKind, DefId)>>,\n     /// Cache the resolved links so we can avoid resolving (and emitting errors for) the same link\n-    visited_links: FxHashMap<CacheKey, CachedLink>,\n+    visited_links: FxHashMap<ResolutionInfo, CachedLink>,\n }\n \n impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n@@ -1108,9 +1104,15 @@ impl LinkCollector<'_, '_> {\n             return None;\n         }\n \n-        let key = CacheKey::new(module_id, disambiguator, path_str.to_owned(), extra_fragment);\n-        let (mut res, mut fragment) =\n-            self.resolve_with_disambiguator_cached(key, item, dox, &ori_link, link_range.clone())?;\n+        let key = ResolutionInfo {\n+            module_id,\n+            dis: disambiguator,\n+            path_str: path_str.to_owned(),\n+            extra_fragment,\n+        };\n+        let diag =\n+            DiagnosticInfo { item, dox, ori_link: &ori_link, link_range: link_range.clone() };\n+        let (mut res, mut fragment) = self.resolve_with_disambiguator_cached(key, diag)?;\n \n         // Check for a primitive which might conflict with a module\n         // Report the ambiguity and require that the user specify which one they meant.\n@@ -1220,59 +1222,47 @@ impl LinkCollector<'_, '_> {\n \n     fn resolve_with_disambiguator_cached(\n         &mut self,\n-        key: CacheKey,\n-        item: &Item,\n-        dox: &str,\n-        ori_link: &str,\n-        link_range: Option<Range<usize>>,\n+        key: ResolutionInfo,\n+        diag: DiagnosticInfo<'_>,\n     ) -> Option<(Res, Option<String>)> {\n         // Try to look up both the result and the corresponding side channel value\n         if let Some(ref cached) = self.visited_links.get(&key) {\n             self.kind_side_channel.set(cached.side_channel.clone());\n-            Some(cached.res.clone())\n-        } else {\n-            match self.resolve_with_disambiguator(\n-                key.dis,\n-                item,\n-                dox,\n-                &key.path_str,\n-                key.module_id,\n-                key.extra_fragment.clone(),\n-                ori_link,\n-                link_range,\n-            ) {\n-                Some(res) => {\n-                    // Store result for the actual namespace\n-                    self.visited_links.insert(\n-                        key,\n-                        CachedLink {\n-                            res: res.clone(),\n-                            side_channel: self.kind_side_channel.clone().into_inner(),\n-                        },\n-                    );\n-                    Some(res)\n-                }\n-                _ => None,\n-            }\n+            return Some(cached.res.clone());\n         }\n+\n+        let res = self.resolve_with_disambiguator(&key, diag);\n+\n+        // Cache only if resolved successfully - don't silence duplicate errors\n+        if let Some(res) = &res {\n+            // Store result for the actual namespace\n+            self.visited_links.insert(\n+                key,\n+                CachedLink {\n+                    res: res.clone(),\n+                    side_channel: self.kind_side_channel.clone().into_inner(),\n+                },\n+            );\n+        }\n+\n+        res\n     }\n \n     /// After parsing the disambiguator, resolve the main part of the link.\n     // FIXME(jynelson): wow this is just so much\n     fn resolve_with_disambiguator(\n         &self,\n-        disambiguator: Option<Disambiguator>,\n-        item: &Item,\n-        dox: &str,\n-        path_str: &str,\n-        base_node: DefId,\n-        extra_fragment: Option<String>,\n-        ori_link: &str,\n-        link_range: Option<Range<usize>>,\n+        key: &ResolutionInfo,\n+        diag: DiagnosticInfo<'_>,\n     ) -> Option<(Res, Option<String>)> {\n+        let disambiguator = key.dis;\n+        let path_str = &key.path_str;\n+        let base_node = key.module_id;\n+        let extra_fragment = &key.extra_fragment;\n+\n         match disambiguator.map(Disambiguator::ns) {\n             Some(ns @ (ValueNS | TypeNS)) => {\n-                match self.resolve(path_str, ns, base_node, &extra_fragment) {\n+                match self.resolve(path_str, ns, base_node, extra_fragment) {\n                     Ok(res) => Some(res),\n                     Err(ErrorKind::Resolve(box mut kind)) => {\n                         // We only looked in one namespace. Try to give a better error if possible.\n@@ -1281,24 +1271,21 @@ impl LinkCollector<'_, '_> {\n                             // FIXME: really it should be `resolution_failure` that does this, not `resolve_with_disambiguator`\n                             // See https://github.com/rust-lang/rust/pull/76955#discussion_r493953382 for a good approach\n                             for &new_ns in &[other_ns, MacroNS] {\n-                                if let Some(res) = self.check_full_res(\n-                                    new_ns,\n-                                    path_str,\n-                                    base_node,\n-                                    &extra_fragment,\n-                                ) {\n+                                if let Some(res) =\n+                                    self.check_full_res(new_ns, path_str, base_node, extra_fragment)\n+                                {\n                                     kind = ResolutionFailure::WrongNamespace(res, ns);\n                                     break;\n                                 }\n                             }\n                         }\n                         resolution_failure(\n                             self,\n-                            &item,\n+                            diag.item,\n                             path_str,\n                             disambiguator,\n-                            dox,\n-                            link_range,\n+                            diag.dox,\n+                            diag.link_range,\n                             smallvec![kind],\n                         );\n                         // This could just be a normal link or a broken link\n@@ -1307,7 +1294,14 @@ impl LinkCollector<'_, '_> {\n                         return None;\n                     }\n                     Err(ErrorKind::AnchorFailure(msg)) => {\n-                        anchor_failure(self.cx, &item, &ori_link, dox, link_range, msg);\n+                        anchor_failure(\n+                            self.cx,\n+                            diag.item,\n+                            diag.ori_link,\n+                            diag.dox,\n+                            diag.link_range,\n+                            msg,\n+                        );\n                         return None;\n                     }\n                 }\n@@ -1318,21 +1312,35 @@ impl LinkCollector<'_, '_> {\n                     macro_ns: self\n                         .resolve_macro(path_str, base_node)\n                         .map(|res| (res, extra_fragment.clone())),\n-                    type_ns: match self.resolve(path_str, TypeNS, base_node, &extra_fragment) {\n+                    type_ns: match self.resolve(path_str, TypeNS, base_node, extra_fragment) {\n                         Ok(res) => {\n                             debug!(\"got res in TypeNS: {:?}\", res);\n                             Ok(res)\n                         }\n                         Err(ErrorKind::AnchorFailure(msg)) => {\n-                            anchor_failure(self.cx, &item, ori_link, dox, link_range, msg);\n+                            anchor_failure(\n+                                self.cx,\n+                                diag.item,\n+                                diag.ori_link,\n+                                diag.dox,\n+                                diag.link_range,\n+                                msg,\n+                            );\n                             return None;\n                         }\n                         Err(ErrorKind::Resolve(box kind)) => Err(kind),\n                     },\n-                    value_ns: match self.resolve(path_str, ValueNS, base_node, &extra_fragment) {\n+                    value_ns: match self.resolve(path_str, ValueNS, base_node, extra_fragment) {\n                         Ok(res) => Ok(res),\n                         Err(ErrorKind::AnchorFailure(msg)) => {\n-                            anchor_failure(self.cx, &item, ori_link, dox, link_range, msg);\n+                            anchor_failure(\n+                                self.cx,\n+                                diag.item,\n+                                diag.ori_link,\n+                                diag.dox,\n+                                diag.link_range,\n+                                msg,\n+                            );\n                             return None;\n                         }\n                         Err(ErrorKind::Resolve(box kind)) => Err(kind),\n@@ -1343,7 +1351,7 @@ impl LinkCollector<'_, '_> {\n                             Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) => {\n                                 Err(ResolutionFailure::WrongNamespace(res, TypeNS))\n                             }\n-                            _ => match (fragment, extra_fragment) {\n+                            _ => match (fragment, extra_fragment.clone()) {\n                                 (Some(fragment), Some(_)) => {\n                                     // Shouldn't happen but who knows?\n                                     Ok((res, Some(fragment)))\n@@ -1359,11 +1367,11 @@ impl LinkCollector<'_, '_> {\n                 if len == 0 {\n                     resolution_failure(\n                         self,\n-                        &item,\n+                        diag.item,\n                         path_str,\n                         disambiguator,\n-                        dox,\n-                        link_range,\n+                        diag.dox,\n+                        diag.link_range,\n                         candidates.into_iter().filter_map(|res| res.err()).collect(),\n                     );\n                     // this could just be a normal link\n@@ -1382,35 +1390,35 @@ impl LinkCollector<'_, '_> {\n                     let candidates = candidates.map(|candidate| candidate.ok().map(|(res, _)| res));\n                     ambiguity_error(\n                         self.cx,\n-                        &item,\n+                        diag.item,\n                         path_str,\n-                        dox,\n-                        link_range,\n+                        diag.dox,\n+                        diag.link_range,\n                         candidates.present_items().collect(),\n                     );\n                     return None;\n                 }\n             }\n             Some(MacroNS) => {\n                 match self.resolve_macro(path_str, base_node) {\n-                    Ok(res) => Some((res, extra_fragment)),\n+                    Ok(res) => Some((res, extra_fragment.clone())),\n                     Err(mut kind) => {\n                         // `resolve_macro` only looks in the macro namespace. Try to give a better error if possible.\n                         for &ns in &[TypeNS, ValueNS] {\n                             if let Some(res) =\n-                                self.check_full_res(ns, path_str, base_node, &extra_fragment)\n+                                self.check_full_res(ns, path_str, base_node, extra_fragment)\n                             {\n                                 kind = ResolutionFailure::WrongNamespace(res, MacroNS);\n                                 break;\n                             }\n                         }\n                         resolution_failure(\n                             self,\n-                            &item,\n+                            diag.item,\n                             path_str,\n                             disambiguator,\n-                            dox,\n-                            link_range,\n+                            diag.dox,\n+                            diag.link_range,\n                             smallvec![kind],\n                         );\n                         return None;"}]}