{"sha": "ac4e57c6400bdd500a1918238fc76abc3b7def3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjNGU1N2M2NDAwYmRkNTAwYTE5MTgyMzhmYzc2YWJjM2I3ZGVmM2Q=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-08-01T01:11:38Z"}, "committer": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-08-01T18:08:46Z"}, "message": "Introduce self_info (self_ty packaged up with a node_id).", "tree": {"sha": "07fee3f96eb6d3f73c4c84b4a2ec0e877e019c3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07fee3f96eb6d3f73c4c84b4a2ec0e877e019c3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac4e57c6400bdd500a1918238fc76abc3b7def3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac4e57c6400bdd500a1918238fc76abc3b7def3d", "html_url": "https://github.com/rust-lang/rust/commit/ac4e57c6400bdd500a1918238fc76abc3b7def3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac4e57c6400bdd500a1918238fc76abc3b7def3d/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "361a9b03e6713f7be5b5d4996f8aeeaa8bb01cb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/361a9b03e6713f7be5b5d4996f8aeeaa8bb01cb2", "html_url": "https://github.com/rust-lang/rust/commit/361a9b03e6713f7be5b5d4996f8aeeaa8bb01cb2"}], "stats": {"total": 91, "additions": 61, "deletions": 30}, "files": [{"sha": "98f0eed72966ffd63b5f883dd971ff41576d421a", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ac4e57c6400bdd500a1918238fc76abc3b7def3d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4e57c6400bdd500a1918238fc76abc3b7def3d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=ac4e57c6400bdd500a1918238fc76abc3b7def3d", "patch": "@@ -79,11 +79,16 @@ import typeck::infer::{resolve_type, force_tvar};\n \n import std::map::str_hash;\n \n+type self_info = {\n+    self_ty: ty::t,\n+    node_id: ast::node_id,\n+};\n+\n type fn_ctxt_ =\n     // var_bindings, locals and next_var_id are shared\n     // with any nested functions that capture the environment\n     // (and with any functions whose environment is being captured).\n-    {self_ty: option<ty::t>,\n+    {self_info: option<self_info>,\n      ret_ty: ty::t,\n      // Used by loop bodies that return from the outer function\n      indirect_ret_ty: option<ty::t>,\n@@ -122,7 +127,7 @@ fn blank_fn_ctxt(ccx: @crate_ctxt, rty: ty::t,\n                  region_bnd: ast::node_id) -> @fn_ctxt {\n // It's kind of a kludge to manufacture a fake function context\n // and statement context, but we might as well do write the code only once\n-    @fn_ctxt_({self_ty: none,\n+    @fn_ctxt_({self_info: none,\n                ret_ty: rty,\n                indirect_ret_ty: none,\n                purity: ast::pure_fn,\n@@ -170,14 +175,14 @@ fn check_bare_fn(ccx: @crate_ctxt,\n                  decl: ast::fn_decl,\n                  body: ast::blk,\n                  id: ast::node_id,\n-                 self_ty: option<ty::t>) {\n+                 self_info: option<self_info>) {\n     let fty = ty::node_id_to_type(ccx.tcx, id);\n     let fn_ty = alt check ty::get(fty).struct { ty::ty_fn(f) {f} };\n-    check_fn(ccx, self_ty, fn_ty, decl, body, false, none);\n+    check_fn(ccx, self_info, fn_ty, decl, body, false, none);\n }\n \n fn check_fn(ccx: @crate_ctxt,\n-            self_ty: option<ty::t>,\n+            self_info: option<self_info>,\n             fn_ty: ty::fn_ty,\n             decl: ast::fn_decl,\n             body: ast::blk,\n@@ -191,20 +196,20 @@ fn check_fn(ccx: @crate_ctxt,\n     // types with free ones.  The free region references will be bound\n     // the node_id of the body block.\n \n-    let {isr, self_ty, fn_ty} = {\n+    let {isr, self_info, fn_ty} = {\n         let old_isr = option::map_default(old_fcx, @nil,\n                                          |fcx| fcx.in_scope_regions);\n-        replace_bound_regions_in_fn_ty(tcx, old_isr, self_ty, fn_ty,\n+        replace_bound_regions_in_fn_ty(tcx, old_isr, self_info, fn_ty,\n                                        |br| ty::re_free(body.node.id, br))\n     };\n \n     let arg_tys = fn_ty.inputs.map(|a| a.ty);\n     let ret_ty = fn_ty.output;\n \n-    debug!{\"check_fn(arg_tys=%?, ret_ty=%?, self_ty=%?)\",\n+    debug!{\"check_fn(arg_tys=%?, ret_ty=%?, self_info.self_ty=%?)\",\n            arg_tys.map(|a| ty_to_str(tcx, a)),\n            ty_to_str(tcx, ret_ty),\n-           option::map(self_ty, |st| ty_to_str(tcx, st))};\n+           option::map(self_info, |s| ty_to_str(tcx, s.self_ty))};\n \n     // ______________________________________________________________________\n     // Create the function context.  This is either derived from scratch or,\n@@ -237,7 +242,7 @@ fn check_fn(ccx: @crate_ctxt,\n             }\n         } else { none };\n \n-        @fn_ctxt_({self_ty: self_ty,\n+        @fn_ctxt_({self_info: self_info,\n                    ret_ty: ret_ty,\n                    indirect_ret_ty: indirect_ret_ty,\n                    purity: purity,\n@@ -359,11 +364,12 @@ fn check_fn(ccx: @crate_ctxt,\n     }\n }\n \n-fn check_method(ccx: @crate_ctxt, method: @ast::method, self_ty: ty::t) {\n-    check_bare_fn(ccx, method.decl, method.body, method.id, some(self_ty));\n+fn check_method(ccx: @crate_ctxt, method: @ast::method,\n+                self_info: self_info) {\n+    check_bare_fn(ccx, method.decl, method.body, method.id, some(self_info));\n }\n \n-fn check_class_member(ccx: @crate_ctxt, class_t: ty::t,\n+fn check_class_member(ccx: @crate_ctxt, class_t: self_info,\n                       cm: @ast::class_member) {\n     alt cm.node {\n       ast::instance_var(_,t,_,_,_) { }\n@@ -409,20 +415,22 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         let rp = ccx.tcx.region_paramd_items.contains_key(it.id);\n         debug!{\"item_impl %s with id %d rp %b\",\n                *it.ident, it.id, rp};\n-        let self_ty = ccx.to_ty(rscope::type_rscope(rp), ty);\n-        for ms.each |m| { check_method(ccx, m, self_ty);}\n+        let self_info = {self_ty: ccx.to_ty(rscope::type_rscope(rp), ty),\n+                         node_id: it.id };\n+        for ms.each |m| { check_method(ccx, m, self_info);}\n       }\n       ast::item_class(tps, traits, members, m_ctor, m_dtor) {\n         let tcx = ccx.tcx;\n-        let class_t = ty::node_id_to_type(tcx, it.id);\n+        let class_t = {self_ty: ty::node_id_to_type(tcx, it.id),\n+                       node_id: it.id};\n \n         do option::iter(m_ctor) |ctor| {\n             // typecheck the ctor\n             check_bare_fn(ccx, ctor.node.dec,\n                           ctor.node.body, ctor.node.id,\n                           some(class_t));\n             // Write the ctor's self's type\n-            write_ty_to_tcx(tcx, ctor.node.self_id, class_t);\n+            write_ty_to_tcx(tcx, ctor.node.self_id, class_t.self_ty);\n         }\n \n         do option::iter(m_dtor) |dtor| {\n@@ -431,7 +439,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n                          dtor.node.body, dtor.node.id,\n                          some(class_t));\n             // Write the dtor's self's type\n-            write_ty_to_tcx(tcx, dtor.node.self_id, class_t);\n+            write_ty_to_tcx(tcx, dtor.node.self_id, class_t.self_ty);\n         };\n \n         // typecheck the members\n@@ -1123,7 +1131,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         fcx.write_ty(expr.id, fty);\n \n-        check_fn(fcx.ccx, fcx.self_ty, fn_ty, decl, body,\n+        check_fn(fcx.ccx, fcx.self_info, fn_ty, decl, body,\n                  is_loop_body, some(fcx));\n     }\n \n@@ -2145,12 +2153,12 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n         ret no_params(typ);\n       }\n       ast::def_self(_) {\n-        alt fcx.self_ty {\n-          some(self_ty) {\n-            ret no_params(self_ty);\n+        alt fcx.self_info {\n+          some(self_info) {\n+            ret no_params(self_info.self_ty);\n           }\n           none {\n-              fcx.ccx.tcx.sess.span_bug(sp, ~\"def_self with no self_ty\");\n+              fcx.ccx.tcx.sess.span_bug(sp, ~\"def_self with no self_info\");\n           }\n         }\n       }"}, {"sha": "5bbe9bb18677f4274ea7c386091cc862f771d85b", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ac4e57c6400bdd500a1918238fc76abc3b7def3d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4e57c6400bdd500a1918238fc76abc3b7def3d/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=ac4e57c6400bdd500a1918238fc76abc3b7def3d", "patch": "@@ -5,16 +5,24 @@ import syntax::print::pprust::{expr_to_str};\n fn replace_bound_regions_in_fn_ty(\n     tcx: ty::ctxt,\n     isr: isr_alist,\n-    self_ty: option<ty::t>,\n+    self_info: option<self_info>,\n     fn_ty: ty::fn_ty,\n-    mapf: fn(ty::bound_region) -> ty::region) -> {isr: isr_alist,\n-                                                  self_ty: option<ty::t>,\n-                                                  fn_ty: ty::fn_ty} {\n+    mapf: fn(ty::bound_region) -> ty::region) ->\n+    {isr: isr_alist, self_info: option<self_info>, fn_ty: ty::fn_ty} {\n+\n+    // Take self_info apart; the self_ty part is the only one we want\n+    // to update here.\n+    let self_ty = alt self_info {\n+      some(s) { some(s.self_ty) }\n+      none { none }\n+    };\n \n     let mut all_tys = ty::tys_in_fn_ty(fn_ty);\n+\n     for self_ty.each |t| { vec::push(all_tys, t) }\n \n-    debug!{\"replace_bound_regions_in_fn_ty(self_ty=%?, fn_ty=%s, all_tys=%?)\",\n+    debug!{\"replace_bound_regions_in_fn_ty(self_info.self_ty=%?, fn_ty=%s, \\\n+                all_tys=%?)\",\n            self_ty.map(|t| ty_to_str(tcx, t)),\n            ty_to_str(tcx, ty::mk_fn(tcx, fn_ty)),\n            all_tys.map(|t| ty_to_str(tcx, t))};\n@@ -29,12 +37,27 @@ fn replace_bound_regions_in_fn_ty(\n     });\n     let t_self = self_ty.map(|t| replace_bound_regions(tcx, isr, t));\n \n-    debug!{\"result of replace_bound_regions_in_fn_ty: self_ty=%?, fn_ty=%s\",\n+    debug!{\"result of replace_bound_regions_in_fn_ty: self_info.self_ty=%?, \\\n+                fn_ty=%s\",\n            t_self.map(|t| ty_to_str(tcx, t)),\n            ty_to_str(tcx, t_fn)};\n \n+\n+    // Glue updated self_ty back together with its original node_id.\n+    let new_self_info = alt self_info {\n+        some(s) {\n+            alt check t_self {\n+              some(t) {\n+                some({self_ty: t, node_id: s.node_id})\n+              }\n+              // this 'none' case shouldn't happen\n+            }\n+        }\n+        none { none }\n+    };\n+\n     ret {isr: isr,\n-         self_ty: t_self,\n+         self_info: new_self_info,\n          fn_ty: alt check ty::get(t_fn).struct { ty::ty_fn(o) {o} }};\n \n "}]}