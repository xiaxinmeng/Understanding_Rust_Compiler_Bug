{"sha": "f8efe5d8222db70964f46b6523be81d6e7c38e65", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4ZWZlNWQ4MjIyZGI3MDk2NGY0NmI2NTIzYmU4MWQ2ZTdjMzhlNjU=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-16T20:22:08Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-09-01T18:13:16Z"}, "message": "Compute proc_macros in resolutions.", "tree": {"sha": "7d00e473f9c3e54adf3f0b386423ee999814f0d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d00e473f9c3e54adf3f0b386423ee999814f0d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8efe5d8222db70964f46b6523be81d6e7c38e65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8efe5d8222db70964f46b6523be81d6e7c38e65", "html_url": "https://github.com/rust-lang/rust/commit/f8efe5d8222db70964f46b6523be81d6e7c38e65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8efe5d8222db70964f46b6523be81d6e7c38e65/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "635978041d3b65cd89cc109a83fc761221b4f1d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/635978041d3b65cd89cc109a83fc761221b4f1d0", "html_url": "https://github.com/rust-lang/rust/commit/635978041d3b65cd89cc109a83fc761221b4f1d0"}], "stats": {"total": 106, "additions": 52, "deletions": 54}, "files": [{"sha": "443698a796ddc63c2e8a250cbaf2461403909cac", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f8efe5d8222db70964f46b6523be81d6e7c38e65/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8efe5d8222db70964f46b6523be81d6e7c38e65/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=f8efe5d8222db70964f46b6523be81d6e7c38e65", "patch": "@@ -502,13 +502,6 @@ pub struct Crate {\n     pub attrs: Vec<Attribute>,\n     pub items: Vec<P<Item>>,\n     pub span: Span,\n-    /// The order of items in the HIR is unrelated to the order of\n-    /// items in the AST. However, we generate proc macro harnesses\n-    /// based on the AST order, and later refer to these harnesses\n-    /// from the HIR. This field keeps track of the order in which\n-    /// we generated proc macros harnesses, so that we can map\n-    /// HIR proc macros items back to their harness items.\n-    pub proc_macros: Vec<NodeId>,\n }\n \n /// Possible values inside of compile-time attribute lists."}, {"sha": "b7e446a8bee2b6f8cf9facd2bb5db1768c274549", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8efe5d8222db70964f46b6523be81d6e7c38e65/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8efe5d8222db70964f46b6523be81d6e7c38e65/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=f8efe5d8222db70964f46b6523be81d6e7c38e65", "patch": "@@ -1059,7 +1059,7 @@ pub fn noop_visit_fn_header<T: MutVisitor>(header: &mut FnHeader, vis: &mut T) {\n // FIXME: Avoid visiting the crate as a `Mod` item, flat map only the inner items if possible,\n // or make crate visiting first class if necessary.\n pub fn noop_visit_crate<T: MutVisitor>(krate: &mut Crate, vis: &mut T) {\n-    visit_clobber(krate, |Crate { attrs, items, span, proc_macros }| {\n+    visit_clobber(krate, |Crate { attrs, items, span }| {\n         let item_vis =\n             Visibility { kind: VisibilityKind::Public, span: span.shrink_to_lo(), tokens: None };\n         let item = P(Item {\n@@ -1075,13 +1075,11 @@ pub fn noop_visit_crate<T: MutVisitor>(krate: &mut Crate, vis: &mut T) {\n \n         let len = items.len();\n         if len == 0 {\n-            Crate { attrs: vec![], items: vec![], span, proc_macros }\n+            Crate { attrs: vec![], items: vec![], span }\n         } else if len == 1 {\n             let Item { attrs, span, kind, .. } = items.into_iter().next().unwrap().into_inner();\n             match kind {\n-                ItemKind::Mod(_, ModKind::Loaded(items, ..)) => {\n-                    Crate { attrs, items, span, proc_macros }\n-                }\n+                ItemKind::Mod(_, ModKind::Loaded(items, ..)) => Crate { attrs, items, span },\n                 _ => panic!(\"visitor converted a module to not a module\"),\n             }\n         } else {"}, {"sha": "f8d366fdee752b7dc77e8f35082dbd5ef7b6c7c3", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8efe5d8222db70964f46b6523be81d6e7c38e65/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8efe5d8222db70964f46b6523be81d6e7c38e65/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=f8efe5d8222db70964f46b6523be81d6e7c38e65", "patch": "@@ -474,9 +474,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.owners.ensure_contains_elem(CRATE_DEF_ID, || None);\n         self.owners[CRATE_DEF_ID] = Some(hir::OwnerNode::Crate(module));\n \n-        let proc_macros =\n-            c.proc_macros.iter().map(|id| self.node_id_to_hir_id[*id].unwrap()).collect();\n-\n         let mut trait_map: FxHashMap<_, FxHashMap<_, _>> = FxHashMap::default();\n         for (k, v) in self.resolver.take_trait_map().into_iter() {\n             if let Some(Some(hir_id)) = self.node_id_to_hir_id.get(k) {\n@@ -510,7 +507,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             owners: self.owners,\n             bodies: self.bodies,\n             modules: self.modules,\n-            proc_macros,\n             trait_map,\n             attrs: self.attrs,\n         };"}, {"sha": "6f61e4cba0776acccf84358c781fa4bd2a4516fa", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f8efe5d8222db70964f46b6523be81d6e7c38e65/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8efe5d8222db70964f46b6523be81d6e7c38e65/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=f8efe5d8222db70964f46b6523be81d6e7c38e65", "patch": "@@ -13,7 +13,6 @@ use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use smallvec::smallvec;\n-use std::cell::RefCell;\n \n struct ProcMacroDerive {\n     id: NodeId,\n@@ -90,7 +89,7 @@ pub fn inject(\n         return krate;\n     }\n \n-    let decls = mk_decls(&mut krate, &mut cx, &macros);\n+    let decls = mk_decls(&mut cx, &macros);\n     krate.items.push(decls);\n \n     krate\n@@ -289,15 +288,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n //              // ...\n //          ];\n //      }\n-fn mk_decls(\n-    ast_krate: &mut ast::Crate,\n-    cx: &mut ExtCtxt<'_>,\n-    macros: &[ProcMacro],\n-) -> P<ast::Item> {\n-    // We're the ones filling in this Vec,\n-    // so it should be empty to start with\n-    assert!(ast_krate.proc_macros.is_empty());\n-\n+fn mk_decls(cx: &mut ExtCtxt<'_>, macros: &[ProcMacro]) -> P<ast::Item> {\n     let expn_id = cx.resolver.expansion_for_ast_pass(\n         DUMMY_SP,\n         AstPass::ProcMacroHarness,\n@@ -316,26 +307,25 @@ fn mk_decls(\n     let attr = Ident::new(sym::attr, span);\n     let bang = Ident::new(sym::bang, span);\n \n-    let krate_ref = RefCell::new(ast_krate);\n-\n-    // We add NodeIds to 'krate.proc_macros' in the order\n+    // We add NodeIds to 'resolver.proc_macros' in the order\n     // that we generate expressions. The position of each NodeId\n     // in the 'proc_macros' Vec corresponds to its position\n     // in the static array that will be generated\n     let decls = {\n-        let local_path =\n-            |sp: Span, name| cx.expr_path(cx.path(sp.with_ctxt(span.ctxt()), vec![name]));\n-        let proc_macro_ty_method_path = |method| {\n+        let local_path = |cx: &ExtCtxt<'_>, sp: Span, name| {\n+            cx.expr_path(cx.path(sp.with_ctxt(span.ctxt()), vec![name]))\n+        };\n+        let proc_macro_ty_method_path = |cx: &ExtCtxt<'_>, method| {\n             cx.expr_path(cx.path(span, vec![proc_macro, bridge, client, proc_macro_ty, method]))\n         };\n         macros\n             .iter()\n             .map(|m| match m {\n                 ProcMacro::Derive(cd) => {\n-                    krate_ref.borrow_mut().proc_macros.push(cd.id);\n+                    cx.resolver.declare_proc_macro(cd.id);\n                     cx.expr_call(\n                         span,\n-                        proc_macro_ty_method_path(custom_derive),\n+                        proc_macro_ty_method_path(cx, custom_derive),\n                         vec![\n                             cx.expr_str(cd.span, cd.trait_name),\n                             cx.expr_vec_slice(\n@@ -345,23 +335,23 @@ fn mk_decls(\n                                     .map(|&s| cx.expr_str(cd.span, s))\n                                     .collect::<Vec<_>>(),\n                             ),\n-                            local_path(cd.span, cd.function_name),\n+                            local_path(cx, cd.span, cd.function_name),\n                         ],\n                     )\n                 }\n                 ProcMacro::Def(ca) => {\n-                    krate_ref.borrow_mut().proc_macros.push(ca.id);\n+                    cx.resolver.declare_proc_macro(ca.id);\n                     let ident = match ca.def_type {\n                         ProcMacroDefType::Attr => attr,\n                         ProcMacroDefType::Bang => bang,\n                     };\n \n                     cx.expr_call(\n                         span,\n-                        proc_macro_ty_method_path(ident),\n+                        proc_macro_ty_method_path(cx, ident),\n                         vec![\n                             cx.expr_str(ca.span, ca.function_name.name),\n-                            local_path(ca.span, ca.function_name),\n+                            local_path(cx, ca.span, ca.function_name),\n                         ],\n                     )\n                 }"}, {"sha": "ebf168d7de7b48a7b227a02910bd6822fda8c26f", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8efe5d8222db70964f46b6523be81d6e7c38e65/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8efe5d8222db70964f46b6523be81d6e7c38e65/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=f8efe5d8222db70964f46b6523be81d6e7c38e65", "patch": "@@ -894,6 +894,14 @@ pub trait ResolverExpand {\n     /// Decodes the proc-macro quoted span in the specified crate, with the specified id.\n     /// No caching is performed.\n     fn get_proc_macro_quoted_span(&self, krate: CrateNum, id: usize) -> Span;\n+\n+    /// The order of items in the HIR is unrelated to the order of\n+    /// items in the AST. However, we generate proc macro harnesses\n+    /// based on the AST order, and later refer to these harnesses\n+    /// from the HIR. This field keeps track of the order in which\n+    /// we generated proc macros harnesses, so that we can map\n+    /// HIR proc macros items back to their harness items.\n+    fn declare_proc_macro(&mut self, id: NodeId);\n }\n \n #[derive(Clone, Default)]"}, {"sha": "a43ef9bb1a0b0310d8d0fc6bee34674323cd1555", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f8efe5d8222db70964f46b6523be81d6e7c38e65/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8efe5d8222db70964f46b6523be81d6e7c38e65/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=f8efe5d8222db70964f46b6523be81d6e7c38e65", "patch": "@@ -676,9 +676,6 @@ pub struct Crate<'hir> {\n     /// A list of modules written out in the order in which they\n     /// appear in the crate. This includes the main crate module.\n     pub modules: BTreeMap<LocalDefId, ModuleItems>,\n-    /// A list of proc macro HirIds, written out in the order in which\n-    /// they are declared in the static array generated by proc_macro_harness.\n-    pub proc_macros: Vec<HirId>,\n \n     /// Map indicating what traits are in scope for places where this\n     /// is relevant; generated by resolve."}, {"sha": "7127ec57c08c32f7ff2da687e45bd29e0af9c5d6", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8efe5d8222db70964f46b6523be81d6e7c38e65/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8efe5d8222db70964f46b6523be81d6e7c38e65/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=f8efe5d8222db70964f46b6523be81d6e7c38e65", "patch": "@@ -324,7 +324,7 @@ pub fn configure_and_expand(\n         };\n \n         let extern_mod_loaded = |ident: Ident, attrs, items, span| {\n-            let krate = ast::Crate { attrs, items, span, proc_macros: vec![] };\n+            let krate = ast::Crate { attrs, items, span };\n             pre_expansion_lint(sess, lint_store, &krate, &ident.name.as_str());\n             (krate.attrs, krate.items)\n         };"}, {"sha": "d8b9a4799760ef3d9cf79db8932c527a512de6ae", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f8efe5d8222db70964f46b6523be81d6e7c38e65/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8efe5d8222db70964f46b6523be81d6e7c38e65/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=f8efe5d8222db70964f46b6523be81d6e7c38e65", "patch": "@@ -454,7 +454,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let table = self.tcx.resolutions(()).definitions.def_path_table();\n         if self.is_proc_macro {\n             for def_index in std::iter::once(CRATE_DEF_INDEX)\n-                .chain(self.tcx.hir().krate().proc_macros.iter().map(|p| p.owner.local_def_index))\n+                .chain(self.tcx.resolutions(()).proc_macros.iter().map(|p| p.local_def_index))\n             {\n                 let def_key = self.lazy(table.def_key(def_index));\n                 let def_path_hash = self.lazy(table.def_path_hash(def_index));\n@@ -1630,7 +1630,8 @@ impl EncodeContext<'a, 'tcx> {\n \n             let proc_macro_decls_static = tcx.proc_macro_decls_static(()).unwrap().local_def_index;\n             let stability = tcx.lookup_stability(DefId::local(CRATE_DEF_INDEX)).copied();\n-            let macros = self.lazy(hir.krate().proc_macros.iter().map(|p| p.owner.local_def_index));\n+            let macros =\n+                self.lazy(tcx.resolutions(()).proc_macros.iter().map(|p| p.local_def_index));\n             let spans = self.tcx.sess.parse_sess.proc_macro_quoted_spans();\n             for (i, span) in spans.into_iter().enumerate() {\n                 let span = self.lazy(span);\n@@ -1649,13 +1650,14 @@ impl EncodeContext<'a, 'tcx> {\n             // Normally, this information is encoded when we walk the items\n             // defined in this crate. However, we skip doing that for proc-macro crates,\n             // so we manually encode just the information that we need\n-            for proc_macro in &hir.krate().proc_macros {\n-                let id = proc_macro.owner.local_def_index;\n-                let mut name = hir.name(*proc_macro);\n-                let span = hir.span(*proc_macro);\n+            for &proc_macro in &tcx.resolutions(()).proc_macros {\n+                let id = proc_macro;\n+                let proc_macro = hir.local_def_id_to_hir_id(proc_macro);\n+                let mut name = hir.name(proc_macro);\n+                let span = hir.span(proc_macro);\n                 // Proc-macros may have attributes like `#[allow_internal_unstable]`,\n                 // so downstream crates need access to them.\n-                let attrs = hir.attrs(*proc_macro);\n+                let attrs = hir.attrs(proc_macro);\n                 let macro_kind = if tcx.sess.contains_name(attrs, sym::proc_macro) {\n                     MacroKind::Bang\n                 } else if tcx.sess.contains_name(attrs, sym::proc_macro_attribute) {\n@@ -1673,10 +1675,10 @@ impl EncodeContext<'a, 'tcx> {\n                     bug!(\"Unknown proc-macro type for item {:?}\", id);\n                 };\n \n-                let mut def_key = self.tcx.hir().def_key(proc_macro.owner);\n+                let mut def_key = self.tcx.hir().def_key(id);\n                 def_key.disambiguated_data.data = DefPathData::MacroNs(name);\n \n-                let def_id = DefId::local(id);\n+                let def_id = id.to_def_id();\n                 record!(self.tables.def_kind[def_id] <- DefKind::Macro(macro_kind));\n                 record!(self.tables.kind[def_id] <- EntryKind::ProcMacro(macro_kind));\n                 record!(self.tables.attributes[def_id] <- attrs);"}, {"sha": "d01ca27b8511895b78102b6c087c1cd496e33fb1", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f8efe5d8222db70964f46b6523be81d6e7c38e65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8efe5d8222db70964f46b6523be81d6e7c38e65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=f8efe5d8222db70964f46b6523be81d6e7c38e65", "patch": "@@ -134,6 +134,9 @@ pub struct ResolverOutputs {\n     pub extern_prelude: FxHashMap<Symbol, bool>,\n     pub main_def: Option<MainDefinition>,\n     pub trait_impls: BTreeMap<DefId, Vec<LocalDefId>>,\n+    /// A list of proc macro LocalDefIds, written out in the order in which\n+    /// they are declared in the static array generated by proc_macro_harness.\n+    pub proc_macros: Vec<LocalDefId>,\n }\n \n #[derive(Clone, Copy, Debug)]"}, {"sha": "10c73fd64bc198cece7158a1ea964629b8d985d8", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f8efe5d8222db70964f46b6523be81d6e7c38e65/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8efe5d8222db70964f46b6523be81d6e7c38e65/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=f8efe5d8222db70964f46b6523be81d6e7c38e65", "patch": "@@ -26,8 +26,7 @@ impl<'a> Parser<'a> {\n     /// Parses a source module as a crate. This is the main entry point for the parser.\n     pub fn parse_crate_mod(&mut self) -> PResult<'a, ast::Crate> {\n         let (attrs, items, span) = self.parse_mod(&token::Eof)?;\n-        let proc_macros = Vec::new(); // Filled in by `proc_macro_harness::inject()`.\n-        Ok(ast::Crate { attrs, items, span, proc_macros })\n+        Ok(ast::Crate { attrs, items, span })\n     }\n \n     /// Parses a `mod <foo> { ... }` or `mod <foo>;` item."}, {"sha": "152d34fd63558df8e2c8caac358cae5b6f7f8608", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f8efe5d8222db70964f46b6523be81d6e7c38e65/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8efe5d8222db70964f46b6523be81d6e7c38e65/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=f8efe5d8222db70964f46b6523be81d6e7c38e65", "patch": "@@ -1035,6 +1035,9 @@ pub struct Resolver<'a> {\n \n     main_def: Option<MainDefinition>,\n     trait_impls: BTreeMap<DefId, Vec<LocalDefId>>,\n+    /// A list of proc macro LocalDefIds, written out in the order in which\n+    /// they are declared in the static array generated by proc_macro_harness.\n+    proc_macros: Vec<NodeId>,\n }\n \n /// Nothing really interesting here; it just provides memory for the rest of the crate.\n@@ -1400,6 +1403,7 @@ impl<'a> Resolver<'a> {\n             item_generics_num_lifetimes: Default::default(),\n             main_def: Default::default(),\n             trait_impls: Default::default(),\n+            proc_macros: Default::default(),\n         };\n \n         let root_parent_scope = ParentScope::module(graph_root, &resolver);\n@@ -1434,6 +1438,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     pub fn into_outputs(self) -> ResolverOutputs {\n+        let proc_macros = self.proc_macros.iter().map(|id| self.local_def_id(*id)).collect();\n         let definitions = self.definitions;\n         let visibilities = self.visibilities;\n         let extern_crate_map = self.extern_crate_map;\n@@ -1458,10 +1463,12 @@ impl<'a> Resolver<'a> {\n                 .collect(),\n             main_def,\n             trait_impls: self.trait_impls,\n+            proc_macros,\n         }\n     }\n \n     pub fn clone_outputs(&self) -> ResolverOutputs {\n+        let proc_macros = self.proc_macros.iter().map(|id| self.local_def_id(*id)).collect();\n         ResolverOutputs {\n             definitions: self.definitions.clone(),\n             cstore: Box::new(self.cstore().clone()),\n@@ -1478,6 +1485,7 @@ impl<'a> Resolver<'a> {\n                 .collect(),\n             main_def: self.main_def.clone(),\n             trait_impls: self.trait_impls.clone(),\n+            proc_macros,\n         }\n     }\n "}, {"sha": "6dc3aa0888a8be605c2e114ecb6555cdd3db28a4", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8efe5d8222db70964f46b6523be81d6e7c38e65/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8efe5d8222db70964f46b6523be81d6e7c38e65/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=f8efe5d8222db70964f46b6523be81d6e7c38e65", "patch": "@@ -466,6 +466,10 @@ impl<'a> ResolverExpand for Resolver<'a> {\n     fn get_proc_macro_quoted_span(&self, krate: CrateNum, id: usize) -> Span {\n         self.crate_loader.cstore().get_proc_macro_quoted_span_untracked(krate, id, self.session)\n     }\n+\n+    fn declare_proc_macro(&mut self, id: NodeId) {\n+        self.proc_macros.push(id)\n+    }\n }\n \n impl<'a> Resolver<'a> {"}]}