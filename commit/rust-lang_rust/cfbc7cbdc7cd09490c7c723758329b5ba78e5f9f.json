{"sha": "cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmYmM3Y2JkYzdjZDA5NDkwYzdjNzIzNzU4MzI5YjViYTc4ZTVmOWY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-28T18:11:15Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-28T21:33:18Z"}, "message": "Convert core::pipes to camel case", "tree": {"sha": "404292a41b0f966a85bfe123a97487a8c8ef9626", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/404292a41b0f966a85bfe123a97487a8c8ef9626"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "html_url": "https://github.com/rust-lang/rust/commit/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9b7ce6f57e8ca74dfdb16ba91fcae38d2c44798", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9b7ce6f57e8ca74dfdb16ba91fcae38d2c44798", "html_url": "https://github.com/rust-lang/rust/commit/e9b7ce6f57e8ca74dfdb16ba91fcae38d2c44798"}], "stats": {"total": 554, "additions": 318, "deletions": 236}, "files": [{"sha": "b8714bef53da5e4d0e00422a2e66c6b311c9e4c1", "filename": "doc/tutorial.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -2966,7 +2966,7 @@ computations in parallel.  We might write something like:\n \n ~~~~\n import task::spawn;\n-import pipes::{stream, port, chan};\n+import pipes::{stream, Port, Chan};\n \n let (chan, port) = stream();\n \n@@ -3016,7 +3016,7 @@ some other expensive computation and then waiting for the child's result\n to arrive on the port:\n \n ~~~~\n-# import pipes::{stream, port, chan};\n+# import pipes::{stream, Port, Chan};\n # fn some_other_expensive_computation() {}\n # let (chan, port) = stream::<int>();\n # chan.send(0);\n@@ -3038,7 +3038,7 @@ Here is the function that implements the child task:\n \n ~~~~\n # import std::comm::DuplexStream;\n-# import pipes::{port, chan};\n+# import pipes::{Port, Chan};\n fn stringifier(channel: DuplexStream<~str, uint>) {\n     let mut value: uint;\n     loop {\n@@ -3061,7 +3061,7 @@ Here is the code for the parent task:\n \n ~~~~\n # import std::comm::DuplexStream;\n-# import pipes::{port, chan};\n+# import pipes::{Port, Chan};\n # import task::spawn;\n # fn stringifier(channel: DuplexStream<~str, uint>) {\n #     let mut value: uint;"}, {"sha": "388baace4400f566b89a1669b7abc17258a3e102", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -241,6 +241,7 @@ mod comm;\n mod task;\n //#[warn(non_camel_ase_types)] pipec code continues to trip this warning\n mod future;\n+#[warn(non_camel_case_types)]\n mod pipes;\n \n // Runtime and language-primitive support"}, {"sha": "81386712457577f95a0b68385f0ed850972cb6f4", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 232, "deletions": 165, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -82,24 +82,32 @@ import option::unwrap;\n \n // Things used by code generated by the pipe compiler.\n export entangle, get_buffer, drop_buffer;\n-export send_packet_buffered, recv_packet_buffered;\n-export packet, mk_packet, entangle_buffer, has_buffer, buffer_header;\n+export SendPacketBuffered, RecvPacketBuffered;\n+export Packet, packet, mk_packet, entangle_buffer, HasBuffer, BufferHeader;\n \n // export these so we can find them in the buffer_resource\n // destructor. This is probably a symptom of #3005.\n export atomic_add_acq, atomic_sub_rel;\n \n // User-level things\n-export send_packet, recv_packet, send, recv, try_recv, peek;\n+export SendPacket, RecvPacket, send, recv, try_recv, peek;\n export select, select2, selecti, select2i, selectable;\n export spawn_service, spawn_service_recv;\n-export stream, port, chan, SharedChan, PortSet, channel;\n-export oneshot, chan_one, port_one;\n+export stream, Port, Chan, SharedChan, PortSet, Channel;\n+export oneshot, ChanOne, PortOne;\n export recv_one, try_recv_one, send_one, try_send_one;\n \n // Functions used by the protocol compiler\n export rt;\n \n+// XXX remove me\n+#[cfg(stage0)]\n+export has_buffer, buffer_header, packet;\n+#[cfg(stage0)]\n+export recv_packet_buffered, send_packet_buffered;\n+#[cfg(stage0)]\n+export send_packet, recv_packet, buffer_header;\n+\n #[doc(hidden)]\n const SPIN_COUNT: uint = 0;\n \n@@ -108,14 +116,14 @@ macro_rules! move_it (\n )\n \n #[doc(hidden)]\n-enum state {\n-    empty,\n-    full,\n-    blocked,\n-    terminated\n+enum State {\n+    Empty,\n+    Full,\n+    Blocked,\n+    Terminated\n }\n \n-struct buffer_header {\n+struct BufferHeader {\n     // Tracks whether this buffer needs to be freed. We can probably\n     // get away with restricting it to 0 or 1, if we're careful.\n     let mut ref_count: int;\n@@ -126,89 +134,113 @@ struct buffer_header {\n     // thing along.\n }\n \n+// XXX remove me\n+#[cfg(stage0)]\n+fn buffer_header() -> BufferHeader { BufferHeader() }\n+\n // This is for protocols to associate extra data to thread around.\n #[doc(hidden)]\n-type buffer<T: send> = {\n-    header: buffer_header,\n+type Buffer<T: send> = {\n+    header: BufferHeader,\n     data: T,\n };\n \n-struct packet_header {\n-    let mut state: state;\n+struct PacketHeader {\n+    let mut state: State;\n     let mut blocked_task: *rust_task;\n \n     // This is a reinterpret_cast of a ~buffer, that can also be cast\n     // to a buffer_header if need be.\n     let mut buffer: *libc::c_void;\n \n     new() {\n-        self.state = empty;\n+        self.state = Empty;\n         self.blocked_task = ptr::null();\n         self.buffer = ptr::null();\n     }\n \n     // Returns the old state.\n-    unsafe fn mark_blocked(this: *rust_task) -> state {\n+    unsafe fn mark_blocked(this: *rust_task) -> State {\n         rustrt::rust_task_ref(this);\n         let old_task = swap_task(&mut self.blocked_task, this);\n         assert old_task.is_null();\n-        swap_state_acq(&mut self.state, blocked)\n+        swap_state_acq(&mut self.state, Blocked)\n     }\n \n     unsafe fn unblock() {\n         let old_task = swap_task(&mut self.blocked_task, ptr::null());\n         if !old_task.is_null() { rustrt::rust_task_deref(old_task) }\n-        match swap_state_acq(&mut self.state, empty) {\n-          empty | blocked => (),\n-          terminated => self.state = terminated,\n-          full => self.state = full\n+        match swap_state_acq(&mut self.state, Empty) {\n+          Empty | Blocked => (),\n+          Terminated => self.state = Terminated,\n+          Full => self.state = Full\n         }\n     }\n \n     // unsafe because this can do weird things to the space/time\n     // continuum. It ends making multiple unique pointers to the same\n     // thing. You'll proobably want to forget them when you're done.\n-    unsafe fn buf_header() -> ~buffer_header {\n+    unsafe fn buf_header() -> ~BufferHeader {\n         assert self.buffer.is_not_null();\n         reinterpret_cast(self.buffer)\n     }\n \n-    fn set_buffer<T: send>(b: ~buffer<T>) unsafe {\n+    fn set_buffer<T: send>(b: ~Buffer<T>) unsafe {\n         self.buffer = reinterpret_cast(b);\n     }\n }\n \n #[doc(hidden)]\n-type packet<T: send> = {\n-    header: packet_header,\n+type Packet<T: send> = {\n+    header: PacketHeader,\n     mut payload: Option<T>,\n };\n \n+// XXX remove me\n+#[cfg(stage0)]\n+#[allow(non_camel_case_types)]\n+type packet<T: send> = Packet<T>;\n+\n+#[doc(hidden)]\n+trait HasBuffer {\n+    // XXX This should not have a trailing underscore\n+    fn set_buffer_(b: *libc::c_void);\n+}\n+\n+impl<T: send> Packet<T>: HasBuffer {\n+    fn set_buffer_(b: *libc::c_void) {\n+        self.header.buffer = b;\n+    }\n+}\n+\n+#[cfg(stage0)] // XXX remove me\n #[doc(hidden)]\n+#[allow(non_camel_case_types)]\n trait has_buffer {\n     fn set_buffer(b: *libc::c_void);\n }\n \n+#[cfg(stage0)] // XXX remove me\n impl<T: send> packet<T>: has_buffer {\n     fn set_buffer(b: *libc::c_void) {\n         self.header.buffer = b;\n     }\n }\n \n #[doc(hidden)]\n-fn mk_packet<T: send>() -> packet<T> {\n+fn mk_packet<T: send>() -> Packet<T> {\n     {\n-        header: packet_header(),\n+        header: PacketHeader(),\n         mut payload: None\n     }\n }\n \n #[doc(hidden)]\n-fn unibuffer<T: send>() -> ~buffer<packet<T>> {\n+fn unibuffer<T: send>() -> ~Buffer<Packet<T>> {\n     let b = ~{\n-        header: buffer_header(),\n+        header: BufferHeader(),\n         data: {\n-            header: packet_header(),\n+            header: PacketHeader(),\n             mut payload: None,\n         }\n     };\n@@ -221,7 +253,7 @@ fn unibuffer<T: send>() -> ~buffer<packet<T>> {\n }\n \n #[doc(hidden)]\n-fn packet<T: send>() -> *packet<T> {\n+fn packet<T: send>() -> *Packet<T> {\n     let b = unibuffer();\n     let p = ptr::addr_of(b.data);\n     // We'll take over memory management from here.\n@@ -231,13 +263,13 @@ fn packet<T: send>() -> *packet<T> {\n \n #[doc(hidden)]\n fn entangle_buffer<T: send, Tstart: send>(\n-    +buffer: ~buffer<T>,\n-    init: fn(*libc::c_void, x: &T) -> *packet<Tstart>)\n-    -> (send_packet_buffered<Tstart, T>, recv_packet_buffered<Tstart, T>)\n+    +buffer: ~Buffer<T>,\n+    init: fn(*libc::c_void, x: &T) -> *Packet<Tstart>)\n+    -> (SendPacketBuffered<Tstart, T>, RecvPacketBuffered<Tstart, T>)\n {\n     let p = init(unsafe { reinterpret_cast(buffer) }, &buffer.data);\n     unsafe { forget(buffer) }\n-    (send_packet_buffered(p), recv_packet_buffered(p))\n+    (SendPacketBuffered(p), RecvPacketBuffered(p))\n }\n \n #[abi = \"rust-intrinsic\"]\n@@ -278,6 +310,7 @@ fn swap_task(+dst: &mut *rust_task, src: *rust_task) -> *rust_task {\n }\n \n #[doc(hidden)]\n+#[allow(non_camel_case_types)]\n type rust_task = libc::c_void;\n \n #[doc(hidden)]\n@@ -307,28 +340,28 @@ fn wait_event(this: *rust_task) -> *libc::c_void {\n }\n \n #[doc(hidden)]\n-fn swap_state_acq(+dst: &mut state, src: state) -> state {\n+fn swap_state_acq(+dst: &mut State, src: State) -> State {\n     unsafe {\n         transmute(rusti::atomic_xchg_acq(transmute(dst), src as int))\n     }\n }\n \n #[doc(hidden)]\n-fn swap_state_rel(+dst: &mut state, src: state) -> state {\n+fn swap_state_rel(+dst: &mut State, src: State) -> State {\n     unsafe {\n         transmute(rusti::atomic_xchg_rel(transmute(dst), src as int))\n     }\n }\n \n #[doc(hidden)]\n-unsafe fn get_buffer<T: send>(p: *packet_header) -> ~buffer<T> {\n+unsafe fn get_buffer<T: send>(p: *PacketHeader) -> ~Buffer<T> {\n     transmute((*p).buf_header())\n }\n \n // This could probably be done with SharedMutableState to avoid move_it!().\n-struct buffer_resource<T: send> {\n-    let buffer: ~buffer<T>;\n-    new(+b: ~buffer<T>) {\n+struct BufferResource<T: send> {\n+    let buffer: ~Buffer<T>;\n+    new(+b: ~Buffer<T>) {\n         //let p = ptr::addr_of(*b);\n         //error!(\"take %?\", p);\n         atomic_add_acq(&mut b.header.ref_count, 1);\n@@ -353,25 +386,25 @@ struct buffer_resource<T: send> {\n }\n \n #[doc(hidden)]\n-fn send<T: send, Tbuffer: send>(+p: send_packet_buffered<T, Tbuffer>,\n+fn send<T: send, Tbuffer: send>(+p: SendPacketBuffered<T, Tbuffer>,\n                                 +payload: T) -> bool {\n     let header = p.header();\n     let p_ = p.unwrap();\n     let p = unsafe { &*p_ };\n     assert ptr::addr_of(p.header) == header;\n     assert p.payload.is_none();\n     p.payload <- Some(payload);\n-    let old_state = swap_state_rel(&mut p.header.state, full);\n+    let old_state = swap_state_rel(&mut p.header.state, Full);\n     match old_state {\n-        empty => {\n+        Empty => {\n             // Yay, fastpath.\n \n             // The receiver will eventually clean this up.\n             //unsafe { forget(p); }\n             return true;\n         }\n-        full => fail ~\"duplicate send\",\n-        blocked => {\n+        Full => fail ~\"duplicate send\",\n+        Blocked => {\n             debug!(\"waking up task for %?\", p_);\n             let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n             if !old_task.is_null() {\n@@ -384,7 +417,7 @@ fn send<T: send, Tbuffer: send>(+p: send_packet_buffered<T, Tbuffer>,\n             //unsafe { forget(p); }\n             return true;\n         }\n-        terminated => {\n+        Terminated => {\n             // The receiver will never receive this. Rely on drop_glue\n             // to clean everything up.\n             return false;\n@@ -397,7 +430,7 @@ fn send<T: send, Tbuffer: send>(+p: send_packet_buffered<T, Tbuffer>,\n Fails if the sender closes the connection.\n \n */\n-fn recv<T: send, Tbuffer: send>(+p: recv_packet_buffered<T, Tbuffer>) -> T {\n+fn recv<T: send, Tbuffer: send>(+p: RecvPacketBuffered<T, Tbuffer>) -> T {\n     option::unwrap_expect(try_recv(p), \"connection closed\")\n }\n \n@@ -407,18 +440,18 @@ Returns `none` if the sender has closed the connection without sending\n a message, or `Some(T)` if a message was received.\n \n */\n-fn try_recv<T: send, Tbuffer: send>(+p: recv_packet_buffered<T, Tbuffer>)\n+fn try_recv<T: send, Tbuffer: send>(+p: RecvPacketBuffered<T, Tbuffer>)\n     -> Option<T>\n {\n     let p_ = p.unwrap();\n     let p = unsafe { &*p_ };\n \n-    struct drop_state {\n-        p: &packet_header;\n+    struct DropState {\n+        p: &PacketHeader;\n \n         drop {\n             if task::failing() {\n-                self.p.state = terminated;\n+                self.p.state = Terminated;\n                 let old_task = swap_task(&mut self.p.blocked_task,\n                                          ptr::null());\n                 if !old_task.is_null() {\n@@ -428,17 +461,17 @@ fn try_recv<T: send, Tbuffer: send>(+p: recv_packet_buffered<T, Tbuffer>)\n         }\n     };\n \n-    let _drop_state = drop_state { p: &p.header };\n+    let _drop_state = DropState { p: &p.header };\n \n     // optimistic path\n     match p.header.state {\n-      full => {\n+      Full => {\n         let mut payload = None;\n         payload <-> p.payload;\n-        p.header.state = empty;\n+        p.header.state = Empty;\n         return Some(option::unwrap(payload))\n       },\n-      terminated => return None,\n+      Terminated => return None,\n       _ => {}\n     }\n \n@@ -453,9 +486,9 @@ fn try_recv<T: send, Tbuffer: send>(+p: recv_packet_buffered<T, Tbuffer>)\n     loop {\n         rustrt::task_clear_event_reject(this);\n         let old_state = swap_state_acq(&mut p.header.state,\n-                                       blocked);\n+                                       Blocked);\n         match old_state {\n-          empty => {\n+          Empty => {\n             debug!(\"no data available on %?, going to sleep.\", p_);\n             if count == 0 {\n                 wait_event(this);\n@@ -471,23 +504,23 @@ fn try_recv<T: send, Tbuffer: send>(+p: recv_packet_buffered<T, Tbuffer>)\n             }\n             debug!(\"woke up, p.state = %?\", copy p.header.state);\n           }\n-          blocked => if first {\n+          Blocked => if first {\n             fail ~\"blocking on already blocked packet\"\n           },\n-          full => {\n+          Full => {\n             let mut payload = None;\n             payload <-> p.payload;\n             let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n             if !old_task.is_null() {\n                 rustrt::rust_task_deref(old_task);\n             }\n-            p.header.state = empty;\n+            p.header.state = Empty;\n             return Some(option::unwrap(payload))\n           }\n-          terminated => {\n+          Terminated => {\n             // This assert detects when we've accidentally unsafely\n             // casted too big of a number to a state.\n-            assert old_state == terminated;\n+            assert old_state == Terminated;\n \n             let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n             if !old_task.is_null() {\n@@ -501,28 +534,28 @@ fn try_recv<T: send, Tbuffer: send>(+p: recv_packet_buffered<T, Tbuffer>)\n }\n \n /// Returns true if messages are available.\n-pure fn peek<T: send, Tb: send>(p: &recv_packet_buffered<T, Tb>) -> bool {\n+pure fn peek<T: send, Tb: send>(p: &RecvPacketBuffered<T, Tb>) -> bool {\n     match unsafe {(*p.header()).state} {\n-      empty => false,\n-      blocked => fail ~\"peeking on blocked packet\",\n-      full | terminated => true\n+      Empty => false,\n+      Blocked => fail ~\"peeking on blocked packet\",\n+      Full | Terminated => true\n     }\n }\n \n-impl<T: send, Tb: send> recv_packet_buffered<T, Tb> {\n+impl<T: send, Tb: send> RecvPacketBuffered<T, Tb> {\n     pure fn peek() -> bool {\n         peek(&self)\n     }\n }\n \n #[doc(hidden)]\n-fn sender_terminate<T: send>(p: *packet<T>) {\n+fn sender_terminate<T: send>(p: *Packet<T>) {\n     let p = unsafe { &*p };\n-    match swap_state_rel(&mut p.header.state, terminated) {\n-      empty => {\n+    match swap_state_rel(&mut p.header.state, Terminated) {\n+      Empty => {\n         // The receiver will eventually clean up.\n       }\n-      blocked => {\n+      Blocked => {\n         // wake up the target\n         let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n         if !old_task.is_null() {\n@@ -533,33 +566,33 @@ fn sender_terminate<T: send>(p: *packet<T>) {\n         }\n         // The receiver will eventually clean up.\n       }\n-      full => {\n+      Full => {\n         // This is impossible\n         fail ~\"you dun goofed\"\n       }\n-      terminated => {\n+      Terminated => {\n         assert p.header.blocked_task.is_null();\n         // I have to clean up, use drop_glue\n       }\n     }\n }\n \n #[doc(hidden)]\n-fn receiver_terminate<T: send>(p: *packet<T>) {\n+fn receiver_terminate<T: send>(p: *Packet<T>) {\n     let p = unsafe { &*p };\n-    match swap_state_rel(&mut p.header.state, terminated) {\n-      empty => {\n+    match swap_state_rel(&mut p.header.state, Terminated) {\n+      Empty => {\n         assert p.header.blocked_task.is_null();\n         // the sender will clean up\n       }\n-      blocked => {\n+      Blocked => {\n         let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n         if !old_task.is_null() {\n             rustrt::rust_task_deref(old_task);\n             assert old_task == rustrt::rust_get_task();\n         }\n       }\n-      terminated | full => {\n+      Terminated | Full => {\n         assert p.header.blocked_task.is_null();\n         // I have to clean up, use drop_glue\n       }\n@@ -576,7 +609,7 @@ that vector. The index points to an endpoint that has either been\n closed by the sender or has a message waiting to be received.\n \n */\n-fn wait_many<T: selectable>(pkts: &[T]) -> uint {\n+fn wait_many<T: Selectable>(pkts: &[T]) -> uint {\n     let this = rustrt::rust_get_task();\n \n     rustrt::task_clear_event_reject(this);\n@@ -586,20 +619,20 @@ fn wait_many<T: selectable>(pkts: &[T]) -> uint {\n         let p = unsafe { &*p.header() };\n         let old = p.mark_blocked(this);\n         match old {\n-          full | terminated => {\n+          Full | Terminated => {\n             data_avail = true;\n             ready_packet = i;\n             (*p).state = old;\n             break;\n           }\n-          blocked => fail ~\"blocking on blocked packet\",\n-          empty => ()\n+          Blocked => fail ~\"blocking on blocked packet\",\n+          Empty => ()\n         }\n     }\n \n     while !data_avail {\n         debug!(\"sleeping on %? packets\", pkts.len());\n-        let event = wait_event(this) as *packet_header;\n+        let event = wait_event(this) as *PacketHeader;\n         let pos = vec::position(pkts, |p| p.header() == event);\n \n         match pos {\n@@ -618,8 +651,8 @@ fn wait_many<T: selectable>(pkts: &[T]) -> uint {\n     debug!(\"%?, %?\", ready_packet, pkts[ready_packet]);\n \n     unsafe {\n-        assert (*pkts[ready_packet].header()).state == full\n-            || (*pkts[ready_packet].header()).state == terminated;\n+        assert (*pkts[ready_packet].header()).state == Full\n+            || (*pkts[ready_packet].header()).state == Terminated;\n     }\n \n     ready_packet\n@@ -654,10 +687,10 @@ this case, `select2` may return either `left` or `right`.\n \n */\n fn select2<A: send, Ab: send, B: send, Bb: send>(\n-    +a: recv_packet_buffered<A, Ab>,\n-    +b: recv_packet_buffered<B, Bb>)\n-    -> Either<(Option<A>, recv_packet_buffered<B, Bb>),\n-              (recv_packet_buffered<A, Ab>, Option<B>)>\n+    +a: RecvPacketBuffered<A, Ab>,\n+    +b: RecvPacketBuffered<B, Bb>)\n+    -> Either<(Option<A>, RecvPacketBuffered<B, Bb>),\n+              (RecvPacketBuffered<A, Ab>, Option<B>)>\n {\n     let i = wait_many([a.header(), b.header()]/_);\n \n@@ -669,21 +702,21 @@ fn select2<A: send, Ab: send, B: send, Bb: send>(\n }\n \n #[doc(hidden)]\n-trait selectable {\n-    pure fn header() -> *packet_header;\n+trait Selectable {\n+    pure fn header() -> *PacketHeader;\n }\n \n-impl *packet_header: selectable {\n-    pure fn header() -> *packet_header { self }\n+impl *PacketHeader: Selectable {\n+    pure fn header() -> *PacketHeader { self }\n }\n \n /// Returns the index of an endpoint that is ready to receive.\n-fn selecti<T: selectable>(endpoints: &[T]) -> uint {\n+fn selecti<T: Selectable>(endpoints: &[T]) -> uint {\n     wait_many(endpoints)\n }\n \n /// Returns 0 or 1 depending on which endpoint is ready to receive\n-fn select2i<A: selectable, B: selectable>(a: &A, b: &B) -> Either<(), ()> {\n+fn select2i<A: Selectable, B: Selectable>(a: &A, b: &B) -> Either<(), ()> {\n     match wait_many([a.header(), b.header()]/_) {\n       0 => Left(()),\n       1 => Right(()),\n@@ -695,8 +728,8 @@ fn select2i<A: selectable, B: selectable>(a: &A, b: &B) -> Either<(), ()> {\n  list of the remaining endpoints.\n \n */\n-fn select<T: send, Tb: send>(+endpoints: ~[recv_packet_buffered<T, Tb>])\n-    -> (uint, Option<T>, ~[recv_packet_buffered<T, Tb>])\n+fn select<T: send, Tb: send>(+endpoints: ~[RecvPacketBuffered<T, Tb>])\n+    -> (uint, Option<T>, ~[RecvPacketBuffered<T, Tb>])\n {\n     let ready = wait_many(endpoints.map(|p| p.header()));\n     let mut remaining = endpoints;\n@@ -709,22 +742,33 @@ fn select<T: send, Tb: send>(+endpoints: ~[recv_packet_buffered<T, Tb>])\n message.\n \n */\n-type send_packet<T: send> = send_packet_buffered<T, packet<T>>;\n+type SendPacket<T: send> = SendPacketBuffered<T, Packet<T>>;\n \n #[doc(hidden)]\n-fn send_packet<T: send>(p: *packet<T>) -> send_packet<T> {\n-    send_packet_buffered(p)\n+fn SendPacket<T: send>(p: *Packet<T>) -> SendPacket<T> {\n+    SendPacketBuffered(p)\n }\n \n-struct send_packet_buffered<T: send, Tbuffer: send> {\n-    let mut p: Option<*packet<T>>;\n-    let mut buffer: Option<buffer_resource<Tbuffer>>;\n-    new(p: *packet<T>) {\n+// XXX remove me\n+#[cfg(stage0)]\n+#[allow(non_camel_case_types)]\n+type send_packet<T: send> = SendPacket<T>;\n+\n+// XXX remove me\n+#[cfg(stage0)]\n+fn send_packet<T: send>(p: *packet<T>) -> SendPacket<T> {\n+    SendPacket(p)\n+}\n+\n+struct SendPacketBuffered<T: send, Tbuffer: send> {\n+    let mut p: Option<*Packet<T>>;\n+    let mut buffer: Option<BufferResource<Tbuffer>>;\n+    new(p: *Packet<T>) {\n         //debug!(\"take send %?\", p);\n         self.p = Some(p);\n         unsafe {\n             self.buffer = Some(\n-                buffer_resource(\n+                BufferResource(\n                     get_buffer(ptr::addr_of((*p).header))));\n         };\n     }\n@@ -742,13 +786,13 @@ struct send_packet_buffered<T: send, Tbuffer: send> {\n         //                    \"none\"\n         //                } else { \"some\" }); }\n     }\n-    fn unwrap() -> *packet<T> {\n+    fn unwrap() -> *Packet<T> {\n         let mut p = None;\n         p <-> self.p;\n         option::unwrap(p)\n     }\n \n-    pure fn header() -> *packet_header {\n+    pure fn header() -> *PacketHeader {\n         match self.p {\n           Some(packet) => unsafe {\n             let packet = &*packet;\n@@ -760,32 +804,49 @@ struct send_packet_buffered<T: send, Tbuffer: send> {\n         }\n     }\n \n-    fn reuse_buffer() -> buffer_resource<Tbuffer> {\n+    fn reuse_buffer() -> BufferResource<Tbuffer> {\n         //error!(\"send reuse_buffer\");\n         let mut tmp = None;\n         tmp <-> self.buffer;\n         option::unwrap(tmp)\n     }\n }\n \n+// XXX remove me\n+#[cfg(stage0)]\n+#[allow(non_camel_case_types)]\n+type send_packet_buffered<T: send, Tbuffer: send> =\n+    SendPacketBuffered<T, Tbuffer>;\n+\n /// Represents the receive end of a pipe. It can receive exactly one\n /// message.\n-type recv_packet<T: send> = recv_packet_buffered<T, packet<T>>;\n+type RecvPacket<T: send> = RecvPacketBuffered<T, Packet<T>>;\n \n #[doc(hidden)]\n-fn recv_packet<T: send>(p: *packet<T>) -> recv_packet<T> {\n-    recv_packet_buffered(p)\n+fn RecvPacket<T: send>(p: *Packet<T>) -> RecvPacket<T> {\n+    RecvPacketBuffered(p)\n }\n \n-struct recv_packet_buffered<T: send, Tbuffer: send> : selectable {\n-    let mut p: Option<*packet<T>>;\n-    let mut buffer: Option<buffer_resource<Tbuffer>>;\n-    new(p: *packet<T>) {\n+// XXX remove me\n+#[cfg(stage0)]\n+#[allow(non_camel_case_types)]\n+type recv_packet<T: send> = RecvPacket<T>;\n+\n+// XXX remove me\n+#[cfg(stage0)]\n+fn recv_packet<T: send>(p: *packet<T>) -> RecvPacket<T> {\n+    RecvPacket(p)\n+}\n+\n+struct RecvPacketBuffered<T: send, Tbuffer: send> : Selectable {\n+    let mut p: Option<*Packet<T>>;\n+    let mut buffer: Option<BufferResource<Tbuffer>>;\n+    new(p: *Packet<T>) {\n         //debug!(\"take recv %?\", p);\n         self.p = Some(p);\n         unsafe {\n             self.buffer = Some(\n-                buffer_resource(\n+                BufferResource(\n                     get_buffer(ptr::addr_of((*p).header))));\n         };\n     }\n@@ -803,13 +864,13 @@ struct recv_packet_buffered<T: send, Tbuffer: send> : selectable {\n         //                    \"none\"\n         //                } else { \"some\" }); }\n     }\n-    fn unwrap() -> *packet<T> {\n+    fn unwrap() -> *Packet<T> {\n         let mut p = None;\n         p <-> self.p;\n         option::unwrap(p)\n     }\n \n-    pure fn header() -> *packet_header {\n+    pure fn header() -> *PacketHeader {\n         match self.p {\n           Some(packet) => unsafe {\n             let packet = &*packet;\n@@ -821,18 +882,24 @@ struct recv_packet_buffered<T: send, Tbuffer: send> : selectable {\n         }\n     }\n \n-    fn reuse_buffer() -> buffer_resource<Tbuffer> {\n+    fn reuse_buffer() -> BufferResource<Tbuffer> {\n         //error!(\"recv reuse_buffer\");\n         let mut tmp = None;\n         tmp <-> self.buffer;\n         option::unwrap(tmp)\n     }\n }\n \n+// XXX remove me\n+#[cfg(stage0)]\n+#[allow(non_camel_case_types)]\n+type recv_packet_buffered<T: send, Tbuffer: send> =\n+    RecvPacketBuffered<T, Tbuffer>;\n+\n #[doc(hidden)]\n-fn entangle<T: send>() -> (send_packet<T>, recv_packet<T>) {\n+fn entangle<T: send>() -> (SendPacket<T>, RecvPacket<T>) {\n     let p = packet();\n-    (send_packet(p), recv_packet(p))\n+    (SendPacket(p), RecvPacket(p))\n }\n \n /** Spawn a task to provide a service.\n@@ -843,10 +910,10 @@ endpoint is passed to the new task.\n \n */\n fn spawn_service<T: send, Tb: send>(\n-    init: extern fn() -> (send_packet_buffered<T, Tb>,\n-                          recv_packet_buffered<T, Tb>),\n-    +service: fn~(+recv_packet_buffered<T, Tb>))\n-    -> send_packet_buffered<T, Tb>\n+    init: extern fn() -> (SendPacketBuffered<T, Tb>,\n+                          RecvPacketBuffered<T, Tb>),\n+    +service: fn~(+RecvPacketBuffered<T, Tb>))\n+    -> SendPacketBuffered<T, Tb>\n {\n     let (client, server) = init();\n \n@@ -867,10 +934,10 @@ receive state.\n \n */\n fn spawn_service_recv<T: send, Tb: send>(\n-    init: extern fn() -> (recv_packet_buffered<T, Tb>,\n-                          send_packet_buffered<T, Tb>),\n-    +service: fn~(+send_packet_buffered<T, Tb>))\n-    -> recv_packet_buffered<T, Tb>\n+    init: extern fn() -> (RecvPacketBuffered<T, Tb>,\n+                          SendPacketBuffered<T, Tb>),\n+    +service: fn~(+SendPacketBuffered<T, Tb>))\n+    -> RecvPacketBuffered<T, Tb>\n {\n     let (client, server) = init();\n \n@@ -889,13 +956,13 @@ fn spawn_service_recv<T: send, Tb: send>(\n // Streams - Make pipes a little easier in general.\n \n proto! streamp (\n-    open:send<T: send> {\n-        data(T) -> open<T>\n+    Open:send<T: send> {\n+        data(T) -> Open<T>\n     }\n )\n \n /// A trait for things that can send multiple messages.\n-trait channel<T: send> {\n+trait Channel<T: send> {\n     // It'd be nice to call this send, but it'd conflict with the\n     // built in send kind.\n \n@@ -907,7 +974,7 @@ trait channel<T: send> {\n }\n \n /// A trait for things that can receive multiple messages.\n-trait recv<T: send> {\n+trait Recv<T: send> {\n     /// Receives a message, or fails if the connection closes.\n     fn recv() -> T;\n \n@@ -925,33 +992,33 @@ trait recv<T: send> {\n }\n \n #[doc(hidden)]\n-type chan_<T:send> = { mut endp: Option<streamp::client::open<T>> };\n+type Chan_<T:send> = { mut endp: Option<streamp::client::Open<T>> };\n \n /// An endpoint that can send many messages.\n-enum chan<T:send> {\n-    chan_(chan_<T>)\n+enum Chan<T:send> {\n+    Chan_(Chan_<T>)\n }\n \n #[doc(hidden)]\n-type port_<T:send> = { mut endp: Option<streamp::server::open<T>> };\n+type Port_<T:send> = { mut endp: Option<streamp::server::Open<T>> };\n \n /// An endpoint that can receive many messages.\n-enum port<T:send> {\n-    port_(port_<T>)\n+enum Port<T:send> {\n+    Port_(Port_<T>)\n }\n \n /** Creates a `(chan, port)` pair.\n \n These allow sending or receiving an unlimited number of messages.\n \n */\n-fn stream<T:send>() -> (chan<T>, port<T>) {\n+fn stream<T:send>() -> (Chan<T>, Port<T>) {\n     let (c, s) = streamp::init();\n \n-    (chan_({ mut endp: Some(c) }), port_({ mut endp: Some(s) }))\n+    (Chan_({ mut endp: Some(c) }), Port_({ mut endp: Some(s) }))\n }\n \n-impl<T: send> chan<T>: channel<T> {\n+impl<T: send> Chan<T>: Channel<T> {\n     fn send(+x: T) {\n         let mut endp = None;\n         endp <-> self.endp;\n@@ -972,7 +1039,7 @@ impl<T: send> chan<T>: channel<T> {\n     }\n }\n \n-impl<T: send> port<T>: recv<T> {\n+impl<T: send> Port<T>: Recv<T> {\n     fn recv() -> T {\n         let mut endp = None;\n         endp <-> self.endp;\n@@ -1006,16 +1073,16 @@ impl<T: send> port<T>: recv<T> {\n }\n \n /// Treat many ports as one.\n-struct PortSet<T: send> : recv<T> {\n-    let mut ports: ~[pipes::port<T>];\n+struct PortSet<T: send> : Recv<T> {\n+    let mut ports: ~[pipes::Port<T>];\n \n     new() { self.ports = ~[]; }\n \n-    fn add(+port: pipes::port<T>) {\n+    fn add(+port: pipes::Port<T>) {\n         vec::push(self.ports, port)\n     }\n \n-    fn chan() -> chan<T> {\n+    fn chan() -> Chan<T> {\n         let (ch, po) = stream();\n         self.add(po);\n         ch\n@@ -1057,8 +1124,8 @@ struct PortSet<T: send> : recv<T> {\n     }\n }\n \n-impl<T: send> port<T>: selectable {\n-    pure fn header() -> *packet_header unchecked {\n+impl<T: send> Port<T>: Selectable {\n+    pure fn header() -> *PacketHeader unchecked {\n         match self.endp {\n           Some(endp) => endp.header(),\n           None => fail ~\"peeking empty stream\"\n@@ -1067,9 +1134,9 @@ impl<T: send> port<T>: selectable {\n }\n \n /// A channel that can be shared between many senders.\n-type SharedChan<T: send> = unsafe::Exclusive<chan<T>>;\n+type SharedChan<T: send> = unsafe::Exclusive<Chan<T>>;\n \n-impl<T: send> SharedChan<T>: channel<T> {\n+impl<T: send> SharedChan<T>: Channel<T> {\n     fn send(+x: T) {\n         let mut xx = Some(x);\n         do self.with |chan| {\n@@ -1090,20 +1157,20 @@ impl<T: send> SharedChan<T>: channel<T> {\n }\n \n /// Converts a `chan` into a `shared_chan`.\n-fn SharedChan<T:send>(+c: chan<T>) -> SharedChan<T> {\n+fn SharedChan<T:send>(+c: Chan<T>) -> SharedChan<T> {\n     unsafe::exclusive(c)\n }\n \n /// Receive a message from one of two endpoints.\n-trait select2<T: send, U: send> {\n+trait Select2<T: send, U: send> {\n     /// Receive a message or return `none` if a connection closes.\n     fn try_select() -> Either<Option<T>, Option<U>>;\n     /// Receive a message or fail if a connection closes.\n     fn select() -> Either<T, U>;\n }\n \n-impl<T: send, U: send, Left: selectable recv<T>, Right: selectable recv<U>>\n-    (Left, Right): select2<T, U> {\n+impl<T: send, U: send, Left: Selectable Recv<T>, Right: Selectable Recv<U>>\n+    (Left, Right): Select2<T, U> {\n \n     fn select() -> Either<T, U> {\n         match self {\n@@ -1125,32 +1192,32 @@ impl<T: send, U: send, Left: selectable recv<T>, Right: selectable recv<U>>\n }\n \n proto! oneshot (\n-    oneshot:send<T:send> {\n+    Oneshot:send<T:send> {\n         send(T) -> !\n     }\n )\n \n /// The send end of a oneshot pipe.\n-type chan_one<T: send> = oneshot::client::oneshot<T>;\n+type ChanOne<T: send> = oneshot::client::Oneshot<T>;\n /// The receive end of a oneshot pipe.\n-type port_one<T: send> = oneshot::server::oneshot<T>;\n+type PortOne<T: send> = oneshot::server::Oneshot<T>;\n \n /// Initialiase a (send-endpoint, recv-endpoint) oneshot pipe pair.\n-fn oneshot<T: send>() -> (chan_one<T>, port_one<T>) {\n+fn oneshot<T: send>() -> (ChanOne<T>, PortOne<T>) {\n     oneshot::init()\n }\n \n /**\n  * Receive a message from a oneshot pipe, failing if the connection was\n  * closed.\n  */\n-fn recv_one<T: send>(+port: port_one<T>) -> T {\n+fn recv_one<T: send>(+port: PortOne<T>) -> T {\n     let oneshot::send(message) = recv(port);\n     message\n }\n \n /// Receive a message from a oneshot pipe unless the connection was closed.\n-fn try_recv_one<T: send> (+port: port_one<T>) -> Option<T> {\n+fn try_recv_one<T: send> (+port: PortOne<T>) -> Option<T> {\n     let message = try_recv(port);\n \n     if message.is_none() { None }\n@@ -1161,15 +1228,15 @@ fn try_recv_one<T: send> (+port: port_one<T>) -> Option<T> {\n }\n \n /// Send a message on a oneshot pipe, failing if the connection was closed.\n-fn send_one<T: send>(+chan: chan_one<T>, +data: T) {\n+fn send_one<T: send>(+chan: ChanOne<T>, +data: T) {\n     oneshot::client::send(chan, data);\n }\n \n /**\n  * Send a message on a oneshot pipe, or return false if the connection was\n  * closed.\n  */\n-fn try_send_one<T: send>(+chan: chan_one<T>, +data: T)\n+fn try_send_one<T: send>(+chan: ChanOne<T>, +data: T)\n         -> bool {\n     oneshot::client::try_send(chan, data).is_some()\n }"}, {"sha": "ffebf5766511c338aaf2e8cb3b15da4beb2f634d", "filename": "src/libcore/unsafe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Flibcore%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Flibcore%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funsafe.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -83,7 +83,7 @@ unsafe fn copy_lifetime<S,T>(_ptr: &a/S, ptr: &T) -> &a/T {\n // An unwrapper uses this protocol to communicate with the \"other\" task that\n // drops the last refcount on an arc. Unfortunately this can't be a proper\n // pipe protocol because the unwrapper has to access both stages at once.\n-type UnwrapProto = ~mut Option<(pipes::chan_one<()>, pipes::port_one<bool>)>;\n+type UnwrapProto = ~mut Option<(pipes::ChanOne<()>, pipes::PortOne<bool>)>;\n \n struct ArcData<T> {\n     mut count:     libc::intptr_t;\n@@ -136,7 +136,7 @@ unsafe fn unwrap_shared_mutable_state<T: send>(+rc: SharedMutableState<T>)\n         -> T {\n     struct DeathThroes<T> {\n         mut ptr:      Option<~ArcData<T>>;\n-        mut response: Option<pipes::chan_one<bool>>;\n+        mut response: Option<pipes::ChanOne<bool>>;\n         drop unsafe {\n             let response = option::swap_unwrap(&mut self.response);\n             // In case we get killed early, we need to tell the person who"}, {"sha": "1a07fa850d5173233746f9b4ae6ac0d54ab6c194", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -11,14 +11,14 @@ Higher level communication abstractions.\n // Make sure we follow the new conventions\n #[forbid(non_camel_case_types)];\n \n-import pipes::{channel, recv, chan, port, selectable};\n+import pipes::{Channel, Recv, Chan, Port, Selectable};\n \n export DuplexStream;\n \n /// An extension of `pipes::stream` that allows both sending and receiving.\n-struct DuplexStream<T: send, U: send> : channel<T>, recv<U>, selectable {\n-    priv chan: chan<T>;\n-    priv port: port<U>;\n+struct DuplexStream<T: send, U: send> : Channel<T>, Recv<U>, Selectable {\n+    priv chan: Chan<T>;\n+    priv port: Port <U>;\n \n     fn send(+x: T) {\n         self.chan.send(x)\n@@ -40,7 +40,7 @@ struct DuplexStream<T: send, U: send> : channel<T>, recv<U>, selectable {\n         self.port.peek()\n     }\n \n-    pure fn header() -> *pipes::packet_header {\n+    pure fn header() -> *pipes::PacketHeader {\n         self.port.header()\n     }\n }"}, {"sha": "5e35454da843f592765033b0d1c5aa13b2b602aa", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -19,13 +19,13 @@ import unsafe::{Exclusive, exclusive};\n \n // Each waiting task receives on one of these.\n #[doc(hidden)]\n-type WaitEnd = pipes::port_one<()>;\n+type WaitEnd = pipes::PortOne<()>;\n #[doc(hidden)]\n-type SignalEnd = pipes::chan_one<()>;\n+type SignalEnd = pipes::ChanOne<()>;\n // A doubly-ended queue of waiting tasks.\n #[doc(hidden)]\n-struct Waitqueue { head: pipes::port<SignalEnd>;\n-                   tail: pipes::chan<SignalEnd>; }\n+struct Waitqueue { head: pipes::Port<SignalEnd>;\n+                   tail: pipes::Chan<SignalEnd>; }\n \n fn new_waitqueue() -> Waitqueue {\n     let (block_tail, block_head) = pipes::stream();\n@@ -928,8 +928,8 @@ mod tests {\n             assert woken == 0;\n         }\n         struct SendOnFailure {\n-            c: pipes::chan<()>;\n-            new(+c: pipes::chan<()>) { self.c = c; }\n+            c: pipes::Chan<()>;\n+            new(+c: pipes::Chan<()>) { self.c = c; }\n             drop { self.c.send(()); }\n         }\n     }"}, {"sha": "b346e23178e1206fad94d27dcb3f89e7b4044a03", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -4,6 +4,7 @@\n // something smarter.\n \n import ast::{ident, node_id};\n+import ast_util::respan;\n import codemap::span;\n import ext::base::mk_ctxt;\n \n@@ -209,8 +210,21 @@ impl ext_ctxt: ext_ctxt_ast_builder {\n     fn item(name: ident,\n             span: span,\n             +node: ast::item_) -> @ast::item {\n+\n+        // XXX: Would be nice if our generated code didn't violate\n+        // Rust coding conventions\n+        let non_camel_case_attribute = respan(self.empty_span(), {\n+            style: ast::attr_outer,\n+            value: respan(self.empty_span(),\n+                          ast::meta_list(~\"allow\", ~[\n+                              @respan(self.empty_span(),\n+                                      ast::meta_word(~\"non_camel_case_types\"))\n+                          ])),\n+            is_sugared_doc: false\n+        });\n+\n         @{ident: name,\n-         attrs: ~[],\n+         attrs: ~[non_camel_case_attribute],\n          id: self.next_id(),\n          node: node,\n          vis: ast::public,"}, {"sha": "44b99bc2ad5acf6752c5f9aa6fe31292586715f4", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -72,10 +72,10 @@ impl message: gen_send {\n                 };\n \n                 body += ~\"let b = pipe.reuse_buffer();\\n\";\n-                body += fmt!(\"let %s = pipes::send_packet_buffered(\\\n+                body += fmt!(\"let %s = pipes::SendPacketBuffered(\\\n                               ptr::addr_of(b.buffer.data.%s));\\n\",\n                              sp, next.name);\n-                body += fmt!(\"let %s = pipes::recv_packet_buffered(\\\n+                body += fmt!(\"let %s = pipes::RecvPacketBuffered(\\\n                               ptr::addr_of(b.buffer.data.%s));\\n\",\n                              rp, next.name);\n             }\n@@ -258,7 +258,7 @@ impl state: to_type_decls {\n                           self.span,\n                           cx.ty_path_ast_builder(\n                               path(~[cx.ident_of(~\"pipes\"),\n-                                     cx.ident_of(dir.to_str() + ~\"_packet\")],\n+                                     cx.ident_of(dir.to_str() + ~\"Packet\")],\n                                    empty_span())\n                               .add_ty(cx.ty_path_ast_builder(\n                                   path(~[cx.ident_of(self.proto.name),\n@@ -275,7 +275,7 @@ impl state: to_type_decls {\n                           cx.ty_path_ast_builder(\n                               path(~[cx.ident_of(~\"pipes\"),\n                                      cx.ident_of(dir.to_str()\n-                                                 + ~\"_packet_buffered\")],\n+                                                 + ~\"PacketBuffered\")],\n                                   empty_span())\n                               .add_tys(~[cx.ty_path_ast_builder(\n                                   path(~[cx.ident_of(self.proto.name),\n@@ -321,7 +321,7 @@ impl protocol: gen_init {\n         };\n \n         cx.parse_item(fmt!(\"fn init%s() -> (client::%s, server::%s)\\\n-                            { import pipes::has_buffer; %s }\",\n+                            { import pipes::HasBuffer; %s }\",\n                            start_state.ty_params.to_source(cx),\n                            start_state.to_ty(cx).to_source(cx),\n                            start_state.to_ty(cx).to_source(cx),\n@@ -341,15 +341,15 @@ impl protocol: gen_init {\n         let buffer_fields = self.gen_buffer_init(ext_cx);\n \n         let buffer = #ast {\n-            ~{header: pipes::buffer_header(),\n+            ~{header: pipes::BufferHeader(),\n               data: $(buffer_fields)}\n         };\n \n         let entangle_body = ext_cx.block_expr(\n             ext_cx.block(\n                 self.states.map_to_vec(\n                     |s| ext_cx.parse_stmt(\n-                        fmt!(\"data.%s.set_buffer(buffer)\",\n+                        fmt!(\"data.%s.set_buffer_(buffer)\",\n                              s.name))),\n                 ext_cx.parse_expr(\n                     fmt!(\"ptr::addr_of(data.%s)\",\n@@ -390,7 +390,7 @@ impl protocol: gen_init {\n             }\n             let ty = s.to_ty(cx);\n             let fty = #ast[ty] {\n-                pipes::packet<$(ty)>\n+                pipes::Packet<$(ty)>\n             };\n             cx.ty_field_imm(cx.ident_of(s.name), fty)\n         };"}, {"sha": "ab810bd48fd2af6894a479132ea10b842e32532c", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -10,8 +10,8 @@ enum direction {\n impl direction: ToStr {\n     fn to_str() -> ~str {\n         match self {\n-          send => ~\"send\",\n-          recv => ~\"recv\"\n+          send => ~\"Send\",\n+          recv => ~\"Recv\"\n         }\n     }\n }"}, {"sha": "867d4669456ea2d69b53ae0b8891e9f378ea710a", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -14,7 +14,7 @@ use std;\n import io::Writer;\n import io::WriterUtil;\n \n-import pipes::{port, chan, SharedChan};\n+import pipes::{Port, Chan, SharedChan};\n \n macro_rules! move_out (\n     { $x:expr } => { unsafe { let y <- *ptr::addr_of($x); y } }\n@@ -26,7 +26,7 @@ enum request {\n     stop\n }\n \n-fn server(requests: port<request>, responses: pipes::chan<uint>) {\n+fn server(requests: Port<request>, responses: pipes::Chan<uint>) {\n     let mut count = 0u;\n     let mut done = false;\n     while !done {"}, {"sha": "eb7e0edfb1181fb5acbd741184fd7973d64ebd75", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -10,7 +10,7 @@ use std;\n import io::Writer;\n import io::WriterUtil;\n \n-import pipes::{port, PortSet, chan};\n+import pipes::{Port, PortSet, Chan};\n \n macro_rules! move_out (\n     { $x:expr } => { unsafe { let y <- *ptr::addr_of($x); y } }\n@@ -22,7 +22,7 @@ enum request {\n     stop\n }\n \n-fn server(requests: PortSet<request>, responses: pipes::chan<uint>) {\n+fn server(requests: PortSet<request>, responses: pipes::Chan<uint>) {\n     let mut count = 0u;\n     let mut done = false;\n     while !done {"}, {"sha": "262bc2e4813fb2b4cf839e9245b22769a227aa86", "filename": "src/test/bench/pingpong.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Fbench%2Fpingpong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Fbench%2Fpingpong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fpingpong.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -64,7 +64,7 @@ macro_rules! follow (\n     )\n )\n \n-fn switch<T: send, Tb: send, U>(+endp: pipes::recv_packet_buffered<T, Tb>,\n+fn switch<T: send, Tb: send, U>(+endp: pipes::RecvPacketBuffered<T, Tb>,\n                       f: fn(+Option<T>) -> U) -> U {\n     f(pipes::try_recv(endp))\n }"}, {"sha": "4b29f76cc8a5343d63165791b99463fd59914c4d", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -7,7 +7,7 @@ import std::map;\n import std::map::hashmap;\n import std::sort;\n import io::ReaderUtil;\n-import pipes::{stream, port, chan};\n+import pipes::{stream, Port, Chan};\n \n // given a map, print a sorted version of it\n fn sort_and_fmt(mm: hashmap<~[u8], uint>, total: uint) -> ~str { \n@@ -88,8 +88,8 @@ fn windows_with_carry(bb: &[u8], nn: uint,\n    return vec::slice(bb, len - (nn - 1u), len); \n }\n \n-fn make_sequence_processor(sz: uint, from_parent: pipes::port<~[u8]>,\n-                           to_parent: pipes::chan<~str>) {\n+fn make_sequence_processor(sz: uint, from_parent: pipes::Port<~[u8]>,\n+                           to_parent: pipes::Chan<~str>) {\n    \n    let freqs: hashmap<~[u8], uint> = map::bytes_hash();\n    let mut carry: ~[u8] = ~[];"}, {"sha": "66b2b07f1a9022d129ae18bfa7be000a9fd8dff8", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -15,16 +15,16 @@ use std;\n import std::{time, getopts};\n import io::WriterUtil;\n import int::range;\n-import pipes::port;\n-import pipes::chan;\n+import pipes::Port;\n+import pipes::Chan;\n import pipes::send;\n import pipes::recv;\n \n import core::result;\n import result::{Ok, Err};\n \n fn fib(n: int) -> int {\n-    fn pfib(c: chan<int>, n: int) {\n+    fn pfib(c: Chan<int>, n: int) {\n         if n == 0 {\n             c.send(0);\n         } else if n <= 2 {"}, {"sha": "6114400a45b85711eaa0a8f5ca7bd3e07b7b782e", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -5,7 +5,7 @@\n //\n // The filename is a song reference; google it in quotes.\n \n-fn child_generation(gens_left: uint, -c: pipes::chan<()>) {\n+fn child_generation(gens_left: uint, -c: pipes::Chan<()>) {\n     // This used to be O(n^2) in the number of generations that ever existed.\n     // With this code, only as many generations are alive at a time as tasks\n     // alive at a time,"}, {"sha": "f2c6ded88d5120139db02dc9c58178fd2779015e", "filename": "src/test/compile-fail/issue-2766-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -14,7 +14,7 @@ mod stream {\n                 recv\n             }\n         }\n-        type stream<T: send> = pipes::recv_packet<stream::stream<T>>;\n+        type stream<T: send> = pipes::RecvPacket<stream::stream<T>>;\n     }\n }\n "}, {"sha": "89b51b8fa73f5958fad5f9320e52385362aebba5", "filename": "src/test/run-pass/issue-3176.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Fissue-3176.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Fissue-3176.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3176.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -1,6 +1,6 @@\n // xfail-fast\n \n-import pipes::{select2, selectable};\n+import pipes::{Select2, Selectable};\n \n fn main() {\n     let (c,p) = pipes::stream();"}, {"sha": "acd1ed5b93efa28c710071c2d7d11ccc91200214", "filename": "src/test/run-pass/pipe-bank-proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -36,7 +36,7 @@ macro_rules! move_it (\n     { $x:expr } => { unsafe { let y <- *ptr::addr_of($x); y } }\n )\n \n-fn switch<T: send, U>(+endp: pipes::recv_packet<T>,\n+fn switch<T: send, U>(+endp: pipes::RecvPacket<T>,\n                       f: fn(+Option<T>) -> U) -> U {\n     f(pipes::try_recv(endp))\n }"}, {"sha": "29f97023e8e32c1d4367fed6b67776ffbf96268e", "filename": "src/test/run-pass/pipe-pingpong-bounded.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -12,21 +12,21 @@ mod pingpong {\n     type packets = {\n         // This is probably a resolve bug, I forgot to export packet,\n         // but since I didn't import pipes::*, it worked anyway.\n-        ping: packet<ping>,\n-        pong: packet<pong>,\n+        ping: Packet<ping>,\n+        pong: Packet<pong>,\n     };\n \n     fn init() -> (client::ping, server::ping) {\n         let buffer = ~{\n-            header: buffer_header(),\n+            header: BufferHeader(),\n             data: {\n                 ping: mk_packet::<ping>(),\n                 pong: mk_packet::<pong>()\n             }\n         };\n         do pipes::entangle_buffer(buffer) |buffer, data| {\n-            data.ping.set_buffer(buffer);\n-            data.pong.set_buffer(buffer);\n+            data.ping.set_buffer_(buffer);\n+            data.pong.set_buffer_(buffer);\n             ptr::addr_of(data.ping)\n         }\n     }\n@@ -36,32 +36,32 @@ mod pingpong {\n         fn ping(+pipe: ping) -> pong {\n             {\n                 let b = pipe.reuse_buffer();\n-                let s = send_packet_buffered(ptr::addr_of(b.buffer.data.pong));\n-                let c = recv_packet_buffered(ptr::addr_of(b.buffer.data.pong));\n+                let s = SendPacketBuffered(ptr::addr_of(b.buffer.data.pong));\n+                let c = RecvPacketBuffered(ptr::addr_of(b.buffer.data.pong));\n                 let message = pingpong::ping(s);\n                 pipes::send(pipe, message);\n                 c\n             }\n         }\n-        type ping = pipes::send_packet_buffered<pingpong::ping,\n+        type ping = pipes::SendPacketBuffered<pingpong::ping,\n         pingpong::packets>;\n-        type pong = pipes::recv_packet_buffered<pingpong::pong,\n+        type pong = pipes::RecvPacketBuffered<pingpong::pong,\n         pingpong::packets>;\n     }\n     mod server {\n-        type ping = pipes::recv_packet_buffered<pingpong::ping,\n+        type ping = pipes::RecvPacketBuffered<pingpong::ping,\n         pingpong::packets>;\n         fn pong(+pipe: pong) -> ping {\n             {\n                 let b = pipe.reuse_buffer();\n-                let s = send_packet_buffered(ptr::addr_of(b.buffer.data.ping));\n-                let c = recv_packet_buffered(ptr::addr_of(b.buffer.data.ping));\n+                let s = SendPacketBuffered(ptr::addr_of(b.buffer.data.ping));\n+                let c = RecvPacketBuffered(ptr::addr_of(b.buffer.data.ping));\n                 let message = pingpong::pong(s);\n                 pipes::send(pipe, message);\n                 c\n             }\n         }\n-        type pong = pipes::send_packet_buffered<pingpong::pong,\n+        type pong = pipes::SendPacketBuffered<pingpong::pong,\n         pingpong::packets>;\n     }\n }"}, {"sha": "575d3232e1cdc47957217a7a098a95a1cf5ed08f", "filename": "src/test/run-pass/task-comm-0.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -1,13 +1,13 @@\n use std;\n \n import pipes;\n-import pipes::chan;\n-import pipes::port;\n+import pipes::Chan;\n+import pipes::Port;\n import task;\n \n fn main() { test05(); }\n \n-fn test05_start(ch : chan<int>) {\n+fn test05_start(ch : Chan<int>) {\n     ch.send(10);\n     error!(\"sent 10\");\n     ch.send(20);"}, {"sha": "03d7a7a9645be2fe59605e5128a391e8b653c872", "filename": "src/test/run-pass/task-comm-10.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -2,7 +2,7 @@ use std;\n import task;\n import pipes;\n \n-fn start(c: pipes::chan<pipes::chan<~str>>) {\n+fn start(c: pipes::Chan<pipes::Chan<~str>>) {\n     let (ch, p) = pipes::stream();\n     c.send(ch);\n "}, {"sha": "b87ba47d7d1c320841377882d01335086c0c8ba5", "filename": "src/test/run-pass/task-comm-11.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -2,7 +2,7 @@ use std;\n import pipes;\n import task;\n \n-fn start(c: pipes::chan<pipes::chan<int>>) {\n+fn start(c: pipes::Chan<pipes::Chan<int>>) {\n     let (ch, p) = pipes::stream();\n     c.send(ch);\n }"}, {"sha": "261fcc409670424813c6bea78144c7c8f37e71fe", "filename": "src/test/run-pass/task-comm-13.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -3,7 +3,7 @@ import task;\n import pipes;\n import pipes::send;\n \n-fn start(c: pipes::chan<int>, start: int, number_of_messages: int) {\n+fn start(c: pipes::Chan<int>, start: int, number_of_messages: int) {\n     let mut i: int = 0;\n     while i < number_of_messages { c.send(start + i); i += 1; }\n }"}, {"sha": "e2ad5057513948a1633beb0f69b6fe2c5f0feb4a", "filename": "src/test/run-pass/task-comm-14.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -26,7 +26,7 @@ fn main() {\n     debug!(\"main thread exiting\");\n }\n \n-fn child(x: int, ch: pipes::chan<int>) {\n+fn child(x: int, ch: pipes::Chan<int>) {\n     log(debug, x);\n     ch.send(x);\n }"}, {"sha": "2fdfc582ce5dc84fb3b3d3739aee2c7ab73c7dcd", "filename": "src/test/run-pass/task-comm-15.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -2,7 +2,7 @@\n use std;\n import task;\n \n-fn start(c: pipes::chan<int>, i0: int) {\n+fn start(c: pipes::Chan<int>, i0: int) {\n     let mut i = i0;\n     while i > 0 {\n         c.send(0);"}, {"sha": "4e408f6540a08829a94fd66a21bd907befd59e73", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -3,9 +3,9 @@\n use std;\n import pipes;\n import pipes::send;\n-import pipes::port;\n+import pipes::Port;\n import pipes::recv;\n-import pipes::chan;\n+import pipes::Chan;\n \n // Tests of ports and channels on various types\n fn test_rec() {"}, {"sha": "7289b75c7128fec70f424992a99781e40faeb69e", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -1,13 +1,13 @@\n use std;\n import task;\n import pipes;\n-import pipes::chan;\n+import pipes::Chan;\n import pipes::send;\n import pipes::recv;\n \n fn main() { debug!(\"===== WITHOUT THREADS =====\"); test00(); }\n \n-fn test00_start(ch: chan<int>, message: int, count: int) {\n+fn test00_start(ch: Chan<int>, message: int, count: int) {\n     debug!(\"Starting test00_start\");\n     let mut i: int = 0;\n     while i < count {"}, {"sha": "39a8735423be6cb3e8130b231b189db6db8a63b1", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -3,7 +3,7 @@ import task;\n \n fn main() { test00(); }\n \n-fn test00_start(c: pipes::chan<int>, start: int, number_of_messages: int) {\n+fn test00_start(c: pipes::Chan<int>, start: int, number_of_messages: int) {\n     let mut i: int = 0;\n     while i < number_of_messages { c.send(start + i); i += 1; }\n }"}, {"sha": "d5f19f16698483a6b9685c4088e69c30e5bc78ad", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -3,7 +3,7 @@ import task;\n \n fn main() { test00(); }\n \n-fn test00_start(c: pipes::chan<int>, number_of_messages: int) {\n+fn test00_start(c: pipes::Chan<int>, number_of_messages: int) {\n     let mut i: int = 0;\n     while i < number_of_messages { c.send(i + 0); i += 1; }\n }"}, {"sha": "5b4352a83456b4811920e9875eaa60a8d523ad55", "filename": "src/test/run-pass/trivial-message.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Ftrivial-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f/src%2Ftest%2Frun-pass%2Ftrivial-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrivial-message.rs?ref=cfbc7cbdc7cd09490c7c723758329b5ba78e5f9f", "patch": "@@ -1,4 +1,4 @@\n-import pipes::{port, chan};\n+import pipes::{Port, Chan};\n \n /*\n   This is about the simplest program that can successfully send a"}]}