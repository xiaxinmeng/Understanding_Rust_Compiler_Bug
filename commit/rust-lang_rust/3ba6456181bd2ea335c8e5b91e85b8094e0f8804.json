{"sha": "3ba6456181bd2ea335c8e5b91e85b8094e0f8804", "node_id": "C_kwDOAAsO6NoAKDNiYTY0NTYxODFiZDJlYTMzNWM4ZTViOTFlODViODA5NGUwZjg4MDQ", "commit": {"author": {"name": "infrandomness", "email": "infrandomness@inftop.home", "date": "2022-06-06T16:17:38Z"}, "committer": {"name": "infrandomness", "email": "infrandomness@inftop.home", "date": "2022-06-06T16:30:15Z"}, "message": "Fix rustdoc warnings", "tree": {"sha": "0dcbe07d1ec6afaba18464c98c2182302cde4a48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0dcbe07d1ec6afaba18464c98c2182302cde4a48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ba6456181bd2ea335c8e5b91e85b8094e0f8804", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ba6456181bd2ea335c8e5b91e85b8094e0f8804", "html_url": "https://github.com/rust-lang/rust/commit/3ba6456181bd2ea335c8e5b91e85b8094e0f8804", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ba6456181bd2ea335c8e5b91e85b8094e0f8804/comments", "author": null, "committer": null, "parents": [{"sha": "fc8631a737e37c26210485bfb838becd79b99268", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc8631a737e37c26210485bfb838becd79b99268", "html_url": "https://github.com/rust-lang/rust/commit/fc8631a737e37c26210485bfb838becd79b99268"}], "stats": {"total": 14, "additions": 7, "deletions": 7}, "files": [{"sha": "eb67a487b5a50d5e6e1e94dd456e5953c4ac7286", "filename": "src/data_race.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ba6456181bd2ea335c8e5b91e85b8094e0f8804/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba6456181bd2ea335c8e5b91e85b8094e0f8804/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=3ba6456181bd2ea335c8e5b91e85b8094e0f8804", "patch": "@@ -1,11 +1,11 @@\n //! Implementation of a data-race detector using Lamport Timestamps / Vector-clocks\n //! based on the Dynamic Race Detection for C++:\n-//! https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf\n+//! <https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf>\n //! which does not report false-positives when fences are used, and gives better\n //! accuracy in presence of read-modify-write operations.\n //!\n //! The implementation contains modifications to correctly model the changes to the memory model in C++20\n-//! regarding the weakening of release sequences: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0982r1.html.\n+//! regarding the weakening of release sequences: <http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0982r1.html>.\n //! Relaxed stores now unconditionally block all currently active release sequences and so per-thread tracking of release\n //! sequences is not needed.\n //!\n@@ -15,7 +15,7 @@\n //! This does not explore weak memory orders and so can still miss data-races\n //! but should not report false-positives\n //!\n-//! Data-race definition from(https://en.cppreference.com/w/cpp/language/memory_model#Threads_and_data_races):\n+//! Data-race definition from(<https://en.cppreference.com/w/cpp/language/memory_model#Threads_and_data_races>):\n //! a data race occurs between two memory accesses if they are on different threads, at least one operation\n //! is non-atomic, at least one operation is a write and neither access happens-before the other. Read the link\n //! for full definition.\n@@ -24,7 +24,7 @@\n //! because it only re-uses vector indexes once all currently-active (not-terminated) threads have an internal\n //! vector clock that happens-after the join operation of the candidate thread. Threads that have not been joined\n //! on are not considered. Since the thread's vector clock will only increase and a data-race implies that\n-//! there is some index x where clock[x] > thread_clock, when this is true clock[candidate-idx] > thread_clock\n+//! there is some index x where clock\\[x\\] > thread_clock, when this is true clock\\[candidate-idx\\] > thread_clock\n //! can never hold and hence a data-race can never be reported in that vector index again.\n //! This means that the thread-index can be safely re-used, starting on the next timestamp for the newly created\n //! thread."}, {"sha": "6b4e9d4f753376cd7d1d274194acbc7e665680b7", "filename": "src/shims/tls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ba6456181bd2ea335c8e5b91e85b8094e0f8804/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba6456181bd2ea335c8e5b91e85b8094e0f8804/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=3ba6456181bd2ea335c8e5b91e85b8094e0f8804", "patch": "@@ -135,7 +135,7 @@ impl<'tcx> TlsData<'tcx> {\n     /// [`_tlv_atexit`\n     /// implementation](https://github.com/opensource-apple/dyld/blob/195030646877261f0c8c7ad8b001f52d6a26f514/src/threadLocalVariables.c#L389):\n     ///\n-    ///     // NOTE: this does not need locks because it only operates on current thread data\n+    /// NOTE: this does not need locks because it only operates on current thread data\n     pub fn set_macos_thread_dtor(\n         &mut self,\n         thread: ThreadId,\n@@ -347,7 +347,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// Note: we consistently run TLS destructors for all threads, including the\n     /// main thread. However, it is not clear that we should run the TLS\n     /// destructors for the main thread. See issue:\n-    /// https://github.com/rust-lang/rust/issues/28129.\n+    /// <https://github.com/rust-lang/rust/issues/28129>.\n     fn schedule_next_tls_dtor_for_active_thread(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let active_thread = this.get_active_thread();"}, {"sha": "0d671ec653b5623412ffe345f9b51d4c413e3e1b", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ba6456181bd2ea335c8e5b91e85b8094e0f8804/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ba6456181bd2ea335c8e5b91e85b8094e0f8804/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=3ba6456181bd2ea335c8e5b91e85b8094e0f8804", "patch": "@@ -945,7 +945,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// it does not alias with anything.\n     ///\n     /// This is a HACK because there is nothing in MIR that would make the retag\n-    /// explicit. Also see https://github.com/rust-lang/rust/issues/71117.\n+    /// explicit. Also see <https://github.com/rust-lang/rust/issues/71117>.\n     fn retag_return_place(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let return_place = this.frame_mut().return_place;"}]}