{"sha": "14e5816f1bf051d922e8c46fa6e2414664cc3a22", "node_id": "C_kwDOAAsO6NoAKDE0ZTU4MTZmMWJmMDUxZDkyMmU4YzQ2ZmE2ZTI0MTQ2NjRjYzNhMjI", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-05-22T23:46:23Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-05-24T02:39:10Z"}, "message": "refine comments, disambiguate len for array and tables", "tree": {"sha": "ea160bdd9ebebeba3450ebaa070af52363355912", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea160bdd9ebebeba3450ebaa070af52363355912"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14e5816f1bf051d922e8c46fa6e2414664cc3a22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14e5816f1bf051d922e8c46fa6e2414664cc3a22", "html_url": "https://github.com/rust-lang/rust/commit/14e5816f1bf051d922e8c46fa6e2414664cc3a22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14e5816f1bf051d922e8c46fa6e2414664cc3a22/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca5e60b7fb8867a59529e3120c305574a1e3e991", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca5e60b7fb8867a59529e3120c305574a1e3e991", "html_url": "https://github.com/rust-lang/rust/commit/ca5e60b7fb8867a59529e3120c305574a1e3e991"}], "stats": {"total": 77, "additions": 41, "deletions": 36}, "files": [{"sha": "6042d0e49c39866efd52498f73323a8f89f6cc98", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/14e5816f1bf051d922e8c46fa6e2414664cc3a22/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e5816f1bf051d922e8c46fa6e2414664cc3a22/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=14e5816f1bf051d922e8c46fa6e2414664cc3a22", "patch": "@@ -269,7 +269,7 @@ impl<'a, 'tcx, T: Decodable<DecodeContext<'a, 'tcx>>> LazyValue<T> {\n }\n \n struct DecodeIterator<'a, 'tcx, T> {\n-    range: std::ops::Range<usize>,\n+    elem_counter: std::ops::Range<usize>,\n     dcx: DecodeContext<'a, 'tcx>,\n     _phantom: PhantomData<fn() -> T>,\n }\n@@ -278,23 +278,23 @@ impl<'a, 'tcx, T: Decodable<DecodeContext<'a, 'tcx>>> Iterator for DecodeIterato\n     type Item = T;\n \n     fn next(&mut self) -> Option<Self::Item> {\n-        self.range.next().map(|_| T::decode(&mut self.dcx))\n+        self.elem_counter.next().map(|_| T::decode(&mut self.dcx))\n     }\n }\n \n impl<'a, 'tcx, T: Decodable<DecodeContext<'a, 'tcx>>> ExactSizeIterator\n     for DecodeIterator<'a, 'tcx, T>\n {\n     fn len(&self) -> usize {\n-        self.range.len()\n+        self.elem_counter.len()\n     }\n }\n \n impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable<DecodeContext<'a, 'tcx>>> LazyArray<T> {\n     fn decode<M: Metadata<'a, 'tcx>>(self, metadata: M) -> DecodeIterator<'a, 'tcx, T> {\n         let mut dcx = metadata.decoder(self.position.get());\n         dcx.lazy_state = LazyState::NodeStart(self.position);\n-        DecodeIterator { range: (0..self.len), dcx, _phantom: PhantomData }\n+        DecodeIterator { elem_counter: (0..self.num_elems), dcx, _phantom: PhantomData }\n     }\n }\n \n@@ -342,11 +342,11 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n     }\n \n     fn read_lazy_array<T>(&mut self, len: usize) -> LazyArray<T> {\n-        self.read_lazy_offset_then(|pos| LazyArray::from_position_and_len(pos, len))\n+        self.read_lazy_offset_then(|pos| LazyArray::from_position_and_num_elems(pos, len))\n     }\n \n     fn read_lazy_table<I, T>(&mut self, len: usize) -> LazyTable<I, T> {\n-        self.read_lazy_offset_then(|pos| LazyTable::from_position_and_len(pos, len))\n+        self.read_lazy_offset_then(|pos| LazyTable::from_position_and_encoded_size(pos, len))\n     }\n \n     #[inline]"}, {"sha": "28f289f06ecb2b585232522afbd5d5fcfa1d619a", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/14e5816f1bf051d922e8c46fa6e2414664cc3a22/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e5816f1bf051d922e8c46fa6e2414664cc3a22/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=14e5816f1bf051d922e8c46fa6e2414664cc3a22", "patch": "@@ -132,8 +132,8 @@ impl<'a, 'tcx, T> Encodable<EncodeContext<'a, 'tcx>> for LazyValue<T> {\n \n impl<'a, 'tcx, T> Encodable<EncodeContext<'a, 'tcx>> for LazyArray<T> {\n     fn encode(&self, e: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n-        e.emit_usize(self.len)?;\n-        if self.len == 0 {\n+        e.emit_usize(self.num_elems)?;\n+        if self.num_elems == 0 {\n             return Ok(());\n         }\n         e.emit_lazy_distance(self.position)\n@@ -142,7 +142,7 @@ impl<'a, 'tcx, T> Encodable<EncodeContext<'a, 'tcx>> for LazyArray<T> {\n \n impl<'a, 'tcx, I, T> Encodable<EncodeContext<'a, 'tcx>> for LazyTable<I, T> {\n     fn encode(&self, e: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n-        e.emit_usize(self.len)?;\n+        e.emit_usize(self.encoded_size)?;\n         e.emit_lazy_distance(self.position)\n     }\n }\n@@ -421,7 +421,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         assert!(pos.get() <= self.position());\n \n-        LazyArray::from_position_and_len(pos, len)\n+        LazyArray::from_position_and_num_elems(pos, len)\n     }\n \n     fn encode_info_for_items(&mut self) {"}, {"sha": "00c4dc3955da0eb60f2b27a5aed494bbc0219ace", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/14e5816f1bf051d922e8c46fa6e2414664cc3a22/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e5816f1bf051d922e8c46fa6e2414664cc3a22/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=14e5816f1bf051d922e8c46fa6e2414664cc3a22", "patch": "@@ -77,20 +77,7 @@ pub const METADATA_HEADER: &[u8] = &[b'r', b'u', b's', b't', 0, 0, 0, METADATA_V\n /// Distances start at 1, as 0-byte nodes are invalid.\n /// Also invalid are nodes being referred in a different\n /// order than they were encoded in.\n-///\n-/// # Sequences (`LazyArray<T>`)\n-///\n-/// Unlike `Lazy<Vec<T>>`, the length is encoded next to the\n-/// position, not at the position, which means that the length\n-/// doesn't need to be known before encoding all the elements.\n-///\n-/// If the length is 0, no position is encoded, but otherwise,\n-/// the encoding is that of `Lazy`, with the distinction that\n-/// the minimal distance the length of the sequence, i.e.\n-/// it's assumed there's no 0-byte element in the sequence.\n #[must_use]\n-// FIXME(#59875) the `Meta` parameter only exists to dodge\n-// invariance wrt `T` (coming from the `meta: T::Meta` field).\n struct LazyValue<T> {\n     position: NonZeroUsize,\n     _marker: PhantomData<fn() -> T>,\n@@ -102,34 +89,49 @@ impl<T> LazyValue<T> {\n     }\n }\n \n+/// A list of lazily-decoded values.\n+///\n+/// Unlike `Lazy<Vec<T>>`, the length is encoded next to the\n+/// position, not at the position, which means that the length\n+/// doesn't need to be known before encoding all the elements.\n+///\n+/// If the length is 0, no position is encoded, but otherwise,\n+/// the encoding is that of `Lazy`, with the distinction that\n+/// the minimal distance the length of the sequence, i.e.\n+/// it's assumed there's no 0-byte element in the sequence.\n struct LazyArray<T> {\n     position: NonZeroUsize,\n-    len: usize,\n+    num_elems: usize,\n     _marker: PhantomData<fn() -> T>,\n }\n \n impl<T> LazyArray<T> {\n-    fn from_position_and_len(position: NonZeroUsize, len: usize) -> LazyArray<T> {\n-        LazyArray { position, len, _marker: PhantomData }\n+    fn from_position_and_num_elems(position: NonZeroUsize, num_elems: usize) -> LazyArray<T> {\n+        LazyArray { position, num_elems, _marker: PhantomData }\n     }\n \n     fn empty() -> LazyArray<T> {\n-        LazyArray::from_position_and_len(NonZeroUsize::new(1).unwrap(), 0)\n+        LazyArray::from_position_and_num_elems(NonZeroUsize::new(1).unwrap(), 0)\n     }\n }\n \n+/// A list of lazily-decoded values, with the added capability of random access.\n+///\n /// Random-access table (i.e. offering constant-time `get`/`set`), similar to\n /// `LazyArray<T>`, but without requiring encoding or decoding all the values\n /// eagerly and in-order.\n struct LazyTable<I, T> {\n     position: NonZeroUsize,\n-    len: usize,\n+    encoded_size: usize,\n     _marker: PhantomData<fn(I) -> T>,\n }\n \n impl<I, T> LazyTable<I, T> {\n-    fn from_position_and_len(position: NonZeroUsize, len: usize) -> LazyTable<I, T> {\n-        LazyTable { position, len, _marker: PhantomData }\n+    fn from_position_and_encoded_size(\n+        position: NonZeroUsize,\n+        encoded_size: usize,\n+    ) -> LazyTable<I, T> {\n+        LazyTable { position, encoded_size, _marker: PhantomData }\n     }\n }\n "}, {"sha": "60c5143a6c377aa8d469bcd666b4ec10c472efc6", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/14e5816f1bf051d922e8c46fa6e2414664cc3a22/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14e5816f1bf051d922e8c46fa6e2414664cc3a22/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=14e5816f1bf051d922e8c46fa6e2414664cc3a22", "patch": "@@ -228,7 +228,7 @@ impl<T> FixedSizeEncoding for Option<LazyArray<T>> {\n         let ([ref position_bytes, ref meta_bytes],[])= b.as_chunks::<4>() else { panic!() };\n         let position = NonZeroUsize::new(u32::from_bytes(position_bytes) as usize)?;\n         let len = u32::from_bytes(meta_bytes) as usize;\n-        Some(LazyArray::from_position_and_len(position, len))\n+        Some(LazyArray::from_position_and_num_elems(position, len))\n     }\n \n     #[inline]\n@@ -239,7 +239,7 @@ impl<T> FixedSizeEncoding for Option<LazyArray<T>> {\n         let position: u32 = position.try_into().unwrap();\n         position.write_to_bytes(position_bytes);\n \n-        let len = self.map_or(0, |lazy| lazy.len);\n+        let len = self.map_or(0, |lazy| lazy.num_elems);\n         let len: u32 = len.try_into().unwrap();\n         len.write_to_bytes(meta_bytes);\n     }\n@@ -289,7 +289,10 @@ where\n             buf.emit_raw_bytes(block).unwrap();\n         }\n         let num_bytes = self.blocks.len() * N;\n-        LazyTable::from_position_and_len(NonZeroUsize::new(pos as usize).unwrap(), num_bytes)\n+        LazyTable::from_position_and_encoded_size(\n+            NonZeroUsize::new(pos as usize).unwrap(),\n+            num_bytes,\n+        )\n     }\n }\n \n@@ -307,10 +310,10 @@ where\n     where\n         Option<T>: FixedSizeEncoding<ByteArray = [u8; N]>,\n     {\n-        debug!(\"LazyTable::lookup: index={:?} len={:?}\", i, self.len);\n+        debug!(\"LazyTable::lookup: index={:?} len={:?}\", i, self.encoded_size);\n \n         let start = self.position.get();\n-        let bytes = &metadata.blob()[start..start + self.len];\n+        let bytes = &metadata.blob()[start..start + self.encoded_size];\n         let (bytes, []) = bytes.as_chunks::<N>() else { panic!() };\n         let bytes = bytes.get(i.index())?;\n         FixedSizeEncoding::from_bytes(bytes)\n@@ -321,6 +324,6 @@ where\n     where\n         Option<T>: FixedSizeEncoding<ByteArray = [u8; N]>,\n     {\n-        self.len / N\n+        self.encoded_size / N\n     }\n }"}]}