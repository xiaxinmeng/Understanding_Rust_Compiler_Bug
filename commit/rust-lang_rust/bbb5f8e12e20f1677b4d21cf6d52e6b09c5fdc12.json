{"sha": "bbb5f8e12e20f1677b4d21cf6d52e6b09c5fdc12", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiYjVmOGUxMmUyMGYxNjc3YjRkMjFjZjZkNTJlNmIwOWM1ZmRjMTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-23T19:46:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-23T19:46:57Z"}, "message": "Auto merge of #29241 - nikomatsakis:issue-28871, r=arielb1\n\nGive preference to projections from where-clauses over those from trait definitions. This makes #28871 work again, though I think there's more to fix in this general area.\r\n\r\nr? @arielb1 \r\ncc @brson (fixes regression)", "tree": {"sha": "fd5867715d9e8d0995ff3161f687f46408e98391", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd5867715d9e8d0995ff3161f687f46408e98391"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbb5f8e12e20f1677b4d21cf6d52e6b09c5fdc12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbb5f8e12e20f1677b4d21cf6d52e6b09c5fdc12", "html_url": "https://github.com/rust-lang/rust/commit/bbb5f8e12e20f1677b4d21cf6d52e6b09c5fdc12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbb5f8e12e20f1677b4d21cf6d52e6b09c5fdc12/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ee4e9e7ec59c7db2d76fcb53719e5b31b43e499", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ee4e9e7ec59c7db2d76fcb53719e5b31b43e499", "html_url": "https://github.com/rust-lang/rust/commit/7ee4e9e7ec59c7db2d76fcb53719e5b31b43e499"}, {"sha": "b69e08ceca608b2ecb9f21525f4448e7361c0035", "url": "https://api.github.com/repos/rust-lang/rust/commits/b69e08ceca608b2ecb9f21525f4448e7361c0035", "html_url": "https://github.com/rust-lang/rust/commit/b69e08ceca608b2ecb9f21525f4448e7361c0035"}], "stats": {"total": 128, "additions": 114, "deletions": 14}, "files": [{"sha": "1027bbf67037b473638287632808ca0d164ab6b3", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bbb5f8e12e20f1677b4d21cf6d52e6b09c5fdc12/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb5f8e12e20f1677b4d21cf6d52e6b09c5fdc12/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=bbb5f8e12e20f1677b4d21cf6d52e6b09c5fdc12", "patch": "@@ -24,6 +24,7 @@ use middle::ty::{self, Ty};\n \n use std::cell::RefCell;\n use std::collections::hash_map::Entry;\n+use std::fmt;\n use std::mem;\n use syntax::codemap::{self, Span};\n use syntax::ast::{self, NodeId};\n@@ -34,9 +35,25 @@ use rustc_front::hir::{Block, Item, FnDecl, Arm, Pat, Stmt, Expr, Local};\n use rustc_front::util::stmt_id;\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n-           RustcDecodable, Debug, Copy)]\n+           RustcDecodable, Copy)]\n pub struct CodeExtent(u32);\n \n+impl fmt::Debug for CodeExtent {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"CodeExtent({:?}\", self.0));\n+\n+        try!(ty::tls::with_opt(|opt_tcx| {\n+            if let Some(tcx) = opt_tcx {\n+                let data = tcx.region_maps.code_extents.borrow()[self.0 as usize];\n+                try!(write!(f, \"/{:?}\", data));\n+            }\n+            Ok(())\n+        }));\n+\n+        write!(f, \")\")\n+    }\n+}\n+\n /// The root of everything. I should be using NonZero or profiling\n /// instead of this (probably).\n pub const ROOT_CODE_EXTENT : CodeExtent = CodeExtent(0);"}, {"sha": "bf90b3a02a870f5f6e013d552cc22940566f7d19", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 62, "deletions": 12, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/bbb5f8e12e20f1677b4d21cf6d52e6b09c5fdc12/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb5f8e12e20f1677b4d21cf6d52e6b09c5fdc12/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=bbb5f8e12e20f1677b4d21cf6d52e6b09c5fdc12", "patch": "@@ -54,9 +54,19 @@ pub struct MismatchedProjectionTypes<'tcx> {\n \n #[derive(PartialEq, Eq, Debug)]\n enum ProjectionTyCandidate<'tcx> {\n+    // from a where-clause in the env or object type\n     ParamEnv(ty::PolyProjectionPredicate<'tcx>),\n+\n+    // from the definition of `Trait` when you have something like <<A as Trait>::B as Trait2>::C\n+    TraitDef(ty::PolyProjectionPredicate<'tcx>),\n+\n+    // defined in an impl\n     Impl(VtableImplData<'tcx, PredicateObligation<'tcx>>),\n+\n+    // closure return type\n     Closure(VtableClosureData<'tcx, PredicateObligation<'tcx>>),\n+\n+    // fn pointer return type\n     FnPointer(Ty<'tcx>),\n }\n \n@@ -491,7 +501,11 @@ fn project_type<'cx,'tcx>(\n            candidates.vec.len(),\n            candidates.ambiguous);\n \n-    // We probably need some winnowing logic similar to select here.\n+    // Inherent ambiguity that prevents us from even enumerating the\n+    // candidates.\n+    if candidates.ambiguous {\n+        return Err(ProjectionTyError::TooManyCandidates);\n+    }\n \n     // Drop duplicates.\n     //\n@@ -512,10 +526,30 @@ fn project_type<'cx,'tcx>(\n         }\n     }\n \n-    if candidates.ambiguous || candidates.vec.len() > 1 {\n-        return Err(ProjectionTyError::TooManyCandidates);\n+    // Prefer where-clauses. As in select, if there are multiple\n+    // candidates, we prefer where-clause candidates over impls.  This\n+    // may seem a bit surprising, since impls are the source of\n+    // \"truth\" in some sense, but in fact some of the impls that SEEM\n+    // applicable are not, because of nested obligations. Where\n+    // clauses are the safer choice. See the comment on\n+    // `select::SelectionCandidate` and #21974 for more details.\n+    if candidates.vec.len() > 1 {\n+        debug!(\"retaining param-env candidates only from {:?}\", candidates.vec);\n+        candidates.vec.retain(|c| match *c {\n+            ProjectionTyCandidate::ParamEnv(..) => true,\n+            ProjectionTyCandidate::Impl(..) |\n+            ProjectionTyCandidate::Closure(..) |\n+            ProjectionTyCandidate::TraitDef(..) |\n+            ProjectionTyCandidate::FnPointer(..) => false,\n+        });\n+        debug!(\"resulting candidate set: {:?}\", candidates.vec);\n+        if candidates.vec.len() != 1 {\n+            return Err(ProjectionTyError::TooManyCandidates);\n+        }\n     }\n \n+    assert!(candidates.vec.len() <= 1);\n+\n     match candidates.vec.pop() {\n         Some(candidate) => {\n             let (ty, obligations) = confirm_candidate(selcx, obligation, candidate);\n@@ -538,9 +572,14 @@ fn assemble_candidates_from_param_env<'cx,'tcx>(\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n {\n+    debug!(\"assemble_candidates_from_param_env(..)\");\n     let env_predicates = selcx.param_env().caller_bounds.iter().cloned();\n-    assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n-                                        candidate_set, env_predicates);\n+    assemble_candidates_from_predicates(selcx,\n+                                        obligation,\n+                                        obligation_trait_ref,\n+                                        candidate_set,\n+                                        ProjectionTyCandidate::ParamEnv,\n+                                        env_predicates);\n }\n \n /// In the case of a nested projection like <<A as Foo>::FooT as Bar>::BarT, we may find\n@@ -559,6 +598,8 @@ fn assemble_candidates_from_trait_def<'cx,'tcx>(\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n {\n+    debug!(\"assemble_candidates_from_trait_def(..)\");\n+\n     // Check whether the self-type is itself a projection.\n     let trait_ref = match obligation_trait_ref.self_ty().sty {\n         ty::TyProjection(ref data) => data.trait_ref.clone(),\n@@ -575,15 +616,20 @@ fn assemble_candidates_from_trait_def<'cx,'tcx>(\n     let trait_predicates = selcx.tcx().lookup_predicates(trait_ref.def_id);\n     let bounds = trait_predicates.instantiate(selcx.tcx(), trait_ref.substs);\n     let bounds = elaborate_predicates(selcx.tcx(), bounds.predicates.into_vec());\n-    assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n-                                        candidate_set, bounds)\n+    assemble_candidates_from_predicates(selcx,\n+                                        obligation,\n+                                        obligation_trait_ref,\n+                                        candidate_set,\n+                                        ProjectionTyCandidate::TraitDef,\n+                                        bounds)\n }\n \n fn assemble_candidates_from_predicates<'cx,'tcx,I>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+    ctor: fn(ty::PolyProjectionPredicate<'tcx>) -> ProjectionTyCandidate<'tcx>,\n     env_predicates: I)\n     where I: Iterator<Item=ty::Predicate<'tcx>>\n {\n@@ -614,8 +660,7 @@ fn assemble_candidates_from_predicates<'cx,'tcx,I>(\n                        data, is_match, same_name);\n \n                 if is_match {\n-                    candidate_set.vec.push(\n-                        ProjectionTyCandidate::ParamEnv(data.clone()));\n+                    candidate_set.vec.push(ctor(data.clone()));\n                 }\n             }\n             _ => { }\n@@ -647,8 +692,12 @@ fn assemble_candidates_from_object_type<'cx,'tcx>(\n                                           .map(|p| p.to_predicate())\n                                           .collect();\n     let env_predicates = elaborate_predicates(selcx.tcx(), env_predicates);\n-    assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n-                                        candidate_set, env_predicates)\n+    assemble_candidates_from_predicates(selcx,\n+                                        obligation,\n+                                        obligation_trait_ref,\n+                                        candidate_set,\n+                                        ProjectionTyCandidate::ParamEnv,\n+                                        env_predicates)\n }\n \n fn assemble_candidates_from_impls<'cx,'tcx>(\n@@ -746,7 +795,8 @@ fn confirm_candidate<'cx,'tcx>(\n            obligation);\n \n     match candidate {\n-        ProjectionTyCandidate::ParamEnv(poly_projection) => {\n+        ProjectionTyCandidate::ParamEnv(poly_projection) |\n+        ProjectionTyCandidate::TraitDef(poly_projection) => {\n             confirm_param_env_candidate(selcx, obligation, poly_projection)\n         }\n "}, {"sha": "a30c437197c3b1e930fba1dfb148a78e7f667290", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbb5f8e12e20f1677b4d21cf6d52e6b09c5fdc12/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb5f8e12e20f1677b4d21cf6d52e6b09c5fdc12/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=bbb5f8e12e20f1677b4d21cf6d52e6b09c5fdc12", "patch": "@@ -91,7 +91,7 @@ pub fn parse_pretty(sess: &Session,\n         (\"expanded,identified\", _) => PpmSource(PpmExpandedIdentified),\n         (\"expanded,hygiene\", _) => PpmSource(PpmExpandedHygiene),\n         (\"hir\", true)       => PpmHir(PpmNormal),\n-        (\"hir,identified\", true) => PpmHir(PpmExpandedIdentified),\n+        (\"hir,identified\", true) => PpmHir(PpmIdentified),\n         (\"hir,typed\", true)        => PpmHir(PpmTyped),\n         (\"flowgraph\", true)    => PpmFlowGraph(PpFlowGraphMode::Default),\n         (\"flowgraph,unlabelled\", true)    => PpmFlowGraph(PpFlowGraphMode::UnlabelledEdges),"}, {"sha": "92ba98f506257f3a6af713a8767e699186ca3f60", "filename": "src/test/run-pass/issue-28871.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bbb5f8e12e20f1677b4d21cf6d52e6b09c5fdc12/src%2Ftest%2Frun-pass%2Fissue-28871.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb5f8e12e20f1677b4d21cf6d52e6b09c5fdc12/src%2Ftest%2Frun-pass%2Fissue-28871.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-28871.rs?ref=bbb5f8e12e20f1677b4d21cf6d52e6b09c5fdc12", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #28871. The problem is that rustc encountered\n+// two ways to project, one from a where clause and one from the where\n+// clauses on the trait definition. (In fact, in this case, the where\n+// clauses originated from the trait definition as well.) The true\n+// cause of the error is that the trait definition where clauses are\n+// not being normalized, and hence the two sources are considered in\n+// conflict, and not a duplicate. Hacky solution is to prefer where\n+// clauses over the data found in the trait definition.\n+\n+trait T {\n+    type T;\n+}\n+\n+struct S;\n+impl T for S {\n+    type T = S;\n+}\n+\n+trait T2 {\n+    type T: Iterator<Item=<S as T>::T>;\n+}\n+\n+fn main() { }"}]}