{"sha": "56016cb1e02ece29f25c619b297f9c9797db821c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2MDE2Y2IxZTAyZWNlMjlmMjVjNjE5YjI5N2Y5Yzk3OTdkYjgyMWM=", "commit": {"author": {"name": "Brad Gibson", "email": "b2b@humanenginuity.com", "date": "2018-07-30T03:03:15Z"}, "committer": {"name": "Brad Gibson", "email": "b2b@humanenginuity.com", "date": "2018-07-30T05:13:12Z"}, "message": "resolved upstream merge conflicts", "tree": {"sha": "70dd7a5658527a54769c7603e6e17bfe27985f86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70dd7a5658527a54769c7603e6e17bfe27985f86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56016cb1e02ece29f25c619b297f9c9797db821c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56016cb1e02ece29f25c619b297f9c9797db821c", "html_url": "https://github.com/rust-lang/rust/commit/56016cb1e02ece29f25c619b297f9c9797db821c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56016cb1e02ece29f25c619b297f9c9797db821c/comments", "author": {"login": "Xandkeeper", "id": 124085026, "node_id": "U_kgDOB2VjIg", "avatar_url": "https://avatars.githubusercontent.com/u/124085026?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xandkeeper", "html_url": "https://github.com/Xandkeeper", "followers_url": "https://api.github.com/users/Xandkeeper/followers", "following_url": "https://api.github.com/users/Xandkeeper/following{/other_user}", "gists_url": "https://api.github.com/users/Xandkeeper/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xandkeeper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xandkeeper/subscriptions", "organizations_url": "https://api.github.com/users/Xandkeeper/orgs", "repos_url": "https://api.github.com/users/Xandkeeper/repos", "events_url": "https://api.github.com/users/Xandkeeper/events{/privacy}", "received_events_url": "https://api.github.com/users/Xandkeeper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Xandkeeper", "id": 124085026, "node_id": "U_kgDOB2VjIg", "avatar_url": "https://avatars.githubusercontent.com/u/124085026?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xandkeeper", "html_url": "https://github.com/Xandkeeper", "followers_url": "https://api.github.com/users/Xandkeeper/followers", "following_url": "https://api.github.com/users/Xandkeeper/following{/other_user}", "gists_url": "https://api.github.com/users/Xandkeeper/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xandkeeper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xandkeeper/subscriptions", "organizations_url": "https://api.github.com/users/Xandkeeper/orgs", "repos_url": "https://api.github.com/users/Xandkeeper/repos", "events_url": "https://api.github.com/users/Xandkeeper/events{/privacy}", "received_events_url": "https://api.github.com/users/Xandkeeper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a78c0a10f2e719117fe4bb929bfb38549acfeec", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a78c0a10f2e719117fe4bb929bfb38549acfeec", "html_url": "https://github.com/rust-lang/rust/commit/6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "866a713258915e6cbb212d135f751a6a8c9e1c0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/866a713258915e6cbb212d135f751a6a8c9e1c0a", "html_url": "https://github.com/rust-lang/rust/commit/866a713258915e6cbb212d135f751a6a8c9e1c0a"}], "stats": {"total": 221218, "additions": 121966, "deletions": 99252}, "files": [{"sha": "b223c8ac5fb841ed167a8c376eb1b6d5753ac0ec", "filename": ".gitattributes", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -4,7 +4,8 @@\n *.cpp rust\n *.h rust\n *.rs rust\n+*.fixed linguist-language=Rust\n src/etc/installer/gfx/* binary\n *.woff binary\n src/vendor/** -text\n-Cargo.lock -merge\n+Cargo.lock -merge linguist-generated=false"}, {"sha": "9ffaa82e1c8b5dace88ca77f19aa55047dc4f7cc", "filename": ".gitignore", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -74,27 +74,30 @@ __pycache__/\n /obj/\n /rt/\n /rustllvm/\n-/src/libstd_unicode/DerivedCoreProperties.txt\n-/src/libstd_unicode/DerivedNormalizationProps.txt\n-/src/libstd_unicode/PropList.txt\n-/src/libstd_unicode/ReadMe.txt\n-/src/libstd_unicode/Scripts.txt\n-/src/libstd_unicode/SpecialCasing.txt\n-/src/libstd_unicode/UnicodeData.txt\n+/src/libcore/unicode/DerivedCoreProperties.txt\n+/src/libcore/unicode/DerivedNormalizationProps.txt\n+/src/libcore/unicode/PropList.txt\n+/src/libcore/unicode/ReadMe.txt\n+/src/libcore/unicode/Scripts.txt\n+/src/libcore/unicode/SpecialCasing.txt\n+/src/libcore/unicode/UnicodeData.txt\n /stage[0-9]+/\n /target\n target/\n /test/\n /tmp/\n+tags\n+tags.*\n TAGS\n-TAGS.emacs\n-TAGS.vi\n+TAGS.*\n \\#*\n \\#*\\#\n config.mk\n config.stamp\n keywords.md\n lexer.ml\n+mir_dump\n+Session.vim\n src/etc/dl\n tmp.*.rs\n version.md"}, {"sha": "f3eb902709ca7167699e2c46eb6092a506774e10", "filename": ".gitmodules", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -53,3 +53,6 @@\n [submodule \"src/tools/lld\"]\n \tpath = src/tools/lld\n \turl = https://github.com/rust-lang/lld.git\n+[submodule \"src/libbacktrace\"]\n+\tpath = src/libbacktrace\n+\turl = https://github.com/rust-lang-nursery/libbacktrace"}, {"sha": "8f4287a438580315f099fb20566f3723e0e212af", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -51,6 +51,7 @@ Carol Willing <carolcode@willingconsulting.com>\n Chris C Cerami <chrisccerami@users.noreply.github.com> Chris C Cerami <chrisccerami@gmail.com>\n Chris Pressey <cpressey@gmail.com>\n Chris Thorn <chris@thorn.co> Chris Thorn <thorn@thoughtbot.com>\n+Chris Vittal <christopher.vittal@gmail.com> Christopher Vittal <christopher.vittal@gmail.com>\n Clark Gaebel <cg.wowus.cg@gmail.com> <cgaebel@mozilla.com>\n Clinton Ryan <clint.ryan3@gmail.com>\n Corey Richardson <corey@octayn.net> Elaine \"See More\" Nemo <corey@octayn.net>"}, {"sha": "0228fdc994dd769b5512c55a074dafd2dcffddd1", "filename": ".travis.yml", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -3,6 +3,10 @@ sudo: required\n dist: trusty\n services:\n   - docker\n+addons:\n+  apt:\n+    packages:\n+      - gdb\n \n git:\n   depth: 2\n@@ -12,7 +16,7 @@ matrix:\n   fast_finish: true\n   include:\n     # Images used in testing PR and try-build should be run first.\n-    - env: IMAGE=x86_64-gnu-llvm-3.9 RUST_BACKTRACE=1\n+    - env: IMAGE=x86_64-gnu-llvm-5.0 RUST_BACKTRACE=1\n       if: type = pull_request OR branch = auto\n \n     - env: IMAGE=dist-x86_64-linux DEPLOY=1\n@@ -169,7 +173,7 @@ matrix:\n     - env: IMAGE=x86_64-gnu-aux\n       if: branch = auto\n     - env: IMAGE=x86_64-gnu-tools\n-      if: branch = auto\n+      if: branch = auto OR (type = pull_request AND commit_message =~ /(?i:^update.*\\b(rls|rustfmt|clippy|miri)\\b)/)\n     - env: IMAGE=x86_64-gnu-debug\n       if: branch = auto\n     - env: IMAGE=x86_64-gnu-nopt\n@@ -197,7 +201,7 @@ env:\n     # AWS_SECRET_ACCESS_KEY=...\n     - secure: \"j96XxTVOSUf4s4r4htIxn/fvIa5DWbMgLqWl7r8z2QfgUwscmkMXAwXuFNc7s7bGTpV/+CgDiMFFM6BAFLGKutytIF6oA02s9b+usQYnM0th7YQ2AIgm9GtMTJCJp4AoyfFmh8F2faUICBZlfVLUJ34udHEe35vOklix+0k4WDo=\"\n     # TOOLSTATE_REPO_ACCESS_TOKEN=...\n-    - secure: \"cFh8thThqEJLC98XKI5pfqflUzOlxsYPRW20AWRaYOOgYHPTiGWypTXiPbGSKaeAXTZoOA+DpQtEmefc0U6lt9dHc7a/MIaK6isFurjlnKYiLOeTruzyu1z7PWCeZ/jKXsU2RK/88DBtlNwfMdaMIeuKj14IVfpepPPL71ETbuk=\"\n+    - secure: \"ESfcXqv4N2VMhqi2iIyw6da9VrsA78I4iR1asouCaq4hzTTrkB4WNRrfURy6xg72gQ4nMhtRJbB0/2jmc9Cu1+g2CzXtyiL223aJ5CKrXdcvbitopQSDfp07dMWm+UED+hNFEanpErKAeU/6FM3A+J+60PMk8MCF1h9tqNRISJw=\"\n \n before_install:\n   # We'll use the AWS cli to download/upload cached docker layers, so install\n@@ -230,7 +234,11 @@ install:\n           travis_retry curl -fo /usr/local/bin/sccache https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2018-04-02-sccache-x86_64-apple-darwin &&\n             chmod +x /usr/local/bin/sccache &&\n           travis_retry curl -fo /usr/local/bin/stamp https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-03-17-stamp-x86_64-apple-darwin &&\n-            chmod +x /usr/local/bin/stamp\n+            chmod +x /usr/local/bin/stamp &&\n+          travis_retry curl -f http://releases.llvm.org/6.0.0/clang+llvm-6.0.0-x86_64-apple-darwin.tar.xz | tar xJf - &&\n+            export CC=`pwd`/clang+llvm-6.0.0-x86_64-apple-darwin/bin/clang &&\n+            export CXX=`pwd`/clang+llvm-6.0.0-x86_64-apple-darwin/bin/clang++ &&\n+            export AR=ar\n           ;;\n     esac\n \n@@ -245,6 +253,8 @@ before_script:\n           export RUN_SCRIPT=\"$RUN_SCRIPT && src/ci/run.sh\";\n       else\n           export RUN_SCRIPT=\"$RUN_SCRIPT && src/ci/docker/run.sh $IMAGE\";\n+          # Enable core dump on Linux.\n+          sudo sh -c 'echo \"/checkout/obj/cores/core.%p.%E\" > /proc/sys/kernel/core_pattern';\n       fi\n \n # Log time information from this machine and an external machine for insight into possible\n@@ -270,6 +280,8 @@ after_failure:\n \n   # Random attempt at debugging currently. Just poking around in here to see if\n   # anything shows up.\n+\n+  # Dump backtrace for macOS\n   - ls -lat $HOME/Library/Logs/DiagnosticReports/\n   - find $HOME/Library/Logs/DiagnosticReports\n       -type f\n@@ -280,6 +292,25 @@ after_failure:\n       -exec head -750 {} \\;\n       -exec echo travis_fold\":\"end:crashlog \\; || true\n \n+  # Dump backtrace for Linux\n+  - ln -s . checkout &&\n+    for CORE in obj/cores/core.*; do\n+      EXE=$(echo $CORE | sed 's|obj/cores/core\\.[0-9]*\\.!checkout!\\(.*\\)|\\1|;y|!|/|');\n+      if [ -f \"$EXE\" ]; then\n+        printf travis_fold\":start:crashlog\\n\\033[31;1m%s\\033[0m\\n\" \"$CORE\";\n+        gdb -q -c \"$CORE\" \"$EXE\"\n+          -iex 'set auto-load off'\n+          -iex 'dir src/'\n+          -iex 'set sysroot .'\n+          -ex bt\n+          -ex q;\n+        echo travis_fold\":\"end:crashlog;\n+      fi;\n+    done || true\n+\n+  # see #50887\n+  - cat ./obj/build/x86_64-unknown-linux-gnu/native/asan/build/lib/asan/clang_rt.asan-dynamic-i386.vers || true\n+\n   # attempt to debug anything killed by the oom killer on linux, just to see if\n   # it happened\n   - dmesg | grep -i kill\n@@ -297,7 +328,6 @@ before_deploy:\n           rm -rf obj/build/dist/doc &&\n           cp -r obj/build/dist/* deploy/$TRAVIS_COMMIT;\n       fi\n-  - travis_retry gem update --system\n   - ls -la deploy/$TRAVIS_COMMIT\n \n deploy:"}, {"sha": "ea9f2c194300507798ef377ea2f821035d82a5d1", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -48,7 +48,7 @@ always work, and sometimes it's hard to know what to search for, so consider thi\n extra credit. We won't mind if you accidentally file a duplicate report.\n \n Similarly, to help others who encountered the bug find your issue,\n-consider filing an issue with with a descriptive title, which contains information that might be unique to it.\n+consider filing an issue with a descriptive title, which contains information that might be unique to it.\n This can be the language or compiler feature used, the conditions that trigger the bug,\n or part of the error message if there is any.\n An example could be: **\"impossible case reached\" on lifetime inference for impl Trait in return position**.\n@@ -142,7 +142,7 @@ file. If you still have a `config.mk` file in your directory - from\n ### Building\n [building]: #building\n \n-A default configuration shall use around 3.5 GB of disk space, whereas building a debug configuration may require more than 30 GB.\n+A default configuration requires around 3.5 GB of disk space, whereas building a debug configuration may require more than 30 GB.\n \n Dependencies\n - [build dependencies](README.md#building-from-source)"}, {"sha": "a2acfe8b478e28579028b5097644cbb8e759ca8a", "filename": "README.md", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -38,6 +38,7 @@ Read [\"Installation\"] from [The Book].\n 3. Build and install:\n \n     ```sh\n+    $ git submodule update --init --recursive --progress\n     $ ./x.py build && sudo ./x.py install\n     ```\n \n@@ -119,7 +120,7 @@ shell with:\n > python x.py build\n ```\n \n-Currently building Rust only works with some known versions of Visual Studio. If\n+Currently, building Rust only works with some known versions of Visual Studio. If\n you have a more recent version installed the build system doesn't understand\n then you may need to force rustbuild to use an older version. This can be done\n by manually calling the appropriate vcvars file before running the bootstrap.\n@@ -133,7 +134,7 @@ python x.py build\n [specifying-an-abi]: #specifying-an-abi\n \n Each specific ABI can also be used from either environment (for example, using\n-the GNU ABI in powershell) by using an explicit build triple. The available\n+the GNU ABI in PowerShell) by using an explicit build triple. The available\n Windows build triples are:\n - GNU ABI (using GCC)\n     - `i686-pc-windows-gnu`\n@@ -179,7 +180,7 @@ the ABI used. I.e., if the ABI was `x86_64-pc-windows-msvc`, the directory will\n [notes]: #notes\n \n Since the Rust compiler is written in Rust, it must be built by a\n-precompiled \"snapshot\" version of itself (made in an earlier state of\n+precompiled \"snapshot\" version of itself (made in an earlier stage of\n development). As such, source builds require a connection to the Internet, to\n fetch snapshots, and an OS that can execute the available snapshot binaries.\n \n@@ -224,13 +225,16 @@ variety of channels on Mozilla's IRC network, irc.mozilla.org. The\n most popular channel is [#rust], a venue for general discussion about\n Rust. And a good place to ask for help would be [#rust-beginners].\n \n-Also, the [rustc guide] might be a good place to start if you want to\n-find out how various parts of the compiler work.\n+The [rustc guide] might be a good place to start if you want to find out how\n+various parts of the compiler work.\n+\n+Also, you may find the [rustdocs for the compiler itself][rustdocs] useful.\n \n [IRC]: https://en.wikipedia.org/wiki/Internet_Relay_Chat\n [#rust]: irc://irc.mozilla.org/rust\n [#rust-beginners]: irc://irc.mozilla.org/rust-beginners\n [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/about-this-guide.html\n+[rustdocs]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/\n \n ## License\n [license]: #license"}, {"sha": "b983851f881987a11089e8409ca0c5666e378c5f", "filename": "RELEASES.md", "status": "modified", "additions": 576, "deletions": 4, "changes": 580, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -1,9 +1,581 @@\n+Version 1.28.0 (2018-08-02)\n+===========================\n+\n+Language\n+--------\n+- [The `#[repr(transparent)]` attribute is now stable.][51562] This attribute\n+  allows a Rust newtype wrapper (`struct NewType<T>(T);`) to be represented as\n+  the inner type across Foreign Function Interface (FFI) boundaries.\n+- [The keywords `pure`, `sizeof`, `alignof`, and `offsetof` have been unreserved\n+  and can now be used as identifiers.][51196]\n+- [The `GlobalAlloc` trait and `#[global_allocator]` attribute are now\n+  stable.][51241] This will allow users to specify a global allocator for\n+  their program.\n+- [Unit test functions marked with the `#[test]` attribute can now return\n+  `Result<(), E: Debug>` in addition to `()`.][51298]\n+- [The `lifetime` specifier for `macro_rules!` is now stable.][50385] This\n+  allows macros to easily target lifetimes.\n+\n+Compiler\n+--------\n+- [The `s` and `z` optimisation levels are now stable.][50265] These optimisations\n+  prioritise making smaller binary sizes. `z` is the same as `s` with the\n+  exception that it does not vectorise loops, which typically results in an even\n+  smaller binary.\n+- [The short error format is now stable.][49546] Specified with\n+  `--error-format=short` this option will provide a more compressed output of\n+  rust error messages.\n+- [Added a lint warning when you have duplicated `macro_export`s.][50143]\n+- [Reduced the number of allocations in the macro parser.][50855] This can\n+  improve compile times of macro heavy crates on average by 5%.\n+\n+Libraries\n+---------\n+- [Implemented `Default` for `&mut str`.][51306]\n+- [Implemented `From<bool>` for all integer and unsigned number types.][50554]\n+- [Implemented `Extend` for `()`.][50234]\n+- [The `Debug` implementation of `time::Duration` should now be more easily\n+  human readable.][50364] Previously a `Duration` of one second would printed as\n+  `Duration { secs: 1, nanos: 0 }` and will now be printed as `1s`.\n+- [Implemented `From<&String>` for `Cow<str>`, `From<&Vec<T>>` for `Cow<[T]>`,\n+  `From<Cow<CStr>>` for `CString`, `From<CString>, From<CStr>, From<&CString>`\n+  for `Cow<CStr>`, `From<OsString>, From<OsStr>, From<&OsString>` for\n+  `Cow<OsStr>`, `From<&PathBuf>` for `Cow<Path>`, and `From<Cow<Path>>`\n+  for `PathBuf`.][50170]\n+- [Implemented `Shl` and `Shr` for `Wrapping<u128>`\n+  and `Wrapping<i128>`.][50465]\n+- [`DirEntry::metadata` now uses `fstatat` instead of `lstat` when\n+  possible.][51050] This can provide up to a 40% speed increase.\n+- [Improved error messages when using `format!`.][50610]\n+\n+Stabilized APIs\n+---------------\n+- [`Iterator::step_by`]\n+- [`Path::ancestors`]\n+- [`SystemTime::UNIX_EPOCH`]\n+- [`alloc::GlobalAlloc`]\n+- [`alloc::Layout`]\n+- [`alloc::LayoutErr`]\n+- [`alloc::System`]\n+- [`alloc::alloc`]\n+- [`alloc::alloc_zeroed`]\n+- [`alloc::dealloc`]\n+- [`alloc::realloc`]\n+- [`alloc::handle_alloc_error`]\n+- [`btree_map::Entry::or_default`]\n+- [`fmt::Alignment`]\n+- [`hash_map::Entry::or_default`]\n+- [`iter::repeat_with`]\n+- [`num::NonZeroUsize`]\n+- [`num::NonZeroU128`]\n+- [`num::NonZeroU16`]\n+- [`num::NonZeroU32`]\n+- [`num::NonZeroU64`]\n+- [`num::NonZeroU8`]\n+- [`ops::RangeBounds`]\n+- [`slice::SliceIndex`]\n+- [`slice::from_mut`]\n+- [`slice::from_ref`]\n+- [`{Any + Send + Sync}::downcast_mut`]\n+- [`{Any + Send + Sync}::downcast_ref`]\n+- [`{Any + Send + Sync}::is`]\n+\n+Cargo\n+-----\n+- [Cargo will now no longer allow you to publish crates with build scripts that\n+  modify the `src` directory.][cargo/5584] The `src` directory in a crate should be\n+  considered to be immutable.\n+\n+Misc\n+----\n+- [The `suggestion_applicability` field in `rustc`'s json output is now\n+  stable.][50486] This will allow dev tools to check whether a code suggestion\n+  would apply to them.\n+\n+Compatibility Notes\n+-------------------\n+- [Rust will no longer consider trait objects with duplicated constraints to\n+  have implementations.][51276] For example the below code will now fail\n+  to compile.\n+  ```rust\n+  trait Trait {}\n+\n+  impl Trait + Send {\n+      fn test(&self) { println!(\"one\"); } //~ ERROR duplicate definitions with name `test`\n+  }\n+\n+  impl Trait + Send + Send {\n+      fn test(&self) { println!(\"two\"); }\n+  }\n+  ```\n+\n+[49546]: https://github.com/rust-lang/rust/pull/49546/\n+[50143]: https://github.com/rust-lang/rust/pull/50143/\n+[50170]: https://github.com/rust-lang/rust/pull/50170/\n+[50234]: https://github.com/rust-lang/rust/pull/50234/\n+[50265]: https://github.com/rust-lang/rust/pull/50265/\n+[50364]: https://github.com/rust-lang/rust/pull/50364/\n+[50385]: https://github.com/rust-lang/rust/pull/50385/\n+[50465]: https://github.com/rust-lang/rust/pull/50465/\n+[50486]: https://github.com/rust-lang/rust/pull/50486/\n+[50554]: https://github.com/rust-lang/rust/pull/50554/\n+[50610]: https://github.com/rust-lang/rust/pull/50610/\n+[50855]: https://github.com/rust-lang/rust/pull/50855/\n+[51050]: https://github.com/rust-lang/rust/pull/51050/\n+[51196]: https://github.com/rust-lang/rust/pull/51196/\n+[51200]: https://github.com/rust-lang/rust/pull/51200/\n+[51241]: https://github.com/rust-lang/rust/pull/51241/\n+[51276]: https://github.com/rust-lang/rust/pull/51276/\n+[51298]: https://github.com/rust-lang/rust/pull/51298/\n+[51306]: https://github.com/rust-lang/rust/pull/51306/\n+[51562]: https://github.com/rust-lang/rust/pull/51562/\n+[cargo/5584]: https://github.com/rust-lang/cargo/pull/5584/\n+[`Iterator::step_by`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.step_by\n+[`Path::ancestors`]: https://doc.rust-lang.org/std/path/struct.Path.html#method.ancestors\n+[`SystemTime::UNIX_EPOCH`]: https://doc.rust-lang.org/std/time/struct.SystemTime.html#associatedconstant.UNIX_EPOCH\n+[`alloc::GlobalAlloc`]: https://doc.rust-lang.org/std/alloc/trait.GlobalAlloc.html\n+[`alloc::Layout`]: https://doc.rust-lang.org/std/alloc/struct.Layout.html\n+[`alloc::LayoutErr`]: https://doc.rust-lang.org/std/alloc/struct.LayoutErr.html\n+[`alloc::System`]: https://doc.rust-lang.org/std/alloc/struct.System.html\n+[`alloc::alloc`]: https://doc.rust-lang.org/std/alloc/fn.alloc.html\n+[`alloc::alloc_zeroed`]: https://doc.rust-lang.org/std/alloc/fn.alloc_zeroed.html\n+[`alloc::dealloc`]: https://doc.rust-lang.org/std/alloc/fn.dealloc.html\n+[`alloc::realloc`]: https://doc.rust-lang.org/std/alloc/fn.realloc.html\n+[`alloc::handle_alloc_error`]: https://doc.rust-lang.org/std/alloc/fn.handle_alloc_error.html\n+[`btree_map::Entry::or_default`]: https://doc.rust-lang.org/std/collections/btree_map/enum.Entry.html#method.or_default\n+[`fmt::Alignment`]: https://doc.rust-lang.org/std/fmt/enum.Alignment.html\n+[`hash_map::Entry::or_default`]: https://doc.rust-lang.org/std/collections/btree_map/enum.Entry.html#method.or_default\n+[`iter::repeat_with`]: https://doc.rust-lang.org/std/iter/fn.repeat_with.html\n+[`num::NonZeroUsize`]: https://doc.rust-lang.org/std/num/struct.NonZeroUsize.html\n+[`num::NonZeroU128`]: https://doc.rust-lang.org/std/num/struct.NonZeroU128.html\n+[`num::NonZeroU16`]: https://doc.rust-lang.org/std/num/struct.NonZeroU16.html\n+[`num::NonZeroU32`]: https://doc.rust-lang.org/std/num/struct.NonZeroU32.html\n+[`num::NonZeroU64`]: https://doc.rust-lang.org/std/num/struct.NonZeroU64.html\n+[`num::NonZeroU8`]: https://doc.rust-lang.org/std/num/struct.NonZeroU8.html\n+[`ops::RangeBounds`]: https://doc.rust-lang.org/std/ops/trait.RangeBounds.html\n+[`slice::SliceIndex`]: https://doc.rust-lang.org/std/slice/trait.SliceIndex.html\n+[`slice::from_mut`]: https://doc.rust-lang.org/std/slice/fn.from_mut.html\n+[`slice::from_ref`]: https://doc.rust-lang.org/std/slice/fn.from_ref.html\n+[`{Any + Send + Sync}::downcast_mut`]: https://doc.rust-lang.org/std/any/trait.Any.html#method.downcast_mut-2\n+[`{Any + Send + Sync}::downcast_ref`]: https://doc.rust-lang.org/std/any/trait.Any.html#method.downcast_ref-2\n+[`{Any + Send + Sync}::is`]: https://doc.rust-lang.org/std/any/trait.Any.html#method.is-2\n+\n+Version 1.27.1 (2018-07-10)\n+===========================\n+\n+Security Notes\n+--------------\n+\n+- rustdoc would execute plugins in the /tmp/rustdoc/plugins directory\n+  when running, which enabled executing code as some other user on a\n+  given machine. This release fixes that vulnerability; you can read\n+  more about this on the [blog][rustdoc-sec]. The associated CVE is [CVE-2018-1000622].\n+\n+  Thank you to Red Hat for responsibily disclosing this vulnerability to us.\n+\n+Compatibility Notes\n+-------------------\n+\n+- The borrow checker was fixed to avoid an additional potential unsoundness when using\n+  match ergonomics: [#51415][51415], [#49534][49534].\n+\n+[51415]: https://github.com/rust-lang/rust/issues/51415\n+[49534]: https://github.com/rust-lang/rust/issues/49534\n+[rustdoc-sec]: https://blog.rust-lang.org/2018/07/06/security-advisory-for-rustdoc.html\n+[CVE-2018-1000622]: https://cve.mitre.org/cgi-bin/cvename.cgi?name=%20CVE-2018-1000622\n+\n+Version 1.27.0 (2018-06-21)\n+==========================\n+\n+Language\n+--------\n+- [Removed 'proc' from the reserved keywords list.][49699] This allows `proc` to\n+  be used as an identifer.\n+- [The dyn syntax is now available.][49968] This syntax is equivalent to the\n+  bare `Trait` syntax, and should make it clearer when being used in tandem with\n+  `impl Trait`. Since it is equivalent to the following syntax:\n+  `&Trait == &dyn Trait`, `&mut Trait == &mut dyn Trait`, and\n+  `Box<Trait> == Box<dyn Trait>`.\n+- [Attributes on generic parameters such as types and lifetimes are\n+  now stable.][48851] e.g.\n+  `fn foo<#[lifetime_attr] 'a, #[type_attr] T: 'a>() {}`\n+- [The `#[must_use]` attribute can now also be used on functions as well as\n+  types.][48925] It provides a lint that by default warns users when the\n+  value returned by a function has not been used.\n+\n+Compiler\n+--------\n+- [Added the `armv5te-unknown-linux-musl` target.][50423]\n+\n+Libraries\n+---------\n+- [SIMD (Single Instruction Multiple Data) on x86/x86_64 is now stable.][49664]\n+  This includes [`arch::x86`] & [`arch::x86_64`] modules which contain\n+  SIMD intrinsics, a new macro called `is_x86_feature_detected!`, the\n+  `#[target_feature(enable=\"\")]` attribute, and adding `target_feature = \"\"` to\n+  the `cfg` attribute.\n+- [A lot of methods for `[u8]`, `f32`, and `f64` previously only available in\n+  std are now available in core.][49896]\n+- [The generic `Rhs` type parameter on `ops::{Shl, ShlAssign, Shr}` now defaults\n+  to `Self`.][49630]\n+- [`std::str::replace` now has the `#[must_use]` attribute][50177] to clarify\n+  that the operation isn't done in place.\n+- [`Clone::clone`, `Iterator::collect`, and `ToOwned::to_owned` now have\n+  the `#[must_use]` attribute][49533] to warn about unused potentially\n+  expensive allocations.\n+\n+Stabilized APIs\n+---------------\n+- [`DoubleEndedIterator::rfind`]\n+- [`DoubleEndedIterator::rfold`]\n+- [`DoubleEndedIterator::try_rfold`]\n+- [`Duration::from_micros`]\n+- [`Duration::from_nanos`]\n+- [`Duration::subsec_micros`]\n+- [`Duration::subsec_millis`]\n+- [`HashMap::remove_entry`]\n+- [`Iterator::try_fold`]\n+- [`Iterator::try_for_each`]\n+- [`NonNull::cast`]\n+- [`Option::filter`]\n+- [`String::replace_range`]\n+- [`Take::set_limit`]\n+- [`hint::unreachable_unchecked`]\n+- [`os::unix::process::parent_id`]\n+- [`ptr::swap_nonoverlapping`]\n+- [`slice::rsplit_mut`]\n+- [`slice::rsplit`]\n+- [`slice::swap_with_slice`]\n+\n+Cargo\n+-----\n+- [`cargo-metadata` now includes `authors`, `categories`, `keywords`,\n+  `readme`, and `repository` fields.][cargo/5386]\n+- [`cargo-metadata` now includes a package's `metadata` table.][cargo/5360]\n+- [Added the `--target-dir` optional argument.][cargo/5393] This allows you to specify\n+  a different directory than `target` for placing compilation artifacts.\n+- [Cargo will be adding automatic target inference for binaries, benchmarks,\n+  examples, and tests in the Rust 2018 edition.][cargo/5335] If your project specifies\n+  specific targets e.g. using `[[bin]]` and have other binaries in locations\n+  where cargo would infer a binary, Cargo will produce a warning. You can\n+  disable this feature ahead of time by setting any of the following `autobins`,\n+  `autobenches`, `autoexamples`, `autotests` to false.\n+- [Cargo will now cache compiler information.][cargo/5359] This can be disabled by\n+  setting `CARGO_CACHE_RUSTC_INFO=0` in your environment.\n+\n+Misc\n+----\n+- [Added \u201cThe Rustc book\u201d into the official documentation.][49707]\n+  [\u201cThe Rustc book\u201d] documents and teaches how to use the rustc compiler.\n+- [All books available on `doc.rust-lang.org` are now searchable.][49623]\n+\n+Compatibility Notes\n+-------------------\n+- [Calling a `CharExt` or `StrExt` method directly on core will no longer\n+  work.][49896] e.g. `::core::prelude::v1::StrExt::is_empty(\"\")` will not\n+  compile, `\"\".is_empty()` will still compile.\n+- [`Debug` output on `atomic::{AtomicBool, AtomicIsize, AtomicPtr, AtomicUsize}`\n+  will only print the inner type.][48553] e.g.\n+  `print!(\"{:?}\", AtomicBool::new(true))` will print `true`\n+  not `AtomicBool(true)`.\n+- [The maximum number for `repr(align(N))` is now 2\u00b2\u2079.][50378] Previously you\n+  could enter higher numbers but they were not supported by LLVM. Up to 512MB\n+  alignment should cover all use cases.\n+\n+[48553]: https://github.com/rust-lang/rust/pull/48553/\n+[48851]: https://github.com/rust-lang/rust/pull/48851/\n+[48925]: https://github.com/rust-lang/rust/pull/48925/\n+[49533]: https://github.com/rust-lang/rust/pull/49533/\n+[49623]: https://github.com/rust-lang/rust/pull/49623/\n+[49630]: https://github.com/rust-lang/rust/pull/49630/\n+[49664]: https://github.com/rust-lang/rust/pull/49664/\n+[49699]: https://github.com/rust-lang/rust/pull/49699/\n+[49707]: https://github.com/rust-lang/rust/pull/49707/\n+[49719]: https://github.com/rust-lang/rust/pull/49719/\n+[49896]: https://github.com/rust-lang/rust/pull/49896/\n+[49968]: https://github.com/rust-lang/rust/pull/49968/\n+[50177]: https://github.com/rust-lang/rust/pull/50177/\n+[50378]: https://github.com/rust-lang/rust/pull/50378/\n+[50398]: https://github.com/rust-lang/rust/pull/50398/\n+[50423]: https://github.com/rust-lang/rust/pull/50423/\n+[cargo/5203]: https://github.com/rust-lang/cargo/pull/5203/\n+[cargo/5335]: https://github.com/rust-lang/cargo/pull/5335/\n+[cargo/5359]: https://github.com/rust-lang/cargo/pull/5359/\n+[cargo/5360]: https://github.com/rust-lang/cargo/pull/5360/\n+[cargo/5386]: https://github.com/rust-lang/cargo/pull/5386/\n+[cargo/5393]: https://github.com/rust-lang/cargo/pull/5393/\n+[`DoubleEndedIterator::rfind`]: https://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html#method.rfind\n+[`DoubleEndedIterator::rfold`]: https://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html#method.rfold\n+[`DoubleEndedIterator::try_rfold`]: https://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html#method.try_rfold\n+[`Duration::from_micros`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.from_micros\n+[`Duration::from_nanos`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.from_nanos\n+[`Duration::subsec_micros`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.subsec_micros\n+[`Duration::subsec_millis`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.subsec_millis\n+[`HashMap::remove_entry`]: https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.remove_entry\n+[`Iterator::try_fold`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.try_fold\n+[`Iterator::try_for_each`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.try_for_each\n+[`NonNull::cast`]: https://doc.rust-lang.org/std/ptr/struct.NonNull.html#method.cast\n+[`Option::filter`]: https://doc.rust-lang.org/std/option/enum.Option.html#method.filter\n+[`String::replace_range`]: https://doc.rust-lang.org/std/string/struct.String.html#method.replace_range\n+[`Take::set_limit`]: https://doc.rust-lang.org/std/io/struct.Take.html#method.set_limit\n+[`hint::unreachable_unchecked`]: https://doc.rust-lang.org/std/hint/fn.unreachable_unchecked.html\n+[`os::unix::process::parent_id`]: https://doc.rust-lang.org/std/os/unix/process/fn.parent_id.html\n+[`process::id`]: https://doc.rust-lang.org/std/process/fn.id.html\n+[`ptr::swap_nonoverlapping`]: https://doc.rust-lang.org/std/ptr/fn.swap_nonoverlapping.html\n+[`slice::rsplit_mut`]: https://doc.rust-lang.org/std/primitive.slice.html#method.rsplit_mut\n+[`slice::rsplit`]: https://doc.rust-lang.org/std/primitive.slice.html#method.rsplit\n+[`slice::swap_with_slice`]: https://doc.rust-lang.org/std/primitive.slice.html#method.swap_with_slice\n+[`arch::x86_64`]: https://doc.rust-lang.org/std/arch/x86_64/index.html\n+[`arch::x86`]: https://doc.rust-lang.org/std/arch/x86/index.html\n+[\u201cThe Rustc book\u201d]: https://doc.rust-lang.org/rustc\n+\n+\n+Version 1.26.2 (2018-06-05)\n+==========================\n+\n+Compatibility Notes\n+-------------------\n+\n+- [The borrow checker was fixed to avoid unsoundness when using match ergonomics][51117]\n+\n+[51117]: https://github.com/rust-lang/rust/issues/51117\n+\n+\n+Version 1.26.1 (2018-05-29)\n+==========================\n+\n+Tools\n+-----\n+\n+- [RLS now works on Windows][50646]\n+- [Rustfmt stopped badly formatting text in some cases][rustfmt/2695]\n+\n+\n+Compatibility Notes\n+--------\n+\n+- [`fn main() -> impl Trait` no longer works for non-Termination\n+  trait][50656]\n+  This reverts an accidental stabilization.\n+- [`NaN > NaN` no longer returns true in const-fn contexts][50812]\n+- [Prohibit using turbofish for `impl Trait` in method arguments][50950]\n+\n+[50646]: https://github.com/rust-lang/rust/issues/50646\n+[50656]: https://github.com/rust-lang/rust/pull/50656\n+[50812]: https://github.com/rust-lang/rust/pull/50812\n+[50950]: https://github.com/rust-lang/rust/issues/50950\n+[rustfmt/2695]: https://github.com/rust-lang-nursery/rustfmt/issues/2695\n+\n+Version 1.26.0 (2018-05-10)\n+==========================\n+\n+Language\n+--------\n+- [Closures now implement `Copy` and/or `Clone` if all captured variables\n+  implement either or both traits.][49299]\n+- [The inclusive range syntax e.g. `for x in 0..=10` is now stable.][47813]\n+- [The `'_` lifetime is now stable. The underscore lifetime can be used anywhere where a\n+  lifetime can be elided.][49458]\n+- [`impl Trait` is now stable allowing you to have abstract types in returns\n+   or in function parameters.][49255] e.g. `fn foo() -> impl Iterator<Item=u8>` or\n+  `fn open(path: impl AsRef<Path>)`.\n+- [Pattern matching will now automatically apply dereferences.][49394]\n+- [128-bit integers in the form of `u128` and `i128` are now stable.][49101]\n+- [`main` can now return `Result<(), E: Debug>`][49162] in addition to `()`.\n+- [A lot of operations are now available in a const context.][46882] E.g. You\n+  can now index into constant arrays, reference and dereference into constants,\n+  and use Tuple struct constructors.\n+- [Fixed entry slice patterns are now stable.][48516] e.g.\n+  ```rust\n+  let points = [1, 2, 3, 4];\n+  match points {\n+      [1, 2, 3, 4] => println!(\"All points were sequential.\"),\n+      _ => println!(\"Not all points were sequential.\"),\n+  }\n+  ```\n+\n+\n+Compiler\n+--------\n+- [LLD is now used as the default linker for `wasm32-unknown-unknown`.][48125]\n+- [Fixed exponential projection complexity on nested types.][48296]\n+  This can provide up to a ~12% reduction in compile times for certain crates.\n+- [Added the `--remap-path-prefix` option to rustc.][48359] Allowing you\n+  to remap path prefixes outputted by the compiler.\n+- [Added `powerpc-unknown-netbsd` target.][48281]\n+\n+Libraries\n+---------\n+- [Implemented `From<u16> for usize` & `From<{u8, i16}> for isize`.][49305]\n+- [Added hexadecimal formatting for integers with fmt::Debug][48978]\n+  e.g. `assert!(format!(\"{:02x?}\", b\"Foo\\0\") == \"[46, 6f, 6f, 00]\")`\n+- [Implemented `Default, Hash` for `cmp::Reverse`.][48628]\n+- [Optimized `str::repeat` being 8x faster in large cases.][48657]\n+- [`ascii::escape_default` is now available in libcore.][48735]\n+- [Trailing commas are now supported in std and core macros.][48056]\n+- [Implemented `Copy, Clone` for `cmp::Reverse`][47379]\n+- [Implemented `Clone` for `char::{ToLowercase, ToUppercase}`.][48629]\n+\n+Stabilized APIs\n+---------------\n+- [`*const T::add`]\n+- [`*const T::copy_to_nonoverlapping`]\n+- [`*const T::copy_to`]\n+- [`*const T::read_unaligned`]\n+- [`*const T::read_volatile`]\n+- [`*const T::read`]\n+- [`*const T::sub`]\n+- [`*const T::wrapping_add`]\n+- [`*const T::wrapping_sub`]\n+- [`*mut T::add`]\n+- [`*mut T::copy_to_nonoverlapping`]\n+- [`*mut T::copy_to`]\n+- [`*mut T::read_unaligned`]\n+- [`*mut T::read_volatile`]\n+- [`*mut T::read`]\n+- [`*mut T::replace`]\n+- [`*mut T::sub`]\n+- [`*mut T::swap`]\n+- [`*mut T::wrapping_add`]\n+- [`*mut T::wrapping_sub`]\n+- [`*mut T::write_bytes`]\n+- [`*mut T::write_unaligned`]\n+- [`*mut T::write_volatile`]\n+- [`*mut T::write`]\n+- [`Box::leak`]\n+- [`FromUtf8Error::as_bytes`]\n+- [`LocalKey::try_with`]\n+- [`Option::cloned`]\n+- [`btree_map::Entry::and_modify`]\n+- [`fs::read_to_string`]\n+- [`fs::read`]\n+- [`fs::write`]\n+- [`hash_map::Entry::and_modify`]\n+- [`iter::FusedIterator`]\n+- [`ops::RangeInclusive`]\n+- [`ops::RangeToInclusive`]\n+- [`process::id`]\n+- [`slice::rotate_left`]\n+- [`slice::rotate_right`]\n+- [`String::retain`]\n+\n+\n+Cargo\n+-----\n+- [Cargo will now output path to custom commands when `-v` is\n+  passed with `--list`][cargo/5041]\n+- [The Cargo binary version is now the same as the Rust version][cargo/5083]\n+\n+Misc\n+----\n+- [The second edition of \"The Rust Programming Language\" book is now recommended\n+  over the first.][48404]\n+\n+Compatibility Notes\n+-------------------\n+\n+- [aliasing a `Fn` trait as `dyn` no longer works.][48481] E.g. the following\n+  syntax is now invalid.\n+  ```\n+  use std::ops::Fn as dyn;\n+  fn g(_: Box<dyn(std::fmt::Debug)>) {}\n+  ```\n+- [The result of dereferences are no longer promoted to `'static`.][47408]\n+  e.g.\n+  ```rust\n+  fn main() {\n+      const PAIR: &(i32, i32) = &(0, 1);\n+      let _reversed_pair: &'static _ = &(PAIR.1, PAIR.0); // Doesn't work\n+  }\n+  ```\n+- [Deprecate `AsciiExt` trait in favor of inherent methods.][49109]\n+- [`\".e0\"` will now no longer parse as `0.0` and will instead cause\n+  an error.][48235]\n+- [Removed hoedown from rustdoc.][48274]\n+- [Bounds on higher-kinded lifetimes a hard error.][48326]\n+\n+[46882]: https://github.com/rust-lang/rust/pull/46882\n+[47379]: https://github.com/rust-lang/rust/pull/47379\n+[47408]: https://github.com/rust-lang/rust/pull/47408\n+[47813]: https://github.com/rust-lang/rust/pull/47813\n+[48056]: https://github.com/rust-lang/rust/pull/48056\n+[48125]: https://github.com/rust-lang/rust/pull/48125\n+[48166]: https://github.com/rust-lang/rust/pull/48166\n+[48235]: https://github.com/rust-lang/rust/pull/48235\n+[48274]: https://github.com/rust-lang/rust/pull/48274\n+[48281]: https://github.com/rust-lang/rust/pull/48281\n+[48296]: https://github.com/rust-lang/rust/pull/48296\n+[48326]: https://github.com/rust-lang/rust/pull/48326\n+[48359]: https://github.com/rust-lang/rust/pull/48359\n+[48404]: https://github.com/rust-lang/rust/pull/48404\n+[48481]: https://github.com/rust-lang/rust/pull/48481\n+[48516]: https://github.com/rust-lang/rust/pull/48516\n+[48628]: https://github.com/rust-lang/rust/pull/48628\n+[48629]: https://github.com/rust-lang/rust/pull/48629\n+[48657]: https://github.com/rust-lang/rust/pull/48657\n+[48735]: https://github.com/rust-lang/rust/pull/48735\n+[48978]: https://github.com/rust-lang/rust/pull/48978\n+[49101]: https://github.com/rust-lang/rust/pull/49101\n+[49109]: https://github.com/rust-lang/rust/pull/49109\n+[49121]: https://github.com/rust-lang/rust/pull/49121\n+[49162]: https://github.com/rust-lang/rust/pull/49162\n+[49184]: https://github.com/rust-lang/rust/pull/49184\n+[49234]: https://github.com/rust-lang/rust/pull/49234\n+[49255]: https://github.com/rust-lang/rust/pull/49255\n+[49299]: https://github.com/rust-lang/rust/pull/49299\n+[49305]: https://github.com/rust-lang/rust/pull/49305\n+[49394]: https://github.com/rust-lang/rust/pull/49394\n+[49458]: https://github.com/rust-lang/rust/pull/49458\n+[`*const T::add`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.add\n+[`*const T::copy_to_nonoverlapping`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.copy_to_nonoverlapping\n+[`*const T::copy_to`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.copy_to\n+[`*const T::read_unaligned`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.read_unaligned\n+[`*const T::read_volatile`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.read_volatile\n+[`*const T::read`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.read\n+[`*const T::sub`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.sub\n+[`*const T::wrapping_add`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.wrapping_add\n+[`*const T::wrapping_sub`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.wrapping_sub\n+[`*mut T::add`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.add-1\n+[`*mut T::copy_to_nonoverlapping`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.copy_to_nonoverlapping-1\n+[`*mut T::copy_to`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.copy_to-1\n+[`*mut T::read_unaligned`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.read_unaligned-1\n+[`*mut T::read_volatile`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.read_volatile-1\n+[`*mut T::read`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.read-1\n+[`*mut T::replace`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.replace\n+[`*mut T::sub`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.sub-1\n+[`*mut T::swap`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.swap\n+[`*mut T::wrapping_add`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.wrapping_add-1\n+[`*mut T::wrapping_sub`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.wrapping_sub-1\n+[`*mut T::write_bytes`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.write_bytes\n+[`*mut T::write_unaligned`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.write_unaligned\n+[`*mut T::write_volatile`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.write_volatile\n+[`*mut T::write`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.write\n+[`Box::leak`]: https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak\n+[`FromUtf8Error::as_bytes`]: https://doc.rust-lang.org/std/string/struct.FromUtf8Error.html#method.as_bytes\n+[`LocalKey::try_with`]: https://doc.rust-lang.org/std/thread/struct.LocalKey.html#method.try_with\n+[`Option::cloned`]: https://doc.rust-lang.org/std/option/enum.Option.html#method.cloned\n+[`btree_map::Entry::and_modify`]: https://doc.rust-lang.org/std/collections/btree_map/enum.Entry.html#method.and_modify\n+[`fs::read_to_string`]: https://doc.rust-lang.org/std/fs/fn.read_to_string.html\n+[`fs::read`]: https://doc.rust-lang.org/std/fs/fn.read.html\n+[`fs::write`]: https://doc.rust-lang.org/std/fs/fn.write.html\n+[`hash_map::Entry::and_modify`]: https://doc.rust-lang.org/std/collections/hash_map/enum.Entry.html#method.and_modify\n+[`iter::FusedIterator`]: https://doc.rust-lang.org/std/iter/trait.FusedIterator.html\n+[`ops::RangeInclusive`]: https://doc.rust-lang.org/std/ops/struct.RangeInclusive.html\n+[`ops::RangeToInclusive`]: https://doc.rust-lang.org/std/ops/struct.RangeToInclusive.html\n+[`process::id`]: https://doc.rust-lang.org/std/process/fn.id.html\n+[`slice::rotate_left`]: https://doc.rust-lang.org/std/primitive.slice.html#method.rotate_left\n+[`slice::rotate_right`]: https://doc.rust-lang.org/std/primitive.slice.html#method.rotate_right\n+[`String::retain`]: https://doc.rust-lang.org/std/string/struct.String.html#method.retain\n+[cargo/5041]: https://github.com/rust-lang/cargo/pull/5041\n+[cargo/5083]: https://github.com/rust-lang/cargo/pull/5083\n+\n+\n Version 1.25.0 (2018-03-29)\n ==========================\n \n Language\n --------\n-- [Stabilised `#[repr(align(x))]`.][47006] [RFC 1358]\n+- [The `#[repr(align(x))]` attribute is now stable.][47006] [RFC 1358]\n - [You can now use nested groups of imports.][47948]\n   e.g. `use std::{fs::File, io::Read, path::{Path, PathBuf}};`\n - [You can now have `|` at the start of a match arm.][47947] e.g.\n@@ -2535,7 +3107,7 @@ Language\n   [RFC 1513](https://github.com/rust-lang/rfcs/blob/master/text/1513-less-unwinding.md).\n * [Add a new crate type, 'cdylib'](https://github.com/rust-lang/rust/pull/33553).\n   cdylibs are dynamic libraries suitable for loading by non-Rust hosts.\n-  [RFC 1510](https://github.com/rust-lang/rfcs/blob/master/text/1510-rdylib.md).\n+  [RFC 1510](https://github.com/rust-lang/rfcs/blob/master/text/1510-cdylib.md).\n   Note that Cargo does not yet directly support cdylibs.\n \n Stabilized APIs\n@@ -2610,7 +3182,7 @@ Stabilized APIs\n * [`UnixDatagram::shutdown`](http://doc.rust-lang.org/std/os/unix/net/struct.UnixDatagram.html#method.shutdown)\n * RawFd impls for `UnixDatagram`\n * `{BTree,Hash}Map::values_mut`\n-* [`<[_]>::binary_search_by_key`](http://doc.rust-lang.org/beta/std/primitive.slice.html#method.binary_search_by_key)\n+* [`<[_]>::binary_search_by_key`](http://doc.rust-lang.org/std/primitive.slice.html#method.binary_search_by_key)\n \n Libraries\n ---------\n@@ -3528,7 +4100,7 @@ Compatibility Notes\n [1.6bh]: https://github.com/rust-lang/rust/pull/29811\n [1.6c]: https://github.com/rust-lang/cargo/pull/2192\n [1.6cc]: https://github.com/rust-lang/cargo/pull/2131\n-[1.6co]: http://doc.rust-lang.org/beta/core/index.html\n+[1.6co]: http://doc.rust-lang.org/core/index.html\n [1.6dv]: https://github.com/rust-lang/rust/pull/30000\n [1.6f]: https://github.com/rust-lang/rust/pull/29129\n [1.6m]: https://github.com/rust-lang/rust/pull/29828"}, {"sha": "b1e2e1545cf85042f1950274249303a2763f5846", "filename": "appveyor.yml", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -6,7 +6,7 @@ environment:\n     secure: 7Y+JiquYedOAgnUU26uL0DPzrxmTtR+qIwG6rNKSuWDffqU3vVZxbGXim9QpTO80\n   SCCACHE_DIGEST: f808afabb4a4eb1d7112bcb3fa6be03b61e93412890c88e177c667eb37f46353d7ec294e559b16f9f4b5e894f2185fe7670a0df15fd064889ecbd80f0c34166c\n   TOOLSTATE_REPO_ACCESS_TOKEN:\n-    secure: PTZiSxJMVUZ0VnMR5i13E4OagbXfglj7pcskDQiKufVrDm13mLoI0vDJAEM35+bY\n+    secure: gKGlVktr7iuqCoYSxHxDE9ltLOKU0nYDEuQxvWbNxUIW7ri5ppn8L06jQzN0GGzN\n \n   # By default schannel checks revocation of certificates unlike some other SSL\n   # backends, but we've historically had problems on CI where a revocation\n@@ -138,6 +138,20 @@ install:\n   - if defined MINGW_URL 7z x -y %MINGW_ARCHIVE% > nul\n   - if defined MINGW_URL set PATH=%CD%\\%MINGW_DIR%\\bin;C:\\msys64\\usr\\bin;%PATH%\n \n+  # If we're compiling for MSVC then we, like most other distribution builders,\n+  # switch to clang as the compiler. This'll allow us eventually to enable LTO\n+  # amongst LLVM and rustc. Note that we only do this on MSVC as I don't think\n+  # clang has an output mode compatible with MinGW that we need. If it does we\n+  # should switch to clang for MinGW as well!\n+  #\n+  # Note that the LLVM installer is an NSIS installer\n+  #\n+  # Original downloaded here came from\n+  # http://releases.llvm.org/6.0.0/LLVM-6.0.0-win64.exe\n+  - if NOT defined MINGW_URL appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/LLVM-6.0.0-win64.exe\n+  - if NOT defined MINGW_URL .\\LLVM-6.0.0-win64.exe /S /NCRC /D=C:\\clang-rust\n+  - if NOT defined MINGW_URL set RUST_CONFIGURE_ARGS=%RUST_CONFIGURE_ARGS% --set llvm.clang-cl=C:\\clang-rust\\bin\\clang-cl.exe\n+\n   # Here we do a pretty heinous thing which is to mangle the MinGW installation\n   # we just had above. Currently, as of this writing, we're using MinGW-w64\n   # builds of gcc, and that's currently at 6.3.0. We use 6.3.0 as it appears to\n@@ -166,8 +180,8 @@ install:\n   - set PATH=C:\\Python27;%PATH%\n \n   # Download and install sccache\n-  - appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2018-04-02-sccache-x86_64-pc-windows-msvc\n-  - mv 2018-04-02-sccache-x86_64-pc-windows-msvc sccache.exe\n+  - appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2018-04-26-sccache-x86_64-pc-windows-msvc\n+  - mv 2018-04-26-sccache-x86_64-pc-windows-msvc sccache.exe\n   - set PATH=%PATH%;%CD%\n \n   # Download and install ninja\n@@ -197,6 +211,11 @@ test_script:\n   - set NO_CCACHE=1\n   - sh src/ci/run.sh\n \n+on_failure:\n+  # Dump crash log\n+  - set PATH=%PATH%;\"C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\X64\"\n+  - if exist %LOCALAPPDATA%\\CrashDumps for %%f in (%LOCALAPPDATA%\\CrashDumps\\*) do cdb -c \"k;q\" -G -z \"%%f\"\n+\n branches:\n   only:\n     - auto"}, {"sha": "99073416334f59ef7b02fcae69c7ac276c3084d3", "filename": "config.toml.example", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -76,6 +76,10 @@\n # passed to prefer linking to shared libraries.\n #link-shared = false\n \n+# On MSVC you can compile LLVM with clang-cl, but the test suite doesn't pass\n+# with clang-cl, so this is special in that it only compiles LLVM with clang-cl\n+#clang-cl = '/path/to/clang-cl.exe'\n+\n # =============================================================================\n # General build configuration options\n # =============================================================================\n@@ -275,6 +279,9 @@\n # Whether or not `panic!`s generate backtraces (RUST_BACKTRACE)\n #backtrace = true\n \n+# Whether to always use incremental compilation when building rustc\n+#incremental = false\n+\n # Build rustc with experimental parallelization\n #experimental-parallel-queries = false\n \n@@ -294,9 +301,9 @@\n # desired in distributions, for example.\n #rpath = true\n \n-# Suppresses extraneous output from tests to ensure the output of the test\n-# harness is relatively clean.\n-#quiet-tests = false\n+# Emits extraneous output from tests to ensure that failures of the test\n+# harness are debuggable just from logfiles.\n+#verbose-tests = false\n \n # Flag indicating whether tests are compiled with optimizations (the -O flag) or\n # with debuginfo (the -g flag)\n@@ -343,12 +350,19 @@\n # rustc to execute.\n #lld = false\n \n+# Indicates whether some LLVM tools, like llvm-objdump, will be made available in the\n+# sysroot.\n+#llvm-tools = false\n+\n # Whether to deny warnings in crates\n #deny-warnings = true\n \n # Print backtrace on internal compiler errors during bootstrap\n #backtrace-on-ice = false\n \n+# Whether to verify generated LLVM IR\n+#verify-llvm-ir = false\n+\n # =============================================================================\n # Options for specific targets\n #"}, {"sha": "89daa8e09c7d1327b0c4f813be1408430b245bb3", "filename": "src/Cargo.lock", "status": "modified", "additions": 1109, "deletions": 1006, "changes": 2115, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "62403700f3a4010a9acf93754a59bdfdffb2a00e", "filename": "src/Cargo.toml", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.toml?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -4,7 +4,7 @@ members = [\n   \"rustc\",\n   \"libstd\",\n   \"libtest\",\n-  \"librustc_trans\",\n+  \"librustc_codegen_llvm\",\n   \"tools/cargotest\",\n   \"tools/clippy\",\n   \"tools/compiletest\",\n@@ -23,22 +23,17 @@ members = [\n   \"tools/rustfmt\",\n   \"tools/miri\",\n   \"tools/rustdoc-themes\",\n-  # FIXME(https://github.com/rust-lang/cargo/issues/4089): move these to exclude\n-  \"tools/rls/test_data/bin_lib\",\n-  \"tools/rls/test_data/borrow_error\",\n-  \"tools/rls/test_data/common\",\n-  \"tools/rls/test_data/deglob\",\n-  \"tools/rls/test_data/features\",\n-  \"tools/rls/test_data/find_all_refs_no_cfg_test\",\n-  \"tools/rls/test_data/find_impls\",\n-  \"tools/rls/test_data/infer_bin\",\n-  \"tools/rls/test_data/infer_custom_bin\",\n-  \"tools/rls/test_data/infer_lib\",\n-  \"tools/rls/test_data/multiple_bins\",\n-  \"tools/rls/test_data/reformat\",\n-  \"tools/rls/test_data/reformat_with_range\",\n-  \"tools/rls/test_data/workspace_symbol\",\n ]\n+exclude = [\n+  \"tools/rls/test_data\",\n+]\n+\n+# Curiously, LLVM 7.0 will segfault if compiled with opt-level=3\n+# See issue https://github.com/rust-lang/rust/issues/52378\n+[profile.release]\n+opt-level = 2\n+[profile.bench]\n+opt-level = 2\n \n # These options are controlled from our rustc wrapper script, so turn them off\n # here and have them controlled elsewhere.\n@@ -57,11 +52,11 @@ debug-assertions = false\n [patch.\"https://github.com/rust-lang/cargo\"]\n cargo = { path = \"tools/cargo\" }\n \n-[patch.crates-io]\n+[patch.\"https://github.com/rust-lang-nursery/rustfmt\"]\n # Similar to Cargo above we want the RLS to use a vendored version of `rustfmt`\n # that we're shipping as well (to ensure that the rustfmt in RLS and the\n-# `rustfmt` executable are the same exact vesion). Unlike Cargo, however, the\n-# RLS depends on `rustfmt` from crates.io, so we put this in a `[patch]` section\n-# for crates.io\n+# `rustfmt` executable are the same exact version).\n rustfmt-nightly = { path = \"tools/rustfmt\" }\n+\n+[patch.\"https://github.com/rust-lang-nursery/rust-clippy\"]\n clippy_lints = { path = \"tools/clippy/clippy_lints\" }"}, {"sha": "6da4944c392db58bde3aec9f189323da38cfac24", "filename": "src/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.md?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -6,7 +6,7 @@ This directory contains the source code of the rust project, including:\n For more information on how various parts of the compiler work, see the [rustc guide].\n \n Their is also useful content in the following READMEs, which are gradually being moved over to the guide:\n-- https://github.com/rust-lang/rust/tree/master/src/librustc/ty/maps\n+- https://github.com/rust-lang/rust/tree/master/src/librustc/ty/query\n - https://github.com/rust-lang/rust/tree/master/src/librustc/dep_graph\n - https://github.com/rust-lang/rust/blob/master/src/librustc/infer/region_constraints\n - https://github.com/rust-lang/rust/tree/master/src/librustc/infer/higher_ranked"}, {"sha": "57a526038041e5037fe82acb2cbc23104968d463", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -28,10 +28,15 @@ name = \"sccache-plus-cl\"\n path = \"bin/sccache-plus-cl.rs\"\n test = false\n \n+[[bin]]\n+name = \"llvm-config-wrapper\"\n+path = \"bin/llvm-config-wrapper.rs\"\n+test = false\n+\n [dependencies]\n build_helper = { path = \"../build_helper\" }\n cmake = \"0.1.23\"\n-filetime = \"0.1\"\n+filetime = \"0.2\"\n num_cpus = \"1.0\"\n getopts = \"0.2\"\n cc = \"1.0.1\""}, {"sha": "b1703f8c728e255dfd1af97277064619d59785ec", "filename": "src/bootstrap/bin/llvm-config-wrapper.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fbin%2Fllvm-config-wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fbin%2Fllvm-config-wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fllvm-config-wrapper.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// The sheer existence of this file is an awful hack. See the comments in\n+// `src/bootstrap/native.rs` for why this is needed when compiling LLD.\n+\n+use std::env;\n+use std::process::{self, Stdio, Command};\n+use std::io::{self, Write};\n+\n+fn main() {\n+    let real_llvm_config = env::var_os(\"LLVM_CONFIG_REAL\").unwrap();\n+    let mut cmd = Command::new(real_llvm_config);\n+    cmd.args(env::args().skip(1)).stderr(Stdio::piped());\n+    let output = cmd.output().expect(\"failed to spawn llvm-config\");\n+    let stdout = String::from_utf8_lossy(&output.stdout);\n+    print!(\"{}\", stdout.replace(\"\\\\\", \"/\"));\n+    io::stdout().flush().unwrap();\n+    process::exit(output.status.code().unwrap_or(1));\n+}"}, {"sha": "7192cae8956e40b5157ac0ea5a34414f99e6d296", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -268,12 +268,25 @@ fn main() {\n         if let Ok(host_linker) = env::var(\"RUSTC_HOST_LINKER\") {\n             cmd.arg(format!(\"-Clinker={}\", host_linker));\n         }\n+\n+        if let Ok(s) = env::var(\"RUSTC_HOST_CRT_STATIC\") {\n+            if s == \"true\" {\n+                cmd.arg(\"-C\").arg(\"target-feature=+crt-static\");\n+            }\n+            if s == \"false\" {\n+                cmd.arg(\"-C\").arg(\"target-feature=-crt-static\");\n+            }\n+        }\n     }\n \n     if env::var_os(\"RUSTC_PARALLEL_QUERIES\").is_some() {\n         cmd.arg(\"--cfg\").arg(\"parallel_queries\");\n     }\n \n+    if env::var_os(\"RUSTC_VERIFY_LLVM_IR\").is_some() {\n+        cmd.arg(\"-Z\").arg(\"verify-llvm-ir\");\n+    }\n+\n     let color = match env::var(\"RUSTC_COLOR\") {\n         Ok(s) => usize::from_str(&s).expect(\"RUSTC_COLOR should be an integer\"),\n         Err(_) => 0,\n@@ -283,12 +296,19 @@ fn main() {\n         cmd.arg(\"--color=always\");\n     }\n \n-    if env::var_os(\"RUSTC_DENY_WARNINGS\").is_some() {\n+    if env::var_os(\"RUSTC_DENY_WARNINGS\").is_some() && env::var_os(\"RUSTC_EXTERNAL_TOOL\").is_none()\n+    {\n         cmd.arg(\"-Dwarnings\");\n+        cmd.arg(\"-Dbare_trait_objects\");\n     }\n \n     if verbose > 1 {\n-        eprintln!(\"rustc command: {:?}\", cmd);\n+        eprintln!(\n+            \"rustc command: {:?}={:?} {:?}\",\n+            bootstrap::util::dylib_path_var(),\n+            env::join_paths(&dylib_path).unwrap(),\n+            cmd,\n+        );\n         eprintln!(\"sysroot: {:?}\", sysroot);\n         eprintln!(\"libdir: {:?}\", libdir);\n     }\n@@ -308,7 +328,7 @@ fn main() {\n             let start = Instant::now();\n             let status = cmd\n                 .status()\n-                .expect(&format!(\"\\n\\n failed to run {:?}\", cmd));\n+                .unwrap_or_else(|_| panic!(\"\\n\\n failed to run {:?}\", cmd));\n             let dur = start.elapsed();\n \n             let is_test = args.iter().any(|a| a == \"--test\");\n@@ -328,7 +348,7 @@ fn main() {\n         }\n     }\n \n-    let code = exec_cmd(&mut cmd).expect(&format!(\"\\n\\n failed to run {:?}\", cmd));\n+    let code = exec_cmd(&mut cmd).unwrap_or_else(|_| panic!(\"\\n\\n failed to run {:?}\", cmd));\n     std::process::exit(code);\n }\n "}, {"sha": "a54e58665cceb8177b936b6744c0bfe50537e683", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -35,7 +35,7 @@ fn main() {\n     };\n \n     let mut dylib_path = bootstrap::util::dylib_path();\n-    dylib_path.insert(0, PathBuf::from(libdir));\n+    dylib_path.insert(0, PathBuf::from(libdir.clone()));\n \n     let mut cmd = Command::new(rustdoc);\n     cmd.args(&args)\n@@ -69,6 +69,7 @@ fn main() {\n \n     if verbose > 1 {\n         eprintln!(\"rustdoc command: {:?}\", cmd);\n+        eprintln!(\"libdir: {:?}\", libdir);\n     }\n \n     std::process::exit(match cmd.status() {"}, {"sha": "0a20ac7e492dc44f87e4e4b4109b07b2a51aced0", "filename": "src/bootstrap/bin/sccache-plus-cl.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fbin%2Fsccache-plus-cl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fbin%2Fsccache-plus-cl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fsccache-plus-cl.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -16,8 +16,8 @@ use std::process::{self, Command};\n fn main() {\n     let target = env::var(\"SCCACHE_TARGET\").unwrap();\n     // Locate the actual compiler that we're invoking\n-    env::remove_var(\"CC\");\n-    env::remove_var(\"CXX\");\n+    env::set_var(\"CC\", env::var_os(\"SCCACHE_CC\").unwrap());\n+    env::set_var(\"CXX\", env::var_os(\"SCCACHE_CXX\").unwrap());\n     let mut cfg = cc::Build::new();\n     cfg.cargo_metadata(false)\n        .out_dir(\"/\")\n@@ -39,6 +39,12 @@ fn main() {\n         cmd.arg(arg);\n     }\n \n+    if let Ok(s) = env::var(\"SCCACHE_EXTRA_ARGS\") {\n+        for s in s.split_whitespace() {\n+            cmd.arg(s);\n+        }\n+    }\n+\n     let status = cmd.status().expect(\"failed to spawn\");\n     process::exit(status.code().unwrap_or(2))\n }"}, {"sha": "71c1c61e3d97ebd51e9bd8cf5b9946cbcbe5ca5c", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -303,6 +303,19 @@ def default_build_triple():\n     return \"{}-{}\".format(cputype, ostype)\n \n \n+@contextlib.contextmanager\n+def output(filepath):\n+    tmp = filepath + '.tmp'\n+    with open(tmp, 'w') as f:\n+        yield f\n+    try:\n+        os.remove(filepath)  # PermissionError/OSError on Win32 if in use\n+        os.rename(tmp, filepath)\n+    except OSError:\n+        shutil.copy2(tmp, filepath)\n+        os.remove(tmp)\n+\n+\n class RustBuild(object):\n     \"\"\"Provide all the methods required to build Rust\"\"\"\n     def __init__(self):\n@@ -346,7 +359,7 @@ def download_stage0(self):\n             self._download_stage0_helper(filename, \"rustc\")\n             self.fix_executable(\"{}/bin/rustc\".format(self.bin_root()))\n             self.fix_executable(\"{}/bin/rustdoc\".format(self.bin_root()))\n-            with open(self.rustc_stamp(), 'w') as rust_stamp:\n+            with output(self.rustc_stamp()) as rust_stamp:\n                 rust_stamp.write(self.date)\n \n             # This is required so that we don't mix incompatible MinGW\n@@ -363,7 +376,7 @@ def download_stage0(self):\n             filename = \"cargo-{}-{}.tar.gz\".format(cargo_channel, self.build)\n             self._download_stage0_helper(filename, \"cargo\")\n             self.fix_executable(\"{}/bin/cargo\".format(self.bin_root()))\n-            with open(self.cargo_stamp(), 'w') as cargo_stamp:\n+            with output(self.cargo_stamp()) as cargo_stamp:\n                 cargo_stamp.write(self.date)\n \n     def _download_stage0_helper(self, filename, pattern):\n@@ -489,7 +502,7 @@ def bin_root(self):\n         \"\"\"\n         return os.path.join(self.build_dir, self.build, \"stage0\")\n \n-    def get_toml(self, key):\n+    def get_toml(self, key, section=None):\n         \"\"\"Returns the value of the given key in config.toml, otherwise returns None\n \n         >>> rb = RustBuild()\n@@ -501,12 +514,29 @@ def get_toml(self, key):\n \n         >>> rb.get_toml(\"key3\") is None\n         True\n+\n+        Optionally also matches the section the key appears in\n+\n+        >>> rb.config_toml = '[a]\\\\nkey = \"value1\"\\\\n[b]\\\\nkey = \"value2\"'\n+        >>> rb.get_toml('key', 'a')\n+        'value1'\n+        >>> rb.get_toml('key', 'b')\n+        'value2'\n+        >>> rb.get_toml('key', 'c') is None\n+        True\n         \"\"\"\n+\n+        cur_section = None\n         for line in self.config_toml.splitlines():\n+            section_match = re.match(r'^\\s*\\[(.*)\\]\\s*$', line)\n+            if section_match is not None:\n+                cur_section = section_match.group(1)\n+\n             match = re.match(r'^{}\\s*=(.*)$'.format(key), line)\n             if match is not None:\n                 value = match.group(1)\n-                return self.get_string(value) or value.strip()\n+                if section is None or section == cur_section:\n+                    return self.get_string(value) or value.strip()\n         return None\n \n     def cargo(self):\n@@ -589,7 +619,17 @@ def build_bootstrap(self):\n         env[\"LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\") + \\\n             (os.pathsep + env[\"LIBRARY_PATH\"]) \\\n             if \"LIBRARY_PATH\" in env else \"\"\n-        env[\"RUSTFLAGS\"] = \"-Cdebuginfo=2\"\n+        env[\"RUSTFLAGS\"] = \"-Cdebuginfo=2 \"\n+\n+        build_section = \"target.{}\".format(self.build_triple())\n+        target_features = []\n+        if self.get_toml(\"crt-static\", build_section) == \"true\":\n+            target_features += [\"+crt-static\"]\n+        elif self.get_toml(\"crt-static\", build_section) == \"false\":\n+            target_features += [\"-crt-static\"]\n+        if target_features:\n+            env[\"RUSTFLAGS\"] += \"-C target-feature=\" + (\",\".join(target_features)) + \" \"\n+\n         env[\"PATH\"] = os.path.join(self.bin_root(), \"bin\") + \\\n             os.pathsep + env[\"PATH\"]\n         if not os.path.isfile(self.cargo()):\n@@ -749,7 +789,7 @@ def bootstrap(help_triggered):\n     if build.use_vendored_sources:\n         if not os.path.exists('.cargo'):\n             os.makedirs('.cargo')\n-        with open('.cargo/config', 'w') as cargo_config:\n+        with output('.cargo/config') as cargo_config:\n             cargo_config.write(\"\"\"\n                 [source.crates-io]\n                 replace-with = 'vendored-sources'\n@@ -788,6 +828,9 @@ def bootstrap(help_triggered):\n     env[\"BOOTSTRAP_PARENT_ID\"] = str(os.getpid())\n     env[\"BOOTSTRAP_PYTHON\"] = sys.executable\n     env[\"BUILD_DIR\"] = build.build_dir\n+    env[\"RUSTC_BOOTSTRAP\"] = '1'\n+    env[\"CARGO\"] = build.cargo()\n+    env[\"RUSTC\"] = build.rustc()\n     run(args, env=env, verbose=build.verbose)\n \n "}, {"sha": "724d3b741903ff6ffc21e17838be60bf38155a15", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 846, "deletions": 508, "changes": 1354, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -11,40 +11,40 @@\n use std::any::Any;\n use std::cell::{Cell, RefCell};\n use std::collections::BTreeSet;\n+use std::collections::HashMap;\n use std::env;\n use std::fmt::Debug;\n use std::fs;\n use std::hash::Hash;\n use std::ops::Deref;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n-use std::time::{Instant, Duration};\n-use std::collections::HashMap;\n+use std::time::{Duration, Instant};\n \n+use cache::{Cache, Interned, INTERNER};\n+use check;\n use compile;\n-use install;\n use dist;\n-use util::{exe, libdir, add_lib_path};\n-use {Build, Mode, DocTests};\n-use cache::{INTERNER, Interned, Cache};\n-use check;\n-use test;\n-use flags::Subcommand;\n use doc;\n-use tool;\n+use flags::Subcommand;\n+use install;\n use native;\n+use test;\n+use tool;\n+use util::{add_lib_path, exe, libdir};\n+use {Build, DocTests, Mode};\n \n pub use Compiler;\n \n-use petgraph::Graph;\n use petgraph::graph::NodeIndex;\n+use petgraph::Graph;\n \n pub struct Builder<'a> {\n     pub build: &'a Build,\n     pub top_stage: u32,\n     pub kind: Kind,\n     cache: Cache,\n-    stack: RefCell<Vec<Box<Any>>>,\n+    stack: RefCell<Vec<Box<dyn Any>>>,\n     time_spent_on_dependencies: Cell<Duration>,\n     pub paths: Vec<PathBuf>,\n     graph_nodes: RefCell<HashMap<String, NodeIndex>>,\n@@ -111,27 +111,38 @@ struct StepDescription {\n }\n \n #[derive(Debug, Clone, PartialOrd, Ord, PartialEq, Eq)]\n-struct PathSet {\n-    set: BTreeSet<PathBuf>,\n+pub enum PathSet {\n+    Set(BTreeSet<PathBuf>),\n+    Suite(PathBuf),\n }\n \n impl PathSet {\n     fn empty() -> PathSet {\n-        PathSet { set: BTreeSet::new() }\n+        PathSet::Set(BTreeSet::new())\n     }\n \n     fn one<P: Into<PathBuf>>(path: P) -> PathSet {\n         let mut set = BTreeSet::new();\n         set.insert(path.into());\n-        PathSet { set }\n+        PathSet::Set(set)\n     }\n \n     fn has(&self, needle: &Path) -> bool {\n-        self.set.iter().any(|p| p.ends_with(needle))\n+        match self {\n+            PathSet::Set(set) => set.iter().any(|p| p.ends_with(needle)),\n+            PathSet::Suite(_) => false,\n+        }\n     }\n \n     fn path(&self, builder: &Builder) -> PathBuf {\n-        self.set.iter().next().unwrap_or(&builder.build.src).to_path_buf()\n+        match self {\n+            PathSet::Set(set) => set\n+                .iter()\n+                .next()\n+                .unwrap_or(&builder.build.src)\n+                .to_path_buf(),\n+            PathSet::Suite(path) => PathBuf::from(path),\n+        }\n     }\n }\n \n@@ -151,8 +162,10 @@ impl StepDescription {\n             eprintln!(\"Skipping {:?} because it is excluded\", pathset);\n             return;\n         } else if !builder.config.exclude.is_empty() {\n-            eprintln!(\"{:?} not skipped for {:?} -- not in {:?}\", pathset,\n-                self.name, builder.config.exclude);\n+            eprintln!(\n+                \"{:?} not skipped for {:?} -- not in {:?}\",\n+                pathset, self.name, builder.config.exclude\n+            );\n         }\n         let hosts = &builder.hosts;\n \n@@ -181,14 +194,18 @@ impl StepDescription {\n     }\n \n     fn run(v: &[StepDescription], builder: &Builder, paths: &[PathBuf]) {\n-        let should_runs = v.iter().map(|desc| {\n-            (desc.should_run)(ShouldRun::new(builder))\n-        }).collect::<Vec<_>>();\n+        let should_runs = v\n+            .iter()\n+            .map(|desc| (desc.should_run)(ShouldRun::new(builder)))\n+            .collect::<Vec<_>>();\n \n         // sanity checks on rules\n         for (desc, should_run) in v.iter().zip(&should_runs) {\n-            assert!(!should_run.paths.is_empty(),\n-                \"{:?} should have at least one pathset\", desc.name);\n+            assert!(\n+                !should_run.paths.is_empty(),\n+                \"{:?} should have at least one pathset\",\n+                desc.name\n+            );\n         }\n \n         if paths.is_empty() {\n@@ -201,9 +218,18 @@ impl StepDescription {\n             }\n         } else {\n             for path in paths {\n+                // strip CurDir prefix if present\n+                let path = match path.strip_prefix(\".\") {\n+                    Ok(p) => p,\n+                    Err(_) => path,\n+                };\n+\n                 let mut attempted_run = false;\n                 for (desc, should_run) in v.iter().zip(&should_runs) {\n-                    if let Some(pathset) = should_run.pathset_for_path(path) {\n+                    if let Some(suite) = should_run.is_suite_path(path) {\n+                        attempted_run = true;\n+                        desc.maybe_run(builder, suite);\n+                    } else if let Some(pathset) = should_run.pathset_for_path(path) {\n                         attempted_run = true;\n                         desc.maybe_run(builder, pathset);\n                     }\n@@ -250,7 +276,7 @@ impl<'a> ShouldRun<'a> {\n         for krate in self.builder.in_tree_crates(name) {\n             set.insert(PathBuf::from(&krate.path));\n         }\n-        self.paths.insert(PathSet { set });\n+        self.paths.insert(PathSet::Set(set));\n         self\n     }\n \n@@ -268,9 +294,20 @@ impl<'a> ShouldRun<'a> {\n \n     // multiple aliases for the same job\n     pub fn paths(mut self, paths: &[&str]) -> Self {\n-        self.paths.insert(PathSet {\n-            set: paths.iter().map(PathBuf::from).collect(),\n-        });\n+        self.paths\n+            .insert(PathSet::Set(paths.iter().map(PathBuf::from).collect()));\n+        self\n+    }\n+\n+    pub fn is_suite_path(&self, path: &Path) -> Option<&PathSet> {\n+        self.paths.iter().find(|pathset| match pathset {\n+            PathSet::Suite(p) => path.starts_with(p),\n+            PathSet::Set(_) => false,\n+        })\n+    }\n+\n+    pub fn suite_path(mut self, suite: &str) -> Self {\n+        self.paths.insert(PathSet::Suite(PathBuf::from(suite)));\n         self\n     }\n \n@@ -304,40 +341,140 @@ impl<'a> Builder<'a> {\n             }};\n         }\n         match kind {\n-            Kind::Build => describe!(compile::Std, compile::Test, compile::Rustc,\n-                compile::StartupObjects, tool::BuildManifest, tool::Rustbook, tool::ErrorIndex,\n-                tool::UnstableBookGen, tool::Tidy, tool::Linkchecker, tool::CargoTest,\n-                tool::Compiletest, tool::RemoteTestServer, tool::RemoteTestClient,\n-                tool::RustInstaller, tool::Cargo, tool::Rls, tool::Rustdoc, tool::Clippy,\n-                native::Llvm, tool::Rustfmt, tool::Miri, native::Lld),\n-            Kind::Check => describe!(check::Std, check::Test, check::Rustc, check::CodegenBackend,\n-                check::Rustdoc),\n-            Kind::Test => describe!(test::Tidy, test::Bootstrap, test::Ui, test::RunPass,\n-                test::CompileFail, test::ParseFail, test::RunFail, test::RunPassValgrind,\n-                test::MirOpt, test::Codegen, test::CodegenUnits, test::Incremental, test::Debuginfo,\n-                test::UiFullDeps, test::RunPassFullDeps, test::RunFailFullDeps,\n-                test::CompileFailFullDeps, test::IncrementalFullDeps, test::Rustdoc, test::Pretty,\n-                test::RunPassPretty, test::RunFailPretty, test::RunPassValgrindPretty,\n-                test::RunPassFullDepsPretty, test::RunFailFullDepsPretty,\n-                test::Crate, test::CrateLibrustc, test::CrateRustdoc, test::Linkcheck,\n-                test::Cargotest, test::Cargo, test::Rls, test::ErrorIndex, test::Distcheck,\n+            Kind::Build => describe!(\n+                compile::Std,\n+                compile::Test,\n+                compile::Rustc,\n+                compile::CodegenBackend,\n+                compile::StartupObjects,\n+                tool::BuildManifest,\n+                tool::Rustbook,\n+                tool::ErrorIndex,\n+                tool::UnstableBookGen,\n+                tool::Tidy,\n+                tool::Linkchecker,\n+                tool::CargoTest,\n+                tool::Compiletest,\n+                tool::RemoteTestServer,\n+                tool::RemoteTestClient,\n+                tool::RustInstaller,\n+                tool::Cargo,\n+                tool::Rls,\n+                tool::Rustdoc,\n+                tool::Clippy,\n+                native::Llvm,\n+                tool::Rustfmt,\n+                tool::Miri,\n+                native::Lld\n+            ),\n+            Kind::Check => describe!(\n+                check::Std,\n+                check::Test,\n+                check::Rustc,\n+                check::CodegenBackend,\n+                check::Rustdoc\n+            ),\n+            Kind::Test => describe!(\n+                test::Tidy,\n+                test::Ui,\n+                test::RunPass,\n+                test::CompileFail,\n+                test::ParseFail,\n+                test::RunFail,\n+                test::RunPassValgrind,\n+                test::MirOpt,\n+                test::Codegen,\n+                test::CodegenUnits,\n+                test::Incremental,\n+                test::Debuginfo,\n+                test::UiFullDeps,\n+                test::RunPassFullDeps,\n+                test::RunFailFullDeps,\n+                test::CompileFailFullDeps,\n+                test::IncrementalFullDeps,\n+                test::Rustdoc,\n+                test::Pretty,\n+                test::RunPassPretty,\n+                test::RunFailPretty,\n+                test::RunPassValgrindPretty,\n+                test::RunPassFullDepsPretty,\n+                test::RunFailFullDepsPretty,\n+                test::Crate,\n+                test::CrateLibrustc,\n+                test::CrateRustdoc,\n+                test::Linkcheck,\n+                test::Cargotest,\n+                test::Cargo,\n+                test::Rls,\n+                test::ErrorIndex,\n+                test::Distcheck,\n                 test::RunMakeFullDeps,\n-                test::Nomicon, test::Reference, test::RustdocBook, test::RustByExample,\n-                test::TheBook, test::UnstableBook, test::RustcBook,\n-                test::Rustfmt, test::Miri, test::Clippy, test::RustdocJS, test::RustdocTheme,\n+                test::Nomicon,\n+                test::Reference,\n+                test::RustdocBook,\n+                test::RustByExample,\n+                test::TheBook,\n+                test::UnstableBook,\n+                test::RustcBook,\n+                test::Rustfmt,\n+                test::Miri,\n+                test::Clippy,\n+                test::RustdocJS,\n+                test::RustdocTheme,\n+                // Run bootstrap close to the end as it's unlikely to fail\n+                test::Bootstrap,\n                 // Run run-make last, since these won't pass without make on Windows\n-                test::RunMake, test::RustdocUi),\n+                test::RunMake,\n+                test::RustdocUi\n+            ),\n             Kind::Bench => describe!(test::Crate, test::CrateLibrustc),\n-            Kind::Doc => describe!(doc::UnstableBook, doc::UnstableBookGen, doc::TheBook,\n-                doc::Standalone, doc::Std, doc::Test, doc::WhitelistedRustc, doc::Rustc,\n-                doc::ErrorIndex, doc::Nomicon, doc::Reference, doc::Rustdoc, doc::RustByExample,\n-                doc::RustcBook, doc::CargoBook),\n-            Kind::Dist => describe!(dist::Docs, dist::RustcDocs, dist::Mingw, dist::Rustc,\n-                dist::DebuggerScripts, dist::Std, dist::Analysis, dist::Src,\n-                dist::PlainSourceTarball, dist::Cargo, dist::Rls, dist::Rustfmt, dist::Extended,\n-                dist::HashSign),\n-            Kind::Install => describe!(install::Docs, install::Std, install::Cargo, install::Rls,\n-                install::Rustfmt, install::Analysis, install::Src, install::Rustc),\n+            Kind::Doc => describe!(\n+                doc::UnstableBook,\n+                doc::UnstableBookGen,\n+                doc::TheBook,\n+                doc::Standalone,\n+                doc::Std,\n+                doc::Test,\n+                doc::WhitelistedRustc,\n+                doc::Rustc,\n+                doc::Rustdoc,\n+                doc::ErrorIndex,\n+                doc::Nomicon,\n+                doc::Reference,\n+                doc::RustdocBook,\n+                doc::RustByExample,\n+                doc::RustcBook,\n+                doc::CargoBook\n+            ),\n+            Kind::Dist => describe!(\n+                dist::Docs,\n+                dist::RustcDocs,\n+                dist::Mingw,\n+                dist::Rustc,\n+                dist::DebuggerScripts,\n+                dist::Std,\n+                dist::Analysis,\n+                dist::Src,\n+                dist::PlainSourceTarball,\n+                dist::Cargo,\n+                dist::Rls,\n+                dist::Rustfmt,\n+                dist::Clippy,\n+                dist::LlvmTools,\n+                dist::Extended,\n+                dist::HashSign\n+            ),\n+            Kind::Install => describe!(\n+                install::Docs,\n+                install::Std,\n+                install::Cargo,\n+                install::Rls,\n+                install::Rustfmt,\n+                install::Clippy,\n+                install::Analysis,\n+                install::Src,\n+                install::Rustc\n+            ),\n         }\n     }\n \n@@ -372,8 +509,12 @@ impl<'a> Builder<'a> {\n         }\n         let mut help = String::from(\"Available paths:\\n\");\n         for pathset in should_run.paths {\n-            for path in pathset.set {\n-                help.push_str(format!(\"    ./x.py {} {}\\n\", subcommand, path.display()).as_str());\n+            if let PathSet::Set(set) = pathset {\n+                set.iter().for_each(|path| {\n+                    help.push_str(\n+                        format!(\"    ./x.py {} {}\\n\", subcommand, path.display()).as_str(),\n+                    )\n+                })\n             }\n         }\n         Some(help)\n@@ -405,9 +546,12 @@ impl<'a> Builder<'a> {\n         };\n \n         if kind == Kind::Dist {\n-            assert!(!builder.config.test_miri, \"Do not distribute with miri enabled.\\n\\\n+            assert!(\n+                !builder.config.test_miri,\n+                \"Do not distribute with miri enabled.\\n\\\n                 The distributed libraries would include all MIR (increasing binary size).\n-                The distributed MIR would include validation statements.\");\n+                The distributed MIR would include validation statements.\"\n+            );\n         }\n \n         builder\n@@ -432,7 +576,9 @@ impl<'a> Builder<'a> {\n     /// obtained through this function, since it ensures that they are valid\n     /// (i.e., built and assembled).\n     pub fn compiler(&self, stage: u32, host: Interned<String>) -> Compiler {\n-        self.ensure(compile::Assemble { target_compiler: Compiler { stage, host } })\n+        self.ensure(compile::Assemble {\n+            target_compiler: Compiler { stage, host },\n+        })\n     }\n \n     pub fn sysroot(&self, compiler: Compiler) -> Interned<PathBuf> {\n@@ -442,7 +588,9 @@ impl<'a> Builder<'a> {\n     /// Returns the libdir where the standard library and other artifacts are\n     /// found for a compiler's sysroot.\n     pub fn sysroot_libdir(\n-        &self, compiler: Compiler, target: Interned<String>\n+        &self,\n+        compiler: Compiler,\n+        target: Interned<String>,\n     ) -> Interned<PathBuf> {\n         #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n         struct Libdir {\n@@ -464,8 +612,12 @@ impl<'a> Builder<'a> {\n                 } else {\n                     Path::new(\"lib\")\n                 };\n-                let sysroot = builder.sysroot(self.compiler).join(lib)\n-                    .join(\"rustlib\").join(self.target).join(\"lib\");\n+                let sysroot = builder\n+                    .sysroot(self.compiler)\n+                    .join(lib)\n+                    .join(\"rustlib\")\n+                    .join(self.target)\n+                    .join(\"lib\");\n                 let _ = fs::remove_dir_all(&sysroot);\n                 t!(fs::create_dir_all(&sysroot));\n                 INTERNER.intern_path(sysroot)\n@@ -499,7 +651,7 @@ impl<'a> Builder<'a> {\n         // compiler live next to the compiler and the system will find them\n         // automatically.\n         if cfg!(windows) {\n-            return\n+            return;\n         }\n \n         add_lib_path(vec![self.rustc_libdir(compiler)], cmd);\n@@ -510,7 +662,9 @@ impl<'a> Builder<'a> {\n         if compiler.is_snapshot(self) {\n             self.initial_rustc.clone()\n         } else {\n-            self.sysroot(compiler).join(\"bin\").join(exe(\"rustc\", &compiler.host))\n+            self.sysroot(compiler)\n+                .join(\"bin\")\n+                .join(exe(\"rustc\", &compiler.host))\n         }\n     }\n \n@@ -522,12 +676,15 @@ impl<'a> Builder<'a> {\n         let mut cmd = Command::new(&self.out.join(\"bootstrap/debug/rustdoc\"));\n         let compiler = self.compiler(self.top_stage, host);\n         cmd.env(\"RUSTC_STAGE\", compiler.stage.to_string())\n-           .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n-           .env(\"RUSTDOC_LIBDIR\", self.sysroot_libdir(compiler, self.config.build))\n-           .env(\"CFG_RELEASE_CHANNEL\", &self.config.channel)\n-           .env(\"RUSTDOC_REAL\", self.rustdoc(host))\n-           .env(\"RUSTDOC_CRATE_VERSION\", self.rust_version())\n-           .env(\"RUSTC_BOOTSTRAP\", \"1\");\n+            .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n+            .env(\n+                \"RUSTDOC_LIBDIR\",\n+                self.sysroot_libdir(compiler, self.config.build),\n+            )\n+            .env(\"CFG_RELEASE_CHANNEL\", &self.config.channel)\n+            .env(\"RUSTDOC_REAL\", self.rustdoc(host))\n+            .env(\"RUSTDOC_CRATE_VERSION\", self.rust_version())\n+            .env(\"RUSTC_BOOTSTRAP\", \"1\");\n         if let Some(linker) = self.linker(host) {\n             cmd.env(\"RUSTC_TARGET_LINKER\", linker);\n         }\n@@ -541,33 +698,48 @@ impl<'a> Builder<'a> {\n     /// rustc compiler, its output will be scoped by `mode`'s output directory,\n     /// it will pass the `--target` flag for the specified `target`, and will be\n     /// executing the Cargo command `cmd`.\n-    pub fn cargo(&self,\n-             compiler: Compiler,\n-             mode: Mode,\n-             target: Interned<String>,\n-             cmd: &str) -> Command {\n+    pub fn cargo(\n+        &self,\n+        compiler: Compiler,\n+        mode: Mode,\n+        target: Interned<String>,\n+        cmd: &str,\n+    ) -> Command {\n         let mut cargo = Command::new(&self.initial_cargo);\n         let out_dir = self.stage_out(compiler, mode);\n-        cargo.env(\"CARGO_TARGET_DIR\", out_dir)\n-             .arg(cmd)\n-             .arg(\"--target\")\n-             .arg(target);\n+        cargo\n+            .env(\"CARGO_TARGET_DIR\", out_dir)\n+            .arg(cmd);\n+\n+        if cmd != \"install\" {\n+            cargo.arg(\"--target\")\n+                 .arg(target);\n+        } else {\n+            assert_eq!(target, compiler.host);\n+        }\n \n         // Set a flag for `check` so that certain build scripts can do less work\n         // (e.g. not building/requiring LLVM).\n         if cmd == \"check\" {\n             cargo.env(\"RUST_CHECK\", \"1\");\n         }\n \n-        // If we were invoked from `make` then that's already got a jobserver\n-        // set up for us so no need to tell Cargo about jobs all over again.\n-        if env::var_os(\"MAKEFLAGS\").is_none() && env::var_os(\"MFLAGS\").is_none() {\n-             cargo.arg(\"-j\").arg(self.jobs().to_string());\n-        }\n+        cargo.arg(\"-j\").arg(self.jobs().to_string());\n+        // Remove make-related flags to ensure Cargo can correctly set things up\n+        cargo.env_remove(\"MAKEFLAGS\");\n+        cargo.env_remove(\"MFLAGS\");\n \n         // FIXME: Temporary fix for https://github.com/rust-lang/cargo/issues/3005\n         // Force cargo to output binaries with disambiguating hashes in the name\n-        cargo.env(\"__CARGO_DEFAULT_LIB_METADATA\", &self.config.channel);\n+        let metadata = if compiler.stage == 0 {\n+            // Treat stage0 like special channel, whether it's a normal prior-\n+            // release rustc or a local rebuild with the same version, so we\n+            // never mix these libraries by accident.\n+            \"bootstrap\"\n+        } else {\n+            &self.config.channel\n+        };\n+        cargo.env(\"__CARGO_DEFAULT_LIB_METADATA\", &metadata);\n \n         let stage;\n         if compiler.stage == 0 && self.local_rebuild {\n@@ -587,35 +759,63 @@ impl<'a> Builder<'a> {\n         }\n \n         if !extra_args.is_empty() {\n-            cargo.env(\"RUSTFLAGS\",\n-                format!(\"{} {}\", env::var(\"RUSTFLAGS\").unwrap_or_default(), extra_args));\n+            cargo.env(\n+                \"RUSTFLAGS\",\n+                format!(\n+                    \"{} {}\",\n+                    env::var(\"RUSTFLAGS\").unwrap_or_default(),\n+                    extra_args\n+                ),\n+            );\n         }\n \n         let want_rustdoc = self.doc_tests != DocTests::No;\n \n+        // We synthetically interpret a stage0 compiler used to build tools as a\n+        // \"raw\" compiler in that it's the exact snapshot we download. Normally\n+        // the stage0 build means it uses libraries build by the stage0\n+        // compiler, but for tools we just use the precompiled libraries that\n+        // we've downloaded\n+        let use_snapshot = mode == Mode::ToolBootstrap;\n+        assert!(!use_snapshot || stage == 0);\n+\n+        let maybe_sysroot = self.sysroot(compiler);\n+        let sysroot = if use_snapshot {\n+            self.rustc_snapshot_sysroot()\n+        } else {\n+            &maybe_sysroot\n+        };\n+        let libdir = sysroot.join(libdir(&compiler.host));\n+\n         // Customize the compiler we're running. Specify the compiler to cargo\n         // as our shim and then pass it some various options used to configure\n         // how the actual compiler itself is called.\n         //\n         // These variables are primarily all read by\n         // src/bootstrap/bin/{rustc.rs,rustdoc.rs}\n-        cargo.env(\"RUSTBUILD_NATIVE_DIR\", self.native_dir(target))\n-             .env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n-             .env(\"RUSTC_REAL\", self.rustc(compiler))\n-             .env(\"RUSTC_STAGE\", stage.to_string())\n-             .env(\"RUSTC_DEBUG_ASSERTIONS\",\n-                  self.config.rust_debug_assertions.to_string())\n-             .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n-             .env(\"RUSTC_LIBDIR\", self.rustc_libdir(compiler))\n-             .env(\"RUSTC_RPATH\", self.config.rust_rpath.to_string())\n-             .env(\"RUSTDOC\", self.out.join(\"bootstrap/debug/rustdoc\"))\n-             .env(\"RUSTDOC_REAL\", if cmd == \"doc\" || (cmd == \"test\" && want_rustdoc) {\n-                 self.rustdoc(compiler.host)\n-             } else {\n-                 PathBuf::from(\"/path/to/nowhere/rustdoc/not/required\")\n-             })\n-             .env(\"TEST_MIRI\", self.config.test_miri.to_string())\n-             .env(\"RUSTC_ERROR_METADATA_DST\", self.extended_error_dir());\n+        cargo\n+            .env(\"RUSTBUILD_NATIVE_DIR\", self.native_dir(target))\n+            .env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n+            .env(\"RUSTC_REAL\", self.rustc(compiler))\n+            .env(\"RUSTC_STAGE\", stage.to_string())\n+            .env(\n+                \"RUSTC_DEBUG_ASSERTIONS\",\n+                self.config.rust_debug_assertions.to_string(),\n+            )\n+            .env(\"RUSTC_SYSROOT\", &sysroot)\n+            .env(\"RUSTC_LIBDIR\", &libdir)\n+            .env(\"RUSTC_RPATH\", self.config.rust_rpath.to_string())\n+            .env(\"RUSTDOC\", self.out.join(\"bootstrap/debug/rustdoc\"))\n+            .env(\n+                \"RUSTDOC_REAL\",\n+                if cmd == \"doc\" || (cmd == \"test\" && want_rustdoc) {\n+                    self.rustdoc(compiler.host)\n+                } else {\n+                    PathBuf::from(\"/path/to/nowhere/rustdoc/not/required\")\n+                },\n+            )\n+            .env(\"TEST_MIRI\", self.config.test_miri.to_string())\n+            .env(\"RUSTC_ERROR_METADATA_DST\", self.extended_error_dir());\n \n         if let Some(host_linker) = self.linker(compiler.host) {\n             cargo.env(\"RUSTC_HOST_LINKER\", host_linker);\n@@ -627,19 +827,25 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUSTC_ERROR_FORMAT\", error_format);\n         }\n         if cmd != \"build\" && cmd != \"check\" && want_rustdoc {\n-            cargo.env(\"RUSTDOC_LIBDIR\", self.rustc_libdir(self.compiler(2, self.config.build)));\n+            cargo.env(\"RUSTDOC_LIBDIR\", self.sysroot_libdir(compiler, self.config.build));\n         }\n \n-        if mode == Mode::Tool {\n+        if mode.is_tool() {\n             // Tools like cargo and rls don't get debuginfo by default right now, but this can be\n             // enabled in the config.  Adding debuginfo makes them several times larger.\n             if self.config.rust_debuginfo_tools {\n                 cargo.env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string());\n-                cargo.env(\"RUSTC_DEBUGINFO_LINES\", self.config.rust_debuginfo_lines.to_string());\n+                cargo.env(\n+                    \"RUSTC_DEBUGINFO_LINES\",\n+                    self.config.rust_debuginfo_lines.to_string(),\n+                );\n             }\n         } else {\n             cargo.env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string());\n-            cargo.env(\"RUSTC_DEBUGINFO_LINES\", self.config.rust_debuginfo_lines.to_string());\n+            cargo.env(\n+                \"RUSTC_DEBUGINFO_LINES\",\n+                self.config.rust_debuginfo_lines.to_string(),\n+            );\n             cargo.env(\"RUSTC_FORCE_UNSTABLE\", \"1\");\n \n             // Currently the compiler depends on crates from crates.io, and\n@@ -665,6 +871,10 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUSTC_CRT_STATIC\", x.to_string());\n         }\n \n+        if let Some(x) = self.crt_static(compiler.host) {\n+            cargo.env(\"RUSTC_HOST_CRT_STATIC\", x.to_string());\n+        }\n+\n         // Enable usage of unstable features\n         cargo.env(\"RUSTC_BOOTSTRAP\", \"1\");\n         self.add_rust_test_threads(&mut cargo);\n@@ -685,18 +895,17 @@ impl<'a> Builder<'a> {\n         //\n         // If LLVM support is disabled we need to use the snapshot compiler to compile\n         // build scripts, as the new compiler doesn't support executables.\n-        if mode == Mode::Libstd || !self.config.llvm_enabled {\n-            cargo.env(\"RUSTC_SNAPSHOT\", &self.initial_rustc)\n-                 .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir());\n+        if mode == Mode::Std || !self.config.llvm_enabled {\n+            cargo\n+                .env(\"RUSTC_SNAPSHOT\", &self.initial_rustc)\n+                .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir());\n         } else {\n-            cargo.env(\"RUSTC_SNAPSHOT\", self.rustc(compiler))\n-                 .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_libdir(compiler));\n+            cargo\n+                .env(\"RUSTC_SNAPSHOT\", self.rustc(compiler))\n+                .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_libdir(compiler));\n         }\n \n-        // Ignore incremental modes except for stage0, since we're\n-        // not guaranteeing correctness across builds if the compiler\n-        // is changing under your feet.`\n-        if self.config.incremental && compiler.stage == 0 {\n+        if self.config.incremental {\n             cargo.env(\"CARGO_INCREMENTAL\", \"1\");\n         }\n \n@@ -712,10 +921,14 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUSTC_BACKTRACE_ON_ICE\", \"1\");\n         }\n \n-        cargo.env(\"RUSTC_VERBOSE\", format!(\"{}\", self.verbosity));\n+        if self.config.rust_verify_llvm_ir {\n+            cargo.env(\"RUSTC_VERIFY_LLVM_IR\", \"1\");\n+        }\n+\n+        cargo.env(\"RUSTC_VERBOSE\", self.verbosity.to_string());\n \n         // in std, we want to avoid denying warnings for stage 0 as that makes cfg's painful.\n-        if self.config.deny_warnings && !(mode == Mode::Libstd && stage == 0) {\n+        if self.config.deny_warnings && !(mode == Mode::Std && stage == 0) {\n             cargo.env(\"RUSTC_DENY_WARNINGS\", \"1\");\n         }\n \n@@ -726,7 +939,11 @@ impl<'a> Builder<'a> {\n         // the options through environment variables that are fetched and understood by both.\n         //\n         // FIXME: the guard against msvc shouldn't need to be here\n-        if !target.contains(\"msvc\") {\n+        if target.contains(\"msvc\") {\n+            if let Some(ref cl) = self.config.llvm_clang_cl {\n+                cargo.env(\"CC\", cl).env(\"CXX\", cl);\n+            }\n+        } else {\n             let ccache = self.config.ccache.as_ref();\n             let ccacheify = |s: &Path| {\n                 let ccache = match ccache {\n@@ -744,32 +961,36 @@ impl<'a> Builder<'a> {\n                 }\n             };\n             let cc = ccacheify(&self.cc(target));\n-            cargo.env(format!(\"CC_{}\", target), &cc)\n-                 .env(\"CC\", &cc);\n+            cargo.env(format!(\"CC_{}\", target), &cc).env(\"CC\", &cc);\n \n             let cflags = self.cflags(target).join(\" \");\n-            cargo.env(format!(\"CFLAGS_{}\", target), cflags.clone())\n-                 .env(\"CFLAGS\", cflags.clone());\n+            cargo\n+                .env(format!(\"CFLAGS_{}\", target), cflags.clone())\n+                .env(\"CFLAGS\", cflags.clone());\n \n             if let Some(ar) = self.ar(target) {\n                 let ranlib = format!(\"{} s\", ar.display());\n-                cargo.env(format!(\"AR_{}\", target), ar)\n-                     .env(\"AR\", ar)\n-                     .env(format!(\"RANLIB_{}\", target), ranlib.clone())\n-                     .env(\"RANLIB\", ranlib);\n+                cargo\n+                    .env(format!(\"AR_{}\", target), ar)\n+                    .env(\"AR\", ar)\n+                    .env(format!(\"RANLIB_{}\", target), ranlib.clone())\n+                    .env(\"RANLIB\", ranlib);\n             }\n \n             if let Ok(cxx) = self.cxx(target) {\n                 let cxx = ccacheify(&cxx);\n-                cargo.env(format!(\"CXX_{}\", target), &cxx)\n-                     .env(\"CXX\", &cxx)\n-                     .env(format!(\"CXXFLAGS_{}\", target), cflags.clone())\n-                     .env(\"CXXFLAGS\", cflags);\n+                cargo\n+                    .env(format!(\"CXX_{}\", target), &cxx)\n+                    .env(\"CXX\", &cxx)\n+                    .env(format!(\"CXXFLAGS_{}\", target), cflags.clone())\n+                    .env(\"CXXFLAGS\", cflags);\n             }\n         }\n \n-        if cmd == \"build\" && mode == Mode::Libstd\n-            && self.config.extended && compiler.is_final_stage(self)\n+        if cmd == \"build\"\n+            && mode == Mode::Std\n+            && self.config.extended\n+            && compiler.is_final_stage(self)\n         {\n             cargo.env(\"RUSTC_SAVE_ANALYSIS\", \"api\".to_string());\n         }\n@@ -803,7 +1024,7 @@ impl<'a> Builder<'a> {\n         // default via `-ldylib=winapi_foo`. That is, they're linked with the\n         // `dylib` type with a `winapi_` prefix (so the winapi ones don't\n         // conflict with the system MinGW ones). This consequently means that\n-        // the binaries we ship of things like rustc_trans (aka the rustc_trans\n+        // the binaries we ship of things like rustc_codegen_llvm (aka the rustc_codegen_llvm\n         // DLL) when linked against *again*, for example with procedural macros\n         // or plugins, will trigger the propagation logic of `-ldylib`, passing\n         // `-lwinapi_foo` to the linker again. This isn't actually available in\n@@ -816,7 +1037,7 @@ impl<'a> Builder<'a> {\n         // be resolved because MinGW has the import library. The downside is we\n         // don't get newer functions from Windows, but we don't use any of them\n         // anyway.\n-        if mode != Mode::Tool {\n+        if !mode.is_tool() {\n             cargo.env(\"WINAPI_NO_BUNDLED_LIBRARIES\", \"1\");\n         }\n \n@@ -831,8 +1052,8 @@ impl<'a> Builder<'a> {\n         }\n \n         if self.config.rust_optimize {\n-            // FIXME: cargo bench does not accept `--release`\n-            if cmd != \"bench\" {\n+            // FIXME: cargo bench/install do not accept `--release`\n+            if cmd != \"bench\" && cmd != \"install\" {\n                 cargo.arg(\"--release\");\n             }\n         }\n@@ -857,7 +1078,10 @@ impl<'a> Builder<'a> {\n             let mut stack = self.stack.borrow_mut();\n             for stack_step in stack.iter() {\n                 // should skip\n-                if stack_step.downcast_ref::<S>().map_or(true, |stack_step| *stack_step != step) {\n+                if stack_step\n+                    .downcast_ref::<S>()\n+                    .map_or(true, |stack_step| *stack_step != step)\n+                {\n                     continue;\n                 }\n                 let mut out = String::new();\n@@ -873,7 +1097,9 @@ impl<'a> Builder<'a> {\n                 {\n                     let mut graph = self.graph.borrow_mut();\n                     let parent = self.parent.get();\n-                    let us = *self.graph_nodes.borrow_mut()\n+                    let us = *self\n+                        .graph_nodes\n+                        .borrow_mut()\n                         .entry(format!(\"{:?}\", step))\n                         .or_insert_with(|| graph.add_node(format!(\"{:?}\", step)));\n                     if let Some(parent) = parent {\n@@ -892,7 +1118,9 @@ impl<'a> Builder<'a> {\n         {\n             let mut graph = self.graph.borrow_mut();\n             let parent = self.parent.get();\n-            let us = *self.graph_nodes.borrow_mut()\n+            let us = *self\n+                .graph_nodes\n+                .borrow_mut()\n                 .entry(format!(\"{:?}\", step))\n                 .or_insert_with(|| graph.add_node(format!(\"{:?}\", step)));\n             self.parent.set(Some(us));\n@@ -914,28 +1142,34 @@ impl<'a> Builder<'a> {\n         self.parent.set(prev_parent);\n \n         if self.config.print_step_timings && dur > Duration::from_millis(100) {\n-            println!(\"[TIMING] {:?} -- {}.{:03}\",\n-                     step,\n-                     dur.as_secs(),\n-                     dur.subsec_nanos() / 1_000_000);\n+            println!(\n+                \"[TIMING] {:?} -- {}.{:03}\",\n+                step,\n+                dur.as_secs(),\n+                dur.subsec_nanos() / 1_000_000\n+            );\n         }\n \n         {\n             let mut stack = self.stack.borrow_mut();\n             let cur_step = stack.pop().expect(\"step stack empty\");\n             assert_eq!(cur_step.downcast_ref(), Some(&step));\n         }\n-        self.verbose(&format!(\"{}< {:?}\", \"  \".repeat(self.stack.borrow().len()), step));\n+        self.verbose(&format!(\n+            \"{}< {:?}\",\n+            \"  \".repeat(self.stack.borrow().len()),\n+            step\n+        ));\n         self.cache.put(step, out.clone());\n         out\n     }\n }\n \n #[cfg(test)]\n mod __test {\n+    use super::*;\n     use config::Config;\n     use std::thread;\n-    use super::*;\n \n     fn configure(host: &[&str], target: &[&str]) -> Config {\n         let mut config = Config::default_opts();\n@@ -944,15 +1178,26 @@ mod __test {\n         config.run_host_only = true;\n         config.dry_run = true;\n         // try to avoid spurious failures in dist where we create/delete each others file\n-        let dir = config.out.join(\"tmp-rustbuild-tests\")\n-            .join(&thread::current().name().unwrap_or(\"unknown\").replace(\":\", \"-\"));\n+        let dir = config.out.join(\"tmp-rustbuild-tests\").join(\n+            &thread::current()\n+                .name()\n+                .unwrap_or(\"unknown\")\n+                .replace(\":\", \"-\"),\n+        );\n         t!(fs::create_dir_all(&dir));\n         config.out = dir;\n         config.build = INTERNER.intern_str(\"A\");\n-        config.hosts = vec![config.build].clone().into_iter()\n-            .chain(host.iter().map(|s| INTERNER.intern_str(s))).collect::<Vec<_>>();\n-        config.targets = config.hosts.clone().into_iter()\n-            .chain(target.iter().map(|s| INTERNER.intern_str(s))).collect::<Vec<_>>();\n+        config.hosts = vec![config.build]\n+            .clone()\n+            .into_iter()\n+            .chain(host.iter().map(|s| INTERNER.intern_str(s)))\n+            .collect::<Vec<_>>();\n+        config.targets = config\n+            .hosts\n+            .clone()\n+            .into_iter()\n+            .chain(target.iter().map(|s| INTERNER.intern_str(s)))\n+            .collect::<Vec<_>>();\n         config\n     }\n \n@@ -968,21 +1213,27 @@ mod __test {\n \n         let a = INTERNER.intern_str(\"A\");\n \n-        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n-            dist::Docs { stage: 2, host: a },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n-            dist::Mingw { host: a },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n-            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n-            dist::Std {\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[dist::Docs { stage: 2, host: a },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[dist::Mingw { host: a },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[dist::Rustc {\n+                compiler: Compiler { host: a, stage: 2 }\n+            },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[dist::Std {\n                 compiler: Compiler { host: a, stage: 2 },\n                 target: a,\n-            },\n-        ]);\n+            },]\n+        );\n         assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n     }\n \n@@ -995,27 +1246,36 @@ mod __test {\n         let a = INTERNER.intern_str(\"A\");\n         let b = INTERNER.intern_str(\"B\");\n \n-        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n-            dist::Docs { stage: 2, host: a },\n-            dist::Docs { stage: 2, host: b },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n-            dist::Mingw { host: a },\n-            dist::Mingw { host: b },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n-            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-        ]);\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[\n+                dist::Docs { stage: 2, host: a },\n+                dist::Docs { stage: 2, host: b },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[dist::Rustc {\n+                compiler: Compiler { host: a, stage: 2 }\n+            },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+            ]\n+        );\n         assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n     }\n \n@@ -1028,28 +1288,41 @@ mod __test {\n         let a = INTERNER.intern_str(\"A\");\n         let b = INTERNER.intern_str(\"B\");\n \n-        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n-            dist::Docs { stage: 2, host: a },\n-            dist::Docs { stage: 2, host: b },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n-            dist::Mingw { host: a },\n-            dist::Mingw { host: b },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n-            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n-            dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-        ]);\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[\n+                dist::Docs { stage: 2, host: a },\n+                dist::Docs { stage: 2, host: b },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[\n+                dist::Rustc {\n+                    compiler: Compiler { host: a, stage: 2 }\n+                },\n+                dist::Rustc {\n+                    compiler: Compiler { host: b, stage: 2 }\n+                },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+            ]\n+        );\n         assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n     }\n \n@@ -1063,34 +1336,50 @@ mod __test {\n         let b = INTERNER.intern_str(\"B\");\n         let c = INTERNER.intern_str(\"C\");\n \n-        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n-            dist::Docs { stage: 2, host: a },\n-            dist::Docs { stage: 2, host: b },\n-            dist::Docs { stage: 2, host: c },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n-            dist::Mingw { host: a },\n-            dist::Mingw { host: b },\n-            dist::Mingw { host: c },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n-            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n-            dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: c,\n-            },\n-        ]);\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[\n+                dist::Docs { stage: 2, host: a },\n+                dist::Docs { stage: 2, host: b },\n+                dist::Docs { stage: 2, host: c },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[\n+                dist::Mingw { host: a },\n+                dist::Mingw { host: b },\n+                dist::Mingw { host: c },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[\n+                dist::Rustc {\n+                    compiler: Compiler { host: a, stage: 2 }\n+                },\n+                dist::Rustc {\n+                    compiler: Compiler { host: b, stage: 2 }\n+                },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: c,\n+                },\n+            ]\n+        );\n         assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n     }\n \n@@ -1106,31 +1395,40 @@ mod __test {\n         let b = INTERNER.intern_str(\"B\");\n         let c = INTERNER.intern_str(\"C\");\n \n-        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n-            dist::Docs { stage: 2, host: a },\n-            dist::Docs { stage: 2, host: b },\n-            dist::Docs { stage: 2, host: c },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n-            dist::Mingw { host: a },\n-            dist::Mingw { host: b },\n-            dist::Mingw { host: c },\n-        ]);\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[\n+                dist::Docs { stage: 2, host: a },\n+                dist::Docs { stage: 2, host: b },\n+                dist::Docs { stage: 2, host: c },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[\n+                dist::Mingw { host: a },\n+                dist::Mingw { host: b },\n+                dist::Mingw { host: c },\n+            ]\n+        );\n         assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[]);\n-        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: c,\n-            },\n-        ]);\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: c,\n+                },\n+            ]\n+        );\n         assert_eq!(first(builder.cache.all::<dist::Src>()), &[]);\n     }\n \n@@ -1143,87 +1441,109 @@ mod __test {\n         let a = INTERNER.intern_str(\"A\");\n         let b = INTERNER.intern_str(\"B\");\n \n-        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[\n-            dist::Docs { stage: 2, host: a },\n-            dist::Docs { stage: 2, host: b },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[\n-            dist::Mingw { host: a },\n-            dist::Mingw { host: b },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[\n-            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n-            dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<dist::Std>()), &[\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-        ]);\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[\n+                dist::Docs { stage: 2, host: a },\n+                dist::Docs { stage: 2, host: b },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[\n+                dist::Rustc {\n+                    compiler: Compiler { host: a, stage: 2 }\n+                },\n+                dist::Rustc {\n+                    compiler: Compiler { host: b, stage: 2 }\n+                },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+            ]\n+        );\n         assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-        assert_eq!(first(builder.cache.all::<compile::Std>()), &[\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-            compile::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<compile::Test>()), &[\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<compile::Assemble>()), &[\n-            compile::Assemble {\n-                target_compiler: Compiler { host: a, stage: 0 },\n-            },\n-            compile::Assemble {\n-                target_compiler: Compiler { host: a, stage: 1 },\n-            },\n-            compile::Assemble {\n-                target_compiler: Compiler { host: a, stage: 2 },\n-            },\n-            compile::Assemble {\n-                target_compiler: Compiler { host: b, stage: 2 },\n-            },\n-        ]);\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Std>()),\n+            &[\n+                compile::Std {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: a,\n+                },\n+                compile::Std {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: a,\n+                },\n+                compile::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                compile::Std {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: b,\n+                },\n+                compile::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Test>()),\n+            &[\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Assemble>()),\n+            &[\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: a, stage: 0 },\n+                },\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: a, stage: 1 },\n+                },\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: a, stage: 2 },\n+                },\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: b, stage: 2 },\n+                },\n+            ]\n+        );\n     }\n \n     #[test]\n@@ -1238,83 +1558,89 @@ mod __test {\n \n         assert!(!builder.cache.all::<compile::Std>().is_empty());\n         assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n-        assert_eq!(first(builder.cache.all::<compile::Rustc>()), &[\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: a,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: b,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: b,\n-            },\n-        ]);\n-\n-        assert_eq!(first(builder.cache.all::<compile::Test>()), &[\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: c,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: c,\n-            },\n-        ]);\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Rustc>()),\n+            &[\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: a,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: a,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: b, stage: 2 },\n+                    target: a,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: b,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: b,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: b, stage: 2 },\n+                    target: b,\n+                },\n+            ]\n+        );\n+\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Test>()),\n+            &[\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: b, stage: 2 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: b, stage: 2 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: c,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: b, stage: 2 },\n+                    target: c,\n+                },\n+            ]\n+        );\n     }\n \n     #[test]\n@@ -1330,84 +1656,93 @@ mod __test {\n         let c = INTERNER.intern_str(\"C\");\n \n         assert!(!builder.cache.all::<compile::Std>().is_empty());\n-        assert_eq!(first(builder.cache.all::<compile::Assemble>()), &[\n-            compile::Assemble {\n-                target_compiler: Compiler { host: a, stage: 0 },\n-            },\n-            compile::Assemble {\n-                target_compiler: Compiler { host: a, stage: 1 },\n-            },\n-            compile::Assemble {\n-                target_compiler: Compiler { host: b, stage: 1 },\n-            },\n-            compile::Assemble {\n-                target_compiler: Compiler { host: a, stage: 2 },\n-            },\n-            compile::Assemble {\n-                target_compiler: Compiler { host: b, stage: 2 },\n-            },\n-        ]);\n-        assert_eq!(first(builder.cache.all::<compile::Rustc>()), &[\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: b,\n-            },\n-            compile::Rustc {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-        ]);\n-\n-        assert_eq!(first(builder.cache.all::<compile::Test>()), &[\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: c,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: c,\n-            },\n-        ]);\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Assemble>()),\n+            &[\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: a, stage: 0 },\n+                },\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: a, stage: 1 },\n+                },\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: b, stage: 1 },\n+                },\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: a, stage: 2 },\n+                },\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: b, stage: 2 },\n+                },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Rustc>()),\n+            &[\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: a,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: a,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: b,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: b,\n+                },\n+            ]\n+        );\n+\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Test>()),\n+            &[\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: b, stage: 2 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: b, stage: 2 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: c,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: b, stage: 2 },\n+                    target: c,\n+                },\n+            ]\n+        );\n     }\n \n     #[test]\n@@ -1420,6 +1755,8 @@ mod __test {\n             rustc_args: vec![],\n             fail_fast: true,\n             doc_tests: DocTests::No,\n+            bless: false,\n+            compare_mode: None,\n         };\n \n         let build = Build::new(config);\n@@ -1434,14 +1771,15 @@ mod __test {\n \n         // Ensure we don't build any compiler artifacts.\n         assert!(builder.cache.all::<compile::Rustc>().is_empty());\n-        assert_eq!(first(builder.cache.all::<test::Crate>()), &[\n-            test::Crate {\n+        assert_eq!(\n+            first(builder.cache.all::<test::Crate>()),\n+            &[test::Crate {\n                 compiler: Compiler { host, stage: 0 },\n                 target: host,\n-                mode: Mode::Libstd,\n+                mode: Mode::Std,\n                 test_kind: test::TestKind::Test,\n                 krate: INTERNER.intern_str(\"std\"),\n-            },\n-        ]);\n+            },]\n+        );\n     }\n }"}, {"sha": "bca5ff85ba23e846052ed1ed1b073f02579fe2ce", "filename": "src/bootstrap/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcache.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -249,7 +249,7 @@ lazy_static! {\n pub struct Cache(\n     RefCell<HashMap<\n         TypeId,\n-        Box<Any>, // actually a HashMap<Step, Interned<Step::Output>>\n+        Box<dyn Any>, // actually a HashMap<Step, Interned<Step::Output>>\n     >>\n );\n "}, {"sha": "04d576df95546b98d58bac8316e69ae280b221d0", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -24,7 +24,7 @@ use Build;\n use config::Config;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &str = \"1.27.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.29.0\";\n \n pub struct GitInfo {\n     inner: Option<Info>,"}, {"sha": "8838cdeed8687c1a488fc938a1eabdf47807844c", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -12,7 +12,7 @@\n \n use compile::{run_cargo, std_cargo, test_cargo, rustc_cargo, rustc_cargo_env, add_to_sysroot};\n use builder::{RunConfig, Builder, ShouldRun, Step};\n-use tool::{self, prepare_tool_cargo};\n+use tool::{self, prepare_tool_cargo, SourceType};\n use {Compiler, Mode};\n use cache::{INTERNER, Interned};\n use std::path::PathBuf;\n@@ -40,10 +40,10 @@ impl Step for Std {\n         let target = self.target;\n         let compiler = builder.compiler(0, builder.config.build);\n \n-        let out_dir = builder.stage_out(compiler, Mode::Libstd);\n+        let out_dir = builder.stage_out(compiler, Mode::Std);\n         builder.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n \n-        let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"check\");\n+        let mut cargo = builder.cargo(compiler, Mode::Std, target, \"check\");\n         std_cargo(builder, &compiler, target, &mut cargo);\n \n         let _folder = builder.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n@@ -87,11 +87,11 @@ impl Step for Rustc {\n         let compiler = builder.compiler(0, builder.config.build);\n         let target = self.target;\n \n-        let stage_out = builder.stage_out(compiler, Mode::Librustc);\n+        let stage_out = builder.stage_out(compiler, Mode::Rustc);\n         builder.clear_if_dirty(&stage_out, &libstd_stamp(builder, compiler, target));\n         builder.clear_if_dirty(&stage_out, &libtest_stamp(builder, compiler, target));\n \n-        let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"check\");\n+        let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"check\");\n         rustc_cargo(builder, &mut cargo);\n \n         let _folder = builder.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n@@ -118,7 +118,7 @@ impl Step for CodegenBackend {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.all_krates(\"rustc_trans\")\n+        run.all_krates(\"rustc_codegen_llvm\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -137,14 +137,14 @@ impl Step for CodegenBackend {\n         let target = self.target;\n         let backend = self.backend;\n \n-        let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"check\");\n+        let mut cargo = builder.cargo(compiler, Mode::Codegen, target, \"check\");\n         let features = builder.rustc_features().to_string();\n-        cargo.arg(\"--manifest-path\").arg(builder.src.join(\"src/librustc_trans/Cargo.toml\"));\n+        cargo.arg(\"--manifest-path\").arg(builder.src.join(\"src/librustc_codegen_llvm/Cargo.toml\"));\n         rustc_cargo_env(builder, &mut cargo);\n \n         // We won't build LLVM if it's not available, as it shouldn't affect `check`.\n \n-        let _folder = builder.fold_output(|| format!(\"stage{}-rustc_trans\", compiler.stage));\n+        let _folder = builder.fold_output(|| format!(\"stage{}-rustc_codegen_llvm\", compiler.stage));\n         run_cargo(builder,\n                   cargo.arg(\"--features\").arg(features),\n                   &codegen_backend_stamp(builder, compiler, target, backend),\n@@ -175,10 +175,10 @@ impl Step for Test {\n         let compiler = builder.compiler(0, builder.config.build);\n         let target = self.target;\n \n-        let out_dir = builder.stage_out(compiler, Mode::Libtest);\n+        let out_dir = builder.stage_out(compiler, Mode::Test);\n         builder.clear_if_dirty(&out_dir, &libstd_stamp(builder, compiler, target));\n \n-        let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"check\");\n+        let mut cargo = builder.cargo(compiler, Mode::Test, target, \"check\");\n         test_cargo(builder, &compiler, target, &mut cargo);\n \n         let _folder = builder.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n@@ -219,9 +219,11 @@ impl Step for Rustdoc {\n \n         let mut cargo = prepare_tool_cargo(builder,\n                                            compiler,\n+                                           Mode::ToolRustc,\n                                            target,\n                                            \"check\",\n-                                           \"src/tools/rustdoc\");\n+                                           \"src/tools/rustdoc\",\n+                                           SourceType::InTree);\n \n         let _folder = builder.fold_output(|| format!(\"stage{}-rustdoc\", compiler.stage));\n         println!(\"Checking rustdoc artifacts ({} -> {})\", &compiler.host, target);\n@@ -236,41 +238,42 @@ impl Step for Rustdoc {\n         builder.ensure(tool::CleanTools {\n             compiler,\n             target,\n-            mode: Mode::Tool,\n+            cause: Mode::Rustc,\n         });\n     }\n }\n \n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n pub fn libstd_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n-    builder.cargo_out(compiler, Mode::Libstd, target).join(\".libstd-check.stamp\")\n+    builder.cargo_out(compiler, Mode::Std, target).join(\".libstd-check.stamp\")\n }\n \n /// Cargo's output path for libtest in a given stage, compiled by a particular\n /// compiler for the specified target.\n pub fn libtest_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n-    builder.cargo_out(compiler, Mode::Libtest, target).join(\".libtest-check.stamp\")\n+    builder.cargo_out(compiler, Mode::Test, target).join(\".libtest-check.stamp\")\n }\n \n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n pub fn librustc_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n-    builder.cargo_out(compiler, Mode::Librustc, target).join(\".librustc-check.stamp\")\n+    builder.cargo_out(compiler, Mode::Rustc, target).join(\".librustc-check.stamp\")\n }\n \n-/// Cargo's output path for librustc_trans in a given stage, compiled by a particular\n+/// Cargo's output path for librustc_codegen_llvm in a given stage, compiled by a particular\n /// compiler for the specified target and backend.\n fn codegen_backend_stamp(builder: &Builder,\n                          compiler: Compiler,\n                          target: Interned<String>,\n                          backend: Interned<String>) -> PathBuf {\n-    builder.cargo_out(compiler, Mode::Librustc, target)\n-         .join(format!(\".librustc_trans-{}-check.stamp\", backend))\n+    builder.cargo_out(compiler, Mode::Codegen, target)\n+         .join(format!(\".librustc_codegen_llvm-{}-check.stamp\", backend))\n }\n \n /// Cargo's output path for rustdoc in a given stage, compiled by a particular\n /// compiler for the specified target.\n pub fn rustdoc_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n-    builder.cargo_out(compiler, Mode::Tool, target).join(\".rustdoc-check.stamp\")\n+    builder.cargo_out(compiler, Mode::ToolRustc, target)\n+        .join(\".rustdoc-check.stamp\")\n }"}, {"sha": "04e8e133b03a11ffca2991a1eb639524b413cc41", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 80, "deletions": 52, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -24,7 +24,6 @@ use std::io::prelude::*;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n use std::str;\n-use std::cmp::min;\n \n use build_helper::{output, mtime, up_to_date};\n use filetime::FileTime;\n@@ -68,6 +67,16 @@ impl Step for Std {\n         let target = self.target;\n         let compiler = self.compiler;\n \n+        if builder.config.keep_stage.contains(&compiler.stage) {\n+            builder.info(\"Warning: Using a potentially old libstd. This may not behave well.\");\n+            builder.ensure(StdLink {\n+                compiler: compiler,\n+                target_compiler: compiler,\n+                target,\n+            });\n+            return;\n+        }\n+\n         builder.ensure(StartupObjects { compiler, target });\n \n         if builder.force_use_stage1(compiler, target) {\n@@ -98,9 +107,9 @@ impl Step for Std {\n             copy_musl_third_party_objects(builder, target, &libdir);\n         }\n \n-        let out_dir = builder.cargo_out(compiler, Mode::Libstd, target);\n+        let out_dir = builder.cargo_out(compiler, Mode::Std, target);\n         builder.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n-        let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"build\");\n+        let mut cargo = builder.cargo(compiler, Mode::Std, target, \"build\");\n         std_cargo(builder, &compiler, target, &mut cargo);\n \n         let _folder = builder.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n@@ -240,7 +249,7 @@ impl Step for StdLink {\n         builder.ensure(tool::CleanTools {\n             compiler: target_compiler,\n             target,\n-            mode: Mode::Libstd,\n+            cause: Mode::Std,\n         });\n     }\n }\n@@ -353,6 +362,16 @@ impl Step for Test {\n \n         builder.ensure(Std { compiler, target });\n \n+        if builder.config.keep_stage.contains(&compiler.stage) {\n+            builder.info(\"Warning: Using a potentially old libtest. This may not behave well.\");\n+            builder.ensure(TestLink {\n+                compiler: compiler,\n+                target_compiler: compiler,\n+                target,\n+            });\n+            return;\n+        }\n+\n         if builder.force_use_stage1(compiler, target) {\n             builder.ensure(Test {\n                 compiler: builder.compiler(1, builder.config.build),\n@@ -368,9 +387,9 @@ impl Step for Test {\n             return;\n         }\n \n-        let out_dir = builder.cargo_out(compiler, Mode::Libtest, target);\n+        let out_dir = builder.cargo_out(compiler, Mode::Test, target);\n         builder.clear_if_dirty(&out_dir, &libstd_stamp(builder, compiler, target));\n-        let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"build\");\n+        let mut cargo = builder.cargo(compiler, Mode::Test, target, \"build\");\n         test_cargo(builder, &compiler, target, &mut cargo);\n \n         let _folder = builder.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n@@ -431,7 +450,7 @@ impl Step for TestLink {\n         builder.ensure(tool::CleanTools {\n             compiler: target_compiler,\n             target,\n-            mode: Mode::Libtest,\n+            cause: Mode::Test,\n         });\n     }\n }\n@@ -469,6 +488,16 @@ impl Step for Rustc {\n \n         builder.ensure(Test { compiler, target });\n \n+        if builder.config.keep_stage.contains(&compiler.stage) {\n+            builder.info(\"Warning: Using a potentially old librustc. This may not behave well.\");\n+            builder.ensure(RustcLink {\n+                compiler: compiler,\n+                target_compiler: compiler,\n+                target,\n+            });\n+            return;\n+        }\n+\n         if builder.force_use_stage1(compiler, target) {\n             builder.ensure(Rustc {\n                 compiler: builder.compiler(1, builder.config.build),\n@@ -489,11 +518,11 @@ impl Step for Rustc {\n             compiler: builder.compiler(self.compiler.stage, builder.config.build),\n             target: builder.config.build,\n         });\n-        let cargo_out = builder.cargo_out(compiler, Mode::Librustc, target);\n+        let cargo_out = builder.cargo_out(compiler, Mode::Rustc, target);\n         builder.clear_if_dirty(&cargo_out, &libstd_stamp(builder, compiler, target));\n         builder.clear_if_dirty(&cargo_out, &libtest_stamp(builder, compiler, target));\n \n-        let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"build\");\n+        let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"build\");\n         rustc_cargo(builder, &mut cargo);\n \n         let _folder = builder.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n@@ -585,7 +614,7 @@ impl Step for RustcLink {\n         builder.ensure(tool::CleanTools {\n             compiler: target_compiler,\n             target,\n-            mode: Mode::Librustc,\n+            cause: Mode::Rustc,\n         });\n     }\n }\n@@ -603,7 +632,7 @@ impl Step for CodegenBackend {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.all_krates(\"rustc_trans\")\n+        run.all_krates(\"rustc_codegen_llvm\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -625,6 +654,14 @@ impl Step for CodegenBackend {\n \n         builder.ensure(Rustc { compiler, target });\n \n+        if builder.config.keep_stage.contains(&compiler.stage) {\n+            builder.info(\"Warning: Using a potentially old codegen backend. \\\n+                This may not behave well.\");\n+            // Codegen backends are linked separately from this step today, so we don't do\n+            // anything here.\n+            return;\n+        }\n+\n         if builder.force_use_stage1(compiler, target) {\n             builder.ensure(CodegenBackend {\n                 compiler: builder.compiler(1, builder.config.build),\n@@ -634,18 +671,18 @@ impl Step for CodegenBackend {\n             return;\n         }\n \n-        let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"build\");\n+        let mut cargo = builder.cargo(compiler, Mode::Codegen, target, \"build\");\n         let mut features = builder.rustc_features().to_string();\n         cargo.arg(\"--manifest-path\")\n-            .arg(builder.src.join(\"src/librustc_trans/Cargo.toml\"));\n+            .arg(builder.src.join(\"src/librustc_codegen_llvm/Cargo.toml\"));\n         rustc_cargo_env(builder, &mut cargo);\n \n         features += &build_codegen_backend(&builder, &mut cargo, &compiler, target, backend);\n \n-        let tmp_stamp = builder.cargo_out(compiler, Mode::Librustc, target)\n+        let tmp_stamp = builder.cargo_out(compiler, Mode::Codegen, target)\n             .join(\".tmp.stamp\");\n \n-        let _folder = builder.fold_output(|| format!(\"stage{}-rustc_trans\", compiler.stage));\n+        let _folder = builder.fold_output(|| format!(\"stage{}-rustc_codegen_llvm\", compiler.stage));\n         let files = run_cargo(builder,\n                               cargo.arg(\"--features\").arg(features),\n                               &tmp_stamp,\n@@ -656,7 +693,7 @@ impl Step for CodegenBackend {\n         let mut files = files.into_iter()\n             .filter(|f| {\n                 let filename = f.file_name().unwrap().to_str().unwrap();\n-                is_dylib(filename) && filename.contains(\"rustc_trans-\")\n+                is_dylib(filename) && filename.contains(\"rustc_codegen_llvm-\")\n             });\n         let codegen_backend = match files.next() {\n             Some(f) => f,\n@@ -697,7 +734,7 @@ pub fn build_codegen_backend(builder: &Builder,\n                      compiler.stage, &compiler.host, target, backend));\n \n             // Pass down configuration from the LLVM build into the build of\n-            // librustc_llvm and librustc_trans.\n+            // librustc_llvm and librustc_codegen_llvm.\n             if builder.is_rust_llvm(target) {\n                 cargo.env(\"LLVM_RUSTLLVM\", \"1\");\n             }\n@@ -762,7 +799,7 @@ fn copy_codegen_backends_to_sysroot(builder: &Builder,\n         t!(t!(File::open(&stamp)).read_to_string(&mut dylib));\n         let file = Path::new(&dylib);\n         let filename = file.file_name().unwrap().to_str().unwrap();\n-        // change `librustc_trans-xxxxxx.so` to `librustc_trans-llvm.so`\n+        // change `librustc_codegen_llvm-xxxxxx.so` to `librustc_codegen_llvm-llvm.so`\n         let target_filename = {\n             let dash = filename.find(\"-\").unwrap();\n             let dot = filename.find(\".\").unwrap();\n@@ -786,36 +823,39 @@ fn copy_lld_to_sysroot(builder: &Builder,\n         .join(\"bin\");\n     t!(fs::create_dir_all(&dst));\n \n-    let exe = exe(\"lld\", &target);\n-    builder.copy(&lld_install_root.join(\"bin\").join(&exe), &dst.join(&exe));\n+    let src_exe = exe(\"lld\", &target);\n+    let dst_exe = exe(\"rust-lld\", &target);\n+    // we prepend this bin directory to the user PATH when linking Rust binaries. To\n+    // avoid shadowing the system LLD we rename the LLD we provide to `rust-lld`.\n+    builder.copy(&lld_install_root.join(\"bin\").join(&src_exe), &dst.join(&dst_exe));\n }\n \n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n pub fn libstd_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n-    builder.cargo_out(compiler, Mode::Libstd, target).join(\".libstd.stamp\")\n+    builder.cargo_out(compiler, Mode::Std, target).join(\".libstd.stamp\")\n }\n \n /// Cargo's output path for libtest in a given stage, compiled by a particular\n /// compiler for the specified target.\n pub fn libtest_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n-    builder.cargo_out(compiler, Mode::Libtest, target).join(\".libtest.stamp\")\n+    builder.cargo_out(compiler, Mode::Test, target).join(\".libtest.stamp\")\n }\n \n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n pub fn librustc_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n-    builder.cargo_out(compiler, Mode::Librustc, target).join(\".librustc.stamp\")\n+    builder.cargo_out(compiler, Mode::Rustc, target).join(\".librustc.stamp\")\n }\n \n-/// Cargo's output path for librustc_trans in a given stage, compiled by a particular\n+/// Cargo's output path for librustc_codegen_llvm in a given stage, compiled by a particular\n /// compiler for the specified target and backend.\n fn codegen_backend_stamp(builder: &Builder,\n                          compiler: Compiler,\n                          target: Interned<String>,\n                          backend: Interned<String>) -> PathBuf {\n-    builder.cargo_out(compiler, Mode::Librustc, target)\n-        .join(format!(\".librustc_trans-{}.stamp\", backend))\n+    builder.cargo_out(compiler, Mode::Codegen, target)\n+        .join(format!(\".librustc_codegen_llvm-{}.stamp\", backend))\n }\n \n pub fn compiler_file(builder: &Builder,\n@@ -873,7 +913,7 @@ impl Step for Assemble {\n     type Output = Compiler;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.all_krates(\"rustc-main\")\n+        run.never()\n     }\n \n     /// Prepare a new compiler from the artifacts in `stage`\n@@ -915,28 +955,16 @@ impl Step for Assemble {\n         // link to these. (FIXME: Is that correct? It seems to be correct most\n         // of the time but I think we do link to these for stage2/bin compilers\n         // when not performing a full bootstrap).\n-        if builder.config.keep_stage.map_or(false, |s| target_compiler.stage <= s) {\n-            builder.verbose(\"skipping compilation of compiler due to --keep-stage\");\n-            let compiler = build_compiler;\n-            for stage in 0..min(target_compiler.stage, builder.config.keep_stage.unwrap()) {\n-                let target_compiler = builder.compiler(stage, target_compiler.host);\n-                let target = target_compiler.host;\n-                builder.ensure(StdLink { compiler, target_compiler, target });\n-                builder.ensure(TestLink { compiler, target_compiler, target });\n-                builder.ensure(RustcLink { compiler, target_compiler, target });\n-            }\n-        } else {\n-            builder.ensure(Rustc {\n+        builder.ensure(Rustc {\n+            compiler: build_compiler,\n+            target: target_compiler.host,\n+        });\n+        for &backend in builder.config.rust_codegen_backends.iter() {\n+            builder.ensure(CodegenBackend {\n                 compiler: build_compiler,\n                 target: target_compiler.host,\n+                backend,\n             });\n-            for &backend in builder.config.rust_codegen_backends.iter() {\n-                builder.ensure(CodegenBackend {\n-                    compiler: build_compiler,\n-                    target: target_compiler.host,\n-                    backend,\n-                });\n-            }\n         }\n \n         let lld_install = if builder.config.lld_enabled {\n@@ -971,8 +999,8 @@ impl Step for Assemble {\n         }\n \n         // Link the compiler binary itself into place\n-        let out_dir = builder.cargo_out(build_compiler, Mode::Librustc, host);\n-        let rustc = out_dir.join(exe(\"rustc\", &*host));\n+        let out_dir = builder.cargo_out(build_compiler, Mode::Rustc, host);\n+        let rustc = out_dir.join(exe(\"rustc_binary\", &*host));\n         let bindir = sysroot.join(\"bin\");\n         t!(fs::create_dir_all(&bindir));\n         let compiler = builder.rustc(target_compiler);\n@@ -1049,22 +1077,22 @@ pub fn run_cargo(builder: &Builder, cargo: &mut Command, stamp: &Path, is_check:\n                !filename.ends_with(\".lib\") &&\n                !is_dylib(&filename) &&\n                !(is_check && filename.ends_with(\".rmeta\")) {\n-                return;\n+                continue;\n             }\n \n             let filename = Path::new(&*filename);\n \n             // If this was an output file in the \"host dir\" we don't actually\n             // worry about it, it's not relevant for us.\n             if filename.starts_with(&host_root_dir) {\n-                return;\n+                continue;\n             }\n \n             // If this was output in the `deps` dir then this is a precise file\n             // name (hash included) so we start tracking it.\n             if filename.starts_with(&target_deps_dir) {\n                 deps.push(filename.to_path_buf());\n-                return;\n+                continue;\n             }\n \n             // Otherwise this was a \"top level artifact\" which right now doesn't\n@@ -1163,7 +1191,7 @@ pub fn run_cargo(builder: &Builder, cargo: &mut Command, stamp: &Path, is_check:\n pub fn stream_cargo(\n     builder: &Builder,\n     cargo: &mut Command,\n-    cb: &mut FnMut(CargoMessage),\n+    cb: &mut dyn FnMut(CargoMessage),\n ) -> bool {\n     if builder.config.dry_run {\n         return true;"}, {"sha": "0a8a5c87d0da1a4b1a90cbd5aad26b634f02ae34", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -23,7 +23,6 @@ use std::cmp;\n \n use num_cpus;\n use toml;\n-use util::exe;\n use cache::{INTERNER, Interned};\n use flags::Flags;\n pub use flags::Subcommand;\n@@ -64,7 +63,7 @@ pub struct Config {\n \n     pub on_fail: Option<String>,\n     pub stage: Option<u32>,\n-    pub keep_stage: Option<u32>,\n+    pub keep_stage: Vec<u32>,\n     pub src: PathBuf,\n     pub jobs: Option<u32>,\n     pub cmd: Subcommand,\n@@ -82,11 +81,13 @@ pub struct Config {\n     pub llvm_version_check: bool,\n     pub llvm_static_stdcpp: bool,\n     pub llvm_link_shared: bool,\n+    pub llvm_clang_cl: Option<String>,\n     pub llvm_targets: Option<String>,\n     pub llvm_experimental_targets: String,\n     pub llvm_link_jobs: Option<u32>,\n \n     pub lld_enabled: bool,\n+    pub llvm_tools_enabled: bool,\n \n     // rust codegen options\n     pub rust_optimize: bool,\n@@ -104,6 +105,7 @@ pub struct Config {\n     pub rust_dist_src: bool,\n     pub rust_codegen_backends: Vec<Interned<String>>,\n     pub rust_codegen_backends_dir: String,\n+    pub rust_verify_llvm_ir: bool,\n \n     pub build: Interned<String>,\n     pub hosts: Vec<Interned<String>>,\n@@ -124,7 +126,7 @@ pub struct Config {\n     // misc\n     pub low_priority: bool,\n     pub channel: String,\n-    pub quiet_tests: bool,\n+    pub verbose_tests: bool,\n     pub test_miri: bool,\n     pub save_toolstates: Option<PathBuf>,\n     pub print_step_timings: bool,\n@@ -250,6 +252,7 @@ struct Llvm {\n     experimental_targets: Option<String>,\n     link_jobs: Option<u32>,\n     link_shared: Option<bool>,\n+    clang_cl: Option<String>\n }\n \n #[derive(Deserialize, Default, Clone)]\n@@ -299,15 +302,18 @@ struct Rust {\n     ignore_git: Option<bool>,\n     debug: Option<bool>,\n     dist_src: Option<bool>,\n-    quiet_tests: Option<bool>,\n+    verbose_tests: Option<bool>,\n     test_miri: Option<bool>,\n+    incremental: Option<bool>,\n     save_toolstates: Option<String>,\n     codegen_backends: Option<Vec<String>>,\n     codegen_backends_dir: Option<String>,\n     wasm_syscall: Option<bool>,\n     lld: Option<bool>,\n+    llvm_tools: Option<bool>,\n     deny_warnings: Option<bool>,\n     backtrace_on_ice: Option<bool>,\n+    verify_llvm_ir: Option<bool>,\n }\n \n /// TOML representation of how each build target is configured.\n@@ -362,9 +368,8 @@ impl Config {\n         config.src = Config::path_from_python(\"SRC\");\n         config.out = Config::path_from_python(\"BUILD_DIR\");\n \n-        let stage0_root = config.out.join(&config.build).join(\"stage0/bin\");\n-        config.initial_rustc = stage0_root.join(exe(\"rustc\", &config.build));\n-        config.initial_cargo = stage0_root.join(exe(\"cargo\", &config.build));\n+        config.initial_rustc = Config::path_from_python(\"RUSTC\");\n+        config.initial_cargo = Config::path_from_python(\"CARGO\");\n \n         config\n     }\n@@ -504,6 +509,7 @@ impl Config {\n             config.llvm_experimental_targets = llvm.experimental_targets.clone()\n                 .unwrap_or(\"WebAssembly\".to_string());\n             config.llvm_link_jobs = llvm.link_jobs;\n+            config.llvm_clang_cl = llvm.clang_cl.clone();\n         }\n \n         if let Some(ref rust) = toml.rust {\n@@ -524,16 +530,22 @@ impl Config {\n             set(&mut config.backtrace, rust.backtrace);\n             set(&mut config.channel, rust.channel.clone());\n             set(&mut config.rust_dist_src, rust.dist_src);\n-            set(&mut config.quiet_tests, rust.quiet_tests);\n+            set(&mut config.verbose_tests, rust.verbose_tests);\n             set(&mut config.test_miri, rust.test_miri);\n+            // in the case \"false\" is set explicitly, do not overwrite the command line args\n+            if let Some(true) = rust.incremental {\n+                config.incremental = true;\n+            }\n             set(&mut config.wasm_syscall, rust.wasm_syscall);\n             set(&mut config.lld_enabled, rust.lld);\n+            set(&mut config.llvm_tools_enabled, rust.llvm_tools);\n             config.rustc_parallel_queries = rust.experimental_parallel_queries.unwrap_or(false);\n             config.rustc_default_linker = rust.default_linker.clone();\n             config.musl_root = rust.musl_root.clone().map(PathBuf::from);\n             config.save_toolstates = rust.save_toolstates.clone().map(PathBuf::from);\n             set(&mut config.deny_warnings, rust.deny_warnings.or(flags.warnings));\n             set(&mut config.backtrace_on_ice, rust.backtrace_on_ice);\n+            set(&mut config.rust_verify_llvm_ir, rust.verify_llvm_ir);\n \n             if let Some(ref backends) = rust.codegen_backends {\n                 config.rust_codegen_backends = backends.iter()"}, {"sha": "9fdba044f4be3da82b035e5bc110c4a477f9085d", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -47,7 +47,7 @@ def v(*args):\n o(\"experimental-parallel-queries\", \"rust.experimental-parallel-queries\", \"build rustc with experimental parallelization\")\n o(\"test-miri\", \"rust.test-miri\", \"run miri's test suite\")\n o(\"debuginfo-tests\", \"rust.debuginfo-tests\", \"build tests with debugger metadata\")\n-o(\"quiet-tests\", \"rust.quiet-tests\", \"enable quieter output when running tests\")\n+o(\"verbose-tests\", \"rust.verbose-tests\", \"enable verbose output when running tests\")\n o(\"ccache\", \"llvm.ccache\", \"invoke gcc/clang via ccache to reuse object files between builds\")\n o(\"sccache\", None, \"invoke gcc/clang via sccache to reuse object files between builds\")\n o(\"local-rust\", None, \"use an installed rustc rather than downloading a snapshot\")\n@@ -335,6 +335,7 @@ def set(key, value):\n     elif option.name == 'full-tools':\n         set('rust.codegen-backends', ['llvm', 'emscripten'])\n         set('rust.lld', True)\n+        set('rust.llvm-tools', True)\n         set('build.extended', True)\n     elif option.name == 'option-checking':\n         # this was handled above\n@@ -431,7 +432,7 @@ def configure_section(lines, config):\n # order that we read it in.\n p(\"\")\n p(\"writing `config.toml` in current directory\")\n-with open('config.toml', 'w') as f:\n+with bootstrap.output('config.toml') as f:\n     for section in section_order:\n         if section == 'target':\n             for target in targets:\n@@ -441,7 +442,7 @@ def configure_section(lines, config):\n             for line in sections[section]:\n                 f.write(line + \"\\n\")\n \n-with open('Makefile', 'w') as f:\n+with bootstrap.output('Makefile') as f:\n     contents = os.path.join(rust_dir, 'src', 'bootstrap', 'mk', 'Makefile.in')\n     contents = open(contents).read()\n     contents = contents.replace(\"$(CFG_SRC_DIR)\", rust_dir + '/')"}, {"sha": "7b4808ef018f761110fcdcac8c2fd663b02b3bec", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 228, "deletions": 9, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -26,7 +26,7 @@ use std::process::{Command, Stdio};\n \n use build_helper::output;\n \n-use {Compiler, Mode};\n+use {Compiler, Mode, LLVM_TOOLS};\n use channel;\n use util::{libdir, is_dylib, exe};\n use builder::{Builder, RunConfig, ShouldRun, Step};\n@@ -41,8 +41,12 @@ pub fn pkgname(builder: &Builder, component: &str) -> String {\n         format!(\"{}-{}\", component, builder.cargo_package_vers())\n     } else if component == \"rls\" {\n         format!(\"{}-{}\", component, builder.rls_package_vers())\n+    } else if component == \"clippy\" {\n+        format!(\"{}-{}\", component, builder.clippy_package_vers())\n     } else if component == \"rustfmt\" {\n         format!(\"{}-{}\", component, builder.rustfmt_package_vers())\n+    } else if component == \"llvm-tools\" {\n+        format!(\"{}-{}\", component, builder.llvm_tools_package_vers())\n     } else {\n         assert!(component.starts_with(\"rust\"));\n         format!(\"{}-{}\", component, builder.rust_package_vers())\n@@ -304,6 +308,14 @@ fn make_win_dist(\n         builder.copy_to_folder(&src, &target_bin_dir);\n     }\n \n+    // Warn windows-gnu users that the bundled GCC cannot compile C files\n+    builder.create(\n+        &target_bin_dir.join(\"GCC-WARNING.txt\"),\n+        \"gcc.exe contained in this folder cannot be used for compiling C files - it is only\\\n+         used as a linker. In order to be able to compile projects containing C code use\\\n+         the GCC provided by MinGW or Cygwin.\"\n+    );\n+\n     //Copy platform libs to platform-specific lib directory\n     let target_lib_dir = plat_root.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"lib\");\n     fs::create_dir_all(&target_lib_dir).expect(\"creating target_lib_dir failed\");\n@@ -394,7 +406,7 @@ impl Step for Rustc {\n         let compiler = self.compiler;\n         let host = self.compiler.host;\n \n-        builder.info(&format!(\"Dist rustc stage{} ({})\", compiler.stage, compiler.host));\n+        builder.info(&format!(\"Dist rustc stage{} ({})\", compiler.stage, host));\n         let name = pkgname(builder, \"rustc\");\n         let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, host));\n         let _ = fs::remove_dir_all(&image);\n@@ -489,12 +501,13 @@ impl Step for Rustc {\n \n             // Copy over lld if it's there\n             if builder.config.lld_enabled {\n-                let exe = exe(\"lld\", &compiler.host);\n+                let exe = exe(\"rust-lld\", &compiler.host);\n                 let src = builder.sysroot_libdir(compiler, host)\n                     .parent()\n                     .unwrap()\n                     .join(\"bin\")\n                     .join(&exe);\n+                // for the rationale about this rename check `compile::copy_lld_to_sysroot`\n                 let dst = image.join(\"lib/rustlib\")\n                     .join(&*host)\n                     .join(\"bin\")\n@@ -722,7 +735,7 @@ impl Step for Analysis {\n \n         let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, target));\n \n-        let src = builder.stage_out(compiler, Mode::Libstd)\n+        let src = builder.stage_out(compiler, Mode::Std)\n             .join(target).join(builder.cargo_dir()).join(\"deps\");\n \n         let image_src = src.join(\"save-analysis\");\n@@ -951,13 +964,16 @@ impl Step for PlainSourceTarball {\n                 has_cargo_vendor |= line.starts_with(\"cargo-vendor \");\n             }\n             if !has_cargo_vendor {\n-                let mut cmd = Command::new(&builder.initial_cargo);\n-                cmd.arg(\"install\")\n-                   .arg(\"--force\")\n+                let mut cmd = builder.cargo(\n+                    builder.compiler(0, builder.config.build),\n+                    Mode::ToolBootstrap,\n+                    builder.config.build,\n+                    \"install\"\n+                );\n+                cmd.arg(\"--force\")\n                    .arg(\"--debug\")\n                    .arg(\"--vers\").arg(CARGO_VENDOR_VERSION)\n-                   .arg(\"cargo-vendor\")\n-                   .env(\"RUSTC\", &builder.initial_rustc);\n+                   .arg(\"cargo-vendor\");\n                 if let Some(dir) = builder.openssl_install_dir(builder.config.build) {\n                     builder.ensure(native::Openssl {\n                         target: builder.config.build,\n@@ -1178,6 +1194,87 @@ impl Step for Rls {\n     }\n }\n \n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Clippy {\n+    pub stage: u32,\n+    pub target: Interned<String>,\n+}\n+\n+impl Step for Clippy {\n+    type Output = Option<PathBuf>;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"clippy\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Clippy {\n+            stage: run.builder.top_stage,\n+            target: run.target,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+        let stage = self.stage;\n+        let target = self.target;\n+        assert!(builder.config.extended);\n+\n+        builder.info(&format!(\"Dist clippy stage{} ({})\", stage, target));\n+        let src = builder.src.join(\"src/tools/clippy\");\n+        let release_num = builder.release_num(\"clippy\");\n+        let name = pkgname(builder, \"clippy\");\n+        let version = builder.clippy_info.version(builder, &release_num);\n+\n+        let tmp = tmpdir(builder);\n+        let image = tmp.join(\"clippy-image\");\n+        drop(fs::remove_dir_all(&image));\n+        builder.create_dir(&image);\n+\n+        // Prepare the image directory\n+        // We expect clippy to build, because we've exited this step above if tool\n+        // state for clippy isn't testing.\n+        let clippy = builder.ensure(tool::Clippy {\n+            compiler: builder.compiler(stage, builder.config.build),\n+            target, extra_features: Vec::new()\n+        }).or_else(|| { println!(\"Unable to build clippy, skipping dist\"); None })?;\n+        let cargoclippy = builder.ensure(tool::CargoClippy {\n+            compiler: builder.compiler(stage, builder.config.build),\n+            target, extra_features: Vec::new()\n+        }).or_else(|| { println!(\"Unable to build cargo clippy, skipping dist\"); None })?;\n+\n+        builder.install(&clippy, &image.join(\"bin\"), 0o755);\n+        builder.install(&cargoclippy, &image.join(\"bin\"), 0o755);\n+        let doc = image.join(\"share/doc/clippy\");\n+        builder.install(&src.join(\"README.md\"), &doc, 0o644);\n+        builder.install(&src.join(\"LICENSE\"), &doc, 0o644);\n+\n+        // Prepare the overlay\n+        let overlay = tmp.join(\"clippy-overlay\");\n+        drop(fs::remove_dir_all(&overlay));\n+        t!(fs::create_dir_all(&overlay));\n+        builder.install(&src.join(\"README.md\"), &overlay, 0o644);\n+        builder.install(&src.join(\"LICENSE\"), &doc, 0o644);\n+        builder.create(&overlay.join(\"version\"), &version);\n+\n+        // Generate the installer tarball\n+        let mut cmd = rust_installer(builder);\n+        cmd.arg(\"generate\")\n+           .arg(\"--product-name=Rust\")\n+           .arg(\"--rel-manifest-dir=rustlib\")\n+           .arg(\"--success-message=clippy-ready-to-serve.\")\n+           .arg(\"--image-dir\").arg(&image)\n+           .arg(\"--work-dir\").arg(&tmpdir(builder))\n+           .arg(\"--output-dir\").arg(&distdir(builder))\n+           .arg(\"--non-installed-overlay\").arg(&overlay)\n+           .arg(format!(\"--package-name={}-{}\", name, target))\n+           .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n+           .arg(\"--component-name=clippy-preview\");\n+\n+        builder.run(&mut cmd);\n+        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n+    }\n+}\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustfmt {\n@@ -1298,6 +1395,8 @@ impl Step for Extended {\n         let cargo_installer = builder.ensure(Cargo { stage, target });\n         let rustfmt_installer = builder.ensure(Rustfmt { stage, target });\n         let rls_installer = builder.ensure(Rls { stage, target });\n+        let llvm_tools_installer = builder.ensure(LlvmTools { stage, target });\n+        let clippy_installer = builder.ensure(Clippy { stage, target });\n         let mingw_installer = builder.ensure(Mingw { host: target });\n         let analysis_installer = builder.ensure(Analysis {\n             compiler: builder.compiler(stage, self.host),\n@@ -1334,7 +1433,9 @@ impl Step for Extended {\n         tarballs.push(rustc_installer);\n         tarballs.push(cargo_installer);\n         tarballs.extend(rls_installer.clone());\n+        tarballs.extend(clippy_installer.clone());\n         tarballs.extend(rustfmt_installer.clone());\n+        tarballs.extend(llvm_tools_installer.clone());\n         tarballs.push(analysis_installer);\n         tarballs.push(std_installer);\n         if builder.config.docs {\n@@ -1402,6 +1503,9 @@ impl Step for Extended {\n             if rls_installer.is_none() {\n                 contents = filter(&contents, \"rls\");\n             }\n+            if clippy_installer.is_none() {\n+                contents = filter(&contents, \"clippy\");\n+            }\n             if rustfmt_installer.is_none() {\n                 contents = filter(&contents, \"rustfmt\");\n             }\n@@ -1439,6 +1543,9 @@ impl Step for Extended {\n             if rls_installer.is_some() {\n                 prepare(\"rls\");\n             }\n+            if clippy_installer.is_some() {\n+                prepare(\"clippy\");\n+            }\n \n             // create an 'uninstall' package\n             builder.install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"uninstall\"), 0o755);\n@@ -1467,6 +1574,8 @@ impl Step for Extended {\n                     format!(\"{}-{}\", name, target)\n                 } else if name == \"rls\" {\n                     \"rls-preview\".to_string()\n+                } else if name == \"clippy\" {\n+                    \"clippy-preview\".to_string()\n                 } else {\n                     name.to_string()\n                 };\n@@ -1483,6 +1592,9 @@ impl Step for Extended {\n             if rls_installer.is_some() {\n                 prepare(\"rls\");\n             }\n+            if clippy_installer.is_some() {\n+                prepare(\"clippy\");\n+            }\n             if target.contains(\"windows-gnu\") {\n                 prepare(\"rust-mingw\");\n             }\n@@ -1563,6 +1675,18 @@ impl Step for Extended {\n                                 .arg(\"-out\").arg(exe.join(\"RlsGroup.wxs\"))\n                                 .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n             }\n+            if clippy_installer.is_some() {\n+                builder.run(Command::new(&heat)\n+                                .current_dir(&exe)\n+                                .arg(\"dir\")\n+                                .arg(\"clippy\")\n+                                .args(&heat_flags)\n+                                .arg(\"-cg\").arg(\"ClippyGroup\")\n+                                .arg(\"-dr\").arg(\"Clippy\")\n+                                .arg(\"-var\").arg(\"var.ClippyDir\")\n+                                .arg(\"-out\").arg(exe.join(\"ClippyGroup.wxs\"))\n+                                .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n+            }\n             builder.run(Command::new(&heat)\n                             .current_dir(&exe)\n                             .arg(\"dir\")\n@@ -1605,6 +1729,9 @@ impl Step for Extended {\n                 if rls_installer.is_some() {\n                     cmd.arg(\"-dRlsDir=rls\");\n                 }\n+                if clippy_installer.is_some() {\n+                    cmd.arg(\"-dClippyDir=clippy\");\n+                }\n                 if target.contains(\"windows-gnu\") {\n                     cmd.arg(\"-dGccDir=rust-mingw\");\n                 }\n@@ -1620,6 +1747,9 @@ impl Step for Extended {\n             if rls_installer.is_some() {\n                 candle(\"RlsGroup.wxs\".as_ref());\n             }\n+            if clippy_installer.is_some() {\n+                candle(\"ClippyGroup.wxs\".as_ref());\n+            }\n             candle(\"AnalysisGroup.wxs\".as_ref());\n \n             if target.contains(\"windows-gnu\") {\n@@ -1649,6 +1779,9 @@ impl Step for Extended {\n             if rls_installer.is_some() {\n                 cmd.arg(\"RlsGroup.wixobj\");\n             }\n+            if clippy_installer.is_some() {\n+                cmd.arg(\"ClippyGroup.wixobj\");\n+            }\n \n             if target.contains(\"windows-gnu\") {\n                 cmd.arg(\"GccGroup.wixobj\");\n@@ -1734,7 +1867,9 @@ impl Step for HashSign {\n         cmd.arg(builder.rust_package_vers());\n         cmd.arg(builder.package_vers(&builder.release_num(\"cargo\")));\n         cmd.arg(builder.package_vers(&builder.release_num(\"rls\")));\n+        cmd.arg(builder.package_vers(&builder.release_num(\"clippy\")));\n         cmd.arg(builder.package_vers(&builder.release_num(\"rustfmt\")));\n+        cmd.arg(builder.llvm_tools_package_vers());\n         cmd.arg(addr);\n \n         builder.create_dir(&distdir(builder));\n@@ -1745,3 +1880,87 @@ impl Step for HashSign {\n         assert!(status.success());\n     }\n }\n+\n+#[derive(Clone, Debug, Eq, Hash, PartialEq)]\n+pub struct LlvmTools {\n+    pub stage: u32,\n+    pub target: Interned<String>,\n+}\n+\n+impl Step for LlvmTools {\n+    type Output = Option<PathBuf>;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"llvm-tools\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(LlvmTools {\n+            stage: run.builder.top_stage,\n+            target: run.target,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+        let stage = self.stage;\n+        let target = self.target;\n+        assert!(builder.config.extended);\n+\n+        /* run only if llvm-config isn't used */\n+        if let Some(config) = builder.config.target_config.get(&target) {\n+            if let Some(ref _s) = config.llvm_config {\n+                builder.info(&format!(\"Skipping LlvmTools stage{} ({}): external LLVM\",\n+                    stage, target));\n+                return None;\n+            }\n+        }\n+\n+        builder.info(&format!(\"Dist LlvmTools stage{} ({})\", stage, target));\n+        let src = builder.src.join(\"src/llvm\");\n+        let name = pkgname(builder, \"llvm-tools\");\n+\n+        let tmp = tmpdir(builder);\n+        let image = tmp.join(\"llvm-tools-image\");\n+        drop(fs::remove_dir_all(&image));\n+\n+        // Prepare the image directory\n+        let bindir = builder\n+            .llvm_out(target)\n+            .join(\"bin\");\n+        let dst = image.join(\"lib/rustlib\")\n+            .join(target)\n+            .join(\"bin\");\n+        t!(fs::create_dir_all(&dst));\n+        for tool in LLVM_TOOLS {\n+            let exe = bindir.join(exe(tool, &target));\n+            builder.install(&exe, &dst, 0o755);\n+        }\n+\n+        // Prepare the overlay\n+        let overlay = tmp.join(\"llvm-tools-overlay\");\n+        drop(fs::remove_dir_all(&overlay));\n+        builder.create_dir(&overlay);\n+        builder.install(&src.join(\"README.txt\"), &overlay, 0o644);\n+        builder.install(&src.join(\"LICENSE.TXT\"), &overlay, 0o644);\n+        builder.create(&overlay.join(\"version\"), &builder.llvm_tools_vers());\n+\n+        // Generate the installer tarball\n+        let mut cmd = rust_installer(builder);\n+        cmd.arg(\"generate\")\n+            .arg(\"--product-name=Rust\")\n+            .arg(\"--rel-manifest-dir=rustlib\")\n+            .arg(\"--success-message=llvm-tools-installed.\")\n+            .arg(\"--image-dir\").arg(&image)\n+            .arg(\"--work-dir\").arg(&tmpdir(builder))\n+            .arg(\"--output-dir\").arg(&distdir(builder))\n+            .arg(\"--non-installed-overlay\").arg(&overlay)\n+            .arg(format!(\"--package-name={}-{}\", name, target))\n+            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n+            .arg(\"--component-name=llvm-tools-preview\");\n+\n+\n+        builder.run(&mut cmd);\n+        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n+    }\n+}"}, {"sha": "fd3730ffc78de984c8063640c951812aba36fc2c", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 106, "deletions": 13, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -28,7 +28,7 @@ use build_helper::up_to_date;\n \n use util::symlink_dir;\n use builder::{Builder, Compiler, RunConfig, ShouldRun, Step};\n-use tool::Tool;\n+use tool::{self, prepare_tool_cargo, Tool, SourceType};\n use compile;\n use cache::{INTERNER, Interned};\n use config::Config;\n@@ -70,7 +70,7 @@ macro_rules! book {\n book!(\n     Nomicon, \"src/doc/nomicon\", \"nomicon\";\n     Reference, \"src/doc/reference\", \"reference\";\n-    Rustdoc, \"src/doc/rustdoc\", \"rustdoc\";\n+    RustdocBook, \"src/doc/rustdoc\", \"rustdoc\";\n     RustcBook, \"src/doc/rustc\", \"rustc\";\n     RustByExample, \"src/doc/rust-by-example\", \"rust-by-example\";\n );\n@@ -272,6 +272,12 @@ impl Step for TheBook {\n             name: INTERNER.intern_string(format!(\"{}/second-edition\", name)),\n         });\n \n+        // build book 2018 edition\n+        builder.ensure(Rustbook {\n+            target,\n+            name: INTERNER.intern_string(format!(\"{}/2018-edition\", name)),\n+        });\n+\n         // build the version info page and CSS\n         builder.ensure(Standalone {\n             compiler,\n@@ -457,7 +463,7 @@ impl Step for Std {\n         };\n \n         builder.ensure(compile::Std { compiler, target });\n-        let out_dir = builder.stage_out(compiler, Mode::Libstd)\n+        let out_dir = builder.stage_out(compiler, Mode::Std)\n                            .join(target).join(\"doc\");\n \n         // Here what we're doing is creating a *symlink* (directory junction on\n@@ -477,7 +483,7 @@ impl Step for Std {\n         builder.clear_if_dirty(&my_out, &rustdoc);\n         t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n \n-        let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"doc\");\n+        let mut cargo = builder.cargo(compiler, Mode::Std, target, \"doc\");\n         compile::std_cargo(builder, &compiler, target, &mut cargo);\n \n         // Keep a whitelist so we do not build internal stdlib crates, these will be\n@@ -540,15 +546,15 @@ impl Step for Test {\n         builder.ensure(Std { stage, target });\n \n         builder.ensure(compile::Test { compiler, target });\n-        let out_dir = builder.stage_out(compiler, Mode::Libtest)\n+        let out_dir = builder.stage_out(compiler, Mode::Test)\n                            .join(target).join(\"doc\");\n \n         // See docs in std above for why we symlink\n         let my_out = builder.crate_doc_out(target);\n         builder.clear_if_dirty(&my_out, &rustdoc);\n         t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n \n-        let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"doc\");\n+        let mut cargo = builder.cargo(compiler, Mode::Test, target, \"doc\");\n         compile::test_cargo(builder, &compiler, target, &mut cargo);\n \n         cargo.arg(\"--no-deps\").arg(\"-p\").arg(\"test\");\n@@ -608,15 +614,15 @@ impl Step for WhitelistedRustc {\n         builder.ensure(Std { stage, target });\n \n         builder.ensure(compile::Rustc { compiler, target });\n-        let out_dir = builder.stage_out(compiler, Mode::Librustc)\n+        let out_dir = builder.stage_out(compiler, Mode::Rustc)\n                            .join(target).join(\"doc\");\n \n         // See docs in std above for why we symlink\n         let my_out = builder.crate_doc_out(target);\n         builder.clear_if_dirty(&my_out, &rustdoc);\n         t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n \n-        let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"doc\");\n+        let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"doc\");\n         compile::rustc_cargo(builder, &mut cargo);\n \n         // We don't want to build docs for internal compiler dependencies in this\n@@ -665,8 +671,12 @@ impl Step for Rustc {\n         let stage = self.stage;\n         let target = self.target;\n         builder.info(&format!(\"Documenting stage{} compiler ({})\", stage, target));\n+\n+        // This is the intended out directory for compiler documentation.\n         let out = builder.compiler_doc_out(target);\n         t!(fs::create_dir_all(&out));\n+\n+        // Get the correct compiler for this stage.\n         let compiler = builder.compiler(stage, builder.config.build);\n         let rustdoc = builder.rustdoc(compiler.host);\n         let compiler = if builder.force_use_stage1(compiler, target) {\n@@ -676,22 +686,24 @@ impl Step for Rustc {\n         };\n \n         if !builder.config.compiler_docs {\n-            builder.info(&format!(\"\\tskipping - compiler docs disabled\"));\n+            builder.info(&format!(\"\\tskipping - compiler/librustdoc docs disabled\"));\n             return;\n         }\n \n-        // Build libstd docs so that we generate relative links\n+        // Build libstd docs so that we generate relative links.\n         builder.ensure(Std { stage, target });\n \n+        // Build rustc.\n         builder.ensure(compile::Rustc { compiler, target });\n-        let out_dir = builder.stage_out(compiler, Mode::Librustc)\n-                           .join(target).join(\"doc\");\n+\n         // We do not symlink to the same shared folder that already contains std library\n         // documentation from previous steps as we do not want to include that.\n+        let out_dir = builder.stage_out(compiler, Mode::Rustc).join(target).join(\"doc\");\n         builder.clear_if_dirty(&out, &rustdoc);\n         t!(symlink_dir_force(&builder.config, &out, &out_dir));\n \n-        let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"doc\");\n+        // Build cargo command.\n+        let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"doc\");\n         cargo.env(\"RUSTDOCFLAGS\", \"--document-private-items\");\n         compile::rustc_cargo(builder, &mut cargo);\n \n@@ -729,6 +741,87 @@ fn find_compiler_crates(\n     }\n }\n \n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Rustdoc {\n+    stage: u32,\n+    target: Interned<String>,\n+}\n+\n+impl Step for Rustdoc {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.krate(\"rustdoc-tool\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Rustdoc {\n+            stage: run.builder.top_stage,\n+            target: run.target,\n+        });\n+    }\n+\n+    /// Generate compiler documentation.\n+    ///\n+    /// This will generate all documentation for compiler and dependencies.\n+    /// Compiler documentation is distributed separately, so we make sure\n+    /// we do not merge it with the other documentation from std, test and\n+    /// proc_macros. This is largely just a wrapper around `cargo doc`.\n+    fn run(self, builder: &Builder) {\n+        let stage = self.stage;\n+        let target = self.target;\n+        builder.info(&format!(\"Documenting stage{} rustdoc ({})\", stage, target));\n+\n+        // This is the intended out directory for compiler documentation.\n+        let out = builder.compiler_doc_out(target);\n+        t!(fs::create_dir_all(&out));\n+\n+        // Get the correct compiler for this stage.\n+        let compiler = builder.compiler(stage, builder.config.build);\n+        let rustdoc = builder.rustdoc(compiler.host);\n+        let compiler = if builder.force_use_stage1(compiler, target) {\n+            builder.compiler(1, compiler.host)\n+        } else {\n+            compiler\n+        };\n+\n+        if !builder.config.compiler_docs {\n+            builder.info(&format!(\"\\tskipping - compiler/librustdoc docs disabled\"));\n+            return;\n+        }\n+\n+        // Build libstd docs so that we generate relative links.\n+        builder.ensure(Std { stage, target });\n+\n+        // Build rustdoc.\n+        builder.ensure(tool::Rustdoc { host: compiler.host });\n+\n+        // Symlink compiler docs to the output directory of rustdoc documentation.\n+        let out_dir = builder.stage_out(compiler, Mode::ToolRustc)\n+            .join(target)\n+            .join(\"doc\");\n+        t!(fs::create_dir_all(&out_dir));\n+        builder.clear_if_dirty(&out, &rustdoc);\n+        t!(symlink_dir_force(&builder.config, &out, &out_dir));\n+\n+        // Build cargo command.\n+        let mut cargo = prepare_tool_cargo(\n+            builder,\n+            compiler,\n+            Mode::ToolRustc,\n+            target,\n+            \"doc\",\n+            \"src/tools/rustdoc\",\n+            SourceType::InTree,\n+        );\n+\n+        cargo.env(\"RUSTDOCFLAGS\", \"--document-private-items\");\n+        builder.run(&mut cargo);\n+    }\n+}\n+\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct ErrorIndex {\n     target: Interned<String>,"}, {"sha": "6a013053e580c78f8a26f1b6e105c7960073b65f", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 153, "deletions": 96, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -19,10 +19,10 @@ use std::process;\n \n use getopts::Options;\n \n-use {Build, DocTests};\n+use builder::Builder;\n use config::Config;\n use metadata;\n-use builder::Builder;\n+use {Build, DocTests};\n \n use cache::{Interned, INTERNER};\n \n@@ -31,7 +31,7 @@ pub struct Flags {\n     pub verbose: usize, // number of -v args; each extra -v after the first is passed to Cargo\n     pub on_fail: Option<String>,\n     pub stage: Option<u32>,\n-    pub keep_stage: Option<u32>,\n+    pub keep_stage: Vec<u32>,\n \n     pub host: Vec<Interned<String>>,\n     pub target: Vec<Interned<String>>,\n@@ -59,6 +59,9 @@ pub enum Subcommand {\n     },\n     Test {\n         paths: Vec<PathBuf>,\n+        /// Whether to automatically update stderr/stdout files\n+        bless: bool,\n+        compare_mode: Option<String>,\n         test_args: Vec<String>,\n         rustc_args: Vec<String>,\n         fail_fast: bool,\n@@ -90,7 +93,8 @@ impl Default for Subcommand {\n impl Flags {\n     pub fn parse(args: &[String]) -> Flags {\n         let mut extra_help = String::new();\n-        let mut subcommand_help = format!(\"\\\n+        let mut subcommand_help = format!(\n+            \"\\\n Usage: x.py <subcommand> [options] [<paths>...]\n \n Subcommands:\n@@ -103,7 +107,8 @@ Subcommands:\n     dist        Build distribution artifacts\n     install     Install distribution artifacts\n \n-To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n+To learn more about a subcommand, run `./x.py <subcommand> -h`\"\n+        );\n \n         let mut opts = Options::new();\n         // Options common to all subcommands\n@@ -117,37 +122,43 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n         opts.optopt(\"\", \"on-fail\", \"command to run on failure\", \"CMD\");\n         opts.optflag(\"\", \"dry-run\", \"dry run; don't build anything\");\n         opts.optopt(\"\", \"stage\", \"stage to build\", \"N\");\n-        opts.optopt(\"\", \"keep-stage\", \"stage to keep without recompiling\", \"N\");\n+        opts.optmulti(\"\", \"keep-stage\", \"stage(s) to keep without recompiling\", \"N\");\n         opts.optopt(\"\", \"src\", \"path to the root of the rust checkout\", \"DIR\");\n         opts.optopt(\"j\", \"jobs\", \"number of jobs to run in parallel\", \"JOBS\");\n         opts.optflag(\"h\", \"help\", \"print this help message\");\n-        opts.optopt(\"\", \"warnings\", \"if value is deny, will deny warnings, otherwise use default\",\n-            \"VALUE\");\n+        opts.optopt(\n+            \"\",\n+            \"warnings\",\n+            \"if value is deny, will deny warnings, otherwise use default\",\n+            \"VALUE\",\n+        );\n         opts.optopt(\"\", \"error-format\", \"rustc error format\", \"FORMAT\");\n \n         // fn usage()\n-        let usage = |exit_code: i32, opts: &Options, subcommand_help: &str, extra_help: &str| -> ! {\n-            println!(\"{}\", opts.usage(subcommand_help));\n-            if !extra_help.is_empty() {\n-                println!(\"{}\", extra_help);\n-            }\n-            process::exit(exit_code);\n-        };\n+        let usage =\n+            |exit_code: i32, opts: &Options, subcommand_help: &str, extra_help: &str| -> ! {\n+                println!(\"{}\", opts.usage(subcommand_help));\n+                if !extra_help.is_empty() {\n+                    println!(\"{}\", extra_help);\n+                }\n+                process::exit(exit_code);\n+            };\n \n         // We can't use getopt to parse the options until we have completed specifying which\n         // options are valid, but under the current implementation, some options are conditional on\n         // the subcommand. Therefore we must manually identify the subcommand first, so that we can\n         // complete the definition of the options.  Then we can use the getopt::Matches object from\n         // there on out.\n-        let subcommand = args.iter().find(|&s|\n+        let subcommand = args.iter().find(|&s| {\n             (s == \"build\")\n-            || (s == \"check\")\n-            || (s == \"test\")\n-            || (s == \"bench\")\n-            || (s == \"doc\")\n-            || (s == \"clean\")\n-            || (s == \"dist\")\n-            || (s == \"install\"));\n+                || (s == \"check\")\n+                || (s == \"test\")\n+                || (s == \"bench\")\n+                || (s == \"doc\")\n+                || (s == \"clean\")\n+                || (s == \"dist\")\n+                || (s == \"install\")\n+        });\n         let subcommand = match subcommand {\n             Some(s) => s,\n             None => {\n@@ -162,7 +173,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n \n         // Some subcommands get extra options\n         match subcommand.as_str() {\n-            \"test\"  => {\n+            \"test\" => {\n                 opts.optflag(\"\", \"no-fail-fast\", \"Run all tests regardless of failure\");\n                 opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n                 opts.optmulti(\n@@ -173,10 +184,25 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n                 );\n                 opts.optflag(\"\", \"no-doc\", \"do not run doc tests\");\n                 opts.optflag(\"\", \"doc\", \"only run doc tests\");\n-            },\n-            \"bench\" => { opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\"); },\n-            \"clean\" => { opts.optflag(\"\", \"all\", \"clean all build artifacts\"); },\n-            _ => { },\n+                opts.optflag(\n+                    \"\",\n+                    \"bless\",\n+                    \"update all stderr/stdout files of failing ui tests\",\n+                );\n+                opts.optopt(\n+                    \"\",\n+                    \"compare-mode\",\n+                    \"mode describing what file the actual ui output will be compared to\",\n+                    \"COMPARE MODE\",\n+                );\n+            }\n+            \"bench\" => {\n+                opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n+            }\n+            \"clean\" => {\n+                opts.optflag(\"\", \"all\", \"clean all build artifacts\");\n+            }\n+            _ => {}\n         };\n \n         // Done specifying what options are possible, so do the getopts parsing\n@@ -196,21 +222,24 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n                 if check_subcommand != subcommand {\n                     pass_sanity_check = false;\n                 }\n-            },\n+            }\n             None => {\n                 pass_sanity_check = false;\n             }\n         }\n         if !pass_sanity_check {\n             println!(\"{}\\n\", subcommand_help);\n-            println!(\"Sorry, I couldn't figure out which subcommand you were trying to specify.\\n\\\n-                      You may need to move some options to after the subcommand.\\n\");\n+            println!(\n+                \"Sorry, I couldn't figure out which subcommand you were trying to specify.\\n\\\n+                 You may need to move some options to after the subcommand.\\n\"\n+            );\n             process::exit(1);\n         }\n         // Extra help text for some commands\n         match subcommand.as_str() {\n             \"build\" => {\n-                subcommand_help.push_str(\"\\n\n+                subcommand_help.push_str(\n+                    \"\\n\n Arguments:\n     This subcommand accepts a number of paths to directories to the crates\n     and/or artifacts to compile. For example:\n@@ -232,10 +261,12 @@ Arguments:\n     This will first build everything once (like --stage 0 without further\n     arguments would), and then use the compiler built in stage 0 to build\n     src/libtest and its dependencies.\n-    Once this is done, build/$ARCH/stage1 contains a usable compiler.\");\n+    Once this is done, build/$ARCH/stage1 contains a usable compiler.\",\n+                );\n             }\n             \"check\" => {\n-                subcommand_help.push_str(\"\\n\n+                subcommand_help.push_str(\n+                    \"\\n\n Arguments:\n     This subcommand accepts a number of paths to directories to the crates\n     and/or artifacts to compile. For example:\n@@ -247,26 +278,32 @@ Arguments:\n     also that since we use `cargo check`, by default this will automatically enable incremental\n     compilation, so there's no need to pass it separately, though it won't hurt. We also completely\n     ignore the stage passed, as there's no way to compile in non-stage 0 without actually building\n-    the compiler.\");\n+    the compiler.\",\n+                );\n             }\n             \"test\" => {\n-                subcommand_help.push_str(\"\\n\n+                subcommand_help.push_str(\n+                    \"\\n\n Arguments:\n     This subcommand accepts a number of paths to directories to tests that\n     should be compiled and run. For example:\n \n         ./x.py test src/test/run-pass\n         ./x.py test src/libstd --test-args hash_map\n         ./x.py test src/libstd --stage 0\n+        ./x.py test src/test/ui --bless\n+        ./x.py test src/test/ui --compare-mode nll\n \n     If no arguments are passed then the complete artifacts for that stage are\n     compiled and tested.\n \n         ./x.py test\n-        ./x.py test --stage 1\");\n+        ./x.py test --stage 1\",\n+                );\n             }\n             \"doc\" => {\n-                subcommand_help.push_str(\"\\n\n+                subcommand_help.push_str(\n+                    \"\\n\n Arguments:\n     This subcommand accepts a number of paths to directories of documentation\n     to build. For example:\n@@ -278,12 +315,16 @@ Arguments:\n     If no arguments are passed then everything is documented:\n \n         ./x.py doc\n-        ./x.py doc --stage 1\");\n+        ./x.py doc --stage 1\",\n+                );\n             }\n-            _ => { }\n+            _ => {}\n         };\n         // Get any optional paths which occur after the subcommand\n-        let paths = matches.free[1..].iter().map(|p| p.into()).collect::<Vec<PathBuf>>();\n+        let paths = matches.free[1..]\n+            .iter()\n+            .map(|p| p.into())\n+            .collect::<Vec<PathBuf>>();\n \n         let cfg_file = matches.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n             if fs::metadata(\"config.toml\").is_ok() {\n@@ -302,9 +343,12 @@ Arguments:\n             let maybe_rules_help = Builder::get_help(&build, subcommand.as_str());\n             extra_help.push_str(maybe_rules_help.unwrap_or_default().as_str());\n         } else if subcommand.as_str() != \"clean\" {\n-            extra_help.push_str(format!(\n-                \"Run `./x.py {} -h -v` to see a list of available paths.\",\n-                subcommand).as_str());\n+            extra_help.push_str(\n+                format!(\n+                    \"Run `./x.py {} -h -v` to see a list of available paths.\",\n+                    subcommand\n+                ).as_str(),\n+            );\n         }\n \n         // User passed in -h/--help?\n@@ -313,36 +357,28 @@ Arguments:\n         }\n \n         let cmd = match subcommand.as_str() {\n-            \"build\" => {\n-                Subcommand::Build { paths: paths }\n-            }\n-            \"check\" => {\n-                Subcommand::Check { paths: paths }\n-            }\n-            \"test\" => {\n-                Subcommand::Test {\n-                    paths,\n-                    test_args: matches.opt_strs(\"test-args\"),\n-                    rustc_args: matches.opt_strs(\"rustc-args\"),\n-                    fail_fast: !matches.opt_present(\"no-fail-fast\"),\n-                    doc_tests: if matches.opt_present(\"doc\") {\n-                        DocTests::Only\n-                    } else if matches.opt_present(\"no-doc\") {\n-                        DocTests::No\n-                    } else {\n-                        DocTests::Yes\n-                    }\n-                }\n-            }\n-            \"bench\" => {\n-                Subcommand::Bench {\n-                    paths,\n-                    test_args: matches.opt_strs(\"test-args\"),\n-                }\n-            }\n-            \"doc\" => {\n-                Subcommand::Doc { paths: paths }\n-            }\n+            \"build\" => Subcommand::Build { paths: paths },\n+            \"check\" => Subcommand::Check { paths: paths },\n+            \"test\" => Subcommand::Test {\n+                paths,\n+                bless: matches.opt_present(\"bless\"),\n+                compare_mode: matches.opt_str(\"compare-mode\"),\n+                test_args: matches.opt_strs(\"test-args\"),\n+                rustc_args: matches.opt_strs(\"rustc-args\"),\n+                fail_fast: !matches.opt_present(\"no-fail-fast\"),\n+                doc_tests: if matches.opt_present(\"doc\") {\n+                    DocTests::Only\n+                } else if matches.opt_present(\"no-doc\") {\n+                    DocTests::No\n+                } else {\n+                    DocTests::Yes\n+                },\n+            },\n+            \"bench\" => Subcommand::Bench {\n+                paths,\n+                test_args: matches.opt_strs(\"test-args\"),\n+            },\n+            \"doc\" => Subcommand::Doc { paths: paths },\n             \"clean\" => {\n                 if paths.len() > 0 {\n                     println!(\"\\nclean does not take a path argument\\n\");\n@@ -353,39 +389,38 @@ Arguments:\n                     all: matches.opt_present(\"all\"),\n                 }\n             }\n-            \"dist\" => {\n-                Subcommand::Dist {\n-                    paths,\n-                }\n-            }\n-            \"install\" => {\n-                Subcommand::Install {\n-                    paths,\n-                }\n-            }\n+            \"dist\" => Subcommand::Dist { paths },\n+            \"install\" => Subcommand::Install { paths },\n             _ => {\n                 usage(1, &opts, &subcommand_help, &extra_help);\n             }\n         };\n \n-\n         Flags {\n             verbose: matches.opt_count(\"verbose\"),\n             stage: matches.opt_str(\"stage\").map(|j| j.parse().unwrap()),\n             dry_run: matches.opt_present(\"dry-run\"),\n             on_fail: matches.opt_str(\"on-fail\"),\n             rustc_error_format: matches.opt_str(\"error-format\"),\n-            keep_stage: matches.opt_str(\"keep-stage\").map(|j| j.parse().unwrap()),\n+            keep_stage: matches.opt_strs(\"keep-stage\")\n+                .into_iter().map(|j| j.parse().unwrap())\n+                .collect(),\n             host: split(matches.opt_strs(\"host\"))\n-                .into_iter().map(|x| INTERNER.intern_string(x)).collect::<Vec<_>>(),\n+                .into_iter()\n+                .map(|x| INTERNER.intern_string(x))\n+                .collect::<Vec<_>>(),\n             target: split(matches.opt_strs(\"target\"))\n-                .into_iter().map(|x| INTERNER.intern_string(x)).collect::<Vec<_>>(),\n+                .into_iter()\n+                .map(|x| INTERNER.intern_string(x))\n+                .collect::<Vec<_>>(),\n             config: cfg_file,\n             jobs: matches.opt_str(\"jobs\").map(|j| j.parse().unwrap()),\n             cmd,\n             incremental: matches.opt_present(\"incremental\"),\n             exclude: split(matches.opt_strs(\"exclude\"))\n-                .into_iter().map(|p| p.into()).collect::<Vec<_>>(),\n+                .into_iter()\n+                .map(|p| p.into())\n+                .collect::<Vec<_>>(),\n             warnings: matches.opt_str(\"warnings\").map(|v| v == \"deny\"),\n         }\n     }\n@@ -394,19 +429,22 @@ Arguments:\n impl Subcommand {\n     pub fn test_args(&self) -> Vec<&str> {\n         match *self {\n-            Subcommand::Test { ref test_args, .. } |\n-            Subcommand::Bench { ref test_args, .. } => {\n-                test_args.iter().flat_map(|s| s.split_whitespace()).collect()\n+            Subcommand::Test { ref test_args, .. } | Subcommand::Bench { ref test_args, .. } => {\n+                test_args\n+                    .iter()\n+                    .flat_map(|s| s.split_whitespace())\n+                    .collect()\n             }\n             _ => Vec::new(),\n         }\n     }\n \n     pub fn rustc_args(&self) -> Vec<&str> {\n         match *self {\n-            Subcommand::Test { ref rustc_args, .. } => {\n-                rustc_args.iter().flat_map(|s| s.split_whitespace()).collect()\n-            }\n+            Subcommand::Test { ref rustc_args, .. } => rustc_args\n+                .iter()\n+                .flat_map(|s| s.split_whitespace())\n+                .collect(),\n             _ => Vec::new(),\n         }\n     }\n@@ -424,8 +462,27 @@ impl Subcommand {\n             _ => DocTests::Yes,\n         }\n     }\n+\n+    pub fn bless(&self) -> bool {\n+        match *self {\n+            Subcommand::Test { bless, .. } => bless,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn compare_mode(&self) -> Option<&str> {\n+        match *self {\n+            Subcommand::Test {\n+                ref compare_mode, ..\n+            } => compare_mode.as_ref().map(|s| &s[..]),\n+            _ => None,\n+        }\n+    }\n }\n \n fn split(s: Vec<String>) -> Vec<String> {\n-    s.iter().flat_map(|s| s.split(',')).map(|s| s.to_string()).collect()\n+    s.iter()\n+        .flat_map(|s| s.split(','))\n+        .map(|s| s.to_string())\n+        .collect()\n }"}, {"sha": "cb28698aa3d6d22b2b7495550a40868c413a90fc", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -39,6 +39,9 @@ pub fn install_cargo(builder: &Builder, stage: u32, host: Interned<String>) {\n pub fn install_rls(builder: &Builder, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"rls\", \"rls\", stage, Some(host));\n }\n+pub fn install_clippy(builder: &Builder, stage: u32, host: Interned<String>) {\n+    install_sh(builder, \"clippy\", \"clippy\", stage, Some(host));\n+}\n \n pub fn install_rustfmt(builder: &Builder, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"rustfmt\", \"rustfmt\", stage, Some(host));\n@@ -72,7 +75,7 @@ fn install_sh(\n     let libdir_default = PathBuf::from(\"lib\");\n     let mandir_default = datadir_default.join(\"man\");\n     let prefix = builder.config.prefix.as_ref().map_or(prefix_default, |p| {\n-        fs::canonicalize(p).expect(&format!(\"could not canonicalize {}\", p.display()))\n+        fs::canonicalize(p).unwrap_or_else(|_| panic!(\"could not canonicalize {}\", p.display()))\n     });\n     let sysconfdir = builder.config.sysconfdir.as_ref().unwrap_or(&sysconfdir_default);\n     let datadir = builder.config.datadir.as_ref().unwrap_or(&datadir_default);\n@@ -216,6 +219,14 @@ install!((self, builder, _config),\n             builder.info(&format!(\"skipping Install RLS stage{} ({})\", self.stage, self.target));\n         }\n     };\n+    Clippy, \"clippy\", Self::should_build(_config), only_hosts: true, {\n+        if builder.ensure(dist::Clippy { stage: self.stage, target: self.target }).is_some() ||\n+            Self::should_install(builder) {\n+            install_clippy(builder, self.stage, self.target);\n+        } else {\n+            builder.info(&format!(\"skipping Install clippy stage{} ({})\", self.stage, self.target));\n+        }\n+    };\n     Rustfmt, \"rustfmt\", Self::should_build(_config), only_hosts: true, {\n         if builder.ensure(dist::Rustfmt { stage: self.stage, target: self.target }).is_some() ||\n             Self::should_install(builder) {"}, {"sha": "1efff19dfb993a69da84014b34587d77ab484499", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 85, "deletions": 21, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -113,8 +113,10 @@\n //! More documentation can be found in each respective module below, and you can\n //! also check out the `src/bootstrap/README.md` file for more information.\n \n+#![deny(bare_trait_objects)]\n #![deny(warnings)]\n #![feature(core_intrinsics)]\n+#![feature(drain_filter)]\n \n #[macro_use]\n extern crate build_helper;\n@@ -177,7 +179,7 @@ mod toolstate;\n #[cfg(windows)]\n mod job;\n \n-#[cfg(unix)]\n+#[cfg(all(unix, not(target_os = \"haiku\")))]\n mod job {\n     use libc;\n \n@@ -188,7 +190,7 @@ mod job {\n     }\n }\n \n-#[cfg(not(any(unix, windows)))]\n+#[cfg(any(target_os = \"haiku\", not(any(unix, windows))))]\n mod job {\n     pub unsafe fn setup(_build: &mut ::Build) {\n     }\n@@ -199,6 +201,15 @@ use flags::Subcommand;\n use cache::{Interned, INTERNER};\n use toolstate::ToolState;\n \n+const LLVM_TOOLS: &[&str] = &[\n+    \"llvm-nm\", // used to inspect binaries; it shows symbol names, their sizes and visibility\n+    \"llvm-objcopy\", // used to transform ELFs into binary format which flashing tools consume\n+    \"llvm-objdump\", // used to disassemble programs\n+    \"llvm-profdata\", // used to inspect and merge files generated by profiles\n+    \"llvm-size\", // used to prints the size of the linker sections of a program\n+    \"llvm-strip\", // used to discard symbols from binary files to reduce their size\n+];\n+\n /// A structure representing a Rust compiler.\n ///\n /// Each compiler has a `stage` that it is associated with and a `host` that\n@@ -240,6 +251,7 @@ pub struct Build {\n     rust_info: channel::GitInfo,\n     cargo_info: channel::GitInfo,\n     rls_info: channel::GitInfo,\n+    clippy_info: channel::GitInfo,\n     rustfmt_info: channel::GitInfo,\n     local_rebuild: bool,\n     fail_fast: bool,\n@@ -280,7 +292,8 @@ pub struct Build {\n struct Crate {\n     name: Interned<String>,\n     version: String,\n-    deps: Vec<Interned<String>>,\n+    deps: HashSet<Interned<String>>,\n+    id: String,\n     path: PathBuf,\n     doc_step: String,\n     build_step: String,\n@@ -307,16 +320,37 @@ impl Crate {\n #[derive(Debug, Hash, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub enum Mode {\n     /// Build the standard library, placing output in the \"stageN-std\" directory.\n-    Libstd,\n+    Std,\n \n     /// Build libtest, placing output in the \"stageN-test\" directory.\n-    Libtest,\n+    Test,\n+\n+    /// Build librustc, and compiler libraries, placing output in the \"stageN-rustc\" directory.\n+    Rustc,\n+\n+    /// Build codegen libraries, placing output in the \"stageN-codegen\" directory\n+    Codegen,\n+\n+    /// Build some tools, placing output in the \"stageN-tools\" directory. The\n+    /// \"other\" here is for miscellaneous sets of tools that are built using the\n+    /// bootstrap compiler in its entirety (target libraries and all).\n+    /// Typically these tools compile with stable Rust.\n+    ToolBootstrap,\n \n-    /// Build librustc and compiler libraries, placing output in the \"stageN-rustc\" directory.\n-    Librustc,\n+    /// Compile a tool which uses all libraries we compile (up to rustc).\n+    /// Doesn't use the stage0 compiler libraries like \"other\", and includes\n+    /// tools like rustdoc, cargo, rls, etc.\n+    ToolStd,\n+    ToolRustc,\n+}\n \n-    /// Build some tool, placing output in the \"stageN-tools\" directory.\n-    Tool,\n+impl Mode {\n+    pub fn is_tool(&self) -> bool {\n+        match self {\n+            Mode::ToolBootstrap | Mode::ToolRustc | Mode::ToolStd => true,\n+            _ => false\n+        }\n+    }\n }\n \n impl Build {\n@@ -340,6 +374,7 @@ impl Build {\n         let rust_info = channel::GitInfo::new(&config, &src);\n         let cargo_info = channel::GitInfo::new(&config, &src.join(\"src/tools/cargo\"));\n         let rls_info = channel::GitInfo::new(&config, &src.join(\"src/tools/rls\"));\n+        let clippy_info = channel::GitInfo::new(&config, &src.join(\"src/tools/clippy\"));\n         let rustfmt_info = channel::GitInfo::new(&config, &src.join(\"src/tools/rustfmt\"));\n \n         let mut build = Build {\n@@ -361,6 +396,7 @@ impl Build {\n             rust_info,\n             cargo_info,\n             rls_info,\n+            clippy_info,\n             rustfmt_info,\n             cc: HashMap::new(),\n             cxx: HashMap::new(),\n@@ -517,10 +553,13 @@ impl Build {\n     /// The mode indicates what the root directory is for.\n     fn stage_out(&self, compiler: Compiler, mode: Mode) -> PathBuf {\n         let suffix = match mode {\n-            Mode::Libstd => \"-std\",\n-            Mode::Libtest => \"-test\",\n-            Mode::Tool => \"-tools\",\n-            Mode::Librustc => \"-rustc\",\n+            Mode::Std => \"-std\",\n+            Mode::Test => \"-test\",\n+            Mode::Codegen => \"-rustc\",\n+            Mode::Rustc => \"-rustc\",\n+            Mode::ToolBootstrap => \"-bootstrap-tools\",\n+            Mode::ToolStd => \"-tools\",\n+            Mode::ToolRustc => \"-tools\",\n         };\n         self.out.join(&*compiler.host)\n                 .join(format!(\"stage{}{}\", compiler.stage, suffix))\n@@ -592,12 +631,20 @@ impl Build {\n             Path::new(llvm_bindir.trim()).join(exe(\"FileCheck\", &*target))\n         } else {\n             let base = self.llvm_out(self.config.build).join(\"build\");\n-            let exe = exe(\"FileCheck\", &*target);\n-            if !self.config.ninja && self.config.build.contains(\"msvc\") {\n-                base.join(\"Release/bin\").join(exe)\n+            let base = if !self.config.ninja && self.config.build.contains(\"msvc\") {\n+                if self.config.llvm_optimize {\n+                    if self.config.llvm_release_debuginfo {\n+                        base.join(\"RelWithDebInfo\")\n+                    } else {\n+                        base.join(\"Release\")\n+                    }\n+                } else {\n+                    base.join(\"Debug\")\n+                }\n             } else {\n-                base.join(\"bin\").join(exe)\n-            }\n+                base\n+            };\n+            base.join(\"bin\").join(exe(\"FileCheck\", &*target))\n         }\n     }\n \n@@ -621,8 +668,12 @@ impl Build {\n \n     /// Returns the libdir of the snapshot compiler.\n     fn rustc_snapshot_libdir(&self) -> PathBuf {\n+        self.rustc_snapshot_sysroot().join(libdir(&self.config.build))\n+    }\n+\n+    /// Returns the sysroot of the snapshot compiler.\n+    fn rustc_snapshot_sysroot(&self) -> &Path {\n         self.initial_rustc.parent().unwrap().parent().unwrap()\n-            .join(libdir(&self.config.build))\n     }\n \n     /// Runs a command, printing out nice contextual information if it fails.\n@@ -936,11 +987,24 @@ impl Build {\n         self.package_vers(&self.release_num(\"rls\"))\n     }\n \n+    /// Returns the value of `package_vers` above for clippy\n+    fn clippy_package_vers(&self) -> String {\n+        self.package_vers(&self.release_num(\"clippy\"))\n+    }\n+\n     /// Returns the value of `package_vers` above for rustfmt\n     fn rustfmt_package_vers(&self) -> String {\n         self.package_vers(&self.release_num(\"rustfmt\"))\n     }\n \n+    fn llvm_tools_package_vers(&self) -> String {\n+        self.package_vers(&self.rust_version())\n+    }\n+\n+    fn llvm_tools_vers(&self) -> String {\n+        self.rust_version()\n+    }\n+\n     /// Returns the `version` string associated with this compiler for Rust\n     /// itself.\n     ///\n@@ -1112,13 +1176,13 @@ impl Build {\n     /// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n     /// when this function is called. Unwanted files or directories can be skipped\n     /// by returning `false` from the filter function.\n-    pub fn cp_filtered(&self, src: &Path, dst: &Path, filter: &Fn(&Path) -> bool) {\n+    pub fn cp_filtered(&self, src: &Path, dst: &Path, filter: &dyn Fn(&Path) -> bool) {\n         // Immediately recurse with an empty relative path\n         self.recurse_(src, dst, Path::new(\"\"), filter)\n     }\n \n     // Inner function does the actual work\n-    fn recurse_(&self, src: &Path, dst: &Path, relative: &Path, filter: &Fn(&Path) -> bool) {\n+    fn recurse_(&self, src: &Path, dst: &Path, relative: &Path, filter: &dyn Fn(&Path) -> bool) {\n         for f in self.read_dir(src) {\n             let path = f.path();\n             let name = path.file_name().unwrap();"}, {"sha": "fa0b1983510b90075b44b6ff0175a5cf58ada47a", "filename": "src/bootstrap/metadata.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetadata.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -11,6 +11,7 @@\n use std::collections::HashMap;\n use std::process::Command;\n use std::path::PathBuf;\n+use std::collections::HashSet;\n \n use build_helper::output;\n use serde_json;\n@@ -45,12 +46,34 @@ struct ResolveNode {\n }\n \n pub fn build(build: &mut Build) {\n-    build_krate(build, \"src/libstd\");\n-    build_krate(build, \"src/libtest\");\n-    build_krate(build, \"src/rustc\");\n+    let mut resolves = Vec::new();\n+    build_krate(&build.std_features(), build, &mut resolves, \"src/libstd\");\n+    build_krate(\"\", build, &mut resolves, \"src/libtest\");\n+    build_krate(&build.rustc_features(), build, &mut resolves, \"src/rustc\");\n+\n+    let mut id2name = HashMap::with_capacity(build.crates.len());\n+    for (name, krate) in build.crates.iter() {\n+        id2name.insert(krate.id.clone(), name.clone());\n+    }\n+\n+    for node in resolves {\n+        let name = match id2name.get(&node.id) {\n+            Some(name) => name,\n+            None => continue,\n+        };\n+\n+        let krate = build.crates.get_mut(name).unwrap();\n+        for dep in node.dependencies.iter() {\n+            let dep = match id2name.get(dep) {\n+                Some(dep) => dep,\n+                None => continue,\n+            };\n+            krate.deps.insert(*dep);\n+        }\n+    }\n }\n \n-fn build_krate(build: &mut Build, krate: &str) {\n+fn build_krate(features: &str, build: &mut Build, resolves: &mut Vec<ResolveNode>, krate: &str) {\n     // Run `cargo metadata` to figure out what crates we're testing.\n     //\n     // Down below we're going to call `cargo test`, but to test the right set\n@@ -60,14 +83,13 @@ fn build_krate(build: &mut Build, krate: &str) {\n     let mut cargo = Command::new(&build.initial_cargo);\n     cargo.arg(\"metadata\")\n          .arg(\"--format-version\").arg(\"1\")\n+         .arg(\"--features\").arg(features)\n          .arg(\"--manifest-path\").arg(build.src.join(krate).join(\"Cargo.toml\"));\n     let output = output(&mut cargo);\n     let output: Output = serde_json::from_str(&output).unwrap();\n-    let mut id2name = HashMap::new();\n     for package in output.packages {\n         if package.source.is_none() {\n             let name = INTERNER.intern_string(package.name);\n-            id2name.insert(package.id, name);\n             let mut path = PathBuf::from(package.manifest_path);\n             path.pop();\n             build.crates.insert(name, Crate {\n@@ -77,25 +99,11 @@ fn build_krate(build: &mut Build, krate: &str) {\n                 bench_step: format!(\"bench-crate-{}\", name),\n                 name,\n                 version: package.version,\n-                deps: Vec::new(),\n+                id: package.id,\n+                deps: HashSet::new(),\n                 path,\n             });\n         }\n     }\n-\n-    for node in output.resolve.nodes {\n-        let name = match id2name.get(&node.id) {\n-            Some(name) => name,\n-            None => continue,\n-        };\n-\n-        let krate = build.crates.get_mut(name).unwrap();\n-        for dep in node.dependencies.iter() {\n-            let dep = match id2name.get(dep) {\n-                Some(dep) => dep,\n-                None => continue,\n-            };\n-            krate.deps.push(*dep);\n-        }\n-    }\n+    resolves.extend(output.resolve.nodes);\n }"}, {"sha": "264acfacee6b0f45eaa87a8969f5f93fb6d0c86c", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 81, "deletions": 14, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -167,8 +167,22 @@ impl Step for Llvm {\n         // which saves both memory during parallel links and overall disk space\n         // for the tools.  We don't distribute any of those tools, so this is\n         // just a local concern.  However, it doesn't work well everywhere.\n-        if target.contains(\"linux-gnu\") || target.contains(\"apple-darwin\") {\n-           cfg.define(\"LLVM_LINK_LLVM_DYLIB\", \"ON\");\n+        //\n+        // If we are shipping llvm tools then we statically link them LLVM\n+        if (target.contains(\"linux-gnu\") || target.contains(\"apple-darwin\")) &&\n+            !builder.config.llvm_tools_enabled {\n+                cfg.define(\"LLVM_LINK_LLVM_DYLIB\", \"ON\");\n+        }\n+\n+        // For distribution we want the LLVM tools to be *statically* linked to libstdc++\n+        if builder.config.llvm_tools_enabled {\n+            if !target.contains(\"windows\") {\n+                if target.contains(\"apple\") {\n+                    cfg.define(\"CMAKE_EXE_LINKER_FLAGS\", \"-static-libstdc++\");\n+                } else {\n+                    cfg.define(\"CMAKE_EXE_LINKER_FLAGS\", \"-Wl,-Bsymbolic -static-libstdc++\");\n+                }\n+            }\n         }\n \n         if target.contains(\"msvc\") {\n@@ -242,12 +256,12 @@ fn check_llvm_version(builder: &Builder, llvm_config: &Path) {\n     let version = output(cmd.arg(\"--version\"));\n     let mut parts = version.split('.').take(2)\n         .filter_map(|s| s.parse::<u32>().ok());\n-    if let (Some(major), Some(minor)) = (parts.next(), parts.next()) {\n-        if major > 3 || (major == 3 && minor >= 9) {\n+    if let (Some(major), Some(_minor)) = (parts.next(), parts.next()) {\n+        if major >= 5 {\n             return\n         }\n     }\n-    panic!(\"\\n\\nbad LLVM version: {}, need >=3.9\\n\\n\", version)\n+    panic!(\"\\n\\nbad LLVM version: {}, need >=5.0\\n\\n\", version)\n }\n \n fn configure_cmake(builder: &Builder,\n@@ -275,21 +289,53 @@ fn configure_cmake(builder: &Builder,\n         return\n     }\n \n-    let cc = builder.cc(target);\n-    let cxx = builder.cxx(target).unwrap();\n+    let (cc, cxx) = match builder.config.llvm_clang_cl {\n+        Some(ref cl) => (cl.as_ref(), cl.as_ref()),\n+        None => (builder.cc(target), builder.cxx(target).unwrap()),\n+    };\n \n     // Handle msvc + ninja + ccache specially (this is what the bots use)\n     if target.contains(\"msvc\") &&\n        builder.config.ninja &&\n-       builder.config.ccache.is_some() {\n-        let mut cc = env::current_exe().expect(\"failed to get cwd\");\n-        cc.set_file_name(\"sccache-plus-cl.exe\");\n+       builder.config.ccache.is_some()\n+    {\n+       let mut wrap_cc = env::current_exe().expect(\"failed to get cwd\");\n+       wrap_cc.set_file_name(\"sccache-plus-cl.exe\");\n \n-       cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(&cc))\n-          .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(&cc));\n+       cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(&wrap_cc))\n+          .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(&wrap_cc));\n        cfg.env(\"SCCACHE_PATH\",\n                builder.config.ccache.as_ref().unwrap())\n-          .env(\"SCCACHE_TARGET\", target);\n+          .env(\"SCCACHE_TARGET\", target)\n+          .env(\"SCCACHE_CC\", &cc)\n+          .env(\"SCCACHE_CXX\", &cxx);\n+\n+       // Building LLVM on MSVC can be a little ludicrous at times. We're so far\n+       // off the beaten path here that I'm not really sure this is even half\n+       // supported any more. Here we're trying to:\n+       //\n+       // * Build LLVM on MSVC\n+       // * Build LLVM with `clang-cl` instead of `cl.exe`\n+       // * Build a project with `sccache`\n+       // * Build for 32-bit as well\n+       // * Build with Ninja\n+       //\n+       // For `cl.exe` there are different binaries to compile 32/64 bit which\n+       // we use but for `clang-cl` there's only one which internally\n+       // multiplexes via flags. As a result it appears that CMake's detection\n+       // of a compiler's architecture and such on MSVC **doesn't** pass any\n+       // custom flags we pass in CMAKE_CXX_FLAGS below. This means that if we\n+       // use `clang-cl.exe` it's always diagnosed as a 64-bit compiler which\n+       // definitely causes problems since all the env vars are pointing to\n+       // 32-bit libraries.\n+       //\n+       // To hack aroudn this... again... we pass an argument that's\n+       // unconditionally passed in the sccache shim. This'll get CMake to\n+       // correctly diagnose it's doing a 32-bit compilation and LLVM will\n+       // internally configure itself appropriately.\n+       if builder.config.llvm_clang_cl.is_some() && target.contains(\"i686\") {\n+           cfg.env(\"SCCACHE_EXTRA_ARGS\", \"-m32\");\n+       }\n \n     // If ccache is configured we inform the build a little differently hwo\n     // to invoke ccache while also invoking our compilers.\n@@ -368,9 +414,27 @@ impl Step for Lld {\n         let mut cfg = cmake::Config::new(builder.src.join(\"src/tools/lld\"));\n         configure_cmake(builder, target, &mut cfg, true);\n \n+        // This is an awful, awful hack. Discovered when we migrated to using\n+        // clang-cl to compile LLVM/LLD it turns out that LLD, when built out of\n+        // tree, will execute `llvm-config --cmakedir` and then tell CMake about\n+        // that directory for later processing. Unfortunately if this path has\n+        // forward slashes in it (which it basically always does on Windows)\n+        // then CMake will hit a syntax error later on as... something isn't\n+        // escaped it seems?\n+        //\n+        // Instead of attempting to fix this problem in upstream CMake and/or\n+        // LLVM/LLD we just hack around it here. This thin wrapper will take the\n+        // output from llvm-config and replace all instances of `\\` with `/` to\n+        // ensure we don't hit the same bugs with escaping. It means that you\n+        // can't build on a system where your paths require `\\` on Windows, but\n+        // there's probably a lot of reasons you can't do that other than this.\n+        let llvm_config_shim = env::current_exe()\n+            .unwrap()\n+            .with_file_name(\"llvm-config-wrapper\");\n         cfg.out_dir(&out_dir)\n            .profile(\"Release\")\n-           .define(\"LLVM_CONFIG_PATH\", llvm_config)\n+           .env(\"LLVM_CONFIG_REAL\", llvm_config)\n+           .define(\"LLVM_CONFIG_PATH\", llvm_config_shim)\n            .define(\"LLVM_INCLUDE_TESTS\", \"OFF\");\n \n         cfg.build();\n@@ -546,8 +610,10 @@ impl Step for Openssl {\n             \"arm-linux-androideabi\" => \"android\",\n             \"arm-unknown-linux-gnueabi\" => \"linux-armv4\",\n             \"arm-unknown-linux-gnueabihf\" => \"linux-armv4\",\n+            \"armv6-unknown-netbsd-eabihf\" => \"BSD-generic32\",\n             \"armv7-linux-androideabi\" => \"android-armv7\",\n             \"armv7-unknown-linux-gnueabihf\" => \"linux-armv4\",\n+            \"armv7-unknown-netbsd-eabihf\" => \"BSD-generic32\",\n             \"i586-unknown-linux-gnu\" => \"linux-elf\",\n             \"i586-unknown-linux-musl\" => \"linux-elf\",\n             \"i686-apple-darwin\" => \"darwin-i386-cc\",\n@@ -565,6 +631,7 @@ impl Step for Openssl {\n             \"powerpc-unknown-netbsd\" => \"BSD-generic32\",\n             \"powerpc64-unknown-linux-gnu\" => \"linux-ppc64\",\n             \"powerpc64le-unknown-linux-gnu\" => \"linux-ppc64le\",\n+            \"powerpc64le-unknown-linux-musl\" => \"linux-ppc64le\",\n             \"s390x-unknown-linux-gnu\" => \"linux64-s390x\",\n             \"sparc-unknown-linux-gnu\" => \"linux-sparcv9\",\n             \"sparc64-unknown-linux-gnu\" => \"linux64-sparcv9\","}, {"sha": "24a1dbbde66396c756df043a78cc62974fe27ad0", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 335, "deletions": 203, "changes": 538, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -15,25 +15,26 @@\n \n use std::env;\n use std::ffi::OsString;\n-use std::iter;\n use std::fmt;\n use std::fs::{self, File};\n-use std::path::{PathBuf, Path};\n-use std::process::Command;\n use std::io::Read;\n+use std::iter;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n \n use build_helper::{self, output};\n \n-use builder::{Kind, RunConfig, ShouldRun, Builder, Compiler, Step};\n-use Crate as CargoCrate;\n-use cache::{INTERNER, Interned};\n+use builder::{Builder, Compiler, Kind, RunConfig, ShouldRun, Step};\n+use cache::{Interned, INTERNER};\n use compile;\n use dist;\n+use flags::Subcommand;\n use native;\n-use tool::{self, Tool};\n-use util::{self, dylib_path, dylib_path_var};\n-use {Mode, DocTests};\n+use tool::{self, Tool, SourceType};\n use toolstate::ToolState;\n+use util::{self, dylib_path, dylib_path_var};\n+use Crate as CargoCrate;\n+use {DocTests, Mode};\n \n const ADB_TEST_DIR: &str = \"/data/tmp/work\";\n \n@@ -46,6 +47,16 @@ pub enum TestKind {\n     Bench,\n }\n \n+impl From<Kind> for TestKind {\n+    fn from(kind: Kind) -> Self {\n+        match kind {\n+            Kind::Test => TestKind::Test,\n+            Kind::Bench => TestKind::Bench,\n+            _ => panic!(\"unexpected kind in crate: {:?}\", kind),\n+        }\n+    }\n+}\n+\n impl TestKind {\n     // Return the cargo subcommand for this test kind\n     fn subcommand(self) -> &'static str {\n@@ -113,13 +124,18 @@ impl Step for Linkcheck {\n         builder.default_doc(None);\n \n         let _time = util::timeit(&builder);\n-        try_run(builder, builder.tool_cmd(Tool::Linkchecker)\n-                              .arg(builder.out.join(host).join(\"doc\")));\n+        try_run(\n+            builder,\n+            builder\n+                .tool_cmd(Tool::Linkchecker)\n+                .arg(builder.out.join(host).join(\"doc\")),\n+        );\n     }\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.path(\"src/tools/linkchecker\").default_condition(builder.config.docs)\n+        run.path(\"src/tools/linkchecker\")\n+            .default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -154,7 +170,10 @@ impl Step for Cargotest {\n     /// test` to ensure that we don't regress the test suites there.\n     fn run(self, builder: &Builder) {\n         let compiler = builder.compiler(self.stage, self.host);\n-        builder.ensure(compile::Rustc { compiler, target: compiler.host });\n+        builder.ensure(compile::Rustc {\n+            compiler,\n+            target: compiler.host,\n+        });\n \n         // Note that this is a short, cryptic, and not scoped directory name. This\n         // is currently to minimize the length of path on Windows where we otherwise\n@@ -164,10 +183,13 @@ impl Step for Cargotest {\n \n         let _time = util::timeit(&builder);\n         let mut cmd = builder.tool_cmd(Tool::CargoTest);\n-        try_run(builder, cmd.arg(&builder.initial_cargo)\n-                          .arg(&out_dir)\n-                          .env(\"RUSTC\", builder.rustc(compiler))\n-                          .env(\"RUSTDOC\", builder.rustdoc(compiler.host)));\n+        try_run(\n+            builder,\n+            cmd.arg(&builder.initial_cargo)\n+                .arg(&out_dir)\n+                .env(\"RUSTC\", builder.rustc(compiler))\n+                .env(\"RUSTDOC\", builder.rustdoc(compiler.host)),\n+        );\n     }\n }\n \n@@ -196,21 +218,30 @@ impl Step for Cargo {\n     fn run(self, builder: &Builder) {\n         let compiler = builder.compiler(self.stage, self.host);\n \n-        builder.ensure(tool::Cargo { compiler, target: self.host });\n-        let mut cargo = builder.cargo(compiler, Mode::Tool, self.host, \"test\");\n-        cargo.arg(\"--manifest-path\").arg(builder.src.join(\"src/tools/cargo/Cargo.toml\"));\n+        builder.ensure(tool::Cargo {\n+            compiler,\n+            target: self.host,\n+        });\n+        let mut cargo = tool::prepare_tool_cargo(builder,\n+                                                 compiler,\n+                                                 Mode::ToolRustc,\n+                                                 self.host,\n+                                                 \"test\",\n+                                                 \"src/tools/cargo\",\n+                                                 SourceType::Submodule);\n+\n         if !builder.fail_fast {\n             cargo.arg(\"--no-fail-fast\");\n         }\n \n-        // Don't build tests dynamically, just a pain to work with\n-        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-\n         // Don't run cross-compile tests, we may not have cross-compiled libstd libs\n         // available.\n         cargo.env(\"CFG_DISABLE_CROSS_TESTS\", \"1\");\n \n-        try_run(builder, cargo.env(\"PATH\", &path_for_cargo(builder, compiler)));\n+        try_run(\n+            builder,\n+            cargo.env(\"PATH\", &path_for_cargo(builder, compiler)),\n+        );\n     }\n }\n \n@@ -253,12 +284,18 @@ impl Step for Rls {\n \n         let mut cargo = tool::prepare_tool_cargo(builder,\n                                                  compiler,\n+                                                 Mode::ToolRustc,\n                                                  host,\n                                                  \"test\",\n-                                                 \"src/tools/rls\");\n+                                                 \"src/tools/rls\",\n+                                                 SourceType::Submodule);\n \n-        // Don't build tests dynamically, just a pain to work with\n-        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+        // Copy `src/tools/rls/test_data` to a writable drive.\n+        let test_workspace_path = builder.out.join(\"rls-test-data\");\n+        let test_data_path = test_workspace_path.join(\"test_data\");\n+        builder.create_dir(&test_data_path);\n+        builder.cp_r(&builder.src.join(\"src/tools/rls/test_data\"), &test_data_path);\n+        cargo.env(\"RLS_TEST_WORKSPACE_DIR\", test_workspace_path);\n \n         builder.add_rustc_lib_path(compiler, &mut cargo);\n \n@@ -307,12 +344,15 @@ impl Step for Rustfmt {\n \n         let mut cargo = tool::prepare_tool_cargo(builder,\n                                                  compiler,\n+                                                 Mode::ToolRustc,\n                                                  host,\n                                                  \"test\",\n-                                                 \"src/tools/rustfmt\");\n+                                                 \"src/tools/rustfmt\",\n+                                                 SourceType::Submodule);\n \n-        // Don't build tests dynamically, just a pain to work with\n-        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+        let dir = testdir(builder, compiler.host);\n+        t!(fs::create_dir_all(&dir));\n+        cargo.env(\"RUSTFMT_TEST_DIR\", dir);\n \n         builder.add_rustc_lib_path(compiler, &mut cargo);\n \n@@ -357,11 +397,14 @@ impl Step for Miri {\n             extra_features: Vec::new(),\n         });\n         if let Some(miri) = miri {\n-            let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-            cargo.arg(\"--manifest-path\").arg(builder.src.join(\"src/tools/miri/Cargo.toml\"));\n+            let mut cargo = tool::prepare_tool_cargo(builder,\n+                                                 compiler,\n+                                                 Mode::ToolRustc,\n+                                                 host,\n+                                                 \"test\",\n+                                                 \"src/tools/miri\",\n+                                                 SourceType::Submodule);\n \n-            // Don't build tests dynamically, just a pain to work with\n-            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n             // miri tests need to know about the stage sysroot\n             cargo.env(\"MIRI_SYSROOT\", builder.sysroot(compiler));\n             cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n@@ -413,16 +456,21 @@ impl Step for Clippy {\n             extra_features: Vec::new(),\n         });\n         if let Some(clippy) = clippy {\n-            let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-            cargo.arg(\"--manifest-path\").arg(builder.src.join(\"src/tools/clippy/Cargo.toml\"));\n+            let mut cargo = tool::prepare_tool_cargo(builder,\n+                                                 compiler,\n+                                                 Mode::ToolRustc,\n+                                                 host,\n+                                                 \"test\",\n+                                                 \"src/tools/clippy\",\n+                                                 SourceType::Submodule);\n \n-            // Don't build tests dynamically, just a pain to work with\n-            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n             // clippy tests need to know about the stage sysroot\n             cargo.env(\"SYSROOT\", builder.sysroot(compiler));\n             cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n             cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n-            let host_libs = builder.stage_out(compiler, Mode::Tool).join(builder.cargo_dir());\n+            let host_libs = builder\n+                .stage_out(compiler, Mode::ToolRustc)\n+                .join(builder.cargo_dir());\n             cargo.env(\"HOST_LIBS\", host_libs);\n             // clippy tests need to find the driver\n             cargo.env(\"CLIPPY_DRIVER_PATH\", clippy);\n@@ -464,23 +512,30 @@ impl Step for RustdocTheme {\n     fn make_run(run: RunConfig) {\n         let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n \n-        run.builder.ensure(RustdocTheme {\n-            compiler: compiler,\n-        });\n+        run.builder.ensure(RustdocTheme { compiler: compiler });\n     }\n \n     fn run(self, builder: &Builder) {\n         let rustdoc = builder.out.join(\"bootstrap/debug/rustdoc\");\n         let mut cmd = builder.tool_cmd(Tool::RustdocTheme);\n         cmd.arg(rustdoc.to_str().unwrap())\n-           .arg(builder.src.join(\"src/librustdoc/html/static/themes\").to_str().unwrap())\n-           .env(\"RUSTC_STAGE\", self.compiler.stage.to_string())\n-           .env(\"RUSTC_SYSROOT\", builder.sysroot(self.compiler))\n-           .env(\"RUSTDOC_LIBDIR\", builder.sysroot_libdir(self.compiler, self.compiler.host))\n-           .env(\"CFG_RELEASE_CHANNEL\", &builder.config.channel)\n-           .env(\"RUSTDOC_REAL\", builder.rustdoc(self.compiler.host))\n-           .env(\"RUSTDOC_CRATE_VERSION\", builder.rust_version())\n-           .env(\"RUSTC_BOOTSTRAP\", \"1\");\n+            .arg(\n+                builder\n+                    .src\n+                    .join(\"src/librustdoc/html/static/themes\")\n+                    .to_str()\n+                    .unwrap(),\n+            )\n+            .env(\"RUSTC_STAGE\", self.compiler.stage.to_string())\n+            .env(\"RUSTC_SYSROOT\", builder.sysroot(self.compiler))\n+            .env(\n+                \"RUSTDOC_LIBDIR\",\n+                builder.sysroot_libdir(self.compiler, self.compiler.host),\n+            )\n+            .env(\"CFG_RELEASE_CHANNEL\", &builder.config.channel)\n+            .env(\"RUSTDOC_REAL\", builder.rustdoc(self.compiler.host))\n+            .env(\"RUSTDOC_CRATE_VERSION\", builder.rust_version())\n+            .env(\"RUSTC_BOOTSTRAP\", \"1\");\n         if let Some(linker) = builder.linker(self.compiler.host) {\n             cmd.env(\"RUSTC_TARGET_LINKER\", linker);\n         }\n@@ -520,7 +575,9 @@ impl Step for RustdocJS {\n             });\n             builder.run(&mut command);\n         } else {\n-            builder.info(&format!(\"No nodejs found, skipping \\\"src/test/rustdoc-js\\\" tests\"));\n+            builder.info(&format!(\n+                \"No nodejs found, skipping \\\"src/test/rustdoc-js\\\" tests\"\n+            ));\n         }\n     }\n }\n@@ -556,6 +613,7 @@ impl Step for RustdocUi {\n             target: self.target,\n             mode: \"ui\",\n             suite: \"rustdoc-ui\",\n+            path: None,\n             compare_mode: None,\n         })\n     }\n@@ -581,7 +639,7 @@ impl Step for Tidy {\n         if !builder.config.vendor {\n             cmd.arg(\"--no-vendor\");\n         }\n-        if builder.config.quiet_tests {\n+        if !builder.config.verbose_tests {\n             cmd.arg(\"--quiet\");\n         }\n \n@@ -660,7 +718,7 @@ macro_rules! test_definitions {\n             const ONLY_HOSTS: bool = $host;\n \n             fn should_run(run: ShouldRun) -> ShouldRun {\n-                run.path($path)\n+                run.suite_path($path)\n             }\n \n             fn make_run(run: RunConfig) {\n@@ -678,6 +736,7 @@ macro_rules! test_definitions {\n                     target: self.target,\n                     mode: $mode,\n                     suite: $suite,\n+                    path: Some($path),\n                     compare_mode: $compare_mode,\n                 })\n             }\n@@ -850,6 +909,7 @@ struct Compiletest {\n     target: Interned<String>,\n     mode: &'static str,\n     suite: &'static str,\n+    path: Option<&'static str>,\n     compare_mode: Option<&'static str>,\n }\n \n@@ -870,7 +930,9 @@ impl Step for Compiletest {\n         let target = self.target;\n         let mode = self.mode;\n         let suite = self.suite;\n-        let compare_mode = self.compare_mode;\n+\n+        // Path for test suite\n+        let suite_path = self.path.unwrap_or(\"\");\n \n         // Skip codegen tests if they aren't enabled in configuration.\n         if !builder.config.codegen_tests && suite == \"codegen\" {\n@@ -899,19 +961,21 @@ impl Step for Compiletest {\n \n             builder.ensure(dist::DebuggerScripts {\n                 sysroot: builder.sysroot(compiler),\n-                host: target\n+                host: target,\n             });\n         }\n \n         if suite.ends_with(\"fulldeps\") ||\n             // FIXME: Does pretty need librustc compiled? Note that there are\n             // fulldeps test suites with mode = pretty as well.\n-            mode == \"pretty\" ||\n-            mode == \"rustdoc\" {\n+            mode == \"pretty\"\n+        {\n             builder.ensure(compile::Rustc { compiler, target });\n         }\n \n-        builder.ensure(compile::Test { compiler, target });\n+        if builder.no_std(target) != Some(true) {\n+            builder.ensure(compile::Test { compiler, target });\n+        }\n         builder.ensure(native::TestHelpers { target });\n         builder.ensure(RemoteCopyLibs { compiler, target });\n \n@@ -920,26 +984,40 @@ impl Step for Compiletest {\n         // compiletest currently has... a lot of arguments, so let's just pass all\n         // of them!\n \n-        cmd.arg(\"--compile-lib-path\").arg(builder.rustc_libdir(compiler));\n-        cmd.arg(\"--run-lib-path\").arg(builder.sysroot_libdir(compiler, target));\n+        cmd.arg(\"--compile-lib-path\")\n+            .arg(builder.rustc_libdir(compiler));\n+        cmd.arg(\"--run-lib-path\")\n+            .arg(builder.sysroot_libdir(compiler, target));\n         cmd.arg(\"--rustc-path\").arg(builder.rustc(compiler));\n \n         let is_rustdoc_ui = suite.ends_with(\"rustdoc-ui\");\n \n         // Avoid depending on rustdoc when we don't need it.\n-        if mode == \"rustdoc\" ||\n-           (mode == \"run-make\" && suite.ends_with(\"fulldeps\")) ||\n-           (mode == \"ui\" && is_rustdoc_ui) {\n-            cmd.arg(\"--rustdoc-path\").arg(builder.rustdoc(compiler.host));\n+        if mode == \"rustdoc\"\n+            || (mode == \"run-make\" && suite.ends_with(\"fulldeps\"))\n+            || (mode == \"ui\" && is_rustdoc_ui)\n+        {\n+            cmd.arg(\"--rustdoc-path\")\n+                .arg(builder.rustdoc(compiler.host));\n         }\n \n-        cmd.arg(\"--src-base\").arg(builder.src.join(\"src/test\").join(suite));\n-        cmd.arg(\"--build-base\").arg(testdir(builder, compiler.host).join(suite));\n-        cmd.arg(\"--stage-id\").arg(format!(\"stage{}-{}\", compiler.stage, target));\n+        cmd.arg(\"--src-base\")\n+            .arg(builder.src.join(\"src/test\").join(suite));\n+        cmd.arg(\"--build-base\")\n+            .arg(testdir(builder, compiler.host).join(suite));\n+        cmd.arg(\"--stage-id\")\n+            .arg(format!(\"stage{}-{}\", compiler.stage, target));\n         cmd.arg(\"--mode\").arg(mode);\n         cmd.arg(\"--target\").arg(target);\n         cmd.arg(\"--host\").arg(&*compiler.host);\n-        cmd.arg(\"--llvm-filecheck\").arg(builder.llvm_filecheck(builder.config.build));\n+        cmd.arg(\"--llvm-filecheck\")\n+            .arg(builder.llvm_filecheck(builder.config.build));\n+\n+        if builder.config.cmd.bless() {\n+            cmd.arg(\"--bless\");\n+        }\n+\n+        let compare_mode = builder.config.cmd.compare_mode().or(self.compare_mode);\n \n         if let Some(ref nodejs) = builder.config.nodejs {\n             cmd.arg(\"--nodejs\").arg(nodejs);\n@@ -969,8 +1047,10 @@ impl Step for Compiletest {\n         cmd.arg(\"--host-rustcflags\").arg(hostflags.join(\" \"));\n \n         let mut targetflags = flags.clone();\n-        targetflags.push(format!(\"-Lnative={}\",\n-                                 builder.test_helpers_out(target).display()));\n+        targetflags.push(format!(\n+            \"-Lnative={}\",\n+            builder.test_helpers_out(target).display()\n+        ));\n         cmd.arg(\"--target-rustcflags\").arg(targetflags.join(\" \"));\n \n         cmd.arg(\"--docck-python\").arg(builder.python());\n@@ -994,13 +1074,34 @@ impl Step for Compiletest {\n             cmd.arg(\"--lldb-python-dir\").arg(dir);\n         }\n \n-        cmd.args(&builder.config.cmd.test_args());\n+        // Get paths from cmd args\n+        let paths = match &builder.config.cmd {\n+            Subcommand::Test { ref paths, .. } => &paths[..],\n+            _ => &[],\n+        };\n+\n+        // Get test-args by striping suite path\n+        let mut test_args: Vec<&str> = paths\n+            .iter()\n+            .map(|p| {\n+                match p.strip_prefix(\".\") {\n+                    Ok(path) => path,\n+                    Err(_) => p,\n+                }\n+            })\n+            .filter(|p| p.starts_with(suite_path) && p.is_file())\n+            .map(|p| p.strip_prefix(suite_path).unwrap().to_str().unwrap())\n+            .collect();\n+\n+        test_args.append(&mut builder.config.cmd.test_args());\n+\n+        cmd.args(&test_args);\n \n         if builder.is_verbose() {\n             cmd.arg(\"--verbose\");\n         }\n \n-        if builder.config.quiet_tests {\n+        if !builder.config.verbose_tests {\n             cmd.arg(\"--quiet\");\n         }\n \n@@ -1022,32 +1123,44 @@ impl Step for Compiletest {\n             if !builder.config.dry_run && suite == \"run-make-fulldeps\" {\n                 let llvm_components = output(Command::new(&llvm_config).arg(\"--components\"));\n                 let llvm_cxxflags = output(Command::new(&llvm_config).arg(\"--cxxflags\"));\n-                cmd.arg(\"--cc\").arg(builder.cc(target))\n-                .arg(\"--cxx\").arg(builder.cxx(target).unwrap())\n-                .arg(\"--cflags\").arg(builder.cflags(target).join(\" \"))\n-                .arg(\"--llvm-components\").arg(llvm_components.trim())\n-                .arg(\"--llvm-cxxflags\").arg(llvm_cxxflags.trim());\n+                cmd.arg(\"--cc\")\n+                    .arg(builder.cc(target))\n+                    .arg(\"--cxx\")\n+                    .arg(builder.cxx(target).unwrap())\n+                    .arg(\"--cflags\")\n+                    .arg(builder.cflags(target).join(\" \"))\n+                    .arg(\"--llvm-components\")\n+                    .arg(llvm_components.trim())\n+                    .arg(\"--llvm-cxxflags\")\n+                    .arg(llvm_cxxflags.trim());\n                 if let Some(ar) = builder.ar(target) {\n                     cmd.arg(\"--ar\").arg(ar);\n                 }\n             }\n         }\n         if suite == \"run-make-fulldeps\" && !builder.config.llvm_enabled {\n-            builder.info(\n-                &format!(\"Ignoring run-make test suite as they generally don't work without LLVM\"));\n+            builder.info(&format!(\n+                \"Ignoring run-make test suite as they generally don't work without LLVM\"\n+            ));\n             return;\n         }\n \n         if suite != \"run-make-fulldeps\" {\n-            cmd.arg(\"--cc\").arg(\"\")\n-               .arg(\"--cxx\").arg(\"\")\n-               .arg(\"--cflags\").arg(\"\")\n-               .arg(\"--llvm-components\").arg(\"\")\n-               .arg(\"--llvm-cxxflags\").arg(\"\");\n+            cmd.arg(\"--cc\")\n+                .arg(\"\")\n+                .arg(\"--cxx\")\n+                .arg(\"\")\n+                .arg(\"--cflags\")\n+                .arg(\"\")\n+                .arg(\"--llvm-components\")\n+                .arg(\"\")\n+                .arg(\"--llvm-cxxflags\")\n+                .arg(\"\");\n         }\n \n         if builder.remote_tested(target) {\n-            cmd.arg(\"--remote-test-client\").arg(builder.tool_exe(Tool::RemoteTestClient));\n+            cmd.arg(\"--remote-test-client\")\n+                .arg(builder.tool_exe(Tool::RemoteTestClient));\n         }\n \n         // Running a C compiler on MSVC requires a few env vars to be set, to be\n@@ -1080,24 +1193,28 @@ impl Step for Compiletest {\n         if target.contains(\"android\") {\n             // Assume that cc for this target comes from the android sysroot\n             cmd.arg(\"--android-cross-path\")\n-               .arg(builder.cc(target).parent().unwrap().parent().unwrap());\n+                .arg(builder.cc(target).parent().unwrap().parent().unwrap());\n         } else {\n             cmd.arg(\"--android-cross-path\").arg(\"\");\n         }\n \n         builder.ci_env.force_coloring_in_ci(&mut cmd);\n \n         let _folder = builder.fold_output(|| format!(\"test_{}\", suite));\n-        builder.info(&format!(\"Check compiletest suite={} mode={} ({} -> {})\",\n-                 suite, mode, &compiler.host, target));\n+        builder.info(&format!(\n+            \"Check compiletest suite={} mode={} ({} -> {})\",\n+            suite, mode, &compiler.host, target\n+        ));\n         let _time = util::timeit(&builder);\n         try_run(builder, &mut cmd);\n \n         if let Some(compare_mode) = compare_mode {\n             cmd.arg(\"--compare-mode\").arg(compare_mode);\n             let _folder = builder.fold_output(|| format!(\"test_{}_{}\", suite, compare_mode));\n-            builder.info(&format!(\"Check compiletest suite={} mode={} compare_mode={} ({} -> {})\",\n-                                  suite, mode, compare_mode, &compiler.host, target));\n+            builder.info(&format!(\n+                \"Check compiletest suite={} mode={} compare_mode={} ({} -> {})\",\n+                suite, mode, compare_mode, &compiler.host, target\n+            ));\n             let _time = util::timeit(&builder);\n             try_run(builder, &mut cmd);\n         }\n@@ -1128,7 +1245,10 @@ impl Step for DocTest {\n     fn run(self, builder: &Builder) {\n         let compiler = self.compiler;\n \n-        builder.ensure(compile::Test { compiler, target: compiler.host });\n+        builder.ensure(compile::Test {\n+            compiler,\n+            target: compiler.host,\n+        });\n \n         // Do a breadth-first traversal of the `src/doc` directory and just run\n         // tests for all files that end in `*.md`\n@@ -1140,7 +1260,7 @@ impl Step for DocTest {\n         while let Some(p) = stack.pop() {\n             if p.is_dir() {\n                 stack.extend(t!(p.read_dir()).map(|p| t!(p).path()));\n-                continue\n+                continue;\n             }\n \n             if p.extension().and_then(|s| s.to_str()) != Some(\"md\") {\n@@ -1158,17 +1278,15 @@ impl Step for DocTest {\n \n         files.sort();\n \n+        let mut toolstate = ToolState::TestPass;\n         for file in files {\n-            let test_result = markdown_test(builder, compiler, &file);\n-            if self.is_ext_doc {\n-                let toolstate = if test_result {\n-                    ToolState::TestPass\n-                } else {\n-                    ToolState::TestFail\n-                };\n-                builder.save_toolstate(self.name, toolstate);\n+            if !markdown_test(builder, compiler, &file) {\n+                toolstate = ToolState::TestFail;\n             }\n         }\n+        if self.is_ext_doc {\n+            builder.save_toolstate(self.name, toolstate);\n+        }\n     }\n }\n \n@@ -1247,7 +1365,10 @@ impl Step for ErrorIndex {\n     fn run(self, builder: &Builder) {\n         let compiler = self.compiler;\n \n-        builder.ensure(compile::Std { compiler, target: compiler.host });\n+        builder.ensure(compile::Std {\n+            compiler,\n+            target: compiler.host,\n+        });\n \n         let dir = testdir(builder, compiler.host);\n         t!(fs::create_dir_all(&dir));\n@@ -1259,7 +1380,6 @@ impl Step for ErrorIndex {\n             .env(\"CFG_BUILD\", &builder.config.build)\n             .env(\"RUSTC_ERROR_METADATA_DST\", builder.extended_error_dir());\n \n-\n         let _folder = builder.fold_output(|| \"test_error_index\");\n         builder.info(&format!(\"Testing error-index stage{}\", compiler.stage));\n         let _time = util::timeit(&builder);\n@@ -1277,7 +1397,7 @@ fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) -> bool\n                 return true;\n             }\n         }\n-        Err(_) => {},\n+        Err(_) => {}\n     }\n \n     builder.info(&format!(\"doc tests for: {}\", markdown.display()));\n@@ -1290,10 +1410,10 @@ fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) -> bool\n     let test_args = builder.config.cmd.test_args().join(\" \");\n     cmd.arg(\"--test-args\").arg(test_args);\n \n-    if builder.config.quiet_tests {\n-        try_run_quiet(builder, &mut cmd)\n-    } else {\n+    if builder.config.verbose_tests {\n         try_run(builder, &mut cmd)\n+    } else {\n+        try_run_quiet(builder, &mut cmd)\n     }\n }\n \n@@ -1320,13 +1440,7 @@ impl Step for CrateLibrustc {\n \n         for krate in builder.in_tree_crates(\"rustc-main\") {\n             if run.path.ends_with(&krate.path) {\n-                let test_kind = if builder.kind == Kind::Test {\n-                    TestKind::Test\n-                } else if builder.kind == Kind::Bench {\n-                    TestKind::Bench\n-                } else {\n-                    panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n-                };\n+                let test_kind = builder.kind.into();\n \n                 builder.ensure(CrateLibrustc {\n                     compiler,\n@@ -1342,7 +1456,7 @@ impl Step for CrateLibrustc {\n         builder.ensure(Crate {\n             compiler: self.compiler,\n             target: self.target,\n-            mode: Mode::Librustc,\n+            mode: Mode::Rustc,\n             test_kind: self.test_kind,\n             krate: self.krate,\n         });\n@@ -1372,13 +1486,7 @@ impl Step for CrateNotDefault {\n         let builder = run.builder;\n         let compiler = builder.compiler(builder.top_stage, run.host);\n \n-        let test_kind = if builder.kind == Kind::Test {\n-            TestKind::Test\n-        } else if builder.kind == Kind::Bench {\n-            TestKind::Bench\n-        } else {\n-            panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n-        };\n+        let test_kind = builder.kind.into();\n \n         builder.ensure(CrateNotDefault {\n             compiler,\n@@ -1399,14 +1507,13 @@ impl Step for CrateNotDefault {\n         builder.ensure(Crate {\n             compiler: self.compiler,\n             target: self.target,\n-            mode: Mode::Libstd,\n+            mode: Mode::Std,\n             test_kind: self.test_kind,\n             krate: INTERNER.intern_str(self.krate),\n         });\n     }\n }\n \n-\n #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct Crate {\n     pub compiler: Compiler,\n@@ -1424,10 +1531,11 @@ impl Step for Crate {\n         let builder = run.builder;\n         run = run.krate(\"test\");\n         for krate in run.builder.in_tree_crates(\"std\") {\n-            if krate.is_local(&run.builder) &&\n-                !krate.name.contains(\"jemalloc\") &&\n-                !(krate.name.starts_with(\"rustc_\") && krate.name.ends_with(\"san\")) &&\n-                krate.name != \"dlmalloc\" {\n+            if krate.is_local(&run.builder)\n+                && !krate.name.contains(\"jemalloc\")\n+                && !(krate.name.starts_with(\"rustc_\") && krate.name.ends_with(\"san\"))\n+                && krate.name != \"dlmalloc\"\n+            {\n                 run = run.path(krate.local_path(&builder).to_str().unwrap());\n             }\n         }\n@@ -1439,13 +1547,7 @@ impl Step for Crate {\n         let compiler = builder.compiler(builder.top_stage, run.host);\n \n         let make = |mode: Mode, krate: &CargoCrate| {\n-            let test_kind = if builder.kind == Kind::Test {\n-                TestKind::Test\n-            } else if builder.kind == Kind::Bench {\n-                TestKind::Bench\n-            } else {\n-                panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n-            };\n+            let test_kind = builder.kind.into();\n \n             builder.ensure(Crate {\n                 compiler,\n@@ -1458,12 +1560,12 @@ impl Step for Crate {\n \n         for krate in builder.in_tree_crates(\"std\") {\n             if run.path.ends_with(&krate.local_path(&builder)) {\n-                make(Mode::Libstd, krate);\n+                make(Mode::Std, krate);\n             }\n         }\n         for krate in builder.in_tree_crates(\"test\") {\n             if run.path.ends_with(&krate.local_path(&builder)) {\n-                make(Mode::Libtest, krate);\n+                make(Mode::Test, krate);\n             }\n         }\n     }\n@@ -1498,13 +1600,13 @@ impl Step for Crate {\n \n         let mut cargo = builder.cargo(compiler, mode, target, test_kind.subcommand());\n         match mode {\n-            Mode::Libstd => {\n+            Mode::Std => {\n                 compile::std_cargo(builder, &compiler, target, &mut cargo);\n             }\n-            Mode::Libtest => {\n+            Mode::Test => {\n                 compile::test_cargo(builder, &compiler, target, &mut cargo);\n             }\n-            Mode::Librustc => {\n+            Mode::Rustc => {\n                 builder.ensure(compile::Rustc { compiler, target });\n                 compile::rustc_cargo(builder, &mut cargo);\n             }\n@@ -1543,43 +1645,64 @@ impl Step for Crate {\n         cargo.arg(\"--\");\n         cargo.args(&builder.config.cmd.test_args());\n \n-        if builder.config.quiet_tests {\n+        if !builder.config.verbose_tests {\n             cargo.arg(\"--quiet\");\n         }\n \n         if target.contains(\"emscripten\") {\n-            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n-                      builder.config.nodejs.as_ref().expect(\"nodejs not configured\"));\n+            cargo.env(\n+                format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n+                builder\n+                    .config\n+                    .nodejs\n+                    .as_ref()\n+                    .expect(\"nodejs not configured\"),\n+            );\n         } else if target.starts_with(\"wasm32\") {\n             // Warn about running tests without the `wasm_syscall` feature enabled.\n             // The javascript shim implements the syscall interface so that test\n             // output can be correctly reported.\n             if !builder.config.wasm_syscall {\n-                builder.info(&format!(\"Libstd was built without `wasm_syscall` feature enabled: \\\n-                          test output may not be visible.\"));\n+                builder.info(&format!(\n+                    \"Libstd was built without `wasm_syscall` feature enabled: \\\n+                     test output may not be visible.\"\n+                ));\n             }\n \n             // On the wasm32-unknown-unknown target we're using LTO which is\n             // incompatible with `-C prefer-dynamic`, so disable that here\n             cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n \n-            let node = builder.config.nodejs.as_ref()\n+            let node = builder\n+                .config\n+                .nodejs\n+                .as_ref()\n                 .expect(\"nodejs not configured\");\n-            let runner = format!(\"{} {}/src/etc/wasm32-shim.js\",\n-                                 node.display(),\n-                                 builder.src.display());\n+            let runner = format!(\n+                \"{} {}/src/etc/wasm32-shim.js\",\n+                node.display(),\n+                builder.src.display()\n+            );\n             cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)), &runner);\n         } else if builder.remote_tested(target) {\n-            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n-                      format!(\"{} run\",\n-                              builder.tool_exe(Tool::RemoteTestClient).display()));\n+            cargo.env(\n+                format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n+                format!(\"{} run\", builder.tool_exe(Tool::RemoteTestClient).display()),\n+            );\n         }\n \n         let _folder = builder.fold_output(|| {\n-            format!(\"{}_stage{}-{}\", test_kind.subcommand(), compiler.stage, krate)\n+            format!(\n+                \"{}_stage{}-{}\",\n+                test_kind.subcommand(),\n+                compiler.stage,\n+                krate\n+            )\n         });\n-        builder.info(&format!(\"{} {} stage{} ({} -> {})\", test_kind, krate, compiler.stage,\n-                &compiler.host, target));\n+        builder.info(&format!(\n+            \"{} {} stage{} ({} -> {})\",\n+            test_kind, krate, compiler.stage, &compiler.host, target\n+        ));\n         let _time = util::timeit(&builder);\n         try_run(builder, &mut cargo);\n     }\n@@ -1603,13 +1726,7 @@ impl Step for CrateRustdoc {\n     fn make_run(run: RunConfig) {\n         let builder = run.builder;\n \n-        let test_kind = if builder.kind == Kind::Test {\n-            TestKind::Test\n-        } else if builder.kind == Kind::Bench {\n-            TestKind::Bench\n-        } else {\n-            panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n-        };\n+        let test_kind = builder.kind.into();\n \n         builder.ensure(CrateRustdoc {\n             host: run.host,\n@@ -1622,12 +1739,15 @@ impl Step for CrateRustdoc {\n \n         let compiler = builder.compiler(builder.top_stage, self.host);\n         let target = compiler.host;\n+        builder.ensure(compile::Rustc { compiler, target });\n \n         let mut cargo = tool::prepare_tool_cargo(builder,\n                                                  compiler,\n+                                                 Mode::ToolRustc,\n                                                  target,\n                                                  test_kind.subcommand(),\n-                                                 \"src/tools/rustdoc\");\n+                                                 \"src/tools/rustdoc\",\n+                                                 SourceType::InTree);\n         if test_kind.subcommand() == \"test\" && !builder.fail_fast {\n             cargo.arg(\"--no-fail-fast\");\n         }\n@@ -1637,28 +1757,30 @@ impl Step for CrateRustdoc {\n         cargo.arg(\"--\");\n         cargo.args(&builder.config.cmd.test_args());\n \n-        if builder.config.quiet_tests {\n+        if !builder.config.verbose_tests {\n             cargo.arg(\"--quiet\");\n         }\n \n-        let _folder = builder.fold_output(|| {\n-            format!(\"{}_stage{}-rustdoc\", test_kind.subcommand(), compiler.stage)\n-        });\n-        builder.info(&format!(\"{} rustdoc stage{} ({} -> {})\", test_kind, compiler.stage,\n-                &compiler.host, target));\n+        let _folder = builder\n+            .fold_output(|| format!(\"{}_stage{}-rustdoc\", test_kind.subcommand(), compiler.stage));\n+        builder.info(&format!(\n+            \"{} rustdoc stage{} ({} -> {})\",\n+            test_kind, compiler.stage, &compiler.host, target\n+        ));\n         let _time = util::timeit(&builder);\n \n         try_run(builder, &mut cargo);\n     }\n }\n \n fn envify(s: &str) -> String {\n-    s.chars().map(|c| {\n-        match c {\n+    s.chars()\n+        .map(|c| match c {\n             '-' => '_',\n             c => c,\n-        }\n-    }).flat_map(|c| c.to_uppercase()).collect()\n+        })\n+        .flat_map(|c| c.to_uppercase())\n+        .collect()\n }\n \n /// Some test suites are run inside emulators or on remote devices, and most\n@@ -1687,23 +1809,26 @@ impl Step for RemoteCopyLibs {\n         let compiler = self.compiler;\n         let target = self.target;\n         if !builder.remote_tested(target) {\n-            return\n+            return;\n         }\n \n         builder.ensure(compile::Test { compiler, target });\n \n         builder.info(&format!(\"REMOTE copy libs to emulator ({})\", target));\n         t!(fs::create_dir_all(builder.out.join(\"tmp\")));\n \n-        let server = builder.ensure(tool::RemoteTestServer { compiler, target });\n+        let server = builder.ensure(tool::RemoteTestServer {\n+            compiler: compiler.with_stage(0),\n+            target,\n+        });\n \n         // Spawn the emulator and wait for it to come online\n         let tool = builder.tool_exe(Tool::RemoteTestClient);\n         let mut cmd = Command::new(&tool);\n         cmd.arg(\"spawn-emulator\")\n-           .arg(target)\n-           .arg(&server)\n-           .arg(builder.out.join(\"tmp\"));\n+            .arg(target)\n+            .arg(&server)\n+            .arg(builder.out.join(\"tmp\"));\n         if let Some(rootfs) = builder.qemu_rootfs(target) {\n             cmd.arg(rootfs);\n         }\n@@ -1714,9 +1839,7 @@ impl Step for RemoteCopyLibs {\n             let f = t!(f);\n             let name = f.file_name().into_string().unwrap();\n             if util::is_dylib(&name) {\n-                builder.run(Command::new(&tool)\n-                                  .arg(\"push\")\n-                                  .arg(f.path()));\n+                builder.run(Command::new(&tool).arg(\"push\").arg(f.path()));\n             }\n         }\n     }\n@@ -1749,17 +1872,21 @@ impl Step for Distcheck {\n \n         let mut cmd = Command::new(\"tar\");\n         cmd.arg(\"-xzf\")\n-           .arg(builder.ensure(dist::PlainSourceTarball))\n-           .arg(\"--strip-components=1\")\n-           .current_dir(&dir);\n+            .arg(builder.ensure(dist::PlainSourceTarball))\n+            .arg(\"--strip-components=1\")\n+            .current_dir(&dir);\n         builder.run(&mut cmd);\n-        builder.run(Command::new(\"./configure\")\n-                         .args(&builder.config.configure_args)\n-                         .arg(\"--enable-vendor\")\n-                         .current_dir(&dir));\n-        builder.run(Command::new(build_helper::make(&builder.config.build))\n-                         .arg(\"check\")\n-                         .current_dir(&dir));\n+        builder.run(\n+            Command::new(\"./configure\")\n+                .args(&builder.config.configure_args)\n+                .arg(\"--enable-vendor\")\n+                .current_dir(&dir),\n+        );\n+        builder.run(\n+            Command::new(build_helper::make(&builder.config.build))\n+                .arg(\"check\")\n+                .current_dir(&dir),\n+        );\n \n         // Now make sure that rust-src has all of libstd's dependencies\n         builder.info(&format!(\"Distcheck rust-src\"));\n@@ -1769,17 +1896,19 @@ impl Step for Distcheck {\n \n         let mut cmd = Command::new(\"tar\");\n         cmd.arg(\"-xzf\")\n-           .arg(builder.ensure(dist::Src))\n-           .arg(\"--strip-components=1\")\n-           .current_dir(&dir);\n+            .arg(builder.ensure(dist::Src))\n+            .arg(\"--strip-components=1\")\n+            .current_dir(&dir);\n         builder.run(&mut cmd);\n \n         let toml = dir.join(\"rust-src/lib/rustlib/src/rust/src/libstd/Cargo.toml\");\n-        builder.run(Command::new(&builder.initial_cargo)\n-                         .arg(\"generate-lockfile\")\n-                         .arg(\"--manifest-path\")\n-                         .arg(&toml)\n-                         .current_dir(&dir));\n+        builder.run(\n+            Command::new(&builder.initial_cargo)\n+                .arg(\"generate-lockfile\")\n+                .arg(\"--manifest-path\")\n+                .arg(&toml)\n+                .current_dir(&dir),\n+        );\n     }\n }\n \n@@ -1795,11 +1924,11 @@ impl Step for Bootstrap {\n     fn run(self, builder: &Builder) {\n         let mut cmd = Command::new(&builder.initial_cargo);\n         cmd.arg(\"test\")\n-           .current_dir(builder.src.join(\"src/bootstrap\"))\n-           .env(\"RUSTFLAGS\", \"-Cdebuginfo=2\")\n-           .env(\"CARGO_TARGET_DIR\", builder.out.join(\"bootstrap\"))\n-           .env(\"RUSTC_BOOTSTRAP\", \"1\")\n-           .env(\"RUSTC\", &builder.initial_rustc);\n+            .current_dir(builder.src.join(\"src/bootstrap\"))\n+            .env(\"RUSTFLAGS\", \"-Cdebuginfo=2\")\n+            .env(\"CARGO_TARGET_DIR\", builder.out.join(\"bootstrap\"))\n+            .env(\"RUSTC_BOOTSTRAP\", \"1\")\n+            .env(\"RUSTC\", &builder.initial_rustc);\n         if let Some(flags) = option_env!(\"RUSTFLAGS\") {\n             // Use the same rustc flags for testing as for \"normal\" compilation,\n             // so that Cargo doesn\u2019t recompile the entire dependency graph every time:\n@@ -1810,6 +1939,9 @@ impl Step for Bootstrap {\n             cmd.arg(\"--no-fail-fast\");\n         }\n         cmd.arg(\"--\").args(&builder.config.cmd.test_args());\n+        // rustbuild tests are racy on directory creation so just run them one at a time.\n+        // Since there's not many this shouldn't be a problem.\n+        cmd.arg(\"--test-threads=1\");\n         try_run(builder, &mut cmd);\n     }\n "}, {"sha": "5e68b797b3d54fe4a80b7e8a5724e410e29e6a12", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 180, "deletions": 60, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -10,8 +10,10 @@\n \n use std::fs;\n use std::env;\n+use std::iter;\n use std::path::PathBuf;\n use std::process::{Command, exit};\n+use std::collections::HashSet;\n \n use Mode;\n use Compiler;\n@@ -27,7 +29,7 @@ use toolstate::ToolState;\n pub struct CleanTools {\n     pub compiler: Compiler,\n     pub target: Interned<String>,\n-    pub mode: Mode,\n+    pub cause: Mode,\n }\n \n impl Step for CleanTools {\n@@ -40,23 +42,23 @@ impl Step for CleanTools {\n     fn run(self, builder: &Builder) {\n         let compiler = self.compiler;\n         let target = self.target;\n-        let mode = self.mode;\n+        let cause = self.cause;\n \n         // This is for the original compiler, but if we're forced to use stage 1, then\n         // std/test/rustc stamps won't exist in stage 2, so we need to get those from stage 1, since\n         // we copy the libs forward.\n-        let tools_dir = builder.stage_out(compiler, Mode::Tool);\n+        let tools_dir = builder.stage_out(compiler, Mode::ToolRustc);\n         let compiler = if builder.force_use_stage1(compiler, target) {\n             builder.compiler(1, compiler.host)\n         } else {\n             compiler\n         };\n \n-        for &cur_mode in &[Mode::Libstd, Mode::Libtest, Mode::Librustc] {\n+        for &cur_mode in &[Mode::Std, Mode::Test, Mode::Rustc] {\n             let stamp = match cur_mode {\n-                Mode::Libstd => libstd_stamp(builder, compiler, target),\n-                Mode::Libtest => libtest_stamp(builder, compiler, target),\n-                Mode::Librustc => librustc_stamp(builder, compiler, target),\n+                Mode::Std => libstd_stamp(builder, compiler, target),\n+                Mode::Test => libtest_stamp(builder, compiler, target),\n+                Mode::Rustc => librustc_stamp(builder, compiler, target),\n                 _ => panic!(),\n             };\n \n@@ -66,21 +68,28 @@ impl Step for CleanTools {\n \n             // If we are a rustc tool, and std changed, we also need to clear ourselves out -- our\n             // dependencies depend on std. Therefore, we iterate up until our own mode.\n-            if mode == cur_mode {\n+            if cause == cur_mode {\n                 break;\n             }\n         }\n     }\n }\n \n+#[derive(Debug, Clone, Hash, PartialEq, Eq)]\n+pub enum SourceType {\n+    InTree,\n+    Submodule,\n+}\n+\n #[derive(Debug, Clone, Hash, PartialEq, Eq)]\n struct ToolBuild {\n     compiler: Compiler,\n     target: Interned<String>,\n     tool: &'static str,\n     path: &'static str,\n     mode: Mode,\n-    is_ext_tool: bool,\n+    is_optional_tool: bool,\n+    source_type: SourceType,\n     extra_features: Vec<String>,\n }\n \n@@ -100,25 +109,42 @@ impl Step for ToolBuild {\n         let target = self.target;\n         let tool = self.tool;\n         let path = self.path;\n-        let is_ext_tool = self.is_ext_tool;\n+        let is_optional_tool = self.is_optional_tool;\n \n         match self.mode {\n-            Mode::Libstd => builder.ensure(compile::Std { compiler, target }),\n-            Mode::Libtest => builder.ensure(compile::Test { compiler, target }),\n-            Mode::Librustc => builder.ensure(compile::Rustc { compiler, target }),\n-            Mode::Tool => panic!(\"unexpected Mode::Tool for tool build\")\n+            Mode::ToolRustc => {\n+                builder.ensure(compile::Rustc { compiler, target })\n+            }\n+            Mode::ToolStd => {\n+                builder.ensure(compile::Std { compiler, target })\n+            }\n+            Mode::ToolBootstrap => {} // uses downloaded stage0 compiler libs\n+            _ => panic!(\"unexpected Mode for tool build\")\n         }\n \n-        let mut cargo = prepare_tool_cargo(builder, compiler, target, \"build\", path);\n+        let mut cargo = prepare_tool_cargo(\n+            builder,\n+            compiler,\n+            self.mode,\n+            target,\n+            \"build\",\n+            path,\n+            self.source_type,\n+        );\n         cargo.arg(\"--features\").arg(self.extra_features.join(\" \"));\n \n         let _folder = builder.fold_output(|| format!(\"stage{}-{}\", compiler.stage, tool));\n         builder.info(&format!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target));\n         let mut duplicates = Vec::new();\n         let is_expected = compile::stream_cargo(builder, &mut cargo, &mut |msg| {\n             // Only care about big things like the RLS/Cargo for now\n-            if tool != \"rls\" && tool != \"cargo\" {\n-                return\n+            match tool {\n+                | \"rls\"\n+                | \"cargo\"\n+                | \"clippy-driver\"\n+                => {}\n+\n+                _ => return,\n             }\n             let (id, features, filenames) = match msg {\n                 compile::CargoMessage::CompilerArtifact {\n@@ -177,12 +203,22 @@ impl Step for ToolBuild {\n                       typically means that something was recompiled because \\\n                       a transitive dependency has different features activated \\\n                       than in a previous build:\\n\");\n+            println!(\"the following dependencies are duplicated although they \\\n+                      have the same features enabled:\");\n+            for (id, cur, prev) in duplicates.drain_filter(|(_, cur, prev)| cur.2 == prev.2) {\n+                println!(\"  {}\", id);\n+                // same features\n+                println!(\"    `{}` ({:?})\\n    `{}` ({:?})\", cur.0, cur.1, prev.0, prev.1);\n+            }\n+            println!(\"the following dependencies have different features:\");\n             for (id, cur, prev) in duplicates {\n                 println!(\"  {}\", id);\n-                println!(\"    `{}` enabled features {:?} at {:?}\",\n-                         cur.0, cur.2, cur.1);\n-                println!(\"    `{}` enabled features {:?} at {:?}\",\n-                         prev.0, prev.2, prev.1);\n+                let cur_features: HashSet<_> = cur.2.into_iter().collect();\n+                let prev_features: HashSet<_> = prev.2.into_iter().collect();\n+                println!(\"    `{}` additionally enabled features {:?} at {:?}\",\n+                         cur.0, &cur_features - &prev_features, cur.1);\n+                println!(\"    `{}` additionally enabled features {:?} at {:?}\",\n+                         prev.0, &prev_features - &cur_features, prev.1);\n             }\n             println!(\"\");\n             panic!(\"tools should not compile multiple copies of the same crate\");\n@@ -195,13 +231,13 @@ impl Step for ToolBuild {\n         });\n \n         if !is_expected {\n-            if !is_ext_tool {\n+            if !is_optional_tool {\n                 exit(1);\n             } else {\n                 return None;\n             }\n         } else {\n-            let cargo_out = builder.cargo_out(compiler, Mode::Tool, target)\n+            let cargo_out = builder.cargo_out(compiler, self.mode, target)\n                 .join(exe(tool, &compiler.host));\n             let bin = builder.tools_dir(compiler).join(exe(tool, &compiler.host));\n             builder.copy(&cargo_out, &bin);\n@@ -213,18 +249,24 @@ impl Step for ToolBuild {\n pub fn prepare_tool_cargo(\n     builder: &Builder,\n     compiler: Compiler,\n+    mode: Mode,\n     target: Interned<String>,\n     command: &'static str,\n     path: &'static str,\n+    source_type: SourceType,\n ) -> Command {\n-    let mut cargo = builder.cargo(compiler, Mode::Tool, target, command);\n+    let mut cargo = builder.cargo(compiler, mode, target, command);\n     let dir = builder.src.join(path);\n     cargo.arg(\"--manifest-path\").arg(dir.join(\"Cargo.toml\"));\n \n     // We don't want to build tools dynamically as they'll be running across\n     // stages and such and it's just easier if they're not dynamically linked.\n     cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n \n+    if source_type == SourceType::Submodule {\n+        cargo.env(\"RUSTC_EXTERNAL_TOOL\", \"1\");\n+    }\n+\n     if let Some(dir) = builder.openssl_install_dir(target) {\n         cargo.env(\"OPENSSL_STATIC\", \"1\");\n         cargo.env(\"OPENSSL_DIR\", dir);\n@@ -252,14 +294,31 @@ pub fn prepare_tool_cargo(\n }\n \n macro_rules! tool {\n-    ($($name:ident, $path:expr, $tool_name:expr, $mode:expr;)+) => {\n-        #[derive(Copy, Clone)]\n+    ($($name:ident, $path:expr, $tool_name:expr, $mode:expr\n+        $(,llvm_tools = $llvm:expr)* $(,is_external_tool = $external:expr)*;)+) => {\n+        #[derive(Copy, PartialEq, Eq, Clone)]\n         pub enum Tool {\n             $(\n                 $name,\n             )+\n         }\n \n+        impl Tool {\n+            pub fn get_mode(&self) -> Mode {\n+                let mode = match self {\n+                    $(Tool::$name => $mode,)+\n+                };\n+                mode\n+            }\n+\n+            /// Whether this tool requires LLVM to run\n+            pub fn uses_llvm_tools(&self) -> bool {\n+                match self {\n+                    $(Tool::$name => false $(|| $llvm)*,)+\n+                }\n+            }\n+        }\n+\n         impl<'a> Builder<'a> {\n             pub fn tool_exe(&self, tool: Tool) -> PathBuf {\n                 let stage = self.tool_default_stage(tool);\n@@ -313,7 +372,12 @@ macro_rules! tool {\n                     tool: $tool_name,\n                     mode: $mode,\n                     path: $path,\n-                    is_ext_tool: false,\n+                    is_optional_tool: false,\n+                    source_type: if false $(|| $external)* {\n+                        SourceType::Submodule\n+                    } else {\n+                        SourceType::InTree\n+                    },\n                     extra_features: Vec::new(),\n                 }).expect(\"expected to build -- essential tool\")\n             }\n@@ -323,17 +387,18 @@ macro_rules! tool {\n }\n \n tool!(\n-    Rustbook, \"src/tools/rustbook\", \"rustbook\", Mode::Librustc;\n-    ErrorIndex, \"src/tools/error_index_generator\", \"error_index_generator\", Mode::Librustc;\n-    UnstableBookGen, \"src/tools/unstable-book-gen\", \"unstable-book-gen\", Mode::Libstd;\n-    Tidy, \"src/tools/tidy\", \"tidy\", Mode::Libstd;\n-    Linkchecker, \"src/tools/linkchecker\", \"linkchecker\", Mode::Libstd;\n-    CargoTest, \"src/tools/cargotest\", \"cargotest\", Mode::Libstd;\n-    Compiletest, \"src/tools/compiletest\", \"compiletest\", Mode::Libtest;\n-    BuildManifest, \"src/tools/build-manifest\", \"build-manifest\", Mode::Libstd;\n-    RemoteTestClient, \"src/tools/remote-test-client\", \"remote-test-client\", Mode::Libstd;\n-    RustInstaller, \"src/tools/rust-installer\", \"fabricate\", Mode::Libstd;\n-    RustdocTheme, \"src/tools/rustdoc-themes\", \"rustdoc-themes\", Mode::Libstd;\n+    Rustbook, \"src/tools/rustbook\", \"rustbook\", Mode::ToolBootstrap;\n+    ErrorIndex, \"src/tools/error_index_generator\", \"error_index_generator\", Mode::ToolRustc;\n+    UnstableBookGen, \"src/tools/unstable-book-gen\", \"unstable-book-gen\", Mode::ToolBootstrap;\n+    Tidy, \"src/tools/tidy\", \"tidy\", Mode::ToolBootstrap;\n+    Linkchecker, \"src/tools/linkchecker\", \"linkchecker\", Mode::ToolBootstrap;\n+    CargoTest, \"src/tools/cargotest\", \"cargotest\", Mode::ToolBootstrap;\n+    Compiletest, \"src/tools/compiletest\", \"compiletest\", Mode::ToolBootstrap, llvm_tools = true;\n+    BuildManifest, \"src/tools/build-manifest\", \"build-manifest\", Mode::ToolBootstrap;\n+    RemoteTestClient, \"src/tools/remote-test-client\", \"remote-test-client\", Mode::ToolBootstrap;\n+    RustInstaller, \"src/tools/rust-installer\", \"fabricate\", Mode::ToolBootstrap,\n+        is_external_tool = true;\n+    RustdocTheme, \"src/tools/rustdoc-themes\", \"rustdoc-themes\", Mode::ToolBootstrap;\n );\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n@@ -361,9 +426,10 @@ impl Step for RemoteTestServer {\n             compiler: self.compiler,\n             target: self.target,\n             tool: \"remote-test-server\",\n-            mode: Mode::Libstd,\n+            mode: Mode::ToolStd,\n             path: \"src/tools/remote-test-server\",\n-            is_ext_tool: false,\n+            is_optional_tool: false,\n+            source_type: SourceType::InTree,\n             extra_features: Vec::new(),\n         }).expect(\"expected to build -- essential tool\")\n     }\n@@ -411,11 +477,15 @@ impl Step for Rustdoc {\n             target: builder.config.build,\n         });\n \n-        let mut cargo = prepare_tool_cargo(builder,\n-                                           build_compiler,\n-                                           target,\n-                                           \"build\",\n-                                           \"src/tools/rustdoc\");\n+        let mut cargo = prepare_tool_cargo(\n+            builder,\n+            build_compiler,\n+            Mode::ToolRustc,\n+            target,\n+            \"build\",\n+            \"src/tools/rustdoc\",\n+            SourceType::InTree,\n+        );\n \n         // Most tools don't get debuginfo, but rustdoc should.\n         cargo.env(\"RUSTC_DEBUGINFO\", builder.config.rust_debuginfo.to_string())\n@@ -429,8 +499,8 @@ impl Step for Rustdoc {\n         // Cargo adds a number of paths to the dylib search path on windows, which results in\n         // the wrong rustdoc being executed. To avoid the conflicting rustdocs, we name the \"tool\"\n         // rustdoc a different name.\n-        let tool_rustdoc = builder.cargo_out(build_compiler, Mode::Tool, target)\n-            .join(exe(\"rustdoc-tool-binary\", &target_compiler.host));\n+        let tool_rustdoc = builder.cargo_out(build_compiler, Mode::ToolRustc, target)\n+            .join(exe(\"rustdoc_tool_binary\", &target_compiler.host));\n \n         // don't create a stage0-sysroot/bin directory.\n         if target_compiler.stage > 0 {\n@@ -484,9 +554,10 @@ impl Step for Cargo {\n             compiler: self.compiler,\n             target: self.target,\n             tool: \"cargo\",\n-            mode: Mode::Librustc,\n+            mode: Mode::ToolRustc,\n             path: \"src/tools/cargo\",\n-            is_ext_tool: false,\n+            is_optional_tool: false,\n+            source_type: SourceType::Submodule,\n             extra_features: Vec::new(),\n         }).expect(\"expected to build -- essential tool\")\n     }\n@@ -532,10 +603,11 @@ macro_rules! tool_extended {\n                     compiler: $sel.compiler,\n                     target: $sel.target,\n                     tool: $tool_name,\n-                    mode: Mode::Librustc,\n+                    mode: Mode::ToolRustc,\n                     path: $path,\n                     extra_features: $sel.extra_features,\n-                    is_ext_tool: true,\n+                    is_optional_tool: true,\n+                    source_type: SourceType::Submodule,\n                 })\n             }\n         }\n@@ -545,6 +617,14 @@ macro_rules! tool_extended {\n \n tool_extended!((self, builder),\n     Cargofmt, rustfmt, \"src/tools/rustfmt\", \"cargo-fmt\", {};\n+    CargoClippy, clippy, \"src/tools/clippy\", \"cargo-clippy\", {\n+        // Clippy depends on procedural macros (serde), which requires a full host\n+        // compiler to be available, so we need to depend on that.\n+        builder.ensure(compile::Rustc {\n+            compiler: self.compiler,\n+            target: builder.config.build,\n+        });\n+    };\n     Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", {\n         // Clippy depends on procedural macros (serde), which requires a full host\n         // compiler to be available, so we need to depend on that.\n@@ -560,8 +640,7 @@ tool_extended!((self, builder),\n             target: self.target,\n             extra_features: Vec::new(),\n         });\n-        let channel = &builder.config.channel;\n-        if clippy.is_some() && channel != \"stable\" && channel != \"beta\" {\n+        if clippy.is_some() {\n             self.extra_features.push(\"clippy\".to_owned());\n         }\n         builder.ensure(native::Openssl {\n@@ -583,19 +662,23 @@ impl<'a> Builder<'a> {\n     pub fn tool_cmd(&self, tool: Tool) -> Command {\n         let mut cmd = Command::new(self.tool_exe(tool));\n         let compiler = self.compiler(self.tool_default_stage(tool), self.config.build);\n-        self.prepare_tool_cmd(compiler, &mut cmd);\n+        self.prepare_tool_cmd(compiler, tool, &mut cmd);\n         cmd\n     }\n \n     /// Prepares the `cmd` provided to be able to run the `compiler` provided.\n     ///\n     /// Notably this munges the dynamic library lookup path to point to the\n     /// right location to run `compiler`.\n-    fn prepare_tool_cmd(&self, compiler: Compiler, cmd: &mut Command) {\n+    fn prepare_tool_cmd(&self, compiler: Compiler, tool: Tool, cmd: &mut Command) {\n         let host = &compiler.host;\n-        let mut paths: Vec<PathBuf> = vec![\n-            PathBuf::from(&self.sysroot_libdir(compiler, compiler.host)),\n-            self.cargo_out(compiler, Mode::Tool, *host).join(\"deps\"),\n+        let mut lib_paths: Vec<PathBuf> = vec![\n+            if compiler.stage == 0 && tool != Tool::ErrorIndex {\n+                self.build.rustc_snapshot_libdir()\n+            } else {\n+                PathBuf::from(&self.sysroot_libdir(compiler, compiler.host))\n+            },\n+            self.cargo_out(compiler, tool.get_mode(), *host).join(\"deps\"),\n         ];\n \n         // On MSVC a tool may invoke a C compiler (e.g. compiletest in run-make\n@@ -610,11 +693,48 @@ impl<'a> Builder<'a> {\n                 }\n                 for path in env::split_paths(v) {\n                     if !curpaths.contains(&path) {\n-                        paths.push(path);\n+                        lib_paths.push(path);\n                     }\n                 }\n             }\n         }\n-        add_lib_path(paths, cmd);\n+\n+        // Add the llvm/bin directory to PATH since it contains lots of\n+        // useful, platform-independent tools\n+        if tool.uses_llvm_tools() {\n+            if let Some(llvm_bin_path) = self.llvm_bin_path() {\n+                if host.contains(\"windows\") {\n+                    // On Windows, PATH and the dynamic library path are the same,\n+                    // so we just add the LLVM bin path to lib_path\n+                    lib_paths.push(llvm_bin_path);\n+                } else {\n+                    let old_path = env::var_os(\"PATH\").unwrap_or_default();\n+                    let new_path = env::join_paths(iter::once(llvm_bin_path)\n+                            .chain(env::split_paths(&old_path)))\n+                        .expect(\"Could not add LLVM bin path to PATH\");\n+                    cmd.env(\"PATH\", new_path);\n+                }\n+            }\n+        }\n+\n+        add_lib_path(lib_paths, cmd);\n+    }\n+\n+    fn llvm_bin_path(&self) -> Option<PathBuf> {\n+        if self.config.llvm_enabled && !self.config.dry_run {\n+            let llvm_config = self.ensure(native::Llvm {\n+                target: self.config.build,\n+                emscripten: false,\n+            });\n+\n+            // Add the llvm/bin directory to PATH since it contains lots of\n+            // useful, platform-independent tools\n+            let llvm_bin_path = llvm_config.parent()\n+                .expect(\"Expected llvm-config to be contained in directory\");\n+            assert!(llvm_bin_path.is_dir());\n+            Some(llvm_bin_path.to_path_buf())\n+        } else {\n+            None\n+        }\n     }\n }"}, {"sha": "be03796921af865b7c2c3d0a16b75d6d6272c888", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -92,10 +92,7 @@ pub fn push_exe_path(mut buf: PathBuf, components: &[&str]) -> PathBuf {\n         file.push_str(\".exe\");\n     }\n \n-    for c in components {\n-        buf.push(c);\n-    }\n-\n+    buf.extend(components);\n     buf.push(file);\n \n     buf"}, {"sha": "1cbb8e49bfa15e0579ebeb0e3b37aa0d0bda10db", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -13,6 +13,7 @@ use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n use std::time::{SystemTime, UNIX_EPOCH};\n use std::{env, fs};\n+use std::thread;\n \n /// A helper macro to `unwrap` a result except also print out details like:\n ///\n@@ -179,7 +180,9 @@ pub struct NativeLibBoilerplate {\n \n impl Drop for NativeLibBoilerplate {\n     fn drop(&mut self) {\n-        t!(File::create(self.out_dir.join(\"rustbuild.timestamp\")));\n+        if !thread::panicking() {\n+            t!(File::create(self.out_dir.join(\"rustbuild.timestamp\")));\n+        }\n     }\n }\n \n@@ -223,24 +226,34 @@ pub fn native_lib_boilerplate(\n     }\n }\n \n-pub fn sanitizer_lib_boilerplate(sanitizer_name: &str) -> Result<NativeLibBoilerplate, ()> {\n-    let (link_name, search_path) = match &*env::var(\"TARGET\").unwrap() {\n+pub fn sanitizer_lib_boilerplate(sanitizer_name: &str)\n+    -> Result<(NativeLibBoilerplate, String), ()>\n+{\n+    let (link_name, search_path, dynamic) = match &*env::var(\"TARGET\").unwrap() {\n         \"x86_64-unknown-linux-gnu\" => (\n             format!(\"clang_rt.{}-x86_64\", sanitizer_name),\n             \"build/lib/linux\",\n+            false,\n         ),\n         \"x86_64-apple-darwin\" => (\n-            format!(\"dylib=clang_rt.{}_osx_dynamic\", sanitizer_name),\n+            format!(\"clang_rt.{}_osx_dynamic\", sanitizer_name),\n             \"build/lib/darwin\",\n+            true,\n         ),\n         _ => return Err(()),\n     };\n-    native_lib_boilerplate(\n+    let to_link = if dynamic {\n+        format!(\"dylib={}\", link_name)\n+    } else {\n+        format!(\"static={}\", link_name)\n+    };\n+    let lib = native_lib_boilerplate(\n         \"libcompiler_builtins/compiler-rt\",\n         sanitizer_name,\n-        &link_name,\n+        &to_link,\n         search_path,\n-    )\n+    )?;\n+    Ok((lib, link_name))\n }\n \n fn dir_up_to_date(src: &Path, threshold: SystemTime) -> bool {"}, {"sha": "34c6e640abb7c85460a9baee202e0bcc69881001", "filename": "src/ci/docker/disabled/dist-armebv7r-none-eabihf/Dockerfile", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armebv7r-none-eabihf%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armebv7r-none-eabihf%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armebv7r-none-eabihf%2FDockerfile?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -0,0 +1,36 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  xz-utils \\\n+  bzip2 \\\n+  libssl-dev \\\n+  pkg-config\n+\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV BASE_URL=https://releases.linaro.org/components/toolchain/binaries/latest/armeb-eabi/\n+ENV GCC_LINARO=gcc-linaro-7.2.1-2017.11-x86_64_armeb-eabi\n+\n+RUN curl -sL $BASE_URL/$GCC_LINARO.tar.xz | tar -xJ\n+\n+ENV PATH=$PATH:/$GCC_LINARO/bin\n+\n+ENV TARGET=armebv7r-none-eabihf\n+\n+ENV CC_armebv7r_none_eabihf=armeb-eabi-gcc \\\n+    CFLAGS_armebv7r_none_eabihf=\"-march=armv7-r\"\n+\n+ENV RUST_CONFIGURE_ARGS --disable-docs\n+\n+ENV SCRIPT python2.7 ../x.py dist --target $TARGET"}, {"sha": "952c265a1390b75fa871cf06a4e1d13323db1420", "filename": "src/ci/docker/disabled/dist-sparc64-linux/Dockerfile", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fdisabled%2Fdist-sparc64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fdisabled%2Fdist-sparc64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-sparc64-linux%2FDockerfile?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -0,0 +1,26 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  xz-utils \\\n+  g++-sparc64-linux-gnu \\\n+  libssl-dev \\\n+  pkg-config\n+\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV HOSTS=sparc64-unknown-linux-gnu\n+\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n+ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "ba2d32a9296b4e099da0b8660652e79dfd13601f", "filename": "src/ci/docker/dist-i586-gnu-i586-i686-musl/Dockerfile", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -42,9 +42,7 @@ ENV RUST_CONFIGURE_ARGS \\\n # See: https://github.com/rust-lang/rust/issues/34978\n ENV CFLAGS_i686_unknown_linux_musl=-Wa,-mrelax-relocations=no\n ENV CFLAGS_i586_unknown_linux_gnu=-Wa,-mrelax-relocations=no\n-# FIXME remove -Wl,-melf_i386 after cc is updated to include\n-#       https://github.com/alexcrichton/cc-rs/pull/281\n-ENV CFLAGS_i586_unknown_linux_musl=\"-Wa,-mrelax-relocations=no -Wl,-melf_i386\"\n+ENV CFLAGS_i586_unknown_linux_musl=-Wa,-mrelax-relocations=no\n \n ENV TARGETS=i586-unknown-linux-gnu,i686-unknown-linux-musl\n "}, {"sha": "d591fb28f36edcd9e0260471764dfc9d7cbac523", "filename": "src/ci/docker/dist-i686-linux/Dockerfile", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -29,13 +29,13 @@ ENV PATH=/rustroot/bin:$PATH\n ENV LD_LIBRARY_PATH=/rustroot/lib64:/rustroot/lib\n ENV PKG_CONFIG_PATH=/rustroot/lib/pkgconfig\n WORKDIR /tmp\n-COPY dist-i686-linux/shared.sh dist-i686-linux/build-binutils.sh /tmp/\n+COPY dist-x86_64-linux/shared.sh /tmp/\n \n # We need a build of openssl which supports SNI to download artifacts from\n # static.rust-lang.org. This'll be used to link into libcurl below (and used\n # later as well), so build a copy of OpenSSL with dynamic libraries into our\n # generic root.\n-COPY dist-i686-linux/build-openssl.sh /tmp/\n+COPY dist-x86_64-linux/build-openssl.sh /tmp/\n RUN ./build-openssl.sh\n \n # The `curl` binary on CentOS doesn't support SNI which is needed for fetching\n@@ -44,36 +44,43 @@ RUN ./build-openssl.sh\n #\n # Note that we also disable a bunch of optional features of curl that we don't\n # really need.\n-COPY dist-i686-linux/build-curl.sh /tmp/\n+COPY dist-x86_64-linux/build-curl.sh /tmp/\n RUN ./build-curl.sh\n \n # binutils < 2.22 has a bug where the 32-bit executables it generates\n # immediately segfault in Rust, so we need to install our own binutils.\n #\n # See https://github.com/rust-lang/rust/issues/20440 for more info\n+COPY dist-x86_64-linux/build-binutils.sh /tmp/\n RUN ./build-binutils.sh\n \n+# libssh2 (a dependency of Cargo) requires cmake 2.8.11 or higher but CentOS\n+# only has 2.6.4, so build our own\n+COPY dist-x86_64-linux/build-cmake.sh /tmp/\n+RUN ./build-cmake.sh\n+\n # Need a newer version of gcc than centos has to compile LLVM nowadays\n-COPY dist-i686-linux/build-gcc.sh /tmp/\n+COPY dist-x86_64-linux/build-gcc.sh /tmp/\n RUN ./build-gcc.sh\n \n # CentOS 5.5 has Python 2.4 by default, but LLVM needs 2.7+\n-COPY dist-i686-linux/build-python.sh /tmp/\n+COPY dist-x86_64-linux/build-python.sh /tmp/\n RUN ./build-python.sh\n \n+# Now build LLVM+Clang 6, afterwards configuring further compilations to use the\n+# clang/clang++ compilers.\n+COPY dist-x86_64-linux/build-clang.sh /tmp/\n+RUN ./build-clang.sh\n+ENV CC=clang CXX=clang++\n+\n # Apparently CentOS 5.5 desn't have `git` in yum, but we're gonna need it for\n # cloning, so download and build it here.\n-COPY dist-i686-linux/build-git.sh /tmp/\n+COPY dist-x86_64-linux/build-git.sh /tmp/\n RUN ./build-git.sh\n \n-# libssh2 (a dependency of Cargo) requires cmake 2.8.11 or higher but CentOS\n-# only has 2.6.4, so build our own\n-COPY dist-i686-linux/build-cmake.sh /tmp/\n-RUN ./build-cmake.sh\n-\n # for sanitizers, we need kernel headers files newer than the ones CentOS ships\n # with so we install newer ones here\n-COPY dist-i686-linux/build-headers.sh /tmp/\n+COPY dist-x86_64-linux/build-headers.sh /tmp/\n RUN ./build-headers.sh\n \n COPY scripts/sccache.sh /scripts/\n@@ -84,11 +91,21 @@ ENV HOSTS=i686-unknown-linux-gnu\n ENV RUST_CONFIGURE_ARGS \\\n       --enable-full-tools \\\n       --enable-sanitizers \\\n-      --enable-profiler\n+      --enable-profiler \\\n+      --set target.i686-unknown-linux-gnu.linker=clang \\\n+      --build=i686-unknown-linux-gnu\n ENV SCRIPT python2.7 ../x.py dist --build $HOSTS --host $HOSTS --target $HOSTS\n-\n-# This is the only builder which will create source tarballs\n-ENV DIST_SRC 1\n+ENV CARGO_TARGET_I686_UNKNOWN_LINUX_GNU_LINKER=clang\n+\n+# This was added when we switched from gcc to clang. It's not clear why this is\n+# needed unfortunately, but without this the stage1 bootstrap segfaults\n+# somewhere inside of a build script. The build ends up just hanging instead of\n+# actually killing the process that segfaulted, but if the process is run\n+# manually in a debugger the segfault is immediately seen as well as the\n+# misaligned stack access.\n+#\n+# Added in #50200 there's some more logs there\n+ENV CFLAGS -mstackrealign\n \n # When we build cargo in this container, we don't want it to use the system\n # libcurl, instead it should compile its own."}, {"sha": "f4bdbd80d0edb761dc08e34286e0c76a1ef4a0a0", "filename": "src/ci/docker/dist-i686-linux/build-binutils.sh", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-binutils.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-binutils.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-binutils.sh?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,26 +0,0 @@\n-#!/usr/bin/env bash\n-# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-set -ex\n-\n-source shared.sh\n-\n-curl https://ftp.gnu.org/gnu/binutils/binutils-2.25.1.tar.bz2 | tar xfj -\n-\n-mkdir binutils-build\n-cd binutils-build\n-hide_output ../binutils-2.25.1/configure --prefix=/rustroot\n-hide_output make -j10\n-hide_output make install\n-\n-cd ..\n-rm -rf binutils-build\n-rm -rf binutils-2.25.1"}, {"sha": "9a3763d421ad2b721d773494cc11fc2d7ffbec28", "filename": "src/ci/docker/dist-i686-linux/build-cmake.sh", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-cmake.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-cmake.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-cmake.sh?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,25 +0,0 @@\n-#!/usr/bin/env bash\n-# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-set -ex\n-source shared.sh\n-\n-curl https://cmake.org/files/v3.6/cmake-3.6.3.tar.gz | tar xzf -\n-\n-mkdir cmake-build\n-cd cmake-build\n-hide_output ../cmake-3.6.3/configure --prefix=/rustroot\n-hide_output make -j10\n-hide_output make install\n-\n-cd ..\n-rm -rf cmake-build\n-rm -rf cmake-3.6.3"}, {"sha": "edf3175b81c436321f510ec99b560f627d93a677", "filename": "src/ci/docker/dist-i686-linux/build-curl.sh", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-curl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-curl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-curl.sh?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,43 +0,0 @@\n-#!/usr/bin/env bash\n-# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-set -ex\n-source shared.sh\n-\n-VERSION=7.51.0\n-\n-curl http://cool.haxx.se/download/curl-$VERSION.tar.bz2 | tar xjf -\n-\n-mkdir curl-build\n-cd curl-build\n-hide_output ../curl-$VERSION/configure \\\n-      --prefix=/rustroot \\\n-      --with-ssl=/rustroot \\\n-      --disable-sspi \\\n-      --disable-gopher \\\n-      --disable-smtp \\\n-      --disable-smb \\\n-      --disable-imap \\\n-      --disable-pop3 \\\n-      --disable-tftp \\\n-      --disable-telnet \\\n-      --disable-manual \\\n-      --disable-dict \\\n-      --disable-rtsp \\\n-      --disable-ldaps \\\n-      --disable-ldap\n-hide_output make -j10\n-hide_output make install\n-\n-cd ..\n-rm -rf curl-build\n-rm -rf curl-$VERSION\n-yum erase -y curl"}, {"sha": "08020e533ff191ca565868062cef8f7d5ab55967", "filename": "src/ci/docker/dist-i686-linux/build-gcc.sh", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-gcc.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-gcc.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-gcc.sh?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,50 +0,0 @@\n-#!/usr/bin/env bash\n-# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-set -ex\n-\n-source shared.sh\n-\n-GCC=4.8.5\n-\n-curl https://ftp.gnu.org/gnu/gcc/gcc-$GCC/gcc-$GCC.tar.bz2 | tar xjf -\n-cd gcc-$GCC\n-\n-# FIXME(#49246): Remove the `sed` below.\n-#\n-# On 2018 March 21st, two Travis builders' cache for Docker are suddenly invalidated. Normally this\n-# is fine, because we just need to rebuild the Docker image. However, it reveals a network issue:\n-# downloading from `ftp://gcc.gnu.org/` from Travis (using passive mode) often leads to \"Connection\n-# timed out\" error, and even when the download completed, the file is usually corrupted. This causes\n-# nothing to be landed that day.\n-#\n-# We observed that the `gcc-4.8.5.tar.bz2` above can be downloaded successfully, so as a stability\n-# improvement we try to download from the HTTPS mirror instead. Turns out this uncovered the third\n-# bug: the host `gcc.gnu.org` and `cygwin.com` share the same IP, and the TLS certificate of the\n-# latter host is presented to `wget`! Therefore, we choose to download from the insecure HTTP server\n-# instead here.\n-#\n-sed -i'' 's|ftp://gcc\\.gnu\\.org/|http://gcc.gnu.org/|g' ./contrib/download_prerequisites\n-\n-./contrib/download_prerequisites\n-mkdir ../gcc-build\n-cd ../gcc-build\n-hide_output ../gcc-$GCC/configure \\\n-    --prefix=/rustroot \\\n-    --enable-languages=c,c++\n-hide_output make -j10\n-hide_output make install\n-ln -nsf gcc /rustroot/bin/cc\n-\n-cd ..\n-rm -rf gcc-build\n-rm -rf gcc-$GCC\n-yum erase -y gcc gcc-c++ binutils"}, {"sha": "aa31f50ba0343134bfbece006ad3faf6c13afc72", "filename": "src/ci/docker/dist-i686-linux/build-git.sh", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-git.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-git.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-git.sh?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,24 +0,0 @@\n-#!/usr/bin/env bash\n-# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-set -ex\n-source shared.sh\n-\n-curl -L https://www.kernel.org/pub/software/scm/git/git-2.10.0.tar.gz | tar xzf -\n-\n-cd git-2.10.0\n-make configure\n-hide_output ./configure --prefix=/rustroot\n-hide_output make -j10\n-hide_output make install\n-\n-cd ..\n-rm -rf git-2.10.0"}, {"sha": "2f15114d6f98028857bbeef289cedc70d1c887e0", "filename": "src/ci/docker/dist-i686-linux/build-headers.sh", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-headers.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-headers.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-headers.sh?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,25 +0,0 @@\n-#!/usr/bin/env bash\n-# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-set -ex\n-source shared.sh\n-\n-curl https://cdn.kernel.org/pub/linux/kernel/v3.x/linux-3.2.84.tar.xz | unxz | tar x\n-\n-cd linux-3.2.84\n-hide_output make mrproper\n-hide_output make INSTALL_HDR_PATH=dest headers_install\n-\n-find dest/include \\( -name .install -o -name ..install.cmd \\) -delete\n-yes | cp -fr dest/include/* /usr/include\n-\n-cd ..\n-rm -rf linux-3.2.84"}, {"sha": "e7226ace020bd8bc8dc35b11e1e07b3ab9b66a53", "filename": "src/ci/docker/dist-i686-linux/build-openssl.sh", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-openssl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-openssl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-openssl.sh?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,28 +0,0 @@\n-#!/usr/bin/env bash\n-# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-set -ex\n-source shared.sh\n-\n-VERSION=1.0.2k\n-URL=https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/openssl-$VERSION.tar.gz\n-\n-curl $URL | tar xzf -\n-\n-cd openssl-$VERSION\n-hide_output ./config --prefix=/rustroot shared -fPIC\n-hide_output make -j10\n-hide_output make install\n-cd ..\n-rm -rf openssl-$VERSION\n-\n-# Make the system cert collection available to the new install.\n-ln -nsf /etc/pki/tls/cert.pem /rustroot/ssl/"}, {"sha": "c6b8cdde4b9af4d57737dd910efe1ebb67c4425e", "filename": "src/ci/docker/dist-i686-linux/build-python.sh", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-python.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-python.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-python.sh?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,30 +0,0 @@\n-#!/usr/bin/env bash\n-# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-set -ex\n-source shared.sh\n-\n-curl https://www.python.org/ftp/python/2.7.12/Python-2.7.12.tgz | \\\n-  tar xzf -\n-\n-mkdir python-build\n-cd python-build\n-\n-# Gotta do some hackery to tell python about our custom OpenSSL build, but other\n-# than that fairly normal.\n-CFLAGS='-I /rustroot/include' LDFLAGS='-L /rustroot/lib -L /rustroot/lib64' \\\n-    hide_output ../Python-2.7.12/configure --prefix=/rustroot\n-hide_output make -j10\n-hide_output make install\n-\n-cd ..\n-rm -rf python-build\n-rm -rf Python-2.7.12"}, {"sha": "97e6d2908cf8a5ae3174e1bc08a17ea27fa3aae5", "filename": "src/ci/docker/dist-i686-linux/shared.sh", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fshared.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fshared.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fshared.sh?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,25 +0,0 @@\n-# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-hide_output() {\n-  set +x\n-  on_err=\"\n-echo ERROR: An error was encountered with the build.\n-cat /tmp/build.log\n-exit 1\n-\"\n-  trap \"$on_err\" ERR\n-  bash -c \"while true; do sleep 30; echo \\$(date) - building ...; done\" &\n-  PING_LOOP_PID=$!\n-  $@ &> /tmp/build.log\n-  trap - ERR\n-  kill $PING_LOOP_PID\n-  set -x\n-}"}, {"sha": "6302f550091ad6285df2584ed6a26022f462cf18", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -80,6 +80,11 @@ RUN \\\n   echo \"# a\" >> /usr/local/mips-linux-musl/bin/mips-openwrt-linux-musl-wrapper.sh && \\\n   echo \"# b\" >> /usr/local/mipsel-linux-musl/bin/mipsel-openwrt-linux-musl-wrapper.sh\n \n+ENV RUN_MAKE_TARGETS=thumbv6m-none-eabi\n+ENV RUN_MAKE_TARGETS=$RUN_MAKE_TARGETS,thumbv7m-none-eabi\n+ENV RUN_MAKE_TARGETS=$RUN_MAKE_TARGETS,thumbv7em-none-eabi\n+ENV RUN_MAKE_TARGETS=$RUN_MAKE_TARGETS,thumbv7em-none-eabihf\n+\n ENV TARGETS=asmjs-unknown-emscripten\n ENV TARGETS=$TARGETS,wasm32-unknown-emscripten\n ENV TARGETS=$TARGETS,x86_64-rumprun-netbsd\n@@ -98,16 +103,10 @@ ENV TARGETS=$TARGETS,thumbv7m-none-eabi\n ENV TARGETS=$TARGETS,thumbv7em-none-eabi\n ENV TARGETS=$TARGETS,thumbv7em-none-eabihf\n \n-# FIXME: remove armv5te vars after https://github.com/alexcrichton/cc-rs/issues/271\n-#        get fixed and cc update\n ENV CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \\\n     CC_mips_unknown_linux_musl=mips-openwrt-linux-gcc \\\n     CC_sparc64_unknown_linux_gnu=sparc64-linux-gnu-gcc \\\n-    CC_x86_64_unknown_redox=x86_64-unknown-redox-gcc \\\n-    CC_armv5te_unknown_linux_gnueabi=arm-linux-gnueabi-gcc \\\n-    CFLAGS_armv5te_unknown_linux_gnueabi=\"-march=armv5te -marm -mfloat-abi=soft\" \\\n-    CC_armv5te_unknown_linux_musleabi=arm-linux-gnueabi-gcc \\\n-    CFLAGS_armv5te_unknown_linux_musleabi=\"-march=armv5te -marm -mfloat-abi=soft\"\n+    CC_x86_64_unknown_redox=x86_64-unknown-redox-gcc\n \n ENV RUST_CONFIGURE_ARGS \\\n       --musl-root-armv5te=/musl-armv5te \\\n@@ -120,7 +119,9 @@ ENV RUST_CONFIGURE_ARGS \\\n       --enable-emscripten \\\n       --disable-docs\n \n-ENV SCRIPT python2.7 ../x.py dist --target $TARGETS\n+ENV SCRIPT \\ \n+      python2.7 ../x.py test --target $RUN_MAKE_TARGETS src/test/run-make && \\\n+      python2.7 ../x.py dist --target $TARGETS\n \n # sccache\n COPY scripts/sccache.sh /scripts/"}, {"sha": "7adb32efa1d414ef8daa1f1030fd7d92bcd51f24", "filename": "src/ci/docker/dist-various-2/Dockerfile", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -34,21 +34,21 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV \\\n-    AR_x86_64_unknown_fuchsia=x86_64-unknown-fuchsia-ar \\\n-    CC_x86_64_unknown_fuchsia=x86_64-unknown-fuchsia-clang \\\n-    CXX_x86_64_unknown_fuchsia=x86_64-unknown-fuchsia-clang++ \\\n-    AR_aarch64_unknown_fuchsia=aarch64-unknown-fuchsia-ar \\\n-    CC_aarch64_unknown_fuchsia=aarch64-unknown-fuchsia-clang \\\n-    CXX_aarch64_unknown_fuchsia=aarch64-unknown-fuchsia-clang++ \\\n+    AR_x86_64_fuchsia=x86_64-fuchsia-ar \\\n+    CC_x86_64_fuchsia=x86_64-fuchsia-clang \\\n+    CXX_x86_64_fuchsia=x86_64-fuchsia-clang++ \\\n+    AR_aarch64_fuchsia=aarch64-fuchsia-ar \\\n+    CC_aarch64_fuchsia=aarch64-fuchsia-clang \\\n+    CXX_aarch64_fuchsia=aarch64-fuchsia-clang++ \\\n     AR_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-ar \\\n     CC_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-gcc \\\n     CXX_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-g++ \\\n     AR_x86_64_sun_solaris=x86_64-sun-solaris2.10-ar \\\n     CC_x86_64_sun_solaris=x86_64-sun-solaris2.10-gcc \\\n     CXX_x86_64_sun_solaris=x86_64-sun-solaris2.10-g++\n \n-ENV TARGETS=x86_64-unknown-fuchsia\n-ENV TARGETS=$TARGETS,aarch64-unknown-fuchsia\n+ENV TARGETS=x86_64-fuchsia\n+ENV TARGETS=$TARGETS,aarch64-fuchsia\n ENV TARGETS=$TARGETS,sparcv9-sun-solaris\n ENV TARGETS=$TARGETS,wasm32-unknown-unknown\n ENV TARGETS=$TARGETS,x86_64-sun-solaris"}, {"sha": "ec19f7c4f45d972aaa5dac84c5f11da455ad7c17", "filename": "src/ci/docker/dist-various-2/build-fuchsia-toolchain.sh", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-fuchsia-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-fuchsia-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-fuchsia-toolchain.sh?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -39,7 +39,7 @@ build() {\n   esac\n \n   hide_output make -j$(getconf _NPROCESSORS_ONLN) $tgt\n-  dst=/usr/local/${arch}-unknown-fuchsia\n+  dst=/usr/local/${arch}-fuchsia\n   mkdir -p $dst\n   cp -a build-${tgt}/sysroot/include $dst/\n   cp -a build-${tgt}/sysroot/lib $dst/\n@@ -55,11 +55,11 @@ rm -rf zircon\n \n for arch in x86_64 aarch64; do\n   for tool in clang clang++; do\n-    cat >/usr/local/bin/${arch}-unknown-fuchsia-${tool} <<EOF\n+    cat >/usr/local/bin/${arch}-fuchsia-${tool} <<EOF\n #!/bin/sh\n-${tool} --target=${arch}-unknown-fuchsia --sysroot=/usr/local/${arch}-unknown-fuchsia \"\\$@\"\n+${tool} --target=${arch}-fuchsia --sysroot=/usr/local/${arch}-fuchsia \"\\$@\"\n EOF\n-    chmod +x /usr/local/bin/${arch}-unknown-fuchsia-${tool}\n+    chmod +x /usr/local/bin/${arch}-fuchsia-${tool}\n   done\n-  ln -s /usr/local/bin/llvm-ar /usr/local/bin/${arch}-unknown-fuchsia-ar\n+  ln -s /usr/local/bin/llvm-ar /usr/local/bin/${arch}-fuchsia-ar\n done"}, {"sha": "5726fab7524ae88a55e35d27d8b1291f18fa8816", "filename": "src/ci/docker/dist-x86_64-linux/Dockerfile", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -29,7 +29,7 @@ ENV PATH=/rustroot/bin:$PATH\n ENV LD_LIBRARY_PATH=/rustroot/lib64:/rustroot/lib\n ENV PKG_CONFIG_PATH=/rustroot/lib/pkgconfig\n WORKDIR /tmp\n-COPY dist-x86_64-linux/shared.sh dist-x86_64-linux/build-binutils.sh /tmp/\n+COPY dist-x86_64-linux/shared.sh /tmp/\n \n # We need a build of openssl which supports SNI to download artifacts from\n # static.rust-lang.org. This'll be used to link into libcurl below (and used\n@@ -51,26 +51,33 @@ RUN ./build-curl.sh\n # immediately segfault in Rust, so we need to install our own binutils.\n #\n # See https://github.com/rust-lang/rust/issues/20440 for more info\n+COPY dist-x86_64-linux/build-binutils.sh /tmp/\n RUN ./build-binutils.sh\n \n-# Need a newer version of gcc than centos has to compile LLVM nowadays\n+# libssh2 (a dependency of Cargo) requires cmake 2.8.11 or higher but CentOS\n+# only has 2.6.4, so build our own\n+COPY dist-x86_64-linux/build-cmake.sh /tmp/\n+RUN ./build-cmake.sh\n+\n+# Build a version of gcc capable of building LLVM 6\n COPY dist-x86_64-linux/build-gcc.sh /tmp/\n RUN ./build-gcc.sh\n \n # CentOS 5.5 has Python 2.4 by default, but LLVM needs 2.7+\n COPY dist-x86_64-linux/build-python.sh /tmp/\n RUN ./build-python.sh\n \n+# Now build LLVM+Clang 6, afterwards configuring further compilations to use the\n+# clang/clang++ compilers.\n+COPY dist-x86_64-linux/build-clang.sh /tmp/\n+RUN ./build-clang.sh\n+ENV CC=clang CXX=clang++\n+\n # Apparently CentOS 5.5 desn't have `git` in yum, but we're gonna need it for\n # cloning, so download and build it here.\n COPY dist-x86_64-linux/build-git.sh /tmp/\n RUN ./build-git.sh\n \n-# libssh2 (a dependency of Cargo) requires cmake 2.8.11 or higher but CentOS\n-# only has 2.6.4, so build our own\n-COPY dist-x86_64-linux/build-cmake.sh /tmp/\n-RUN ./build-cmake.sh\n-\n # for sanitizers, we need kernel headers files newer than the ones CentOS ships\n # with so we install newer ones here\n COPY dist-x86_64-linux/build-headers.sh /tmp/\n@@ -85,8 +92,10 @@ ENV RUST_CONFIGURE_ARGS \\\n       --enable-full-tools \\\n       --enable-sanitizers \\\n       --enable-profiler \\\n-      --enable-compiler-docs\n+      --enable-compiler-docs \\\n+      --set target.x86_64-unknown-linux-gnu.linker=clang\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV CARGO_TARGET_X86_64_UNKNOWN_LINUX_GNU_LINKER=clang\n \n # This is the only builder which will create source tarballs\n ENV DIST_SRC 1"}, {"sha": "b0c27aa45bf9319d50c1574319c9d16ba0852be0", "filename": "src/ci/docker/dist-x86_64-linux/build-clang.sh", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-clang.sh", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-clang.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-clang.sh?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -0,0 +1,64 @@\n+#!/usr/bin/env bash\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+source shared.sh\n+\n+LLVM=6.0.0\n+\n+mkdir clang\n+cd clang\n+\n+curl https://releases.llvm.org/$LLVM/llvm-$LLVM.src.tar.xz | \\\n+  xz -d | \\\n+  tar xf -\n+\n+cd llvm-$LLVM.src\n+\n+mkdir -p tools/clang\n+\n+curl https://releases.llvm.org/$LLVM/cfe-$LLVM.src.tar.xz | \\\n+  xz -d | \\\n+  tar xf - -C tools/clang --strip-components=1\n+\n+mkdir ../clang-build\n+cd ../clang-build\n+\n+# For whatever reason the default set of include paths for clang is different\n+# than that of gcc. As a result we need to manually include our sysroot's\n+# include path, /rustroot/include, to clang's default include path.\n+#\n+# Alsow there's this weird oddity with gcc where there's an 'include-fixed'\n+# directory that it generates. It turns out [1] that Centos 5's headers are so\n+# old that they're incompatible with modern C semantics. While gcc automatically\n+# fixes that clang doesn't account for this. Tell clang to manually include the\n+# fixed headers so we can successfully compile code later on.\n+#\n+# [1]: https://sourceware.org/ml/crossgcc/2008-11/msg00028.html\n+INC=\"/rustroot/include\"\n+INC=\"$INC:/rustroot/lib/gcc/x86_64-unknown-linux-gnu/4.8.5/include-fixed\"\n+INC=\"$INC:/usr/include\"\n+\n+hide_output \\\n+    cmake ../llvm-$LLVM.src \\\n+      -DCMAKE_C_COMPILER=/rustroot/bin/gcc \\\n+      -DCMAKE_CXX_COMPILER=/rustroot/bin/g++ \\\n+      -DCMAKE_BUILD_TYPE=Release \\\n+      -DCMAKE_INSTALL_PREFIX=/rustroot \\\n+      -DLLVM_TARGETS_TO_BUILD=X86 \\\n+      -DC_INCLUDE_DIRS=\"$INC\"\n+\n+hide_output make -j10\n+hide_output make install\n+\n+cd ../..\n+rm -rf clang"}, {"sha": "62ea2506f4ef81964c7e14d5f84dcc46539c1a2c", "filename": "src/ci/docker/dist-x86_64-linux/build-gcc.sh", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -42,7 +42,6 @@ hide_output ../gcc-$GCC/configure \\\n     --enable-languages=c,c++\n hide_output make -j10\n hide_output make install\n-ln -nsf gcc /rustroot/bin/cc\n \n cd ..\n rm -rf gcc-build"}, {"sha": "b1ee636644ec79e76415e4cb2eb76d64fa3c6f84", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -36,8 +36,10 @@ if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n       s3url=\"s3://$SCCACHE_BUCKET/docker/$cksum\"\n       url=\"https://s3-us-west-1.amazonaws.com/$SCCACHE_BUCKET/docker/$cksum\"\n       echo \"Attempting to download $s3url\"\n+      rm -f /tmp/rustci_docker_cache\n       set +e\n-      loaded_images=$(curl $url | docker load | sed 's/.* sha/sha/')\n+      retry curl -f -L -C - -o /tmp/rustci_docker_cache \"$url\"\n+      loaded_images=$(docker load -i /tmp/rustci_docker_cache | sed 's/.* sha/sha/')\n       set -e\n       echo \"Downloaded containers:\\n$loaded_images\"\n     fi\n@@ -97,6 +99,7 @@ objdir=$root_dir/obj\n \n mkdir -p $HOME/.cargo\n mkdir -p $objdir/tmp\n+mkdir -p $objdir/cores\n \n args=\n if [ \"$SCCACHE_BUCKET\" != \"\" ]; then\n@@ -116,6 +119,10 @@ fi\n # goes ahead and sets it for all builders.\n args=\"$args --privileged\"\n \n+if [ \"$CI\" != \"\" ]; then\n+    args=\"$args --dns 8.8.8.8 --dns 8.8.4.4 --dns 1.1.1.1 --dns 1.0.0.1\"\n+fi\n+\n exec docker \\\n   run \\\n   --volume \"$root_dir:/checkout:ro\" \\"}, {"sha": "4ca7389d6d1a53102eca067a43697f88250dbcd9", "filename": "src/ci/docker/scripts/musl.sh", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -32,11 +32,17 @@ shift\n \n export CFLAGS=\"-fPIC $CFLAGS\"\n \n-MUSL=musl-1.1.18\n+# FIXME: remove the patch when upate to 1.1.20\n+MUSL=musl-1.1.19\n \n # may have been downloaded in a previous run\n if [ ! -d $MUSL ]; then\n   curl https://www.musl-libc.org/releases/$MUSL.tar.gz | tar xzf -\n+  # Patch to fix https://github.com/rust-lang/rust/issues/48967\n+  cd $MUSL && \\\n+    curl \"https://git.musl-libc.org/cgit/musl/patch/?id=610c5a8524c3d6cd3ac5a5f1231422e7648a3791\" |\\\n+    patch -p1 && \\\n+    cd -\n fi\n \n cd $MUSL"}, {"sha": "6b8186048988d089a08c9e8bc8c4aa393c466f82", "filename": "src/ci/docker/x86_64-gnu-llvm-3.9/Dockerfile", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.9%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.9%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.9%2FDockerfile?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,27 +0,0 @@\n-FROM ubuntu:16.04\n-\n-RUN apt-get update && apt-get install -y --no-install-recommends \\\n-  g++ \\\n-  make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n-  python2.7 \\\n-  git \\\n-  cmake \\\n-  sudo \\\n-  gdb \\\n-  llvm-3.9-tools \\\n-  libedit-dev \\\n-  zlib1g-dev \\\n-  xz-utils\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-# using llvm-link-shared due to libffi issues -- see #34486\n-ENV RUST_CONFIGURE_ARGS \\\n-      --build=x86_64-unknown-linux-gnu \\\n-      --llvm-root=/usr/lib/llvm-3.9 \\\n-      --enable-llvm-link-shared\n-ENV RUST_CHECK_TARGET check"}, {"sha": "4f90c5097260ce153a595fe4151733934d26de2a", "filename": "src/ci/docker/x86_64-gnu-llvm-5.0/Dockerfile", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-5.0%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-5.0%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-5.0%2FDockerfile?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -0,0 +1,27 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  llvm-5.0-tools \\\n+  libedit-dev \\\n+  zlib1g-dev \\\n+  xz-utils\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+# using llvm-link-shared due to libffi issues -- see #34486\n+ENV RUST_CONFIGURE_ARGS \\\n+      --build=x86_64-unknown-linux-gnu \\\n+      --llvm-root=/usr/lib/llvm-5.0 \\\n+      --enable-llvm-link-shared\n+ENV RUST_CHECK_TARGET check"}, {"sha": "208aab434ce1fa84f289b5e0c044a4bda3afd0fc", "filename": "src/ci/docker/x86_64-gnu-tools/checkregression.py", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fcheckregression.py", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fcheckregression.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fcheckregression.py?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -18,6 +18,7 @@\n     os_name = sys.argv[1]\n     toolstate_file = sys.argv[2]\n     current_state = sys.argv[3]\n+    verb = sys.argv[4] # 'regressed' or 'changed'\n \n     with open(toolstate_file, 'r') as f:\n         toolstate = json.load(f)\n@@ -29,10 +30,17 @@\n         tool = cur['tool']\n         state = cur[os_name]\n         new_state = toolstate.get(tool, '')\n-        if new_state < state:\n+        if verb == 'regressed':\n+            updated = new_state < state\n+        elif verb == 'changed':\n+            updated = new_state != state\n+        else:\n+            print('Unknown verb {}'.format(updated))\n+            sys.exit(2)\n+        if updated:\n             print(\n-                'Error: The state of \"{}\" has regressed from \"{}\" to \"{}\"'\n-                .format(tool, state, new_state)\n+                'The state of \"{}\" has {} from \"{}\" to \"{}\"'\n+                .format(tool, verb, state, new_state)\n             )\n             regressed = True\n "}, {"sha": "16055078ad5eb1bec918b509971a513f7c218783", "filename": "src/ci/docker/x86_64-gnu-tools/checktools.sh", "status": "modified", "additions": 55, "deletions": 23, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -23,21 +23,25 @@ SIX_WEEK_CYCLE=\"$(( ($(date +%s) / 604800 - 3) % 6 ))\"\n \n touch \"$TOOLSTATE_FILE\"\n \n+# Try to test all the tools and store the build/test success in the TOOLSTATE_FILE\n+\n set +e\n python2.7 \"$X_PY\" test --no-fail-fast \\\n     src/doc/book \\\n     src/doc/nomicon \\\n     src/doc/reference \\\n     src/doc/rust-by-example \\\n+    src/tools/clippy \\\n     src/tools/rls \\\n     src/tools/rustfmt \\\n     src/tools/miri \\\n-    src/tools/clippy\n+\n set -e\n \n cat \"$TOOLSTATE_FILE\"\n echo\n \n+# This function checks that if a tool's submodule changed, the tool's state must improve\n verify_status() {\n     echo \"Verifying status of $1...\"\n     if echo \"$CHANGED_FILES\" | grep -q \"^M[[:blank:]]$2$\"; then\n@@ -57,35 +61,63 @@ verify_status() {\n     fi\n }\n \n+# deduplicates the submodule check and the assertion that on beta some tools MUST be passing\n+check_dispatch() {\n+    if [ \"$1\" = submodule_changed ]; then\n+        # ignore $2 (branch id)\n+        verify_status $3 $4\n+    elif [ \"$2\" = beta ]; then\n+        echo \"Requiring test passing for $3...\"\n+        if grep -q '\"'\"$3\"'\":\"\\(test\\|build\\)-fail\"' \"$TOOLSTATE_FILE\"; then\n+            exit 4\n+        fi\n+    fi\n+}\n+\n+# list all tools here\n+status_check() {\n+    check_dispatch $1 beta book src/doc/book\n+    check_dispatch $1 beta nomicon src/doc/nomicon\n+    check_dispatch $1 beta reference src/doc/reference\n+    check_dispatch $1 beta rust-by-example src/doc/rust-by-example\n+    check_dispatch $1 beta rls src/tools/rls\n+    check_dispatch $1 beta rustfmt src/tools/rustfmt\n+    check_dispatch $1 beta clippy-driver src/tools/clippy\n+    # these tools are not required for beta to successfully branch\n+    check_dispatch $1 nightly miri src/tools/miri\n+}\n+\n # If this PR is intended to update one of these tools, do not let the build pass\n # when they do not test-pass.\n \n-verify_status book src/doc/book\n-verify_status nomicon src/doc/nomicon\n-verify_status reference src/doc/reference\n-verify_status rust-by-example src/doc/rust-by-example\n-verify_status rls src/tool/rls\n-verify_status rustfmt src/tool/rustfmt\n-verify_status clippy-driver src/tool/clippy\n-verify_status miri src/tool/miri\n-\n-if [ \"$RUST_RELEASE_CHANNEL\" = nightly -a -n \"${TOOLSTATE_REPO_ACCESS_TOKEN+is_set}\" ]; then\n-    . \"$(dirname $0)/repo.sh\"\n-    MESSAGE_FILE=$(mktemp -t msg.XXXXXX)\n-    echo \"($OS CI update)\" > \"$MESSAGE_FILE\"\n-    commit_toolstate_change \"$MESSAGE_FILE\" \\\n+status_check \"submodule_changed\"\n+\n+CHECK_NOT=\"$(readlink -f \"$(dirname $0)/checkregression.py\")\"\n+change_toolstate() {\n+    # only update the history\n+    if python2.7 \"$CHECK_NOT\" \"$OS\" \"$TOOLSTATE_FILE\" \"_data/latest.json\" changed; then\n+        echo 'Toolstate is not changed. Not updating.'\n+    else\n+        if [ $SIX_WEEK_CYCLE -eq 5 ]; then\n+            python2.7 \"$CHECK_NOT\" \"$OS\" \"$TOOLSTATE_FILE\" \"_data/latest.json\" regressed\n+        fi\n         sed -i \"1 a\\\\\n $COMMIT\\t$(cat \"$TOOLSTATE_FILE\")\n \" \"history/$OS.tsv\"\n-    # if we are at the last week in the 6-week release cycle, reject any kind of regression.\n-    if [ $SIX_WEEK_CYCLE -eq 5 ]; then\n-        python2.7 \"$(dirname $0)/checkregression.py\" \\\n-            \"$OS\" \"$TOOLSTATE_FILE\" \"rust-toolstate/_data/latest.json\"\n     fi\n-    rm -f \"$MESSAGE_FILE\"\n+}\n+\n+if [ \"$RUST_RELEASE_CHANNEL\" = nightly ]; then\n+    if [ -n \"${TOOLSTATE_REPO_ACCESS_TOKEN+is_set}\" ]; then\n+        . \"$(dirname $0)/repo.sh\"\n+        MESSAGE_FILE=$(mktemp -t msg.XXXXXX)\n+        echo \"($OS CI update)\" > \"$MESSAGE_FILE\"\n+        commit_toolstate_change \"$MESSAGE_FILE\" change_toolstate\n+        rm -f \"$MESSAGE_FILE\"\n+    fi\n     exit 0\n fi\n \n-if grep -q fail \"$TOOLSTATE_FILE\"; then\n-    exit 4\n-fi\n+# abort compilation if an important tool doesn't build\n+# (this code is reachable if not on the nightly channel)\n+status_check \"beta_required\""}, {"sha": "807e6fb7b642e2d6b789ea7ef40aaf7c07633a88", "filename": "src/ci/docker/x86_64-gnu-tools/repo.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Frepo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Frepo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Frepo.sh?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -60,7 +60,7 @@ commit_toolstate_change() {\n     OLDFLAGS=\"$-\"\n     set -eu\n \n-    git config --global user.email '34210020+rust-toolstate-update@users.noreply.github.com'\n+    git config --global user.email '7378925+rust-toolstate-update@users.noreply.github.com'\n     git config --global user.name 'Rust Toolstate Update'\n     git config --global credential.helper store\n     printf 'https://%s:x-oauth-basic@github.com\\n' \"$TOOLSTATE_REPO_ACCESS_TOKEN\" \\"}, {"sha": "09a0cf3541d8dde8f7dc524db62af022933b2e5b", "filename": "src/ci/run.sh", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -24,13 +24,16 @@ if [ \"$NO_CHANGE_USER\" = \"\" ]; then\n   fi\n fi\n \n+# only enable core dump on Linux\n+if [ -f /proc/sys/kernel/core_pattern ]; then\n+  ulimit -c unlimited\n+fi\n+\n ci_dir=`cd $(dirname $0) && pwd`\n source \"$ci_dir/shared.sh\"\n \n-if [ \"$TRAVIS\" == \"true\" ] && [ \"$TRAVIS_BRANCH\" != \"auto\" ]; then\n-    RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-quiet-tests\"\n-else\n-    RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set build.print-step-timings\"\n+if [ \"$TRAVIS\" != \"true\" ] || [ \"$TRAVIS_BRANCH\" == \"auto\" ]; then\n+    RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set build.print-step-timings --enable-verbose-tests\"\n fi\n \n RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-sccache\""}, {"sha": "bb6945f0fd6bbb5b542778b466c532e8d3682c23", "filename": "src/ci/shared.sh", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fshared.sh", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fci%2Fshared.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fshared.sh?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -21,11 +21,12 @@ function retry {\n   while true; do\n     \"$@\" && break || {\n       if [[ $n -lt $max ]]; then\n+        sleep $n  # don't retry immediately\n         ((n++))\n         echo \"Command failed. Attempt $n/$max:\"\n       else\n         echo \"The command has failed after $n attempts.\"\n-        exit 1\n+        return 1\n       fi\n     }\n   done"}, {"sha": "f475da63a18d50217459a601cbef69a4bcac5e71", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -1 +1 @@\n-Subproject commit f51127530d46b9acbf4747c859da185e771cfcf3\n+Subproject commit f475da63a18d50217459a601cbef69a4bcac5e71"}, {"sha": "ee9135b6578f6071e7f43fbbe6f2214f1253dbf6", "filename": "src/doc/grammar.md", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -101,29 +101,24 @@ properties: `ident`, `non_null`, `non_eol`, `non_single_quote` and\n \n ### Identifiers\n \n-The `ident` production is any nonempty Unicode[^non_ascii_idents] string of\n+The `ident` production is any nonempty Unicode string of\n the following form:\n \n-[^non_ascii_idents]: Non-ASCII characters in identifiers are currently feature\n-  gated. This is expected to improve soon.\n+- The first character is in one of the following ranges `U+0041` to `U+005A`\n+(\"A\" to \"Z\"), `U+0061` to `U+007A` (\"a\" to \"z\"), or `U+005F` (\"\\_\").\n+- The remaining characters are in the range `U+0030` to `U+0039` (\"0\" to \"9\"),\n+or any of the prior valid initial characters.\n \n-- The first character has property `XID_start`\n-- The remaining characters have property `XID_continue`\n-\n-that does _not_ occur in the set of [keywords](#keywords).\n-\n-> **Note**: `XID_start` and `XID_continue` as character properties cover the\n-> character ranges used to form the more familiar C and Java language-family\n-> identifiers.\n+as long as the identifier does _not_ occur in the set of [keywords](#keywords).\n \n ### Delimiter-restricted productions\n \n Some productions are defined by exclusion of particular Unicode characters:\n \n - `non_null` is any single Unicode character aside from `U+0000` (null)\n-- `non_eol` is `non_null` restricted to exclude `U+000A` (`'\\n'`)\n-- `non_single_quote` is `non_null` restricted to exclude `U+0027`  (`'`)\n-- `non_double_quote` is `non_null` restricted to exclude `U+0022` (`\"`)\n+- `non_eol` is any single Unicode character aside from `U+000A` (`'\\n'`)\n+- `non_single_quote` is any single Unicode character aside from `U+0027`  (`'`)\n+- `non_double_quote` is any single Unicode character aside from `U+0022` (`\"`)\n \n ## Comments\n "}, {"sha": "8f611063dbe5d901a222b5fb45134965d0ab319e", "filename": "src/doc/man/rustc.1", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Fman%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Fman%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fman%2Frustc.1?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -55,7 +55,7 @@ Configure the output that \\fBrustc\\fR will produce. Each emission may also have\n an optional explicit output \\fIPATH\\fR specified for that particular emission\n kind. This path takes precedence over the \\fB-o\\fR option.\n .TP\n-\\fB\\-\\-print\\fR [crate\\-name|file\\-names|sysroot]\n+\\fB\\-\\-print\\fR [crate\\-name|\\:file\\-names|\\:sysroot|\\:cfg|\\:target\\-list|\\:target\\-cpus|\\:target\\-features|\\:relocation\\-models|\\:code\\-models|\\:tls\\-models|\\:target\\-spec\\-json|\\:native\\-static\\-libs]\n Comma separated list of compiler information to print on stdout.\n .TP\n \\fB\\-g\\fR"}, {"sha": "66ef7373409d1979c2839db8886ac2ec9b6a58cd", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -1 +1 @@\n-Subproject commit 748a5e6742db4a21c4c630a58087f818828e8a0a\n+Subproject commit 66ef7373409d1979c2839db8886ac2ec9b6a58cd"}, {"sha": "219e261ddb833a5683627b0a9be87a0f4486abb9", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -1 +1 @@\n-Subproject commit 134f419ee62714590b04712fe6072253bc2a7822\n+Subproject commit 219e261ddb833a5683627b0a9be87a0f4486abb9"}, {"sha": "d2a64395a5210a61d3512a3a5c615f5c47699443", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -1 +1 @@\n-Subproject commit eebda16e4b45f2eed4310cf7b9872cc752278163\n+Subproject commit d2a64395a5210a61d3512a3a5c615f5c47699443"}, {"sha": "93e94e5586302629d12e7299d87fa076b69e5a88", "filename": "src/doc/rustc-ux-guidelines.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Frustc-ux-guidelines.md", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Frustc-ux-guidelines.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-ux-guidelines.md?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -69,7 +69,7 @@ for details on how to format and write long error codes.\n   [librustc_passes](https://github.com/rust-lang/rust/blob/master/src/librustc_passes/diagnostics.rs),\n   [librustc_privacy](https://github.com/rust-lang/rust/blob/master/src/librustc_privacy/diagnostics.rs),\n   [librustc_resolve](https://github.com/rust-lang/rust/blob/master/src/librustc_resolve/diagnostics.rs),\n-  [librustc_trans](https://github.com/rust-lang/rust/blob/master/src/librustc_trans/diagnostics.rs),\n+  [librustc_codegen_llvm](https://github.com/rust-lang/rust/blob/master/src/librustc_codegen_llvm/diagnostics.rs),\n   [librustc_plugin](https://github.com/rust-lang/rust/blob/master/src/librustc_plugin/diagnostics.rs),\n   [librustc_typeck](https://github.com/rust-lang/rust/blob/master/src/librustc_typeck/diagnostics.rs).\n * Explanations have full markdown support. Use it, especially to highlight"}, {"sha": "7768b41f85ee44c7d906a06fc7d6bb84a7057f99", "filename": "src/doc/rustc/src/lints/listing/allowed-by-default.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -64,7 +64,7 @@ To fix it, do as the help message suggests:\n \n ```rust\n #![feature(dyn_trait)]\n-#![deny(bare_trait_object)]\n+#![deny(bare_trait_objects)]\n \n trait Trait { }\n "}, {"sha": "3a85a40fd1fdb9af606df8414f8289b4330949ee", "filename": "src/doc/rustc/src/lints/listing/deny-by-default.md", "status": "modified", "additions": 41, "deletions": 37, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -91,43 +91,6 @@ The legacy_directory_ownership warning is issued when\n The warning can be fixed by renaming the parent module to \"mod.rs\" and moving\n it into its own directory if appropriate.\n \n-## legacy-imports\n-\n-This lint detects names that resolve to ambiguous glob imports. Some example\n-code that triggers this lint:\n-\n-```rust,ignore\n-pub struct Foo;\n-\n-mod bar {\n-    struct Foo;\n-\n-    mod baz {\n-        use *;\n-        use bar::*;\n-        fn f(_: Foo) {}\n-    }\n-}\n-```\n-\n-This will produce:\n-\n-```text\n-error: `Foo` is ambiguous\n- --> src/main.rs:9:17\n-  |\n-7 |         use *;\n-  |             - `Foo` could refer to the name imported here\n-8 |         use bar::*;\n-  |             ------ `Foo` could also refer to the name imported here\n-9 |         fn f(_: Foo) {}\n-  |                 ^^^\n-  |\n-  = note: #[deny(legacy_imports)] on by default\n-  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-  = note: for more information, see issue #38260 <https://github.com/rust-lang/rust/issues/38260>\n-```\n-\n \n ## missing-fragment-specifier\n \n@@ -239,3 +202,44 @@ error: invalid `crate_type` value\n   | ^^^^^^^^^^^^^^^^^^^^\n   |\n ```\n+\n+## incoherent-fundamental-impls\n+\n+This lint detects potentially-conflicting impls that were erroneously allowed. Some\n+example code that triggers this lint:\n+\n+```rust,ignore\n+pub trait Trait1<X> {\n+    type Output;\n+}\n+\n+pub trait Trait2<X> {}\n+\n+pub struct A;\n+\n+impl<X, T> Trait1<X> for T where T: Trait2<X> {\n+    type Output = ();\n+}\n+\n+impl<X> Trait1<Box<X>> for A {\n+    type Output = i32;\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+error: conflicting implementations of trait `Trait1<std::boxed::Box<_>>` for type `A`: (E0119)\n+  --> src/main.rs:13:1\n+   |\n+9  | impl<X, T> Trait1<X> for T where T: Trait2<X> {\n+   | --------------------------------------------- first implementation here\n+...\n+13 | impl<X> Trait1<Box<X>> for A {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `A`\n+   |\n+   = note: #[deny(incoherent_fundamental_impls)] on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #46205 <https://github.com/rust-lang/rust/issues/46205>\n+   = note: downstream crates may implement trait `Trait2<std::boxed::Box<_>>` for type `A`\n+```"}, {"sha": "b49708ff6adcd2e11fb0276eb318904b22ba082c", "filename": "src/doc/rustc/src/lints/listing/warn-by-default.md", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -117,47 +117,6 @@ warning: found struct without foreign-function-safe representation annotation in\n   |\n ```\n \n-## incoherent-fundamental-impls\n-\n-This lint detects potentially-conflicting impls that were erroneously allowed. Some\n-example code that triggers this lint:\n-\n-```rust\n-pub trait Trait1<X> {\n-    type Output;\n-}\n-\n-pub trait Trait2<X> {}\n-\n-pub struct A;\n-\n-impl<X, T> Trait1<X> for T where T: Trait2<X> {\n-    type Output = ();\n-}\n-\n-impl<X> Trait1<Box<X>> for A {\n-    type Output = i32;\n-}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: conflicting implementations of trait `Trait1<std::boxed::Box<_>>` for type `A`: (E0119)\n-  --> src/main.rs:13:1\n-   |\n-9  | impl<X, T> Trait1<X> for T where T: Trait2<X> {\n-   | --------------------------------------------- first implementation here\n-...\n-13 | impl<X> Trait1<Box<X>> for A {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `A`\n-   |\n-   = note: #[warn(incoherent_fundamental_impls)] on by default\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46205 <https://github.com/rust-lang/rust/issues/46205>\n-   = note: downstream crates may implement trait `Trait2<std::boxed::Box<_>>` for type `A`\n-```\n-\n ## late-bound-lifetime-arguments\n \n This lint detects detects generic lifetime arguments in path segments with"}, {"sha": "e4af122d0cb98d55938994581144f0803faa0f33", "filename": "src/doc/rustdoc/src/documentation-tests.md", "status": "modified", "additions": 83, "deletions": 21, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -79,15 +79,17 @@ from your example, but are important to make the tests work. Consider\n an example block that looks like this:\n \n ```text\n-/// Some documentation.\n-# fn foo() {}\n+/// /// Some documentation.\n+/// # fn foo() {} // this function will be hidden\n+/// println!(\"Hello, World!\");\n ```\n \n It will render like this:\n \n ```rust\n /// Some documentation.\n # fn foo() {}\n+println!(\"Hello, World!\");\n ```\n \n Yes, that's right: you can add lines that start with `# `, and they will\n@@ -168,37 +170,73 @@ By repeating all parts of the example, you can ensure that your example still\n compiles, while only showing the parts that are relevant to that part of your\n explanation.\n \n-Another case where the use of `#` is handy is when you want to ignore\n-error handling. Lets say you want the following,\n+The `#`-hiding of lines can be prevented by using two consecutive hashes\n+`##`. This only needs to be done with with the first `#` which would've\n+otherwise caused hiding. If we have a string literal like the following,\n+which has a line that starts with a `#`:\n+\n+```rust\n+let s = \"foo\n+## bar # baz\";\n+```\n+\n+We can document it by escaping the initial `#`:\n+\n+```text\n+/// let s = \"foo\n+/// ## bar # baz\";\n+```\n+\n+\n+## Using `?` in doc tests\n+\n+When writing an example, it is rarely useful to include a complete error\n+handling, as it would add significant amounts of boilerplate code. Instead, you\n+may want the following:\n \n ```ignore\n+/// ```\n /// use std::io;\n /// let mut input = String::new();\n /// io::stdin().read_line(&mut input)?;\n+/// ```\n ```\n \n-The problem is that `?` returns a `Result<T, E>` and test functions\n-don't return anything so this will give a mismatched types error.\n+The problem is that `?` returns a `Result<T, E>` and test functions don't\n+return anything, so this will give a mismatched types error.\n+\n+You can get around this limitation by manually adding a `main` that returns\n+`Result<T, E>`, because `Result<T, E>` implements the `Termination` trait:\n \n ```ignore\n /// A doc test using ?\n ///\n /// ```\n /// use std::io;\n-/// # fn foo() -> io::Result<()> {\n+///\n+/// fn main() -> io::Result<()> {\n+///     let mut input = String::new();\n+///     io::stdin().read_line(&mut input)?;\n+///     Ok(())\n+/// }\n+/// ```\n+```\n+\n+Together with the `# ` from the section above, you arrive at a solution that\n+appears to the reader as the initial idea but works with doc tests:\n+\n+```ignore\n+/// ```\n+/// use std::io;\n+/// # fn main() -> io::Result<()> {\n /// let mut input = String::new();\n /// io::stdin().read_line(&mut input)?;\n /// # Ok(())\n /// # }\n /// ```\n-# fn foo() {}\n ```\n \n-You can get around this by wrapping the code in a function. This catches\n-and swallows the `Result<T, E>` when running tests on the docs. This\n-pattern appears regularly in the standard library.\n-\n-### Documenting macros\n+## Documenting macros\n \n Here\u2019s an example of documenting a macro:\n \n@@ -268,10 +306,10 @@ not actually pass as a test.\n # fn foo() {}\n ```\n \n-`compile_fail` tells `rustdoc` that the compilation should fail. If it\n-compiles, then the test will fail. However please note that code failing\n-with the current Rust release may work in a future release, as new features\n-are added.\n+The `no_run` attribute will compile your code, but not run it. This is\n+important for examples such as \"Here's how to retrieve a web page,\"\n+which you would want to ensure compiles, but might be run in a test\n+environment that has no network access.\n \n ```text\n /// ```compile_fail\n@@ -280,7 +318,31 @@ are added.\n /// ```\n ```\n \n-The `no_run` attribute will compile your code, but not run it. This is\n-important for examples such as \"Here's how to retrieve a web page,\"\n-which you would want to ensure compiles, but might be run in a test\n-environment that has no network access.\n+`compile_fail` tells `rustdoc` that the compilation should fail. If it\n+compiles, then the test will fail. However please note that code failing\n+with the current Rust release may work in a future release, as new features\n+are added.\n+\n+## Syntax reference\n+\n+The *exact* syntax for code blocks, including the edge cases, can be found\n+in the [Fenced Code Blocks](https://spec.commonmark.org/0.28/#fenced-code-blocks)\n+section of the CommonMark specification.\n+\n+Rustdoc also accepts *indented* code blocks as an alternative to fenced\n+code blocks: instead of surrounding your code with three backticks, you\n+can indent each line by four or more spaces.\n+\n+``````markdown\n+    let foo = \"foo\";\n+    assert_eq!(foo, \"foo\");\n+``````\n+\n+These, too, are documented in the CommonMark specification, in the\n+[Indented Code Blocks](https://spec.commonmark.org/0.28/#indented-code-blocks)\n+section.\n+\n+However, it's preferable to use fenced code blocks over indented code blocks.\n+Not only are fenced code blocks considered more idiomatic for Rust code,\n+but there is no way to use directives such as `ignore` or `should_panic` with\n+indented code blocks."}, {"sha": "615b3dca199f1cc218a426b49b1bfd2e74d40435", "filename": "src/doc/rustdoc/src/passes.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Frustdoc%2Fsrc%2Fpasses.md", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Frustdoc%2Fsrc%2Fpasses.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fpasses.md?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -5,8 +5,8 @@ Rustdoc has a concept called \"passes\". These are transformations that\n \n In addition to the passes below, check out the docs for these flags:\n \n-* [`--passes`](command-line-arguments.html#--passes-add-more-rustdoc-passes)\n-* [`--no-defaults`](command-line-arguments.html#--no-defaults-dont-run-default-passes)\n+* [`--passes`](command-line-arguments.html#a--passes-add-more-rustdoc-passes)\n+* [`--no-defaults`](command-line-arguments.html#a--no-defaults-dont-run-default-passes)\n \n ## Default passes\n "}, {"sha": "320283f31b51feb3e3fd24a632195fcb42a5181a", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -1,3 +1,3 @@\n % The Rust Tutorial\n \n-This tutorial has been deprecated in favor of [the Book](book/index.html). Go check that out instead!\n+This tutorial has been deprecated in favor of [the Book](book/index.html), which is available free online and in dead tree form. Go check that out instead!"}, {"sha": "414dc48e557d3ec3f391fbb7bd288c19a88a33e4", "filename": "src/doc/unstable-book/src/language-features/box-syntax.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fbox-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fbox-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fbox-syntax.md?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -1,8 +1,8 @@\n # `box_syntax`\n \n-The tracking issue for this feature is: [#27779]\n+The tracking issue for this feature is: [#49733]\n \n-[#27779]: https://github.com/rust-lang/rust/issues/27779\n+[#49733]: https://github.com/rust-lang/rust/issues/49733\n \n See also [`box_patterns`](language-features/box-patterns.html)\n "}, {"sha": "8f1ba22de8cb1f0b4726fd05b660cd431608a8ab", "filename": "src/doc/unstable-book/src/language-features/global-allocator.md", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,72 +0,0 @@\n-# `global_allocator`\n-\n-The tracking issue for this feature is: [#27389]\n-\n-[#27389]: https://github.com/rust-lang/rust/issues/27389\n-\n-------------------------\n-\n-Rust programs may need to change the allocator that they're running with from\n-time to time. This use case is distinct from an allocator-per-collection (e.g. a\n-`Vec` with a custom allocator) and instead is more related to changing the\n-global default allocator, e.g. what `Vec<T>` uses by default.\n-\n-Currently Rust programs don't have a specified global allocator. The compiler\n-may link to a version of [jemalloc] on some platforms, but this is not\n-guaranteed. Libraries, however, like cdylibs and staticlibs are guaranteed\n-to use the \"system allocator\" which means something like `malloc` on Unixes and\n-`HeapAlloc` on Windows.\n-\n-[jemalloc]: https://github.com/jemalloc/jemalloc\n-\n-The `#[global_allocator]` attribute, however, allows configuring this choice.\n-You can use this to implement a completely custom global allocator to route all\n-default allocation requests to a custom object. Defined in [RFC 1974] usage\n-looks like:\n-\n-[RFC 1974]: https://github.com/rust-lang/rfcs/pull/1974\n-\n-```rust\n-#![feature(global_allocator, allocator_api, heap_api)]\n-\n-use std::alloc::{GlobalAlloc, System, Layout, Opaque};\n-use std::ptr::NonNull;\n-\n-struct MyAllocator;\n-\n-unsafe impl GlobalAlloc for MyAllocator {\n-    unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n-        System.alloc(layout)\n-    }\n-\n-    unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n-        System.dealloc(ptr, layout)\n-    }\n-}\n-\n-#[global_allocator]\n-static GLOBAL: MyAllocator = MyAllocator;\n-\n-fn main() {\n-    // This `Vec` will allocate memory through `GLOBAL` above\n-    let mut v = Vec::new();\n-    v.push(1);\n-}\n-```\n-\n-And that's it! The `#[global_allocator]` attribute is applied to a `static`\n-which implements the `Alloc` trait in the `std::alloc` module. Note, though,\n-that the implementation is defined for `&MyAllocator`, not just `MyAllocator`.\n-You may wish, however, to also provide `Alloc for MyAllocator` for other use\n-cases.\n-\n-A crate can only have one instance of `#[global_allocator]` and this instance\n-may be loaded through a dependency. For example `#[global_allocator]` above\n-could have been placed in one of the dependencies loaded through `extern crate`.\n-\n-Note that `Alloc` itself is an `unsafe` trait, with much documentation on the\n-trait itself about usage and for implementors. Extra care should be taken when\n-implementing a global allocator as well as the allocator may be called from many\n-portions of the standard library, such as the panicking routine. As a result it\n-is highly recommended to not panic during allocation and work in as many\n-situations with as few dependencies as possible as well."}, {"sha": "73c7eafdb98d583b24f65201714e3ba07d5babb0", "filename": "src/doc/unstable-book/src/language-features/infer-outlives-requirements.md", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finfer-outlives-requirements.md", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finfer-outlives-requirements.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finfer-outlives-requirements.md?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -0,0 +1,67 @@\n+# `infer_outlives_requirements`\n+\n+The tracking issue for this feature is: [#44493]\n+\n+[#44493]: https://github.com/rust-lang/rust/issues/44493\n+\n+------------------------\n+The `infer_outlives_requirements` feature indicates that certain\n+outlives requirements can be infered by the compiler rather than\n+stating them explicitly.\n+\n+For example, currently generic struct definitions that contain\n+references, require where-clauses of the form T: 'a. By using\n+this feature the outlives predicates will be infered, although\n+they may still be written explicitly.\n+\n+```rust,ignore (pseudo-Rust)\n+struct Foo<'a, T>\n+  where T: 'a // <-- currently required\n+  {\n+      bar: &'a T,\n+  }\n+```\n+\n+\n+## Examples:\n+\n+\n+```rust,ignore (pseudo-Rust)\n+#![feature(infer_outlives_requirements)]\n+\n+// Implicitly infer T: 'a\n+struct Foo<'a, T> {\n+    bar: &'a T,\n+}\n+```\n+\n+```rust,ignore (pseudo-Rust)\n+#![feature(infer_outlives_requirements)]\n+\n+// Implicitly infer `U: 'b`\n+struct Foo<'b, U> {\n+    bar: Bar<'b, U>\n+}\n+\n+struct Bar<'a, T> where T: 'a {\n+    x: &'a (),\n+    y: T,\n+}\n+```\n+\n+```rust,ignore (pseudo-Rust)\n+#![feature(infer_outlives_requirements)]\n+\n+// Implicitly infer `b': 'a`\n+struct Foo<'a, 'b, T> {\n+    x: &'a &'b T\n+}\n+```\n+\n+```rust,ignore (pseudo-Rust)\n+#![feature(infer_outlives_requirements)]\n+\n+// Implicitly infer `<T as std::iter::Iterator>::Item : 'a`\n+struct Foo<'a, T: Iterator> {\n+    bar: &'a T::Item\n+```"}, {"sha": "f50472fb41e31128d1dcb1da186dc66516ecd35f", "filename": "src/doc/unstable-book/src/language-features/infer-static-outlives-requirements.md", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finfer-static-outlives-requirements.md", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finfer-static-outlives-requirements.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finfer-static-outlives-requirements.md?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -0,0 +1,45 @@\n+# `infer_static_outlives_requirements`\n+\n+The tracking issue for this feature is: [#44493]\n+\n+[#44493]: https://github.com/rust-lang/rust/issues/44493\n+\n+------------------------\n+The `infer_static_outlives_requirements` feature indicates that certain\n+`'static` outlives requirements can be infered by the compiler rather than\n+stating them explicitly.\n+\n+Note: It is an accompanying feature to `infer_outlives_requirements`,\n+which must be enabled to infer outlives requirements.\n+\n+For example, currently generic struct definitions that contain\n+references, require where-clauses of the form T: 'static. By using\n+this feature the outlives predicates will be infered, although\n+they may still be written explicitly.\n+\n+```rust,ignore (pseudo-Rust)\n+struct Foo<U> where U: 'static { // <-- currently required\n+    bar: Bar<U>\n+}\n+struct Bar<T: 'static> {\n+    x: T,\n+}\n+```\n+\n+\n+## Examples:\n+\n+```rust,ignore (pseudo-Rust)\n+#![feature(infer_outlives_requirements)]\n+#![feature(infer_static_outlives_requirements)]\n+\n+#[rustc_outlives]\n+// Implicitly infer U: 'static\n+struct Foo<U> {\n+    bar: Bar<U>\n+}\n+struct Bar<T: 'static> {\n+    x: T,\n+}\n+```\n+"}, {"sha": "46b843778e81077967d1864514553eb31d7696c5", "filename": "src/doc/unstable-book/src/language-features/irrefutable-let-patterns.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Firrefutable-let-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Firrefutable-let-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Firrefutable-let-patterns.md?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -0,0 +1,28 @@\n+# `irrefutable_let_patterns`\n+\n+The tracking issue for this feature is: [#44495]\n+\n+[#44495]: https://github.com/rust-lang/rust/issues/44495\n+\n+------------------------\n+\n+This feature changes the way that \"irrefutable patterns\" are handled\n+in the `if let` and `while let` forms. An *irrefutable pattern* is one\n+that cannot fail to match -- for example, the `_` pattern matches any\n+value, and hence it is \"irrefutable\". Without this feature, using an\n+irrefutable pattern in an `if let` gives a hard error (since often\n+this indicates programmer error). But when the feature is enabled, the\n+error becomes a lint (since in some cases irrefutable patterns are\n+expected). This means you can use `#[allow]` to silence the lint:\n+\n+```rust\n+#![feature(irrefutable_let_patterns)]\n+\n+#[allow(irrefutable_let_patterns)]\n+fn main() {\n+    // These two examples used to be errors, but now they\n+    // trigger a lint (that is allowed):\n+    if let _ = 5 {}\n+    while let _ = 5 { break; }\n+}\n+```"}, {"sha": "bac619fd4a30d2c17e50d45415d55d1ef42600d6", "filename": "src/doc/unstable-book/src/language-features/lang-items.md", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -19,6 +19,7 @@ sugar for dynamic allocations via `malloc` and `free`:\n #![feature(lang_items, box_syntax, start, libc, core_intrinsics)]\n #![no_std]\n use core::intrinsics;\n+use core::panic::PanicInfo;\n \n extern crate libc;\n \n@@ -50,7 +51,7 @@ fn main(_argc: isize, _argv: *const *const u8) -> isize {\n }\n \n #[lang = \"eh_personality\"] extern fn rust_eh_personality() {}\n-#[lang = \"panic_fmt\"] extern fn rust_begin_panic() -> ! { unsafe { intrinsics::abort() } }\n+#[lang = \"panic_impl\"] extern fn rust_begin_panic(info: &PanicInfo) -> ! { unsafe { intrinsics::abort() } }\n #[lang = \"eh_unwind_resume\"] extern fn rust_eh_unwind_resume() {}\n #[no_mangle] pub extern fn rust_eh_register_frames () {}\n #[no_mangle] pub extern fn rust_eh_unregister_frames () {}\n@@ -110,6 +111,7 @@ in the same format as C:\n #![feature(start)]\n #![no_std]\n use core::intrinsics;\n+use core::panic::PanicInfo;\n \n // Pull in the system libc library for what crt0.o likely requires.\n extern crate libc;\n@@ -134,12 +136,9 @@ pub extern fn rust_eh_personality() {\n pub extern fn rust_eh_unwind_resume() {\n }\n \n-#[lang = \"panic_fmt\"]\n+#[lang = \"panic_impl\"]\n #[no_mangle]\n-pub extern fn rust_begin_panic(_msg: core::fmt::Arguments,\n-                               _file: &'static str,\n-                               _line: u32,\n-                               _column: u32) -> ! {\n+pub extern fn rust_begin_panic(info: &PanicInfo) -> ! {\n     unsafe { intrinsics::abort() }\n }\n ```\n@@ -155,6 +154,7 @@ compiler's name mangling too:\n #![no_std]\n #![no_main]\n use core::intrinsics;\n+use core::panic::PanicInfo;\n \n // Pull in the system libc library for what crt0.o likely requires.\n extern crate libc;\n@@ -179,12 +179,9 @@ pub extern fn rust_eh_personality() {\n pub extern fn rust_eh_unwind_resume() {\n }\n \n-#[lang = \"panic_fmt\"]\n+#[lang = \"panic_impl\"]\n #[no_mangle]\n-pub extern fn rust_begin_panic(_msg: core::fmt::Arguments,\n-                               _file: &'static str,\n-                               _line: u32,\n-                               _column: u32) -> ! {\n+pub extern fn rust_begin_panic(info: &PanicInfo) -> ! {\n     unsafe { intrinsics::abort() }\n }\n ```\n@@ -215,7 +212,7 @@ called. The language item's name is `eh_personality`.\n \n The second function, `rust_begin_panic`, is also used by the failure mechanisms of the\n compiler. When a panic happens, this controls the message that's displayed on\n-the screen. While the language item's name is `panic_fmt`, the symbol name is\n+the screen. While the language item's name is `panic_impl`, the symbol name is\n `rust_begin_panic`.\n \n A third function, `rust_eh_unwind_resume`, is also needed if the `custom_unwind_resume`\n@@ -259,8 +256,8 @@ the source code.\n   - `msvc_try_filter`: `libpanic_unwind/seh.rs` (SEH)\n   - `panic`: `libcore/panicking.rs`\n   - `panic_bounds_check`: `libcore/panicking.rs`\n-  - `panic_fmt`: `libcore/panicking.rs`\n-  - `panic_fmt`: `libstd/panicking.rs`\n+  - `panic_impl`: `libcore/panicking.rs`\n+  - `panic_impl`: `libstd/panicking.rs`\n - Allocations\n   - `owned_box`: `liballoc/boxed.rs`\n   - `exchange_malloc`: `liballoc/heap.rs`"}, {"sha": "251fc7209122c8e0d3df4c36c2219a61c713a8a5", "filename": "src/doc/unstable-book/src/language-features/macro-at-most-once-rep.md", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-at-most-once-rep.md", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-at-most-once-rep.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-at-most-once-rep.md?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -1,13 +1,15 @@\n # `macro_at_most_once_rep`\n \n-The tracking issue for this feature is: TODO(mark-i-m)\n+NOTE: This feature is only available in the 2018 Edition.\n+\n+The tracking issue for this feature is: #48075\n \n With this feature gate enabled, one can use `?` as a Kleene operator meaning \"0\n or 1 repetitions\" in a macro definition. Previously only `+` and `*` were allowed.\n \n For example:\n \n-```rust\n+```rust,ignore\n #![feature(macro_at_most_once_rep)]\n \n macro_rules! foo {"}, {"sha": "5b585d7f041d25877b2bd339cb01e7100f9413c3", "filename": "src/doc/unstable-book/src/language-features/macro-lifetime-matcher.md", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-lifetime-matcher.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-lifetime-matcher.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-lifetime-matcher.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,14 +0,0 @@\n-# `macro_lifetime_matcher`\n-\n-The tracking issue for this feature is: [#46895]\n-\n-With this feature gate enabled, the [list of fragment specifiers][frags] gains one more entry:\n-\n-* `lifetime`: a lifetime. Examples: 'static, 'a.\n-\n-A `lifetime` variable may be followed by anything.\n-\n-[#46895]: https://github.com/rust-lang/rust/issues/46895\n-[frags]: ../book/first-edition/macros.html#syntactic-requirements\n-\n-------------------------"}, {"sha": "7e3638fd1cf4c1d1362320d0efcab2323491a341", "filename": "src/doc/unstable-book/src/language-features/macro-literal-matcher.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-literal-matcher.md", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-literal-matcher.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-literal-matcher.md?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -0,0 +1,17 @@\n+# `macro_literal_matcher`\n+\n+The tracking issue for this feature is: [#35625]\n+\n+The RFC is: [rfc#1576].\n+\n+With this feature gate enabled, the [list of fragment specifiers][frags] gains one more entry:\n+\n+* `literal`: a literal. Examples: 2, \"string\", 'c'\n+\n+A `literal` may be followed by anything, similarly to the `ident` specifier.\n+\n+[rfc#1576]: http://rust-lang.github.io/rfcs/1576-macros-literal-matcher.html\n+[#35625]: https://github.com/rust-lang/rust/issues/35625\n+[frags]: ../book/first-edition/macros.html#syntactic-requirements\n+\n+------------------------"}, {"sha": "19ece09509078d450c11f6a1efe0f09d12900139", "filename": "src/doc/unstable-book/src/language-features/plugin.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -183,6 +183,8 @@ that warns about any item named `lintme`.\n ```rust,ignore\n #![feature(plugin_registrar)]\n #![feature(box_syntax, rustc_private)]\n+#![feature(macro_vis_matcher)]\n+#![feature(macro_at_most_once_rep)]\n \n extern crate syntax;\n \n@@ -208,7 +210,7 @@ impl LintPass for Pass {\n \n impl EarlyLintPass for Pass {\n     fn check_item(&mut self, cx: &EarlyContext, it: &ast::Item) {\n-        if it.ident.name.as_str() == \"lintme\" {\n+        if it.ident.as_str() == \"lintme\" {\n             cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n         }\n     }"}, {"sha": "1bd8c41629eea01712d001f940d2e797ee47138f", "filename": "src/doc/unstable-book/src/language-features/proc-macro.md", "status": "removed", "additions": 0, "deletions": 241, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fproc-macro.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fproc-macro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fproc-macro.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,241 +0,0 @@\n-# `proc_macro`\n-\n-The tracking issue for this feature is: [#38356]\n-\n-[#38356]: https://github.com/rust-lang/rust/issues/38356\n-\n-------------------------\n-\n-This feature flag guards the new procedural macro features as laid out by [RFC 1566], which alongside the now-stable \n-[custom derives], provide stabilizable alternatives to the compiler plugin API (which requires the use of \n-perma-unstable internal APIs) for programmatically modifying Rust code at compile-time.\n-\n-The two new procedural macro kinds are:\n- \n-* Function-like procedural macros which are invoked like regular declarative macros, and:\n-\n-* Attribute-like procedural macros which can be applied to any item which built-in attributes can\n-be applied to, and which can take arguments in their invocation as well.\n-\n-Additionally, this feature flag implicitly enables the [`use_extern_macros`](language-features/use-extern-macros.html) feature,\n-which allows macros to be imported like any other item with `use` statements, as compared to \n-applying `#[macro_use]` to an `extern crate` declaration. It is important to note that procedural macros may\n-**only** be imported in this manner, and will throw an error otherwise.\n-\n-You **must** declare the `proc_macro` feature in both the crate declaring these new procedural macro kinds as well as \n-in any crates that use them.\n-\n-### Common Concepts\n-\n-As with custom derives, procedural macros may only be declared in crates of the `proc-macro` type, and must be public\n-functions. No other public items may be declared in `proc-macro` crates, but private items are fine.\n-\n-To declare your crate as a `proc-macro` crate, simply add:\n-\n-```toml\n-[lib]\n-proc-macro = true\n-```\n-\n-to your `Cargo.toml`. \n-\n-Unlike custom derives, however, the name of the function implementing the procedural macro is used directly as the \n-procedural macro's name, so choose carefully.\n-\n-Additionally, both new kinds of procedural macros return a `TokenStream` which *wholly* replaces the original \n-invocation and its input.\n-\n-#### Importing\n-\n-As referenced above, the new procedural macros are not meant to be imported via `#[macro_use]` and will throw an \n-error if they are. Instead, they are meant to be imported like any other item in Rust, with `use` statements:\n-\n-```rust,ignore\n-#![feature(proc_macro)]\n-\n-// Where `my_proc_macros` is some crate of type `proc_macro`\n-extern crate my_proc_macros;\n-\n-// And declares a `#[proc_macro] pub fn my_bang_macro()` at its root.\n-use my_proc_macros::my_bang_macro;\n-\n-fn main() {\n-    println!(\"{}\", my_bang_macro!());\n-}\n-```\n-\n-#### Error Reporting\n-\n-Any panics in a procedural macro implementation will be caught by the compiler and turned into an error message pointing \n-to the problematic invocation. Thus, it is important to make your panic messages as informative as possible: use \n-`Option::expect` instead of `Option::unwrap` and `Result::expect` instead of `Result::unwrap`, and inform the user of \n-the error condition as unambiguously as you can.\n- \n-#### `TokenStream`\n-\n-The `proc_macro::TokenStream` type is hardcoded into the signatures of procedural macro functions for both input and \n-output. It is a wrapper around the compiler's internal representation for a given chunk of Rust code.\n-\n-### Function-like Procedural Macros\n-\n-These are procedural macros that are invoked like regular declarative macros. They are declared as public functions in \n-crates of the `proc_macro` type and using the `#[proc_macro]` attribute. The name of the declared function becomes the \n-name of the macro as it is to be imported and used. The function must be of the kind `fn(TokenStream) -> TokenStream` \n-where the sole argument is the input to the macro and the return type is the macro's output.\n-\n-This kind of macro can expand to anything that is valid for the context it is invoked in, including expressions and\n-statements, as well as items.\n-\n-**Note**: invocations of this kind of macro require a wrapping `[]`, `{}` or `()` like regular macros, but these do not \n-appear in the input, only the tokens between them. The tokens between the braces do not need to be valid Rust syntax.\n-\n-<span class=\"filename\">my_macro_crate/src/lib.rs</span>\n-\n-```rust,ignore\n-#![feature(proc_macro)]\n-\n-// This is always necessary to get the `TokenStream` typedef.\n-extern crate proc_macro;\n-\n-use proc_macro::TokenStream;\n-\n-#[proc_macro]\n-pub fn say_hello(_input: TokenStream) -> TokenStream {\n-    // This macro will accept any input because it ignores it. \n-    // To enforce correctness in macros which don't take input,\n-    // you may want to add `assert!(_input.to_string().is_empty());`.\n-    \"println!(\\\"Hello, world!\\\")\".parse().unwrap()\n-}\n-```\n-\n-<span class=\"filename\">my_macro_user/Cargo.toml</span>\n-\n-```toml\n-[dependencies]\n-my_macro_crate = { path = \"<relative path to my_macro_crate>\" }\n-```\n-\n-<span class=\"filename\">my_macro_user/src/lib.rs</span>\n-\n-```rust,ignore\n-#![feature(proc_macro)]\n-\n-extern crate my_macro_crate;\n-\n-use my_macro_crate::say_hello;\n-\n-fn main() {\n-    say_hello!();\n-}\n-```\n-\n-As expected, this prints `Hello, world!`.\n-\n-### Attribute-like Procedural Macros\n-\n-These are arguably the most powerful flavor of procedural macro as they can be applied anywhere attributes are allowed. \n-\n-They are declared as public functions in crates of the `proc-macro` type, using the `#[proc_macro_attribute]` attribute. \n-The name of the function becomes the name of the attribute as it is to be imported and used. The function must be of the \n-kind `fn(TokenStream, TokenStream) -> TokenStream` where:\n-\n-The first argument represents any metadata for the attribute (see [the reference chapter on attributes][refr-attr]). \n-Only the metadata itself will appear in this argument, for example:\n- \n- * `#[my_macro]` will get an empty string.\n- * `#[my_macro = \"string\"]` will get `= \"string\"`.\n- * `#[my_macro(ident)]` will get `(ident)`.\n- * etc.\n- \n-The second argument is the item that the attribute is applied to. It can be a function, a type definition, \n-an impl block, an `extern` block, or a module\u2014attribute invocations can take the inner form (`#![my_attr]`) \n-or outer form (`#[my_attr]`).\n-\n-The return type is the output of the macro which *wholly* replaces the item it was applied to. Thus, if your intention\n-is to merely modify an item, it *must* be copied to the output. The output must be an item; expressions, statements\n-and bare blocks are not allowed.\n-\n-There is no restriction on how many items an attribute-like procedural macro can emit as long as they are valid in \n-the given context.\n-\n-<span class=\"filename\">my_macro_crate/src/lib.rs</span>\n-\n-```rust,ignore\n-#![feature(proc_macro)]\n-\n-extern crate proc_macro;\n-\n-use proc_macro::TokenStream;\n-\n-/// Adds a `/// ### Panics` docstring to the end of the input's documentation\n-///\n-/// Does not assert that its receiver is a function or method.\n-#[proc_macro_attribute]\n-pub fn panics_note(args: TokenStream, input: TokenStream) -> TokenStream {\n-    let args = args.to_string();\n-    let mut input = input.to_string();\n-\n-    assert!(args.starts_with(\"= \\\"\"), \"`#[panics_note]` requires an argument of the form \\\n-                                       `#[panics_note = \\\"panic note here\\\"]`\");\n-\n-    // Get just the bare note string\n-    let panics_note = args.trim_matches(&['=', ' ', '\"'][..]);\n-\n-    // The input will include all docstrings regardless of where the attribute is placed,\n-    // so we need to find the last index before the start of the item\n-    let insert_idx = idx_after_last_docstring(&input);\n-\n-    // And insert our `### Panics` note there so it always appears at the end of an item's docs\n-    input.insert_str(insert_idx, &format!(\"/// # Panics \\n/// {}\\n\", panics_note));\n-\n-    input.parse().unwrap()\n-}\n-\n-// `proc-macro` crates can contain any kind of private item still\n-fn idx_after_last_docstring(input: &str) -> usize {\n-    // Skip docstring lines to find the start of the item proper\n-    input.lines().skip_while(|line| line.trim_left().starts_with(\"///\")).next()\n-        // Find the index of the first non-docstring line in the input\n-        // Note: assumes this exact line is unique in the input\n-        .and_then(|line_after| input.find(line_after))\n-        // No docstrings in the input\n-        .unwrap_or(0)\n-}\n-```\n-\n-<span class=\"filename\">my_macro_user/Cargo.toml</span>\n-\n-```toml\n-[dependencies]\n-my_macro_crate = { path = \"<relative path to my_macro_crate>\" }\n-```\n-\n-<span class=\"filename\">my_macro_user/src/lib.rs</span>\n-\n-```rust,ignore\n-#![feature(proc_macro)]\n-\n-extern crate my_macro_crate;\n-\n-use my_macro_crate::panics_note;\n-\n-/// Do the `foo` thing.\n-#[panics_note = \"Always.\"]\n-pub fn foo() {\n-    panic!()\n-}\n-```\n-\n-Then the rendered documentation for `pub fn foo` will look like this:\n-\n-> `pub fn foo()`\n-> \n-> ----\n-> Do the `foo` thing.\n-> # Panics\n-> Always.\n-\n-[RFC 1566]: https://github.com/rust-lang/rfcs/blob/master/text/1566-proc-macros.md\n-[custom derives]: https://doc.rust-lang.org/book/procedural-macros.html\n-[rust-lang/rust#41430]: https://github.com/rust-lang/rust/issues/41430\n-[refr-attr]: https://doc.rust-lang.org/reference/attributes.html"}, {"sha": "62202dc96fd4620e2ce53da7df0dfc40de26978a", "filename": "src/doc/unstable-book/src/language-features/repr-transparent.md", "status": "removed", "additions": 0, "deletions": 176, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-transparent.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-transparent.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-transparent.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,176 +0,0 @@\n-# `repr_transparent`\n-\n-The tracking issue for this feature is: [#43036]\n-\n-[#43036]: https://github.com/rust-lang/rust/issues/43036\n-\n-------------------------\n-\n-This feature enables the `repr(transparent)` attribute on structs, which enables\n-the use of newtypes without the usual ABI implications of wrapping the value in\n-a struct.\n-\n-## Background\n-\n-It's sometimes useful to add additional type safety by introducing *newtypes*.\n-For example, code that handles numeric quantities in different units such as\n-millimeters, centimeters, grams, kilograms, etc. may want to use the type system\n-to rule out mistakes such as adding millimeters to grams:\n-\n-```rust\n-use std::ops::Add;\n-\n-struct Millimeters(f64);\n-struct Grams(f64);\n-\n-impl Add<Millimeters> for Millimeters {\n-    type Output = Millimeters;\n-\n-    fn add(self, other: Millimeters) -> Millimeters {\n-        Millimeters(self.0 + other.0)\n-    }\n-}\n-\n-// Likewise: impl Add<Grams> for Grams {}\n-```\n-\n-Other uses of newtypes include using `PhantomData` to add lifetimes to raw\n-pointers or to implement the \"phantom types\" pattern. See the [PhantomData]\n-documentation and [the Nomicon][nomicon-phantom] for more details.\n-\n-The added type safety is especially useful when interacting with C or other\n-languages. However, in those cases we need to ensure the newtypes we add do not\n-introduce incompatibilities with the C ABI.\n-\n-## Newtypes in FFI\n-\n-Luckily, `repr(C)` newtypes are laid out just like the type they wrap on all\n-platforms which Rust currently supports, and likely on many more. For example,\n-consider this C declaration:\n-\n-```C\n-struct Object {\n-    double weight; //< in grams\n-    double height; //< in millimeters\n-    // ...\n-}\n-\n-void frobnicate(struct Object *);\n-```\n-\n-While using this C code from Rust, we could add `repr(C)` to the `Grams` and\n-`Millimeters` newtypes introduced above and use them to add some type safety\n-while staying compatible with the memory layout of `Object`:\n-\n-```rust,no_run\n-#[repr(C)]\n-struct Grams(f64);\n-\n-#[repr(C)]\n-struct Millimeters(f64);\n-\n-#[repr(C)]\n-struct Object {\n-    weight: Grams,\n-    height: Millimeters,\n-    // ...\n-}\n-\n-extern {\n-    fn frobnicate(_: *mut Object);\n-}\n-```\n-\n-This works even when adding some `PhantomData` fields, because they are\n-zero-sized and therefore don't have to affect the memory layout.\n-\n-However, there's more to the ABI than just memory layout: there's also the\n-question of how function call arguments and return values are passed. Many\n-common ABI treat a struct containing a single field differently from that field\n-itself, at least when the field is a scalar (e.g., integer or float or pointer).\n-\n-To continue the above example, suppose the C library also exposes a function\n-like this:\n-\n-```C\n-double calculate_weight(double height);\n-```\n-\n-Using our newtypes on the Rust side like this will cause an ABI mismatch on many\n-platforms:\n-\n-```rust,ignore\n-extern {\n-    fn calculate_weight(height: Millimeters) -> Grams;\n-}\n-```\n-\n-For example, on x86_64 Linux, Rust will pass the argument in an integer\n-register, while the C function expects the argument to be in a floating-point\n-register. Likewise, the C function will return the result in a floating-point\n-register while Rust will expect it in an integer register.\n-\n-Note that this problem is not specific to floats: To give another example,\n-32-bit x86 linux will pass and return `struct Foo(i32);` on the stack while\n-`i32` is placed in registers.\n-\n-## Enter `repr(transparent)`\n-\n-So while `repr(C)` happens to do the right thing with respect to memory layout,\n-it's not quite the right tool for newtypes in FFI. Instead of declaring a C\n-struct, we need to communicate to the Rust compiler that our newtype is just for\n-type safety on the Rust side. This is what `repr(transparent)` does.\n-\n-The attribute can be applied to a newtype-like structs that contains a single\n-field. It indicates that the newtype should be represented exactly like that\n-field's type, i.e., the newtype should be ignored for ABI purpopses: not only is\n-it laid out the same in memory, it is also passed identically in function calls.\n-\n-In the above example, the ABI mismatches can be prevented by making the newtypes\n-`Grams` and `Millimeters` transparent like this:\n-\n-```rust\n-#![feature(repr_transparent)]\n-\n-#[repr(transparent)]\n-struct Grams(f64);\n-\n-#[repr(transparent)]\n-struct Millimeters(f64);\n-```\n-\n-In addition to that single field, any number of zero-sized fields are permitted,\n-including but not limited to `PhantomData`:\n-\n-```rust\n-#![feature(repr_transparent)]\n-\n-use std::marker::PhantomData;\n-\n-struct Foo { /* ... */ }\n-\n-#[repr(transparent)]\n-struct FooPtrWithLifetime<'a>(*const Foo, PhantomData<&'a Foo>);\n-\n-#[repr(transparent)]\n-struct NumberWithUnit<T, U>(T, PhantomData<U>);\n-\n-struct CustomZst;\n-\n-#[repr(transparent)]\n-struct PtrWithCustomZst<'a> {\n-    ptr: FooPtrWithLifetime<'a>,\n-    some_marker: CustomZst,\n-}\n-```\n-\n-Transparent structs can be nested: `PtrWithCustomZst` is also represented\n-exactly like `*const Foo`.\n-\n-Because `repr(transparent)` delegates all representation concerns to another\n-type, it is incompatible with all other `repr(..)` attributes. It also cannot be\n-applied to enums, unions, empty structs, structs whose fields are all\n-zero-sized, or structs with *multiple* non-zero-sized fields.\n-\n-[PhantomData]: https://doc.rust-lang.org/std/marker/struct.PhantomData.html\n-[nomicon-phantom]: https://doc.rust-lang.org/nomicon/phantom-data.html"}, {"sha": "5c0d33b5ab0c492f6b3712165e5496cee3bf4fbd", "filename": "src/doc/unstable-book/src/language-features/tool-lints.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftool-lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftool-lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftool-lints.md?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -0,0 +1,35 @@\n+# `tool_lints`\n+\n+The tracking issue for this feature is: [#44690]\n+\n+[#44690]: https://github.com/rust-lang/rust/issues/44690\n+\n+------------------------\n+\n+Tool lints let you use scoped lints, to `allow`, `warn`, `deny` or `forbid` lints of\n+certain tools.\n+\n+Currently `clippy` is the only available lint tool.\n+\n+It is recommended for lint tools to implement the scoped lints like this:\n+\n+- `#[_(TOOL_NAME::lintname)]`: for lint names\n+- `#[_(TOOL_NAME::lintgroup)]`: for groups of lints\n+- `#[_(TOOL_NAME::all)]`: for (almost[^1]) all lints\n+\n+## An example\n+\n+```rust\n+#![feature(tool_lints)]\n+\n+#![warn(clippy::pedantic)]\n+\n+#[allow(clippy::filter_map)]\n+fn main() {\n+    let v = vec![0; 10];\n+    let _ = v.into_iter().filter(|&x| x < 1).map(|x| x + 1).collect::<Vec<_>>();\n+    println!(\"No filter_map()!\");\n+}\n+```\n+\n+[^1]: Some defined lint groups can be excluded here."}, {"sha": "c3b7f2e41e15b27b265f37fcc75e53801538ef8c", "filename": "src/doc/unstable-book/src/language-features/used.md", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fused.md", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fused.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fused.md?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -87,11 +87,13 @@ This condition can be met using `#[used]` and `#[link_section]` plus a linker\n script.\n \n ``` rust,ignore\n-#![feature(lang_items)]\n+#![feature(panic_implementation)]\n #![feature(used)]\n #![no_main]\n #![no_std]\n \n+use core::panic::PanicInfo;\n+\n extern \"C\" fn reset_handler() -> ! {\n     loop {}\n }\n@@ -100,8 +102,10 @@ extern \"C\" fn reset_handler() -> ! {\n #[used]\n static RESET_HANDLER: extern \"C\" fn() -> ! = reset_handler;\n \n-#[lang = \"panic_fmt\"]\n-fn panic_fmt() {}\n+#[panic_implementation]\n+fn panic_impl(info: &PanicInfo) -> ! {\n+    loop {}\n+}\n ```\n \n ``` text"}, {"sha": "425d4cb79b2df7e359fbd0c05edd3c8155d3156c", "filename": "src/doc/unstable-book/src/library-features/alloc-jemalloc.md", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-jemalloc.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-jemalloc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-jemalloc.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,13 +0,0 @@\n-# `alloc_jemalloc`\n-\n-The tracking issue for this feature is: [#33082]\n-\n-[#33082]: https://github.com/rust-lang/rust/issues/33082\n-\n-See also [`alloc_system`](library-features/alloc-system.html).\n-\n-------------------------\n-\n-This feature has been replaced by [the `jemallocator` crate on crates.io.][jemallocator].\n-\n-[jemallocator]: https://crates.io/crates/jemallocator"}, {"sha": "9effab202cabd909b8c270110f2ff1df5f7fa568", "filename": "src/doc/unstable-book/src/library-features/alloc-system.md", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-system.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-system.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-system.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,77 +0,0 @@\n-# `alloc_system`\n-\n-The tracking issue for this feature is: [#32838]\n-\n-[#32838]: https://github.com/rust-lang/rust/issues/32838\n-\n-See also [`global_allocator`](language-features/global-allocator.html).\n-\n-------------------------\n-\n-The compiler currently ships two default allocators: `alloc_system` and\n-`alloc_jemalloc` (some targets don't have jemalloc, however). These allocators\n-are normal Rust crates and contain an implementation of the routines to\n-allocate and deallocate memory. The standard library is not compiled assuming\n-either one, and the compiler will decide which allocator is in use at\n-compile-time depending on the type of output artifact being produced.\n-\n-Binaries generated by the compiler will use `alloc_jemalloc` by default (where\n-available). In this situation the compiler \"controls the world\" in the sense of\n-it has power over the final link. Primarily this means that the allocator\n-decision can be left up the compiler.\n-\n-Dynamic and static libraries, however, will use `alloc_system` by default. Here\n-Rust is typically a 'guest' in another application or another world where it\n-cannot authoritatively decide what allocator is in use. As a result it resorts\n-back to the standard APIs (e.g. `malloc` and `free`) for acquiring and releasing\n-memory.\n-\n-# Switching Allocators\n-\n-Although the compiler's default choices may work most of the time, it's often\n-necessary to tweak certain aspects. Overriding the compiler's decision about\n-which allocator is in use is done through the `#[global_allocator]` attribute:\n-\n-```rust,no_run\n-#![feature(alloc_system, global_allocator, allocator_api)]\n-\n-extern crate alloc_system;\n-\n-use alloc_system::System;\n-\n-#[global_allocator]\n-static A: System = System;\n-\n-fn main() {\n-    let a = Box::new(4); // Allocates from the system allocator.\n-    println!(\"{}\", a);\n-}\n-```\n-\n-In this example the binary generated will not link to jemalloc by default but\n-instead use the system allocator. Conversely to generate a dynamic library which\n-uses jemalloc by default one would write:\n-\n-(The `alloc_jemalloc` crate cannot be used to control the global allocator,\n-crate.io\u2019s `jemallocator` crate provides equivalent functionality.)\n-\n-```toml\n-# Cargo.toml\n-[dependencies]\n-jemallocator = \"0.1\"\n-```\n-```rust,ignore\n-#![feature(global_allocator)]\n-#![crate_type = \"dylib\"]\n-\n-extern crate jemallocator;\n-\n-#[global_allocator]\n-static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;\n-\n-pub fn foo() {\n-    let a = Box::new(4); // Allocates from jemalloc.\n-    println!(\"{}\", a);\n-}\n-# fn main() {}\n-```"}, {"sha": "f8c8a2a7a718bafa31c0f1dcd8adabb885cd12f6", "filename": "src/doc/unstable-book/src/library-features/entry-or-default.md", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fentry-or-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fentry-or-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fentry-or-default.md?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,13 +0,0 @@\n-# `entry_or_default`\n-\n-The tracking issue for this feature is: [#44324]\n-\n-[#44324]: https://github.com/rust-lang/rust/issues/44324\n-\n-------------------------\n-\n-The `entry_or_default` feature adds a new method to `hash_map::Entry`\n-and `btree_map::Entry`, `or_default`, when `V: Default`. This method is\n-semantically identical to `or_insert_with(Default::default)`, and will\n-insert the default value for the type if no entry exists for the current\n-key."}, {"sha": "2e9169ce5b942920c16dc5426003888fd98ec8b7", "filename": "src/etc/generate-deriving-span-tests.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fetc%2Fgenerate-deriving-span-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fetc%2Fgenerate-deriving-span-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-deriving-span-tests.py?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -122,7 +122,7 @@ def write_file(name, string):\n \n for (trait, supers, errs) in [('Clone', [], 1),\n                               ('PartialEq', [], 2),\n-                              ('PartialOrd', ['PartialEq'], 5),\n+                              ('PartialOrd', ['PartialEq'], 1),\n                               ('Eq', ['PartialEq'], 1),\n                               ('Ord', ['Eq', 'PartialOrd', 'PartialEq'], 1),\n                               ('Debug', [], 1),"}, {"sha": "569788fe9c08a93cfca05915a7835ea629c34be0", "filename": "src/etc/htmldocck.py", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fetc%2Fhtmldocck.py", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fetc%2Fhtmldocck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fhtmldocck.py?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -346,15 +346,19 @@ def check_tree_attr(tree, path, attr, pat, regexp):\n def check_tree_text(tree, path, pat, regexp):\n     path = normalize_xpath(path)\n     ret = False\n-    for e in tree.findall(path):\n-        try:\n-            value = flatten(e)\n-        except KeyError:\n-            continue\n-        else:\n-            ret = check_string(value, pat, regexp)\n-            if ret:\n-                break\n+    try:\n+        for e in tree.findall(path):\n+            try:\n+                value = flatten(e)\n+            except KeyError:\n+                continue\n+            else:\n+                ret = check_string(value, pat, regexp)\n+                if ret:\n+                    break\n+    except Exception as e:\n+        print('Failed to get path \"{}\"'.format(path))\n+        raise e\n     return ret\n \n "}, {"sha": "046ea48638baf22f22cc5dc35b67b747e7376263", "filename": "src/etc/platform-intrinsics/generator.py", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -806,9 +806,6 @@ def open(platform):\n use {{Intrinsic, Type}};\n use IntrinsicDef::Named;\n \n-// The default inlining settings trigger a pathological behaviour in\n-// LLVM, which causes makes compilation very slow. See #28273.\n-#[inline(never)]\n pub fn find(name: &str) -> Option<Intrinsic> {{\n     if !name.starts_with(\"{0}\") {{ return None }}\n     Some(match &name[\"{0}\".len()..] {{'''.format(platform.platform_prefix())"}, {"sha": "6835d6aa90874b7b7372dc8d68e557246a644696", "filename": "src/etc/rust-gdb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fetc%2Frust-gdb", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fetc%2Frust-gdb", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust-gdb?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -21,6 +21,6 @@ GDB_PYTHON_MODULE_DIRECTORY=\"$RUSTC_SYSROOT/lib/rustlib/etc\"\n # different/specific command (defaults to `gdb`).\n RUST_GDB=\"${RUST_GDB:-gdb}\"\n PYTHONPATH=\"$PYTHONPATH:$GDB_PYTHON_MODULE_DIRECTORY\" ${RUST_GDB} \\\n-  -d \"$GDB_PYTHON_MODULE_DIRECTORY\" \\\n+  --directory=\"$GDB_PYTHON_MODULE_DIRECTORY\" \\\n   -iex \"add-auto-load-safe-path $GDB_PYTHON_MODULE_DIRECTORY\" \\\n   \"$@\""}, {"sha": "378aae597331600acfbf5e42f1242c6e46c10870", "filename": "src/etc/wasm32-shim.js", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fetc%2Fwasm32-shim.js", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fetc%2Fwasm32-shim.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fwasm32-shim.js?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -107,6 +107,10 @@ imports.env = {\n   exp2f: function(x) { return Math.pow(2, x); },\n   ldexp: function(x, y) { return x * Math.pow(2, y); },\n   ldexpf: function(x, y) { return x * Math.pow(2, y); },\n+  sin: Math.sin,\n+  sinf: Math.sin,\n+  cos: Math.cos,\n+  cosf: Math.cos,\n   log: Math.log,\n   log2: Math.log2,\n   log10: Math.log10,"}, {"sha": "ada21e04b306cc9c0662611b1dafb0e998b2284f", "filename": "src/liballoc/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2FCargo.toml?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -2,6 +2,8 @@\n authors = [\"The Rust Project Developers\"]\n name = \"alloc\"\n version = \"0.0.0\"\n+autotests = false\n+autobenches = false\n \n [lib]\n name = \"alloc\""}, {"sha": "84bd275df347c9c73b376c37e900ff3212be6900", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 114, "deletions": 101, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -8,42 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable(feature = \"allocator_api\",\n-            reason = \"the precise API and guarantees it provides may be tweaked \\\n-                      slightly, especially to possibly take into account the \\\n-                      types being stored to make room for a future \\\n-                      tracing garbage collector\",\n-            issue = \"32838\")]\n+//! Memory allocation APIs\n+\n+#![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n \n use core::intrinsics::{min_align_of_val, size_of_val};\n use core::ptr::{NonNull, Unique};\n use core::usize;\n \n+#[stable(feature = \"alloc_module\", since = \"1.28.0\")]\n #[doc(inline)]\n pub use core::alloc::*;\n \n-#[cfg(stage0)]\n-extern \"Rust\" {\n-    #[allocator]\n-    #[rustc_allocator_nounwind]\n-    fn __rust_alloc(size: usize, align: usize, err: *mut u8) -> *mut u8;\n-    #[cold]\n-    #[rustc_allocator_nounwind]\n-    fn __rust_oom(err: *const u8) -> !;\n-    #[rustc_allocator_nounwind]\n-    fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);\n-    #[rustc_allocator_nounwind]\n-    fn __rust_realloc(ptr: *mut u8,\n-                      old_size: usize,\n-                      old_align: usize,\n-                      new_size: usize,\n-                      new_align: usize,\n-                      err: *mut u8) -> *mut u8;\n-    #[rustc_allocator_nounwind]\n-    fn __rust_alloc_zeroed(size: usize, align: usize, err: *mut u8) -> *mut u8;\n-}\n-\n-#[cfg(not(stage0))]\n extern \"Rust\" {\n     #[allocator]\n     #[rustc_allocator_nounwind]\n@@ -59,82 +35,117 @@ extern \"Rust\" {\n     fn __rust_alloc_zeroed(size: usize, align: usize) -> *mut u8;\n }\n \n+/// The global memory allocator.\n+///\n+/// This type implements the [`Alloc`] trait by forwarding calls\n+/// to the allocator registered with the `#[global_allocator]` attribute\n+/// if there is one, or the `std` crate\u2019s default.\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[derive(Copy, Clone, Default, Debug)]\n pub struct Global;\n \n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-#[rustc_deprecated(since = \"1.27.0\", reason = \"type renamed to `Global`\")]\n-pub type Heap = Global;\n-\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-#[rustc_deprecated(since = \"1.27.0\", reason = \"type renamed to `Global`\")]\n-#[allow(non_upper_case_globals)]\n-pub const Heap: Global = Global;\n-\n-unsafe impl GlobalAlloc for Global {\n-    #[inline]\n-    unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n-        #[cfg(not(stage0))]\n-        let ptr = __rust_alloc(layout.size(), layout.align());\n-        #[cfg(stage0)]\n-        let ptr = __rust_alloc(layout.size(), layout.align(), &mut 0);\n-        ptr as *mut Opaque\n-    }\n+/// Allocate memory with the global allocator.\n+///\n+/// This function forwards calls to the [`GlobalAlloc::alloc`] method\n+/// of the allocator registered with the `#[global_allocator]` attribute\n+/// if there is one, or the `std` crate\u2019s default.\n+///\n+/// This function is expected to be deprecated in favor of the `alloc` method\n+/// of the [`Global`] type when it and the [`Alloc`] trait become stable.\n+///\n+/// # Safety\n+///\n+/// See [`GlobalAlloc::alloc`].\n+#[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+#[inline]\n+pub unsafe fn alloc(layout: Layout) -> *mut u8 {\n+    __rust_alloc(layout.size(), layout.align())\n+}\n \n-    #[inline]\n-    unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n-        __rust_dealloc(ptr as *mut u8, layout.size(), layout.align())\n-    }\n+/// Deallocate memory with the global allocator.\n+///\n+/// This function forwards calls to the [`GlobalAlloc::dealloc`] method\n+/// of the allocator registered with the `#[global_allocator]` attribute\n+/// if there is one, or the `std` crate\u2019s default.\n+///\n+/// This function is expected to be deprecated in favor of the `dealloc` method\n+/// of the [`Global`] type when it and the [`Alloc`] trait become stable.\n+///\n+/// # Safety\n+///\n+/// See [`GlobalAlloc::dealloc`].\n+#[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+#[inline]\n+pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {\n+    __rust_dealloc(ptr, layout.size(), layout.align())\n+}\n \n-    #[inline]\n-    unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n-        #[cfg(not(stage0))]\n-        let ptr = __rust_realloc(ptr as *mut u8, layout.size(), layout.align(), new_size);\n-        #[cfg(stage0)]\n-        let ptr = __rust_realloc(ptr as *mut u8, layout.size(), layout.align(),\n-                                 new_size, layout.align(), &mut 0);\n-        ptr as *mut Opaque\n-    }\n+/// Reallocate memory with the global allocator.\n+///\n+/// This function forwards calls to the [`GlobalAlloc::realloc`] method\n+/// of the allocator registered with the `#[global_allocator]` attribute\n+/// if there is one, or the `std` crate\u2019s default.\n+///\n+/// This function is expected to be deprecated in favor of the `realloc` method\n+/// of the [`Global`] type when it and the [`Alloc`] trait become stable.\n+///\n+/// # Safety\n+///\n+/// See [`GlobalAlloc::realloc`].\n+#[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+#[inline]\n+pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+    __rust_realloc(ptr, layout.size(), layout.align(), new_size)\n+}\n \n-    #[inline]\n-    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n-        #[cfg(not(stage0))]\n-        let ptr = __rust_alloc_zeroed(layout.size(), layout.align());\n-        #[cfg(stage0)]\n-        let ptr = __rust_alloc_zeroed(layout.size(), layout.align(), &mut 0);\n-        ptr as *mut Opaque\n-    }\n+/// Allocate zero-initialized memory with the global allocator.\n+///\n+/// This function forwards calls to the [`GlobalAlloc::alloc_zeroed`] method\n+/// of the allocator registered with the `#[global_allocator]` attribute\n+/// if there is one, or the `std` crate\u2019s default.\n+///\n+/// This function is expected to be deprecated in favor of the `alloc_zeroed` method\n+/// of the [`Global`] type when it and the [`Alloc`] trait become stable.\n+///\n+/// # Safety\n+///\n+/// See [`GlobalAlloc::alloc_zeroed`].\n+#[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+#[inline]\n+pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n+    __rust_alloc_zeroed(layout.size(), layout.align())\n }\n \n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl Alloc for Global {\n     #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n-        NonNull::new(GlobalAlloc::alloc(self, layout)).ok_or(AllocErr)\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n+        NonNull::new(alloc(layout)).ok_or(AllocErr)\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&mut self, ptr: NonNull<Opaque>, layout: Layout) {\n-        GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n+    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n+        dealloc(ptr.as_ptr(), layout)\n     }\n \n     #[inline]\n     unsafe fn realloc(&mut self,\n-                      ptr: NonNull<Opaque>,\n+                      ptr: NonNull<u8>,\n                       layout: Layout,\n                       new_size: usize)\n-                      -> Result<NonNull<Opaque>, AllocErr>\n+                      -> Result<NonNull<u8>, AllocErr>\n     {\n-        NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n+        NonNull::new(realloc(ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n     }\n \n     #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n-        NonNull::new(GlobalAlloc::alloc_zeroed(self, layout)).ok_or(AllocErr)\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n+        NonNull::new(alloc_zeroed(layout)).ok_or(AllocErr)\n     }\n }\n \n /// The allocator for unique pointers.\n-// This function must not unwind. If it does, MIR trans will fail.\n+// This function must not unwind. If it does, MIR codegen will fail.\n #[cfg(not(test))]\n #[lang = \"exchange_malloc\"]\n #[inline]\n@@ -143,23 +154,16 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n         align as *mut u8\n     } else {\n         let layout = Layout::from_size_align_unchecked(size, align);\n-        let ptr = Global.alloc(layout);\n+        let ptr = alloc(layout);\n         if !ptr.is_null() {\n-            ptr as *mut u8\n+            ptr\n         } else {\n-            oom()\n+            handle_alloc_error(layout)\n         }\n     }\n }\n \n-#[cfg(stage0)]\n-#[lang = \"box_free\"]\n-#[inline]\n-unsafe fn old_box_free<T: ?Sized>(ptr: *mut T) {\n-    box_free(Unique::new_unchecked(ptr))\n-}\n-\n-#[cfg_attr(not(any(test, stage0)), lang = \"box_free\")]\n+#[cfg_attr(not(test), lang = \"box_free\")]\n #[inline]\n pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n     let ptr = ptr.as_ptr();\n@@ -168,37 +172,46 @@ pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n     // We do not allocate for Box<T> when T is ZST, so deallocation is also not necessary.\n     if size != 0 {\n         let layout = Layout::from_size_align_unchecked(size, align);\n-        Global.dealloc(ptr as *mut Opaque, layout);\n+        dealloc(ptr as *mut u8, layout);\n     }\n }\n \n-#[cfg(stage0)]\n-pub fn oom() -> ! {\n-    unsafe { ::core::intrinsics::abort() }\n-}\n-\n-#[cfg(not(stage0))]\n-pub fn oom() -> ! {\n-    extern {\n+/// Abort on memory allocation error or failure.\n+///\n+/// Callers of memory allocation APIs wishing to abort computation\n+/// in response to an allocation error are encouraged to call this function,\n+/// rather than directly invoking `panic!` or similar.\n+///\n+/// The default behavior of this function is to print a message to standard error\n+/// and abort the process.\n+/// It can be replaced with [`set_alloc_error_hook`] and [`take_alloc_error_hook`].\n+///\n+/// [`set_alloc_error_hook`]: ../../std/alloc/fn.set_alloc_error_hook.html\n+/// [`take_alloc_error_hook`]: ../../std/alloc/fn.take_alloc_error_hook.html\n+#[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+#[rustc_allocator_nounwind]\n+pub fn handle_alloc_error(layout: Layout) -> ! {\n+    #[allow(improper_ctypes)]\n+    extern \"Rust\" {\n         #[lang = \"oom\"]\n-        fn oom_impl() -> !;\n+        fn oom_impl(layout: Layout) -> !;\n     }\n-    unsafe { oom_impl() }\n+    unsafe { oom_impl(layout) }\n }\n \n #[cfg(test)]\n mod tests {\n     extern crate test;\n     use self::test::Bencher;\n     use boxed::Box;\n-    use alloc::{Global, Alloc, Layout, oom};\n+    use alloc::{Global, Alloc, Layout, handle_alloc_error};\n \n     #[test]\n     fn allocate_zeroed() {\n         unsafe {\n             let layout = Layout::from_size_align(1024, 1).unwrap();\n             let ptr = Global.alloc_zeroed(layout.clone())\n-                .unwrap_or_else(|_| oom());\n+                .unwrap_or_else(|_| handle_alloc_error(layout));\n \n             let mut i = ptr.cast::<u8>().as_ptr();\n             let end = i.offset(layout.size() as isize);"}, {"sha": "d0950bff9ce8092a38b5c53616f86c0dfaad83bc", "filename": "src/liballoc/arc.rs", "status": "removed", "additions": 0, "deletions": 1861, "changes": 1861, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,1861 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-//! Thread-safe reference-counting pointers.\n-//!\n-//! See the [`Arc<T>`][arc] documentation for more details.\n-//!\n-//! [arc]: struct.Arc.html\n-\n-use core::sync::atomic;\n-use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n-use core::borrow;\n-use core::fmt;\n-use core::cmp::Ordering;\n-use core::intrinsics::abort;\n-use core::mem::{self, align_of_val, size_of_val, uninitialized};\n-use core::ops::Deref;\n-use core::ops::CoerceUnsized;\n-use core::ptr::{self, NonNull};\n-use core::marker::{Unsize, PhantomData};\n-use core::hash::{Hash, Hasher};\n-use core::{isize, usize};\n-use core::convert::From;\n-\n-use alloc::{Global, Alloc, Layout, box_free, oom};\n-use boxed::Box;\n-use string::String;\n-use vec::Vec;\n-\n-/// A soft limit on the amount of references that may be made to an `Arc`.\n-///\n-/// Going above this limit will abort your program (although not\n-/// necessarily) at _exactly_ `MAX_REFCOUNT + 1` references.\n-const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n-\n-/// A thread-safe reference-counting pointer. 'Arc' stands for 'Atomically\n-/// Reference Counted'.\n-///\n-/// The type `Arc<T>` provides shared ownership of a value of type `T`,\n-/// allocated in the heap. Invoking [`clone`][clone] on `Arc` produces\n-/// a new pointer to the same value in the heap. When the last `Arc`\n-/// pointer to a given value is destroyed, the pointed-to value is\n-/// also destroyed.\n-///\n-/// Shared references in Rust disallow mutation by default, and `Arc` is no\n-/// exception: you cannot generally obtain a mutable reference to something\n-/// inside an `Arc`. If you need to mutate through an `Arc`, use\n-/// [`Mutex`][mutex], [`RwLock`][rwlock], or one of the [`Atomic`][atomic]\n-/// types.\n-///\n-/// ## Thread Safety\n-///\n-/// Unlike [`Rc<T>`], `Arc<T>` uses atomic operations for its reference\n-/// counting. This means that it is thread-safe. The disadvantage is that\n-/// atomic operations are more expensive than ordinary memory accesses. If you\n-/// are not sharing reference-counted values between threads, consider using\n-/// [`Rc<T>`] for lower overhead. [`Rc<T>`] is a safe default, because the\n-/// compiler will catch any attempt to send an [`Rc<T>`] between threads.\n-/// However, a library might choose `Arc<T>` in order to give library consumers\n-/// more flexibility.\n-///\n-/// `Arc<T>` will implement [`Send`] and [`Sync`] as long as the `T` implements\n-/// [`Send`] and [`Sync`]. Why can't you put a non-thread-safe type `T` in an\n-/// `Arc<T>` to make it thread-safe? This may be a bit counter-intuitive at\n-/// first: after all, isn't the point of `Arc<T>` thread safety? The key is\n-/// this: `Arc<T>` makes it thread safe to have multiple ownership of the same\n-/// data, but it  doesn't add thread safety to its data. Consider\n-/// `Arc<`[`RefCell<T>`]`>`. [`RefCell<T>`] isn't [`Sync`], and if `Arc<T>` was always\n-/// [`Send`], `Arc<`[`RefCell<T>`]`>` would be as well. But then we'd have a problem:\n-/// [`RefCell<T>`] is not thread safe; it keeps track of the borrowing count using\n-/// non-atomic operations.\n-///\n-/// In the end, this means that you may need to pair `Arc<T>` with some sort of\n-/// [`std::sync`] type, usually [`Mutex<T>`][mutex].\n-///\n-/// ## Breaking cycles with `Weak`\n-///\n-/// The [`downgrade`][downgrade] method can be used to create a non-owning\n-/// [`Weak`][weak] pointer. A [`Weak`][weak] pointer can be [`upgrade`][upgrade]d\n-/// to an `Arc`, but this will return [`None`] if the value has already been\n-/// dropped.\n-///\n-/// A cycle between `Arc` pointers will never be deallocated. For this reason,\n-/// [`Weak`][weak] is used to break cycles. For example, a tree could have\n-/// strong `Arc` pointers from parent nodes to children, and [`Weak`][weak]\n-/// pointers from children back to their parents.\n-///\n-/// # Cloning references\n-///\n-/// Creating a new reference from an existing reference counted pointer is done using the\n-/// `Clone` trait implemented for [`Arc<T>`][arc] and [`Weak<T>`][weak].\n-///\n-/// ```\n-/// use std::sync::Arc;\n-/// let foo = Arc::new(vec![1.0, 2.0, 3.0]);\n-/// // The two syntaxes below are equivalent.\n-/// let a = foo.clone();\n-/// let b = Arc::clone(&foo);\n-/// // a and b both point to the same memory location as foo.\n-/// ```\n-///\n-/// The [`Arc::clone(&from)`] syntax is the most idiomatic because it conveys more explicitly\n-/// the meaning of the code. In the example above, this syntax makes it easier to see that\n-/// this code is creating a new reference rather than copying the whole content of foo.\n-///\n-/// ## `Deref` behavior\n-///\n-/// `Arc<T>` automatically dereferences to `T` (via the [`Deref`][deref] trait),\n-/// so you can call `T`'s methods on a value of type `Arc<T>`. To avoid name\n-/// clashes with `T`'s methods, the methods of `Arc<T>` itself are [associated\n-/// functions][assoc], called using function-like syntax:\n-///\n-/// ```\n-/// use std::sync::Arc;\n-/// let my_arc = Arc::new(());\n-///\n-/// Arc::downgrade(&my_arc);\n-/// ```\n-///\n-/// [`Weak<T>`][weak] does not auto-dereference to `T`, because the value may have\n-/// already been destroyed.\n-///\n-/// [arc]: struct.Arc.html\n-/// [weak]: struct.Weak.html\n-/// [`Rc<T>`]: ../../std/rc/struct.Rc.html\n-/// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n-/// [mutex]: ../../std/sync/struct.Mutex.html\n-/// [rwlock]: ../../std/sync/struct.RwLock.html\n-/// [atomic]: ../../std/sync/atomic/index.html\n-/// [`Send`]: ../../std/marker/trait.Send.html\n-/// [`Sync`]: ../../std/marker/trait.Sync.html\n-/// [deref]: ../../std/ops/trait.Deref.html\n-/// [downgrade]: struct.Arc.html#method.downgrade\n-/// [upgrade]: struct.Weak.html#method.upgrade\n-/// [`None`]: ../../std/option/enum.Option.html#variant.None\n-/// [assoc]: ../../book/first-edition/method-syntax.html#associated-functions\n-/// [`RefCell<T>`]: ../../std/cell/struct.RefCell.html\n-/// [`std::sync`]: ../../std/sync/index.html\n-/// [`Arc::clone(&from)`]: #method.clone\n-///\n-/// # Examples\n-///\n-/// Sharing some immutable data between threads:\n-///\n-// Note that we **do not** run these tests here. The windows builders get super\n-// unhappy if a thread outlives the main thread and then exits at the same time\n-// (something deadlocks) so we just avoid this entirely by not running these\n-// tests.\n-/// ```no_run\n-/// use std::sync::Arc;\n-/// use std::thread;\n-///\n-/// let five = Arc::new(5);\n-///\n-/// for _ in 0..10 {\n-///     let five = Arc::clone(&five);\n-///\n-///     thread::spawn(move || {\n-///         println!(\"{:?}\", five);\n-///     });\n-/// }\n-/// ```\n-///\n-/// Sharing a mutable [`AtomicUsize`]:\n-///\n-/// [`AtomicUsize`]: ../../std/sync/atomic/struct.AtomicUsize.html\n-///\n-/// ```no_run\n-/// use std::sync::Arc;\n-/// use std::sync::atomic::{AtomicUsize, Ordering};\n-/// use std::thread;\n-///\n-/// let val = Arc::new(AtomicUsize::new(5));\n-///\n-/// for _ in 0..10 {\n-///     let val = Arc::clone(&val);\n-///\n-///     thread::spawn(move || {\n-///         let v = val.fetch_add(1, Ordering::SeqCst);\n-///         println!(\"{:?}\", v);\n-///     });\n-/// }\n-/// ```\n-///\n-/// See the [`rc` documentation][rc_examples] for more examples of reference\n-/// counting in general.\n-///\n-/// [rc_examples]: ../../std/rc/index.html#examples\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Arc<T: ?Sized> {\n-    ptr: NonNull<ArcInner<T>>,\n-    phantom: PhantomData<T>,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: ?Sized + Sync + Send> Send for Arc<T> {}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: ?Sized + Sync + Send> Sync for Arc<T> {}\n-\n-#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n-\n-/// `Weak` is a version of [`Arc`] that holds a non-owning reference to the\n-/// managed value. The value is accessed by calling [`upgrade`] on the `Weak`\n-/// pointer, which returns an [`Option`]`<`[`Arc`]`<T>>`.\n-///\n-/// Since a `Weak` reference does not count towards ownership, it will not\n-/// prevent the inner value from being dropped, and `Weak` itself makes no\n-/// guarantees about the value still being present and may return [`None`]\n-/// when [`upgrade`]d.\n-///\n-/// A `Weak` pointer is useful for keeping a temporary reference to the value\n-/// within [`Arc`] without extending its lifetime. It is also used to prevent\n-/// circular references between [`Arc`] pointers, since mutual owning references\n-/// would never allow either [`Arc`] to be dropped. For example, a tree could\n-/// have strong [`Arc`] pointers from parent nodes to children, and `Weak`\n-/// pointers from children back to their parents.\n-///\n-/// The typical way to obtain a `Weak` pointer is to call [`Arc::downgrade`].\n-///\n-/// [`Arc`]: struct.Arc.html\n-/// [`Arc::downgrade`]: struct.Arc.html#method.downgrade\n-/// [`upgrade`]: struct.Weak.html#method.upgrade\n-/// [`Option`]: ../../std/option/enum.Option.html\n-/// [`None`]: ../../std/option/enum.Option.html#variant.None\n-#[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n-pub struct Weak<T: ?Sized> {\n-    ptr: NonNull<ArcInner<T>>,\n-}\n-\n-#[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n-unsafe impl<T: ?Sized + Sync + Send> Send for Weak<T> {}\n-#[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n-unsafe impl<T: ?Sized + Sync + Send> Sync for Weak<T> {}\n-\n-#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n-impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n-\n-#[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n-impl<T: ?Sized + fmt::Debug> fmt::Debug for Weak<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"(Weak)\")\n-    }\n-}\n-\n-struct ArcInner<T: ?Sized> {\n-    strong: atomic::AtomicUsize,\n-\n-    // the value usize::MAX acts as a sentinel for temporarily \"locking\" the\n-    // ability to upgrade weak pointers or downgrade strong ones; this is used\n-    // to avoid races in `make_mut` and `get_mut`.\n-    weak: atomic::AtomicUsize,\n-\n-    data: T,\n-}\n-\n-unsafe impl<T: ?Sized + Sync + Send> Send for ArcInner<T> {}\n-unsafe impl<T: ?Sized + Sync + Send> Sync for ArcInner<T> {}\n-\n-impl<T> Arc<T> {\n-    /// Constructs a new `Arc<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(data: T) -> Arc<T> {\n-        // Start the weak pointer count as 1 which is the weak pointer that's\n-        // held by all the strong pointers (kinda), see std/rc.rs for more info\n-        let x: Box<_> = box ArcInner {\n-            strong: atomic::AtomicUsize::new(1),\n-            weak: atomic::AtomicUsize::new(1),\n-            data,\n-        };\n-        Arc { ptr: Box::into_raw_non_null(x), phantom: PhantomData }\n-    }\n-\n-    /// Returns the contained value, if the `Arc` has exactly one strong reference.\n-    ///\n-    /// Otherwise, an [`Err`][result] is returned with the same `Arc` that was\n-    /// passed in.\n-    ///\n-    /// This will succeed even if there are outstanding weak references.\n-    ///\n-    /// [result]: ../../std/result/enum.Result.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let x = Arc::new(3);\n-    /// assert_eq!(Arc::try_unwrap(x), Ok(3));\n-    ///\n-    /// let x = Arc::new(4);\n-    /// let _y = Arc::clone(&x);\n-    /// assert_eq!(*Arc::try_unwrap(x).unwrap_err(), 4);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"arc_unique\", since = \"1.4.0\")]\n-    pub fn try_unwrap(this: Self) -> Result<T, Self> {\n-        // See `drop` for why all these atomics are like this\n-        if this.inner().strong.compare_exchange(1, 0, Release, Relaxed).is_err() {\n-            return Err(this);\n-        }\n-\n-        atomic::fence(Acquire);\n-\n-        unsafe {\n-            let elem = ptr::read(&this.ptr.as_ref().data);\n-\n-            // Make a weak pointer to clean up the implicit strong-weak reference\n-            let _weak = Weak { ptr: this.ptr };\n-            mem::forget(this);\n-\n-            Ok(elem)\n-        }\n-    }\n-}\n-\n-impl<T: ?Sized> Arc<T> {\n-    /// Consumes the `Arc`, returning the wrapped pointer.\n-    ///\n-    /// To avoid a memory leak the pointer must be converted back to an `Arc` using\n-    /// [`Arc::from_raw`][from_raw].\n-    ///\n-    /// [from_raw]: struct.Arc.html#method.from_raw\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let x = Arc::new(10);\n-    /// let x_ptr = Arc::into_raw(x);\n-    /// assert_eq!(unsafe { *x_ptr }, 10);\n-    /// ```\n-    #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n-    pub fn into_raw(this: Self) -> *const T {\n-        let ptr: *const T = &*this;\n-        mem::forget(this);\n-        ptr\n-    }\n-\n-    /// Constructs an `Arc` from a raw pointer.\n-    ///\n-    /// The raw pointer must have been previously returned by a call to a\n-    /// [`Arc::into_raw`][into_raw].\n-    ///\n-    /// This function is unsafe because improper use may lead to memory problems. For example, a\n-    /// double-free may occur if the function is called twice on the same raw pointer.\n-    ///\n-    /// [into_raw]: struct.Arc.html#method.into_raw\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let x = Arc::new(10);\n-    /// let x_ptr = Arc::into_raw(x);\n-    ///\n-    /// unsafe {\n-    ///     // Convert back to an `Arc` to prevent leak.\n-    ///     let x = Arc::from_raw(x_ptr);\n-    ///     assert_eq!(*x, 10);\n-    ///\n-    ///     // Further calls to `Arc::from_raw(x_ptr)` would be memory unsafe.\n-    /// }\n-    ///\n-    /// // The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!\n-    /// ```\n-    #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n-    pub unsafe fn from_raw(ptr: *const T) -> Self {\n-        // Align the unsized value to the end of the ArcInner.\n-        // Because it is ?Sized, it will always be the last field in memory.\n-        let align = align_of_val(&*ptr);\n-        let layout = Layout::new::<ArcInner<()>>();\n-        let offset = (layout.size() + layout.padding_needed_for(align)) as isize;\n-\n-        // Reverse the offset to find the original ArcInner.\n-        let fake_ptr = ptr as *mut ArcInner<T>;\n-        let arc_ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n-\n-        Arc {\n-            ptr: NonNull::new_unchecked(arc_ptr),\n-            phantom: PhantomData,\n-        }\n-    }\n-\n-    /// Creates a new [`Weak`][weak] pointer to this value.\n-    ///\n-    /// [weak]: struct.Weak.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// let weak_five = Arc::downgrade(&five);\n-    /// ```\n-    #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n-    pub fn downgrade(this: &Self) -> Weak<T> {\n-        // This Relaxed is OK because we're checking the value in the CAS\n-        // below.\n-        let mut cur = this.inner().weak.load(Relaxed);\n-\n-        loop {\n-            // check if the weak counter is currently \"locked\"; if so, spin.\n-            if cur == usize::MAX {\n-                cur = this.inner().weak.load(Relaxed);\n-                continue;\n-            }\n-\n-            // NOTE: this code currently ignores the possibility of overflow\n-            // into usize::MAX; in general both Rc and Arc need to be adjusted\n-            // to deal with overflow.\n-\n-            // Unlike with Clone(), we need this to be an Acquire read to\n-            // synchronize with the write coming from `is_unique`, so that the\n-            // events prior to that write happen before this read.\n-            match this.inner().weak.compare_exchange_weak(cur, cur + 1, Acquire, Relaxed) {\n-                Ok(_) => return Weak { ptr: this.ptr },\n-                Err(old) => cur = old,\n-            }\n-        }\n-    }\n-\n-    /// Gets the number of [`Weak`][weak] pointers to this value.\n-    ///\n-    /// [weak]: struct.Weak.html\n-    ///\n-    /// # Safety\n-    ///\n-    /// This method by itself is safe, but using it correctly requires extra care.\n-    /// Another thread can change the weak count at any time,\n-    /// including potentially between calling this method and acting on the result.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    /// let _weak_five = Arc::downgrade(&five);\n-    ///\n-    /// // This assertion is deterministic because we haven't shared\n-    /// // the `Arc` or `Weak` between threads.\n-    /// assert_eq!(1, Arc::weak_count(&five));\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"arc_counts\", since = \"1.15.0\")]\n-    pub fn weak_count(this: &Self) -> usize {\n-        let cnt = this.inner().weak.load(SeqCst);\n-        // If the weak count is currently locked, the value of the\n-        // count was 0 just before taking the lock.\n-        if cnt == usize::MAX { 0 } else { cnt - 1 }\n-    }\n-\n-    /// Gets the number of strong (`Arc`) pointers to this value.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This method by itself is safe, but using it correctly requires extra care.\n-    /// Another thread can change the strong count at any time,\n-    /// including potentially between calling this method and acting on the result.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    /// let _also_five = Arc::clone(&five);\n-    ///\n-    /// // This assertion is deterministic because we haven't shared\n-    /// // the `Arc` between threads.\n-    /// assert_eq!(2, Arc::strong_count(&five));\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"arc_counts\", since = \"1.15.0\")]\n-    pub fn strong_count(this: &Self) -> usize {\n-        this.inner().strong.load(SeqCst)\n-    }\n-\n-    #[inline]\n-    fn inner(&self) -> &ArcInner<T> {\n-        // This unsafety is ok because while this arc is alive we're guaranteed\n-        // that the inner pointer is valid. Furthermore, we know that the\n-        // `ArcInner` structure itself is `Sync` because the inner data is\n-        // `Sync` as well, so we're ok loaning out an immutable pointer to these\n-        // contents.\n-        unsafe { self.ptr.as_ref() }\n-    }\n-\n-    // Non-inlined part of `drop`.\n-    #[inline(never)]\n-    unsafe fn drop_slow(&mut self) {\n-        // Destroy the data at this time, even though we may not free the box\n-        // allocation itself (there may still be weak pointers lying around).\n-        ptr::drop_in_place(&mut self.ptr.as_mut().data);\n-\n-        if self.inner().weak.fetch_sub(1, Release) == 1 {\n-            atomic::fence(Acquire);\n-            Global.dealloc(self.ptr.as_opaque(), Layout::for_value(self.ptr.as_ref()))\n-        }\n-    }\n-\n-    #[inline]\n-    #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n-    /// Returns true if the two `Arc`s point to the same value (not\n-    /// just values that compare as equal).\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    /// let same_five = Arc::clone(&five);\n-    /// let other_five = Arc::new(5);\n-    ///\n-    /// assert!(Arc::ptr_eq(&five, &same_five));\n-    /// assert!(!Arc::ptr_eq(&five, &other_five));\n-    /// ```\n-    pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n-        this.ptr.as_ptr() == other.ptr.as_ptr()\n-    }\n-}\n-\n-impl<T: ?Sized> Arc<T> {\n-    // Allocates an `ArcInner<T>` with sufficient space for an unsized value\n-    unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n-        // Create a fake ArcInner to find allocation size and alignment\n-        let fake_ptr = ptr as *mut ArcInner<T>;\n-\n-        let layout = Layout::for_value(&*fake_ptr);\n-\n-        let mem = Global.alloc(layout)\n-            .unwrap_or_else(|_| oom());\n-\n-        // Initialize the real ArcInner\n-        let inner = set_data_ptr(ptr as *mut T, mem.as_ptr() as *mut u8) as *mut ArcInner<T>;\n-\n-        ptr::write(&mut (*inner).strong, atomic::AtomicUsize::new(1));\n-        ptr::write(&mut (*inner).weak, atomic::AtomicUsize::new(1));\n-\n-        inner\n-    }\n-\n-    fn from_box(v: Box<T>) -> Arc<T> {\n-        unsafe {\n-            let box_unique = Box::into_unique(v);\n-            let bptr = box_unique.as_ptr();\n-\n-            let value_size = size_of_val(&*bptr);\n-            let ptr = Self::allocate_for_ptr(bptr);\n-\n-            // Copy value as bytes\n-            ptr::copy_nonoverlapping(\n-                bptr as *const T as *const u8,\n-                &mut (*ptr).data as *mut _ as *mut u8,\n-                value_size);\n-\n-            // Free the allocation without dropping its contents\n-            box_free(box_unique);\n-\n-            Arc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n-        }\n-    }\n-}\n-\n-// Sets the data pointer of a `?Sized` raw pointer.\n-//\n-// For a slice/trait object, this sets the `data` field and leaves the rest\n-// unchanged. For a sized raw pointer, this simply sets the pointer.\n-unsafe fn set_data_ptr<T: ?Sized, U>(mut ptr: *mut T, data: *mut U) -> *mut T {\n-    ptr::write(&mut ptr as *mut _ as *mut *mut u8, data as *mut u8);\n-    ptr\n-}\n-\n-impl<T> Arc<[T]> {\n-    // Copy elements from slice into newly allocated Arc<[T]>\n-    //\n-    // Unsafe because the caller must either take ownership or bind `T: Copy`\n-    unsafe fn copy_from_slice(v: &[T]) -> Arc<[T]> {\n-        let v_ptr = v as *const [T];\n-        let ptr = Self::allocate_for_ptr(v_ptr);\n-\n-        ptr::copy_nonoverlapping(\n-            v.as_ptr(),\n-            &mut (*ptr).data as *mut [T] as *mut T,\n-            v.len());\n-\n-        Arc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n-    }\n-}\n-\n-// Specialization trait used for From<&[T]>\n-trait ArcFromSlice<T> {\n-    fn from_slice(slice: &[T]) -> Self;\n-}\n-\n-impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n-    #[inline]\n-    default fn from_slice(v: &[T]) -> Self {\n-        // Panic guard while cloning T elements.\n-        // In the event of a panic, elements that have been written\n-        // into the new ArcInner will be dropped, then the memory freed.\n-        struct Guard<T> {\n-            mem: NonNull<u8>,\n-            elems: *mut T,\n-            layout: Layout,\n-            n_elems: usize,\n-        }\n-\n-        impl<T> Drop for Guard<T> {\n-            fn drop(&mut self) {\n-                use core::slice::from_raw_parts_mut;\n-\n-                unsafe {\n-                    let slice = from_raw_parts_mut(self.elems, self.n_elems);\n-                    ptr::drop_in_place(slice);\n-\n-                    Global.dealloc(self.mem.as_opaque(), self.layout.clone());\n-                }\n-            }\n-        }\n-\n-        unsafe {\n-            let v_ptr = v as *const [T];\n-            let ptr = Self::allocate_for_ptr(v_ptr);\n-\n-            let mem = ptr as *mut _ as *mut u8;\n-            let layout = Layout::for_value(&*ptr);\n-\n-            // Pointer to first element\n-            let elems = &mut (*ptr).data as *mut [T] as *mut T;\n-\n-            let mut guard = Guard{\n-                mem: NonNull::new_unchecked(mem),\n-                elems: elems,\n-                layout: layout,\n-                n_elems: 0,\n-            };\n-\n-            for (i, item) in v.iter().enumerate() {\n-                ptr::write(elems.offset(i as isize), item.clone());\n-                guard.n_elems += 1;\n-            }\n-\n-            // All clear. Forget the guard so it doesn't free the new ArcInner.\n-            mem::forget(guard);\n-\n-            Arc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n-        }\n-    }\n-}\n-\n-impl<T: Copy> ArcFromSlice<T> for Arc<[T]> {\n-    #[inline]\n-    fn from_slice(v: &[T]) -> Self {\n-        unsafe { Arc::copy_from_slice(v) }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> Clone for Arc<T> {\n-    /// Makes a clone of the `Arc` pointer.\n-    ///\n-    /// This creates another pointer to the same inner value, increasing the\n-    /// strong reference count.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// Arc::clone(&five);\n-    /// ```\n-    #[inline]\n-    fn clone(&self) -> Arc<T> {\n-        // Using a relaxed ordering is alright here, as knowledge of the\n-        // original reference prevents other threads from erroneously deleting\n-        // the object.\n-        //\n-        // As explained in the [Boost documentation][1], Increasing the\n-        // reference counter can always be done with memory_order_relaxed: New\n-        // references to an object can only be formed from an existing\n-        // reference, and passing an existing reference from one thread to\n-        // another must already provide any required synchronization.\n-        //\n-        // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n-        let old_size = self.inner().strong.fetch_add(1, Relaxed);\n-\n-        // However we need to guard against massive refcounts in case someone\n-        // is `mem::forget`ing Arcs. If we don't do this the count can overflow\n-        // and users will use-after free. We racily saturate to `isize::MAX` on\n-        // the assumption that there aren't ~2 billion threads incrementing\n-        // the reference count at once. This branch will never be taken in\n-        // any realistic program.\n-        //\n-        // We abort because such a program is incredibly degenerate, and we\n-        // don't care to support it.\n-        if old_size > MAX_REFCOUNT {\n-            unsafe {\n-                abort();\n-            }\n-        }\n-\n-        Arc { ptr: self.ptr, phantom: PhantomData }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> Deref for Arc<T> {\n-    type Target = T;\n-\n-    #[inline]\n-    fn deref(&self) -> &T {\n-        &self.inner().data\n-    }\n-}\n-\n-impl<T: Clone> Arc<T> {\n-    /// Makes a mutable reference into the given `Arc`.\n-    ///\n-    /// If there are other `Arc` or [`Weak`][weak] pointers to the same value,\n-    /// then `make_mut` will invoke [`clone`][clone] on the inner value to\n-    /// ensure unique ownership. This is also referred to as clone-on-write.\n-    ///\n-    /// See also [`get_mut`][get_mut], which will fail rather than cloning.\n-    ///\n-    /// [weak]: struct.Weak.html\n-    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n-    /// [get_mut]: struct.Arc.html#method.get_mut\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let mut data = Arc::new(5);\n-    ///\n-    /// *Arc::make_mut(&mut data) += 1;         // Won't clone anything\n-    /// let mut other_data = Arc::clone(&data); // Won't clone inner data\n-    /// *Arc::make_mut(&mut data) += 1;         // Clones inner data\n-    /// *Arc::make_mut(&mut data) += 1;         // Won't clone anything\n-    /// *Arc::make_mut(&mut other_data) *= 2;   // Won't clone anything\n-    ///\n-    /// // Now `data` and `other_data` point to different values.\n-    /// assert_eq!(*data, 8);\n-    /// assert_eq!(*other_data, 12);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"arc_unique\", since = \"1.4.0\")]\n-    pub fn make_mut(this: &mut Self) -> &mut T {\n-        // Note that we hold both a strong reference and a weak reference.\n-        // Thus, releasing our strong reference only will not, by itself, cause\n-        // the memory to be deallocated.\n-        //\n-        // Use Acquire to ensure that we see any writes to `weak` that happen\n-        // before release writes (i.e., decrements) to `strong`. Since we hold a\n-        // weak count, there's no chance the ArcInner itself could be\n-        // deallocated.\n-        if this.inner().strong.compare_exchange(1, 0, Acquire, Relaxed).is_err() {\n-            // Another strong pointer exists; clone\n-            *this = Arc::new((**this).clone());\n-        } else if this.inner().weak.load(Relaxed) != 1 {\n-            // Relaxed suffices in the above because this is fundamentally an\n-            // optimization: we are always racing with weak pointers being\n-            // dropped. Worst case, we end up allocated a new Arc unnecessarily.\n-\n-            // We removed the last strong ref, but there are additional weak\n-            // refs remaining. We'll move the contents to a new Arc, and\n-            // invalidate the other weak refs.\n-\n-            // Note that it is not possible for the read of `weak` to yield\n-            // usize::MAX (i.e., locked), since the weak count can only be\n-            // locked by a thread with a strong reference.\n-\n-            // Materialize our own implicit weak pointer, so that it can clean\n-            // up the ArcInner as needed.\n-            let weak = Weak { ptr: this.ptr };\n-\n-            // mark the data itself as already deallocated\n-            unsafe {\n-                // there is no data race in the implicit write caused by `read`\n-                // here (due to zeroing) because data is no longer accessed by\n-                // other threads (due to there being no more strong refs at this\n-                // point).\n-                let mut swap = Arc::new(ptr::read(&weak.ptr.as_ref().data));\n-                mem::swap(this, &mut swap);\n-                mem::forget(swap);\n-            }\n-        } else {\n-            // We were the sole reference of either kind; bump back up the\n-            // strong ref count.\n-            this.inner().strong.store(1, Release);\n-        }\n-\n-        // As with `get_mut()`, the unsafety is ok because our reference was\n-        // either unique to begin with, or became one upon cloning the contents.\n-        unsafe {\n-            &mut this.ptr.as_mut().data\n-        }\n-    }\n-}\n-\n-impl<T: ?Sized> Arc<T> {\n-    /// Returns a mutable reference to the inner value, if there are\n-    /// no other `Arc` or [`Weak`][weak] pointers to the same value.\n-    ///\n-    /// Returns [`None`][option] otherwise, because it is not safe to\n-    /// mutate a shared value.\n-    ///\n-    /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n-    /// the inner value when it's shared.\n-    ///\n-    /// [weak]: struct.Weak.html\n-    /// [option]: ../../std/option/enum.Option.html\n-    /// [make_mut]: struct.Arc.html#method.make_mut\n-    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let mut x = Arc::new(3);\n-    /// *Arc::get_mut(&mut x).unwrap() = 4;\n-    /// assert_eq!(*x, 4);\n-    ///\n-    /// let _y = Arc::clone(&x);\n-    /// assert!(Arc::get_mut(&mut x).is_none());\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"arc_unique\", since = \"1.4.0\")]\n-    pub fn get_mut(this: &mut Self) -> Option<&mut T> {\n-        if this.is_unique() {\n-            // This unsafety is ok because we're guaranteed that the pointer\n-            // returned is the *only* pointer that will ever be returned to T. Our\n-            // reference count is guaranteed to be 1 at this point, and we required\n-            // the Arc itself to be `mut`, so we're returning the only possible\n-            // reference to the inner data.\n-            unsafe {\n-                Some(&mut this.ptr.as_mut().data)\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Determine whether this is the unique reference (including weak refs) to\n-    /// the underlying data.\n-    ///\n-    /// Note that this requires locking the weak ref count.\n-    fn is_unique(&mut self) -> bool {\n-        // lock the weak pointer count if we appear to be the sole weak pointer\n-        // holder.\n-        //\n-        // The acquire label here ensures a happens-before relationship with any\n-        // writes to `strong` prior to decrements of the `weak` count (via drop,\n-        // which uses Release).\n-        if self.inner().weak.compare_exchange(1, usize::MAX, Acquire, Relaxed).is_ok() {\n-            // Due to the previous acquire read, this will observe any writes to\n-            // `strong` that were due to upgrading weak pointers; only strong\n-            // clones remain, which require that the strong count is > 1 anyway.\n-            let unique = self.inner().strong.load(Relaxed) == 1;\n-\n-            // The release write here synchronizes with a read in `downgrade`,\n-            // effectively preventing the above read of `strong` from happening\n-            // after the write.\n-            self.inner().weak.store(1, Release); // release the lock\n-            unique\n-        } else {\n-            false\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<#[may_dangle] T: ?Sized> Drop for Arc<T> {\n-    /// Drops the `Arc`.\n-    ///\n-    /// This will decrement the strong reference count. If the strong reference\n-    /// count reaches zero then the only other references (if any) are\n-    /// [`Weak`][weak], so we `drop` the inner value.\n-    ///\n-    /// [weak]: struct.Weak.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// struct Foo;\n-    ///\n-    /// impl Drop for Foo {\n-    ///     fn drop(&mut self) {\n-    ///         println!(\"dropped!\");\n-    ///     }\n-    /// }\n-    ///\n-    /// let foo  = Arc::new(Foo);\n-    /// let foo2 = Arc::clone(&foo);\n-    ///\n-    /// drop(foo);    // Doesn't print anything\n-    /// drop(foo2);   // Prints \"dropped!\"\n-    /// ```\n-    #[inline]\n-    fn drop(&mut self) {\n-        // Because `fetch_sub` is already atomic, we do not need to synchronize\n-        // with other threads unless we are going to delete the object. This\n-        // same logic applies to the below `fetch_sub` to the `weak` count.\n-        if self.inner().strong.fetch_sub(1, Release) != 1 {\n-            return;\n-        }\n-\n-        // This fence is needed to prevent reordering of use of the data and\n-        // deletion of the data.  Because it is marked `Release`, the decreasing\n-        // of the reference count synchronizes with this `Acquire` fence. This\n-        // means that use of the data happens before decreasing the reference\n-        // count, which happens before this fence, which happens before the\n-        // deletion of the data.\n-        //\n-        // As explained in the [Boost documentation][1],\n-        //\n-        // > It is important to enforce any possible access to the object in one\n-        // > thread (through an existing reference) to *happen before* deleting\n-        // > the object in a different thread. This is achieved by a \"release\"\n-        // > operation after dropping a reference (any access to the object\n-        // > through this reference must obviously happened before), and an\n-        // > \"acquire\" operation before deleting the object.\n-        //\n-        // In particular, while the contents of an Arc are usually immutable, it's\n-        // possible to have interior writes to something like a Mutex<T>. Since a\n-        // Mutex is not acquired when it is deleted, we can't rely on its\n-        // synchronization logic to make writes in thread A visible to a destructor\n-        // running in thread B.\n-        //\n-        // Also note that the Acquire fence here could probably be replaced with an\n-        // Acquire load, which could improve performance in highly-contended\n-        // situations. See [2].\n-        //\n-        // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n-        // [2]: (https://github.com/rust-lang/rust/pull/41714)\n-        atomic::fence(Acquire);\n-\n-        unsafe {\n-            self.drop_slow();\n-        }\n-    }\n-}\n-\n-impl<T> Weak<T> {\n-    /// Constructs a new `Weak<T>`, allocating memory for `T` without initializing\n-    /// it. Calling [`upgrade`] on the return value always gives [`None`].\n-    ///\n-    /// [`upgrade`]: struct.Weak.html#method.upgrade\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Weak;\n-    ///\n-    /// let empty: Weak<i64> = Weak::new();\n-    /// assert!(empty.upgrade().is_none());\n-    /// ```\n-    #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n-    pub fn new() -> Weak<T> {\n-        unsafe {\n-            Weak {\n-                ptr: Box::into_raw_non_null(box ArcInner {\n-                    strong: atomic::AtomicUsize::new(0),\n-                    weak: atomic::AtomicUsize::new(1),\n-                    data: uninitialized(),\n-                }),\n-            }\n-        }\n-    }\n-}\n-\n-impl<T: ?Sized> Weak<T> {\n-    /// Attempts to upgrade the `Weak` pointer to an [`Arc`], extending\n-    /// the lifetime of the value if successful.\n-    ///\n-    /// Returns [`None`] if the value has since been dropped.\n-    ///\n-    /// [`Arc`]: struct.Arc.html\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// let weak_five = Arc::downgrade(&five);\n-    ///\n-    /// let strong_five: Option<Arc<_>> = weak_five.upgrade();\n-    /// assert!(strong_five.is_some());\n-    ///\n-    /// // Destroy all strong pointers.\n-    /// drop(strong_five);\n-    /// drop(five);\n-    ///\n-    /// assert!(weak_five.upgrade().is_none());\n-    /// ```\n-    #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n-    pub fn upgrade(&self) -> Option<Arc<T>> {\n-        // We use a CAS loop to increment the strong count instead of a\n-        // fetch_add because once the count hits 0 it must never be above 0.\n-        let inner = self.inner();\n-\n-        // Relaxed load because any write of 0 that we can observe\n-        // leaves the field in a permanently zero state (so a\n-        // \"stale\" read of 0 is fine), and any other value is\n-        // confirmed via the CAS below.\n-        let mut n = inner.strong.load(Relaxed);\n-\n-        loop {\n-            if n == 0 {\n-                return None;\n-            }\n-\n-            // See comments in `Arc::clone` for why we do this (for `mem::forget`).\n-            if n > MAX_REFCOUNT {\n-                unsafe {\n-                    abort();\n-                }\n-            }\n-\n-            // Relaxed is valid for the same reason it is on Arc's Clone impl\n-            match inner.strong.compare_exchange_weak(n, n + 1, Relaxed, Relaxed) {\n-                Ok(_) => return Some(Arc { ptr: self.ptr, phantom: PhantomData }),\n-                Err(old) => n = old,\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn inner(&self) -> &ArcInner<T> {\n-        // See comments above for why this is \"safe\"\n-        unsafe { self.ptr.as_ref() }\n-    }\n-}\n-\n-#[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n-impl<T: ?Sized> Clone for Weak<T> {\n-    /// Makes a clone of the `Weak` pointer that points to the same value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::{Arc, Weak};\n-    ///\n-    /// let weak_five = Arc::downgrade(&Arc::new(5));\n-    ///\n-    /// Weak::clone(&weak_five);\n-    /// ```\n-    #[inline]\n-    fn clone(&self) -> Weak<T> {\n-        // See comments in Arc::clone() for why this is relaxed.  This can use a\n-        // fetch_add (ignoring the lock) because the weak count is only locked\n-        // where are *no other* weak pointers in existence. (So we can't be\n-        // running this code in that case).\n-        let old_size = self.inner().weak.fetch_add(1, Relaxed);\n-\n-        // See comments in Arc::clone() for why we do this (for mem::forget).\n-        if old_size > MAX_REFCOUNT {\n-            unsafe {\n-                abort();\n-            }\n-        }\n-\n-        return Weak { ptr: self.ptr };\n-    }\n-}\n-\n-#[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n-impl<T> Default for Weak<T> {\n-    /// Constructs a new `Weak<T>`, allocating memory for `T` without initializing\n-    /// it. Calling [`upgrade`] on the return value always gives [`None`].\n-    ///\n-    /// [`upgrade`]: struct.Weak.html#method.upgrade\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Weak;\n-    ///\n-    /// let empty: Weak<i64> = Default::default();\n-    /// assert!(empty.upgrade().is_none());\n-    /// ```\n-    fn default() -> Weak<T> {\n-        Weak::new()\n-    }\n-}\n-\n-#[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n-impl<T: ?Sized> Drop for Weak<T> {\n-    /// Drops the `Weak` pointer.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::{Arc, Weak};\n-    ///\n-    /// struct Foo;\n-    ///\n-    /// impl Drop for Foo {\n-    ///     fn drop(&mut self) {\n-    ///         println!(\"dropped!\");\n-    ///     }\n-    /// }\n-    ///\n-    /// let foo = Arc::new(Foo);\n-    /// let weak_foo = Arc::downgrade(&foo);\n-    /// let other_weak_foo = Weak::clone(&weak_foo);\n-    ///\n-    /// drop(weak_foo);   // Doesn't print anything\n-    /// drop(foo);        // Prints \"dropped!\"\n-    ///\n-    /// assert!(other_weak_foo.upgrade().is_none());\n-    /// ```\n-    fn drop(&mut self) {\n-        // If we find out that we were the last weak pointer, then its time to\n-        // deallocate the data entirely. See the discussion in Arc::drop() about\n-        // the memory orderings\n-        //\n-        // It's not necessary to check for the locked state here, because the\n-        // weak count can only be locked if there was precisely one weak ref,\n-        // meaning that drop could only subsequently run ON that remaining weak\n-        // ref, which can only happen after the lock is released.\n-        if self.inner().weak.fetch_sub(1, Release) == 1 {\n-            atomic::fence(Acquire);\n-            unsafe {\n-                Global.dealloc(self.ptr.as_opaque(), Layout::for_value(self.ptr.as_ref()))\n-            }\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n-    /// Equality for two `Arc`s.\n-    ///\n-    /// Two `Arc`s are equal if their inner values are equal.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// assert!(five == Arc::new(5));\n-    /// ```\n-    fn eq(&self, other: &Arc<T>) -> bool {\n-        *(*self) == *(*other)\n-    }\n-\n-    /// Inequality for two `Arc`s.\n-    ///\n-    /// Two `Arc`s are unequal if their inner values are unequal.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// assert!(five != Arc::new(6));\n-    /// ```\n-    fn ne(&self, other: &Arc<T>) -> bool {\n-        *(*self) != *(*other)\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + PartialOrd> PartialOrd for Arc<T> {\n-    /// Partial comparison for two `Arc`s.\n-    ///\n-    /// The two are compared by calling `partial_cmp()` on their inner values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    /// use std::cmp::Ordering;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// assert_eq!(Some(Ordering::Less), five.partial_cmp(&Arc::new(6)));\n-    /// ```\n-    fn partial_cmp(&self, other: &Arc<T>) -> Option<Ordering> {\n-        (**self).partial_cmp(&**other)\n-    }\n-\n-    /// Less-than comparison for two `Arc`s.\n-    ///\n-    /// The two are compared by calling `<` on their inner values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// assert!(five < Arc::new(6));\n-    /// ```\n-    fn lt(&self, other: &Arc<T>) -> bool {\n-        *(*self) < *(*other)\n-    }\n-\n-    /// 'Less than or equal to' comparison for two `Arc`s.\n-    ///\n-    /// The two are compared by calling `<=` on their inner values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// assert!(five <= Arc::new(5));\n-    /// ```\n-    fn le(&self, other: &Arc<T>) -> bool {\n-        *(*self) <= *(*other)\n-    }\n-\n-    /// Greater-than comparison for two `Arc`s.\n-    ///\n-    /// The two are compared by calling `>` on their inner values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// assert!(five > Arc::new(4));\n-    /// ```\n-    fn gt(&self, other: &Arc<T>) -> bool {\n-        *(*self) > *(*other)\n-    }\n-\n-    /// 'Greater than or equal to' comparison for two `Arc`s.\n-    ///\n-    /// The two are compared by calling `>=` on their inner values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// assert!(five >= Arc::new(5));\n-    /// ```\n-    fn ge(&self, other: &Arc<T>) -> bool {\n-        *(*self) >= *(*other)\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + Ord> Ord for Arc<T> {\n-    /// Comparison for two `Arc`s.\n-    ///\n-    /// The two are compared by calling `cmp()` on their inner values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    /// use std::cmp::Ordering;\n-    ///\n-    /// let five = Arc::new(5);\n-    ///\n-    /// assert_eq!(Ordering::Less, five.cmp(&Arc::new(6)));\n-    /// ```\n-    fn cmp(&self, other: &Arc<T>) -> Ordering {\n-        (**self).cmp(&**other)\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + Eq> Eq for Arc<T> {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + fmt::Display> fmt::Display for Arc<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&**self, f)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + fmt::Debug> fmt::Debug for Arc<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&**self, f)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> fmt::Pointer for Arc<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&(&**self as *const T), f)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Default> Default for Arc<T> {\n-    /// Creates a new `Arc<T>`, with the `Default` value for `T`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::Arc;\n-    ///\n-    /// let x: Arc<i32> = Default::default();\n-    /// assert_eq!(*x, 0);\n-    /// ```\n-    fn default() -> Arc<T> {\n-        Arc::new(Default::default())\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized + Hash> Hash for Arc<T> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        (**self).hash(state)\n-    }\n-}\n-\n-#[stable(feature = \"from_for_ptrs\", since = \"1.6.0\")]\n-impl<T> From<T> for Arc<T> {\n-    fn from(t: T) -> Self {\n-        Arc::new(t)\n-    }\n-}\n-\n-#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n-impl<'a, T: Clone> From<&'a [T]> for Arc<[T]> {\n-    #[inline]\n-    fn from(v: &[T]) -> Arc<[T]> {\n-        <Self as ArcFromSlice<T>>::from_slice(v)\n-    }\n-}\n-\n-#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n-impl<'a> From<&'a str> for Arc<str> {\n-    #[inline]\n-    fn from(v: &str) -> Arc<str> {\n-        let arc = Arc::<[u8]>::from(v.as_bytes());\n-        unsafe { Arc::from_raw(Arc::into_raw(arc) as *const str) }\n-    }\n-}\n-\n-#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n-impl From<String> for Arc<str> {\n-    #[inline]\n-    fn from(v: String) -> Arc<str> {\n-        Arc::from(&v[..])\n-    }\n-}\n-\n-#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n-impl<T: ?Sized> From<Box<T>> for Arc<T> {\n-    #[inline]\n-    fn from(v: Box<T>) -> Arc<T> {\n-        Arc::from_box(v)\n-    }\n-}\n-\n-#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n-impl<T> From<Vec<T>> for Arc<[T]> {\n-    #[inline]\n-    fn from(mut v: Vec<T>) -> Arc<[T]> {\n-        unsafe {\n-            let arc = Arc::copy_from_slice(&v);\n-\n-            // Allow the Vec to free its memory, but not destroy its contents\n-            v.set_len(0);\n-\n-            arc\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use std::boxed::Box;\n-    use std::clone::Clone;\n-    use std::sync::mpsc::channel;\n-    use std::mem::drop;\n-    use std::ops::Drop;\n-    use std::option::Option;\n-    use std::option::Option::{None, Some};\n-    use std::sync::atomic;\n-    use std::sync::atomic::Ordering::{Acquire, SeqCst};\n-    use std::thread;\n-    use std::sync::Mutex;\n-    use std::convert::From;\n-\n-    use super::{Arc, Weak};\n-    use vec::Vec;\n-\n-    struct Canary(*mut atomic::AtomicUsize);\n-\n-    impl Drop for Canary {\n-        fn drop(&mut self) {\n-            unsafe {\n-                match *self {\n-                    Canary(c) => {\n-                        (*c).fetch_add(1, SeqCst);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    fn manually_share_arc() {\n-        let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        let arc_v = Arc::new(v);\n-\n-        let (tx, rx) = channel();\n-\n-        let _t = thread::spawn(move || {\n-            let arc_v: Arc<Vec<i32>> = rx.recv().unwrap();\n-            assert_eq!((*arc_v)[3], 4);\n-        });\n-\n-        tx.send(arc_v.clone()).unwrap();\n-\n-        assert_eq!((*arc_v)[2], 3);\n-        assert_eq!((*arc_v)[4], 5);\n-    }\n-\n-    #[test]\n-    fn test_arc_get_mut() {\n-        let mut x = Arc::new(3);\n-        *Arc::get_mut(&mut x).unwrap() = 4;\n-        assert_eq!(*x, 4);\n-        let y = x.clone();\n-        assert!(Arc::get_mut(&mut x).is_none());\n-        drop(y);\n-        assert!(Arc::get_mut(&mut x).is_some());\n-        let _w = Arc::downgrade(&x);\n-        assert!(Arc::get_mut(&mut x).is_none());\n-    }\n-\n-    #[test]\n-    fn try_unwrap() {\n-        let x = Arc::new(3);\n-        assert_eq!(Arc::try_unwrap(x), Ok(3));\n-        let x = Arc::new(4);\n-        let _y = x.clone();\n-        assert_eq!(Arc::try_unwrap(x), Err(Arc::new(4)));\n-        let x = Arc::new(5);\n-        let _w = Arc::downgrade(&x);\n-        assert_eq!(Arc::try_unwrap(x), Ok(5));\n-    }\n-\n-    #[test]\n-    fn into_from_raw() {\n-        let x = Arc::new(box \"hello\");\n-        let y = x.clone();\n-\n-        let x_ptr = Arc::into_raw(x);\n-        drop(y);\n-        unsafe {\n-            assert_eq!(**x_ptr, \"hello\");\n-\n-            let x = Arc::from_raw(x_ptr);\n-            assert_eq!(**x, \"hello\");\n-\n-            assert_eq!(Arc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_into_from_raw_unsized() {\n-        use std::fmt::Display;\n-        use std::string::ToString;\n-\n-        let arc: Arc<str> = Arc::from(\"foo\");\n-\n-        let ptr = Arc::into_raw(arc.clone());\n-        let arc2 = unsafe { Arc::from_raw(ptr) };\n-\n-        assert_eq!(unsafe { &*ptr }, \"foo\");\n-        assert_eq!(arc, arc2);\n-\n-        let arc: Arc<Display> = Arc::new(123);\n-\n-        let ptr = Arc::into_raw(arc.clone());\n-        let arc2 = unsafe { Arc::from_raw(ptr) };\n-\n-        assert_eq!(unsafe { &*ptr }.to_string(), \"123\");\n-        assert_eq!(arc2.to_string(), \"123\");\n-    }\n-\n-    #[test]\n-    fn test_cowarc_clone_make_mut() {\n-        let mut cow0 = Arc::new(75);\n-        let mut cow1 = cow0.clone();\n-        let mut cow2 = cow1.clone();\n-\n-        assert!(75 == *Arc::make_mut(&mut cow0));\n-        assert!(75 == *Arc::make_mut(&mut cow1));\n-        assert!(75 == *Arc::make_mut(&mut cow2));\n-\n-        *Arc::make_mut(&mut cow0) += 1;\n-        *Arc::make_mut(&mut cow1) += 2;\n-        *Arc::make_mut(&mut cow2) += 3;\n-\n-        assert!(76 == *cow0);\n-        assert!(77 == *cow1);\n-        assert!(78 == *cow2);\n-\n-        // none should point to the same backing memory\n-        assert!(*cow0 != *cow1);\n-        assert!(*cow0 != *cow2);\n-        assert!(*cow1 != *cow2);\n-    }\n-\n-    #[test]\n-    fn test_cowarc_clone_unique2() {\n-        let mut cow0 = Arc::new(75);\n-        let cow1 = cow0.clone();\n-        let cow2 = cow1.clone();\n-\n-        assert!(75 == *cow0);\n-        assert!(75 == *cow1);\n-        assert!(75 == *cow2);\n-\n-        *Arc::make_mut(&mut cow0) += 1;\n-        assert!(76 == *cow0);\n-        assert!(75 == *cow1);\n-        assert!(75 == *cow2);\n-\n-        // cow1 and cow2 should share the same contents\n-        // cow0 should have a unique reference\n-        assert!(*cow0 != *cow1);\n-        assert!(*cow0 != *cow2);\n-        assert!(*cow1 == *cow2);\n-    }\n-\n-    #[test]\n-    fn test_cowarc_clone_weak() {\n-        let mut cow0 = Arc::new(75);\n-        let cow1_weak = Arc::downgrade(&cow0);\n-\n-        assert!(75 == *cow0);\n-        assert!(75 == *cow1_weak.upgrade().unwrap());\n-\n-        *Arc::make_mut(&mut cow0) += 1;\n-\n-        assert!(76 == *cow0);\n-        assert!(cow1_weak.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn test_live() {\n-        let x = Arc::new(5);\n-        let y = Arc::downgrade(&x);\n-        assert!(y.upgrade().is_some());\n-    }\n-\n-    #[test]\n-    fn test_dead() {\n-        let x = Arc::new(5);\n-        let y = Arc::downgrade(&x);\n-        drop(x);\n-        assert!(y.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn weak_self_cyclic() {\n-        struct Cycle {\n-            x: Mutex<Option<Weak<Cycle>>>,\n-        }\n-\n-        let a = Arc::new(Cycle { x: Mutex::new(None) });\n-        let b = Arc::downgrade(&a.clone());\n-        *a.x.lock().unwrap() = Some(b);\n-\n-        // hopefully we don't double-free (or leak)...\n-    }\n-\n-    #[test]\n-    fn drop_arc() {\n-        let mut canary = atomic::AtomicUsize::new(0);\n-        let x = Arc::new(Canary(&mut canary as *mut atomic::AtomicUsize));\n-        drop(x);\n-        assert!(canary.load(Acquire) == 1);\n-    }\n-\n-    #[test]\n-    fn drop_arc_weak() {\n-        let mut canary = atomic::AtomicUsize::new(0);\n-        let arc = Arc::new(Canary(&mut canary as *mut atomic::AtomicUsize));\n-        let arc_weak = Arc::downgrade(&arc);\n-        assert!(canary.load(Acquire) == 0);\n-        drop(arc);\n-        assert!(canary.load(Acquire) == 1);\n-        drop(arc_weak);\n-    }\n-\n-    #[test]\n-    fn test_strong_count() {\n-        let a = Arc::new(0);\n-        assert!(Arc::strong_count(&a) == 1);\n-        let w = Arc::downgrade(&a);\n-        assert!(Arc::strong_count(&a) == 1);\n-        let b = w.upgrade().expect(\"\");\n-        assert!(Arc::strong_count(&b) == 2);\n-        assert!(Arc::strong_count(&a) == 2);\n-        drop(w);\n-        drop(a);\n-        assert!(Arc::strong_count(&b) == 1);\n-        let c = b.clone();\n-        assert!(Arc::strong_count(&b) == 2);\n-        assert!(Arc::strong_count(&c) == 2);\n-    }\n-\n-    #[test]\n-    fn test_weak_count() {\n-        let a = Arc::new(0);\n-        assert!(Arc::strong_count(&a) == 1);\n-        assert!(Arc::weak_count(&a) == 0);\n-        let w = Arc::downgrade(&a);\n-        assert!(Arc::strong_count(&a) == 1);\n-        assert!(Arc::weak_count(&a) == 1);\n-        let x = w.clone();\n-        assert!(Arc::weak_count(&a) == 2);\n-        drop(w);\n-        drop(x);\n-        assert!(Arc::strong_count(&a) == 1);\n-        assert!(Arc::weak_count(&a) == 0);\n-        let c = a.clone();\n-        assert!(Arc::strong_count(&a) == 2);\n-        assert!(Arc::weak_count(&a) == 0);\n-        let d = Arc::downgrade(&c);\n-        assert!(Arc::weak_count(&c) == 1);\n-        assert!(Arc::strong_count(&c) == 2);\n-\n-        drop(a);\n-        drop(c);\n-        drop(d);\n-    }\n-\n-    #[test]\n-    fn show_arc() {\n-        let a = Arc::new(5);\n-        assert_eq!(format!(\"{:?}\", a), \"5\");\n-    }\n-\n-    // Make sure deriving works with Arc<T>\n-    #[derive(Eq, Ord, PartialEq, PartialOrd, Clone, Debug, Default)]\n-    struct Foo {\n-        inner: Arc<i32>,\n-    }\n-\n-    #[test]\n-    fn test_unsized() {\n-        let x: Arc<[i32]> = Arc::new([1, 2, 3]);\n-        assert_eq!(format!(\"{:?}\", x), \"[1, 2, 3]\");\n-        let y = Arc::downgrade(&x.clone());\n-        drop(x);\n-        assert!(y.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn test_from_owned() {\n-        let foo = 123;\n-        let foo_arc = Arc::from(foo);\n-        assert!(123 == *foo_arc);\n-    }\n-\n-    #[test]\n-    fn test_new_weak() {\n-        let foo: Weak<usize> = Weak::new();\n-        assert!(foo.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn test_ptr_eq() {\n-        let five = Arc::new(5);\n-        let same_five = five.clone();\n-        let other_five = Arc::new(5);\n-\n-        assert!(Arc::ptr_eq(&five, &same_five));\n-        assert!(!Arc::ptr_eq(&five, &other_five));\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    fn test_weak_count_locked() {\n-        let mut a = Arc::new(atomic::AtomicBool::new(false));\n-        let a2 = a.clone();\n-        let t = thread::spawn(move || {\n-            for _i in 0..1000000 {\n-                Arc::get_mut(&mut a);\n-            }\n-            a.store(true, SeqCst);\n-        });\n-\n-        while !a2.load(SeqCst) {\n-            let n = Arc::weak_count(&a2);\n-            assert!(n < 2, \"bad weak count: {}\", n);\n-        }\n-        t.join().unwrap();\n-    }\n-\n-    #[test]\n-    fn test_from_str() {\n-        let r: Arc<str> = Arc::from(\"foo\");\n-\n-        assert_eq!(&r[..], \"foo\");\n-    }\n-\n-    #[test]\n-    fn test_copy_from_slice() {\n-        let s: &[u32] = &[1, 2, 3];\n-        let r: Arc<[u32]> = Arc::from(s);\n-\n-        assert_eq!(&r[..], [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_clone_from_slice() {\n-        #[derive(Clone, Debug, Eq, PartialEq)]\n-        struct X(u32);\n-\n-        let s: &[X] = &[X(1), X(2), X(3)];\n-        let r: Arc<[X]> = Arc::from(s);\n-\n-        assert_eq!(&r[..], s);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_clone_from_slice_panic() {\n-        use std::string::{String, ToString};\n-\n-        struct Fail(u32, String);\n-\n-        impl Clone for Fail {\n-            fn clone(&self) -> Fail {\n-                if self.0 == 2 {\n-                    panic!();\n-                }\n-                Fail(self.0, self.1.clone())\n-            }\n-        }\n-\n-        let s: &[Fail] = &[\n-            Fail(0, \"foo\".to_string()),\n-            Fail(1, \"bar\".to_string()),\n-            Fail(2, \"baz\".to_string()),\n-        ];\n-\n-        // Should panic, but not cause memory corruption\n-        let _r: Arc<[Fail]> = Arc::from(s);\n-    }\n-\n-    #[test]\n-    fn test_from_box() {\n-        let b: Box<u32> = box 123;\n-        let r: Arc<u32> = Arc::from(b);\n-\n-        assert_eq!(*r, 123);\n-    }\n-\n-    #[test]\n-    fn test_from_box_str() {\n-        use std::string::String;\n-\n-        let s = String::from(\"foo\").into_boxed_str();\n-        let r: Arc<str> = Arc::from(s);\n-\n-        assert_eq!(&r[..], \"foo\");\n-    }\n-\n-    #[test]\n-    fn test_from_box_slice() {\n-        let s = vec![1, 2, 3].into_boxed_slice();\n-        let r: Arc<[u32]> = Arc::from(s);\n-\n-        assert_eq!(&r[..], [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_from_box_trait() {\n-        use std::fmt::Display;\n-        use std::string::ToString;\n-\n-        let b: Box<Display> = box 123;\n-        let r: Arc<Display> = Arc::from(b);\n-\n-        assert_eq!(r.to_string(), \"123\");\n-    }\n-\n-    #[test]\n-    fn test_from_box_trait_zero_sized() {\n-        use std::fmt::Debug;\n-\n-        let b: Box<Debug> = box ();\n-        let r: Arc<Debug> = Arc::from(b);\n-\n-        assert_eq!(format!(\"{:?}\", r), \"()\");\n-    }\n-\n-    #[test]\n-    fn test_from_vec() {\n-        let v = vec![1, 2, 3];\n-        let r: Arc<[u32]> = Arc::from(v);\n-\n-        assert_eq!(&r[..], [1, 2, 3]);\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: ?Sized> borrow::Borrow<T> for Arc<T> {\n-    fn borrow(&self) -> &T {\n-        &**self\n-    }\n-}\n-\n-#[stable(since = \"1.5.0\", feature = \"smart_ptr_as_ref\")]\n-impl<T: ?Sized> AsRef<T> for Arc<T> {\n-    fn as_ref(&self) -> &T {\n-        &**self\n-    }\n-}"}, {"sha": "2cf9b13a67a2750754b0f98070a52aec2e979d34", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 176, "deletions": 15, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -58,14 +58,16 @@\n use core::any::Any;\n use core::borrow;\n use core::cmp::Ordering;\n+use core::convert::From;\n use core::fmt;\n+use core::future::{Future, FutureObj, LocalFutureObj, UnsafeFutureObj};\n use core::hash::{Hash, Hasher};\n use core::iter::FusedIterator;\n use core::marker::{Unpin, Unsize};\n-use core::mem::{self, Pin};\n+use core::mem::{self, PinMut};\n use core::ops::{CoerceUnsized, Deref, DerefMut, Generator, GeneratorState};\n use core::ptr::{self, NonNull, Unique};\n-use core::convert::From;\n+use core::task::{Context, Poll, Executor, SpawnErrorKind, SpawnObjError};\n \n use raw_vec::RawVec;\n use str::from_boxed_utf8_unchecked;\n@@ -192,7 +194,9 @@ impl<T: ?Sized> Box<T> {\n     }\n \n     /// Consumes and leaks the `Box`, returning a mutable reference,\n-    /// `&'a mut T`. Here, the lifetime `'a` may be chosen to be `'static`.\n+    /// `&'a mut T`. Note that the type `T` must outlive the chosen lifetime\n+    /// `'a`. If the type has only static references, or none at all, then this\n+    /// may be chosen to be `'static`.\n     ///\n     /// This function is mainly useful for data that lives for the remainder of\n     /// the program's life. Dropping the returned reference will cause a memory\n@@ -444,7 +448,7 @@ impl From<Box<str>> for Box<[u8]> {\n     }\n }\n \n-impl Box<Any> {\n+impl Box<dyn Any> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Attempt to downcast the box to a concrete type.\n@@ -466,10 +470,10 @@ impl Box<Any> {\n     ///     print_if_string(Box::new(0i8));\n     /// }\n     /// ```\n-    pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any>> {\n+    pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<dyn Any>> {\n         if self.is::<T>() {\n             unsafe {\n-                let raw: *mut Any = Box::into_raw(self);\n+                let raw: *mut dyn Any = Box::into_raw(self);\n                 Ok(Box::from_raw(raw as *mut T))\n             }\n         } else {\n@@ -478,7 +482,7 @@ impl Box<Any> {\n     }\n }\n \n-impl Box<Any + Send> {\n+impl Box<dyn Any + Send> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Attempt to downcast the box to a concrete type.\n@@ -500,10 +504,10 @@ impl Box<Any + Send> {\n     ///     print_if_string(Box::new(0i8));\n     /// }\n     /// ```\n-    pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any + Send>> {\n-        <Box<Any>>::downcast(self).map_err(|s| unsafe {\n+    pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<dyn Any + Send>> {\n+        <Box<dyn Any>>::downcast(self).map_err(|s| unsafe {\n             // reapply the Send marker\n-            Box::from_raw(Box::into_raw(s) as *mut (Any + Send))\n+            Box::from_raw(Box::into_raw(s) as *mut (dyn Any + Send))\n         })\n     }\n }\n@@ -641,7 +645,7 @@ impl<A, F> FnBox<A> for F\n \n #[unstable(feature = \"fnbox\",\n            reason = \"will be deprecated if and when `Box<FnOnce>` becomes usable\", issue = \"28796\")]\n-impl<'a, A, R> FnOnce<A> for Box<FnBox<A, Output = R> + 'a> {\n+impl<'a, A, R> FnOnce<A> for Box<dyn FnBox<A, Output = R> + 'a> {\n     type Output = R;\n \n     extern \"rust-call\" fn call_once(self, args: A) -> R {\n@@ -651,7 +655,7 @@ impl<'a, A, R> FnOnce<A> for Box<FnBox<A, Output = R> + 'a> {\n \n #[unstable(feature = \"fnbox\",\n            reason = \"will be deprecated if and when `Box<FnOnce>` becomes usable\", issue = \"28796\")]\n-impl<'a, A, R> FnOnce<A> for Box<FnBox<A, Output = R> + Send + 'a> {\n+impl<'a, A, R> FnOnce<A> for Box<dyn FnBox<A, Output = R> + Send + 'a> {\n     type Output = R;\n \n     extern \"rust-call\" fn call_once(self, args: A) -> R {\n@@ -755,6 +759,7 @@ impl<T> Generator for Box<T>\n /// A pinned, heap allocated reference.\n #[unstable(feature = \"pin\", issue = \"49150\")]\n #[fundamental]\n+#[repr(transparent)]\n pub struct PinBox<T: ?Sized> {\n     inner: Box<T>,\n }\n@@ -771,14 +776,72 @@ impl<T> PinBox<T> {\n #[unstable(feature = \"pin\", issue = \"49150\")]\n impl<T: ?Sized> PinBox<T> {\n     /// Get a pinned reference to the data in this PinBox.\n-    pub fn as_pin<'a>(&'a mut self) -> Pin<'a, T> {\n-        unsafe { Pin::new_unchecked(&mut *self.inner) }\n+    #[inline]\n+    pub fn as_pin_mut<'a>(&'a mut self) -> PinMut<'a, T> {\n+        unsafe { PinMut::new_unchecked(&mut *self.inner) }\n+    }\n+\n+    /// Constructs a `PinBox` from a raw pointer.\n+    ///\n+    /// After calling this function, the raw pointer is owned by the\n+    /// resulting `PinBox`. Specifically, the `PinBox` destructor will call\n+    /// the destructor of `T` and free the allocated memory. Since the\n+    /// way `PinBox` allocates and releases memory is unspecified, the\n+    /// only valid pointer to pass to this function is the one taken\n+    /// from another `PinBox` via the [`PinBox::into_raw`] function.\n+    ///\n+    /// This function is unsafe because improper use may lead to\n+    /// memory problems. For example, a double-free may occur if the\n+    /// function is called twice on the same raw pointer.\n+    ///\n+    /// [`PinBox::into_raw`]: struct.PinBox.html#method.into_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(pin)]\n+    /// use std::boxed::PinBox;\n+    /// let x = PinBox::new(5);\n+    /// let ptr = PinBox::into_raw(x);\n+    /// let x = unsafe { PinBox::from_raw(ptr) };\n+    /// ```\n+    #[inline]\n+    pub unsafe fn from_raw(raw: *mut T) -> Self {\n+        PinBox { inner: Box::from_raw(raw) }\n+    }\n+\n+    /// Consumes the `PinBox`, returning the wrapped raw pointer.\n+    ///\n+    /// After calling this function, the caller is responsible for the\n+    /// memory previously managed by the `PinBox`. In particular, the\n+    /// caller should properly destroy `T` and release the memory. The\n+    /// proper way to do so is to convert the raw pointer back into a\n+    /// `PinBox` with the [`PinBox::from_raw`] function.\n+    ///\n+    /// Note: this is an associated function, which means that you have\n+    /// to call it as `PinBox::into_raw(b)` instead of `b.into_raw()`. This\n+    /// is so that there is no conflict with a method on the inner type.\n+    ///\n+    /// [`PinBox::from_raw`]: struct.PinBox.html#method.from_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(pin)]\n+    /// use std::boxed::PinBox;\n+    /// let x = PinBox::new(5);\n+    /// let ptr = PinBox::into_raw(x);\n+    /// ```\n+    #[inline]\n+    pub fn into_raw(b: PinBox<T>) -> *mut T {\n+        Box::into_raw(b.inner)\n     }\n \n     /// Get a mutable reference to the data inside this PinBox.\n     ///\n     /// This function is unsafe. Users must guarantee that the data is never\n     /// moved out of this reference.\n+    #[inline]\n     pub unsafe fn get_mut<'a>(this: &'a mut PinBox<T>) -> &'a mut T {\n         &mut *this.inner\n     }\n@@ -787,6 +850,7 @@ impl<T: ?Sized> PinBox<T> {\n     ///\n     /// This function is unsafe. Users must guarantee that the data is never\n     /// moved out of the box.\n+    #[inline]\n     pub unsafe fn unpin(this: PinBox<T>) -> Box<T> {\n         this.inner\n     }\n@@ -850,4 +914,101 @@ impl<T: ?Sized> fmt::Pointer for PinBox<T> {\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<PinBox<U>> for PinBox<T> {}\n \n #[unstable(feature = \"pin\", issue = \"49150\")]\n-unsafe impl<T: ?Sized> Unpin for PinBox<T> {}\n+impl<T: ?Sized> Unpin for PinBox<T> {}\n+\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+impl<F: ?Sized + Future + Unpin> Future for Box<F> {\n+    type Output = F::Output;\n+\n+    fn poll(mut self: PinMut<Self>, cx: &mut Context) -> Poll<Self::Output> {\n+        PinMut::new(&mut **self).poll(cx)\n+    }\n+}\n+\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+impl<F: ?Sized + Future> Future for PinBox<F> {\n+    type Output = F::Output;\n+\n+    fn poll(mut self: PinMut<Self>, cx: &mut Context) -> Poll<Self::Output> {\n+        self.as_pin_mut().poll(cx)\n+    }\n+}\n+\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+unsafe impl<'a, T, F> UnsafeFutureObj<'a, T> for Box<F>\n+    where F: Future<Output = T> + 'a\n+{\n+    fn into_raw(self) -> *mut () {\n+        Box::into_raw(self) as *mut ()\n+    }\n+\n+    unsafe fn poll(ptr: *mut (), cx: &mut Context) -> Poll<T> {\n+        let ptr = ptr as *mut F;\n+        let pin: PinMut<F> = PinMut::new_unchecked(&mut *ptr);\n+        pin.poll(cx)\n+    }\n+\n+    unsafe fn drop(ptr: *mut ()) {\n+        drop(Box::from_raw(ptr as *mut F))\n+    }\n+}\n+\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+unsafe impl<'a, T, F> UnsafeFutureObj<'a, T> for PinBox<F>\n+    where F: Future<Output = T> + 'a\n+{\n+    fn into_raw(self) -> *mut () {\n+        PinBox::into_raw(self) as *mut ()\n+    }\n+\n+    unsafe fn poll(ptr: *mut (), cx: &mut Context) -> Poll<T> {\n+        let ptr = ptr as *mut F;\n+        let pin: PinMut<F> = PinMut::new_unchecked(&mut *ptr);\n+        pin.poll(cx)\n+    }\n+\n+    unsafe fn drop(ptr: *mut ()) {\n+        drop(PinBox::from_raw(ptr as *mut F))\n+    }\n+}\n+\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+impl<E> Executor for Box<E>\n+    where E: Executor + ?Sized\n+{\n+    fn spawn_obj(&mut self, task: FutureObj<'static, ()>) -> Result<(), SpawnObjError> {\n+        (**self).spawn_obj(task)\n+    }\n+\n+    fn status(&self) -> Result<(), SpawnErrorKind> {\n+        (**self).status()\n+    }\n+}\n+\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+impl<'a, F: Future<Output = ()> + Send + 'a> From<PinBox<F>> for FutureObj<'a, ()> {\n+    fn from(boxed: PinBox<F>) -> Self {\n+        FutureObj::new(boxed)\n+    }\n+}\n+\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+impl<'a, F: Future<Output = ()> + Send + 'a> From<Box<F>> for FutureObj<'a, ()> {\n+    fn from(boxed: Box<F>) -> Self {\n+        FutureObj::new(boxed)\n+    }\n+}\n+\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+impl<'a, F: Future<Output = ()> + 'a> From<PinBox<F>> for LocalFutureObj<'a, ()> {\n+    fn from(boxed: PinBox<F>) -> Self {\n+        LocalFutureObj::new(boxed)\n+    }\n+}\n+\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+impl<'a, F: Future<Output = ()> + 'a> From<Box<F>> for LocalFutureObj<'a, ()> {\n+    fn from(boxed: Box<F>) -> Self {\n+        LocalFutureObj::new(boxed)\n+    }\n+}"}, {"sha": "55995742a4a7da7bfa1ce5ec4008145190da7842", "filename": "src/liballoc/boxed_test.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fboxed_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fboxed_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed_test.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -31,8 +31,8 @@ struct Test;\n \n #[test]\n fn any_move() {\n-    let a = Box::new(8) as Box<Any>;\n-    let b = Box::new(Test) as Box<Any>;\n+    let a = Box::new(8) as Box<dyn Any>;\n+    let b = Box::new(Test) as Box<dyn Any>;\n \n     match a.downcast::<i32>() {\n         Ok(a) => {\n@@ -47,26 +47,26 @@ fn any_move() {\n         Err(..) => panic!(),\n     }\n \n-    let a = Box::new(8) as Box<Any>;\n-    let b = Box::new(Test) as Box<Any>;\n+    let a = Box::new(8) as Box<dyn Any>;\n+    let b = Box::new(Test) as Box<dyn Any>;\n \n     assert!(a.downcast::<Box<Test>>().is_err());\n     assert!(b.downcast::<Box<i32>>().is_err());\n }\n \n #[test]\n fn test_show() {\n-    let a = Box::new(8) as Box<Any>;\n-    let b = Box::new(Test) as Box<Any>;\n+    let a = Box::new(8) as Box<dyn Any>;\n+    let b = Box::new(Test) as Box<dyn Any>;\n     let a_str = format!(\"{:?}\", a);\n     let b_str = format!(\"{:?}\", b);\n     assert_eq!(a_str, \"Any\");\n     assert_eq!(b_str, \"Any\");\n \n     static EIGHT: usize = 8;\n     static TEST: Test = Test;\n-    let a = &EIGHT as &Any;\n-    let b = &TEST as &Any;\n+    let a = &EIGHT as &dyn Any;\n+    let b = &TEST as &dyn Any;\n     let s = format!(\"{:?}\", a);\n     assert_eq!(s, \"Any\");\n     let s = format!(\"{:?}\", b);\n@@ -110,12 +110,12 @@ fn raw_trait() {\n         }\n     }\n \n-    let x: Box<Foo> = Box::new(Bar(17));\n+    let x: Box<dyn Foo> = Box::new(Bar(17));\n     let p = Box::into_raw(x);\n     unsafe {\n         assert_eq!(17, (*p).get());\n         (*p).set(19);\n-        let y: Box<Foo> = Box::from_raw(p);\n+        let y: Box<dyn Foo> = Box::from_raw(p);\n         assert_eq!(19, y.get());\n     }\n }"}, {"sha": "fcadcb544c431a9e9ede7bc00912ce3123b2533c", "filename": "src/liballoc/collections/binary_heap.rs", "status": "renamed", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -157,7 +157,7 @@\n \n use core::ops::{Deref, DerefMut};\n use core::iter::{FromIterator, FusedIterator};\n-use core::mem::{swap, size_of};\n+use core::mem::{swap, size_of, ManuallyDrop};\n use core::ptr;\n use core::fmt;\n \n@@ -864,8 +864,7 @@ impl<T: Ord> BinaryHeap<T> {\n /// position with the value that was originally removed.\n struct Hole<'a, T: 'a> {\n     data: &'a mut [T],\n-    /// `elt` is always `Some` from new until drop.\n-    elt: Option<T>,\n+    elt: ManuallyDrop<T>,\n     pos: usize,\n }\n \n@@ -879,7 +878,7 @@ impl<'a, T> Hole<'a, T> {\n         let elt = ptr::read(&data[pos]);\n         Hole {\n             data,\n-            elt: Some(elt),\n+            elt: ManuallyDrop::new(elt),\n             pos,\n         }\n     }\n@@ -892,7 +891,7 @@ impl<'a, T> Hole<'a, T> {\n     /// Returns a reference to the element removed.\n     #[inline]\n     fn element(&self) -> &T {\n-        self.elt.as_ref().unwrap()\n+        &self.elt\n     }\n \n     /// Returns a reference to the element at `index`.\n@@ -925,7 +924,7 @@ impl<'a, T> Drop for Hole<'a, T> {\n         // fill the hole again\n         unsafe {\n             let pos = self.pos;\n-            ptr::write(self.data.get_unchecked_mut(pos), self.elt.take().unwrap());\n+            ptr::copy_nonoverlapping(&*self.elt, self.data.get_unchecked_mut(pos), 1);\n         }\n     }\n }", "previous_filename": "src/liballoc/binary_heap.rs"}, {"sha": "8c950cd06d9e385373f56175d5253060c4e8390a", "filename": "src/liballoc/collections/btree/map.rs", "status": "renamed", "additions": 56, "deletions": 17, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -149,12 +149,11 @@ unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for BTreeMap<K, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n     fn clone(&self) -> BTreeMap<K, V> {\n-        fn clone_subtree<K: Clone, V: Clone>(node: node::NodeRef<marker::Immut,\n-                                                                 K,\n-                                                                 V,\n-                                                                 marker::LeafOrInternal>)\n-                                             -> BTreeMap<K, V> {\n-\n+        fn clone_subtree<'a, K: Clone, V: Clone>(\n+            node: node::NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>\n+        ) -> BTreeMap<K, V>\n+        where K: 'a, V: 'a,\n+        {\n             match node.force() {\n                 Leaf(leaf) => {\n                     let mut out_tree = BTreeMap {\n@@ -213,7 +212,16 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n             }\n         }\n \n-        clone_subtree(self.root.as_ref())\n+        if self.len() == 0 {\n+            // Ideally we'd call `BTreeMap::new` here, but that has the `K:\n+            // Ord` constraint, which this method lacks.\n+            BTreeMap {\n+                root: node::Root::shared_empty_root(),\n+                length: 0,\n+            }\n+        } else {\n+            clone_subtree(self.root.as_ref())\n+        }\n     }\n }\n \n@@ -246,6 +254,7 @@ impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n     }\n \n     fn replace(&mut self, key: K) -> Option<K> {\n+        self.ensure_root_is_owned();\n         match search::search_tree::<marker::Mut, K, (), K>(self.root.as_mut(), &key) {\n             Found(handle) => Some(mem::replace(handle.into_kv_mut().0, key)),\n             GoDown(handle) => {\n@@ -523,7 +532,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> BTreeMap<K, V> {\n         BTreeMap {\n-            root: node::Root::new_leaf(),\n+            root: node::Root::shared_empty_root(),\n             length: 0,\n         }\n     }\n@@ -544,7 +553,6 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn clear(&mut self) {\n-        // FIXME(gereeter) .clear() allocates\n         *self = BTreeMap::new();\n     }\n \n@@ -890,6 +898,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn entry(&mut self, key: K) -> Entry<K, V> {\n+        // FIXME(@porglezomp) Avoid allocating if we don't insert\n+        self.ensure_root_is_owned();\n         match search::search_tree(self.root.as_mut(), &key) {\n             Found(handle) => {\n                 Occupied(OccupiedEntry {\n@@ -910,6 +920,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     }\n \n     fn from_sorted_iter<I: Iterator<Item = (K, V)>>(&mut self, iter: I) {\n+        self.ensure_root_is_owned();\n         let mut cur_node = last_leaf_edge(self.root.as_mut()).into_node();\n         // Iterate through all key-value pairs, pushing them into nodes at the right level.\n         for (key, value) in iter {\n@@ -1019,6 +1030,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         let total_num = self.len();\n \n         let mut right = Self::new();\n+        right.root = node::Root::new_leaf();\n         for _ in 0..(self.root.as_ref().height()) {\n             right.root.push_level();\n         }\n@@ -1067,7 +1079,11 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n     /// Calculates the number of elements if it is incorrect.\n     fn recalc_length(&mut self) {\n-        fn dfs<K, V>(node: NodeRef<marker::Immut, K, V, marker::LeafOrInternal>) -> usize {\n+        fn dfs<'a, K, V>(\n+            node: NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>\n+        ) -> usize\n+        where K: 'a, V: 'a\n+        {\n             let mut res = node.len();\n \n             if let Internal(node) = node.force() {\n@@ -1153,6 +1169,13 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n         self.fix_top();\n     }\n+\n+    /// If the root node is the shared root node, allocate our own node.\n+    fn ensure_root_is_owned(&mut self) {\n+        if self.root.is_shared_root() {\n+            self.root = node::Root::new_leaf();\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1290,6 +1313,10 @@ impl<K, V> Drop for IntoIter<K, V> {\n         self.for_each(drop);\n         unsafe {\n             let leaf_node = ptr::read(&self.front).into_node();\n+            if leaf_node.is_shared_root() {\n+                return;\n+            }\n+\n             if let Some(first_parent) = leaf_node.deallocate_and_ascend() {\n                 let mut cur_node = first_parent.into_node();\n                 while let Some(parent) = cur_node.deallocate_and_ascend() {\n@@ -1819,7 +1846,7 @@ fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n      Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>)\n         where Q: Ord, K: Borrow<Q>\n {\n-    match (range.start(), range.end()) {\n+    match (range.start_bound(), range.end_bound()) {\n         (Excluded(s), Excluded(e)) if s==e =>\n             panic!(\"range start and end are equal and excluded in BTreeMap\"),\n         (Included(s), Included(e)) |\n@@ -1837,7 +1864,7 @@ fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n     let mut diverged = false;\n \n     loop {\n-        let min_edge = match (min_found, range.start()) {\n+        let min_edge = match (min_found, range.start_bound()) {\n             (false, Included(key)) => match search::search_linear(&min_node, key) {\n                 (i, true) => { min_found = true; i },\n                 (i, false) => i,\n@@ -1851,7 +1878,7 @@ fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n             (true, Excluded(_)) => 0,\n         };\n \n-        let max_edge = match (max_found, range.end()) {\n+        let max_edge = match (max_found, range.end_bound()) {\n             (false, Included(key)) => match search::search_linear(&max_node, key) {\n                 (i, true) => { max_found = true; i+1 },\n                 (i, false) => i,\n@@ -2169,14 +2196,13 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n }\n \n impl<'a, K: Ord, V: Default> Entry<'a, K, V> {\n-    #[unstable(feature = \"entry_or_default\", issue = \"44324\")]\n+    #[stable(feature = \"entry_or_default\", since = \"1.28.0\")]\n     /// Ensures a value is in the entry by inserting the default value if empty,\n     /// and returns a mutable reference to the value in the entry.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(entry_or_default)]\n     /// # fn main() {\n     /// use std::collections::BTreeMap;\n     ///\n@@ -2354,6 +2380,11 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n \n     /// Gets a mutable reference to the value in the entry.\n     ///\n+    /// If you need a reference to the `OccupiedEntry` which may outlive the\n+    /// destruction of the `Entry` value, see [`into_mut`].\n+    ///\n+    /// [`into_mut`]: #method.into_mut\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2365,9 +2396,13 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     ///\n     /// assert_eq!(map[\"poneyland\"], 12);\n     /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n-    ///      *o.get_mut() += 10;\n+    ///     *o.get_mut() += 10;\n+    ///     assert_eq!(*o.get(), 22);\n+    ///\n+    ///     // We can use the same Entry multiple times.\n+    ///     *o.get_mut() += 2;\n     /// }\n-    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// assert_eq!(map[\"poneyland\"], 24);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut V {\n@@ -2376,6 +2411,10 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n \n     /// Converts the entry into a mutable reference to its value.\n     ///\n+    /// If you need multiple references to the `OccupiedEntry`, see [`get_mut`].\n+    ///\n+    /// [`get_mut`]: #method.get_mut\n+    ///\n     /// # Examples\n     ///\n     /// ```", "previous_filename": "src/liballoc/btree/map.rs"}, {"sha": "087c9f228d4448bb6c119675ce28eac9e354a6b4", "filename": "src/liballoc/collections/btree/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "previous_filename": "src/liballoc/btree/mod.rs"}, {"sha": "0ae45b3123259a2b7dbb4c7286d3207757f3f3b4", "filename": "src/liballoc/collections/btree/node.rs", "status": "renamed", "additions": 116, "deletions": 34, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -60,12 +60,12 @@ pub const CAPACITY: usize = 2 * B - 1;\n ///\n /// See also rust-lang/rfcs#197, which would make this structure significantly more safe by\n /// avoiding accidentally dropping unused and uninitialized keys and values.\n+///\n+/// We put the metadata first so that its position is the same for every `K` and `V`, in order\n+/// to statically allocate a single dummy node to avoid allocations. This struct is `repr(C)` to\n+/// prevent them from being reordered.\n+#[repr(C)]\n struct LeafNode<K, V> {\n-    /// The arrays storing the actual data of the node. Only the first `len` elements of each\n-    /// array are initialized and valid.\n-    keys: [K; CAPACITY],\n-    vals: [V; CAPACITY],\n-\n     /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n     /// This either points to an actual node or is null.\n     parent: *const InternalNode<K, V>,\n@@ -77,10 +77,14 @@ struct LeafNode<K, V> {\n \n     /// The number of keys and values this node stores.\n     ///\n-    /// This is at the end of the node's representation and next to `parent_idx` to encourage\n-    /// the compiler to join `len` and `parent_idx` into the same 32-bit word, reducing space\n-    /// overhead.\n+    /// This next to `parent_idx` to encourage the compiler to join `len` and\n+    /// `parent_idx` into the same 32-bit word, reducing space overhead.\n     len: u16,\n+\n+    /// The arrays storing the actual data of the node. Only the first `len` elements of each\n+    /// array are initialized and valid.\n+    keys: [K; CAPACITY],\n+    vals: [V; CAPACITY],\n }\n \n impl<K, V> LeafNode<K, V> {\n@@ -97,8 +101,26 @@ impl<K, V> LeafNode<K, V> {\n             len: 0\n         }\n     }\n+\n+    fn is_shared_root(&self) -> bool {\n+        ptr::eq(self, &EMPTY_ROOT_NODE as *const _ as *const _)\n+    }\n }\n \n+// We need to implement Sync here in order to make a static instance.\n+unsafe impl Sync for LeafNode<(), ()> {}\n+\n+// An empty node used as a placeholder for the root node, to avoid allocations.\n+// We use () in order to save space, since no operation on an empty tree will\n+// ever take a pointer past the first key.\n+static EMPTY_ROOT_NODE: LeafNode<(), ()> = LeafNode {\n+    parent: ptr::null(),\n+    parent_idx: 0,\n+    len: 0,\n+    keys: [(); CAPACITY],\n+    vals: [(); CAPACITY],\n+};\n+\n /// The underlying representation of internal nodes. As with `LeafNode`s, these should be hidden\n /// behind `BoxedNode`s to prevent dropping uninitialized keys and values. Any pointer to an\n /// `InternalNode` can be directly casted to a pointer to the underlying `LeafNode` portion of the\n@@ -168,6 +190,21 @@ unsafe impl<K: Sync, V: Sync> Sync for Root<K, V> { }\n unsafe impl<K: Send, V: Send> Send for Root<K, V> { }\n \n impl<K, V> Root<K, V> {\n+    pub fn is_shared_root(&self) -> bool {\n+        self.as_ref().is_shared_root()\n+    }\n+\n+    pub fn shared_empty_root() -> Self {\n+        Root {\n+            node: unsafe {\n+                BoxedNode::from_ptr(NonNull::new_unchecked(\n+                    &EMPTY_ROOT_NODE as *const _ as *const LeafNode<K, V> as *mut _\n+                ))\n+            },\n+            height: 0,\n+        }\n+    }\n+\n     pub fn new_leaf() -> Self {\n         Root {\n             node: BoxedNode::from_leaf(Box::new(unsafe { LeafNode::new() })),\n@@ -209,6 +246,7 @@ impl<K, V> Root<K, V> {\n     /// new node the root. This increases the height by 1 and is the opposite of `pop_level`.\n     pub fn push_level(&mut self)\n             -> NodeRef<marker::Mut, K, V, marker::Internal> {\n+        debug_assert!(!self.is_shared_root());\n         let mut new_node = Box::new(unsafe { InternalNode::new() });\n         new_node.edges[0] = unsafe { BoxedNode::from_ptr(self.node.as_ptr()) };\n \n@@ -249,7 +287,7 @@ impl<K, V> Root<K, V> {\n         self.as_mut().as_leaf_mut().parent = ptr::null();\n \n         unsafe {\n-            Global.dealloc(NonNull::from(top).as_opaque(), Layout::new::<InternalNode<K, V>>());\n+            Global.dealloc(NonNull::from(top).cast(), Layout::new::<InternalNode<K, V>>());\n         }\n     }\n }\n@@ -353,12 +391,16 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         }\n     }\n \n+    pub fn is_shared_root(&self) -> bool {\n+        self.as_leaf().is_shared_root()\n+    }\n+\n     pub fn keys(&self) -> &[K] {\n-        self.reborrow().into_slices().0\n+        self.reborrow().into_key_slice()\n     }\n \n-    pub fn vals(&self) -> &[V] {\n-        self.reborrow().into_slices().1\n+    fn vals(&self) -> &[V] {\n+        self.reborrow().into_val_slice()\n     }\n \n     /// Finds the parent of the current node. Returns `Ok(handle)` if the current\n@@ -433,9 +475,10 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n             marker::Edge\n         >\n     > {\n+        debug_assert!(!self.is_shared_root());\n         let node = self.node;\n         let ret = self.ascend().ok();\n-        Global.dealloc(node.as_opaque(), Layout::new::<LeafNode<K, V>>());\n+        Global.dealloc(node.cast(), Layout::new::<LeafNode<K, V>>());\n         ret\n     }\n }\n@@ -456,7 +499,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n     > {\n         let node = self.node;\n         let ret = self.ascend().ok();\n-        Global.dealloc(node.as_opaque(), Layout::new::<InternalNode<K, V>>());\n+        Global.dealloc(node.cast(), Layout::new::<InternalNode<K, V>>());\n         ret\n     }\n }\n@@ -500,30 +543,51 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         }\n     }\n \n-    pub fn keys_mut(&mut self) -> &mut [K] {\n-        unsafe { self.reborrow_mut().into_slices_mut().0 }\n+    fn keys_mut(&mut self) -> &mut [K] {\n+        unsafe { self.reborrow_mut().into_key_slice_mut() }\n     }\n \n-    pub fn vals_mut(&mut self) -> &mut [V] {\n-        unsafe { self.reborrow_mut().into_slices_mut().1 }\n+    fn vals_mut(&mut self) -> &mut [V] {\n+        unsafe { self.reborrow_mut().into_val_slice_mut() }\n     }\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n-    pub fn into_slices(self) -> (&'a [K], &'a [V]) {\n-        unsafe {\n-            (\n+    fn into_key_slice(self) -> &'a [K] {\n+        // When taking a pointer to the keys, if our key has a stricter\n+        // alignment requirement than the shared root does, then the pointer\n+        // would be out of bounds, which LLVM assumes will not happen. If the\n+        // alignment is more strict, we need to make an empty slice that doesn't\n+        // use an out of bounds pointer.\n+        if mem::align_of::<K>() > mem::align_of::<LeafNode<(), ()>>() && self.is_shared_root() {\n+            &[]\n+        } else {\n+            // Here either it's not the root, or the alignment is less strict,\n+            // in which case the keys pointer will point \"one-past-the-end\" of\n+            // the node, which is allowed by LLVM.\n+            unsafe {\n                 slice::from_raw_parts(\n                     self.as_leaf().keys.as_ptr(),\n                     self.len()\n-                ),\n-                slice::from_raw_parts(\n-                    self.as_leaf().vals.as_ptr(),\n-                    self.len()\n                 )\n+            }\n+        }\n+    }\n+\n+    fn into_val_slice(self) -> &'a [V] {\n+        debug_assert!(!self.is_shared_root());\n+        unsafe {\n+            slice::from_raw_parts(\n+                self.as_leaf().vals.as_ptr(),\n+                self.len()\n             )\n         }\n     }\n+\n+    fn into_slices(self) -> (&'a [K], &'a [V]) {\n+        let k = unsafe { ptr::read(&self) };\n+        (k.into_key_slice(), self.into_val_slice())\n+    }\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n@@ -535,27 +599,41 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         }\n     }\n \n-    pub fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n-        unsafe {\n-            (\n+    fn into_key_slice_mut(mut self) -> &'a mut [K] {\n+        if mem::align_of::<K>() > mem::align_of::<LeafNode<(), ()>>() && self.is_shared_root() {\n+            &mut []\n+        } else {\n+            unsafe {\n                 slice::from_raw_parts_mut(\n                     &mut self.as_leaf_mut().keys as *mut [K] as *mut K,\n                     self.len()\n-                ),\n-                slice::from_raw_parts_mut(\n-                    &mut self.as_leaf_mut().vals as *mut [V] as *mut V,\n-                    self.len()\n                 )\n+            }\n+        }\n+    }\n+\n+    fn into_val_slice_mut(mut self) -> &'a mut [V] {\n+        debug_assert!(!self.is_shared_root());\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                &mut self.as_leaf_mut().vals as *mut [V] as *mut V,\n+                self.len()\n             )\n         }\n     }\n+\n+    fn into_slices_mut(self) -> (&'a mut [K], &'a mut [V]) {\n+        let k = unsafe { ptr::read(&self) };\n+        (k.into_key_slice_mut(), self.into_val_slice_mut())\n+    }\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     /// Adds a key/value pair the end of the node.\n     pub fn push(&mut self, key: K, val: V) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(self.len() < CAPACITY);\n+        debug_assert!(!self.is_shared_root());\n \n         let idx = self.len();\n \n@@ -571,6 +649,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     pub fn push_front(&mut self, key: K, val: V) {\n         // Necessary for correctness, but this is an internal module\n         debug_assert!(self.len() < CAPACITY);\n+        debug_assert!(!self.is_shared_root());\n \n         unsafe {\n             slice_insert(self.keys_mut(), 0, key);\n@@ -884,6 +963,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     fn insert_fit(&mut self, key: K, val: V) -> *mut V {\n         // Necessary for correctness, but in a private module\n         debug_assert!(self.node.len() < CAPACITY);\n+        debug_assert!(!self.node.is_shared_root());\n \n         unsafe {\n             slice_insert(self.node.keys_mut(), self.idx, key);\n@@ -1061,6 +1141,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n     ///   allocated node.\n     pub fn split(mut self)\n             -> (NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, K, V, Root<K, V>) {\n+        debug_assert!(!self.node.is_shared_root());\n         unsafe {\n             let mut new_node = Box::new(LeafNode::new());\n \n@@ -1098,6 +1179,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n     /// now adjacent key/value pairs to the left and right of this handle.\n     pub fn remove(mut self)\n             -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>, K, V) {\n+        debug_assert!(!self.node.is_shared_root());\n         unsafe {\n             let k = slice_remove(self.node.keys_mut(), self.idx);\n             let v = slice_remove(self.node.vals_mut(), self.idx);\n@@ -1239,12 +1321,12 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 }\n \n                 Global.dealloc(\n-                    right_node.node.as_opaque(),\n+                    right_node.node.cast(),\n                     Layout::new::<InternalNode<K, V>>(),\n                 );\n             } else {\n                 Global.dealloc(\n-                    right_node.node.as_opaque(),\n+                    right_node.node.cast(),\n                     Layout::new::<LeafNode<K, V>>(),\n                 );\n             }", "previous_filename": "src/liballoc/btree/node.rs"}, {"sha": "bc1272fbc786e7aa4c2c9e39e24345c3a84f68a4", "filename": "src/liballoc/collections/btree/search.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "previous_filename": "src/liballoc/btree/search.rs"}, {"sha": "af9a7074e4a4f96d9916ae126ac8f936879cf2e2", "filename": "src/liballoc/collections/btree/set.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -19,7 +19,7 @@ use core::iter::{Peekable, FromIterator, FusedIterator};\n use core::ops::{BitOr, BitAnd, BitXor, Sub, RangeBounds};\n \n use borrow::Borrow;\n-use btree_map::{BTreeMap, Keys};\n+use collections::btree_map::{self, BTreeMap, Keys};\n use super::Recover;\n \n // FIXME(conventions): implement bounded iterators\n@@ -104,7 +104,7 @@ impl<'a, T: 'a + fmt::Debug> fmt::Debug for Iter<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct IntoIter<T> {\n-    iter: ::btree_map::IntoIter<T, ()>,\n+    iter: btree_map::IntoIter<T, ()>,\n }\n \n /// An iterator over a sub-range of items in a `BTreeSet`.\n@@ -117,7 +117,7 @@ pub struct IntoIter<T> {\n #[derive(Debug)]\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct Range<'a, T: 'a> {\n-    iter: ::btree_map::Range<'a, T, ()>,\n+    iter: btree_map::Range<'a, T, ()>,\n }\n \n /// A lazy iterator producing elements in the difference of `BTreeSet`s.", "previous_filename": "src/liballoc/btree/set.rs"}, {"sha": "9844de9a57d70274c4bf91cc93d79da0e381acf4", "filename": "src/liballoc/collections/linked_list.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "previous_filename": "src/liballoc/linked_list.rs"}, {"sha": "96e0eb633b2f54cbaa38ad8c230a4c6f165ebc97", "filename": "src/liballoc/collections/mod.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fmod.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Collection types.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+pub mod binary_heap;\n+mod btree;\n+pub mod linked_list;\n+pub mod vec_deque;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub mod btree_map {\n+    //! A map based on a B-Tree.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::btree::map::*;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub mod btree_set {\n+    //! A set based on a B-Tree.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::btree::set::*;\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)]\n+pub use self::binary_heap::BinaryHeap;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)]\n+pub use self::btree_map::BTreeMap;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)]\n+pub use self::btree_set::BTreeSet;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)]\n+pub use self::linked_list::LinkedList;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(no_inline)]\n+pub use self::vec_deque::VecDeque;\n+\n+use alloc::{AllocErr, LayoutErr};\n+\n+/// Augments `AllocErr` with a CapacityOverflow variant.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+#[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+pub enum CollectionAllocErr {\n+    /// Error due to the computed capacity exceeding the collection's maximum\n+    /// (usually `isize::MAX` bytes).\n+    CapacityOverflow,\n+    /// Error due to the allocator (see the `AllocErr` type's docs).\n+    AllocErr,\n+}\n+\n+#[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+impl From<AllocErr> for CollectionAllocErr {\n+    #[inline]\n+    fn from(AllocErr: AllocErr) -> Self {\n+        CollectionAllocErr::AllocErr\n+    }\n+}\n+\n+#[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n+impl From<LayoutErr> for CollectionAllocErr {\n+    #[inline]\n+    fn from(_: LayoutErr) -> Self {\n+        CollectionAllocErr::CapacityOverflow\n+    }\n+}\n+\n+/// An intermediate trait for specialization of `Extend`.\n+#[doc(hidden)]\n+trait SpecExtend<I: IntoIterator> {\n+    /// Extends `self` with the contents of the given iterator.\n+    fn spec_extend(&mut self, iter: I);\n+}"}, {"sha": "ba92b886138c02efbeec9b421154965da89e41e7", "filename": "src/liballoc/collections/vec_deque.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -30,7 +30,7 @@ use core::slice;\n use core::hash::{Hash, Hasher};\n use core::cmp;\n \n-use alloc::CollectionAllocErr;\n+use collections::CollectionAllocErr;\n use raw_vec::RawVec;\n use vec::Vec;\n \n@@ -980,12 +980,12 @@ impl<T> VecDeque<T> {\n         // and the head/tail values will be restored correctly.\n         //\n         let len = self.len();\n-        let start = match range.start() {\n+        let start = match range.start_bound() {\n             Included(&n) => n,\n             Excluded(&n) => n + 1,\n             Unbounded    => 0,\n         };\n-        let end = match range.end() {\n+        let end = match range.end_bound() {\n             Included(&n) => n + 1,\n             Excluded(&n) => n,\n             Unbounded    => len,\n@@ -2891,7 +2891,7 @@ mod tests {\n \n     #[test]\n     fn test_from_vec() {\n-        use super::super::vec::Vec;\n+        use vec::Vec;\n         for cap in 0..35 {\n             for len in 0..cap + 1 {\n                 let mut vec = Vec::with_capacity(cap);\n@@ -2907,7 +2907,7 @@ mod tests {\n \n     #[test]\n     fn test_vec_from_vecdeque() {\n-        use super::super::vec::Vec;\n+        use vec::Vec;\n \n         fn create_vec_and_test_convert(cap: usize, offset: usize, len: usize) {\n             let mut vd = VecDeque::with_capacity(cap);", "previous_filename": "src/liballoc/vec_deque.rs"}, {"sha": "b49ec0ae25212d05787ad7df0f845cebd52e8405", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -340,7 +340,8 @@\n //!\n //! ## Fill/Alignment\n //!\n-//! The fill character is provided normally in conjunction with the `width`\n+//! The fill character is provided normally in conjunction with the\n+//! [`width`](#width)\n //! parameter. This indicates that if the value being formatted is smaller than\n //! `width` some extra characters will be printed around it. The extra\n //! characters are specified by `fill`, and the alignment can be one of the\n@@ -388,7 +389,8 @@\n //! padding specified by fill/alignment will be used to take up the required\n //! space.\n //!\n-//! The default fill/alignment for non-numerics is a space and left-aligned. The\n+//! The default [fill/alignment](#fillalignment) for non-numerics is a space and\n+//! left-aligned. The\n //! defaults for numeric formatters is also a space but with right-alignment. If\n //! the `0` flag is specified for numerics, then the implicit fill character is\n //! `0`.\n@@ -529,6 +531,8 @@ pub use core::fmt::Error;\n pub use core::fmt::{write, ArgumentV1, Arguments};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::fmt::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n+#[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n+pub use core::fmt::{Alignment};\n \n use string;\n "}, {"sha": "16f0630b91134dd62965aa04d75663b98cc402f6", "filename": "src/liballoc/heap.rs", "status": "removed", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,110 +0,0 @@\n-// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(deprecated)]\n-\n-pub use alloc::{Layout, AllocErr, CannotReallocInPlace, Opaque};\n-use core::alloc::Alloc as CoreAlloc;\n-use core::ptr::NonNull;\n-\n-#[doc(hidden)]\n-pub mod __core {\n-    pub use core::*;\n-}\n-\n-#[derive(Debug)]\n-pub struct Excess(pub *mut u8, pub usize);\n-\n-/// Compatibility with older versions of #[global_allocator] during bootstrap\n-pub unsafe trait Alloc {\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr>;\n-    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout);\n-    fn oom(&mut self, err: AllocErr) -> !;\n-    fn usable_size(&self, layout: &Layout) -> (usize, usize);\n-    unsafe fn realloc(&mut self,\n-                      ptr: *mut u8,\n-                      layout: Layout,\n-                      new_layout: Layout) -> Result<*mut u8, AllocErr>;\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<*mut u8, AllocErr>;\n-    unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr>;\n-    unsafe fn realloc_excess(&mut self,\n-                             ptr: *mut u8,\n-                             layout: Layout,\n-                             new_layout: Layout) -> Result<Excess, AllocErr>;\n-    unsafe fn grow_in_place(&mut self,\n-                            ptr: *mut u8,\n-                            layout: Layout,\n-                            new_layout: Layout) -> Result<(), CannotReallocInPlace>;\n-    unsafe fn shrink_in_place(&mut self,\n-                              ptr: *mut u8,\n-                              layout: Layout,\n-                              new_layout: Layout) -> Result<(), CannotReallocInPlace>;\n-}\n-\n-unsafe impl<T> Alloc for T where T: CoreAlloc {\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n-        CoreAlloc::alloc(self, layout).map(|ptr| ptr.cast().as_ptr())\n-    }\n-\n-    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n-        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n-        CoreAlloc::dealloc(self, ptr, layout)\n-    }\n-\n-    fn oom(&mut self, _: AllocErr) -> ! {\n-        unsafe { ::core::intrinsics::abort() }\n-    }\n-\n-    fn usable_size(&self, layout: &Layout) -> (usize, usize) {\n-        CoreAlloc::usable_size(self, layout)\n-    }\n-\n-    unsafe fn realloc(&mut self,\n-                      ptr: *mut u8,\n-                      layout: Layout,\n-                      new_layout: Layout) -> Result<*mut u8, AllocErr> {\n-        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n-        CoreAlloc::realloc(self, ptr, layout, new_layout.size()).map(|ptr| ptr.cast().as_ptr())\n-    }\n-\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n-        CoreAlloc::alloc_zeroed(self, layout).map(|ptr| ptr.cast().as_ptr())\n-    }\n-\n-    unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n-        CoreAlloc::alloc_excess(self, layout)\n-            .map(|e| Excess(e.0 .cast().as_ptr(), e.1))\n-    }\n-\n-    unsafe fn realloc_excess(&mut self,\n-                             ptr: *mut u8,\n-                             layout: Layout,\n-                             new_layout: Layout) -> Result<Excess, AllocErr> {\n-        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n-        CoreAlloc::realloc_excess(self, ptr, layout, new_layout.size())\n-            .map(|e| Excess(e.0 .cast().as_ptr(), e.1))\n-    }\n-\n-    unsafe fn grow_in_place(&mut self,\n-                            ptr: *mut u8,\n-                            layout: Layout,\n-                            new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n-        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n-        CoreAlloc::grow_in_place(self, ptr, layout, new_layout.size())\n-    }\n-\n-    unsafe fn shrink_in_place(&mut self,\n-                              ptr: *mut u8,\n-                              layout: Layout,\n-                              new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n-        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n-        CoreAlloc::shrink_in_place(self, ptr, layout, new_layout.size())\n-    }\n-}"}, {"sha": "ef619527e064a34d2f8f387881619570393cde5d", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 20, "deletions": 76, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -13,10 +13,10 @@\n //! This library provides smart pointers and collections for managing\n //! heap-allocated values.\n //!\n-//! This library, like libcore, is not intended for general usage, but rather as\n-//! a building block of other libraries. The types and interfaces in this\n-//! library are re-exported through the [standard library](../std/index.html),\n-//! and should not be used through this library.\n+//! This library, like libcore, normally doesn\u2019t need to be used directly\n+//! since its contents are re-exported in the [`std` crate](../std/index.html).\n+//! Crates that use the `#![no_std]` attribute however will typically\n+//! not depend on `std`, so they\u2019d use this crate instead.\n //!\n //! ## Boxed values\n //!\n@@ -40,7 +40,7 @@\n //!\n //! ## Atomically reference counted pointers\n //!\n-//! The [`Arc`](arc/index.html) type is the threadsafe equivalent of the `Rc`\n+//! The [`Arc`](sync/index.html) type is the threadsafe equivalent of the `Rc`\n //! type. It provides all the same functionality of `Rc`, except it requires\n //! that the contained type `T` is shareable. Additionally, `Arc<T>` is itself\n //! sendable while `Rc<T>` is not.\n@@ -75,12 +75,12 @@\n #![deny(missing_debug_implementations)]\n \n #![cfg_attr(test, allow(deprecated))] // rand\n-#![cfg_attr(all(not(test), stage0), feature(float_internals))]\n #![cfg_attr(not(test), feature(exact_size_is_empty))]\n #![cfg_attr(not(test), feature(generator_trait))]\n #![cfg_attr(test, feature(rand, test))]\n #![feature(allocator_api)]\n #![feature(allow_internal_unstable)]\n+#![feature(arbitrary_self_types)]\n #![feature(ascii_ctype)]\n #![feature(box_into_raw_non_null)]\n #![feature(box_patterns)]\n@@ -90,27 +90,24 @@\n #![feature(collections_range)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n-#![cfg_attr(stage0, feature(core_slice_ext))]\n-#![cfg_attr(stage0, feature(core_str_ext))]\n #![feature(custom_attribute)]\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n #![feature(fmt_internals)]\n-#![cfg_attr(stage0, feature(fn_must_use))]\n #![feature(from_ref)]\n #![feature(fundamental)]\n+#![feature(futures_api)]\n #![feature(lang_items)]\n #![feature(libc)]\n #![feature(needs_allocator)]\n-#![feature(nonzero)]\n #![feature(optin_builtin_traits)]\n #![feature(pattern)]\n #![feature(pin)]\n #![feature(ptr_internals)]\n #![feature(ptr_offset_from)]\n #![feature(rustc_attrs)]\n-#![feature(slice_get_slice)]\n #![feature(specialization)]\n+#![feature(split_ascii_whitespace)]\n #![feature(staged_api)]\n #![feature(str_internals)]\n #![feature(trusted_len)]\n@@ -123,8 +120,8 @@\n #![feature(exact_chunks)]\n #![feature(pointer_methods)]\n #![feature(inclusive_range_methods)]\n-#![cfg_attr(stage0, feature(generic_param_attrs))]\n #![feature(rustc_const_unstable)]\n+#![feature(const_vec_new)]\n \n #![cfg_attr(not(test), feature(fn_traits, i128))]\n #![cfg_attr(test, feature(test))]\n@@ -143,30 +140,14 @@ extern crate rand;\n #[macro_use]\n mod macros;\n \n-#[rustc_deprecated(since = \"1.27.0\", reason = \"use the heap module in core, alloc, or std instead\")]\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-/// Use the `alloc` module instead.\n-pub mod allocator {\n-    pub use alloc::*;\n-}\n-\n // Heaps provided for low-level allocation strategies\n \n pub mod alloc;\n \n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-#[rustc_deprecated(since = \"1.27.0\", reason = \"module renamed to `alloc`\")]\n-/// Use the `alloc` module instead.\n-#[cfg(not(stage0))]\n-pub mod heap {\n-    pub use alloc::*;\n-}\n-\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-#[rustc_deprecated(since = \"1.27.0\", reason = \"module renamed to `alloc`\")]\n-#[cfg(stage0)]\n-pub mod heap;\n-\n+#[unstable(feature = \"futures_api\",\n+           reason = \"futures in libcore are unstable\",\n+           issue = \"50547\")]\n+pub mod task;\n // Primitive types using the heaps above\n \n // Need to conditionally define the mod from `boxed.rs` to avoid\n@@ -180,60 +161,23 @@ mod boxed {\n }\n #[cfg(test)]\n mod boxed_test;\n-#[cfg(target_has_atomic = \"ptr\")]\n-pub mod arc;\n+pub mod collections;\n+#[cfg(any(\n+    all(stage0, target_has_atomic = \"ptr\"),\n+    all(not(stage0), target_has_atomic = \"ptr\", target_has_atomic = \"cas\")\n+))]\n+pub mod sync;\n pub mod rc;\n pub mod raw_vec;\n-\n-// collections modules\n-pub mod binary_heap;\n-mod btree;\n+pub mod prelude;\n pub mod borrow;\n pub mod fmt;\n-pub mod linked_list;\n pub mod slice;\n pub mod str;\n pub mod string;\n pub mod vec;\n-pub mod vec_deque;\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub mod btree_map {\n-    //! A map based on a B-Tree.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use btree::map::*;\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub mod btree_set {\n-    //! A set based on a B-Tree.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use btree::set::*;\n-}\n \n #[cfg(not(test))]\n mod std {\n     pub use core::ops;      // RangeFull\n }\n-\n-/// An intermediate trait for specialization of `Extend`.\n-#[doc(hidden)]\n-trait SpecExtend<I: IntoIterator> {\n-    /// Extends `self` with the contents of the given iterator.\n-    fn spec_extend(&mut self, iter: I);\n-}\n-\n-#[doc(no_inline)]\n-pub use binary_heap::BinaryHeap;\n-#[doc(no_inline)]\n-pub use btree_map::BTreeMap;\n-#[doc(no_inline)]\n-pub use btree_set::BTreeSet;\n-#[doc(no_inline)]\n-pub use linked_list::LinkedList;\n-#[doc(no_inline)]\n-pub use vec_deque::VecDeque;\n-#[doc(no_inline)]\n-pub use string::String;\n-#[doc(no_inline)]\n-pub use vec::Vec;"}, {"sha": "53b5e93a66e26d923d25d9d1d7ea94f2e0f8807c", "filename": "src/liballoc/prelude.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fprelude.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The alloc Prelude\n+//!\n+//! The purpose of this module is to alleviate imports of commonly-used\n+//! items of the `alloc` crate by adding a glob import to the top of modules:\n+//!\n+//! ```\n+//! # #![allow(unused_imports)]\n+//! # #![feature(alloc)]\n+//! extern crate alloc;\n+//! use alloc::prelude::*;\n+//! ```\n+\n+#![unstable(feature = \"alloc\", issue = \"27783\")]\n+\n+#[unstable(feature = \"alloc\", issue = \"27783\")] pub use borrow::ToOwned;\n+#[unstable(feature = \"alloc\", issue = \"27783\")] pub use boxed::Box;\n+#[unstable(feature = \"alloc\", issue = \"27783\")] pub use slice::SliceConcatExt;\n+#[unstable(feature = \"alloc\", issue = \"27783\")] pub use string::{String, ToString};\n+#[unstable(feature = \"alloc\", issue = \"27783\")] pub use vec::Vec;"}, {"sha": "4f2686abf4515fbb11554df4b81dd83114b51976", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 116, "deletions": 101, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -8,15 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![unstable(feature = \"raw_vec_internals\", reason = \"implemention detail\", issue = \"0\")]\n+#![doc(hidden)]\n+\n use core::cmp;\n use core::mem;\n use core::ops::Drop;\n use core::ptr::{self, NonNull, Unique};\n use core::slice;\n \n-use alloc::{Alloc, Layout, Global, oom};\n-use alloc::CollectionAllocErr;\n-use alloc::CollectionAllocErr::*;\n+use alloc::{Alloc, Layout, Global, handle_alloc_error};\n+use collections::CollectionAllocErr;\n+use collections::CollectionAllocErr::*;\n use boxed::Box;\n \n /// A low-level utility for more ergonomically allocating, reallocating, and deallocating\n@@ -93,22 +96,23 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n             // handles ZSTs and `cap = 0` alike\n             let ptr = if alloc_size == 0 {\n-                NonNull::<T>::dangling().as_opaque()\n+                NonNull::<T>::dangling()\n             } else {\n                 let align = mem::align_of::<T>();\n+                let layout = Layout::from_size_align(alloc_size, align).unwrap();\n                 let result = if zeroed {\n-                    a.alloc_zeroed(Layout::from_size_align(alloc_size, align).unwrap())\n+                    a.alloc_zeroed(layout)\n                 } else {\n-                    a.alloc(Layout::from_size_align(alloc_size, align).unwrap())\n+                    a.alloc(layout)\n                 };\n                 match result {\n-                    Ok(ptr) => ptr,\n-                    Err(_) => oom(),\n+                    Ok(ptr) => ptr.cast(),\n+                    Err(_) => handle_alloc_error(layout),\n                 }\n             };\n \n             RawVec {\n-                ptr: ptr.cast().into(),\n+                ptr: ptr.into(),\n                 cap,\n                 a,\n             }\n@@ -263,7 +267,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(alloc)]\n+    /// # #![feature(alloc, raw_vec_internals)]\n     /// # extern crate alloc;\n     /// # use std::ptr;\n     /// # use alloc::raw_vec::RawVec;\n@@ -313,12 +317,14 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     let new_cap = 2 * self.cap;\n                     let new_size = new_cap * elem_size;\n                     alloc_guard(new_size).unwrap_or_else(|_| capacity_overflow());\n-                    let ptr_res = self.a.realloc(NonNull::from(self.ptr).as_opaque(),\n+                    let ptr_res = self.a.realloc(NonNull::from(self.ptr).cast(),\n                                                  cur,\n                                                  new_size);\n                     match ptr_res {\n                         Ok(ptr) => (new_cap, ptr.cast().into()),\n-                        Err(_) => oom(),\n+                        Err(_) => handle_alloc_error(\n+                            Layout::from_size_align_unchecked(new_size, cur.align())\n+                        ),\n                     }\n                 }\n                 None => {\n@@ -327,7 +333,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n                     match self.a.alloc_array::<T>(new_cap) {\n                         Ok(ptr) => (new_cap, ptr.into()),\n-                        Err(_) => oom(),\n+                        Err(_) => handle_alloc_error(Layout::array::<T>(new_cap).unwrap()),\n                     }\n                 }\n             };\n@@ -372,7 +378,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             let new_cap = 2 * self.cap;\n             let new_size = new_cap * elem_size;\n             alloc_guard(new_size).unwrap_or_else(|_| capacity_overflow());\n-            match self.a.grow_in_place(NonNull::from(self.ptr).as_opaque(), old_layout, new_size) {\n+            match self.a.grow_in_place(NonNull::from(self.ptr).cast(), old_layout, new_size) {\n                 Ok(_) => {\n                     // We can't directly divide `size`.\n                     self.cap = new_cap;\n@@ -385,6 +391,13 @@ impl<T, A: Alloc> RawVec<T, A> {\n         }\n     }\n \n+    /// The same as `reserve_exact`, but returns on errors instead of panicking or aborting.\n+    pub fn try_reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize)\n+           -> Result<(), CollectionAllocErr> {\n+\n+        self.reserve_internal(used_cap, needed_extra_cap, Fallible, Exact)\n+    }\n+\n     /// Ensures that the buffer contains at least enough space to hold\n     /// `used_cap + needed_extra_cap` elements. If it doesn't already,\n     /// will reallocate the minimum possible amount of memory necessary.\n@@ -405,46 +418,10 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// # Aborts\n     ///\n     /// Aborts on OOM\n-    pub fn try_reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize)\n-           -> Result<(), CollectionAllocErr> {\n-\n-        unsafe {\n-            // NOTE: we don't early branch on ZSTs here because we want this\n-            // to actually catch \"asking for more than usize::MAX\" in that case.\n-            // If we make it past the first branch then we are guaranteed to\n-            // panic.\n-\n-            // Don't actually need any more capacity.\n-            // Wrapping in case they gave a bad `used_cap`.\n-            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n-                return Ok(());\n-            }\n-\n-            // Nothing we can really do about these checks :(\n-            let new_cap = used_cap.checked_add(needed_extra_cap).ok_or(CapacityOverflow)?;\n-            let new_layout = Layout::array::<T>(new_cap).map_err(|_| CapacityOverflow)?;\n-\n-            alloc_guard(new_layout.size())?;\n-\n-            let res = match self.current_layout() {\n-                Some(layout) => {\n-                    debug_assert!(new_layout.align() == layout.align());\n-                    self.a.realloc(NonNull::from(self.ptr).as_opaque(), layout, new_layout.size())\n-                }\n-                None => self.a.alloc(new_layout),\n-            };\n-\n-            self.ptr = res?.cast().into();\n-            self.cap = new_cap;\n-\n-            Ok(())\n-        }\n-    }\n-\n     pub fn reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize) {\n-        match self.try_reserve_exact(used_cap, needed_extra_cap) {\n+        match self.reserve_internal(used_cap, needed_extra_cap, Infallible, Exact) {\n             Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocErr) => oom(),\n+            Err(AllocErr) => unreachable!(),\n             Ok(()) => { /* yay */ }\n          }\n      }\n@@ -463,6 +440,12 @@ impl<T, A: Alloc> RawVec<T, A> {\n         Ok(cmp::max(double_cap, required_cap))\n     }\n \n+    /// The same as `reserve`, but returns on errors instead of panicking or aborting.\n+    pub fn try_reserve(&mut self, used_cap: usize, needed_extra_cap: usize)\n+        -> Result<(), CollectionAllocErr> {\n+        self.reserve_internal(used_cap, needed_extra_cap, Fallible, Amortized)\n+    }\n+\n     /// Ensures that the buffer contains at least enough space to hold\n     /// `used_cap + needed_extra_cap` elements. If it doesn't already have\n     /// enough capacity, will reallocate enough space plus comfortable slack\n@@ -488,7 +471,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(alloc)]\n+    /// # #![feature(alloc, raw_vec_internals)]\n     /// # extern crate alloc;\n     /// # use std::ptr;\n     /// # use alloc::raw_vec::RawVec;\n@@ -515,49 +498,13 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// #   vector.push_all(&[1, 3, 5, 7, 9]);\n     /// # }\n     /// ```\n-    pub fn try_reserve(&mut self, used_cap: usize, needed_extra_cap: usize)\n-        -> Result<(), CollectionAllocErr> {\n-         unsafe {\n-            // NOTE: we don't early branch on ZSTs here because we want this\n-            // to actually catch \"asking for more than usize::MAX\" in that case.\n-            // If we make it past the first branch then we are guaranteed to\n-            // panic.\n-\n-            // Don't actually need any more capacity.\n-            // Wrapping in case they give a bad `used_cap`\n-            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n-               return Ok(());\n-            }\n-\n-            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap)?;\n-            let new_layout = Layout::array::<T>(new_cap).map_err(|_| CapacityOverflow)?;\n-\n-             // FIXME: may crash and burn on over-reserve\n-            alloc_guard(new_layout.size())?;\n-\n-            let res = match self.current_layout() {\n-                Some(layout) => {\n-                    debug_assert!(new_layout.align() == layout.align());\n-                    self.a.realloc(NonNull::from(self.ptr).as_opaque(), layout, new_layout.size())\n-                }\n-                None => self.a.alloc(new_layout),\n-            };\n-\n-            self.ptr = res?.cast().into();\n-            self.cap = new_cap;\n-\n-            Ok(())\n-        }\n-    }\n-\n-    /// The same as try_reserve, but errors are lowered to a call to oom().\n     pub fn reserve(&mut self, used_cap: usize, needed_extra_cap: usize) {\n-        match self.try_reserve(used_cap, needed_extra_cap) {\n+        match self.reserve_internal(used_cap, needed_extra_cap, Infallible, Amortized) {\n             Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocErr) => oom(),\n+            Err(AllocErr) => unreachable!(),\n             Ok(()) => { /* yay */ }\n-         }\n-     }\n+        }\n+    }\n     /// Attempts to ensure that the buffer contains at least enough space to hold\n     /// `used_cap + needed_extra_cap` elements. If it doesn't already have\n     /// enough capacity, will reallocate in place enough space plus comfortable slack\n@@ -604,7 +551,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             // FIXME: may crash and burn on over-reserve\n             alloc_guard(new_layout.size()).unwrap_or_else(|_| capacity_overflow());\n             match self.a.grow_in_place(\n-                NonNull::from(self.ptr).as_opaque(), old_layout, new_layout.size(),\n+                NonNull::from(self.ptr).cast(), old_layout, new_layout.size(),\n             ) {\n                 Ok(_) => {\n                     self.cap = new_cap;\n@@ -665,18 +612,87 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 let new_size = elem_size * amount;\n                 let align = mem::align_of::<T>();\n                 let old_layout = Layout::from_size_align_unchecked(old_size, align);\n-                match self.a.realloc(NonNull::from(self.ptr).as_opaque(),\n+                match self.a.realloc(NonNull::from(self.ptr).cast(),\n                                      old_layout,\n                                      new_size) {\n                     Ok(p) => self.ptr = p.cast().into(),\n-                    Err(_) => oom(),\n+                    Err(_) => handle_alloc_error(\n+                        Layout::from_size_align_unchecked(new_size, align)\n+                    ),\n                 }\n             }\n             self.cap = amount;\n         }\n     }\n }\n \n+enum Fallibility {\n+    Fallible,\n+    Infallible,\n+}\n+\n+use self::Fallibility::*;\n+\n+enum ReserveStrategy {\n+    Exact,\n+    Amortized,\n+}\n+\n+use self::ReserveStrategy::*;\n+\n+impl<T, A: Alloc> RawVec<T, A> {\n+    fn reserve_internal(\n+        &mut self,\n+        used_cap: usize,\n+        needed_extra_cap: usize,\n+        fallibility: Fallibility,\n+        strategy: ReserveStrategy,\n+    ) -> Result<(), CollectionAllocErr> {\n+        unsafe {\n+            use alloc::AllocErr;\n+\n+            // NOTE: we don't early branch on ZSTs here because we want this\n+            // to actually catch \"asking for more than usize::MAX\" in that case.\n+            // If we make it past the first branch then we are guaranteed to\n+            // panic.\n+\n+            // Don't actually need any more capacity.\n+            // Wrapping in case they gave a bad `used_cap`.\n+            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n+                return Ok(());\n+            }\n+\n+            // Nothing we can really do about these checks :(\n+            let new_cap = match strategy {\n+                Exact => used_cap.checked_add(needed_extra_cap).ok_or(CapacityOverflow)?,\n+                Amortized => self.amortized_new_size(used_cap, needed_extra_cap)?,\n+            };\n+            let new_layout = Layout::array::<T>(new_cap).map_err(|_| CapacityOverflow)?;\n+\n+            alloc_guard(new_layout.size())?;\n+\n+            let res = match self.current_layout() {\n+                Some(layout) => {\n+                    debug_assert!(new_layout.align() == layout.align());\n+                    self.a.realloc(NonNull::from(self.ptr).cast(), layout, new_layout.size())\n+                }\n+                None => self.a.alloc(new_layout),\n+            };\n+\n+            match (&res, fallibility) {\n+                (Err(AllocErr), Infallible) => handle_alloc_error(new_layout),\n+                _ => {}\n+            }\n+\n+            self.ptr = res?.cast().into();\n+            self.cap = new_cap;\n+\n+            Ok(())\n+        }\n+    }\n+\n+}\n+\n impl<T> RawVec<T, Global> {\n     /// Converts the entire buffer into `Box<[T]>`.\n     ///\n@@ -701,7 +717,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n         let elem_size = mem::size_of::<T>();\n         if elem_size != 0 {\n             if let Some(layout) = self.current_layout() {\n-                self.a.dealloc(NonNull::from(self.ptr).as_opaque(), layout);\n+                self.a.dealloc(NonNull::from(self.ptr).cast(), layout);\n             }\n         }\n     }\n@@ -744,11 +760,10 @@ fn capacity_overflow() -> ! {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use alloc::Opaque;\n \n     #[test]\n     fn allocator_param() {\n-        use allocator::{Alloc, AllocErr};\n+        use alloc::AllocErr;\n \n         // Writing a test of integration between third-party\n         // allocators and RawVec is a little tricky because the RawVec\n@@ -764,7 +779,7 @@ mod tests {\n         // before allocation attempts start failing.\n         struct BoundedAlloc { fuel: usize }\n         unsafe impl Alloc for BoundedAlloc {\n-            unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n+            unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n                 let size = layout.size();\n                 if size > self.fuel {\n                     return Err(AllocErr);\n@@ -774,7 +789,7 @@ mod tests {\n                     err @ Err(_) => err,\n                 }\n             }\n-            unsafe fn dealloc(&mut self, ptr: NonNull<Opaque>, layout: Layout) {\n+            unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n                 Global.dealloc(ptr, layout)\n             }\n         }"}, {"sha": "be049eb6e5ef377a56daff179198e8faa26a0bbe", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 62, "deletions": 48, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -253,13 +253,14 @@ use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n use core::marker;\n use core::marker::{Unsize, PhantomData};\n-use core::mem::{self, align_of_val, forget, size_of_val, uninitialized};\n+use core::mem::{self, align_of_val, forget, size_of_val};\n use core::ops::Deref;\n use core::ops::CoerceUnsized;\n use core::ptr::{self, NonNull};\n use core::convert::From;\n+use core::usize;\n \n-use alloc::{Global, Alloc, Layout, Opaque, box_free, oom};\n+use alloc::{Global, Alloc, Layout, box_free, handle_alloc_error};\n use string::String;\n use vec::Vec;\n \n@@ -449,6 +450,8 @@ impl<T: ?Sized> Rc<T> {\n     #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n     pub fn downgrade(this: &Self) -> Weak<T> {\n         this.inc_weak();\n+        // Make sure we do not create a dangling Weak\n+        debug_assert!(!is_dangling(this.ptr));\n         Weak { ptr: this.ptr }\n     }\n \n@@ -618,15 +621,14 @@ impl<T: Clone> Rc<T> {\n     }\n }\n \n-impl Rc<Any> {\n+impl Rc<dyn Any> {\n     #[inline]\n-    #[unstable(feature = \"rc_downcast\", issue = \"44608\")]\n+    #[stable(feature = \"rc_downcast\", since = \"1.29.0\")]\n     /// Attempt to downcast the `Rc<Any>` to a concrete type.\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(rc_downcast)]\n     /// use std::any::Any;\n     /// use std::rc::Rc;\n     ///\n@@ -642,17 +644,11 @@ impl Rc<Any> {\n     ///     print_if_string(Rc::new(0i8));\n     /// }\n     /// ```\n-    pub fn downcast<T: Any>(self) -> Result<Rc<T>, Rc<Any>> {\n+    pub fn downcast<T: Any>(self) -> Result<Rc<T>, Rc<dyn Any>> {\n         if (*self).is::<T>() {\n-            // avoid the pointer arithmetic in from_raw\n-            unsafe {\n-                let raw: *const RcBox<Any> = self.ptr.as_ptr();\n-                forget(self);\n-                Ok(Rc {\n-                    ptr: NonNull::new_unchecked(raw as *const RcBox<T> as *mut _),\n-                    phantom: PhantomData,\n-                })\n-            }\n+            let ptr = self.ptr.cast::<RcBox<T>>();\n+            forget(self);\n+            Ok(Rc { ptr, phantom: PhantomData })\n         } else {\n             Err(self)\n         }\n@@ -668,7 +664,7 @@ impl<T: ?Sized> Rc<T> {\n         let layout = Layout::for_value(&*fake_ptr);\n \n         let mem = Global.alloc(layout)\n-            .unwrap_or_else(|_| oom());\n+            .unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the real RcBox\n         let inner = set_data_ptr(ptr as *mut T, mem.as_ptr() as *mut u8) as *mut RcBox<T>;\n@@ -738,7 +734,7 @@ impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n         // In the event of a panic, elements that have been written\n         // into the new RcBox will be dropped, then the memory freed.\n         struct Guard<T> {\n-            mem: NonNull<Opaque>,\n+            mem: NonNull<u8>,\n             elems: *mut T,\n             layout: Layout,\n             n_elems: usize,\n@@ -761,7 +757,7 @@ impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n             let v_ptr = v as *const [T];\n             let ptr = Self::allocate_for_ptr(v_ptr);\n \n-            let mem = ptr as *mut _ as *mut Opaque;\n+            let mem = ptr as *mut _ as *mut u8;\n             let layout = Layout::for_value(&*ptr);\n \n             // Pointer to first element\n@@ -845,7 +841,7 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n                 self.dec_weak();\n \n                 if self.weak() == 0 {\n-                    Global.dealloc(self.ptr.as_opaque(), Layout::for_value(self.ptr.as_ref()));\n+                    Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n                 }\n             }\n         }\n@@ -1159,6 +1155,11 @@ impl<T> From<Vec<T>> for Rc<[T]> {\n /// [`None`]: ../../std/option/enum.Option.html#variant.None\n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n pub struct Weak<T: ?Sized> {\n+    // This is a `NonNull` to allow optimizing the size of this type in enums,\n+    // but it is not necessarily a valid pointer.\n+    // `Weak::new` sets this to `usize::MAX` so that it doesn\u2019t need\n+    // to allocate space on the heap.  That's not a value a real pointer\n+    // will ever have because RcBox has alignment at least 2.\n     ptr: NonNull<RcBox<T>>,\n }\n \n@@ -1171,8 +1172,8 @@ impl<T: ?Sized> !marker::Sync for Weak<T> {}\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n \n impl<T> Weak<T> {\n-    /// Constructs a new `Weak<T>`, allocating memory for `T` without initializing\n-    /// it. Calling [`upgrade`] on the return value always gives [`None`].\n+    /// Constructs a new `Weak<T>`, without allocating any memory.\n+    /// Calling [`upgrade`] on the return value always gives [`None`].\n     ///\n     /// [`upgrade`]: struct.Weak.html#method.upgrade\n     /// [`None`]: ../../std/option/enum.Option.html\n@@ -1187,18 +1188,17 @@ impl<T> Weak<T> {\n     /// ```\n     #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n     pub fn new() -> Weak<T> {\n-        unsafe {\n-            Weak {\n-                ptr: Box::into_raw_non_null(box RcBox {\n-                    strong: Cell::new(0),\n-                    weak: Cell::new(1),\n-                    value: uninitialized(),\n-                }),\n-            }\n+        Weak {\n+            ptr: NonNull::new(usize::MAX as *mut RcBox<T>).expect(\"MAX is not 0\"),\n         }\n     }\n }\n \n+pub(crate) fn is_dangling<T: ?Sized>(ptr: NonNull<T>) -> bool {\n+    let address = ptr.as_ptr() as *mut () as usize;\n+    address == usize::MAX\n+}\n+\n impl<T: ?Sized> Weak<T> {\n     /// Attempts to upgrade the `Weak` pointer to an [`Rc`], extending\n     /// the lifetime of the value if successful.\n@@ -1228,13 +1228,25 @@ impl<T: ?Sized> Weak<T> {\n     /// ```\n     #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n     pub fn upgrade(&self) -> Option<Rc<T>> {\n-        if self.strong() == 0 {\n+        let inner = self.inner()?;\n+        if inner.strong() == 0 {\n             None\n         } else {\n-            self.inc_strong();\n+            inner.inc_strong();\n             Some(Rc { ptr: self.ptr, phantom: PhantomData })\n         }\n     }\n+\n+    /// Return `None` when the pointer is dangling and there is no allocated `RcBox`,\n+    /// i.e. this `Weak` was created by `Weak::new`\n+    #[inline]\n+    fn inner(&self) -> Option<&RcBox<T>> {\n+        if is_dangling(self.ptr) {\n+            None\n+        } else {\n+            Some(unsafe { self.ptr.as_ref() })\n+        }\n+    }\n }\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n@@ -1264,12 +1276,14 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// assert!(other_weak_foo.upgrade().is_none());\n     /// ```\n     fn drop(&mut self) {\n-        unsafe {\n-            self.dec_weak();\n+        if let Some(inner) = self.inner() {\n+            inner.dec_weak();\n             // the weak count starts at 1, and will only go to zero if all\n             // the strong pointers have disappeared.\n-            if self.weak() == 0 {\n-                Global.dealloc(self.ptr.as_opaque(), Layout::for_value(self.ptr.as_ref()));\n+            if inner.weak() == 0 {\n+                unsafe {\n+                    Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n+                }\n             }\n         }\n     }\n@@ -1290,7 +1304,9 @@ impl<T: ?Sized> Clone for Weak<T> {\n     /// ```\n     #[inline]\n     fn clone(&self) -> Weak<T> {\n-        self.inc_weak();\n+        if let Some(inner) = self.inner() {\n+            inner.inc_weak()\n+        }\n         Weak { ptr: self.ptr }\n     }\n }\n@@ -1323,7 +1339,7 @@ impl<T> Default for Weak<T> {\n     }\n }\n \n-// NOTE: We checked_add here to deal with mem::forget safety. In particular\n+// NOTE: We checked_add here to deal with mem::forget safely. In particular\n // if you mem::forget Rcs (or Weaks), the ref-count can overflow, and then\n // you can free the allocation while outstanding Rcs (or Weaks) exist.\n // We abort because this is such a degenerate scenario that we don't care about\n@@ -1376,12 +1392,10 @@ impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n     }\n }\n \n-impl<T: ?Sized> RcBoxPtr<T> for Weak<T> {\n+impl<T: ?Sized> RcBoxPtr<T> for RcBox<T> {\n     #[inline(always)]\n     fn inner(&self) -> &RcBox<T> {\n-        unsafe {\n-            self.ptr.as_ref()\n-        }\n+        self\n     }\n }\n \n@@ -1543,7 +1557,7 @@ mod tests {\n         assert_eq!(unsafe { &*ptr }, \"foo\");\n         assert_eq!(rc, rc2);\n \n-        let rc: Rc<Display> = Rc::new(123);\n+        let rc: Rc<dyn Display> = Rc::new(123);\n \n         let ptr = Rc::into_raw(rc.clone());\n         let rc2 = unsafe { Rc::from_raw(ptr) };\n@@ -1744,8 +1758,8 @@ mod tests {\n         use std::fmt::Display;\n         use std::string::ToString;\n \n-        let b: Box<Display> = box 123;\n-        let r: Rc<Display> = Rc::from(b);\n+        let b: Box<dyn Display> = box 123;\n+        let r: Rc<dyn Display> = Rc::from(b);\n \n         assert_eq!(r.to_string(), \"123\");\n     }\n@@ -1754,8 +1768,8 @@ mod tests {\n     fn test_from_box_trait_zero_sized() {\n         use std::fmt::Debug;\n \n-        let b: Box<Debug> = box ();\n-        let r: Rc<Debug> = Rc::from(b);\n+        let b: Box<dyn Debug> = box ();\n+        let r: Rc<dyn Debug> = Rc::from(b);\n \n         assert_eq!(format!(\"{:?}\", r), \"()\");\n     }\n@@ -1772,8 +1786,8 @@ mod tests {\n     fn test_downcast() {\n         use std::any::Any;\n \n-        let r1: Rc<Any> = Rc::new(i32::max_value());\n-        let r2: Rc<Any> = Rc::new(\"abc\");\n+        let r1: Rc<dyn Any> = Rc::new(i32::max_value());\n+        let r2: Rc<dyn Any> = Rc::new(\"abc\");\n \n         assert!(r1.clone().downcast::<u32>().is_err());\n "}, {"sha": "5c14ee4fd83b4a6467cd3a6c1d2f6d74b501d7ff", "filename": "src/liballoc/repeat-generic-slice.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fliballoc%2Frepeat-generic-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Fliballoc%2Frepeat-generic-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frepeat-generic-slice.rs?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(repeat_generic_slice)]\n-\n-fn main() {\n-    assert_eq!([1, 2].repeat(2), vec![1, 2, 1, 2]);\n-    assert_eq!([1, 2, 3, 4].repeat(0), vec![]);\n-    assert_eq!([1, 2, 3, 4].repeat(1), vec![1, 2, 3, 4]);\n-    assert_eq!([1, 2, 3, 4].repeat(3),\n-               vec![1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n-}"}, {"sha": "c27c596e7975a33463042261b9ec17d33aa7990c", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -10,6 +10,8 @@\n \n //! A dynamically-sized view into a contiguous sequence, `[T]`.\n //!\n+//! *[See also the slice primitive type](../../std/primitive.slice.html).*\n+//!\n //! Slices are a view into a block of memory represented as a pointer and a\n //! length.\n //!\n@@ -78,8 +80,6 @@\n //! * Further methods that return iterators are [`.split`], [`.splitn`],\n //!   [`.chunks`], [`.windows`] and more.\n //!\n-//! *[See also the slice primitive type](../../std/primitive.slice.html).*\n-//!\n //! [`Clone`]: ../../std/clone/trait.Clone.html\n //! [`Eq`]: ../../std/cmp/trait.Eq.html\n //! [`Ord`]: ../../std/cmp/trait.Ord.html\n@@ -101,7 +101,6 @@ use core::cmp::Ordering::{self, Less};\n use core::mem::size_of;\n use core::mem;\n use core::ptr;\n-#[cfg(stage0)] use core::slice::SliceExt;\n use core::{u8, u16, u32};\n \n use borrow::{Borrow, BorrowMut, ToOwned};\n@@ -120,9 +119,9 @@ pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n pub use core::slice::{RSplit, RSplitMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n-#[unstable(feature = \"from_ref\", issue = \"45703\")]\n-pub use core::slice::{from_ref, from_ref_mut};\n-#[unstable(feature = \"slice_get_slice\", issue = \"35729\")]\n+#[stable(feature = \"from_ref\", since = \"1.28.0\")]\n+pub use core::slice::{from_ref, from_mut};\n+#[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n pub use core::slice::SliceIndex;\n #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n pub use core::slice::{ExactChunks, ExactChunksMut};\n@@ -171,13 +170,9 @@ mod hack {\n     }\n }\n \n-#[cfg_attr(stage0, lang = \"slice\")]\n-#[cfg_attr(not(stage0), lang = \"slice_alloc\")]\n+#[lang = \"slice_alloc\"]\n #[cfg(not(test))]\n impl<T> [T] {\n-    #[cfg(stage0)]\n-    slice_core_methods!();\n-\n     /// Sorts the slice.\n     ///\n     /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n@@ -467,8 +462,7 @@ impl<T> [T] {\n     }\n }\n \n-#[cfg_attr(stage0, lang = \"slice_u8\")]\n-#[cfg_attr(not(stage0), lang = \"slice_u8_alloc\")]\n+#[lang = \"slice_u8_alloc\"]\n #[cfg(not(test))]\n impl [u8] {\n     /// Returns a vector containing a copy of this slice where each byte\n@@ -504,9 +498,6 @@ impl [u8] {\n         me.make_ascii_lowercase();\n         me\n     }\n-\n-    #[cfg(stage0)]\n-    slice_u8_core_methods!();\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -575,15 +566,17 @@ impl<T: Clone, V: Borrow<[T]>> SliceConcatExt<T> for [V] {\n     }\n \n     fn join(&self, sep: &T) -> Vec<T> {\n+        let mut iter = self.iter();\n+        let first = match iter.next() {\n+            Some(first) => first,\n+            None => return vec![],\n+        };\n         let size = self.iter().fold(0, |acc, v| acc + v.borrow().len());\n         let mut result = Vec::with_capacity(size + self.len());\n-        let mut first = true;\n-        for v in self {\n-            if first {\n-                first = false\n-            } else {\n-                result.push(sep.clone())\n-            }\n+        result.extend_from_slice(first.borrow());\n+\n+        for v in iter {\n+            result.push(sep.clone());\n             result.extend_from_slice(v.borrow())\n         }\n         result"}, {"sha": "870bf971cd3f626d82c086dfd5021a94378b2df8", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 141, "deletions": 53, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -10,6 +10,8 @@\n \n //! Unicode string slices.\n //!\n+//! *[See also the `str` primitive type](../../std/primitive.str.html).*\n+//!\n //! The `&str` type is one of the two main string types, the other being `String`.\n //! Unlike its `String` counterpart, its contents are borrowed.\n //!\n@@ -29,8 +31,6 @@\n //! ```\n //! let hello_world: &'static str = \"Hello, world!\";\n //! ```\n-//!\n-//! *[See also the `str` primitive type](../../std/primitive.str.html).*\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -40,19 +40,18 @@\n \n use core::fmt;\n use core::str as core_str;\n-#[cfg(stage0)] use core::str::StrExt;\n use core::str::pattern::Pattern;\n use core::str::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n use core::mem;\n use core::ptr;\n use core::iter::FusedIterator;\n+use core::unicode::conversions;\n \n use borrow::{Borrow, ToOwned};\n use boxed::Box;\n use slice::{SliceConcatExt, SliceIndex};\n use string::String;\n use vec::Vec;\n-use vec_deque::VecDeque;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::str::{FromStr, Utf8Error};\n@@ -79,6 +78,8 @@ pub use core::str::SplitWhitespace;\n pub use core::str::pattern;\n #[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n pub use core::str::EncodeUtf16;\n+#[unstable(feature = \"split_ascii_whitespace\", issue = \"48656\")]\n+pub use core::str::SplitAsciiWhitespace;\n \n #[unstable(feature = \"slice_concat_ext\",\n            reason = \"trait should not have to exist\",\n@@ -87,52 +88,108 @@ impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n     type Output = String;\n \n     fn concat(&self) -> String {\n-        if self.is_empty() {\n-            return String::new();\n-        }\n-\n-        // `len` calculation may overflow but push_str will check boundaries\n-        let len = self.iter().map(|s| s.borrow().len()).sum();\n-        let mut result = String::with_capacity(len);\n-\n-        for s in self {\n-            result.push_str(s.borrow())\n-        }\n-\n-        result\n+        self.join(\"\")\n     }\n \n     fn join(&self, sep: &str) -> String {\n-        if self.is_empty() {\n-            return String::new();\n-        }\n-\n-        // concat is faster\n-        if sep.is_empty() {\n-            return self.concat();\n+        unsafe {\n+            String::from_utf8_unchecked( join_generic_copy(self, sep.as_bytes()) )\n         }\n+    }\n \n-        // this is wrong without the guarantee that `self` is non-empty\n-        // `len` calculation may overflow but push_str but will check boundaries\n-        let len = sep.len() * (self.len() - 1) +\n-                  self.iter().map(|s| s.borrow().len()).sum::<usize>();\n-        let mut result = String::with_capacity(len);\n-        let mut first = true;\n+    fn connect(&self, sep: &str) -> String {\n+        self.join(sep)\n+    }\n+}\n \n-        for s in self {\n-            if first {\n-                first = false;\n-            } else {\n-                result.push_str(sep);\n+macro_rules! spezialize_for_lengths {\n+    ($separator:expr, $target:expr, $iter:expr; $($num:expr),*) => {\n+        let mut target = $target;\n+        let iter = $iter;\n+        let sep_bytes = $separator;\n+        match $separator.len() {\n+            $(\n+                // loops with hardcoded sizes run much faster\n+                // specialize the cases with small separator lengths\n+                $num => {\n+                    for s in iter {\n+                        copy_slice_and_advance!(target, sep_bytes);\n+                        copy_slice_and_advance!(target, s.borrow().as_ref());\n+                    }\n+                },\n+            )*\n+            _ => {\n+                // arbitrary non-zero size fallback\n+                for s in iter {\n+                    copy_slice_and_advance!(target, sep_bytes);\n+                    copy_slice_and_advance!(target, s.borrow().as_ref());\n+                }\n             }\n-            result.push_str(s.borrow());\n         }\n-        result\n+    };\n+}\n+\n+macro_rules! copy_slice_and_advance {\n+    ($target:expr, $bytes:expr) => {\n+        let len = $bytes.len();\n+        let (head, tail) = {$target}.split_at_mut(len);\n+        head.copy_from_slice($bytes);\n+        $target = tail;\n     }\n+}\n \n-    fn connect(&self, sep: &str) -> String {\n-        self.join(sep)\n+// Optimized join implementation that works for both Vec<T> (T: Copy) and String's inner vec\n+// Currently (2018-05-13) there is a bug with type inference and specialization (see issue #36262)\n+// For this reason SliceConcatExt<T> is not specialized for T: Copy and SliceConcatExt<str> is the\n+// only user of this function. It is left in place for the time when that is fixed.\n+//\n+// the bounds for String-join are S: Borrow<str> and for Vec-join Borrow<[T]>\n+// [T] and str both impl AsRef<[T]> for some T\n+// => s.borrow().as_ref() and we always have slices\n+fn join_generic_copy<B, T, S>(slice: &[S], sep: &[T]) -> Vec<T>\n+where\n+    T: Copy,\n+    B: AsRef<[T]> + ?Sized,\n+    S: Borrow<B>,\n+{\n+    let sep_len = sep.len();\n+    let mut iter = slice.iter();\n+\n+    // the first slice is the only one without a separator preceding it\n+    let first = match iter.next() {\n+        Some(first) => first,\n+        None => return vec![],\n+    };\n+\n+    // compute the exact total length of the joined Vec\n+    // if the `len` calculation overflows, we'll panic\n+    // we would have run out of memory anyway and the rest of the function requires\n+    // the entire Vec pre-allocated for safety\n+    let len =  sep_len.checked_mul(iter.len()).and_then(|n| {\n+            slice.iter()\n+                .map(|s| s.borrow().as_ref().len())\n+                .try_fold(n, usize::checked_add)\n+        }).expect(\"attempt to join into collection with len > usize::MAX\");\n+\n+    // crucial for safety\n+    let mut result = Vec::with_capacity(len);\n+    assert!(result.capacity() >= len);\n+\n+    result.extend_from_slice(first.borrow().as_ref());\n+\n+    unsafe {\n+        {\n+            let pos = result.len();\n+            let target = result.get_unchecked_mut(pos..len);\n+\n+            // copy separator and slices over without bounds checks\n+            // generate loops with hardcoded offsets for small separators\n+            // massive improvements possible (~ x2)\n+            spezialize_for_lengths!(sep, target, iter; 0, 1, 2, 3, 4);\n+        }\n+        result.set_len(len);\n     }\n+    result\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -158,13 +215,9 @@ impl ToOwned for str {\n }\n \n /// Methods for string slices.\n-#[cfg_attr(stage0, lang = \"str\")]\n-#[cfg_attr(not(stage0), lang = \"str_alloc\")]\n+#[lang = \"str_alloc\"]\n #[cfg(not(test))]\n impl str {\n-    #[cfg(stage0)]\n-    str_core_methods!();\n-\n     /// Converts a `Box<str>` into a `Box<[u8]>` without copying or allocating.\n     ///\n     /// # Examples\n@@ -207,18 +260,19 @@ impl str {\n     /// let s = \"this is old\";\n     /// assert_eq!(s, s.replace(\"cookie monster\", \"little lamb\"));\n     /// ```\n-    #[must_use]\n+    #[must_use = \"this returns the replaced string as a new allocation, \\\n+                  without modifying the original\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn replace<'a, P: Pattern<'a>>(&'a self, from: P, to: &str) -> String {\n         let mut result = String::new();\n         let mut last_end = 0;\n         for (start, part) in self.match_indices(from) {\n-            result.push_str(unsafe { self.slice_unchecked(last_end, start) });\n+            result.push_str(unsafe { self.get_unchecked(last_end..start) });\n             result.push_str(to);\n             last_end = start + part.len();\n         }\n-        result.push_str(unsafe { self.slice_unchecked(last_end, self.len()) });\n+        result.push_str(unsafe { self.get_unchecked(last_end..self.len()) });\n         result\n     }\n \n@@ -247,18 +301,19 @@ impl str {\n     /// let s = \"this is old\";\n     /// assert_eq!(s, s.replacen(\"cookie monster\", \"little lamb\", 10));\n     /// ```\n-    #[must_use]\n+    #[must_use = \"this returns the replaced string as a new allocation, \\\n+                  without modifying the original\"]\n     #[stable(feature = \"str_replacen\", since = \"1.16.0\")]\n     pub fn replacen<'a, P: Pattern<'a>>(&'a self, pat: P, to: &str, count: usize) -> String {\n         // Hope to reduce the times of re-allocation\n         let mut result = String::with_capacity(32);\n         let mut last_end = 0;\n         for (start, part) in self.match_indices(pat).take(count) {\n-            result.push_str(unsafe { self.slice_unchecked(last_end, start) });\n+            result.push_str(unsafe { self.get_unchecked(last_end..start) });\n             result.push_str(to);\n             last_end = start + part.len();\n         }\n-        result.push_str(unsafe { self.slice_unchecked(last_end, self.len()) });\n+        result.push_str(unsafe { self.get_unchecked(last_end..self.len()) });\n         result\n     }\n \n@@ -315,7 +370,18 @@ impl str {\n                 // See https://github.com/rust-lang/rust/issues/26035\n                 map_uppercase_sigma(self, i, &mut s)\n             } else {\n-                s.extend(c.to_lowercase());\n+                match conversions::to_lower(c) {\n+                    [a, '\\0', _] => s.push(a),\n+                    [a, b, '\\0'] => {\n+                        s.push(a);\n+                        s.push(b);\n+                    }\n+                    [a, b, c] => {\n+                        s.push(a);\n+                        s.push(b);\n+                        s.push(c);\n+                    }\n+                }\n             }\n         }\n         return s;\n@@ -369,18 +435,40 @@ impl str {\n     #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n     pub fn to_uppercase(&self) -> String {\n         let mut s = String::with_capacity(self.len());\n-        s.extend(self.chars().flat_map(|c| c.to_uppercase()));\n+        for c in self[..].chars() {\n+            match conversions::to_upper(c) {\n+                [a, '\\0', _] => s.push(a),\n+                [a, b, '\\0'] => {\n+                    s.push(a);\n+                    s.push(b);\n+                }\n+                [a, b, c] => {\n+                    s.push(a);\n+                    s.push(b);\n+                    s.push(c);\n+                }\n+            }\n+        }\n         return s;\n     }\n \n     /// Escapes each char in `s` with [`char::escape_debug`].\n     ///\n+    /// Note: only extended grapheme codepoints that begin the string will be\n+    /// escaped.\n+    ///\n     /// [`char::escape_debug`]: primitive.char.html#method.escape_debug\n     #[unstable(feature = \"str_escape\",\n                reason = \"return type may change to be an iterator\",\n                issue = \"27791\")]\n     pub fn escape_debug(&self) -> String {\n-        self.chars().flat_map(|c| c.escape_debug()).collect()\n+        let mut string = String::with_capacity(self.len());\n+        let mut chars = self.chars();\n+        if let Some(first) = chars.next() {\n+            string.extend(first.escape_debug_ext(true))\n+        }\n+        string.extend(chars.flat_map(|c| c.escape_debug_ext(false)));\n+        string\n     }\n \n     /// Escapes each char in `s` with [`char::escape_default`]."}, {"sha": "631779a17a1655e6e261e9864f277d3ae32bc881", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -66,7 +66,7 @@ use core::ptr;\n use core::str::pattern::Pattern;\n use core::str::lossy;\n \n-use alloc::CollectionAllocErr;\n+use collections::CollectionAllocErr;\n use borrow::{Cow, ToOwned};\n use boxed::Box;\n use str::{self, from_boxed_utf8_unchecked, FromStr, Utf8Error, Chars};\n@@ -380,7 +380,8 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> String {\n+    #[rustc_const_unstable(feature = \"const_string_new\")]\n+    pub const fn new() -> String {\n         String { vec: Vec::new() }\n     }\n \n@@ -1221,7 +1222,7 @@ impl String {\n \n         while idx < len {\n             let ch = unsafe {\n-                self.slice_unchecked(idx, len).chars().next().unwrap()\n+                self.get_unchecked(idx..len).chars().next().unwrap()\n             };\n             let ch_len = ch.len_utf8();\n \n@@ -1492,12 +1493,12 @@ impl String {\n         // Because the range removal happens in Drop, if the Drain iterator is leaked,\n         // the removal will not happen.\n         let len = self.len();\n-        let start = match range.start() {\n+        let start = match range.start_bound() {\n             Included(&n) => n,\n             Excluded(&n) => n + 1,\n             Unbounded => 0,\n         };\n-        let end = match range.end() {\n+        let end = match range.end_bound() {\n             Included(&n) => n + 1,\n             Excluded(&n) => n,\n             Unbounded => len,\n@@ -1550,12 +1551,12 @@ impl String {\n         // Replace_range does not have the memory safety issues of a vector Splice.\n         // of the vector version. The data is just plain bytes.\n \n-        match range.start() {\n+        match range.start_bound() {\n              Included(&n) => assert!(self.is_char_boundary(n)),\n              Excluded(&n) => assert!(self.is_char_boundary(n + 1)),\n              Unbounded => {},\n         };\n-        match range.end() {\n+        match range.end_bound() {\n              Included(&n) => assert!(self.is_char_boundary(n + 1)),\n              Excluded(&n) => assert!(self.is_char_boundary(n)),\n              Unbounded => {},\n@@ -2239,6 +2240,14 @@ impl<'a> From<String> for Cow<'a, str> {\n     }\n }\n \n+#[stable(feature = \"cow_from_string_ref\", since = \"1.28.0\")]\n+impl<'a> From<&'a String> for Cow<'a, str> {\n+    #[inline]\n+    fn from(s: &'a String) -> Cow<'a, str> {\n+        Cow::Borrowed(s.as_str())\n+    }\n+}\n+\n #[stable(feature = \"cow_str_from_iter\", since = \"1.12.0\")]\n impl<'a> FromIterator<char> for Cow<'a, str> {\n     fn from_iter<I: IntoIterator<Item = char>>(it: I) -> Cow<'a, str> {"}, {"sha": "a00b6b4e435f06e504f6521d4c137e4a9cd38343", "filename": "src/liballoc/sync.rs", "status": "added", "additions": 1944, "deletions": 0, "changes": 1944, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -0,0 +1,1944 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+//! Thread-safe reference-counting pointers.\n+//!\n+//! See the [`Arc<T>`][arc] documentation for more details.\n+//!\n+//! [arc]: struct.Arc.html\n+\n+use core::any::Any;\n+use core::sync::atomic;\n+use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n+use core::borrow;\n+use core::fmt;\n+use core::cmp::Ordering;\n+use core::intrinsics::abort;\n+use core::mem::{self, align_of_val, size_of_val};\n+use core::ops::Deref;\n+use core::ops::CoerceUnsized;\n+use core::ptr::{self, NonNull};\n+use core::marker::{Unsize, PhantomData};\n+use core::hash::{Hash, Hasher};\n+use core::{isize, usize};\n+use core::convert::From;\n+\n+use alloc::{Global, Alloc, Layout, box_free, handle_alloc_error};\n+use boxed::Box;\n+use rc::is_dangling;\n+use string::String;\n+use vec::Vec;\n+\n+/// A soft limit on the amount of references that may be made to an `Arc`.\n+///\n+/// Going above this limit will abort your program (although not\n+/// necessarily) at _exactly_ `MAX_REFCOUNT + 1` references.\n+const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n+\n+/// A thread-safe reference-counting pointer. 'Arc' stands for 'Atomically\n+/// Reference Counted'.\n+///\n+/// The type `Arc<T>` provides shared ownership of a value of type `T`,\n+/// allocated in the heap. Invoking [`clone`][clone] on `Arc` produces\n+/// a new pointer to the same value in the heap. When the last `Arc`\n+/// pointer to a given value is destroyed, the pointed-to value is\n+/// also destroyed.\n+///\n+/// Shared references in Rust disallow mutation by default, and `Arc` is no\n+/// exception: you cannot generally obtain a mutable reference to something\n+/// inside an `Arc`. If you need to mutate through an `Arc`, use\n+/// [`Mutex`][mutex], [`RwLock`][rwlock], or one of the [`Atomic`][atomic]\n+/// types.\n+///\n+/// ## Thread Safety\n+///\n+/// Unlike [`Rc<T>`], `Arc<T>` uses atomic operations for its reference\n+/// counting. This means that it is thread-safe. The disadvantage is that\n+/// atomic operations are more expensive than ordinary memory accesses. If you\n+/// are not sharing reference-counted values between threads, consider using\n+/// [`Rc<T>`] for lower overhead. [`Rc<T>`] is a safe default, because the\n+/// compiler will catch any attempt to send an [`Rc<T>`] between threads.\n+/// However, a library might choose `Arc<T>` in order to give library consumers\n+/// more flexibility.\n+///\n+/// `Arc<T>` will implement [`Send`] and [`Sync`] as long as the `T` implements\n+/// [`Send`] and [`Sync`]. Why can't you put a non-thread-safe type `T` in an\n+/// `Arc<T>` to make it thread-safe? This may be a bit counter-intuitive at\n+/// first: after all, isn't the point of `Arc<T>` thread safety? The key is\n+/// this: `Arc<T>` makes it thread safe to have multiple ownership of the same\n+/// data, but it  doesn't add thread safety to its data. Consider\n+/// `Arc<`[`RefCell<T>`]`>`. [`RefCell<T>`] isn't [`Sync`], and if `Arc<T>` was always\n+/// [`Send`], `Arc<`[`RefCell<T>`]`>` would be as well. But then we'd have a problem:\n+/// [`RefCell<T>`] is not thread safe; it keeps track of the borrowing count using\n+/// non-atomic operations.\n+///\n+/// In the end, this means that you may need to pair `Arc<T>` with some sort of\n+/// [`std::sync`] type, usually [`Mutex<T>`][mutex].\n+///\n+/// ## Breaking cycles with `Weak`\n+///\n+/// The [`downgrade`][downgrade] method can be used to create a non-owning\n+/// [`Weak`][weak] pointer. A [`Weak`][weak] pointer can be [`upgrade`][upgrade]d\n+/// to an `Arc`, but this will return [`None`] if the value has already been\n+/// dropped.\n+///\n+/// A cycle between `Arc` pointers will never be deallocated. For this reason,\n+/// [`Weak`][weak] is used to break cycles. For example, a tree could have\n+/// strong `Arc` pointers from parent nodes to children, and [`Weak`][weak]\n+/// pointers from children back to their parents.\n+///\n+/// # Cloning references\n+///\n+/// Creating a new reference from an existing reference counted pointer is done using the\n+/// `Clone` trait implemented for [`Arc<T>`][arc] and [`Weak<T>`][weak].\n+///\n+/// ```\n+/// use std::sync::Arc;\n+/// let foo = Arc::new(vec![1.0, 2.0, 3.0]);\n+/// // The two syntaxes below are equivalent.\n+/// let a = foo.clone();\n+/// let b = Arc::clone(&foo);\n+/// // a and b both point to the same memory location as foo.\n+/// ```\n+///\n+/// The [`Arc::clone(&from)`] syntax is the most idiomatic because it conveys more explicitly\n+/// the meaning of the code. In the example above, this syntax makes it easier to see that\n+/// this code is creating a new reference rather than copying the whole content of foo.\n+///\n+/// ## `Deref` behavior\n+///\n+/// `Arc<T>` automatically dereferences to `T` (via the [`Deref`][deref] trait),\n+/// so you can call `T`'s methods on a value of type `Arc<T>`. To avoid name\n+/// clashes with `T`'s methods, the methods of `Arc<T>` itself are [associated\n+/// functions][assoc], called using function-like syntax:\n+///\n+/// ```\n+/// use std::sync::Arc;\n+/// let my_arc = Arc::new(());\n+///\n+/// Arc::downgrade(&my_arc);\n+/// ```\n+///\n+/// [`Weak<T>`][weak] does not auto-dereference to `T`, because the value may have\n+/// already been destroyed.\n+///\n+/// [arc]: struct.Arc.html\n+/// [weak]: struct.Weak.html\n+/// [`Rc<T>`]: ../../std/rc/struct.Rc.html\n+/// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n+/// [mutex]: ../../std/sync/struct.Mutex.html\n+/// [rwlock]: ../../std/sync/struct.RwLock.html\n+/// [atomic]: ../../std/sync/atomic/index.html\n+/// [`Send`]: ../../std/marker/trait.Send.html\n+/// [`Sync`]: ../../std/marker/trait.Sync.html\n+/// [deref]: ../../std/ops/trait.Deref.html\n+/// [downgrade]: struct.Arc.html#method.downgrade\n+/// [upgrade]: struct.Weak.html#method.upgrade\n+/// [`None`]: ../../std/option/enum.Option.html#variant.None\n+/// [assoc]: ../../book/first-edition/method-syntax.html#associated-functions\n+/// [`RefCell<T>`]: ../../std/cell/struct.RefCell.html\n+/// [`std::sync`]: ../../std/sync/index.html\n+/// [`Arc::clone(&from)`]: #method.clone\n+///\n+/// # Examples\n+///\n+/// Sharing some immutable data between threads:\n+///\n+// Note that we **do not** run these tests here. The windows builders get super\n+// unhappy if a thread outlives the main thread and then exits at the same time\n+// (something deadlocks) so we just avoid this entirely by not running these\n+// tests.\n+/// ```no_run\n+/// use std::sync::Arc;\n+/// use std::thread;\n+///\n+/// let five = Arc::new(5);\n+///\n+/// for _ in 0..10 {\n+///     let five = Arc::clone(&five);\n+///\n+///     thread::spawn(move || {\n+///         println!(\"{:?}\", five);\n+///     });\n+/// }\n+/// ```\n+///\n+/// Sharing a mutable [`AtomicUsize`]:\n+///\n+/// [`AtomicUsize`]: ../../std/sync/atomic/struct.AtomicUsize.html\n+///\n+/// ```no_run\n+/// use std::sync::Arc;\n+/// use std::sync::atomic::{AtomicUsize, Ordering};\n+/// use std::thread;\n+///\n+/// let val = Arc::new(AtomicUsize::new(5));\n+///\n+/// for _ in 0..10 {\n+///     let val = Arc::clone(&val);\n+///\n+///     thread::spawn(move || {\n+///         let v = val.fetch_add(1, Ordering::SeqCst);\n+///         println!(\"{:?}\", v);\n+///     });\n+/// }\n+/// ```\n+///\n+/// See the [`rc` documentation][rc_examples] for more examples of reference\n+/// counting in general.\n+///\n+/// [rc_examples]: ../../std/rc/index.html#examples\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Arc<T: ?Sized> {\n+    ptr: NonNull<ArcInner<T>>,\n+    phantom: PhantomData<T>,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: ?Sized + Sync + Send> Send for Arc<T> {}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<T: ?Sized + Sync + Send> Sync for Arc<T> {}\n+\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n+\n+/// `Weak` is a version of [`Arc`] that holds a non-owning reference to the\n+/// managed value. The value is accessed by calling [`upgrade`] on the `Weak`\n+/// pointer, which returns an [`Option`]`<`[`Arc`]`<T>>`.\n+///\n+/// Since a `Weak` reference does not count towards ownership, it will not\n+/// prevent the inner value from being dropped, and `Weak` itself makes no\n+/// guarantees about the value still being present and may return [`None`]\n+/// when [`upgrade`]d.\n+///\n+/// A `Weak` pointer is useful for keeping a temporary reference to the value\n+/// within [`Arc`] without extending its lifetime. It is also used to prevent\n+/// circular references between [`Arc`] pointers, since mutual owning references\n+/// would never allow either [`Arc`] to be dropped. For example, a tree could\n+/// have strong [`Arc`] pointers from parent nodes to children, and `Weak`\n+/// pointers from children back to their parents.\n+///\n+/// The typical way to obtain a `Weak` pointer is to call [`Arc::downgrade`].\n+///\n+/// [`Arc`]: struct.Arc.html\n+/// [`Arc::downgrade`]: struct.Arc.html#method.downgrade\n+/// [`upgrade`]: struct.Weak.html#method.upgrade\n+/// [`Option`]: ../../std/option/enum.Option.html\n+/// [`None`]: ../../std/option/enum.Option.html#variant.None\n+#[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n+pub struct Weak<T: ?Sized> {\n+    // This is a `NonNull` to allow optimizing the size of this type in enums,\n+    // but it is not necessarily a valid pointer.\n+    // `Weak::new` sets this to `usize::MAX` so that it doesn\u2019t need\n+    // to allocate space on the heap.  That's not a value a real pointer\n+    // will ever have because RcBox has alignment at least 2.\n+    ptr: NonNull<ArcInner<T>>,\n+}\n+\n+#[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n+unsafe impl<T: ?Sized + Sync + Send> Send for Weak<T> {}\n+#[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n+unsafe impl<T: ?Sized + Sync + Send> Sync for Weak<T> {}\n+\n+#[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n+\n+#[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n+impl<T: ?Sized + fmt::Debug> fmt::Debug for Weak<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"(Weak)\")\n+    }\n+}\n+\n+struct ArcInner<T: ?Sized> {\n+    strong: atomic::AtomicUsize,\n+\n+    // the value usize::MAX acts as a sentinel for temporarily \"locking\" the\n+    // ability to upgrade weak pointers or downgrade strong ones; this is used\n+    // to avoid races in `make_mut` and `get_mut`.\n+    weak: atomic::AtomicUsize,\n+\n+    data: T,\n+}\n+\n+unsafe impl<T: ?Sized + Sync + Send> Send for ArcInner<T> {}\n+unsafe impl<T: ?Sized + Sync + Send> Sync for ArcInner<T> {}\n+\n+impl<T> Arc<T> {\n+    /// Constructs a new `Arc<T>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn new(data: T) -> Arc<T> {\n+        // Start the weak pointer count as 1 which is the weak pointer that's\n+        // held by all the strong pointers (kinda), see std/rc.rs for more info\n+        let x: Box<_> = box ArcInner {\n+            strong: atomic::AtomicUsize::new(1),\n+            weak: atomic::AtomicUsize::new(1),\n+            data,\n+        };\n+        Arc { ptr: Box::into_raw_non_null(x), phantom: PhantomData }\n+    }\n+\n+    /// Returns the contained value, if the `Arc` has exactly one strong reference.\n+    ///\n+    /// Otherwise, an [`Err`][result] is returned with the same `Arc` that was\n+    /// passed in.\n+    ///\n+    /// This will succeed even if there are outstanding weak references.\n+    ///\n+    /// [result]: ../../std/result/enum.Result.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let x = Arc::new(3);\n+    /// assert_eq!(Arc::try_unwrap(x), Ok(3));\n+    ///\n+    /// let x = Arc::new(4);\n+    /// let _y = Arc::clone(&x);\n+    /// assert_eq!(*Arc::try_unwrap(x).unwrap_err(), 4);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"arc_unique\", since = \"1.4.0\")]\n+    pub fn try_unwrap(this: Self) -> Result<T, Self> {\n+        // See `drop` for why all these atomics are like this\n+        if this.inner().strong.compare_exchange(1, 0, Release, Relaxed).is_err() {\n+            return Err(this);\n+        }\n+\n+        atomic::fence(Acquire);\n+\n+        unsafe {\n+            let elem = ptr::read(&this.ptr.as_ref().data);\n+\n+            // Make a weak pointer to clean up the implicit strong-weak reference\n+            let _weak = Weak { ptr: this.ptr };\n+            mem::forget(this);\n+\n+            Ok(elem)\n+        }\n+    }\n+}\n+\n+impl<T: ?Sized> Arc<T> {\n+    /// Consumes the `Arc`, returning the wrapped pointer.\n+    ///\n+    /// To avoid a memory leak the pointer must be converted back to an `Arc` using\n+    /// [`Arc::from_raw`][from_raw].\n+    ///\n+    /// [from_raw]: struct.Arc.html#method.from_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let x = Arc::new(10);\n+    /// let x_ptr = Arc::into_raw(x);\n+    /// assert_eq!(unsafe { *x_ptr }, 10);\n+    /// ```\n+    #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n+    pub fn into_raw(this: Self) -> *const T {\n+        let ptr: *const T = &*this;\n+        mem::forget(this);\n+        ptr\n+    }\n+\n+    /// Constructs an `Arc` from a raw pointer.\n+    ///\n+    /// The raw pointer must have been previously returned by a call to a\n+    /// [`Arc::into_raw`][into_raw].\n+    ///\n+    /// This function is unsafe because improper use may lead to memory problems. For example, a\n+    /// double-free may occur if the function is called twice on the same raw pointer.\n+    ///\n+    /// [into_raw]: struct.Arc.html#method.into_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let x = Arc::new(10);\n+    /// let x_ptr = Arc::into_raw(x);\n+    ///\n+    /// unsafe {\n+    ///     // Convert back to an `Arc` to prevent leak.\n+    ///     let x = Arc::from_raw(x_ptr);\n+    ///     assert_eq!(*x, 10);\n+    ///\n+    ///     // Further calls to `Arc::from_raw(x_ptr)` would be memory unsafe.\n+    /// }\n+    ///\n+    /// // The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!\n+    /// ```\n+    #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n+    pub unsafe fn from_raw(ptr: *const T) -> Self {\n+        // Align the unsized value to the end of the ArcInner.\n+        // Because it is ?Sized, it will always be the last field in memory.\n+        let align = align_of_val(&*ptr);\n+        let layout = Layout::new::<ArcInner<()>>();\n+        let offset = (layout.size() + layout.padding_needed_for(align)) as isize;\n+\n+        // Reverse the offset to find the original ArcInner.\n+        let fake_ptr = ptr as *mut ArcInner<T>;\n+        let arc_ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n+\n+        Arc {\n+            ptr: NonNull::new_unchecked(arc_ptr),\n+            phantom: PhantomData,\n+        }\n+    }\n+\n+    /// Creates a new [`Weak`][weak] pointer to this value.\n+    ///\n+    /// [weak]: struct.Weak.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// let weak_five = Arc::downgrade(&five);\n+    /// ```\n+    #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n+    pub fn downgrade(this: &Self) -> Weak<T> {\n+        // This Relaxed is OK because we're checking the value in the CAS\n+        // below.\n+        let mut cur = this.inner().weak.load(Relaxed);\n+\n+        loop {\n+            // check if the weak counter is currently \"locked\"; if so, spin.\n+            if cur == usize::MAX {\n+                cur = this.inner().weak.load(Relaxed);\n+                continue;\n+            }\n+\n+            // NOTE: this code currently ignores the possibility of overflow\n+            // into usize::MAX; in general both Rc and Arc need to be adjusted\n+            // to deal with overflow.\n+\n+            // Unlike with Clone(), we need this to be an Acquire read to\n+            // synchronize with the write coming from `is_unique`, so that the\n+            // events prior to that write happen before this read.\n+            match this.inner().weak.compare_exchange_weak(cur, cur + 1, Acquire, Relaxed) {\n+                Ok(_) => {\n+                    // Make sure we do not create a dangling Weak\n+                    debug_assert!(!is_dangling(this.ptr));\n+                    return Weak { ptr: this.ptr };\n+                }\n+                Err(old) => cur = old,\n+            }\n+        }\n+    }\n+\n+    /// Gets the number of [`Weak`][weak] pointers to this value.\n+    ///\n+    /// [weak]: struct.Weak.html\n+    ///\n+    /// # Safety\n+    ///\n+    /// This method by itself is safe, but using it correctly requires extra care.\n+    /// Another thread can change the weak count at any time,\n+    /// including potentially between calling this method and acting on the result.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    /// let _weak_five = Arc::downgrade(&five);\n+    ///\n+    /// // This assertion is deterministic because we haven't shared\n+    /// // the `Arc` or `Weak` between threads.\n+    /// assert_eq!(1, Arc::weak_count(&five));\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"arc_counts\", since = \"1.15.0\")]\n+    pub fn weak_count(this: &Self) -> usize {\n+        let cnt = this.inner().weak.load(SeqCst);\n+        // If the weak count is currently locked, the value of the\n+        // count was 0 just before taking the lock.\n+        if cnt == usize::MAX { 0 } else { cnt - 1 }\n+    }\n+\n+    /// Gets the number of strong (`Arc`) pointers to this value.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This method by itself is safe, but using it correctly requires extra care.\n+    /// Another thread can change the strong count at any time,\n+    /// including potentially between calling this method and acting on the result.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    /// let _also_five = Arc::clone(&five);\n+    ///\n+    /// // This assertion is deterministic because we haven't shared\n+    /// // the `Arc` between threads.\n+    /// assert_eq!(2, Arc::strong_count(&five));\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"arc_counts\", since = \"1.15.0\")]\n+    pub fn strong_count(this: &Self) -> usize {\n+        this.inner().strong.load(SeqCst)\n+    }\n+\n+    #[inline]\n+    fn inner(&self) -> &ArcInner<T> {\n+        // This unsafety is ok because while this arc is alive we're guaranteed\n+        // that the inner pointer is valid. Furthermore, we know that the\n+        // `ArcInner` structure itself is `Sync` because the inner data is\n+        // `Sync` as well, so we're ok loaning out an immutable pointer to these\n+        // contents.\n+        unsafe { self.ptr.as_ref() }\n+    }\n+\n+    // Non-inlined part of `drop`.\n+    #[inline(never)]\n+    unsafe fn drop_slow(&mut self) {\n+        // Destroy the data at this time, even though we may not free the box\n+        // allocation itself (there may still be weak pointers lying around).\n+        ptr::drop_in_place(&mut self.ptr.as_mut().data);\n+\n+        if self.inner().weak.fetch_sub(1, Release) == 1 {\n+            atomic::fence(Acquire);\n+            Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()))\n+        }\n+    }\n+\n+    #[inline]\n+    #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n+    /// Returns true if the two `Arc`s point to the same value (not\n+    /// just values that compare as equal).\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    /// let same_five = Arc::clone(&five);\n+    /// let other_five = Arc::new(5);\n+    ///\n+    /// assert!(Arc::ptr_eq(&five, &same_five));\n+    /// assert!(!Arc::ptr_eq(&five, &other_five));\n+    /// ```\n+    pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n+        this.ptr.as_ptr() == other.ptr.as_ptr()\n+    }\n+}\n+\n+impl<T: ?Sized> Arc<T> {\n+    // Allocates an `ArcInner<T>` with sufficient space for an unsized value\n+    unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n+        // Create a fake ArcInner to find allocation size and alignment\n+        let fake_ptr = ptr as *mut ArcInner<T>;\n+\n+        let layout = Layout::for_value(&*fake_ptr);\n+\n+        let mem = Global.alloc(layout)\n+            .unwrap_or_else(|_| handle_alloc_error(layout));\n+\n+        // Initialize the real ArcInner\n+        let inner = set_data_ptr(ptr as *mut T, mem.as_ptr() as *mut u8) as *mut ArcInner<T>;\n+\n+        ptr::write(&mut (*inner).strong, atomic::AtomicUsize::new(1));\n+        ptr::write(&mut (*inner).weak, atomic::AtomicUsize::new(1));\n+\n+        inner\n+    }\n+\n+    fn from_box(v: Box<T>) -> Arc<T> {\n+        unsafe {\n+            let box_unique = Box::into_unique(v);\n+            let bptr = box_unique.as_ptr();\n+\n+            let value_size = size_of_val(&*bptr);\n+            let ptr = Self::allocate_for_ptr(bptr);\n+\n+            // Copy value as bytes\n+            ptr::copy_nonoverlapping(\n+                bptr as *const T as *const u8,\n+                &mut (*ptr).data as *mut _ as *mut u8,\n+                value_size);\n+\n+            // Free the allocation without dropping its contents\n+            box_free(box_unique);\n+\n+            Arc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n+        }\n+    }\n+}\n+\n+// Sets the data pointer of a `?Sized` raw pointer.\n+//\n+// For a slice/trait object, this sets the `data` field and leaves the rest\n+// unchanged. For a sized raw pointer, this simply sets the pointer.\n+unsafe fn set_data_ptr<T: ?Sized, U>(mut ptr: *mut T, data: *mut U) -> *mut T {\n+    ptr::write(&mut ptr as *mut _ as *mut *mut u8, data as *mut u8);\n+    ptr\n+}\n+\n+impl<T> Arc<[T]> {\n+    // Copy elements from slice into newly allocated Arc<[T]>\n+    //\n+    // Unsafe because the caller must either take ownership or bind `T: Copy`\n+    unsafe fn copy_from_slice(v: &[T]) -> Arc<[T]> {\n+        let v_ptr = v as *const [T];\n+        let ptr = Self::allocate_for_ptr(v_ptr);\n+\n+        ptr::copy_nonoverlapping(\n+            v.as_ptr(),\n+            &mut (*ptr).data as *mut [T] as *mut T,\n+            v.len());\n+\n+        Arc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n+    }\n+}\n+\n+// Specialization trait used for From<&[T]>\n+trait ArcFromSlice<T> {\n+    fn from_slice(slice: &[T]) -> Self;\n+}\n+\n+impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n+    #[inline]\n+    default fn from_slice(v: &[T]) -> Self {\n+        // Panic guard while cloning T elements.\n+        // In the event of a panic, elements that have been written\n+        // into the new ArcInner will be dropped, then the memory freed.\n+        struct Guard<T> {\n+            mem: NonNull<u8>,\n+            elems: *mut T,\n+            layout: Layout,\n+            n_elems: usize,\n+        }\n+\n+        impl<T> Drop for Guard<T> {\n+            fn drop(&mut self) {\n+                use core::slice::from_raw_parts_mut;\n+\n+                unsafe {\n+                    let slice = from_raw_parts_mut(self.elems, self.n_elems);\n+                    ptr::drop_in_place(slice);\n+\n+                    Global.dealloc(self.mem.cast(), self.layout.clone());\n+                }\n+            }\n+        }\n+\n+        unsafe {\n+            let v_ptr = v as *const [T];\n+            let ptr = Self::allocate_for_ptr(v_ptr);\n+\n+            let mem = ptr as *mut _ as *mut u8;\n+            let layout = Layout::for_value(&*ptr);\n+\n+            // Pointer to first element\n+            let elems = &mut (*ptr).data as *mut [T] as *mut T;\n+\n+            let mut guard = Guard{\n+                mem: NonNull::new_unchecked(mem),\n+                elems: elems,\n+                layout: layout,\n+                n_elems: 0,\n+            };\n+\n+            for (i, item) in v.iter().enumerate() {\n+                ptr::write(elems.offset(i as isize), item.clone());\n+                guard.n_elems += 1;\n+            }\n+\n+            // All clear. Forget the guard so it doesn't free the new ArcInner.\n+            mem::forget(guard);\n+\n+            Arc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n+        }\n+    }\n+}\n+\n+impl<T: Copy> ArcFromSlice<T> for Arc<[T]> {\n+    #[inline]\n+    fn from_slice(v: &[T]) -> Self {\n+        unsafe { Arc::copy_from_slice(v) }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> Clone for Arc<T> {\n+    /// Makes a clone of the `Arc` pointer.\n+    ///\n+    /// This creates another pointer to the same inner value, increasing the\n+    /// strong reference count.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// Arc::clone(&five);\n+    /// ```\n+    #[inline]\n+    fn clone(&self) -> Arc<T> {\n+        // Using a relaxed ordering is alright here, as knowledge of the\n+        // original reference prevents other threads from erroneously deleting\n+        // the object.\n+        //\n+        // As explained in the [Boost documentation][1], Increasing the\n+        // reference counter can always be done with memory_order_relaxed: New\n+        // references to an object can only be formed from an existing\n+        // reference, and passing an existing reference from one thread to\n+        // another must already provide any required synchronization.\n+        //\n+        // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n+        let old_size = self.inner().strong.fetch_add(1, Relaxed);\n+\n+        // However we need to guard against massive refcounts in case someone\n+        // is `mem::forget`ing Arcs. If we don't do this the count can overflow\n+        // and users will use-after free. We racily saturate to `isize::MAX` on\n+        // the assumption that there aren't ~2 billion threads incrementing\n+        // the reference count at once. This branch will never be taken in\n+        // any realistic program.\n+        //\n+        // We abort because such a program is incredibly degenerate, and we\n+        // don't care to support it.\n+        if old_size > MAX_REFCOUNT {\n+            unsafe {\n+                abort();\n+            }\n+        }\n+\n+        Arc { ptr: self.ptr, phantom: PhantomData }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> Deref for Arc<T> {\n+    type Target = T;\n+\n+    #[inline]\n+    fn deref(&self) -> &T {\n+        &self.inner().data\n+    }\n+}\n+\n+impl<T: Clone> Arc<T> {\n+    /// Makes a mutable reference into the given `Arc`.\n+    ///\n+    /// If there are other `Arc` or [`Weak`][weak] pointers to the same value,\n+    /// then `make_mut` will invoke [`clone`][clone] on the inner value to\n+    /// ensure unique ownership. This is also referred to as clone-on-write.\n+    ///\n+    /// See also [`get_mut`][get_mut], which will fail rather than cloning.\n+    ///\n+    /// [weak]: struct.Weak.html\n+    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n+    /// [get_mut]: struct.Arc.html#method.get_mut\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut data = Arc::new(5);\n+    ///\n+    /// *Arc::make_mut(&mut data) += 1;         // Won't clone anything\n+    /// let mut other_data = Arc::clone(&data); // Won't clone inner data\n+    /// *Arc::make_mut(&mut data) += 1;         // Clones inner data\n+    /// *Arc::make_mut(&mut data) += 1;         // Won't clone anything\n+    /// *Arc::make_mut(&mut other_data) *= 2;   // Won't clone anything\n+    ///\n+    /// // Now `data` and `other_data` point to different values.\n+    /// assert_eq!(*data, 8);\n+    /// assert_eq!(*other_data, 12);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"arc_unique\", since = \"1.4.0\")]\n+    pub fn make_mut(this: &mut Self) -> &mut T {\n+        // Note that we hold both a strong reference and a weak reference.\n+        // Thus, releasing our strong reference only will not, by itself, cause\n+        // the memory to be deallocated.\n+        //\n+        // Use Acquire to ensure that we see any writes to `weak` that happen\n+        // before release writes (i.e., decrements) to `strong`. Since we hold a\n+        // weak count, there's no chance the ArcInner itself could be\n+        // deallocated.\n+        if this.inner().strong.compare_exchange(1, 0, Acquire, Relaxed).is_err() {\n+            // Another strong pointer exists; clone\n+            *this = Arc::new((**this).clone());\n+        } else if this.inner().weak.load(Relaxed) != 1 {\n+            // Relaxed suffices in the above because this is fundamentally an\n+            // optimization: we are always racing with weak pointers being\n+            // dropped. Worst case, we end up allocated a new Arc unnecessarily.\n+\n+            // We removed the last strong ref, but there are additional weak\n+            // refs remaining. We'll move the contents to a new Arc, and\n+            // invalidate the other weak refs.\n+\n+            // Note that it is not possible for the read of `weak` to yield\n+            // usize::MAX (i.e., locked), since the weak count can only be\n+            // locked by a thread with a strong reference.\n+\n+            // Materialize our own implicit weak pointer, so that it can clean\n+            // up the ArcInner as needed.\n+            let weak = Weak { ptr: this.ptr };\n+\n+            // mark the data itself as already deallocated\n+            unsafe {\n+                // there is no data race in the implicit write caused by `read`\n+                // here (due to zeroing) because data is no longer accessed by\n+                // other threads (due to there being no more strong refs at this\n+                // point).\n+                let mut swap = Arc::new(ptr::read(&weak.ptr.as_ref().data));\n+                mem::swap(this, &mut swap);\n+                mem::forget(swap);\n+            }\n+        } else {\n+            // We were the sole reference of either kind; bump back up the\n+            // strong ref count.\n+            this.inner().strong.store(1, Release);\n+        }\n+\n+        // As with `get_mut()`, the unsafety is ok because our reference was\n+        // either unique to begin with, or became one upon cloning the contents.\n+        unsafe {\n+            &mut this.ptr.as_mut().data\n+        }\n+    }\n+}\n+\n+impl<T: ?Sized> Arc<T> {\n+    /// Returns a mutable reference to the inner value, if there are\n+    /// no other `Arc` or [`Weak`][weak] pointers to the same value.\n+    ///\n+    /// Returns [`None`][option] otherwise, because it is not safe to\n+    /// mutate a shared value.\n+    ///\n+    /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n+    /// the inner value when it's shared.\n+    ///\n+    /// [weak]: struct.Weak.html\n+    /// [option]: ../../std/option/enum.Option.html\n+    /// [make_mut]: struct.Arc.html#method.make_mut\n+    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut x = Arc::new(3);\n+    /// *Arc::get_mut(&mut x).unwrap() = 4;\n+    /// assert_eq!(*x, 4);\n+    ///\n+    /// let _y = Arc::clone(&x);\n+    /// assert!(Arc::get_mut(&mut x).is_none());\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"arc_unique\", since = \"1.4.0\")]\n+    pub fn get_mut(this: &mut Self) -> Option<&mut T> {\n+        if this.is_unique() {\n+            // This unsafety is ok because we're guaranteed that the pointer\n+            // returned is the *only* pointer that will ever be returned to T. Our\n+            // reference count is guaranteed to be 1 at this point, and we required\n+            // the Arc itself to be `mut`, so we're returning the only possible\n+            // reference to the inner data.\n+            unsafe {\n+                Some(&mut this.ptr.as_mut().data)\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Determine whether this is the unique reference (including weak refs) to\n+    /// the underlying data.\n+    ///\n+    /// Note that this requires locking the weak ref count.\n+    fn is_unique(&mut self) -> bool {\n+        // lock the weak pointer count if we appear to be the sole weak pointer\n+        // holder.\n+        //\n+        // The acquire label here ensures a happens-before relationship with any\n+        // writes to `strong` (in particular in `Weak::upgrade`) prior to decrements\n+        // of the `weak` count (via `Weak::drop`, which uses release).  If the upgraded\n+        // weak ref was never dropped, the CAS here will fail so we do not care to synchronize.\n+        if self.inner().weak.compare_exchange(1, usize::MAX, Acquire, Relaxed).is_ok() {\n+            // This needs to be an `Acquire` to synchronize with the decrement of the `strong`\n+            // counter in `drop` -- the only access that happens when any but the last reference\n+            // is being dropped.\n+            let unique = self.inner().strong.load(Acquire) == 1;\n+\n+            // The release write here synchronizes with a read in `downgrade`,\n+            // effectively preventing the above read of `strong` from happening\n+            // after the write.\n+            self.inner().weak.store(1, Release); // release the lock\n+            unique\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl<#[may_dangle] T: ?Sized> Drop for Arc<T> {\n+    /// Drops the `Arc`.\n+    ///\n+    /// This will decrement the strong reference count. If the strong reference\n+    /// count reaches zero then the only other references (if any) are\n+    /// [`Weak`][weak], so we `drop` the inner value.\n+    ///\n+    /// [weak]: struct.Weak.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// struct Foo;\n+    ///\n+    /// impl Drop for Foo {\n+    ///     fn drop(&mut self) {\n+    ///         println!(\"dropped!\");\n+    ///     }\n+    /// }\n+    ///\n+    /// let foo  = Arc::new(Foo);\n+    /// let foo2 = Arc::clone(&foo);\n+    ///\n+    /// drop(foo);    // Doesn't print anything\n+    /// drop(foo2);   // Prints \"dropped!\"\n+    /// ```\n+    #[inline]\n+    fn drop(&mut self) {\n+        // Because `fetch_sub` is already atomic, we do not need to synchronize\n+        // with other threads unless we are going to delete the object. This\n+        // same logic applies to the below `fetch_sub` to the `weak` count.\n+        if self.inner().strong.fetch_sub(1, Release) != 1 {\n+            return;\n+        }\n+\n+        // This fence is needed to prevent reordering of use of the data and\n+        // deletion of the data.  Because it is marked `Release`, the decreasing\n+        // of the reference count synchronizes with this `Acquire` fence. This\n+        // means that use of the data happens before decreasing the reference\n+        // count, which happens before this fence, which happens before the\n+        // deletion of the data.\n+        //\n+        // As explained in the [Boost documentation][1],\n+        //\n+        // > It is important to enforce any possible access to the object in one\n+        // > thread (through an existing reference) to *happen before* deleting\n+        // > the object in a different thread. This is achieved by a \"release\"\n+        // > operation after dropping a reference (any access to the object\n+        // > through this reference must obviously happened before), and an\n+        // > \"acquire\" operation before deleting the object.\n+        //\n+        // In particular, while the contents of an Arc are usually immutable, it's\n+        // possible to have interior writes to something like a Mutex<T>. Since a\n+        // Mutex is not acquired when it is deleted, we can't rely on its\n+        // synchronization logic to make writes in thread A visible to a destructor\n+        // running in thread B.\n+        //\n+        // Also note that the Acquire fence here could probably be replaced with an\n+        // Acquire load, which could improve performance in highly-contended\n+        // situations. See [2].\n+        //\n+        // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n+        // [2]: (https://github.com/rust-lang/rust/pull/41714)\n+        atomic::fence(Acquire);\n+\n+        unsafe {\n+            self.drop_slow();\n+        }\n+    }\n+}\n+\n+impl Arc<dyn Any + Send + Sync> {\n+    #[inline]\n+    #[stable(feature = \"rc_downcast\", since = \"1.29.0\")]\n+    /// Attempt to downcast the `Arc<dyn Any + Send + Sync>` to a concrete type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::any::Any;\n+    /// use std::sync::Arc;\n+    ///\n+    /// fn print_if_string(value: Arc<dyn Any + Send + Sync>) {\n+    ///     if let Ok(string) = value.downcast::<String>() {\n+    ///         println!(\"String ({}): {}\", string.len(), string);\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let my_string = \"Hello World\".to_string();\n+    ///     print_if_string(Arc::new(my_string));\n+    ///     print_if_string(Arc::new(0i8));\n+    /// }\n+    /// ```\n+    pub fn downcast<T>(self) -> Result<Arc<T>, Self>\n+    where\n+        T: Any + Send + Sync + 'static,\n+    {\n+        if (*self).is::<T>() {\n+            let ptr = self.ptr.cast::<ArcInner<T>>();\n+            mem::forget(self);\n+            Ok(Arc { ptr, phantom: PhantomData })\n+        } else {\n+            Err(self)\n+        }\n+    }\n+}\n+\n+impl<T> Weak<T> {\n+    /// Constructs a new `Weak<T>`, without allocating any memory.\n+    /// Calling [`upgrade`] on the return value always gives [`None`].\n+    ///\n+    /// [`upgrade`]: struct.Weak.html#method.upgrade\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Weak;\n+    ///\n+    /// let empty: Weak<i64> = Weak::new();\n+    /// assert!(empty.upgrade().is_none());\n+    /// ```\n+    #[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n+    pub fn new() -> Weak<T> {\n+        Weak {\n+            ptr: NonNull::new(usize::MAX as *mut ArcInner<T>).expect(\"MAX is not 0\"),\n+        }\n+    }\n+}\n+\n+impl<T: ?Sized> Weak<T> {\n+    /// Attempts to upgrade the `Weak` pointer to an [`Arc`], extending\n+    /// the lifetime of the value if successful.\n+    ///\n+    /// Returns [`None`] if the value has since been dropped.\n+    ///\n+    /// [`Arc`]: struct.Arc.html\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// let weak_five = Arc::downgrade(&five);\n+    ///\n+    /// let strong_five: Option<Arc<_>> = weak_five.upgrade();\n+    /// assert!(strong_five.is_some());\n+    ///\n+    /// // Destroy all strong pointers.\n+    /// drop(strong_five);\n+    /// drop(five);\n+    ///\n+    /// assert!(weak_five.upgrade().is_none());\n+    /// ```\n+    #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n+    pub fn upgrade(&self) -> Option<Arc<T>> {\n+        // We use a CAS loop to increment the strong count instead of a\n+        // fetch_add because once the count hits 0 it must never be above 0.\n+        let inner = self.inner()?;\n+\n+        // Relaxed load because any write of 0 that we can observe\n+        // leaves the field in a permanently zero state (so a\n+        // \"stale\" read of 0 is fine), and any other value is\n+        // confirmed via the CAS below.\n+        let mut n = inner.strong.load(Relaxed);\n+\n+        loop {\n+            if n == 0 {\n+                return None;\n+            }\n+\n+            // See comments in `Arc::clone` for why we do this (for `mem::forget`).\n+            if n > MAX_REFCOUNT {\n+                unsafe {\n+                    abort();\n+                }\n+            }\n+\n+            // Relaxed is valid for the same reason it is on Arc's Clone impl\n+            match inner.strong.compare_exchange_weak(n, n + 1, Relaxed, Relaxed) {\n+                Ok(_) => return Some(Arc {\n+                    // null checked above\n+                    ptr: self.ptr,\n+                    phantom: PhantomData,\n+                }),\n+                Err(old) => n = old,\n+            }\n+        }\n+    }\n+\n+    /// Return `None` when the pointer is dangling and there is no allocated `ArcInner`,\n+    /// i.e. this `Weak` was created by `Weak::new`\n+    #[inline]\n+    fn inner(&self) -> Option<&ArcInner<T>> {\n+        if is_dangling(self.ptr) {\n+            None\n+        } else {\n+            Some(unsafe { self.ptr.as_ref() })\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n+impl<T: ?Sized> Clone for Weak<T> {\n+    /// Makes a clone of the `Weak` pointer that points to the same value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::{Arc, Weak};\n+    ///\n+    /// let weak_five = Arc::downgrade(&Arc::new(5));\n+    ///\n+    /// Weak::clone(&weak_five);\n+    /// ```\n+    #[inline]\n+    fn clone(&self) -> Weak<T> {\n+        let inner = if let Some(inner) = self.inner() {\n+            inner\n+        } else {\n+            return Weak { ptr: self.ptr };\n+        };\n+        // See comments in Arc::clone() for why this is relaxed.  This can use a\n+        // fetch_add (ignoring the lock) because the weak count is only locked\n+        // where are *no other* weak pointers in existence. (So we can't be\n+        // running this code in that case).\n+        let old_size = inner.weak.fetch_add(1, Relaxed);\n+\n+        // See comments in Arc::clone() for why we do this (for mem::forget).\n+        if old_size > MAX_REFCOUNT {\n+            unsafe {\n+                abort();\n+            }\n+        }\n+\n+        return Weak { ptr: self.ptr };\n+    }\n+}\n+\n+#[stable(feature = \"downgraded_weak\", since = \"1.10.0\")]\n+impl<T> Default for Weak<T> {\n+    /// Constructs a new `Weak<T>`, without allocating memory.\n+    /// Calling [`upgrade`] on the return value always gives [`None`].\n+    ///\n+    /// [`upgrade`]: struct.Weak.html#method.upgrade\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Weak;\n+    ///\n+    /// let empty: Weak<i64> = Default::default();\n+    /// assert!(empty.upgrade().is_none());\n+    /// ```\n+    fn default() -> Weak<T> {\n+        Weak::new()\n+    }\n+}\n+\n+#[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n+impl<T: ?Sized> Drop for Weak<T> {\n+    /// Drops the `Weak` pointer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::{Arc, Weak};\n+    ///\n+    /// struct Foo;\n+    ///\n+    /// impl Drop for Foo {\n+    ///     fn drop(&mut self) {\n+    ///         println!(\"dropped!\");\n+    ///     }\n+    /// }\n+    ///\n+    /// let foo = Arc::new(Foo);\n+    /// let weak_foo = Arc::downgrade(&foo);\n+    /// let other_weak_foo = Weak::clone(&weak_foo);\n+    ///\n+    /// drop(weak_foo);   // Doesn't print anything\n+    /// drop(foo);        // Prints \"dropped!\"\n+    ///\n+    /// assert!(other_weak_foo.upgrade().is_none());\n+    /// ```\n+    fn drop(&mut self) {\n+        // If we find out that we were the last weak pointer, then its time to\n+        // deallocate the data entirely. See the discussion in Arc::drop() about\n+        // the memory orderings\n+        //\n+        // It's not necessary to check for the locked state here, because the\n+        // weak count can only be locked if there was precisely one weak ref,\n+        // meaning that drop could only subsequently run ON that remaining weak\n+        // ref, which can only happen after the lock is released.\n+        let inner = if let Some(inner) = self.inner() {\n+            inner\n+        } else {\n+            return\n+        };\n+\n+        if inner.weak.fetch_sub(1, Release) == 1 {\n+            atomic::fence(Acquire);\n+            unsafe {\n+                Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()))\n+            }\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized + PartialEq> PartialEq for Arc<T> {\n+    /// Equality for two `Arc`s.\n+    ///\n+    /// Two `Arc`s are equal if their inner values are equal.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// assert!(five == Arc::new(5));\n+    /// ```\n+    fn eq(&self, other: &Arc<T>) -> bool {\n+        *(*self) == *(*other)\n+    }\n+\n+    /// Inequality for two `Arc`s.\n+    ///\n+    /// Two `Arc`s are unequal if their inner values are unequal.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// assert!(five != Arc::new(6));\n+    /// ```\n+    fn ne(&self, other: &Arc<T>) -> bool {\n+        *(*self) != *(*other)\n+    }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized + PartialOrd> PartialOrd for Arc<T> {\n+    /// Partial comparison for two `Arc`s.\n+    ///\n+    /// The two are compared by calling `partial_cmp()` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// assert_eq!(Some(Ordering::Less), five.partial_cmp(&Arc::new(6)));\n+    /// ```\n+    fn partial_cmp(&self, other: &Arc<T>) -> Option<Ordering> {\n+        (**self).partial_cmp(&**other)\n+    }\n+\n+    /// Less-than comparison for two `Arc`s.\n+    ///\n+    /// The two are compared by calling `<` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// assert!(five < Arc::new(6));\n+    /// ```\n+    fn lt(&self, other: &Arc<T>) -> bool {\n+        *(*self) < *(*other)\n+    }\n+\n+    /// 'Less than or equal to' comparison for two `Arc`s.\n+    ///\n+    /// The two are compared by calling `<=` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// assert!(five <= Arc::new(5));\n+    /// ```\n+    fn le(&self, other: &Arc<T>) -> bool {\n+        *(*self) <= *(*other)\n+    }\n+\n+    /// Greater-than comparison for two `Arc`s.\n+    ///\n+    /// The two are compared by calling `>` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// assert!(five > Arc::new(4));\n+    /// ```\n+    fn gt(&self, other: &Arc<T>) -> bool {\n+        *(*self) > *(*other)\n+    }\n+\n+    /// 'Greater than or equal to' comparison for two `Arc`s.\n+    ///\n+    /// The two are compared by calling `>=` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// assert!(five >= Arc::new(5));\n+    /// ```\n+    fn ge(&self, other: &Arc<T>) -> bool {\n+        *(*self) >= *(*other)\n+    }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized + Ord> Ord for Arc<T> {\n+    /// Comparison for two `Arc`s.\n+    ///\n+    /// The two are compared by calling `cmp()` on their inner values.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// let five = Arc::new(5);\n+    ///\n+    /// assert_eq!(Ordering::Less, five.cmp(&Arc::new(6)));\n+    /// ```\n+    fn cmp(&self, other: &Arc<T>) -> Ordering {\n+        (**self).cmp(&**other)\n+    }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized + Eq> Eq for Arc<T> {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized + fmt::Display> fmt::Display for Arc<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&**self, f)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized + fmt::Debug> fmt::Debug for Arc<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&**self, f)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> fmt::Pointer for Arc<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Pointer::fmt(&(&**self as *const T), f)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Default> Default for Arc<T> {\n+    /// Creates a new `Arc<T>`, with the `Default` value for `T`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Arc;\n+    ///\n+    /// let x: Arc<i32> = Default::default();\n+    /// assert_eq!(*x, 0);\n+    /// ```\n+    fn default() -> Arc<T> {\n+        Arc::new(Default::default())\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized + Hash> Hash for Arc<T> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        (**self).hash(state)\n+    }\n+}\n+\n+#[stable(feature = \"from_for_ptrs\", since = \"1.6.0\")]\n+impl<T> From<T> for Arc<T> {\n+    fn from(t: T) -> Self {\n+        Arc::new(t)\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<'a, T: Clone> From<&'a [T]> for Arc<[T]> {\n+    #[inline]\n+    fn from(v: &[T]) -> Arc<[T]> {\n+        <Self as ArcFromSlice<T>>::from_slice(v)\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<'a> From<&'a str> for Arc<str> {\n+    #[inline]\n+    fn from(v: &str) -> Arc<str> {\n+        let arc = Arc::<[u8]>::from(v.as_bytes());\n+        unsafe { Arc::from_raw(Arc::into_raw(arc) as *const str) }\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl From<String> for Arc<str> {\n+    #[inline]\n+    fn from(v: String) -> Arc<str> {\n+        Arc::from(&v[..])\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<T: ?Sized> From<Box<T>> for Arc<T> {\n+    #[inline]\n+    fn from(v: Box<T>) -> Arc<T> {\n+        Arc::from_box(v)\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<T> From<Vec<T>> for Arc<[T]> {\n+    #[inline]\n+    fn from(mut v: Vec<T>) -> Arc<[T]> {\n+        unsafe {\n+            let arc = Arc::copy_from_slice(&v);\n+\n+            // Allow the Vec to free its memory, but not destroy its contents\n+            v.set_len(0);\n+\n+            arc\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::boxed::Box;\n+    use std::clone::Clone;\n+    use std::sync::mpsc::channel;\n+    use std::mem::drop;\n+    use std::ops::Drop;\n+    use std::option::Option;\n+    use std::option::Option::{None, Some};\n+    use std::sync::atomic;\n+    use std::sync::atomic::Ordering::{Acquire, SeqCst};\n+    use std::thread;\n+    use std::sync::Mutex;\n+    use std::convert::From;\n+\n+    use super::{Arc, Weak};\n+    use vec::Vec;\n+\n+    struct Canary(*mut atomic::AtomicUsize);\n+\n+    impl Drop for Canary {\n+        fn drop(&mut self) {\n+            unsafe {\n+                match *self {\n+                    Canary(c) => {\n+                        (*c).fetch_add(1, SeqCst);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n+    fn manually_share_arc() {\n+        let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+        let arc_v = Arc::new(v);\n+\n+        let (tx, rx) = channel();\n+\n+        let _t = thread::spawn(move || {\n+            let arc_v: Arc<Vec<i32>> = rx.recv().unwrap();\n+            assert_eq!((*arc_v)[3], 4);\n+        });\n+\n+        tx.send(arc_v.clone()).unwrap();\n+\n+        assert_eq!((*arc_v)[2], 3);\n+        assert_eq!((*arc_v)[4], 5);\n+    }\n+\n+    #[test]\n+    fn test_arc_get_mut() {\n+        let mut x = Arc::new(3);\n+        *Arc::get_mut(&mut x).unwrap() = 4;\n+        assert_eq!(*x, 4);\n+        let y = x.clone();\n+        assert!(Arc::get_mut(&mut x).is_none());\n+        drop(y);\n+        assert!(Arc::get_mut(&mut x).is_some());\n+        let _w = Arc::downgrade(&x);\n+        assert!(Arc::get_mut(&mut x).is_none());\n+    }\n+\n+    #[test]\n+    fn try_unwrap() {\n+        let x = Arc::new(3);\n+        assert_eq!(Arc::try_unwrap(x), Ok(3));\n+        let x = Arc::new(4);\n+        let _y = x.clone();\n+        assert_eq!(Arc::try_unwrap(x), Err(Arc::new(4)));\n+        let x = Arc::new(5);\n+        let _w = Arc::downgrade(&x);\n+        assert_eq!(Arc::try_unwrap(x), Ok(5));\n+    }\n+\n+    #[test]\n+    fn into_from_raw() {\n+        let x = Arc::new(box \"hello\");\n+        let y = x.clone();\n+\n+        let x_ptr = Arc::into_raw(x);\n+        drop(y);\n+        unsafe {\n+            assert_eq!(**x_ptr, \"hello\");\n+\n+            let x = Arc::from_raw(x_ptr);\n+            assert_eq!(**x, \"hello\");\n+\n+            assert_eq!(Arc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n+        }\n+    }\n+\n+    #[test]\n+    fn test_into_from_raw_unsized() {\n+        use std::fmt::Display;\n+        use std::string::ToString;\n+\n+        let arc: Arc<str> = Arc::from(\"foo\");\n+\n+        let ptr = Arc::into_raw(arc.clone());\n+        let arc2 = unsafe { Arc::from_raw(ptr) };\n+\n+        assert_eq!(unsafe { &*ptr }, \"foo\");\n+        assert_eq!(arc, arc2);\n+\n+        let arc: Arc<dyn Display> = Arc::new(123);\n+\n+        let ptr = Arc::into_raw(arc.clone());\n+        let arc2 = unsafe { Arc::from_raw(ptr) };\n+\n+        assert_eq!(unsafe { &*ptr }.to_string(), \"123\");\n+        assert_eq!(arc2.to_string(), \"123\");\n+    }\n+\n+    #[test]\n+    fn test_cowarc_clone_make_mut() {\n+        let mut cow0 = Arc::new(75);\n+        let mut cow1 = cow0.clone();\n+        let mut cow2 = cow1.clone();\n+\n+        assert!(75 == *Arc::make_mut(&mut cow0));\n+        assert!(75 == *Arc::make_mut(&mut cow1));\n+        assert!(75 == *Arc::make_mut(&mut cow2));\n+\n+        *Arc::make_mut(&mut cow0) += 1;\n+        *Arc::make_mut(&mut cow1) += 2;\n+        *Arc::make_mut(&mut cow2) += 3;\n+\n+        assert!(76 == *cow0);\n+        assert!(77 == *cow1);\n+        assert!(78 == *cow2);\n+\n+        // none should point to the same backing memory\n+        assert!(*cow0 != *cow1);\n+        assert!(*cow0 != *cow2);\n+        assert!(*cow1 != *cow2);\n+    }\n+\n+    #[test]\n+    fn test_cowarc_clone_unique2() {\n+        let mut cow0 = Arc::new(75);\n+        let cow1 = cow0.clone();\n+        let cow2 = cow1.clone();\n+\n+        assert!(75 == *cow0);\n+        assert!(75 == *cow1);\n+        assert!(75 == *cow2);\n+\n+        *Arc::make_mut(&mut cow0) += 1;\n+        assert!(76 == *cow0);\n+        assert!(75 == *cow1);\n+        assert!(75 == *cow2);\n+\n+        // cow1 and cow2 should share the same contents\n+        // cow0 should have a unique reference\n+        assert!(*cow0 != *cow1);\n+        assert!(*cow0 != *cow2);\n+        assert!(*cow1 == *cow2);\n+    }\n+\n+    #[test]\n+    fn test_cowarc_clone_weak() {\n+        let mut cow0 = Arc::new(75);\n+        let cow1_weak = Arc::downgrade(&cow0);\n+\n+        assert!(75 == *cow0);\n+        assert!(75 == *cow1_weak.upgrade().unwrap());\n+\n+        *Arc::make_mut(&mut cow0) += 1;\n+\n+        assert!(76 == *cow0);\n+        assert!(cow1_weak.upgrade().is_none());\n+    }\n+\n+    #[test]\n+    fn test_live() {\n+        let x = Arc::new(5);\n+        let y = Arc::downgrade(&x);\n+        assert!(y.upgrade().is_some());\n+    }\n+\n+    #[test]\n+    fn test_dead() {\n+        let x = Arc::new(5);\n+        let y = Arc::downgrade(&x);\n+        drop(x);\n+        assert!(y.upgrade().is_none());\n+    }\n+\n+    #[test]\n+    fn weak_self_cyclic() {\n+        struct Cycle {\n+            x: Mutex<Option<Weak<Cycle>>>,\n+        }\n+\n+        let a = Arc::new(Cycle { x: Mutex::new(None) });\n+        let b = Arc::downgrade(&a.clone());\n+        *a.x.lock().unwrap() = Some(b);\n+\n+        // hopefully we don't double-free (or leak)...\n+    }\n+\n+    #[test]\n+    fn drop_arc() {\n+        let mut canary = atomic::AtomicUsize::new(0);\n+        let x = Arc::new(Canary(&mut canary as *mut atomic::AtomicUsize));\n+        drop(x);\n+        assert!(canary.load(Acquire) == 1);\n+    }\n+\n+    #[test]\n+    fn drop_arc_weak() {\n+        let mut canary = atomic::AtomicUsize::new(0);\n+        let arc = Arc::new(Canary(&mut canary as *mut atomic::AtomicUsize));\n+        let arc_weak = Arc::downgrade(&arc);\n+        assert!(canary.load(Acquire) == 0);\n+        drop(arc);\n+        assert!(canary.load(Acquire) == 1);\n+        drop(arc_weak);\n+    }\n+\n+    #[test]\n+    fn test_strong_count() {\n+        let a = Arc::new(0);\n+        assert!(Arc::strong_count(&a) == 1);\n+        let w = Arc::downgrade(&a);\n+        assert!(Arc::strong_count(&a) == 1);\n+        let b = w.upgrade().expect(\"\");\n+        assert!(Arc::strong_count(&b) == 2);\n+        assert!(Arc::strong_count(&a) == 2);\n+        drop(w);\n+        drop(a);\n+        assert!(Arc::strong_count(&b) == 1);\n+        let c = b.clone();\n+        assert!(Arc::strong_count(&b) == 2);\n+        assert!(Arc::strong_count(&c) == 2);\n+    }\n+\n+    #[test]\n+    fn test_weak_count() {\n+        let a = Arc::new(0);\n+        assert!(Arc::strong_count(&a) == 1);\n+        assert!(Arc::weak_count(&a) == 0);\n+        let w = Arc::downgrade(&a);\n+        assert!(Arc::strong_count(&a) == 1);\n+        assert!(Arc::weak_count(&a) == 1);\n+        let x = w.clone();\n+        assert!(Arc::weak_count(&a) == 2);\n+        drop(w);\n+        drop(x);\n+        assert!(Arc::strong_count(&a) == 1);\n+        assert!(Arc::weak_count(&a) == 0);\n+        let c = a.clone();\n+        assert!(Arc::strong_count(&a) == 2);\n+        assert!(Arc::weak_count(&a) == 0);\n+        let d = Arc::downgrade(&c);\n+        assert!(Arc::weak_count(&c) == 1);\n+        assert!(Arc::strong_count(&c) == 2);\n+\n+        drop(a);\n+        drop(c);\n+        drop(d);\n+    }\n+\n+    #[test]\n+    fn show_arc() {\n+        let a = Arc::new(5);\n+        assert_eq!(format!(\"{:?}\", a), \"5\");\n+    }\n+\n+    // Make sure deriving works with Arc<T>\n+    #[derive(Eq, Ord, PartialEq, PartialOrd, Clone, Debug, Default)]\n+    struct Foo {\n+        inner: Arc<i32>,\n+    }\n+\n+    #[test]\n+    fn test_unsized() {\n+        let x: Arc<[i32]> = Arc::new([1, 2, 3]);\n+        assert_eq!(format!(\"{:?}\", x), \"[1, 2, 3]\");\n+        let y = Arc::downgrade(&x.clone());\n+        drop(x);\n+        assert!(y.upgrade().is_none());\n+    }\n+\n+    #[test]\n+    fn test_from_owned() {\n+        let foo = 123;\n+        let foo_arc = Arc::from(foo);\n+        assert!(123 == *foo_arc);\n+    }\n+\n+    #[test]\n+    fn test_new_weak() {\n+        let foo: Weak<usize> = Weak::new();\n+        assert!(foo.upgrade().is_none());\n+    }\n+\n+    #[test]\n+    fn test_ptr_eq() {\n+        let five = Arc::new(5);\n+        let same_five = five.clone();\n+        let other_five = Arc::new(5);\n+\n+        assert!(Arc::ptr_eq(&five, &same_five));\n+        assert!(!Arc::ptr_eq(&five, &other_five));\n+    }\n+\n+    #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n+    fn test_weak_count_locked() {\n+        let mut a = Arc::new(atomic::AtomicBool::new(false));\n+        let a2 = a.clone();\n+        let t = thread::spawn(move || {\n+            for _i in 0..1000000 {\n+                Arc::get_mut(&mut a);\n+            }\n+            a.store(true, SeqCst);\n+        });\n+\n+        while !a2.load(SeqCst) {\n+            let n = Arc::weak_count(&a2);\n+            assert!(n < 2, \"bad weak count: {}\", n);\n+        }\n+        t.join().unwrap();\n+    }\n+\n+    #[test]\n+    fn test_from_str() {\n+        let r: Arc<str> = Arc::from(\"foo\");\n+\n+        assert_eq!(&r[..], \"foo\");\n+    }\n+\n+    #[test]\n+    fn test_copy_from_slice() {\n+        let s: &[u32] = &[1, 2, 3];\n+        let r: Arc<[u32]> = Arc::from(s);\n+\n+        assert_eq!(&r[..], [1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_clone_from_slice() {\n+        #[derive(Clone, Debug, Eq, PartialEq)]\n+        struct X(u32);\n+\n+        let s: &[X] = &[X(1), X(2), X(3)];\n+        let r: Arc<[X]> = Arc::from(s);\n+\n+        assert_eq!(&r[..], s);\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn test_clone_from_slice_panic() {\n+        use std::string::{String, ToString};\n+\n+        struct Fail(u32, String);\n+\n+        impl Clone for Fail {\n+            fn clone(&self) -> Fail {\n+                if self.0 == 2 {\n+                    panic!();\n+                }\n+                Fail(self.0, self.1.clone())\n+            }\n+        }\n+\n+        let s: &[Fail] = &[\n+            Fail(0, \"foo\".to_string()),\n+            Fail(1, \"bar\".to_string()),\n+            Fail(2, \"baz\".to_string()),\n+        ];\n+\n+        // Should panic, but not cause memory corruption\n+        let _r: Arc<[Fail]> = Arc::from(s);\n+    }\n+\n+    #[test]\n+    fn test_from_box() {\n+        let b: Box<u32> = box 123;\n+        let r: Arc<u32> = Arc::from(b);\n+\n+        assert_eq!(*r, 123);\n+    }\n+\n+    #[test]\n+    fn test_from_box_str() {\n+        use std::string::String;\n+\n+        let s = String::from(\"foo\").into_boxed_str();\n+        let r: Arc<str> = Arc::from(s);\n+\n+        assert_eq!(&r[..], \"foo\");\n+    }\n+\n+    #[test]\n+    fn test_from_box_slice() {\n+        let s = vec![1, 2, 3].into_boxed_slice();\n+        let r: Arc<[u32]> = Arc::from(s);\n+\n+        assert_eq!(&r[..], [1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_from_box_trait() {\n+        use std::fmt::Display;\n+        use std::string::ToString;\n+\n+        let b: Box<dyn Display> = box 123;\n+        let r: Arc<dyn Display> = Arc::from(b);\n+\n+        assert_eq!(r.to_string(), \"123\");\n+    }\n+\n+    #[test]\n+    fn test_from_box_trait_zero_sized() {\n+        use std::fmt::Debug;\n+\n+        let b: Box<dyn Debug> = box ();\n+        let r: Arc<dyn Debug> = Arc::from(b);\n+\n+        assert_eq!(format!(\"{:?}\", r), \"()\");\n+    }\n+\n+    #[test]\n+    fn test_from_vec() {\n+        let v = vec![1, 2, 3];\n+        let r: Arc<[u32]> = Arc::from(v);\n+\n+        assert_eq!(&r[..], [1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_downcast() {\n+        use std::any::Any;\n+\n+        let r1: Arc<dyn Any + Send + Sync> = Arc::new(i32::max_value());\n+        let r2: Arc<dyn Any + Send + Sync> = Arc::new(\"abc\");\n+\n+        assert!(r1.clone().downcast::<u32>().is_err());\n+\n+        let r1i32 = r1.downcast::<i32>();\n+        assert!(r1i32.is_ok());\n+        assert_eq!(r1i32.unwrap(), Arc::new(i32::max_value()));\n+\n+        assert!(r2.clone().downcast::<i32>().is_err());\n+\n+        let r2str = r2.downcast::<&'static str>();\n+        assert!(r2str.is_ok());\n+        assert_eq!(r2str.unwrap(), Arc::new(\"abc\"));\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> borrow::Borrow<T> for Arc<T> {\n+    fn borrow(&self) -> &T {\n+        &**self\n+    }\n+}\n+\n+#[stable(since = \"1.5.0\", feature = \"smart_ptr_as_ref\")]\n+impl<T: ?Sized> AsRef<T> for Arc<T> {\n+    fn as_ref(&self) -> &T {\n+        &**self\n+    }\n+}"}, {"sha": "9792d52dd66d26c658bc5e3fbcb380f0f5022081", "filename": "src/liballoc/task.rs", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftask.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -0,0 +1,149 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Types and Traits for working with asynchronous tasks.\n+\n+pub use core::task::*;\n+\n+#[cfg(any(\n+    all(stage0, target_has_atomic = \"ptr\"),\n+    all(not(stage0), target_has_atomic = \"ptr\", target_has_atomic = \"cas\")\n+))]\n+pub use self::if_arc::*;\n+\n+#[cfg(any(\n+    all(stage0, target_has_atomic = \"ptr\"),\n+    all(not(stage0), target_has_atomic = \"ptr\", target_has_atomic = \"cas\")\n+))]\n+mod if_arc {\n+    use super::*;\n+    use core::marker::PhantomData;\n+    use core::mem;\n+    use core::ptr::{self, NonNull};\n+    use sync::Arc;\n+\n+    /// A way of waking up a specific task.\n+    ///\n+    /// Any task executor must provide a way of signaling that a task it owns\n+    /// is ready to be `poll`ed again. Executors do so by implementing this trait.\n+    pub trait Wake: Send + Sync {\n+        /// Indicates that the associated task is ready to make progress and should\n+        /// be `poll`ed.\n+        ///\n+        /// Executors generally maintain a queue of \"ready\" tasks; `wake` should place\n+        /// the associated task onto this queue.\n+        fn wake(arc_self: &Arc<Self>);\n+\n+        /// Indicates that the associated task is ready to make progress and should\n+        /// be `poll`ed. This function is like `wake`, but can only be called from the\n+        /// thread on which this `Wake` was created.\n+        ///\n+        /// Executors generally maintain a queue of \"ready\" tasks; `wake_local` should place\n+        /// the associated task onto this queue.\n+        #[inline]\n+        unsafe fn wake_local(arc_self: &Arc<Self>) {\n+            Self::wake(arc_self);\n+        }\n+    }\n+\n+    #[cfg(any(\n+        all(stage0, target_has_atomic = \"ptr\"),\n+        all(not(stage0), target_has_atomic = \"ptr\", target_has_atomic = \"cas\")\n+    ))]\n+    struct ArcWrapped<T>(PhantomData<T>);\n+\n+    unsafe impl<T: Wake + 'static> UnsafeWake for ArcWrapped<T> {\n+        #[inline]\n+        unsafe fn clone_raw(&self) -> Waker {\n+            let me: *const ArcWrapped<T> = self;\n+            let arc = (*(&me as *const *const ArcWrapped<T> as *const Arc<T>)).clone();\n+            Waker::from(arc)\n+        }\n+\n+        #[inline]\n+        unsafe fn drop_raw(&self) {\n+            let mut me: *const ArcWrapped<T> = self;\n+            let me = &mut me as *mut *const ArcWrapped<T> as *mut Arc<T>;\n+            ptr::drop_in_place(me);\n+        }\n+\n+        #[inline]\n+        unsafe fn wake(&self) {\n+            let me: *const ArcWrapped<T> = self;\n+            T::wake(&*(&me as *const *const ArcWrapped<T> as *const Arc<T>))\n+        }\n+\n+        #[inline]\n+        unsafe fn wake_local(&self) {\n+            let me: *const ArcWrapped<T> = self;\n+            T::wake_local(&*(&me as *const *const ArcWrapped<T> as *const Arc<T>))\n+        }\n+    }\n+\n+    impl<T> From<Arc<T>> for Waker\n+        where T: Wake + 'static,\n+    {\n+        fn from(rc: Arc<T>) -> Self {\n+            unsafe {\n+                let ptr = mem::transmute::<Arc<T>, NonNull<ArcWrapped<T>>>(rc);\n+                Waker::new(ptr)\n+            }\n+        }\n+    }\n+\n+    /// Creates a `LocalWaker` from a local `wake`.\n+    ///\n+    /// This function requires that `wake` is \"local\" (created on the current thread).\n+    /// The resulting `LocalWaker` will call `wake.wake_local()` when awoken, and\n+    /// will call `wake.wake()` if awoken after being converted to a `Waker`.\n+    #[inline]\n+    pub unsafe fn local_waker<W: Wake + 'static>(wake: Arc<W>) -> LocalWaker {\n+        let ptr = mem::transmute::<Arc<W>, NonNull<ArcWrapped<W>>>(wake);\n+        LocalWaker::new(ptr)\n+    }\n+\n+    struct NonLocalAsLocal<T>(ArcWrapped<T>);\n+\n+    unsafe impl<T: Wake + 'static> UnsafeWake for NonLocalAsLocal<T> {\n+        #[inline]\n+        unsafe fn clone_raw(&self) -> Waker {\n+            self.0.clone_raw()\n+        }\n+\n+        #[inline]\n+        unsafe fn drop_raw(&self) {\n+            self.0.drop_raw()\n+        }\n+\n+        #[inline]\n+        unsafe fn wake(&self) {\n+            self.0.wake()\n+        }\n+\n+        #[inline]\n+        unsafe fn wake_local(&self) {\n+            // Since we're nonlocal, we can't call wake_local\n+            self.0.wake()\n+        }\n+    }\n+\n+    /// Creates a `LocalWaker` from a non-local `wake`.\n+    ///\n+    /// This function is similar to `local_waker`, but does not require that `wake`\n+    /// is local to the current thread. The resulting `LocalWaker` will call\n+    /// `wake.wake()` when awoken.\n+    #[inline]\n+    pub fn local_waker_from_nonlocal<W: Wake + 'static>(wake: Arc<W>) -> LocalWaker {\n+        unsafe {\n+            let ptr = mem::transmute::<Arc<W>, NonNull<NonLocalAsLocal<W>>>(wake);\n+            LocalWaker::new(ptr)\n+        }\n+    }\n+}"}, {"sha": "d90c22a3b18924496c9967a8e699ac6bc69684fc", "filename": "src/liballoc/tests/arc.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Ftests%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Ftests%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Farc.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::any::Any;\n+use std::sync::{Arc, Weak};\n+\n+#[test]\n+fn uninhabited() {\n+    enum Void {}\n+    let mut a = Weak::<Void>::new();\n+    a = a.clone();\n+    assert!(a.upgrade().is_none());\n+\n+    let mut a: Weak<dyn Any> = a;  // Unsizing\n+    a = a.clone();\n+    assert!(a.upgrade().is_none());\n+}\n+\n+#[test]\n+fn slice() {\n+    let a: Arc<[u32; 3]> = Arc::new([3, 2, 1]);\n+    let a: Arc<[u32]> = a;  // Unsizing\n+    let b: Arc<[u32]> = Arc::from(&[3, 2, 1][..]);  // Conversion\n+    assert_eq!(a, b);\n+\n+    // Exercise is_dangling() with a DST\n+    let mut a = Arc::downgrade(&a);\n+    a = a.clone();\n+    assert!(a.upgrade().is_some());\n+}\n+\n+#[test]\n+fn trait_object() {\n+    let a: Arc<u32> = Arc::new(4);\n+    let a: Arc<dyn Any> = a;  // Unsizing\n+\n+    // Exercise is_dangling() with a DST\n+    let mut a = Arc::downgrade(&a);\n+    a = a.clone();\n+    assert!(a.upgrade().is_some());\n+\n+    let mut b = Weak::<u32>::new();\n+    b = b.clone();\n+    assert!(b.upgrade().is_none());\n+    let mut b: Weak<dyn Any> = b;  // Unsizing\n+    b = b.clone();\n+    assert!(b.upgrade().is_none());\n+}"}, {"sha": "0330bda5e3238527c16071d92ebe585888e80311", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -40,7 +40,7 @@ fn test_hash() {\n }\n \n fn check<F>(a: &[i32], b: &[i32], expected: &[i32], f: F)\n-    where F: FnOnce(&BTreeSet<i32>, &BTreeSet<i32>, &mut FnMut(&i32) -> bool) -> bool\n+    where F: FnOnce(&BTreeSet<i32>, &BTreeSet<i32>, &mut dyn FnMut(&i32) -> bool) -> bool\n {\n     let mut set_a = BTreeSet::new();\n     let mut set_b = BTreeSet::new();"}, {"sha": "618aff963f22dd59bc8d549bd4fc585ecd4d8847", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -15,7 +15,6 @@\n #![feature(const_fn)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n-#![feature(iterator_step_by)]\n #![feature(pattern)]\n #![feature(rand)]\n #![feature(slice_sort_by_cached_key)]\n@@ -25,7 +24,7 @@\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(exact_chunks)]\n-#![feature(inclusive_range_methods)]\n+#![feature(repeat_generic_slice)]\n \n extern crate alloc_system;\n extern crate core;\n@@ -34,12 +33,14 @@ extern crate rand;\n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;\n \n+mod arc;\n mod binary_heap;\n mod btree;\n mod cow_str;\n mod fmt;\n mod heap;\n mod linked_list;\n+mod rc;\n mod slice;\n mod str;\n mod string;\n@@ -63,7 +64,7 @@ fn test_boxed_hasher() {\n     5u32.hash(&mut hasher_1);\n     assert_eq!(ordinary_hash, hasher_1.finish());\n \n-    let mut hasher_2 = Box::new(DefaultHasher::new()) as Box<Hasher>;\n+    let mut hasher_2 = Box::new(DefaultHasher::new()) as Box<dyn Hasher>;\n     5u32.hash(&mut hasher_2);\n     assert_eq!(ordinary_hash, hasher_2.finish());\n }"}, {"sha": "9ec7c831444d18d02881e2b11a103da0332cc930", "filename": "src/liballoc/tests/rc.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Ftests%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Ftests%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Frc.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::any::Any;\n+use std::rc::{Rc, Weak};\n+\n+#[test]\n+fn uninhabited() {\n+    enum Void {}\n+    let mut a = Weak::<Void>::new();\n+    a = a.clone();\n+    assert!(a.upgrade().is_none());\n+\n+    let mut a: Weak<dyn Any> = a;  // Unsizing\n+    a = a.clone();\n+    assert!(a.upgrade().is_none());\n+}\n+\n+#[test]\n+fn slice() {\n+    let a: Rc<[u32; 3]> = Rc::new([3, 2, 1]);\n+    let a: Rc<[u32]> = a;  // Unsizing\n+    let b: Rc<[u32]> = Rc::from(&[3, 2, 1][..]);  // Conversion\n+    assert_eq!(a, b);\n+\n+    // Exercise is_dangling() with a DST\n+    let mut a = Rc::downgrade(&a);\n+    a = a.clone();\n+    assert!(a.upgrade().is_some());\n+}\n+\n+#[test]\n+fn trait_object() {\n+    let a: Rc<u32> = Rc::new(4);\n+    let a: Rc<dyn Any> = a;  // Unsizing\n+\n+    // Exercise is_dangling() with a DST\n+    let mut a = Rc::downgrade(&a);\n+    a = a.clone();\n+    assert!(a.upgrade().is_some());\n+\n+    let mut b = Weak::<u32>::new();\n+    b = b.clone();\n+    assert!(b.upgrade().is_none());\n+    let mut b: Weak<dyn Any> = b;  // Unsizing\n+    b = b.clone();\n+    assert!(b.upgrade().is_none());\n+}"}, {"sha": "df5e18a9a184ecc60a9afa90c19cf4a508109d28", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -609,6 +609,15 @@ fn test_join() {\n     assert_eq!(v.join(&0), [1, 0, 2, 0, 3]);\n }\n \n+#[test]\n+fn test_join_nocopy() {\n+    let v: [String; 0] = [];\n+    assert_eq!(v.join(\",\"), \"\");\n+    assert_eq!([\"a\".to_string(), \"ab\".into()].join(\",\"), \"a,ab\");\n+    assert_eq!([\"a\".to_string(), \"ab\".into(), \"abc\".into()].join(\",\"), \"a,ab,abc\");\n+    assert_eq!([\"a\".to_string(), \"ab\".into(), \"\".into()].join(\",\"), \"a,ab,\");\n+}\n+\n #[test]\n fn test_insert() {\n     let mut a = vec![1, 2, 4];\n@@ -1520,3 +1529,14 @@ fn panic_safe() {\n         }\n     }\n }\n+\n+#[test]\n+fn repeat_generic_slice() {\n+    assert_eq!([1, 2].repeat(2), vec![1, 2, 1, 2]);\n+    assert_eq!([1, 2, 3, 4].repeat(0), vec![]);\n+    assert_eq!([1, 2, 3, 4].repeat(1), vec![1, 2, 3, 4]);\n+    assert_eq!(\n+        [1, 2, 3, 4].repeat(3),\n+        vec![1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]\n+    );\n+}"}, {"sha": "6275c7bb112063dc2205fc75698a7d6f7b8d3ba1", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 381, "deletions": 138, "changes": 519, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -162,11 +162,24 @@ fn test_join_for_different_lengths() {\n     test_join!(\"-a-bc\", [\"\", \"a\", \"bc\"], \"-\");\n }\n \n+// join has fast paths for small separators up to 4 bytes\n+// this tests the slow paths.\n+#[test]\n+fn test_join_for_different_lengths_with_long_separator() {\n+    assert_eq!(\"\uff5e\uff5e\uff5e\uff5e\uff5e\".len(), 15);\n+\n+    let empty: &[&str] = &[];\n+    test_join!(\"\", empty, \"\uff5e\uff5e\uff5e\uff5e\uff5e\");\n+    test_join!(\"a\", [\"a\"], \"\uff5e\uff5e\uff5e\uff5e\uff5e\");\n+    test_join!(\"a\uff5e\uff5e\uff5e\uff5e\uff5eb\", [\"a\", \"b\"], \"\uff5e\uff5e\uff5e\uff5e\uff5e\");\n+    test_join!(\"\uff5e\uff5e\uff5e\uff5e\uff5ea\uff5e\uff5e\uff5e\uff5e\uff5ebc\", [\"\", \"a\", \"bc\"], \"\uff5e\uff5e\uff5e\uff5e\uff5e\");\n+}\n+\n #[test]\n fn test_unsafe_slice() {\n-    assert_eq!(\"ab\", unsafe {\"abc\".slice_unchecked(0, 2)});\n-    assert_eq!(\"bc\", unsafe {\"abc\".slice_unchecked(1, 3)});\n-    assert_eq!(\"\", unsafe {\"abc\".slice_unchecked(1, 1)});\n+    assert_eq!(\"ab\", unsafe {\"abc\".get_unchecked(0..2)});\n+    assert_eq!(\"bc\", unsafe {\"abc\".get_unchecked(1..3)});\n+    assert_eq!(\"\", unsafe {\"abc\".get_unchecked(1..1)});\n     fn a_million_letter_a() -> String {\n         let mut i = 0;\n         let mut rs = String::new();\n@@ -187,7 +200,7 @@ fn test_unsafe_slice() {\n     }\n     let letters = a_million_letter_a();\n     assert_eq!(half_a_million_letter_a(),\n-        unsafe { letters.slice_unchecked(0, 500000)});\n+        unsafe { letters.get_unchecked(0..500000)});\n }\n \n #[test]\n@@ -291,113 +304,379 @@ fn test_replace_pattern() {\n     assert_eq!(data.replace(|c| c == '\u03b3', \"\ud83d\ude3a\ud83d\ude3a\ud83d\ude3a\"), \"abcd\u03b1\u03b2\ud83d\ude3a\ud83d\ude3a\ud83d\ude3a\u03b4abcd\u03b1\u03b2\ud83d\ude3a\ud83d\ude3a\ud83d\ude3a\u03b4\");\n }\n \n-#[test]\n-fn test_slice() {\n-    assert_eq!(\"ab\", &\"abc\"[0..2]);\n-    assert_eq!(\"bc\", &\"abc\"[1..3]);\n-    assert_eq!(\"\", &\"abc\"[1..1]);\n-    assert_eq!(\"\\u{65e5}\", &\"\\u{65e5}\\u{672c}\"[0..3]);\n+// The current implementation of SliceIndex fails to handle methods\n+// orthogonally from range types; therefore, it is worth testing\n+// all of the indexing operations on each input.\n+mod slice_index {\n+    // Test a slicing operation **that should succeed,**\n+    // testing it on all of the indexing methods.\n+    //\n+    // This is not suitable for testing failure on invalid inputs.\n+    macro_rules! assert_range_eq {\n+        ($s:expr, $range:expr, $expected:expr)\n+        => {\n+            let mut s: String = $s.to_owned();\n+            let mut expected: String = $expected.to_owned();\n+            {\n+                let s: &str = &s;\n+                let expected: &str = &expected;\n+\n+                assert_eq!(&s[$range], expected, \"(in assertion for: index)\");\n+                assert_eq!(s.get($range), Some(expected), \"(in assertion for: get)\");\n+                unsafe {\n+                    assert_eq!(\n+                        s.get_unchecked($range), expected,\n+                        \"(in assertion for: get_unchecked)\",\n+                    );\n+                }\n+            }\n+            {\n+                let s: &mut str = &mut s;\n+                let expected: &mut str = &mut expected;\n+\n+                assert_eq!(\n+                    &mut s[$range], expected,\n+                    \"(in assertion for: index_mut)\",\n+                );\n+                assert_eq!(\n+                    s.get_mut($range), Some(&mut expected[..]),\n+                    \"(in assertion for: get_mut)\",\n+                );\n+                unsafe {\n+                    assert_eq!(\n+                        s.get_unchecked_mut($range), expected,\n+                        \"(in assertion for: get_unchecked_mut)\",\n+                    );\n+                }\n+            }\n+        }\n+    }\n \n-    let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-    assert_eq!(\"\u0e1b\", &data[0..3]);\n-    assert_eq!(\"\u0e23\", &data[3..6]);\n-    assert_eq!(\"\", &data[3..3]);\n-    assert_eq!(\"\u534e\", &data[30..33]);\n+    // Make sure the macro can actually detect bugs,\n+    // because if it can't, then what are we even doing here?\n+    //\n+    // (Be aware this only demonstrates the ability to detect bugs\n+    //  in the FIRST method that panics, as the macro is not designed\n+    //  to be used in `should_panic`)\n+    #[test]\n+    #[should_panic(expected = \"out of bounds\")]\n+    fn assert_range_eq_can_fail_by_panic() {\n+        assert_range_eq!(\"abc\", 0..5, \"abc\");\n+    }\n \n-    fn a_million_letter_x() -> String {\n-        let mut i = 0;\n-        let mut rs = String::new();\n-        while i < 100000 {\n-            rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\");\n-            i += 1;\n+    // (Be aware this only demonstrates the ability to detect bugs\n+    //  in the FIRST method it calls, as the macro is not designed\n+    //  to be used in `should_panic`)\n+    #[test]\n+    #[should_panic(expected = \"==\")]\n+    fn assert_range_eq_can_fail_by_inequality() {\n+        assert_range_eq!(\"abc\", 0..2, \"abc\");\n+    }\n+\n+    // Generates test cases for bad index operations.\n+    //\n+    // This generates `should_panic` test cases for Index/IndexMut\n+    // and `None` test cases for get/get_mut.\n+    macro_rules! panic_cases {\n+        ($(\n+            in mod $case_name:ident {\n+                data: $data:expr;\n+\n+                // optional:\n+                //\n+                // a similar input for which DATA[input] succeeds, and the corresponding\n+                // output str. This helps validate \"critical points\" where an input range\n+                // straddles the boundary between valid and invalid.\n+                // (such as the input `len..len`, which is just barely valid)\n+                $(\n+                    good: data[$good:expr] == $output:expr;\n+                )*\n+\n+                bad: data[$bad:expr];\n+                message: $expect_msg:expr; // must be a literal\n+            }\n+        )*) => {$(\n+            mod $case_name {\n+                #[test]\n+                fn pass() {\n+                    let mut v: String = $data.into();\n+\n+                    $( assert_range_eq!(v, $good, $output); )*\n+\n+                    {\n+                        let v: &str = &v;\n+                        assert_eq!(v.get($bad), None, \"(in None assertion for get)\");\n+                    }\n+\n+                    {\n+                        let v: &mut str = &mut v;\n+                        assert_eq!(v.get_mut($bad), None, \"(in None assertion for get_mut)\");\n+                    }\n+                }\n+\n+                #[test]\n+                #[should_panic(expected = $expect_msg)]\n+                fn index_fail() {\n+                    let v: String = $data.into();\n+                    let v: &str = &v;\n+                    let _v = &v[$bad];\n+                }\n+\n+                #[test]\n+                #[should_panic(expected = $expect_msg)]\n+                fn index_mut_fail() {\n+                    let mut v: String = $data.into();\n+                    let v: &mut str = &mut v;\n+                    let _v = &mut v[$bad];\n+                }\n+            }\n+        )*};\n+    }\n+\n+    #[test]\n+    fn simple_ascii() {\n+        assert_range_eq!(\"abc\", .., \"abc\");\n+\n+        assert_range_eq!(\"abc\", 0..2, \"ab\");\n+        assert_range_eq!(\"abc\", 0..=1, \"ab\");\n+        assert_range_eq!(\"abc\", ..2, \"ab\");\n+        assert_range_eq!(\"abc\", ..=1, \"ab\");\n+\n+        assert_range_eq!(\"abc\", 1..3, \"bc\");\n+        assert_range_eq!(\"abc\", 1..=2, \"bc\");\n+        assert_range_eq!(\"abc\", 1..1, \"\");\n+        assert_range_eq!(\"abc\", 1..=0, \"\");\n+    }\n+\n+    #[test]\n+    fn simple_unicode() {\n+        // \u65e5\u672c\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", .., \"\\u{65e5}\\u{672c}\");\n+\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", 0..3, \"\\u{65e5}\");\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", 0..=2, \"\\u{65e5}\");\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", ..3, \"\\u{65e5}\");\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", ..=2, \"\\u{65e5}\");\n+\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", 3..6, \"\\u{672c}\");\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", 3..=5, \"\\u{672c}\");\n+        assert_range_eq!(\"\\u{65e5}\\u{672c}\", 3.., \"\\u{672c}\");\n+\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        assert_range_eq!(data, 0..3, \"\u0e1b\");\n+        assert_range_eq!(data, 3..6, \"\u0e23\");\n+        assert_range_eq!(data, 3..3, \"\");\n+        assert_range_eq!(data, 30..33, \"\u534e\");\n+\n+        /*0: \u4e2d\n+          3: \u534e\n+          6: V\n+          7: i\n+          8: \u1ec7\n+         11: t\n+         12:\n+         13: N\n+         14: a\n+         15: m */\n+        let ss = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+        assert_range_eq!(ss, 3..6, \"\u534e\");\n+        assert_range_eq!(ss, 6..16, \"Vi\u1ec7t Nam\");\n+        assert_range_eq!(ss, 6..=15, \"Vi\u1ec7t Nam\");\n+        assert_range_eq!(ss, 6.., \"Vi\u1ec7t Nam\");\n+\n+        assert_range_eq!(ss, 0..3, \"\u4e2d\");\n+        assert_range_eq!(ss, 3..7, \"\u534eV\");\n+        assert_range_eq!(ss, 3..=6, \"\u534eV\");\n+        assert_range_eq!(ss, 3..3, \"\");\n+        assert_range_eq!(ss, 3..=2, \"\");\n+    }\n+\n+    #[test]\n+    #[cfg(not(target_arch = \"asmjs\"))] // hits an OOM\n+    fn simple_big() {\n+        fn a_million_letter_x() -> String {\n+            let mut i = 0;\n+            let mut rs = String::new();\n+            while i < 100000 {\n+                rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\");\n+                i += 1;\n+            }\n+            rs\n         }\n-        rs\n+        fn half_a_million_letter_x() -> String {\n+            let mut i = 0;\n+            let mut rs = String::new();\n+            while i < 100000 {\n+                rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\");\n+                i += 1;\n+            }\n+            rs\n+        }\n+        let letters = a_million_letter_x();\n+        assert_range_eq!(letters, 0..3 * 500000, half_a_million_letter_x());\n     }\n-    fn half_a_million_letter_x() -> String {\n-        let mut i = 0;\n-        let mut rs = String::new();\n-        while i < 100000 {\n-            rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\");\n-            i += 1;\n+\n+    #[test]\n+    #[should_panic]\n+    fn test_slice_fail() {\n+        &\"\u4e2d\u534eVi\u1ec7t Nam\"[0..2];\n+    }\n+\n+    panic_cases! {\n+        in mod rangefrom_len {\n+            data: \"abcdef\";\n+            good: data[6..] == \"\";\n+            bad: data[7..];\n+            message: \"out of bounds\";\n+        }\n+\n+        in mod rangeto_len {\n+            data: \"abcdef\";\n+            good: data[..6] == \"abcdef\";\n+            bad: data[..7];\n+            message: \"out of bounds\";\n+        }\n+\n+        in mod rangetoinclusive_len {\n+            data: \"abcdef\";\n+            good: data[..=5] == \"abcdef\";\n+            bad: data[..=6];\n+            message: \"out of bounds\";\n+        }\n+\n+        in mod range_len_len {\n+            data: \"abcdef\";\n+            good: data[6..6] == \"\";\n+            bad: data[7..7];\n+            message: \"out of bounds\";\n+        }\n+\n+        in mod rangeinclusive_len_len {\n+            data: \"abcdef\";\n+            good: data[6..=5] == \"\";\n+            bad: data[7..=6];\n+            message: \"out of bounds\";\n         }\n-        rs\n     }\n-    let letters = a_million_letter_x();\n-    assert_eq!(half_a_million_letter_x(), &letters[0..3 * 500000]);\n-}\n \n-#[test]\n-fn test_slice_2() {\n-    let ss = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+    panic_cases! {\n+        in mod range_neg_width {\n+            data: \"abcdef\";\n+            good: data[4..4] == \"\";\n+            bad: data[4..3];\n+            message: \"begin <= end (4 <= 3)\";\n+        }\n \n-    assert_eq!(\"\u534e\", &ss[3..6]);\n-    assert_eq!(\"Vi\u1ec7t Nam\", &ss[6..16]);\n+        in mod rangeinclusive_neg_width {\n+            data: \"abcdef\";\n+            good: data[4..=3] == \"\";\n+            bad: data[4..=2];\n+            message: \"begin <= end (4 <= 3)\";\n+        }\n+    }\n \n-    assert_eq!(\"ab\", &\"abc\"[0..2]);\n-    assert_eq!(\"bc\", &\"abc\"[1..3]);\n-    assert_eq!(\"\", &\"abc\"[1..1]);\n+    mod overflow {\n+        panic_cases! {\n+            in mod rangeinclusive {\n+                data: \"hello\";\n+                // note: using 0 specifically ensures that the result of overflowing is 0..0,\n+                //       so that `get` doesn't simply return None for the wrong reason.\n+                bad: data[0..=usize::max_value()];\n+                message: \"maximum usize\";\n+            }\n \n-    assert_eq!(\"\u4e2d\", &ss[0..3]);\n-    assert_eq!(\"\u534eV\", &ss[3..7]);\n-    assert_eq!(\"\", &ss[3..3]);\n-    /*0: \u4e2d\n-      3: \u534e\n-      6: V\n-      7: i\n-      8: \u1ec7\n-     11: t\n-     12:\n-     13: N\n-     14: a\n-     15: m */\n-}\n+            in mod rangetoinclusive {\n+                data: \"hello\";\n+                bad: data[..=usize::max_value()];\n+                message: \"maximum usize\";\n+            }\n+        }\n+    }\n \n-#[test]\n-#[should_panic]\n-fn test_slice_fail() {\n-    &\"\u4e2d\u534eVi\u1ec7t Nam\"[0..2];\n-}\n+    mod boundary {\n+        const DATA: &'static str = \"abc\u03b1\u03b2\u03b3\";\n+\n+        const BAD_START: usize = 4;\n+        const GOOD_START: usize = 3;\n+        const BAD_END: usize = 6;\n+        const GOOD_END: usize = 7;\n+        const BAD_END_INCL: usize = BAD_END - 1;\n+        const GOOD_END_INCL: usize = GOOD_END - 1;\n+\n+        // it is especially important to test all of the different range types here\n+        // because some of the logic may be duplicated as part of micro-optimizations\n+        // to dodge unicode boundary checks on half-ranges.\n+        panic_cases! {\n+            in mod range_1 {\n+                data: super::DATA;\n+                bad: data[super::BAD_START..super::GOOD_END];\n+                message:\n+                    \"byte index 4 is not a char boundary; it is inside '\u03b1' (bytes 3..5) of\";\n+            }\n \n-#[test]\n-#[should_panic]\n-fn test_str_slice_rangetoinclusive_max_panics() {\n-    &\"hello\"[..=usize::max_value()];\n-}\n+            in mod range_2 {\n+                data: super::DATA;\n+                bad: data[super::GOOD_START..super::BAD_END];\n+                message:\n+                    \"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\";\n+            }\n \n-#[test]\n-#[should_panic]\n-fn test_str_slice_rangeinclusive_max_panics() {\n-    &\"hello\"[1..=usize::max_value()];\n-}\n+            in mod rangefrom {\n+                data: super::DATA;\n+                bad: data[super::BAD_START..];\n+                message:\n+                    \"byte index 4 is not a char boundary; it is inside '\u03b1' (bytes 3..5) of\";\n+            }\n \n-#[test]\n-#[should_panic]\n-fn test_str_slicemut_rangetoinclusive_max_panics() {\n-    let mut s = \"hello\".to_owned();\n-    let s: &mut str = &mut s;\n-    &mut s[..=usize::max_value()];\n-}\n+            in mod rangeto {\n+                data: super::DATA;\n+                bad: data[..super::BAD_END];\n+                message:\n+                    \"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\";\n+            }\n \n-#[test]\n-#[should_panic]\n-fn test_str_slicemut_rangeinclusive_max_panics() {\n-    let mut s = \"hello\".to_owned();\n-    let s: &mut str = &mut s;\n-    &mut s[1..=usize::max_value()];\n-}\n+            in mod rangeinclusive_1 {\n+                data: super::DATA;\n+                bad: data[super::BAD_START..=super::GOOD_END_INCL];\n+                message:\n+                    \"byte index 4 is not a char boundary; it is inside '\u03b1' (bytes 3..5) of\";\n+            }\n \n-#[test]\n-fn test_str_get_maxinclusive() {\n-    let mut s = \"hello\".to_owned();\n-    {\n-        let s: &str = &s;\n-        assert_eq!(s.get(..=usize::max_value()), None);\n-        assert_eq!(s.get(1..=usize::max_value()), None);\n+            in mod rangeinclusive_2 {\n+                data: super::DATA;\n+                bad: data[super::GOOD_START..=super::BAD_END_INCL];\n+                message:\n+                    \"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\";\n+            }\n+\n+            in mod rangetoinclusive {\n+                data: super::DATA;\n+                bad: data[..=super::BAD_END_INCL];\n+                message:\n+                    \"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\";\n+            }\n+        }\n     }\n-    {\n-        let s: &mut str = &mut s;\n-        assert_eq!(s.get(..=usize::max_value()), None);\n-        assert_eq!(s.get(1..=usize::max_value()), None);\n+\n+    const LOREM_PARAGRAPH: &'static str = \"\\\n+    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem \\\n+    sit amet dolor ultricies condimentum. Praesent iaculis purus elit, ac malesuada \\\n+    quam malesuada in. Duis sed orci eros. Suspendisse sit amet magna mollis, mollis \\\n+    nunc luctus, imperdiet mi. Integer fringilla non sem ut lacinia. Fusce varius \\\n+    tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec tempus vel, \\\n+    gravida nec quam.\";\n+\n+    // check the panic includes the prefix of the sliced string\n+    #[test]\n+    #[should_panic(expected=\"byte index 1024 is out of bounds of `Lorem ipsum dolor sit amet\")]\n+    fn test_slice_fail_truncated_1() {\n+        &LOREM_PARAGRAPH[..1024];\n+    }\n+    // check the truncation in the panic message\n+    #[test]\n+    #[should_panic(expected=\"luctus, im`[...]\")]\n+    fn test_slice_fail_truncated_2() {\n+        &LOREM_PARAGRAPH[..1024];\n     }\n }\n \n@@ -446,50 +725,6 @@ fn test_is_char_boundary() {\n         }\n     }\n }\n-const LOREM_PARAGRAPH: &'static str = \"\\\n-Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem sit amet dolor \\\n-ultricies condimentum. Praesent iaculis purus elit, ac malesuada quam malesuada in. Duis sed orci \\\n-eros. Suspendisse sit amet magna mollis, mollis nunc luctus, imperdiet mi. Integer fringilla non \\\n-sem ut lacinia. Fusce varius tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec \\\n-tempus vel, gravida nec quam.\";\n-\n-// check the panic includes the prefix of the sliced string\n-#[test]\n-#[should_panic(expected=\"byte index 1024 is out of bounds of `Lorem ipsum dolor sit amet\")]\n-fn test_slice_fail_truncated_1() {\n-    &LOREM_PARAGRAPH[..1024];\n-}\n-// check the truncation in the panic message\n-#[test]\n-#[should_panic(expected=\"luctus, im`[...]\")]\n-fn test_slice_fail_truncated_2() {\n-    &LOREM_PARAGRAPH[..1024];\n-}\n-\n-#[test]\n-#[should_panic(expected=\"byte index 4 is not a char boundary; it is inside '\u03b1' (bytes 3..5) of\")]\n-fn test_slice_fail_boundary_1() {\n-    &\"abc\u03b1\u03b2\u03b3\"[4..];\n-}\n-\n-#[test]\n-#[should_panic(expected=\"byte index 6 is not a char boundary; it is inside '\u03b2' (bytes 5..7) of\")]\n-fn test_slice_fail_boundary_2() {\n-    &\"abc\u03b1\u03b2\u03b3\"[2..6];\n-}\n-\n-#[test]\n-fn test_slice_from() {\n-    assert_eq!(&\"abcd\"[0..], \"abcd\");\n-    assert_eq!(&\"abcd\"[2..], \"cd\");\n-    assert_eq!(&\"abcd\"[4..], \"\");\n-}\n-#[test]\n-fn test_slice_to() {\n-    assert_eq!(&\"abcd\"[..0], \"\");\n-    assert_eq!(&\"abcd\"[..2], \"ab\");\n-    assert_eq!(&\"abcd\"[..4], \"abcd\");\n-}\n \n #[test]\n fn test_trim_left_matches() {\n@@ -767,6 +1002,12 @@ fn test_escape_unicode() {\n \n #[test]\n fn test_escape_debug() {\n+    // Note that there are subtleties with the number of backslashes\n+    // on the left- and right-hand sides. In particular, Unicode code points\n+    // are usually escaped with two backslashes on the right-hand side, as\n+    // they are escaped. However, when the character is unescaped (e.g. for\n+    // printable characters), only a single backslash appears (as the character\n+    // itself appears in the debug string).\n     assert_eq!(\"abc\".escape_debug(), \"abc\");\n     assert_eq!(\"a c\".escape_debug(), \"a c\");\n     assert_eq!(\"\u00e9\u00e8\u00ea\".escape_debug(), \"\u00e9\u00e8\u00ea\");\n@@ -777,6 +1018,7 @@ fn test_escape_debug() {\n     assert_eq!(\"\\u{10000}\\u{10ffff}\".escape_debug(), \"\\u{10000}\\\\u{10ffff}\");\n     assert_eq!(\"ab\\u{200b}\".escape_debug(), \"ab\\\\u{200b}\");\n     assert_eq!(\"\\u{10d4ea}\\r\".escape_debug(), \"\\\\u{10d4ea}\\\\r\");\n+    assert_eq!(\"\\u{301}a\\u{301}b\u00e9\\u{e000}\".escape_debug(), \"\\\\u{301}a\\u{301}b\u00e9\\\\u{e000}\");\n }\n \n #[test]\n@@ -1084,6 +1326,7 @@ fn test_str_default() {\n \n     t::<&str>();\n     t::<String>();\n+    t::<&mut str>();\n }\n \n #[test]"}, {"sha": "5efe1e23309a7d7a84e96796149be522763511c9", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -73,17 +73,14 @@ use core::intrinsics::{arith_offset, assume};\n use core::iter::{FromIterator, FusedIterator, TrustedLen};\n use core::marker::PhantomData;\n use core::mem;\n-#[cfg(not(test))]\n-#[cfg(stage0)]\n-use core::num::Float;\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{Index, IndexMut, RangeBounds};\n use core::ops;\n use core::ptr;\n use core::ptr::NonNull;\n use core::slice;\n \n-use alloc::CollectionAllocErr;\n+use collections::CollectionAllocErr;\n use borrow::ToOwned;\n use borrow::Cow;\n use boxed::Box;\n@@ -812,9 +809,15 @@ impl<T> Vec<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn swap_remove(&mut self, index: usize) -> T {\n-        let length = self.len();\n-        self.swap(index, length - 1);\n-        self.pop().unwrap()\n+        unsafe {\n+            // We replace self[index] with the last element. Note that if the\n+            // bounds check on hole succeeds there must be a last element (which\n+            // can be self[index] itself).\n+            let hole: *mut T = &mut self[index];\n+            let last = ptr::read(self.get_unchecked(self.len - 1));\n+            self.len -= 1;\n+            ptr::replace(hole, last)\n+        }\n     }\n \n     /// Inserts an element at position `index` within the vector, shifting all\n@@ -840,7 +843,7 @@ impl<T> Vec<T> {\n \n         // space for the new element\n         if len == self.buf.cap() {\n-            self.buf.double();\n+            self.reserve(1);\n         }\n \n         unsafe {\n@@ -1060,7 +1063,7 @@ impl<T> Vec<T> {\n         // This will panic or abort if we would allocate > isize::MAX bytes\n         // or if the length increment would overflow for zero-sized types.\n         if self.len == self.buf.cap() {\n-            self.buf.double();\n+            self.reserve(1);\n         }\n         unsafe {\n             let end = self.as_mut_ptr().offset(self.len as isize);\n@@ -1169,12 +1172,12 @@ impl<T> Vec<T> {\n         // the hole, and the vector length is restored to the new length.\n         //\n         let len = self.len();\n-        let start = match range.start() {\n+        let start = match range.start_bound() {\n             Included(&n) => n,\n             Excluded(&n) => n + 1,\n             Unbounded    => 0,\n         };\n-        let end = match range.end() {\n+        let end = match range.end_bound() {\n             Included(&n) => n + 1,\n             Excluded(&n) => n,\n             Unbounded    => len,\n@@ -1696,7 +1699,10 @@ impl<T: Hash> Hash for Vec<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n+#[rustc_on_unimplemented(\n+    message=\"vector indices are of type `usize` or ranges of `usize`\",\n+    label=\"vector indices are of type `usize` or ranges of `usize`\",\n+)]\n impl<T, I> Index<I> for Vec<T>\n where\n     I: ::core::slice::SliceIndex<[T]>,\n@@ -1710,7 +1716,10 @@ where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"vector indices are of type `usize` or ranges of `usize`\"]\n+#[rustc_on_unimplemented(\n+    message=\"vector indices are of type `usize` or ranges of `usize`\",\n+    label=\"vector indices are of type `usize` or ranges of `usize`\",\n+)]\n impl<T, I> IndexMut<I> for Vec<T>\n where\n     I: ::core::slice::SliceIndex<[T]>,\n@@ -2286,6 +2295,13 @@ impl<'a, T: Clone> From<Vec<T>> for Cow<'a, [T]> {\n     }\n }\n \n+#[stable(feature = \"cow_from_vec_ref\", since = \"1.28.0\")]\n+impl<'a, T: Clone> From<&'a Vec<T>> for Cow<'a, [T]> {\n+    fn from(v: &'a Vec<T>) -> Cow<'a, [T]> {\n+        Cow::Borrowed(v.as_slice())\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> FromIterator<T> for Cow<'a, [T]> where T: Clone {\n     fn from_iter<I: IntoIterator<Item = T>>(it: I) -> Cow<'a, [T]> {\n@@ -2533,9 +2549,11 @@ impl<'a, T> Drop for Drain<'a, T> {\n                 // memmove back untouched tail, update to new length\n                 let start = source_vec.len();\n                 let tail = self.tail_start;\n-                let src = source_vec.as_ptr().offset(tail as isize);\n-                let dst = source_vec.as_mut_ptr().offset(start as isize);\n-                ptr::copy(src, dst, self.tail_len);\n+                if tail != start {\n+                    let src = source_vec.as_ptr().offset(tail as isize);\n+                    let dst = source_vec.as_mut_ptr().offset(start as isize);\n+                    ptr::copy(src, dst, self.tail_len);\n+                }\n                 source_vec.set_len(start + self.tail_len);\n             }\n         }"}, {"sha": "b3b20715511a7627662d6eac5550f62f6db4508e", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -11,9 +11,8 @@\n #![no_std]\n #![allow(unused_attributes)]\n #![unstable(feature = \"alloc_jemalloc\",\n-            reason = \"this library is unlikely to be stabilized in its current \\\n-                      form or name\",\n-            issue = \"27783\")]\n+            reason = \"implementation detail of std, does not provide any public API\",\n+            issue = \"0\")]\n #![feature(core_intrinsics)]\n #![feature(libc)]\n #![feature(linkage)]\n@@ -97,13 +96,6 @@ mod contents {\n         ptr\n     }\n \n-    #[cfg(stage0)]\n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rde_oom() -> ! {\n-        ::core::intrinsics::abort();\n-    }\n-\n     #[no_mangle]\n     #[rustc_std_internal_symbol]\n     pub unsafe extern fn __rde_dealloc(ptr: *mut u8,"}, {"sha": "64348e05de7db16967708aded5d286e613cd75b1", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 71, "deletions": 78, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -14,7 +14,6 @@\n             reason = \"this library is unlikely to be stabilized in its current \\\n                       form or name\",\n             issue = \"32838\")]\n-#![feature(global_allocator)]\n #![feature(allocator_api)]\n #![feature(core_intrinsics)]\n #![feature(staged_api)]\n@@ -41,81 +40,78 @@ const MIN_ALIGN: usize = 8;\n #[allow(dead_code)]\n const MIN_ALIGN: usize = 16;\n \n-use core::alloc::{Alloc, GlobalAlloc, AllocErr, Layout, Opaque};\n+use core::alloc::{Alloc, GlobalAlloc, AllocErr, Layout};\n use core::ptr::NonNull;\n \n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+/// The default memory allocator provided by the operating system.\n+///\n+/// This is based on `malloc` on Unix platforms and `HeapAlloc` on Windows,\n+/// plus related functions.\n+///\n+/// This type can be used in a `static` item\n+/// with the `#[global_allocator]` attribute\n+/// to force the global allocator to be the system\u2019s one.\n+/// (The default is jemalloc for executables, on some platforms.)\n+///\n+/// ```rust\n+/// use std::alloc::System;\n+///\n+/// #[global_allocator]\n+/// static A: System = System;\n+///\n+/// fn main() {\n+///     let a = Box::new(4); // Allocates from the system allocator.\n+///     println!(\"{}\", a);\n+/// }\n+/// ```\n+///\n+/// It can also be used directly to allocate memory\n+/// independently of the standard library\u2019s global allocator.\n+#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n pub struct System;\n \n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl Alloc for System {\n     #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n         NonNull::new(GlobalAlloc::alloc(self, layout)).ok_or(AllocErr)\n     }\n \n     #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n         NonNull::new(GlobalAlloc::alloc_zeroed(self, layout)).ok_or(AllocErr)\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&mut self, ptr: NonNull<Opaque>, layout: Layout) {\n+    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n         GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n     }\n \n     #[inline]\n     unsafe fn realloc(&mut self,\n-                      ptr: NonNull<Opaque>,\n+                      ptr: NonNull<u8>,\n                       layout: Layout,\n-                      new_size: usize) -> Result<NonNull<Opaque>, AllocErr> {\n+                      new_size: usize) -> Result<NonNull<u8>, AllocErr> {\n         NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n     }\n }\n \n-#[cfg(stage0)]\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-unsafe impl<'a> Alloc for &'a System {\n-    #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n-        NonNull::new(GlobalAlloc::alloc(*self, layout)).ok_or(AllocErr)\n-    }\n-\n-    #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n-        NonNull::new(GlobalAlloc::alloc_zeroed(*self, layout)).ok_or(AllocErr)\n-    }\n-\n-    #[inline]\n-    unsafe fn dealloc(&mut self, ptr: NonNull<Opaque>, layout: Layout) {\n-        GlobalAlloc::dealloc(*self, ptr.as_ptr(), layout)\n-    }\n-\n-    #[inline]\n-    unsafe fn realloc(&mut self,\n-                      ptr: NonNull<Opaque>,\n-                      layout: Layout,\n-                      new_size: usize) -> Result<NonNull<Opaque>, AllocErr> {\n-        NonNull::new(GlobalAlloc::realloc(*self, ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n-    }\n-}\n-\n #[cfg(any(windows, unix, target_os = \"cloudabi\", target_os = \"redox\"))]\n mod realloc_fallback {\n-    use core::alloc::{GlobalAlloc, Opaque, Layout};\n+    use core::alloc::{GlobalAlloc, Layout};\n     use core::cmp;\n     use core::ptr;\n \n     impl super::System {\n-        pub(crate) unsafe fn realloc_fallback(&self, ptr: *mut Opaque, old_layout: Layout,\n-                                              new_size: usize) -> *mut Opaque {\n+        pub(crate) unsafe fn realloc_fallback(&self, ptr: *mut u8, old_layout: Layout,\n+                                              new_size: usize) -> *mut u8 {\n             // Docs for GlobalAlloc::realloc require this to be valid:\n             let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n \n             let new_ptr = GlobalAlloc::alloc(self, new_layout);\n             if !new_ptr.is_null() {\n                 let size = cmp::min(old_layout.size(), new_size);\n-                ptr::copy_nonoverlapping(ptr as *mut u8, new_ptr as *mut u8, size);\n+                ptr::copy_nonoverlapping(ptr, new_ptr, size);\n                 GlobalAlloc::dealloc(self, ptr, old_layout);\n             }\n             new_ptr\n@@ -131,49 +127,47 @@ mod platform {\n \n     use MIN_ALIGN;\n     use System;\n-    use core::alloc::{GlobalAlloc, Layout, Opaque};\n+    use core::alloc::{GlobalAlloc, Layout};\n \n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n     unsafe impl GlobalAlloc for System {\n         #[inline]\n-        unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n+        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n             if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-                libc::malloc(layout.size()) as *mut Opaque\n+                libc::malloc(layout.size()) as *mut u8\n             } else {\n                 #[cfg(target_os = \"macos\")]\n                 {\n                     if layout.align() > (1 << 31) {\n-                        // FIXME: use Opaque::null_mut\n-                        // https://github.com/rust-lang/rust/issues/49659\n-                        return 0 as *mut Opaque\n+                        return ptr::null_mut()\n                     }\n                 }\n                 aligned_malloc(&layout)\n             }\n         }\n \n         #[inline]\n-        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n             if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-                libc::calloc(layout.size(), 1) as *mut Opaque\n+                libc::calloc(layout.size(), 1) as *mut u8\n             } else {\n                 let ptr = self.alloc(layout.clone());\n                 if !ptr.is_null() {\n-                    ptr::write_bytes(ptr as *mut u8, 0, layout.size());\n+                    ptr::write_bytes(ptr, 0, layout.size());\n                 }\n                 ptr\n             }\n         }\n \n         #[inline]\n-        unsafe fn dealloc(&self, ptr: *mut Opaque, _layout: Layout) {\n+        unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {\n             libc::free(ptr as *mut libc::c_void)\n         }\n \n         #[inline]\n-        unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n+        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n             if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\n-                libc::realloc(ptr as *mut libc::c_void, new_size) as *mut Opaque\n+                libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8\n             } else {\n                 self.realloc_fallback(ptr, layout, new_size)\n             }\n@@ -182,7 +176,7 @@ mod platform {\n \n     #[cfg(any(target_os = \"android\", target_os = \"redox\", target_os = \"solaris\"))]\n     #[inline]\n-    unsafe fn aligned_malloc(layout: &Layout) -> *mut Opaque {\n+    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n         // On android we currently target API level 9 which unfortunately\n         // doesn't have the `posix_memalign` API used below. Instead we use\n         // `memalign`, but this unfortunately has the property on some systems\n@@ -200,19 +194,18 @@ mod platform {\n         // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n         // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n         //                                       /memory/aligned_memory.cc\n-        libc::memalign(layout.align(), layout.size()) as *mut Opaque\n+        libc::memalign(layout.align(), layout.size()) as *mut u8\n     }\n \n     #[cfg(not(any(target_os = \"android\", target_os = \"redox\", target_os = \"solaris\")))]\n     #[inline]\n-    unsafe fn aligned_malloc(layout: &Layout) -> *mut Opaque {\n+    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n         let mut out = ptr::null_mut();\n         let ret = libc::posix_memalign(&mut out, layout.align(), layout.size());\n         if ret != 0 {\n-            // FIXME: use Opaque::null_mut https://github.com/rust-lang/rust/issues/49659\n-            0 as *mut Opaque\n+            ptr::null_mut()\n         } else {\n-            out as *mut Opaque\n+            out as *mut u8\n         }\n     }\n }\n@@ -222,7 +215,7 @@ mod platform {\n mod platform {\n     use MIN_ALIGN;\n     use System;\n-    use core::alloc::{GlobalAlloc, Opaque, Layout};\n+    use core::alloc::{GlobalAlloc, Layout};\n \n     type LPVOID = *mut u8;\n     type HANDLE = LPVOID;\n@@ -254,7 +247,7 @@ mod platform {\n     }\n \n     #[inline]\n-    unsafe fn allocate_with_flags(layout: Layout, flags: DWORD) -> *mut Opaque {\n+    unsafe fn allocate_with_flags(layout: Layout, flags: DWORD) -> *mut u8 {\n         let ptr = if layout.align() <= MIN_ALIGN {\n             HeapAlloc(GetProcessHeap(), flags, layout.size())\n         } else {\n@@ -266,39 +259,39 @@ mod platform {\n                 align_ptr(ptr, layout.align())\n             }\n         };\n-        ptr as *mut Opaque\n+        ptr as *mut u8\n     }\n \n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n     unsafe impl GlobalAlloc for System {\n         #[inline]\n-        unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n+        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n             allocate_with_flags(layout, 0)\n         }\n \n         #[inline]\n-        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n             allocate_with_flags(layout, HEAP_ZERO_MEMORY)\n         }\n \n         #[inline]\n-        unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n+        unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n             if layout.align() <= MIN_ALIGN {\n                 let err = HeapFree(GetProcessHeap(), 0, ptr as LPVOID);\n                 debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n                               GetLastError());\n             } else {\n-                let header = get_header(ptr as *mut u8);\n+                let header = get_header(ptr);\n                 let err = HeapFree(GetProcessHeap(), 0, header.0 as LPVOID);\n                 debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n                               GetLastError());\n             }\n         }\n \n         #[inline]\n-        unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n+        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n             if layout.align() <= MIN_ALIGN {\n-                HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, new_size) as *mut Opaque\n+                HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, new_size) as *mut u8\n             } else {\n                 self.realloc_fallback(ptr, layout, new_size)\n             }\n@@ -327,32 +320,32 @@ mod platform {\n mod platform {\n     extern crate dlmalloc;\n \n-    use core::alloc::{GlobalAlloc, Layout, Opaque};\n+    use core::alloc::{GlobalAlloc, Layout};\n     use System;\n \n     // No need for synchronization here as wasm is currently single-threaded\n     static mut DLMALLOC: dlmalloc::Dlmalloc = dlmalloc::DLMALLOC_INIT;\n \n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n     unsafe impl GlobalAlloc for System {\n         #[inline]\n-        unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n-            DLMALLOC.malloc(layout.size(), layout.align()) as *mut Opaque\n+        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+            DLMALLOC.malloc(layout.size(), layout.align())\n         }\n \n         #[inline]\n-        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n-            DLMALLOC.calloc(layout.size(), layout.align()) as *mut Opaque\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+            DLMALLOC.calloc(layout.size(), layout.align())\n         }\n \n         #[inline]\n-        unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n-            DLMALLOC.free(ptr as *mut u8, layout.size(), layout.align())\n+        unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+            DLMALLOC.free(ptr, layout.size(), layout.align())\n         }\n \n         #[inline]\n-        unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n-            DLMALLOC.realloc(ptr as *mut u8, layout.size(), layout.align(), new_size) as *mut Opaque\n+        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+            DLMALLOC.realloc(ptr, layout.size(), layout.align(), new_size)\n         }\n     }\n }"}, {"sha": "0f4a5d16e1759aa1a4a0f957930fc5b02235c757", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -26,7 +26,7 @@\n #![feature(alloc)]\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n-#![cfg_attr(stage0, feature(generic_param_attrs))]\n+#![feature(raw_vec_internals)]\n #![cfg_attr(test, feature(test))]\n \n #![allow(deprecated)]\n@@ -315,17 +315,15 @@ impl DroplessArena {\n         false\n     }\n \n-    fn align_for<T>(&self) {\n-        let align = mem::align_of::<T>();\n+    fn align(&self, align: usize) {\n         let final_address = ((self.ptr.get() as usize) + align - 1) & !(align - 1);\n         self.ptr.set(final_address as *mut u8);\n         assert!(self.ptr <= self.end);\n     }\n \n     #[inline(never)]\n     #[cold]\n-    fn grow<T>(&self, n: usize) {\n-        let needed_bytes = n * mem::size_of::<T>();\n+    fn grow(&self, needed_bytes: usize) {\n         unsafe {\n             let mut chunks = self.chunks.borrow_mut();\n             let (chunk, mut new_capacity);\n@@ -357,25 +355,38 @@ impl DroplessArena {\n     }\n \n     #[inline]\n-    pub fn alloc<T>(&self, object: T) -> &mut T {\n+    pub fn alloc_raw(&self, bytes: usize, align: usize) -> &mut [u8] {\n         unsafe {\n-            assert!(!mem::needs_drop::<T>());\n-            assert!(mem::size_of::<T>() != 0);\n+            assert!(bytes != 0);\n+\n+            self.align(align);\n \n-            self.align_for::<T>();\n-            let future_end = intrinsics::arith_offset(self.ptr.get(), mem::size_of::<T>() as isize);\n+            let future_end = intrinsics::arith_offset(self.ptr.get(), bytes as isize);\n             if (future_end as *mut u8) >= self.end.get() {\n-                self.grow::<T>(1)\n+                self.grow(bytes);\n             }\n \n             let ptr = self.ptr.get();\n             // Set the pointer past ourselves\n             self.ptr.set(\n-                intrinsics::arith_offset(self.ptr.get(), mem::size_of::<T>() as isize) as *mut u8,\n+                intrinsics::arith_offset(self.ptr.get(), bytes as isize) as *mut u8,\n             );\n+            slice::from_raw_parts_mut(ptr, bytes)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn alloc<T>(&self, object: T) -> &mut T {\n+        assert!(!mem::needs_drop::<T>());\n+\n+        let mem = self.alloc_raw(\n+            mem::size_of::<T>(),\n+            mem::align_of::<T>()) as *mut _ as *mut T;\n+\n+        unsafe {\n             // Write into uninitialized memory.\n-            ptr::write(ptr as *mut T, object);\n-            &mut *(ptr as *mut T)\n+            ptr::write(mem, object);\n+            &mut *mem\n         }\n     }\n \n@@ -394,21 +405,13 @@ impl DroplessArena {\n         assert!(!mem::needs_drop::<T>());\n         assert!(mem::size_of::<T>() != 0);\n         assert!(slice.len() != 0);\n-        self.align_for::<T>();\n \n-        let future_end = unsafe {\n-            intrinsics::arith_offset(self.ptr.get(), (slice.len() * mem::size_of::<T>()) as isize)\n-        };\n-        if (future_end as *mut u8) >= self.end.get() {\n-            self.grow::<T>(slice.len());\n-        }\n+        let mem = self.alloc_raw(\n+            slice.len() * mem::size_of::<T>(),\n+            mem::align_of::<T>()) as *mut _ as *mut T;\n \n         unsafe {\n-            let arena_slice = slice::from_raw_parts_mut(self.ptr.get() as *mut T, slice.len());\n-            self.ptr.set(intrinsics::arith_offset(\n-                self.ptr.get(),\n-                (slice.len() * mem::size_of::<T>()) as isize,\n-            ) as *mut u8);\n+            let arena_slice = slice::from_raw_parts_mut(mem, slice.len());\n             arena_slice.copy_from_slice(slice);\n             arena_slice\n         }\n@@ -465,6 +468,12 @@ impl SyncDroplessArena {\n         self.lock.lock().in_arena(ptr)\n     }\n \n+    #[inline(always)]\n+    pub fn alloc_raw(&self, bytes: usize, align: usize) -> &mut [u8] {\n+        // Extend the lifetime of the result since it's limited to the lock guard\n+        unsafe { &mut *(self.lock.lock().alloc_raw(bytes, align) as *mut [u8]) }\n+    }\n+\n     #[inline(always)]\n     pub fn alloc<T>(&self, object: T) -> &mut T {\n         // Extend the lifetime of the result since it's limited to the lock guard"}, {"sha": "f4d02bbdbf8a2c5a31f0801dfef597a86caad9e3", "filename": "src/libbacktrace", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace?ref=56016cb1e02ece29f25c619b297f9c9797db821c", "patch": "@@ -0,0 +1 @@\n+Subproject commit f4d02bbdbf8a2c5a31f0801dfef597a86caad9e3"}, {"sha": "acc07047f6729cc578b55bec881acb8f8fd379ba", "filename": "src/libbacktrace/ChangeLog", "status": "removed", "additions": 0, "deletions": 590, "changes": 590, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2FChangeLog", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FChangeLog?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,590 +0,0 @@\n-2016-05-18  Uros Bizjak  <ubizjak@gmail.com>\n-\n-\tPR target/71161\n-\t* elf.c (phdr_callback) [__i386__]: Add\n-\t__attribute__((__force_align_arg_pointer__)).\n-\n-2016-03-02  Maxim Ostapenko  <m.ostapenko@partner.samsung.com>\n-\n-\t* elf.c (backtrace_initialize): Properly initialize elf_fileline_fn to\n-\tavoid possible crash.\n-\t(elf_add): Don't set *fileline_fn to elf_nodebug value in case of\n-\tmissing debug info anymore.\n-\n-2016-02-06  John David Anglin  <danglin@gcc.gnu.org>\n-\n-\t* mmap.c (MAP_FAILED): Define if not defined.\n-\n-2016-01-04  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tUpdate copyright years.\n-\n-2015-12-18  Andris Pavenis  <andris.pavenis@iki.fi>\n-\n-\t* configure.ac: Specify that DJGPP do not have mmap\n-\teven when sys/mman.h exists.\n-\t* configure: Regenerate\n-\n-2015-12-09  John David Anglin  <danglin@gcc.gnu.org>\n-\n-\tPR libgfortran/68115\n-\t* configure.ac: Set libbacktrace_cv_sys_sync to no on hppa*-*-hpux*.\n-\t* configure: Regenerate.\n-\t* elf.c (backtrace_initialize): Cast __sync_bool_compare_and_swap call\n-\tto void.\n-\n-2015-09-17  Ian Lance Taylor  <iant@google.com>\n-\n-\t* posix.c (backtrace_open): Cast second argument of open() to int.\n-\n-2015-09-11  Ian Lance Taylor  <iant@google.com>\n-\n-\t* Makefile.am (backtrace.lo): Depend on internal.h.\n-\t(sort.lo, stest.lo): Add explicit dependencies.\n-\t* Makefile.in: Rebuild.\n-\n-2015-09-09  Hans-Peter Nilsson  <hp@axis.com>\n-\n-\t* backtrace.c: #include <sys/types.h>.\n-\n-2015-09-08  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR other/67457\n-\t* backtrace.c: #include \"internal.h\".\n-\t(struct backtrace_data): Add can_alloc field.\n-\t(unwind): If can_alloc is false, don't try to get file/line\n-\tinformation.\n-\t(backtrace_full): Set can_alloc field in bdata.\n-\t* alloc.c (backtrace_alloc): Don't call error_callback if it is\n-\tNULL.\n-\t* mmap.c (backtrace_alloc): Likewise.\n-\t* internal.h: Update comments for backtrace_alloc and\n-\tbacktrace_free.\n-\n-2015-09-08  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR other/67457\n-\t* mmap.c (backtrace_alloc): Correct test for mmap failure.\n-\n-2015-08-31  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n-\n-\t* configure.ac: For spu-*-* targets, set have_fcntl to no.\n-\t* configure: Regenerate.\n-\n-2015-08-27  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n-\n-\t* configure.ac: Remove [disable-shared] argument to LT_INIT.\n-\tRemove setting PIC_FLAG when building as target library.\n-\t* configure: Regenerate.\n-\n-2015-08-26  Hans-Peter Nilsson  <hp@axis.com>\n-\n-\t* configure.ac: Only compile with -fPIC if the target\n-\tsupports it.\n-\t* configure: Regenerate.\n-\n-2015-08-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n-\n-\t* configure.ac: Set have_mmap to no on spu-*-* targets.\n-\t* configure: Regenerate.\n-\n-2015-08-13  Ian Lance Taylor  <iant@google.com>\n-\n-\t* dwarf.c (read_function_entry): Add vec_inlined parameter.\n-\tChange all callers.\n-\n-2015-06-11  Martin Sebor  <msebor@redhat.com>\n-\n-\tPR sanitizer/65479\n-\t* dwarf.c (struct line): Add new field idx.\n-\t(line_compare): Use it.\n-\t(add_line): Set it.\n-\t(read_line_info): Reset it.\n-\n-2015-05-29  Tristan Gingold  <gingold@adacore.com>\n-\n-\t* pecoff.c: New file.\n-\t* Makefile.am (FORMAT_FILES): Add pecoff.c and dependencies.\n-\t* Makefile.in: Regenerate.\n-\t* filetype.awk: Detect pecoff.\n-\t* configure.ac: Define BACKTRACE_SUPPORTS_DATA on elf platforms.\n-\tAdd pecoff.\n-\t* btest.c (test5): Test enabled only if BACKTRACE_SUPPORTS_DATA is\n-\ttrue.\n-\t* backtrace-supported.h.in (BACKTRACE_SUPPORTS_DATA): Define.\n-\t* configure: Regenerate.\n-\t* pecoff.c: New file.\n-\n-2015-05-13  Michael Haubenwallner  <michael.haubenwallner@ssi-schaefer.com>\n-\n-\t* Makefile.in: Regenerated with automake-1.11.6.\n-\t* aclocal.m4: Likewise.\n-\t* configure: Likewise.\n-\n-2015-01-24  Matthias Klose  <doko@ubuntu.com>\n-\n-\t* configure.ac: Move AM_ENABLE_MULTILIB before AC_PROG_CC.\n-\t* configure: Regenerate.\n-\n-2015-01-05  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tUpdate copyright years.\n-\n-2014-11-21  H.J. Lu  <hongjiu.lu@intel.com>\n-\n-\tPR bootstrap/63784\n-\t* configure: Regenerated.\n-\n-2014-11-11  David Malcolm  <dmalcolm@redhat.com>\n-\n-\t* ChangeLog.jit: New.\n-\n-2014-11-11  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n-\n-\tPR target/63610\n-\t* configure: Regenerate.\n-\n-2014-10-23  Ian Lance Taylor  <iant@google.com>\n-\n-\t* internal.h (backtrace_atomic_load_pointer) [no atomic or sync]:\n-\tFix to return void *.\n-\n-2014-05-08  Ian Lance Taylor  <iant@google.com>\n-\n-\t* mmap.c (backtrace_free): If freeing a large aligned block of\n-\tmemory, call munmap rather than holding onto it.\n-\t(backtrace_vector_grow): When growing a vector, double the number\n-\tof pages requested.  When releasing the old version of a grown\n-\tvector, pass the correct size to backtrace_free.\n-\n-2014-03-07  Ian Lance Taylor  <iant@google.com>\n-\n-\t* sort.c (backtrace_qsort): Use middle element as pivot.\n-\n-2014-03-06  Ian Lance Taylor  <iant@google.com>\n-\n-\t* sort.c: New file.\n-\t* stest.c: New file.\n-\t* internal.h (backtrace_qsort): Declare.\n-\t* dwarf.c (read_abbrevs): Call backtrace_qsort instead of qsort.\n-\t(read_line_info, read_function_entry): Likewise.\n-\t(read_function_info, build_dwarf_data): Likewise.\n-\t* elf.c (elf_initialize_syminfo): Likewise.\n-\t* Makefile.am (libbacktrace_la_SOURCES): Add sort.c.\n-\t(stest_SOURCES, stest_LDADD): Define.\n-\t(check_PROGRAMS): Add stest.\n-\n-2014-02-07  Misty De Meo  <misty@brew.sh>\n-\n-\tPR target/58710\n-\t* configure.ac: Use AC_LINK_IFELSE in check for\n-\t_Unwind_GetIPInfo.\n-\t* configure: Regenerate.\n-\n-2014-01-02  Richard Sandiford  <rdsandiford@googlemail.com>\n-\n-\tUpdate copyright years\n-\n-2013-12-06  Jakub Jelinek  <jakub@redhat.com>\n-\n-\t* elf.c (ET_DYN): Undefine and define again.\n-\t(elf_add): Add exe argument, if true and ehdr.e_type is ET_DYN,\n-\treturn early -1 without closing the descriptor.\n-\t(struct phdr_data): Add exe_descriptor.\n-\t(phdr_callback): If pd->exe_descriptor is not -1, for very first\n-\tcall if dlpi_name is NULL just call elf_add with the exe_descriptor,\n-\totherwise backtrace_close the exe_descriptor if not -1.  Adjust\n-\tcall to elf_add.\n-\t(backtrace_initialize): Adjust call to elf_add.  If it returns\n-\t-1, set pd.exe_descriptor to descriptor, otherwise set it to -1.\n-\n-2013-12-05  Ian Lance Taylor  <iant@google.com>\n-\n-\t* alloc.c (backtrace_vector_finish): Add error_callback and data\n-\tparameters.  Call backtrace_vector_release.  Return address base.\n-\t* mmap.c (backtrace_vector_finish): Add error_callback and data\n-\tparameters.  Return address base.\n-\t* dwarf.c (read_function_info): Get new address base from\n-\tbacktrace_vector_finish.\n-\t* internal.h (backtrace_vector_finish): Update declaration.\n-\n-2013-11-27  Ian Lance Taylor  <iant@google.com>\n-\n-\t* dwarf.c (find_address_ranges): New static function, broken out\n-\tof build_address_map.\n-\t(build_address_map): Call it.\n-\t* btest.c (check): Check for missing filename or function, rather\n-\tthan crashing.\n-\t(f3): Check that enough frames were returned.\n-\n-2013-11-19  Jakub Jelinek  <jakub@redhat.com>\n-\n-\t* backtrace.h (backtrace_syminfo_callback): Add symsize argument.\n-\t* elf.c (elf_syminfo): Pass 0 or sym->size to the callback as\n-\tlast argument.\n-\t* btest.c (struct symdata): Add size field.\n-\t(callback_three): Add symsize argument.  Copy it to the data->size\n-\tfield.\n-\t(f23): Set symdata.size to 0.\n-\t(test5): Likewise.  If sizeof (int) > 1, lookup address of\n-\t((uintptr_t) &global) + 1.  Verify symdata.val and symdata.size\n-\tvalues.\n-\n-\t* atomic.c: Include sys/types.h.\n-\n-2013-11-18  Ian Lance Taylor  <iant@google.com>\n-\n-\t* configure.ac: Check for support of __atomic extensions.\n-\t* internal.h: Declare or #define atomic functions for use in\n-\tbacktrace code.\n-\t* atomic.c: New file.\n-\t* dwarf.c (dwarf_lookup_pc): Use atomic functions.\n-\t(dwarf_fileline, backtrace_dwarf_add): Likewise.\n-\t* elf.c (elf_add_syminfo_data, elf_syminfo): Likewise.\n-\t(backtrace_initialize): Likewise.\n-\t* fileline.c (fileline_initialize): Likewise.\n-\t* Makefile.am (libbacktrace_la_SOURCES): Add atomic.c.\n-\t* configure, config.h.in, Makefile.in: Rebuild.\n-\n-2013-11-18  Jakub Jelinek  <jakub@redhat.com>\n-\n-\t* elf.c (SHN_UNDEF): Define.\n-\t(elf_initialize_syminfo): Add base_address argument.  Ignore symbols\n-\twith st_shndx == SHN_UNDEF.  Add base_address to address fields.\n-\t(elf_add): Adjust caller.\n-\n-\t* elf.c (phdr_callback): Process info->dlpi_addr == 0 normally.\n-\n-2013-11-16  Ian Lance Taylor  <iant@google.com>\n-\n-\t* backtrace.h (backtrace_create_state): Correct comment about\n-\tthreading.\n-\n-2013-11-15  Ian Lance Taylor  <iant@google.com>\n-\n-\t* backtrace.h (backtrace_syminfo): Update comment and parameter\n-\tname to take any address, not just a PC value.\n-\t* elf.c (STT_OBJECT): Define.\n-\t(elf_nosyms): Rename parameter pc to addr.\n-\t(elf_symbol_search): Rename local variable pc to addr.\n-\t(elf_initialize_syminfo): Add STT_OBJECT symbols to elf_symbols.\n-\t(elf_syminfo): Rename parameter pc to addr.\n-\t* btest.c (global): New global variable.\n-\t(test5): New test.\n-\t(main): Call test5.\n-\n-2013-10-17  Ian Lance Taylor  <iant@google.com>\n-\n-\t* elf.c (elf_add): Don't get the wrong offsets if a debug section\n-\tis missing.\n-\n-2013-10-15  David Malcolm  <dmalcolm@redhat.com>\n-\n-\t* configure.ac: Add --enable-host-shared, setting up\n-\tpre-existing PIC_FLAG variable within Makefile.am et al.\n-\t* configure: Regenerate.\n-\n-2013-09-20  Alan Modra  <amodra@gmail.com>\n-\n-\t* configure: Regenerate.\n-\n-2013-07-23  Alexander Monakov  <amonakov@ispras.ru>\n-\n-\t* elf.c (elf_syminfo): Loop over the elf_syminfo_data chain.\n-\n-2013-07-23  Alexander Monakov  <amonakov@ispras.ru>\n-\n-\t* elf.c (backtrace_initialize): Pass elf_fileline_fn to\n-\tdl_iterate_phdr callbacks.\n-\n-2013-03-25  Ian Lance Taylor  <iant@google.com>\n-\n-\t* alloc.c: #include <sys/types.h>.\n-\t* mmap.c: Likewise.\n-\n-2013-01-31  Ian Lance Taylor  <iant@google.com>\n-\n-\t* dwarf.c (read_function_info): Permit fvec parameter to be NULL.\n-\t(dwarf_lookup_pc): Don't use ddata->fvec if threaded.\n-\n-2013-01-25  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tPR other/56076\n-\t* dwarf.c (read_line_header): Don't crash if DW_AT_comp_dir\n-\tattribute was not seen.\n-\n-2013-01-16  Ian Lance Taylor  <iant@google.com>\n-\n-\t* dwarf.c (struct unit): Add filename and abs_filename fields.\n-\t(build_address_map): Set new fields when reading unit.\n-\t(dwarf_lookup_pc): If we don't find an entry in the line table,\n-\tjust return the main file name.\n-\n-2013-01-14  Richard Sandiford  <rdsandiford@googlemail.com>\n-\n-\tUpdate copyright years.\n-\n-2013-01-01  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR bootstrap/54834\n-\t* Makefile.am (AM_CPPFLAGS): Remove -I ../gcc/include and -I\n-\t$(MULTIBUILDTOP)/../../gcc/include.\n-\t* Makefile.in: Rebuild.\n-\n-2013-01-01  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR other/55536\n-\t* mmap.c (backtrace_alloc): Don't call sync functions if not\n-\tthreaded.\n-\t(backtrace_free): Likewise.\n-\n-2012-12-12  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n-\n-\t* mmapio.c: Define MAP_FAILED if not defined.\n-\n-2012-12-11  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tPR bootstrap/54926\n-\t* Makefile.am (AM_CFLAGS): Remove -frandom-seed=$@.\n-\t* configure.ac: If --with-target-subdir, add -frandom-seed=$@\n-\tto EXTRA_FLAGS unconditionally, otherwise check whether the compiler\n-\taccepts it.\n-\t* Makefile.in: Regenerated.\n-\t* configure: Regenerated.\n-\n-2012-12-07  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tPR bootstrap/54926\n-\t* Makefile.am (AM_CFLAGS): Add -frandom-seed=$@.\n-\t* Makefile.in: Regenerated.\n-\n-2012-11-20  Ian Lance Taylor  <iant@google.com>\n-\n-\t* dwarf.c (read_attribute): Always clear val.\n-\n-2012-11-13  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR other/55312\n-\t* configure.ac: Only add -Werror if building a target library.\n-\t* configure: Rebuild.\n-\n-2012-11-12  Ian Lance Taylor  <iant@google.com>\n-\t    Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\t    Gerald Pfeifer  <gerald@pfeifer.com>\n-\n-\t* configure.ac: Check for getexecname.\n-\t* fileline.c: #include <errno.h>.  Define getexecname if not\n-\tavailable.\n-\t(fileline_initialize): Try to find the executable in a few\n-\tdifferent ways.\n-\t* print.c (error_callback): Only print the filename if it came\n-\tfrom the backtrace state.\n-\t* configure, config.h.in: Rebuild.\n-\n-2012-10-29  Ian Lance Taylor  <iant@google.com>\n-\n-\t* mmap.c (backtrace_vector_release): Correct last patch: add\n-\taligned, not size.\n-\n-2012-10-29  Ian Lance Taylor  <iant@google.com>\n-\n-\t* mmap.c (backtrace_vector_release): Make sure freed block is\n-\taligned on 8-byte boundary.\n-\n-2012-10-26  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR other/55087\n-\t* posix.c (backtrace_open): Add does_not_exist parameter.\n-\t* elf.c (phdr_callback): Do not warn if shared library could not\n-\tbe opened.\n-\t* fileline.c (fileline_initialize): Update calls to\n-\tbacktrace_open.\n-\t* internal.h (backtrace_open): Update declaration.\n-\n-2012-10-26  Jack Howarth  <howarth@bromo.med.uc.edu>\n-\n-\tPR target/55061\n-\t* configure.ac: Check for _Unwind_GetIPInfo function declaration.\n-\t* configure: Regenerate.\n-\n-2012-10-24  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR target/55061\n-\t* configure.ac: Check whether -funwind-tables option works.\n-\t* configure: Rebuild.\n-\n-2012-10-11  Ian Lance Taylor  <iant@google.com>\n-\n-\t* configure.ac: Do not use dl_iterate_phdr on Solaris 10.\n-\t* configure: Rebuild.\n-\n-2012-10-10  Ian Lance Taylor  <iant@google.com>\n-\n-\t* elf.c: Rename all Elf typedefs to start with b_elf, and be all\n-\tlower case.\n-\n-2012-10-10  Hans-Peter Nilsson  <hp@bitrange.com>\n-\n-\t* elf.c (elf_add_syminfo_data): Add casts to avoid warning.\n-\n-2012-10-09  Ian Lance Taylor  <iant@google.com>\n-\n-\t* dwarf.c (dwarf_fileline): Add cast to avoid warning.\n-\t(backtrace_dwarf_add): Likewise.\n-\n-2012-10-09  Ian Lance Taylor  <iant@google.com>\n-\n-\tAdd support for tracing through shared libraries.\n-\t* configure.ac: Check for link.h and dl_iterate_phdr.\n-\t* elf.c: #include <link.h> if system has dl_iterate_phdr.  #undef\n-\tELF macros before #defining them.\n-\t(dl_phdr_info, dl_iterate_phdr): Define if system does not have\n-\tdl_iterate_phdr.\n-\t(struct elf_syminfo_data): Add next field.\n-\t(elf_initialize_syminfo): Initialize next field.\n-\t(elf_add_syminfo_data): New static function.\n-\t(elf_add): New static function, broken out of\n-\tbacktrace_initialize.  Call backtrace_dwarf_add instead of\n-\tbacktrace_dwarf_initialize.\n-\t(struct phdr_data): Define.\n-\t(phdr_callback): New static function.\n-\t(backtrace_initialize): Call elf_add.\n-\t* dwarf.c (struct dwarf_data): Add next and base_address fields.\n-\t(add_unit_addr): Add base_address parameter.  Change all callers.\n-\t(add_unit_ranges, build_address_map): Likewise.\n-\t(add_line): Add ddata parameter.  Change all callers.\n-\t(read_line_program, add_function_range): Likewise.\n-\t(dwarf_lookup_pc): New static function, broken out of\n-\tdwarf_fileline.\n-\t(dwarf_fileline): Call dwarf_lookup_pc.\n-\t(build_dwarf_data): New static function.\n-\t(backtrace_dwarf_add): New function.\n-\t(backtrace_dwarf_initialize): Remove.\n-\t* internal.h (backtrace_dwarf_initialize): Don't declare.\n-\t(backtrace_dwarf_add): Declare.\n-\t* configure, config.h.in: Rebuild.\n-\n-2012-10-04  Gerald Pfeifer  <gerald@pfeifer.com>\n-\n-\t* btest.c (f23): Avoid uninitialized variable warning.\n-\n-2012-10-04  Ian Lance Taylor  <iant@google.com>\n-\n-\t* dwarf.c: If the system header files do not declare strnlen,\n-\tprovide our own version.\n-\n-2012-10-03  Ian Lance Taylor  <iant@google.com>\n-\n-\t* dwarf.c (read_uleb128): Fix overflow test.\n-\t(read_sleb128): Likewise.\n-\t(build_address_map): Don't change unit_buf.start.\n-\n-2012-10-02  Uros Bizjak  <ubizjak@gmail.com>\n-\n-\tPR other/54761\n-\t* configure.ac (EXTRA_FLAGS): New.\n-\t* Makefile.am (AM_FLAGS): Add $(EXTRA_FLAGS).\n-\t* configure, Makefile.in: Regenerate.\n-\n-2012-09-29  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR other/54749\n-\t* fileline.c (fileline_initialize): Pass errnum as -1 when\n-\treporting that we could not read executable information after a\n-\tprevious failure.\n-\n-2012-09-27  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR bootstrap/54732\n-\t* configure.ac: Add no-dependencies to AM_INIT_AUTOMAKE.\n-\t* Makefile.am: Add dependencies for all objects.\n-\t* configure, aclocal.m4, Makefile.in: Rebuild.\n-\n-2012-09-27  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR other/54726\n-\t* elf.c (backtrace_initialize): Set *fileln_fn, not\n-\tstate->fileln_fn.\n-\n-2012-09-19  Ian Lance Taylor  <iant@google.com>\n-\n-\t* configure.ac: Only use GCC_CHECK_UNWIND_GETIPINFO when compiled\n-\tas a target library.\n-\t* configure: Rebuild.\n-\n-2012-09-19  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\t    Ian Lance Taylor  <iant@google.com>\n-\n-        * configure.ac (GCC_HEADER_STDINT): Invoke.\n-        * backtrace.h: If we can't find <stdint.h>, use \"gstdint.h\".\n-        * btest.c: Don't include <stdint.h>.\n-        * dwarf.c: Likewise.\n-        * configure, aclocal.m4, Makefile.in, config.h.in: Rebuild.\n-\n-2012-09-18  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR bootstrap/54623\n-\t* Makefile.am (AM_CPPFLAGS): Define.\n-\t(AM_CFLAGS): Remove -I options.\n-\t* Makefile.in: Rebuild.\n-\n-2012-09-18  Ian Lance Taylor  <iant@google.com>\n-\n-\t* posix.c (O_BINARY): Define if not defined.\n-\t(backtrace_open): Pass O_BINARY to open.  Only call fcntl if\n-\tHAVE_FCNTL is defined.\n-\t* configure.ac: Test for the fcntl function.\n-\t* configure, config.h.in: Rebuild.\n-\n-2012-09-18  Ian Lance Taylor  <iant@google.com>\n-\n-\t* btest.c (test1, test2, test3, test4): Add the unused attribute.\n-\n-2012-09-18  Ian Lance Taylor  <iant@google.com>\n-\n-\t* dwarf.c: Correct test of HAVE_DECL_STRNLEN.\n-\n-2012-09-18  Ian Lance Taylor  <iant@google.com>\n-\n-\t* configure.ac: Add AC_USE_SYSTEM_EXTENSIONS.\n-\t* mmapio.c: Don't define _GNU_SOURCE.\n-\t* configure, config.h.in: Rebuild.\n-\n-2012-09-18  Ian Lance Taylor  <iant@google.com>\n-\n-\t* configure.ac: Check whether strnlen is declared.\n-\t* dwarf.c: Declare strnlen if not declared.\n-\t* configure, config.h.in: Rebuild.\n-\n-2012-09-18  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\n-\t* fileline.c: Include <stdlib.h>.\n-\t* mmap.c: Likewise.\n-\n-2012-09-17  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR bootstrap/54611\n-\t* nounwind.c (backtrace_full): Rename from backtrace.  Add state\n-\tparameter.\n-\n-2012-09-17  Gerald Pfeifer  <gerald@pfeifer.com>\n-\n-\tPR bootstrap/54611\n-\t* nounwind.c (backtrace_simple): Add state parameter.\n-\n-2012-09-17  Ian Lance Taylor  <iant@google.com>\n-\n-\tPR bootstrap/54609\n-\t* unknown.c (unknown_fileline): Add state parameter, remove\n-\tfileline_data parameter, name error_callback parameter.\n-\t(backtrace_initialize): Add state parameter.\n-\n-2012-09-17  Ian Lance Taylor  <iant@google.com>\n-\n-\t* Initial implementation.\n-\f\n-Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-\n-Copying and distribution of this file, with or without modification,\n-are permitted in any medium without royalty provided the copyright\n-notice and this notice are preserved."}, {"sha": "6b60e3b3b07382a48c7ffbaf992876426234bdee", "filename": "src/libbacktrace/ChangeLog.jit", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2FChangeLog.jit", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2FChangeLog.jit", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FChangeLog.jit?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,14 +0,0 @@\n-2014-09-24  David Malcolm  <dmalcolm@redhat.com>\n-\n-\t* ChangeLog.jit: Add copyright footer.\n-\n-2013-10-03  David Malcolm  <dmalcolm@redhat.com>\n-\n-\t* configure.ac: Add --enable-host-shared.\n-\t* configure: Regenerate.\n-\f\n-Copyright (C) 2013-2014 Free Software Foundation, Inc.\n-\n-Copying and distribution of this file, with or without modification,\n-are permitted in any medium without royalty provided the copyright\n-notice and this notice are preserved."}, {"sha": "a7df02590982255a96166a4be552f07e6f42cabb", "filename": "src/libbacktrace/Makefile.am", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2FMakefile.am", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2FMakefile.am", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FMakefile.am?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,136 +0,0 @@\n-# Makefile.am -- Backtrace Makefile.\n-# Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-\n-# Redistribution and use in source and binary forms, with or without\n-# modification, are permitted provided that the following conditions are\n-# met:\n-\n-#     (1) Redistributions of source code must retain the above copyright\n-#     notice, this list of conditions and the following disclaimer. \n-\n-#     (2) Redistributions in binary form must reproduce the above copyright\n-#     notice, this list of conditions and the following disclaimer in\n-#     the documentation and/or other materials provided with the\n-#     distribution.  \n-\n-#     (3) The name of the author may not be used to\n-#     endorse or promote products derived from this software without\n-#     specific prior written permission.\n-\n-# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-# POSSIBILITY OF SUCH DAMAGE.\n-\n-ACLOCAL_AMFLAGS = -I .. -I ../config\n-\n-AM_CPPFLAGS = -I $(top_srcdir)/../include -I $(top_srcdir)/../libgcc \\\n-\t-I ../libgcc\n-\n-AM_CFLAGS = $(EXTRA_FLAGS) $(WARN_FLAGS) $(PIC_FLAG)\n-\n-noinst_LTLIBRARIES = libbacktrace.la\n-\n-libbacktrace_la_SOURCES = \\\n-\tbacktrace.h \\\n-\tatomic.c \\\n-\tdwarf.c \\\n-\tfileline.c \\\n-\tinternal.h \\\n-\tposix.c \\\n-\tprint.c \\\n-\tsort.c \\\n-\tstate.c\n-\n-BACKTRACE_FILES = \\\n-\tbacktrace.c \\\n-\tsimple.c \\\n-\tnounwind.c\n-\n-FORMAT_FILES = \\\n-\telf.c \\\n-\tpecoff.c \\\n-\tunknown.c\n-\n-VIEW_FILES = \\\n-\tread.c \\\n-\tmmapio.c\n-\n-ALLOC_FILES = \\\n-\talloc.c \\\n-\tmmap.c\n-\n-EXTRA_libbacktrace_la_SOURCES = \\\n-\t$(BACKTRACE_FILES) \\\n-\t$(FORMAT_FILES) \\\n-\t$(VIEW_FILES) \\\n-\t$(ALLOC_FILES)\n-\n-libbacktrace_la_LIBADD = \\\n-\t$(BACKTRACE_FILE) \\\n-\t$(FORMAT_FILE) \\\n-\t$(VIEW_FILE) \\\n-\t$(ALLOC_FILE)\n-\n-libbacktrace_la_DEPENDENCIES = $(libbacktrace_la_LIBADD)\n-\n-# Testsuite.\n-\n-check_PROGRAMS =\n-\n-TESTS = $(check_PROGRAMS)\n-\n-if NATIVE\n-\n-btest_SOURCES = btest.c\n-btest_CFLAGS = $(AM_CFLAGS) -g -O\n-btest_LDADD = libbacktrace.la\n-\n-check_PROGRAMS += btest\n-\n-stest_SOURCES = stest.c\n-stest_LDADD = libbacktrace.la\n-\n-check_PROGRAMS += stest\n-\n-endif NATIVE\n-\n-# We can't use automake's automatic dependency tracking, because it\n-# breaks when using bootstrap-lean.  Automatic dependency tracking\n-# with GCC bootstrap will cause some of the objects to depend on\n-# header files in prev-gcc/include, e.g., stddef.h and stdarg.h.  When\n-# using bootstrap-lean, prev-gcc is removed after each stage.  When\n-# running \"make install\", those header files will be gone, causing the\n-# library to be rebuilt at install time.  That may not succeed.\n-\n-# These manual dependencies do not include dependencies on unwind.h,\n-# even though that is part of GCC, because where to find it depends on\n-# whether we are being built as a host library or a target library.\n-\n-INCDIR = $(top_srcdir)/../include\n-alloc.lo: config.h backtrace.h internal.h\n-backtrace.lo: config.h backtrace.h internal.h\n-btest.lo: (INCDIR)/filenames.h backtrace.h backtrace-supported.h\n-dwarf.lo: config.h $(INCDIR)/dwarf2.h $(INCDIR)/dwarf2.def \\\n-\t$(INCDIR)/filenames.h backtrace.h internal.h\n-elf.lo: config.h backtrace.h internal.h\n-fileline.lo: config.h backtrace.h internal.h\n-mmap.lo: config.h backtrace.h internal.h\n-mmapio.lo: config.h backtrace.h internal.h\n-nounwind.lo: config.h internal.h\n-pecoff.lo: config.h backtrace.h internal.h\n-posix.lo: config.h backtrace.h internal.h\n-print.lo: config.h backtrace.h internal.h\n-read.lo: config.h backtrace.h internal.h\n-simple.lo: config.h backtrace.h internal.h\n-sort.lo: config.h backtrace.h internal.h\n-stest.lo: config.h backtrace.h internal.h\n-state.lo: config.h backtrace.h backtrace-supported.h internal.h\n-unknown.lo: config.h backtrace.h internal.h"}, {"sha": "586b6a6eaa10e94d4bf4deb478e063f2653088ac", "filename": "src/libbacktrace/Makefile.in", "status": "removed", "additions": 0, "deletions": 770, "changes": 770, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FMakefile.in?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,770 +0,0 @@\n-# Makefile.in generated by automake 1.11.6 from Makefile.am.\n-# @configure_input@\n-\n-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software\n-# Foundation, Inc.\n-# This Makefile.in is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-@SET_MAKE@\n-\n-# Makefile.am -- Backtrace Makefile.\n-# Copyright (C) 2012-2015 Free Software Foundation, Inc.\n-\n-# Redistribution and use in source and binary forms, with or without\n-# modification, are permitted provided that the following conditions are\n-# met:\n-\n-#     (1) Redistributions of source code must retain the above copyright\n-#     notice, this list of conditions and the following disclaimer. \n-\n-#     (2) Redistributions in binary form must reproduce the above copyright\n-#     notice, this list of conditions and the following disclaimer in\n-#     the documentation and/or other materials provided with the\n-#     distribution.  \n-\n-#     (3) The name of the author may not be used to\n-#     endorse or promote products derived from this software without\n-#     specific prior written permission.\n-\n-# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-# POSSIBILITY OF SUCH DAMAGE.\n-\n-VPATH = @srcdir@\n-am__make_dryrun = \\\n-  { \\\n-    am__dry=no; \\\n-    case $$MAKEFLAGS in \\\n-      *\\\\[\\ \\\t]*) \\\n-        echo 'am--echo: ; @echo \"AM\"  OK' | $(MAKE) -f - 2>/dev/null \\\n-          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \\\n-      *) \\\n-        for am__flg in $$MAKEFLAGS; do \\\n-          case $$am__flg in \\\n-            *=*|--*) ;; \\\n-            *n*) am__dry=yes; break;; \\\n-          esac; \\\n-        done;; \\\n-    esac; \\\n-    test $$am__dry = yes; \\\n-  }\n-pkgdatadir = $(datadir)/@PACKAGE@\n-pkgincludedir = $(includedir)/@PACKAGE@\n-pkglibdir = $(libdir)/@PACKAGE@\n-pkglibexecdir = $(libexecdir)/@PACKAGE@\n-am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n-install_sh_DATA = $(install_sh) -c -m 644\n-install_sh_PROGRAM = $(install_sh) -c\n-install_sh_SCRIPT = $(install_sh) -c\n-INSTALL_HEADER = $(INSTALL_DATA)\n-transform = $(program_transform_name)\n-NORMAL_INSTALL = :\n-PRE_INSTALL = :\n-POST_INSTALL = :\n-NORMAL_UNINSTALL = :\n-PRE_UNINSTALL = :\n-POST_UNINSTALL = :\n-build_triplet = @build@\n-host_triplet = @host@\n-target_triplet = @target@\n-check_PROGRAMS = $(am__EXEEXT_1)\n-@NATIVE_TRUE@am__append_1 = btest stest\n-subdir = .\n-DIST_COMMON = README ChangeLog $(srcdir)/Makefile.in \\\n-\t$(srcdir)/Makefile.am $(top_srcdir)/configure \\\n-\t$(am__configure_deps) $(srcdir)/config.h.in \\\n-\t$(srcdir)/../mkinstalldirs $(srcdir)/backtrace-supported.h.in\n-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n-am__aclocal_m4_deps = $(top_srcdir)/../config/lead-dot.m4 \\\n-\t$(top_srcdir)/../config/multi.m4 \\\n-\t$(top_srcdir)/../config/override.m4 \\\n-\t$(top_srcdir)/../config/stdint.m4 \\\n-\t$(top_srcdir)/../config/unwind_ipinfo.m4 \\\n-\t$(top_srcdir)/../config/warnings.m4 \\\n-\t$(top_srcdir)/../libtool.m4 $(top_srcdir)/../ltoptions.m4 \\\n-\t$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \\\n-\t$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/configure.ac\n-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n-\t$(ACLOCAL_M4)\n-am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n- configure.lineno config.status.lineno\n-mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n-CONFIG_HEADER = config.h\n-CONFIG_CLEAN_FILES = backtrace-supported.h\n-CONFIG_CLEAN_VPATH_FILES =\n-LTLIBRARIES = $(noinst_LTLIBRARIES)\n-am__DEPENDENCIES_1 =\n-am_libbacktrace_la_OBJECTS = atomic.lo dwarf.lo fileline.lo posix.lo \\\n-\tprint.lo sort.lo state.lo\n-libbacktrace_la_OBJECTS = $(am_libbacktrace_la_OBJECTS)\n-@NATIVE_TRUE@am__EXEEXT_1 = btest$(EXEEXT) stest$(EXEEXT)\n-@NATIVE_TRUE@am_btest_OBJECTS = btest-btest.$(OBJEXT)\n-btest_OBJECTS = $(am_btest_OBJECTS)\n-@NATIVE_TRUE@btest_DEPENDENCIES = libbacktrace.la\n-btest_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n-\t--mode=link $(CCLD) $(btest_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n-\t$(LDFLAGS) -o $@\n-@NATIVE_TRUE@am_stest_OBJECTS = stest.$(OBJEXT)\n-stest_OBJECTS = $(am_stest_OBJECTS)\n-@NATIVE_TRUE@stest_DEPENDENCIES = libbacktrace.la\n-DEFAULT_INCLUDES = -I.@am__isrc@\n-depcomp =\n-am__depfiles_maybe =\n-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n-\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n-LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n-\t--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n-\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n-CCLD = $(CC)\n-LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n-\t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n-\t$(LDFLAGS) -o $@\n-SOURCES = $(libbacktrace_la_SOURCES) $(EXTRA_libbacktrace_la_SOURCES) \\\n-\t$(btest_SOURCES) $(stest_SOURCES)\n-MULTISRCTOP = \n-MULTIBUILDTOP = \n-MULTIDIRS = \n-MULTISUBDIR = \n-MULTIDO = true\n-MULTICLEAN = true\n-am__can_run_installinfo = \\\n-  case $$AM_UPDATE_INFO_DIR in \\\n-    n|no|NO) false;; \\\n-    *) (install-info --version) >/dev/null 2>&1;; \\\n-  esac\n-ETAGS = etags\n-CTAGS = ctags\n-am__tty_colors = \\\n-red=; grn=; lgn=; blu=; std=\n-ACLOCAL = @ACLOCAL@\n-ALLOC_FILE = @ALLOC_FILE@\n-AMTAR = @AMTAR@\n-AR = @AR@\n-AUTOCONF = @AUTOCONF@\n-AUTOHEADER = @AUTOHEADER@\n-AUTOMAKE = @AUTOMAKE@\n-AWK = @AWK@\n-BACKTRACE_FILE = @BACKTRACE_FILE@\n-BACKTRACE_SUPPORTED = @BACKTRACE_SUPPORTED@\n-BACKTRACE_SUPPORTS_DATA = @BACKTRACE_SUPPORTS_DATA@\n-BACKTRACE_SUPPORTS_THREADS = @BACKTRACE_SUPPORTS_THREADS@\n-BACKTRACE_USES_MALLOC = @BACKTRACE_USES_MALLOC@\n-CC = @CC@\n-CFLAGS = @CFLAGS@\n-CPP = @CPP@\n-CPPFLAGS = @CPPFLAGS@\n-CYGPATH_W = @CYGPATH_W@\n-DEFS = @DEFS@\n-DSYMUTIL = @DSYMUTIL@\n-DUMPBIN = @DUMPBIN@\n-ECHO_C = @ECHO_C@\n-ECHO_N = @ECHO_N@\n-ECHO_T = @ECHO_T@\n-EGREP = @EGREP@\n-EXEEXT = @EXEEXT@\n-EXTRA_FLAGS = @EXTRA_FLAGS@\n-FGREP = @FGREP@\n-FORMAT_FILE = @FORMAT_FILE@\n-GREP = @GREP@\n-INSTALL = @INSTALL@\n-INSTALL_DATA = @INSTALL_DATA@\n-INSTALL_PROGRAM = @INSTALL_PROGRAM@\n-INSTALL_SCRIPT = @INSTALL_SCRIPT@\n-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n-LD = @LD@\n-LDFLAGS = @LDFLAGS@\n-LIBOBJS = @LIBOBJS@\n-LIBS = @LIBS@\n-LIBTOOL = @LIBTOOL@\n-LIPO = @LIPO@\n-LN_S = @LN_S@\n-LTLIBOBJS = @LTLIBOBJS@\n-MAINT = @MAINT@\n-MAKEINFO = @MAKEINFO@\n-MKDIR_P = @MKDIR_P@\n-NM = @NM@\n-NMEDIT = @NMEDIT@\n-OBJDUMP = @OBJDUMP@\n-OBJEXT = @OBJEXT@\n-OTOOL = @OTOOL@\n-OTOOL64 = @OTOOL64@\n-PACKAGE = @PACKAGE@\n-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n-PACKAGE_NAME = @PACKAGE_NAME@\n-PACKAGE_STRING = @PACKAGE_STRING@\n-PACKAGE_TARNAME = @PACKAGE_TARNAME@\n-PACKAGE_URL = @PACKAGE_URL@\n-PACKAGE_VERSION = @PACKAGE_VERSION@\n-PATH_SEPARATOR = @PATH_SEPARATOR@\n-PIC_FLAG = @PIC_FLAG@\n-RANLIB = @RANLIB@\n-SED = @SED@\n-SET_MAKE = @SET_MAKE@\n-SHELL = @SHELL@\n-STRIP = @STRIP@\n-VERSION = @VERSION@\n-VIEW_FILE = @VIEW_FILE@\n-WARN_FLAGS = @WARN_FLAGS@\n-abs_builddir = @abs_builddir@\n-abs_srcdir = @abs_srcdir@\n-abs_top_builddir = @abs_top_builddir@\n-abs_top_srcdir = @abs_top_srcdir@\n-ac_ct_CC = @ac_ct_CC@\n-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n-am__leading_dot = @am__leading_dot@\n-am__tar = @am__tar@\n-am__untar = @am__untar@\n-bindir = @bindir@\n-build = @build@\n-build_alias = @build_alias@\n-build_cpu = @build_cpu@\n-build_os = @build_os@\n-build_vendor = @build_vendor@\n-builddir = @builddir@\n-datadir = @datadir@\n-datarootdir = @datarootdir@\n-docdir = @docdir@\n-dvidir = @dvidir@\n-exec_prefix = @exec_prefix@\n-host = @host@\n-host_alias = @host_alias@\n-host_cpu = @host_cpu@\n-host_os = @host_os@\n-host_vendor = @host_vendor@\n-htmldir = @htmldir@\n-includedir = @includedir@\n-infodir = @infodir@\n-install_sh = @install_sh@\n-libdir = @libdir@\n-libexecdir = @libexecdir@\n-libtool_VERSION = @libtool_VERSION@\n-localedir = @localedir@\n-localstatedir = @localstatedir@\n-mandir = @mandir@\n-mkdir_p = @mkdir_p@\n-multi_basedir = @multi_basedir@\n-oldincludedir = @oldincludedir@\n-pdfdir = @pdfdir@\n-prefix = @prefix@\n-program_transform_name = @program_transform_name@\n-psdir = @psdir@\n-sbindir = @sbindir@\n-sharedstatedir = @sharedstatedir@\n-srcdir = @srcdir@\n-sysconfdir = @sysconfdir@\n-target = @target@\n-target_alias = @target_alias@\n-target_cpu = @target_cpu@\n-target_os = @target_os@\n-target_vendor = @target_vendor@\n-top_build_prefix = @top_build_prefix@\n-top_builddir = @top_builddir@\n-top_srcdir = @top_srcdir@\n-ACLOCAL_AMFLAGS = -I .. -I ../config\n-AM_CPPFLAGS = -I $(top_srcdir)/../include -I $(top_srcdir)/../libgcc \\\n-\t-I ../libgcc\n-\n-AM_CFLAGS = $(EXTRA_FLAGS) $(WARN_FLAGS) $(PIC_FLAG)\n-noinst_LTLIBRARIES = libbacktrace.la\n-libbacktrace_la_SOURCES = \\\n-\tbacktrace.h \\\n-\tatomic.c \\\n-\tdwarf.c \\\n-\tfileline.c \\\n-\tinternal.h \\\n-\tposix.c \\\n-\tprint.c \\\n-\tsort.c \\\n-\tstate.c\n-\n-BACKTRACE_FILES = \\\n-\tbacktrace.c \\\n-\tsimple.c \\\n-\tnounwind.c\n-\n-FORMAT_FILES = \\\n-\telf.c \\\n-\tpecoff.c \\\n-\tunknown.c\n-\n-VIEW_FILES = \\\n-\tread.c \\\n-\tmmapio.c\n-\n-ALLOC_FILES = \\\n-\talloc.c \\\n-\tmmap.c\n-\n-EXTRA_libbacktrace_la_SOURCES = \\\n-\t$(BACKTRACE_FILES) \\\n-\t$(FORMAT_FILES) \\\n-\t$(VIEW_FILES) \\\n-\t$(ALLOC_FILES)\n-\n-libbacktrace_la_LIBADD = \\\n-\t$(BACKTRACE_FILE) \\\n-\t$(FORMAT_FILE) \\\n-\t$(VIEW_FILE) \\\n-\t$(ALLOC_FILE)\n-\n-libbacktrace_la_DEPENDENCIES = $(libbacktrace_la_LIBADD)\n-TESTS = $(check_PROGRAMS)\n-@NATIVE_TRUE@btest_SOURCES = btest.c\n-@NATIVE_TRUE@btest_CFLAGS = $(AM_CFLAGS) -g -O\n-@NATIVE_TRUE@btest_LDADD = libbacktrace.la\n-@NATIVE_TRUE@stest_SOURCES = stest.c\n-@NATIVE_TRUE@stest_LDADD = libbacktrace.la\n-\n-# We can't use automake's automatic dependency tracking, because it\n-# breaks when using bootstrap-lean.  Automatic dependency tracking\n-# with GCC bootstrap will cause some of the objects to depend on\n-# header files in prev-gcc/include, e.g., stddef.h and stdarg.h.  When\n-# using bootstrap-lean, prev-gcc is removed after each stage.  When\n-# running \"make install\", those header files will be gone, causing the\n-# library to be rebuilt at install time.  That may not succeed.\n-\n-# These manual dependencies do not include dependencies on unwind.h,\n-# even though that is part of GCC, because where to find it depends on\n-# whether we are being built as a host library or a target library.\n-INCDIR = $(top_srcdir)/../include\n-all: config.h\n-\t$(MAKE) $(AM_MAKEFLAGS) all-am\n-\n-.SUFFIXES:\n-.SUFFIXES: .c .lo .o .obj\n-am--refresh: Makefile\n-\t@:\n-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n-\t@for dep in $?; do \\\n-\t  case '$(am__configure_deps)' in \\\n-\t    *$$dep*) \\\n-\t      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign --ignore-deps'; \\\n-\t      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign --ignore-deps \\\n-\t\t&& exit 0; \\\n-\t      exit 1;; \\\n-\t  esac; \\\n-\tdone; \\\n-\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign --ignore-deps Makefile'; \\\n-\t$(am__cd) $(top_srcdir) && \\\n-\t  $(AUTOMAKE) --foreign --ignore-deps Makefile\n-.PRECIOUS: Makefile\n-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n-\t@case '$?' in \\\n-\t  *config.status*) \\\n-\t    echo ' $(SHELL) ./config.status'; \\\n-\t    $(SHELL) ./config.status;; \\\n-\t  *) \\\n-\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \\\n-\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \\\n-\tesac;\n-\n-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n-\t$(SHELL) ./config.status --recheck\n-\n-$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n-\t$(am__cd) $(srcdir) && $(AUTOCONF)\n-$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n-\t$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)\n-$(am__aclocal_m4_deps):\n-\n-config.h: stamp-h1\n-\t@if test ! -f $@; then rm -f stamp-h1; else :; fi\n-\t@if test ! -f $@; then $(MAKE) $(AM_MAKEFLAGS) stamp-h1; else :; fi\n-\n-stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status\n-\t@rm -f stamp-h1\n-\tcd $(top_builddir) && $(SHELL) ./config.status config.h\n-$(srcdir)/config.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps) \n-\t($(am__cd) $(top_srcdir) && $(AUTOHEADER))\n-\trm -f stamp-h1\n-\ttouch $@\n-\n-distclean-hdr:\n-\t-rm -f config.h stamp-h1\n-backtrace-supported.h: $(top_builddir)/config.status $(srcdir)/backtrace-supported.h.in\n-\tcd $(top_builddir) && $(SHELL) ./config.status $@\n-\n-clean-noinstLTLIBRARIES:\n-\t-test -z \"$(noinst_LTLIBRARIES)\" || rm -f $(noinst_LTLIBRARIES)\n-\t@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \\\n-\t  dir=\"`echo $$p | sed -e 's|/[^/]*$$||'`\"; \\\n-\t  test \"$$dir\" != \"$$p\" || dir=.; \\\n-\t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n-\t  rm -f \"$${dir}/so_locations\"; \\\n-\tdone\n-libbacktrace.la: $(libbacktrace_la_OBJECTS) $(libbacktrace_la_DEPENDENCIES) $(EXTRA_libbacktrace_la_DEPENDENCIES) \n-\t$(LINK)  $(libbacktrace_la_OBJECTS) $(libbacktrace_la_LIBADD) $(LIBS)\n-\n-clean-checkPROGRAMS:\n-\t@list='$(check_PROGRAMS)'; test -n \"$$list\" || exit 0; \\\n-\techo \" rm -f\" $$list; \\\n-\trm -f $$list || exit $$?; \\\n-\ttest -n \"$(EXEEXT)\" || exit 0; \\\n-\tlist=`for p in $$list; do echo \"$$p\"; done | sed 's/$(EXEEXT)$$//'`; \\\n-\techo \" rm -f\" $$list; \\\n-\trm -f $$list\n-btest$(EXEEXT): $(btest_OBJECTS) $(btest_DEPENDENCIES) $(EXTRA_btest_DEPENDENCIES) \n-\t@rm -f btest$(EXEEXT)\n-\t$(btest_LINK) $(btest_OBJECTS) $(btest_LDADD) $(LIBS)\n-stest$(EXEEXT): $(stest_OBJECTS) $(stest_DEPENDENCIES) $(EXTRA_stest_DEPENDENCIES) \n-\t@rm -f stest$(EXEEXT)\n-\t$(LINK) $(stest_OBJECTS) $(stest_LDADD) $(LIBS)\n-\n-mostlyclean-compile:\n-\t-rm -f *.$(OBJEXT)\n-\n-distclean-compile:\n-\t-rm -f *.tab.c\n-\n-.c.o:\n-\t$(COMPILE) -c $<\n-\n-.c.obj:\n-\t$(COMPILE) -c `$(CYGPATH_W) '$<'`\n-\n-.c.lo:\n-\t$(LTCOMPILE) -c -o $@ $<\n-\n-btest-btest.o: btest.c\n-\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(btest_CFLAGS) $(CFLAGS) -c -o btest-btest.o `test -f 'btest.c' || echo '$(srcdir)/'`btest.c\n-\n-btest-btest.obj: btest.c\n-\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(btest_CFLAGS) $(CFLAGS) -c -o btest-btest.obj `if test -f 'btest.c'; then $(CYGPATH_W) 'btest.c'; else $(CYGPATH_W) '$(srcdir)/btest.c'; fi`\n-\n-mostlyclean-libtool:\n-\t-rm -f *.lo\n-\n-clean-libtool:\n-\t-rm -rf .libs _libs\n-\n-distclean-libtool:\n-\t-rm -f libtool config.lt\n-\n-# GNU Make needs to see an explicit $(MAKE) variable in the command it\n-# runs to enable its job server during parallel builds.  Hence the\n-# comments below.\n-all-multi:\n-\t$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)\n-install-multi:\n-\t$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do # $(MAKE)\n-\n-mostlyclean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean # $(MAKE)\n-clean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean # $(MAKE)\n-distclean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean # $(MAKE)\n-maintainer-clean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean # $(MAKE)\n-\n-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n-\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n-\tunique=`for i in $$list; do \\\n-\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-\t  done | \\\n-\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n-\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n-\tmkid -fID $$unique\n-tags: TAGS\n-\n-TAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \\\n-\t\t$(TAGS_FILES) $(LISP)\n-\tset x; \\\n-\there=`pwd`; \\\n-\tlist='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \\\n-\tunique=`for i in $$list; do \\\n-\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-\t  done | \\\n-\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n-\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n-\tshift; \\\n-\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n-\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n-\t  if test $$# -gt 0; then \\\n-\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n-\t      \"$$@\" $$unique; \\\n-\t  else \\\n-\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n-\t      $$unique; \\\n-\t  fi; \\\n-\tfi\n-ctags: CTAGS\n-CTAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \\\n-\t\t$(TAGS_FILES) $(LISP)\n-\tlist='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \\\n-\tunique=`for i in $$list; do \\\n-\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-\t  done | \\\n-\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n-\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n-\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n-\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n-\t     $$unique\n-\n-GTAGS:\n-\there=`$(am__cd) $(top_builddir) && pwd` \\\n-\t  && $(am__cd) $(top_srcdir) \\\n-\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n-\n-distclean-tags:\n-\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n-\n-check-TESTS: $(TESTS)\n-\t@failed=0; all=0; xfail=0; xpass=0; skip=0; \\\n-\tsrcdir=$(srcdir); export srcdir; \\\n-\tlist=' $(TESTS) '; \\\n-\t$(am__tty_colors); \\\n-\tif test -n \"$$list\"; then \\\n-\t  for tst in $$list; do \\\n-\t    if test -f ./$$tst; then dir=./; \\\n-\t    elif test -f $$tst; then dir=; \\\n-\t    else dir=\"$(srcdir)/\"; fi; \\\n-\t    if $(TESTS_ENVIRONMENT) $${dir}$$tst; then \\\n-\t      all=`expr $$all + 1`; \\\n-\t      case \" $(XFAIL_TESTS) \" in \\\n-\t      *[\\ \\\t]$$tst[\\ \\\t]*) \\\n-\t\txpass=`expr $$xpass + 1`; \\\n-\t\tfailed=`expr $$failed + 1`; \\\n-\t\tcol=$$red; res=XPASS; \\\n-\t      ;; \\\n-\t      *) \\\n-\t\tcol=$$grn; res=PASS; \\\n-\t      ;; \\\n-\t      esac; \\\n-\t    elif test $$? -ne 77; then \\\n-\t      all=`expr $$all + 1`; \\\n-\t      case \" $(XFAIL_TESTS) \" in \\\n-\t      *[\\ \\\t]$$tst[\\ \\\t]*) \\\n-\t\txfail=`expr $$xfail + 1`; \\\n-\t\tcol=$$lgn; res=XFAIL; \\\n-\t      ;; \\\n-\t      *) \\\n-\t\tfailed=`expr $$failed + 1`; \\\n-\t\tcol=$$red; res=FAIL; \\\n-\t      ;; \\\n-\t      esac; \\\n-\t    else \\\n-\t      skip=`expr $$skip + 1`; \\\n-\t      col=$$blu; res=SKIP; \\\n-\t    fi; \\\n-\t    echo \"$${col}$$res$${std}: $$tst\"; \\\n-\t  done; \\\n-\t  if test \"$$all\" -eq 1; then \\\n-\t    tests=\"test\"; \\\n-\t    All=\"\"; \\\n-\t  else \\\n-\t    tests=\"tests\"; \\\n-\t    All=\"All \"; \\\n-\t  fi; \\\n-\t  if test \"$$failed\" -eq 0; then \\\n-\t    if test \"$$xfail\" -eq 0; then \\\n-\t      banner=\"$$All$$all $$tests passed\"; \\\n-\t    else \\\n-\t      if test \"$$xfail\" -eq 1; then failures=failure; else failures=failures; fi; \\\n-\t      banner=\"$$All$$all $$tests behaved as expected ($$xfail expected $$failures)\"; \\\n-\t    fi; \\\n-\t  else \\\n-\t    if test \"$$xpass\" -eq 0; then \\\n-\t      banner=\"$$failed of $$all $$tests failed\"; \\\n-\t    else \\\n-\t      if test \"$$xpass\" -eq 1; then passes=pass; else passes=passes; fi; \\\n-\t      banner=\"$$failed of $$all $$tests did not behave as expected ($$xpass unexpected $$passes)\"; \\\n-\t    fi; \\\n-\t  fi; \\\n-\t  dashes=\"$$banner\"; \\\n-\t  skipped=\"\"; \\\n-\t  if test \"$$skip\" -ne 0; then \\\n-\t    if test \"$$skip\" -eq 1; then \\\n-\t      skipped=\"($$skip test was not run)\"; \\\n-\t    else \\\n-\t      skipped=\"($$skip tests were not run)\"; \\\n-\t    fi; \\\n-\t    test `echo \"$$skipped\" | wc -c` -le `echo \"$$banner\" | wc -c` || \\\n-\t      dashes=\"$$skipped\"; \\\n-\t  fi; \\\n-\t  report=\"\"; \\\n-\t  if test \"$$failed\" -ne 0 && test -n \"$(PACKAGE_BUGREPORT)\"; then \\\n-\t    report=\"Please report to $(PACKAGE_BUGREPORT)\"; \\\n-\t    test `echo \"$$report\" | wc -c` -le `echo \"$$banner\" | wc -c` || \\\n-\t      dashes=\"$$report\"; \\\n-\t  fi; \\\n-\t  dashes=`echo \"$$dashes\" | sed s/./=/g`; \\\n-\t  if test \"$$failed\" -eq 0; then \\\n-\t    col=\"$$grn\"; \\\n-\t  else \\\n-\t    col=\"$$red\"; \\\n-\t  fi; \\\n-\t  echo \"$${col}$$dashes$${std}\"; \\\n-\t  echo \"$${col}$$banner$${std}\"; \\\n-\t  test -z \"$$skipped\" || echo \"$${col}$$skipped$${std}\"; \\\n-\t  test -z \"$$report\" || echo \"$${col}$$report$${std}\"; \\\n-\t  echo \"$${col}$$dashes$${std}\"; \\\n-\t  test \"$$failed\" -eq 0; \\\n-\telse :; fi\n-check-am: all-am\n-\t$(MAKE) $(AM_MAKEFLAGS) $(check_PROGRAMS)\n-\t$(MAKE) $(AM_MAKEFLAGS) check-TESTS\n-check: check-am\n-all-am: Makefile $(LTLIBRARIES) all-multi config.h\n-installdirs:\n-install: install-am\n-install-exec: install-exec-am\n-install-data: install-data-am\n-uninstall: uninstall-am\n-\n-install-am: all-am\n-\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n-\n-installcheck: installcheck-am\n-install-strip:\n-\tif test -z '$(STRIP)'; then \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t      install; \\\n-\telse \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t    \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\" install; \\\n-\tfi\n-mostlyclean-generic:\n-\n-clean-generic:\n-\n-distclean-generic:\n-\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n-\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n-\n-maintainer-clean-generic:\n-\t@echo \"This command is intended for maintainers to use\"\n-\t@echo \"it deletes files that may require special tools to rebuild.\"\n-clean: clean-am clean-multi\n-\n-clean-am: clean-checkPROGRAMS clean-generic clean-libtool \\\n-\tclean-noinstLTLIBRARIES mostlyclean-am\n-\n-distclean: distclean-am distclean-multi\n-\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -f Makefile\n-distclean-am: clean-am distclean-compile distclean-generic \\\n-\tdistclean-hdr distclean-libtool distclean-tags\n-\n-dvi: dvi-am\n-\n-dvi-am:\n-\n-html: html-am\n-\n-html-am:\n-\n-info: info-am\n-\n-info-am:\n-\n-install-data-am:\n-\n-install-dvi: install-dvi-am\n-\n-install-dvi-am:\n-\n-install-exec-am: install-multi\n-\n-install-html: install-html-am\n-\n-install-html-am:\n-\n-install-info: install-info-am\n-\n-install-info-am:\n-\n-install-man:\n-\n-install-pdf: install-pdf-am\n-\n-install-pdf-am:\n-\n-install-ps: install-ps-am\n-\n-install-ps-am:\n-\n-installcheck-am:\n-\n-maintainer-clean: maintainer-clean-am maintainer-clean-multi\n-\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf $(top_srcdir)/autom4te.cache\n-\t-rm -f Makefile\n-maintainer-clean-am: distclean-am maintainer-clean-generic\n-\n-mostlyclean: mostlyclean-am mostlyclean-multi\n-\n-mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n-\tmostlyclean-libtool\n-\n-pdf: pdf-am\n-\n-pdf-am:\n-\n-ps: ps-am\n-\n-ps-am:\n-\n-uninstall-am:\n-\n-.MAKE: all all-multi check-am clean-multi distclean-multi install-am \\\n-\tinstall-multi install-strip maintainer-clean-multi \\\n-\tmostlyclean-multi\n-\n-.PHONY: CTAGS GTAGS all all-am all-multi am--refresh check check-TESTS \\\n-\tcheck-am clean clean-checkPROGRAMS clean-generic clean-libtool \\\n-\tclean-multi clean-noinstLTLIBRARIES ctags distclean \\\n-\tdistclean-compile distclean-generic distclean-hdr \\\n-\tdistclean-libtool distclean-multi distclean-tags dvi dvi-am \\\n-\thtml html-am info info-am install install-am install-data \\\n-\tinstall-data-am install-dvi install-dvi-am install-exec \\\n-\tinstall-exec-am install-html install-html-am install-info \\\n-\tinstall-info-am install-man install-multi install-pdf \\\n-\tinstall-pdf-am install-ps install-ps-am install-strip \\\n-\tinstallcheck installcheck-am installdirs maintainer-clean \\\n-\tmaintainer-clean-generic maintainer-clean-multi mostlyclean \\\n-\tmostlyclean-compile mostlyclean-generic mostlyclean-libtool \\\n-\tmostlyclean-multi pdf pdf-am ps ps-am tags uninstall \\\n-\tuninstall-am\n-\n-alloc.lo: config.h backtrace.h internal.h\n-backtrace.lo: config.h backtrace.h internal.h\n-btest.lo: (INCDIR)/filenames.h backtrace.h backtrace-supported.h\n-dwarf.lo: config.h $(INCDIR)/dwarf2.h $(INCDIR)/dwarf2.def \\\n-\t$(INCDIR)/filenames.h backtrace.h internal.h\n-elf.lo: config.h backtrace.h internal.h\n-fileline.lo: config.h backtrace.h internal.h\n-mmap.lo: config.h backtrace.h internal.h\n-mmapio.lo: config.h backtrace.h internal.h\n-nounwind.lo: config.h internal.h\n-pecoff.lo: config.h backtrace.h internal.h\n-posix.lo: config.h backtrace.h internal.h\n-print.lo: config.h backtrace.h internal.h\n-read.lo: config.h backtrace.h internal.h\n-simple.lo: config.h backtrace.h internal.h\n-sort.lo: config.h backtrace.h internal.h\n-stest.lo: config.h backtrace.h internal.h\n-state.lo: config.h backtrace.h backtrace-supported.h internal.h\n-unknown.lo: config.h backtrace.h internal.h\n-\n-# Tell versions [3.59,3.63) of GNU make to not export all variables.\n-# Otherwise a system limit (for SysV at least) may be exceeded.\n-.NOEXPORT:"}, {"sha": "e8b225745c9c639e67ea4f6fa0f97041ba978276", "filename": "src/libbacktrace/README", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FREADME?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,23 +0,0 @@\n-The libbacktrace library\n-Initially written by Ian Lance Taylor <iant@google.com>\n-\n-The libbacktrace library may be linked into a program or library and\n-used to produce symbolic backtraces.  Sample uses would be to print a\n-detailed backtrace when an error occurs or to gather detailed\n-profiling information.\n-\n-The libbacktrace library is provided under a BSD license.  See the\n-source files for the exact license text.\n-\n-The public functions are declared and documented in the header file\n-backtrace.h, which should be #include'd by a user of the library.\n-\n-Building libbacktrace will generate a file backtrace-supported.h,\n-which a user of the library may use to determine whether backtraces\n-will work.  See the source file backtrace-supported.h.in for the\n-macros that it defines.\n-\n-As of September 2012, libbacktrace only supports ELF executables with\n-DWARF debugging information.  The library is written to make it\n-straightforward to add support for other object file and debugging\n-formats."}, {"sha": "8e84ddd1f10132210a49e7d08ba522e09df3a8ad", "filename": "src/libbacktrace/aclocal.m4", "status": "removed", "additions": 0, "deletions": 683, "changes": 683, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Faclocal.m4", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Faclocal.m4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Faclocal.m4?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,683 +0,0 @@\n-# generated automatically by aclocal 1.11.6 -*- Autoconf -*-\n-\n-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-# 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation,\n-# Inc.\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-m4_ifndef([AC_AUTOCONF_VERSION],\n-  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n-m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.64],,\n-[m4_warning([this file was generated for autoconf 2.64.\n-You have another version of autoconf.  It may work, but is not guaranteed to.\n-If you have problems, you may need to regenerate the build system entirely.\n-To do so, use the procedure documented by the package, typically `autoreconf'.])])\n-\n-# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008, 2011 Free Software\n-# Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 1\n-\n-# AM_AUTOMAKE_VERSION(VERSION)\n-# ----------------------------\n-# Automake X.Y traces this macro to ensure aclocal.m4 has been\n-# generated from the m4 files accompanying Automake X.Y.\n-# (This private macro should not be called outside this file.)\n-AC_DEFUN([AM_AUTOMAKE_VERSION],\n-[am__api_version='1.11'\n-dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\n-dnl require some minimum version.  Point them to the right macro.\n-m4_if([$1], [1.11.6], [],\n-      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n-])\n-\n-# _AM_AUTOCONF_VERSION(VERSION)\n-# -----------------------------\n-# aclocal traces this macro to find the Autoconf version.\n-# This is a private macro too.  Using m4_define simplifies\n-# the logic in aclocal, which can simply ignore this definition.\n-m4_define([_AM_AUTOCONF_VERSION], [])\n-\n-# AM_SET_CURRENT_AUTOMAKE_VERSION\n-# -------------------------------\n-# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n-# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.\n-AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n-[AM_AUTOMAKE_VERSION([1.11.6])dnl\n-m4_ifndef([AC_AUTOCONF_VERSION],\n-  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n-_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])\n-\n-# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n-\n-# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 1\n-\n-# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n-# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to\n-# `$srcdir', `$srcdir/..', or `$srcdir/../..'.\n-#\n-# Of course, Automake must honor this variable whenever it calls a\n-# tool from the auxiliary directory.  The problem is that $srcdir (and\n-# therefore $ac_aux_dir as well) can be either absolute or relative,\n-# depending on how configure is run.  This is pretty annoying, since\n-# it makes $ac_aux_dir quite unusable in subdirectories: in the top\n-# source directory, any form will work fine, but in subdirectories a\n-# relative path needs to be adjusted first.\n-#\n-# $ac_aux_dir/missing\n-#    fails when called from a subdirectory if $ac_aux_dir is relative\n-# $top_srcdir/$ac_aux_dir/missing\n-#    fails if $ac_aux_dir is absolute,\n-#    fails when called from a subdirectory in a VPATH build with\n-#          a relative $ac_aux_dir\n-#\n-# The reason of the latter failure is that $top_srcdir and $ac_aux_dir\n-# are both prefixed by $srcdir.  In an in-source build this is usually\n-# harmless because $srcdir is `.', but things will broke when you\n-# start a VPATH build or use an absolute $srcdir.\n-#\n-# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,\n-# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:\n-#   am_aux_dir='\\$(top_srcdir)/'`expr \"$ac_aux_dir\" : \"$srcdir//*\\(.*\\)\"`\n-# and then we would define $MISSING as\n-#   MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n-# This will work as long as MISSING is not called from configure, because\n-# unfortunately $(top_srcdir) has no meaning in configure.\n-# However there are other variables, like CC, which are often used in\n-# configure, and could therefore not use this \"fixed\" $ac_aux_dir.\n-#\n-# Another solution, used here, is to always expand $ac_aux_dir to an\n-# absolute PATH.  The drawback is that using absolute paths prevent a\n-# configured tree to be moved without reconfiguration.\n-\n-AC_DEFUN([AM_AUX_DIR_EXPAND],\n-[dnl Rely on autoconf to set up CDPATH properly.\n-AC_PREREQ([2.50])dnl\n-# expand $ac_aux_dir to an absolute path\n-am_aux_dir=`cd $ac_aux_dir && pwd`\n-])\n-\n-# AM_CONDITIONAL                                            -*- Autoconf -*-\n-\n-# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008\n-# Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 9\n-\n-# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n-# -------------------------------------\n-# Define a conditional.\n-AC_DEFUN([AM_CONDITIONAL],\n-[AC_PREREQ(2.52)dnl\n- ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n-\t[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\n-AC_SUBST([$1_TRUE])dnl\n-AC_SUBST([$1_FALSE])dnl\n-_AM_SUBST_NOTMAKE([$1_TRUE])dnl\n-_AM_SUBST_NOTMAKE([$1_FALSE])dnl\n-m4_define([_AM_COND_VALUE_$1], [$2])dnl\n-if $2; then\n-  $1_TRUE=\n-  $1_FALSE='#'\n-else\n-  $1_TRUE='#'\n-  $1_FALSE=\n-fi\n-AC_CONFIG_COMMANDS_PRE(\n-[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n-  AC_MSG_ERROR([[conditional \"$1\" was never defined.\n-Usually this means the macro was only invoked conditionally.]])\n-fi])])\n-\n-# Do all the work for Automake.                             -*- Autoconf -*-\n-\n-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-# 2005, 2006, 2008, 2009 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 16\n-\n-# This macro actually does too much.  Some checks are only needed if\n-# your package does certain things.  But this isn't really a big deal.\n-\n-# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])\n-# AM_INIT_AUTOMAKE([OPTIONS])\n-# -----------------------------------------------\n-# The call with PACKAGE and VERSION arguments is the old style\n-# call (pre autoconf-2.50), which is being phased out.  PACKAGE\n-# and VERSION should now be passed to AC_INIT and removed from\n-# the call to AM_INIT_AUTOMAKE.\n-# We support both call styles for the transition.  After\n-# the next Automake release, Autoconf can make the AC_INIT\n-# arguments mandatory, and then we can depend on a new Autoconf\n-# release and drop the old call support.\n-AC_DEFUN([AM_INIT_AUTOMAKE],\n-[AC_PREREQ([2.62])dnl\n-dnl Autoconf wants to disallow AM_ names.  We explicitly allow\n-dnl the ones we care about.\n-m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl\n-AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl\n-AC_REQUIRE([AC_PROG_INSTALL])dnl\n-if test \"`cd $srcdir && pwd`\" != \"`pwd`\"; then\n-  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output\n-  # is not polluted with repeated \"-I.\"\n-  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl\n-  # test to see if srcdir already configured\n-  if test -f $srcdir/config.status; then\n-    AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n-  fi\n-fi\n-\n-# test whether we have cygpath\n-if test -z \"$CYGPATH_W\"; then\n-  if (cygpath --version) >/dev/null 2>/dev/null; then\n-    CYGPATH_W='cygpath -w'\n-  else\n-    CYGPATH_W=echo\n-  fi\n-fi\n-AC_SUBST([CYGPATH_W])\n-\n-# Define the identity of the package.\n-dnl Distinguish between old-style and new-style calls.\n-m4_ifval([$2],\n-[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl\n- AC_SUBST([PACKAGE], [$1])dnl\n- AC_SUBST([VERSION], [$2])],\n-[_AM_SET_OPTIONS([$1])dnl\n-dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.\n-m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,\n-  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl\n- AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl\n- AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl\n-\n-_AM_IF_OPTION([no-define],,\n-[AC_DEFINE_UNQUOTED(PACKAGE, \"$PACKAGE\", [Name of package])\n- AC_DEFINE_UNQUOTED(VERSION, \"$VERSION\", [Version number of package])])dnl\n-\n-# Some tools Automake needs.\n-AC_REQUIRE([AM_SANITY_CHECK])dnl\n-AC_REQUIRE([AC_ARG_PROGRAM])dnl\n-AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})\n-AM_MISSING_PROG(AUTOCONF, autoconf)\n-AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})\n-AM_MISSING_PROG(AUTOHEADER, autoheader)\n-AM_MISSING_PROG(MAKEINFO, makeinfo)\n-AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n-AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl\n-AC_REQUIRE([AM_PROG_MKDIR_P])dnl\n-# We need awk for the \"check\" target.  The system \"awk\" is bad on\n-# some platforms.\n-AC_REQUIRE([AC_PROG_AWK])dnl\n-AC_REQUIRE([AC_PROG_MAKE_SET])dnl\n-AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n-_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],\n-\t      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],\n-\t\t\t     [_AM_PROG_TAR([v7])])])\n-_AM_IF_OPTION([no-dependencies],,\n-[AC_PROVIDE_IFELSE([AC_PROG_CC],\n-\t\t  [_AM_DEPENDENCIES(CC)],\n-\t\t  [define([AC_PROG_CC],\n-\t\t\t  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl\n-AC_PROVIDE_IFELSE([AC_PROG_CXX],\n-\t\t  [_AM_DEPENDENCIES(CXX)],\n-\t\t  [define([AC_PROG_CXX],\n-\t\t\t  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl\n-AC_PROVIDE_IFELSE([AC_PROG_OBJC],\n-\t\t  [_AM_DEPENDENCIES(OBJC)],\n-\t\t  [define([AC_PROG_OBJC],\n-\t\t\t  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl\n-])\n-_AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl\n-dnl The `parallel-tests' driver may need to know about EXEEXT, so add the\n-dnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro\n-dnl is hooked onto _AC_COMPILER_EXEEXT early, see below.\n-AC_CONFIG_COMMANDS_PRE(dnl\n-[m4_provide_if([_AM_COMPILER_EXEEXT],\n-  [AM_CONDITIONAL([am__EXEEXT], [test -n \"$EXEEXT\"])])])dnl\n-])\n-\n-dnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not\n-dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further\n-dnl mangled by Autoconf and run in a shell conditional statement.\n-m4_define([_AC_COMPILER_EXEEXT],\n-m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])\n-\n-\n-# When config.status generates a header, we must update the stamp-h file.\n-# This file resides in the same directory as the config header\n-# that is generated.  The stamp files are numbered to have different names.\n-\n-# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the\n-# loop where config.status creates the headers, so we can generate\n-# our stamp files there.\n-AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],\n-[# Compute $1's index in $config_headers.\n-_am_arg=$1\n-_am_stamp_count=1\n-for _am_header in $config_headers :; do\n-  case $_am_header in\n-    $_am_arg | $_am_arg:* )\n-      break ;;\n-    * )\n-      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n-  esac\n-done\n-echo \"timestamp for $_am_arg\" >`AS_DIRNAME([\"$_am_arg\"])`/stamp-h[]$_am_stamp_count])\n-\n-# Copyright (C) 2001, 2003, 2005, 2008, 2011 Free Software Foundation,\n-# Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 1\n-\n-# AM_PROG_INSTALL_SH\n-# ------------------\n-# Define $install_sh.\n-AC_DEFUN([AM_PROG_INSTALL_SH],\n-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n-if test x\"${install_sh}\" != xset; then\n-  case $am_aux_dir in\n-  *\\ * | *\\\t*)\n-    install_sh=\"\\${SHELL} '$am_aux_dir/install-sh'\" ;;\n-  *)\n-    install_sh=\"\\${SHELL} $am_aux_dir/install-sh\"\n-  esac\n-fi\n-AC_SUBST(install_sh)])\n-\n-# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-\n-# From Jim Meyering\n-\n-# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008,\n-# 2011 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 5\n-\n-# AM_MAINTAINER_MODE([DEFAULT-MODE])\n-# ----------------------------------\n-# Control maintainer-specific portions of Makefiles.\n-# Default is to disable them, unless `enable' is passed literally.\n-# For symmetry, `disable' may be passed as well.  Anyway, the user\n-# can override the default with the --enable/--disable switch.\n-AC_DEFUN([AM_MAINTAINER_MODE],\n-[m4_case(m4_default([$1], [disable]),\n-       [enable], [m4_define([am_maintainer_other], [disable])],\n-       [disable], [m4_define([am_maintainer_other], [enable])],\n-       [m4_define([am_maintainer_other], [enable])\n-        m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])\n-AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])\n-  dnl maintainer-mode's default is 'disable' unless 'enable' is passed\n-  AC_ARG_ENABLE([maintainer-mode],\n-[  --][am_maintainer_other][-maintainer-mode  am_maintainer_other make rules and dependencies not useful\n-\t\t\t  (and sometimes confusing) to the casual installer],\n-      [USE_MAINTAINER_MODE=$enableval],\n-      [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))\n-  AC_MSG_RESULT([$USE_MAINTAINER_MODE])\n-  AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])\n-  MAINT=$MAINTAINER_MODE_TRUE\n-  AC_SUBST([MAINT])dnl\n-]\n-)\n-\n-AU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])\n-\n-# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n-\n-# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008\n-# Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 6\n-\n-# AM_MISSING_PROG(NAME, PROGRAM)\n-# ------------------------------\n-AC_DEFUN([AM_MISSING_PROG],\n-[AC_REQUIRE([AM_MISSING_HAS_RUN])\n-$1=${$1-\"${am_missing_run}$2\"}\n-AC_SUBST($1)])\n-\n-\n-# AM_MISSING_HAS_RUN\n-# ------------------\n-# Define MISSING if not defined so far and test if it supports --run.\n-# If it does, set am_missing_run to use it, otherwise, to nothing.\n-AC_DEFUN([AM_MISSING_HAS_RUN],\n-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n-AC_REQUIRE_AUX_FILE([missing])dnl\n-if test x\"${MISSING+set}\" != xset; then\n-  case $am_aux_dir in\n-  *\\ * | *\\\t*)\n-    MISSING=\"\\${SHELL} \\\"$am_aux_dir/missing\\\"\" ;;\n-  *)\n-    MISSING=\"\\${SHELL} $am_aux_dir/missing\" ;;\n-  esac\n-fi\n-# Use eval to expand $SHELL\n-if eval \"$MISSING --run true\"; then\n-  am_missing_run=\"$MISSING --run \"\n-else\n-  am_missing_run=\n-  AC_MSG_WARN([`missing' script is too old or missing])\n-fi\n-])\n-\n-# Copyright (C) 2003, 2004, 2005, 2006, 2011 Free Software Foundation,\n-# Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 1\n-\n-# AM_PROG_MKDIR_P\n-# ---------------\n-# Check for `mkdir -p'.\n-AC_DEFUN([AM_PROG_MKDIR_P],\n-[AC_PREREQ([2.60])dnl\n-AC_REQUIRE([AC_PROG_MKDIR_P])dnl\n-dnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,\n-dnl while keeping a definition of mkdir_p for backward compatibility.\n-dnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.\n-dnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of\n-dnl Makefile.ins that do not define MKDIR_P, so we do our own\n-dnl adjustment using top_builddir (which is defined more often than\n-dnl MKDIR_P).\n-AC_SUBST([mkdir_p], [\"$MKDIR_P\"])dnl\n-case $mkdir_p in\n-  [[\\\\/$]]* | ?:[[\\\\/]]*) ;;\n-  */*) mkdir_p=\"\\$(top_builddir)/$mkdir_p\" ;;\n-esac\n-])\n-\n-# Helper functions for option handling.                     -*- Autoconf -*-\n-\n-# Copyright (C) 2001, 2002, 2003, 2005, 2008, 2010 Free Software\n-# Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 5\n-\n-# _AM_MANGLE_OPTION(NAME)\n-# -----------------------\n-AC_DEFUN([_AM_MANGLE_OPTION],\n-[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n-\n-# _AM_SET_OPTION(NAME)\n-# --------------------\n-# Set option NAME.  Presently that only means defining a flag for this option.\n-AC_DEFUN([_AM_SET_OPTION],\n-[m4_define(_AM_MANGLE_OPTION([$1]), 1)])\n-\n-# _AM_SET_OPTIONS(OPTIONS)\n-# ------------------------\n-# OPTIONS is a space-separated list of Automake options.\n-AC_DEFUN([_AM_SET_OPTIONS],\n-[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n-\n-# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])\n-# -------------------------------------------\n-# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\n-AC_DEFUN([_AM_IF_OPTION],\n-[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n-\n-# Check to make sure that the build environment is sane.    -*- Autoconf -*-\n-\n-# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008\n-# Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 5\n-\n-# AM_SANITY_CHECK\n-# ---------------\n-AC_DEFUN([AM_SANITY_CHECK],\n-[AC_MSG_CHECKING([whether build environment is sane])\n-# Just in case\n-sleep 1\n-echo timestamp > conftest.file\n-# Reject unsafe characters in $srcdir or the absolute working directory\n-# name.  Accept space and tab only in the latter.\n-am_lf='\n-'\n-case `pwd` in\n-  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf]]*)\n-    AC_MSG_ERROR([unsafe absolute working directory name]);;\n-esac\n-case $srcdir in\n-  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf\\ \\\t]]*)\n-    AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;\n-esac\n-\n-# Do `set' in a subshell so we don't clobber the current shell's\n-# arguments.  Must try -L first in case configure is actually a\n-# symlink; some systems play weird games with the mod time of symlinks\n-# (eg FreeBSD returns the mod time of the symlink's containing\n-# directory).\n-if (\n-   set X `ls -Lt \"$srcdir/configure\" conftest.file 2> /dev/null`\n-   if test \"$[*]\" = \"X\"; then\n-      # -L didn't work.\n-      set X `ls -t \"$srcdir/configure\" conftest.file`\n-   fi\n-   rm -f conftest.file\n-   if test \"$[*]\" != \"X $srcdir/configure conftest.file\" \\\n-      && test \"$[*]\" != \"X conftest.file $srcdir/configure\"; then\n-\n-      # If neither matched, then we have a broken ls.  This can happen\n-      # if, for instance, CONFIG_SHELL is bash and it inherits a\n-      # broken ls alias from the environment.  This has actually\n-      # happened.  Such a system could not be considered \"sane\".\n-      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken\n-alias in your environment])\n-   fi\n-\n-   test \"$[2]\" = conftest.file\n-   )\n-then\n-   # Ok.\n-   :\n-else\n-   AC_MSG_ERROR([newly created file is older than distributed files!\n-Check your system clock])\n-fi\n-AC_MSG_RESULT(yes)])\n-\n-# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 1\n-\n-# AM_PROG_INSTALL_STRIP\n-# ---------------------\n-# One issue with vendor `install' (even GNU) is that you can't\n-# specify the program used to strip binaries.  This is especially\n-# annoying in cross-compiling environments, where the build's strip\n-# is unlikely to handle the host's binaries.\n-# Fortunately install-sh will honor a STRIPPROG variable, so we\n-# always use install-sh in `make install-strip', and initialize\n-# STRIPPROG with the value of the STRIP variable (set by the user).\n-AC_DEFUN([AM_PROG_INSTALL_STRIP],\n-[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n-# Installed binaries are usually stripped using `strip' when the user\n-# run `make install-strip'.  However `strip' might not be the right\n-# tool to use in cross-compilation environments, therefore Automake\n-# will honor the `STRIP' environment variable to overrule this program.\n-dnl Don't test for $cross_compiling = yes, because it might be `maybe'.\n-if test \"$cross_compiling\" != no; then\n-  AC_CHECK_TOOL([STRIP], [strip], :)\n-fi\n-INSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\n-AC_SUBST([INSTALL_STRIP_PROGRAM])])\n-\n-# Copyright (C) 2006, 2008, 2010 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 3\n-\n-# _AM_SUBST_NOTMAKE(VARIABLE)\n-# ---------------------------\n-# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.\n-# This macro is traced by Automake.\n-AC_DEFUN([_AM_SUBST_NOTMAKE])\n-\n-# AM_SUBST_NOTMAKE(VARIABLE)\n-# --------------------------\n-# Public sister of _AM_SUBST_NOTMAKE.\n-AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n-\n-# Check how to create a tarball.                            -*- Autoconf -*-\n-\n-# Copyright (C) 2004, 2005, 2012 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 2\n-\n-# _AM_PROG_TAR(FORMAT)\n-# --------------------\n-# Check how to create a tarball in format FORMAT.\n-# FORMAT should be one of `v7', `ustar', or `pax'.\n-#\n-# Substitute a variable $(am__tar) that is a command\n-# writing to stdout a FORMAT-tarball containing the directory\n-# $tardir.\n-#     tardir=directory && $(am__tar) > result.tar\n-#\n-# Substitute a variable $(am__untar) that extract such\n-# a tarball read from stdin.\n-#     $(am__untar) < result.tar\n-AC_DEFUN([_AM_PROG_TAR],\n-[# Always define AMTAR for backward compatibility.  Yes, it's still used\n-# in the wild :-(  We should find a proper way to deprecate it ...\n-AC_SUBST([AMTAR], ['$${TAR-tar}'])\n-m4_if([$1], [v7],\n-     [am__tar='$${TAR-tar} chof - \"$$tardir\"' am__untar='$${TAR-tar} xf -'],\n-     [m4_case([$1], [ustar],, [pax],,\n-              [m4_fatal([Unknown tar format])])\n-AC_MSG_CHECKING([how to create a $1 tar archive])\n-# Loop over all known methods to create a tar archive until one works.\n-_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'\n-_am_tools=${am_cv_prog_tar_$1-$_am_tools}\n-# Do not fold the above two line into one, because Tru64 sh and\n-# Solaris sh will not grok spaces in the rhs of `-'.\n-for _am_tool in $_am_tools\n-do\n-  case $_am_tool in\n-  gnutar)\n-    for _am_tar in tar gnutar gtar;\n-    do\n-      AM_RUN_LOG([$_am_tar --version]) && break\n-    done\n-    am__tar=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$$tardir\"'\n-    am__tar_=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$tardir\"'\n-    am__untar=\"$_am_tar -xf -\"\n-    ;;\n-  plaintar)\n-    # Must skip GNU tar: if it does not support --format= it doesn't create\n-    # ustar tarball either.\n-    (tar --version) >/dev/null 2>&1 && continue\n-    am__tar='tar chf - \"$$tardir\"'\n-    am__tar_='tar chf - \"$tardir\"'\n-    am__untar='tar xf -'\n-    ;;\n-  pax)\n-    am__tar='pax -L -x $1 -w \"$$tardir\"'\n-    am__tar_='pax -L -x $1 -w \"$tardir\"'\n-    am__untar='pax -r'\n-    ;;\n-  cpio)\n-    am__tar='find \"$$tardir\" -print | cpio -o -H $1 -L'\n-    am__tar_='find \"$tardir\" -print | cpio -o -H $1 -L'\n-    am__untar='cpio -i -H $1 -d'\n-    ;;\n-  none)\n-    am__tar=false\n-    am__tar_=false\n-    am__untar=false\n-    ;;\n-  esac\n-\n-  # If the value was cached, stop now.  We just wanted to have am__tar\n-  # and am__untar set.\n-  test -n \"${am_cv_prog_tar_$1}\" && break\n-\n-  # tar/untar a dummy directory, and stop if the command works\n-  rm -rf conftest.dir\n-  mkdir conftest.dir\n-  echo GrepMe > conftest.dir/file\n-  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])\n-  rm -rf conftest.dir\n-  if test -s conftest.tar; then\n-    AM_RUN_LOG([$am__untar <conftest.tar])\n-    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break\n-  fi\n-done\n-rm -rf conftest.dir\n-\n-AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])\n-AC_MSG_RESULT([$am_cv_prog_tar_$1])])\n-AC_SUBST([am__tar])\n-AC_SUBST([am__untar])\n-]) # _AM_PROG_TAR\n-\n-m4_include([../config/lead-dot.m4])\n-m4_include([../config/multi.m4])\n-m4_include([../config/override.m4])\n-m4_include([../config/stdint.m4])\n-m4_include([../config/unwind_ipinfo.m4])\n-m4_include([../config/warnings.m4])\n-m4_include([../libtool.m4])\n-m4_include([../ltoptions.m4])\n-m4_include([../ltsugar.m4])\n-m4_include([../ltversion.m4])\n-m4_include([../lt~obsolete.m4])"}, {"sha": "a9f07a013f8feec7a4508b7fc7189fb188c90031", "filename": "src/libbacktrace/alloc.c", "status": "removed", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Falloc.c", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Falloc.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Falloc.c?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec", "patch": "@@ -1,156 +0,0 @@\n-/* alloc.c -- Memory allocation without mmap.\n-   Copyright (C) 2012-2016 Free Software Foundation, Inc.\n-   Written by Ian Lance Taylor, Google.\n-\n-Redistribution and use in source and binary forms, with or without\n-modification, are permitted provided that the following conditions are\n-met:\n-\n-    (1) Redistributions of source code must retain the above copyright\n-    notice, this list of conditions and the following disclaimer. \n-\n-    (2) Redistributions in binary form must reproduce the above copyright\n-    notice, this list of conditions and the following disclaimer in\n-    the documentation and/or other materials provided with the\n-    distribution.  \n-    \n-    (3) The name of the author may not be used to\n-    endorse or promote products derived from this software without\n-    specific prior written permission.\n-\n-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n-DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n-SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n-STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n-IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-POSSIBILITY OF SUCH DAMAGE.  */\n-\n-#include \"config.h\"\n-\n-#include <errno.h>\n-#include <stdlib.h>\n-#include <sys/types.h>\n-\n-#include \"backtrace.h\"\n-#include \"internal.h\"\n-\n-/* Allocation routines to use on systems that do not support anonymous\n-   mmap.  This implementation just uses malloc, which means that the\n-   backtrace functions may not be safely invoked from a signal\n-   handler.  */\n-\n-/* Allocate memory like malloc.  If ERROR_CALLBACK is NULL, don't\n-   report an error.  */\n-\n-void *\n-backtrace_alloc (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-\t\t size_t size, backtrace_error_callback error_callback,\n-\t\t void *data)\n-{\n-  void *ret;\n-\n-  ret = malloc (size);\n-  if (ret == NULL)\n-    {\n-      if (error_callback)\n-\terror_callback (data, \"malloc\", errno);\n-    }\n-  return ret;\n-}\n-\n-/* Free memory.  */\n-\n-void\n-backtrace_free (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-\t\tvoid *p, size_t size ATTRIBUTE_UNUSED,\n-\t\tbacktrace_error_callback error_callback ATTRIBUTE_UNUSED,\n-\t\tvoid *data ATTRIBUTE_UNUSED)\n-{\n-  free (p);\n-}\n-\n-/* Grow VEC by SIZE bytes.  */\n-\n-void *\n-backtrace_vector_grow (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-\t\t       size_t size, backtrace_error_callback error_callback,\n-\t\t       void *data, struct backtrace_vector *vec)\n-{\n-  void *ret;\n-\n-  if (size > vec->alc)\n-    {\n-      size_t alc;\n-      void *base;\n-\n-      if (vec->size == 0)\n-\talc = 32 * size;\n-      else if (vec->size >= 4096)\n-\talc = vec->size + 4096;\n-      else\n-\talc = 2 * vec->size;\n-\n-      if (alc < vec->size + size)\n-\talc = vec->size + size;\n-\n-      base = realloc (vec->base, alc);\n-      if (base == NULL)\n-\t{\n-\t  error_callback (data, \"realloc\", errno);\n-\t  return NULL;\n-\t}\n-\n-      vec->base = base;\n-      vec->alc = alc - vec->size;\n-    }\n-\n-  ret = (char *) vec->base + vec->size;\n-  vec->size += size;\n-  vec->alc -= size;\n-  return ret;\n-}\n-\n-/* Finish the current allocation on VEC.  */\n-\n-void *\n-backtrace_vector_finish (struct backtrace_state *state,\n-\t\t\t struct backtrace_vector *vec,\n-\t\t\t backtrace_error_callback error_callback,\n-\t\t\t void *data)\n-{\n-  void *ret;\n-\n-  /* With this allocator we call realloc in backtrace_vector_grow,\n-     which means we can't easily reuse the memory here.  So just\n-     release it.  */\n-  if (!backtrace_vector_release (state, vec, error_callback, data))\n-    return NULL;\n-  ret = vec->base;\n-  vec->base = NULL;\n-  vec->size = 0;\n-  vec->alc = 0;\n-  return ret;\n-}\n-\n-/* Release any extra space allocated for VEC.  */\n-\n-int\n-backtrace_vector_release (struct backtrace_state *state ATTRIBUTE_UNUSED,\n-\t\t\t  struct backtrace_vector *vec,\n-\t\t\t  backtrace_error_callback error_callback,\n-\t\t\t  void *data)\n-{\n-  vec->base = realloc (vec->base, vec->size);\n-  if (vec->base == NULL)\n-    {\n-      error_callback (data, \"realloc\", errno);\n-      return 0;\n-    }\n-  vec->alc = 0;\n-  return 1;\n-}"}, {"sha": "4087dd729175082d6e00f7371b4fbab18236aa78", "filename": "src/libbacktrace/ansidecl.h", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fansidecl.h", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fansidecl.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fansidecl.h?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "cb0ad0298e68a4bd3fc92ca20efadde0d1a0a8ca", "filename": "src/libbacktrace/atomic.c", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fatomic.c", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fatomic.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fatomic.c?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "ab34199fcd362cceefb43d28f2c28daad07cc1f8", "filename": "src/libbacktrace/backtrace-supported.h.in", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fbacktrace-supported.h.in", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fbacktrace-supported.h.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbacktrace-supported.h.in?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "b89bf554ac548d2ab2a88fe65aa3907ac354e4a8", "filename": "src/libbacktrace/backtrace.c", "status": "removed", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fbacktrace.c", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fbacktrace.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbacktrace.c?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "d209219d9a419ea82a723d4a4bf4282a7a900a83", "filename": "src/libbacktrace/backtrace.h", "status": "removed", "additions": 0, "deletions": 199, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fbacktrace.h", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fbacktrace.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbacktrace.h?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "0506d2b112186b7b61fa89b3e2ec20b7286a699b", "filename": "src/libbacktrace/btest.c", "status": "removed", "additions": 0, "deletions": 721, "changes": 721, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fbtest.c", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fbtest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbtest.c?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "87cb805984d4f06782ed96a509fe18a290377f33", "filename": "src/libbacktrace/config.h.in", "status": "removed", "additions": 0, "deletions": 134, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fconfig.h.in", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfig.h.in?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "40ea5dfe1152f0fc5160879bb71bfe1fae2595f6", "filename": "src/libbacktrace/config.sub", "status": "removed", "additions": 0, "deletions": 1836, "changes": 1836, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fconfig.sub", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fconfig.sub", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfig.sub?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "8bdb29d25606f81756b37437032f286dadcad96d", "filename": "src/libbacktrace/configure", "status": "removed", "additions": 0, "deletions": 15199, "changes": 15199, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fconfigure", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fconfigure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfigure?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "ea1b27d807e13d9741f4fa7821f16e6f2e0006c3", "filename": "src/libbacktrace/configure.ac", "status": "removed", "additions": 0, "deletions": 418, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fconfigure.ac", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfigure.ac?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "55b8d7dc2a56d96e69df0a1be6728bad212754c7", "filename": "src/libbacktrace/dwarf.c", "status": "removed", "additions": 0, "deletions": 3038, "changes": 3038, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fdwarf.c", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fdwarf.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fdwarf.c?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "2dfee5666dea68d8292f04c5100c93e1f1fcf4f4", "filename": "src/libbacktrace/dwarf2.def", "status": "removed", "additions": 0, "deletions": 713, "changes": 713, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fdwarf2.def", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fdwarf2.def", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fdwarf2.def?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "4ada87162fa868eb80c6994e1877c6d9897ae732", "filename": "src/libbacktrace/dwarf2.h", "status": "removed", "additions": 0, "deletions": 430, "changes": 430, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fdwarf2.h", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fdwarf2.h?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "81ba3440ab7d18539180f53805ac36c408284a66", "filename": "src/libbacktrace/elf.c", "status": "removed", "additions": 0, "deletions": 979, "changes": 979, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Felf.c", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Felf.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Felf.c?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "27ebbedc21ccf39f86f439138c2e418b556ccbd8", "filename": "src/libbacktrace/fileline.c", "status": "removed", "additions": 0, "deletions": 194, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Ffileline.c", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Ffileline.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Ffileline.c?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "1161daaa4f3581c81c4842509aa7c7298d3bbd7b", "filename": "src/libbacktrace/filenames.h", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Ffilenames.h", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Ffilenames.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Ffilenames.h?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "a5f6c8cc1800f0cb24d415cade2b0905f54a730f", "filename": "src/libbacktrace/filetype.awk", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Ffiletype.awk", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Ffiletype.awk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Ffiletype.awk?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "b1b5877aae7ca83dd2f04cc050c352b82e4a8d35", "filename": "src/libbacktrace/hashtab.h", "status": "removed", "additions": 0, "deletions": 204, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fhashtab.h", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fhashtab.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fhashtab.h?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "0b0fdcbba69ab6dd05ca162a5328828d46ab1d54", "filename": "src/libbacktrace/install-sh", "status": "removed", "additions": 0, "deletions": 501, "changes": 501, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Finstall-sh", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Finstall-sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Finstall-sh?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "73728da3f5664db0306a9ffd6e23066fff2df45d", "filename": "src/libbacktrace/internal.h", "status": "removed", "additions": 0, "deletions": 294, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Finternal.h", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Finternal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Finternal.h?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "fd23815fc617a5cb8f77cdc4e95a3d177db97cbb", "filename": "src/libbacktrace/ltmain.sh", "status": "removed", "additions": 0, "deletions": 8636, "changes": 8636, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fltmain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fltmain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fltmain.sh?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "ba7f94c079f8a8e3c227093524d8a725b1978ae9", "filename": "src/libbacktrace/macho.c", "status": "removed", "additions": 0, "deletions": 1416, "changes": 1416, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fmacho.c", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fmacho.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fmacho.c?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "138ef70711a02597b6e843516d84c687f9aef753", "filename": "src/libbacktrace/mmap.c", "status": "removed", "additions": 0, "deletions": 303, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fmmap.c", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fmmap.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fmmap.c?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "dfdaf6fa52e6e774c1c59e5b4509b8c54a7e110a", "filename": "src/libbacktrace/mmapio.c", "status": "removed", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fmmapio.c", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fmmapio.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fmmapio.c?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "448a2049f1d1b46aa393f3b17e60d9a799181fc4", "filename": "src/libbacktrace/nounwind.c", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fnounwind.c", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fnounwind.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fnounwind.c?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "2d6a9877219dcacac0a2fe31f6c4fe83193804e1", "filename": "src/libbacktrace/pecoff.c", "status": "removed", "additions": 0, "deletions": 942, "changes": 942, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fpecoff.c", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fpecoff.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fpecoff.c?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "09f5e95a6e42d824b1ef09d3d4ff489e61644f58", "filename": "src/libbacktrace/posix.c", "status": "removed", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fposix.c", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fposix.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fposix.c?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "74c8fcbee5a1f9bc853a0bb6e3607a15a20f9dba", "filename": "src/libbacktrace/print.c", "status": "removed", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fprint.c", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fprint.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fprint.c?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "7f0317c3a8ce91e3de6c8bc95cae597e3163faf2", "filename": "src/libbacktrace/read.c", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fread.c", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fread.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fread.c?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "018773a7e5dbdb66de407529f2508a5cd5769b54", "filename": "src/libbacktrace/simple.c", "status": "removed", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fsimple.c", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fsimple.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fsimple.c?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "68a7df65a47f6e4cd8bcc9171410c269b462033e", "filename": "src/libbacktrace/sort.c", "status": "removed", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fsort.c", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fsort.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fsort.c?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "93420d9c61b19939ebd28d4fe0dccae745d2af57", "filename": "src/libbacktrace/state.c", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fstate.c", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fstate.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fstate.c?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "55ec31d10bc8168343550e57a71da06dbd5f64fd", "filename": "src/libbacktrace/stest.c", "status": "removed", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fstest.c", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Fstest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fstest.c?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "8d06c31549f70a0fbfa049bd9eda0921591b4a31", "filename": "src/libbacktrace/unknown.c", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Funknown.c", "raw_url": "https://github.com/rust-lang/rust/raw/6a78c0a10f2e719117fe4bb929bfb38549acfeec/src%2Flibbacktrace%2Funknown.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Funknown.c?ref=6a78c0a10f2e719117fe4bb929bfb38549acfeec"}, {"sha": "52a6a4d7087d14a35d44a11c39c77fa79d71378d", "filename": "src/libcompiler_builtins", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "321ed892ea9a986337baa7ea902215e27202f816", "filename": "src/libcore/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2FCargo.toml?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "b6ac248b79f8666331ab77c82d7aa9d311b188ff", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 296, "deletions": 154, "changes": 450, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "6b26093439e4f509925d0be5eff19329f554b6b8", "filename": "src/libcore/any.rs", "status": "modified", "additions": 98, "deletions": 8, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "6ee91e0b22ff09bd9b0879df889d634f06bad365", "filename": "src/libcore/ascii.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fascii.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "137e9fe2c1533e251a09e54c6c0a86879c7d4332", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 245, "deletions": 82, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "0b8dce19dffa1c053437ce55f3da3cd36760a027", "filename": "src/libcore/char/decode.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fchar%2Fdecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fchar%2Fdecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fdecode.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "eee78de903628cee1514f40a0dc86315637dc210", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "59bcf1383f47a27580a05cd6c9fa8f4bd15f0c84", "filename": "src/libcore/char/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmod.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "3b15ba2b4ab1fbc5167e73d73808191a6467b9de", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "3626a266ad5d3f0d86cd059ede2c21fbae92c816", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "11cc4ffecf0055af511be82a17af07b08ecf626d", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "3c5f934d4d8c795ce9b5842a18b62032422c961f", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "928f95e3ba2ea2a65c7cc2fa1aab225d2588dbec", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 93, "deletions": 18, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "51391fa50d56f915dfd51cb32c778a311a969d08", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "10b4ca9b0b27a5e55f089501c1bf45f8ebaf633e", "filename": "src/libcore/future/future.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "98c504a3f7bef380a6ca28cb044bc3c1c0bbf546", "filename": "src/libcore/future/future_obj.rs", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ffuture%2Ffuture_obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ffuture%2Ffuture_obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture_obj.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "f9361a0f4e7a3ecc9e5175c4959c3874242c72fd", "filename": "src/libcore/future/mod.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fmod.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "e7907e0344493bf13b8a298a84f4ec08ce21c69b", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "db75f9bf210fc399bc7a02917b3b5ae0db6fae46", "filename": "src/libcore/internal_macros.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Finternal_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Finternal_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Finternal_macros.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "854cb5f4e3b3f77a1791896e3f8df6d0eaba57dd", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 11, "deletions": 36, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "48c6eb94144296ec7c4785171ec7223337b638b7", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 59, "deletions": 19, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "35ae77411069cdf5c9a63fda2fedc313dad341b3", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 85, "deletions": 38, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "651c7a35d413c6478b6e661b23dbd586208be6a6", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 34, "deletions": 145, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "d500cc99fa13c2641dabc0e3bfc3d898e4fd194e", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "4b2c1aa551e994ad7470de7480abea31edb20e42", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "72074e1dbce1873fa386585f05a1092691bb0fe8", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "83f9dfea8f2676059c9dc6cf4c0617534ddd6201", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 17, "deletions": 32, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "8643219cb61153307944351cb5ff60edb097564c", "filename": "src/libcore/manually_drop_stage0.rs", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fmanually_drop_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fmanually_drop_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmanually_drop_stage0.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "4f37b462583d12b42717b58970700e03888c427f", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "1a54f03bb00673ed2c2a431e7e76ef2a3ffd333f", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 90, "deletions": 123, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "cc36ea7f71391ed99f9eabf697c9475c97b126bd", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 4, "deletions": 93, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "456d0e956d42aad36258acb069674438e5845f4e", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "577c823f9a060d8009f856a58bb4dee11a144b3f", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 85, "deletions": 159, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "b8e3dd6ed646cb8e90ef36e1552646be11efd18c", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 90, "deletions": 160, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "aa6a08cb2057ea34a4e1faed0dfa1c700a56b5a6", "filename": "src/libcore/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "f33186e59c2e6a65107aee8c436c8f852ab44e67", "filename": "src/libcore/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "0b8f8f0703df79739414df45ad0b4670a8851897", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 259, "deletions": 154, "changes": 413, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "1c826c2fa76bdd6c08fd13096cd269e70ba5ac79", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 461, "deletions": 197, "changes": 658, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "1ac80ecc96ffeb775cd6fc3ffc2d52f018aacbb2", "filename": "src/libcore/ops/index.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fops%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fops%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Findex.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "9c635678d7aa0b2da528bdaad32761238d60e431", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 136, "deletions": 112, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "2b6c376f8a71ca9da8632260c4cb8588455c3a25", "filename": "src/libcore/option.rs", "status": "modified", "additions": 80, "deletions": 5, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "17cac5aa0a05fd1e5a4eed9ca078f29c9a6533dd", "filename": "src/libcore/panic.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanic.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "58407de9566e95048a4edcdcf9d3333651fd0d66", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "45f629a64424cd526c0a17d27525f10c58f8bc1d", "filename": "src/libcore/prelude/v1.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude%2Fv1.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "fe5914c72e1ac27c3760e64c26b6ec4824e4524b", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 245, "deletions": 71, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "fb496836c2c104d41f5b4a6c5d60a5cf3bb8831d", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "72e7b57a6cb3cee63e87b970f026d946e9c40ee8", "filename": "src/libcore/slice/memchr.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fslice%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fslice%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmemchr.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "b766140ffe99a1e37f292e729df55ecb4850ad57", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 640, "deletions": 855, "changes": 1495, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "28ef53ccb5cb6b50547b5619bd7d5b7af86049c7", "filename": "src/libcore/slice/rotate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fslice%2Frotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fslice%2Frotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Frotate.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "5cfb36d3b195bbcc2673673b2c2155cd74f8975f", "filename": "src/libcore/str/lossy.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fstr%2Flossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fstr%2Flossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Flossy.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "86b8349fa3c89cd1894f39d8172b4d02e9465873", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 336, "deletions": 572, "changes": 908, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "5e63fa9ff354c60d1adcb892041a8077a323b956", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "1e2b18bf9b038fc83fa0485474db7aecaca1e232", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "1fc975cb178819d9584c8c3604ea36fab5b93a08", "filename": "src/libcore/task/context.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftask%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftask%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fcontext.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "affcbf464da221214da7c8712e5c7972bde24d23", "filename": "src/libcore/task/executor.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftask%2Fexecutor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftask%2Fexecutor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fexecutor.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "c4f075361640f1b887e099b8c797b0ded7082265", "filename": "src/libcore/task/mod.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "fb027efc6dca0c1a269c0bd15f223aa5e3389252", "filename": "src/libcore/task/poll.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fpoll.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "321b432d3f4307b7c29681caddda75b5453bf2c3", "filename": "src/libcore/task/wake.rs", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "a80bf93953039fe91afeee3f4d451ef23314ca2a", "filename": "src/libcore/tests/any.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fany.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "4b7243b9cfc79e9d66d2409220a058e0170e4ff5", "filename": "src/libcore/tests/cell.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fcell.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "d2a9ed75be658abd1de4a8b2920700ede283ecb6", "filename": "src/libcore/tests/char.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fchar.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "85c9d41b65b591d255ccc2666fb3c352c4bce548", "filename": "src/libcore/tests/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fhash%2Fmod.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "9f3cba26a62db894e11bf72ae7204dda47fe4a65", "filename": "src/libcore/tests/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fintrinsics.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "72b115f8b5f7705c6ee97a32921624e5011fff46", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "2323b30a0104a132a2450a512a2aef0f0cd71dc6", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "96bc9247da6e72da961bde26d5b3184be367fb2b", "filename": "src/libcore/tests/manually_drop.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fmanually_drop.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "714f2babbdff685ff73af76cb22f4a6a8dbab795", "filename": "src/libcore/tests/mem.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fmem.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "3ad694e38adb082743d80045ebd0c08ba87f3fad", "filename": "src/libcore/tests/num/dec2flt/parse.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fparse.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "a1928657dabc480413d361950f8234d60ab8474b", "filename": "src/libcore/tests/num/flt2dec/random.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "ab96d3126bb22f003829dec2ad19d7f1a9a92711", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 205, "deletions": 39, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "ca6906f731047c62e0091c3a3212756cff2b5c23", "filename": "src/libcore/tests/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "1324ba2d9a9c34de48ba36f9a1ae359462098566", "filename": "src/libcore/tests/option.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Foption.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "92160910d8f705ab3e0908851ad455147776a82e", "filename": "src/libcore/tests/ptr.rs", "status": "modified", "additions": 99, "deletions": 10, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fptr.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "0c00992ffd84efc0087099b82c96ccc529a04a4b", "filename": "src/libcore/tests/result.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fresult.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "2b37acdfe3e81386d4a4c3b5d6a7bb606df29e3d", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 263, "deletions": 39, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "343c9596c538321395d4d90a33b54301c255bedf", "filename": "src/libcore/tests/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fstr.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "56ef3f070c1fa8b3c80249d6d15892d99c0ace5e", "filename": "src/libcore/tests/str_lossy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fstr_lossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Fstr_lossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fstr_lossy.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "466f28f0ef0aab4182b4b433cb03315724094266", "filename": "src/libcore/tests/time.rs", "status": "modified", "additions": 182, "deletions": 2, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ftime.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "54973b7b7783a5e1240c6f3ee5031f89b7c2ae2f", "filename": "src/libcore/time.rs", "status": "modified", "additions": 211, "deletions": 9, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "e5cda880f8807044ce97d25f482f31c942b370b1", "filename": "src/libcore/unicode/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Funicode%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Funicode%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fmod.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "519dd17bb9b3f9d2864d0961f32b369028059497", "filename": "src/libcore/unicode/printable.rs", "status": "modified", "additions": 101, "deletions": 97, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Funicode%2Fprintable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Funicode%2Fprintable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fprintable.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "32668ea93dd8c18a62df7a8cc59d844a52aa93a9", "filename": "src/libcore/unicode/tables.rs", "status": "modified", "additions": 1179, "deletions": 968, "changes": 2147, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Funicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Funicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Ftables.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "be0970b544406e5ac9cfe6e2d0b41bb4aa76217a", "filename": "src/libcore/unicode/unicode.py", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Funicode%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibcore%2Funicode%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Funicode.py?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "3aa09a91e076595178880c623878197b647823c5", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 103, "deletions": 20, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "b6d23ed45d72918239c0bfac11dc547895e59b81", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "a24c659689139d6f7b6f3760f109ad0b1b56b647", "filename": "src/libpanic_unwind/dwarf/eh.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "87efc23abc81d7bec015bfff038a1e2fa2c3f9ed", "filename": "src/libpanic_unwind/emcc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibpanic_unwind%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibpanic_unwind%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Femcc.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "11ebcf5c01ea79e3ca62052577c394afd3c951c8", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "5c320bb369e709b63024f43b7f00bf846abf29e4", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "8cbc4a623fa052ebf44664614dfeac7f1e036cfd", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "0b08e54c6739a0684c41cf9478e87b35027f8e82", "filename": "src/libpanic_unwind/seh64_gnu.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh64_gnu.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "7150560b4a13d809d29a0e4d0ab3cc2d3e9ad640", "filename": "src/libpanic_unwind/wasm32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibpanic_unwind%2Fwasm32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibpanic_unwind%2Fwasm32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fwasm32.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "51e7647f36cc2f9673d49e27a1100182fe995f46", "filename": "src/libproc_macro/diagnostic.rs", "status": "modified", "additions": 22, "deletions": 38, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibproc_macro%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibproc_macro%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fdiagnostic.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "bf6e4a3aaa40585cf8b668908b449ae94ca56a65", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 404, "deletions": 490, "changes": 894, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "7ae7b13a15217b2026cd3adfde27e88c598620c7", "filename": "src/libproc_macro/quote.rs", "status": "modified", "additions": 99, "deletions": 239, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fquote.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "a54c695f6376fc0e817d42ea2c58fc9c0cb5067b", "filename": "src/libproc_macro/rustc.rs", "status": "added", "additions": 284, "deletions": 0, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibproc_macro%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibproc_macro%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Frustc.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "457a9f2f625ec1eb5d433828989f252227c35753", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "98cfa094c169a2c250311df96f35919246c1096b", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 54, "deletions": 58, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "cf9c24cc58a623176f400e5968e3f3f230e1ab1d", "filename": "src/librustc/cfg/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fmod.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "f0e43e78a50afdb2f2644b78e22071e2396e3482", "filename": "src/librustc/dep_graph/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fdep_graph%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdebug.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "14a818ddafb710f09f8197d853480d097347fb23", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "e308f2924a05c571c0efa4a4a24cdfc704c8789e", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 31, "deletions": 67, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "ce0b5557a34bf1c2ac15fccbba3a317b893200f2", "filename": "src/librustc/dep_graph/query.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fquery.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "5ace8397d9f827bbf17b434ddb8f0edd10edd44a", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "05e0257cdafd20993cb0dfabacf778bd49da6b1a", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 14, "deletions": 44, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "1c355e35fd6eafffbc048e23c6fe21dae2874291", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 91, "deletions": 4, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "7acfe6839540b5ebd2c57e676a63c6d5724ad9f3", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "4274cd3a0a6559e6759a13b5734714503f22588c", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 177, "deletions": 152, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "a62000e10c79f8374116269b5eeb45c534307cea", "filename": "src/librustc/hir/itemlikevisit.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "7e2c5d03d6b2430d9cc2017d02531a0644a469da", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1568, "deletions": 912, "changes": 2480, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "f2f7f95426ab827e977cab992111d409df00bfa5", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "0150ba659c900dcb8ea2a32e05d82926c5f04567", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "cab620aeec548317a71eff72c2065a0f67b56f0a", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 134, "deletions": 110, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "c4b28fe2c4332ad5b1a077f48128f271ce9675d6", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 47, "deletions": 92, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "a17c160c4d03e5340051d6597dd69ab1a7ed59cf", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "49231e58cf0fc574d39cad754c6f46cea58dbf22", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 198, "deletions": 129, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "610add90b8577253eaee6501e7d8b535a9425cfb", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 635, "deletions": 627, "changes": 1262, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "8a714a5fbd847173c8b2eefc82da51cf576dd0e2", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "4499a378be21a928a435fefcc00588186c2511c1", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 371, "deletions": 284, "changes": 655, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "a6e35d78dcb5aaef76b09a3ed1cb7c9f03cd4b76", "filename": "src/librustc/ich/fingerprint.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fich%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fich%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Ffingerprint.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}, {"sha": "05361b6564170dff4f501217eb13baf8384bc164", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56016cb1e02ece29f25c619b297f9c9797db821c/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=56016cb1e02ece29f25c619b297f9c9797db821c"}]}