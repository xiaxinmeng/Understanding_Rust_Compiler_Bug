{"sha": "95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1ZTBhMmM1MGQwNjNiZDdlYjc5YWE1NWQxNmNkNWZlZTcxNWMyODA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-11T14:45:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-11T14:45:00Z"}, "message": "Auto merge of #68725 - jumbatm:invert-control-in-struct_lint_level, r=Centril\n\nInvert control in struct_lint_level.\n\nCloses #67927\n\nChanges the `struct_lint*` methods to take a  `decorate` function instead of a message string. This decorate function is also responsible for eventually stashing, emitting or cancelling the diagnostic. If the lint was allowed after all, the decorate function is not run at all, saving us from spending time formatting messages (and potentially other expensive work) for lints that don't end up being emitted.\n\nr? @Centril", "tree": {"sha": "0f4b3d8fbfec1c1d3ec85e2761cb20b6e18863c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f4b3d8fbfec1c1d3ec85e2761cb20b6e18863c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "html_url": "https://github.com/rust-lang/rust/commit/95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6690a8c35e9afa3e0f65140cc69d4ba1b9e78c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6690a8c35e9afa3e0f65140cc69d4ba1b9e78c4", "html_url": "https://github.com/rust-lang/rust/commit/b6690a8c35e9afa3e0f65140cc69d4ba1b9e78c4"}, {"sha": "b959da2f4cd2cf8f4b170369355fe7329cf5a9c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b959da2f4cd2cf8f4b170369355fe7329cf5a9c9", "html_url": "https://github.com/rust-lang/rust/commit/b959da2f4cd2cf8f4b170369355fe7329cf5a9c9"}], "stats": {"total": 3406, "additions": 1795, "deletions": 1611}, "files": [{"sha": "01390f2c7195b27dc392e096a2e5c2438e242a12", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -1701,7 +1701,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         sub: Region<'tcx>,\n     ) {\n         self.construct_generic_bound_failure(region_scope_tree, span, origin, bound_kind, sub)\n-            .emit()\n+            .emit();\n     }\n \n     pub fn construct_generic_bound_failure("}, {"sha": "004835b230ab44e3260494aaa3c9611a34b28827", "filename": "src/librustc/lint.rs", "status": "modified", "additions": 138, "deletions": 106, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -174,132 +174,164 @@ impl<'a> HashStable<StableHashingContext<'a>> for LintLevelMap {\n     }\n }\n \n-pub fn struct_lint_level<'a>(\n-    sess: &'a Session,\n+pub struct LintDiagnosticBuilder<'a>(DiagnosticBuilder<'a>);\n+\n+impl<'a> LintDiagnosticBuilder<'a> {\n+    /// Return the inner DiagnosticBuilder, first setting the primary message to `msg`.\n+    pub fn build(mut self, msg: &str) -> DiagnosticBuilder<'a> {\n+        self.0.set_primary_message(msg);\n+        self.0\n+    }\n+\n+    /// Create a LintDiagnosticBuilder from some existing DiagnosticBuilder.\n+    pub fn new(err: DiagnosticBuilder<'a>) -> LintDiagnosticBuilder<'a> {\n+        LintDiagnosticBuilder(err)\n+    }\n+}\n+\n+pub fn struct_lint_level<'s, 'd>(\n+    sess: &'s Session,\n     lint: &'static Lint,\n     level: Level,\n     src: LintSource,\n     span: Option<MultiSpan>,\n-    msg: &str,\n-) -> DiagnosticBuilder<'a> {\n-    let mut err = match (level, span) {\n-        (Level::Allow, _) => return sess.diagnostic().struct_dummy(),\n-        (Level::Warn, Some(span)) => sess.struct_span_warn(span, msg),\n-        (Level::Warn, None) => sess.struct_warn(msg),\n-        (Level::Deny, Some(span)) | (Level::Forbid, Some(span)) => sess.struct_span_err(span, msg),\n-        (Level::Deny, None) | (Level::Forbid, None) => sess.struct_err(msg),\n-    };\n+    decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>) + 'd,\n+) {\n+    // Avoid codegen bloat from monomorphization by immediately doing dyn dispatch of `decorate` to\n+    // the \"real\" work.\n+    fn struct_lint_level_impl(\n+        sess: &'s Session,\n+        lint: &'static Lint,\n+        level: Level,\n+        src: LintSource,\n+        span: Option<MultiSpan>,\n+        decorate: Box<dyn for<'b> FnOnce(LintDiagnosticBuilder<'b>) + 'd>,\n+    ) {\n+        let mut err = match (level, span) {\n+            (Level::Allow, _) => {\n+                return;\n+            }\n+            (Level::Warn, Some(span)) => sess.struct_span_warn(span, \"\"),\n+            (Level::Warn, None) => sess.struct_warn(\"\"),\n+            (Level::Deny, Some(span)) | (Level::Forbid, Some(span)) => {\n+                sess.struct_span_err(span, \"\")\n+            }\n+            (Level::Deny, None) | (Level::Forbid, None) => sess.struct_err(\"\"),\n+        };\n \n-    // Check for future incompatibility lints and issue a stronger warning.\n-    let lint_id = LintId::of(lint);\n-    let future_incompatible = lint.future_incompatible;\n-\n-    // If this code originates in a foreign macro, aka something that this crate\n-    // did not itself author, then it's likely that there's nothing this crate\n-    // can do about it. We probably want to skip the lint entirely.\n-    if err.span.primary_spans().iter().any(|s| in_external_macro(sess, *s)) {\n-        // Any suggestions made here are likely to be incorrect, so anything we\n-        // emit shouldn't be automatically fixed by rustfix.\n-        err.allow_suggestions(false);\n-\n-        // If this is a future incompatible lint it'll become a hard error, so\n-        // we have to emit *something*. Also allow lints to whitelist themselves\n-        // on a case-by-case basis for emission in a foreign macro.\n-        if future_incompatible.is_none() && !lint.report_in_external_macro {\n-            err.cancel();\n-            // Don't continue further, since we don't want to have\n-            // `diag_span_note_once` called for a diagnostic that isn't emitted.\n-            return err;\n+        // Check for future incompatibility lints and issue a stronger warning.\n+        let lint_id = LintId::of(lint);\n+        let future_incompatible = lint.future_incompatible;\n+\n+        // If this code originates in a foreign macro, aka something that this crate\n+        // did not itself author, then it's likely that there's nothing this crate\n+        // can do about it. We probably want to skip the lint entirely.\n+        if err.span.primary_spans().iter().any(|s| in_external_macro(sess, *s)) {\n+            // Any suggestions made here are likely to be incorrect, so anything we\n+            // emit shouldn't be automatically fixed by rustfix.\n+            err.allow_suggestions(false);\n+\n+            // If this is a future incompatible lint it'll become a hard error, so\n+            // we have to emit *something*. Also allow lints to whitelist themselves\n+            // on a case-by-case basis for emission in a foreign macro.\n+            if future_incompatible.is_none() && !lint.report_in_external_macro {\n+                err.cancel();\n+                // Don't continue further, since we don't want to have\n+                // `diag_span_note_once` called for a diagnostic that isn't emitted.\n+                return;\n+            }\n         }\n-    }\n \n-    let name = lint.name_lower();\n-    match src {\n-        LintSource::Default => {\n-            sess.diag_note_once(\n-                &mut err,\n-                DiagnosticMessageId::from(lint),\n-                &format!(\"`#[{}({})]` on by default\", level.as_str(), name),\n-            );\n-        }\n-        LintSource::CommandLine(lint_flag_val) => {\n-            let flag = match level {\n-                Level::Warn => \"-W\",\n-                Level::Deny => \"-D\",\n-                Level::Forbid => \"-F\",\n-                Level::Allow => panic!(),\n-            };\n-            let hyphen_case_lint_name = name.replace(\"_\", \"-\");\n-            if lint_flag_val.as_str() == name {\n+        let name = lint.name_lower();\n+        match src {\n+            LintSource::Default => {\n                 sess.diag_note_once(\n                     &mut err,\n                     DiagnosticMessageId::from(lint),\n-                    &format!(\n-                        \"requested on the command line with `{} {}`\",\n-                        flag, hyphen_case_lint_name\n-                    ),\n-                );\n-            } else {\n-                let hyphen_case_flag_val = lint_flag_val.as_str().replace(\"_\", \"-\");\n-                sess.diag_note_once(\n-                    &mut err,\n-                    DiagnosticMessageId::from(lint),\n-                    &format!(\n-                        \"`{} {}` implied by `{} {}`\",\n-                        flag, hyphen_case_lint_name, flag, hyphen_case_flag_val\n-                    ),\n+                    &format!(\"`#[{}({})]` on by default\", level.as_str(), name),\n                 );\n             }\n-        }\n-        LintSource::Node(lint_attr_name, src, reason) => {\n-            if let Some(rationale) = reason {\n-                err.note(&rationale.as_str());\n+            LintSource::CommandLine(lint_flag_val) => {\n+                let flag = match level {\n+                    Level::Warn => \"-W\",\n+                    Level::Deny => \"-D\",\n+                    Level::Forbid => \"-F\",\n+                    Level::Allow => panic!(),\n+                };\n+                let hyphen_case_lint_name = name.replace(\"_\", \"-\");\n+                if lint_flag_val.as_str() == name {\n+                    sess.diag_note_once(\n+                        &mut err,\n+                        DiagnosticMessageId::from(lint),\n+                        &format!(\n+                            \"requested on the command line with `{} {}`\",\n+                            flag, hyphen_case_lint_name\n+                        ),\n+                    );\n+                } else {\n+                    let hyphen_case_flag_val = lint_flag_val.as_str().replace(\"_\", \"-\");\n+                    sess.diag_note_once(\n+                        &mut err,\n+                        DiagnosticMessageId::from(lint),\n+                        &format!(\n+                            \"`{} {}` implied by `{} {}`\",\n+                            flag, hyphen_case_lint_name, flag, hyphen_case_flag_val\n+                        ),\n+                    );\n+                }\n             }\n-            sess.diag_span_note_once(\n-                &mut err,\n-                DiagnosticMessageId::from(lint),\n-                src,\n-                \"the lint level is defined here\",\n-            );\n-            if lint_attr_name.as_str() != name {\n-                let level_str = level.as_str();\n-                sess.diag_note_once(\n+            LintSource::Node(lint_attr_name, src, reason) => {\n+                if let Some(rationale) = reason {\n+                    err.note(&rationale.as_str());\n+                }\n+                sess.diag_span_note_once(\n                     &mut err,\n                     DiagnosticMessageId::from(lint),\n-                    &format!(\n-                        \"`#[{}({})]` implied by `#[{}({})]`\",\n-                        level_str, name, level_str, lint_attr_name\n-                    ),\n+                    src,\n+                    \"the lint level is defined here\",\n                 );\n+                if lint_attr_name.as_str() != name {\n+                    let level_str = level.as_str();\n+                    sess.diag_note_once(\n+                        &mut err,\n+                        DiagnosticMessageId::from(lint),\n+                        &format!(\n+                            \"`#[{}({})]` implied by `#[{}({})]`\",\n+                            level_str, name, level_str, lint_attr_name\n+                        ),\n+                    );\n+                }\n             }\n         }\n-    }\n \n-    err.code(DiagnosticId::Lint(name));\n-\n-    if let Some(future_incompatible) = future_incompatible {\n-        const STANDARD_MESSAGE: &str = \"this was previously accepted by the compiler but is being phased out; \\\n-             it will become a hard error\";\n-\n-        let explanation = if lint_id == LintId::of(builtin::UNSTABLE_NAME_COLLISIONS) {\n-            \"once this method is added to the standard library, \\\n-             the ambiguity may cause an error or change in behavior!\"\n-                .to_owned()\n-        } else if lint_id == LintId::of(builtin::MUTABLE_BORROW_RESERVATION_CONFLICT) {\n-            \"this borrowing pattern was not meant to be accepted, \\\n-             and may become a hard error in the future\"\n-                .to_owned()\n-        } else if let Some(edition) = future_incompatible.edition {\n-            format!(\"{} in the {} edition!\", STANDARD_MESSAGE, edition)\n-        } else {\n-            format!(\"{} in a future release!\", STANDARD_MESSAGE)\n-        };\n-        let citation = format!(\"for more information, see {}\", future_incompatible.reference);\n-        err.warn(&explanation);\n-        err.note(&citation);\n-    }\n+        err.code(DiagnosticId::Lint(name));\n+\n+        if let Some(future_incompatible) = future_incompatible {\n+            const STANDARD_MESSAGE: &str = \"this was previously accepted by the compiler but is being phased out; \\\n+                 it will become a hard error\";\n+\n+            let explanation = if lint_id == LintId::of(builtin::UNSTABLE_NAME_COLLISIONS) {\n+                \"once this method is added to the standard library, \\\n+                 the ambiguity may cause an error or change in behavior!\"\n+                    .to_owned()\n+            } else if lint_id == LintId::of(builtin::MUTABLE_BORROW_RESERVATION_CONFLICT) {\n+                \"this borrowing pattern was not meant to be accepted, \\\n+                 and may become a hard error in the future\"\n+                    .to_owned()\n+            } else if let Some(edition) = future_incompatible.edition {\n+                format!(\"{} in the {} edition!\", STANDARD_MESSAGE, edition)\n+            } else {\n+                format!(\"{} in a future release!\", STANDARD_MESSAGE)\n+            };\n+            let citation = format!(\"for more information, see {}\", future_incompatible.reference);\n+            err.warn(&explanation);\n+            err.note(&citation);\n+        }\n \n-    return err;\n+        // Finally, run `decorate`. This function is also responsible for emitting the diagnostic.\n+        decorate(LintDiagnosticBuilder::new(err));\n+    }\n+    struct_lint_level_impl(sess, lint, level, src, span, Box::new(decorate))\n }\n \n /// Returns whether `span` originates in a foreign crate's external macro."}, {"sha": "dd30fb23c2e7681a47b7d84493a0225d3b2a53ae", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -222,11 +222,13 @@ fn late_report_deprecation(\n         return;\n     }\n \n-    let mut diag = tcx.struct_span_lint_hir(lint, hir_id, span, message);\n-    if let hir::Node::Expr(_) = tcx.hir().get(hir_id) {\n-        deprecation_suggestion(&mut diag, suggestion, span);\n-    }\n-    diag.emit();\n+    tcx.struct_span_lint_hir(lint, hir_id, span, |lint| {\n+        let mut diag = lint.build(message);\n+        if let hir::Node::Expr(_) = tcx.hir().get(hir_id) {\n+            deprecation_suggestion(&mut diag, suggestion, span);\n+        }\n+        diag.emit()\n+    });\n     if hir_id == hir::DUMMY_HIR_ID {\n         span_bug!(span, \"emitted a {} lint with dummy HIR id: {:?}\", lint.name, def_id);\n     }\n@@ -387,8 +389,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Additionally, this function will also check if the item is deprecated. If so, and `id` is\n     /// not `None`, a deprecated lint attached to `id` will be emitted.\n     pub fn check_stability(self, def_id: DefId, id: Option<HirId>, span: Span) {\n-        let soft_handler =\n-            |lint, span, msg: &_| self.lint_hir(lint, id.unwrap_or(hir::CRATE_HIR_ID), span, msg);\n+        let soft_handler = |lint, span, msg: &_| {\n+            self.struct_span_lint_hir(lint, id.unwrap_or(hir::CRATE_HIR_ID), span, |lint| {\n+                lint.build(msg).emit()\n+            })\n+        };\n         match self.eval_stability(def_id, id, span) {\n             EvalResult::Allow => {}\n             EvalResult::Deny { feature, reason, issue, is_soft } => {"}, {"sha": "df3971a5ac3f11523ceeb647acd65c16d975a906", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 51, "deletions": 33, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -83,18 +83,15 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         &self,\n         tcx: TyCtxtAt<'tcx>,\n         message: &str,\n-    ) -> Result<DiagnosticBuilder<'tcx>, ErrorHandled> {\n-        self.struct_generic(tcx, message, None)\n+        emit: impl FnOnce(DiagnosticBuilder<'_>),\n+    ) -> Result<(), ErrorHandled> {\n+        self.struct_generic(tcx, message, emit, None)\n     }\n \n     pub fn report_as_error(&self, tcx: TyCtxtAt<'tcx>, message: &str) -> ErrorHandled {\n-        let err = self.struct_error(tcx, message);\n-        match err {\n-            Ok(mut err) => {\n-                err.emit();\n-                ErrorHandled::Reported\n-            }\n-            Err(err) => err,\n+        match self.struct_error(tcx, message, |mut e| e.emit()) {\n+            Ok(_) => ErrorHandled::Reported,\n+            Err(x) => x,\n         }\n     }\n \n@@ -105,9 +102,11 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         lint_root: hir::HirId,\n         span: Option<Span>,\n     ) -> ErrorHandled {\n-        let lint = self.struct_generic(tcx, message, Some(lint_root));\n-        match lint {\n-            Ok(mut lint) => {\n+        match self.struct_generic(\n+            tcx,\n+            message,\n+            |mut lint: DiagnosticBuilder<'_>| {\n+                // Apply the span.\n                 if let Some(span) = span {\n                     let primary_spans = lint.span.primary_spans().to_vec();\n                     // point at the actual error as the primary span\n@@ -121,18 +120,25 @@ impl<'tcx> ConstEvalErr<'tcx> {\n                     }\n                 }\n                 lint.emit();\n-                ErrorHandled::Reported\n-            }\n+            },\n+            Some(lint_root),\n+        ) {\n+            Ok(_) => ErrorHandled::Reported,\n             Err(err) => err,\n         }\n     }\n \n+    /// Sets the message passed in via `message`, then adds the span labels for you, before applying\n+    /// further modifications in `emit`. It's up to you to call emit(), stash(..), etc. within the\n+    /// `emit` method. If you don't need to do any additional processing, just use\n+    /// struct_generic.\n     fn struct_generic(\n         &self,\n         tcx: TyCtxtAt<'tcx>,\n         message: &str,\n+        emit: impl FnOnce(DiagnosticBuilder<'_>),\n         lint_root: Option<hir::HirId>,\n-    ) -> Result<DiagnosticBuilder<'tcx>, ErrorHandled> {\n+    ) -> Result<(), ErrorHandled> {\n         let must_error = match self.error {\n             InterpError::MachineStop(_) => bug!(\"CTFE does not stop\"),\n             err_inval!(Layout(LayoutError::Unknown(_))) | err_inval!(TooGeneric) => {\n@@ -143,7 +149,22 @@ impl<'tcx> ConstEvalErr<'tcx> {\n             _ => false,\n         };\n         trace!(\"reporting const eval failure at {:?}\", self.span);\n-        let mut err = if let (Some(lint_root), false) = (lint_root, must_error) {\n+\n+        let add_span_labels = |err: &mut DiagnosticBuilder<'_>| {\n+            if !must_error {\n+                err.span_label(self.span, self.error.to_string());\n+            }\n+            // Skip the last, which is just the environment of the constant.  The stacktrace\n+            // is sometimes empty because we create \"fake\" eval contexts in CTFE to do work\n+            // on constant values.\n+            if self.stacktrace.len() > 0 {\n+                for frame_info in &self.stacktrace[..self.stacktrace.len() - 1] {\n+                    err.span_label(frame_info.call_site, frame_info.to_string());\n+                }\n+            }\n+        };\n+\n+        if let (Some(lint_root), false) = (lint_root, must_error) {\n             let hir_id = self\n                 .stacktrace\n                 .iter()\n@@ -155,25 +176,22 @@ impl<'tcx> ConstEvalErr<'tcx> {\n                 rustc_session::lint::builtin::CONST_ERR,\n                 hir_id,\n                 tcx.span,\n-                message,\n-            )\n-        } else if must_error {\n-            struct_error(tcx, &self.error.to_string())\n+                |lint| {\n+                    let mut err = lint.build(message);\n+                    add_span_labels(&mut err);\n+                    emit(err);\n+                },\n+            );\n         } else {\n-            struct_error(tcx, message)\n+            let mut err = if must_error {\n+                struct_error(tcx, &self.error.to_string())\n+            } else {\n+                struct_error(tcx, message)\n+            };\n+            add_span_labels(&mut err);\n+            emit(err);\n         };\n-        if !must_error {\n-            err.span_label(self.span, self.error.to_string());\n-        }\n-        // Skip the last, which is just the environment of the constant.  The stacktrace\n-        // is sometimes empty because we create \"fake\" eval contexts in CTFE to do work\n-        // on constant values.\n-        if self.stacktrace.len() > 0 {\n-            for frame_info in &self.stacktrace[..self.stacktrace.len() - 1] {\n-                err.span_label(frame_info.call_site, frame_info.to_string());\n-            }\n-        }\n-        Ok(err)\n+        Ok(())\n     }\n }\n "}, {"sha": "4c5cd866b4a01b6651e4634e079810572135d5aa", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 37, "deletions": 27, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -227,37 +227,47 @@ fn object_safety_violations_for_trait(\n             {\n                 // Using `CRATE_NODE_ID` is wrong, but it's hard to get a more precise id.\n                 // It's also hard to get a use site span, so we use the method definition span.\n-                let mut err = tcx.struct_span_lint_hir(\n+                tcx.struct_span_lint_hir(\n                     WHERE_CLAUSES_OBJECT_SAFETY,\n                     hir::CRATE_HIR_ID,\n                     *span,\n-                    &format!(\n-                        \"the trait `{}` cannot be made into an object\",\n-                        tcx.def_path_str(trait_def_id)\n-                    ),\n+                    |lint| {\n+                        let mut err = lint.build(&format!(\n+                            \"the trait `{}` cannot be made into an object\",\n+                            tcx.def_path_str(trait_def_id)\n+                        ));\n+                        let node = tcx.hir().get_if_local(trait_def_id);\n+                        let msg = if let Some(hir::Node::Item(item)) = node {\n+                            err.span_label(\n+                                item.ident.span,\n+                                \"this trait cannot be made into an object...\",\n+                            );\n+                            format!(\"...because {}\", violation.error_msg())\n+                        } else {\n+                            format!(\n+                                \"the trait cannot be made into an object because {}\",\n+                                violation.error_msg()\n+                            )\n+                        };\n+                        err.span_label(*span, &msg);\n+                        match (node, violation.solution()) {\n+                            (Some(_), Some((note, None))) => {\n+                                err.help(&note);\n+                            }\n+                            (Some(_), Some((note, Some((sugg, span))))) => {\n+                                err.span_suggestion(\n+                                    span,\n+                                    &note,\n+                                    sugg,\n+                                    Applicability::MachineApplicable,\n+                                );\n+                            }\n+                            // Only provide the help if its a local trait, otherwise it's not actionable.\n+                            _ => {}\n+                        }\n+                        err.emit();\n+                    },\n                 );\n-                let node = tcx.hir().get_if_local(trait_def_id);\n-                let msg = if let Some(hir::Node::Item(item)) = node {\n-                    err.span_label(item.ident.span, \"this trait cannot be made into an object...\");\n-                    format!(\"...because {}\", violation.error_msg())\n-                } else {\n-                    format!(\n-                        \"the trait cannot be made into an object because {}\",\n-                        violation.error_msg()\n-                    )\n-                };\n-                err.span_label(*span, &msg);\n-                match (node, violation.solution()) {\n-                    (Some(_), Some((note, None))) => {\n-                        err.help(&note);\n-                    }\n-                    (Some(_), Some((note, Some((sugg, span))))) => {\n-                        err.span_suggestion(span, &note, sugg, Applicability::MachineApplicable);\n-                    }\n-                    // Only provide the help if its a local trait, otherwise it's not actionable.\n-                    _ => {}\n-                }\n-                err.emit();\n                 false\n             } else {\n                 true"}, {"sha": "7c93a35158b08173c69a0036cd45a3128f4394bb", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 64, "deletions": 52, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -16,6 +16,7 @@ use crate::traits::select::IntercrateAmbiguityCause;\n use crate::traits::{self, coherence, FutureCompatOverlapErrorKind, ObligationCause, TraitEngine};\n use crate::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use crate::ty::{self, TyCtxt, TypeFoldable};\n+use rustc::lint::LintDiagnosticBuilder;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir::def_id::DefId;\n@@ -317,22 +318,70 @@ pub(super) fn specialization_graph_provider(\n             };\n \n             if let Some(overlap) = overlap {\n-                let msg = format!(\n-                    \"conflicting implementations of trait `{}`{}:{}\",\n-                    overlap.trait_desc,\n-                    overlap\n-                        .self_desc\n-                        .clone()\n-                        .map_or(String::new(), |ty| { format!(\" for type `{}`\", ty) }),\n-                    match used_to_be_allowed {\n-                        Some(FutureCompatOverlapErrorKind::Issue33140) => \" (E0119)\",\n-                        _ => \"\",\n-                    }\n-                );\n                 let impl_span =\n                     tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n-                let mut err = match used_to_be_allowed {\n-                    None => struct_span_err!(tcx.sess, impl_span, E0119, \"{}\", msg),\n+\n+                // Work to be done after we've built the DiagnosticBuilder. We have to define it\n+                // now because the struct_lint methods don't return back the DiagnosticBuilder\n+                // that's passed in.\n+                let decorate = |err: LintDiagnosticBuilder<'_>| {\n+                    let msg = format!(\n+                        \"conflicting implementations of trait `{}`{}:{}\",\n+                        overlap.trait_desc,\n+                        overlap\n+                            .self_desc\n+                            .clone()\n+                            .map_or(String::new(), |ty| { format!(\" for type `{}`\", ty) }),\n+                        match used_to_be_allowed {\n+                            Some(FutureCompatOverlapErrorKind::Issue33140) => \" (E0119)\",\n+                            _ => \"\",\n+                        }\n+                    );\n+                    let mut err = err.build(&msg);\n+                    match tcx.span_of_impl(overlap.with_impl) {\n+                        Ok(span) => {\n+                            err.span_label(\n+                                tcx.sess.source_map().def_span(span),\n+                                \"first implementation here\".to_string(),\n+                            );\n+\n+                            err.span_label(\n+                                impl_span,\n+                                format!(\n+                                    \"conflicting implementation{}\",\n+                                    overlap\n+                                        .self_desc\n+                                        .map_or(String::new(), |ty| format!(\" for `{}`\", ty))\n+                                ),\n+                            );\n+                        }\n+                        Err(cname) => {\n+                            let msg = match to_pretty_impl_header(tcx, overlap.with_impl) {\n+                                Some(s) => format!(\n+                                    \"conflicting implementation in crate `{}`:\\n- {}\",\n+                                    cname, s\n+                                ),\n+                                None => format!(\"conflicting implementation in crate `{}`\", cname),\n+                            };\n+                            err.note(&msg);\n+                        }\n+                    }\n+\n+                    for cause in &overlap.intercrate_ambiguity_causes {\n+                        cause.add_intercrate_ambiguity_hint(&mut err);\n+                    }\n+\n+                    if overlap.involves_placeholder {\n+                        coherence::add_placeholder_note(&mut err);\n+                    }\n+                    err.emit()\n+                };\n+\n+                match used_to_be_allowed {\n+                    None => {\n+                        let err = struct_span_err!(tcx.sess, impl_span, E0119, \"\");\n+                        decorate(LintDiagnosticBuilder::new(err));\n+                    }\n                     Some(kind) => {\n                         let lint = match kind {\n                             FutureCompatOverlapErrorKind::Issue33140 => {\n@@ -344,47 +393,10 @@ pub(super) fn specialization_graph_provider(\n                             lint,\n                             tcx.hir().as_local_hir_id(impl_def_id).unwrap(),\n                             impl_span,\n-                            &msg,\n+                            decorate,\n                         )\n                     }\n                 };\n-\n-                match tcx.span_of_impl(overlap.with_impl) {\n-                    Ok(span) => {\n-                        err.span_label(\n-                            tcx.sess.source_map().def_span(span),\n-                            \"first implementation here\".to_string(),\n-                        );\n-                        err.span_label(\n-                            impl_span,\n-                            format!(\n-                                \"conflicting implementation{}\",\n-                                overlap\n-                                    .self_desc\n-                                    .map_or(String::new(), |ty| format!(\" for `{}`\", ty))\n-                            ),\n-                        );\n-                    }\n-                    Err(cname) => {\n-                        let msg = match to_pretty_impl_header(tcx, overlap.with_impl) {\n-                            Some(s) => {\n-                                format!(\"conflicting implementation in crate `{}`:\\n- {}\", cname, s)\n-                            }\n-                            None => format!(\"conflicting implementation in crate `{}`\", cname),\n-                        };\n-                        err.note(&msg);\n-                    }\n-                }\n-\n-                for cause in &overlap.intercrate_ambiguity_causes {\n-                    cause.add_intercrate_ambiguity_hint(&mut err);\n-                }\n-\n-                if overlap.involves_placeholder {\n-                    coherence::add_placeholder_note(&mut err);\n-                }\n-\n-                err.emit();\n             }\n         } else {\n             let parent = tcx.impl_parent(impl_def_id).unwrap_or(trait_id);"}, {"sha": "f2ad01b3d59615d0d3fe4af2824f100a7938a319", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -41,6 +41,7 @@ use crate::ty::{ExistentialPredicate, InferTy, ParamTy, PolyFnSig, Predicate, Pr\n use crate::ty::{InferConst, ParamConst};\n use crate::ty::{List, TyKind, TyS};\n use crate::util::common::ErrorReported;\n+use rustc::lint::LintDiagnosticBuilder;\n use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::profiling::SelfProfilerRef;\n@@ -49,7 +50,6 @@ use rustc_data_structures::stable_hasher::{\n     hash_stable_hashmap, HashStable, StableHasher, StableVec,\n };\n use rustc_data_structures::sync::{self, Lock, Lrc, WorkerLocal};\n-use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, DefIndex, LOCAL_CRATE};\n@@ -2551,16 +2551,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         iter.intern_with(|xs| self.intern_goals(xs))\n     }\n \n-    pub fn lint_hir(\n-        self,\n-        lint: &'static Lint,\n-        hir_id: HirId,\n-        span: impl Into<MultiSpan>,\n-        msg: &str,\n-    ) {\n-        self.struct_span_lint_hir(lint, hir_id, span.into(), msg).emit()\n-    }\n-\n     /// Walks upwards from `id` to find a node which might change lint levels with attributes.\n     /// It stops at `bound` and just returns it if reached.\n     pub fn maybe_lint_level_root_bounded(self, mut id: HirId, bound: HirId) -> HirId {\n@@ -2604,20 +2594,20 @@ impl<'tcx> TyCtxt<'tcx> {\n         lint: &'static Lint,\n         hir_id: HirId,\n         span: impl Into<MultiSpan>,\n-        msg: &str,\n-    ) -> DiagnosticBuilder<'tcx> {\n+        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>),\n+    ) {\n         let (level, src) = self.lint_level_at_node(lint, hir_id);\n-        struct_lint_level(self.sess, lint, level, src, Some(span.into()), msg)\n+        struct_lint_level(self.sess, lint, level, src, Some(span.into()), decorate);\n     }\n \n     pub fn struct_lint_node(\n         self,\n         lint: &'static Lint,\n         id: HirId,\n-        msg: &str,\n-    ) -> DiagnosticBuilder<'tcx> {\n+        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>),\n+    ) {\n         let (level, src) = self.lint_level_at_node(lint, id);\n-        struct_lint_level(self.sess, lint, level, src, None, msg)\n+        struct_lint_level(self.sess, lint, level, src, None, decorate);\n     }\n \n     pub fn in_scope_traits(self, id: HirId) -> Option<&'tcx StableVec<TraitCandidate>> {"}, {"sha": "3c13735bbf41f5c53225c2703e827d0c37c59b1c", "filename": "src/librustc_attr/builtin.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_attr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_attr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Fbuiltin.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -37,7 +37,9 @@ fn handle_errors(sess: &ParseSess, span: Span, error: AttrError) {\n                 .span_label(span, format!(\"expected one of {}\", expected.join(\", \")))\n                 .emit();\n         }\n-        AttrError::MissingSince => struct_span_err!(diag, span, E0542, \"missing 'since'\").emit(),\n+        AttrError::MissingSince => {\n+            struct_span_err!(diag, span, E0542, \"missing 'since'\").emit();\n+        }\n         AttrError::MissingFeature => {\n             struct_span_err!(diag, span, E0546, \"missing 'feature'\").emit();\n         }\n@@ -639,7 +641,7 @@ fn gate_cfg(gated_cfg: &GatedCfg, cfg_span: Span, sess: &ParseSess, features: &F\n     let (cfg, feature, has_feature) = gated_cfg;\n     if !has_feature(features) && !cfg_span.allows_unstable(*feature) {\n         let explain = format!(\"`cfg({})` is experimental and subject to change\", cfg);\n-        feature_err(sess, *feature, cfg_span, &explain).emit()\n+        feature_err(sess, *feature, cfg_span, &explain).emit();\n     }\n }\n "}, {"sha": "189b5bd0f9e87e576f7a7f490e972dd8c55b8fe1", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -194,6 +194,7 @@ impl Diagnostic {\n         found_extra: &dyn fmt::Display,\n     ) -> &mut Self {\n         let expected_label = format!(\"expected {}\", expected_label);\n+\n         let found_label = format!(\"found {}\", found_label);\n         let (found_padding, expected_padding) = if expected_label.len() > found_label.len() {\n             (expected_label.len() - found_label.len(), 0)"}, {"sha": "39f585231eea433c5e737871dae38c0e331001a8", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -106,7 +106,11 @@ impl<'a> DiagnosticBuilder<'a> {\n     ///\n     /// See `emit` and `delay_as_bug` for details.\n     pub fn emit_unless(&mut self, delay: bool) {\n-        if delay { self.delay_as_bug() } else { self.emit() }\n+        if delay {\n+            self.delay_as_bug();\n+        } else {\n+            self.emit();\n+        }\n     }\n \n     /// Stashes diagnostic for possible later improvement in a different,\n@@ -369,6 +373,7 @@ impl<'a> DiagnosticBuilder<'a> {\n     /// Creates a new `DiagnosticBuilder` with an already constructed\n     /// diagnostic.\n     crate fn new_diagnostic(handler: &'a Handler, diagnostic: Diagnostic) -> DiagnosticBuilder<'a> {\n+        debug!(\"Created new diagnostic\");\n         DiagnosticBuilder(Box::new(DiagnosticBuilderInner {\n             handler,\n             diagnostic,"}, {"sha": "a5614f900b6fb142cae7ca5d85da01ba105ad0b6", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -1113,7 +1113,11 @@ pub fn expr_to_string(\n     err_msg: &str,\n ) -> Option<(Symbol, ast::StrStyle)> {\n     expr_to_spanned_string(cx, expr, err_msg)\n-        .map_err(|err| err.map(|mut err| err.emit()))\n+        .map_err(|err| {\n+            err.map(|mut err| {\n+                err.emit();\n+            })\n+        })\n         .ok()\n         .map(|(symbol, style, _)| (symbol, style))\n }"}, {"sha": "a91d735622f4e0710b3ba463373f4e328c1ea4f0", "filename": "src/librustc_lint/array_into_iter.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_lint%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_lint%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Farray_into_iter.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -77,20 +77,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIntoIter {\n                 // to an array or to a slice.\n                 _ => bug!(\"array type coerced to something other than array or slice\"),\n             };\n-            let msg = format!(\n+            cx.struct_span_lint(ARRAY_INTO_ITER, *span, |lint| {\n+                lint.build(&format!(\n                 \"this method call currently resolves to `<&{} as IntoIterator>::into_iter` (due \\\n                     to autoref coercions), but that might change in the future when \\\n                     `IntoIterator` impls for arrays are added.\",\n                 target,\n-            );\n-            cx.struct_span_lint(ARRAY_INTO_ITER, *span, &msg)\n+                ))\n                 .span_suggestion(\n                     call.ident.span,\n                     \"use `.iter()` instead of `.into_iter()` to avoid ambiguity\",\n                     \"iter\".into(),\n                     Applicability::MachineApplicable,\n                 )\n                 .emit();\n+            })\n         }\n     }\n }"}, {"sha": "c827a7f3d5283ed4944527f1324ee430c88517f1", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 294, "deletions": 271, "changes": 565, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -23,6 +23,7 @@\n \n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc::hir::map::Map;\n+use rustc::lint::LintDiagnosticBuilder;\n use rustc::traits::misc::can_type_implement_copy;\n use rustc::ty::{self, layout::VariantIdx, Ty, TyCtxt};\n use rustc_ast_pretty::pprust::{self, expr_to_string};\n@@ -77,14 +78,16 @@ impl EarlyLintPass for WhileTrue {\n                     if !lit.span.from_expansion() {\n                         let msg = \"denote infinite loops with `loop { ... }`\";\n                         let condition_span = cx.sess.source_map().def_span(e.span);\n-                        cx.struct_span_lint(WHILE_TRUE, condition_span, msg)\n-                            .span_suggestion_short(\n-                                condition_span,\n-                                \"use `loop`\",\n-                                \"loop\".to_owned(),\n-                                Applicability::MachineApplicable,\n-                            )\n-                            .emit();\n+                        cx.struct_span_lint(WHILE_TRUE, condition_span, |lint| {\n+                            lint.build(msg)\n+                                .span_suggestion_short(\n+                                    condition_span,\n+                                    \"use `loop`\",\n+                                    \"loop\".to_owned(),\n+                                    Applicability::MachineApplicable,\n+                                )\n+                                .emit();\n+                        })\n                     }\n                 }\n             }\n@@ -104,8 +107,9 @@ impl BoxPointers {\n     fn check_heap_type(&self, cx: &LateContext<'_, '_>, span: Span, ty: Ty<'_>) {\n         for leaf_ty in ty.walk() {\n             if leaf_ty.is_box() {\n-                let m = format!(\"type uses owned (Box type) pointers: {}\", ty);\n-                cx.span_lint(BOX_POINTERS, span, &m);\n+                cx.struct_span_lint(BOX_POINTERS, span, |lint| {\n+                    lint.build(&format!(\"type uses owned (Box type) pointers: {}\", ty)).emit()\n+                });\n             }\n         }\n     }\n@@ -174,29 +178,28 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n                     if cx.tcx.find_field_index(ident, &variant)\n                         == Some(cx.tcx.field_index(fieldpat.hir_id, cx.tables))\n                     {\n-                        let mut err = cx.struct_span_lint(\n-                            NON_SHORTHAND_FIELD_PATTERNS,\n-                            fieldpat.span,\n-                            &format!(\"the `{}:` in this pattern is redundant\", ident),\n-                        );\n-                        let binding = match binding_annot {\n-                            hir::BindingAnnotation::Unannotated => None,\n-                            hir::BindingAnnotation::Mutable => Some(\"mut\"),\n-                            hir::BindingAnnotation::Ref => Some(\"ref\"),\n-                            hir::BindingAnnotation::RefMut => Some(\"ref mut\"),\n-                        };\n-                        let ident = if let Some(binding) = binding {\n-                            format!(\"{} {}\", binding, ident)\n-                        } else {\n-                            ident.to_string()\n-                        };\n-                        err.span_suggestion(\n-                            fieldpat.span,\n-                            \"use shorthand field pattern\",\n-                            ident,\n-                            Applicability::MachineApplicable,\n-                        );\n-                        err.emit();\n+                        cx.struct_span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span, |lint| {\n+                            let mut err = lint\n+                                .build(&format!(\"the `{}:` in this pattern is redundant\", ident));\n+                            let binding = match binding_annot {\n+                                hir::BindingAnnotation::Unannotated => None,\n+                                hir::BindingAnnotation::Mutable => Some(\"mut\"),\n+                                hir::BindingAnnotation::Ref => Some(\"ref\"),\n+                                hir::BindingAnnotation::RefMut => Some(\"ref mut\"),\n+                            };\n+                            let ident = if let Some(binding) = binding {\n+                                format!(\"{} {}\", binding, ident)\n+                            } else {\n+                                ident.to_string()\n+                            };\n+                            err.span_suggestion(\n+                                fieldpat.span,\n+                                \"use shorthand field pattern\",\n+                                ident,\n+                                Applicability::MachineApplicable,\n+                            );\n+                            err.emit();\n+                        });\n                     }\n                 }\n             }\n@@ -213,46 +216,58 @@ declare_lint! {\n declare_lint_pass!(UnsafeCode => [UNSAFE_CODE]);\n \n impl UnsafeCode {\n-    fn report_unsafe(&self, cx: &EarlyContext<'_>, span: Span, desc: &'static str) {\n+    fn report_unsafe(\n+        &self,\n+        cx: &EarlyContext<'_>,\n+        span: Span,\n+        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>),\n+    ) {\n         // This comes from a macro that has `#[allow_internal_unsafe]`.\n         if span.allows_unsafe() {\n             return;\n         }\n \n-        cx.span_lint(UNSAFE_CODE, span, desc);\n+        cx.struct_span_lint(UNSAFE_CODE, span, decorate);\n     }\n }\n \n impl EarlyLintPass for UnsafeCode {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &ast::Attribute) {\n         if attr.check_name(sym::allow_internal_unsafe) {\n-            self.report_unsafe(\n-                cx,\n-                attr.span,\n-                \"`allow_internal_unsafe` allows defining \\\n+            self.report_unsafe(cx, attr.span, |lint| {\n+                lint.build(\n+                    \"`allow_internal_unsafe` allows defining \\\n                                                macros using unsafe without triggering \\\n                                                the `unsafe_code` lint at their call site\",\n-            );\n+                )\n+                .emit()\n+            });\n         }\n     }\n \n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         if let ast::ExprKind::Block(ref blk, _) = e.kind {\n             // Don't warn about generated blocks; that'll just pollute the output.\n             if blk.rules == ast::BlockCheckMode::Unsafe(ast::UserProvided) {\n-                self.report_unsafe(cx, blk.span, \"usage of an `unsafe` block\");\n+                self.report_unsafe(cx, blk.span, |lint| {\n+                    lint.build(\"usage of an `unsafe` block\").emit()\n+                });\n             }\n         }\n     }\n \n     fn check_item(&mut self, cx: &EarlyContext<'_>, it: &ast::Item) {\n         match it.kind {\n             ast::ItemKind::Trait(_, ast::Unsafety::Unsafe, ..) => {\n-                self.report_unsafe(cx, it.span, \"declaration of an `unsafe` trait\")\n+                self.report_unsafe(cx, it.span, |lint| {\n+                    lint.build(\"declaration of an `unsafe` trait\").emit()\n+                })\n             }\n \n             ast::ItemKind::Impl { unsafety: ast::Unsafety::Unsafe, .. } => {\n-                self.report_unsafe(cx, it.span, \"implementation of an `unsafe` trait\")\n+                self.report_unsafe(cx, it.span, |lint| {\n+                    lint.build(\"implementation of an `unsafe` trait\").emit()\n+                })\n             }\n \n             _ => return,\n@@ -274,7 +289,7 @@ impl EarlyLintPass for UnsafeCode {\n                 FnCtxt::Assoc(_) if body.is_none() => \"declaration of an `unsafe` method\",\n                 FnCtxt::Assoc(_) => \"implementation of an `unsafe` method\",\n             };\n-            self.report_unsafe(cx, span, msg);\n+            self.report_unsafe(cx, span, |lint| lint.build(msg).emit());\n         }\n     }\n }\n@@ -359,11 +374,9 @@ impl MissingDoc {\n \n         let has_doc = attrs.iter().any(|a| has_doc(a));\n         if !has_doc {\n-            cx.span_lint(\n-                MISSING_DOCS,\n-                cx.tcx.sess.source_map().def_span(sp),\n-                &format!(\"missing documentation for {}\", desc),\n-            );\n+            cx.struct_span_lint(MISSING_DOCS, cx.tcx.sess.source_map().def_span(sp), |lint| {\n+                lint.build(&format!(\"missing documentation for {}\", desc)).emit()\n+            });\n         }\n     }\n }\n@@ -391,10 +404,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         for macro_def in krate.exported_macros {\n             let has_doc = macro_def.attrs.iter().any(|a| has_doc(a));\n             if !has_doc {\n-                cx.span_lint(\n+                cx.struct_span_lint(\n                     MISSING_DOCS,\n                     cx.tcx.sess.source_map().def_span(macro_def.span),\n-                    \"missing documentation for macro\",\n+                    |lint| lint.build(\"missing documentation for macro\").emit(),\n                 );\n             }\n         }\n@@ -542,12 +555,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n             return;\n         }\n         if can_type_implement_copy(cx.tcx, param_env, ty).is_ok() {\n-            cx.span_lint(\n-                MISSING_COPY_IMPLEMENTATIONS,\n-                item.span,\n-                \"type could implement `Copy`; consider adding `impl \\\n+            cx.struct_span_lint(MISSING_COPY_IMPLEMENTATIONS, item.span, |lint| {\n+                lint.build(\n+                    \"type could implement `Copy`; consider adding `impl \\\n                           Copy`\",\n-            )\n+                )\n+                .emit()\n+            })\n         }\n     }\n }\n@@ -596,15 +610,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n         }\n \n         if !self.impling_types.as_ref().unwrap().contains(&item.hir_id) {\n-            cx.span_lint(\n-                MISSING_DEBUG_IMPLEMENTATIONS,\n-                item.span,\n-                &format!(\n+            cx.struct_span_lint(MISSING_DEBUG_IMPLEMENTATIONS, item.span, |lint| {\n+                lint.build(&format!(\n                     \"type does not implement `{}`; consider adding `#[derive(Debug)]` \\\n                      or a manual implementation\",\n                     cx.tcx.def_path_str(debug)\n-                ),\n-            );\n+                ))\n+                .emit()\n+            });\n         }\n     }\n }\n@@ -632,28 +645,28 @@ impl EarlyLintPass for AnonymousParameters {\n                     match arg.pat.kind {\n                         ast::PatKind::Ident(_, ident, None) => {\n                             if ident.name == kw::Invalid {\n-                                let ty_snip = cx.sess.source_map().span_to_snippet(arg.ty.span);\n+                                cx.struct_span_lint(ANONYMOUS_PARAMETERS, arg.pat.span, |lint| {\n+                                    let ty_snip = cx.sess.source_map().span_to_snippet(arg.ty.span);\n \n-                                let (ty_snip, appl) = if let Ok(snip) = ty_snip {\n-                                    (snip, Applicability::MachineApplicable)\n-                                } else {\n-                                    (\"<type>\".to_owned(), Applicability::HasPlaceholders)\n-                                };\n+                                    let (ty_snip, appl) = if let Ok(ref snip) = ty_snip {\n+                                        (snip.as_str(), Applicability::MachineApplicable)\n+                                    } else {\n+                                        (\"<type>\", Applicability::HasPlaceholders)\n+                                    };\n \n-                                cx.struct_span_lint(\n-                                    ANONYMOUS_PARAMETERS,\n-                                    arg.pat.span,\n-                                    \"anonymous parameters are deprecated and will be \\\n+                                    lint.build(\n+                                        \"anonymous parameters are deprecated and will be \\\n                                      removed in the next edition.\",\n-                                )\n-                                .span_suggestion(\n-                                    arg.pat.span,\n-                                    \"try naming the parameter or explicitly \\\n-                                    ignoring it\",\n-                                    format!(\"_: {}\", ty_snip),\n-                                    appl,\n-                                )\n-                                .emit();\n+                                    )\n+                                    .span_suggestion(\n+                                        arg.pat.span,\n+                                        \"try naming the parameter or explicitly \\\n+                                            ignoring it\",\n+                                        format!(\"_: {}\", ty_snip),\n+                                        appl,\n+                                    )\n+                                    .emit();\n+                                })\n                             }\n                         }\n                         _ => (),\n@@ -687,14 +700,16 @@ fn lint_deprecated_attr(\n     msg: &str,\n     suggestion: Option<&str>,\n ) {\n-    cx.struct_span_lint(DEPRECATED, attr.span, &msg)\n-        .span_suggestion_short(\n-            attr.span,\n-            suggestion.unwrap_or(\"remove this attribute\"),\n-            String::new(),\n-            Applicability::MachineApplicable,\n-        )\n-        .emit();\n+    cx.struct_span_lint(DEPRECATED, attr.span, |lint| {\n+        lint.build(msg)\n+            .span_suggestion_short(\n+                attr.span,\n+                suggestion.unwrap_or(\"remove this attribute\"),\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n+    })\n }\n \n impl EarlyLintPass for DeprecatedAttr {\n@@ -759,21 +774,20 @@ impl UnusedDocComment {\n             let span = sugared_span.take().unwrap_or_else(|| attr.span);\n \n             if attr.is_doc_comment() || attr.check_name(sym::doc) {\n-                let mut err = cx.struct_span_lint(UNUSED_DOC_COMMENTS, span, \"unused doc comment\");\n-\n-                err.span_label(\n-                    node_span,\n-                    format!(\"rustdoc does not generate documentation for {}\", node_kind),\n-                );\n-\n-                if is_macro_expansion {\n-                    err.help(\n-                        \"to document an item produced by a macro, \\\n-                              the macro must produce the documentation as part of its expansion\",\n+                cx.struct_span_lint(UNUSED_DOC_COMMENTS, span, |lint| {\n+                    let mut err = lint.build(\"unused doc comment\");\n+                    err.span_label(\n+                        node_span,\n+                        format!(\"rustdoc does not generate documentation for {}\", node_kind),\n                     );\n-                }\n-\n-                err.emit();\n+                    if is_macro_expansion {\n+                        err.help(\n+                            \"to document an item produced by a macro, \\\n+                                  the macro must produce the documentation as part of its expansion\",\n+                        );\n+                    }\n+                    err.emit();\n+                });\n             }\n         }\n     }\n@@ -831,20 +845,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                         match param.kind {\n                             GenericParamKind::Lifetime { .. } => {}\n                             GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n-                                let mut err = cx.struct_span_lint(\n-                                    NO_MANGLE_GENERIC_ITEMS,\n-                                    it.span,\n-                                    \"functions generic over types or consts must be mangled\",\n-                                );\n-                                err.span_suggestion_short(\n-                                    no_mangle_attr.span,\n-                                    \"remove this attribute\",\n-                                    String::new(),\n-                                    // Use of `#[no_mangle]` suggests FFI intent; correct\n-                                    // fix may be to monomorphize source by hand\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                                err.emit();\n+                                cx.struct_span_lint(NO_MANGLE_GENERIC_ITEMS, it.span, |lint| {\n+                                    lint.build(\n+                                        \"functions generic over types or consts must be mangled\",\n+                                    )\n+                                    .span_suggestion_short(\n+                                        no_mangle_attr.span,\n+                                        \"remove this attribute\",\n+                                        String::new(),\n+                                        // Use of `#[no_mangle]` suggests FFI intent; correct\n+                                        // fix may be to monomorphize source by hand\n+                                        Applicability::MaybeIncorrect,\n+                                    )\n+                                    .emit();\n+                                });\n                                 break;\n                             }\n                         }\n@@ -855,26 +869,28 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                 if attr::contains_name(&it.attrs, sym::no_mangle) {\n                     // Const items do not refer to a particular location in memory, and therefore\n                     // don't have anything to attach a symbol to\n-                    let msg = \"const items should never be `#[no_mangle]`\";\n-                    let mut err = cx.struct_span_lint(NO_MANGLE_CONST_ITEMS, it.span, msg);\n-\n-                    // account for \"pub const\" (#45562)\n-                    let start = cx\n-                        .tcx\n-                        .sess\n-                        .source_map()\n-                        .span_to_snippet(it.span)\n-                        .map(|snippet| snippet.find(\"const\").unwrap_or(0))\n-                        .unwrap_or(0) as u32;\n-                    // `const` is 5 chars\n-                    let const_span = it.span.with_hi(BytePos(it.span.lo().0 + start + 5));\n-                    err.span_suggestion(\n-                        const_span,\n-                        \"try a static value\",\n-                        \"pub static\".to_owned(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                    err.emit();\n+                    cx.struct_span_lint(NO_MANGLE_CONST_ITEMS, it.span, |lint| {\n+                        let msg = \"const items should never be `#[no_mangle]`\";\n+                        let mut err = lint.build(msg);\n+\n+                        // account for \"pub const\" (#45562)\n+                        let start = cx\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .span_to_snippet(it.span)\n+                            .map(|snippet| snippet.find(\"const\").unwrap_or(0))\n+                            .unwrap_or(0) as u32;\n+                        // `const` is 5 chars\n+                        let const_span = it.span.with_hi(BytePos(it.span.lo().0 + start + 5));\n+                        err.span_suggestion(\n+                            const_span,\n+                            \"try a static value\",\n+                            \"pub static\".to_owned(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                        err.emit();\n+                    });\n                 }\n             }\n             _ => {}\n@@ -894,12 +910,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n     fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) {\n         use rustc_target::spec::abi::Abi::RustIntrinsic;\n \n-        let msg = \"mutating transmuted &mut T from &T may cause undefined behavior, \\\n-                   consider instead using an UnsafeCell\";\n         match get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (&ty1.kind, &ty2.kind)) {\n             Some((&ty::Ref(_, _, from_mt), &ty::Ref(_, _, to_mt))) => {\n                 if to_mt == hir::Mutability::Mut && from_mt == hir::Mutability::Not {\n-                    cx.span_lint(MUTABLE_TRANSMUTES, expr.span, msg);\n+                    let msg = \"mutating transmuted &mut T from &T may cause undefined behavior, \\\n+                               consider instead using an UnsafeCell\";\n+                    cx.struct_span_lint(MUTABLE_TRANSMUTES, expr.span, |lint| {\n+                        lint.build(msg).emit()\n+                    });\n                 }\n             }\n             _ => (),\n@@ -949,7 +967,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnstableFeatures {\n         if attr.check_name(sym::feature) {\n             if let Some(items) = attr.meta_item_list() {\n                 for item in items {\n-                    ctx.span_lint(UNSTABLE_FEATURES, item.span(), \"unstable feature\");\n+                    ctx.struct_span_lint(UNSTABLE_FEATURES, item.span(), |lint| {\n+                        lint.build(\"unstable feature\").emit()\n+                    });\n                 }\n             }\n         }\n@@ -984,28 +1004,26 @@ impl UnreachablePub {\n                     applicability = Applicability::MaybeIncorrect;\n                 }\n                 let def_span = cx.tcx.sess.source_map().def_span(span);\n-                let mut err = cx.struct_span_lint(\n-                    UNREACHABLE_PUB,\n-                    def_span,\n-                    &format!(\"unreachable `pub` {}\", what),\n-                );\n-                let replacement = if cx.tcx.features().crate_visibility_modifier {\n-                    \"crate\"\n-                } else {\n-                    \"pub(crate)\"\n-                }\n-                .to_owned();\n+                cx.struct_span_lint(UNREACHABLE_PUB, def_span, |lint| {\n+                    let mut err = lint.build(&format!(\"unreachable `pub` {}\", what));\n+                    let replacement = if cx.tcx.features().crate_visibility_modifier {\n+                        \"crate\"\n+                    } else {\n+                        \"pub(crate)\"\n+                    }\n+                    .to_owned();\n \n-                err.span_suggestion(\n-                    vis.span,\n-                    \"consider restricting its visibility\",\n-                    replacement,\n-                    applicability,\n-                );\n-                if exportable {\n-                    err.help(\"or consider exporting it for use by other crates\");\n-                }\n-                err.emit();\n+                    err.span_suggestion(\n+                        vis.span,\n+                        \"consider restricting its visibility\",\n+                        replacement,\n+                        applicability,\n+                    );\n+                    if exportable {\n+                        err.help(\"or consider exporting it for use by other crates\");\n+                    }\n+                    err.emit();\n+                });\n             }\n             _ => {}\n         }\n@@ -1114,28 +1132,30 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeAliasBounds {\n         let mut suggested_changing_assoc_types = false;\n         // There must not be a where clause\n         if !type_alias_generics.where_clause.predicates.is_empty() {\n-            let spans: Vec<_> = type_alias_generics\n-                .where_clause\n-                .predicates\n-                .iter()\n-                .map(|pred| pred.span())\n-                .collect();\n-            let mut err = cx.struct_span_lint(\n+            cx.lint(\n                 TYPE_ALIAS_BOUNDS,\n-                spans,\n-                \"where clauses are not enforced in type aliases\",\n-            );\n-            err.span_suggestion(\n-                type_alias_generics.where_clause.span_for_predicates_or_empty_place(),\n-                \"the clause will not be checked when the type alias is used, and should be removed\",\n-                String::new(),\n-                Applicability::MachineApplicable,\n+                |lint| {\n+                    let mut err = lint.build(\"where clauses are not enforced in type aliases\");\n+                    let spans: Vec<_> = type_alias_generics\n+                        .where_clause\n+                        .predicates\n+                        .iter()\n+                        .map(|pred| pred.span())\n+                        .collect();\n+                    err.set_span(spans);\n+                    err.span_suggestion(\n+                        type_alias_generics.where_clause.span_for_predicates_or_empty_place(),\n+                        \"the clause will not be checked when the type alias is used, and should be removed\",\n+                        String::new(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                    if !suggested_changing_assoc_types {\n+                        TypeAliasBounds::suggest_changing_assoc_types(ty, &mut err);\n+                        suggested_changing_assoc_types = true;\n+                    }\n+                    err.emit();\n+                },\n             );\n-            if !suggested_changing_assoc_types {\n-                TypeAliasBounds::suggest_changing_assoc_types(ty, &mut err);\n-                suggested_changing_assoc_types = true;\n-            }\n-            err.emit();\n         }\n         // The parameters must not have bounds\n         for param in type_alias_generics.params.iter() {\n@@ -1148,19 +1168,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeAliasBounds {\n                 })\n                 .collect();\n             if !spans.is_empty() {\n-                let mut err = cx.struct_span_lint(\n-                    TYPE_ALIAS_BOUNDS,\n-                    spans,\n-                    \"bounds on generic parameters are not enforced in type aliases\",\n-                );\n-                let msg = \"the bound will not be checked when the type alias is used, \\\n-                           and should be removed\";\n-                err.multipart_suggestion(&msg, suggestion, Applicability::MachineApplicable);\n-                if !suggested_changing_assoc_types {\n-                    TypeAliasBounds::suggest_changing_assoc_types(ty, &mut err);\n-                    suggested_changing_assoc_types = true;\n-                }\n-                err.emit();\n+                cx.struct_span_lint(TYPE_ALIAS_BOUNDS, spans, |lint| {\n+                    let mut err =\n+                        lint.build(\"bounds on generic parameters are not enforced in type aliases\");\n+                    let msg = \"the bound will not be checked when the type alias is used, \\\n+                                   and should be removed\";\n+                    err.multipart_suggestion(&msg, suggestion, Applicability::MachineApplicable);\n+                    if !suggested_changing_assoc_types {\n+                        TypeAliasBounds::suggest_changing_assoc_types(ty, &mut err);\n+                        suggested_changing_assoc_types = true;\n+                    }\n+                    err.emit();\n+                });\n             }\n         }\n     }\n@@ -1232,15 +1251,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n                     ConstEvaluatable(..) => continue,\n                 };\n                 if predicate.is_global() {\n-                    cx.span_lint(\n-                        TRIVIAL_BOUNDS,\n-                        span,\n-                        &format!(\n+                    cx.struct_span_lint(TRIVIAL_BOUNDS, span, |lint| {\n+                        lint.build(&format!(\n                             \"{} bound {} does not depend on any type \\\n                                 or lifetime parameters\",\n                             predicate_kind_name, predicate\n-                        ),\n-                    );\n+                        ))\n+                        .emit()\n+                    });\n                 }\n             }\n         }\n@@ -1317,28 +1335,32 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n             let suggestion = \"use `..=` for an inclusive range\";\n             if parenthesise {\n                 self.node_id = Some(pat.id);\n-                let end = expr_to_string(&end);\n-                let replace = match start {\n-                    Some(start) => format!(\"&({}..={})\", expr_to_string(&start), end),\n-                    None => format!(\"&(..={})\", end),\n-                };\n-                let mut err = cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, pat.span, msg);\n-                err.span_suggestion(\n-                    pat.span,\n-                    suggestion,\n-                    replace,\n-                    Applicability::MachineApplicable,\n-                );\n-                err.emit();\n+                cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, pat.span, |lint| {\n+                    let end = expr_to_string(&end);\n+                    let replace = match start {\n+                        Some(start) => format!(\"&({}..={})\", expr_to_string(&start), end),\n+                        None => format!(\"&(..={})\", end),\n+                    };\n+                    lint.build(msg)\n+                        .span_suggestion(\n+                            pat.span,\n+                            suggestion,\n+                            replace,\n+                            Applicability::MachineApplicable,\n+                        )\n+                        .emit();\n+                });\n             } else {\n-                let mut err = cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, join, msg);\n-                err.span_suggestion_short(\n-                    join,\n-                    suggestion,\n-                    \"..=\".to_owned(),\n-                    Applicability::MachineApplicable,\n-                );\n-                err.emit();\n+                cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, join, |lint| {\n+                    lint.build(msg)\n+                        .span_suggestion_short(\n+                            join,\n+                            suggestion,\n+                            \"..=\".to_owned(),\n+                            Applicability::MachineApplicable,\n+                        )\n+                        .emit();\n+                });\n             };\n         }\n     }\n@@ -1384,7 +1406,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n         }\n \n         if let Some(attr) = attr::find_by_name(&it.attrs, sym::rustc_test_marker) {\n-            cx.struct_span_lint(UNNAMEABLE_TEST_ITEMS, attr.span, \"cannot test inner items\").emit();\n+            cx.struct_span_lint(UNNAMEABLE_TEST_ITEMS, attr.span, |lint| {\n+                lint.build(\"cannot test inner items\").emit()\n+            });\n         }\n     }\n \n@@ -1465,18 +1489,16 @@ impl KeywordIdents {\n             return;\n         }\n \n-        let mut lint = cx.struct_span_lint(\n-            KEYWORD_IDENTS,\n-            ident.span,\n-            &format!(\"`{}` is a keyword in the {} edition\", ident, next_edition),\n-        );\n-        lint.span_suggestion(\n-            ident.span,\n-            \"you can use a raw identifier to stay compatible\",\n-            format!(\"r#{}\", ident),\n-            Applicability::MachineApplicable,\n-        );\n-        lint.emit()\n+        cx.struct_span_lint(KEYWORD_IDENTS, ident.span, |lint| {\n+            lint.build(&format!(\"`{}` is a keyword in the {} edition\", ident, next_edition))\n+                .span_suggestion(\n+                    ident.span,\n+                    \"you can use a raw identifier to stay compatible\",\n+                    format!(\"r#{}\", ident),\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit()\n+        });\n     }\n }\n \n@@ -1780,17 +1802,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n             }\n \n             if !lint_spans.is_empty() {\n-                let mut err = cx.struct_span_lint(\n-                    EXPLICIT_OUTLIVES_REQUIREMENTS,\n-                    lint_spans.clone(),\n-                    \"outlives requirements can be inferred\",\n-                );\n-                err.multipart_suggestion(\n-                    if bound_count == 1 { \"remove this bound\" } else { \"remove these bounds\" },\n-                    lint_spans.into_iter().map(|span| (span, \"\".to_owned())).collect::<Vec<_>>(),\n-                    Applicability::MachineApplicable,\n-                );\n-                err.emit();\n+                cx.struct_span_lint(EXPLICIT_OUTLIVES_REQUIREMENTS, lint_spans.clone(), |lint| {\n+                    lint.build(\"outlives requirements can be inferred\")\n+                        .multipart_suggestion(\n+                            if bound_count == 1 {\n+                                \"remove this bound\"\n+                            } else {\n+                                \"remove these bounds\"\n+                            },\n+                            lint_spans\n+                                .into_iter()\n+                                .map(|span| (span, \"\".to_owned()))\n+                                .collect::<Vec<_>>(),\n+                            Applicability::MachineApplicable,\n+                        )\n+                        .emit();\n+                });\n             }\n         }\n     }\n@@ -1817,15 +1844,13 @@ impl EarlyLintPass for IncompleteFeatures {\n             .chain(features.declared_lib_features.iter().map(|(name, span)| (name, span)))\n             .filter(|(name, _)| rustc_feature::INCOMPLETE_FEATURES.iter().any(|f| name == &f))\n             .for_each(|(name, &span)| {\n-                cx.struct_span_lint(\n-                    INCOMPLETE_FEATURES,\n-                    span,\n-                    &format!(\n+                cx.struct_span_lint(INCOMPLETE_FEATURES, span, |lint| {\n+                    lint.build(&format!(\n                         \"the feature `{}` is incomplete and may cause the compiler to crash\",\n                         name,\n-                    ),\n-                )\n-                .emit();\n+                    ))\n+                    .emit()\n+                })\n             });\n     }\n }\n@@ -2015,30 +2040,28 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n             // We are extremely conservative with what we warn about.\n             let conjured_ty = cx.tables.expr_ty(expr);\n             if let Some((msg, span)) = ty_find_init_error(cx.tcx, conjured_ty, init) {\n-                let mut err = cx.struct_span_lint(\n-                    INVALID_VALUE,\n-                    expr.span,\n-                    &format!(\n+                cx.struct_span_lint(INVALID_VALUE, expr.span, |lint| {\n+                    let mut err = lint.build(&format!(\n                         \"the type `{}` does not permit {}\",\n                         conjured_ty,\n                         match init {\n                             InitKind::Zeroed => \"zero-initialization\",\n                             InitKind::Uninit => \"being left uninitialized\",\n                         },\n-                    ),\n-                );\n-                err.span_label(expr.span, \"this code causes undefined behavior when executed\");\n-                err.span_label(\n-                    expr.span,\n-                    \"help: use `MaybeUninit<T>` instead, \\\n-                    and only call `assume_init` after initialization is done\",\n-                );\n-                if let Some(span) = span {\n-                    err.span_note(span, &msg);\n-                } else {\n-                    err.note(&msg);\n-                }\n-                err.emit();\n+                    ));\n+                    err.span_label(expr.span, \"this code causes undefined behavior when executed\");\n+                    err.span_label(\n+                        expr.span,\n+                        \"help: use `MaybeUninit<T>` instead, \\\n+                            and only call `assume_init` after initialization is done\",\n+                    );\n+                    if let Some(span) = span {\n+                        err.span_note(span, &msg);\n+                    } else {\n+                        err.note(&msg);\n+                    }\n+                    err.emit();\n+                });\n             }\n         }\n     }"}, {"sha": "8e8beefa72f1397114d5184b0993e76bca3917a6", "filename": "src/librustc_lint/context.rs", "status": "modified", "additions": 99, "deletions": 125, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_lint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_lint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fcontext.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -20,13 +20,14 @@ use crate::levels::LintLevelsBuilder;\n use crate::passes::{EarlyLintPassObject, LateLintPassObject};\n use rustc::hir::map::definitions::{DefPathData, DisambiguatedDefPathData};\n use rustc::lint::add_elided_lifetime_in_path_suggestion;\n+use rustc::lint::LintDiagnosticBuilder;\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability;\n use rustc::ty::layout::{LayoutError, LayoutOf, TyLayout};\n use rustc::ty::{self, print::Printer, subst::GenericArg, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync;\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_session::lint::BuiltinLintDiagnostics;\n@@ -473,150 +474,123 @@ pub trait LintContext: Sized {\n     fn sess(&self) -> &Session;\n     fn lints(&self) -> &LintStore;\n \n-    fn lookup_and_emit<S: Into<MultiSpan>>(&self, lint: &'static Lint, span: Option<S>, msg: &str) {\n-        self.lookup(lint, span, msg).emit();\n-    }\n-\n-    fn lookup_and_emit_with_diagnostics<S: Into<MultiSpan>>(\n+    fn lookup_with_diagnostics(\n         &self,\n         lint: &'static Lint,\n-        span: Option<S>,\n-        msg: &str,\n+        span: Option<impl Into<MultiSpan>>,\n+        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>),\n         diagnostic: BuiltinLintDiagnostics,\n     ) {\n-        let mut db = self.lookup(lint, span, msg);\n-\n-        let sess = self.sess();\n-        match diagnostic {\n-            BuiltinLintDiagnostics::Normal => (),\n-            BuiltinLintDiagnostics::BareTraitObject(span, is_global) => {\n-                let (sugg, app) = match sess.source_map().span_to_snippet(span) {\n-                    Ok(s) if is_global => {\n-                        (format!(\"dyn ({})\", s), Applicability::MachineApplicable)\n-                    }\n-                    Ok(s) => (format!(\"dyn {}\", s), Applicability::MachineApplicable),\n-                    Err(_) => (\"dyn <type>\".to_string(), Applicability::HasPlaceholders),\n-                };\n-                db.span_suggestion(span, \"use `dyn`\", sugg, app);\n-            }\n-            BuiltinLintDiagnostics::AbsPathWithModule(span) => {\n-                let (sugg, app) = match sess.source_map().span_to_snippet(span) {\n-                    Ok(ref s) => {\n-                        // FIXME(Manishearth) ideally the emitting code\n-                        // can tell us whether or not this is global\n-                        let opt_colon = if s.trim_start().starts_with(\"::\") { \"\" } else { \"::\" };\n-\n-                        (format!(\"crate{}{}\", opt_colon, s), Applicability::MachineApplicable)\n-                    }\n-                    Err(_) => (\"crate::<path>\".to_string(), Applicability::HasPlaceholders),\n-                };\n-                db.span_suggestion(span, \"use `crate`\", sugg, app);\n-            }\n-            BuiltinLintDiagnostics::ProcMacroDeriveResolutionFallback(span) => {\n-                db.span_label(\n-                    span,\n-                    \"names from parent modules are not accessible without an explicit import\",\n-                );\n-            }\n-            BuiltinLintDiagnostics::MacroExpandedMacroExportsAccessedByAbsolutePaths(span_def) => {\n-                db.span_note(span_def, \"the macro is defined here\");\n-            }\n-            BuiltinLintDiagnostics::ElidedLifetimesInPaths(\n-                n,\n-                path_span,\n-                incl_angl_brckt,\n-                insertion_span,\n-                anon_lts,\n-            ) => {\n-                add_elided_lifetime_in_path_suggestion(\n-                    sess,\n-                    &mut db,\n+        self.lookup(lint, span, |lint| {\n+            // We first generate a blank diagnostic.\n+            let mut db = lint.build(\"\");\n+\n+            // Now, set up surrounding context.\n+            let sess = self.sess();\n+            match diagnostic {\n+                BuiltinLintDiagnostics::Normal => (),\n+                BuiltinLintDiagnostics::BareTraitObject(span, is_global) => {\n+                    let (sugg, app) = match sess.source_map().span_to_snippet(span) {\n+                        Ok(s) if is_global => {\n+                            (format!(\"dyn ({})\", s), Applicability::MachineApplicable)\n+                        }\n+                        Ok(s) => (format!(\"dyn {}\", s), Applicability::MachineApplicable),\n+                        Err(_) => (\"dyn <type>\".to_string(), Applicability::HasPlaceholders),\n+                    };\n+                    db.span_suggestion(span, \"use `dyn`\", sugg, app);\n+                }\n+                BuiltinLintDiagnostics::AbsPathWithModule(span) => {\n+                    let (sugg, app) = match sess.source_map().span_to_snippet(span) {\n+                        Ok(ref s) => {\n+                            // FIXME(Manishearth) ideally the emitting code\n+                            // can tell us whether or not this is global\n+                            let opt_colon =\n+                                if s.trim_start().starts_with(\"::\") { \"\" } else { \"::\" };\n+\n+                            (format!(\"crate{}{}\", opt_colon, s), Applicability::MachineApplicable)\n+                        }\n+                        Err(_) => (\"crate::<path>\".to_string(), Applicability::HasPlaceholders),\n+                    };\n+                    db.span_suggestion(span, \"use `crate`\", sugg, app);\n+                }\n+                BuiltinLintDiagnostics::ProcMacroDeriveResolutionFallback(span) => {\n+                    db.span_label(\n+                        span,\n+                        \"names from parent modules are not accessible without an explicit import\",\n+                    );\n+                }\n+                BuiltinLintDiagnostics::MacroExpandedMacroExportsAccessedByAbsolutePaths(\n+                    span_def,\n+                ) => {\n+                    db.span_note(span_def, \"the macro is defined here\");\n+                }\n+                BuiltinLintDiagnostics::ElidedLifetimesInPaths(\n                     n,\n                     path_span,\n                     incl_angl_brckt,\n                     insertion_span,\n                     anon_lts,\n-                );\n-            }\n-            BuiltinLintDiagnostics::UnknownCrateTypes(span, note, sugg) => {\n-                db.span_suggestion(span, &note, sugg, Applicability::MaybeIncorrect);\n-            }\n-            BuiltinLintDiagnostics::UnusedImports(message, replaces) => {\n-                if !replaces.is_empty() {\n-                    db.tool_only_multipart_suggestion(\n-                        &message,\n-                        replaces,\n-                        Applicability::MachineApplicable,\n+                ) => {\n+                    add_elided_lifetime_in_path_suggestion(\n+                        sess,\n+                        &mut db,\n+                        n,\n+                        path_span,\n+                        incl_angl_brckt,\n+                        insertion_span,\n+                        anon_lts,\n                     );\n                 }\n-            }\n-            BuiltinLintDiagnostics::RedundantImport(spans, ident) => {\n-                for (span, is_imported) in spans {\n-                    let introduced = if is_imported { \"imported\" } else { \"defined\" };\n-                    db.span_label(\n-                        span,\n-                        format!(\"the item `{}` is already {} here\", ident, introduced),\n-                    );\n+                BuiltinLintDiagnostics::UnknownCrateTypes(span, note, sugg) => {\n+                    db.span_suggestion(span, &note, sugg, Applicability::MaybeIncorrect);\n+                }\n+                BuiltinLintDiagnostics::UnusedImports(message, replaces) => {\n+                    if !replaces.is_empty() {\n+                        db.tool_only_multipart_suggestion(\n+                            &message,\n+                            replaces,\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                }\n+                BuiltinLintDiagnostics::RedundantImport(spans, ident) => {\n+                    for (span, is_imported) in spans {\n+                        let introduced = if is_imported { \"imported\" } else { \"defined\" };\n+                        db.span_label(\n+                            span,\n+                            format!(\"the item `{}` is already {} here\", ident, introduced),\n+                        );\n+                    }\n+                }\n+                BuiltinLintDiagnostics::DeprecatedMacro(suggestion, span) => {\n+                    stability::deprecation_suggestion(&mut db, suggestion, span)\n                 }\n             }\n-            BuiltinLintDiagnostics::DeprecatedMacro(suggestion, span) => {\n-                stability::deprecation_suggestion(&mut db, suggestion, span)\n-            }\n-        }\n-\n-        db.emit();\n+            // Rewrap `db`, and pass control to the user.\n+            decorate(LintDiagnosticBuilder::new(db));\n+        });\n     }\n \n+    // FIXME: These methods should not take an Into<MultiSpan> -- instead, callers should need to\n+    // set the span in their `decorate` function (preferably using set_span).\n     fn lookup<S: Into<MultiSpan>>(\n         &self,\n         lint: &'static Lint,\n         span: Option<S>,\n-        msg: &str,\n-    ) -> DiagnosticBuilder<'_>;\n-\n-    /// Emit a lint at the appropriate level, for a particular span.\n-    fn span_lint<S: Into<MultiSpan>>(&self, lint: &'static Lint, span: S, msg: &str) {\n-        self.lookup_and_emit(lint, Some(span), msg);\n-    }\n+        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>),\n+    );\n \n     fn struct_span_lint<S: Into<MultiSpan>>(\n         &self,\n         lint: &'static Lint,\n         span: S,\n-        msg: &str,\n-    ) -> DiagnosticBuilder<'_> {\n-        self.lookup(lint, Some(span), msg)\n-    }\n-\n-    /// Emit a lint and note at the appropriate level, for a particular span.\n-    fn span_lint_note(\n-        &self,\n-        lint: &'static Lint,\n-        span: Span,\n-        msg: &str,\n-        note_span: Span,\n-        note: &str,\n+        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>),\n     ) {\n-        let mut err = self.lookup(lint, Some(span), msg);\n-        if note_span == span {\n-            err.note(note);\n-        } else {\n-            err.span_note(note_span, note);\n-        }\n-        err.emit();\n+        self.lookup(lint, Some(span), decorate);\n     }\n-\n-    /// Emit a lint and help at the appropriate level, for a particular span.\n-    fn span_lint_help(&self, lint: &'static Lint, span: Span, msg: &str, help: &str) {\n-        let mut err = self.lookup(lint, Some(span), msg);\n-        self.span_lint(lint, span, msg);\n-        err.span_help(span, help);\n-        err.emit();\n-    }\n-\n     /// Emit a lint at the appropriate level, with no associated span.\n-    fn lint(&self, lint: &'static Lint, msg: &str) {\n-        self.lookup_and_emit(lint, None as Option<Span>, msg);\n+    fn lint(&self, lint: &'static Lint, decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>)) {\n+        self.lookup(lint, None as Option<Span>, decorate);\n     }\n }\n \n@@ -654,13 +628,13 @@ impl LintContext for LateContext<'_, '_> {\n         &self,\n         lint: &'static Lint,\n         span: Option<S>,\n-        msg: &str,\n-    ) -> DiagnosticBuilder<'_> {\n+        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>),\n+    ) {\n         let hir_id = self.last_node_with_lint_attrs;\n \n         match span {\n-            Some(s) => self.tcx.struct_span_lint_hir(lint, hir_id, s, msg),\n-            None => self.tcx.struct_lint_node(lint, hir_id, msg),\n+            Some(s) => self.tcx.struct_span_lint_hir(lint, hir_id, s, decorate),\n+            None => self.tcx.struct_lint_node(lint, hir_id, decorate),\n         }\n     }\n }\n@@ -681,9 +655,9 @@ impl LintContext for EarlyContext<'_> {\n         &self,\n         lint: &'static Lint,\n         span: Option<S>,\n-        msg: &str,\n-    ) -> DiagnosticBuilder<'_> {\n-        self.builder.struct_lint(lint, span.map(|s| s.into()), msg)\n+        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>),\n+    ) {\n+        self.builder.struct_lint(lint, span.map(|s| s.into()), decorate)\n     }\n }\n "}, {"sha": "c351159067387938ce19f2907be7d93f41b39955", "filename": "src/librustc_lint/early.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_lint%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_lint%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fearly.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -37,11 +37,18 @@ struct EarlyContextAndPass<'a, T: EarlyLintPass> {\n impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n     fn check_id(&mut self, id: ast::NodeId) {\n         for early_lint in self.context.buffered.take(id) {\n-            self.context.lookup_and_emit_with_diagnostics(\n-                early_lint.lint_id.lint,\n-                Some(early_lint.span.clone()),\n-                &early_lint.msg,\n-                early_lint.diagnostic,\n+            let rustc_session::lint::BufferedEarlyLint {\n+                span,\n+                msg,\n+                node_id: _,\n+                lint_id,\n+                diagnostic,\n+            } = early_lint;\n+            self.context.lookup_with_diagnostics(\n+                lint_id.lint,\n+                Some(span),\n+                |lint| lint.build(&msg).emit(),\n+                diagnostic,\n             );\n         }\n     }"}, {"sha": "7875261911201bf784c73cec388e61f5ccbd4eeb", "filename": "src/librustc_lint/internal.rs", "status": "modified", "additions": 58, "deletions": 54, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_lint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_lint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Finternal.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -37,16 +37,22 @@ impl_lint_pass!(DefaultHashTypes => [DEFAULT_HASH_TYPES]);\n impl EarlyLintPass for DefaultHashTypes {\n     fn check_ident(&mut self, cx: &EarlyContext<'_>, ident: Ident) {\n         if let Some(replace) = self.map.get(&ident.name) {\n-            let msg = format!(\"Prefer {} over {}, it has better performance\", replace, ident);\n-            let mut db = cx.struct_span_lint(DEFAULT_HASH_TYPES, ident.span, &msg);\n-            db.span_suggestion(\n-                ident.span,\n-                \"use\",\n-                replace.to_string(),\n-                Applicability::MaybeIncorrect, // FxHashMap, ... needs another import\n-            );\n-            db.note(&format!(\"a `use rustc_data_structures::fx::{}` may be necessary\", replace))\n-                .emit();\n+            cx.struct_span_lint(DEFAULT_HASH_TYPES, ident.span, |lint| {\n+                // FIXME: We can avoid a copy here. Would require us to take String instead of &str.\n+                let msg = format!(\"Prefer {} over {}, it has better performance\", replace, ident);\n+                lint.build(&msg)\n+                    .span_suggestion(\n+                        ident.span,\n+                        \"use\",\n+                        replace.to_string(),\n+                        Applicability::MaybeIncorrect, // FxHashMap, ... needs another import\n+                    )\n+                    .note(&format!(\n+                        \"a `use rustc_data_structures::fx::{}` may be necessary\",\n+                        replace\n+                    ))\n+                    .emit();\n+            });\n         }\n     }\n }\n@@ -85,14 +91,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n         if let Some(last) = segments.last() {\n             let span = path.span.with_hi(last.ident.span.hi());\n             if lint_ty_kind_usage(cx, last) {\n-                cx.struct_span_lint(USAGE_OF_TY_TYKIND, span, \"usage of `ty::TyKind::<kind>`\")\n-                    .span_suggestion(\n-                        span,\n-                        \"try using ty::<kind> directly\",\n-                        \"ty\".to_string(),\n-                        Applicability::MaybeIncorrect, // ty maybe needs an import\n-                    )\n-                    .emit();\n+                cx.struct_span_lint(USAGE_OF_TY_TYKIND, span, |lint| {\n+                    lint.build(\"usage of `ty::TyKind::<kind>`\")\n+                        .span_suggestion(\n+                            span,\n+                            \"try using ty::<kind> directly\",\n+                            \"ty\".to_string(),\n+                            Applicability::MaybeIncorrect, // ty maybe needs an import\n+                        )\n+                        .emit();\n+                })\n             }\n         }\n     }\n@@ -103,32 +111,28 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n                 if let QPath::Resolved(_, path) = qpath {\n                     if let Some(last) = path.segments.iter().last() {\n                         if lint_ty_kind_usage(cx, last) {\n-                            cx.struct_span_lint(\n-                                USAGE_OF_TY_TYKIND,\n-                                path.span,\n-                                \"usage of `ty::TyKind`\",\n-                            )\n-                            .help(\"try using `Ty` instead\")\n-                            .emit();\n+                            cx.struct_span_lint(USAGE_OF_TY_TYKIND, path.span, |lint| {\n+                                lint.build(\"usage of `ty::TyKind`\")\n+                                    .help(\"try using `Ty` instead\")\n+                                    .emit();\n+                            })\n                         } else {\n                             if ty.span.from_expansion() {\n                                 return;\n                             }\n                             if let Some(t) = is_ty_or_ty_ctxt(cx, ty) {\n                                 if path.segments.len() > 1 {\n-                                    cx.struct_span_lint(\n-                                        USAGE_OF_QUALIFIED_TY,\n-                                        path.span,\n-                                        &format!(\"usage of qualified `ty::{}`\", t),\n-                                    )\n-                                    .span_suggestion(\n-                                        path.span,\n-                                        \"try using it unqualified\",\n-                                        t,\n-                                        // The import probably needs to be changed\n-                                        Applicability::MaybeIncorrect,\n-                                    )\n-                                    .emit();\n+                                    cx.struct_span_lint(USAGE_OF_QUALIFIED_TY, path.span, |lint| {\n+                                        lint.build(&format!(\"usage of qualified `ty::{}`\", t))\n+                                            .span_suggestion(\n+                                                path.span,\n+                                                \"try using it unqualified\",\n+                                                t,\n+                                                // The import probably needs to be changed\n+                                                Applicability::MaybeIncorrect,\n+                                            )\n+                                            .emit();\n+                                    })\n                                 }\n                             }\n                         }\n@@ -142,19 +146,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n                     }\n                 }\n                 if let Some(t) = is_ty_or_ty_ctxt(cx, &inner_ty) {\n-                    cx.struct_span_lint(\n-                        TY_PASS_BY_REFERENCE,\n-                        ty.span,\n-                        &format!(\"passing `{}` by reference\", t),\n-                    )\n-                    .span_suggestion(\n-                        ty.span,\n-                        \"try passing by value\",\n-                        t,\n-                        // Changing type of function argument\n-                        Applicability::MaybeIncorrect,\n-                    )\n-                    .emit();\n+                    cx.struct_span_lint(TY_PASS_BY_REFERENCE, ty.span, |lint| {\n+                        lint.build(&format!(\"passing `{}` by reference\", t))\n+                            .span_suggestion(\n+                                ty.span,\n+                                \"try passing by value\",\n+                                t,\n+                                // Changing type of function argument\n+                                Applicability::MaybeIncorrect,\n+                            )\n+                            .emit();\n+                    })\n                 }\n             }\n             _ => {}\n@@ -234,10 +236,12 @@ impl EarlyLintPass for LintPassImpl {\n                         cx.struct_span_lint(\n                             LINT_PASS_IMPL_WITHOUT_MACRO,\n                             lint_pass.path.span,\n-                            \"implementing `LintPass` by hand\",\n+                            |lint| {\n+                                lint.build(\"implementing `LintPass` by hand\")\n+                                    .help(\"try using `declare_lint_pass!` or `impl_lint_pass!` instead\")\n+                                    .emit();\n+                            },\n                         )\n-                        .help(\"try using `declare_lint_pass!` or `impl_lint_pass!` instead\")\n-                        .emit();\n                     }\n                 }\n             }"}, {"sha": "da449ed42fd0051ed371024661e04f689a990da8", "filename": "src/librustc_lint/levels.rs", "status": "modified", "additions": 52, "deletions": 48, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_lint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_lint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flevels.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -1,12 +1,13 @@\n use crate::context::{CheckLintNameResult, LintStore};\n use crate::late::unerased_lint_store;\n use rustc::hir::map::Map;\n+use rustc::lint::LintDiagnosticBuilder;\n use rustc::lint::{struct_lint_level, LintLevelMap, LintLevelSets, LintSet, LintSource};\n use rustc::ty::query::Providers;\n use rustc::ty::TyCtxt;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_hir::{intravisit, HirId};\n@@ -39,8 +40,8 @@ fn lint_levels(tcx: TyCtxt<'_>, cnum: CrateNum) -> &LintLevelMap {\n     tcx.arena.alloc(builder.levels.build_map())\n }\n \n-pub struct LintLevelsBuilder<'a> {\n-    sess: &'a Session,\n+pub struct LintLevelsBuilder<'s> {\n+    sess: &'s Session,\n     sets: LintLevelSets,\n     id_to_set: FxHashMap<HirId, u32>,\n     cur: u32,\n@@ -52,8 +53,8 @@ pub struct BuilderPush {\n     pub changed: bool,\n }\n \n-impl<'a> LintLevelsBuilder<'a> {\n-    pub fn new(sess: &'a Session, warn_about_weird_lints: bool, store: &LintStore) -> Self {\n+impl<'s> LintLevelsBuilder<'s> {\n+    pub fn new(sess: &'s Session, warn_about_weird_lints: bool, store: &LintStore) -> Self {\n         let mut builder = LintLevelsBuilder {\n             sess,\n             sets: LintLevelSets::new(),\n@@ -233,27 +234,29 @@ impl<'a> LintLevelsBuilder<'a> {\n                                 let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n                                 let (lvl, src) =\n                                     self.sets.get_lint_level(lint, self.cur, Some(&specs), &sess);\n-                                let msg = format!(\n-                                    \"lint name `{}` is deprecated \\\n-                                     and may not have an effect in the future. \\\n-                                     Also `cfg_attr(cargo-clippy)` won't be necessary anymore\",\n-                                    name\n-                                );\n                                 struct_lint_level(\n                                     self.sess,\n                                     lint,\n                                     lvl,\n                                     src,\n                                     Some(li.span().into()),\n-                                    &msg,\n-                                )\n-                                .span_suggestion(\n-                                    li.span(),\n-                                    \"change it to\",\n-                                    new_lint_name.to_string(),\n-                                    Applicability::MachineApplicable,\n-                                )\n-                                .emit();\n+                                    |lint| {\n+                                        let msg = format!(\n+                                            \"lint name `{}` is deprecated \\\n+                                             and may not have an effect in the future. \\\n+                                             Also `cfg_attr(cargo-clippy)` won't be necessary anymore\",\n+                                            name\n+                                        );\n+                                        lint.build(&msg)\n+                                            .span_suggestion(\n+                                                li.span(),\n+                                                \"change it to\",\n+                                                new_lint_name.to_string(),\n+                                                Applicability::MachineApplicable,\n+                                            )\n+                                            .emit();\n+                                    },\n+                                );\n \n                                 let src = LintSource::Node(\n                                     Symbol::intern(&new_lint_name),\n@@ -279,48 +282,49 @@ impl<'a> LintLevelsBuilder<'a> {\n                         let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n                         let (level, src) =\n                             self.sets.get_lint_level(lint, self.cur, Some(&specs), &sess);\n-                        let mut err = struct_lint_level(\n+                        struct_lint_level(\n                             self.sess,\n                             lint,\n                             level,\n                             src,\n                             Some(li.span().into()),\n-                            &msg,\n+                            |lint| {\n+                                let mut err = lint.build(&msg);\n+                                if let Some(new_name) = renamed {\n+                                    err.span_suggestion(\n+                                        li.span(),\n+                                        \"use the new name\",\n+                                        new_name,\n+                                        Applicability::MachineApplicable,\n+                                    );\n+                                }\n+                                err.emit();\n+                            },\n                         );\n-                        if let Some(new_name) = renamed {\n-                            err.span_suggestion(\n-                                li.span(),\n-                                \"use the new name\",\n-                                new_name,\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                        err.emit();\n                     }\n                     CheckLintNameResult::NoLint(suggestion) => {\n                         let lint = builtin::UNKNOWN_LINTS;\n                         let (level, src) =\n                             self.sets.get_lint_level(lint, self.cur, Some(&specs), self.sess);\n-                        let msg = format!(\"unknown lint: `{}`\", name);\n-                        let mut db = struct_lint_level(\n+                        struct_lint_level(\n                             self.sess,\n                             lint,\n                             level,\n                             src,\n                             Some(li.span().into()),\n-                            &msg,\n+                            |lint| {\n+                                let mut db = lint.build(&format!(\"unknown lint: `{}`\", name));\n+                                if let Some(suggestion) = suggestion {\n+                                    db.span_suggestion(\n+                                        li.span(),\n+                                        \"did you mean\",\n+                                        suggestion.to_string(),\n+                                        Applicability::MachineApplicable,\n+                                    );\n+                                }\n+                                db.emit();\n+                            },\n                         );\n-\n-                        if let Some(suggestion) = suggestion {\n-                            db.span_suggestion(\n-                                li.span(),\n-                                \"did you mean\",\n-                                suggestion.to_string(),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-\n-                        db.emit();\n                     }\n                 }\n             }\n@@ -390,10 +394,10 @@ impl<'a> LintLevelsBuilder<'a> {\n         &self,\n         lint: &'static Lint,\n         span: Option<MultiSpan>,\n-        msg: &str,\n-    ) -> DiagnosticBuilder<'a> {\n+        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>),\n+    ) {\n         let (level, src) = self.sets.get_lint_level(lint, self.cur, None, self.sess);\n-        struct_lint_level(self.sess, lint, level, src, span, msg)\n+        struct_lint_level(self.sess, lint, level, src, span, decorate)\n     }\n \n     /// Registers the ID provided with the current set of lints stored in"}, {"sha": "a0ca7ad1860e8625f2086851aea4384c5c8915ce", "filename": "src/librustc_lint/non_ascii_idents.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_lint%2Fnon_ascii_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_lint%2Fnon_ascii_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnon_ascii_idents.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -22,19 +22,13 @@ impl EarlyLintPass for NonAsciiIdents {\n         if name_str.is_ascii() {\n             return;\n         }\n-        cx.struct_span_lint(\n-            NON_ASCII_IDENTS,\n-            ident.span,\n-            \"identifier contains non-ASCII characters\",\n-        )\n-        .emit();\n+        cx.struct_span_lint(NON_ASCII_IDENTS, ident.span, |lint| {\n+            lint.build(\"identifier contains non-ASCII characters\").emit()\n+        });\n         if !name_str.chars().all(GeneralSecurityProfile::identifier_allowed) {\n-            cx.struct_span_lint(\n-                UNCOMMON_CODEPOINTS,\n-                ident.span,\n-                \"identifier contains uncommon Unicode codepoints\",\n-            )\n-            .emit();\n+            cx.struct_span_lint(UNCOMMON_CODEPOINTS, ident.span, |lint| {\n+                lint.build(\"identifier contains uncommon Unicode codepoints\").emit()\n+            })\n         }\n     }\n }"}, {"sha": "8c58f2ba4c07ad5a8b76ea887cce15aa361067b1", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -107,15 +107,17 @@ impl NonCamelCaseTypes {\n         let name = &ident.name.as_str();\n \n         if !is_camel_case(name) {\n-            let msg = format!(\"{} `{}` should have an upper camel case name\", sort, name);\n-            cx.struct_span_lint(NON_CAMEL_CASE_TYPES, ident.span, &msg)\n-                .span_suggestion(\n-                    ident.span,\n-                    \"convert the identifier to upper camel case\",\n-                    to_camel_case(name),\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .emit();\n+            cx.struct_span_lint(NON_CAMEL_CASE_TYPES, ident.span, |lint| {\n+                let msg = format!(\"{} `{}` should have an upper camel case name\", sort, name);\n+                lint.build(&msg)\n+                    .span_suggestion(\n+                        ident.span,\n+                        \"convert the identifier to upper camel case\",\n+                        to_camel_case(name),\n+                        Applicability::MaybeIncorrect,\n+                    )\n+                    .emit()\n+            })\n         }\n     }\n }\n@@ -223,25 +225,25 @@ impl NonSnakeCase {\n         let name = &ident.name.as_str();\n \n         if !is_snake_case(name) {\n-            let sc = NonSnakeCase::to_snake_case(name);\n-\n-            let msg = format!(\"{} `{}` should have a snake case name\", sort, name);\n-            let mut err = cx.struct_span_lint(NON_SNAKE_CASE, ident.span, &msg);\n-\n-            // We have a valid span in almost all cases, but we don't have one when linting a crate\n-            // name provided via the command line.\n-            if !ident.span.is_dummy() {\n-                err.span_suggestion(\n-                    ident.span,\n-                    \"convert the identifier to snake case\",\n-                    sc,\n-                    Applicability::MaybeIncorrect,\n-                );\n-            } else {\n-                err.help(&format!(\"convert the identifier to snake case: `{}`\", sc));\n-            }\n+            cx.struct_span_lint(NON_SNAKE_CASE, ident.span, |lint| {\n+                let sc = NonSnakeCase::to_snake_case(name);\n+                let msg = format!(\"{} `{}` should have a snake case name\", sort, name);\n+                let mut err = lint.build(&msg);\n+                // We have a valid span in almost all cases, but we don't have one when linting a crate\n+                // name provided via the command line.\n+                if !ident.span.is_dummy() {\n+                    err.span_suggestion(\n+                        ident.span,\n+                        \"convert the identifier to snake case\",\n+                        sc,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                } else {\n+                    err.help(&format!(\"convert the identifier to snake case: `{}`\", sc));\n+                }\n \n-            err.emit();\n+                err.emit();\n+            });\n         }\n     }\n }\n@@ -386,19 +388,18 @@ declare_lint_pass!(NonUpperCaseGlobals => [NON_UPPER_CASE_GLOBALS]);\n impl NonUpperCaseGlobals {\n     fn check_upper_case(cx: &LateContext<'_, '_>, sort: &str, ident: &Ident) {\n         let name = &ident.name.as_str();\n-\n         if name.chars().any(|c| c.is_lowercase()) {\n-            let uc = NonSnakeCase::to_snake_case(&name).to_uppercase();\n-\n-            let msg = format!(\"{} `{}` should have an upper case name\", sort, name);\n-            cx.struct_span_lint(NON_UPPER_CASE_GLOBALS, ident.span, &msg)\n-                .span_suggestion(\n-                    ident.span,\n-                    \"convert the identifier to upper case\",\n-                    uc,\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .emit();\n+            cx.struct_span_lint(NON_UPPER_CASE_GLOBALS, ident.span, |lint| {\n+                let uc = NonSnakeCase::to_snake_case(&name).to_uppercase();\n+                lint.build(&format!(\"{} `{}` should have an upper case name\", sort, name))\n+                    .span_suggestion(\n+                        ident.span,\n+                        \"convert the identifier to upper case\",\n+                        uc,\n+                        Applicability::MaybeIncorrect,\n+                    )\n+                    .emit();\n+            })\n         }\n     }\n }"}, {"sha": "68cb0b54f56c55439d34e2e79877921e48a93913", "filename": "src/librustc_lint/redundant_semicolon.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_lint%2Fredundant_semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_lint%2Fredundant_semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fredundant_semicolon.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -26,19 +26,21 @@ impl EarlyLintPass for RedundantSemicolon {\n                             } else {\n                                 \"unnecessary trailing semicolon\"\n                             };\n-                            let mut err = cx.struct_span_lint(REDUNDANT_SEMICOLON, stmt.span, &msg);\n-                            let suggest_msg = if multiple {\n-                                \"remove these semicolons\"\n-                            } else {\n-                                \"remove this semicolon\"\n-                            };\n-                            err.span_suggestion(\n-                                stmt.span,\n-                                &suggest_msg,\n-                                String::new(),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                            err.emit();\n+                            cx.struct_span_lint(REDUNDANT_SEMICOLON, stmt.span, |lint| {\n+                                let mut err = lint.build(&msg);\n+                                let suggest_msg = if multiple {\n+                                    \"remove these semicolons\"\n+                                } else {\n+                                    \"remove this semicolon\"\n+                                };\n+                                err.span_suggestion(\n+                                    stmt.span,\n+                                    &suggest_msg,\n+                                    String::new(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                                err.emit();\n+                            });\n                         }\n                     }\n                 }"}, {"sha": "5ffa9c1747fa90f748a00693c05543e535100065", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 101, "deletions": 113, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -67,6 +67,7 @@ fn lint_overflowing_range_endpoint<'a, 'tcx>(\n ) -> bool {\n     // We only want to handle exclusive (`..`) ranges,\n     // which are represented as `ExprKind::Struct`.\n+    let mut overwritten = false;\n     if let ExprKind::Struct(_, eps, _) = &parent_expr.kind {\n         if eps.len() != 2 {\n             return false;\n@@ -75,35 +76,32 @@ fn lint_overflowing_range_endpoint<'a, 'tcx>(\n         // (`..=`) instead only if it is the `end` that is\n         // overflowing and only by 1.\n         if eps[1].expr.hir_id == expr.hir_id && lit_val - 1 == max {\n-            let mut err = cx.struct_span_lint(\n-                OVERFLOWING_LITERALS,\n-                parent_expr.span,\n-                &format!(\"range endpoint is out of range for `{}`\", ty),\n-            );\n-            if let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) {\n-                use ast::{LitIntType, LitKind};\n-                // We need to preserve the literal's suffix,\n-                // as it may determine typing information.\n-                let suffix = match lit.node {\n-                    LitKind::Int(_, LitIntType::Signed(s)) => format!(\"{}\", s.name_str()),\n-                    LitKind::Int(_, LitIntType::Unsigned(s)) => format!(\"{}\", s.name_str()),\n-                    LitKind::Int(_, LitIntType::Unsuffixed) => \"\".to_owned(),\n-                    _ => bug!(),\n-                };\n-                let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n-                err.span_suggestion(\n-                    parent_expr.span,\n-                    &\"use an inclusive range instead\",\n-                    suggestion,\n-                    Applicability::MachineApplicable,\n-                );\n-                err.emit();\n-                return true;\n-            }\n+            cx.struct_span_lint(OVERFLOWING_LITERALS, parent_expr.span, |lint| {\n+                let mut err = lint.build(&format!(\"range endpoint is out of range for `{}`\", ty));\n+                if let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) {\n+                    use ast::{LitIntType, LitKind};\n+                    // We need to preserve the literal's suffix,\n+                    // as it may determine typing information.\n+                    let suffix = match lit.node {\n+                        LitKind::Int(_, LitIntType::Signed(s)) => format!(\"{}\", s.name_str()),\n+                        LitKind::Int(_, LitIntType::Unsigned(s)) => format!(\"{}\", s.name_str()),\n+                        LitKind::Int(_, LitIntType::Unsuffixed) => \"\".to_owned(),\n+                        _ => bug!(),\n+                    };\n+                    let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n+                    err.span_suggestion(\n+                        parent_expr.span,\n+                        &\"use an inclusive range instead\",\n+                        suggestion,\n+                        Applicability::MachineApplicable,\n+                    );\n+                    err.emit();\n+                    overwritten = true;\n+                }\n+            });\n         }\n     }\n-\n-    false\n+    overwritten\n }\n \n // For `isize` & `usize`, be conservative with the warnings, so that the\n@@ -153,41 +151,39 @@ fn report_bin_hex_error(\n     negative: bool,\n ) {\n     let size = layout::Integer::from_attr(&cx.tcx, ty).size();\n-    let (t, actually) = match ty {\n-        attr::IntType::SignedInt(t) => {\n-            let actually = sign_extend(val, size) as i128;\n-            (t.name_str(), actually.to_string())\n-        }\n-        attr::IntType::UnsignedInt(t) => {\n-            let actually = truncate(val, size);\n-            (t.name_str(), actually.to_string())\n-        }\n-    };\n-    let mut err = cx.struct_span_lint(\n-        OVERFLOWING_LITERALS,\n-        expr.span,\n-        &format!(\"literal out of range for {}\", t),\n-    );\n-    err.note(&format!(\n-        \"the literal `{}` (decimal `{}`) does not fit into \\\n-            an `{}` and will become `{}{}`\",\n-        repr_str, val, t, actually, t\n-    ));\n-    if let Some(sugg_ty) = get_type_suggestion(&cx.tables.node_type(expr.hir_id), val, negative) {\n-        if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n-            let (sans_suffix, _) = repr_str.split_at(pos);\n-            err.span_suggestion(\n-                expr.span,\n-                &format!(\"consider using `{}` instead\", sugg_ty),\n-                format!(\"{}{}\", sans_suffix, sugg_ty),\n-                Applicability::MachineApplicable,\n-            );\n-        } else {\n-            err.help(&format!(\"consider using `{}` instead\", sugg_ty));\n+    cx.struct_span_lint(OVERFLOWING_LITERALS, expr.span, |lint| {\n+        let (t, actually) = match ty {\n+            attr::IntType::SignedInt(t) => {\n+                let actually = sign_extend(val, size) as i128;\n+                (t.name_str(), actually.to_string())\n+            }\n+            attr::IntType::UnsignedInt(t) => {\n+                let actually = truncate(val, size);\n+                (t.name_str(), actually.to_string())\n+            }\n+        };\n+        let mut err = lint.build(&format!(\"literal out of range for {}\", t));\n+        err.note(&format!(\n+            \"the literal `{}` (decimal `{}`) does not fit into \\\n+                    an `{}` and will become `{}{}`\",\n+            repr_str, val, t, actually, t\n+        ));\n+        if let Some(sugg_ty) = get_type_suggestion(&cx.tables.node_type(expr.hir_id), val, negative)\n+        {\n+            if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n+                let (sans_suffix, _) = repr_str.split_at(pos);\n+                err.span_suggestion(\n+                    expr.span,\n+                    &format!(\"consider using `{}` instead\", sugg_ty),\n+                    format!(\"{}{}\", sans_suffix, sugg_ty),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                err.help(&format!(\"consider using `{}` instead\", sugg_ty));\n+            }\n         }\n-    }\n-\n-    err.emit();\n+        err.emit();\n+    });\n }\n \n // This function finds the next fitting type and generates a suggestion string.\n@@ -270,11 +266,9 @@ fn lint_int_literal<'a, 'tcx>(\n             }\n         }\n \n-        cx.span_lint(\n-            OVERFLOWING_LITERALS,\n-            e.span,\n-            &format!(\"literal out of range for `{}`\", t.name_str()),\n-        );\n+        cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, |lint| {\n+            lint.build(&format!(\"literal out of range for `{}`\", t.name_str())).emit()\n+        });\n     }\n }\n \n@@ -298,18 +292,16 @@ fn lint_uint_literal<'a, 'tcx>(\n             match par_e.kind {\n                 hir::ExprKind::Cast(..) => {\n                     if let ty::Char = cx.tables.expr_ty(par_e).kind {\n-                        let mut err = cx.struct_span_lint(\n-                            OVERFLOWING_LITERALS,\n-                            par_e.span,\n-                            \"only `u8` can be cast into `char`\",\n-                        );\n-                        err.span_suggestion(\n-                            par_e.span,\n-                            &\"use a `char` literal instead\",\n-                            format!(\"'\\\\u{{{:X}}}'\", lit_val),\n-                            Applicability::MachineApplicable,\n-                        );\n-                        err.emit();\n+                        cx.struct_span_lint(OVERFLOWING_LITERALS, par_e.span, |lint| {\n+                            lint.build(\"only `u8` can be cast into `char`\")\n+                                .span_suggestion(\n+                                    par_e.span,\n+                                    &\"use a `char` literal instead\",\n+                                    format!(\"'\\\\u{{{:X}}}'\", lit_val),\n+                                    Applicability::MachineApplicable,\n+                                )\n+                                .emit();\n+                        });\n                         return;\n                     }\n                 }\n@@ -327,11 +319,9 @@ fn lint_uint_literal<'a, 'tcx>(\n             report_bin_hex_error(cx, e, attr::IntType::UnsignedInt(t), repr_str, lit_val, false);\n             return;\n         }\n-        cx.span_lint(\n-            OVERFLOWING_LITERALS,\n-            e.span,\n-            &format!(\"literal out of range for `{}`\", t.name_str()),\n-        );\n+        cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, |lint| {\n+            lint.build(&format!(\"literal out of range for `{}`\", t.name_str())).emit()\n+        });\n     }\n }\n \n@@ -361,11 +351,9 @@ fn lint_literal<'a, 'tcx>(\n                 _ => bug!(),\n             };\n             if is_infinite == Ok(true) {\n-                cx.span_lint(\n-                    OVERFLOWING_LITERALS,\n-                    e.span,\n-                    &format!(\"literal out of range for `{}`\", t.name_str()),\n-                );\n+                cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, |lint| {\n+                    lint.build(&format!(\"literal out of range for `{}`\", t.name_str())).emit()\n+                });\n             }\n         }\n         _ => {}\n@@ -383,11 +371,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             }\n             hir::ExprKind::Binary(binop, ref l, ref r) => {\n                 if is_comparison(binop) && !check_limits(cx, binop, &l, &r) {\n-                    cx.span_lint(\n-                        UNUSED_COMPARISONS,\n-                        e.span,\n-                        \"comparison is useless due to type limits\",\n-                    );\n+                    cx.struct_span_lint(UNUSED_COMPARISONS, e.span, |lint| {\n+                        lint.build(\"comparison is useless due to type limits\").emit()\n+                    });\n                 }\n             }\n             hir::ExprKind::Lit(ref lit) => lint_literal(cx, self, e, lit),\n@@ -883,22 +869,21 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         note: &str,\n         help: Option<&str>,\n     ) {\n-        let mut diag = self.cx.struct_span_lint(\n-            IMPROPER_CTYPES,\n-            sp,\n-            &format!(\"`extern` block uses type `{}`, which is not FFI-safe\", ty),\n-        );\n-        diag.span_label(sp, \"not FFI-safe\");\n-        if let Some(help) = help {\n-            diag.help(help);\n-        }\n-        diag.note(note);\n-        if let ty::Adt(def, _) = ty.kind {\n-            if let Some(sp) = self.cx.tcx.hir().span_if_local(def.did) {\n-                diag.span_note(sp, \"the type is defined here\");\n+        self.cx.struct_span_lint(IMPROPER_CTYPES, sp, |lint| {\n+            let mut diag =\n+                lint.build(&format!(\"`extern` block uses type `{}`, which is not FFI-safe\", ty));\n+            diag.span_label(sp, \"not FFI-safe\");\n+            if let Some(help) = help {\n+                diag.help(help);\n             }\n-        }\n-        diag.emit();\n+            diag.note(note);\n+            if let ty::Adt(def, _) = ty.kind {\n+                if let Some(sp) = self.cx.tcx.hir().span_if_local(def.did) {\n+                    diag.span_note(sp, \"the type is defined here\");\n+                }\n+            }\n+            diag.emit();\n+        });\n     }\n \n     fn check_for_opaque_ty(&mut self, sp: Span, ty: Ty<'tcx>) -> bool {\n@@ -1062,14 +1047,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n             // We only warn if the largest variant is at least thrice as large as\n             // the second-largest.\n             if largest > slargest * 3 && slargest > 0 {\n-                cx.span_lint(\n+                cx.struct_span_lint(\n                     VARIANT_SIZE_DIFFERENCES,\n                     enum_definition.variants[largest_index].span,\n-                    &format!(\n-                        \"enum variant is more than three times \\\n+                    |lint| {\n+                        lint.build(&format!(\n+                            \"enum variant is more than three times \\\n                                           larger ({} bytes) than the next largest\",\n-                        largest\n-                    ),\n+                            largest\n+                        ))\n+                        .emit()\n+                    },\n                 );\n             }\n         }"}, {"sha": "480df99a01eedeea52c5ff1a3796978693cac4f8", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 95, "deletions": 80, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -104,16 +104,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n         };\n \n         if let Some(must_use_op) = must_use_op {\n-            cx.span_lint(\n-                UNUSED_MUST_USE,\n-                expr.span,\n-                &format!(\"unused {} that must be used\", must_use_op),\n-            );\n+            cx.struct_span_lint(UNUSED_MUST_USE, expr.span, |lint| {\n+                lint.build(&format!(\"unused {} that must be used\", must_use_op)).emit()\n+            });\n             op_warned = true;\n         }\n \n         if !(type_permits_lack_of_use || fn_warned || op_warned) {\n-            cx.span_lint(UNUSED_RESULTS, s.span, \"unused result\");\n+            cx.struct_span_lint(UNUSED_RESULTS, s.span, |lint| lint.build(\"unused result\").emit());\n         }\n \n         // Returns whether an error has been emitted (and thus another does not need to be later).\n@@ -204,6 +202,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n         }\n \n         // Returns whether an error has been emitted (and thus another does not need to be later).\n+        // FIXME: Args desc_{pre,post}_path could be made lazy by taking Fn() -> &str, but this\n+        // would make calling it a big awkward. Could also take String (so args are moved), but\n+        // this would still require a copy into the format string, which would only be executed\n+        // when needed.\n         fn check_must_use_def(\n             cx: &LateContext<'_, '_>,\n             def_id: DefId,\n@@ -213,18 +215,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n         ) -> bool {\n             for attr in cx.tcx.get_attrs(def_id).iter() {\n                 if attr.check_name(sym::must_use) {\n-                    let msg = format!(\n-                        \"unused {}`{}`{} that must be used\",\n-                        descr_pre_path,\n-                        cx.tcx.def_path_str(def_id),\n-                        descr_post_path\n-                    );\n-                    let mut err = cx.struct_span_lint(UNUSED_MUST_USE, span, &msg);\n-                    // check for #[must_use = \"...\"]\n-                    if let Some(note) = attr.value_str() {\n-                        err.note(&note.as_str());\n-                    }\n-                    err.emit();\n+                    cx.struct_span_lint(UNUSED_MUST_USE, span, |lint| {\n+                        let msg = format!(\n+                            \"unused {}`{}`{} that must be used\",\n+                            descr_pre_path,\n+                            cx.tcx.def_path_str(def_id),\n+                            descr_post_path\n+                        );\n+                        let mut err = lint.build(&msg);\n+                        // check for #[must_use = \"...\"]\n+                        if let Some(note) = attr.value_str() {\n+                            err.note(&note.as_str());\n+                        }\n+                        err.emit();\n+                    });\n                     return true;\n                 }\n             }\n@@ -245,7 +249,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PathStatements {\n     fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt<'_>) {\n         if let hir::StmtKind::Semi(ref expr) = s.kind {\n             if let hir::ExprKind::Path(_) = expr.kind {\n-                cx.span_lint(PATH_STATEMENTS, s.span, \"path statement with no effect\");\n+                cx.struct_span_lint(PATH_STATEMENTS, s.span, |lint| {\n+                    lint.build(\"path statement with no effect\").emit()\n+                });\n             }\n         }\n     }\n@@ -286,17 +292,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n \n         if !attr::is_used(attr) {\n             debug!(\"emitting warning for: {:?}\", attr);\n-            cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n+            cx.struct_span_lint(UNUSED_ATTRIBUTES, attr.span, |lint| {\n+                lint.build(\"unused attribute\").emit()\n+            });\n             // Is it a builtin attribute that must be used at the crate level?\n             if attr_info.map_or(false, |(_, ty, ..)| ty == &AttributeType::CrateLevel) {\n-                let msg = match attr.style {\n-                    ast::AttrStyle::Outer => {\n-                        \"crate-level attribute should be an inner attribute: add an exclamation \\\n-                         mark: `#![foo]`\"\n-                    }\n-                    ast::AttrStyle::Inner => \"crate-level attribute should be in the root module\",\n-                };\n-                cx.span_lint(UNUSED_ATTRIBUTES, attr.span, msg);\n+                cx.struct_span_lint(UNUSED_ATTRIBUTES, attr.span, |lint| {\n+                    let msg = match attr.style {\n+                        ast::AttrStyle::Outer => {\n+                            \"crate-level attribute should be an inner attribute: add an exclamation \\\n+                             mark: `#![foo]`\"\n+                        }\n+                        ast::AttrStyle::Inner => \"crate-level attribute should be in the root module\",\n+                    };\n+                    lint.build(msg).emit()\n+                });\n             }\n         } else {\n             debug!(\"Attr was used: {:?}\", attr);\n@@ -406,52 +416,54 @@ impl UnusedParens {\n         msg: &str,\n         keep_space: (bool, bool),\n     ) {\n-        let span_msg = format!(\"unnecessary parentheses around {}\", msg);\n-        let mut err = cx.struct_span_lint(UNUSED_PARENS, span, &span_msg);\n-        let mut ate_left_paren = false;\n-        let mut ate_right_paren = false;\n-        let parens_removed = pattern.trim_matches(|c| match c {\n-            '(' => {\n-                if ate_left_paren {\n-                    false\n-                } else {\n-                    ate_left_paren = true;\n-                    true\n+        cx.struct_span_lint(UNUSED_PARENS, span, |lint| {\n+            let span_msg = format!(\"unnecessary parentheses around {}\", msg);\n+            let mut err = lint.build(&span_msg);\n+            let mut ate_left_paren = false;\n+            let mut ate_right_paren = false;\n+            let parens_removed = pattern.trim_matches(|c| match c {\n+                '(' => {\n+                    if ate_left_paren {\n+                        false\n+                    } else {\n+                        ate_left_paren = true;\n+                        true\n+                    }\n                 }\n-            }\n-            ')' => {\n-                if ate_right_paren {\n-                    false\n-                } else {\n-                    ate_right_paren = true;\n-                    true\n+                ')' => {\n+                    if ate_right_paren {\n+                        false\n+                    } else {\n+                        ate_right_paren = true;\n+                        true\n+                    }\n                 }\n-            }\n-            _ => false,\n-        });\n+                _ => false,\n+            });\n \n-        let replace = {\n-            let mut replace = if keep_space.0 {\n-                let mut s = String::from(\" \");\n-                s.push_str(parens_removed);\n-                s\n-            } else {\n-                String::from(parens_removed)\n-            };\n+            let replace = {\n+                let mut replace = if keep_space.0 {\n+                    let mut s = String::from(\" \");\n+                    s.push_str(parens_removed);\n+                    s\n+                } else {\n+                    String::from(parens_removed)\n+                };\n \n-            if keep_space.1 {\n-                replace.push(' ');\n-            }\n-            replace\n-        };\n+                if keep_space.1 {\n+                    replace.push(' ');\n+                }\n+                replace\n+            };\n \n-        err.span_suggestion_short(\n-            span,\n-            \"remove these parentheses\",\n-            replace,\n-            Applicability::MachineApplicable,\n-        );\n-        err.emit();\n+            err.span_suggestion_short(\n+                span,\n+                \"remove these parentheses\",\n+                replace,\n+                Applicability::MachineApplicable,\n+            );\n+            err.emit();\n+        });\n     }\n }\n \n@@ -631,8 +643,9 @@ impl UnusedImportBraces {\n                 ast::UseTreeKind::Nested(_) => return,\n             };\n \n-            let msg = format!(\"braces around {} is unnecessary\", node_name);\n-            cx.span_lint(UNUSED_IMPORT_BRACES, item.span, &msg);\n+            cx.struct_span_lint(UNUSED_IMPORT_BRACES, item.span, |lint| {\n+                lint.build(&format!(\"braces around {} is unnecessary\", node_name)).emit()\n+            });\n         }\n     }\n }\n@@ -662,15 +675,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAllocation {\n \n         for adj in cx.tables.expr_adjustments(e) {\n             if let adjustment::Adjust::Borrow(adjustment::AutoBorrow::Ref(_, m)) = adj.kind {\n-                let msg = match m {\n-                    adjustment::AutoBorrowMutability::Not => {\n-                        \"unnecessary allocation, use `&` instead\"\n-                    }\n-                    adjustment::AutoBorrowMutability::Mut { .. } => {\n-                        \"unnecessary allocation, use `&mut` instead\"\n-                    }\n-                };\n-                cx.span_lint(UNUSED_ALLOCATION, e.span, msg);\n+                cx.struct_span_lint(UNUSED_ALLOCATION, e.span, |lint| {\n+                    let msg = match m {\n+                        adjustment::AutoBorrowMutability::Not => {\n+                            \"unnecessary allocation, use `&` instead\"\n+                        }\n+                        adjustment::AutoBorrowMutability::Mut { .. } => {\n+                            \"unnecessary allocation, use `&mut` instead\"\n+                        }\n+                    };\n+                    lint.build(msg).emit()\n+                });\n             }\n         }\n     }"}, {"sha": "82a9c631b727e6ff0c49ecccae5dc013484cd0b5", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -319,18 +319,20 @@ fn do_mir_borrowck<'a, 'tcx>(\n         };\n \n         // Span and message don't matter; we overwrite them below anyway\n-        let mut diag = mbcx.infcx.tcx.struct_span_lint_hir(\n+        mbcx.infcx.tcx.struct_span_lint_hir(\n             MUTABLE_BORROW_RESERVATION_CONFLICT,\n             lint_root,\n             DUMMY_SP,\n-            \"\",\n-        );\n+            |lint| {\n+                let mut diag = lint.build(\"\");\n \n-        diag.message = initial_diag.styled_message().clone();\n-        diag.span = initial_diag.span.clone();\n+                diag.message = initial_diag.styled_message().clone();\n+                diag.span = initial_diag.span.clone();\n \n+                diag.buffer(&mut mbcx.errors_buffer);\n+            },\n+        );\n         initial_diag.cancel();\n-        diag.buffer(&mut mbcx.errors_buffer);\n     }\n \n     // For each non-user used mutable variable, check if it's been assigned from\n@@ -376,20 +378,17 @@ fn do_mir_borrowck<'a, 'tcx>(\n             continue;\n         }\n \n-        let mut_span = tcx.sess.source_map().span_until_non_whitespace(span);\n-        tcx.struct_span_lint_hir(\n-            UNUSED_MUT,\n-            lint_root,\n-            span,\n-            \"variable does not need to be mutable\",\n-        )\n-        .span_suggestion_short(\n-            mut_span,\n-            \"remove this `mut`\",\n-            String::new(),\n-            Applicability::MachineApplicable,\n-        )\n-        .emit();\n+        tcx.struct_span_lint_hir(UNUSED_MUT, lint_root, span, |lint| {\n+            let mut_span = tcx.sess.source_map().span_until_non_whitespace(span);\n+            lint.build(\"variable does not need to be mutable\")\n+                .span_suggestion_short(\n+                    mut_span,\n+                    \"remove this `mut`\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n+        })\n     }\n \n     // Buffer any move errors that we collected and de-duplicated."}, {"sha": "2e8e4dac237bcfa517cf223b12a0660f47094d09", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -209,12 +209,11 @@ fn validate_and_turn_into_const<'tcx>(\n \n     val.map_err(|error| {\n         let err = error_to_const_error(&ecx, error);\n-        match err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\") {\n-            Ok(mut diag) => {\n-                diag.note(note_on_undefined_behavior_error());\n-                diag.emit();\n-                ErrorHandled::Reported\n-            }\n+        match err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\", |mut diag| {\n+            diag.note(note_on_undefined_behavior_error());\n+            diag.emit();\n+        }) {\n+            Ok(_) => ErrorHandled::Reported,\n             Err(err) => err,\n         }\n     })"}, {"sha": "9fea82d78c94f91cddf3acc32471bd1da365c62e", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -326,12 +326,15 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n             // to read enum discriminants in order to find references in enum variant fields.\n             if let err_unsup!(ValidationFailure(_)) = error.kind {\n                 let err = crate::const_eval::error_to_const_error(&ecx, error);\n-                match err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\") {\n-                    Ok(mut diag) => {\n+                match err.struct_error(\n+                    ecx.tcx,\n+                    \"it is undefined behavior to use this value\",\n+                    |mut diag| {\n                         diag.note(crate::const_eval::note_on_undefined_behavior_error());\n                         diag.emit();\n-                    }\n-                    Err(ErrorHandled::TooGeneric) | Err(ErrorHandled::Reported) => {}\n+                    },\n+                ) {\n+                    Ok(()) | Err(ErrorHandled::TooGeneric) | Err(ErrorHandled::Reported) => {}\n                 }\n             }\n         }"}, {"sha": "6e80338c975eddacde1464053dbfc566baaef810", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 34, "deletions": 28, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -516,18 +516,20 @@ fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: DefId) {\n         .as_local_hir_id(def_id)\n         .unwrap_or_else(|| bug!(\"checking unsafety for non-local def id {:?}\", def_id));\n \n-    // FIXME: when we make this a hard error, this should have its\n-    // own error code.\n-    let message = if tcx.generics_of(def_id).own_requires_monomorphization() {\n-        \"`#[derive]` can't be used on a `#[repr(packed)]` struct with \\\n-         type or const parameters (error E0133)\"\n-            .to_string()\n-    } else {\n-        \"`#[derive]` can't be used on a `#[repr(packed)]` struct that \\\n-         does not derive Copy (error E0133)\"\n-            .to_string()\n-    };\n-    tcx.lint_hir(SAFE_PACKED_BORROWS, lint_hir_id, tcx.def_span(def_id), &message);\n+    tcx.struct_span_lint_hir(SAFE_PACKED_BORROWS, lint_hir_id, tcx.def_span(def_id), |lint| {\n+        // FIXME: when we make this a hard error, this should have its\n+        // own error code.\n+        let message = if tcx.generics_of(def_id).own_requires_monomorphization() {\n+            \"`#[derive]` can't be used on a `#[repr(packed)]` struct with \\\n+             type or const parameters (error E0133)\"\n+                .to_string()\n+        } else {\n+            \"`#[derive]` can't be used on a `#[repr(packed)]` struct that \\\n+             does not derive Copy (error E0133)\"\n+                .to_string()\n+        };\n+        lint.build(&message).emit()\n+    });\n }\n \n /// Returns the `HirId` for an enclosing scope that is also `unsafe`.\n@@ -558,16 +560,18 @@ fn is_enclosed(\n \n fn report_unused_unsafe(tcx: TyCtxt<'_>, used_unsafe: &FxHashSet<hir::HirId>, id: hir::HirId) {\n     let span = tcx.sess.source_map().def_span(tcx.hir().span(id));\n-    let msg = \"unnecessary `unsafe` block\";\n-    let mut db = tcx.struct_span_lint_hir(UNUSED_UNSAFE, id, span, msg);\n-    db.span_label(span, msg);\n-    if let Some((kind, id)) = is_enclosed(tcx, used_unsafe, id) {\n-        db.span_label(\n-            tcx.sess.source_map().def_span(tcx.hir().span(id)),\n-            format!(\"because it's nested under this `unsafe` {}\", kind),\n-        );\n-    }\n-    db.emit();\n+    tcx.struct_span_lint_hir(UNUSED_UNSAFE, id, span, |lint| {\n+        let msg = \"unnecessary `unsafe` block\";\n+        let mut db = lint.build(msg);\n+        db.span_label(span, msg);\n+        if let Some((kind, id)) = is_enclosed(tcx, used_unsafe, id) {\n+            db.span_label(\n+                tcx.sess.source_map().def_span(tcx.hir().span(id)),\n+                format!(\"because it's nested under this `unsafe` {}\", kind),\n+            );\n+        }\n+        db.emit();\n+    });\n }\n \n fn builtin_derive_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n@@ -619,13 +623,15 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: DefId) {\n                         SAFE_PACKED_BORROWS,\n                         lint_hir_id,\n                         source_info.span,\n-                        &format!(\n-                            \"{} is unsafe and requires unsafe function or block (error E0133)\",\n-                            description\n-                        ),\n+                        |lint| {\n+                            lint.build(&format!(\n+                                \"{} is unsafe and requires unsafe function or block (error E0133)\",\n+                                description\n+                            ))\n+                            .note(&details.as_str())\n+                            .emit()\n+                        },\n                     )\n-                    .note(&details.as_str())\n-                    .emit();\n                 }\n             }\n         }"}, {"sha": "14c0db2def285ff759eb1e4662223c9387f576ba", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 47, "deletions": 31, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -556,12 +556,14 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             let r_bits = r.to_scalar().and_then(|r| r.to_bits(right_size));\n             if r_bits.map_or(false, |b| b >= left_bits as u128) {\n                 let lint_root = self.lint_root(source_info)?;\n-                let dir = if op == BinOp::Shr { \"right\" } else { \"left\" };\n-                self.tcx.lint_hir(\n+                self.tcx.struct_span_lint_hir(\n                     ::rustc::lint::builtin::EXCEEDING_BITSHIFTS,\n                     lint_root,\n                     source_info.span,\n-                    &format!(\"attempt to shift {} with overflow\", dir),\n+                    |lint| {\n+                        let dir = if op == BinOp::Shr { \"right\" } else { \"left\" };\n+                        lint.build(&format!(\"attempt to shift {} with overflow\", dir)).emit()\n+                    },\n                 );\n                 return None;\n             }\n@@ -912,35 +914,49 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                             .hir()\n                             .as_local_hir_id(self.source.def_id())\n                             .expect(\"some part of a failing const eval must be local\");\n-                        let msg = match msg {\n-                            PanicInfo::Overflow(_)\n-                            | PanicInfo::OverflowNeg\n-                            | PanicInfo::DivisionByZero\n-                            | PanicInfo::RemainderByZero => msg.description().to_owned(),\n-                            PanicInfo::BoundsCheck { ref len, ref index } => {\n-                                let len =\n-                                    self.eval_operand(len, source_info).expect(\"len must be const\");\n-                                let len = match self.ecx.read_scalar(len) {\n-                                    Ok(ScalarMaybeUndef::Scalar(Scalar::Raw { data, .. })) => data,\n-                                    other => bug!(\"const len not primitive: {:?}\", other),\n-                                };\n-                                let index = self\n-                                    .eval_operand(index, source_info)\n-                                    .expect(\"index must be const\");\n-                                let index = match self.ecx.read_scalar(index) {\n-                                    Ok(ScalarMaybeUndef::Scalar(Scalar::Raw { data, .. })) => data,\n-                                    other => bug!(\"const index not primitive: {:?}\", other),\n+                        self.tcx.struct_span_lint_hir(\n+                            ::rustc::lint::builtin::CONST_ERR,\n+                            hir_id,\n+                            span,\n+                            |lint| {\n+                                let msg = match msg {\n+                                    PanicInfo::Overflow(_)\n+                                    | PanicInfo::OverflowNeg\n+                                    | PanicInfo::DivisionByZero\n+                                    | PanicInfo::RemainderByZero => msg.description().to_owned(),\n+                                    PanicInfo::BoundsCheck { ref len, ref index } => {\n+                                        let len = self\n+                                            .eval_operand(len, source_info)\n+                                            .expect(\"len must be const\");\n+                                        let len = match self.ecx.read_scalar(len) {\n+                                            Ok(ScalarMaybeUndef::Scalar(Scalar::Raw {\n+                                                data,\n+                                                ..\n+                                            })) => data,\n+                                            other => bug!(\"const len not primitive: {:?}\", other),\n+                                        };\n+                                        let index = self\n+                                            .eval_operand(index, source_info)\n+                                            .expect(\"index must be const\");\n+                                        let index = match self.ecx.read_scalar(index) {\n+                                            Ok(ScalarMaybeUndef::Scalar(Scalar::Raw {\n+                                                data,\n+                                                ..\n+                                            })) => data,\n+                                            other => bug!(\"const index not primitive: {:?}\", other),\n+                                        };\n+                                        format!(\n+                                            \"index out of bounds: \\\n+                                            the len is {} but the index is {}\",\n+                                            len, index,\n+                                        )\n+                                    }\n+                                    // Need proper const propagator for these\n+                                    _ => return,\n                                 };\n-                                format!(\n-                                    \"index out of bounds: \\\n-                                    the len is {} but the index is {}\",\n-                                    len, index,\n-                                )\n-                            }\n-                            // Need proper const propagator for these\n-                            _ => return,\n-                        };\n-                        self.tcx.lint_hir(::rustc::lint::builtin::CONST_ERR, hir_id, span, &msg);\n+                                lint.build(&msg).emit()\n+                            },\n+                        );\n                     } else {\n                         if self.should_const_prop(value) {\n                             if let ScalarMaybeUndef::Scalar(scalar) = value_const {"}, {"sha": "7ed6c81eb63bd6671927249adb02a9c9fb6872cc", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -2235,24 +2235,26 @@ fn lint_overlapping_patterns<'tcx>(\n     overlaps: Vec<IntRange<'tcx>>,\n ) {\n     if let (true, Some(hir_id)) = (!overlaps.is_empty(), hir_id) {\n-        let mut err = tcx.struct_span_lint_hir(\n+        tcx.struct_span_lint_hir(\n             lint::builtin::OVERLAPPING_PATTERNS,\n             hir_id,\n             ctor_range.span,\n-            \"multiple patterns covering the same range\",\n+            |lint| {\n+                let mut err = lint.build(\"multiple patterns covering the same range\");\n+                err.span_label(ctor_range.span, \"overlapping patterns\");\n+                for int_range in overlaps {\n+                    // Use the real type for user display of the ranges:\n+                    err.span_label(\n+                        int_range.span,\n+                        &format!(\n+                            \"this range overlaps on `{}`\",\n+                            IntRange { range: int_range.range, ty, span: DUMMY_SP }.to_pat(tcx),\n+                        ),\n+                    );\n+                }\n+                err.emit();\n+            },\n         );\n-        err.span_label(ctor_range.span, \"overlapping patterns\");\n-        for int_range in overlaps {\n-            // Use the real type for user display of the ranges:\n-            err.span_label(\n-                int_range.span,\n-                &format!(\n-                    \"this range overlaps on `{}`\",\n-                    IntRange { range: int_range.range, ty, span: DUMMY_SP }.to_pat(tcx),\n-                ),\n-            );\n-        }\n-        err.emit();\n     }\n }\n "}, {"sha": "651f2f70d9bfb7ba32f9b2786f38ba27639d8dfa", "filename": "src/librustc_mir_build/hair/pattern/check_match.rs", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -286,26 +286,27 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n                             variant.ident == ident && variant.ctor_kind == CtorKind::Const\n                         })\n                     {\n-                        let ty_path = cx.tcx.def_path_str(edef.did);\n-                        cx.tcx\n-                            .struct_span_lint_hir(\n-                                BINDINGS_WITH_VARIANT_NAME,\n-                                p.hir_id,\n-                                p.span,\n-                                &format!(\n+                        cx.tcx.struct_span_lint_hir(\n+                            BINDINGS_WITH_VARIANT_NAME,\n+                            p.hir_id,\n+                            p.span,\n+                            |lint| {\n+                                let ty_path = cx.tcx.def_path_str(edef.did);\n+                                lint.build(&format!(\n                                     \"pattern binding `{}` is named the same as one \\\n-                                    of the variants of the type `{}`\",\n+                                                of the variants of the type `{}`\",\n                                     ident, ty_path\n-                                ),\n-                            )\n-                            .code(error_code!(E0170))\n-                            .span_suggestion(\n-                                p.span,\n-                                \"to match on the variant, qualify the path\",\n-                                format!(\"{}::{}\", ty_path, ident),\n-                                Applicability::MachineApplicable,\n-                            )\n-                            .emit();\n+                                ))\n+                                .code(error_code!(E0170))\n+                                .span_suggestion(\n+                                    p.span,\n+                                    \"to match on the variant, qualify the path\",\n+                                    format!(\"{}::{}\", ty_path, ident),\n+                                    Applicability::MachineApplicable,\n+                                )\n+                                .emit();\n+                            },\n+                        )\n                     }\n                 }\n             }\n@@ -325,22 +326,26 @@ fn pat_is_catchall(pat: &super::Pat<'_>) -> bool {\n }\n \n fn unreachable_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, catchall: Option<Span>) {\n-    let mut err = tcx.struct_span_lint_hir(UNREACHABLE_PATTERNS, id, span, \"unreachable pattern\");\n-    if let Some(catchall) = catchall {\n-        // We had a catchall pattern, hint at that.\n-        err.span_label(span, \"unreachable pattern\");\n-        err.span_label(catchall, \"matches any value\");\n-    }\n-    err.emit();\n+    tcx.struct_span_lint_hir(UNREACHABLE_PATTERNS, id, span, |lint| {\n+        let mut err = lint.build(\"unreachable pattern\");\n+        if let Some(catchall) = catchall {\n+            // We had a catchall pattern, hint at that.\n+            err.span_label(span, \"unreachable pattern\");\n+            err.span_label(catchall, \"matches any value\");\n+        }\n+        err.emit();\n+    });\n }\n \n fn irrefutable_let_pattern(tcx: TyCtxt<'_>, span: Span, id: HirId, source: hir::MatchSource) {\n-    let msg = match source {\n-        hir::MatchSource::IfLetDesugar { .. } => \"irrefutable if-let pattern\",\n-        hir::MatchSource::WhileLetDesugar => \"irrefutable while-let pattern\",\n-        _ => bug!(),\n-    };\n-    tcx.lint_hir(IRREFUTABLE_LET_PATTERNS, id, span, msg);\n+    tcx.struct_span_lint_hir(IRREFUTABLE_LET_PATTERNS, id, span, |lint| {\n+        let msg = match source {\n+            hir::MatchSource::IfLetDesugar { .. } => \"irrefutable if-let pattern\",\n+            hir::MatchSource::WhileLetDesugar => \"irrefutable while-let pattern\",\n+            _ => bug!(),\n+        };\n+        lint.build(msg).emit()\n+    });\n }\n \n /// Check for unreachable patterns."}, {"sha": "5fbe764430c54ad097eb2f8545b1223b09027b8e", "filename": "src/librustc_mir_build/hair/pattern/const_to_pat.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -109,11 +109,14 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                     }\n                 };\n                 let path = self.tcx().def_path_str(adt_def.did);\n-                let msg = format!(\n-                    \"to use a constant of type `{}` in a pattern, \\\n-                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                    path, path,\n-                );\n+\n+                let make_msg = || -> String {\n+                    format!(\n+                        \"to use a constant of type `{}` in a pattern, \\\n+                         `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n+                        path, path,\n+                    )\n+                };\n \n                 // double-check there even *is* a semantic `PartialEq` to dispatch to.\n                 //\n@@ -143,13 +146,13 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n \n                 if !ty_is_partial_eq {\n                     // span_fatal avoids ICE from resolution of non-existent method (rare case).\n-                    self.tcx().sess.span_fatal(self.span, &msg);\n+                    self.tcx().sess.span_fatal(self.span, &make_msg());\n                 } else {\n-                    self.tcx().lint_hir(\n+                    self.tcx().struct_span_lint_hir(\n                         lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n                         self.id,\n                         self.span,\n-                        &msg,\n+                        |lint| lint.build(&make_msg()).emit(),\n                     );\n                 }\n             }\n@@ -177,11 +180,11 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n \n         let kind = match cv.ty.kind {\n             ty::Float(_) => {\n-                tcx.lint_hir(\n+                tcx.struct_span_lint_hir(\n                     ::rustc::lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n                     id,\n                     span,\n-                    \"floating-point types cannot be used in patterns\",\n+                    |lint| lint.build(\"floating-point types cannot be used in patterns\").emit(),\n                 );\n                 PatKind::Constant { value: cv }\n             }"}, {"sha": "0017f800de7021ec0b5a2ea52274595c9de08426", "filename": "src/librustc_mir_build/lints.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_mir_build%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_mir_build%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Flints.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -124,18 +124,15 @@ fn check_fn_for_unconditional_recursion<'tcx>(\n     if !reached_exit_without_self_call && !self_call_locations.is_empty() {\n         let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         let sp = tcx.sess.source_map().def_span(tcx.hir().span(hir_id));\n-        let mut db = tcx.struct_span_lint_hir(\n-            UNCONDITIONAL_RECURSION,\n-            hir_id,\n-            sp,\n-            \"function cannot return without recursing\",\n-        );\n-        db.span_label(sp, \"cannot return without recursing\");\n-        // offer some help to the programmer.\n-        for location in &self_call_locations {\n-            db.span_label(location.span, \"recursive call site\");\n-        }\n-        db.help(\"a `loop` may express intention better if this is on purpose\");\n-        db.emit();\n+        tcx.struct_span_lint_hir(UNCONDITIONAL_RECURSION, hir_id, sp, |lint| {\n+            let mut db = lint.build(\"function cannot return without recursing\");\n+            db.span_label(sp, \"cannot return without recursing\");\n+            // offer some help to the programmer.\n+            for location in &self_call_locations {\n+                db.span_label(location.span, \"recursive call site\");\n+            }\n+            db.help(\"a `loop` may express intention better if this is on purpose\");\n+            db.emit();\n+        });\n     }\n }"}, {"sha": "8dec64c579e8883b6b87790e4560a82a2e200161", "filename": "src/librustc_parse/config.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_parse%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_parse%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fconfig.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -315,10 +315,11 @@ impl<'a> StripUnconfigured<'a> {\n                 validate_attr::check_meta_bad_delim(self.sess, dspan, delim, msg);\n                 match parse_in(self.sess, tts.clone(), \"`cfg_attr` input\", |p| p.parse_cfg_attr()) {\n                     Ok(r) => return Some(r),\n-                    Err(mut e) => e\n-                        .help(&format!(\"the valid syntax is `{}`\", CFG_ATTR_GRAMMAR_HELP))\n-                        .note(CFG_ATTR_NOTE_REF)\n-                        .emit(),\n+                    Err(mut e) => {\n+                        e.help(&format!(\"the valid syntax is `{}`\", CFG_ATTR_GRAMMAR_HELP))\n+                            .note(CFG_ATTR_NOTE_REF)\n+                            .emit();\n+                    }\n                 }\n             }\n             _ => self.error_malformed_cfg_attr_missing(attr.span),"}, {"sha": "d41775a143ad6c467e6e69d00d7e481cc137d2bc", "filename": "src/librustc_parse/lexer/unescape_error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_parse%2Flexer%2Funescape_error_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_parse%2Flexer%2Funescape_error_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Funescape_error_reporting.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -69,7 +69,7 @@ pub(crate) fn emit_unescape_error(\n                     format!(\"\\\"{}\\\"\", lit),\n                     Applicability::MachineApplicable,\n                 )\n-                .emit()\n+                .emit();\n         }\n         EscapeError::EscapeOnlyChar => {\n             let (c, _span) = last_char();"}, {"sha": "905f6bef58e85c155f97215e40ce746cd38fb765", "filename": "src/librustc_parse/parser/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fattr.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -149,7 +149,7 @@ impl<'a> Parser<'a> {\n                                    source files. Outer attributes, like `#[test]`, annotate the \\\n                                    item following them.\",\n                             )\n-                            .emit()\n+                            .emit();\n                     }\n                 }\n \n@@ -239,7 +239,7 @@ impl<'a> Parser<'a> {\n                                     (`1u8`, `1.0f32`, etc.), use an unsuffixed version \\\n                                     (`1`, `1.0`, etc.)\",\n                 )\n-                .emit()\n+                .emit();\n         }\n \n         Ok(lit)"}, {"sha": "018aef3c13cee88c87440c87654244c046463ccc", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -1014,7 +1014,7 @@ impl<'a> Parser<'a> {\n                     String::new(),\n                     Applicability::MachineApplicable,\n                 )\n-                .emit()\n+                .emit();\n         }\n     }\n "}, {"sha": "21a738c7f7b188925e544b10e574dfc1eb62f302", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -1407,6 +1407,8 @@ pub fn emit_unclosed_delims(unclosed_delims: &mut Vec<UnmatchedBrace>, sess: &Pa\n     *sess.reached_eof.borrow_mut() |=\n         unclosed_delims.iter().any(|unmatched_delim| unmatched_delim.found_delim.is_none());\n     for unmatched in unclosed_delims.drain(..) {\n-        make_unclosed_delims_error(unmatched, sess).map(|mut e| e.emit());\n+        make_unclosed_delims_error(unmatched, sess).map(|mut e| {\n+            e.emit();\n+        });\n     }\n }"}, {"sha": "ec6d4db610285539e59541c45625fb6be30f8848", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -572,7 +572,7 @@ impl<'a> Parser<'a> {\n         self.struct_span_err(span, problem)\n             .span_suggestion(span, suggestion, fix, Applicability::MachineApplicable)\n             .note(\"`mut` may be followed by `variable` and `variable @ pattern`\")\n-            .emit()\n+            .emit();\n     }\n \n     /// Eat any extraneous `mut`s and error + recover if we ate any."}, {"sha": "f5e47608d589de011db842db2aae0621a54de91a", "filename": "src/librustc_parse/validate_attr.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_parse%2Fvalidate_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_parse%2Fvalidate_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fvalidate_attr.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -27,7 +27,11 @@ pub fn check_meta(sess: &ParseSess, attr: &Attribute) {\n         _ => {\n             if let MacArgs::Eq(..) = attr.get_normal_item().args {\n                 // All key-value attributes are restricted to meta-item syntax.\n-                parse_meta(sess, attr).map_err(|mut err| err.emit()).ok();\n+                parse_meta(sess, attr)\n+                    .map_err(|mut err| {\n+                        err.emit();\n+                    })\n+                    .ok();\n             }\n         }\n     }\n@@ -152,6 +156,8 @@ pub fn check_builtin_attribute(\n                 }\n             }\n         }\n-        Err(mut err) => err.emit(),\n+        Err(mut err) => {\n+            err.emit();\n+        }\n     }\n }"}, {"sha": "ecffd615e71c007b29301db7d3f0200ab286dfe9", "filename": "src/librustc_passes/check_attr.rs", "status": "modified", "additions": 26, "deletions": 34, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_passes%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_passes%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_attr.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -92,38 +92,29 @@ impl CheckAttrVisitor<'tcx> {\n             | Target::Method(MethodKind::Trait { body: true })\n             | Target::Method(MethodKind::Inherent) => true,\n             Target::Method(MethodKind::Trait { body: false }) | Target::ForeignFn => {\n-                self.tcx\n-                    .struct_span_lint_hir(\n-                        UNUSED_ATTRIBUTES,\n-                        hir_id,\n-                        attr.span,\n-                        \"`#[inline]` is ignored on function prototypes\",\n-                    )\n-                    .emit();\n+                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n+                    lint.build(\"`#[inline]` is ignored on function prototypes\").emit()\n+                });\n                 true\n             }\n             // FIXME(#65833): We permit associated consts to have an `#[inline]` attribute with\n             // just a lint, because we previously erroneously allowed it and some crates used it\n             // accidentally, to to be compatible with crates depending on them, we can't throw an\n             // error here.\n             Target::AssocConst => {\n-                self.tcx\n-                    .struct_span_lint_hir(\n-                        UNUSED_ATTRIBUTES,\n-                        hir_id,\n-                        attr.span,\n-                        \"`#[inline]` is ignored on constants\",\n-                    )\n-                    .warn(\n-                        \"this was previously accepted by the compiler but is \\\n-                       being phased out; it will become a hard error in \\\n-                       a future release!\",\n-                    )\n-                    .note(\n-                        \"see issue #65833 <https://github.com/rust-lang/rust/issues/65833> \\\n-                         for more information\",\n-                    )\n-                    .emit();\n+                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n+                    lint.build(\"`#[inline]` is ignored on constants\")\n+                        .warn(\n+                            \"this was previously accepted by the compiler but is \\\n+                               being phased out; it will become a hard error in \\\n+                               a future release!\",\n+                        )\n+                        .note(\n+                            \"see issue #65833 <https://github.com/rust-lang/rust/issues/65833> \\\n+                                 for more information\",\n+                        )\n+                        .emit();\n+                });\n                 true\n             }\n             _ => {\n@@ -331,15 +322,16 @@ impl CheckAttrVisitor<'tcx> {\n             || (is_simd && is_c)\n             || (int_reprs == 1 && is_c && item.map_or(false, |item| is_c_like_enum(item)))\n         {\n-            self.tcx\n-                .struct_span_lint_hir(\n-                    CONFLICTING_REPR_HINTS,\n-                    hir_id,\n-                    hint_spans.collect::<Vec<Span>>(),\n-                    \"conflicting representation hints\",\n-                )\n-                .code(rustc_errors::error_code!(E0566))\n-                .emit();\n+            self.tcx.struct_span_lint_hir(\n+                CONFLICTING_REPR_HINTS,\n+                hir_id,\n+                hint_spans.collect::<Vec<Span>>(),\n+                |lint| {\n+                    lint.build(\"conflicting representation hints\")\n+                        .code(rustc_errors::error_code!(E0566))\n+                        .emit();\n+                },\n+            );\n         }\n     }\n "}, {"sha": "25b8b8fcd444bc0c469dcc79943364771eba1abb", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -554,12 +554,9 @@ impl DeadVisitor<'tcx> {\n         participle: &str,\n     ) {\n         if !name.as_str().starts_with(\"_\") {\n-            self.tcx.lint_hir(\n-                lint::builtin::DEAD_CODE,\n-                id,\n-                span,\n-                &format!(\"{} is never {}: `{}`\", node_type, participle, name),\n-            );\n+            self.tcx.struct_span_lint_hir(lint::builtin::DEAD_CODE, id, span, |lint| {\n+                lint.build(&format!(\"{} is never {}: `{}`\", node_type, participle, name)).emit()\n+            });\n         }\n     }\n }"}, {"sha": "709068d2189378f9d27ac9683ded814fb9bde14e", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 56, "deletions": 54, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -1521,45 +1521,47 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                 if ln == self.s.exit_ln { false } else { self.assigned_on_exit(ln, var).is_some() };\n \n             if is_assigned {\n-                self.ir\n-                    .tcx\n-                    .struct_span_lint_hir(\n-                        lint::builtin::UNUSED_VARIABLES,\n-                        hir_id,\n-                        spans,\n-                        &format!(\"variable `{}` is assigned to, but never used\", name),\n-                    )\n-                    .note(&format!(\"consider using `_{}` instead\", name))\n-                    .emit();\n+                self.ir.tcx.struct_span_lint_hir(\n+                    lint::builtin::UNUSED_VARIABLES,\n+                    hir_id,\n+                    spans,\n+                    |lint| {\n+                        lint.build(&format!(\"variable `{}` is assigned to, but never used\", name))\n+                            .note(&format!(\"consider using `_{}` instead\", name))\n+                            .emit();\n+                    },\n+                )\n             } else {\n-                let mut err = self.ir.tcx.struct_span_lint_hir(\n+                self.ir.tcx.struct_span_lint_hir(\n                     lint::builtin::UNUSED_VARIABLES,\n                     hir_id,\n                     spans.clone(),\n-                    &format!(\"unused variable: `{}`\", name),\n+                    |lint| {\n+                        let mut err = lint.build(&format!(\"unused variable: `{}`\", name));\n+                        if self.ir.variable_is_shorthand(var) {\n+                            if let Node::Binding(pat) = self.ir.tcx.hir().get(hir_id) {\n+                                // Handle `ref` and `ref mut`.\n+                                let spans = spans\n+                                    .iter()\n+                                    .map(|_span| (pat.span, format!(\"{}: _\", name)))\n+                                    .collect();\n+\n+                                err.multipart_suggestion(\n+                                    \"try ignoring the field\",\n+                                    spans,\n+                                    Applicability::MachineApplicable,\n+                                );\n+                            }\n+                        } else {\n+                            err.multipart_suggestion(\n+                                \"consider prefixing with an underscore\",\n+                                spans.iter().map(|span| (*span, format!(\"_{}\", name))).collect(),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n+                        err.emit()\n+                    },\n                 );\n-\n-                if self.ir.variable_is_shorthand(var) {\n-                    if let Node::Binding(pat) = self.ir.tcx.hir().get(hir_id) {\n-                        // Handle `ref` and `ref mut`.\n-                        let spans =\n-                            spans.iter().map(|_span| (pat.span, format!(\"{}: _\", name))).collect();\n-\n-                        err.multipart_suggestion(\n-                            \"try ignoring the field\",\n-                            spans,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-                } else {\n-                    err.multipart_suggestion(\n-                        \"consider prefixing with an underscore\",\n-                        spans.iter().map(|span| (*span, format!(\"_{}\", name))).collect(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-\n-                err.emit()\n             }\n         }\n     }\n@@ -1573,27 +1575,27 @@ impl<'tcx> Liveness<'_, 'tcx> {\n     fn report_dead_assign(&self, hir_id: HirId, spans: Vec<Span>, var: Variable, is_param: bool) {\n         if let Some(name) = self.should_warn(var) {\n             if is_param {\n-                self.ir\n-                    .tcx\n-                    .struct_span_lint_hir(\n-                        lint::builtin::UNUSED_ASSIGNMENTS,\n-                        hir_id,\n-                        spans,\n-                        &format!(\"value passed to `{}` is never read\", name),\n-                    )\n-                    .help(\"maybe it is overwritten before being read?\")\n-                    .emit();\n+                self.ir.tcx.struct_span_lint_hir(\n+                    lint::builtin::UNUSED_ASSIGNMENTS,\n+                    hir_id,\n+                    spans,\n+                    |lint| {\n+                        lint.build(&format!(\"value passed to `{}` is never read\", name))\n+                            .help(\"maybe it is overwritten before being read?\")\n+                            .emit();\n+                    },\n+                )\n             } else {\n-                self.ir\n-                    .tcx\n-                    .struct_span_lint_hir(\n-                        lint::builtin::UNUSED_ASSIGNMENTS,\n-                        hir_id,\n-                        spans,\n-                        &format!(\"value assigned to `{}` is never read\", name),\n-                    )\n-                    .help(\"maybe it is overwritten before being read?\")\n-                    .emit();\n+                self.ir.tcx.struct_span_lint_hir(\n+                    lint::builtin::UNUSED_ASSIGNMENTS,\n+                    hir_id,\n+                    spans,\n+                    |lint| {\n+                        lint.build(&format!(\"value assigned to `{}` is never read\", name))\n+                            .help(\"maybe it is overwritten before being read?\")\n+                            .emit();\n+                    },\n+                )\n             }\n         }\n     }"}, {"sha": "4e2085d07a39ad869f2bcb66b08e030827b2eb4f", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -604,16 +604,14 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n }\n \n fn unnecessary_stable_feature_lint(tcx: TyCtxt<'_>, span: Span, feature: Symbol, since: Symbol) {\n-    tcx.lint_hir(\n-        lint::builtin::STABLE_FEATURES,\n-        hir::CRATE_HIR_ID,\n-        span,\n-        &format!(\n+    tcx.struct_span_lint_hir(lint::builtin::STABLE_FEATURES, hir::CRATE_HIR_ID, span, |lint| {\n+        lint.build(&format!(\n             \"the feature `{}` has been stable since {} and no longer requires \\\n-                  an attribute to enable\",\n+                      an attribute to enable\",\n             feature, since\n-        ),\n-    );\n+        ))\n+        .emit();\n+    });\n }\n \n fn duplicate_feature_err(sess: &Session, span: Span, feature: Symbol) {"}, {"sha": "ef1e99c5a64be940e744a8c643b1b98cb6d03c50", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -1781,17 +1781,20 @@ impl SearchInterfaceForPrivateItemsVisitor<'tcx> {\n \n     fn check_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n         if self.leaks_private_dep(def_id) {\n-            self.tcx.lint_hir(\n+            self.tcx.struct_span_lint_hir(\n                 lint::builtin::EXPORTED_PRIVATE_DEPENDENCIES,\n                 self.item_id,\n                 self.span,\n-                &format!(\n-                    \"{} `{}` from private dependency '{}' in public \\\n-                                        interface\",\n-                    kind,\n-                    descr,\n-                    self.tcx.crate_name(def_id.krate)\n-                ),\n+                |lint| {\n+                    lint.build(&format!(\n+                        \"{} `{}` from private dependency '{}' in public \\\n+                                                interface\",\n+                        kind,\n+                        descr,\n+                        self.tcx.crate_name(def_id.krate)\n+                    ))\n+                    .emit()\n+                },\n             );\n         }\n \n@@ -1802,23 +1805,23 @@ impl SearchInterfaceForPrivateItemsVisitor<'tcx> {\n \n         let (vis, vis_span, vis_descr) = def_id_visibility(self.tcx, def_id);\n         if !vis.is_at_least(self.required_visibility, self.tcx) {\n-            let msg = format!(\"{} {} `{}` in public interface\", vis_descr, kind, descr);\n+            let make_msg = || format!(\"{} {} `{}` in public interface\", vis_descr, kind, descr);\n             if self.has_pub_restricted || self.has_old_errors || self.in_assoc_ty {\n                 let mut err = if kind == \"trait\" {\n-                    struct_span_err!(self.tcx.sess, self.span, E0445, \"{}\", msg)\n+                    struct_span_err!(self.tcx.sess, self.span, E0445, \"{}\", make_msg())\n                 } else {\n-                    struct_span_err!(self.tcx.sess, self.span, E0446, \"{}\", msg)\n+                    struct_span_err!(self.tcx.sess, self.span, E0446, \"{}\", make_msg())\n                 };\n                 err.span_label(self.span, format!(\"can't leak {} {}\", vis_descr, kind));\n                 err.span_label(vis_span, format!(\"`{}` declared as {}\", descr, vis_descr));\n                 err.emit();\n             } else {\n                 let err_code = if kind == \"trait\" { \"E0445\" } else { \"E0446\" };\n-                self.tcx.lint_hir(\n+                self.tcx.struct_span_lint_hir(\n                     lint::builtin::PRIVATE_IN_PUBLIC,\n                     hir_id,\n                     self.span,\n-                    &format!(\"{} (error {})\", msg, err_code),\n+                    |lint| lint.build(&format!(\"{} (error {})\", make_msg(), err_code)).emit(),\n                 );\n             }\n         }"}, {"sha": "fd4d2c718c094380186f301f0194696499dea890", "filename": "src/librustc_resolve/lifetimes.rs", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_resolve%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_resolve%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flifetimes.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -1575,22 +1575,28 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             }\n                         }\n \n-                        let mut err = self.tcx.struct_span_lint_hir(\n+                        self.tcx.struct_span_lint_hir(\n                             lint::builtin::SINGLE_USE_LIFETIMES,\n                             id,\n                             span,\n-                            &format!(\"lifetime parameter `{}` only used once\", name),\n+                            |lint| {\n+                                let mut err = lint.build(&format!(\n+                                    \"lifetime parameter `{}` only used once\",\n+                                    name\n+                                ));\n+                                if span == lifetime.span {\n+                                    // spans are the same for in-band lifetime declarations\n+                                    err.span_label(span, \"this lifetime is only used here\");\n+                                } else {\n+                                    err.span_label(span, \"this lifetime...\");\n+                                    err.span_label(lifetime.span, \"...is used only here\");\n+                                }\n+                                self.suggest_eliding_single_use_lifetime(\n+                                    &mut err, def_id, lifetime,\n+                                );\n+                                err.emit();\n+                            },\n                         );\n-\n-                        if span == lifetime.span {\n-                            // spans are the same for in-band lifetime declarations\n-                            err.span_label(span, \"this lifetime is only used here\");\n-                        } else {\n-                            err.span_label(span, \"this lifetime...\");\n-                            err.span_label(lifetime.span, \"...is used only here\");\n-                        }\n-                        self.suggest_eliding_single_use_lifetime(&mut err, def_id, lifetime);\n-                        err.emit();\n                     }\n                 }\n                 Some(LifetimeUseSet::Many) => {\n@@ -1610,26 +1616,32 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         _ => None,\n                     } {\n                         debug!(\"id ={:?} span = {:?} name = {:?}\", id, span, name);\n-                        let mut err = self.tcx.struct_span_lint_hir(\n+                        self.tcx.struct_span_lint_hir(\n                             lint::builtin::UNUSED_LIFETIMES,\n                             id,\n                             span,\n-                            &format!(\"lifetime parameter `{}` never used\", name),\n-                        );\n-                        if let Some(parent_def_id) = self.tcx.parent(def_id) {\n-                            if let Some(generics) = self.tcx.hir().get_generics(parent_def_id) {\n-                                let unused_lt_span = self.lifetime_deletion_span(name, generics);\n-                                if let Some(span) = unused_lt_span {\n-                                    err.span_suggestion(\n-                                        span,\n-                                        \"elide the unused lifetime\",\n-                                        String::new(),\n-                                        Applicability::MachineApplicable,\n-                                    );\n+                            |lint| {\n+                                let mut err = lint\n+                                    .build(&format!(\"lifetime parameter `{}` never used\", name));\n+                                if let Some(parent_def_id) = self.tcx.parent(def_id) {\n+                                    if let Some(generics) =\n+                                        self.tcx.hir().get_generics(parent_def_id)\n+                                    {\n+                                        let unused_lt_span =\n+                                            self.lifetime_deletion_span(name, generics);\n+                                        if let Some(span) = unused_lt_span {\n+                                            err.span_suggestion(\n+                                                span,\n+                                                \"elide the unused lifetime\",\n+                                                String::new(),\n+                                                Applicability::MachineApplicable,\n+                                            );\n+                                        }\n+                                    }\n                                 }\n-                            }\n-                        }\n-                        err.emit();\n+                                err.emit();\n+                            },\n+                        );\n                     }\n                 }\n             }"}, {"sha": "c26b47c313023ee38ba41bfc1ce6db26a2279bb1", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -331,11 +331,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 } else {\n                     let mut multispan = MultiSpan::from_span(span);\n                     multispan.push_span_label(span_late, note.to_string());\n-                    tcx.lint_hir(\n+                    tcx.struct_span_lint_hir(\n                         lint::builtin::LATE_BOUND_LIFETIME_ARGUMENTS,\n                         args.args[0].id(),\n                         multispan,\n-                        msg,\n+                        |lint| lint.build(msg).emit(),\n                     );\n                     reported_late_bound_region_err = Some(false);\n                 }\n@@ -2216,34 +2216,31 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         tcx.check_stability(item.def_id, Some(hir_ref_id), span);\n \n         if let Some(variant_def_id) = variant_resolution {\n-            let mut err = tcx.struct_span_lint_hir(\n-                AMBIGUOUS_ASSOCIATED_ITEMS,\n-                hir_ref_id,\n-                span,\n-                \"ambiguous associated item\",\n-            );\n+            tcx.struct_span_lint_hir(AMBIGUOUS_ASSOCIATED_ITEMS, hir_ref_id, span, |lint| {\n+                let mut err = lint.build(\"ambiguous associated item\");\n+                let mut could_refer_to = |kind: DefKind, def_id, also| {\n+                    let note_msg = format!(\n+                        \"`{}` could{} refer to the {} defined here\",\n+                        assoc_ident,\n+                        also,\n+                        kind.descr(def_id)\n+                    );\n+                    err.span_note(tcx.def_span(def_id), &note_msg);\n+                };\n \n-            let mut could_refer_to = |kind: DefKind, def_id, also| {\n-                let note_msg = format!(\n-                    \"`{}` could{} refer to the {} defined here\",\n-                    assoc_ident,\n-                    also,\n-                    kind.descr(def_id)\n+                could_refer_to(DefKind::Variant, variant_def_id, \"\");\n+                could_refer_to(kind, item.def_id, \" also\");\n+\n+                err.span_suggestion(\n+                    span,\n+                    \"use fully-qualified syntax\",\n+                    format!(\"<{} as {}>::{}\", qself_ty, tcx.item_name(trait_did), assoc_ident),\n+                    Applicability::MachineApplicable,\n                 );\n-                err.span_note(tcx.def_span(def_id), &note_msg);\n-            };\n-            could_refer_to(DefKind::Variant, variant_def_id, \"\");\n-            could_refer_to(kind, item.def_id, \" also\");\n \n-            err.span_suggestion(\n-                span,\n-                \"use fully-qualified syntax\",\n-                format!(\"<{} as {}>::{}\", qself_ty, tcx.item_name(trait_did), assoc_ident),\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+                err.emit();\n+            });\n         }\n-\n         Ok((ty, kind, item.def_id))\n     }\n "}, {"sha": "909f40ee98499639825eefffe29f17d0e844f880", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -468,23 +468,20 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         } else {\n             (\"\", lint::builtin::TRIVIAL_CASTS)\n         };\n-        let mut err = fcx.tcx.struct_span_lint_hir(\n-            lint,\n-            self.expr.hir_id,\n-            self.span,\n-            &format!(\n+        fcx.tcx.struct_span_lint_hir(lint, self.expr.hir_id, self.span, |err| {\n+            err.build(&format!(\n                 \"trivial {}cast: `{}` as `{}`\",\n                 adjective,\n                 fcx.ty_to_string(t_expr),\n                 fcx.ty_to_string(t_cast)\n-            ),\n-        );\n-        err.help(&format!(\n-            \"cast can be replaced by coercion; this might \\\n-                           require {}a temporary variable\",\n-            type_asc_or\n-        ));\n-        err.emit();\n+            ))\n+            .help(&format!(\n+                \"cast can be replaced by coercion; this might \\\n+                                   require {}a temporary variable\",\n+                type_asc_or\n+            ))\n+            .emit();\n+        });\n     }\n \n     pub fn check(mut self, fcx: &FnCtxt<'a, 'tcx>) {"}, {"sha": "760b6487045d85340ed4c160ddea970bcb1cdd5a", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -382,11 +382,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     )\n                     .emit();\n                 } else {\n-                    self.tcx.lint_hir(\n+                    self.tcx.struct_span_lint_hir(\n                         lint::builtin::TYVAR_BEHIND_RAW_POINTER,\n                         scope_expr_id,\n                         span,\n-                        \"type annotations needed\",\n+                        |lint| lint.build(\"type annotations needed\").emit(),\n                     );\n                 }\n             } else {\n@@ -1280,33 +1280,36 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         stable_pick: &Pick<'_>,\n         unstable_candidates: &[(&Candidate<'tcx>, Symbol)],\n     ) {\n-        let mut diag = self.tcx.struct_span_lint_hir(\n+        self.tcx.struct_span_lint_hir(\n             lint::builtin::UNSTABLE_NAME_COLLISIONS,\n             self.fcx.body_id,\n             self.span,\n-            \"a method with this name may be added to the standard library in the future\",\n-        );\n-\n-        // FIXME: This should be a `span_suggestion` instead of `help`\n-        // However `self.span` only\n-        // highlights the method name, so we can't use it. Also consider reusing the code from\n-        // `report_method_error()`.\n-        diag.help(&format!(\n-            \"call with fully qualified syntax `{}(...)` to keep using the current method\",\n-            self.tcx.def_path_str(stable_pick.item.def_id),\n-        ));\n-\n-        if nightly_options::is_nightly_build() {\n-            for (candidate, feature) in unstable_candidates {\n+            |lint| {\n+                let mut diag = lint.build(\n+                    \"a method with this name may be added to the standard library in the future\",\n+                );\n+                // FIXME: This should be a `span_suggestion` instead of `help`\n+                // However `self.span` only\n+                // highlights the method name, so we can't use it. Also consider reusing the code from\n+                // `report_method_error()`.\n                 diag.help(&format!(\n-                    \"add `#![feature({})]` to the crate attributes to enable `{}`\",\n-                    feature,\n-                    self.tcx.def_path_str(candidate.item.def_id),\n+                    \"call with fully qualified syntax `{}(...)` to keep using the current method\",\n+                    self.tcx.def_path_str(stable_pick.item.def_id),\n                 ));\n-            }\n-        }\n \n-        diag.emit();\n+                if nightly_options::is_nightly_build() {\n+                    for (candidate, feature) in unstable_candidates {\n+                        diag.help(&format!(\n+                            \"add `#![feature({})]` to the crate attributes to enable `{}`\",\n+                            feature,\n+                            self.tcx.def_path_str(candidate.item.def_id),\n+                        ));\n+                    }\n+                }\n+\n+                diag.emit();\n+            },\n+        );\n     }\n \n     fn select_trait_candidate("}, {"sha": "be2052dce3c0b9f3232237f11fca5d3ebda0591c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -2895,15 +2895,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 debug!(\"warn_if_unreachable: id={:?} span={:?} kind={}\", id, span, kind);\n \n-                let msg = format!(\"unreachable {}\", kind);\n-                self.tcx()\n-                    .struct_span_lint_hir(lint::builtin::UNREACHABLE_CODE, id, span, &msg)\n-                    .span_label(span, &msg)\n-                    .span_label(\n-                        orig_span,\n-                        custom_note.unwrap_or(\"any code following this expression is unreachable\"),\n-                    )\n-                    .emit();\n+                self.tcx().struct_span_lint_hir(lint::builtin::UNREACHABLE_CODE, id, span, |lint| {\n+                    let msg = format!(\"unreachable {}\", kind);\n+                    lint.build(&msg)\n+                        .span_label(span, &msg)\n+                        .span_label(\n+                            orig_span,\n+                            custom_note\n+                                .unwrap_or(\"any code following this expression is unreachable\"),\n+                        )\n+                        .emit();\n+                })\n             }\n         }\n     }"}, {"sha": "dd833d9751cb90e483f7d921fd74fe4aa547c75c", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 45, "deletions": 40, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -55,12 +55,14 @@ impl CheckVisitor<'tcx> {\n             return;\n         }\n \n-        let msg = if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n-            format!(\"unused import: `{}`\", snippet)\n-        } else {\n-            \"unused import\".to_owned()\n-        };\n-        self.tcx.lint_hir(lint::builtin::UNUSED_IMPORTS, id, span, &msg);\n+        self.tcx.struct_span_lint_hir(lint::builtin::UNUSED_IMPORTS, id, span, |lint| {\n+            let msg = if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                format!(\"unused import: `{}`\", snippet)\n+            } else {\n+                \"unused import\".to_owned()\n+            };\n+            lint.build(&msg).emit();\n+        });\n     }\n }\n \n@@ -121,23 +123,23 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n         // We do this in any edition.\n         if extern_crate.warn_if_unused {\n             if let Some(&span) = unused_extern_crates.get(&extern_crate.def_id) {\n-                let msg = \"unused extern crate\";\n-\n-                // Removal suggestion span needs to include attributes (Issue #54400)\n-                let span_with_attrs = tcx\n-                    .get_attrs(extern_crate.def_id)\n-                    .iter()\n-                    .map(|attr| attr.span)\n-                    .fold(span, |acc, attr_span| acc.to(attr_span));\n-\n-                tcx.struct_span_lint_hir(lint, id, span, msg)\n-                    .span_suggestion_short(\n-                        span_with_attrs,\n-                        \"remove it\",\n-                        String::new(),\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n+                tcx.struct_span_lint_hir(lint, id, span, |lint| {\n+                    // Removal suggestion span needs to include attributes (Issue #54400)\n+                    let span_with_attrs = tcx\n+                        .get_attrs(extern_crate.def_id)\n+                        .iter()\n+                        .map(|attr| attr.span)\n+                        .fold(span, |acc, attr_span| acc.to(attr_span));\n+\n+                    lint.build(\"unused extern crate\")\n+                        .span_suggestion_short(\n+                            span_with_attrs,\n+                            \"remove it\",\n+                            String::new(),\n+                            Applicability::MachineApplicable,\n+                        )\n+                        .emit();\n+                });\n                 continue;\n             }\n         }\n@@ -168,23 +170,26 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n         if !tcx.get_attrs(extern_crate.def_id).is_empty() {\n             continue;\n         }\n-\n-        // Otherwise, we can convert it into a `use` of some kind.\n-        let msg = \"`extern crate` is not idiomatic in the new edition\";\n-        let help = format!(\"convert it to a `{}`\", visibility_qualified(&item.vis, \"use\"));\n-        let base_replacement = match extern_crate.orig_name {\n-            Some(orig_name) => format!(\"use {} as {};\", orig_name, item.ident.name),\n-            None => format!(\"use {};\", item.ident.name),\n-        };\n-        let replacement = visibility_qualified(&item.vis, base_replacement);\n-        tcx.struct_span_lint_hir(lint, id, extern_crate.span, msg)\n-            .span_suggestion_short(\n-                extern_crate.span,\n-                &help,\n-                replacement,\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+        tcx.struct_span_lint_hir(lint, id, extern_crate.span, |lint| {\n+            // Otherwise, we can convert it into a `use` of some kind.\n+            let base_replacement = match extern_crate.orig_name {\n+                Some(orig_name) => format!(\"use {} as {};\", orig_name, item.ident.name),\n+                None => format!(\"use {};\", item.ident.name),\n+            };\n+\n+            let replacement = visibility_qualified(&item.vis, base_replacement);\n+            let msg = \"`extern crate` is not idiomatic in the new edition\";\n+            let help = format!(\"convert it to a `{}`\", visibility_qualified(&item.vis, \"use\"));\n+\n+            lint.build(msg)\n+                .span_suggestion_short(\n+                    extern_crate.span,\n+                    &help,\n+                    replacement,\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n+        })\n     }\n }\n "}, {"sha": "b661006d1ddd08e0b27624dcbf32f4a89a671ebe", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -1151,14 +1151,17 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n             GenericParamKind::Type { ref default, synthetic, .. } => {\n                 if !allow_defaults && default.is_some() {\n                     if !tcx.features().default_type_parameter_fallback {\n-                        tcx.lint_hir(\n+                        tcx.struct_span_lint_hir(\n                             lint::builtin::INVALID_TYPE_PARAM_DEFAULT,\n                             param.hir_id,\n                             param.span,\n-                            &format!(\n-                                \"defaults for type parameters are only allowed in \\\n+                            |lint| {\n+                                lint.build(&format!(\n+                                    \"defaults for type parameters are only allowed in \\\n                                         `struct`, `enum`, `type`, or `trait` definitions.\"\n-                            ),\n+                                ))\n+                                .emit();\n+                            },\n                         );\n                     }\n                 }\n@@ -2956,10 +2959,12 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                     lint::builtin::INLINE_NO_SANITIZE,\n                     hir_id,\n                     no_sanitize_span,\n-                    \"`no_sanitize` will have no effect after inlining\",\n+                    |lint| {\n+                        lint.build(\"`no_sanitize` will have no effect after inlining\")\n+                            .span_note(inline_span, \"inlining requested here\")\n+                            .emit();\n+                    },\n                 )\n-                .span_note(inline_span, \"inlining requested here\")\n-                .emit();\n             }\n         }\n     }"}, {"sha": "79bcfe7aee7447ee9caffd0eb364b0a1e13e89be", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 125, "deletions": 118, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -669,39 +669,43 @@ fn build_diagnostic(\n     let attrs = &item.attrs;\n     let sp = span_of_attrs(attrs).unwrap_or(item.source.span());\n \n-    let mut diag = cx.tcx.struct_span_lint_hir(\n+    cx.tcx.struct_span_lint_hir(\n         lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n         hir_id,\n         sp,\n-        &format!(\"`[{}]` {}\", path_str, err_msg),\n+        |lint| {\n+            let mut diag = lint.build(&format!(\"`[{}]` {}\", path_str, err_msg));\n+            if let Some(link_range) = link_range {\n+                if let Some(sp) = super::source_span_for_markdown_range(cx, dox, &link_range, attrs)\n+                {\n+                    diag.set_span(sp);\n+                    diag.span_label(sp, short_err_msg);\n+                } else {\n+                    // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n+                    //                       ^     ~~~~\n+                    //                       |     link_range\n+                    //                       last_new_line_offset\n+                    let last_new_line_offset =\n+                        dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n+                    let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n+\n+                    // Print the line containing the `link_range` and manually mark it with '^'s.\n+                    diag.note(&format!(\n+                        \"the link appears in this line:\\n\\n{line}\\n\\\n+                         {indicator: <before$}{indicator:^<found$}\",\n+                        line = line,\n+                        indicator = \"\",\n+                        before = link_range.start - last_new_line_offset,\n+                        found = link_range.len(),\n+                    ));\n+                }\n+            };\n+            if let Some(help_msg) = help_msg {\n+                diag.help(help_msg);\n+            }\n+            diag.emit();\n+        },\n     );\n-    if let Some(link_range) = link_range {\n-        if let Some(sp) = super::source_span_for_markdown_range(cx, dox, &link_range, attrs) {\n-            diag.set_span(sp);\n-            diag.span_label(sp, short_err_msg);\n-        } else {\n-            // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n-            //                       ^     ~~~~\n-            //                       |     link_range\n-            //                       last_new_line_offset\n-            let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n-            let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n-\n-            // Print the line containing the `link_range` and manually mark it with '^'s.\n-            diag.note(&format!(\n-                \"the link appears in this line:\\n\\n{line}\\n\\\n-                 {indicator: <before$}{indicator:^<found$}\",\n-                line = line,\n-                indicator = \"\",\n-                before = link_range.start - last_new_line_offset,\n-                found = link_range.len(),\n-            ));\n-        }\n-    };\n-    if let Some(help_msg) = help_msg {\n-        diag.help(help_msg);\n-    }\n-    diag.emit();\n }\n \n /// Reports a resolution failure diagnostic.\n@@ -766,105 +770,108 @@ fn ambiguity_error(\n     let attrs = &item.attrs;\n     let sp = span_of_attrs(attrs).unwrap_or(item.source.span());\n \n-    let mut msg = format!(\"`{}` is \", path_str);\n-\n-    let candidates = [TypeNS, ValueNS, MacroNS]\n-        .iter()\n-        .filter_map(|&ns| candidates[ns].map(|res| (res, ns)))\n-        .collect::<Vec<_>>();\n-    match candidates.as_slice() {\n-        [(first_def, _), (second_def, _)] => {\n-            msg += &format!(\n-                \"both {} {} and {} {}\",\n-                first_def.article(),\n-                first_def.descr(),\n-                second_def.article(),\n-                second_def.descr(),\n-            );\n-        }\n-        _ => {\n-            let mut candidates = candidates.iter().peekable();\n-            while let Some((res, _)) = candidates.next() {\n-                if candidates.peek().is_some() {\n-                    msg += &format!(\"{} {}, \", res.article(), res.descr());\n-                } else {\n-                    msg += &format!(\"and {} {}\", res.article(), res.descr());\n-                }\n-            }\n-        }\n-    }\n-\n-    let mut diag = cx.tcx.struct_span_lint_hir(\n+    cx.tcx.struct_span_lint_hir(\n         lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE,\n         hir_id,\n         sp,\n-        &msg,\n-    );\n+        |lint| {\n+            let mut msg = format!(\"`{}` is \", path_str);\n \n-    if let Some(link_range) = link_range {\n-        if let Some(sp) = super::source_span_for_markdown_range(cx, dox, &link_range, attrs) {\n-            diag.set_span(sp);\n-            diag.span_label(sp, \"ambiguous link\");\n-\n-            for (res, ns) in candidates {\n-                let (action, mut suggestion) = match res {\n-                    Res::Def(DefKind::Method, _) | Res::Def(DefKind::Fn, _) => {\n-                        (\"add parentheses\", format!(\"{}()\", path_str))\n-                    }\n-                    Res::Def(DefKind::Macro(..), _) => {\n-                        (\"add an exclamation mark\", format!(\"{}!\", path_str))\n+            let candidates = [TypeNS, ValueNS, MacroNS]\n+                .iter()\n+                .filter_map(|&ns| candidates[ns].map(|res| (res, ns)))\n+                .collect::<Vec<_>>();\n+            match candidates.as_slice() {\n+                [(first_def, _), (second_def, _)] => {\n+                    msg += &format!(\n+                        \"both {} {} and {} {}\",\n+                        first_def.article(),\n+                        first_def.descr(),\n+                        second_def.article(),\n+                        second_def.descr(),\n+                    );\n+                }\n+                _ => {\n+                    let mut candidates = candidates.iter().peekable();\n+                    while let Some((res, _)) = candidates.next() {\n+                        if candidates.peek().is_some() {\n+                            msg += &format!(\"{} {}, \", res.article(), res.descr());\n+                        } else {\n+                            msg += &format!(\"and {} {}\", res.article(), res.descr());\n+                        }\n                     }\n-                    _ => {\n-                        let type_ = match (res, ns) {\n-                            (Res::Def(DefKind::Const, _), _) => \"const\",\n-                            (Res::Def(DefKind::Static, _), _) => \"static\",\n-                            (Res::Def(DefKind::Struct, _), _) => \"struct\",\n-                            (Res::Def(DefKind::Enum, _), _) => \"enum\",\n-                            (Res::Def(DefKind::Union, _), _) => \"union\",\n-                            (Res::Def(DefKind::Trait, _), _) => \"trait\",\n-                            (Res::Def(DefKind::Mod, _), _) => \"module\",\n-                            (_, TypeNS) => \"type\",\n-                            (_, ValueNS) => \"value\",\n-                            (_, MacroNS) => \"macro\",\n+                }\n+            }\n+\n+            let mut diag = lint.build(&msg);\n+\n+            if let Some(link_range) = link_range {\n+                if let Some(sp) = super::source_span_for_markdown_range(cx, dox, &link_range, attrs)\n+                {\n+                    diag.set_span(sp);\n+                    diag.span_label(sp, \"ambiguous link\");\n+\n+                    for (res, ns) in candidates {\n+                        let (action, mut suggestion) = match res {\n+                            Res::Def(DefKind::Method, _) | Res::Def(DefKind::Fn, _) => {\n+                                (\"add parentheses\", format!(\"{}()\", path_str))\n+                            }\n+                            Res::Def(DefKind::Macro(..), _) => {\n+                                (\"add an exclamation mark\", format!(\"{}!\", path_str))\n+                            }\n+                            _ => {\n+                                let type_ = match (res, ns) {\n+                                    (Res::Def(DefKind::Const, _), _) => \"const\",\n+                                    (Res::Def(DefKind::Static, _), _) => \"static\",\n+                                    (Res::Def(DefKind::Struct, _), _) => \"struct\",\n+                                    (Res::Def(DefKind::Enum, _), _) => \"enum\",\n+                                    (Res::Def(DefKind::Union, _), _) => \"union\",\n+                                    (Res::Def(DefKind::Trait, _), _) => \"trait\",\n+                                    (Res::Def(DefKind::Mod, _), _) => \"module\",\n+                                    (_, TypeNS) => \"type\",\n+                                    (_, ValueNS) => \"value\",\n+                                    (_, MacroNS) => \"macro\",\n+                                };\n+\n+                                // FIXME: if this is an implied shortcut link, it's bad style to suggest `@`\n+                                (\"prefix with the item type\", format!(\"{}@{}\", type_, path_str))\n+                            }\n                         };\n \n-                        // FIXME: if this is an implied shortcut link, it's bad style to suggest `@`\n-                        (\"prefix with the item type\", format!(\"{}@{}\", type_, path_str))\n-                    }\n-                };\n+                        if dox.bytes().nth(link_range.start) == Some(b'`') {\n+                            suggestion = format!(\"`{}`\", suggestion);\n+                        }\n \n-                if dox.bytes().nth(link_range.start) == Some(b'`') {\n-                    suggestion = format!(\"`{}`\", suggestion);\n+                        diag.span_suggestion(\n+                            sp,\n+                            &format!(\"to link to the {}, {}\", res.descr(), action),\n+                            suggestion,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                } else {\n+                    // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n+                    //                       ^     ~~~~\n+                    //                       |     link_range\n+                    //                       last_new_line_offset\n+                    let last_new_line_offset =\n+                        dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n+                    let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n+\n+                    // Print the line containing the `link_range` and manually mark it with '^'s.\n+                    diag.note(&format!(\n+                        \"the link appears in this line:\\n\\n{line}\\n\\\n+                         {indicator: <before$}{indicator:^<found$}\",\n+                        line = line,\n+                        indicator = \"\",\n+                        before = link_range.start - last_new_line_offset,\n+                        found = link_range.len(),\n+                    ));\n                 }\n-\n-                diag.span_suggestion(\n-                    sp,\n-                    &format!(\"to link to the {}, {}\", res.descr(), action),\n-                    suggestion,\n-                    Applicability::MaybeIncorrect,\n-                );\n             }\n-        } else {\n-            // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n-            //                       ^     ~~~~\n-            //                       |     link_range\n-            //                       last_new_line_offset\n-            let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n-            let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n-\n-            // Print the line containing the `link_range` and manually mark it with '^'s.\n-            diag.note(&format!(\n-                \"the link appears in this line:\\n\\n{line}\\n\\\n-                 {indicator: <before$}{indicator:^<found$}\",\n-                line = line,\n-                indicator = \"\",\n-                before = link_range.start - last_new_line_offset,\n-                found = link_range.len(),\n-            ));\n-        }\n-    }\n-\n-    diag.emit();\n+            diag.emit();\n+        },\n+    );\n }\n \n /// Given an enum variant's res, return the res of its enum and the associated fragment."}, {"sha": "9e48904a47d335616009fb6a87cfa51ad21c475a", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -342,24 +342,19 @@ pub fn look_for_tests<'tcx>(\n \n     if check_missing_code == true && tests.found_tests == 0 {\n         let sp = span_of_attrs(&item.attrs).unwrap_or(item.source.span());\n-        let mut diag = cx.tcx.struct_span_lint_hir(\n-            lint::builtin::MISSING_DOC_CODE_EXAMPLES,\n-            hir_id,\n-            sp,\n-            \"missing code example in this documentation\",\n-        );\n-        diag.emit();\n+        cx.tcx.struct_span_lint_hir(lint::builtin::MISSING_DOC_CODE_EXAMPLES, hir_id, sp, |lint| {\n+            lint.build(\"missing code example in this documentation\").emit()\n+        });\n     } else if check_missing_code == false\n         && tests.found_tests > 0\n         && !cx.renderinfo.borrow().access_levels.is_public(item.def_id)\n     {\n-        let mut diag = cx.tcx.struct_span_lint_hir(\n+        cx.tcx.struct_span_lint_hir(\n             lint::builtin::PRIVATE_DOC_TESTS,\n             hir_id,\n             span_of_attrs(&item.attrs).unwrap_or(item.source.span()),\n-            \"documentation test in private item\",\n+            |lint| lint.build(\"documentation test in private item\").emit(),\n         );\n-        diag.emit();\n     }\n }\n "}, {"sha": "91b3372e8f41516815f430cb43f32db385c0107f", "filename": "src/test/ui-fulldeps/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -4,17 +4,19 @@\n extern crate rustc_ast_pretty;\n extern crate rustc_driver;\n extern crate rustc_hir;\n-#[macro_use] extern crate rustc_lint;\n-#[macro_use] extern crate rustc_session;\n+#[macro_use]\n+extern crate rustc_lint;\n+#[macro_use]\n+extern crate rustc_session;\n extern crate rustc_span;\n extern crate syntax;\n \n use rustc_ast_pretty::pprust;\n-use rustc_hir::intravisit;\n+use rustc_driver::plugin::Registry;\n use rustc_hir as hir;\n+use rustc_hir::intravisit;\n use rustc_hir::Node;\n-use rustc_lint::{LateContext, LintPass, LintArray, LateLintPass, LintContext};\n-use rustc_driver::plugin::Registry;\n+use rustc_lint::{LateContext, LateLintPass, LintArray, LintContext, LintPass};\n use rustc_span::source_map;\n \n #[plugin_registrar]\n@@ -32,23 +34,25 @@ declare_lint! {\n declare_lint_pass!(MissingWhitelistedAttrPass => [MISSING_WHITELISTED_ATTR]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingWhitelistedAttrPass {\n-    fn check_fn(&mut self,\n-                cx: &LateContext<'a, 'tcx>,\n-                _: intravisit::FnKind<'tcx>,\n-                _: &'tcx hir::FnDecl,\n-                _: &'tcx hir::Body,\n-                span: source_map::Span,\n-                id: hir::HirId) {\n-\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        _: intravisit::FnKind<'tcx>,\n+        _: &'tcx hir::FnDecl,\n+        _: &'tcx hir::Body,\n+        span: source_map::Span,\n+        id: hir::HirId,\n+    ) {\n         let item = match cx.tcx.hir().get(id) {\n             Node::Item(item) => item,\n             _ => cx.tcx.hir().expect_item(cx.tcx.hir().get_parent_item(id)),\n         };\n \n         let whitelisted = |attr| pprust::attribute_to_string(attr).contains(\"whitelisted_attr\");\n         if !item.attrs.iter().any(whitelisted) {\n-            cx.span_lint(MISSING_WHITELISTED_ATTR, span,\n-                         \"Missing 'whitelisted_attr' attribute\");\n+            cx.lint(MISSING_WHITELISTED_ATTR, |lint| {\n+                lint.build(\"Missing 'whitelisted_attr' attribute\").set_span(span).emit()\n+            });\n         }\n     }\n }"}, {"sha": "eb251a0a3adb8bdaf594e55eeeac0f82f9fcd4be", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate-rpass.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -5,12 +5,14 @@\n extern crate rustc_driver;\n extern crate rustc_hir;\n extern crate rustc_span;\n-#[macro_use] extern crate rustc_lint;\n-#[macro_use] extern crate rustc_session;\n+#[macro_use]\n+extern crate rustc_lint;\n+#[macro_use]\n+extern crate rustc_session;\n extern crate syntax;\n \n-use rustc_lint::{LateContext, LintContext, LintPass, LateLintPass};\n use rustc_driver::plugin::Registry;\n+use rustc_lint::{LateContext, LateLintPass, LintContext, LintPass};\n use rustc_span::symbol::Symbol;\n use syntax::attr;\n \n@@ -28,8 +30,10 @@ macro_rules! fake_lint_pass {\n             fn check_crate(&mut self, cx: &LateContext, krate: &rustc_hir::Crate) {\n                 $(\n                     if !attr::contains_name(&krate.attrs, $attr) {\n-                        cx.span_lint(CRATE_NOT_OKAY, krate.span,\n-                                     &format!(\"crate is not marked with #![{}]\", $attr));\n+                        cx.lint(CRATE_NOT_OKAY, |lint| {\n+                             let msg = format!(\"crate is not marked with #![{}]\", $attr);\n+                             lint.build(&msg).set_span(krate.span).emit()\n+                        });\n                     }\n                 )*\n             }"}, {"sha": "e5f4bf88d57aad260a40828f5e4454ef97996ae4", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -5,13 +5,15 @@\n \n extern crate rustc_driver;\n extern crate rustc_hir;\n-#[macro_use] extern crate rustc_lint;\n-#[macro_use] extern crate rustc_session;\n+#[macro_use]\n+extern crate rustc_lint;\n+#[macro_use]\n+extern crate rustc_session;\n extern crate rustc_span;\n extern crate syntax;\n \n-use rustc_lint::{LateContext, LintContext, LintPass, LateLintPass, LintArray};\n use rustc_driver::plugin::Registry;\n+use rustc_lint::{LateContext, LateLintPass, LintArray, LintContext, LintPass};\n use rustc_span::symbol::Symbol;\n use syntax::attr;\n \n@@ -26,8 +28,11 @@ declare_lint_pass!(Pass => [CRATE_NOT_OKAY]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_crate(&mut self, cx: &LateContext, krate: &rustc_hir::Crate) {\n         if !attr::contains_name(&krate.attrs, Symbol::intern(\"crate_okay\")) {\n-            cx.span_lint(CRATE_NOT_OKAY, krate.span,\n-                         \"crate is not marked with #![crate_okay]\");\n+            cx.lint(CRATE_NOT_OKAY, |lint| {\n+                lint.build(\"crate is not marked with #![crate_okay]\")\n+                    .set_span(krate.span)\n+                    .emit()\n+            });\n         }\n     }\n }"}, {"sha": "5a8eaa63db2f86f72592242f4aa4422ce50a6dbe", "filename": "src/test/ui-fulldeps/auxiliary/lint-group-plugin-test.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -6,11 +6,13 @@\n // Load rustc as a plugin to get macros.\n extern crate rustc_driver;\n extern crate rustc_hir;\n-#[macro_use] extern crate rustc_lint;\n-#[macro_use] extern crate rustc_session;\n+#[macro_use]\n+extern crate rustc_lint;\n+#[macro_use]\n+extern crate rustc_session;\n \n-use rustc_lint::{LateContext, LintContext, LintPass, LateLintPass, LintArray, LintId};\n use rustc_driver::plugin::Registry;\n+use rustc_lint::{LateContext, LateLintPass, LintArray, LintContext, LintId, LintPass};\n \n declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");\n \n@@ -21,8 +23,12 @@ declare_lint_pass!(Pass => [TEST_LINT, PLEASE_LINT]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_item(&mut self, cx: &LateContext, it: &rustc_hir::Item) {\n         match &*it.ident.as_str() {\n-            \"lintme\" => cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\"),\n-            \"pleaselintme\" => cx.span_lint(PLEASE_LINT, it.span, \"item is named 'pleaselintme'\"),\n+            \"lintme\" => cx.lint(TEST_LINT, |lint| {\n+                lint.build(\"item is named 'lintme'\").set_span(it.span).emit()\n+            }),\n+            \"pleaselintme\" => cx.lint(PLEASE_LINT, |lint| {\n+                lint.build(\"item is named 'pleaselintme'\").set_span(it.span).emit()\n+            }),\n             _ => {}\n         }\n     }\n@@ -32,6 +38,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.lint_store.register_lints(&[&TEST_LINT, &PLEASE_LINT]);\n     reg.lint_store.register_late_pass(|| box Pass);\n-    reg.lint_store.register_group(true, \"lint_me\", None,\n-        vec![LintId::of(&TEST_LINT), LintId::of(&PLEASE_LINT)]);\n+    reg.lint_store.register_group(\n+        true,\n+        \"lint_me\",\n+        None,\n+        vec![LintId::of(&TEST_LINT), LintId::of(&PLEASE_LINT)],\n+    );\n }"}, {"sha": "ad5f882c4343408f8d8486783b247702e3165fa1", "filename": "src/test/ui-fulldeps/auxiliary/lint-plugin-test.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -7,11 +7,13 @@ extern crate syntax;\n \n // Load rustc as a plugin to get macros\n extern crate rustc_driver;\n-#[macro_use] extern crate rustc_lint;\n-#[macro_use] extern crate rustc_session;\n+#[macro_use]\n+extern crate rustc_lint;\n+#[macro_use]\n+extern crate rustc_session;\n \n-use rustc_lint::{EarlyContext, LintContext, LintPass, EarlyLintPass, LintArray};\n use rustc_driver::plugin::Registry;\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintArray, LintContext, LintPass};\n use syntax::ast;\n declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");\n \n@@ -20,7 +22,9 @@ declare_lint_pass!(Pass => [TEST_LINT]);\n impl EarlyLintPass for Pass {\n     fn check_item(&mut self, cx: &EarlyContext, it: &ast::Item) {\n         if it.ident.name.as_str() == \"lintme\" {\n-            cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n+            cx.lint(TEST_LINT, |lint| {\n+                lint.build(\"item is named 'lintme'\").set_span(it.span).emit()\n+            });\n         }\n     }\n }"}, {"sha": "b14dbdf8f938b5443e793a41b80695cdda19f387", "filename": "src/test/ui-fulldeps/auxiliary/lint-tool-test.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -5,11 +5,13 @@ extern crate syntax;\n \n // Load rustc as a plugin to get macros\n extern crate rustc_driver;\n-#[macro_use] extern crate rustc_lint;\n-#[macro_use] extern crate rustc_session;\n+#[macro_use]\n+extern crate rustc_lint;\n+#[macro_use]\n+extern crate rustc_session;\n \n-use rustc_lint::{EarlyContext, EarlyLintPass, LintArray, LintContext, LintPass, LintId};\n use rustc_driver::plugin::Registry;\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintArray, LintContext, LintId, LintPass};\n use syntax::ast;\n declare_tool_lint!(pub clippy::TEST_LINT, Warn, \"Warn about stuff\");\n declare_tool_lint!(\n@@ -30,10 +32,14 @@ declare_lint_pass!(Pass => [TEST_LINT, TEST_GROUP, TEST_RUSTC_TOOL_LINT]);\n impl EarlyLintPass for Pass {\n     fn check_item(&mut self, cx: &EarlyContext, it: &ast::Item) {\n         if it.ident.name.as_str() == \"lintme\" {\n-            cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n+            cx.lint(TEST_LINT, |lint| {\n+                lint.build(\"item is named 'lintme'\").set_span(it.span).emit()\n+            });\n         }\n         if it.ident.name.as_str() == \"lintmetoo\" {\n-            cx.span_lint(TEST_GROUP, it.span, \"item is named 'lintmetoo'\");\n+            cx.lint(TEST_GROUP, |lint| {\n+                lint.build(\"item is named 'lintmetoo'\").set_span(it.span).emit()\n+            });\n         }\n     }\n }\n@@ -42,6 +48,10 @@ impl EarlyLintPass for Pass {\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.lint_store.register_lints(&[&TEST_RUSTC_TOOL_LINT, &TEST_LINT, &TEST_GROUP]);\n     reg.lint_store.register_early_pass(|| box Pass);\n-    reg.lint_store.register_group(true, \"clippy::group\", Some(\"clippy_group\"),\n-        vec![LintId::of(&TEST_LINT), LintId::of(&TEST_GROUP)]);\n+    reg.lint_store.register_group(\n+        true,\n+        \"clippy::group\",\n+        Some(\"clippy_group\"),\n+        vec![LintId::of(&TEST_LINT), LintId::of(&TEST_GROUP)],\n+    );\n }"}, {"sha": "5f3b711b31aa91bac473564d7e63ac574a05d3b5", "filename": "src/test/ui/type-alias-enum-variants/enum-variant-priority-lint-ambiguous_associated_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fenum-variant-priority-lint-ambiguous_associated_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95e0a2c50d063bd7eb79aa55d16cd5fee715c280/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fenum-variant-priority-lint-ambiguous_associated_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fenum-variant-priority-lint-ambiguous_associated_items.rs?ref=95e0a2c50d063bd7eb79aa55d16cd5fee715c280", "patch": "@@ -32,6 +32,7 @@ impl Tr for E {\n     fn f() -> Self::V { 0 }\n     //~^ ERROR ambiguous associated item\n     //~| WARN this was previously accepted\n+    //~| HELP use fully-qualified syntax\n }\n \n fn main() {}"}]}