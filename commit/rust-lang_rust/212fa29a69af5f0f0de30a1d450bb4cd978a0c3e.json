{"sha": "212fa29a69af5f0f0de30a1d450bb4cd978a0c3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxMmZhMjlhNjlhZjVmMGYwZGUzMGExZDQ1MGJiNGNkOTc4YTBjM2U=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-04T00:13:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-04T00:13:11Z"}, "message": "Merge #5197\n\n5197: SSR internal refactorings r=davidlattimore a=davidlattimore\n\n- Extract error code out to a separate module\r\n- Improve error reporting when a test fails\r\n- Refactor matching code\r\n- Update tests so that all paths in search patterns can be resolved\n\nCo-authored-by: David Lattimore <dml@google.com>", "tree": {"sha": "d6e217123706604766365d4630ee21ef2d34a8bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6e217123706604766365d4630ee21ef2d34a8bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/212fa29a69af5f0f0de30a1d450bb4cd978a0c3e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe/8mXCRBK7hj4Ov3rIwAAdHIIAJiSd6pOMCPKd7H5Qv9yFolw\nFVLGpnMHwcQefOk2HPeFaN8ssOhDwRQsqTZBfUYM7i2ZkiPLMKglliP3DyY9sFJv\n+ekmUqeEAX1XbODtCuCHy8xVedl6Lz4AewSBlddMoLBRjUeq4RgIHE/u/bwnNvq/\nP9yoOOqtlMhVCdl/4bA2kltz961ZraU7eUcK21Nu+gzMc3bgwKrtqMUDQ2/2+iRn\nUAIQVqBa4AZXi8xn3718UereOel5kdOzjfb7Bw06xGN/PpMoccuSPQLSquRuze8J\nrbJtqR/De5dAb3Fp+yUFiuQqYbJ6LG14AsgHlHirXUx8u2Aoik9ymoJIfU9lbOs=\n=b38V\n-----END PGP SIGNATURE-----\n", "payload": "tree d6e217123706604766365d4630ee21ef2d34a8bb\nparent fe16e1da695589d55f13b36644b7a56be7d09a48\nparent a354e5b5cf433a8f1236c85f30cd19829a374f6d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593821591 +0000\ncommitter GitHub <noreply@github.com> 1593821591 +0000\n\nMerge #5197\n\n5197: SSR internal refactorings r=davidlattimore a=davidlattimore\n\n- Extract error code out to a separate module\r\n- Improve error reporting when a test fails\r\n- Refactor matching code\r\n- Update tests so that all paths in search patterns can be resolved\n\nCo-authored-by: David Lattimore <dml@google.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/212fa29a69af5f0f0de30a1d450bb4cd978a0c3e", "html_url": "https://github.com/rust-lang/rust/commit/212fa29a69af5f0f0de30a1d450bb4cd978a0c3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/212fa29a69af5f0f0de30a1d450bb4cd978a0c3e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe16e1da695589d55f13b36644b7a56be7d09a48", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe16e1da695589d55f13b36644b7a56be7d09a48", "html_url": "https://github.com/rust-lang/rust/commit/fe16e1da695589d55f13b36644b7a56be7d09a48"}, {"sha": "a354e5b5cf433a8f1236c85f30cd19829a374f6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a354e5b5cf433a8f1236c85f30cd19829a374f6d", "html_url": "https://github.com/rust-lang/rust/commit/a354e5b5cf433a8f1236c85f30cd19829a374f6d"}], "stats": {"total": 434, "additions": 243, "deletions": 191}, "files": [{"sha": "c02bacae6bfe68f2ed94a114011ecb805006844e", "filename": "crates/ra_ssr/src/errors.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/212fa29a69af5f0f0de30a1d450bb4cd978a0c3e/crates%2Fra_ssr%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212fa29a69af5f0f0de30a1d450bb4cd978a0c3e/crates%2Fra_ssr%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ferrors.rs?ref=212fa29a69af5f0f0de30a1d450bb4cd978a0c3e", "patch": "@@ -0,0 +1,29 @@\n+//! Code relating to errors produced by SSR.\n+\n+/// Constructs an SsrError taking arguments like the format macro.\n+macro_rules! _error {\n+    ($fmt:expr) => {$crate::SsrError::new(format!($fmt))};\n+    ($fmt:expr, $($arg:tt)+) => {$crate::SsrError::new(format!($fmt, $($arg)+))}\n+}\n+pub(crate) use _error as error;\n+\n+/// Returns from the current function with an error, supplied by arguments as for format!\n+macro_rules! _bail {\n+    ($($tokens:tt)*) => {return Err(crate::errors::error!($($tokens)*))}\n+}\n+pub(crate) use _bail as bail;\n+\n+#[derive(Debug, PartialEq)]\n+pub struct SsrError(pub(crate) String);\n+\n+impl std::fmt::Display for SsrError {\n+    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n+        write!(f, \"Parse error: {}\", self.0)\n+    }\n+}\n+\n+impl SsrError {\n+    pub(crate) fn new(message: impl Into<String>) -> SsrError {\n+        SsrError(message.into())\n+    }\n+}"}, {"sha": "cca4576ce05baab20f0e27949494863503846b0b", "filename": "crates/ra_ssr/src/lib.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/212fa29a69af5f0f0de30a1d450bb4cd978a0c3e/crates%2Fra_ssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212fa29a69af5f0f0de30a1d450bb4cd978a0c3e/crates%2Fra_ssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Flib.rs?ref=212fa29a69af5f0f0de30a1d450bb4cd978a0c3e", "patch": "@@ -6,9 +6,12 @@\n mod matching;\n mod parsing;\n mod replacing;\n+#[macro_use]\n+mod errors;\n #[cfg(test)]\n mod tests;\n \n+pub use crate::errors::SsrError;\n pub use crate::matching::Match;\n use crate::matching::{record_match_fails_reasons_scope, MatchFailureReason};\n use hir::Semantics;\n@@ -41,9 +44,6 @@ pub struct SsrPattern {\n     pattern: Option<SyntaxNode>,\n }\n \n-#[derive(Debug, PartialEq)]\n-pub struct SsrError(String);\n-\n #[derive(Debug, Default)]\n pub struct SsrMatches {\n     pub matches: Vec<Match>,\n@@ -201,9 +201,8 @@ impl<'db> MatchFinder<'db> {\n                         );\n                     }\n                 }\n-            } else {\n-                self.output_debug_for_nodes_at_range(&node, range, restrict_range, out);\n             }\n+            self.output_debug_for_nodes_at_range(&node, range, restrict_range, out);\n         }\n     }\n }\n@@ -216,33 +215,28 @@ pub struct MatchDebugInfo {\n     matched: Result<Match, MatchFailureReason>,\n }\n \n-impl std::fmt::Display for SsrError {\n-    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n-        write!(f, \"Parse error: {}\", self.0)\n-    }\n-}\n-\n impl std::fmt::Debug for MatchDebugInfo {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        write!(f, \"========= PATTERN ==========\\n\")?;\n+        match &self.matched {\n+            Ok(_) => writeln!(f, \"Node matched\")?,\n+            Err(reason) => writeln!(f, \"Node failed to match because: {}\", reason.reason)?,\n+        }\n+        writeln!(\n+            f,\n+            \"============ AST ===========\\n\\\n+            {:#?}\",\n+            self.node\n+        )?;\n+        writeln!(f, \"========= PATTERN ==========\")?;\n         match &self.pattern {\n             Ok(pattern) => {\n-                write!(f, \"{:#?}\", pattern)?;\n+                writeln!(f, \"{:#?}\", pattern)?;\n             }\n             Err(err) => {\n-                write!(f, \"{}\", err.reason)?;\n+                writeln!(f, \"{}\", err.reason)?;\n             }\n         }\n-        write!(\n-            f,\n-            \"\\n============ AST ===========\\n\\\n-            {:#?}\\n============================\\n\",\n-            self.node\n-        )?;\n-        match &self.matched {\n-            Ok(_) => write!(f, \"Node matched\")?,\n-            Err(reason) => write!(f, \"Node failed to match because: {}\", reason.reason)?,\n-        }\n+        writeln!(f, \"============================\")?;\n         Ok(())\n     }\n }"}, {"sha": "50b29eab2d630f5856b6adc2e1b4b7a2f81e9d2f", "filename": "crates/ra_ssr/src/matching.rs", "status": "modified", "additions": 75, "deletions": 80, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/212fa29a69af5f0f0de30a1d450bb4cd978a0c3e/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212fa29a69af5f0f0de30a1d450bb4cd978a0c3e/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fmatching.rs?ref=212fa29a69af5f0f0de30a1d450bb4cd978a0c3e", "patch": "@@ -92,58 +92,52 @@ pub(crate) fn get_match(\n     sema: &Semantics<ra_ide_db::RootDatabase>,\n ) -> Result<Match, MatchFailed> {\n     record_match_fails_reasons_scope(debug_active, || {\n-        MatchState::try_match(rule, code, restrict_range, sema)\n+        Matcher::try_match(rule, code, restrict_range, sema)\n     })\n }\n \n-/// Inputs to matching. This cannot be part of `MatchState`, since we mutate `MatchState` and in at\n-/// least one case need to hold a borrow of a placeholder from the input pattern while calling a\n-/// mutable `MatchState` method.\n-struct MatchInputs<'pattern> {\n-    ssr_pattern: &'pattern SsrPattern,\n-}\n-\n-/// State used while attempting to match our search pattern against a particular node of the AST.\n-struct MatchState<'db, 'sema> {\n+/// Checks if our search pattern matches a particular node of the AST.\n+struct Matcher<'db, 'sema> {\n     sema: &'sema Semantics<'db, ra_ide_db::RootDatabase>,\n     /// If any placeholders come from anywhere outside of this range, then the match will be\n     /// rejected.\n     restrict_range: Option<FileRange>,\n-    /// The match that we're building. We do two passes for a successful match. On the first pass,\n-    /// this is None so that we can avoid doing things like storing copies of what placeholders\n-    /// matched to. If that pass succeeds, then we do a second pass where we collect those details.\n-    /// This means that if we have a pattern like `$a.foo()` we won't do an insert into the\n-    /// placeholders map for every single method call in the codebase. Instead we'll discard all the\n-    /// method calls that aren't calls to `foo` on the first pass and only insert into the\n-    /// placeholders map on the second pass. Likewise for ignored comments.\n-    match_out: Option<Match>,\n+    rule: &'sema SsrRule,\n+}\n+\n+/// Which phase of matching we're currently performing. We do two phases because most attempted\n+/// matches will fail and it means we can defer more expensive checks to the second phase.\n+enum Phase<'a> {\n+    /// On the first phase, we perform cheap checks. No state is mutated and nothing is recorded.\n+    First,\n+    /// On the second phase, we construct the `Match`. Things like what placeholders bind to is\n+    /// recorded.\n+    Second(&'a mut Match),\n }\n \n-impl<'db, 'sema> MatchState<'db, 'sema> {\n+impl<'db, 'sema> Matcher<'db, 'sema> {\n     fn try_match(\n-        rule: &SsrRule,\n+        rule: &'sema SsrRule,\n         code: &SyntaxNode,\n         restrict_range: &Option<FileRange>,\n         sema: &'sema Semantics<'db, ra_ide_db::RootDatabase>,\n     ) -> Result<Match, MatchFailed> {\n-        let mut match_state =\n-            MatchState { sema, restrict_range: restrict_range.clone(), match_out: None };\n-        let match_inputs = MatchInputs { ssr_pattern: &rule.pattern };\n+        let match_state = Matcher { sema, restrict_range: restrict_range.clone(), rule };\n         let pattern_tree = rule.pattern.tree_for_kind(code.kind())?;\n         // First pass at matching, where we check that node types and idents match.\n-        match_state.attempt_match_node(&match_inputs, &pattern_tree, code)?;\n+        match_state.attempt_match_node(&mut Phase::First, &pattern_tree, code)?;\n         match_state.validate_range(&sema.original_range(code))?;\n-        match_state.match_out = Some(Match {\n+        let mut the_match = Match {\n             range: sema.original_range(code),\n             matched_node: code.clone(),\n             placeholder_values: FxHashMap::default(),\n             ignored_comments: Vec::new(),\n             template: rule.template.clone(),\n-        });\n+        };\n         // Second matching pass, where we record placeholder matches, ignored comments and maybe do\n         // any other more expensive checks that we didn't want to do on the first pass.\n-        match_state.attempt_match_node(&match_inputs, &pattern_tree, code)?;\n-        Ok(match_state.match_out.unwrap())\n+        match_state.attempt_match_node(&mut Phase::Second(&mut the_match), &pattern_tree, code)?;\n+        Ok(the_match)\n     }\n \n     /// Checks that `range` is within the permitted range if any. This is applicable when we're\n@@ -161,27 +155,22 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n     }\n \n     fn attempt_match_node(\n-        &mut self,\n-        match_inputs: &MatchInputs,\n+        &self,\n+        phase: &mut Phase,\n         pattern: &SyntaxNode,\n         code: &SyntaxNode,\n     ) -> Result<(), MatchFailed> {\n         // Handle placeholders.\n-        if let Some(placeholder) =\n-            match_inputs.get_placeholder(&SyntaxElement::Node(pattern.clone()))\n-        {\n+        if let Some(placeholder) = self.get_placeholder(&SyntaxElement::Node(pattern.clone())) {\n             for constraint in &placeholder.constraints {\n                 self.check_constraint(constraint, code)?;\n             }\n-            if self.match_out.is_none() {\n-                return Ok(());\n-            }\n-            let original_range = self.sema.original_range(code);\n-            // We validated the range for the node when we started the match, so the placeholder\n-            // probably can't fail range validation, but just to be safe...\n-            self.validate_range(&original_range)?;\n-            if let Some(match_out) = &mut self.match_out {\n-                match_out.placeholder_values.insert(\n+            if let Phase::Second(matches_out) = phase {\n+                let original_range = self.sema.original_range(code);\n+                // We validated the range for the node when we started the match, so the placeholder\n+                // probably can't fail range validation, but just to be safe...\n+                self.validate_range(&original_range)?;\n+                matches_out.placeholder_values.insert(\n                     Var(placeholder.ident.to_string()),\n                     PlaceholderMatch::new(code, original_range),\n                 );\n@@ -190,53 +179,59 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n         }\n         // Non-placeholders.\n         if pattern.kind() != code.kind() {\n-            fail_match!(\"Pattern had a {:?}, code had {:?}\", pattern.kind(), code.kind());\n+            fail_match!(\n+                \"Pattern had a `{}` ({:?}), code had `{}` ({:?})\",\n+                pattern.text(),\n+                pattern.kind(),\n+                code.text(),\n+                code.kind()\n+            );\n         }\n         // Some kinds of nodes have special handling. For everything else, we fall back to default\n         // matching.\n         match code.kind() {\n             SyntaxKind::RECORD_FIELD_LIST => {\n-                self.attempt_match_record_field_list(match_inputs, pattern, code)\n+                self.attempt_match_record_field_list(phase, pattern, code)\n             }\n-            SyntaxKind::TOKEN_TREE => self.attempt_match_token_tree(match_inputs, pattern, code),\n-            _ => self.attempt_match_node_children(match_inputs, pattern, code),\n+            SyntaxKind::TOKEN_TREE => self.attempt_match_token_tree(phase, pattern, code),\n+            _ => self.attempt_match_node_children(phase, pattern, code),\n         }\n     }\n \n     fn attempt_match_node_children(\n-        &mut self,\n-        match_inputs: &MatchInputs,\n+        &self,\n+        phase: &mut Phase,\n         pattern: &SyntaxNode,\n         code: &SyntaxNode,\n     ) -> Result<(), MatchFailed> {\n         self.attempt_match_sequences(\n-            match_inputs,\n+            phase,\n             PatternIterator::new(pattern),\n             code.children_with_tokens(),\n         )\n     }\n \n     fn attempt_match_sequences(\n-        &mut self,\n-        match_inputs: &MatchInputs,\n+        &self,\n+        phase: &mut Phase,\n         pattern_it: PatternIterator,\n         mut code_it: SyntaxElementChildren,\n     ) -> Result<(), MatchFailed> {\n         let mut pattern_it = pattern_it.peekable();\n         loop {\n-            match self.next_non_trivial(&mut code_it) {\n+            match phase.next_non_trivial(&mut code_it) {\n                 None => {\n                     if let Some(p) = pattern_it.next() {\n                         fail_match!(\"Part of the pattern was unmatched: {:?}\", p);\n                     }\n                     return Ok(());\n                 }\n                 Some(SyntaxElement::Token(c)) => {\n-                    self.attempt_match_token(&mut pattern_it, &c)?;\n+                    self.attempt_match_token(phase, &mut pattern_it, &c)?;\n                 }\n                 Some(SyntaxElement::Node(c)) => match pattern_it.next() {\n                     Some(SyntaxElement::Node(p)) => {\n-                        self.attempt_match_node(match_inputs, &p, &c)?;\n+                        self.attempt_match_node(phase, &p, &c)?;\n                     }\n                     Some(p) => fail_match!(\"Pattern wanted '{}', code has {}\", p, c.text()),\n                     None => fail_match!(\"Pattern reached end, code has {}\", c.text()),\n@@ -246,11 +241,12 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n     }\n \n     fn attempt_match_token(\n-        &mut self,\n+        &self,\n+        phase: &mut Phase,\n         pattern: &mut Peekable<PatternIterator>,\n         code: &ra_syntax::SyntaxToken,\n     ) -> Result<(), MatchFailed> {\n-        self.record_ignored_comments(code);\n+        phase.record_ignored_comments(code);\n         // Ignore whitespace and comments.\n         if code.kind().is_trivia() {\n             return Ok(());\n@@ -317,8 +313,8 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n     /// We want to allow the records to match in any order, so we have special matching logic for\n     /// them.\n     fn attempt_match_record_field_list(\n-        &mut self,\n-        match_inputs: &MatchInputs,\n+        &self,\n+        phase: &mut Phase,\n         pattern: &SyntaxNode,\n         code: &SyntaxNode,\n     ) -> Result<(), MatchFailed> {\n@@ -334,11 +330,11 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n         for p in pattern.children_with_tokens() {\n             if let SyntaxElement::Node(p) = p {\n                 if let Some(name_element) = p.first_child_or_token() {\n-                    if match_inputs.get_placeholder(&name_element).is_some() {\n+                    if self.get_placeholder(&name_element).is_some() {\n                         // If the pattern is using placeholders for field names then order\n                         // independence doesn't make sense. Fall back to regular ordered\n                         // matching.\n-                        return self.attempt_match_node_children(match_inputs, pattern, code);\n+                        return self.attempt_match_node_children(phase, pattern, code);\n                     }\n                     if let Some(ident) = only_ident(name_element) {\n                         let code_record = fields_by_name.remove(ident.text()).ok_or_else(|| {\n@@ -347,7 +343,7 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n                                 ident\n                             )\n                         })?;\n-                        self.attempt_match_node(match_inputs, &p, &code_record)?;\n+                        self.attempt_match_node(phase, &p, &code_record)?;\n                     }\n                 }\n             }\n@@ -367,16 +363,15 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n     /// pattern matches the macro invocation. For matches within the macro call, we'll already have\n     /// expanded the macro.\n     fn attempt_match_token_tree(\n-        &mut self,\n-        match_inputs: &MatchInputs,\n+        &self,\n+        phase: &mut Phase,\n         pattern: &SyntaxNode,\n         code: &ra_syntax::SyntaxNode,\n     ) -> Result<(), MatchFailed> {\n         let mut pattern = PatternIterator::new(pattern).peekable();\n         let mut children = code.children_with_tokens();\n         while let Some(child) = children.next() {\n-            if let Some(placeholder) = pattern.peek().and_then(|p| match_inputs.get_placeholder(p))\n-            {\n+            if let Some(placeholder) = pattern.peek().and_then(|p| self.get_placeholder(p)) {\n                 pattern.next();\n                 let next_pattern_token = pattern\n                     .peek()\n@@ -402,7 +397,7 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n                                 if Some(first_token.to_string()) == next_pattern_token {\n                                     if let Some(SyntaxElement::Node(p)) = pattern.next() {\n                                         // We have a subtree that starts with the next token in our pattern.\n-                                        self.attempt_match_token_tree(match_inputs, &p, &n)?;\n+                                        self.attempt_match_token_tree(phase, &p, &n)?;\n                                         break;\n                                     }\n                                 }\n@@ -411,7 +406,7 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n                     };\n                     last_matched_token = next;\n                 }\n-                if let Some(match_out) = &mut self.match_out {\n+                if let Phase::Second(match_out) = phase {\n                     match_out.placeholder_values.insert(\n                         Var(placeholder.ident.to_string()),\n                         PlaceholderMatch::from_range(FileRange {\n@@ -427,11 +422,11 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n             // Match literal (non-placeholder) tokens.\n             match child {\n                 SyntaxElement::Token(token) => {\n-                    self.attempt_match_token(&mut pattern, &token)?;\n+                    self.attempt_match_token(phase, &mut pattern, &token)?;\n                 }\n                 SyntaxElement::Node(node) => match pattern.next() {\n                     Some(SyntaxElement::Node(p)) => {\n-                        self.attempt_match_token_tree(match_inputs, &p, &node)?;\n+                        self.attempt_match_token_tree(phase, &p, &node)?;\n                     }\n                     Some(SyntaxElement::Token(p)) => fail_match!(\n                         \"Pattern has token '{}', code has subtree '{}'\",\n@@ -448,6 +443,13 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n         Ok(())\n     }\n \n+    fn get_placeholder(&self, element: &SyntaxElement) -> Option<&Placeholder> {\n+        only_ident(element.clone())\n+            .and_then(|ident| self.rule.pattern.placeholders_by_stand_in.get(ident.text()))\n+    }\n+}\n+\n+impl Phase<'_> {\n     fn next_non_trivial(&mut self, code_it: &mut SyntaxElementChildren) -> Option<SyntaxElement> {\n         loop {\n             let c = code_it.next();\n@@ -463,7 +465,7 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n \n     fn record_ignored_comments(&mut self, token: &SyntaxToken) {\n         if token.kind() == SyntaxKind::COMMENT {\n-            if let Some(match_out) = &mut self.match_out {\n+            if let Phase::Second(match_out) = self {\n                 if let Some(comment) = ast::Comment::cast(token.clone()) {\n                     match_out.ignored_comments.push(comment);\n                 }\n@@ -472,13 +474,6 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n     }\n }\n \n-impl MatchInputs<'_> {\n-    fn get_placeholder(&self, element: &SyntaxElement) -> Option<&Placeholder> {\n-        only_ident(element.clone())\n-            .and_then(|ident| self.ssr_pattern.placeholders_by_stand_in.get(ident.text()))\n-    }\n-}\n-\n fn is_closing_token(kind: SyntaxKind) -> bool {\n     kind == SyntaxKind::R_PAREN || kind == SyntaxKind::R_CURLY || kind == SyntaxKind::R_BRACK\n }\n@@ -596,12 +591,12 @@ impl PatternIterator {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::MatchFinder;\n+    use crate::{MatchFinder, SsrRule};\n \n     #[test]\n     fn parse_match_replace() {\n         let rule: SsrRule = \"foo($x) ==>> bar($x)\".parse().unwrap();\n-        let input = \"fn main() { foo(1+2); }\";\n+        let input = \"fn foo() {} fn main() { foo(1+2); }\";\n \n         use ra_db::fixture::WithFixture;\n         let (db, file_id) = ra_ide_db::RootDatabase::with_single_file(input);\n@@ -623,6 +618,6 @@ mod tests {\n         let edit = crate::replacing::matches_to_edit(&matches, input);\n         let mut after = input.to_string();\n         edit.apply(&mut after);\n-        assert_eq!(after, \"fn main() { bar(1+2); }\");\n+        assert_eq!(after, \"fn foo() {} fn main() { bar(1+2); }\");\n     }\n }"}, {"sha": "4aee97bb2b8b0a1f728158014585297123ca9557", "filename": "crates/ra_ssr/src/parsing.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/212fa29a69af5f0f0de30a1d450bb4cd978a0c3e/crates%2Fra_ssr%2Fsrc%2Fparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212fa29a69af5f0f0de30a1d450bb4cd978a0c3e/crates%2Fra_ssr%2Fsrc%2Fparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fparsing.rs?ref=212fa29a69af5f0f0de30a1d450bb4cd978a0c3e", "patch": "@@ -5,17 +5,12 @@\n //! search patterns, we go further and parse the pattern as each kind of thing that we can match.\n //! e.g. expressions, type references etc.\n \n+use crate::errors::bail;\n use crate::{SsrError, SsrPattern, SsrRule};\n use ra_syntax::{ast, AstNode, SmolStr, SyntaxKind, T};\n use rustc_hash::{FxHashMap, FxHashSet};\n use std::str::FromStr;\n \n-/// Returns from the current function with an error, supplied by arguments as for format!\n-macro_rules! bail {\n-    ($e:expr) => {return Err($crate::SsrError::new($e))};\n-    ($fmt:expr, $($arg:tt)+) => {return Err($crate::SsrError::new(format!($fmt, $($arg)+)))}\n-}\n-\n #[derive(Clone, Debug)]\n pub(crate) struct SsrTemplate {\n     pub(crate) tokens: Vec<PatternElement>,\n@@ -246,7 +241,7 @@ fn parse_placeholder(tokens: &mut std::vec::IntoIter<Token>) -> Result<Placehold\n                 }\n             }\n             _ => {\n-                bail!(\"Placeholders should either be $name or ${name:constraints}\");\n+                bail!(\"Placeholders should either be $name or ${{name:constraints}}\");\n             }\n         }\n     }\n@@ -289,7 +284,7 @@ fn expect_token(tokens: &mut std::vec::IntoIter<Token>, expected: &str) -> Resul\n         }\n         bail!(\"Expected {} found {}\", expected, t.text);\n     }\n-    bail!(\"Expected {} found end of stream\");\n+    bail!(\"Expected {} found end of stream\", expected);\n }\n \n impl NodeKind {\n@@ -307,12 +302,6 @@ impl Placeholder {\n     }\n }\n \n-impl SsrError {\n-    fn new(message: impl Into<String>) -> SsrError {\n-        SsrError(message.into())\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "f20ae2cdf9a0c2eca5930bc9af19e02111e904a7", "filename": "crates/ra_ssr/src/tests.rs", "status": "modified", "additions": 118, "deletions": 73, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/212fa29a69af5f0f0de30a1d450bb4cd978a0c3e/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212fa29a69af5f0f0de30a1d450bb4cd978a0c3e/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ftests.rs?ref=212fa29a69af5f0f0de30a1d450bb4cd978a0c3e", "patch": "@@ -91,6 +91,18 @@ fn assert_ssr_transforms(rules: &[&str], input: &str, result: &str) {\n     }\n }\n \n+fn print_match_debug_info(match_finder: &MatchFinder, file_id: FileId, snippet: &str) {\n+    let debug_info = match_finder.debug_where_text_equal(file_id, snippet);\n+    println!(\n+        \"Match debug info: {} nodes had text exactly equal to '{}'\",\n+        debug_info.len(),\n+        snippet\n+    );\n+    for (index, d) in debug_info.iter().enumerate() {\n+        println!(\"Node #{}\\n{:#?}\\n\", index, d);\n+    }\n+}\n+\n fn assert_matches(pattern: &str, code: &str, expected: &[&str]) {\n     let (db, file_id) = single_file(code);\n     let mut match_finder = MatchFinder::new(&db);\n@@ -103,17 +115,20 @@ fn assert_matches(pattern: &str, code: &str, expected: &[&str]) {\n         .map(|m| m.matched_text())\n         .collect();\n     if matched_strings != expected && !expected.is_empty() {\n-        let debug_info = match_finder.debug_where_text_equal(file_id, &expected[0]);\n-        eprintln!(\"Test is about to fail. Some possibly useful info: {} nodes had text exactly equal to '{}'\", debug_info.len(), &expected[0]);\n-        for d in debug_info {\n-            eprintln!(\"{:#?}\", d);\n-        }\n+        print_match_debug_info(&match_finder, file_id, &expected[0]);\n     }\n     assert_eq!(matched_strings, expected);\n }\n \n fn assert_no_match(pattern: &str, code: &str) {\n-    assert_matches(pattern, code, &[]);\n+    let (db, file_id) = single_file(code);\n+    let mut match_finder = MatchFinder::new(&db);\n+    match_finder.add_search_pattern(pattern.parse().unwrap());\n+    let matches = match_finder.find_matches_in_file(file_id).flattened().matches;\n+    if !matches.is_empty() {\n+        print_match_debug_info(&match_finder, file_id, &matches[0].matched_text());\n+        panic!(\"Got {} matches when we expected none: {:#?}\", matches.len(), matches);\n+    }\n }\n \n fn assert_match_failure_reason(pattern: &str, code: &str, snippet: &str, expected_reason: &str) {\n@@ -133,62 +148,62 @@ fn assert_match_failure_reason(pattern: &str, code: &str, snippet: &str, expecte\n fn ssr_function_to_method() {\n     assert_ssr_transform(\n         \"my_function($a, $b) ==>> ($a).my_method($b)\",\n-        \"loop { my_function( other_func(x, y), z + w) }\",\n-        \"loop { (other_func(x, y)).my_method(z + w) }\",\n+        \"fn my_function() {} fn main() { loop { my_function( other_func(x, y), z + w) } }\",\n+        \"fn my_function() {} fn main() { loop { (other_func(x, y)).my_method(z + w) } }\",\n     )\n }\n \n #[test]\n fn ssr_nested_function() {\n     assert_ssr_transform(\n         \"foo($a, $b, $c) ==>> bar($c, baz($a, $b))\",\n-        \"fn main { foo  (x + value.method(b), x+y-z, true && false) }\",\n-        \"fn main { bar(true && false, baz(x + value.method(b), x+y-z)) }\",\n+        \"fn foo() {} fn main { foo  (x + value.method(b), x+y-z, true && false) }\",\n+        \"fn foo() {} fn main { bar(true && false, baz(x + value.method(b), x+y-z)) }\",\n     )\n }\n \n #[test]\n fn ssr_expected_spacing() {\n     assert_ssr_transform(\n         \"foo($x) + bar() ==>> bar($x)\",\n-        \"fn main() { foo(5) + bar() }\",\n-        \"fn main() { bar(5) }\",\n+        \"fn foo() {} fn bar() {} fn main() { foo(5) + bar() }\",\n+        \"fn foo() {} fn bar() {} fn main() { bar(5) }\",\n     );\n }\n \n #[test]\n fn ssr_with_extra_space() {\n     assert_ssr_transform(\n         \"foo($x  ) +    bar() ==>> bar($x)\",\n-        \"fn main() { foo(  5 )  +bar(   ) }\",\n-        \"fn main() { bar(5) }\",\n+        \"fn foo() {} fn bar() {} fn main() { foo(  5 )  +bar(   ) }\",\n+        \"fn foo() {} fn bar() {} fn main() { bar(5) }\",\n     );\n }\n \n #[test]\n fn ssr_keeps_nested_comment() {\n     assert_ssr_transform(\n         \"foo($x) ==>> bar($x)\",\n-        \"fn main() { foo(other(5 /* using 5 */)) }\",\n-        \"fn main() { bar(other(5 /* using 5 */)) }\",\n+        \"fn foo() {} fn main() { foo(other(5 /* using 5 */)) }\",\n+        \"fn foo() {} fn main() { bar(other(5 /* using 5 */)) }\",\n     )\n }\n \n #[test]\n fn ssr_keeps_comment() {\n     assert_ssr_transform(\n         \"foo($x) ==>> bar($x)\",\n-        \"fn main() { foo(5 /* using 5 */) }\",\n-        \"fn main() { bar(5)/* using 5 */ }\",\n+        \"fn foo() {} fn main() { foo(5 /* using 5 */) }\",\n+        \"fn foo() {} fn main() { bar(5)/* using 5 */ }\",\n     )\n }\n \n #[test]\n fn ssr_struct_lit() {\n     assert_ssr_transform(\n         \"foo{a: $a, b: $b} ==>> foo::new($a, $b)\",\n-        \"fn main() { foo{b:2, a:1} }\",\n-        \"fn main() { foo::new(1, 2) }\",\n+        \"fn foo() {} fn main() { foo{b:2, a:1} }\",\n+        \"fn foo() {} fn main() { foo::new(1, 2) }\",\n     )\n }\n \n@@ -210,16 +225,18 @@ fn match_fn_definition() {\n \n #[test]\n fn match_struct_definition() {\n-    assert_matches(\n-        \"struct $n {$f: Option<String>}\",\n-        \"struct Bar {} struct Foo {name: Option<String>}\",\n-        &[\"struct Foo {name: Option<String>}\"],\n-    );\n+    let code = r#\"\n+        struct Option<T> {}\n+        struct Bar {}\n+        struct Foo {name: Option<String>}\"#;\n+    assert_matches(\"struct $n {$f: Option<String>}\", code, &[\"struct Foo {name: Option<String>}\"]);\n }\n \n #[test]\n fn match_expr() {\n-    let code = \"fn f() -> i32 {foo(40 + 2, 42)}\";\n+    let code = r#\"\n+        fn foo() {}\n+        fn f() -> i32 {foo(40 + 2, 42)}\"#;\n     assert_matches(\"foo($a, $b)\", code, &[\"foo(40 + 2, 42)\"]);\n     assert_no_match(\"foo($a, $b, $c)\", code);\n     assert_no_match(\"foo($a)\", code);\n@@ -248,7 +265,9 @@ fn match_nested_method_calls_with_macro_call() {\n \n #[test]\n fn match_complex_expr() {\n-    let code = \"fn f() -> i32 {foo(bar(40, 2), 42)}\";\n+    let code = r#\"\n+        fn foo() {} fn bar() {}\n+        fn f() -> i32 {foo(bar(40, 2), 42)}\"#;\n     assert_matches(\"foo($a, $b)\", code, &[\"foo(bar(40, 2), 42)\"]);\n     assert_no_match(\"foo($a, $b, $c)\", code);\n     assert_no_match(\"foo($a)\", code);\n@@ -259,53 +278,62 @@ fn match_complex_expr() {\n #[test]\n fn match_with_trailing_commas() {\n     // Code has comma, pattern doesn't.\n-    assert_matches(\"foo($a, $b)\", \"fn f() {foo(1, 2,);}\", &[\"foo(1, 2,)\"]);\n-    assert_matches(\"Foo{$a, $b}\", \"fn f() {Foo{1, 2,};}\", &[\"Foo{1, 2,}\"]);\n+    assert_matches(\"foo($a, $b)\", \"fn foo() {} fn f() {foo(1, 2,);}\", &[\"foo(1, 2,)\"]);\n+    assert_matches(\"Foo{$a, $b}\", \"struct Foo {} fn f() {Foo{1, 2,};}\", &[\"Foo{1, 2,}\"]);\n \n     // Pattern has comma, code doesn't.\n-    assert_matches(\"foo($a, $b,)\", \"fn f() {foo(1, 2);}\", &[\"foo(1, 2)\"]);\n-    assert_matches(\"Foo{$a, $b,}\", \"fn f() {Foo{1, 2};}\", &[\"Foo{1, 2}\"]);\n+    assert_matches(\"foo($a, $b,)\", \"fn foo() {} fn f() {foo(1, 2);}\", &[\"foo(1, 2)\"]);\n+    assert_matches(\"Foo{$a, $b,}\", \"struct Foo {} fn f() {Foo{1, 2};}\", &[\"Foo{1, 2}\"]);\n }\n \n #[test]\n fn match_type() {\n     assert_matches(\"i32\", \"fn f() -> i32 {1  +  2}\", &[\"i32\"]);\n-    assert_matches(\"Option<$a>\", \"fn f() -> Option<i32> {42}\", &[\"Option<i32>\"]);\n-    assert_no_match(\"Option<$a>\", \"fn f() -> Result<i32, ()> {42}\");\n+    assert_matches(\n+        \"Option<$a>\",\n+        \"struct Option<T> {} fn f() -> Option<i32> {42}\",\n+        &[\"Option<i32>\"],\n+    );\n+    assert_no_match(\n+        \"Option<$a>\",\n+        \"struct Option<T> {} struct Result<T, E> {} fn f() -> Result<i32, ()> {42}\",\n+    );\n }\n \n #[test]\n fn match_struct_instantiation() {\n-    assert_matches(\n-        \"Foo {bar: 1, baz: 2}\",\n-        \"fn f() {Foo {bar: 1, baz: 2}}\",\n-        &[\"Foo {bar: 1, baz: 2}\"],\n-    );\n+    let code = r#\"\n+        struct Foo {bar: i32, baz: i32}\n+        fn f() {Foo {bar: 1, baz: 2}}\"#;\n+    assert_matches(\"Foo {bar: 1, baz: 2}\", code, &[\"Foo {bar: 1, baz: 2}\"]);\n     // Now with placeholders for all parts of the struct.\n-    assert_matches(\n-        \"Foo {$a: $b, $c: $d}\",\n-        \"fn f() {Foo {bar: 1, baz: 2}}\",\n-        &[\"Foo {bar: 1, baz: 2}\"],\n-    );\n-    assert_matches(\"Foo {}\", \"fn f() {Foo {}}\", &[\"Foo {}\"]);\n+    assert_matches(\"Foo {$a: $b, $c: $d}\", code, &[\"Foo {bar: 1, baz: 2}\"]);\n+    assert_matches(\"Foo {}\", \"struct Foo {} fn f() {Foo {}}\", &[\"Foo {}\"]);\n }\n \n #[test]\n fn match_path() {\n-    assert_matches(\"foo::bar\", \"fn f() {foo::bar(42)}\", &[\"foo::bar\"]);\n-    assert_matches(\"$a::bar\", \"fn f() {foo::bar(42)}\", &[\"foo::bar\"]);\n-    assert_matches(\"foo::$b\", \"fn f() {foo::bar(42)}\", &[\"foo::bar\"]);\n+    let code = r#\"\n+        mod foo {\n+            fn bar() {}\n+        }\n+        fn f() {foo::bar(42)}\"#;\n+    assert_matches(\"foo::bar\", code, &[\"foo::bar\"]);\n+    assert_matches(\"$a::bar\", code, &[\"foo::bar\"]);\n+    assert_matches(\"foo::$b\", code, &[\"foo::bar\"]);\n }\n \n #[test]\n fn match_pattern() {\n-    assert_matches(\"Some($a)\", \"fn f() {if let Some(x) = foo() {}}\", &[\"Some(x)\"]);\n+    assert_matches(\"Some($a)\", \"struct Some(); fn f() {if let Some(x) = foo() {}}\", &[\"Some(x)\"]);\n }\n \n #[test]\n fn literal_constraint() {\n     mark::check!(literal_constraint);\n     let code = r#\"\n+        enum Option<T> { Some(T), None }\n+        use Option::Some;\n         fn f1() {\n             let x1 = Some(42);\n             let x2 = Some(\"foo\");\n@@ -322,24 +350,36 @@ fn literal_constraint() {\n fn match_reordered_struct_instantiation() {\n     assert_matches(\n         \"Foo {aa: 1, b: 2, ccc: 3}\",\n-        \"fn f() {Foo {b: 2, ccc: 3, aa: 1}}\",\n+        \"struct Foo {} fn f() {Foo {b: 2, ccc: 3, aa: 1}}\",\n         &[\"Foo {b: 2, ccc: 3, aa: 1}\"],\n     );\n-    assert_no_match(\"Foo {a: 1}\", \"fn f() {Foo {b: 1}}\");\n-    assert_no_match(\"Foo {a: 1}\", \"fn f() {Foo {a: 2}}\");\n-    assert_no_match(\"Foo {a: 1, b: 2}\", \"fn f() {Foo {a: 1}}\");\n-    assert_no_match(\"Foo {a: 1, b: 2}\", \"fn f() {Foo {b: 2}}\");\n-    assert_no_match(\"Foo {a: 1, }\", \"fn f() {Foo {a: 1, b: 2}}\");\n-    assert_no_match(\"Foo {a: 1, z: 9}\", \"fn f() {Foo {a: 1}}\");\n+    assert_no_match(\"Foo {a: 1}\", \"struct Foo {} fn f() {Foo {b: 1}}\");\n+    assert_no_match(\"Foo {a: 1}\", \"struct Foo {} fn f() {Foo {a: 2}}\");\n+    assert_no_match(\"Foo {a: 1, b: 2}\", \"struct Foo {} fn f() {Foo {a: 1}}\");\n+    assert_no_match(\"Foo {a: 1, b: 2}\", \"struct Foo {} fn f() {Foo {b: 2}}\");\n+    assert_no_match(\"Foo {a: 1, }\", \"struct Foo {} fn f() {Foo {a: 1, b: 2}}\");\n+    assert_no_match(\"Foo {a: 1, z: 9}\", \"struct Foo {} fn f() {Foo {a: 1}}\");\n }\n \n #[test]\n fn match_macro_invocation() {\n-    assert_matches(\"foo!($a)\", \"fn() {foo(foo!(foo()))}\", &[\"foo!(foo())\"]);\n-    assert_matches(\"foo!(41, $a, 43)\", \"fn() {foo!(41, 42, 43)}\", &[\"foo!(41, 42, 43)\"]);\n-    assert_no_match(\"foo!(50, $a, 43)\", \"fn() {foo!(41, 42, 43}\");\n-    assert_no_match(\"foo!(41, $a, 50)\", \"fn() {foo!(41, 42, 43}\");\n-    assert_matches(\"foo!($a())\", \"fn() {foo!(bar())}\", &[\"foo!(bar())\"]);\n+    assert_matches(\n+        \"foo!($a)\",\n+        \"macro_rules! foo {() => {}} fn() {foo(foo!(foo()))}\",\n+        &[\"foo!(foo())\"],\n+    );\n+    assert_matches(\n+        \"foo!(41, $a, 43)\",\n+        \"macro_rules! foo {() => {}} fn() {foo!(41, 42, 43)}\",\n+        &[\"foo!(41, 42, 43)\"],\n+    );\n+    assert_no_match(\"foo!(50, $a, 43)\", \"macro_rules! foo {() => {}} fn() {foo!(41, 42, 43}\");\n+    assert_no_match(\"foo!(41, $a, 50)\", \"macro_rules! foo {() => {}} fn() {foo!(41, 42, 43}\");\n+    assert_matches(\n+        \"foo!($a())\",\n+        \"macro_rules! foo {() => {}} fn() {foo!(bar())}\",\n+        &[\"foo!(bar())\"],\n+    );\n }\n \n // When matching within a macro expansion, we only allow matches of nodes that originated from\n@@ -374,56 +414,60 @@ fn no_match_split_expression() {\n \n #[test]\n fn replace_function_call() {\n-    assert_ssr_transform(\"foo() ==>> bar()\", \"fn f1() {foo(); foo();}\", \"fn f1() {bar(); bar();}\");\n+    assert_ssr_transform(\n+        \"foo() ==>> bar()\",\n+        \"fn foo() {} fn f1() {foo(); foo();}\",\n+        \"fn foo() {} fn f1() {bar(); bar();}\",\n+    );\n }\n \n #[test]\n fn replace_function_call_with_placeholders() {\n     assert_ssr_transform(\n         \"foo($a, $b) ==>> bar($b, $a)\",\n-        \"fn f1() {foo(5, 42)}\",\n-        \"fn f1() {bar(42, 5)}\",\n+        \"fn foo() {} fn f1() {foo(5, 42)}\",\n+        \"fn foo() {} fn f1() {bar(42, 5)}\",\n     );\n }\n \n #[test]\n fn replace_nested_function_calls() {\n     assert_ssr_transform(\n         \"foo($a) ==>> bar($a)\",\n-        \"fn f1() {foo(foo(42))}\",\n-        \"fn f1() {bar(bar(42))}\",\n+        \"fn foo() {} fn f1() {foo(foo(42))}\",\n+        \"fn foo() {} fn f1() {bar(bar(42))}\",\n     );\n }\n \n #[test]\n fn replace_type() {\n     assert_ssr_transform(\n         \"Result<(), $a> ==>> Option<$a>\",\n-        \"fn f1() -> Result<(), Vec<Error>> {foo()}\",\n-        \"fn f1() -> Option<Vec<Error>> {foo()}\",\n+        \"struct Result<T, E> {} fn f1() -> Result<(), Vec<Error>> {foo()}\",\n+        \"struct Result<T, E> {} fn f1() -> Option<Vec<Error>> {foo()}\",\n     );\n }\n \n #[test]\n fn replace_struct_init() {\n     assert_ssr_transform(\n         \"Foo {a: $a, b: $b} ==>> Foo::new($a, $b)\",\n-        \"fn f1() {Foo{b: 1, a: 2}}\",\n-        \"fn f1() {Foo::new(2, 1)}\",\n+        \"struct Foo {} fn f1() {Foo{b: 1, a: 2}}\",\n+        \"struct Foo {} fn f1() {Foo::new(2, 1)}\",\n     );\n }\n \n #[test]\n fn replace_macro_invocations() {\n     assert_ssr_transform(\n         \"try!($a) ==>> $a?\",\n-        \"fn f1() -> Result<(), E> {bar(try!(foo()));}\",\n-        \"fn f1() -> Result<(), E> {bar(foo()?);}\",\n+        \"macro_rules! try {() => {}} fn f1() -> Result<(), E> {bar(try!(foo()));}\",\n+        \"macro_rules! try {() => {}} fn f1() -> Result<(), E> {bar(foo()?);}\",\n     );\n     assert_ssr_transform(\n         \"foo!($a($b)) ==>> foo($b, $a)\",\n-        \"fn f1() {foo!(abc(def() + 2));}\",\n-        \"fn f1() {foo(def() + 2, abc);}\",\n+        \"macro_rules! foo {() => {}} fn f1() {foo!(abc(def() + 2));}\",\n+        \"macro_rules! foo {() => {}} fn f1() {foo(def() + 2, abc);}\",\n     );\n }\n \n@@ -512,6 +556,7 @@ fn preserves_whitespace_within_macro_expansion() {\n #[test]\n fn match_failure_reasons() {\n     let code = r#\"\n+        fn bar() {}\n         macro_rules! foo {\n             ($a:expr) => {\n                 1 + $a + 2"}]}