{"sha": "8994c6d417e25eba3cd077c0dce5760cfd05d576", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5OTRjNmQ0MTdlMjVlYmEzY2QwNzdjMGRjZTU3NjBjZmQwNWQ1NzY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-09-18T22:46:18Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-10-05T07:40:40Z"}, "message": "expansion: Remove restriction on use of macro attributes with test/bench\n\nThe restrictions were introduced in https://github.com/rust-lang/rust/pull/54277 and no longer necessary now because legacy plugins are now expanded in usual left-to-right order", "tree": {"sha": "853afa3e3ea0e7eda630137e8c39183c29259e98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/853afa3e3ea0e7eda630137e8c39183c29259e98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8994c6d417e25eba3cd077c0dce5760cfd05d576", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8994c6d417e25eba3cd077c0dce5760cfd05d576", "html_url": "https://github.com/rust-lang/rust/commit/8994c6d417e25eba3cd077c0dce5760cfd05d576", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8994c6d417e25eba3cd077c0dce5760cfd05d576/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60a1d4e6c2b23eeed79ea7ca2cbc43713d10197e", "url": "https://api.github.com/repos/rust-lang/rust/commits/60a1d4e6c2b23eeed79ea7ca2cbc43713d10197e", "html_url": "https://github.com/rust-lang/rust/commit/60a1d4e6c2b23eeed79ea7ca2cbc43713d10197e"}], "stats": {"total": 158, "additions": 44, "deletions": 114}, "files": [{"sha": "b9f51786e86e43be476aa598f22e24fc3172458c", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8994c6d417e25eba3cd077c0dce5760cfd05d576/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8994c6d417e25eba3cd077c0dce5760cfd05d576/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=8994c6d417e25eba3cd077c0dce5760cfd05d576", "patch": "@@ -24,7 +24,7 @@ use syntax::attr;\n use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Determinacy};\n use syntax::ext::base::{MacroKind, SyntaxExtension, Resolver as SyntaxResolver};\n-use syntax::ext::expand::{AstFragment, Invocation, InvocationKind, TogetherWith};\n+use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n use syntax::ext::hygiene::{self, Mark};\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{self, feature_err, emit_feature_err, is_builtin_attr_name, GateIssue};\n@@ -313,29 +313,24 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n \n     fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: Mark, force: bool)\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n-        let (path, kind, derives_in_scope, together_with) = match invoc.kind {\n+        let (path, kind, derives_in_scope, after_derive) = match invoc.kind {\n             InvocationKind::Attr { attr: None, .. } =>\n                 return Ok(None),\n-            InvocationKind::Attr { attr: Some(ref attr), ref traits, together_with, .. } =>\n-                (&attr.path, MacroKind::Attr, traits.clone(), together_with),\n+            InvocationKind::Attr { attr: Some(ref attr), ref traits, after_derive, .. } =>\n+                (&attr.path, MacroKind::Attr, traits.clone(), after_derive),\n             InvocationKind::Bang { ref mac, .. } =>\n-                (&mac.node.path, MacroKind::Bang, Vec::new(), TogetherWith::None),\n+                (&mac.node.path, MacroKind::Bang, Vec::new(), false),\n             InvocationKind::Derive { ref path, .. } =>\n-                (path, MacroKind::Derive, Vec::new(), TogetherWith::None),\n+                (path, MacroKind::Derive, Vec::new(), false),\n         };\n \n         let parent_scope = self.invoc_parent_scope(invoc_id, derives_in_scope);\n         let (def, ext) = self.resolve_macro_to_def(path, kind, &parent_scope, force)?;\n \n         if let Def::Macro(def_id, _) = def {\n-            match together_with {\n-                TogetherWith::Derive =>\n-                    self.session.span_err(invoc.span(),\n-                        \"macro attributes must be placed before `#[derive]`\"),\n-                TogetherWith::TestBench if !self.session.features_untracked().plugin =>\n-                    self.session.span_err(invoc.span(),\n-                        \"macro attributes cannot be used together with `#[test]` or `#[bench]`\"),\n-                _ => {}\n+            if after_derive {\n+                self.session.span_err(invoc.span(),\n+                                      \"macro attributes must be placed before `#[derive]`\");\n             }\n             self.macro_defs.insert(invoc.expansion_data.mark, def_id);\n             let normal_module_def_id ="}, {"sha": "e6e34dc8569ee8c30edbcc475d54ede6833672fb", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 30, "deletions": 43, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/8994c6d417e25eba3cd077c0dce5760cfd05d576/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8994c6d417e25eba3cd077c0dce5760cfd05d576/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=8994c6d417e25eba3cd077c0dce5760cfd05d576", "patch": "@@ -220,14 +220,6 @@ pub struct Invocation {\n     pub expansion_data: ExpansionData,\n }\n \n-// Needed for feature-gating attributes used after derives or together with test/bench\n-#[derive(Clone, Copy, PartialEq)]\n-pub enum TogetherWith {\n-    None,\n-    Derive,\n-    TestBench,\n-}\n-\n pub enum InvocationKind {\n     Bang {\n         mac: ast::Mac,\n@@ -238,7 +230,8 @@ pub enum InvocationKind {\n         attr: Option<ast::Attribute>,\n         traits: Vec<Path>,\n         item: Annotatable,\n-        together_with: TogetherWith,\n+        // We temporarily report errors for attribute macros placed after derives\n+        after_derive: bool,\n     },\n     Derive {\n         path: Path,\n@@ -1084,19 +1077,17 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                     traits: Vec<Path>,\n                     item: Annotatable,\n                     kind: AstFragmentKind,\n-                    together_with: TogetherWith)\n+                    after_derive: bool)\n                     -> AstFragment {\n-        self.collect(kind, InvocationKind::Attr { attr, traits, item, together_with })\n+        self.collect(kind, InvocationKind::Attr { attr, traits, item, after_derive })\n     }\n \n-    fn find_attr_invoc(&self, attrs: &mut Vec<ast::Attribute>, together_with: &mut TogetherWith)\n+    fn find_attr_invoc(&self, attrs: &mut Vec<ast::Attribute>, after_derive: &mut bool)\n                        -> Option<ast::Attribute> {\n         let attr = attrs.iter()\n                         .position(|a| {\n                             if a.path == \"derive\" {\n-                                *together_with = TogetherWith::Derive\n-                            } else if a.path == \"rustc_test_marker2\" {\n-                                *together_with = TogetherWith::TestBench\n+                                *after_derive = true;\n                             }\n                             !attr::is_known(a) && !is_builtin_attr(a)\n                         })\n@@ -1109,19 +1100,15 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                                  \"non-builtin inner attributes are unstable\");\n             }\n         }\n-        if together_with == &TogetherWith::None &&\n-           attrs.iter().any(|a| a.path == \"rustc_test_marker2\") {\n-            *together_with = TogetherWith::TestBench;\n-        }\n         attr\n     }\n \n     /// If `item` is an attr invocation, remove and return the macro attribute and derive traits.\n     fn classify_item<T>(&mut self, mut item: T)\n-                        -> (Option<ast::Attribute>, Vec<Path>, T, TogetherWith)\n+                        -> (Option<ast::Attribute>, Vec<Path>, T, /* after_derive */ bool)\n         where T: HasAttrs,\n     {\n-        let (mut attr, mut traits, mut together_with) = (None, Vec::new(), TogetherWith::None);\n+        let (mut attr, mut traits, mut after_derive) = (None, Vec::new(), false);\n \n         item = item.map_attrs(|mut attrs| {\n             if let Some(legacy_attr_invoc) = self.cx.resolver.find_legacy_attr_invoc(&mut attrs,\n@@ -1130,20 +1117,20 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                 return attrs;\n             }\n \n-            attr = self.find_attr_invoc(&mut attrs, &mut together_with);\n+            attr = self.find_attr_invoc(&mut attrs, &mut after_derive);\n             traits = collect_derives(&mut self.cx, &mut attrs);\n             attrs\n         });\n \n-        (attr, traits, item, together_with)\n+        (attr, traits, item, after_derive)\n     }\n \n     /// Alternative of `classify_item()` that ignores `#[derive]` so invocations fallthrough\n     /// to the unused-attributes lint (making it an error on statements and expressions\n     /// is a breaking change)\n     fn classify_nonitem<T: HasAttrs>(&mut self, mut item: T)\n-                                     -> (Option<ast::Attribute>, T, TogetherWith) {\n-        let (mut attr, mut together_with) = (None, TogetherWith::None);\n+                                     -> (Option<ast::Attribute>, T, /* after_derive */ bool) {\n+        let (mut attr, mut after_derive) = (None, false);\n \n         item = item.map_attrs(|mut attrs| {\n             if let Some(legacy_attr_invoc) = self.cx.resolver.find_legacy_attr_invoc(&mut attrs,\n@@ -1152,11 +1139,11 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                 return attrs;\n             }\n \n-            attr = self.find_attr_invoc(&mut attrs, &mut together_with);\n+            attr = self.find_attr_invoc(&mut attrs, &mut after_derive);\n             attrs\n         });\n \n-        (attr, item, together_with)\n+        (attr, item, after_derive)\n     }\n \n     fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n@@ -1195,7 +1182,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         expr.node = self.cfg.configure_expr_kind(expr.node);\n \n         // ignore derives so they remain unused\n-        let (attr, expr, together_with) = self.classify_nonitem(expr);\n+        let (attr, expr, after_derive) = self.classify_nonitem(expr);\n \n         if attr.is_some() {\n             // collect the invoc regardless of whether or not attributes are permitted here\n@@ -1204,7 +1191,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n             // AstFragmentKind::Expr requires the macro to emit an expression\n             return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n-                                     AstFragmentKind::Expr, together_with).make_expr();\n+                                     AstFragmentKind::Expr, after_derive).make_expr();\n         }\n \n         if let ast::ExprKind::Mac(mac) = expr.node {\n@@ -1220,13 +1207,13 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         expr.node = self.cfg.configure_expr_kind(expr.node);\n \n         // ignore derives so they remain unused\n-        let (attr, expr, together_with) = self.classify_nonitem(expr);\n+        let (attr, expr, after_derive) = self.classify_nonitem(expr);\n \n         if attr.is_some() {\n             attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n \n             return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n-                                     AstFragmentKind::OptExpr, together_with).make_opt_expr();\n+                                     AstFragmentKind::OptExpr, after_derive).make_opt_expr();\n         }\n \n         if let ast::ExprKind::Mac(mac) = expr.node {\n@@ -1258,18 +1245,18 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n         // we'll expand attributes on expressions separately\n         if !stmt.is_expr() {\n-            let (attr, derives, stmt_, together_with) = if stmt.is_item() {\n+            let (attr, derives, stmt_, after_derive) = if stmt.is_item() {\n                 self.classify_item(stmt)\n             } else {\n                 // ignore derives on non-item statements so it falls through\n                 // to the unused-attributes lint\n-                let (attr, stmt, together_with) = self.classify_nonitem(stmt);\n-                (attr, vec![], stmt, together_with)\n+                let (attr, stmt, after_derive) = self.classify_nonitem(stmt);\n+                (attr, vec![], stmt, after_derive)\n             };\n \n             if attr.is_some() || !derives.is_empty() {\n                 return self.collect_attr(attr, derives, Annotatable::Stmt(P(stmt_)),\n-                                         AstFragmentKind::Stmts, together_with).make_stmts();\n+                                         AstFragmentKind::Stmts, after_derive).make_stmts();\n             }\n \n             stmt = stmt_;\n@@ -1311,10 +1298,10 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n         let item = configure!(self, item);\n \n-        let (attr, traits, item, together_with) = self.classify_item(item);\n+        let (attr, traits, item, after_derive) = self.classify_item(item);\n         if attr.is_some() || !traits.is_empty() {\n             return self.collect_attr(attr, traits, Annotatable::Item(item),\n-                                     AstFragmentKind::Items, together_with).make_items();\n+                                     AstFragmentKind::Items, after_derive).make_items();\n         }\n \n         match item.node {\n@@ -1386,10 +1373,10 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_trait_item(&mut self, item: ast::TraitItem) -> SmallVec<[ast::TraitItem; 1]> {\n         let item = configure!(self, item);\n \n-        let (attr, traits, item, together_with) = self.classify_item(item);\n+        let (attr, traits, item, after_derive) = self.classify_item(item);\n         if attr.is_some() || !traits.is_empty() {\n             return self.collect_attr(attr, traits, Annotatable::TraitItem(P(item)),\n-                                     AstFragmentKind::TraitItems, together_with).make_trait_items()\n+                                     AstFragmentKind::TraitItems, after_derive).make_trait_items()\n         }\n \n         match item.node {\n@@ -1405,10 +1392,10 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_impl_item(&mut self, item: ast::ImplItem) -> SmallVec<[ast::ImplItem; 1]> {\n         let item = configure!(self, item);\n \n-        let (attr, traits, item, together_with) = self.classify_item(item);\n+        let (attr, traits, item, after_derive) = self.classify_item(item);\n         if attr.is_some() || !traits.is_empty() {\n             return self.collect_attr(attr, traits, Annotatable::ImplItem(P(item)),\n-                                     AstFragmentKind::ImplItems, together_with).make_impl_items();\n+                                     AstFragmentKind::ImplItems, after_derive).make_impl_items();\n         }\n \n         match item.node {\n@@ -1440,11 +1427,11 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_foreign_item(&mut self, foreign_item: ast::ForeignItem)\n         -> SmallVec<[ast::ForeignItem; 1]>\n     {\n-        let (attr, traits, foreign_item, together_with) = self.classify_item(foreign_item);\n+        let (attr, traits, foreign_item, after_derive) = self.classify_item(foreign_item);\n \n         if attr.is_some() || !traits.is_empty() {\n             return self.collect_attr(attr, traits, Annotatable::ForeignItem(P(foreign_item)),\n-                                     AstFragmentKind::ForeignItems, together_with)\n+                                     AstFragmentKind::ForeignItems, after_derive)\n                                      .make_foreign_items();\n         }\n "}, {"sha": "0cc3ef60cee9a3343fbbc723445edd663b72496a", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8994c6d417e25eba3cd077c0dce5760cfd05d576/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8994c6d417e25eba3cd077c0dce5760cfd05d576/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=8994c6d417e25eba3cd077c0dce5760cfd05d576", "patch": "@@ -990,10 +990,6 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                      \"the `#[rustc_test_marker]` attribute \\\n                                       is used internally to track tests\",\n                                      cfg_fn!(rustc_attrs))),\n-    (\"rustc_test_marker2\", Normal, Gated(Stability::Unstable,\n-                                         \"rustc_attrs\",\n-                                         \"temporarily used by rustc to report some errors\",\n-                                         cfg_fn!(rustc_attrs))),\n     (\"rustc_transparent_macro\", Whitelisted, Gated(Stability::Unstable,\n                                                    \"rustc_attrs\",\n                                                    \"used internally for testing macro hygiene\","}, {"sha": "be3485cfa7cc23a5e2c8a40e3a22e42ac4822f39", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8994c6d417e25eba3cd077c0dce5760cfd05d576/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8994c6d417e25eba3cd077c0dce5760cfd05d576/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=8994c6d417e25eba3cd077c0dce5760cfd05d576", "patch": "@@ -49,7 +49,7 @@ pub fn expand_test_or_bench(\n     // If we're not in test configuration, remove the annotated item\n     if !cx.ecfg.should_test { return vec![]; }\n \n-    let mut item =\n+    let item =\n         if let Annotatable::Item(i) = item { i }\n         else {\n             cx.parse_sess.span_diagnostic.span_fatal(item.span(),\n@@ -192,12 +192,6 @@ pub fn expand_test_or_bench(\n \n     debug!(\"Synthetic test item:\\n{}\\n\", pprust::item_to_string(&test_const));\n \n-    // Temporarily add another marker to the original item for error reporting\n-    let marker2 = cx.attribute(\n-        attr_sp, cx.meta_word(attr_sp, Symbol::intern(\"rustc_test_marker2\"))\n-    );\n-    item.attrs.push(marker2);\n-\n     vec![\n         // Access to libtest under a gensymed name\n         Annotatable::Item(test_extern),"}, {"sha": "f51a6aae068a121903fe8a357a4fd01923cc34e9", "filename": "src/test/run-pass-fulldeps/macro-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8994c6d417e25eba3cd077c0dce5760cfd05d576/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8994c6d417e25eba3cd077c0dce5760cfd05d576/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs?ref=8994c6d417e25eba3cd077c0dce5760cfd05d576", "patch": "@@ -19,8 +19,8 @@\n #[macro_use] #[no_link]\n extern crate macro_crate_test;\n \n-#[derive(PartialEq, Clone, Debug)]\n #[rustc_into_multi_foo]\n+#[derive(PartialEq, Clone, Debug)]\n fn foo() -> AnotherFakeTypeThatHadBetterGoAway {}\n \n // Check that the `#[into_multi_foo]`-generated `foo2` is configured away"}, {"sha": "7b1eecd1558659f4665d2978d9839febc9074710", "filename": "src/test/ui-fulldeps/attribute-order-restricted.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8994c6d417e25eba3cd077c0dce5760cfd05d576/src%2Ftest%2Fui-fulldeps%2Fattribute-order-restricted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8994c6d417e25eba3cd077c0dce5760cfd05d576/src%2Ftest%2Fui-fulldeps%2Fattribute-order-restricted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fattribute-order-restricted.rs?ref=8994c6d417e25eba3cd077c0dce5760cfd05d576", "patch": "@@ -1,9 +1,5 @@\n // aux-build:attr_proc_macro.rs\n-// compile-flags:--test\n \n-#![feature(test)]\n-\n-extern crate test;\n extern crate attr_proc_macro;\n use attr_proc_macro::*;\n \n@@ -15,18 +11,4 @@ struct Before;\n #[attr_proc_macro] //~ ERROR macro attributes must be placed before `#[derive]`\n struct After;\n \n-#[attr_proc_macro] //~ ERROR macro attributes cannot be used together with `#[test]` or `#[bench]`\n-#[test]\n-fn test_before() {}\n-\n-#[test]\n-#[attr_proc_macro] //~ ERROR macro attributes cannot be used together with `#[test]` or `#[bench]`\n-fn test_after() {}\n-\n-#[attr_proc_macro] //~ ERROR macro attributes cannot be used together with `#[test]` or `#[bench]`\n-#[bench]\n-fn bench_before(b: &mut test::Bencher) {}\n-\n-#[bench]\n-#[attr_proc_macro] //~ ERROR macro attributes cannot be used together with `#[test]` or `#[bench]`\n-fn bench_after(b: &mut test::Bencher) {}\n+fn main() {}"}, {"sha": "a4f165cd1b52c65470e116dbed27a4c33152c9b3", "filename": "src/test/ui-fulldeps/attribute-order-restricted.stderr", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8994c6d417e25eba3cd077c0dce5760cfd05d576/src%2Ftest%2Fui-fulldeps%2Fattribute-order-restricted.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8994c6d417e25eba3cd077c0dce5760cfd05d576/src%2Ftest%2Fui-fulldeps%2Fattribute-order-restricted.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fattribute-order-restricted.stderr?ref=8994c6d417e25eba3cd077c0dce5760cfd05d576", "patch": "@@ -1,32 +1,8 @@\n error: macro attributes must be placed before `#[derive]`\n-  --> $DIR/attribute-order-restricted.rs:15:1\n+  --> $DIR/attribute-order-restricted.rs:11:1\n    |\n LL | #[attr_proc_macro] //~ ERROR macro attributes must be placed before `#[derive]`\n    | ^^^^^^^^^^^^^^^^^^\n \n-error: macro attributes cannot be used together with `#[test]` or `#[bench]`\n-  --> $DIR/attribute-order-restricted.rs:18:1\n-   |\n-LL | #[attr_proc_macro] //~ ERROR macro attributes cannot be used together with `#[test]` or `#[bench]`\n-   | ^^^^^^^^^^^^^^^^^^\n-\n-error: macro attributes cannot be used together with `#[test]` or `#[bench]`\n-  --> $DIR/attribute-order-restricted.rs:23:1\n-   |\n-LL | #[attr_proc_macro] //~ ERROR macro attributes cannot be used together with `#[test]` or `#[bench]`\n-   | ^^^^^^^^^^^^^^^^^^\n-\n-error: macro attributes cannot be used together with `#[test]` or `#[bench]`\n-  --> $DIR/attribute-order-restricted.rs:26:1\n-   |\n-LL | #[attr_proc_macro] //~ ERROR macro attributes cannot be used together with `#[test]` or `#[bench]`\n-   | ^^^^^^^^^^^^^^^^^^\n-\n-error: macro attributes cannot be used together with `#[test]` or `#[bench]`\n-  --> $DIR/attribute-order-restricted.rs:31:1\n-   |\n-LL | #[attr_proc_macro] //~ ERROR macro attributes cannot be used together with `#[test]` or `#[bench]`\n-   | ^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 5 previous errors\n+error: aborting due to previous error\n "}]}