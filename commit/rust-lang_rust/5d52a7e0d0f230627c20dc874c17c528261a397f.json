{"sha": "5d52a7e0d0f230627c20dc874c17c528261a397f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNTJhN2UwZDBmMjMwNjI3YzIwZGM4NzRjMTdjNTI4MjYxYTM5N2Y=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-04-13T16:18:12Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-15T15:23:51Z"}, "message": "rustc_metadata: split tables into an usize-keyed Table and a DefIndex-keyed PerDefTable.", "tree": {"sha": "06819560560408381a0cbe18166aa0f6a25494d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06819560560408381a0cbe18166aa0f6a25494d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d52a7e0d0f230627c20dc874c17c528261a397f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d52a7e0d0f230627c20dc874c17c528261a397f", "html_url": "https://github.com/rust-lang/rust/commit/5d52a7e0d0f230627c20dc874c17c528261a397f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d52a7e0d0f230627c20dc874c17c528261a397f/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd1264e90a47d9818d868276cd09363fe78056c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd1264e90a47d9818d868276cd09363fe78056c4", "html_url": "https://github.com/rust-lang/rust/commit/dd1264e90a47d9818d868276cd09363fe78056c4"}], "stats": {"total": 112, "additions": 75, "deletions": 37}, "files": [{"sha": "c640e411f63469ae3d109a3395f81a31be1cee37", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d52a7e0d0f230627c20dc874c17c528261a397f/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d52a7e0d0f230627c20dc874c17c528261a397f/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=5d52a7e0d0f230627c20dc874c17c528261a397f", "patch": "@@ -2,7 +2,7 @@\n \n use crate::cstore::{self, CrateMetadata, MetadataBlob};\n use crate::schema::*;\n-use crate::table::Table;\n+use crate::table::PerDefTable;\n \n use rustc_index::vec::IndexVec;\n use rustc_data_structures::sync::{Lrc, ReadGuard};\n@@ -255,10 +255,10 @@ impl<'a, 'tcx, T: Encodable> SpecializedDecoder<Lazy<[T]>> for DecodeContext<'a,\n     }\n }\n \n-impl<'a, 'tcx, T> SpecializedDecoder<Lazy<Table<T>>> for DecodeContext<'a, 'tcx>\n+impl<'a, 'tcx, T> SpecializedDecoder<Lazy<PerDefTable<T>>> for DecodeContext<'a, 'tcx>\n     where T: LazyMeta<Meta = ()>,\n {\n-    fn specialized_decode(&mut self) -> Result<Lazy<Table<T>>, Self::Error> {\n+    fn specialized_decode(&mut self) -> Result<Lazy<PerDefTable<T>>, Self::Error> {\n         let len = self.read_usize()?;\n         self.read_lazy_with_meta(len)\n     }"}, {"sha": "df99541df587639e1e53ab12c91d931d237c1ced", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5d52a7e0d0f230627c20dc874c17c528261a397f/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d52a7e0d0f230627c20dc874c17c528261a397f/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=5d52a7e0d0f230627c20dc874c17c528261a397f", "patch": "@@ -1,5 +1,5 @@\n use crate::schema::*;\n-use crate::table::Table;\n+use crate::table::PerDefTable;\n \n use rustc::middle::cstore::{LinkagePreference, NativeLibrary,\n                             EncodedMetadata, ForeignModule};\n@@ -47,7 +47,7 @@ struct EncodeContext<'tcx> {\n     opaque: opaque::Encoder,\n     tcx: TyCtxt<'tcx>,\n \n-    entries_table: Table<Entry<'tcx>>,\n+    entries_table: PerDefTable<Entry<'tcx>>,\n \n     lazy_state: LazyState,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n@@ -114,10 +114,10 @@ impl<'tcx, T: Encodable> SpecializedEncoder<Lazy<[T]>> for EncodeContext<'tcx> {\n     }\n }\n \n-impl<'tcx, T> SpecializedEncoder<Lazy<Table<T>>> for EncodeContext<'tcx>\n+impl<'tcx, T> SpecializedEncoder<Lazy<PerDefTable<T>>> for EncodeContext<'tcx>\n     where T: LazyMeta<Meta = ()>,\n {\n-    fn specialized_encode(&mut self, lazy: &Lazy<Table<T>>) -> Result<(), Self::Error> {\n+    fn specialized_encode(&mut self, lazy: &Lazy<PerDefTable<T>>) -> Result<(), Self::Error> {\n         self.emit_usize(lazy.meta)?;\n         self.emit_lazy_distance(*lazy)\n     }\n@@ -1925,7 +1925,7 @@ crate fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n         let mut ecx = EncodeContext {\n             opaque: encoder,\n             tcx,\n-            entries_table: Table::new(tcx.hir().definitions().def_index_count()),\n+            entries_table: PerDefTable::new(tcx.hir().definitions().def_index_count()),\n             lazy_state: LazyState::NoNode,\n             type_shorthands: Default::default(),\n             predicate_shorthands: Default::default(),"}, {"sha": "dffc8f33b2de6d0e201c30cdfb90b3d64662a091", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d52a7e0d0f230627c20dc874c17c528261a397f/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d52a7e0d0f230627c20dc874c17c528261a397f/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=5d52a7e0d0f230627c20dc874c17c528261a397f", "patch": "@@ -1,4 +1,4 @@\n-use crate::table::Table;\n+use crate::table::PerDefTable;\n \n use rustc::hir;\n use rustc::hir::def::{self, CtorKind};\n@@ -162,6 +162,7 @@ crate enum LazyState {\n // Only needed when `T` itself contains a parameter (e.g. `'tcx`).\n macro_rules! Lazy {\n     (Table<$T:ty>) => {Lazy<Table<$T>, usize>};\n+    (PerDefTable<$T:ty>) => {Lazy<PerDefTable<$T>, usize>};\n     ([$T:ty]) => {Lazy<[$T], usize>};\n     ($T:ty) => {Lazy<$T, ()>};\n }\n@@ -196,7 +197,7 @@ crate struct CrateRoot<'tcx> {\n     pub exported_symbols: Lazy!([(ExportedSymbol<'tcx>, SymbolExportLevel)]),\n     pub interpret_alloc_index: Lazy<[u32]>,\n \n-    pub entries_table: Lazy!(Table<Entry<'tcx>>),\n+    pub entries_table: Lazy!(PerDefTable<Entry<'tcx>>),\n \n     /// The DefIndex's of any proc macros delcared by\n     /// this crate"}, {"sha": "c60c8e2cbce55a1efa6974dd36d6f5e4cbd69dee", "filename": "src/librustc_metadata/table.rs", "status": "modified", "additions": 64, "deletions": 27, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/5d52a7e0d0f230627c20dc874c17c528261a397f/src%2Flibrustc_metadata%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d52a7e0d0f230627c20dc874c17c528261a397f/src%2Flibrustc_metadata%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftable.rs?ref=5d52a7e0d0f230627c20dc874c17c528261a397f", "patch": "@@ -73,44 +73,41 @@ impl FixedSizeEncoding for u32 {\n /// (e.g. while visiting the definitions of a crate), and on-demand decoding\n /// of specific indices (e.g. queries for per-definition data).\n /// Similar to `Vec<Lazy<T>>`, but with zero-copy decoding.\n+// FIXME(eddyb) newtype `[u8]` here, such that `Box<Table<T>>` would be used\n+// when building it, and `Lazy<Table<T>>` or `&Table<T>` when reading it.\n+// Sadly, that doesn't work for `DefPerTable`, which is `(Table<T>, Table<T>)`,\n+// and so would need two lengths in its metadata, which is not supported yet.\n crate struct Table<T: LazyMeta<Meta = ()>> {\n-    positions: Vec<u8>,\n+    bytes: Vec<u8>,\n     _marker: PhantomData<T>,\n }\n \n impl<T: LazyMeta<Meta = ()>> Table<T> {\n-    crate fn new(max_index: usize) -> Self {\n+    crate fn new(len: usize) -> Self {\n         Table {\n-            positions: vec![0; max_index * 4],\n+            bytes: vec![0; len * 4],\n             _marker: PhantomData,\n         }\n     }\n \n-    crate fn record(&mut self, def_id: DefId, entry: Lazy<T>) {\n-        assert!(def_id.is_local());\n-        self.record_index(def_id.index, entry);\n-    }\n-\n-    crate fn record_index(&mut self, item: DefIndex, entry: Lazy<T>) {\n+    crate fn record(&mut self, i: usize, entry: Lazy<T>) {\n         let position: u32 = entry.position.get().try_into().unwrap();\n-        let array_index = item.index();\n \n-        let positions = &mut self.positions;\n-        assert!(u32::read_from_bytes_at(positions, array_index) == 0,\n-                \"recorded position for item {:?} twice, first at {:?} and now at {:?}\",\n-                item,\n-                u32::read_from_bytes_at(positions, array_index),\n+        assert!(u32::read_from_bytes_at(&self.bytes, i) == 0,\n+                \"recorded position for index {:?} twice, first at {:?} and now at {:?}\",\n+                i,\n+                u32::read_from_bytes_at(&self.bytes, i),\n                 position);\n \n-        position.write_to_bytes_at(positions, array_index)\n+        position.write_to_bytes_at(&mut self.bytes, i)\n     }\n \n     crate fn encode(&self, buf: &mut Encoder) -> Lazy<Self> {\n         let pos = buf.position();\n-        buf.emit_raw_bytes(&self.positions);\n+        buf.emit_raw_bytes(&self.bytes);\n         Lazy::from_position_and_meta(\n             NonZeroUsize::new(pos as usize).unwrap(),\n-            self.positions.len() / 4,\n+            self.bytes.len(),\n         )\n     }\n }\n@@ -119,22 +116,62 @@ impl<T: LazyMeta<Meta = ()>> LazyMeta for Table<T> {\n     type Meta = usize;\n \n     fn min_size(len: usize) -> usize {\n-        len * 4\n+        len\n     }\n }\n \n impl<T: Encodable> Lazy<Table<T>> {\n-    /// Given the metadata, extract out the offset of a particular\n-    /// DefIndex (if any).\n+    /// Given the metadata, extract out the offset of a particular index (if any).\n     #[inline(never)]\n-    crate fn lookup(&self, bytes: &[u8], def_index: DefIndex) -> Option<Lazy<T>> {\n-        debug!(\"Table::lookup: index={:?} len={:?}\",\n-               def_index,\n-               self.meta);\n+    crate fn lookup(&self, bytes: &[u8], i: usize) -> Option<Lazy<T>> {\n+        debug!(\"Table::lookup: index={:?} len={:?}\", i, self.meta);\n \n-        let bytes = &bytes[self.position.get()..][..self.meta * 4];\n-        let position = u32::read_from_bytes_at(bytes, def_index.index());\n+        let bytes = &bytes[self.position.get()..][..self.meta];\n+        let position = u32::read_from_bytes_at(bytes, i);\n         debug!(\"Table::lookup: position={:?}\", position);\n+\n         NonZeroUsize::new(position as usize).map(Lazy::from_position)\n     }\n }\n+\n+\n+/// Per-definition table, similar to `Table` but keyed on `DefIndex`.\n+// FIXME(eddyb) replace by making `Table` behave like `IndexVec`,\n+// and by using `newtype_index!` to define `DefIndex`.\n+crate struct PerDefTable<T: LazyMeta<Meta = ()>>(Table<T>);\n+\n+impl<T: LazyMeta<Meta = ()>> PerDefTable<T> {\n+    crate fn new(def_index_count: usize) -> Self {\n+        PerDefTable(Table::new(def_index_count))\n+    }\n+\n+    crate fn record(&mut self, def_id: DefId, entry: Lazy<T>) {\n+        assert!(def_id.is_local());\n+        self.0.record(def_id.index.index(), entry);\n+    }\n+\n+    crate fn encode(&self, buf: &mut Encoder) -> Lazy<Self> {\n+        let lazy = self.0.encode(buf);\n+        Lazy::from_position_and_meta(lazy.position, lazy.meta)\n+    }\n+}\n+\n+impl<T: LazyMeta<Meta = ()>> LazyMeta for PerDefTable<T> {\n+    type Meta = <Table<T> as LazyMeta>::Meta;\n+\n+    fn min_size(meta: Self::Meta) -> usize {\n+        Table::<T>::min_size(meta)\n+    }\n+}\n+\n+impl<T: Encodable> Lazy<PerDefTable<T>> {\n+    fn as_table(&self) -> Lazy<Table<T>> {\n+        Lazy::from_position_and_meta(self.position, self.meta)\n+    }\n+\n+    /// Given the metadata, extract out the offset of a particular DefIndex (if any).\n+    #[inline(never)]\n+    crate fn lookup(&self, bytes: &[u8], def_index: DefIndex) -> Option<Lazy<T>> {\n+        self.as_table().lookup(bytes, def_index.index())\n+    }\n+}"}]}