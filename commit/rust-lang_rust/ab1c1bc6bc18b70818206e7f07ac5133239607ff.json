{"sha": "ab1c1bc6bc18b70818206e7f07ac5133239607ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiMWMxYmM2YmMxOGI3MDgxODIwNmU3ZjA3YWM1MTMzMjM5NjA3ZmY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-22T22:38:51Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-07T10:28:00Z"}, "message": "mir-borrowck returns closure requirements, mir-typeck enforces", "tree": {"sha": "b7d4e6f34fc609127323c145f7f84c46449cdfa2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7d4e6f34fc609127323c145f7f84c46449cdfa2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab1c1bc6bc18b70818206e7f07ac5133239607ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab1c1bc6bc18b70818206e7f07ac5133239607ff", "html_url": "https://github.com/rust-lang/rust/commit/ab1c1bc6bc18b70818206e7f07ac5133239607ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab1c1bc6bc18b70818206e7f07ac5133239607ff/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ec959fc35a8b0bdab13c03fcce9c90a929e9bd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ec959fc35a8b0bdab13c03fcce9c90a929e9bd7", "html_url": "https://github.com/rust-lang/rust/commit/2ec959fc35a8b0bdab13c03fcce9c90a929e9bd7"}], "stats": {"total": 1305, "additions": 1121, "deletions": 184}, "files": [{"sha": "beee34e11b724b7e0a6bada0ddfcb703bed846f0", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=ab1c1bc6bc18b70818206e7f07ac5133239607ff", "patch": "@@ -572,3 +572,15 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Literal<'gcx> {\n }\n \n impl_stable_hash_for!(struct mir::Location { block, statement_index });\n+\n+impl_stable_hash_for!(struct mir::ClosureRegionRequirements {\n+    num_external_vids,\n+    outlives_requirements\n+});\n+\n+impl_stable_hash_for!(struct mir::ClosureOutlivesRequirement {\n+    free_region,\n+    outlived_free_region,\n+    blame_span\n+});\n+"}, {"sha": "2655e2acbbdfb369f19437a1c9c35bff1e53149a", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=ab1c1bc6bc18b70818206e7f07ac5133239607ff", "patch": "@@ -84,6 +84,16 @@ for ty::RegionKind {\n     }\n }\n \n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::RegionVid {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use rustc_data_structures::indexed_vec::Idx;\n+        self.index().hash_stable(hcx, hasher);\n+    }\n+}\n+\n impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ty::adjustment::AutoBorrow<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,"}, {"sha": "0d4d294ad36f368bcc0e93b7fc77043c44a52f49", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=ab1c1bc6bc18b70818206e7f07ac5133239607ff", "patch": "@@ -1062,6 +1062,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.mk_region(ty::ReVar(self.borrow_region_constraints().new_region_var(origin)))\n     }\n \n+    /// Number of region variables created so far.\n+    pub fn num_region_vars(&self) -> usize {\n+        self.borrow_region_constraints().var_origins().len()\n+    }\n+\n     /// Just a convenient wrapper of `next_region_var` for using during NLL.\n     pub fn next_nll_region_var(&self, origin: NLLRegionVariableOrigin)\n                                -> ty::Region<'tcx> {"}, {"sha": "720d831a245335a4a3e22e023c56296b10315e71", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=ab1c1bc6bc18b70818206e7f07ac5133239607ff", "patch": "@@ -1789,6 +1789,75 @@ pub struct GeneratorLayout<'tcx> {\n     pub fields: Vec<LocalDecl<'tcx>>,\n }\n \n+/// After we borrow check a closure, we are left with various\n+/// requirements that we have inferred between the free regions that\n+/// appear in the closure's signature or on its field types.  These\n+/// requirements are then verified and proved by the closure's\n+/// creating function. This struct encodes those requirements.\n+///\n+/// The requirements are listed as being between various\n+/// `RegionVid`. The 0th region refers to `'static`; subsequent region\n+/// vids refer to the free regions that appear in the closure (or\n+/// generator's) type, in order of appearance. (This numbering is\n+/// actually defined by the `UniversalRegions` struct in the NLL\n+/// region checker. See for example\n+/// `UniversalRegions::closure_mapping`.) Note that we treat the free\n+/// regions in the closure's type \"as if\" they were erased, so their\n+/// precise identity is not important, only their position.\n+///\n+/// Example: If type check produces a closure with the closure substs:\n+///\n+/// ```\n+/// ClosureSubsts = [\n+///     i8,                                  // the \"closure kind\"\n+///     for<'x> fn(&'a &'x u32) -> &'x u32,  // the \"closure signature\"\n+///     &'a String,                          // some upvar\n+/// ]\n+/// ```\n+///\n+/// here, there is one unique free region (`'a`) but it appears\n+/// twice. We would \"renumber\" each occurence to a unique vid, as follows:\n+///\n+/// ```\n+/// ClosureSubsts = [\n+///     i8,                                  // the \"closure kind\"\n+///     for<'x> fn(&'1 &'x u32) -> &'x u32,  // the \"closure signature\"\n+///     &'2 String,                          // some upvar\n+/// ]\n+/// ```\n+///\n+/// Now the code might impose a requirement like `'1: '2`. When an\n+/// instance of the closure is created, the corresponding free regions\n+/// can be extracted from its type and constrained to have the given\n+/// outlives relationship.\n+#[derive(Clone, Debug)]\n+pub struct ClosureRegionRequirements {\n+    /// The number of external regions defined on the closure.  In our\n+    /// example above, it would be 3 -- one for `'static`, then `'1`\n+    /// and `'2`. This is just used for a sanity check later on, to\n+    /// make sure that the number of regions we see at the callsite\n+    /// matches.\n+    pub num_external_vids: usize,\n+\n+    /// Requirements between the various free regions defined in\n+    /// indices.\n+    pub outlives_requirements: Vec<ClosureOutlivesRequirement>,\n+}\n+\n+/// Indicates an outlives constraint between two free-regions declared\n+/// on the closure.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct ClosureOutlivesRequirement {\n+    // This region ...\n+    pub free_region: ty::RegionVid,\n+\n+    // .. must outlive this one.\n+    pub outlived_free_region: ty::RegionVid,\n+\n+    // If not, report an error here.\n+    pub blame_span: Span,\n+}\n+\n /*\n  * TypeFoldable implementations for MIR types\n  */"}, {"sha": "848d2a0a7def71d9a7adef2bca3fcaa72eff0fd2", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=ab1c1bc6bc18b70818206e7f07ac5133239607ff", "patch": "@@ -190,8 +190,10 @@ define_maps! { <'tcx>\n     [] fn coherent_trait: coherent_trait_dep_node((CrateNum, DefId)) -> (),\n \n     [] fn borrowck: BorrowCheck(DefId) -> Rc<BorrowCheckResult>,\n-    // FIXME: shouldn't this return a `Result<(), BorrowckErrors>` instead?\n-    [] fn mir_borrowck: MirBorrowCheck(DefId) -> (),\n+\n+    /// Borrow checks the function body. If this is a closure, returns\n+    /// additional requirements that the closure's creator must verify.\n+    [] fn mir_borrowck: MirBorrowCheck(DefId) -> Option<mir::ClosureRegionRequirements>,\n \n     /// Gets a complete map from all types to their inherent impls.\n     /// Not meant to be used directly outside of coherence."}, {"sha": "24cf14419e4aed55cb9e372ed5e1e1995ba48398", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=ab1c1bc6bc18b70818206e7f07ac5133239607ff", "patch": "@@ -646,6 +646,17 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n pub struct Binder<T>(pub T);\n \n impl<T> Binder<T> {\n+    /// Wraps `value` in a binder, asserting that `value` does not\n+    /// contain any bound regions that would be bound by the\n+    /// binder. This is commonly used to 'inject' a value T into a\n+    /// different binding level.\n+    pub fn new_not_binding<'tcx>(value: T) -> Binder<T>\n+        where T: TypeFoldable<'tcx>\n+    {\n+        assert!(!value.has_escaping_regions());\n+        Binder(value)\n+    }\n+\n     /// Skips the binder and returns the \"bound\" value. This is a\n     /// risky thing to do because it's easy to get confused about\n     /// debruijn indices and the like. It is usually better to\n@@ -700,6 +711,32 @@ impl<T> Binder<T> {\n             Some(self.skip_binder().clone())\n         }\n     }\n+\n+    /// Given two things that have the same binder level,\n+    /// and an operation that wraps on their contents, execute the operation\n+    /// and then wrap its result.\n+    ///\n+    /// `f` should consider bound regions at depth 1 to be free, and\n+    /// anything it produces with bound regions at depth 1 will be\n+    /// bound in the resulting return value.\n+    pub fn fuse<U,F,R>(self, u: Binder<U>, f: F) -> Binder<R>\n+        where F: FnOnce(T, U) -> R\n+    {\n+        ty::Binder(f(self.0, u.0))\n+    }\n+\n+    /// Split the contents into two things that share the same binder\n+    /// level as the original, returning two distinct binders.\n+    ///\n+    /// `f` should consider bound regions at depth 1 to be free, and\n+    /// anything it produces with bound regions at depth 1 will be\n+    /// bound in the resulting return values.\n+    pub fn split<U,V,F>(self, f: F) -> (Binder<U>, Binder<V>)\n+        where F: FnOnce(T) -> (U, V)\n+    {\n+        let (u, v) = f(self.0);\n+        (ty::Binder(u), ty::Binder(v))\n+    }\n }\n \n /// Represents the projection of an associated type. In explicit UFCS\n@@ -799,6 +836,9 @@ impl<'tcx> PolyFnSig<'tcx> {\n     pub fn input(&self, index: usize) -> ty::Binder<Ty<'tcx>> {\n         self.map_bound_ref(|fn_sig| fn_sig.inputs()[index])\n     }\n+    pub fn inputs_and_output(&self) -> ty::Binder<&'tcx Slice<Ty<'tcx>>> {\n+        self.map_bound_ref(|fn_sig| fn_sig.inputs_and_output)\n+    }\n     pub fn output(&self) -> ty::Binder<Ty<'tcx>> {\n         self.map_bound_ref(|fn_sig| fn_sig.output().clone())\n     }"}, {"sha": "b0f61e9a19177cfe21bcce6ff29b57b2f1708879", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=ab1c1bc6bc18b70818206e7f07ac5133239607ff", "patch": "@@ -1069,7 +1069,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(control: &CompileController,\n \n         time(time_passes,\n              \"MIR borrow checking\",\n-             || for def_id in tcx.body_owners() { tcx.mir_borrowck(def_id) });\n+             || for def_id in tcx.body_owners() { tcx.mir_borrowck(def_id); });\n \n         time(time_passes,\n              \"MIR effect checking\","}, {"sha": "97d8a677fe8f15e0fe4454ef1362cdac6d2a3ab3", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=ab1c1bc6bc18b70818206e7f07ac5133239607ff", "patch": "@@ -19,6 +19,7 @@ use rustc::ty::maps::Providers;\n use rustc::mir::{AssertMessage, BasicBlock, BorrowKind, Local, Location, Place};\n use rustc::mir::{Mir, Mutability, Operand, Projection, ProjectionElem, Rvalue};\n use rustc::mir::{Field, Statement, StatementKind, Terminator, TerminatorKind};\n+use rustc::mir::ClosureRegionRequirements;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_set::{self, IdxSetBuf};\n@@ -51,29 +52,34 @@ pub fn provide(providers: &mut Providers) {\n     };\n }\n \n-fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+fn mir_borrowck<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+) -> Option<ClosureRegionRequirements> {\n     let input_mir = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.item_path_str(def_id));\n \n     if {\n         !tcx.has_attr(def_id, \"rustc_mir_borrowck\") && !tcx.sess.opts.borrowck_mode.use_mir()\n             && !tcx.sess.opts.debugging_opts.nll\n     } {\n-        return;\n+        return None;\n     }\n \n-    tcx.infer_ctxt().enter(|infcx| {\n+    let opt_closure_req = tcx.infer_ctxt().enter(|infcx| {\n         let input_mir: &Mir = &input_mir.borrow();\n-        do_mir_borrowck(&infcx, input_mir, def_id);\n+        do_mir_borrowck(&infcx, input_mir, def_id)\n     });\n     debug!(\"mir_borrowck done\");\n+\n+    opt_closure_req\n }\n \n fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     input_mir: &Mir<'gcx>,\n     def_id: DefId,\n-) {\n+) -> Option<ClosureRegionRequirements> {\n     let tcx = infcx.tcx;\n     let attributes = tcx.get_attrs(def_id);\n     let param_env = tcx.param_env(def_id);\n@@ -91,7 +97,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         let mir = &mut mir;\n \n         // Replace all regions with fresh inference variables.\n-        Some(nll::replace_regions_in_mir(infcx, def_id, mir))\n+        Some(nll::replace_regions_in_mir(infcx, def_id, param_env, mir))\n     };\n     let mir = &mir;\n \n@@ -177,19 +183,20 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     ));\n \n     // If we are in non-lexical mode, compute the non-lexical lifetimes.\n-    let opt_regioncx = if let Some(free_regions) = free_regions {\n-        Some(nll::compute_regions(\n+    let (opt_regioncx, opt_closure_req) = if let Some(free_regions) = free_regions {\n+        let (regioncx, opt_closure_req) = nll::compute_regions(\n             infcx,\n             def_id,\n             free_regions,\n             mir,\n             param_env,\n             &mut flow_inits,\n             &mdpe.move_data,\n-        ))\n+        );\n+        (Some(regioncx), opt_closure_req)\n     } else {\n         assert!(!tcx.sess.opts.debugging_opts.nll);\n-        None\n+        (None, None)\n     };\n     let flow_inits = flow_inits; // remove mut\n \n@@ -226,6 +233,8 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     );\n \n     mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n+\n+    opt_closure_req\n }\n \n #[allow(dead_code)]"}, {"sha": "3d698abc83f4349ab8fb4bed3f83acb76317bf04", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=ab1c1bc6bc18b70818206e7f07ac5133239607ff", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::hir::def_id::DefId;\n-use rustc::mir::Mir;\n+use rustc::mir::{ClosureRegionRequirements, Mir};\n use rustc::infer::InferCtxt;\n use rustc::ty::{self, RegionKind, RegionVid};\n use rustc::util::nodemap::FxHashMap;\n@@ -35,20 +35,21 @@ use self::region_infer::RegionInferenceContext;\n mod renumber;\n \n /// Rewrites the regions in the MIR to use NLL variables, also\n-/// scraping out the set of free regions (e.g., region parameters)\n+/// scraping out the set of universal regions (e.g., region parameters)\n /// declared on the function. That set will need to be given to\n /// `compute_regions`.\n pub(in borrow_check) fn replace_regions_in_mir<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n     def_id: DefId,\n+    param_env: ty::ParamEnv<'tcx>,\n     mir: &mut Mir<'tcx>,\n ) -> UniversalRegions<'tcx> {\n     debug!(\"replace_regions_in_mir(def_id={:?})\", def_id);\n \n-    // Compute named region information.\n-    let universal_regions = universal_regions::universal_regions(infcx, def_id);\n+    // Compute named region information. This also renumbers the inputs/outputs.\n+    let universal_regions = UniversalRegions::new(infcx, def_id, param_env);\n \n-    // Replace all regions with fresh inference variables.\n+    // Replace all remaining regions with fresh inference variables.\n     renumber::renumber_mir(infcx, &universal_regions, mir);\n \n     let source = MirSource::item(def_id);\n@@ -68,21 +69,19 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     param_env: ty::ParamEnv<'gcx>,\n     flow_inits: &mut FlowInProgress<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n-) -> RegionInferenceContext<'tcx> {\n+) -> (\n+    RegionInferenceContext<'tcx>,\n+    Option<ClosureRegionRequirements>,\n+) {\n     // Run the MIR type-checker.\n     let mir_node_id = infcx.tcx.hir.as_local_node_id(def_id).unwrap();\n     let constraint_sets = &type_check::type_check(infcx, mir_node_id, param_env, mir);\n \n     // Create the region inference context, taking ownership of the region inference\n     // data that was contained in `infcx`.\n     let var_origins = infcx.take_region_var_origins();\n-    let mut regioncx = RegionInferenceContext::new(var_origins, &universal_regions, mir);\n-    subtype_constraint_generation::generate(\n-        &mut regioncx,\n-        &universal_regions,\n-        mir,\n-        constraint_sets,\n-    );\n+    let mut regioncx = RegionInferenceContext::new(var_origins, universal_regions, mir);\n+    subtype_constraint_generation::generate(&mut regioncx, mir, constraint_sets);\n \n     // Compute what is live where.\n     let liveness = &LivenessResults {\n@@ -115,13 +114,13 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     );\n \n     // Solve the region constraints.\n-    regioncx.solve(infcx, &mir);\n+    let closure_region_requirements = regioncx.solve(infcx, &mir, def_id);\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests.\n     dump_mir_results(infcx, liveness, MirSource::item(def_id), &mir, &regioncx);\n \n-    regioncx\n+    (regioncx, closure_region_requirements)\n }\n \n struct LivenessResults {\n@@ -197,7 +196,7 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n /// Right now, we piggy back on the `ReVar` to store our NLL inference\n /// regions. These are indexed with `RegionVid`. This method will\n /// assert that the region is a `ReVar` and extract its interal index.\n-/// This is reasonable because in our MIR we replace all free regions\n+/// This is reasonable because in our MIR we replace all universal regions\n /// with inference variables.\n pub trait ToRegionVid {\n     fn to_region_vid(&self) -> RegionVid;"}, {"sha": "171deb3e1d753797b7a67cc8b58383438770662e", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 235, "deletions": 66, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=ab1c1bc6bc18b70818206e7f07ac5133239607ff", "patch": "@@ -9,12 +9,13 @@\n // except according to those terms.\n \n use super::universal_regions::UniversalRegions;\n+use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n-use rustc::infer::RegionVariableOrigin;\n use rustc::infer::NLLRegionVariableOrigin;\n+use rustc::infer::RegionVariableOrigin;\n+use rustc::infer::SubregionOrigin;\n use rustc::infer::region_constraints::VarOrigins;\n-use rustc::infer::outlives::free_region_map::FreeRegionMap;\n-use rustc::mir::{Location, Mir};\n+use rustc::mir::{ClosureOutlivesRequirement, ClosureRegionRequirements, Location, Mir};\n use rustc::ty::{self, RegionVid};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashSet;\n@@ -52,12 +53,9 @@ pub struct RegionInferenceContext<'tcx> {\n     /// the free regions.)\n     point_indices: BTreeMap<Location, usize>,\n \n-    /// Number of universally quantified regions. This is used to\n-    /// determine the meaning of the bits in `inferred_values` and\n-    /// friends.\n-    num_universal_regions: usize,\n-\n-    free_region_map: &'tcx FreeRegionMap<'tcx>,\n+    /// Information about the universally quantified regions in scope\n+    /// on this function and their (known) relations to one another.\n+    universal_regions: UniversalRegions<'tcx>,\n }\n \n struct RegionDefinition<'tcx> {\n@@ -67,9 +65,15 @@ struct RegionDefinition<'tcx> {\n     /// late-bound-regions).\n     origin: RegionVariableOrigin,\n \n-    /// If this is a free-region, then this is `Some(X)` where `X` is\n-    /// the name of the region.\n-    name: Option<ty::Region<'tcx>>,\n+    /// True if this is a universally quantified region. This means a\n+    /// lifetime parameter that appears in the function signature (or,\n+    /// in the case of a closure, in the closure environment, which of\n+    /// course is also in the function signature).\n+    is_universal: bool,\n+\n+    /// If this is 'static or an early-bound region, then this is\n+    /// `Some(X)` where `X` is the name of the region.\n+    external_name: Option<ty::Region<'tcx>>,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -98,11 +102,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// regions defined in `universal_regions`.\n     pub fn new(\n         var_origins: VarOrigins,\n-        universal_regions: &UniversalRegions<'tcx>,\n+        universal_regions: UniversalRegions<'tcx>,\n         mir: &Mir<'tcx>,\n     ) -> Self {\n         let num_region_variables = var_origins.len();\n-        let num_universal_regions = universal_regions.indices.len();\n+        let num_universal_regions = universal_regions.len();\n \n         let mut num_points = 0;\n         let mut point_indices = BTreeMap::new();\n@@ -133,11 +137,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             inferred_values: None,\n             constraints: Vec::new(),\n             point_indices,\n-            num_universal_regions,\n-            free_region_map: universal_regions.free_region_map,\n+            universal_regions,\n         };\n \n-        result.init_universal_regions(universal_regions);\n+        result.init_universal_regions();\n \n         result\n     }\n@@ -159,25 +162,24 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///     R1 = { CFG, R0, R1 } // 'b\n     ///\n     /// Here, R0 represents `'a`, and it contains (a) the entire CFG\n-    /// and (b) any free regions that it outlives, which in this case\n-    /// is just itself. R1 (`'b`) in contrast also outlives `'a` and\n-    /// hence contains R0 and R1.\n-    fn init_universal_regions(&mut self, universal_regions: &UniversalRegions<'tcx>) {\n-        let UniversalRegions {\n-            indices,\n-            free_region_map: _,\n-        } = universal_regions;\n+    /// and (b) any universally quantified regions that it outlives,\n+    /// which in this case is just itself. R1 (`'b`) in contrast also\n+    /// outlives `'a` and hence contains R0 and R1.\n+    fn init_universal_regions(&mut self) {\n+        // Update the names (if any)\n+        for (external_name, variable) in self.universal_regions.named_universal_regions() {\n+            self.definitions[variable].external_name = Some(external_name);\n+        }\n \n         // For each universally quantified region X:\n-        for (free_region, &variable) in indices {\n+        for variable in self.universal_regions.universal_regions() {\n             // These should be free-region variables.\n             assert!(match self.definitions[variable].origin {\n                 RegionVariableOrigin::NLL(NLLRegionVariableOrigin::FreeRegion) => true,\n                 _ => false,\n             });\n \n-            // Initialize the name and a few other details.\n-            self.definitions[variable].name = Some(free_region);\n+            self.definitions[variable].is_universal = true;\n \n             // Add all nodes in the CFG to liveness constraints\n             for (_location, point_index) in &self.point_indices {\n@@ -196,6 +198,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.definitions.indices()\n     }\n \n+    /// Given a universal region in scope on the MIR, returns the\n+    /// corresponding index.\n+    ///\n+    /// (Panics if `r` is not a registered universal region.)\n+    pub fn to_region_vid(&self, r: ty::Region<'tcx>) -> RegionVid {\n+        self.universal_regions.to_region_vid(r)\n+    }\n+\n     /// Returns true if the region `r` contains the point `p`.\n     ///\n     /// Panics if called before `solve()` executes,\n@@ -237,19 +247,25 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .as_ref()\n             .expect(\"region values not yet inferred\");\n \n+        self.region_value_str_from_matrix(inferred_values, r)\n+    }\n+\n+    fn region_value_str_from_matrix(&self,\n+                                    matrix: &BitMatrix,\n+                                    r: RegionVid) -> String {\n         let mut result = String::new();\n         result.push_str(\"{\");\n         let mut sep = \"\";\n \n         for &point in self.point_indices.keys() {\n-            if self.region_contains_point_in_matrix(inferred_values, r, point) {\n+            if self.region_contains_point_in_matrix(matrix, r, point) {\n                 result.push_str(&format!(\"{}{:?}\", sep, point));\n                 sep = \", \";\n             }\n         }\n \n-        for fr in (0..self.num_universal_regions).map(RegionVid::new) {\n-            if self.region_contains_region_in_matrix(inferred_values, r, fr) {\n+        for fr in (0..self.universal_regions.len()).map(RegionVid::new) {\n+            if self.region_contains_region_in_matrix(matrix, r, fr) {\n                 result.push_str(&format!(\"{}{:?}\", sep, fr));\n                 sep = \", \";\n             }\n@@ -289,8 +305,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Perform region inference.\n-    pub(super) fn solve(&mut self, infcx: &InferCtxt<'_, '_, 'tcx>, mir: &Mir<'tcx>) {\n+    pub(super) fn solve(\n+        &mut self,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        mir_def_id: DefId,\n+    ) -> Option<ClosureRegionRequirements> {\n         assert!(self.inferred_values.is_none(), \"values already inferred\");\n+        let tcx = infcx.tcx;\n \n         // Find the minimal regions that can solve the constraints. This is infallible.\n         self.propagate_constraints(mir);\n@@ -310,57 +332,135 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         // The universal regions are always found in a prefix of the\n         // full list.\n-        let free_region_definitions = self.definitions\n+        let universal_definitions = self.definitions\n             .iter_enumerated()\n-            .take_while(|(_, fr_definition)| fr_definition.name.is_some());\n+            .take_while(|(_, fr_definition)| fr_definition.is_universal);\n+\n+        // Go through each of the universal regions `fr` and check that\n+        // they did not grow too large, accumulating any requirements\n+        // for our caller into the `outlives_requirements` vector.\n+        let mut outlives_requirements = vec![];\n+        for (fr, _) in universal_definitions {\n+            self.check_universal_region(infcx, fr, &mut outlives_requirements);\n+        }\n \n-        for (fr, fr_definition) in free_region_definitions {\n-            self.check_free_region(infcx, fr, fr_definition);\n+        // If this is not a closure, then there is no caller to which we can\n+        // \"pass the buck\". So if there are any outlives-requirements that were\n+        // not satisfied, we just have to report a hard error here.\n+        if !tcx.is_closure(mir_def_id) {\n+            for outlives_requirement in outlives_requirements {\n+                self.report_error(\n+                    infcx,\n+                    outlives_requirement.free_region,\n+                    outlives_requirement.outlived_free_region,\n+                    outlives_requirement.blame_span,\n+                );\n+            }\n+            return None;\n         }\n+\n+        let num_external_vids = self.universal_regions.num_global_and_external_regions();\n+\n+        Some(ClosureRegionRequirements {\n+            num_external_vids,\n+            outlives_requirements,\n+        })\n     }\n \n-    fn check_free_region(\n+    /// Check the final value for the free region `fr` to see if it\n+    /// grew too large. In particular, examine what `end(X)` points\n+    /// wound up in `fr`'s final value; for each `end(X)` where `X !=\n+    /// fr`, we want to check that `fr: X`. If not, that's either an\n+    /// error, or something we have to propagate to our creator.\n+    ///\n+    /// Things that are to be propagated are accumulated into the\n+    /// `outlives_requirements` vector.\n+    fn check_universal_region(\n         &self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         longer_fr: RegionVid,\n-        longer_definition: &RegionDefinition<'tcx>,\n+        outlives_requirements: &mut Vec<ClosureOutlivesRequirement>,\n     ) {\n         let inferred_values = self.inferred_values.as_ref().unwrap();\n-        let longer_name = longer_definition.name.unwrap();\n         let longer_value = inferred_values.iter(longer_fr.index());\n \n-        // Find every region `shorter` such that `longer: shorter`\n-        // (because `longer` includes `end(shorter)`).\n-        for shorter_fr in longer_value.take_while(|&i| i < self.num_universal_regions) {\n-            let shorter_fr = RegionVid::new(shorter_fr);\n+        debug!(\"check_universal_region(fr={:?})\", longer_fr);\n \n-            // `fr` includes `end(fr)`, that's not especially\n-            // interesting.\n-            if longer_fr == shorter_fr {\n+        // Find every region `o` such that `fr: o`\n+        // (because `fr` includes `end(o)`).\n+        let shorter_frs = longer_value\n+            .take_while(|&i| i < self.universal_regions.len())\n+            .map(RegionVid::new);\n+        for shorter_fr in shorter_frs {\n+            // If it is known that `fr: o`, carry on.\n+            if self.universal_regions.outlives(longer_fr, shorter_fr) {\n                 continue;\n             }\n \n-            let shorter_definition = &self.definitions[shorter_fr];\n-            let shorter_name = shorter_definition.name.unwrap();\n-\n-            // Check that `o <= fr`. If not, report an error.\n-            if !self.free_region_map\n-                .sub_free_regions(shorter_name, longer_name)\n-            {\n-                // FIXME: worst error msg ever\n-                let blame_span = self.blame_span(longer_fr, shorter_fr);\n-                infcx.tcx.sess.span_err(\n-                    blame_span,\n-                    &format!(\n-                        \"free region `{}` does not outlive `{}`\",\n-                        longer_name,\n-                        shorter_name\n-                    ),\n+            debug!(\n+                \"check_universal_region: fr={:?} does not outlive shorter_fr={:?}\",\n+                longer_fr,\n+                shorter_fr,\n+            );\n+\n+            let blame_span = self.blame_span(longer_fr, shorter_fr);\n+\n+            // Shrink `fr` until we find a non-local region (if we do).\n+            // We'll call that `fr-` -- it's ever so slightly smaller than `fr`.\n+            if let Some(fr_minus) = self.universal_regions.non_local_lower_bound(longer_fr) {\n+                debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n+\n+                // Grow `shorter_fr` until we find a non-local\n+                // regon. (We always will.)  We'll call that\n+                // `shorter_fr+` -- it's ever so slightly larger than\n+                // `fr`.\n+                let shorter_fr_plus = self.universal_regions.non_local_upper_bound(shorter_fr);\n+                debug!(\n+                    \"check_universal_region: shorter_fr_plus={:?}\",\n+                    shorter_fr_plus\n                 );\n+\n+                // Push the constraint `fr-: shorter_fr+`\n+                outlives_requirements.push(ClosureOutlivesRequirement {\n+                    free_region: fr_minus,\n+                    outlived_free_region: shorter_fr_plus,\n+                    blame_span: blame_span,\n+                });\n+                return;\n             }\n+\n+            // If we could not shrink `fr` to something smaller that\n+            // the external users care about, then we can't pass the\n+            // buck; just report an error.\n+            self.report_error(infcx, longer_fr, shorter_fr, blame_span);\n         }\n     }\n \n+    fn report_error(\n+        &self,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        fr: RegionVid,\n+        outlived_fr: RegionVid,\n+        blame_span: Span,\n+    ) {\n+        // Obviously uncool error reporting.\n+\n+        let fr_string = match self.definitions[fr].external_name {\n+            Some(r) => format!(\"free region `{}`\", r),\n+            None => format!(\"free region `{:?}`\", fr),\n+        };\n+\n+        let outlived_fr_string = match self.definitions[outlived_fr].external_name {\n+            Some(r) => format!(\"free region `{}`\", r),\n+            None => format!(\"free region `{:?}`\", outlived_fr),\n+        };\n+\n+        infcx.tcx.sess.span_err(\n+            blame_span,\n+            &format!(\"{} does not outlive {}\", fr_string, outlived_fr_string,),\n+        );\n+    }\n+\n     /// Propagate the region constraints: this will grow the values\n     /// for each region variable until all the constraints are\n     /// satisfied. Note that some values may grow **too** large to be\n@@ -421,8 +521,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         stack.push(start_point);\n         while let Some(p) = stack.pop() {\n-            debug!(\"        copy: p={:?}\", p);\n-\n             if !self.region_contains_point_in_matrix(inferred_values, from_region, p) {\n                 debug!(\"            not in from-region\");\n                 continue;\n@@ -464,7 +562,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // and make sure they are included in the `to_region`.\n                 let universal_region_indices = inferred_values\n                     .iter(from_region.index())\n-                    .take_while(|&i| i < self.num_universal_regions)\n+                    .take_while(|&i| i < self.universal_regions.len())\n                     .collect::<Vec<_>>();\n                 for fr in &universal_region_indices {\n                     changed |= inferred_values.add(to_region.index(), *fr);\n@@ -535,7 +633,11 @@ impl<'tcx> RegionDefinition<'tcx> {\n         // Create a new region definition. Note that, for free\n         // regions, these fields get updated later in\n         // `init_universal_regions`.\n-        Self { origin, name: None }\n+        Self {\n+            origin,\n+            is_universal: false,\n+            external_name: None,\n+        }\n     }\n }\n \n@@ -551,3 +653,70 @@ impl fmt::Debug for Constraint {\n         )\n     }\n }\n+\n+pub trait ClosureRegionRequirementsExt {\n+    fn apply_requirements<'tcx>(\n+        &self,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        location: Location,\n+        closure_def_id: DefId,\n+        closure_substs: ty::ClosureSubsts<'tcx>,\n+    );\n+}\n+\n+impl ClosureRegionRequirementsExt for ClosureRegionRequirements {\n+    /// Given an instance T of the closure type, this method\n+    /// instantiates the \"extra\" requirements that we computed for the\n+    /// closure into the inference context. This has the effect of\n+    /// adding new subregion obligations to existing variables.\n+    ///\n+    /// As described on `ClosureRegionRequirements`, the extra\n+    /// requirements are expressed in terms of regionvids that index\n+    /// into the free regions that appear on the closure type. So, to\n+    /// do this, we first copy those regions out from the type T into\n+    /// a vector. Then we can just index into that vector to extract\n+    /// out the corresponding region from T and apply the\n+    /// requirements.\n+    fn apply_requirements<'tcx>(\n+        &self,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        location: Location,\n+        closure_def_id: DefId,\n+        closure_substs: ty::ClosureSubsts<'tcx>,\n+    ) {\n+        let tcx = infcx.tcx;\n+\n+        debug!(\n+            \"apply_requirements(location={:?}, closure_def_id={:?}, closure_substs={:?})\",\n+            location,\n+            closure_def_id,\n+            closure_substs\n+        );\n+\n+        // Get Tu.\n+        let user_closure_ty = tcx.mk_closure(closure_def_id, closure_substs);\n+        debug!(\"apply_requirements: user_closure_ty={:?}\", user_closure_ty);\n+\n+        // Extract the values of the free regions in `user_closure_ty`\n+        // into a vector.  These are the regions that we will be\n+        // relating to one another.\n+        let closure_mapping =\n+            UniversalRegions::closure_mapping(infcx, user_closure_ty, self.num_external_vids);\n+        debug!(\"apply_requirements: closure_mapping={:?}\", closure_mapping);\n+\n+        // Create the predicates.\n+        for outlives_requirement in &self.outlives_requirements {\n+            let region = closure_mapping[outlives_requirement.free_region];\n+            let outlived_region = closure_mapping[outlives_requirement.outlived_free_region];\n+            debug!(\n+                \"apply_requirements: region={:?} outlived_region={:?} outlives_requirements={:?}\",\n+                region,\n+                outlived_region,\n+                outlives_requirement\n+            );\n+            // FIXME, this origin is not entirely suitable.\n+            let origin = SubregionOrigin::CallRcvr(outlives_requirement.blame_span);\n+            infcx.sub_regions(origin, outlived_region, region);\n+        }\n+    }\n+}"}, {"sha": "1262c238a132cee55492a3b281fdc8b38c22784e", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 28, "deletions": 33, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=ab1c1bc6bc18b70818206e7f07ac5133239607ff", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::indexed_vec::Idx;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, ClosureSubsts, RegionVid, Ty, TypeFoldable};\n+use rustc::ty::{self, ClosureSubsts, Ty, TypeFoldable};\n use rustc::mir::{BasicBlock, Local, Location, Mir, Statement, StatementKind};\n+use rustc::mir::RETURN_PLACE;\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n \n@@ -25,34 +26,31 @@ pub fn renumber_mir<'a, 'gcx, 'tcx>(\n     universal_regions: &UniversalRegions<'tcx>,\n     mir: &mut Mir<'tcx>,\n ) {\n-    // Create inference variables for each of the free regions\n-    // declared on the function signature.\n-    let free_region_inference_vars = (0..universal_regions.indices.len())\n-        .map(RegionVid::new)\n-        .map(|vid_expected| {\n-            let r = infcx.next_nll_region_var(NLLRegionVariableOrigin::FreeRegion);\n-            assert_eq!(vid_expected, r.to_region_vid());\n-            r\n-        })\n-        .collect();\n-\n     debug!(\"renumber_mir()\");\n-    debug!(\"renumber_mir: universal_regions={:#?}\", universal_regions);\n     debug!(\"renumber_mir: mir.arg_count={:?}\", mir.arg_count);\n \n+    // Update the return type and types of the arguments based on the\n+    // `universal_regions` computation.\n+    debug!(\"renumber_mir: output_ty={:?}\", universal_regions.output_ty);\n+    mir.local_decls[RETURN_PLACE].ty = universal_regions.output_ty;\n+    for (&input_ty, local) in universal_regions\n+        .input_tys\n+        .iter()\n+        .zip((1..).map(Local::new))\n+    {\n+        debug!(\"renumber_mir: input_ty={:?} local={:?}\", input_ty, local);\n+        mir.local_decls[local].ty = input_ty;\n+    }\n+\n     let mut visitor = NLLVisitor {\n         infcx,\n-        universal_regions,\n-        free_region_inference_vars,\n         arg_count: mir.arg_count,\n     };\n     visitor.visit_mir(mir);\n }\n \n struct NLLVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    universal_regions: &'a UniversalRegions<'tcx>,\n-    free_region_inference_vars: IndexVec<RegionVid, ty::Region<'tcx>>,\n     arg_count: usize,\n }\n \n@@ -74,20 +72,17 @@ impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n             })\n     }\n \n-    /// Renumbers the regions appearing in `value`, but those regions\n-    /// are expected to be free regions from the function signature.\n-    fn renumber_universal_regions<T>(&mut self, value: &T) -> T\n+    /// Checks that all the regions appearing in `value` have already\n+    /// been renumbered. `FreeRegions` code should have done this.\n+    fn assert_free_regions_are_renumbered<T>(&self, value: &T)\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        debug!(\"renumber_universal_regions(value={:?})\", value);\n+        debug!(\"assert_free_regions_are_renumbered(value={:?})\", value);\n \n-        self.infcx\n-            .tcx\n-            .fold_regions(value, &mut false, |region, _depth| {\n-                let index = self.universal_regions.indices[&region];\n-                self.free_region_inference_vars[index]\n-            })\n+        self.infcx.tcx.for_each_free_region(value, |region| {\n+            region.to_region_vid(); // will panic if `region` is not renumbered\n+        });\n     }\n \n     fn is_argument_or_return_slot(&self, local: Local) -> bool {\n@@ -110,12 +105,12 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n             ty_context\n         );\n \n-        let old_ty = *ty;\n-        *ty = if is_arg {\n-            self.renumber_universal_regions(&old_ty)\n+        if is_arg {\n+            self.assert_free_regions_are_renumbered(ty);\n         } else {\n-            self.renumber_regions(ty_context, &old_ty)\n-        };\n+            *ty = self.renumber_regions(ty_context, ty);\n+        }\n+\n         debug!(\"visit_ty: ty={:?}\", ty);\n     }\n "}, {"sha": "c98a94fa8bc106b20a35d25102adec0aba6a435c", "filename": "src/librustc_mir/borrow_check/nll/subtype_constraint_generation.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs?ref=ab1c1bc6bc18b70818206e7f07ac5133239607ff", "patch": "@@ -15,7 +15,6 @@ use rustc::ty;\n use transform::type_check::MirTypeckRegionConstraints;\n use transform::type_check::OutlivesSet;\n \n-use super::universal_regions::UniversalRegions;\n use super::region_infer::RegionInferenceContext;\n \n /// When the MIR type-checker executes, it validates all the types in\n@@ -25,20 +24,17 @@ use super::region_infer::RegionInferenceContext;\n /// them into the NLL `RegionInferenceContext`.\n pub(super) fn generate<'tcx>(\n     regioncx: &mut RegionInferenceContext<'tcx>,\n-    universal_regions: &UniversalRegions<'tcx>,\n     mir: &Mir<'tcx>,\n     constraints: &MirTypeckRegionConstraints<'tcx>,\n ) {\n     SubtypeConstraintGenerator {\n         regioncx,\n-        universal_regions,\n         mir,\n     }.generate(constraints);\n }\n \n struct SubtypeConstraintGenerator<'cx, 'tcx: 'cx> {\n     regioncx: &'cx mut RegionInferenceContext<'tcx>,\n-    universal_regions: &'cx UniversalRegions<'tcx>,\n     mir: &'cx Mir<'tcx>,\n }\n \n@@ -106,10 +102,7 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n         if let ty::ReVar(vid) = r {\n             *vid\n         } else {\n-            *self.universal_regions\n-                 .indices\n-                 .get(&r)\n-                 .unwrap_or_else(|| bug!(\"to_region_vid: bad region {:?}\", r))\n+            self.regioncx.to_region_vid(r)\n         }\n     }\n }"}, {"sha": "35c50f941907ab20cc27f8bf5a9181e314b0af6d", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 648, "deletions": 46, "changes": 694, "blob_url": "https://github.com/rust-lang/rust/blob/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=ab1c1bc6bc18b70818206e7f07ac5133239607ff", "patch": "@@ -22,69 +22,671 @@\n //! The code in this file doesn't *do anything* with those results; it\n //! just returns them for other code to use.\n \n+use rustc::hir::HirId;\n use rustc::hir::def_id::DefId;\n-use rustc::infer::InferCtxt;\n-use rustc::infer::outlives::free_region_map::FreeRegionMap;\n-use rustc::ty::{self, RegionVid};\n+use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n+use rustc::infer::region_constraints::GenericKind;\n+use rustc::infer::outlives::bounds::{self, OutlivesBound};\n+use rustc::ty::{self, RegionVid, Ty, TyCtxt};\n+use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n use rustc::util::nodemap::FxHashMap;\n-use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::transitive_relation::TransitiveRelation;\n+use std::iter;\n+use syntax::ast;\n+\n+use super::ToRegionVid;\n \n #[derive(Debug)]\n pub struct UniversalRegions<'tcx> {\n-    /// Given a universally quantified region defined on this function\n-    /// (either early- or late-bound), this maps it to its internal\n-    /// region index. When the region context is created, the first N\n-    /// variables will be created based on these indices.\n-    pub indices: FxHashMap<ty::Region<'tcx>, RegionVid>,\n-\n-    /// The map from the typeck tables telling us how to relate universal regions.\n-    pub free_region_map: &'tcx FreeRegionMap<'tcx>,\n+    indices: UniversalRegionIndices<'tcx>,\n+\n+    /// The vid assigned to `'static`\n+    pub fr_static: RegionVid,\n+\n+    /// We create region variables such that they are ordered by their\n+    /// `RegionClassification`. The first block are globals, then\n+    /// externals, then locals. So things from:\n+    /// - `FIRST_GLOBAL_INDEX..first_extern_index` are global;\n+    /// - `first_extern_index..first_local_index` are external; and\n+    /// - first_local_index..num_universals` are local.\n+    first_extern_index: usize,\n+\n+    /// See `first_extern_index`.\n+    first_local_index: usize,\n+\n+    /// The total number of universal region variables instantiated.\n+    num_universals: usize,\n+\n+    /// The \"defining\" type for this function, with all universal\n+    /// regions instantiated.  For a closure or generator, this is the\n+    /// closure type, but for a top-level function it's the `TyFnDef`.\n+    pub defining_ty: Ty<'tcx>,\n+\n+    /// The return type of this function, with all regions replaced\n+    /// by their universal `RegionVid` equivalents.\n+    pub output_ty: Ty<'tcx>,\n+\n+    /// The fully liberated input types of this function, with all\n+    /// regions replaced by their universal `RegionVid` equivalents.\n+    pub input_tys: &'tcx [Ty<'tcx>],\n+\n+    /// Each RBP `('a, GK)` indicates that `GK: 'a` can be assumed to\n+    /// be true. These encode relationships like `T: 'a` that are\n+    /// added via implicit bounds.\n+    ///\n+    /// Each region here is guaranteed to be a key in the `indices`\n+    /// map.  We use the \"original\" regions (i.e., the keys from the\n+    /// map, and not the values) because the code in\n+    /// `process_registered_region_obligations` has some special-cased\n+    /// logic expecting to see (e.g.) `ReStatic`, and if we supplied\n+    /// our special inference variable there, we would mess that up.\n+    pub region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n+\n+    relations: UniversalRegionRelations,\n+}\n+\n+#[derive(Debug)]\n+struct UniversalRegionIndices<'tcx> {\n+    /// For those regions that may appear in the parameter environment\n+    /// ('static and early-bound regions), we maintain a map from the\n+    /// `ty::Region` to the internal `RegionVid` we are using. This is\n+    /// used because trait matching and type-checking will feed us\n+    /// region constraints that reference those regions and we need to\n+    /// be able to map them our internal `RegionVid`. This is\n+    /// basically equivalent to a `Substs`, except that it also\n+    /// contains an entry for `ReStatic` -- it might be nice to just\n+    /// use a substs, and then handle `ReStatic` another way.\n+    indices: FxHashMap<ty::Region<'tcx>, RegionVid>,\n+}\n+\n+#[derive(Debug)]\n+struct UniversalRegionRelations {\n+    /// Stores the outlives relations that are known to hold from the\n+    /// implied bounds, in-scope where clauses, and that sort of\n+    /// thing.\n+    outlives: TransitiveRelation<RegionVid>,\n+\n+    /// This is the `<=` relation; that is, if `a: b`, then `b <= a`,\n+    /// and we store that here. This is useful when figuring out how\n+    /// to express some local region in terms of external regions our\n+    /// caller will understand.\n+    inverse_outlives: TransitiveRelation<RegionVid>,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum RegionClassification {\n+    /// A **global** region is one that can be named from\n+    /// anywhere. There is only one, `'static`.\n+    Global,\n+\n+    /// An **external** region is only relevant for closures. In that\n+    /// case, it refers to regions that are free in the closure type\n+    /// -- basically, something bound in the surrounding context.\n+    ///\n+    /// Consider this example:\n+    ///\n+    /// ```\n+    /// fn foo<'a, 'b>(a: &'a u32, b: &'b u32, c: &'static u32) {\n+    ///   let closure = for<'x> |x: &'x u32| { .. };\n+    ///                 ^^^^^^^ pretend this were legal syntax\n+    ///                         for declaring a late-bound region in\n+    ///                         a closure signature\n+    /// }\n+    /// ```\n+    ///\n+    /// Here, the lifetimes `'a` and `'b` would be **external** to the\n+    /// closure.\n+    ///\n+    /// If we are not analyzing a closure, there are no external\n+    /// lifetimes.\n+    External,\n+\n+    /// A **local** lifetime is one about which we know the full set\n+    /// of relevant constraints (that is, relationships to other named\n+    /// regions).  For a closure, this includes any region bound in\n+    /// the closure's signature.  For a fn item, this includes all\n+    /// regions other than global ones.\n+    ///\n+    /// Continuing with the example from `External`, if we were\n+    /// analyzing the closure, then `'x` would be local (and `'a` and\n+    /// `'b` are external).  If we are analyzing the function item\n+    /// `foo`, then `'a` and `'b` are local (and `'x` is not in\n+    /// scope).\n+    Local,\n }\n \n-pub fn universal_regions<'a, 'gcx, 'tcx>(\n-    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-    item_def_id: DefId,\n-) -> UniversalRegions<'tcx> {\n-    debug!(\"universal_regions(item_def_id={:?})\", item_def_id);\n+const FIRST_GLOBAL_INDEX: usize = 0;\n+\n+impl<'tcx> UniversalRegions<'tcx> {\n+    /// Creates a new and fully initialized `UniversalRegions` that\n+    /// contains indices for all the free regions found in the given\n+    /// MIR -- that is, all the regions that appear in the function's\n+    /// signature. This will also compute the relationships that are\n+    /// known between those regions.\n+    pub fn new(\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        mir_def_id: DefId,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Self {\n+        let tcx = infcx.tcx;\n+        let mir_node_id = tcx.hir.as_local_node_id(mir_def_id).unwrap();\n+        let mir_hir_id = tcx.hir.node_to_hir_id(mir_node_id);\n+        UniversalRegionsBuilder {\n+            infcx,\n+            mir_def_id,\n+            mir_node_id,\n+            mir_hir_id,\n+            param_env,\n+            region_bound_pairs: vec![],\n+            relations: UniversalRegionRelations {\n+                outlives: TransitiveRelation::new(),\n+                inverse_outlives: TransitiveRelation::new(),\n+            },\n+        }.build()\n+    }\n+\n+    /// Given a reference to a closure type, extracts all the values\n+    /// from its free regions and returns a vector with them. This is\n+    /// used when the closure's creator checks that the\n+    /// `ClosureRegionRequirements` are met. The requirements from\n+    /// `ClosureRegionRequirements` are expressed in terms of\n+    /// `RegionVid` entries that map into the returned vector `V`: so\n+    /// if the `ClosureRegionRequirements` contains something like\n+    /// `'1: '2`, then the caller would impose the constraint that\n+    /// `V[1]: V[2]`.\n+    pub fn closure_mapping(\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        closure_ty: Ty<'tcx>,\n+        expected_num_vars: usize,\n+    ) -> IndexVec<RegionVid, ty::Region<'tcx>> {\n+        let mut region_mapping = IndexVec::with_capacity(expected_num_vars);\n+        region_mapping.push(infcx.tcx.types.re_static);\n+        infcx.tcx.for_each_free_region(&closure_ty, |fr| {\n+            region_mapping.push(fr);\n+        });\n+\n+        assert_eq!(\n+            region_mapping.len(),\n+            expected_num_vars,\n+            \"index vec had unexpected number of variables\"\n+        );\n \n-    let mut indices = FxHashMap();\n+        region_mapping\n+    }\n \n-    // `'static` is always free.\n-    insert_free_region(&mut indices, infcx.tcx.types.re_static);\n+    /// True if `r` is a member of this set of universal regions.\n+    pub fn is_universal_region(&self, r: RegionVid) -> bool {\n+        (FIRST_GLOBAL_INDEX..self.num_universals).contains(r.index())\n+    }\n \n-    // Extract the early regions.\n-    let item_substs = Substs::identity_for_item(infcx.tcx, item_def_id);\n-    for item_subst in item_substs {\n-        if let Some(region) = item_subst.as_region() {\n-            insert_free_region(&mut indices, region);\n+    /// Classifies `r` as a universal region, returning `None` if this\n+    /// is not a member of this set of universal regions.\n+    pub fn region_classification(&self, r: RegionVid) -> Option<RegionClassification> {\n+        let index = r.index();\n+        if (FIRST_GLOBAL_INDEX..self.first_extern_index).contains(index) {\n+            Some(RegionClassification::Global)\n+        } else if (self.first_extern_index..self.first_local_index).contains(index) {\n+            Some(RegionClassification::External)\n+        } else if (self.first_local_index..self.num_universals).contains(index) {\n+            Some(RegionClassification::Local)\n+        } else {\n+            None\n         }\n     }\n \n-    // Extract the late-bound regions. Use the liberated fn sigs,\n-    // where the late-bound regions will have been converted into free\n-    // regions, and add them to the map.\n-    let item_id = infcx.tcx.hir.as_local_node_id(item_def_id).unwrap();\n-    let fn_hir_id = infcx.tcx.hir.node_to_hir_id(item_id);\n-    let tables = infcx.tcx.typeck_tables_of(item_def_id);\n-    let fn_sig = tables.liberated_fn_sigs()[fn_hir_id].clone();\n-    infcx\n-        .tcx\n-        .for_each_free_region(&fn_sig.inputs_and_output, |region| {\n-            if let ty::ReFree(_) = *region {\n-                insert_free_region(&mut indices, region);\n+    /// Returns an iterator over all the RegionVids corresponding to\n+    /// universally quantified free regions.\n+    pub fn universal_regions(&self) -> impl Iterator<Item = RegionVid> {\n+        (FIRST_GLOBAL_INDEX..self.num_universals).map(RegionVid::new)\n+    }\n+\n+    /// True if `r` is classied as a global region.\n+    pub fn is_global_free_region(&self, r: RegionVid) -> bool {\n+        self.region_classification(r) == Some(RegionClassification::Global)\n+    }\n+\n+    /// True if `r` is classied as an external region.\n+    pub fn is_extern_free_region(&self, r: RegionVid) -> bool {\n+        self.region_classification(r) == Some(RegionClassification::External)\n+    }\n+\n+    /// True if `r` is classied as an local region.\n+    pub fn is_local_free_region(&self, r: RegionVid) -> bool {\n+        self.region_classification(r) == Some(RegionClassification::Local)\n+    }\n+\n+    /// Returns the number of universal regions created in any category.\n+    pub fn len(&self) -> usize {\n+        self.num_universals\n+    }\n+\n+    /// Finds an \"upper bound\" for `fr` that is not local. In other\n+    /// words, returns the smallest (*) known region `fr1` that (a)\n+    /// outlives `fr` and (b) is not local. This cannot fail, because\n+    /// we will always find `'static` at worst.\n+    ///\n+    /// (*) If there are multiple competing choices, we pick the \"postdominating\"\n+    /// one. See `TransitiveRelation::postdom_upper_bound` for details.\n+    pub fn non_local_upper_bound(&self, fr: RegionVid) -> RegionVid {\n+        debug!(\"non_local_upper_bound(fr={:?})\", fr);\n+        self.non_local_bound(&self.relations.inverse_outlives, fr)\n+            .unwrap_or(self.fr_static)\n+    }\n+\n+    /// Finds a \"lower bound\" for `fr` that is not local. In other\n+    /// words, returns the largest (*) known region `fr1` that (a) is\n+    /// outlived by `fr` and (b) is not local. This cannot fail,\n+    /// because we will always find `'static` at worst.\n+    ///\n+    /// (*) If there are multiple competing choices, we pick the \"postdominating\"\n+    /// one. See `TransitiveRelation::postdom_upper_bound` for details.\n+    pub fn non_local_lower_bound(&self, fr: RegionVid) -> Option<RegionVid> {\n+        debug!(\"non_local_lower_bound(fr={:?})\", fr);\n+        self.non_local_bound(&self.relations.outlives, fr)\n+    }\n+\n+    /// Returns the number of global plus external universal regions.\n+    /// For closures, these are the regions that appear free in the\n+    /// closure type (versus those bound in the closure\n+    /// signature). They are therefore the regions between which the\n+    /// closure may impose constraints that its creator must verify.\n+    pub fn num_global_and_external_regions(&self) -> usize {\n+        self.first_local_index\n+    }\n+\n+    /// Helper for `non_local_upper_bound` and\n+    /// `non_local_lower_bound`.  Repeatedly invokes `postdom_parent`\n+    /// until we find something that is not local. Returns None if we\n+    /// never do so.\n+    fn non_local_bound(\n+        &self,\n+        relation: &TransitiveRelation<RegionVid>,\n+        fr0: RegionVid,\n+    ) -> Option<RegionVid> {\n+        let mut external_parents = vec![];\n+        let mut queue = vec![&fr0];\n+\n+        // Keep expanding `fr` into its parents until we reach\n+        // non-local regions.\n+        while let Some(fr) = queue.pop() {\n+            if !self.is_local_free_region(*fr) {\n+                external_parents.push(fr);\n+                continue;\n             }\n-        });\n \n-    debug!(\"universal_regions: indices={:#?}\", indices);\n+            queue.extend(relation.parents(fr));\n+        }\n+\n+        debug!(\"non_local_bound: external_parents={:?}\", external_parents);\n+\n+        // In case we find more than one, reduce to one for\n+        // convenience.  This is to prevent us from generating more\n+        // complex constraints, but it will cause spurious errors.\n+        let post_dom = relation\n+            .mutual_immediate_postdominator(external_parents)\n+            .cloned();\n+\n+        debug!(\"non_local_bound: post_dom={:?}\", post_dom);\n+\n+        post_dom.and_then(|post_dom| {\n+            // If the mutual immediate postdom is not local, then\n+            // there is no non-local result we can return.\n+            if !self.is_local_free_region(post_dom) {\n+                Some(post_dom)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    /// True if fr1 is known to outlive fr2.\n+    ///\n+    /// This will only ever be true for universally quantified regions.\n+    pub fn outlives(&self, fr1: RegionVid, fr2: RegionVid) -> bool {\n+        self.relations.outlives.contains(&fr1, &fr2)\n+    }\n+\n+    /// Returns a vector of free regions `x` such that `fr1: x` is\n+    /// known to hold.\n+    pub fn regions_outlived_by(&self, fr1: RegionVid) -> Vec<&RegionVid> {\n+        self.relations.outlives.reachable_from(&fr1)\n+    }\n+\n+    /// Get an iterator over all the early-bound regions that have names.\n+    pub fn named_universal_regions<'s>(\n+        &'s self,\n+    ) -> impl Iterator<Item = (ty::Region<'tcx>, ty::RegionVid)> + 's {\n+        self.indices.indices.iter().map(|(&r, &v)| (r, v))\n+    }\n+\n+    /// See `UniversalRegionIndices::to_region_vid`.\n+    pub fn to_region_vid(&self, r: ty::Region<'tcx>) -> RegionVid {\n+        self.indices.to_region_vid(r)\n+    }\n+}\n+\n+struct UniversalRegionsBuilder<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+    mir_def_id: DefId,\n+    mir_hir_id: HirId,\n+    mir_node_id: ast::NodeId,\n+    param_env: ty::ParamEnv<'tcx>,\n+    region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n+    relations: UniversalRegionRelations,\n+}\n+\n+const FR: NLLRegionVariableOrigin = NLLRegionVariableOrigin::FreeRegion;\n+\n+impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n+    fn build(mut self) -> UniversalRegions<'tcx> {\n+        let param_env = self.param_env;\n+\n+        assert_eq!(FIRST_GLOBAL_INDEX, self.infcx.num_region_vars());\n+\n+        // Create the \"global\" region that is always free in all contexts: 'static.\n+        let fr_static = self.infcx.next_nll_region_var(FR).to_region_vid();\n+\n+        // We've now added all the global regions. The next ones we\n+        // add will be external.\n+        let first_extern_index = self.infcx.num_region_vars();\n+\n+        let defining_ty = self.defining_ty();\n+\n+        let indices = self.compute_indices(fr_static, defining_ty);\n+\n+        let bound_inputs_and_output = self.compute_inputs_and_output(&indices, defining_ty);\n+\n+        // \"Liberate\" the late-bound regions. These correspond to\n+        // \"local\" free regions.\n+        let first_local_index = self.infcx.num_region_vars();\n+        let inputs_and_output = self.infcx\n+            .replace_bound_regions_with_nll_infer_vars(FR, &bound_inputs_and_output);\n+        let num_universals = self.infcx.num_region_vars();\n+\n+        // Insert the facts we know from the predicates. Why? Why not.\n+        self.add_outlives_bounds(&indices, bounds::explicit_outlives_bounds(param_env));\n+\n+        // Add the implied bounds from inputs and outputs.\n+        for ty in inputs_and_output {\n+            self.add_implied_bounds(&indices, ty);\n+        }\n+\n+        // Finally, outlives is reflexive, and static outlives every\n+        // other free region.\n+        for fr in (FIRST_GLOBAL_INDEX..num_universals).map(RegionVid::new) {\n+            self.relations.relate_universal_regions(fr, fr);\n+            self.relations.relate_universal_regions(fr_static, fr);\n+        }\n+\n+        let (output_ty, input_tys) = inputs_and_output.split_last().unwrap();\n+\n+        // we should not have created any more variables\n+        assert_eq!(self.infcx.num_region_vars(), num_universals);\n+\n+        debug!(\"build: global regions = {}..{}\",\n+               FIRST_GLOBAL_INDEX,\n+               first_extern_index);\n+        debug!(\"build: extern regions = {}..{}\",\n+               first_extern_index,\n+               first_local_index);\n+        debug!(\"build: local regions  = {}..{}\",\n+               first_local_index,\n+               num_universals);\n+\n+        UniversalRegions {\n+            indices,\n+            fr_static,\n+            first_extern_index,\n+            first_local_index,\n+            num_universals,\n+            defining_ty,\n+            output_ty,\n+            input_tys,\n+            region_bound_pairs: self.region_bound_pairs,\n+            relations: self.relations,\n+        }\n+    }\n+\n+    fn defining_ty(&self) -> ty::Ty<'tcx> {\n+        let tcx = self.infcx.tcx;\n+        let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n+\n+        let defining_ty = if self.mir_def_id == closure_base_def_id {\n+            tcx.type_of(closure_base_def_id)\n+        } else {\n+            let tables = tcx.typeck_tables_of(self.mir_def_id);\n+            tables.node_id_to_type(self.mir_hir_id)\n+        };\n+\n+        self.infcx\n+            .replace_free_regions_with_nll_infer_vars(FR, &defining_ty)\n+    }\n+\n+    fn compute_indices(\n+        &self,\n+        fr_static: RegionVid,\n+        defining_ty: Ty<'tcx>,\n+    ) -> UniversalRegionIndices<'tcx> {\n+        let tcx = self.infcx.tcx;\n+        let gcx = tcx.global_tcx();\n+        let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n+        let identity_substs = Substs::identity_for_item(gcx, closure_base_def_id);\n+        let fr_substs = match defining_ty.sty {\n+            ty::TyClosure(_, substs) | ty::TyGenerator(_, substs, ..) => {\n+                // In the case of closures, we rely on the fact that\n+                // the first N elements in the ClosureSubsts are\n+                // inherited from the `closure_base_def_id`.\n+                // Therefore, when we zip together (below) with\n+                // `identity_substs`, we will get only those regions\n+                // that correspond to early-bound regions declared on\n+                // the `closure_base_def_id`.\n+                assert!(substs.substs.len() >= identity_substs.len());\n+                substs.substs\n+            }\n+            ty::TyFnDef(_, substs) => substs,\n+            _ => bug!(),\n+        };\n+\n+        let global_mapping = iter::once((gcx.types.re_static, fr_static));\n+        let subst_mapping = identity_substs\n+            .regions()\n+            .zip(fr_substs.regions().map(|r| r.to_region_vid()));\n+\n+        UniversalRegionIndices {\n+            indices: global_mapping.chain(subst_mapping).collect(),\n+        }\n+    }\n+\n+    fn compute_inputs_and_output(\n+        &self,\n+        indices: &UniversalRegionIndices<'tcx>,\n+        defining_ty: Ty<'tcx>,\n+    ) -> ty::Binder<&'tcx ty::Slice<Ty<'tcx>>> {\n+        let tcx = self.infcx.tcx;\n+        match defining_ty.sty {\n+            ty::TyClosure(def_id, substs) => {\n+                assert_eq!(self.mir_def_id, def_id);\n+                let closure_sig = substs.closure_sig_ty(def_id, tcx).fn_sig(tcx);\n+                let inputs_and_output = closure_sig.inputs_and_output();\n+                let closure_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n+                ty::Binder::fuse(\n+                    closure_ty,\n+                    inputs_and_output,\n+                    |closure_ty, inputs_and_output| {\n+                        // The \"inputs\" of the closure in the\n+                        // signature appear as a tuple.  The MIR side\n+                        // flattens this tuple.\n+                        let (&output, tuplized_inputs) = inputs_and_output.split_last().unwrap();\n+                        assert_eq!(tuplized_inputs.len(), 1, \"multiple closure inputs\");\n+                        let inputs = match tuplized_inputs[0].sty {\n+                            ty::TyTuple(inputs, _) => inputs,\n+                            _ => bug!(\"closure inputs not a tuple: {:?}\", tuplized_inputs[0]),\n+                        };\n \n-    UniversalRegions { indices, free_region_map: &tables.free_region_map }\n+                        tcx.mk_type_list(\n+                            iter::once(closure_ty)\n+                                .chain(inputs.iter().cloned())\n+                                .chain(iter::once(output)),\n+                        )\n+                    },\n+                )\n+            }\n+\n+            ty::TyGenerator(def_id, substs, ..) => {\n+                assert_eq!(self.mir_def_id, def_id);\n+                let output = substs.generator_return_ty(def_id, tcx);\n+                let inputs_and_output = self.infcx.tcx.intern_type_list(&[defining_ty, output]);\n+                ty::Binder::new_not_binding(inputs_and_output)\n+            }\n+\n+            ty::TyFnDef(def_id, _) => {\n+                let sig = tcx.fn_sig(def_id);\n+                let sig = indices.fold_to_region_vids(tcx, &sig);\n+                return sig.inputs_and_output();\n+            }\n+\n+            _ => span_bug!(\n+                tcx.def_span(self.mir_def_id),\n+                \"unexpected defining type: {:?}\",\n+                defining_ty\n+            ),\n+        }\n+    }\n+\n+    /// Update the type of a single local, which should represent\n+    /// either the return type of the MIR or one of its arguments. At\n+    /// the same time, compute and add any implied bounds that come\n+    /// from this local.\n+    ///\n+    /// Assumes that `universal_regions` indices map is fully constructed.\n+    fn add_implied_bounds(&mut self, indices: &UniversalRegionIndices<'tcx>, ty: Ty<'tcx>) {\n+        let span = self.infcx.tcx.def_span(self.mir_def_id);\n+        let bounds = self.infcx\n+            .implied_outlives_bounds(self.param_env, self.mir_node_id, ty, span);\n+        self.add_outlives_bounds(indices, bounds);\n+    }\n+\n+    /// Registers the `OutlivesBound` items from `outlives_bounds` in\n+    /// the outlives relation as well as the region-bound pairs\n+    /// listing.\n+    fn add_outlives_bounds<I>(&mut self, indices: &UniversalRegionIndices<'tcx>, outlives_bounds: I)\n+    where\n+        I: IntoIterator<Item = OutlivesBound<'tcx>>,\n+    {\n+        for outlives_bound in outlives_bounds {\n+            match outlives_bound {\n+                OutlivesBound::RegionSubRegion(r1, r2) => {\n+                    // The bound says that `r1 <= r2`; we store `r2: r1`.\n+                    let r1 = indices.to_region_vid(r1);\n+                    let r2 = indices.to_region_vid(r2);\n+                    self.relations.relate_universal_regions(r2, r1);\n+                }\n+\n+                OutlivesBound::RegionSubParam(r_a, param_b) => {\n+                    self.region_bound_pairs\n+                        .push((r_a, GenericKind::Param(param_b)));\n+                }\n+\n+                OutlivesBound::RegionSubProjection(r_a, projection_b) => {\n+                    self.region_bound_pairs\n+                        .push((r_a, GenericKind::Projection(projection_b)));\n+                }\n+            }\n+        }\n+    }\n }\n \n-fn insert_free_region<'tcx>(\n-    universal_regions: &mut FxHashMap<ty::Region<'tcx>, RegionVid>,\n-    region: ty::Region<'tcx>,\n-) {\n-    let next = RegionVid::new(universal_regions.len());\n-    universal_regions.entry(region).or_insert(next);\n+impl UniversalRegionRelations {\n+    /// Records in the `outlives_relation` (and\n+    /// `inverse_outlives_relation`) that `fr_a: fr_b`.\n+    fn relate_universal_regions(&mut self, fr_a: RegionVid, fr_b: RegionVid) {\n+        debug!(\n+            \"relate_universal_regions: fr_a={:?} outlives fr_b={:?}\",\n+            fr_a,\n+            fr_b\n+        );\n+        self.outlives.add(fr_a, fr_b);\n+        self.inverse_outlives.add(fr_b, fr_a);\n+    }\n+}\n+\n+pub(crate) trait InferCtxtExt<'tcx> {\n+    fn replace_free_regions_with_nll_infer_vars<T>(\n+        &self,\n+        origin: NLLRegionVariableOrigin,\n+        value: &T,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>;\n+\n+    fn replace_bound_regions_with_nll_infer_vars<T>(\n+        &self,\n+        origin: NLLRegionVariableOrigin,\n+        value: &ty::Binder<T>,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>;\n+}\n+\n+impl<'cx, 'gcx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'gcx, 'tcx> {\n+    fn replace_free_regions_with_nll_infer_vars<T>(\n+        &self,\n+        origin: NLLRegionVariableOrigin,\n+        value: &T,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        self.tcx.fold_regions(\n+            value,\n+            &mut false,\n+            |_region, _depth| self.next_nll_region_var(origin),\n+        )\n+    }\n+\n+    fn replace_bound_regions_with_nll_infer_vars<T>(\n+        &self,\n+        origin: NLLRegionVariableOrigin,\n+        value: &ty::Binder<T>,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        let (value, _map) = self.tcx\n+            .replace_late_bound_regions(value, |_br| self.next_nll_region_var(origin));\n+        value\n+    }\n+}\n+\n+impl<'tcx> UniversalRegionIndices<'tcx> {\n+    /// Converts `r` into a local inference variable: `r` can either\n+    /// by a `ReVar` (i.e., already a reference to an inference\n+    /// variable) or it can be `'static` or some early-bound\n+    /// region. This is useful when taking the results from\n+    /// type-checking and trait-matching, which may sometimes\n+    /// reference those regions from the `ParamEnv`. It is also used\n+    /// during initialization. Relies on the `indices` map having been\n+    /// fully initialized.\n+    pub fn to_region_vid(&self, r: ty::Region<'tcx>) -> RegionVid {\n+        match r {\n+            ty::ReEarlyBound(..) | ty::ReStatic => *self.indices.get(&r).unwrap(),\n+            ty::ReVar(..) => r.to_region_vid(),\n+            _ => bug!(\"cannot convert `{:?}` to a region vid\", r),\n+        }\n+    }\n+\n+    /// Replace all free regions in `value` with region vids, as\n+    /// returned by `to_region_vid`.\n+    pub fn fold_to_region_vids<T>(&self, tcx: TyCtxt<'_, '_, 'tcx>, value: &T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        tcx.fold_regions(\n+            value,\n+            &mut false,\n+            |region, _| tcx.mk_region(ty::ReVar(self.to_region_vid(region))),\n+        )\n+    }\n }"}, {"sha": "1a74f32700151c55e4567839372010801456b14b", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab1c1bc6bc18b70818206e7f07ac5133239607ff/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=ab1c1bc6bc18b70818206e7f07ac5133239607ff", "patch": "@@ -11,6 +11,7 @@\n //! This pass type-checks the MIR to ensure it is not broken.\n #![allow(unreachable_code)]\n \n+use borrow_check::nll::region_infer::ClosureRegionRequirementsExt;\n use rustc::infer::{InferCtxt, InferOk, InferResult, LateBoundRegionConversionTime, UnitResult};\n use rustc::infer::region_constraints::RegionConstraintData;\n use rustc::traits::{self, FulfillmentContext};\n@@ -1135,14 +1136,45 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         operands: &[Operand<'tcx>],\n         location: Location,\n     ) {\n+        let tcx = self.tcx();\n+\n         match aggregate_kind {\n             // tuple rvalue field type is always the type of the op. Nothing to check here.\n             AggregateKind::Tuple => return,\n+\n+            // For closures, we have some **extra requirements** we\n+            // have to check. In particular, in their upvars and\n+            // signatures, closures often reference various regions\n+            // from the surrounding function -- we call those the\n+            // closure's free regions. When we borrow-check (and hence\n+            // region-check) closures, we may find that the closure\n+            // requires certain relationships between those free\n+            // regions. However, because those free regions refer to\n+            // portions of the CFG of their caller, the closure is not\n+            // in a position to verify those relationships. In that\n+            // case, the requirements get \"propagated\" to us, and so\n+            // we have to solve them here where we instantiate the\n+            // closure.\n+            //\n+            // Despite the opacity of the previous parapgrah, this is\n+            // actually relatively easy to understand in terms of the\n+            // desugaring. A closure gets desugared to a struct, and\n+            // these extra requirements are basically like where\n+            // clauses on the struct.\n+            AggregateKind::Closure(def_id, substs) => {\n+                if let Some(closure_region_requirements) = tcx.mir_borrowck(*def_id) {\n+                    closure_region_requirements.apply_requirements(\n+                        self.infcx,\n+                        location,\n+                        *def_id,\n+                        *substs,\n+                    );\n+                }\n+            }\n+\n             _ => {}\n         }\n \n-        let tcx = self.tcx();\n-\n         for (i, operand) in operands.iter().enumerate() {\n             let field_ty = match self.aggregate_field_ty(aggregate_kind, i, location) {\n                 Ok(field_ty) => field_ty,"}]}