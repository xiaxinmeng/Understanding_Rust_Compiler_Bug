{"sha": "5156b3a6cd1c60982f0bea9f3b7243f66cab9bb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxNTZiM2E2Y2QxYzYwOTgyZjBiZWE5ZjNiNzI0M2Y2NmNhYjliYjU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-04-09T18:46:03Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-04-10T10:11:28Z"}, "message": "Modify the codemap code to use more slices and to information about\ncolumns within a line, not just the line numbers. Also try to clarify\nand use the term `line_index` when 0-based.", "tree": {"sha": "75d8cda2da3841c27d31cabc5cbc287c8f5d8b86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75d8cda2da3841c27d31cabc5cbc287c8f5d8b86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5156b3a6cd1c60982f0bea9f3b7243f66cab9bb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5156b3a6cd1c60982f0bea9f3b7243f66cab9bb5", "html_url": "https://github.com/rust-lang/rust/commit/5156b3a6cd1c60982f0bea9f3b7243f66cab9bb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5156b3a6cd1c60982f0bea9f3b7243f66cab9bb5/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16574e3fbdddb7ad453f01c6a8b7f8f2f3b3cbb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/16574e3fbdddb7ad453f01c6a8b7f8f2f3b3cbb0", "html_url": "https://github.com/rust-lang/rust/commit/16574e3fbdddb7ad453f01c6a8b7f8f2f3b3cbb0"}], "stats": {"total": 173, "additions": 133, "deletions": 40}, "files": [{"sha": "7635c8eadc26efab0fb7fce588aa10d33c04daba", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 92, "deletions": 13, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/5156b3a6cd1c60982f0bea9f3b7243f66cab9bb5/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5156b3a6cd1c60982f0bea9f3b7243f66cab9bb5/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=5156b3a6cd1c60982f0bea9f3b7243f66cab9bb5", "patch": "@@ -49,7 +49,7 @@ pub struct BytePos(pub u32);\n /// A character offset. Because of multibyte utf8 characters, a byte offset\n /// is not equivalent to a character offset. The CodeMap will convert BytePos\n /// values to CharPos values as necessary.\n-#[derive(Copy, Clone, PartialEq, Hash, PartialOrd, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Debug)]\n pub struct CharPos(pub usize);\n \n // FIXME: Lots of boilerplate in these impls, but so far my attempts to fix\n@@ -305,9 +305,21 @@ impl ExpnId {\n \n pub type FileName = String;\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub struct LineInfo {\n+    /// Index of line, starting from 0.\n+    pub line_index: usize,\n+\n+    /// Column in line where span begins, starting from 0.\n+    pub start_col: CharPos,\n+\n+    /// Column in line where span ends, starting from 0, exclusive.\n+    pub end_col: CharPos,\n+}\n+\n pub struct FileLines {\n     pub file: Rc<FileMap>,\n-    pub lines: Vec<usize>\n+    pub lines: Vec<LineInfo>\n }\n \n /// Identifies an offset of a multi-byte character in a FileMap\n@@ -479,9 +491,9 @@ impl FileMap {\n         lines.push(pos);\n     }\n \n-    /// get a line from the list of pre-computed line-beginnings\n-    ///\n-    pub fn get_line(&self, line_number: usize) -> Option<String> {\n+    /// get a line from the list of pre-computed line-beginnings.\n+    /// line-number here is 0-based.\n+    pub fn get_line(&self, line_number: usize) -> Option<&str> {\n         match self.src {\n             Some(ref src) => {\n                 let lines = self.lines.borrow();\n@@ -492,7 +504,7 @@ impl FileMap {\n                     match slice.find('\\n') {\n                         Some(e) => &slice[..e],\n                         None => slice\n-                    }.to_string()\n+                    }\n                 })\n             }\n             None => None\n@@ -661,10 +673,29 @@ impl CodeMap {\n     pub fn span_to_lines(&self, sp: Span) -> FileLines {\n         let lo = self.lookup_char_pos(sp.lo);\n         let hi = self.lookup_char_pos(sp.hi);\n-        let mut lines = Vec::new();\n-        for i in lo.line - 1..hi.line {\n-            lines.push(i);\n-        };\n+        let mut lines = Vec::with_capacity(hi.line - lo.line + 1);\n+\n+        // The span starts partway through the first line,\n+        // but after that it starts from offset 0.\n+        let mut start_col = lo.col;\n+\n+        // For every line but the last, it extends from `start_col`\n+        // and to the end of the line. Be careful because the line\n+        // numbers in Loc are 1-based, so we subtract 1 to get 0-based\n+        // lines.\n+        for line_index in lo.line-1 .. hi.line-1 {\n+            let line_len = lo.file.get_line(line_index).map(|s| s.len()).unwrap_or(0);\n+            lines.push(LineInfo { line_index: line_index,\n+                                  start_col: start_col,\n+                                  end_col: CharPos::from_usize(line_len) });\n+            start_col = CharPos::from_usize(0);\n+        }\n+\n+        // For the last line, it extends from `start_col` to `hi.col`:\n+        lines.push(LineInfo { line_index: hi.line - 1,\n+                              start_col: start_col,\n+                              end_col: hi.col });\n+\n         FileLines {file: lo.file, lines: lines}\n     }\n \n@@ -919,17 +950,18 @@ pub struct MalformedCodemapPositions {\n #[cfg(test)]\n mod test {\n     use super::*;\n+    use std::rc::Rc;\n \n     #[test]\n     fn t1 () {\n         let cm = CodeMap::new();\n         let fm = cm.new_filemap(\"blork.rs\".to_string(),\n                                 \"first line.\\nsecond line\".to_string());\n         fm.next_line(BytePos(0));\n-        assert_eq!(fm.get_line(0), Some(\"first line.\".to_string()));\n+        assert_eq!(fm.get_line(0), Some(\"first line.\"));\n         // TESTING BROKEN BEHAVIOR:\n         fm.next_line(BytePos(10));\n-        assert_eq!(fm.get_line(1), Some(\".\".to_string()));\n+        assert_eq!(fm.get_line(1), Some(\".\"));\n     }\n \n     #[test]\n@@ -1057,7 +1089,54 @@ mod test {\n \n         assert_eq!(file_lines.file.name, \"blork.rs\");\n         assert_eq!(file_lines.lines.len(), 1);\n-        assert_eq!(file_lines.lines[0], 1);\n+        assert_eq!(file_lines.lines[0].line_index, 1);\n+    }\n+\n+    /// Given a string like \" ^~~~~~~~~~~~ \", produces a span\n+    /// coverting that range. The idea is that the string has the same\n+    /// length as the input, and we uncover the byte positions.  Note\n+    /// that this can span lines and so on.\n+    fn span_from_selection(input: &str, selection: &str) -> Span {\n+        assert_eq!(input.len(), selection.len());\n+        let left_index = selection.find('^').unwrap() as u32;\n+        let right_index = selection.rfind('~').unwrap() as u32;\n+        Span { lo: BytePos(left_index), hi: BytePos(right_index + 1), expn_id: NO_EXPANSION }\n+    }\n+\n+    fn new_filemap_and_lines(cm: &CodeMap, filename: &str, input: &str) -> Rc<FileMap> {\n+        let fm = cm.new_filemap(filename.to_string(), input.to_string());\n+        let mut byte_pos: u32 = 0;\n+        for line in input.lines() {\n+            // register the start of this line\n+            fm.next_line(BytePos(byte_pos));\n+\n+            // update byte_pos to include this line and the \\n at the end\n+            byte_pos += line.len() as u32 + 1;\n+        }\n+        fm\n+    }\n+\n+    /// Test span_to_snippet and span_to_lines for a span coverting 3\n+    /// lines in the middle of a file.\n+    #[test]\n+    fn span_to_snippet_and_lines_spanning_multiple_lines() {\n+        let cm = CodeMap::new();\n+        let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n+        let selection = \"     \\n    ^~\\n~~~\\n~~~~~     \\n   \\n\";\n+        new_filemap_and_lines(&cm, \"blork.rs\", inputtext);\n+        let span = span_from_selection(inputtext, selection);\n+\n+        // check that we are extracting the text we thought we were extracting\n+        assert_eq!(&cm.span_to_snippet(span).unwrap(), \"BB\\nCCC\\nDDDDD\");\n+\n+        // check that span_to_lines gives us the complete result with the lines/cols we expected\n+        let lines = cm.span_to_lines(span);\n+        let expected = vec![\n+            LineInfo { line_index: 1, start_col: CharPos(4), end_col: CharPos(6) },\n+            LineInfo { line_index: 2, start_col: CharPos(0), end_col: CharPos(3) },\n+            LineInfo { line_index: 3, start_col: CharPos(0), end_col: CharPos(5) }\n+            ];\n+        assert_eq!(lines.lines, expected);\n     }\n \n     #[test]"}, {"sha": "32509ba6065103ef30c77b0392c8ece5372549ac", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 41, "deletions": 27, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/5156b3a6cd1c60982f0bea9f3b7243f66cab9bb5/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5156b3a6cd1c60982f0bea9f3b7243f66cab9bb5/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=5156b3a6cd1c60982f0bea9f3b7243f66cab9bb5", "patch": "@@ -483,25 +483,39 @@ fn highlight_lines(err: &mut EmitterWriter,\n                    cm: &codemap::CodeMap,\n                    sp: Span,\n                    lvl: Level,\n-                   lines: codemap::FileLines) -> io::Result<()> {\n+                   lines: codemap::FileLines)\n+                   -> io::Result<()>\n+{\n     let fm = &*lines.file;\n \n-    let mut elided = false;\n-    let mut display_lines = &lines.lines[..];\n-    if display_lines.len() > MAX_LINES {\n-        display_lines = &display_lines[0..MAX_LINES];\n-        elided = true;\n-    }\n+    let line_strings: Option<Vec<&str>> =\n+        lines.lines.iter()\n+                   .map(|info| fm.get_line(info.line_index))\n+                   .collect();\n+\n+    let line_strings = match line_strings {\n+        None => { return Ok(()); }\n+        Some(line_strings) => line_strings\n+    };\n+\n+    // Display only the first MAX_LINES lines.\n+    let all_lines = lines.lines.len();\n+    let display_lines = cmp::min(all_lines, MAX_LINES);\n+    let display_line_infos = &lines.lines[..display_lines];\n+    let display_line_strings = &line_strings[..display_lines];\n+\n     // Print the offending lines\n-    for &line_number in display_lines {\n-        if let Some(line) = fm.get_line(line_number) {\n-            try!(write!(&mut err.dst, \"{}:{} {}\\n\", fm.name,\n-                        line_number + 1, line));\n-        }\n+    for (line_info, line) in display_line_infos.iter().zip(display_line_strings.iter()) {\n+        try!(write!(&mut err.dst, \"{}:{} {}\\n\",\n+                    fm.name,\n+                    line_info.line_index + 1,\n+                    line));\n     }\n-    if elided {\n-        let last_line = display_lines[display_lines.len() - 1];\n-        let s = format!(\"{}:{} \", fm.name, last_line + 1);\n+\n+    // If we elided something, put an ellipsis.\n+    if display_lines < all_lines {\n+        let last_line_index = display_line_infos.last().unwrap().line_index;\n+        let s = format!(\"{}:{} \", fm.name, last_line_index + 1);\n         try!(write!(&mut err.dst, \"{0:1$}...\\n\", \"\", s.len()));\n     }\n \n@@ -510,7 +524,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n     if lines.lines.len() == 1 {\n         let lo = cm.lookup_char_pos(sp.lo);\n         let mut digits = 0;\n-        let mut num = (lines.lines[0] + 1) / 10;\n+        let mut num = (lines.lines[0].line_index + 1) / 10;\n \n         // how many digits must be indent past?\n         while num > 0 { num /= 10; digits += 1; }\n@@ -522,7 +536,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n         for _ in 0..skip {\n             s.push(' ');\n         }\n-        if let Some(orig) = fm.get_line(lines.lines[0]) {\n+        if let Some(orig) = fm.get_line(lines.lines[0].line_index) {\n             let mut col = skip;\n             let mut lastc = ' ';\n             let mut iter = orig.chars().enumerate();\n@@ -597,32 +611,32 @@ fn end_highlight_lines(w: &mut EmitterWriter,\n \n     let lines = &lines.lines[..];\n     if lines.len() > MAX_LINES {\n-        if let Some(line) = fm.get_line(lines[0]) {\n+        if let Some(line) = fm.get_line(lines[0].line_index) {\n             try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n-                        lines[0] + 1, line));\n+                        lines[0].line_index + 1, line));\n         }\n         try!(write!(&mut w.dst, \"...\\n\"));\n-        let last_line_number = lines[lines.len() - 1];\n-        if let Some(last_line) = fm.get_line(last_line_number) {\n+        let last_line_index = lines[lines.len() - 1].line_index;\n+        if let Some(last_line) = fm.get_line(last_line_index) {\n             try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n-                        last_line_number + 1, last_line));\n+                        last_line_index + 1, last_line));\n         }\n     } else {\n-        for &line_number in lines {\n-            if let Some(line) = fm.get_line(line_number) {\n+        for line_info in lines {\n+            if let Some(line) = fm.get_line(line_info.line_index) {\n                 try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n-                            line_number + 1, line));\n+                            line_info.line_index + 1, line));\n             }\n         }\n     }\n-    let last_line_start = format!(\"{}:{} \", fm.name, lines[lines.len()-1]+1);\n+    let last_line_start = format!(\"{}:{} \", fm.name, lines[lines.len()-1].line_index + 1);\n     let hi = cm.lookup_char_pos(sp.hi);\n     let skip = last_line_start.width(false);\n     let mut s = String::new();\n     for _ in 0..skip {\n         s.push(' ');\n     }\n-    if let Some(orig) = fm.get_line(lines[0]) {\n+    if let Some(orig) = fm.get_line(lines[0].line_index) {\n         let iter = orig.chars().enumerate();\n         for (pos, ch) in iter {\n             // Span seems to use half-opened interval, so subtract 1"}]}