{"sha": "c4c94151321b8018ceb06ccff359109b8fed6bfe", "node_id": "C_kwDOAAsO6NoAKGM0Yzk0MTUxMzIxYjgwMThjZWIwNmNjZmYzNTkxMDliOGZlZDZiZmU", "commit": {"author": {"name": "mejrs", "email": "", "date": "2022-09-25T22:55:35Z"}, "committer": {"name": "mejrs", "email": "", "date": "2022-09-27T19:42:09Z"}, "message": "Wrapper suggestions", "tree": {"sha": "e9572b4e96cee41a8934626b50b98e22305b19c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9572b4e96cee41a8934626b50b98e22305b19c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4c94151321b8018ceb06ccff359109b8fed6bfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4c94151321b8018ceb06ccff359109b8fed6bfe", "html_url": "https://github.com/rust-lang/rust/commit/c4c94151321b8018ceb06ccff359109b8fed6bfe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4c94151321b8018ceb06ccff359109b8fed6bfe/comments", "author": {}, "committer": {}, "parents": [{"sha": "57ee5cf5a93923dae9c98bffb11545fc3a31368d", "url": "https://api.github.com/repos/rust-lang/rust/commits/57ee5cf5a93923dae9c98bffb11545fc3a31368d", "html_url": "https://github.com/rust-lang/rust/commit/57ee5cf5a93923dae9c98bffb11545fc3a31368d"}], "stats": {"total": 383, "additions": 316, "deletions": 67}, "files": [{"sha": "1ff2575bcc5dd3e1ffd08ffbcb39b1e80c88e93e", "filename": "compiler/rustc_hir_analysis/src/check/method/suggest.rs", "status": "modified", "additions": 146, "deletions": 67, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/c4c94151321b8018ceb06ccff359109b8fed6bfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4c94151321b8018ceb06ccff359109b8fed6bfe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=c4c94151321b8018ceb06ccff359109b8fed6bfe", "patch": "@@ -2,6 +2,7 @@\n //! found or is otherwise invalid.\n \n use crate::check::FnCtxt;\n+use rustc_ast::ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{\n     pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n@@ -30,7 +31,7 @@ use rustc_trait_selection::traits::{\n use std::cmp::Ordering;\n use std::iter;\n \n-use super::probe::{IsSuggestion, Mode, ProbeScope};\n+use super::probe::{AutorefOrPtrAdjustment, IsSuggestion, Mode, ProbeScope};\n use super::{CandidateSource, MethodError, NoMatchData};\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -983,7 +984,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.check_for_field_method(&mut err, source, span, actual, item_name);\n                 }\n \n-                self.check_for_unwrap_self(&mut err, source, span, actual, item_name);\n+                self.check_for_inner_self(&mut err, source, span, actual, item_name);\n \n                 bound_spans.sort();\n                 bound_spans.dedup();\n@@ -1395,7 +1396,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_for_unwrap_self(\n+    fn check_for_inner_self(\n         &self,\n         err: &mut Diagnostic,\n         source: SelfSource<'tcx>,\n@@ -1408,81 +1409,159 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let call_expr = tcx.hir().expect_expr(tcx.hir().get_parent_node(expr.hir_id));\n \n         let ty::Adt(kind, substs) = actual.kind() else { return; };\n-        if !kind.is_enum() {\n-            return;\n-        }\n+        match kind.adt_kind() {\n+            ty::AdtKind::Enum => {\n+                let matching_variants: Vec<_> = kind\n+                    .variants()\n+                    .iter()\n+                    .flat_map(|variant| {\n+                        let [field] = &variant.fields[..] else { return None; };\n+                        let field_ty = field.ty(tcx, substs);\n+\n+                        // Skip `_`, since that'll just lead to ambiguity.\n+                        if self.resolve_vars_if_possible(field_ty).is_ty_var() {\n+                            return None;\n+                        }\n \n-        let matching_variants: Vec<_> = kind\n-            .variants()\n-            .iter()\n-            .flat_map(|variant| {\n-                let [field] = &variant.fields[..] else { return None; };\n-                let field_ty = field.ty(tcx, substs);\n+                        self.lookup_probe(\n+                            span,\n+                            item_name,\n+                            field_ty,\n+                            call_expr,\n+                            ProbeScope::AllTraits,\n+                        )\n+                        .ok()\n+                        .map(|pick| (variant, field, pick))\n+                    })\n+                    .collect();\n+\n+                let ret_ty_matches = |diagnostic_item| {\n+                    if let Some(ret_ty) = self\n+                        .ret_coercion\n+                        .as_ref()\n+                        .map(|c| self.resolve_vars_if_possible(c.borrow().expected_ty()))\n+                        && let ty::Adt(kind, _) = ret_ty.kind()\n+                        && tcx.get_diagnostic_item(diagnostic_item) == Some(kind.did())\n+                    {\n+                        true\n+                    } else {\n+                        false\n+                    }\n+                };\n \n-                // Skip `_`, since that'll just lead to ambiguity.\n-                if self.resolve_vars_if_possible(field_ty).is_ty_var() {\n-                    return None;\n+                match &matching_variants[..] {\n+                    [(_, field, pick)] => {\n+                        let self_ty = field.ty(tcx, substs);\n+                        err.span_note(\n+                            tcx.def_span(pick.item.def_id),\n+                            &format!(\"the method `{item_name}` exists on the type `{self_ty}`\"),\n+                        );\n+                        let (article, kind, variant, question) =\n+                            if tcx.is_diagnostic_item(sym::Result, kind.did()) {\n+                                (\"a\", \"Result\", \"Err\", ret_ty_matches(sym::Result))\n+                            } else if tcx.is_diagnostic_item(sym::Option, kind.did()) {\n+                                (\"an\", \"Option\", \"None\", ret_ty_matches(sym::Option))\n+                            } else {\n+                                return;\n+                            };\n+                        if question {\n+                            err.span_suggestion_verbose(\n+                                expr.span.shrink_to_hi(),\n+                                format!(\n+                                    \"use the `?` operator to extract the `{self_ty}` value, propagating \\\n+                                    {article} `{kind}::{variant}` value to the caller\"\n+                                ),\n+                                \"?\",\n+                                Applicability::MachineApplicable,\n+                            );\n+                        } else {\n+                            err.span_suggestion_verbose(\n+                                expr.span.shrink_to_hi(),\n+                                format!(\n+                                    \"consider using `{kind}::expect` to unwrap the `{self_ty}` value, \\\n+                                    panicking if the value is {article} `{kind}::{variant}`\"\n+                                ),\n+                                \".expect(\\\"REASON\\\")\",\n+                                Applicability::HasPlaceholders,\n+                            );\n+                        }\n+                    }\n+                    // FIXME(compiler-errors): Support suggestions for other matching enum variants\n+                    _ => {}\n                 }\n-\n-                self.lookup_probe(span, item_name, field_ty, call_expr, ProbeScope::AllTraits)\n-                    .ok()\n-                    .map(|pick| (variant, field, pick))\n-            })\n-            .collect();\n-\n-        let ret_ty_matches = |diagnostic_item| {\n-            if let Some(ret_ty) = self\n-                .ret_coercion\n-                .as_ref()\n-                .map(|c| self.resolve_vars_if_possible(c.borrow().expected_ty()))\n-                && let ty::Adt(kind, _) = ret_ty.kind()\n-                && tcx.get_diagnostic_item(diagnostic_item) == Some(kind.did())\n-            {\n-                true\n-            } else {\n-                false\n             }\n-        };\n-\n-        match &matching_variants[..] {\n-            [(_, field, pick)] => {\n-                let self_ty = field.ty(tcx, substs);\n-                err.span_note(\n-                    tcx.def_span(pick.item.def_id),\n-                    &format!(\"the method `{item_name}` exists on the type `{self_ty}`\"),\n-                );\n-                let (article, kind, variant, question) =\n-                    if Some(kind.did()) == tcx.get_diagnostic_item(sym::Result) {\n-                        (\"a\", \"Result\", \"Err\", ret_ty_matches(sym::Result))\n-                    } else if Some(kind.did()) == tcx.get_diagnostic_item(sym::Option) {\n-                        (\"an\", \"Option\", \"None\", ret_ty_matches(sym::Option))\n-                    } else {\n-                        return;\n-                    };\n-                if question {\n+            // Target wrapper types - types that wrap or pretend to wrap another type,\n+            // perhaps this inner type is meant to be called?\n+            ty::AdtKind::Struct | ty::AdtKind::Union => {\n+                let [first] = ***substs else { return; };\n+                let ty::GenericArgKind::Type(ty) = first.unpack() else { return; };\n+                let Ok(pick) = self.lookup_probe(\n+                            span,\n+                            item_name,\n+                            ty,\n+                            call_expr,\n+                            ProbeScope::AllTraits,\n+                        )  else { return; };\n+\n+                let name = self.ty_to_value_string(actual);\n+                let inner_id = kind.did();\n+\n+                if tcx.is_diagnostic_item(sym::LocalKey, inner_id) {\n+                    err.help(\"use `with` or `try_with` to access the contents of threadlocals\");\n+                } else if Some(kind.did()) == tcx.lang_items().maybe_uninit() {\n+                    err.help(format!(\n+                        \"if this `{name}` has been initialized, \\\n+                        use one of the `assume_init` methods to access the inner value\"\n+                    ));\n+                } else if tcx.is_diagnostic_item(sym::RefCell, inner_id) {\n+                    match pick.autoref_or_ptr_adjustment {\n+                        Some(AutorefOrPtrAdjustment::Autoref {\n+                            mutbl: Mutability::Not, ..\n+                        }) => {\n+                            err.span_suggestion_verbose(\n+                                expr.span.shrink_to_hi(),\n+                                format!(\n+                                    \"use `.borrow()` to borrow the {ty}, \\\n+                                panicking if any outstanding mutable borrows exist.\"\n+                                ),\n+                                \".borrow()\",\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                        Some(AutorefOrPtrAdjustment::Autoref {\n+                            mutbl: Mutability::Mut, ..\n+                        }) => {\n+                            err.span_suggestion_verbose(\n+                                expr.span.shrink_to_hi(),\n+                                format!(\n+                                    \"use `.borrow_mut()` to mutably borrow the {ty}, \\\n+                                panicking if any outstanding borrows exist.\"\n+                                ),\n+                                \".borrow_mut()\",\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                        _ => return,\n+                    }\n+                } else if tcx.is_diagnostic_item(sym::Mutex, inner_id) {\n                     err.span_suggestion_verbose(\n                         expr.span.shrink_to_hi(),\n                         format!(\n-                            \"use the `?` operator to extract the `{self_ty}` value, propagating \\\n-                            {article} `{kind}::{variant}` value to the caller\"\n+                            \"use `.lock()` to borrow the {ty}, \\\n+                            blocking the current thread until it can be acquired\"\n                         ),\n-                        \"?\",\n-                        Applicability::MachineApplicable,\n+                        \".lock().unwrap()\",\n+                        Applicability::MaybeIncorrect,\n                     );\n                 } else {\n-                    err.span_suggestion_verbose(\n-                        expr.span.shrink_to_hi(),\n-                        format!(\n-                            \"consider using `{kind}::expect` to unwrap the `{self_ty}` value, \\\n-                             panicking if the value is {article} `{kind}::{variant}`\"\n-                        ),\n-                        \".expect(\\\"REASON\\\")\",\n-                        Applicability::HasPlaceholders,\n-                    );\n-                }\n+                    return;\n+                };\n+\n+                err.span_note(\n+                    tcx.def_span(pick.item.def_id),\n+                    &format!(\"the method `{item_name}` exists on the type `{ty}`\"),\n+                );\n             }\n-            // FIXME(compiler-errors): Support suggestions for other matching enum variants\n-            _ => {}\n         }\n     }\n "}, {"sha": "6101c1c47e380552c934f913ddbd6dfd49c855dd", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c4c94151321b8018ceb06ccff359109b8fed6bfe/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4c94151321b8018ceb06ccff359109b8fed6bfe/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=c4c94151321b8018ceb06ccff359109b8fed6bfe", "patch": "@@ -224,6 +224,7 @@ symbols! {\n         Left,\n         LinkedList,\n         LintPass,\n+        LocalKey,\n         Mutex,\n         MutexGuard,\n         N,\n@@ -266,6 +267,7 @@ symbols! {\n         Rc,\n         Ready,\n         Receiver,\n+        RefCell,\n         Relaxed,\n         Release,\n         Result,"}, {"sha": "cf7b1b358c9404d9fd1a4cde2e902374aa2b8e21", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4c94151321b8018ceb06ccff359109b8fed6bfe/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4c94151321b8018ceb06ccff359109b8fed6bfe/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=c4c94151321b8018ceb06ccff359109b8fed6bfe", "patch": "@@ -614,6 +614,7 @@ impl<T, const N: usize> Cell<[T; N]> {\n /// A mutable memory location with dynamically checked borrow rules\n ///\n /// See the [module-level documentation](self) for more.\n+#[rustc_diagnostic_item = \"RefCell\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RefCell<T: ?Sized> {\n     borrow: Cell<BorrowFlag>,"}, {"sha": "1d728349951bfe3c3dd0545bed2dc9d78b7c9410", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c4c94151321b8018ceb06ccff359109b8fed6bfe/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4c94151321b8018ceb06ccff359109b8fed6bfe/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=c4c94151321b8018ceb06ccff359109b8fed6bfe", "patch": "@@ -95,6 +95,7 @@ use crate::fmt;\n /// [loader lock]: https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices\n /// [`JoinHandle::join`]: crate::thread::JoinHandle::join\n /// [`with`]: LocalKey::with\n+#[rustc_diagnostic_item = \"LocalKey\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct LocalKey<T: 'static> {\n     // This outer `LocalKey<T>` type is what's going to be stored in statics,"}, {"sha": "f6dc7c4ce172204f9e9a4dbdcc439cf36932d929", "filename": "src/test/ui/suggestions/inner_type.fixed", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c4c94151321b8018ceb06ccff359109b8fed6bfe/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/c4c94151321b8018ceb06ccff359109b8fed6bfe/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.fixed?ref=c4c94151321b8018ceb06ccff359109b8fed6bfe", "patch": "@@ -0,0 +1,30 @@\n+// compile-flags: --edition=2021\n+// run-rustfix\n+\n+pub struct Struct<T> {\n+    pub p: T,\n+}\n+\n+impl<T> Struct<T> {\n+    pub fn method(&self) {}\n+\n+    pub fn some_mutable_method(&mut self) {}\n+}\n+\n+fn main() {\n+    let other_item = std::cell::RefCell::new(Struct { p: 42_u32 });\n+\n+    other_item.borrow().method();\n+    //~^ ERROR no method named `method` found for struct `RefCell` in the current scope [E0599]\n+    //~| HELP use `.borrow()` to borrow the Struct<u32>, panicking if any outstanding mutable borrows exist.\n+\n+    other_item.borrow_mut().some_mutable_method();\n+    //~^ ERROR no method named `some_mutable_method` found for struct `RefCell` in the current scope [E0599]\n+    //~| HELP use `.borrow_mut()` to mutably borrow the Struct<u32>, panicking if any outstanding borrows exist.\n+\n+    let another_item = std::sync::Mutex::new(Struct { p: 42_u32 });\n+\n+    another_item.lock().unwrap().method();\n+    //~^ ERROR no method named `method` found for struct `Mutex` in the current scope [E0599]\n+    //~| HELP use `.lock()` to borrow the Struct<u32>, blocking the current thread until it can be acquired\n+}\n\\ No newline at end of file"}, {"sha": "b42067c047c04e8a8358e2033c00c016016b90da", "filename": "src/test/ui/suggestions/inner_type.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c4c94151321b8018ceb06ccff359109b8fed6bfe/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4c94151321b8018ceb06ccff359109b8fed6bfe/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.rs?ref=c4c94151321b8018ceb06ccff359109b8fed6bfe", "patch": "@@ -0,0 +1,30 @@\n+// compile-flags: --edition=2021\n+// run-rustfix\n+\n+pub struct Struct<T> {\n+    pub p: T,\n+}\n+\n+impl<T> Struct<T> {\n+    pub fn method(&self) {}\n+\n+    pub fn some_mutable_method(&mut self) {}\n+}\n+\n+fn main() {\n+    let other_item = std::cell::RefCell::new(Struct { p: 42_u32 });\n+\n+    other_item.method();\n+    //~^ ERROR no method named `method` found for struct `RefCell` in the current scope [E0599]\n+    //~| HELP use `.borrow()` to borrow the Struct<u32>, panicking if any outstanding mutable borrows exist.\n+\n+    other_item.some_mutable_method();\n+    //~^ ERROR no method named `some_mutable_method` found for struct `RefCell` in the current scope [E0599]\n+    //~| HELP use `.borrow_mut()` to mutably borrow the Struct<u32>, panicking if any outstanding borrows exist.\n+\n+    let another_item = std::sync::Mutex::new(Struct { p: 42_u32 });\n+\n+    another_item.method();\n+    //~^ ERROR no method named `method` found for struct `Mutex` in the current scope [E0599]\n+    //~| HELP use `.lock()` to borrow the Struct<u32>, blocking the current thread until it can be acquired\n+}\n\\ No newline at end of file"}, {"sha": "f2b25944c8b2dbf51b89b50132a2611ffa241615", "filename": "src/test/ui/suggestions/inner_type.stderr", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c4c94151321b8018ceb06ccff359109b8fed6bfe/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4c94151321b8018ceb06ccff359109b8fed6bfe/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finner_type.stderr?ref=c4c94151321b8018ceb06ccff359109b8fed6bfe", "patch": "@@ -0,0 +1,51 @@\n+error[E0599]: no method named `method` found for struct `RefCell` in the current scope\n+  --> $DIR/inner_type.rs:17:16\n+   |\n+LL |     other_item.method();\n+   |                ^^^^^^ method not found in `RefCell<Struct<u32>>`\n+   |\n+note: the method `method` exists on the type `Struct<u32>`\n+  --> $DIR/inner_type.rs:9:5\n+   |\n+LL |     pub fn method(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+help: use `.borrow()` to borrow the Struct<u32>, panicking if any outstanding mutable borrows exist.\n+   |\n+LL |     other_item.borrow().method();\n+   |               +++++++++\n+\n+error[E0599]: no method named `some_mutable_method` found for struct `RefCell` in the current scope\n+  --> $DIR/inner_type.rs:21:16\n+   |\n+LL |     other_item.some_mutable_method();\n+   |                ^^^^^^^^^^^^^^^^^^^ method not found in `RefCell<Struct<u32>>`\n+   |\n+note: the method `some_mutable_method` exists on the type `Struct<u32>`\n+  --> $DIR/inner_type.rs:11:5\n+   |\n+LL |     pub fn some_mutable_method(&mut self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: use `.borrow_mut()` to mutably borrow the Struct<u32>, panicking if any outstanding borrows exist.\n+   |\n+LL |     other_item.borrow_mut().some_mutable_method();\n+   |               +++++++++++++\n+\n+error[E0599]: no method named `method` found for struct `Mutex` in the current scope\n+  --> $DIR/inner_type.rs:27:18\n+   |\n+LL |     another_item.method();\n+   |                  ^^^^^^ method not found in `Mutex<Struct<u32>>`\n+   |\n+note: the method `method` exists on the type `Struct<u32>`\n+  --> $DIR/inner_type.rs:9:5\n+   |\n+LL |     pub fn method(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+help: use `.lock()` to borrow the Struct<u32>, blocking the current thread until it can be acquired\n+   |\n+LL |     another_item.lock().unwrap().method();\n+   |                 ++++++++++++++++\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "694c0adfd06c21a66582f6683eebb5b4fca95204", "filename": "src/test/ui/suggestions/inner_type2.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c4c94151321b8018ceb06ccff359109b8fed6bfe/src%2Ftest%2Fui%2Fsuggestions%2Finner_type2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4c94151321b8018ceb06ccff359109b8fed6bfe/src%2Ftest%2Fui%2Fsuggestions%2Finner_type2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finner_type2.rs?ref=c4c94151321b8018ceb06ccff359109b8fed6bfe", "patch": "@@ -0,0 +1,26 @@\n+pub struct Struct<T> {\n+    pub p: T,\n+}\n+\n+impl<T> Struct<T> {\n+    pub fn method(&self) {}\n+\n+    pub fn some_mutable_method(&mut self) {}\n+}\n+\n+thread_local! {\n+    static STRUCT: Struct<u32> = Struct {\n+        p: 42_u32\n+    };\n+}\n+\n+fn main() {\n+    STRUCT.method();\n+    //~^ ERROR no method named `method` found for struct `LocalKey` in the current scope [E0599]\n+    //~| HELP use `with` or `try_with` to access the contents of threadlocals\n+\n+    let item = std::mem::MaybeUninit::new(Struct { p: 42_u32 });\n+    item.method();\n+    //~^ ERROR no method named `method` found for union `MaybeUninit` in the current scope [E0599]\n+    //~| HELP if this `MaybeUninit::<Struct<u32>>` has been initialized, use one of the `assume_init` methods to access the inner value\n+}\n\\ No newline at end of file"}, {"sha": "40e7a7ab41e44b33ab13a27714d7b1066de79e65", "filename": "src/test/ui/suggestions/inner_type2.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c4c94151321b8018ceb06ccff359109b8fed6bfe/src%2Ftest%2Fui%2Fsuggestions%2Finner_type2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4c94151321b8018ceb06ccff359109b8fed6bfe/src%2Ftest%2Fui%2Fsuggestions%2Finner_type2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finner_type2.stderr?ref=c4c94151321b8018ceb06ccff359109b8fed6bfe", "patch": "@@ -0,0 +1,29 @@\n+error[E0599]: no method named `method` found for struct `LocalKey` in the current scope\n+  --> $DIR/inner_type2.rs:18:12\n+   |\n+LL |     STRUCT.method();\n+   |            ^^^^^^ method not found in `LocalKey<Struct<u32>>`\n+   |\n+   = help: use `with` or `try_with` to access the contents of threadlocals\n+note: the method `method` exists on the type `Struct<u32>`\n+  --> $DIR/inner_type2.rs:6:5\n+   |\n+LL |     pub fn method(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0599]: no method named `method` found for union `MaybeUninit` in the current scope\n+  --> $DIR/inner_type2.rs:23:10\n+   |\n+LL |     item.method();\n+   |          ^^^^^^ method not found in `MaybeUninit<Struct<u32>>`\n+   |\n+   = help: if this `MaybeUninit::<Struct<u32>>` has been initialized, use one of the `assume_init` methods to access the inner value\n+note: the method `method` exists on the type `Struct<u32>`\n+  --> $DIR/inner_type2.rs:6:5\n+   |\n+LL |     pub fn method(&self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}]}