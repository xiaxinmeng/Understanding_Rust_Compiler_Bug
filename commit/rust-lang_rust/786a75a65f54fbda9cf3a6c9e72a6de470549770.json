{"sha": "786a75a65f54fbda9cf3a6c9e72a6de470549770", "node_id": "C_kwDOAAsO6NoAKDc4NmE3NWE2NWY1NGZiZGE5Y2YzYTZjOWU3MmE2ZGU0NzA1NDk3NzA", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-02-26T11:04:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-26T11:04:59Z"}, "message": "Rollup merge of #108418 - est31:parser_function_names, r=Nilstrieb\n\nReplace parse_[sth]_expr with parse_expr_[sth] function names\n\nThis resolves an inconsistency in naming style for functions on the parser, where:\n\n* functions parsing specific kinds of items are named `parse_item_[sth]` and\n* functions parsing specific kinds of *expressions* are named `parse_[sth]_expr`\n\nfavoring the style used by functions for items. There are multiple advantages of that style:\n\n* functions of both categories are collected in the same place in the [rustdoc output](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_parse/parser/struct.Parser.html).\n* it helps with autocompletion, as you can narrow down your search for a function to those about expressions.\n* it mirrors rust's path syntax where less specific things come first, then it gets more specific, i.e. `std::collections::hash_map::Entry`.\n\nThe disadvantage is that it doesn't \"read like a sentence\" any more. But I think the advantages weigh more greatly.\n\nThis change was mostly application of this command:\n\n```\nsed -i -E 's/(fn |\\.)parse_([[:alnum:]_]+)_expr/\\1parse_expr_\\2/' compiler/rustc_parse/src/parser/*.rs\n```\n\nPlus very minor fixes outside of `rustc_parse`, and an invocation of `x fmt`.", "tree": {"sha": "6db855c50d9068c375e4067882aeef93536308d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6db855c50d9068c375e4067882aeef93536308d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/786a75a65f54fbda9cf3a6c9e72a6de470549770", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj+zzbCRBK7hj4Ov3rIwAA2fkIACqEQ0P5f6cuPoIqQeRTAM31\nRdu3s7HWo2zzvHOshz48TfzWzpBC3XHjEitYzeWfOkIKQAsQGens7OgkEF9wmejq\n4dozSrBKTim685YSJyygWdkRxK9ngdxlXPJmFv+VSzNsN6NkfxBKIj4eBg1XJcfP\nqOkNTSp26i3dRMQ7Ib9OMktZ70CKI6F2qfM75WjLT/LE17q9Zr/AQFjUFMjkLLkH\nmKuGd7wN0abXubrjX4BCmDGnZ3Hkwbnfsfp9F+X2HYru30uUM6DShIPyS3GeQCM+\n2+DHeQ3V3TGpgN5uX2gACTx7ilef/0fM5EFxNcVncvIIwSYPChrjTqfRM7VmZxQ=\n=Xp0O\n-----END PGP SIGNATURE-----\n", "payload": "tree 6db855c50d9068c375e4067882aeef93536308d7\nparent 19b8685b061402a0b4b459a01eb224726a9a54ed\nparent 28501166367ac12ac11fcf4bb06261e2c8139988\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1677409499 +0100\ncommitter GitHub <noreply@github.com> 1677409499 +0100\n\nRollup merge of #108418 - est31:parser_function_names, r=Nilstrieb\n\nReplace parse_[sth]_expr with parse_expr_[sth] function names\n\nThis resolves an inconsistency in naming style for functions on the parser, where:\n\n* functions parsing specific kinds of items are named `parse_item_[sth]` and\n* functions parsing specific kinds of *expressions* are named `parse_[sth]_expr`\n\nfavoring the style used by functions for items. There are multiple advantages of that style:\n\n* functions of both categories are collected in the same place in the [rustdoc output](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_parse/parser/struct.Parser.html).\n* it helps with autocompletion, as you can narrow down your search for a function to those about expressions.\n* it mirrors rust's path syntax where less specific things come first, then it gets more specific, i.e. `std::collections::hash_map::Entry`.\n\nThe disadvantage is that it doesn't \"read like a sentence\" any more. But I think the advantages weigh more greatly.\n\nThis change was mostly application of this command:\n\n```\nsed -i -E 's/(fn |\\.)parse_([[:alnum:]_]+)_expr/\\1parse_expr_\\2/' compiler/rustc_parse/src/parser/*.rs\n```\n\nPlus very minor fixes outside of `rustc_parse`, and an invocation of `x fmt`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/786a75a65f54fbda9cf3a6c9e72a6de470549770", "html_url": "https://github.com/rust-lang/rust/commit/786a75a65f54fbda9cf3a6c9e72a6de470549770", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/786a75a65f54fbda9cf3a6c9e72a6de470549770/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19b8685b061402a0b4b459a01eb224726a9a54ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/19b8685b061402a0b4b459a01eb224726a9a54ed", "html_url": "https://github.com/rust-lang/rust/commit/19b8685b061402a0b4b459a01eb224726a9a54ed"}, {"sha": "28501166367ac12ac11fcf4bb06261e2c8139988", "url": "https://api.github.com/repos/rust-lang/rust/commits/28501166367ac12ac11fcf4bb06261e2c8139988", "html_url": "https://github.com/rust-lang/rust/commit/28501166367ac12ac11fcf4bb06261e2c8139988"}], "stats": {"total": 262, "additions": 131, "deletions": 131}, "files": [{"sha": "3fdbc9715275fff1f343ba025eb958b55563b93a", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/786a75a65f54fbda9cf3a6c9e72a6de470549770/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786a75a65f54fbda9cf3a6c9e72a6de470549770/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=786a75a65f54fbda9cf3a6c9e72a6de470549770", "patch": "@@ -152,7 +152,7 @@ pub fn parse_asm_args<'a>(\n                 ast::InlineAsmOperand::InOut { reg, expr, late: true }\n             }\n         } else if p.eat_keyword(kw::Const) {\n-            let anon_const = p.parse_anon_const_expr()?;\n+            let anon_const = p.parse_expr_anon_const()?;\n             ast::InlineAsmOperand::Const { anon_const }\n         } else if p.eat_keyword(sym::sym) {\n             let expr = p.parse_expr()?;"}, {"sha": "b4948dddcc95c024a69d948bddd497e76c71962a", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/786a75a65f54fbda9cf3a6c9e72a6de470549770/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786a75a65f54fbda9cf3a6c9e72a6de470549770/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=786a75a65f54fbda9cf3a6c9e72a6de470549770", "patch": "@@ -693,7 +693,7 @@ impl<'a> Parser<'a> {\n                 span: self.prev_token.span.shrink_to_lo(),\n                 tokens: None,\n             };\n-            let struct_expr = snapshot.parse_struct_expr(None, path, false);\n+            let struct_expr = snapshot.parse_expr_struct(None, path, false);\n             let block_tail = self.parse_block_tail(lo, s, AttemptLocalParseRecovery::No);\n             return Some(match (struct_expr, block_tail) {\n                 (Ok(expr), Err(mut err)) => {\n@@ -1624,7 +1624,7 @@ impl<'a> Parser<'a> {\n             // Handle `await { <expr> }`.\n             // This needs to be handled separately from the next arm to avoid\n             // interpreting `await { <expr> }?` as `<expr>?.await`.\n-            self.parse_block_expr(None, self.token.span, BlockCheckMode::Default)\n+            self.parse_expr_block(None, self.token.span, BlockCheckMode::Default)\n         } else {\n             self.parse_expr()\n         }"}, {"sha": "33254d034c9dbdef4f26353f4eb38af7df02e3b8", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 118, "deletions": 118, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/786a75a65f54fbda9cf3a6c9e72a6de470549770/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786a75a65f54fbda9cf3a6c9e72a6de470549770/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=786a75a65f54fbda9cf3a6c9e72a6de470549770", "patch": "@@ -103,7 +103,7 @@ impl<'a> Parser<'a> {\n         self.collect_tokens_no_attrs(|this| this.parse_expr())\n     }\n \n-    pub fn parse_anon_const_expr(&mut self) -> PResult<'a, AnonConst> {\n+    pub fn parse_expr_anon_const(&mut self) -> PResult<'a, AnonConst> {\n         self.parse_expr().map(|value| AnonConst { id: DUMMY_NODE_ID, value })\n     }\n \n@@ -125,7 +125,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a sequence of expressions delimited by parentheses.\n-    fn parse_paren_expr_seq(&mut self) -> PResult<'a, ThinVec<P<Expr>>> {\n+    fn parse_expr_paren_seq(&mut self) -> PResult<'a, ThinVec<P<Expr>>> {\n         self.parse_paren_comma_seq(|p| p.parse_expr_catch_underscore()).map(|(r, _)| r)\n     }\n \n@@ -136,23 +136,23 @@ impl<'a> Parser<'a> {\n         r: Restrictions,\n         already_parsed_attrs: Option<AttrWrapper>,\n     ) -> PResult<'a, P<Expr>> {\n-        self.with_res(r, |this| this.parse_assoc_expr(already_parsed_attrs))\n+        self.with_res(r, |this| this.parse_expr_assoc(already_parsed_attrs))\n     }\n \n     /// Parses an associative expression.\n     ///\n     /// This parses an expression accounting for associativity and precedence of the operators in\n     /// the expression.\n     #[inline]\n-    fn parse_assoc_expr(\n+    fn parse_expr_assoc(\n         &mut self,\n         already_parsed_attrs: Option<AttrWrapper>,\n     ) -> PResult<'a, P<Expr>> {\n-        self.parse_assoc_expr_with(0, already_parsed_attrs.into())\n+        self.parse_expr_assoc_with(0, already_parsed_attrs.into())\n     }\n \n     /// Parses an associative expression with operators of at least `min_prec` precedence.\n-    pub(super) fn parse_assoc_expr_with(\n+    pub(super) fn parse_expr_assoc_with(\n         &mut self,\n         min_prec: usize,\n         lhs: LhsExpr,\n@@ -167,9 +167,9 @@ impl<'a> Parser<'a> {\n                 _ => None,\n             };\n             if self.token.is_range_separator() {\n-                return self.parse_prefix_range_expr(attrs);\n+                return self.parse_expr_prefix_range(attrs);\n             } else {\n-                self.parse_prefix_expr(attrs)?\n+                self.parse_expr_prefix(attrs)?\n             }\n         };\n         let last_type_ascription_set = self.last_type_ascription.is_some();\n@@ -293,7 +293,7 @@ impl<'a> Parser<'a> {\n             } else if op == AssocOp::DotDot || op == AssocOp::DotDotEq {\n                 // If we didn't have to handle `x..`/`x..=`, it would be pretty easy to\n                 // generalise it to the Fixity::None code.\n-                lhs = self.parse_range_expr(prec, lhs, op, cur_op_span)?;\n+                lhs = self.parse_expr_range(prec, lhs, op, cur_op_span)?;\n                 break;\n             }\n \n@@ -306,7 +306,7 @@ impl<'a> Parser<'a> {\n                 Fixity::None => 1,\n             };\n             let rhs = self.with_res(restrictions - Restrictions::STMT_EXPR, |this| {\n-                this.parse_assoc_expr_with(prec + prec_adjustment, LhsExpr::NotYetParsed)\n+                this.parse_expr_assoc_with(prec + prec_adjustment, LhsExpr::NotYetParsed)\n             })?;\n \n             let span = self.mk_expr_sp(&lhs, lhs_span, rhs.span);\n@@ -458,15 +458,15 @@ impl<'a> Parser<'a> {\n \n     /// Parses `x..y`, `x..=y`, and `x..`/`x..=`.\n     /// The other two variants are handled in `parse_prefix_range_expr` below.\n-    fn parse_range_expr(\n+    fn parse_expr_range(\n         &mut self,\n         prec: usize,\n         lhs: P<Expr>,\n         op: AssocOp,\n         cur_op_span: Span,\n     ) -> PResult<'a, P<Expr>> {\n         let rhs = if self.is_at_start_of_range_notation_rhs() {\n-            Some(self.parse_assoc_expr_with(prec + 1, LhsExpr::NotYetParsed)?)\n+            Some(self.parse_expr_assoc_with(prec + 1, LhsExpr::NotYetParsed)?)\n         } else {\n             None\n         };\n@@ -491,7 +491,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses prefix-forms of range notation: `..expr`, `..`, `..=expr`.\n-    fn parse_prefix_range_expr(&mut self, attrs: Option<AttrWrapper>) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_prefix_range(&mut self, attrs: Option<AttrWrapper>) -> PResult<'a, P<Expr>> {\n         // Check for deprecated `...` syntax.\n         if self.token == token::DotDotDot {\n             self.err_dotdotdot_syntax(self.token.span);\n@@ -518,7 +518,7 @@ impl<'a> Parser<'a> {\n             this.bump();\n             let (span, opt_end) = if this.is_at_start_of_range_notation_rhs() {\n                 // RHS must be parsed with more associativity than the dots.\n-                this.parse_assoc_expr_with(op.unwrap().precedence() + 1, LhsExpr::NotYetParsed)\n+                this.parse_expr_assoc_with(op.unwrap().precedence() + 1, LhsExpr::NotYetParsed)\n                     .map(|x| (lo.to(x.span), Some(x)))?\n             } else {\n                 (lo, None)\n@@ -529,7 +529,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a prefix-unary-operator expr.\n-    fn parse_prefix_expr(&mut self, attrs: Option<AttrWrapper>) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_prefix(&mut self, attrs: Option<AttrWrapper>) -> PResult<'a, P<Expr>> {\n         let attrs = self.parse_or_use_outer_attributes(attrs)?;\n         let lo = self.token.span;\n \n@@ -547,20 +547,20 @@ impl<'a> Parser<'a> {\n         // Note: when adding new unary operators, don't forget to adjust TokenKind::can_begin_expr()\n         match this.token.uninterpolate().kind {\n             // `!expr`\n-            token::Not => make_it!(this, attrs, |this, _| this.parse_unary_expr(lo, UnOp::Not)),\n+            token::Not => make_it!(this, attrs, |this, _| this.parse_expr_unary(lo, UnOp::Not)),\n             // `~expr`\n             token::Tilde => make_it!(this, attrs, |this, _| this.recover_tilde_expr(lo)),\n             // `-expr`\n             token::BinOp(token::Minus) => {\n-                make_it!(this, attrs, |this, _| this.parse_unary_expr(lo, UnOp::Neg))\n+                make_it!(this, attrs, |this, _| this.parse_expr_unary(lo, UnOp::Neg))\n             }\n             // `*expr`\n             token::BinOp(token::Star) => {\n-                make_it!(this, attrs, |this, _| this.parse_unary_expr(lo, UnOp::Deref))\n+                make_it!(this, attrs, |this, _| this.parse_expr_unary(lo, UnOp::Deref))\n             }\n             // `&expr` and `&&expr`\n             token::BinOp(token::And) | token::AndAnd => {\n-                make_it!(this, attrs, |this, _| this.parse_borrow_expr(lo))\n+                make_it!(this, attrs, |this, _| this.parse_expr_borrow(lo))\n             }\n             // `+lit`\n             token::BinOp(token::Plus) if this.look_ahead(1, |tok| tok.is_numeric_lit()) => {\n@@ -579,7 +579,7 @@ impl<'a> Parser<'a> {\n                 this.sess.emit_err(err);\n \n                 this.bump();\n-                this.parse_prefix_expr(None)\n+                this.parse_expr_prefix(None)\n             }\n             // Recover from `++x`:\n             token::BinOp(token::Plus)\n@@ -592,41 +592,41 @@ impl<'a> Parser<'a> {\n                 this.bump();\n                 this.bump();\n \n-                let operand_expr = this.parse_dot_or_call_expr(Default::default())?;\n+                let operand_expr = this.parse_expr_dot_or_call(Default::default())?;\n                 this.recover_from_prefix_increment(operand_expr, pre_span, starts_stmt)\n             }\n             token::Ident(..) if this.token.is_keyword(kw::Box) => {\n-                make_it!(this, attrs, |this, _| this.parse_box_expr(lo))\n+                make_it!(this, attrs, |this, _| this.parse_expr_box(lo))\n             }\n             token::Ident(..) if this.may_recover() && this.is_mistaken_not_ident_negation() => {\n                 make_it!(this, attrs, |this, _| this.recover_not_expr(lo))\n             }\n-            _ => return this.parse_dot_or_call_expr(Some(attrs)),\n+            _ => return this.parse_expr_dot_or_call(Some(attrs)),\n         }\n     }\n \n-    fn parse_prefix_expr_common(&mut self, lo: Span) -> PResult<'a, (Span, P<Expr>)> {\n+    fn parse_expr_prefix_common(&mut self, lo: Span) -> PResult<'a, (Span, P<Expr>)> {\n         self.bump();\n-        let expr = self.parse_prefix_expr(None);\n+        let expr = self.parse_expr_prefix(None);\n         let (span, expr) = self.interpolated_or_expr_span(expr)?;\n         Ok((lo.to(span), expr))\n     }\n \n-    fn parse_unary_expr(&mut self, lo: Span, op: UnOp) -> PResult<'a, (Span, ExprKind)> {\n-        let (span, expr) = self.parse_prefix_expr_common(lo)?;\n+    fn parse_expr_unary(&mut self, lo: Span, op: UnOp) -> PResult<'a, (Span, ExprKind)> {\n+        let (span, expr) = self.parse_expr_prefix_common(lo)?;\n         Ok((span, self.mk_unary(op, expr)))\n     }\n \n     /// Recover on `~expr` in favor of `!expr`.\n     fn recover_tilde_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n         self.sess.emit_err(errors::TildeAsUnaryOperator(lo));\n \n-        self.parse_unary_expr(lo, UnOp::Not)\n+        self.parse_expr_unary(lo, UnOp::Not)\n     }\n \n     /// Parse `box expr`.\n-    fn parse_box_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n-        let (span, expr) = self.parse_prefix_expr_common(lo)?;\n+    fn parse_expr_box(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n+        let (span, expr) = self.parse_expr_prefix_common(lo)?;\n         self.sess.gated_spans.gate(sym::box_syntax, span);\n         Ok((span, ExprKind::Box(expr)))\n     }\n@@ -664,7 +664,7 @@ impl<'a> Parser<'a> {\n             ),\n         });\n \n-        self.parse_unary_expr(lo, UnOp::Not)\n+        self.parse_expr_unary(lo, UnOp::Not)\n     }\n \n     /// Returns the span of expr, if it was not interpolated or the span of the interpolated token.\n@@ -722,7 +722,7 @@ impl<'a> Parser<'a> {\n                                 segments[0].ident.span,\n                             ),\n                         };\n-                        match self.parse_labeled_expr(label, false) {\n+                        match self.parse_expr_labeled(label, false) {\n                             Ok(expr) => {\n                                 type_err.cancel();\n                                 self.sess.emit_err(errors::MalformedLoopLabel {\n@@ -816,7 +816,7 @@ impl<'a> Parser<'a> {\n                 (\"cast\", None)\n             };\n \n-        let with_postfix = self.parse_dot_or_call_expr_with_(cast_expr, span)?;\n+        let with_postfix = self.parse_expr_dot_or_call_with_(cast_expr, span)?;\n \n         // Check if an illegal postfix operator has been added after the cast.\n         // If the resulting expression is not a cast, it is an illegal postfix operator.\n@@ -887,15 +887,15 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse `& mut? <expr>` or `& raw [ const | mut ] <expr>`.\n-    fn parse_borrow_expr(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n+    fn parse_expr_borrow(&mut self, lo: Span) -> PResult<'a, (Span, ExprKind)> {\n         self.expect_and()?;\n         let has_lifetime = self.token.is_lifetime() && self.look_ahead(1, |t| t != &token::Colon);\n         let lifetime = has_lifetime.then(|| self.expect_lifetime()); // For recovery, see below.\n         let (borrow_kind, mutbl) = self.parse_borrow_modifiers(lo);\n         let expr = if self.token.is_range_separator() {\n-            self.parse_prefix_range_expr(None)\n+            self.parse_expr_prefix_range(None)\n         } else {\n-            self.parse_prefix_expr(None)\n+            self.parse_expr_prefix(None)\n         };\n         let (hi, expr) = self.interpolated_or_expr_span(expr)?;\n         let span = lo.to(hi);\n@@ -925,16 +925,16 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses `a.b` or `a(13)` or `a[4]` or just `a`.\n-    fn parse_dot_or_call_expr(&mut self, attrs: Option<AttrWrapper>) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_dot_or_call(&mut self, attrs: Option<AttrWrapper>) -> PResult<'a, P<Expr>> {\n         let attrs = self.parse_or_use_outer_attributes(attrs)?;\n         self.collect_tokens_for_expr(attrs, |this, attrs| {\n-            let base = this.parse_bottom_expr();\n+            let base = this.parse_expr_bottom();\n             let (span, base) = this.interpolated_or_expr_span(base)?;\n-            this.parse_dot_or_call_expr_with(base, span, attrs)\n+            this.parse_expr_dot_or_call_with(base, span, attrs)\n         })\n     }\n \n-    pub(super) fn parse_dot_or_call_expr_with(\n+    pub(super) fn parse_expr_dot_or_call_with(\n         &mut self,\n         e0: P<Expr>,\n         lo: Span,\n@@ -943,7 +943,7 @@ impl<'a> Parser<'a> {\n         // Stitch the list of outer attributes onto the return value.\n         // A little bit ugly, but the best way given the current code\n         // structure\n-        let res = self.parse_dot_or_call_expr_with_(e0, lo);\n+        let res = self.parse_expr_dot_or_call_with_(e0, lo);\n         if attrs.is_empty() {\n             res\n         } else {\n@@ -957,7 +957,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_dot_or_call_expr_with_(&mut self, mut e: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_dot_or_call_with_(&mut self, mut e: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n         loop {\n             let has_question = if self.prev_token.kind == TokenKind::Ident(kw::Return, false) {\n                 // we are using noexpect here because we don't expect a `?` directly after a `return`\n@@ -980,15 +980,15 @@ impl<'a> Parser<'a> {\n             };\n             if has_dot {\n                 // expr.f\n-                e = self.parse_dot_suffix_expr(lo, e)?;\n+                e = self.parse_expr_dot_suffix(lo, e)?;\n                 continue;\n             }\n             if self.expr_is_complete(&e) {\n                 return Ok(e);\n             }\n             e = match self.token.kind {\n-                token::OpenDelim(Delimiter::Parenthesis) => self.parse_fn_call_expr(lo, e),\n-                token::OpenDelim(Delimiter::Bracket) => self.parse_index_expr(lo, e)?,\n+                token::OpenDelim(Delimiter::Parenthesis) => self.parse_expr_fn_call(lo, e),\n+                token::OpenDelim(Delimiter::Bracket) => self.parse_expr_index(lo, e)?,\n                 _ => return Ok(e),\n             }\n         }\n@@ -1000,14 +1000,14 @@ impl<'a> Parser<'a> {\n             && self.look_ahead(3, |t| t.can_begin_expr())\n     }\n \n-    fn parse_dot_suffix_expr(&mut self, lo: Span, base: P<Expr>) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_dot_suffix(&mut self, lo: Span, base: P<Expr>) -> PResult<'a, P<Expr>> {\n         match self.token.uninterpolate().kind {\n             token::Ident(..) => self.parse_dot_suffix(base, lo),\n             token::Literal(token::Lit { kind: token::Integer, symbol, suffix }) => {\n-                Ok(self.parse_tuple_field_access_expr(lo, base, symbol, suffix, None))\n+                Ok(self.parse_expr_tuple_field_access(lo, base, symbol, suffix, None))\n             }\n             token::Literal(token::Lit { kind: token::Float, symbol, suffix }) => {\n-                Ok(self.parse_tuple_field_access_expr_float(lo, base, symbol, suffix))\n+                Ok(self.parse_expr_tuple_field_access_float(lo, base, symbol, suffix))\n             }\n             _ => {\n                 self.error_unexpected_after_dot();\n@@ -1029,7 +1029,7 @@ impl<'a> Parser<'a> {\n     // support pushing \"future tokens\" (would be also helpful to `break_and_eat`), or\n     // we should break everything including floats into more basic proc-macro style\n     // tokens in the lexer (probably preferable).\n-    fn parse_tuple_field_access_expr_float(\n+    fn parse_expr_tuple_field_access_float(\n         &mut self,\n         lo: Span,\n         base: P<Expr>,\n@@ -1072,7 +1072,7 @@ impl<'a> Parser<'a> {\n         match &*components {\n             // 1e2\n             [IdentLike(i)] => {\n-                self.parse_tuple_field_access_expr(lo, base, Symbol::intern(&i), suffix, None)\n+                self.parse_expr_tuple_field_access(lo, base, Symbol::intern(&i), suffix, None)\n             }\n             // 1.\n             [IdentLike(i), Punct('.')] => {\n@@ -1088,7 +1088,7 @@ impl<'a> Parser<'a> {\n                 let symbol = Symbol::intern(&i);\n                 self.token = Token::new(token::Ident(symbol, false), ident_span);\n                 let next_token = (Token::new(token::Dot, dot_span), self.token_spacing);\n-                self.parse_tuple_field_access_expr(lo, base, symbol, None, Some(next_token))\n+                self.parse_expr_tuple_field_access(lo, base, symbol, None, Some(next_token))\n             }\n             // 1.2 | 1.2e3\n             [IdentLike(i1), Punct('.'), IdentLike(i2)] => {\n@@ -1109,11 +1109,11 @@ impl<'a> Parser<'a> {\n                 // See issue #76399 and PR #76285 for more details\n                 let next_token1 = (Token::new(token::Dot, dot_span), Spacing::Alone);\n                 let base1 =\n-                    self.parse_tuple_field_access_expr(lo, base, symbol1, None, Some(next_token1));\n+                    self.parse_expr_tuple_field_access(lo, base, symbol1, None, Some(next_token1));\n                 let symbol2 = Symbol::intern(&i2);\n                 let next_token2 = Token::new(token::Ident(symbol2, false), ident2_span);\n                 self.bump_with((next_token2, self.token_spacing)); // `.`\n-                self.parse_tuple_field_access_expr(lo, base1, symbol2, suffix, None)\n+                self.parse_expr_tuple_field_access(lo, base1, symbol2, suffix, None)\n             }\n             // 1e+ | 1e- (recovered)\n             [IdentLike(_), Punct('+' | '-')] |\n@@ -1131,7 +1131,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_tuple_field_access_expr(\n+    fn parse_expr_tuple_field_access(\n         &mut self,\n         lo: Span,\n         base: P<Expr>,\n@@ -1152,7 +1152,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a function call expression, `expr(...)`.\n-    fn parse_fn_call_expr(&mut self, lo: Span, fun: P<Expr>) -> P<Expr> {\n+    fn parse_expr_fn_call(&mut self, lo: Span, fun: P<Expr>) -> P<Expr> {\n         let snapshot = if self.token.kind == token::OpenDelim(Delimiter::Parenthesis)\n             && self.look_ahead_type_ascription_as_field()\n         {\n@@ -1163,7 +1163,7 @@ impl<'a> Parser<'a> {\n         let open_paren = self.token.span;\n \n         let mut seq = self\n-            .parse_paren_expr_seq()\n+            .parse_expr_paren_seq()\n             .map(|args| self.mk_expr(lo.to(self.prev_token.span), self.mk_call(fun, args)));\n         if let Some(expr) =\n             self.maybe_recover_struct_lit_bad_delims(lo, open_paren, &mut seq, snapshot)\n@@ -1236,7 +1236,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an indexing expression `expr[...]`.\n-    fn parse_index_expr(&mut self, lo: Span, base: P<Expr>) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_index(&mut self, lo: Span, base: P<Expr>) -> PResult<'a, P<Expr>> {\n         let prev_span = self.prev_token.span;\n         let open_delim_span = self.token.span;\n         self.bump(); // `[`\n@@ -1259,7 +1259,7 @@ impl<'a> Parser<'a> {\n \n         if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n             // Method call `expr.f()`\n-            let args = self.parse_paren_expr_seq()?;\n+            let args = self.parse_expr_paren_seq()?;\n             let fn_span = fn_span_lo.to(self.prev_token.span);\n             let span = lo.to(self.prev_token.span);\n             Ok(self.mk_expr(\n@@ -1287,7 +1287,7 @@ impl<'a> Parser<'a> {\n     ///\n     /// N.B., this does not parse outer attributes, and is private because it only works\n     /// correctly if called from `parse_dot_or_call_expr()`.\n-    fn parse_bottom_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_bottom(&mut self) -> PResult<'a, P<Expr>> {\n         maybe_recover_from_interpolated_ty_qpath!(self, true);\n         maybe_whole_expr!(self);\n \n@@ -1300,13 +1300,13 @@ impl<'a> Parser<'a> {\n             // This match arm is a special-case of the `_` match arm below and\n             // could be removed without changing functionality, but it's faster\n             // to have it here, especially for programs with large constants.\n-            self.parse_lit_expr()\n+            self.parse_expr_lit()\n         } else if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n-            self.parse_tuple_parens_expr()\n+            self.parse_expr_tuple_parens()\n         } else if self.check(&token::OpenDelim(Delimiter::Brace)) {\n-            self.parse_block_expr(None, lo, BlockCheckMode::Default)\n+            self.parse_expr_block(None, lo, BlockCheckMode::Default)\n         } else if self.check(&token::BinOp(token::Or)) || self.check(&token::OrOr) {\n-            self.parse_closure_expr().map_err(|mut err| {\n+            self.parse_expr_closure().map_err(|mut err| {\n                 // If the input is something like `if a { 1 } else { 2 } | if a { 3 } else { 4 }`\n                 // then suggest parens around the lhs.\n                 if let Some(sp) = self.sess.ambiguous_block_expr_parse.borrow().get(&lo) {\n@@ -1315,42 +1315,42 @@ impl<'a> Parser<'a> {\n                 err\n             })\n         } else if self.check(&token::OpenDelim(Delimiter::Bracket)) {\n-            self.parse_array_or_repeat_expr(Delimiter::Bracket)\n+            self.parse_expr_array_or_repeat(Delimiter::Bracket)\n         } else if self.check_path() {\n-            self.parse_path_start_expr()\n+            self.parse_expr_path_start()\n         } else if self.check_keyword(kw::Move)\n             || self.check_keyword(kw::Static)\n             || self.check_const_closure()\n         {\n-            self.parse_closure_expr()\n+            self.parse_expr_closure()\n         } else if self.eat_keyword(kw::If) {\n-            self.parse_if_expr()\n+            self.parse_expr_if()\n         } else if self.check_keyword(kw::For) {\n             if self.choose_generics_over_qpath(1) {\n-                self.parse_closure_expr()\n+                self.parse_expr_closure()\n             } else {\n                 assert!(self.eat_keyword(kw::For));\n-                self.parse_for_expr(None, self.prev_token.span)\n+                self.parse_expr_for(None, self.prev_token.span)\n             }\n         } else if self.eat_keyword(kw::While) {\n-            self.parse_while_expr(None, self.prev_token.span)\n+            self.parse_expr_while(None, self.prev_token.span)\n         } else if let Some(label) = self.eat_label() {\n-            self.parse_labeled_expr(label, true)\n+            self.parse_expr_labeled(label, true)\n         } else if self.eat_keyword(kw::Loop) {\n             let sp = self.prev_token.span;\n-            self.parse_loop_expr(None, self.prev_token.span).map_err(|mut err| {\n+            self.parse_expr_loop(None, self.prev_token.span).map_err(|mut err| {\n                 err.span_label(sp, \"while parsing this `loop` expression\");\n                 err\n             })\n         } else if self.eat_keyword(kw::Match) {\n             let match_sp = self.prev_token.span;\n-            self.parse_match_expr().map_err(|mut err| {\n+            self.parse_expr_match().map_err(|mut err| {\n                 err.span_label(match_sp, \"while parsing this `match` expression\");\n                 err\n             })\n         } else if self.eat_keyword(kw::Unsafe) {\n             let sp = self.prev_token.span;\n-            self.parse_block_expr(None, lo, BlockCheckMode::Unsafe(ast::UserProvided)).map_err(\n+            self.parse_expr_block(None, lo, BlockCheckMode::Unsafe(ast::UserProvided)).map_err(\n                 |mut err| {\n                     err.span_label(sp, \"while parsing this `unsafe` expression\");\n                     err\n@@ -1364,17 +1364,17 @@ impl<'a> Parser<'a> {\n             self.expect_keyword(kw::Try)?;\n             self.parse_try_block(lo)\n         } else if self.eat_keyword(kw::Return) {\n-            self.parse_return_expr()\n+            self.parse_expr_return()\n         } else if self.eat_keyword(kw::Continue) {\n-            self.parse_continue_expr(lo)\n+            self.parse_expr_continue(lo)\n         } else if self.eat_keyword(kw::Break) {\n-            self.parse_break_expr()\n+            self.parse_expr_break()\n         } else if self.eat_keyword(kw::Yield) {\n-            self.parse_yield_expr()\n+            self.parse_expr_yield()\n         } else if self.is_do_yeet() {\n-            self.parse_yeet_expr()\n+            self.parse_expr_yeet()\n         } else if self.check_keyword(kw::Let) {\n-            self.parse_let_expr()\n+            self.parse_expr_let()\n         } else if self.eat_keyword(kw::Underscore) {\n             Ok(self.mk_expr(self.prev_token.span, ExprKind::Underscore))\n         } else if !self.unclosed_delims.is_empty() && self.check(&token::Semi) {\n@@ -1397,19 +1397,19 @@ impl<'a> Parser<'a> {\n                     // Check for `async {` and `async move {`.\n                     self.parse_async_block()\n                 } else {\n-                    self.parse_closure_expr()\n+                    self.parse_expr_closure()\n                 }\n             } else if self.eat_keyword(kw::Await) {\n                 self.recover_incorrect_await_syntax(lo, self.prev_token.span)\n             } else {\n-                self.parse_lit_expr()\n+                self.parse_expr_lit()\n             }\n         } else {\n-            self.parse_lit_expr()\n+            self.parse_expr_lit()\n         }\n     }\n \n-    fn parse_lit_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_lit(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n         match self.parse_opt_token_lit() {\n             Some((token_lit, _)) => {\n@@ -1420,7 +1420,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_tuple_parens_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_tuple_parens(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n         self.expect(&token::OpenDelim(Delimiter::Parenthesis))?;\n         let (es, trailing_comma) = match self.parse_seq_to_end(\n@@ -1444,7 +1444,7 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n-    fn parse_array_or_repeat_expr(&mut self, close_delim: Delimiter) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_array_or_repeat(&mut self, close_delim: Delimiter) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n         self.bump(); // `[` or other open delim\n \n@@ -1457,7 +1457,7 @@ impl<'a> Parser<'a> {\n             let first_expr = self.parse_expr()?;\n             if self.eat(&token::Semi) {\n                 // Repeating array syntax: `[ 0; 512 ]`\n-                let count = self.parse_anon_const_expr()?;\n+                let count = self.parse_expr_anon_const()?;\n                 self.expect(close)?;\n                 ExprKind::Repeat(first_expr, count)\n             } else if self.eat(&token::Comma) {\n@@ -1476,7 +1476,7 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n-    fn parse_path_start_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_path_start(&mut self) -> PResult<'a, P<Expr>> {\n         let (qself, path) = if self.eat_lt() {\n             let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n             (Some(qself), path)\n@@ -1513,7 +1513,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse `'label: $expr`. The label is already parsed.\n-    fn parse_labeled_expr(\n+    fn parse_expr_labeled(\n         &mut self,\n         label_: Label,\n         mut consume_colon: bool,\n@@ -1522,15 +1522,15 @@ impl<'a> Parser<'a> {\n         let label = Some(label_);\n         let ate_colon = self.eat(&token::Colon);\n         let expr = if self.eat_keyword(kw::While) {\n-            self.parse_while_expr(label, lo)\n+            self.parse_expr_while(label, lo)\n         } else if self.eat_keyword(kw::For) {\n-            self.parse_for_expr(label, lo)\n+            self.parse_expr_for(label, lo)\n         } else if self.eat_keyword(kw::Loop) {\n-            self.parse_loop_expr(label, lo)\n+            self.parse_expr_loop(label, lo)\n         } else if self.check_noexpect(&token::OpenDelim(Delimiter::Brace))\n             || self.token.is_whole_block()\n         {\n-            self.parse_block_expr(label, lo, BlockCheckMode::Default)\n+            self.parse_expr_block(label, lo, BlockCheckMode::Default)\n         } else if !ate_colon\n             && self.may_recover()\n             && (matches!(self.token.kind, token::CloseDelim(_) | token::Comma)\n@@ -1670,15 +1670,15 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse `\"return\" expr?`.\n-    fn parse_return_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_return(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_token.span;\n         let kind = ExprKind::Ret(self.parse_expr_opt()?);\n         let expr = self.mk_expr(lo.to(self.prev_token.span), kind);\n         self.maybe_recover_from_bad_qpath(expr)\n     }\n \n     /// Parse `\"do\" \"yeet\" expr?`.\n-    fn parse_yeet_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_yeet(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n \n         self.bump(); // `do`\n@@ -1700,13 +1700,13 @@ impl<'a> Parser<'a> {\n     /// `break 'lbl: loop {}`); a labeled break with an unlabeled loop as its value\n     /// expression only gets a warning for compatibility reasons; and a labeled break\n     /// with a labeled loop does not even get a warning because there is no ambiguity.\n-    fn parse_break_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_break(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_token.span;\n         let mut label = self.eat_label();\n         let kind = if self.token == token::Colon && let Some(label) = label.take() {\n             // The value expression can be a labeled loop, see issue #86948, e.g.:\n             // `loop { break 'label: loop { break 'label 42; }; }`\n-            let lexpr = self.parse_labeled_expr(label, true)?;\n+            let lexpr = self.parse_expr_labeled(label, true)?;\n             self.sess.emit_err(errors::LabeledLoopInBreak {\n                 span: lexpr.span,\n                 sub: errors::WrapExpressionInParentheses {\n@@ -1759,7 +1759,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse `\"continue\" label?`.\n-    fn parse_continue_expr(&mut self, lo: Span) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_continue(&mut self, lo: Span) -> PResult<'a, P<Expr>> {\n         let mut label = self.eat_label();\n \n         // Recover `continue label` -> `continue 'label`\n@@ -1776,7 +1776,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse `\"yield\" expr?`.\n-    fn parse_yield_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_yield(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_token.span;\n         let kind = ExprKind::Yield(self.parse_expr_opt()?);\n         let span = lo.to(self.prev_token.span);\n@@ -1993,7 +1993,7 @@ impl<'a> Parser<'a> {\n     /// expression.\n     fn maybe_suggest_brackets_instead_of_braces(&mut self, lo: Span) -> Option<P<Expr>> {\n         let mut snapshot = self.create_snapshot_for_diagnostic();\n-        match snapshot.parse_array_or_repeat_expr(Delimiter::Brace) {\n+        match snapshot.parse_expr_array_or_repeat(Delimiter::Brace) {\n             Ok(arr) => {\n                 self.sess.emit_err(errors::ArrayBracketsInsteadOfSpaces {\n                     span: arr.span,\n@@ -2056,7 +2056,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a block or unsafe block.\n-    pub(super) fn parse_block_expr(\n+    pub(super) fn parse_expr_block(\n         &mut self,\n         opt_label: Option<Label>,\n         lo: Span,\n@@ -2086,7 +2086,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a closure expression (e.g., `move |args| expr`).\n-    fn parse_closure_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_closure(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n \n         let binder = if self.check_keyword(kw::For) {\n@@ -2123,7 +2123,7 @@ impl<'a> Parser<'a> {\n             _ => {\n                 // If an explicit return type is given, require a block to appear (RFC 968).\n                 let body_lo = self.token.span;\n-                self.parse_block_expr(None, body_lo, BlockCheckMode::Default)?\n+                self.parse_expr_block(None, body_lo, BlockCheckMode::Default)?\n             }\n         };\n \n@@ -2236,9 +2236,9 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses an `if` expression (`if` token already eaten).\n-    fn parse_if_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_if(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_token.span;\n-        let cond = self.parse_cond_expr()?;\n+        let cond = self.parse_expr_cond()?;\n         self.parse_if_after_cond(lo, cond)\n     }\n \n@@ -2316,12 +2316,12 @@ impl<'a> Parser<'a> {\n             self.error_on_if_block_attrs(lo, false, block.span, attrs);\n             block\n         };\n-        let els = if self.eat_keyword(kw::Else) { Some(self.parse_else_expr()?) } else { None };\n+        let els = if self.eat_keyword(kw::Else) { Some(self.parse_expr_else()?) } else { None };\n         Ok(self.mk_expr(lo.to(self.prev_token.span), ExprKind::If(cond, thn, els)))\n     }\n \n     /// Parses the condition of a `if` or `while` expression.\n-    fn parse_cond_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_cond(&mut self) -> PResult<'a, P<Expr>> {\n         let cond =\n             self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL | Restrictions::ALLOW_LET, None)?;\n \n@@ -2334,7 +2334,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a `let $pat = $expr` pseudo-expression.\n-    fn parse_let_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_let(&mut self) -> PResult<'a, P<Expr>> {\n         // This is a *approximate* heuristic that detects if `let` chains are\n         // being parsed in the right position. It's approximate because it\n         // doesn't deny all invalid `let` expressions, just completely wrong usages.\n@@ -2364,19 +2364,19 @@ impl<'a> Parser<'a> {\n             self.expect(&token::Eq)?;\n         }\n         let expr = self.with_res(self.restrictions | Restrictions::NO_STRUCT_LITERAL, |this| {\n-            this.parse_assoc_expr_with(1 + prec_let_scrutinee_needs_par(), None.into())\n+            this.parse_expr_assoc_with(1 + prec_let_scrutinee_needs_par(), None.into())\n         })?;\n         let span = lo.to(expr.span);\n         self.sess.gated_spans.gate(sym::let_chains, span);\n         Ok(self.mk_expr(span, ExprKind::Let(pat, expr, span)))\n     }\n \n     /// Parses an `else { ... }` expression (`else` token already eaten).\n-    fn parse_else_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_else(&mut self) -> PResult<'a, P<Expr>> {\n         let else_span = self.prev_token.span; // `else`\n         let attrs = self.parse_outer_attributes()?; // For recovery.\n         let expr = if self.eat_keyword(kw::If) {\n-            self.parse_if_expr()?\n+            self.parse_expr_if()?\n         } else if self.check(&TokenKind::OpenDelim(Delimiter::Brace)) {\n             self.parse_simple_block()?\n         } else {\n@@ -2450,7 +2450,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses `for <src_pat> in <src_expr> <src_loop_block>` (`for` token already eaten).\n-    fn parse_for_expr(&mut self, opt_label: Option<Label>, lo: Span) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_for(&mut self, opt_label: Option<Label>, lo: Span) -> PResult<'a, P<Expr>> {\n         // Record whether we are about to parse `for (`.\n         // This is used below for recovery in case of `for ( $stuff ) $block`\n         // in which case we will suggest `for $stuff $block`.\n@@ -2508,8 +2508,8 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a `while` or `while let` expression (`while` token already eaten).\n-    fn parse_while_expr(&mut self, opt_label: Option<Label>, lo: Span) -> PResult<'a, P<Expr>> {\n-        let cond = self.parse_cond_expr().map_err(|mut err| {\n+    fn parse_expr_while(&mut self, opt_label: Option<Label>, lo: Span) -> PResult<'a, P<Expr>> {\n+        let cond = self.parse_expr_cond().map_err(|mut err| {\n             err.span_label(lo, \"while parsing the condition of this `while` expression\");\n             err\n         })?;\n@@ -2526,7 +2526,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses `loop { ... }` (`loop` token already eaten).\n-    fn parse_loop_expr(&mut self, opt_label: Option<Label>, lo: Span) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_loop(&mut self, opt_label: Option<Label>, lo: Span) -> PResult<'a, P<Expr>> {\n         let loop_span = self.prev_token.span;\n         let (attrs, body) = self.parse_inner_attrs_and_block()?;\n         Ok(self.mk_expr_with_attrs(\n@@ -2544,7 +2544,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a `match ... { ... }` expression (`match` token already eaten).\n-    fn parse_match_expr(&mut self) -> PResult<'a, P<Expr>> {\n+    fn parse_expr_match(&mut self) -> PResult<'a, P<Expr>> {\n         let match_span = self.prev_token.span;\n         let lo = self.prev_token.span;\n         let scrutinee = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n@@ -2914,7 +2914,7 @@ impl<'a> Parser<'a> {\n             if let Err(err) = self.expect(&token::OpenDelim(Delimiter::Brace)) {\n                 return Some(Err(err));\n             }\n-            let expr = self.parse_struct_expr(qself.clone(), path.clone(), true);\n+            let expr = self.parse_expr_struct(qself.clone(), path.clone(), true);\n             if let (Ok(expr), false) = (&expr, struct_allowed) {\n                 // This is a struct literal, but we don't can't accept them here.\n                 self.sess.emit_err(errors::StructLiteralNotAllowedHere {\n@@ -3043,7 +3043,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Precondition: already parsed the '{'.\n-    pub(super) fn parse_struct_expr(\n+    pub(super) fn parse_expr_struct(\n         &mut self,\n         qself: Option<P<ast::QSelf>>,\n         pth: ast::Path,"}, {"sha": "9d9ae154ad42ee10f96f278990b6f732d6fcd704", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/786a75a65f54fbda9cf3a6c9e72a6de470549770/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786a75a65f54fbda9cf3a6c9e72a6de470549770/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=786a75a65f54fbda9cf3a6c9e72a6de470549770", "patch": "@@ -1331,7 +1331,7 @@ impl<'a> Parser<'a> {\n                 };\n \n                 let disr_expr =\n-                    if this.eat(&token::Eq) { Some(this.parse_anon_const_expr()?) } else { None };\n+                    if this.eat(&token::Eq) { Some(this.parse_expr_anon_const()?) } else { None };\n \n                 let vr = ast::Variant {\n                     ident,\n@@ -1722,7 +1722,7 @@ impl<'a> Parser<'a> {\n         }\n         if self.token.kind == token::Eq {\n             self.bump();\n-            let const_expr = self.parse_anon_const_expr()?;\n+            let const_expr = self.parse_expr_anon_const()?;\n             let sp = ty.span.shrink_to_hi().to(const_expr.value.span);\n             self.struct_span_err(sp, \"default values on `struct` fields aren't supported\")\n                 .span_suggestion("}, {"sha": "b50d2984a4ec03ab08c99af2b598a494fa54bed8", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/786a75a65f54fbda9cf3a6c9e72a6de470549770/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786a75a65f54fbda9cf3a6c9e72a6de470549770/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=786a75a65f54fbda9cf3a6c9e72a6de470549770", "patch": "@@ -653,7 +653,7 @@ impl<'a> Parser<'a> {\n     pub(super) fn parse_const_arg(&mut self) -> PResult<'a, AnonConst> {\n         // Parse const argument.\n         let value = if let token::OpenDelim(Delimiter::Brace) = self.token.kind {\n-            self.parse_block_expr(None, self.token.span, BlockCheckMode::Default)?\n+            self.parse_expr_block(None, self.token.span, BlockCheckMode::Default)?\n         } else {\n             self.handle_unambiguous_unbraced_const_arg()?\n         };"}, {"sha": "92a22ffc2b07bffcd452e2cfaa276ba31b962ce0", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/786a75a65f54fbda9cf3a6c9e72a6de470549770/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786a75a65f54fbda9cf3a6c9e72a6de470549770/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=786a75a65f54fbda9cf3a6c9e72a6de470549770", "patch": "@@ -146,14 +146,14 @@ impl<'a> Parser<'a> {\n             }\n \n             let expr = if this.eat(&token::OpenDelim(Delimiter::Brace)) {\n-                this.parse_struct_expr(None, path, true)?\n+                this.parse_expr_struct(None, path, true)?\n             } else {\n                 let hi = this.prev_token.span;\n                 this.mk_expr(lo.to(hi), ExprKind::Path(None, path))\n             };\n \n             let expr = this.with_res(Restrictions::STMT_EXPR, |this| {\n-                this.parse_dot_or_call_expr_with(expr, lo, attrs)\n+                this.parse_expr_dot_or_call_with(expr, lo, attrs)\n             })?;\n             // `DUMMY_SP` will get overwritten later in this function\n             Ok((this.mk_stmt(rustc_span::DUMMY_SP, StmtKind::Expr(expr)), TrailingToken::None))\n@@ -163,7 +163,7 @@ impl<'a> Parser<'a> {\n             // Perform this outside of the `collect_tokens_trailing_token` closure,\n             // since our outer attributes do not apply to this part of the expression\n             let expr = self.with_res(Restrictions::STMT_EXPR, |this| {\n-                this.parse_assoc_expr_with(\n+                this.parse_expr_assoc_with(\n                     0,\n                     LhsExpr::AlreadyParsed { expr, starts_statement: true },\n                 )\n@@ -199,8 +199,8 @@ impl<'a> Parser<'a> {\n             // Since none of the above applied, this is an expression statement macro.\n             let e = self.mk_expr(lo.to(hi), ExprKind::MacCall(mac));\n             let e = self.maybe_recover_from_bad_qpath(e)?;\n-            let e = self.parse_dot_or_call_expr_with(e, lo, attrs)?;\n-            let e = self.parse_assoc_expr_with(\n+            let e = self.parse_expr_dot_or_call_with(e, lo, attrs)?;\n+            let e = self.parse_expr_assoc_with(\n                 0,\n                 LhsExpr::AlreadyParsed { expr: e, starts_statement: false },\n             )?;"}, {"sha": "6fe4da71f6b13398f18fe7fb2d12fd62d9d06ec7", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/786a75a65f54fbda9cf3a6c9e72a6de470549770/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786a75a65f54fbda9cf3a6c9e72a6de470549770/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=786a75a65f54fbda9cf3a6c9e72a6de470549770", "patch": "@@ -433,7 +433,7 @@ impl<'a> Parser<'a> {\n         };\n \n         let ty = if self.eat(&token::Semi) {\n-            let mut length = self.parse_anon_const_expr()?;\n+            let mut length = self.parse_expr_anon_const()?;\n             if let Err(e) = self.expect(&token::CloseDelim(Delimiter::Bracket)) {\n                 // Try to recover from `X<Y, ...>` when `X::<Y, ...>` works\n                 self.check_mistyped_turbofish_with_multiple_type_params(e, &mut length.value)?;\n@@ -494,7 +494,7 @@ impl<'a> Parser<'a> {\n     // To avoid ambiguity, the type is surrounded by parentheses.\n     fn parse_typeof_ty(&mut self) -> PResult<'a, TyKind> {\n         self.expect(&token::OpenDelim(Delimiter::Parenthesis))?;\n-        let expr = self.parse_anon_const_expr()?;\n+        let expr = self.parse_expr_anon_const()?;\n         self.expect(&token::CloseDelim(Delimiter::Parenthesis))?;\n         Ok(TyKind::Typeof(expr))\n     }"}]}