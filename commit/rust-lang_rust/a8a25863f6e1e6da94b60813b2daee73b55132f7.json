{"sha": "a8a25863f6e1e6da94b60813b2daee73b55132f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4YTI1ODYzZjZlMWU2ZGE5NGI2MDgxM2IyZGFlZTczYjU1MTMyZjc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-10T21:35:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-10T21:35:05Z"}, "message": "Merge #8436\n\n8436: Fix extract function's mutability of variables outliving the body r=matklad a=brandondong\n\n**Reproduction:**\r\n```rust\r\nfn main() {\r\n    let mut k = 1;\r\n    let mut j = 2;\r\n    j += 1;\r\n    k += j;\r\n}\r\n```\r\n1. Select the first to third lines of the main function. Use the \"Extract into function\" code assist.\r\n2. The output is the following which does not compile because the outlived variable `k` is declared as immutable:\r\n```rust\r\nfn main() {\r\n    let (k, j) = fun_name();\r\n    k += j;\r\n}\r\n\r\nfn fun_name() -> (i32, i32) {\r\n    let mut k = 1;\r\n    let mut j = 2;\r\n    j += 1;\r\n    (k, j)\r\n}\r\n```\r\n3. We would instead expect the output to be:\r\n```rust\r\nfn main() {\r\n    let (mut k, j) = fun_name();\r\n    k += j;\r\n}\r\n```\r\n\r\n**Fix:**\r\n- Instead of declaring outlived variables as immutable unconditionally, check for any mutable usages outside of the extracted function.\n\nCo-authored-by: Brandon <brandondong604@hotmail.com>", "tree": {"sha": "1e2b90d4196867eb1326d19bac70be8a5847a26e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e2b90d4196867eb1326d19bac70be8a5847a26e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8a25863f6e1e6da94b60813b2daee73b55132f7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgchoJCRBK7hj4Ov3rIwAAdHIIABV4/YibgPeOL4l9VuofUxsr\nvInaBvuahjAe6Eq5fq8EasEfMSw1ElZ5ues8sw2eHhIVPPNncoEem0ZMK7a55cr+\nd2jZ2eQ/KYuwM5tdfna1VXnI15T2LEbnY7tnf9FFtJ75exMnu3t2oR+25j9EflON\nk/ZA79t4+lyDUHUSDjPJl1v8a0txSt+pWlRHgclSoXsy/poi4qR4jzZqRgDR82C3\nnHRO7wvCzH87lPWusGvqLeJWCXUG37FKErcSOex2wr/jpOyxwAjaH+VSVqqkii5c\noDt7Yj3532lG9S7pnbpwjiIypGHgzGggPXR1dKmYYilKOARXRE9KwnwGp9GfUls=\n=fn8g\n-----END PGP SIGNATURE-----\n", "payload": "tree 1e2b90d4196867eb1326d19bac70be8a5847a26e\nparent bd675c8a8bdd3fda239bee3d3f31acd8679655b9\nparent c989287a34b8b27fa4880d27e698bd880631a794\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1618090505 +0000\ncommitter GitHub <noreply@github.com> 1618090505 +0000\n\nMerge #8436\n\n8436: Fix extract function's mutability of variables outliving the body r=matklad a=brandondong\n\n**Reproduction:**\r\n```rust\r\nfn main() {\r\n    let mut k = 1;\r\n    let mut j = 2;\r\n    j += 1;\r\n    k += j;\r\n}\r\n```\r\n1. Select the first to third lines of the main function. Use the \"Extract into function\" code assist.\r\n2. The output is the following which does not compile because the outlived variable `k` is declared as immutable:\r\n```rust\r\nfn main() {\r\n    let (k, j) = fun_name();\r\n    k += j;\r\n}\r\n\r\nfn fun_name() -> (i32, i32) {\r\n    let mut k = 1;\r\n    let mut j = 2;\r\n    j += 1;\r\n    (k, j)\r\n}\r\n```\r\n3. We would instead expect the output to be:\r\n```rust\r\nfn main() {\r\n    let (mut k, j) = fun_name();\r\n    k += j;\r\n}\r\n```\r\n\r\n**Fix:**\r\n- Instead of declaring outlived variables as immutable unconditionally, check for any mutable usages outside of the extracted function.\n\nCo-authored-by: Brandon <brandondong604@hotmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8a25863f6e1e6da94b60813b2daee73b55132f7", "html_url": "https://github.com/rust-lang/rust/commit/a8a25863f6e1e6da94b60813b2daee73b55132f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8a25863f6e1e6da94b60813b2daee73b55132f7/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd675c8a8bdd3fda239bee3d3f31acd8679655b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd675c8a8bdd3fda239bee3d3f31acd8679655b9", "html_url": "https://github.com/rust-lang/rust/commit/bd675c8a8bdd3fda239bee3d3f31acd8679655b9"}, {"sha": "c989287a34b8b27fa4880d27e698bd880631a794", "url": "https://api.github.com/repos/rust-lang/rust/commits/c989287a34b8b27fa4880d27e698bd880631a794", "html_url": "https://github.com/rust-lang/rust/commit/c989287a34b8b27fa4880d27e698bd880631a794"}], "stats": {"total": 128, "additions": 109, "deletions": 19}, "files": [{"sha": "af95437666ebacbf2b6265405ff8e904b3af6a59", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 109, "deletions": 19, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/a8a25863f6e1e6da94b60813b2daee73b55132f7/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a25863f6e1e6da94b60813b2daee73b55132f7/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=a8a25863f6e1e6da94b60813b2daee73b55132f7", "patch": "@@ -75,7 +75,8 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n     let insert_after = scope_for_fn_insertion(&body, anchor)?;\n     let module = ctx.sema.scope(&insert_after).module()?;\n \n-    let vars_defined_in_body_and_outlive = vars_defined_in_body_and_outlive(ctx, &body);\n+    let vars_defined_in_body_and_outlive =\n+        vars_defined_in_body_and_outlive(ctx, &body, &node.parent().as_ref().unwrap_or(&node));\n     let ret_ty = body_return_ty(ctx, &body)?;\n \n     // FIXME: we compute variables that outlive here just to check `never!` condition\n@@ -257,7 +258,7 @@ struct Function {\n     control_flow: ControlFlow,\n     ret_ty: RetType,\n     body: FunctionBody,\n-    vars_defined_in_body_and_outlive: Vec<Local>,\n+    vars_defined_in_body_and_outlive: Vec<OutlivedLocal>,\n }\n \n #[derive(Debug)]\n@@ -296,9 +297,9 @@ impl Function {\n             RetType::Expr(ty) => FunType::Single(ty.clone()),\n             RetType::Stmt => match self.vars_defined_in_body_and_outlive.as_slice() {\n                 [] => FunType::Unit,\n-                [var] => FunType::Single(var.ty(ctx.db())),\n+                [var] => FunType::Single(var.local.ty(ctx.db())),\n                 vars => {\n-                    let types = vars.iter().map(|v| v.ty(ctx.db())).collect();\n+                    let types = vars.iter().map(|v| v.local.ty(ctx.db())).collect();\n                     FunType::Tuple(types)\n                 }\n             },\n@@ -562,6 +563,12 @@ impl HasTokenAtOffset for FunctionBody {\n     }\n }\n \n+#[derive(Debug)]\n+struct OutlivedLocal {\n+    local: Local,\n+    mut_usage_outside_body: bool,\n+}\n+\n /// Try to guess what user wants to extract\n ///\n /// We have basically have two cases:\n@@ -707,10 +714,10 @@ fn has_exclusive_usages(ctx: &AssistContext, usages: &LocalUsages, body: &Functi\n         .any(|reference| reference_is_exclusive(reference, body, ctx))\n }\n \n-/// checks if this reference requires `&mut` access inside body\n+/// checks if this reference requires `&mut` access inside node\n fn reference_is_exclusive(\n     reference: &FileReference,\n-    body: &FunctionBody,\n+    node: &dyn HasTokenAtOffset,\n     ctx: &AssistContext,\n ) -> bool {\n     // we directly modify variable with set: `n = 0`, `n += 1`\n@@ -719,7 +726,7 @@ fn reference_is_exclusive(\n     }\n \n     // we take `&mut` reference to variable: `&mut v`\n-    let path = match path_element_of_reference(body, reference) {\n+    let path = match path_element_of_reference(node, reference) {\n         Some(path) => path,\n         None => return false,\n     };\n@@ -820,10 +827,16 @@ fn vars_defined_in_body(body: &FunctionBody, ctx: &AssistContext) -> Vec<Local>\n }\n \n /// list local variables defined inside `body` that should be returned from extracted function\n-fn vars_defined_in_body_and_outlive(ctx: &AssistContext, body: &FunctionBody) -> Vec<Local> {\n-    let mut vars_defined_in_body = vars_defined_in_body(&body, ctx);\n-    vars_defined_in_body.retain(|var| var_outlives_body(ctx, body, var));\n+fn vars_defined_in_body_and_outlive(\n+    ctx: &AssistContext,\n+    body: &FunctionBody,\n+    parent: &SyntaxNode,\n+) -> Vec<OutlivedLocal> {\n+    let vars_defined_in_body = vars_defined_in_body(&body, ctx);\n     vars_defined_in_body\n+        .into_iter()\n+        .filter_map(|var| var_outlives_body(ctx, body, var, parent))\n+        .collect()\n }\n \n /// checks if the relevant local was defined before(outside of) body\n@@ -843,11 +856,23 @@ fn either_syntax(value: &Either<ast::IdentPat, ast::SelfParam>) -> &SyntaxNode {\n     }\n }\n \n-/// checks if local variable is used after(outside of) body\n-fn var_outlives_body(ctx: &AssistContext, body: &FunctionBody, var: &Local) -> bool {\n-    let usages = LocalUsages::find(ctx, *var);\n+/// returns usage details if local variable is used after(outside of) body\n+fn var_outlives_body(\n+    ctx: &AssistContext,\n+    body: &FunctionBody,\n+    var: Local,\n+    parent: &SyntaxNode,\n+) -> Option<OutlivedLocal> {\n+    let usages = LocalUsages::find(ctx, var);\n     let has_usages = usages.iter().any(|reference| body.preceedes_range(reference.range));\n-    has_usages\n+    if !has_usages {\n+        return None;\n+    }\n+    let has_mut_usages = usages\n+        .iter()\n+        .filter(|reference| body.preceedes_range(reference.range))\n+        .any(|reference| reference_is_exclusive(reference, parent, ctx));\n+    Some(OutlivedLocal { local: var, mut_usage_outside_body: has_mut_usages })\n }\n \n fn body_return_ty(ctx: &AssistContext, body: &FunctionBody) -> Option<RetType> {\n@@ -927,16 +952,25 @@ fn format_replacement(ctx: &AssistContext, fun: &Function, indent: IndentLevel)\n     let mut buf = String::new();\n     match fun.vars_defined_in_body_and_outlive.as_slice() {\n         [] => {}\n-        [var] => format_to!(buf, \"let {} = \", var.name(ctx.db()).unwrap()),\n+        [var] => {\n+            format_to!(buf, \"let {}{} = \", mut_modifier(var), var.local.name(ctx.db()).unwrap())\n+        }\n         [v0, vs @ ..] => {\n             buf.push_str(\"let (\");\n-            format_to!(buf, \"{}\", v0.name(ctx.db()).unwrap());\n+            format_to!(buf, \"{}{}\", mut_modifier(v0), v0.local.name(ctx.db()).unwrap());\n             for var in vs {\n-                format_to!(buf, \", {}\", var.name(ctx.db()).unwrap());\n+                format_to!(buf, \", {}{}\", mut_modifier(var), var.local.name(ctx.db()).unwrap());\n             }\n             buf.push_str(\") = \");\n         }\n     }\n+    fn mut_modifier(var: &OutlivedLocal) -> &'static str {\n+        if var.mut_usage_outside_body {\n+            \"mut \"\n+        } else {\n+            \"\"\n+        }\n+    }\n     format_to!(buf, \"{}\", expr);\n     if fun.ret_ty.is_unit()\n         && (!fun.vars_defined_in_body_and_outlive.is_empty() || !expr.is_block_like())\n@@ -1199,10 +1233,10 @@ fn make_body(\n                 match fun.vars_defined_in_body_and_outlive.as_slice() {\n                     [] => {}\n                     [var] => {\n-                        tail_expr = Some(path_expr_from_local(ctx, *var));\n+                        tail_expr = Some(path_expr_from_local(ctx, var.local));\n                     }\n                     vars => {\n-                        let exprs = vars.iter().map(|var| path_expr_from_local(ctx, *var));\n+                        let exprs = vars.iter().map(|var| path_expr_from_local(ctx, var.local));\n                         let expr = make::expr_tuple(exprs);\n                         tail_expr = Some(expr);\n                     }\n@@ -2110,6 +2144,30 @@ fn $0fun_name(n: i32) -> i32 {\n         );\n     }\n \n+    #[test]\n+    fn variable_defined_inside_and_used_after_mutably_no_ret() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() {\n+    let n = 1;\n+    $0let mut k = n * n;$0\n+    k += 1;\n+}\",\n+            r\"\n+fn foo() {\n+    let n = 1;\n+    let mut k = fun_name(n);\n+    k += 1;\n+}\n+\n+fn $0fun_name(n: i32) -> i32 {\n+    let mut k = n * n;\n+    k\n+}\",\n+        );\n+    }\n+\n     #[test]\n     fn two_variables_defined_inside_and_used_after_no_ret() {\n         check_assist(\n@@ -2136,6 +2194,38 @@ fn $0fun_name(n: i32) -> (i32, i32) {\n         );\n     }\n \n+    #[test]\n+    fn multi_variables_defined_inside_and_used_after_mutably_no_ret() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() {\n+    let n = 1;\n+    $0let mut k = n * n;\n+    let mut m = k + 2;\n+    let mut o = m + 3;\n+    o += 1;$0\n+    k += o;\n+    m = 1;\n+}\",\n+            r\"\n+fn foo() {\n+    let n = 1;\n+    let (mut k, mut m, o) = fun_name(n);\n+    k += o;\n+    m = 1;\n+}\n+\n+fn $0fun_name(n: i32) -> (i32, i32, i32) {\n+    let mut k = n * n;\n+    let mut m = k + 2;\n+    let mut o = m + 3;\n+    o += 1;\n+    (k, m, o)\n+}\",\n+        );\n+    }\n+\n     #[test]\n     fn nontrivial_patterns_define_variables() {\n         check_assist("}]}