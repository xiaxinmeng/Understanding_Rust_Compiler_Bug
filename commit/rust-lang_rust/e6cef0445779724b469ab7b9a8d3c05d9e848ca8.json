{"sha": "e6cef0445779724b469ab7b9a8d3c05d9e848ca8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2Y2VmMDQ0NTc3OTcyNGI0NjlhYjdiOWE4ZDNjMDVkOWU4NDhjYTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-05T13:00:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-05T13:00:36Z"}, "message": "Auto merge of #70807 - Dylan-DPC:rollup-qd1kgl2, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #70558 (Fix some aliasing issues in Vec)\n - #70760 (docs: make the description of Result::map_or more clear)\n - #70769 (Miri: remove an outdated FIXME)\n - #70776 (clarify comment in RawVec::into_box)\n - #70806 (fix Miri assignment sanity check)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "5bd98427f0b156eee15487f9d155530335b6bde5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bd98427f0b156eee15487f9d155530335b6bde5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6cef0445779724b469ab7b9a8d3c05d9e848ca8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6cef0445779724b469ab7b9a8d3c05d9e848ca8", "html_url": "https://github.com/rust-lang/rust/commit/e6cef0445779724b469ab7b9a8d3c05d9e848ca8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6cef0445779724b469ab7b9a8d3c05d9e848ca8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "607b8582362be8e26df7acc12fa242359d7edf95", "url": "https://api.github.com/repos/rust-lang/rust/commits/607b8582362be8e26df7acc12fa242359d7edf95", "html_url": "https://github.com/rust-lang/rust/commit/607b8582362be8e26df7acc12fa242359d7edf95"}, {"sha": "31b8d65803c88e4e267b3aedb81164bf63ef99f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/31b8d65803c88e4e267b3aedb81164bf63ef99f3", "html_url": "https://github.com/rust-lang/rust/commit/31b8d65803c88e4e267b3aedb81164bf63ef99f3"}], "stats": {"total": 177, "additions": 138, "deletions": 39}, "files": [{"sha": "7ac67870eb751c717dd8d91f91fffd010f2e1daf", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e6cef0445779724b469ab7b9a8d3c05d9e848ca8/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6cef0445779724b469ab7b9a8d3c05d9e848ca8/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=e6cef0445779724b469ab7b9a8d3c05d9e848ca8", "patch": "@@ -570,16 +570,19 @@ impl<T> RawVec<T, Global> {\n     ///\n     /// # Safety\n     ///\n-    /// `shrink_to_fit(len)` must be called immediately prior to calling this function. This\n-    /// implies, that `len` must be smaller than or equal to `self.capacity()`.\n+    /// * `len` must be greater than or equal to the most recently requested capacity, and\n+    /// * `len` must be less than or equal to `self.capacity()`.\n+    ///\n+    /// Note, that the requested capacity and `self.capacity()` could differ, as\n+    /// an allocator could overallocate and return a greater memory block than requested.\n     pub unsafe fn into_box(self, len: usize) -> Box<[MaybeUninit<T>]> {\n+        // Sanity-check one half of the safety requirement (we cannot check the other half).\n         debug_assert!(\n             len <= self.capacity(),\n             \"`len` must be smaller than or equal to `self.capacity()`\"\n         );\n \n         let me = ManuallyDrop::new(self);\n-        // NOTE: not calling `capacity()` here; actually using the real `cap` field!\n         let slice = slice::from_raw_parts_mut(me.ptr() as *mut MaybeUninit<T>, len);\n         Box::from_raw(slice)\n     }"}, {"sha": "6321e7154e7d091e7617a6007e79522185f84876", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 66, "deletions": 5, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e6cef0445779724b469ab7b9a8d3c05d9e848ca8/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6cef0445779724b469ab7b9a8d3c05d9e848ca8/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=e6cef0445779724b469ab7b9a8d3c05d9e848ca8", "patch": "@@ -1351,24 +1351,85 @@ fn test_try_reserve_exact() {\n }\n \n #[test]\n-fn test_stable_push_pop() {\n+fn test_stable_pointers() {\n+    /// Pull an element from the iterator, then drop it.\n+    /// Useful to cover both the `next` and `drop` paths of an iterator.\n+    fn next_then_drop<I: Iterator>(mut i: I) {\n+        i.next().unwrap();\n+        drop(i);\n+    }\n+\n     // Test that, if we reserved enough space, adding and removing elements does not\n     // invalidate references into the vector (such as `v0`).  This test also\n     // runs in Miri, which would detect such problems.\n-    let mut v = Vec::with_capacity(10);\n+    let mut v = Vec::with_capacity(128);\n     v.push(13);\n \n-    // laundering the lifetime -- we take care that `v` does not reallocate, so that's okay.\n-    let v0 = unsafe { &*(&v[0] as *const _) };\n-\n+    // Laundering the lifetime -- we take care that `v` does not reallocate, so that's okay.\n+    let v0 = &mut v[0];\n+    let v0 = unsafe { &mut *(v0 as *mut _) };\n     // Now do a bunch of things and occasionally use `v0` again to assert it is still valid.\n+\n+    // Pushing/inserting and popping/removing\n     v.push(1);\n     v.push(2);\n     v.insert(1, 1);\n     assert_eq!(*v0, 13);\n     v.remove(1);\n     v.pop().unwrap();\n     assert_eq!(*v0, 13);\n+    v.push(1);\n+    v.swap_remove(1);\n+    assert_eq!(v.len(), 2);\n+    v.swap_remove(1); // swap_remove the last element\n+    assert_eq!(*v0, 13);\n+\n+    // Appending\n+    v.append(&mut vec![27, 19]);\n+    assert_eq!(*v0, 13);\n+\n+    // Extending\n+    v.extend_from_slice(&[1, 2]);\n+    v.extend(&[1, 2]); // `slice::Iter` (with `T: Copy`) specialization\n+    v.extend(vec![2, 3]); // `vec::IntoIter` specialization\n+    v.extend(std::iter::once(3)); // `TrustedLen` specialization\n+    v.extend(std::iter::empty::<i32>()); // `TrustedLen` specialization with empty iterator\n+    v.extend(std::iter::once(3).filter(|_| true)); // base case\n+    v.extend(std::iter::once(&3)); // `cloned` specialization\n+    assert_eq!(*v0, 13);\n+\n+    // Truncation\n+    v.truncate(2);\n+    assert_eq!(*v0, 13);\n+\n+    // Resizing\n+    v.resize_with(v.len() + 10, || 42);\n+    assert_eq!(*v0, 13);\n+    v.resize_with(2, || panic!());\n+    assert_eq!(*v0, 13);\n+\n+    // No-op reservation\n+    v.reserve(32);\n+    v.reserve_exact(32);\n+    assert_eq!(*v0, 13);\n+\n+    // Partial draining\n+    v.resize_with(10, || 42);\n+    next_then_drop(v.drain(5..));\n+    assert_eq!(*v0, 13);\n+\n+    // Splicing\n+    v.resize_with(10, || 42);\n+    next_then_drop(v.splice(5.., vec![1, 2, 3, 4, 5])); // empty tail after range\n+    assert_eq!(*v0, 13);\n+    next_then_drop(v.splice(5..8, vec![1])); // replacement is smaller than original range\n+    assert_eq!(*v0, 13);\n+    next_then_drop(v.splice(5..6, vec![1; 10].into_iter().filter(|_| true))); // lower bound not exact\n+    assert_eq!(*v0, 13);\n+\n+    // Smoke test that would fire even outside Miri if an actual relocation happened.\n+    *v0 -= 13;\n+    assert_eq!(v[0], 0);\n }\n \n // https://github.com/rust-lang/rust/pull/49496 introduced specialization based on:"}, {"sha": "a48e48d7da31e6d6748ec6d925e4f2c36f6c7aae", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e6cef0445779724b469ab7b9a8d3c05d9e848ca8/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6cef0445779724b469ab7b9a8d3c05d9e848ca8/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=e6cef0445779724b469ab7b9a8d3c05d9e848ca8", "patch": "@@ -740,7 +740,8 @@ impl<T> Vec<T> {\n             if len > self.len {\n                 return;\n             }\n-            let s = self.get_unchecked_mut(len..) as *mut _;\n+            let remaining_len = self.len - len;\n+            let s = slice::from_raw_parts_mut(self.as_mut_ptr().add(len), remaining_len);\n             self.len = len;\n             ptr::drop_in_place(s);\n         }\n@@ -963,13 +964,15 @@ impl<T> Vec<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn swap_remove(&mut self, index: usize) -> T {\n+        let len = self.len();\n+        assert!(index < len);\n         unsafe {\n             // We replace self[index] with the last element. Note that if the\n-            // bounds check on hole succeeds there must be a last element (which\n+            // bounds check above succeeds there must be a last element (which\n             // can be self[index] itself).\n-            let hole: *mut T = &mut self[index];\n-            let last = ptr::read(self.get_unchecked(self.len - 1));\n-            self.len -= 1;\n+            let last = ptr::read(self.as_ptr().add(len - 1));\n+            let hole: *mut T = self.as_mut_ptr().add(index);\n+            self.set_len(len - 1);\n             ptr::replace(hole, last)\n         }\n     }\n@@ -1200,7 +1203,7 @@ impl<T> Vec<T> {\n         } else {\n             unsafe {\n                 self.len -= 1;\n-                Some(ptr::read(self.get_unchecked(self.len())))\n+                Some(ptr::read(self.as_ptr().add(self.len())))\n             }\n         }\n     }\n@@ -2020,7 +2023,7 @@ where\n                 let (lower, _) = iterator.size_hint();\n                 let mut vector = Vec::with_capacity(lower.saturating_add(1));\n                 unsafe {\n-                    ptr::write(vector.get_unchecked_mut(0), element);\n+                    ptr::write(vector.as_mut_ptr(), element);\n                     vector.set_len(1);\n                 }\n                 vector\n@@ -2122,8 +2125,9 @@ where\n         self.reserve(slice.len());\n         unsafe {\n             let len = self.len();\n+            let dst_slice = slice::from_raw_parts_mut(self.as_mut_ptr().add(len), slice.len());\n+            dst_slice.copy_from_slice(slice);\n             self.set_len(len + slice.len());\n-            self.get_unchecked_mut(len..).copy_from_slice(slice);\n         }\n     }\n }\n@@ -2144,7 +2148,7 @@ impl<T> Vec<T> {\n                 self.reserve(lower.saturating_add(1));\n             }\n             unsafe {\n-                ptr::write(self.get_unchecked_mut(len), element);\n+                ptr::write(self.as_mut_ptr().add(len), element);\n                 // NB can't overflow since we would have had to alloc the address space\n                 self.set_len(len + 1);\n             }"}, {"sha": "c7b5777a16e7f7459c8d89f4f9b3b5a5f3d1f3ee", "filename": "src/libcore/result.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6cef0445779724b469ab7b9a8d3c05d9e848ca8/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6cef0445779724b469ab7b9a8d3c05d9e848ca8/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=e6cef0445779724b469ab7b9a8d3c05d9e848ca8", "patch": "@@ -521,14 +521,16 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Applies a function to the contained value (if any),\n-    /// or returns the provided default (if not).\n+    /// Applies a function to the contained value (if [`Ok`]),\n+    /// or returns the provided default (if [`Err`]).\n     ///\n     /// Arguments passed to `map_or` are eagerly evaluated; if you are passing\n     /// the result of a function call, it is recommended to use [`map_or_else`],\n     /// which is lazily evaluated.\n     ///\n     /// [`map_or_else`]: #method.map_or_else\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///"}, {"sha": "0b182d42287159f0875dac674eb5823ee2df5bf8", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e6cef0445779724b469ab7b9a8d3c05d9e848ca8/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6cef0445779724b469ab7b9a8d3c05d9e848ca8/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=e6cef0445779724b469ab7b9a8d3c05d9e848ca8", "patch": "@@ -14,11 +14,11 @@ use rustc_middle::mir::interpret::{\n     sign_extend, truncate, AllocId, FrameInfo, GlobalId, InterpResult, Pointer, Scalar,\n };\n use rustc_middle::ty::layout::{self, TyAndLayout};\n-use rustc_middle::ty::query::TyCtxtAt;\n-use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{\n+    self, fold::BottomUpFolder, query::TyCtxtAt, subst::SubstsRef, Ty, TyCtxt, TypeFoldable,\n+};\n use rustc_span::source_map::DUMMY_SP;\n-use rustc_target::abi::{Abi, Align, HasDataLayout, LayoutOf, Size, TargetDataLayout};\n+use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Size, TargetDataLayout};\n \n use super::{\n     Immediate, MPlaceTy, Machine, MemPlace, MemPlaceMeta, Memory, OpTy, Operand, Place, PlaceTy,\n@@ -213,30 +213,50 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for InterpCx<'mir, 'tcx, M> {\n /// Test if it is valid for a MIR assignment to assign `src`-typed place to `dest`-typed value.\n /// This test should be symmetric, as it is primarily about layout compatibility.\n pub(super) fn mir_assign_valid_types<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     src: TyAndLayout<'tcx>,\n     dest: TyAndLayout<'tcx>,\n ) -> bool {\n     if src.ty == dest.ty {\n         // Equal types, all is good.\n         return true;\n     }\n-    // Type-changing assignments can happen for (at least) two reasons:\n-    // - `&mut T` -> `&T` gets optimized from a reborrow to a mere assignment.\n-    // - Subtyping is used. While all normal lifetimes are erased, higher-ranked lifetime\n-    //   bounds are still around and can lead to type differences.\n-    // There is no good way to check the latter, so we compare layouts instead -- but only\n-    // for values with `Scalar`/`ScalarPair` abi.\n-    // FIXME: Do something more accurate, type-based.\n-    match &src.abi {\n-        Abi::Scalar(..) | Abi::ScalarPair(..) => src.layout == dest.layout,\n-        _ => false,\n+    if src.layout != dest.layout {\n+        // Layout differs, definitely not equal.\n+        // We do this here because Miri would *do the wrong thing* if we allowed layout-changing\n+        // assignments.\n+        return false;\n     }\n+\n+    // Type-changing assignments can happen for (at least) two reasons:\n+    // 1. `&mut T` -> `&T` gets optimized from a reborrow to a mere assignment.\n+    // 2. Subtyping is used. While all normal lifetimes are erased, higher-ranked types\n+    //    with their late-bound lifetimes are still around and can lead to type differences.\n+    // Normalize both of them away.\n+    let normalize = |ty: Ty<'tcx>| {\n+        ty.fold_with(&mut BottomUpFolder {\n+            tcx,\n+            // Normalize all references to immutable.\n+            ty_op: |ty| match ty.kind {\n+                ty::Ref(_, pointee, _) => tcx.mk_imm_ref(tcx.lifetimes.re_erased, pointee),\n+                _ => ty,\n+            },\n+            // We just erase all late-bound lifetimes, but this is not fully correct (FIXME):\n+            // lifetimes in invariant positions could matter (e.g. through associated types).\n+            // We rely on the fact that layout was confirmed to be equal above.\n+            lt_op: |_| tcx.lifetimes.re_erased,\n+            // Leave consts unchanged.\n+            ct_op: |ct| ct,\n+        })\n+    };\n+    normalize(src.ty) == normalize(dest.ty)\n }\n \n /// Use the already known layout if given (but sanity check in debug mode),\n /// or compute the layout.\n #[cfg_attr(not(debug_assertions), inline(always))]\n pub(super) fn from_known_layout<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     known_layout: Option<TyAndLayout<'tcx>>,\n     compute: impl FnOnce() -> InterpResult<'tcx, TyAndLayout<'tcx>>,\n ) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n@@ -246,7 +266,7 @@ pub(super) fn from_known_layout<'tcx>(\n             if cfg!(debug_assertions) {\n                 let check_layout = compute()?;\n                 assert!(\n-                    mir_assign_valid_types(check_layout, known_layout),\n+                    mir_assign_valid_types(tcx, check_layout, known_layout),\n                     \"expected type differs from actual type.\\nexpected: {:?}\\nactual: {:?}\",\n                     known_layout.ty,\n                     check_layout.ty,\n@@ -424,7 +444,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // have to support that case (mostly by skipping all caching).\n         match frame.locals.get(local).and_then(|state| state.layout.get()) {\n             None => {\n-                let layout = from_known_layout(layout, || {\n+                let layout = from_known_layout(self.tcx.tcx, layout, || {\n                     let local_ty = frame.body.local_decls[local].ty;\n                     let local_ty =\n                         self.subst_from_frame_and_normalize_erasing_regions(frame, local_ty);"}, {"sha": "03614b2803f65fe2e33091aeabe14e5f3dbff03d", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6cef0445779724b469ab7b9a8d3c05d9e848ca8/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6cef0445779724b469ab7b9a8d3c05d9e848ca8/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=e6cef0445779724b469ab7b9a8d3c05d9e848ca8", "patch": "@@ -529,7 +529,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ty::ConstKind::Value(val_val) => val_val,\n         };\n         // Other cases need layout.\n-        let layout = from_known_layout(layout, || self.layout_of(val.ty))?;\n+        let layout = from_known_layout(self.tcx.tcx, layout, || self.layout_of(val.ty))?;\n         let op = match val_val {\n             ConstValue::ByRef { alloc, offset } => {\n                 let id = self.tcx.alloc_map.lock().create_memory_alloc(alloc);"}, {"sha": "716c7c7d933677863efd504fc75d86d9acf8559b", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6cef0445779724b469ab7b9a8d3c05d9e848ca8/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6cef0445779724b469ab7b9a8d3c05d9e848ca8/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=e6cef0445779724b469ab7b9a8d3c05d9e848ca8", "patch": "@@ -868,7 +868,7 @@ where\n         // We do NOT compare the types for equality, because well-typed code can\n         // actually \"transmute\" `&mut T` to `&T` in an assignment without a cast.\n         assert!(\n-            mir_assign_valid_types(src.layout, dest.layout),\n+            mir_assign_valid_types(self.tcx.tcx, src.layout, dest.layout),\n             \"type mismatch when copying!\\nsrc: {:?},\\ndest: {:?}\",\n             src.layout.ty,\n             dest.layout.ty,\n@@ -922,7 +922,7 @@ where\n         src: OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        if mir_assign_valid_types(src.layout, dest.layout) {\n+        if mir_assign_valid_types(self.tcx.tcx, src.layout, dest.layout) {\n             // Fast path: Just use normal `copy_op`\n             return self.copy_op(src, dest);\n         }"}, {"sha": "6ebe5b80370cac86eb40c3ef4dbf64dac7492950", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e6cef0445779724b469ab7b9a8d3c05d9e848ca8/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6cef0445779724b469ab7b9a8d3c05d9e848ca8/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=e6cef0445779724b469ab7b9a8d3c05d9e848ca8", "patch": "@@ -75,7 +75,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             Drop { location, target, unwind } => {\n-                // FIXME(CTFE): forbid drop in const eval\n                 let place = self.eval_place(location)?;\n                 let ty = place.layout.ty;\n                 trace!(\"TerminatorKind::drop: {:?}, type {}\", location, ty);"}, {"sha": "59d46ea66c9ca66d6719dd609ef31b83b5b8da28", "filename": "src/test/ui/consts/const-eval/issue-70804-fn-subtyping.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e6cef0445779724b469ab7b9a8d3c05d9e848ca8/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-70804-fn-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6cef0445779724b469ab7b9a8d3c05d9e848ca8/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-70804-fn-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-70804-fn-subtyping.rs?ref=e6cef0445779724b469ab7b9a8d3c05d9e848ca8", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+#![feature(const_fn)]\n+\n+const fn nested(x: (for<'a> fn(&'a ()), String)) -> (fn(&'static ()), String) {\n+    x\n+}\n+\n+pub const TEST: (fn(&'static ()), String) = nested((|_x| (), String::new()));\n+\n+fn main() {}"}]}