{"sha": "6d26ea86dac0eb987b338bf3ba5f3900fd68f000", "node_id": "C_kwDOAAsO6NoAKDZkMjZlYTg2ZGFjMGViOTg3YjMzOGJmM2JhNWYzOTAwZmQ2OGYwMDA", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-11-05T20:04:19Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-11-06T12:25:06Z"}, "message": "Rename `Ctxt` and `CTX` to `Tcx` and `Qcx`\n\nThis makes it consistent and clear which context is used.", "tree": {"sha": "58e3926aef58d5e5b5588b7b07eae12bedeb5a99", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58e3926aef58d5e5b5588b7b07eae12bedeb5a99"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d26ea86dac0eb987b338bf3ba5f3900fd68f000", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN SSH SIGNATURE-----\nU1NIU0lHAAAAAQAAADMAAAALc3NoLWVkMjU1MTkAAAAgbSfWKRQb2tiqhuHtakDJeupmrF\nChDbM0msU+PXaBOk8AAAADZ2l0AAAAAAAAAAZzaGE1MTIAAABTAAAAC3NzaC1lZDI1NTE5\nAAAAQGhEnbhd/S9xLa2KjnibxgBw2LLsU95Y2F0QzWIeK1kOU955jVJz0GwSm0WQcLs81S\nPEMJ3ZDYkNmnwUV7lQ3AM=\n-----END SSH SIGNATURE-----", "payload": "tree 58e3926aef58d5e5b5588b7b07eae12bedeb5a99\nparent 16558bd26740085c5ae3dd27ae1d01cc39d18f2f\nauthor Nilstrieb <48135649+Nilstrieb@users.noreply.github.com> 1667678659 +0100\ncommitter Nilstrieb <48135649+Nilstrieb@users.noreply.github.com> 1667737506 +0100\n\nRename `Ctxt` and `CTX` to `Tcx` and `Qcx`\n\nThis makes it consistent and clear which context is used.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d26ea86dac0eb987b338bf3ba5f3900fd68f000", "html_url": "https://github.com/rust-lang/rust/commit/6d26ea86dac0eb987b338bf3ba5f3900fd68f000", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d26ea86dac0eb987b338bf3ba5f3900fd68f000/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16558bd26740085c5ae3dd27ae1d01cc39d18f2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/16558bd26740085c5ae3dd27ae1d01cc39d18f2f", "html_url": "https://github.com/rust-lang/rust/commit/16558bd26740085c5ae3dd27ae1d01cc39d18f2f"}], "stats": {"total": 218, "additions": 109, "deletions": 109}, "files": [{"sha": "7cc885be2ba6a6319b51e783e1d03efc97f344a1", "filename": "compiler/rustc_query_system/src/cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d26ea86dac0eb987b338bf3ba5f3900fd68f000/compiler%2Frustc_query_system%2Fsrc%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d26ea86dac0eb987b338bf3ba5f3900fd68f000/compiler%2Frustc_query_system%2Fsrc%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fcache.rs?ref=6d26ea86dac0eb987b338bf3ba5f3900fd68f000", "patch": "@@ -26,7 +26,7 @@ impl<Key, Value> Cache<Key, Value> {\n }\n \n impl<Key: Eq + Hash, Value: Clone> Cache<Key, Value> {\n-    pub fn get<CTX: DepContext>(&self, key: &Key, tcx: CTX) -> Option<Value> {\n+    pub fn get<Tcx: DepContext>(&self, key: &Key, tcx: Tcx) -> Option<Value> {\n         Some(self.hashmap.borrow().get(key)?.get(tcx))\n     }\n \n@@ -46,7 +46,7 @@ impl<T: Clone> WithDepNode<T> {\n         WithDepNode { dep_node, cached_value }\n     }\n \n-    pub fn get<CTX: DepContext>(&self, tcx: CTX) -> T {\n+    pub fn get<Tcx: DepContext>(&self, tcx: Tcx) -> T {\n         tcx.dep_graph().read_index(self.dep_node);\n         self.cached_value.clone()\n     }"}, {"sha": "d79c5816a9c40bb1fc0d3aab18113ae01af46ea8", "filename": "compiler/rustc_query_system/src/dep_graph/dep_node.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6d26ea86dac0eb987b338bf3ba5f3900fd68f000/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d26ea86dac0eb987b338bf3ba5f3900fd68f000/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=6d26ea86dac0eb987b338bf3ba5f3900fd68f000", "patch": "@@ -61,18 +61,18 @@ impl<K: DepKind> DepNode<K> {\n     /// Creates a new, parameterless DepNode. This method will assert\n     /// that the DepNode corresponding to the given DepKind actually\n     /// does not require any parameters.\n-    pub fn new_no_params<Ctxt>(tcx: Ctxt, kind: K) -> DepNode<K>\n+    pub fn new_no_params<Tcx>(tcx: Tcx, kind: K) -> DepNode<K>\n     where\n-        Ctxt: super::DepContext<DepKind = K>,\n+        Tcx: super::DepContext<DepKind = K>,\n     {\n         debug_assert_eq!(tcx.fingerprint_style(kind), FingerprintStyle::Unit);\n         DepNode { kind, hash: Fingerprint::ZERO.into() }\n     }\n \n-    pub fn construct<Ctxt, Key>(tcx: Ctxt, kind: K, arg: &Key) -> DepNode<K>\n+    pub fn construct<Tcx, Key>(tcx: Tcx, kind: K, arg: &Key) -> DepNode<K>\n     where\n-        Ctxt: super::DepContext<DepKind = K>,\n-        Key: DepNodeParams<Ctxt>,\n+        Tcx: super::DepContext<DepKind = K>,\n+        Key: DepNodeParams<Tcx>,\n     {\n         let hash = arg.to_fingerprint(tcx);\n         let dep_node = DepNode { kind, hash: hash.into() };\n@@ -93,9 +93,9 @@ impl<K: DepKind> DepNode<K> {\n     /// Construct a DepNode from the given DepKind and DefPathHash. This\n     /// method will assert that the given DepKind actually requires a\n     /// single DefId/DefPathHash parameter.\n-    pub fn from_def_path_hash<Ctxt>(tcx: Ctxt, def_path_hash: DefPathHash, kind: K) -> Self\n+    pub fn from_def_path_hash<Tcx>(tcx: Tcx, def_path_hash: DefPathHash, kind: K) -> Self\n     where\n-        Ctxt: super::DepContext<DepKind = K>,\n+        Tcx: super::DepContext<DepKind = K>,\n     {\n         debug_assert!(tcx.fingerprint_style(kind) == FingerprintStyle::DefPathHash);\n         DepNode { kind, hash: def_path_hash.0.into() }\n@@ -108,18 +108,18 @@ impl<K: DepKind> fmt::Debug for DepNode<K> {\n     }\n }\n \n-pub trait DepNodeParams<Ctxt: DepContext>: fmt::Debug + Sized {\n+pub trait DepNodeParams<Tcx: DepContext>: fmt::Debug + Sized {\n     fn fingerprint_style() -> FingerprintStyle;\n \n     /// This method turns the parameters of a DepNodeConstructor into an opaque\n     /// Fingerprint to be used in DepNode.\n     /// Not all DepNodeParams support being turned into a Fingerprint (they\n     /// don't need to if the corresponding DepNode is anonymous).\n-    fn to_fingerprint(&self, _: Ctxt) -> Fingerprint {\n+    fn to_fingerprint(&self, _: Tcx) -> Fingerprint {\n         panic!(\"Not implemented. Accidentally called on anonymous node?\")\n     }\n \n-    fn to_debug_str(&self, _: Ctxt) -> String {\n+    fn to_debug_str(&self, _: Tcx) -> String {\n         format!(\"{:?}\", self)\n     }\n \n@@ -129,10 +129,10 @@ pub trait DepNodeParams<Ctxt: DepContext>: fmt::Debug + Sized {\n     /// `fingerprint_style()` is not `FingerprintStyle::Opaque`.\n     /// It is always valid to return `None` here, in which case incremental\n     /// compilation will treat the query as having changed instead of forcing it.\n-    fn recover(tcx: Ctxt, dep_node: &DepNode<Ctxt::DepKind>) -> Option<Self>;\n+    fn recover(tcx: Tcx, dep_node: &DepNode<Tcx::DepKind>) -> Option<Self>;\n }\n \n-impl<Ctxt: DepContext, T> DepNodeParams<Ctxt> for T\n+impl<Tcx: DepContext, T> DepNodeParams<Tcx> for T\n where\n     T: for<'a> HashStable<StableHashingContext<'a>> + fmt::Debug,\n {\n@@ -142,7 +142,7 @@ where\n     }\n \n     #[inline(always)]\n-    default fn to_fingerprint(&self, tcx: Ctxt) -> Fingerprint {\n+    default fn to_fingerprint(&self, tcx: Tcx) -> Fingerprint {\n         tcx.with_stable_hashing_context(|mut hcx| {\n             let mut hasher = StableHasher::new();\n             self.hash_stable(&mut hcx, &mut hasher);\n@@ -151,12 +151,12 @@ where\n     }\n \n     #[inline(always)]\n-    default fn to_debug_str(&self, _: Ctxt) -> String {\n+    default fn to_debug_str(&self, _: Tcx) -> String {\n         format!(\"{:?}\", *self)\n     }\n \n     #[inline(always)]\n-    default fn recover(_: Ctxt, _: &DepNode<Ctxt::DepKind>) -> Option<Self> {\n+    default fn recover(_: Tcx, _: &DepNode<Tcx::DepKind>) -> Option<Self> {\n         None\n     }\n }\n@@ -166,7 +166,7 @@ where\n /// Information is retrieved by indexing the `DEP_KINDS` array using the integer value\n /// of the `DepKind`. Overall, this allows to implement `DepContext` using this manual\n /// jump table instead of large matches.\n-pub struct DepKindStruct<CTX: DepContext> {\n+pub struct DepKindStruct<Tcx: DepContext> {\n     /// Anonymous queries cannot be replayed from one compiler invocation to the next.\n     /// When their result is needed, it is recomputed. They are useful for fine-grained\n     /// dependency tracking, and caching within one compiler invocation.\n@@ -216,10 +216,10 @@ pub struct DepKindStruct<CTX: DepContext> {\n     /// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n     /// is actually a `DefPathHash`, and can therefore just look up the corresponding\n     /// `DefId` in `tcx.def_path_hash_to_def_id`.\n-    pub force_from_dep_node: Option<fn(tcx: CTX, dep_node: DepNode<CTX::DepKind>) -> bool>,\n+    pub force_from_dep_node: Option<fn(tcx: Tcx, dep_node: DepNode<Tcx::DepKind>) -> bool>,\n \n     /// Invoke a query to put the on-disk cached value in memory.\n-    pub try_load_from_on_disk_cache: Option<fn(CTX, DepNode<CTX::DepKind>)>,\n+    pub try_load_from_on_disk_cache: Option<fn(Tcx, DepNode<Tcx::DepKind>)>,\n }\n \n /// A \"work product\" corresponds to a `.o` (or other) file that we"}, {"sha": "d86c0bebdcdf4d2166cabe7918dca9dd925b5fba", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6d26ea86dac0eb987b338bf3ba5f3900fd68f000/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d26ea86dac0eb987b338bf3ba5f3900fd68f000/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=6d26ea86dac0eb987b338bf3ba5f3900fd68f000", "patch": "@@ -377,9 +377,9 @@ impl<K: DepKind> DepGraph<K> {\n \n     /// Executes something within an \"anonymous\" task, that is, a task the\n     /// `DepNode` of which is determined by the list of inputs it read from.\n-    pub fn with_anon_task<Ctxt: DepContext<DepKind = K>, OP, R>(\n+    pub fn with_anon_task<Tcx: DepContext<DepKind = K>, OP, R>(\n         &self,\n-        cx: Ctxt,\n+        cx: Tcx,\n         dep_kind: K,\n         op: OP,\n     ) -> (R, DepNodeIndex)\n@@ -571,9 +571,9 @@ impl<K: DepKind> DepGraph<K> {\n     /// A node will have an index, when it's already been marked green, or when we can mark it\n     /// green. This function will mark the current task as a reader of the specified node, when\n     /// a node index can be found for that node.\n-    pub fn try_mark_green<Ctxt: QueryContext<DepKind = K>>(\n+    pub fn try_mark_green<Qcx: QueryContext<DepKind = K>>(\n         &self,\n-        qcx: Ctxt,\n+        qcx: Qcx,\n         dep_node: &DepNode<K>,\n     ) -> Option<(SerializedDepNodeIndex, DepNodeIndex)> {\n         debug_assert!(!qcx.dep_context().is_eval_always(dep_node.kind));\n@@ -599,9 +599,9 @@ impl<K: DepKind> DepGraph<K> {\n     }\n \n     #[instrument(skip(self, qcx, data, parent_dep_node_index), level = \"debug\")]\n-    fn try_mark_parent_green<Ctxt: QueryContext<DepKind = K>>(\n+    fn try_mark_parent_green<Qcx: QueryContext<DepKind = K>>(\n         &self,\n-        qcx: Ctxt,\n+        qcx: Qcx,\n         data: &DepGraphData<K>,\n         parent_dep_node_index: SerializedDepNodeIndex,\n         dep_node: &DepNode<K>,\n@@ -687,9 +687,9 @@ impl<K: DepKind> DepGraph<K> {\n \n     /// Try to mark a dep-node which existed in the previous compilation session as green.\n     #[instrument(skip(self, qcx, data, prev_dep_node_index), level = \"debug\")]\n-    fn try_mark_previous_green<Ctxt: QueryContext<DepKind = K>>(\n+    fn try_mark_previous_green<Qcx: QueryContext<DepKind = K>>(\n         &self,\n-        qcx: Ctxt,\n+        qcx: Qcx,\n         data: &DepGraphData<K>,\n         prev_dep_node_index: SerializedDepNodeIndex,\n         dep_node: &DepNode<K>,\n@@ -755,9 +755,9 @@ impl<K: DepKind> DepGraph<K> {\n     /// This may be called concurrently on multiple threads for the same dep node.\n     #[cold]\n     #[inline(never)]\n-    fn emit_side_effects<Ctxt: QueryContext<DepKind = K>>(\n+    fn emit_side_effects<Qcx: QueryContext<DepKind = K>>(\n         &self,\n-        qcx: Ctxt,\n+        qcx: Qcx,\n         data: &DepGraphData<K>,\n         dep_node_index: DepNodeIndex,\n         side_effects: QuerySideEffects,\n@@ -799,7 +799,7 @@ impl<K: DepKind> DepGraph<K> {\n     //\n     // This method will only load queries that will end up in the disk cache.\n     // Other queries will not be executed.\n-    pub fn exec_cache_promotions<Ctxt: DepContext<DepKind = K>>(&self, tcx: Ctxt) {\n+    pub fn exec_cache_promotions<Tcx: DepContext<DepKind = K>>(&self, tcx: Tcx) {\n         let _prof_timer = tcx.profiler().generic_activity(\"incr_comp_query_cache_promotion\");\n \n         let data = self.data.as_ref().unwrap();"}, {"sha": "f40e174b7e79bf3a885843cd7d462fc29fa8f368", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6d26ea86dac0eb987b338bf3ba5f3900fd68f000/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d26ea86dac0eb987b338bf3ba5f3900fd68f000/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=6d26ea86dac0eb987b338bf3ba5f3900fd68f000", "patch": "@@ -11,7 +11,7 @@ use rustc_data_structures::fingerprint::Fingerprint;\n use std::fmt::Debug;\n use std::hash::Hash;\n \n-pub trait QueryConfig<CTX: QueryContext> {\n+pub trait QueryConfig<Qcx: QueryContext> {\n     const NAME: &'static str;\n \n     type Key: Eq + Hash + Clone + Debug;\n@@ -21,47 +21,47 @@ pub trait QueryConfig<CTX: QueryContext> {\n     type Cache: QueryCache<Key = Self::Key, Stored = Self::Stored, Value = Self::Value>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_state<'a>(tcx: CTX) -> &'a QueryState<Self::Key>\n+    fn query_state<'a>(tcx: Qcx) -> &'a QueryState<Self::Key>\n     where\n-        CTX: 'a;\n+        Qcx: 'a;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_cache<'a>(tcx: CTX) -> &'a Self::Cache\n+    fn query_cache<'a>(tcx: Qcx) -> &'a Self::Cache\n     where\n-        CTX: 'a;\n+        Qcx: 'a;\n \n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n-    fn make_vtable(tcx: CTX, key: &Self::Key) -> QueryVTable<CTX, Self::Key, Self::Value>;\n+    fn make_vtable(tcx: Qcx, key: &Self::Key) -> QueryVTable<Qcx, Self::Key, Self::Value>;\n \n-    fn cache_on_disk(tcx: CTX::DepContext, key: &Self::Key) -> bool;\n+    fn cache_on_disk(tcx: Qcx::DepContext, key: &Self::Key) -> bool;\n \n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n-    fn execute_query(tcx: CTX::DepContext, k: Self::Key) -> Self::Stored;\n+    fn execute_query(tcx: Qcx::DepContext, k: Self::Key) -> Self::Stored;\n }\n \n #[derive(Copy, Clone)]\n-pub struct QueryVTable<CTX: QueryContext, K, V> {\n+pub struct QueryVTable<Qcx: QueryContext, K, V> {\n     pub anon: bool,\n-    pub dep_kind: CTX::DepKind,\n+    pub dep_kind: Qcx::DepKind,\n     pub eval_always: bool,\n     pub depth_limit: bool,\n \n-    pub compute: fn(CTX::DepContext, K) -> V,\n+    pub compute: fn(Qcx::DepContext, K) -> V,\n     pub hash_result: Option<fn(&mut StableHashingContext<'_>, &V) -> Fingerprint>,\n     pub handle_cycle_error: HandleCycleError,\n     // NOTE: this is also `None` if `cache_on_disk()` returns false, not just if it's unsupported by the query\n-    pub try_load_from_disk: Option<fn(CTX, SerializedDepNodeIndex) -> Option<V>>,\n+    pub try_load_from_disk: Option<fn(Qcx, SerializedDepNodeIndex) -> Option<V>>,\n }\n \n-impl<CTX: QueryContext, K, V> QueryVTable<CTX, K, V> {\n-    pub(crate) fn to_dep_node(&self, tcx: CTX::DepContext, key: &K) -> DepNode<CTX::DepKind>\n+impl<Qcx: QueryContext, K, V> QueryVTable<Qcx, K, V> {\n+    pub(crate) fn to_dep_node(&self, tcx: Qcx::DepContext, key: &K) -> DepNode<Qcx::DepKind>\n     where\n-        K: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n+        K: crate::dep_graph::DepNodeParams<Qcx::DepContext>,\n     {\n         DepNode::construct(tcx, self.dep_kind, key)\n     }\n \n-    pub(crate) fn compute(&self, tcx: CTX::DepContext, key: K) -> V {\n+    pub(crate) fn compute(&self, tcx: Qcx::DepContext, key: K) -> V {\n         (self.compute)(tcx, key)\n     }\n }"}, {"sha": "49bbcf57804596623ed30642d0d837d5ba1ca8af", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d26ea86dac0eb987b338bf3ba5f3900fd68f000/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d26ea86dac0eb987b338bf3ba5f3900fd68f000/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=6d26ea86dac0eb987b338bf3ba5f3900fd68f000", "patch": "@@ -596,8 +596,8 @@ pub(crate) fn report_cycle<'a>(\n     cycle_diag.into_diagnostic(&sess.parse_sess.span_diagnostic)\n }\n \n-pub fn print_query_stack<CTX: QueryContext>(\n-    qcx: CTX,\n+pub fn print_query_stack<Qcx: QueryContext>(\n+    qcx: Qcx,\n     mut current_query: Option<QueryJobId>,\n     handler: &Handler,\n     num_frames: Option<usize>,"}, {"sha": "f8d93a27d1c2bbbb3ceff184ae2702235eef9387", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/6d26ea86dac0eb987b338bf3ba5f3900fd68f000/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d26ea86dac0eb987b338bf3ba5f3900fd68f000/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=6d26ea86dac0eb987b338bf3ba5f3900fd68f000", "patch": "@@ -62,10 +62,10 @@ where\n         }\n     }\n \n-    pub fn try_collect_active_jobs<CTX: Copy>(\n+    pub fn try_collect_active_jobs<Qcx: Copy>(\n         &self,\n-        qcx: CTX,\n-        make_query: fn(CTX, K) -> QueryStackFrame,\n+        qcx: Qcx,\n+        make_query: fn(Qcx, K) -> QueryStackFrame,\n         jobs: &mut QueryMap,\n     ) -> Option<()> {\n         #[cfg(parallel_compiler)]\n@@ -119,31 +119,31 @@ where\n \n #[cold]\n #[inline(never)]\n-fn mk_cycle<CTX, V, R>(\n-    qcx: CTX,\n+fn mk_cycle<Qcx, V, R>(\n+    qcx: Qcx,\n     cycle_error: CycleError,\n     handler: HandleCycleError,\n     cache: &dyn crate::query::QueryStorage<Value = V, Stored = R>,\n ) -> R\n where\n-    CTX: QueryContext,\n-    V: std::fmt::Debug + Value<CTX::DepContext>,\n+    Qcx: QueryContext,\n+    V: std::fmt::Debug + Value<Qcx::DepContext>,\n     R: Clone,\n {\n     let error = report_cycle(qcx.dep_context().sess(), &cycle_error);\n     let value = handle_cycle_error(*qcx.dep_context(), &cycle_error, error, handler);\n     cache.store_nocache(value)\n }\n \n-fn handle_cycle_error<CTX, V>(\n-    tcx: CTX,\n+fn handle_cycle_error<Tcx, V>(\n+    tcx: Tcx,\n     cycle_error: &CycleError,\n     mut error: DiagnosticBuilder<'_, ErrorGuaranteed>,\n     handler: HandleCycleError,\n ) -> V\n where\n-    CTX: DepContext,\n-    V: Value<CTX>,\n+    Tcx: DepContext,\n+    V: Value<Tcx>,\n {\n     use HandleCycleError::*;\n     match handler {\n@@ -176,14 +176,14 @@ where\n     /// This function is inlined because that results in a noticeable speed-up\n     /// for some compile-time benchmarks.\n     #[inline(always)]\n-    fn try_start<'b, CTX>(\n-        qcx: &'b CTX,\n+    fn try_start<'b, Qcx>(\n+        qcx: &'b Qcx,\n         state: &'b QueryState<K>,\n         span: Span,\n         key: K,\n     ) -> TryGetJob<'b, K>\n     where\n-        CTX: QueryContext,\n+        Qcx: QueryContext,\n     {\n         #[cfg(parallel_compiler)]\n         let mut state_lock = state.active.get_shard_by_value(&key).lock();\n@@ -335,16 +335,16 @@ where\n /// which will be used if the query is not in the cache and we need\n /// to compute it.\n #[inline]\n-pub fn try_get_cached<'a, CTX, C, R, OnHit>(\n-    tcx: CTX,\n+pub fn try_get_cached<'a, Tcx, C, R, OnHit>(\n+    tcx: Tcx,\n     cache: &'a C,\n     key: &C::Key,\n     // `on_hit` can be called while holding a lock to the query cache\n     on_hit: OnHit,\n ) -> Result<R, ()>\n where\n     C: QueryCache,\n-    CTX: DepContext,\n+    Tcx: DepContext,\n     OnHit: FnOnce(&C::Stored) -> R,\n {\n     cache.lookup(&key, |value, index| {\n@@ -356,20 +356,20 @@ where\n     })\n }\n \n-fn try_execute_query<CTX, C>(\n-    qcx: CTX,\n+fn try_execute_query<Qcx, C>(\n+    qcx: Qcx,\n     state: &QueryState<C::Key>,\n     cache: &C,\n     span: Span,\n     key: C::Key,\n-    dep_node: Option<DepNode<CTX::DepKind>>,\n-    query: &QueryVTable<CTX, C::Key, C::Value>,\n+    dep_node: Option<DepNode<Qcx::DepKind>>,\n+    query: &QueryVTable<Qcx, C::Key, C::Value>,\n ) -> (C::Stored, Option<DepNodeIndex>)\n where\n     C: QueryCache,\n-    C::Key: Clone + DepNodeParams<CTX::DepContext>,\n-    C::Value: Value<CTX::DepContext>,\n-    CTX: QueryContext,\n+    C::Key: Clone + DepNodeParams<Qcx::DepContext>,\n+    C::Value: Value<Qcx::DepContext>,\n+    Qcx: QueryContext,\n {\n     match JobOwner::<'_, C::Key>::try_start(&qcx, state, span, key.clone()) {\n         TryGetJob::NotYetStarted(job) => {\n@@ -397,17 +397,17 @@ where\n     }\n }\n \n-fn execute_job<CTX, K, V>(\n-    qcx: CTX,\n+fn execute_job<Qcx, K, V>(\n+    qcx: Qcx,\n     key: K,\n-    mut dep_node_opt: Option<DepNode<CTX::DepKind>>,\n-    query: &QueryVTable<CTX, K, V>,\n+    mut dep_node_opt: Option<DepNode<Qcx::DepKind>>,\n+    query: &QueryVTable<Qcx, K, V>,\n     job_id: QueryJobId,\n ) -> (V, DepNodeIndex)\n where\n-    K: Clone + DepNodeParams<CTX::DepContext>,\n+    K: Clone + DepNodeParams<Qcx::DepContext>,\n     V: Debug,\n-    CTX: QueryContext,\n+    Qcx: QueryContext,\n {\n     let dep_graph = qcx.dep_context().dep_graph();\n \n@@ -470,15 +470,15 @@ where\n     (result, dep_node_index)\n }\n \n-fn try_load_from_disk_and_cache_in_memory<CTX, K, V>(\n-    qcx: CTX,\n+fn try_load_from_disk_and_cache_in_memory<Qcx, K, V>(\n+    qcx: Qcx,\n     key: &K,\n-    dep_node: &DepNode<CTX::DepKind>,\n-    query: &QueryVTable<CTX, K, V>,\n+    dep_node: &DepNode<Qcx::DepKind>,\n+    query: &QueryVTable<Qcx, K, V>,\n ) -> Option<(V, DepNodeIndex)>\n where\n     K: Clone,\n-    CTX: QueryContext,\n+    Qcx: QueryContext,\n     V: Debug,\n {\n     // Note this function can be called concurrently from the same query\n@@ -564,13 +564,13 @@ where\n }\n \n #[instrument(skip(qcx, result, query), level = \"debug\")]\n-fn incremental_verify_ich<CTX, K, V: Debug>(\n-    qcx: CTX::DepContext,\n+fn incremental_verify_ich<Qcx, K, V: Debug>(\n+    qcx: Qcx::DepContext,\n     result: &V,\n-    dep_node: &DepNode<CTX::DepKind>,\n-    query: &QueryVTable<CTX, K, V>,\n+    dep_node: &DepNode<Qcx::DepKind>,\n+    query: &QueryVTable<Qcx, K, V>,\n ) where\n-    CTX: QueryContext,\n+    Qcx: QueryContext,\n {\n     assert!(\n         qcx.dep_graph().is_green(dep_node),\n@@ -676,14 +676,14 @@ fn incremental_verify_ich_failed(sess: &Session, dep_node: DebugArg<'_>, result:\n ///\n /// Note: The optimization is only available during incr. comp.\n #[inline(never)]\n-fn ensure_must_run<CTX, K, V>(\n-    qcx: CTX,\n+fn ensure_must_run<Qcx, K, V>(\n+    qcx: Qcx,\n     key: &K,\n-    query: &QueryVTable<CTX, K, V>,\n-) -> (bool, Option<DepNode<CTX::DepKind>>)\n+    query: &QueryVTable<Qcx, K, V>,\n+) -> (bool, Option<DepNode<Qcx::DepKind>>)\n where\n-    K: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n-    CTX: QueryContext,\n+    K: crate::dep_graph::DepNodeParams<Qcx::DepContext>,\n+    Qcx: QueryContext,\n {\n     if query.eval_always {\n         return (true, None);\n@@ -719,12 +719,12 @@ pub enum QueryMode {\n     Ensure,\n }\n \n-pub fn get_query<Q, CTX>(qcx: CTX, span: Span, key: Q::Key, mode: QueryMode) -> Option<Q::Stored>\n+pub fn get_query<Q, Qcx>(qcx: Qcx, span: Span, key: Q::Key, mode: QueryMode) -> Option<Q::Stored>\n where\n-    Q: QueryConfig<CTX>,\n-    Q::Key: DepNodeParams<CTX::DepContext>,\n-    Q::Value: Value<CTX::DepContext>,\n-    CTX: QueryContext,\n+    Q: QueryConfig<Qcx>,\n+    Q::Key: DepNodeParams<Qcx::DepContext>,\n+    Q::Value: Value<Qcx::DepContext>,\n+    Qcx: QueryContext,\n {\n     let query = Q::make_vtable(qcx, &key);\n     let dep_node = if let QueryMode::Ensure = mode {\n@@ -752,12 +752,12 @@ where\n     Some(result)\n }\n \n-pub fn force_query<Q, CTX>(qcx: CTX, key: Q::Key, dep_node: DepNode<CTX::DepKind>)\n+pub fn force_query<Q, Qcx>(qcx: Qcx, key: Q::Key, dep_node: DepNode<Qcx::DepKind>)\n where\n-    Q: QueryConfig<CTX>,\n-    Q::Key: DepNodeParams<CTX::DepContext>,\n-    Q::Value: Value<CTX::DepContext>,\n-    CTX: QueryContext,\n+    Q: QueryConfig<Qcx>,\n+    Q::Key: DepNodeParams<Qcx::DepContext>,\n+    Q::Value: Value<Qcx::DepContext>,\n+    Qcx: QueryContext,\n {\n     // We may be concurrently trying both execute and force a query.\n     // Ensure that only one of them runs the query."}, {"sha": "214656abed4dfeb3d13c858faeb67eec9db82830", "filename": "compiler/rustc_query_system/src/values.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d26ea86dac0eb987b338bf3ba5f3900fd68f000/compiler%2Frustc_query_system%2Fsrc%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d26ea86dac0eb987b338bf3ba5f3900fd68f000/compiler%2Frustc_query_system%2Fsrc%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fvalues.rs?ref=6d26ea86dac0eb987b338bf3ba5f3900fd68f000", "patch": "@@ -1,12 +1,12 @@\n use crate::dep_graph::DepContext;\n use crate::query::QueryInfo;\n \n-pub trait Value<CTX: DepContext>: Sized {\n-    fn from_cycle_error(tcx: CTX, cycle: &[QueryInfo]) -> Self;\n+pub trait Value<Tcx: DepContext>: Sized {\n+    fn from_cycle_error(tcx: Tcx, cycle: &[QueryInfo]) -> Self;\n }\n \n-impl<CTX: DepContext, T> Value<CTX> for T {\n-    default fn from_cycle_error(tcx: CTX, _: &[QueryInfo]) -> T {\n+impl<Tcx: DepContext, T> Value<Tcx> for T {\n+    default fn from_cycle_error(tcx: Tcx, _: &[QueryInfo]) -> T {\n         tcx.sess().abort_if_errors();\n         // Ideally we would use `bug!` here. But bug! is only defined in rustc_middle, and it's\n         // non-trivial to define it earlier."}]}