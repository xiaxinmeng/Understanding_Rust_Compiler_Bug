{"sha": "0c3067fcff9794e2ce2471401e0c301f3d8c8b5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjMzA2N2ZjZmY5Nzk0ZTJjZTI0NzE0MDFlMGMzMDFmM2Q4YzhiNWM=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-12-09T16:46:35Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-12-09T16:46:35Z"}, "message": "Remove functions from clean/mod.rs", "tree": {"sha": "f672a138d3bc585af07acfb13c30d5293ae55367", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f672a138d3bc585af07acfb13c30d5293ae55367"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c3067fcff9794e2ce2471401e0c301f3d8c8b5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c3067fcff9794e2ce2471401e0c301f3d8c8b5c", "html_url": "https://github.com/rust-lang/rust/commit/0c3067fcff9794e2ce2471401e0c301f3d8c8b5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c3067fcff9794e2ce2471401e0c301f3d8c8b5c/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d906ed97149eed1d4a34fd6c128e1371ea90321", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d906ed97149eed1d4a34fd6c128e1371ea90321", "html_url": "https://github.com/rust-lang/rust/commit/5d906ed97149eed1d4a34fd6c128e1371ea90321"}], "stats": {"total": 567, "additions": 0, "deletions": 567}, "files": [{"sha": "54d693b19652187dee033b4998e3768ff45575b8", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 567, "changes": 567, "blob_url": "https://github.com/rust-lang/rust/blob/0c3067fcff9794e2ce2471401e0c301f3d8c8b5c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c3067fcff9794e2ce2471401e0c301f3d8c8b5c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0c3067fcff9794e2ce2471401e0c301f3d8c8b5c", "patch": "@@ -54,15 +54,6 @@ pub use self::types::Visibility::{Public, Inherited};\n \n const FN_OUTPUT_NAME: &'static str = \"Output\";\n \n-// extract the stability index for a node from tcx, if possible\n-fn get_stability(cx: &DocContext<'_>, def_id: DefId) -> Option<Stability> {\n-    cx.tcx.lookup_stability(def_id).clean(cx)\n-}\n-\n-fn get_deprecation(cx: &DocContext<'_>, def_id: DefId) -> Option<Deprecation> {\n-    cx.tcx.lookup_deprecation(def_id).clean(cx)\n-}\n-\n pub trait Clean<T> {\n     fn clean(&self, cx: &DocContext<'_>) -> T;\n }\n@@ -109,91 +100,6 @@ impl<T: Clean<U>, U> Clean<Vec<U>> for P<[T]> {\n     }\n }\n \n-pub fn krate(mut cx: &mut DocContext<'_>) -> Crate {\n-    use crate::visit_lib::LibEmbargoVisitor;\n-\n-    let krate = cx.tcx.hir().krate();\n-    let module = crate::visit_ast::RustdocVisitor::new(&mut cx).visit(krate);\n-\n-    let mut r = cx.renderinfo.get_mut();\n-    r.deref_trait_did = cx.tcx.lang_items().deref_trait();\n-    r.deref_mut_trait_did = cx.tcx.lang_items().deref_mut_trait();\n-    r.owned_box_did = cx.tcx.lang_items().owned_box();\n-\n-    let mut externs = Vec::new();\n-    for &cnum in cx.tcx.crates().iter() {\n-        externs.push((cnum, cnum.clean(cx)));\n-        // Analyze doc-reachability for extern items\n-        LibEmbargoVisitor::new(&mut cx).visit_lib(cnum);\n-    }\n-    externs.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n-\n-    // Clean the crate, translating the entire libsyntax AST to one that is\n-    // understood by rustdoc.\n-    let mut module = module.clean(cx);\n-    let mut masked_crates = FxHashSet::default();\n-\n-    match module.inner {\n-        ModuleItem(ref module) => {\n-            for it in &module.items {\n-                // `compiler_builtins` should be masked too, but we can't apply\n-                // `#[doc(masked)]` to the injected `extern crate` because it's unstable.\n-                if it.is_extern_crate()\n-                    && (it.attrs.has_doc_flag(sym::masked)\n-                        || cx.tcx.is_compiler_builtins(it.def_id.krate))\n-                {\n-                    masked_crates.insert(it.def_id.krate);\n-                }\n-            }\n-        }\n-        _ => unreachable!(),\n-    }\n-\n-    let ExternalCrate { name, src, primitives, keywords, .. } = LOCAL_CRATE.clean(cx);\n-    {\n-        let m = match module.inner {\n-            ModuleItem(ref mut m) => m,\n-            _ => unreachable!(),\n-        };\n-        m.items.extend(primitives.iter().map(|&(def_id, prim, ref attrs)| {\n-            Item {\n-                source: Span::empty(),\n-                name: Some(prim.to_url_str().to_string()),\n-                attrs: attrs.clone(),\n-                visibility: Public,\n-                stability: get_stability(cx, def_id),\n-                deprecation: get_deprecation(cx, def_id),\n-                def_id,\n-                inner: PrimitiveItem(prim),\n-            }\n-        }));\n-        m.items.extend(keywords.into_iter().map(|(def_id, kw, attrs)| {\n-            Item {\n-                source: Span::empty(),\n-                name: Some(kw.clone()),\n-                attrs,\n-                visibility: Public,\n-                stability: get_stability(cx, def_id),\n-                deprecation: get_deprecation(cx, def_id),\n-                def_id,\n-                inner: KeywordItem(kw),\n-            }\n-        }));\n-    }\n-\n-    Crate {\n-        name,\n-        version: None,\n-        src,\n-        module: Some(module),\n-        externs,\n-        primitives,\n-        external_traits: cx.external_traits.clone(),\n-        masked_crates,\n-        collapsed: false,\n-    }\n-}\n-\n impl Clean<ExternalCrate> for CrateNum {\n     fn clean(&self, cx: &DocContext<'_>) -> ExternalCrate {\n         let root = DefId { krate: *self, index: CRATE_DEF_INDEX };\n@@ -394,66 +300,6 @@ impl Clean<GenericBound> for hir::GenericBound {\n     }\n }\n \n-fn external_generic_args(\n-    cx: &DocContext<'_>,\n-    trait_did: Option<DefId>,\n-    has_self: bool,\n-    bindings: Vec<TypeBinding>,\n-    substs: SubstsRef<'_>,\n-) -> GenericArgs {\n-    let mut skip_self = has_self;\n-    let mut ty_kind = None;\n-    let args: Vec<_> = substs.iter().filter_map(|kind| match kind.unpack() {\n-        GenericArgKind::Lifetime(lt) => {\n-            lt.clean(cx).and_then(|lt| Some(GenericArg::Lifetime(lt)))\n-        }\n-        GenericArgKind::Type(_) if skip_self => {\n-            skip_self = false;\n-            None\n-        }\n-        GenericArgKind::Type(ty) => {\n-            ty_kind = Some(&ty.kind);\n-            Some(GenericArg::Type(ty.clean(cx)))\n-        }\n-        GenericArgKind::Const(ct) => Some(GenericArg::Const(ct.clean(cx))),\n-    }).collect();\n-\n-    match trait_did {\n-        // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n-        Some(did) if cx.tcx.lang_items().fn_trait_kind(did).is_some() => {\n-            assert!(ty_kind.is_some());\n-            let inputs = match ty_kind {\n-                Some(ty::Tuple(ref tys)) => tys.iter().map(|t| t.expect_ty().clean(cx)).collect(),\n-                _ => return GenericArgs::AngleBracketed { args, bindings },\n-            };\n-            let output = None;\n-            // FIXME(#20299) return type comes from a projection now\n-            // match types[1].kind {\n-            //     ty::Tuple(ref v) if v.is_empty() => None, // -> ()\n-            //     _ => Some(types[1].clean(cx))\n-            // };\n-            GenericArgs::Parenthesized { inputs, output }\n-        },\n-        _ => {\n-            GenericArgs::AngleBracketed { args, bindings }\n-        }\n-    }\n-}\n-\n-// trait_did should be set to a trait's DefId if called on a TraitRef, in order to sugar\n-// from Fn<(A, B,), C> to Fn(A, B) -> C\n-fn external_path(cx: &DocContext<'_>, name: Symbol, trait_did: Option<DefId>, has_self: bool,\n-                 bindings: Vec<TypeBinding>, substs: SubstsRef<'_>) -> Path {\n-    Path {\n-        global: false,\n-        res: Res::Err,\n-        segments: vec![PathSegment {\n-            name: name.to_string(),\n-            args: external_generic_args(cx, trait_did, has_self, bindings, substs)\n-        }],\n-    }\n-}\n-\n impl<'a, 'tcx> Clean<GenericBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>) {\n     fn clean(&self, cx: &DocContext<'_>) -> GenericBound {\n         let (trait_ref, ref bounds) = *self;\n@@ -1036,118 +882,6 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n     }\n }\n \n-/// The point of this function is to replace bounds with types.\n-///\n-/// i.e. `[T, U]` when you have the following bounds: `T: Display, U: Option<T>` will return\n-/// `[Display, Option]` (we just returns the list of the types, we don't care about the\n-/// wrapped types in here).\n-fn get_real_types(\n-    generics: &Generics,\n-    arg: &Type,\n-    cx: &DocContext<'_>,\n-    recurse: i32,\n-) -> FxHashSet<Type> {\n-    let arg_s = arg.print().to_string();\n-    let mut res = FxHashSet::default();\n-    if recurse >= 10 { // FIXME: remove this whole recurse thing when the recursion bug is fixed\n-        return res;\n-    }\n-    if arg.is_full_generic() {\n-        if let Some(where_pred) = generics.where_predicates.iter().find(|g| {\n-            match g {\n-                &WherePredicate::BoundPredicate { ref ty, .. } => ty.def_id() == arg.def_id(),\n-                _ => false,\n-            }\n-        }) {\n-            let bounds = where_pred.get_bounds().unwrap_or_else(|| &[]);\n-            for bound in bounds.iter() {\n-                match *bound {\n-                    GenericBound::TraitBound(ref poly_trait, _) => {\n-                        for x in poly_trait.generic_params.iter() {\n-                            if !x.is_type() {\n-                                continue\n-                            }\n-                            if let Some(ty) = x.get_type() {\n-                                let adds = get_real_types(generics, &ty, cx, recurse + 1);\n-                                if !adds.is_empty() {\n-                                    res.extend(adds);\n-                                } else if !ty.is_full_generic() {\n-                                    res.insert(ty);\n-                                }\n-                            }\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-        }\n-        if let Some(bound) = generics.params.iter().find(|g| {\n-            g.is_type() && g.name == arg_s\n-        }) {\n-            for bound in bound.get_bounds().unwrap_or_else(|| &[]) {\n-                if let Some(ty) = bound.get_trait_type() {\n-                    let adds = get_real_types(generics, &ty, cx, recurse + 1);\n-                    if !adds.is_empty() {\n-                        res.extend(adds);\n-                    } else if !ty.is_full_generic() {\n-                        res.insert(ty.clone());\n-                    }\n-                }\n-            }\n-        }\n-    } else {\n-        res.insert(arg.clone());\n-        if let Some(gens) = arg.generics() {\n-            for gen in gens.iter() {\n-                if gen.is_full_generic() {\n-                    let adds = get_real_types(generics, gen, cx, recurse + 1);\n-                    if !adds.is_empty() {\n-                        res.extend(adds);\n-                    }\n-                } else {\n-                    res.insert(gen.clone());\n-                }\n-            }\n-        }\n-    }\n-    res\n-}\n-\n-/// Return the full list of types when bounds have been resolved.\n-///\n-/// i.e. `fn foo<A: Display, B: Option<A>>(x: u32, y: B)` will return\n-/// `[u32, Display, Option]`.\n-pub fn get_all_types(\n-    generics: &Generics,\n-    decl: &FnDecl,\n-    cx: &DocContext<'_>,\n-) -> (Vec<Type>, Vec<Type>) {\n-    let mut all_types = FxHashSet::default();\n-    for arg in decl.inputs.values.iter() {\n-        if arg.type_.is_self_type() {\n-            continue;\n-        }\n-        let args = get_real_types(generics, &arg.type_, cx, 0);\n-        if !args.is_empty() {\n-            all_types.extend(args);\n-        } else {\n-            all_types.insert(arg.type_.clone());\n-        }\n-    }\n-\n-    let ret_types = match decl.output {\n-        FunctionRetTy::Return(ref return_type) => {\n-            let mut ret = get_real_types(generics, &return_type, cx, 0);\n-            if ret.is_empty() {\n-                ret.insert(return_type.clone());\n-            }\n-            ret.into_iter().collect()\n-        }\n-        _ => Vec::new(),\n-    };\n-    (all_types.into_iter().collect(), ret_types)\n-}\n-\n impl<'a> Clean<Method> for (&'a hir::FnSig, &'a hir::Generics, hir::BodyId,\n                             Option<hir::Defaultness>) {\n     fn clean(&self, cx: &DocContext<'_>) -> Method {\n@@ -2262,66 +1996,6 @@ impl Clean<PathSegment> for hir::PathSegment {\n     }\n }\n \n-fn strip_type(ty: Type) -> Type {\n-    match ty {\n-        Type::ResolvedPath { path, param_names, did, is_generic } => {\n-            Type::ResolvedPath { path: strip_path(&path), param_names, did, is_generic }\n-        }\n-        Type::Tuple(inner_tys) => {\n-            Type::Tuple(inner_tys.iter().map(|t| strip_type(t.clone())).collect())\n-        }\n-        Type::Slice(inner_ty) => Type::Slice(Box::new(strip_type(*inner_ty))),\n-        Type::Array(inner_ty, s) => Type::Array(Box::new(strip_type(*inner_ty)), s),\n-        Type::RawPointer(m, inner_ty) => Type::RawPointer(m, Box::new(strip_type(*inner_ty))),\n-        Type::BorrowedRef { lifetime, mutability, type_ } => {\n-            Type::BorrowedRef { lifetime, mutability, type_: Box::new(strip_type(*type_)) }\n-        }\n-        Type::QPath { name, self_type, trait_ } => {\n-            Type::QPath {\n-                name,\n-                self_type: Box::new(strip_type(*self_type)), trait_: Box::new(strip_type(*trait_))\n-            }\n-        }\n-        _ => ty\n-    }\n-}\n-\n-fn strip_path(path: &Path) -> Path {\n-    let segments = path.segments.iter().map(|s| {\n-        PathSegment {\n-            name: s.name.clone(),\n-            args: GenericArgs::AngleBracketed {\n-                args: vec![],\n-                bindings: vec![],\n-            }\n-        }\n-    }).collect();\n-\n-    Path {\n-        global: path.global,\n-        res: path.res.clone(),\n-        segments,\n-    }\n-}\n-\n-fn qpath_to_string(p: &hir::QPath) -> String {\n-    let segments = match *p {\n-        hir::QPath::Resolved(_, ref path) => &path.segments,\n-        hir::QPath::TypeRelative(_, ref segment) => return segment.ident.to_string(),\n-    };\n-\n-    let mut s = String::new();\n-    for (i, seg) in segments.iter().enumerate() {\n-        if i > 0 {\n-            s.push_str(\"::\");\n-        }\n-        if seg.ident.name != kw::PathRoot {\n-            s.push_str(&seg.ident.as_str());\n-        }\n-    }\n-    s\n-}\n-\n impl Clean<String> for Ident {\n     #[inline]\n     fn clean(&self, cx: &DocContext<'_>) -> String {\n@@ -2444,15 +2118,6 @@ impl Clean<ImplPolarity> for ty::ImplPolarity {\n     }\n }\n \n-pub fn get_auto_trait_and_blanket_impls(\n-    cx: &DocContext<'tcx>,\n-    ty: Ty<'tcx>,\n-    param_env_def_id: DefId,\n-) -> impl Iterator<Item = Item> {\n-    AutoTraitFinder::new(cx).get_auto_trait_impls(ty, param_env_def_id).into_iter()\n-        .chain(BlanketImplFinder::new(cx).get_blanket_impls(ty, param_env_def_id))\n-}\n-\n impl Clean<Vec<Item>> for doctree::Impl<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n         let mut ret = Vec::new();\n@@ -2497,63 +2162,6 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n     }\n }\n \n-fn build_deref_target_impls(cx: &DocContext<'_>,\n-                            items: &[Item],\n-                            ret: &mut Vec<Item>) {\n-    use self::PrimitiveType::*;\n-    let tcx = cx.tcx;\n-\n-    for item in items {\n-        let target = match item.inner {\n-            TypedefItem(ref t, true) => &t.type_,\n-            _ => continue,\n-        };\n-        let primitive = match *target {\n-            ResolvedPath { did, .. } if did.is_local() => continue,\n-            ResolvedPath { did, .. } => {\n-                ret.extend(inline::build_impls(cx, did, None));\n-                continue\n-            }\n-            _ => match target.primitive_type() {\n-                Some(prim) => prim,\n-                None => continue,\n-            }\n-        };\n-        let did = match primitive {\n-            Isize => tcx.lang_items().isize_impl(),\n-            I8 => tcx.lang_items().i8_impl(),\n-            I16 => tcx.lang_items().i16_impl(),\n-            I32 => tcx.lang_items().i32_impl(),\n-            I64 => tcx.lang_items().i64_impl(),\n-            I128 => tcx.lang_items().i128_impl(),\n-            Usize => tcx.lang_items().usize_impl(),\n-            U8 => tcx.lang_items().u8_impl(),\n-            U16 => tcx.lang_items().u16_impl(),\n-            U32 => tcx.lang_items().u32_impl(),\n-            U64 => tcx.lang_items().u64_impl(),\n-            U128 => tcx.lang_items().u128_impl(),\n-            F32 => tcx.lang_items().f32_impl(),\n-            F64 => tcx.lang_items().f64_impl(),\n-            Char => tcx.lang_items().char_impl(),\n-            Bool => tcx.lang_items().bool_impl(),\n-            Str => tcx.lang_items().str_impl(),\n-            Slice => tcx.lang_items().slice_impl(),\n-            Array => tcx.lang_items().slice_impl(),\n-            Tuple => None,\n-            Unit => None,\n-            RawPointer => tcx.lang_items().const_ptr_impl(),\n-            Reference => None,\n-            Fn => None,\n-            Never => None,\n-        };\n-        if let Some(did) = did {\n-            if !did.is_local() {\n-                inline::build_impl(cx, did, None, ret);\n-            }\n-        }\n-    }\n-}\n-\n impl Clean<Vec<Item>> for doctree::ExternCrate<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n \n@@ -2710,170 +2318,6 @@ impl Clean<Item> for doctree::ForeignItem<'_> {\n     }\n }\n \n-// Utilities\n-\n-pub trait ToSource {\n-    fn to_src(&self, cx: &DocContext<'_>) -> String;\n-}\n-\n-impl ToSource for syntax_pos::Span {\n-    fn to_src(&self, cx: &DocContext<'_>) -> String {\n-        debug!(\"converting span {:?} to snippet\", self.clean(cx));\n-        let sn = match cx.sess().source_map().span_to_snippet(*self) {\n-            Ok(x) => x,\n-            Err(_) => String::new()\n-        };\n-        debug!(\"got snippet {}\", sn);\n-        sn\n-    }\n-}\n-\n-fn name_from_pat(p: &hir::Pat) -> String {\n-    use rustc::hir::*;\n-    debug!(\"trying to get a name from pattern: {:?}\", p);\n-\n-    match p.kind {\n-        PatKind::Wild => \"_\".to_string(),\n-        PatKind::Binding(_, _, ident, _) => ident.to_string(),\n-        PatKind::TupleStruct(ref p, ..) | PatKind::Path(ref p) => qpath_to_string(p),\n-        PatKind::Struct(ref name, ref fields, etc) => {\n-            format!(\"{} {{ {}{} }}\", qpath_to_string(name),\n-                fields.iter().map(|fp| format!(\"{}: {}\", fp.ident, name_from_pat(&fp.pat)))\n-                             .collect::<Vec<String>>().join(\", \"),\n-                if etc { \", ..\" } else { \"\" }\n-            )\n-        }\n-        PatKind::Or(ref pats) => {\n-            pats.iter().map(|p| name_from_pat(&**p)).collect::<Vec<String>>().join(\" | \")\n-        }\n-        PatKind::Tuple(ref elts, _) => format!(\"({})\", elts.iter().map(|p| name_from_pat(&**p))\n-                                            .collect::<Vec<String>>().join(\", \")),\n-        PatKind::Box(ref p) => name_from_pat(&**p),\n-        PatKind::Ref(ref p, _) => name_from_pat(&**p),\n-        PatKind::Lit(..) => {\n-            warn!(\"tried to get argument name from PatKind::Lit, \\\n-                  which is silly in function arguments\");\n-            \"()\".to_string()\n-        },\n-        PatKind::Range(..) => panic!(\"tried to get argument name from PatKind::Range, \\\n-                              which is not allowed in function arguments\"),\n-        PatKind::Slice(ref begin, ref mid, ref end) => {\n-            let begin = begin.iter().map(|p| name_from_pat(&**p));\n-            let mid = mid.as_ref().map(|p| format!(\"..{}\", name_from_pat(&**p))).into_iter();\n-            let end = end.iter().map(|p| name_from_pat(&**p));\n-            format!(\"[{}]\", begin.chain(mid).chain(end).collect::<Vec<_>>().join(\", \"))\n-        },\n-    }\n-}\n-\n-fn print_const(cx: &DocContext<'_>, n: &ty::Const<'_>) -> String {\n-    match n.val {\n-        ty::ConstKind::Unevaluated(def_id, _) => {\n-            if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(def_id) {\n-                print_const_expr(cx, cx.tcx.hir().body_owned_by(hir_id))\n-            } else {\n-                inline::print_inlined_const(cx, def_id)\n-            }\n-        },\n-        _ => {\n-            let mut s = n.to_string();\n-            // array lengths are obviously usize\n-            if s.ends_with(\"usize\") {\n-                let n = s.len() - \"usize\".len();\n-                s.truncate(n);\n-                if s.ends_with(\": \") {\n-                    let n = s.len() - \": \".len();\n-                    s.truncate(n);\n-                }\n-            }\n-            s\n-        },\n-    }\n-}\n-\n-fn print_const_expr(cx: &DocContext<'_>, body: hir::BodyId) -> String {\n-    cx.tcx.hir().hir_to_pretty_string(body.hir_id)\n-}\n-\n-/// Given a type Path, resolve it to a Type using the TyCtxt\n-fn resolve_type(cx: &DocContext<'_>,\n-                path: Path,\n-                id: hir::HirId) -> Type {\n-    if id == hir::DUMMY_HIR_ID {\n-        debug!(\"resolve_type({:?})\", path);\n-    } else {\n-        debug!(\"resolve_type({:?},{:?})\", path, id);\n-    }\n-\n-    let is_generic = match path.res {\n-        Res::PrimTy(p) => match p {\n-            hir::Str => return Primitive(PrimitiveType::Str),\n-            hir::Bool => return Primitive(PrimitiveType::Bool),\n-            hir::Char => return Primitive(PrimitiveType::Char),\n-            hir::Int(int_ty) => return Primitive(int_ty.into()),\n-            hir::Uint(uint_ty) => return Primitive(uint_ty.into()),\n-            hir::Float(float_ty) => return Primitive(float_ty.into()),\n-        },\n-        Res::SelfTy(..) if path.segments.len() == 1 => {\n-            return Generic(kw::SelfUpper.to_string());\n-        }\n-        Res::Def(DefKind::TyParam, _) if path.segments.len() == 1 => {\n-            return Generic(format!(\"{:#}\", path.print()));\n-        }\n-        Res::SelfTy(..)\n-        | Res::Def(DefKind::TyParam, _)\n-        | Res::Def(DefKind::AssocTy, _) => true,\n-        _ => false,\n-    };\n-    let did = register_res(&*cx, path.res);\n-    ResolvedPath { path, param_names: None, did, is_generic }\n-}\n-\n-pub fn register_res(cx: &DocContext<'_>, res: Res) -> DefId {\n-    debug!(\"register_res({:?})\", res);\n-\n-    let (did, kind) = match res {\n-        Res::Def(DefKind::Fn, i) => (i, TypeKind::Function),\n-        Res::Def(DefKind::TyAlias, i) => (i, TypeKind::Typedef),\n-        Res::Def(DefKind::Enum, i) => (i, TypeKind::Enum),\n-        Res::Def(DefKind::Trait, i) => (i, TypeKind::Trait),\n-        Res::Def(DefKind::Struct, i) => (i, TypeKind::Struct),\n-        Res::Def(DefKind::Union, i) => (i, TypeKind::Union),\n-        Res::Def(DefKind::Mod, i) => (i, TypeKind::Module),\n-        Res::Def(DefKind::ForeignTy, i) => (i, TypeKind::Foreign),\n-        Res::Def(DefKind::Const, i) => (i, TypeKind::Const),\n-        Res::Def(DefKind::Static, i) => (i, TypeKind::Static),\n-        Res::Def(DefKind::Variant, i) => (cx.tcx.parent(i).expect(\"cannot get parent def id\"),\n-                            TypeKind::Enum),\n-        Res::Def(DefKind::Macro(mac_kind), i) => match mac_kind {\n-            MacroKind::Bang => (i, TypeKind::Macro),\n-            MacroKind::Attr => (i, TypeKind::Attr),\n-            MacroKind::Derive => (i, TypeKind::Derive),\n-        },\n-        Res::Def(DefKind::TraitAlias, i) => (i, TypeKind::TraitAlias),\n-        Res::SelfTy(Some(def_id), _) => (def_id, TypeKind::Trait),\n-        Res::SelfTy(_, Some(impl_def_id)) => return impl_def_id,\n-        _ => return res.def_id()\n-    };\n-    if did.is_local() { return did }\n-    inline::record_extern_fqn(cx, did, kind);\n-    if let TypeKind::Trait = kind {\n-        inline::record_extern_trait(cx, did);\n-    }\n-    did\n-}\n-\n-fn resolve_use_source(cx: &DocContext<'_>, path: Path) -> ImportSource {\n-    ImportSource {\n-        did: if path.res.opt_def_id().is_none() {\n-            None\n-        } else {\n-            Some(register_res(cx, path.res))\n-        },\n-        path,\n-    }\n-}\n-\n impl Clean<Item> for doctree::Macro<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let name = self.name.clean(cx);\n@@ -2981,17 +2425,6 @@ impl Clean<TypeBindingKind> for hir::TypeBindingKind {\n     }\n }\n \n-pub fn enter_impl_trait<F, R>(cx: &DocContext<'_>, f: F) -> R\n-where\n-    F: FnOnce() -> R,\n-{\n-    let old_bounds = mem::take(&mut *cx.impl_trait_bounds.borrow_mut());\n-    let r = f();\n-    assert!(cx.impl_trait_bounds.borrow().is_empty());\n-    *cx.impl_trait_bounds.borrow_mut() = old_bounds;\n-    r\n-}\n-\n #[derive(Eq, PartialEq, Hash, Copy, Clone, Debug)]\n enum RegionTarget<'tcx> {\n     Region(Region<'tcx>),"}]}