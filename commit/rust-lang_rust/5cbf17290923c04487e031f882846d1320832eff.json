{"sha": "5cbf17290923c04487e031f882846d1320832eff", "node_id": "C_kwDOAAsO6NoAKDVjYmYxNzI5MDkyM2MwNDQ4N2UwMzFmODgyODQ2ZDEzMjA4MzJlZmY", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-11-03T09:10:31Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-11-25T08:09:52Z"}, "message": "Print a trace through types to show how to get to the problematic type", "tree": {"sha": "3fc5281288f9dd54f99c25bc2e205c1303b7c5de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fc5281288f9dd54f99c25bc2e205c1303b7c5de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5cbf17290923c04487e031f882846d1320832eff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5cbf17290923c04487e031f882846d1320832eff", "html_url": "https://github.com/rust-lang/rust/commit/5cbf17290923c04487e031f882846d1320832eff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5cbf17290923c04487e031f882846d1320832eff/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9909cb902f76bbd99e74d9ff91718d9f5a2eba80", "url": "https://api.github.com/repos/rust-lang/rust/commits/9909cb902f76bbd99e74d9ff91718d9f5a2eba80", "html_url": "https://github.com/rust-lang/rust/commit/9909cb902f76bbd99e74d9ff91718d9f5a2eba80"}], "stats": {"total": 165, "additions": 110, "deletions": 55}, "files": [{"sha": "700bf4a0aca9bd406e32b4ef232cf9c8b5fb5d6e", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 64, "deletions": 42, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/5cbf17290923c04487e031f882846d1320832eff/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cbf17290923c04487e031f882846d1320832eff/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=5cbf17290923c04487e031f882846d1320832eff", "patch": "@@ -57,8 +57,6 @@ use rustc_trait_selection::traits::{self, misc::can_type_implement_copy};\n \n use crate::nonstandard_style::{method_context, MethodLateContext};\n \n-use std::fmt::Write;\n-\n // hardwired lints from librustc_middle\n pub use rustc_session::lint::builtin::*;\n \n@@ -2408,8 +2406,34 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n         }\n \n         /// Information about why a type cannot be initialized this way.\n-        /// Contains an error message and optionally a span to point at.\n-        type InitError = (String, Option<Span>);\n+        struct InitError {\n+            message: String,\n+            /// Spans from struct fields and similar can be obtained from just the type.\n+            span: Option<Span>,\n+            /// Used to report a trace through adts.\n+            nested: Option<Box<InitError>>,\n+        }\n+        impl InitError {\n+            fn spanned(self, span: Span) -> InitError {\n+                Self { span: Some(span), ..self }\n+            }\n+\n+            fn nested(self, nested: InitError) -> InitError {\n+                assert!(self.nested.is_none());\n+                Self { nested: Some(Box::new(nested)), ..self }\n+            }\n+        }\n+\n+        impl<'a> From<&'a str> for InitError {\n+            fn from(s: &'a str) -> Self {\n+                s.to_owned().into()\n+            }\n+        }\n+        impl From<String> for InitError {\n+            fn from(message: String) -> Self {\n+                Self { message, span: None, nested: None }\n+            }\n+        }\n \n         /// Test if this constant is all-0.\n         fn is_zero(expr: &hir::Expr<'_>) -> bool {\n@@ -2471,17 +2495,10 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             init: InitKind,\n         ) -> Option<InitError> {\n             variant.fields.iter().find_map(|field| {\n-                ty_find_init_error(cx, field.ty(cx.tcx, substs), init).map(|(mut msg, span)| {\n-                    if span.is_none() {\n-                        // Point to this field, should be helpful for figuring\n-                        // out where the source of the error is.\n-                        let span = cx.tcx.def_span(field.did);\n-                        write!(&mut msg, \" (in this {descr})\").unwrap();\n-                        (msg, Some(span))\n-                    } else {\n-                        // Just forward.\n-                        (msg, span)\n-                    }\n+                ty_find_init_error(cx, field.ty(cx.tcx, substs), init).map(|err| {\n+                    InitError::from(format!(\"in this {descr}\"))\n+                        .spanned(cx.tcx.def_span(field.did))\n+                        .nested(err)\n                 })\n             })\n         }\n@@ -2496,30 +2513,30 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             use rustc_type_ir::sty::TyKind::*;\n             match ty.kind() {\n                 // Primitive types that don't like 0 as a value.\n-                Ref(..) => Some((\"references must be non-null\".to_string(), None)),\n-                Adt(..) if ty.is_box() => Some((\"`Box` must be non-null\".to_string(), None)),\n-                FnPtr(..) => Some((\"function pointers must be non-null\".to_string(), None)),\n-                Never => Some((\"the `!` type has no valid value\".to_string(), None)),\n+                Ref(..) => Some(\"references must be non-null\".into()),\n+                Adt(..) if ty.is_box() => Some(\"`Box` must be non-null\".into()),\n+                FnPtr(..) => Some(\"function pointers must be non-null\".into()),\n+                Never => Some(\"the `!` type has no valid value\".into()),\n                 RawPtr(tm) if matches!(tm.ty.kind(), Dynamic(..)) =>\n                 // raw ptr to dyn Trait\n                 {\n-                    Some((\"the vtable of a wide raw pointer must be non-null\".to_string(), None))\n+                    Some(\"the vtable of a wide raw pointer must be non-null\".into())\n                 }\n                 // Primitive types with other constraints.\n                 Bool if init == InitKind::Uninit => {\n-                    Some((\"booleans must be either `true` or `false`\".to_string(), None))\n+                    Some(\"booleans must be either `true` or `false`\".into())\n                 }\n                 Char if init == InitKind::Uninit => {\n-                    Some((\"characters must be a valid Unicode codepoint\".to_string(), None))\n+                    Some(\"characters must be a valid Unicode codepoint\".into())\n                 }\n                 Int(_) | Uint(_) if init == InitKind::Uninit => {\n-                    Some((\"integers must not be uninitialized\".to_string(), None))\n+                    Some(\"integers must not be uninitialized\".into())\n                 }\n                 Float(_) if init == InitKind::Uninit => {\n-                    Some((\"floats must not be uninitialized\".to_string(), None))\n+                    Some(\"floats must not be uninitialized\".into())\n                 }\n                 RawPtr(_) if init == InitKind::Uninit => {\n-                    Some((\"raw pointers must not be uninitialized\".to_string(), None))\n+                    Some(\"raw pointers must not be uninitialized\".into())\n                 }\n                 // Recurse and checks for some compound types. (but not unions)\n                 Adt(adt_def, substs) if !adt_def.is_union() => {\n@@ -2531,21 +2548,21 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                         // handle the attribute correctly.)\n                         // We don't add a span since users cannot declare such types anyway.\n                         (Bound::Included(lo), Bound::Included(hi)) if 0 < lo && lo < hi => {\n-                            return Some((format!(\"`{}` must be non-null\", ty), None));\n+                            return Some(format!(\"`{}` must be non-null\", ty).into());\n                         }\n                         (Bound::Included(lo), Bound::Unbounded) if 0 < lo => {\n-                            return Some((format!(\"`{}` must be non-null\", ty), None));\n+                            return Some(format!(\"`{}` must be non-null\", ty).into());\n                         }\n                         (Bound::Included(_), _) | (_, Bound::Included(_))\n                             if init == InitKind::Uninit =>\n                         {\n-                            return Some((\n+                            return Some(\n                                 format!(\n                                     \"`{}` must be initialized inside its custom valid range\",\n                                     ty,\n-                                ),\n-                                None,\n-                            ));\n+                                )\n+                                .into(),\n+                            );\n                         }\n                         _ => {}\n                     }\n@@ -2576,7 +2593,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                         Some((variant, definitely_inhabited))\n                     });\n                     let Some(first_variant) = potential_variants.next() else {\n-                        return Some((\"enums with no inhabited variants have no valid value\".to_string(), Some(span)));\n+                        return Some(InitError::from(\"enums with no inhabited variants have no valid value\").spanned(span));\n                     };\n                     // So we have at least one potentially inhabited variant. Might we have two?\n                     let Some(second_variant) = potential_variants.next() else {\n@@ -2600,10 +2617,9 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                                 .filter(|(_variant, definitely_inhabited)| *definitely_inhabited)\n                                 .count();\n                         if definitely_inhabited > 1 {\n-                            return Some((\n-                                \"enums with multiple inhabited variants have to be initialized to a variant\".to_string(),\n-                                Some(span),\n-                            ));\n+                            return Some(InitError::from(\n+                                \"enums with multiple inhabited variants have to be initialized to a variant\",\n+                            ).spanned(span));\n                         }\n                     }\n                     // We couldn't find anything wrong here.\n@@ -2632,8 +2648,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             // using zeroed or uninitialized memory.\n             // We are extremely conservative with what we warn about.\n             let conjured_ty = cx.typeck_results().expr_ty(expr);\n-            if let Some((msg, span)) =\n-                with_no_trimmed_paths!(ty_find_init_error(cx, conjured_ty, init))\n+            if let Some(mut err) = with_no_trimmed_paths!(ty_find_init_error(cx, conjured_ty, init))\n             {\n                 // FIXME(davidtwco): make translatable\n                 cx.struct_span_lint(\n@@ -2659,10 +2674,17 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                             \"help: use `MaybeUninit<T>` instead, \\\n                             and only call `assume_init` after initialization is done\",\n                         );\n-                        if let Some(span) = span {\n-                            lint.span_note(span, &msg);\n-                        } else {\n-                            lint.note(&msg);\n+                        loop {\n+                            if let Some(span) = err.span {\n+                                lint.span_note(span, &err.message);\n+                            } else {\n+                                lint.note(&err.message);\n+                            }\n+                            if let Some(e) = err.nested {\n+                                err = *e;\n+                            } else {\n+                                break;\n+                            }\n                         }\n                         lint\n                     },"}, {"sha": "8b4d845b30eaa0ee857d6614645a4e6bee00cf8f", "filename": "src/test/ui/consts/const-eval/validate_uninhabited_zsts.32bit.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5cbf17290923c04487e031f882846d1320832eff/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5cbf17290923c04487e031f882846d1320832eff/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.32bit.stderr?ref=5cbf17290923c04487e031f882846d1320832eff", "patch": "@@ -40,6 +40,11 @@ LL | const BAR: [empty::Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n    |                                          this code causes undefined behavior when executed\n    |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n+note: in this struct field\n+  --> $DIR/validate_uninhabited_zsts.rs:16:22\n+   |\n+LL |     pub struct Empty(Void);\n+   |                      ^^^^\n note: enums with no inhabited variants have no valid value\n   --> $DIR/validate_uninhabited_zsts.rs:13:5\n    |"}, {"sha": "8b4d845b30eaa0ee857d6614645a4e6bee00cf8f", "filename": "src/test/ui/consts/const-eval/validate_uninhabited_zsts.64bit.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5cbf17290923c04487e031f882846d1320832eff/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5cbf17290923c04487e031f882846d1320832eff/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fvalidate_uninhabited_zsts.64bit.stderr?ref=5cbf17290923c04487e031f882846d1320832eff", "patch": "@@ -40,6 +40,11 @@ LL | const BAR: [empty::Empty; 3] = [unsafe { std::mem::transmute(()) }; 3];\n    |                                          this code causes undefined behavior when executed\n    |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n+note: in this struct field\n+  --> $DIR/validate_uninhabited_zsts.rs:16:22\n+   |\n+LL |     pub struct Empty(Void);\n+   |                      ^^^^\n note: enums with no inhabited variants have no valid value\n   --> $DIR/validate_uninhabited_zsts.rs:13:5\n    |"}, {"sha": "7b452325ccb4fc0581e4c3b836aa7b7b5535631a", "filename": "src/test/ui/lint/invalid_value.stderr", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5cbf17290923c04487e031f882846d1320832eff/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5cbf17290923c04487e031f882846d1320832eff/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Finvalid_value.stderr?ref=5cbf17290923c04487e031f882846d1320832eff", "patch": "@@ -34,11 +34,12 @@ LL |         let _val: Wrap<&'static T> = mem::zeroed();\n    |                                      this code causes undefined behavior when executed\n    |                                      help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: references must be non-null (in this struct field)\n+note: in this struct field\n   --> $DIR/invalid_value.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n+   = note: references must be non-null\n \n error: the type `Wrap<&T>` does not permit being left uninitialized\n   --> $DIR/invalid_value.rs:58:38\n@@ -49,11 +50,12 @@ LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n    |                                      this code causes undefined behavior when executed\n    |                                      help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: references must be non-null (in this struct field)\n+note: in this struct field\n   --> $DIR/invalid_value.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n+   = note: references must be non-null\n \n error: the type `!` does not permit zero-initialization\n   --> $DIR/invalid_value.rs:65:23\n@@ -160,11 +162,12 @@ LL |         let _val: Ref = mem::zeroed();\n    |                         this code causes undefined behavior when executed\n    |                         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: references must be non-null (in this struct field)\n+note: in this struct field\n   --> $DIR/invalid_value.rs:14:12\n    |\n LL | struct Ref(&'static i32);\n    |            ^^^^^^^^^^^^\n+   = note: references must be non-null\n \n error: the type `Ref` does not permit being left uninitialized\n   --> $DIR/invalid_value.rs:78:25\n@@ -175,11 +178,12 @@ LL |         let _val: Ref = mem::uninitialized();\n    |                         this code causes undefined behavior when executed\n    |                         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: references must be non-null (in this struct field)\n+note: in this struct field\n   --> $DIR/invalid_value.rs:14:12\n    |\n LL | struct Ref(&'static i32);\n    |            ^^^^^^^^^^^^\n+   = note: references must be non-null\n \n error: the type `fn()` does not permit zero-initialization\n   --> $DIR/invalid_value.rs:80:26\n@@ -212,11 +216,12 @@ LL |         let _val: Wrap<fn()> = mem::zeroed();\n    |                                this code causes undefined behavior when executed\n    |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: function pointers must be non-null (in this struct field)\n+note: in this struct field\n   --> $DIR/invalid_value.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n+   = note: function pointers must be non-null\n \n error: the type `Wrap<fn()>` does not permit being left uninitialized\n   --> $DIR/invalid_value.rs:84:32\n@@ -227,11 +232,12 @@ LL |         let _val: Wrap<fn()> = mem::uninitialized();\n    |                                this code causes undefined behavior when executed\n    |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: function pointers must be non-null (in this struct field)\n+note: in this struct field\n   --> $DIR/invalid_value.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n+   = note: function pointers must be non-null\n \n error: the type `WrapEnum<fn()>` does not permit zero-initialization\n   --> $DIR/invalid_value.rs:86:36\n@@ -242,11 +248,12 @@ LL |         let _val: WrapEnum<fn()> = mem::zeroed();\n    |                                    this code causes undefined behavior when executed\n    |                                    help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: function pointers must be non-null (in this field of the only potentially inhabited enum variant)\n+note: in this field of the only potentially inhabited enum variant\n   --> $DIR/invalid_value.rs:18:28\n    |\n LL | enum WrapEnum<T> { Wrapped(T) }\n    |                            ^\n+   = note: function pointers must be non-null\n \n error: the type `WrapEnum<fn()>` does not permit being left uninitialized\n   --> $DIR/invalid_value.rs:87:36\n@@ -257,11 +264,12 @@ LL |         let _val: WrapEnum<fn()> = mem::uninitialized();\n    |                                    this code causes undefined behavior when executed\n    |                                    help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: function pointers must be non-null (in this field of the only potentially inhabited enum variant)\n+note: in this field of the only potentially inhabited enum variant\n   --> $DIR/invalid_value.rs:18:28\n    |\n LL | enum WrapEnum<T> { Wrapped(T) }\n    |                            ^\n+   = note: function pointers must be non-null\n \n error: the type `Wrap<(RefPair, i32)>` does not permit zero-initialization\n   --> $DIR/invalid_value.rs:89:42\n@@ -272,11 +280,17 @@ LL |         let _val: Wrap<(RefPair, i32)> = mem::zeroed();\n    |                                          this code causes undefined behavior when executed\n    |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: references must be non-null (in this struct field)\n+note: in this struct field\n+  --> $DIR/invalid_value.rs:17:18\n+   |\n+LL | struct Wrap<T> { wrapped: T }\n+   |                  ^^^^^^^^^^\n+note: in this struct field\n   --> $DIR/invalid_value.rs:15:16\n    |\n LL | struct RefPair((&'static i32, i32));\n    |                ^^^^^^^^^^^^^^^^^^^\n+   = note: references must be non-null\n \n error: the type `Wrap<(RefPair, i32)>` does not permit being left uninitialized\n   --> $DIR/invalid_value.rs:90:42\n@@ -287,11 +301,17 @@ LL |         let _val: Wrap<(RefPair, i32)> = mem::uninitialized();\n    |                                          this code causes undefined behavior when executed\n    |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: references must be non-null (in this struct field)\n+note: in this struct field\n+  --> $DIR/invalid_value.rs:17:18\n+   |\n+LL | struct Wrap<T> { wrapped: T }\n+   |                  ^^^^^^^^^^\n+note: in this struct field\n   --> $DIR/invalid_value.rs:15:16\n    |\n LL | struct RefPair((&'static i32, i32));\n    |                ^^^^^^^^^^^^^^^^^^^\n+   = note: references must be non-null\n \n error: the type `NonNull<i32>` does not permit zero-initialization\n   --> $DIR/invalid_value.rs:92:34\n@@ -420,11 +440,12 @@ LL |         let _val: OneFruitNonZero = mem::zeroed();\n    |                                     this code causes undefined behavior when executed\n    |                                     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: `std::num::NonZeroU32` must be non-null (in this field of the only potentially inhabited enum variant)\n+note: in this field of the only potentially inhabited enum variant\n   --> $DIR/invalid_value.rs:39:12\n    |\n LL |     Banana(NonZeroU32),\n    |            ^^^^^^^^^^\n+   = note: `std::num::NonZeroU32` must be non-null\n \n error: the type `OneFruitNonZero` does not permit being left uninitialized\n   --> $DIR/invalid_value.rs:108:37\n@@ -435,11 +456,12 @@ LL |         let _val: OneFruitNonZero = mem::uninitialized();\n    |                                     this code causes undefined behavior when executed\n    |                                     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: `std::num::NonZeroU32` must be non-null (in this field of the only potentially inhabited enum variant)\n+note: in this field of the only potentially inhabited enum variant\n   --> $DIR/invalid_value.rs:39:12\n    |\n LL |     Banana(NonZeroU32),\n    |            ^^^^^^^^^^\n+   = note: `std::num::NonZeroU32` must be non-null\n \n error: the type `bool` does not permit being left uninitialized\n   --> $DIR/invalid_value.rs:112:26\n@@ -461,11 +483,12 @@ LL |         let _val: Wrap<char> = mem::uninitialized();\n    |                                this code causes undefined behavior when executed\n    |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n-note: characters must be a valid Unicode codepoint (in this struct field)\n+note: in this struct field\n   --> $DIR/invalid_value.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n+   = note: characters must be a valid Unicode codepoint\n \n error: the type `NonBig` does not permit being left uninitialized\n   --> $DIR/invalid_value.rs:118:28"}]}