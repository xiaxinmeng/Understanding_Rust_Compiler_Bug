{"sha": "f4dc1c5d64d5439ba8b70f93490d7dc8ee512c7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0ZGMxYzVkNjRkNTQzOWJhOGI3MGY5MzQ5MGQ3ZGM4ZWU1MTJjN2U=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2018-11-26T08:23:42Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2018-12-16T23:59:32Z"}, "message": "fix review comments, round 2", "tree": {"sha": "d78fdff9e3379a1ebace6b4cb4e8073c33f6683b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d78fdff9e3379a1ebace6b4cb4e8073c33f6683b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4dc1c5d64d5439ba8b70f93490d7dc8ee512c7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4dc1c5d64d5439ba8b70f93490d7dc8ee512c7e", "html_url": "https://github.com/rust-lang/rust/commit/f4dc1c5d64d5439ba8b70f93490d7dc8ee512c7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4dc1c5d64d5439ba8b70f93490d7dc8ee512c7e/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78f7e854f981c5f0c23f0eaf4c750ce1aa581ac6", "url": "https://api.github.com/repos/rust-lang/rust/commits/78f7e854f981c5f0c23f0eaf4c750ce1aa581ac6", "html_url": "https://github.com/rust-lang/rust/commit/78f7e854f981c5f0c23f0eaf4c750ce1aa581ac6"}], "stats": {"total": 76, "additions": 23, "deletions": 53}, "files": [{"sha": "e8252f55735bc0c37dd5f995782a6c46df6aebb7", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 22, "deletions": 50, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f4dc1c5d64d5439ba8b70f93490d7dc8ee512c7e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4dc1c5d64d5439ba8b70f93490d7dc8ee512c7e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f4dc1c5d64d5439ba8b70f93490d7dc8ee512c7e", "patch": "@@ -134,7 +134,6 @@ use std::collections::hash_map::Entry;\n use std::cmp;\n use std::fmt::Display;\n use std::iter;\n-use std::vec;\n use std::mem::replace;\n use std::ops::{self, Deref};\n use std::slice;\n@@ -143,6 +142,7 @@ use require_c_abi_if_variadic;\n use session::{CompileIncomplete, config, Session};\n use TypeAndSubsts;\n use lint;\n+use util::captures::Captures;\n use util::common::{ErrorReported, indenter};\n use util::nodemap::{DefIdMap, DefIdSet, FxHashMap, FxHashSet, NodeMap};\n \n@@ -2751,55 +2751,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => false\n         }\n     }\n-}\n-\n-/// FIXME: impl Trait why u give me lifetime errors?\n-pub struct ObligationMapper<'a, 'gcx, 'tcx>(&'a FnCtxt<'a, 'gcx, 'tcx>, ty::TyVid);\n-\n-impl<'a, 'gcx, 'tcx> FnOnce<(traits::PredicateObligation<'tcx>,)>\n-    for ObligationMapper<'a, 'gcx, 'tcx>\n-{\n-    type Output = Option<ty::PolyTraitRef<'tcx>>;\n-\n-    extern \"rust-call\" fn call_once(mut self, args: (traits::PredicateObligation<'tcx>,))\n-                                    -> Self::Output {\n-        self.call_mut(args)\n-    }\n-}\n \n-impl<'a, 'gcx, 'tcx> FnMut<(traits::PredicateObligation<'tcx>,)>\n-    for ObligationMapper<'a, 'gcx, 'tcx>\n-{\n-    extern \"rust-call\" fn call_mut(&mut self, args: (traits::PredicateObligation<'tcx>,))\n-                                   -> Self::Output {\n-        match args.0.predicate {\n-            ty::Predicate::Projection(ref data) => Some(data.to_poly_trait_ref(self.0.tcx)),\n-            ty::Predicate::Trait(ref data) => Some(data.to_poly_trait_ref()),\n-            ty::Predicate::Subtype(..) => None,\n-            ty::Predicate::RegionOutlives(..) => None,\n-            ty::Predicate::TypeOutlives(..) => None,\n-            ty::Predicate::WellFormed(..) => None,\n-            ty::Predicate::ObjectSafe(..) => None,\n-            ty::Predicate::ConstEvaluatable(..) => None,\n-            // N.B., this predicate is created by breaking down a\n-            // `ClosureType: FnFoo()` predicate, where\n-            // `ClosureType` represents some `Closure`. It can't\n-            // possibly be referring to the current closure,\n-            // because we haven't produced the `Closure` for\n-            // this closure yet; this is exactly why the other\n-            // code is looking for a self type of a unresolved\n-            // inference variable.\n-            ty::Predicate::ClosureKind(..) => None,\n-        }.filter(|tr| {\n-            self.0.self_type_matches_expected_vid(*tr, self.1)\n-        })\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn obligations_for_self_ty<'b>(&'b self, self_ty: ty::TyVid)\n-        -> iter::FilterMap<vec::IntoIter<traits::PredicateObligation<'tcx>>,\n-                           ObligationMapper<'b, 'gcx, 'tcx>>\n+        -> impl Iterator<Item=ty::PolyTraitRef<'tcx>> + Captures<'gcx> + 'b\n     {\n         let ty_var_root = self.root_var(self_ty);\n         debug!(\"obligations_for_self_ty: self_ty={:?} ty_var_root={:?} pending_obligations={:?}\",\n@@ -2810,12 +2764,30 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             .borrow()\n             .pending_obligations()\n             .into_iter()\n-            .filter_map(ObligationMapper(self, ty_var_root))\n+            .filter_map(move |obligation| match obligation.predicate {\n+                ty::Predicate::Projection(ref data) => Some(data.to_poly_trait_ref(self.tcx)),\n+                ty::Predicate::Trait(ref data) => Some(data.to_poly_trait_ref()),\n+                ty::Predicate::Subtype(..) => None,\n+                ty::Predicate::RegionOutlives(..) => None,\n+                ty::Predicate::TypeOutlives(..) => None,\n+                ty::Predicate::WellFormed(..) => None,\n+                ty::Predicate::ObjectSafe(..) => None,\n+                ty::Predicate::ConstEvaluatable(..) => None,\n+                // N.B., this predicate is created by breaking down a\n+                // `ClosureType: FnFoo()` predicate, where\n+                // `ClosureType` represents some `Closure`. It can't\n+                // possibly be referring to the current closure,\n+                // because we haven't produced the `Closure` for\n+                // this closure yet; this is exactly why the other\n+                // code is looking for a self type of a unresolved\n+                // inference variable.\n+                ty::Predicate::ClosureKind(..) => None,\n+            }).filter(move |tr| self.self_type_matches_expected_vid(*tr, ty_var_root))\n     }\n \n     fn type_var_is_sized(&self, self_ty: ty::TyVid) -> bool {\n         self.obligations_for_self_ty(self_ty).any(|tr| {\n-                Some(tr.def_id()) == self.tcx.lang_items().sized_trait()\n+            Some(tr.def_id()) == self.tcx.lang_items().sized_trait()\n         })\n     }\n "}, {"sha": "8d6fb8b7f39485c43e938887e94391c8afdc40f5", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4dc1c5d64d5439ba8b70f93490d7dc8ee512c7e/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4dc1c5d64d5439ba8b70f93490d7dc8ee512c7e/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=f4dc1c5d64d5439ba8b70f93490d7dc8ee512c7e", "patch": "@@ -75,15 +75,13 @@ This API is completely unstable and subject to change.\n #![feature(box_syntax)]\n #![feature(crate_visibility_modifier)]\n #![feature(exhaustive_patterns)]\n-#![feature(fn_traits)]\n #![feature(nll)]\n #![feature(quote)]\n #![feature(refcell_replace_swap)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]\n #![feature(slice_sort_by_cached_key)]\n #![feature(never_type)]\n-#![feature(unboxed_closures)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "bea8586452e552877fc6699e9938fae103779d65", "filename": "src/test/ui/coercion/coerce-issue-49593-box-never.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4dc1c5d64d5439ba8b70f93490d7dc8ee512c7e/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4dc1c5d64d5439ba8b70f93490d7dc8ee512c7e/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.rs?ref=f4dc1c5d64d5439ba8b70f93490d7dc8ee512c7e", "patch": "@@ -55,7 +55,7 @@ fn foo_no_never() {\n \n     let mut y : Option<S> = None;\n     // assert types are equal\n-    mem::replace(&mut x, &mut y);\n+    mem::swap(&mut x, &mut y);\n }\n \n fn main() {"}]}