{"sha": "2a979f8ba02f0c60e327c9764ea27837ba4bb028", "node_id": "C_kwDOAAsO6NoAKDJhOTc5ZjhiYTAyZjBjNjBlMzI3Yzk3NjRlYTI3ODM3YmE0YmIwMjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-21T12:36:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-21T12:36:58Z"}, "message": "Auto merge of #2794 - RalfJung:rustup, r=RalfJung\n\nRustup", "tree": {"sha": "d9cc6cbdfb11d450d05a47a8b399c7756c2fa8ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9cc6cbdfb11d450d05a47a8b399c7756c2fa8ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a979f8ba02f0c60e327c9764ea27837ba4bb028", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a979f8ba02f0c60e327c9764ea27837ba4bb028", "html_url": "https://github.com/rust-lang/rust/commit/2a979f8ba02f0c60e327c9764ea27837ba4bb028", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a979f8ba02f0c60e327c9764ea27837ba4bb028/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9669e57ed1cd81c7f04db39f9b401198ae574c30", "url": "https://api.github.com/repos/rust-lang/rust/commits/9669e57ed1cd81c7f04db39f9b401198ae574c30", "html_url": "https://github.com/rust-lang/rust/commit/9669e57ed1cd81c7f04db39f9b401198ae574c30"}, {"sha": "4e0cb32311e3e3924ba7d9f93f519ae53ef21bfa", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e0cb32311e3e3924ba7d9f93f519ae53ef21bfa", "html_url": "https://github.com/rust-lang/rust/commit/4e0cb32311e3e3924ba7d9f93f519ae53ef21bfa"}], "stats": {"total": 5830, "additions": 3855, "deletions": 1975}, "files": [{"sha": "6c17edd302081e8044fd3780b2b79e3fbc87d149", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -4180,6 +4180,7 @@ dependencies = [\n  \"rustc_hir_analysis\",\n  \"rustc_hir_typeck\",\n  \"rustc_incremental\",\n+ \"rustc_index\",\n  \"rustc_lint\",\n  \"rustc_macros\",\n  \"rustc_metadata\","}, {"sha": "4a0e005b8b90220c1befaeda82a973fa76218d06", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_hir::PredicateOrigin;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::ty::{DefIdTree, ResolverAstLowering, TyCtxt};\n-use rustc_span::lev_distance::find_best_match_for_name;\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{Span, Symbol};"}, {"sha": "5e1334559f5f303a81754111a5127a584eae981d", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -534,7 +534,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                     return PlaceTy::from_ty(self.tcx().ty_error());\n                 }\n             }\n-            place_ty = self.sanitize_projection(place_ty, elem, place, location);\n+            place_ty = self.sanitize_projection(place_ty, elem, place, location, context);\n         }\n \n         if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n@@ -630,12 +630,14 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn sanitize_projection(\n         &mut self,\n         base: PlaceTy<'tcx>,\n         pi: PlaceElem<'tcx>,\n         place: &Place<'tcx>,\n         location: Location,\n+        context: PlaceContext,\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_projection: {:?} {:?} {:?}\", base, pi, place);\n         let tcx = self.tcx();\n@@ -713,8 +715,11 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 match self.field_ty(place, base, field, location) {\n                     Ok(ty) => {\n                         let ty = self.cx.normalize(ty, location);\n-                        if let Err(terr) = self.cx.eq_types(\n+                        debug!(?fty, ?ty);\n+\n+                        if let Err(terr) = self.cx.relate_types(\n                             ty,\n+                            self.get_ambient_variance(context),\n                             fty,\n                             location.to_locations(),\n                             ConstraintCategory::Boring,\n@@ -743,9 +748,10 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 let ty = self.sanitize_type(place, ty);\n                 let ty = self.cx.normalize(ty, location);\n                 self.cx\n-                    .eq_types(\n-                        base.ty,\n+                    .relate_types(\n                         ty,\n+                        self.get_ambient_variance(context),\n+                        base.ty,\n                         location.to_locations(),\n                         ConstraintCategory::TypeAnnotation,\n                     )\n@@ -760,6 +766,21 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         self.tcx().ty_error()\n     }\n \n+    fn get_ambient_variance(&self, context: PlaceContext) -> ty::Variance {\n+        use rustc_middle::mir::visit::NonMutatingUseContext::*;\n+        use rustc_middle::mir::visit::NonUseContext::*;\n+\n+        match context {\n+            PlaceContext::MutatingUse(_) => ty::Invariant,\n+            PlaceContext::NonUse(StorageDead | StorageLive | VarDebugInfo) => ty::Invariant,\n+            PlaceContext::NonMutatingUse(\n+                Inspect | Copy | Move | SharedBorrow | ShallowBorrow | UniqueBorrow | AddressOf\n+                | Projection,\n+            ) => ty::Covariant,\n+            PlaceContext::NonUse(AscribeUserTy) => ty::Covariant,\n+        }\n+    }\n+\n     fn field_ty(\n         &mut self,\n         parent: &dyn fmt::Debug,"}, {"sha": "019ec0758d6efe0606aa65b00b59ed6f5ad7a290", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -33,6 +33,7 @@ use rustc_target::spec::{RelocModel, Target};\n /// <dt>dylib</dt>\n /// <dd>The metadata can be found in the `.rustc` section of the shared library.</dd>\n /// </dl>\n+#[derive(Debug)]\n pub struct DefaultMetadataLoader;\n \n fn load_metadata_with("}, {"sha": "2be5ed896ec808ea6fc431ad89d8c1c6f62b7436", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -312,6 +312,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n     }\n \n+    /// `src` is a *pointer to* a `source_ty`, and in `dest` we should store a pointer to th same\n+    /// data at type `cast_ty`.\n     fn unsize_into_ptr(\n         &mut self,\n         src: &OpTy<'tcx, M::Provenance>,\n@@ -335,7 +337,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 );\n                 self.write_immediate(val, dest)\n             }\n-            (ty::Dynamic(data_a, ..), ty::Dynamic(data_b, ..)) => {\n+            (ty::Dynamic(data_a, _, ty::Dyn), ty::Dynamic(data_b, _, ty::Dyn)) => {\n                 let val = self.read_immediate(src)?;\n                 if data_a.principal() == data_b.principal() {\n                     // A NOP cast that doesn't actually change anything, should be allowed even with mismatching vtables.\n@@ -359,7 +361,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             _ => {\n-                span_bug!(self.cur_span(), \"invalid unsizing {:?} -> {:?}\", src.layout.ty, cast_ty)\n+                span_bug!(\n+                    self.cur_span(),\n+                    \"invalid pointer unsizing {:?} -> {:?}\",\n+                    src.layout.ty,\n+                    cast_ty\n+                )\n             }\n         }\n     }"}, {"sha": "24b157054d3e49e895f89f7181881aec14fa3020", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -632,7 +632,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n                 Ok(Some((size, align)))\n             }\n-            ty::Dynamic(..) => {\n+            ty::Dynamic(_, _, ty::Dyn) => {\n                 let vtable = metadata.unwrap_meta().to_pointer(self)?;\n                 // Read size and align from vtable (already checks size).\n                 Ok(Some(self.get_vtable_size_and_align(vtable)?))"}, {"sha": "21ef1836188c02133b40f572aadb282ee705c79d", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -242,7 +242,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n             let mplace = self.ecx.ref_to_mplace(&value)?;\n             assert_eq!(mplace.layout.ty, referenced_ty);\n             // Handle trait object vtables.\n-            if let ty::Dynamic(..) =\n+            if let ty::Dynamic(_, _, ty::Dyn) =\n                 tcx.struct_tail_erasing_lifetimes(referenced_ty, self.ecx.param_env).kind()\n             {\n                 let ptr = mplace.meta.unwrap_meta().to_pointer(&tcx)?;"}, {"sha": "8d5192bca67e5deeeeed9abfb4598b4edffecd35", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -255,7 +255,22 @@ impl<'tcx, Prov: Provenance> OpTy<'tcx, Prov> {\n         }\n     }\n \n-    pub fn offset_with_meta(\n+    /// Replace the layout of this operand. There's basically no sanity check that this makes sense,\n+    /// you better know what you are doing! If this is an immediate, applying the wrong layout can\n+    /// not just lead to invalid data, it can actually *shift the data around* since the offsets of\n+    /// a ScalarPair are entirely determined by the layout, not the data.\n+    pub fn transmute(&self, layout: TyAndLayout<'tcx>) -> Self {\n+        assert_eq!(\n+            self.layout.size, layout.size,\n+            \"transmuting with a size change, that doesn't seem right\"\n+        );\n+        OpTy { layout, ..*self }\n+    }\n+\n+    /// Offset the operand in memory (if possible) and change its metadata.\n+    ///\n+    /// This can go wrong very easily if you give the wrong layout for the new place!\n+    pub(super) fn offset_with_meta(\n         &self,\n         offset: Size,\n         meta: MemPlaceMeta<Prov>,\n@@ -276,6 +291,9 @@ impl<'tcx, Prov: Provenance> OpTy<'tcx, Prov> {\n         }\n     }\n \n+    /// Offset the operand in memory (if possible).\n+    ///\n+    /// This can go wrong very easily if you give the wrong layout for the new place!\n     pub fn offset(\n         &self,\n         offset: Size,"}, {"sha": "244fa8030af73e0960ecd2b6a998c9a85e69bcd5", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 52, "deletions": 15, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -26,6 +26,7 @@ pub enum MemPlaceMeta<Prov: Provenance = AllocId> {\n }\n \n impl<Prov: Provenance> MemPlaceMeta<Prov> {\n+    #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n     pub fn unwrap_meta(self) -> Scalar<Prov> {\n         match self {\n             Self::Meta(s) => s,\n@@ -147,12 +148,16 @@ impl<Prov: Provenance> MemPlace<Prov> {\n     }\n \n     #[inline]\n-    pub fn offset_with_meta<'tcx>(\n+    pub(super) fn offset_with_meta<'tcx>(\n         self,\n         offset: Size,\n         meta: MemPlaceMeta<Prov>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n+        debug_assert!(\n+            !meta.has_meta() || self.meta.has_meta(),\n+            \"cannot use `offset_with_meta` to add metadata to a place\"\n+        );\n         Ok(MemPlace { ptr: self.ptr.offset(offset, cx)?, meta })\n     }\n }\n@@ -182,8 +187,11 @@ impl<'tcx, Prov: Provenance> MPlaceTy<'tcx, Prov> {\n         MPlaceTy { mplace: MemPlace { ptr, meta: MemPlaceMeta::None }, layout, align }\n     }\n \n+    /// Offset the place in memory and change its metadata.\n+    ///\n+    /// This can go wrong very easily if you give the wrong layout for the new place!\n     #[inline]\n-    pub fn offset_with_meta(\n+    pub(crate) fn offset_with_meta(\n         &self,\n         offset: Size,\n         meta: MemPlaceMeta<Prov>,\n@@ -197,6 +205,9 @@ impl<'tcx, Prov: Provenance> MPlaceTy<'tcx, Prov> {\n         })\n     }\n \n+    /// Offset the place in memory.\n+    ///\n+    /// This can go wrong very easily if you give the wrong layout for the new place!\n     pub fn offset(\n         &self,\n         offset: Size,\n@@ -241,14 +252,6 @@ impl<'tcx, Prov: Provenance> MPlaceTy<'tcx, Prov> {\n             }\n         }\n     }\n-\n-    #[inline]\n-    pub(super) fn vtable(&self) -> Scalar<Prov> {\n-        match self.layout.ty.kind() {\n-            ty::Dynamic(..) => self.mplace.meta.unwrap_meta(),\n-            _ => bug!(\"vtable not supported on type {:?}\", self.layout.ty),\n-        }\n-    }\n }\n \n // These are defined here because they produce a place.\n@@ -266,7 +269,12 @@ impl<'tcx, Prov: Provenance> OpTy<'tcx, Prov> {\n     #[inline(always)]\n     #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n     pub fn assert_mem_place(&self) -> MPlaceTy<'tcx, Prov> {\n-        self.as_mplace_or_imm().left().unwrap()\n+        self.as_mplace_or_imm().left().unwrap_or_else(|| {\n+            bug!(\n+                \"OpTy of type {} was immediate when it was expected to be an MPlace\",\n+                self.layout.ty\n+            )\n+        })\n     }\n }\n \n@@ -283,7 +291,12 @@ impl<'tcx, Prov: Provenance> PlaceTy<'tcx, Prov> {\n     #[inline(always)]\n     #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n     pub fn assert_mem_place(&self) -> MPlaceTy<'tcx, Prov> {\n-        self.as_mplace_or_local().left().unwrap()\n+        self.as_mplace_or_local().left().unwrap_or_else(|| {\n+            bug!(\n+                \"PlaceTy of type {} was a local when it was expected to be an MPlace\",\n+                self.layout.ty\n+            )\n+        })\n     }\n }\n \n@@ -807,11 +820,16 @@ where\n     }\n \n     /// Turn a place with a `dyn Trait` type into a place with the actual dynamic type.\n+    /// Aso returns the vtable.\n     pub(super) fn unpack_dyn_trait(\n         &self,\n         mplace: &MPlaceTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::Provenance>> {\n-        let vtable = mplace.vtable().to_pointer(self)?; // also sanity checks the type\n+    ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::Provenance>, Pointer<Option<M::Provenance>>)> {\n+        assert!(\n+            matches!(mplace.layout.ty.kind(), ty::Dynamic(_, _, ty::Dyn)),\n+            \"`unpack_dyn_trait` only makes sense on `dyn*` types\"\n+        );\n+        let vtable = mplace.meta.unwrap_meta().to_pointer(self)?;\n         let (ty, _) = self.get_ptr_vtable(vtable)?;\n         let layout = self.layout_of(ty)?;\n \n@@ -820,7 +838,26 @@ where\n             layout,\n             align: layout.align.abi,\n         };\n-        Ok(mplace)\n+        Ok((mplace, vtable))\n+    }\n+\n+    /// Turn an operand with a `dyn* Trait` type into an operand with the actual dynamic type.\n+    /// Aso returns the vtable.\n+    pub(super) fn unpack_dyn_star(\n+        &self,\n+        op: &OpTy<'tcx, M::Provenance>,\n+    ) -> InterpResult<'tcx, (OpTy<'tcx, M::Provenance>, Pointer<Option<M::Provenance>>)> {\n+        assert!(\n+            matches!(op.layout.ty.kind(), ty::Dynamic(_, _, ty::DynStar)),\n+            \"`unpack_dyn_star` only makes sense on `dyn*` types\"\n+        );\n+        let data = self.operand_field(&op, 0)?;\n+        let vtable = self.operand_field(&op, 1)?;\n+        let vtable = self.read_pointer(&vtable)?;\n+        let (ty, _) = self.get_ptr_vtable(vtable)?;\n+        let layout = self.layout_of(ty)?;\n+        let data = data.transmute(layout);\n+        Ok((data, vtable))\n     }\n }\n "}, {"sha": "d934cfbbb84eaed16ce96056698ff8c436693d1b", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 69, "deletions": 38, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -547,7 +547,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let receiver_place = loop {\n                     match receiver.layout.ty.kind() {\n                         ty::Ref(..) | ty::RawPtr(..) => break self.deref_operand(&receiver)?,\n-                        ty::Dynamic(..) => break receiver.assert_mem_place(), // no immediate unsized values\n+                        ty::Dynamic(.., ty::Dyn) => break receiver.assert_mem_place(), // no immediate unsized values\n+                        ty::Dynamic(.., ty::DynStar) => {\n+                            // Not clear how to handle this, so far we assume the receiver is always a pointer.\n+                            span_bug!(\n+                                self.cur_span(),\n+                                \"by-value calls on a `dyn*`... are those a thing?\"\n+                            );\n+                        }\n                         _ => {\n                             // Not there yet, search for the only non-ZST field.\n                             let mut non_zst_field = None;\n@@ -573,39 +580,59 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         }\n                     }\n                 };\n-                // Obtain the underlying trait we are working on.\n-                let receiver_tail = self\n-                    .tcx\n-                    .struct_tail_erasing_lifetimes(receiver_place.layout.ty, self.param_env);\n-                let ty::Dynamic(data, ..) = receiver_tail.kind() else {\n-                    span_bug!(self.cur_span(), \"dynamic call on non-`dyn` type {}\", receiver_tail)\n-                };\n \n-                // Get the required information from the vtable.\n-                let vptr = receiver_place.meta.unwrap_meta().to_pointer(self)?;\n-                let (dyn_ty, dyn_trait) = self.get_ptr_vtable(vptr)?;\n-                if dyn_trait != data.principal() {\n-                    throw_ub_format!(\n-                        \"`dyn` call on a pointer whose vtable does not match its type\"\n-                    );\n-                }\n+                // Obtain the underlying trait we are working on, and the adjusted receiver argument.\n+                let (vptr, dyn_ty, adjusted_receiver) = if let ty::Dynamic(data, _, ty::DynStar) =\n+                    receiver_place.layout.ty.kind()\n+                {\n+                    let (recv, vptr) = self.unpack_dyn_star(&receiver_place.into())?;\n+                    let (dyn_ty, dyn_trait) = self.get_ptr_vtable(vptr)?;\n+                    if dyn_trait != data.principal() {\n+                        throw_ub_format!(\n+                            \"`dyn*` call on a pointer whose vtable does not match its type\"\n+                        );\n+                    }\n+                    let recv = recv.assert_mem_place(); // we passed an MPlaceTy to `unpack_dyn_star` so we definitely still have one\n+\n+                    (vptr, dyn_ty, recv.ptr)\n+                } else {\n+                    // Doesn't have to be a `dyn Trait`, but the unsized tail must be `dyn Trait`.\n+                    // (For that reason we also cannot use `unpack_dyn_trait`.)\n+                    let receiver_tail = self\n+                        .tcx\n+                        .struct_tail_erasing_lifetimes(receiver_place.layout.ty, self.param_env);\n+                    let ty::Dynamic(data, _, ty::Dyn) = receiver_tail.kind() else {\n+                            span_bug!(self.cur_span(), \"dynamic call on non-`dyn` type {}\", receiver_tail)\n+                        };\n+                    assert!(receiver_place.layout.is_unsized());\n+\n+                    // Get the required information from the vtable.\n+                    let vptr = receiver_place.meta.unwrap_meta().to_pointer(self)?;\n+                    let (dyn_ty, dyn_trait) = self.get_ptr_vtable(vptr)?;\n+                    if dyn_trait != data.principal() {\n+                        throw_ub_format!(\n+                            \"`dyn` call on a pointer whose vtable does not match its type\"\n+                        );\n+                    }\n+\n+                    // It might be surprising that we use a pointer as the receiver even if this\n+                    // is a by-val case; this works because by-val passing of an unsized `dyn\n+                    // Trait` to a function is actually desugared to a pointer.\n+                    (vptr, dyn_ty, receiver_place.ptr)\n+                };\n \n                 // Now determine the actual method to call. We can do that in two different ways and\n                 // compare them to ensure everything fits.\n                 let Some(ty::VtblEntry::Method(fn_inst)) = self.get_vtable_entries(vptr)?.get(idx).copied() else {\n                     throw_ub_format!(\"`dyn` call trying to call something that is not a method\")\n                 };\n+                trace!(\"Virtual call dispatches to {fn_inst:#?}\");\n                 if cfg!(debug_assertions) {\n                     let tcx = *self.tcx;\n \n                     let trait_def_id = tcx.trait_of_item(def_id).unwrap();\n                     let virtual_trait_ref =\n                         ty::TraitRef::from_method(tcx, trait_def_id, instance.substs);\n-                    assert_eq!(\n-                        receiver_tail,\n-                        virtual_trait_ref.self_ty(),\n-                        \"mismatch in underlying dyn trait computation within Miri and MIR building\",\n-                    );\n                     let existential_trait_ref =\n                         ty::ExistentialTraitRef::erase_self_ty(tcx, virtual_trait_ref);\n                     let concrete_trait_ref = existential_trait_ref.with_self_ty(tcx, dyn_ty);\n@@ -620,17 +647,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     assert_eq!(fn_inst, concrete_method);\n                 }\n \n-                // `*mut receiver_place.layout.ty` is almost the layout that we\n-                // want for args[0]: We have to project to field 0 because we want\n-                // a thin pointer.\n-                assert!(receiver_place.layout.is_unsized());\n-                let receiver_ptr_ty = self.tcx.mk_mut_ptr(receiver_place.layout.ty);\n-                let this_receiver_ptr = self.layout_of(receiver_ptr_ty)?.field(self, 0);\n-                // Adjust receiver argument.\n-                args[0] = OpTy::from(ImmTy::from_immediate(\n-                    Scalar::from_maybe_pointer(receiver_place.ptr, self).into(),\n-                    this_receiver_ptr,\n-                ));\n+                // Adjust receiver argument. Layout can be any (thin) ptr.\n+                args[0] = ImmTy::from_immediate(\n+                    Scalar::from_maybe_pointer(adjusted_receiver, self).into(),\n+                    self.layout_of(self.tcx.mk_mut_ptr(dyn_ty))?,\n+                )\n+                .into();\n                 trace!(\"Patched receiver operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n                 self.eval_fn_call(\n@@ -659,15 +681,24 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // implementation fail -- a problem shared by rustc.\n         let place = self.force_allocation(place)?;\n \n-        let (instance, place) = match place.layout.ty.kind() {\n-            ty::Dynamic(..) => {\n+        let place = match place.layout.ty.kind() {\n+            ty::Dynamic(_, _, ty::Dyn) => {\n                 // Dropping a trait object. Need to find actual drop fn.\n-                let place = self.unpack_dyn_trait(&place)?;\n-                let instance = ty::Instance::resolve_drop_in_place(*self.tcx, place.layout.ty);\n-                (instance, place)\n+                self.unpack_dyn_trait(&place)?.0\n+            }\n+            ty::Dynamic(_, _, ty::DynStar) => {\n+                // Dropping a `dyn*`. Need to find actual drop fn.\n+                self.unpack_dyn_star(&place.into())?.0.assert_mem_place()\n+            }\n+            _ => {\n+                debug_assert_eq!(\n+                    instance,\n+                    ty::Instance::resolve_drop_in_place(*self.tcx, place.layout.ty)\n+                );\n+                place\n             }\n-            _ => (instance, place),\n         };\n+        let instance = ty::Instance::resolve_drop_in_place(*self.tcx, place.layout.ty);\n         let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty())?;\n \n         let arg = ImmTy::from_immediate("}, {"sha": "e76d4c1728e90b3518d7573e987aa827c4a53b30", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -23,18 +23,18 @@ use std::hash::Hash;\n // for the validation errors\n use super::UndefinedBehaviorInfo::*;\n use super::{\n-    CheckInAllocMsg, GlobalAlloc, ImmTy, Immediate, InterpCx, InterpResult, MPlaceTy, Machine,\n-    MemPlaceMeta, OpTy, Scalar, ValueVisitor,\n+    AllocId, CheckInAllocMsg, GlobalAlloc, ImmTy, Immediate, InterpCx, InterpResult, MPlaceTy,\n+    Machine, MemPlaceMeta, OpTy, Pointer, Scalar, ValueVisitor,\n };\n \n macro_rules! throw_validation_failure {\n-    ($where:expr, { $( $what_fmt:expr ),+ } $( expected { $( $expected_fmt:expr ),+ } )?) => {{\n+    ($where:expr, { $( $what_fmt:tt )* } $( expected { $( $expected_fmt:tt )* } )?) => {{\n         let mut msg = String::new();\n         msg.push_str(\"encountered \");\n-        write!(&mut msg, $($what_fmt),+).unwrap();\n+        write!(&mut msg, $($what_fmt)*).unwrap();\n         $(\n             msg.push_str(\", but expected \");\n-            write!(&mut msg, $($expected_fmt),+).unwrap();\n+            write!(&mut msg, $($expected_fmt)*).unwrap();\n         )?\n         let path = rustc_middle::ty::print::with_no_trimmed_paths!({\n             let where_ = &$where;\n@@ -82,7 +82,7 @@ macro_rules! throw_validation_failure {\n ///\n macro_rules! try_validation {\n     ($e:expr, $where:expr,\n-    $( $( $p:pat_param )|+ => { $( $what_fmt:expr ),+ } $( expected { $( $expected_fmt:expr ),+ } )? ),+ $(,)?\n+    $( $( $p:pat_param )|+ => { $( $what_fmt:tt )* } $( expected { $( $expected_fmt:tt )* } )? ),+ $(,)?\n     ) => {{\n         match $e {\n             Ok(x) => x,\n@@ -93,7 +93,7 @@ macro_rules! try_validation {\n                     InterpError::UndefinedBehavior($($p)|+) =>\n                        throw_validation_failure!(\n                             $where,\n-                            { $( $what_fmt ),+ } $( expected { $( $expected_fmt ),+ } )?\n+                            { $( $what_fmt )* } $( expected { $( $expected_fmt )* } )?\n                         )\n                 ),+,\n                 #[allow(unreachable_patterns)]\n@@ -335,7 +335,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n     ) -> InterpResult<'tcx> {\n         let tail = self.ecx.tcx.struct_tail_erasing_lifetimes(pointee.ty, self.ecx.param_env);\n         match tail.kind() {\n-            ty::Dynamic(..) => {\n+            ty::Dynamic(_, _, ty::Dyn) => {\n                 let vtable = meta.unwrap_meta().to_pointer(self.ecx)?;\n                 // Make sure it is a genuine vtable pointer.\n                 let (_ty, _trait) = try_validation!(\n@@ -399,12 +399,15 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 {\n                     \"an unaligned {kind} (required {} byte alignment but found {})\",\n                     required.bytes(),\n-                    has.bytes()\n+                    has.bytes(),\n                 },\n             DanglingIntPointer(0, _) =>\n                 { \"a null {kind}\" },\n             DanglingIntPointer(i, _) =>\n-                { \"a dangling {kind} (address {i:#x} is unallocated)\" },\n+                {\n+                    \"a dangling {kind} ({pointer} has no provenance)\",\n+                    pointer = Pointer::<Option<AllocId>>::from_addr_invalid(*i),\n+                },\n             PointerOutOfBounds { .. } =>\n                 { \"a dangling {kind} (going beyond the bounds of its allocation)\" },\n             // This cannot happen during const-eval (because interning already detects"}, {"sha": "7a14459399c436640c9c2b08fbdea01d820e90c4", "filename": "compiler/rustc_const_eval/src/interpret/visitor.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -284,7 +284,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueMut<'mir, 'tcx, M>\n         &self,\n         ecx: &InterpCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n-        // We `force_allocation` here so that `from_op` below can work.\n+        // No need for `force_allocation` since we are just going to read from this.\n         ecx.place_to_op(self)\n     }\n \n@@ -421,15 +421,25 @@ macro_rules! make_value_visitor {\n                 // Special treatment for special types, where the (static) layout is not sufficient.\n                 match *ty.kind() {\n                     // If it is a trait object, switch to the real type that was used to create it.\n-                    ty::Dynamic(..) => {\n+                    ty::Dynamic(_, _, ty::Dyn) => {\n+                        // Dyn types. This is unsized, and the actual dynamic type of the data is given by the\n+                        // vtable stored in the place metadata.\n                         // unsized values are never immediate, so we can assert_mem_place\n                         let op = v.to_op_for_read(self.ecx())?;\n                         let dest = op.assert_mem_place();\n-                        let inner_mplace = self.ecx().unpack_dyn_trait(&dest)?;\n+                        let inner_mplace = self.ecx().unpack_dyn_trait(&dest)?.0;\n                         trace!(\"walk_value: dyn object layout: {:#?}\", inner_mplace.layout);\n                         // recurse with the inner type\n                         return self.visit_field(&v, 0, &$value_trait::from_op(&inner_mplace.into()));\n                     },\n+                    ty::Dynamic(_, _, ty::DynStar) => {\n+                        // DynStar types. Very different from a dyn type (but strangely part of the\n+                        // same variant in `TyKind`): These are pairs where the 2nd component is the\n+                        // vtable, and the first component is the data (which must be ptr-sized).\n+                        let op = v.to_op_for_proj(self.ecx())?;\n+                        let data = self.ecx().unpack_dyn_star(&op)?.0;\n+                        return self.visit_field(&v, 0, &$value_trait::from_op(&data));\n+                    }\n                     // Slices do not need special handling here: they have `Array` field\n                     // placement with length 0, so we enter the `Array` case below which\n                     // indirectly uses the metadata to determine the actual length."}, {"sha": "d7e9e00f3b63bb40fc0df2d62cfc65e7aeef8a9f", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -320,7 +320,7 @@ fn run_compiler(\n             }\n \n             // Make sure name resolution and macro expansion is run.\n-            queries.global_ctxt()?;\n+            queries.global_ctxt()?.enter(|tcx| tcx.resolver_for_lowering(()));\n \n             if callbacks.after_expansion(compiler, queries) == Compilation::Stop {\n                 return early_exit();"}, {"sha": "00c5fe791f915e674ef41d8ec68add0d2064fda4", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -5,6 +5,7 @@ use crate::expand::{self, AstFragment, Invocation};\n use crate::module::DirOwnership;\n \n use rustc_ast::attr::MarkedAttrs;\n+use rustc_ast::mut_visit::DummyAstNode;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Nonterminal};\n use rustc_ast::tokenstream::TokenStream;\n@@ -640,6 +641,10 @@ impl MacResult for DummyResult {\n     fn make_variants(self: Box<DummyResult>) -> Option<SmallVec<[ast::Variant; 1]>> {\n         Some(SmallVec::new())\n     }\n+\n+    fn make_crate(self: Box<DummyResult>) -> Option<ast::Crate> {\n+        Some(DummyAstNode::dummy())\n+    }\n }\n \n /// A syntax extension kind."}, {"sha": "5679cdcbbd0625e8d03c7769b38ac65d850fc134", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -16,7 +16,6 @@ use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, TransparencyError};\n use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n use rustc_errors::{Applicability, ErrorGuaranteed};\n-use rustc_feature::Features;\n use rustc_lint_defs::builtin::{\n     RUST_2021_INCOMPATIBLE_OR_PATTERNS, SEMICOLON_IN_EXPRESSIONS_FROM_MACROS,\n };\n@@ -379,7 +378,6 @@ pub(super) fn try_match_macro<'matcher, T: Tracker<'matcher>>(\n /// Converts a macro item into a syntax extension.\n pub fn compile_declarative_macro(\n     sess: &Session,\n-    features: &Features,\n     def: &ast::Item,\n     edition: Edition,\n ) -> (SyntaxExtension, Vec<(usize, Span)>) {\n@@ -508,7 +506,7 @@ pub fn compile_declarative_macro(\n                         true,\n                         &sess.parse_sess,\n                         def.id,\n-                        features,\n+                        sess.features_untracked(),\n                         edition,\n                     )\n                     .pop()\n@@ -532,7 +530,7 @@ pub fn compile_declarative_macro(\n                         false,\n                         &sess.parse_sess,\n                         def.id,\n-                        features,\n+                        sess.features_untracked(),\n                         edition,\n                     )\n                     .pop()"}, {"sha": "3f52f174cdf6d55cefbb42039f20e50ed2455de8", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -987,7 +987,6 @@ pub struct Pat<'hir> {\n }\n \n impl<'hir> Pat<'hir> {\n-    // FIXME(#19596) this is a workaround, but there should be a better way\n     fn walk_short_(&self, it: &mut impl FnMut(&Pat<'hir>) -> bool) -> bool {\n         if !it(self) {\n             return false;\n@@ -1015,7 +1014,6 @@ impl<'hir> Pat<'hir> {\n         self.walk_short_(&mut it)\n     }\n \n-    // FIXME(#19596) this is a workaround, but there should be a better way\n     fn walk_(&self, it: &mut impl FnMut(&Pat<'hir>) -> bool) {\n         if !it(self) {\n             return;"}, {"sha": "a68e0e0ac5bd058afaa9b4c4fc2e0529659502db", "filename": "compiler/rustc_hir_analysis/src/astconv/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -7,7 +7,7 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::traits::FulfillmentError;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::parse::feature_err;\n-use rustc_span::lev_distance::find_best_match_for_name;\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::{Span, Symbol, DUMMY_SP};\n "}, {"sha": "630becc09d26e482b976c15f90427cec30294a72", "filename": "compiler/rustc_hir_analysis/src/astconv/generics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -6,7 +6,7 @@ use crate::astconv::{\n use crate::errors::AssocTypeBindingNotAllowed;\n use crate::structured_errors::{GenericArgsInfo, StructuredDiagnostic, WrongNumberOfGenericArgs};\n use rustc_ast::ast::ParamKindOrd;\n-use rustc_errors::{struct_span_err, Applicability, Diagnostic, MultiSpan};\n+use rustc_errors::{struct_span_err, Applicability, Diagnostic, ErrorGuaranteed, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n@@ -26,7 +26,7 @@ fn generic_arg_mismatch_err(\n     param: &GenericParamDef,\n     possible_ordering_error: bool,\n     help: Option<&str>,\n-) {\n+) -> ErrorGuaranteed {\n     let sess = tcx.sess;\n     let mut err = struct_span_err!(\n         sess,\n@@ -70,9 +70,9 @@ fn generic_arg_mismatch_err(\n         ) => match path.res {\n             Res::Err => {\n                 add_braces_suggestion(arg, &mut err);\n-                err.set_primary_message(\"unresolved item provided when a constant was expected\")\n+                return err\n+                    .set_primary_message(\"unresolved item provided when a constant was expected\")\n                     .emit();\n-                return;\n             }\n             Res::Def(DefKind::TyParam, src_def_id) => {\n                 if let Some(param_local_id) = param.def_id.as_local() {\n@@ -81,7 +81,7 @@ fn generic_arg_mismatch_err(\n                     if param_type.is_suggestable(tcx, false) {\n                         err.span_suggestion(\n                             tcx.def_span(src_def_id),\n-                            \"consider changing this type parameter to be a `const` generic\",\n+                            \"consider changing this type parameter to a const parameter\",\n                             format!(\"const {}: {}\", param_name, param_type),\n                             Applicability::MaybeIncorrect,\n                         );\n@@ -137,7 +137,7 @@ fn generic_arg_mismatch_err(\n         }\n     }\n \n-    err.emit();\n+    err.emit()\n }\n \n /// Creates the relevant generic argument substitutions"}, {"sha": "c0cd54cc916e09ae4b397409d934ececb4cb3e87", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -37,8 +37,8 @@ use rustc_middle::ty::DynKind;\n use rustc_middle::ty::GenericParamDefKind;\n use rustc_middle::ty::{self, Const, DefIdTree, IsSuggestable, Ty, TyCtxt, TypeVisitable};\n use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, BARE_TRAIT_OBJECTS};\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::edition::Edition;\n-use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::{sym, Span, DUMMY_SP};\n use rustc_target::spec::abi;"}, {"sha": "08cbfffdd171b581cf21cf47d75b9ea598c7f647", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -45,8 +45,8 @@ use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, AdtKind, Ty, TypeVisitable};\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_session::parse::feature_err;\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::hygiene::DesugaringKind;\n-use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_target::spec::abi::Abi::RustIntrinsic;"}, {"sha": "b2f3a3abb4c50ca76bfa6abbf1916a3e8fececd5", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -32,7 +32,7 @@ use rustc_session::lint;\n use rustc_span::def_id::LocalDefId;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{self, NormalizeExt, ObligationCauseCode, ObligationCtxt};\n \n@@ -737,7 +737,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let ty::subst::GenericArgKind::Type(ty) = ty.unpack()\n                     && let ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) = *ty.kind()\n                     && let Some(def_id) = def_id.as_local()\n-                    && self.opaque_type_origin(def_id, DUMMY_SP).is_some() {\n+                    && self.opaque_type_origin(def_id).is_some() {\n                     return None;\n                 }\n             }"}, {"sha": "39e0ea98f96e3263f9bb01624164ca1b0da92007", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -549,6 +549,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return Err(expr);\n         };\n \n+        if let (\n+            hir::ExprKind::AddrOf(_borrow_kind, _borrow_mutability, borrowed_expr),\n+            ty::Ref(_ty_region, ty_ref_type, _ty_mutability),\n+        ) = (&expr.kind, in_ty.kind())\n+        {\n+            // We can \"drill into\" the borrowed expression.\n+            return self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                param,\n+                borrowed_expr,\n+                (*ty_ref_type).into(),\n+            );\n+        }\n+\n         if let (hir::ExprKind::Tup(expr_elements), ty::Tuple(in_ty_elements)) =\n             (&expr.kind, in_ty.kind())\n         {"}, {"sha": "4b08832eddc9d08b24aaa4d4d839c1f9a7c05c82", "filename": "compiler/rustc_hir_typeck/src/mem_categorization.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -601,7 +601,6 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         }\n     }\n \n-    // FIXME(#19596) This is a workaround, but there should be a better way to do this\n     fn cat_pattern_<F>(\n         &self,\n         mut place_with_id: PlaceWithHirId<'tcx>,"}, {"sha": "88af554483b8e71b31bb814f38c72287d77088f5", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -24,8 +24,8 @@ use rustc_middle::ty::{InternalSubsts, SubstsRef};\n use rustc_session::lint;\n use rustc_span::def_id::DefId;\n use rustc_span::def_id::LocalDefId;\n-use rustc_span::lev_distance::{\n-    find_best_match_for_name_with_substrings, lev_distance_with_substrings,\n+use rustc_span::edit_distance::{\n+    edit_distance_with_substrings, find_best_match_for_name_with_substrings,\n };\n use rustc_span::symbol::sym;\n use rustc_span::{symbol::Ident, Span, Symbol, DUMMY_SP};\n@@ -69,7 +69,7 @@ struct ProbeContext<'a, 'tcx> {\n     impl_dups: FxHashSet<DefId>,\n \n     /// When probing for names, include names that are close to the\n-    /// requested name (by Levenshtein distance)\n+    /// requested name (by edit distance)\n     allow_similar_names: bool,\n \n     /// Some(candidate) if there is a private candidate\n@@ -1793,7 +1793,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n     /// Similarly to `probe_for_return_type`, this method attempts to find the best matching\n     /// candidate method where the method name may have been misspelled. Similarly to other\n-    /// Levenshtein based suggestions, we provide at most one such suggestion.\n+    /// edit distance based suggestions, we provide at most one such suggestion.\n     fn probe_for_similar_candidate(&mut self) -> Result<Option<ty::AssocItem>, MethodError<'tcx>> {\n         debug!(\"probing for method names similar to {:?}\", self.method_name);\n \n@@ -2024,8 +2024,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         if self.matches_by_doc_alias(x.def_id) {\n                             return true;\n                         }\n-                        match lev_distance_with_substrings(name.as_str(), x.name.as_str(), max_dist)\n-                        {\n+                        match edit_distance_with_substrings(\n+                            name.as_str(),\n+                            x.name.as_str(),\n+                            max_dist,\n+                        ) {\n                             Some(d) => d > 0,\n                             None => false,\n                         }"}, {"sha": "4f3dbe03c052aac1c9c961441e1ec81c61e2d344", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -31,7 +31,7 @@ use rustc_middle::ty::{self, DefIdTree, GenericArgKind, Ty, TyCtxt, TypeVisitabl\n use rustc_middle::ty::{IsSuggestable, ToPolyTraitRef};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Symbol;\n-use rustc_span::{lev_distance, source_map, ExpnKind, FileName, MacroKind, Span};\n+use rustc_span::{edit_distance, source_map, ExpnKind, FileName, MacroKind, Span};\n use rustc_trait_selection::traits::error_reporting::on_unimplemented::OnUnimplementedNote;\n use rustc_trait_selection::traits::error_reporting::on_unimplemented::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n@@ -1014,7 +1014,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // that had unsatisfied trait bounds\n         if unsatisfied_predicates.is_empty() && rcvr_ty.is_enum() {\n             let adt_def = rcvr_ty.ty_adt_def().expect(\"enum is not an ADT\");\n-            if let Some(suggestion) = lev_distance::find_best_match_for_name(\n+            if let Some(suggestion) = edit_distance::find_best_match_for_name(\n                 &adt_def.variants().iter().map(|s| s.name).collect::<Vec<_>>(),\n                 item_name.name,\n                 None,"}, {"sha": "ab6e76ef8aa35932c416a2f82820ab1c244953f5", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -14,8 +14,8 @@ use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKi\n use rustc_middle::middle::stability::EvalResult;\n use rustc_middle::ty::{self, Adt, BindingMode, Ty, TypeVisitable};\n use rustc_session::lint::builtin::NON_EXHAUSTIVE_OMITTED_PATTERNS;\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::hygiene::DesugaringKind;\n-use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{BytePos, DUMMY_SP};"}, {"sha": "e783443502b865357a8007730bbf82ae8366c095", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -57,9 +57,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         }\n         let mut obligations = vec![];\n         let replace_opaque_type = |def_id: DefId| {\n-            def_id\n-                .as_local()\n-                .map_or(false, |def_id| self.opaque_type_origin(def_id, span).is_some())\n+            def_id.as_local().map_or(false, |def_id| self.opaque_type_origin(def_id).is_some())\n         };\n         let value = value.fold_with(&mut BottomUpFolder {\n             tcx: self.tcx,\n@@ -144,9 +142,9 @@ impl<'tcx> InferCtxt<'tcx> {\n                         //     let x = || foo(); // returns the Opaque assoc with `foo`\n                         // }\n                         // ```\n-                        self.opaque_type_origin(def_id, cause.span)?\n+                        self.opaque_type_origin(def_id)?\n                     }\n-                    DefiningAnchor::Bubble => self.opaque_ty_origin_unchecked(def_id, cause.span),\n+                    DefiningAnchor::Bubble => self.opaque_type_origin_unchecked(def_id),\n                     DefiningAnchor::Error => return None,\n                 };\n                 if let ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, .. }) = *b.kind() {\n@@ -155,9 +153,8 @@ impl<'tcx> InferCtxt<'tcx> {\n                     // no one encounters it in practice.\n                     // It does occur however in `fn fut() -> impl Future<Output = i32> { async { 42 } }`,\n                     // where it is of no concern, so we only check for TAITs.\n-                    if let Some(OpaqueTyOrigin::TyAlias) = b_def_id\n-                        .as_local()\n-                        .and_then(|b_def_id| self.opaque_type_origin(b_def_id, cause.span))\n+                    if let Some(OpaqueTyOrigin::TyAlias) =\n+                        b_def_id.as_local().and_then(|b_def_id| self.opaque_type_origin(b_def_id))\n                     {\n                         self.tcx.sess.emit_err(OpaqueHiddenTypeDiag {\n                             span: cause.span,\n@@ -371,24 +368,18 @@ impl<'tcx> InferCtxt<'tcx> {\n         });\n     }\n \n+    /// Returns the origin of the opaque type `def_id` if we're currently\n+    /// in its defining scope.\n     #[instrument(skip(self), level = \"trace\", ret)]\n-    pub fn opaque_type_origin(&self, def_id: LocalDefId, span: Span) -> Option<OpaqueTyOrigin> {\n+    pub fn opaque_type_origin(&self, def_id: LocalDefId) -> Option<OpaqueTyOrigin> {\n         let opaque_hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n         let parent_def_id = match self.defining_use_anchor {\n             DefiningAnchor::Bubble | DefiningAnchor::Error => return None,\n             DefiningAnchor::Bind(bind) => bind,\n         };\n-        let item_kind = &self.tcx.hir().expect_item(def_id).kind;\n-\n-        let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) = item_kind else {\n-            span_bug!(\n-                span,\n-                \"weird opaque type: {:#?}, {:#?}\",\n-                def_id,\n-                item_kind\n-            )\n-        };\n-        let in_definition_scope = match *origin {\n+\n+        let origin = self.opaque_type_origin_unchecked(def_id);\n+        let in_definition_scope = match origin {\n             // Async `impl Trait`\n             hir::OpaqueTyOrigin::AsyncFn(parent) => parent == parent_def_id,\n             // Anonymous `impl Trait`\n@@ -398,16 +389,17 @@ impl<'tcx> InferCtxt<'tcx> {\n                 may_define_opaque_type(self.tcx, parent_def_id, opaque_hir_id)\n             }\n         };\n-        trace!(?origin);\n-        in_definition_scope.then_some(*origin)\n+        in_definition_scope.then_some(origin)\n     }\n \n+    /// Returns the origin of the opaque type `def_id` even if we are not in its\n+    /// defining scope.\n     #[instrument(skip(self), level = \"trace\", ret)]\n-    fn opaque_ty_origin_unchecked(&self, def_id: LocalDefId, span: Span) -> OpaqueTyOrigin {\n+    fn opaque_type_origin_unchecked(&self, def_id: LocalDefId) -> OpaqueTyOrigin {\n         match self.tcx.hir().expect_item(def_id).kind {\n             hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => origin,\n             ref itemkind => {\n-                span_bug!(span, \"weird opaque type: {:?}, {:#?}\", def_id, itemkind)\n+                bug!(\"weird opaque type: {:?}, {:#?}\", def_id, itemkind)\n             }\n         }\n     }"}, {"sha": "ac6e8fca69554baadc02d292dab06640bea461f6", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -24,6 +24,7 @@ rustc_middle = { path = \"../rustc_middle\" }\n rustc_ast_lowering = { path = \"../rustc_ast_lowering\" }\n rustc_ast_passes = { path = \"../rustc_ast_passes\" }\n rustc_incremental = { path = \"../rustc_incremental\" }\n+rustc_index = { path = \"../rustc_index\" }\n rustc_traits = { path = \"../rustc_traits\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_codegen_ssa = { path = \"../rustc_codegen_ssa\" }"}, {"sha": "aa59654099a689e20ae6b8efd746a15e26be2e76", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 42, "deletions": 21, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -8,11 +8,12 @@ use rustc_ast::{self as ast, visit};\n use rustc_borrowck as mir_borrowck;\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_data_structures::parallel;\n+use rustc_data_structures::steal::Steal;\n use rustc_data_structures::sync::{Lrc, OnceCell, WorkerLocal};\n-use rustc_errors::{ErrorGuaranteed, PResult};\n+use rustc_errors::PResult;\n use rustc_expand::base::{ExtCtxt, LintStoreExpand, ResolverExpand};\n use rustc_hir::def_id::{StableCrateId, LOCAL_CRATE};\n-use rustc_lint::{BufferedEarlyLint, EarlyCheckNode, LintStore};\n+use rustc_lint::{unerased_lint_store, BufferedEarlyLint, EarlyCheckNode, LintStore};\n use rustc_metadata::creader::CStore;\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::DepGraph;\n@@ -171,14 +172,12 @@ impl LintStoreExpand for LintStoreExpandImpl<'_> {\n /// syntax expansion, secondary `cfg` expansion, synthesis of a test\n /// harness if one is to be provided, injection of a dependency on the\n /// standard library and prelude, and name resolution.\n-pub fn configure_and_expand(\n-    sess: &Session,\n-    lint_store: &LintStore,\n-    mut krate: ast::Crate,\n-    crate_name: Symbol,\n-    resolver: &mut Resolver<'_, '_>,\n-) -> Result<ast::Crate> {\n-    trace!(\"configure_and_expand\");\n+#[instrument(level = \"trace\", skip(krate, resolver))]\n+fn configure_and_expand(mut krate: ast::Crate, resolver: &mut Resolver<'_, '_>) -> ast::Crate {\n+    let tcx = resolver.tcx();\n+    let sess = tcx.sess;\n+    let lint_store = unerased_lint_store(tcx);\n+    let crate_name = tcx.crate_name(LOCAL_CRATE);\n     pre_expansion_lint(sess, lint_store, resolver.registered_tools(), &krate, crate_name);\n     rustc_builtin_macros::register_builtin_macros(resolver);\n \n@@ -249,20 +248,19 @@ pub fn configure_and_expand(\n             ecx.check_unused_macros();\n         });\n \n-        let recursion_limit_hit = ecx.reduced_recursion_limit.is_some();\n+        // If we hit a recursion limit, exit early to avoid later passes getting overwhelmed\n+        // with a large AST\n+        if ecx.reduced_recursion_limit.is_some() {\n+            sess.abort_if_errors();\n+            unreachable!();\n+        }\n \n         if cfg!(windows) {\n             env::set_var(\"PATH\", &old_path);\n         }\n \n-        if recursion_limit_hit {\n-            // If we hit a recursion limit, exit early to avoid later passes getting overwhelmed\n-            // with a large AST\n-            Err(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n-        } else {\n-            Ok(krate)\n-        }\n-    })?;\n+        krate\n+    });\n \n     sess.time(\"maybe_building_test_harness\", || {\n         rustc_builtin_macros::test_harness::inject(sess, resolver, &mut krate)\n@@ -365,7 +363,7 @@ pub fn configure_and_expand(\n         )\n     });\n \n-    Ok(krate)\n+    krate\n }\n \n // Returns all the paths that correspond to generated files.\n@@ -564,6 +562,28 @@ fn write_out_deps(\n     }\n }\n \n+fn resolver_for_lowering<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    (): (),\n+) -> &'tcx Steal<(ty::ResolverAstLowering, Lrc<ast::Crate>)> {\n+    let arenas = Resolver::arenas();\n+    let krate = tcx.crate_for_resolver(()).steal();\n+    let mut resolver = Resolver::new(tcx, &krate, &arenas);\n+    let krate = configure_and_expand(krate, &mut resolver);\n+\n+    // Make sure we don't mutate the cstore from here on.\n+    tcx.untracked().cstore.leak();\n+\n+    let ty::ResolverOutputs {\n+        global_ctxt: untracked_resolutions,\n+        ast_lowering: untracked_resolver_for_lowering,\n+    } = resolver.into_outputs();\n+\n+    let feed = tcx.feed_unit_query();\n+    feed.resolutions(tcx.arena.alloc(untracked_resolutions));\n+    tcx.arena.alloc(Steal::new((untracked_resolver_for_lowering, Lrc::new(krate))))\n+}\n+\n fn output_filenames(tcx: TyCtxt<'_>, (): ()) -> Arc<OutputFilenames> {\n     let sess = tcx.sess;\n     let _timer = sess.timer(\"prepare_outputs\");\n@@ -597,7 +617,7 @@ fn output_filenames(tcx: TyCtxt<'_>, (): ()) -> Arc<OutputFilenames> {\n         }\n     }\n \n-    write_out_deps(sess, tcx.cstore_untracked(), &outputs, &output_paths);\n+    write_out_deps(sess, &*tcx.cstore_untracked(), &outputs, &output_paths);\n \n     let only_dep_info = sess.opts.output_types.contains_key(&OutputType::DepInfo)\n         && sess.opts.output_types.len() == 1;\n@@ -618,6 +638,7 @@ pub static DEFAULT_QUERY_PROVIDERS: LazyLock<Providers> = LazyLock::new(|| {\n     providers.analysis = analysis;\n     providers.hir_crate = rustc_ast_lowering::lower_to_hir;\n     providers.output_filenames = output_filenames;\n+    providers.resolver_for_lowering = resolver_for_lowering;\n     proc_macro_decls::provide(providers);\n     rustc_const_eval::provide(providers);\n     rustc_middle::hir::provide(providers);"}, {"sha": "c957578b59e1d4d51ec11d94756e2a3ba3af2d98", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 26, "deletions": 39, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -7,16 +7,19 @@ use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_codegen_ssa::CodegenResults;\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::svh::Svh;\n-use rustc_data_structures::sync::{Lrc, OnceCell, WorkerLocal};\n-use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_data_structures::sync::{Lrc, OnceCell, RwLock, WorkerLocal};\n+use rustc_hir::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n+use rustc_hir::definitions::Definitions;\n use rustc_incremental::DepGraphFuture;\n+use rustc_index::vec::IndexVec;\n use rustc_lint::LintStore;\n+use rustc_metadata::creader::CStore;\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::DepGraph;\n-use rustc_middle::ty::{self, GlobalCtxt, TyCtxt};\n+use rustc_middle::ty::{GlobalCtxt, TyCtxt};\n use rustc_query_impl::Queries as TcxQueries;\n-use rustc_resolve::Resolver;\n use rustc_session::config::{self, OutputFilenames, OutputType};\n+use rustc_session::cstore::Untracked;\n use rustc_session::{output::find_crate_name, Session};\n use rustc_span::symbol::sym;\n use rustc_span::Symbol;\n@@ -187,35 +190,18 @@ impl<'tcx> Queries<'tcx> {\n         self.gcx.compute(|| {\n             let crate_name = *self.crate_name()?.borrow();\n             let (krate, lint_store) = self.register_plugins()?.steal();\n-            let (krate, resolver_outputs) = {\n-                let _timer = self.session().timer(\"configure_and_expand\");\n-                let sess = self.session();\n-\n-                let arenas = Resolver::arenas();\n-                let mut resolver = Resolver::new(\n-                    sess,\n-                    &krate,\n-                    crate_name,\n-                    self.codegen_backend().metadata_loader(),\n-                    &arenas,\n-                );\n-                let krate = passes::configure_and_expand(\n-                    sess,\n-                    &lint_store,\n-                    krate,\n-                    crate_name,\n-                    &mut resolver,\n-                )?;\n-                (Lrc::new(krate), resolver.into_outputs())\n-            };\n-\n-            let ty::ResolverOutputs {\n-                untracked,\n-                global_ctxt: untracked_resolutions,\n-                ast_lowering: untracked_resolver_for_lowering,\n-            } = resolver_outputs;\n \n-            let gcx = passes::create_global_ctxt(\n+            let sess = self.session();\n+\n+            let cstore = RwLock::new(Box::new(CStore::new(sess)) as _);\n+            let definitions = RwLock::new(Definitions::new(sess.local_stable_crate_id()));\n+            let mut source_span = IndexVec::default();\n+            let _id = source_span.push(krate.spans.inner_span);\n+            debug_assert_eq!(_id, CRATE_DEF_ID);\n+            let source_span = RwLock::new(source_span);\n+            let untracked = Untracked { cstore, source_span, definitions };\n+\n+            let qcx = passes::create_global_ctxt(\n                 self.compiler,\n                 lint_store,\n                 self.dep_graph()?.steal(),\n@@ -226,17 +212,18 @@ impl<'tcx> Queries<'tcx> {\n                 &self.hir_arena,\n             );\n \n-            gcx.enter(|tcx| {\n+            qcx.enter(|tcx| {\n+                let feed = tcx.feed_local_crate();\n+                feed.crate_name(crate_name);\n+\n                 let feed = tcx.feed_unit_query();\n-                feed.resolver_for_lowering(\n-                    tcx.arena.alloc(Steal::new((untracked_resolver_for_lowering, krate))),\n+                feed.crate_for_resolver(tcx.arena.alloc(Steal::new(krate)));\n+                feed.metadata_loader(\n+                    tcx.arena.alloc(Steal::new(self.codegen_backend().metadata_loader())),\n                 );\n-                feed.resolutions(tcx.arena.alloc(untracked_resolutions));\n                 feed.features_query(tcx.sess.features_untracked());\n-                let feed = tcx.feed_local_crate();\n-                feed.crate_name(crate_name);\n             });\n-            Ok(gcx)\n+            Ok(qcx)\n         })\n     }\n "}, {"sha": "475d3601b52ab65263b5fc92e767c71ac7d40049", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -14,8 +14,8 @@ use rustc_session::filesearch::sysroot_candidates;\n use rustc_session::lint::{self, BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::parse::CrateConfig;\n use rustc_session::{early_error, filesearch, output, Session};\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::edition::Edition;\n-use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::FileLoader;\n use rustc_span::symbol::{sym, Symbol};\n use session::CompilerIO;"}, {"sha": "aace4974cc935cad3de3cb4957f8a0a6cdcde790", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -39,7 +39,7 @@ use rustc_middle::ty::{self, print::Printer, subst::GenericArg, RegisteredTools,\n use rustc_session::lint::{BuiltinLintDiagnostics, LintExpectationId};\n use rustc_session::lint::{FutureIncompatibleInfo, Level, Lint, LintBuffer, LintId};\n use rustc_session::Session;\n-use rustc_span::lev_distance::find_best_match_for_name;\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{BytePos, Span};\n use rustc_target::abi;"}, {"sha": "b05626311e8e1f0deccd2b455aa0c5d4f38b770e", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -8,15 +8,15 @@ use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_ast::{self as ast, *};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::svh::Svh;\n-use rustc_data_structures::sync::ReadGuard;\n+use rustc_data_structures::sync::MappedReadGuard;\n use rustc_expand::base::SyntaxExtension;\n use rustc_hir::def_id::{CrateNum, LocalDefId, StableCrateId, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::{self, CrateType, ExternLocation};\n+use rustc_session::cstore::ExternCrateSource;\n use rustc_session::cstore::{CrateDepKind, CrateSource, ExternCrate};\n-use rustc_session::cstore::{ExternCrateSource, MetadataLoaderDyn};\n use rustc_session::lint;\n use rustc_session::output::validate_crate_name;\n use rustc_session::search_paths::PathKind;\n@@ -60,17 +60,22 @@ impl std::fmt::Debug for CStore {\n     }\n }\n \n-pub struct CrateLoader<'a> {\n+pub struct CrateLoader<'a, 'tcx: 'a> {\n     // Immutable configuration.\n-    sess: &'a Session,\n-    metadata_loader: &'a MetadataLoaderDyn,\n-    definitions: ReadGuard<'a, Definitions>,\n-    local_crate_name: Symbol,\n+    tcx: TyCtxt<'tcx>,\n     // Mutable output.\n     cstore: &'a mut CStore,\n     used_extern_options: &'a mut FxHashSet<Symbol>,\n }\n \n+impl<'a, 'tcx> std::ops::Deref for CrateLoader<'a, 'tcx> {\n+    type Target = TyCtxt<'tcx>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.tcx\n+    }\n+}\n+\n pub enum LoadedMacro {\n     MacroDef(ast::Item, Edition),\n     ProcMacro(SyntaxExtension),\n@@ -127,11 +132,10 @@ impl<'a> std::fmt::Debug for CrateDump<'a> {\n }\n \n impl CStore {\n-    pub fn from_tcx(tcx: TyCtxt<'_>) -> &CStore {\n-        tcx.cstore_untracked()\n-            .as_any()\n-            .downcast_ref::<CStore>()\n-            .expect(\"`tcx.cstore` is not a `CStore`\")\n+    pub fn from_tcx(tcx: TyCtxt<'_>) -> MappedReadGuard<'_, CStore> {\n+        MappedReadGuard::map(tcx.cstore_untracked(), |c| {\n+            c.as_any().downcast_ref::<CStore>().expect(\"`tcx.cstore` is not a `CStore`\")\n+        })\n     }\n \n     fn alloc_new_crate_num(&mut self) -> CrateNum {\n@@ -256,23 +260,13 @@ impl CStore {\n     }\n }\n \n-impl<'a> CrateLoader<'a> {\n+impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n     pub fn new(\n-        sess: &'a Session,\n-        metadata_loader: &'a MetadataLoaderDyn,\n-        local_crate_name: Symbol,\n+        tcx: TyCtxt<'tcx>,\n         cstore: &'a mut CStore,\n-        definitions: ReadGuard<'a, Definitions>,\n         used_extern_options: &'a mut FxHashSet<Symbol>,\n     ) -> Self {\n-        CrateLoader {\n-            sess,\n-            metadata_loader,\n-            local_crate_name,\n-            cstore,\n-            used_extern_options,\n-            definitions,\n-        }\n+        CrateLoader { tcx, cstore, used_extern_options }\n     }\n     pub fn cstore(&self) -> &CStore {\n         &self.cstore\n@@ -563,9 +557,10 @@ impl<'a> CrateLoader<'a> {\n             (LoadResult::Previous(cnum), None)\n         } else {\n             info!(\"falling back to a load\");\n+            let metadata_loader = self.tcx.metadata_loader(()).borrow();\n             let mut locator = CrateLocator::new(\n                 self.sess,\n-                &*self.metadata_loader,\n+                &**metadata_loader,\n                 name,\n                 hash,\n                 extra_filename,\n@@ -970,7 +965,7 @@ impl<'a> CrateLoader<'a> {\n                     &format!(\n                         \"external crate `{}` unused in `{}`: remove the dependency or add `use {} as _;`\",\n                         name,\n-                        self.local_crate_name,\n+                        self.tcx.crate_name(LOCAL_CRATE),\n                         name),\n                 );\n         }\n@@ -990,6 +985,7 @@ impl<'a> CrateLoader<'a> {\n         &mut self,\n         item: &ast::Item,\n         def_id: LocalDefId,\n+        definitions: &Definitions,\n     ) -> Option<CrateNum> {\n         match item.kind {\n             ast::ItemKind::ExternCrate(orig_name) => {\n@@ -1012,7 +1008,7 @@ impl<'a> CrateLoader<'a> {\n \n                 let cnum = self.resolve_crate(name, item.span, dep_kind)?;\n \n-                let path_len = self.definitions.def_path(def_id).data.len();\n+                let path_len = definitions.def_path(def_id).data.len();\n                 self.update_extern_crate(\n                     cnum,\n                     ExternCrate {"}, {"sha": "60ea08a16473c96876a445a11fee5ac9342628fc", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -130,7 +130,13 @@ macro_rules! provide_one {\n                 $tcx.ensure().crate_hash($def_id.krate);\n             }\n \n-            let $cdata = CStore::from_tcx($tcx).get_crate_data($def_id.krate);\n+            let cdata = rustc_data_structures::sync::MappedReadGuard::map(CStore::from_tcx($tcx), |c| {\n+                c.get_crate_data($def_id.krate).cdata\n+            });\n+            let $cdata = crate::creader::CrateMetadataRef {\n+                cdata: &cdata,\n+                cstore: &CStore::from_tcx($tcx),\n+            };\n \n             $compute\n         }"}, {"sha": "d4019b5bf17eb3c1ed9455a59d3f91d801d235e3", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -35,6 +35,8 @@ macro_rules! arena_types {\n                 rustc_data_structures::sync::Lrc<rustc_ast::Crate>,\n             )>,\n             [] output_filenames: std::sync::Arc<rustc_session::config::OutputFilenames>,\n+            [] metadata_loader: rustc_data_structures::steal::Steal<Box<rustc_session::cstore::MetadataLoaderDyn>>,\n+            [] crate_for_resolver: rustc_data_structures::steal::Steal<rustc_ast::ast::Crate>,\n             [] resolutions: rustc_middle::ty::ResolverGlobalCtxt,\n             [decode] unsafety_check_result: rustc_middle::mir::UnsafetyCheckResult,\n             [decode] code_region: rustc_middle::mir::coverage::CodeRegion,"}, {"sha": "893bf54b8660b101e5dafda730db29fde96b5517", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -194,11 +194,6 @@ impl EffectiveVisibilities {\n     }\n }\n \n-pub trait IntoDefIdTree {\n-    type Tree: DefIdTree;\n-    fn tree(self) -> Self::Tree;\n-}\n-\n impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n     pub fn iter(&self) -> impl Iterator<Item = (&Id, &EffectiveVisibility)> {\n         self.map.iter()\n@@ -217,25 +212,21 @@ impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n         self.map.entry(id).or_insert_with(|| EffectiveVisibility::from_vis(lazy_private_vis()))\n     }\n \n-    pub fn update<T: IntoDefIdTree>(\n+    pub fn update(\n         &mut self,\n         id: Id,\n         nominal_vis: Visibility,\n-        lazy_private_vis: impl FnOnce(T) -> (Visibility, T),\n+        lazy_private_vis: impl FnOnce() -> Visibility,\n         inherited_effective_vis: EffectiveVisibility,\n         level: Level,\n-        mut into_tree: T,\n+        tree: impl DefIdTree,\n     ) -> bool {\n         let mut changed = false;\n-        let mut current_effective_vis = match self.map.get(&id).copied() {\n-            Some(eff_vis) => eff_vis,\n-            None => {\n-                let private_vis;\n-                (private_vis, into_tree) = lazy_private_vis(into_tree);\n-                EffectiveVisibility::from_vis(private_vis)\n-            }\n-        };\n-        let tree = into_tree.tree();\n+        let mut current_effective_vis = self\n+            .map\n+            .get(&id)\n+            .copied()\n+            .unwrap_or_else(|| EffectiveVisibility::from_vis(lazy_private_vis()));\n \n         let mut inherited_effective_vis_at_prev_level = *inherited_effective_vis.at_level(level);\n         let mut calculated_effective_vis = inherited_effective_vis_at_prev_level;"}, {"sha": "3b559c7f8adff5cfcb98b9cac6df176fdefd0767", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -33,7 +33,7 @@ rustc_queries! {\n     }\n \n     query resolver_for_lowering(_: ()) -> &'tcx Steal<(ty::ResolverAstLowering, Lrc<ast::Crate>)> {\n-        feedable\n+        eval_always\n         no_hash\n         desc { \"getting the resolver for lowering\" }\n     }\n@@ -2077,6 +2077,18 @@ rustc_queries! {\n         desc { \"looking up enabled feature gates\" }\n     }\n \n+    query metadata_loader((): ()) -> &'tcx Steal<Box<rustc_session::cstore::MetadataLoaderDyn>> {\n+        feedable\n+        no_hash\n+        desc { \"raw operations for metadata file access\" }\n+    }\n+\n+    query crate_for_resolver((): ()) -> &'tcx Steal<rustc_ast::ast::Crate> {\n+        feedable\n+        no_hash\n+        desc { \"the ast before macro expansion and name resolution\" }\n+    }\n+\n     /// Attempt to resolve the given `DefId` to an `Instance`, for the\n     /// given generics args (`SubstsRef`), returning one of:\n     ///  * `Ok(Some(instance))` on success"}, {"sha": "cf4836ded474bb94538f4f10b50fffd5eae371aa", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -36,7 +36,7 @@ use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n-use rustc_data_structures::sync::{self, Lock, Lrc, ReadGuard, WorkerLocal};\n+use rustc_data_structures::sync::{self, Lock, Lrc, MappedReadGuard, ReadGuard, WorkerLocal};\n use rustc_errors::{\n     DecorateLint, DiagnosticBuilder, DiagnosticMessage, ErrorGuaranteed, MultiSpan,\n };\n@@ -836,7 +836,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let Some(id) = id.as_local() {\n             self.definitions_untracked().def_key(id)\n         } else {\n-            self.untracked.cstore.def_key(id)\n+            self.cstore_untracked().def_key(id)\n         }\n     }\n \n@@ -850,7 +850,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let Some(id) = id.as_local() {\n             self.definitions_untracked().def_path(id)\n         } else {\n-            self.untracked.cstore.def_path(id)\n+            self.cstore_untracked().def_path(id)\n         }\n     }\n \n@@ -860,7 +860,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let Some(def_id) = def_id.as_local() {\n             self.definitions_untracked().def_path_hash(def_id)\n         } else {\n-            self.untracked.cstore.def_path_hash(def_id)\n+            self.cstore_untracked().def_path_hash(def_id)\n         }\n     }\n \n@@ -869,7 +869,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if crate_num == LOCAL_CRATE {\n             self.sess.local_stable_crate_id()\n         } else {\n-            self.untracked.cstore.stable_crate_id(crate_num)\n+            self.cstore_untracked().stable_crate_id(crate_num)\n         }\n     }\n \n@@ -880,7 +880,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if stable_crate_id == self.sess.local_stable_crate_id() {\n             LOCAL_CRATE\n         } else {\n-            self.untracked.cstore.stable_crate_id_to_crate_num(stable_crate_id)\n+            self.cstore_untracked().stable_crate_id_to_crate_num(stable_crate_id)\n         }\n     }\n \n@@ -899,7 +899,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         } else {\n             // If this is a DefPathHash from an upstream crate, let the CrateStore map\n             // it to a DefId.\n-            let cstore = &*self.untracked.cstore;\n+            let cstore = &*self.cstore_untracked();\n             let cnum = cstore.stable_crate_id_to_crate_num(stable_crate_id);\n             cstore.def_path_hash_to_def_id(cnum, hash)\n         }\n@@ -913,7 +913,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let (crate_name, stable_crate_id) = if def_id.is_local() {\n             (self.crate_name(LOCAL_CRATE), self.sess.local_stable_crate_id())\n         } else {\n-            let cstore = &*self.untracked.cstore;\n+            let cstore = &*self.cstore_untracked();\n             (cstore.crate_name(def_id.krate), cstore.stable_crate_id(def_id.krate))\n         };\n \n@@ -1011,10 +1011,14 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Note that this is *untracked* and should only be used within the query\n     /// system if the result is otherwise tracked through queries\n-    pub fn cstore_untracked(self) -> &'tcx CrateStoreDyn {\n-        &*self.untracked.cstore\n+    pub fn cstore_untracked(self) -> MappedReadGuard<'tcx, CrateStoreDyn> {\n+        ReadGuard::map(self.untracked.cstore.read(), |c| &**c)\n     }\n \n+    /// Give out access to the untracked data without any sanity checks.\n+    pub fn untracked(self) -> &'tcx Untracked {\n+        &self.untracked\n+    }\n     /// Note that this is *untracked* and should only be used within the query\n     /// system if the result is otherwise tracked through queries\n     #[inline]\n@@ -1026,7 +1030,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// system if the result is otherwise tracked through queries\n     #[inline]\n     pub fn source_span_untracked(self, def_id: LocalDefId) -> Span {\n-        self.untracked.source_span.get(def_id).copied().unwrap_or(DUMMY_SP)\n+        self.untracked.source_span.read().get(def_id).copied().unwrap_or(DUMMY_SP)\n     }\n \n     #[inline(always)]\n@@ -2518,5 +2522,5 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         tcx.lang_items().panic_impl().map_or(false, |did| did.is_local())\n     };\n     providers.source_span =\n-        |tcx, def_id| tcx.untracked.source_span.get(def_id).copied().unwrap_or(DUMMY_SP);\n+        |tcx, def_id| tcx.untracked.source_span.read().get(def_id).copied().unwrap_or(DUMMY_SP);\n }"}, {"sha": "f61fe707ac934fd41a631060c88a00798824a8e1", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -43,7 +43,6 @@ use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_serialize::{Decodable, Encodable};\n-use rustc_session::cstore::Untracked;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{ExpnId, ExpnKind, Span};\n@@ -157,7 +156,6 @@ pub type RegisteredTools = FxHashSet<Ident>;\n pub struct ResolverOutputs {\n     pub global_ctxt: ResolverGlobalCtxt,\n     pub ast_lowering: ResolverAstLowering,\n-    pub untracked: Untracked,\n }\n \n #[derive(Debug)]"}, {"sha": "f164bb330f3daee79ee8ff506ca26398cc713b46", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -19,8 +19,8 @@ use rustc_errors::{\n     struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic, PResult,\n     StashKey,\n };\n+use rustc_span::edit_distance::edit_distance;\n use rustc_span::edition::Edition;\n-use rustc_span::lev_distance::lev_distance;\n use rustc_span::source_map::{self, Span};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::DUMMY_SP;\n@@ -459,7 +459,8 @@ impl<'a> Parser<'a> {\n                 // Maybe the user misspelled `macro_rules` (issue #91227)\n                 if self.token.is_ident()\n                     && path.segments.len() == 1\n-                    && lev_distance(\"macro_rules\", &path.segments[0].ident.to_string(), 3).is_some()\n+                    && edit_distance(\"macro_rules\", &path.segments[0].ident.to_string(), 2)\n+                        .is_some()\n                 {\n                     err.span_suggestion(\n                         path.span,"}, {"sha": "8db8ee9428bc737fb78c413f1a99b889b64a2717", "filename": "compiler/rustc_query_system/src/ich/hcx.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fhcx.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -90,7 +90,7 @@ impl<'a> StableHashingContext<'a> {\n         if let Some(def_id) = def_id.as_local() {\n             self.local_def_path_hash(def_id)\n         } else {\n-            self.untracked.cstore.def_path_hash(def_id)\n+            self.untracked.cstore.read().def_path_hash(def_id)\n         }\n     }\n \n@@ -146,7 +146,7 @@ impl<'a> rustc_span::HashStableContext for StableHashingContext<'a> {\n \n     #[inline]\n     fn def_span(&self, def_id: LocalDefId) -> Span {\n-        *self.untracked.source_span.get(def_id).unwrap_or(&DUMMY_SP)\n+        *self.untracked.source_span.read().get(def_id).unwrap_or(&DUMMY_SP)\n     }\n \n     #[inline]"}, {"sha": "b1e023f2caa5761b3620d7e030268dd8a74b91d3", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 51, "deletions": 31, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -130,11 +130,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         def_key.disambiguated_data.data.get_opt_name().expect(\"module without name\")\n                     };\n \n+                    let expn_id = self.cstore().module_expansion_untracked(def_id, &self.tcx.sess);\n+                    let span = self.cstore().get_span_untracked(def_id, &self.tcx.sess);\n                     Some(self.new_module(\n                         parent,\n                         ModuleKind::Def(def_kind, def_id, name),\n-                        self.cstore().module_expansion_untracked(def_id, &self.session),\n-                        self.cstore().get_span_untracked(def_id, &self.session),\n+                        expn_id,\n+                        span,\n                         // FIXME: Account for `#[no_implicit_prelude]` attributes.\n                         parent.map_or(false, |module| module.no_implicit_prelude),\n                     ))\n@@ -179,7 +181,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             return macro_data.clone();\n         }\n \n-        let (ext, macro_rules) = match self.cstore().load_macro_untracked(def_id, &self.session) {\n+        let load_macro_untracked = self.cstore().load_macro_untracked(def_id, &self.tcx.sess);\n+        let (ext, macro_rules) = match load_macro_untracked {\n             LoadedMacro::MacroDef(item, edition) => (\n                 Lrc::new(self.compile_macro(&item, edition).0),\n                 matches!(item.kind, ItemKind::MacroDef(def) if def.macro_rules),\n@@ -204,9 +207,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     pub(crate) fn build_reduced_graph_external(&mut self, module: Module<'a>) {\n-        for child in\n-            Vec::from_iter(self.cstore().module_children_untracked(module.def_id(), self.session))\n-        {\n+        let children =\n+            Vec::from_iter(self.cstore().module_children_untracked(module.def_id(), self.tcx.sess));\n+        for child in children {\n             let parent_scope = ParentScope::module(module, self);\n             BuildReducedGraphVisitor { r: self, parent_scope }\n                 .build_reduced_graph_for_external_crate_res(child);\n@@ -346,7 +349,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n \n     fn insert_field_names_extern(&mut self, def_id: DefId) {\n         let field_names =\n-            self.r.cstore().struct_field_names_untracked(def_id, self.r.session).collect();\n+            self.r.cstore().struct_field_names_untracked(def_id, self.r.tcx.sess).collect();\n         self.r.field_names.insert(def_id, field_names);\n     }\n \n@@ -539,14 +542,15 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                         }\n \n                         self.r\n-                            .session\n+                            .tcx\n+                            .sess\n                             .struct_span_err(item.span, \"`$crate` may not be imported\")\n                             .emit();\n                     }\n                 }\n \n                 if ident.name == kw::Crate {\n-                    self.r.session.span_err(\n+                    self.r.tcx.sess.span_err(\n                         ident.span,\n                         \"crate root imports need to be explicitly named: \\\n                          `use crate as name;`\",\n@@ -575,7 +579,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n             }\n             ast::UseTreeKind::Glob => {\n                 let kind = ImportKind::Glob {\n-                    is_prelude: self.r.session.contains_name(&item.attrs, sym::prelude_import),\n+                    is_prelude: self.r.tcx.sess.contains_name(&item.attrs, sym::prelude_import),\n                     max_vis: Cell::new(None),\n                     id,\n                 };\n@@ -690,7 +694,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                     expansion.to_expn_id(),\n                     item.span,\n                     parent.no_implicit_prelude\n-                        || self.r.session.contains_name(&item.attrs, sym::no_implicit_prelude),\n+                        || self.r.tcx.sess.contains_name(&item.attrs, sym::no_implicit_prelude),\n                 );\n                 self.r.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n \n@@ -755,7 +759,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                     // If the structure is marked as non_exhaustive then lower the visibility\n                     // to within the crate.\n                     let mut ctor_vis = if vis.is_public()\n-                        && self.r.session.contains_name(&item.attrs, sym::non_exhaustive)\n+                        && self.r.tcx.sess.contains_name(&item.attrs, sym::non_exhaustive)\n                     {\n                         ty::Visibility::Restricted(CRATE_DEF_ID)\n                     } else {\n@@ -837,7 +841,8 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n \n         let (used, module, binding) = if orig_name.is_none() && ident.name == kw::SelfLower {\n             self.r\n-                .session\n+                .tcx\n+                .sess\n                 .struct_span_err(item.span, \"`extern crate self;` requires renaming\")\n                 .span_suggestion(\n                     item.span,\n@@ -850,7 +855,10 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         } else if orig_name == Some(kw::SelfLower) {\n             Some(self.r.graph_root)\n         } else {\n-            let crate_id = self.r.crate_loader().process_extern_crate(item, local_def_id);\n+            let tcx = self.r.tcx;\n+            let crate_id = self.r.crate_loader(|c| {\n+                c.process_extern_crate(item, local_def_id, &tcx.definitions_untracked())\n+            });\n             crate_id.map(|crate_id| {\n                 self.r.extern_crate_map.insert(local_def_id, crate_id);\n                 self.r.expect_module(crate_id.as_def_id())\n@@ -887,7 +895,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                 {\n                     let msg = \"macro-expanded `extern crate` items cannot \\\n                                        shadow names passed with `--extern`\";\n-                    self.r.session.span_err(item.span, msg);\n+                    self.r.tcx.sess.span_err(item.span, msg);\n                 }\n             }\n             let entry = self.r.extern_prelude.entry(ident.normalize_to_macros_2_0()).or_insert(\n@@ -998,23 +1006,26 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n             | Res::Err => bug!(\"unexpected resolution: {:?}\", res),\n         }\n         // Record some extra data for better diagnostics.\n-        let cstore = self.r.cstore();\n         match res {\n             Res::Def(DefKind::Struct, def_id) => {\n+                let cstore = self.r.cstore();\n                 if let Some((ctor_kind, ctor_def_id)) = cstore.ctor_untracked(def_id) {\n                     let ctor_res = Res::Def(DefKind::Ctor(CtorOf::Struct, ctor_kind), ctor_def_id);\n                     let ctor_vis = cstore.visibility_untracked(ctor_def_id);\n                     let field_visibilities =\n                         cstore.struct_field_visibilities_untracked(def_id).collect();\n+                    drop(cstore);\n                     self.r\n                         .struct_constructors\n                         .insert(def_id, (ctor_res, ctor_vis, field_visibilities));\n+                } else {\n+                    drop(cstore);\n                 }\n                 self.insert_field_names_extern(def_id)\n             }\n             Res::Def(DefKind::Union, def_id) => self.insert_field_names_extern(def_id),\n             Res::Def(DefKind::AssocFn, def_id) => {\n-                if cstore.fn_has_self_parameter_untracked(def_id, self.r.session) {\n+                if self.r.cstore().fn_has_self_parameter_untracked(def_id, self.r.tcx.sess) {\n                     self.r.has_self.insert(def_id);\n                 }\n             }\n@@ -1033,7 +1044,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n             let msg = format!(\"`{}` is already in scope\", name);\n             let note =\n                 \"macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\";\n-            self.r.session.struct_span_err(span, &msg).note(note).emit();\n+            self.r.tcx.sess.struct_span_err(span, &msg).note(note).emit();\n         }\n     }\n \n@@ -1045,7 +1056,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n             if attr.has_name(sym::macro_use) {\n                 if self.parent_scope.module.parent.is_some() {\n                     struct_span_err!(\n-                        self.r.session,\n+                        self.r.tcx.sess,\n                         item.span,\n                         E0468,\n                         \"an `extern crate` loading macros must be at the crate root\"\n@@ -1055,7 +1066,8 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                 if let ItemKind::ExternCrate(Some(orig_name)) = item.kind {\n                     if orig_name == kw::SelfLower {\n                         self.r\n-                            .session\n+                            .tcx\n+                            .sess\n                             .struct_span_err(\n                                 attr.span,\n                                 \"`#[macro_use]` is not supported on `extern crate self`\",\n@@ -1064,7 +1076,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                     }\n                 }\n                 let ill_formed = |span| {\n-                    struct_span_err!(self.r.session, span, E0466, \"bad macro import\").emit();\n+                    struct_span_err!(self.r.tcx.sess, span, E0466, \"bad macro import\").emit();\n                 };\n                 match attr.meta() {\n                     Some(meta) => match meta.kind {\n@@ -1135,8 +1147,13 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                         allow_shadowing,\n                     );\n                 } else {\n-                    struct_span_err!(self.r.session, ident.span, E0469, \"imported macro not found\")\n-                        .emit();\n+                    struct_span_err!(\n+                        self.r.tcx.sess,\n+                        ident.span,\n+                        E0469,\n+                        \"imported macro not found\"\n+                    )\n+                    .emit();\n                 }\n             }\n         }\n@@ -1148,7 +1165,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         for attr in attrs {\n             if attr.has_name(sym::macro_escape) {\n                 let msg = \"`#[macro_escape]` is a deprecated synonym for `#[macro_use]`\";\n-                let mut err = self.r.session.struct_span_warn(attr.span, msg);\n+                let mut err = self.r.tcx.sess.struct_span_warn(attr.span, msg);\n                 if let ast::AttrStyle::Inner = attr.style {\n                     err.help(\"try an outer attribute: `#[macro_use]`\").emit();\n                 } else {\n@@ -1159,7 +1176,10 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n             }\n \n             if !attr.is_word() {\n-                self.r.session.span_err(attr.span, \"arguments to `macro_use` are not allowed here\");\n+                self.r\n+                    .tcx\n+                    .sess\n+                    .span_err(attr.span, \"arguments to `macro_use` are not allowed here\");\n             }\n             return true;\n         }\n@@ -1183,11 +1203,11 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n     }\n \n     fn proc_macro_stub(&self, item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {\n-        if self.r.session.contains_name(&item.attrs, sym::proc_macro) {\n+        if self.r.tcx.sess.contains_name(&item.attrs, sym::proc_macro) {\n             return Some((MacroKind::Bang, item.ident, item.span));\n-        } else if self.r.session.contains_name(&item.attrs, sym::proc_macro_attribute) {\n+        } else if self.r.tcx.sess.contains_name(&item.attrs, sym::proc_macro_attribute) {\n             return Some((MacroKind::Attr, item.ident, item.span));\n-        } else if let Some(attr) = self.r.session.find_by_name(&item.attrs, sym::proc_macro_derive)\n+        } else if let Some(attr) = self.r.tcx.sess.find_by_name(&item.attrs, sym::proc_macro_derive)\n         {\n             if let Some(nested_meta) = attr.meta_item_list().and_then(|list| list.get(0).cloned()) {\n                 if let Some(ident) = nested_meta.ident() {\n@@ -1222,7 +1242,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         let def_id = self.r.local_def_id(item.id);\n         let (ext, ident, span, macro_rules, rule_spans) = match &item.kind {\n             ItemKind::MacroDef(def) => {\n-                let (ext, rule_spans) = self.r.compile_macro(item, self.r.session.edition());\n+                let (ext, rule_spans) = self.r.compile_macro(item, self.r.tcx.sess.edition());\n                 let ext = Lrc::new(ext);\n                 (ext, item.ident, item.span, def.macro_rules, rule_spans)\n             }\n@@ -1243,7 +1263,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         if macro_rules {\n             let ident = ident.normalize_to_macros_2_0();\n             self.r.macro_names.insert(ident);\n-            let is_macro_export = self.r.session.contains_name(&item.attrs, sym::macro_export);\n+            let is_macro_export = self.r.tcx.sess.contains_name(&item.attrs, sym::macro_export);\n             let vis = if is_macro_export {\n                 ty::Visibility::Public\n             } else {\n@@ -1507,7 +1527,7 @@ impl<'a, 'b, 'tcx> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n \n         // If the variant is marked as non_exhaustive then lower the visibility to within the crate.\n         let ctor_vis = if vis.is_public()\n-            && self.r.session.contains_name(&variant.attrs, sym::non_exhaustive)\n+            && self.r.tcx.sess.contains_name(&variant.attrs, sym::non_exhaustive)\n         {\n             ty::Visibility::Restricted(CRATE_DEF_ID)\n         } else {"}, {"sha": "0114e116386b028be4cb2d9e779bc7de051fedfc", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -290,7 +290,7 @@ impl Resolver<'_, '_> {\n             let ms = MultiSpan::from_spans(spans.clone());\n             let mut span_snippets = spans\n                 .iter()\n-                .filter_map(|s| match visitor.r.session.source_map().span_to_snippet(*s) {\n+                .filter_map(|s| match visitor.r.tcx.sess.source_map().span_to_snippet(*s) {\n                     Ok(s) => Some(format!(\"`{}`\", s)),\n                     _ => None,\n                 })\n@@ -317,7 +317,7 @@ impl Resolver<'_, '_> {\n             // If we are in the `--test` mode, suppress a help that adds the `#[cfg(test)]`\n             // attribute; however, if not, suggest adding the attribute. There is no way to\n             // retrieve attributes here because we do not have a `TyCtxt` yet.\n-            let test_module_span = if visitor.r.session.opts.test {\n+            let test_module_span = if visitor.r.tcx.sess.opts.test {\n                 None\n             } else {\n                 let parent_module = visitor.r.get_nearest_non_block_module("}, {"sha": "9aec25fff0b4f4f3d64f6f10ec2154f951cc64ba", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 82, "deletions": 71, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -21,9 +21,9 @@ use rustc_session::lint::builtin::ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE;\n use rustc_session::lint::builtin::MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS;\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::Session;\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::MacroKind;\n-use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, Span, SyntaxContext};\n@@ -154,8 +154,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             if !candidates.is_empty() {\n                 show_candidates(\n-                    &self.session,\n-                    &self.untracked.source_span,\n+                    &self.tcx.sess,\n+                    &self.tcx.untracked().source_span.read(),\n                     &mut err,\n                     span,\n                     &candidates,\n@@ -206,7 +206,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         };\n \n         let (name, span) =\n-            (ident.name, self.session.source_map().guess_head_span(new_binding.span));\n+            (ident.name, self.tcx.sess.source_map().guess_head_span(new_binding.span));\n \n         if let Some(s) = self.name_already_seen.get(&name) {\n             if s == &span {\n@@ -226,15 +226,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let msg = format!(\"the name `{}` is defined multiple times\", name);\n \n         let mut err = match (old_binding.is_extern_crate(), new_binding.is_extern_crate()) {\n-            (true, true) => struct_span_err!(self.session, span, E0259, \"{}\", msg),\n+            (true, true) => struct_span_err!(self.tcx.sess, span, E0259, \"{}\", msg),\n             (true, _) | (_, true) => match new_binding.is_import() && old_binding.is_import() {\n-                true => struct_span_err!(self.session, span, E0254, \"{}\", msg),\n-                false => struct_span_err!(self.session, span, E0260, \"{}\", msg),\n+                true => struct_span_err!(self.tcx.sess, span, E0254, \"{}\", msg),\n+                false => struct_span_err!(self.tcx.sess, span, E0260, \"{}\", msg),\n             },\n             _ => match (old_binding.is_import_user_facing(), new_binding.is_import_user_facing()) {\n-                (false, false) => struct_span_err!(self.session, span, E0428, \"{}\", msg),\n-                (true, true) => struct_span_err!(self.session, span, E0252, \"{}\", msg),\n-                _ => struct_span_err!(self.session, span, E0255, \"{}\", msg),\n+                (false, false) => struct_span_err!(self.tcx.sess, span, E0428, \"{}\", msg),\n+                (true, true) => struct_span_err!(self.tcx.sess, span, E0252, \"{}\", msg),\n+                _ => struct_span_err!(self.tcx.sess, span, E0255, \"{}\", msg),\n             },\n         };\n \n@@ -248,7 +248,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         err.span_label(span, format!(\"`{}` re{} here\", name, new_participle));\n         if !old_binding.span.is_dummy() && old_binding.span != span {\n             err.span_label(\n-                self.session.source_map().guess_head_span(old_binding.span),\n+                self.tcx.sess.source_map().guess_head_span(old_binding.span),\n                 format!(\"previous {} of the {} `{}` here\", old_noun, old_kind, name),\n             );\n         }\n@@ -352,7 +352,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 if let Some(pos) =\n                     source.span.hi().0.checked_sub(binding_span.lo().0).map(|pos| pos as usize)\n                 {\n-                    if let Ok(snippet) = self.session.source_map().span_to_snippet(binding_span) {\n+                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(binding_span) {\n                         if pos <= snippet.len() {\n                             suggestion = Some(format!(\n                                 \"{} as {}{}\",\n@@ -426,12 +426,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         //   `a` and `import.use_span` is `issue_52891::{d, e, a};`.\n \n         let (found_closing_brace, span) =\n-            find_span_of_binding_until_next_binding(self.session, binding_span, import.use_span);\n+            find_span_of_binding_until_next_binding(self.tcx.sess, binding_span, import.use_span);\n \n         // If there was a closing brace then identify the span to remove any trailing commas from\n         // previous imports.\n         if found_closing_brace {\n-            if let Some(span) = extend_span_to_previous_binding(self.session, span) {\n+            if let Some(span) = extend_span_to_previous_binding(self.tcx.sess, span) {\n                 err.tool_only_span_suggestion(span, message, \"\", Applicability::MaybeIncorrect);\n             } else {\n                 // Remove the entire line if we cannot extend the span back, this indicates an\n@@ -462,7 +462,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         let first_name = match path.get(0) {\n             // In the 2018 edition this lint is a hard error, so nothing to do\n-            Some(seg) if seg.ident.span.is_rust_2015() && self.session.is_rust_2015() => {\n+            Some(seg) if seg.ident.span.is_rust_2015() && self.tcx.sess.is_rust_2015() => {\n                 seg.ident.name\n             }\n             _ => return,\n@@ -541,14 +541,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match resolution_error {\n             ResolutionError::GenericParamsFromOuterFunction(outer_res, has_generic_params) => {\n                 let mut err = struct_span_err!(\n-                    self.session,\n+                    self.tcx.sess,\n                     span,\n                     E0401,\n                     \"can't use generic parameters from outer function\",\n                 );\n                 err.span_label(span, \"use of generic parameter from outer function\");\n \n-                let sm = self.session.source_map();\n+                let sm = self.tcx.sess.source_map();\n                 let def_id = match outer_res {\n                     Res::SelfTyParam { .. } => {\n                         err.span_label(span, \"can't use `Self` here\");\n@@ -605,10 +605,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 err\n             }\n             ResolutionError::NameAlreadyUsedInParameterList(name, first_use_span) => self\n-                .session\n+                .tcx\n+                .sess\n                 .create_err(errs::NameAlreadyUsedInParameterList { span, first_use_span, name }),\n             ResolutionError::MethodNotMemberOfTrait(method, trait_, candidate) => {\n-                self.session.create_err(errs::MethodNotMemberOfTrait {\n+                self.tcx.sess.create_err(errs::MethodNotMemberOfTrait {\n                     span,\n                     method,\n                     trait_,\n@@ -619,7 +620,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 })\n             }\n             ResolutionError::TypeNotMemberOfTrait(type_, trait_, candidate) => {\n-                self.session.create_err(errs::TypeNotMemberOfTrait {\n+                self.tcx.sess.create_err(errs::TypeNotMemberOfTrait {\n                     span,\n                     type_,\n                     trait_,\n@@ -630,7 +631,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 })\n             }\n             ResolutionError::ConstNotMemberOfTrait(const_, trait_, candidate) => {\n-                self.session.create_err(errs::ConstNotMemberOfTrait {\n+                self.tcx.sess.create_err(errs::ConstNotMemberOfTrait {\n                     span,\n                     const_,\n                     trait_,\n@@ -648,7 +649,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 let msp = MultiSpan::from_spans(target_sp.clone());\n                 let mut err = struct_span_err!(\n-                    self.session,\n+                    self.tcx.sess,\n                     msp,\n                     E0408,\n                     \"variable `{}` is not bound in all patterns\",\n@@ -686,8 +687,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         err.span_help(span, &help_msg);\n                     }\n                     show_candidates(\n-                        &self.session,\n-                        &self.untracked.source_span,\n+                        &self.tcx.sess,\n+                        &self.tcx.untracked().source_span.read(),\n                         &mut err,\n                         Some(span),\n                         &import_suggestions,\n@@ -701,17 +702,19 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 err\n             }\n             ResolutionError::VariableBoundWithDifferentMode(variable_name, first_binding_span) => {\n-                self.session.create_err(errs::VariableBoundWithDifferentMode {\n+                self.tcx.sess.create_err(errs::VariableBoundWithDifferentMode {\n                     span,\n                     first_binding_span,\n                     variable_name,\n                 })\n             }\n             ResolutionError::IdentifierBoundMoreThanOnceInParameterList(identifier) => self\n-                .session\n+                .tcx\n+                .sess\n                 .create_err(errs::IdentifierBoundMoreThanOnceInParameterList { span, identifier }),\n             ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(identifier) => self\n-                .session\n+                .tcx\n+                .sess\n                 .create_err(errs::IdentifierBoundMoreThanOnceInSamePattern { span, identifier }),\n             ResolutionError::UndeclaredLabel { name, suggestion } => {\n                 let ((sub_reachable, sub_reachable_suggestion), sub_unreachable) = match suggestion\n@@ -737,7 +740,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // No similarly-named labels exist.\n                     None => ((None, None), None),\n                 };\n-                self.session.create_err(errs::UndeclaredLabel {\n+                self.tcx.sess.create_err(errs::UndeclaredLabel {\n                     span,\n                     name,\n                     sub_reachable,\n@@ -762,21 +765,22 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     };\n                     (Some(suggestion), Some(mpart_suggestion))\n                 };\n-                self.session.create_err(errs::SelfImportsOnlyAllowedWithin {\n+                self.tcx.sess.create_err(errs::SelfImportsOnlyAllowedWithin {\n                     span,\n                     suggestion,\n                     mpart_suggestion,\n                 })\n             }\n             ResolutionError::SelfImportCanOnlyAppearOnceInTheList => {\n-                self.session.create_err(errs::SelfImportCanOnlyAppearOnceInTheList { span })\n-            }\n-            ResolutionError::SelfImportOnlyInImportListWithNonEmptyPrefix => {\n-                self.session.create_err(errs::SelfImportOnlyInImportListWithNonEmptyPrefix { span })\n+                self.tcx.sess.create_err(errs::SelfImportCanOnlyAppearOnceInTheList { span })\n             }\n+            ResolutionError::SelfImportOnlyInImportListWithNonEmptyPrefix => self\n+                .tcx\n+                .sess\n+                .create_err(errs::SelfImportOnlyInImportListWithNonEmptyPrefix { span }),\n             ResolutionError::FailedToResolve { label, suggestion } => {\n                 let mut err =\n-                    struct_span_err!(self.session, span, E0433, \"failed to resolve: {}\", &label);\n+                    struct_span_err!(self.tcx.sess, span, E0433, \"failed to resolve: {}\", &label);\n                 err.span_label(span, label);\n \n                 if let Some((suggestions, msg, applicability)) = suggestion {\n@@ -790,7 +794,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 err\n             }\n             ResolutionError::CannotCaptureDynamicEnvironmentInFnItem => {\n-                self.session.create_err(errs::CannotCaptureDynamicEnvironmentInFnItem { span })\n+                self.tcx.sess.create_err(errs::CannotCaptureDynamicEnvironmentInFnItem { span })\n             }\n             ResolutionError::AttemptToUseNonConstantValueInConstant(ident, suggestion, current) => {\n                 // let foo =...\n@@ -802,12 +806,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 // the further the two are apart, the higher the chance of the suggestion being wrong\n \n                 let sp = self\n-                    .session\n+                    .tcx\n+                    .sess\n                     .source_map()\n                     .span_extend_to_prev_str(ident.span, current, true, false);\n \n                 let ((with, with_label), without) = match sp {\n-                    Some(sp) if !self.session.source_map().is_multiline(sp) => {\n+                    Some(sp) if !self.tcx.sess.source_map().is_multiline(sp) => {\n                         let sp = sp.with_lo(BytePos(sp.lo().0 - (current.len() as u32)));\n                         (\n                         (Some(errs::AttemptToUseNonConstantValueInConstantWithSuggestion {\n@@ -828,7 +833,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     ),\n                 };\n \n-                self.session.create_err(errs::AttemptToUseNonConstantValueInConstant {\n+                self.tcx.sess.create_err(errs::AttemptToUseNonConstantValueInConstant {\n                     span,\n                     with,\n                     with_label,\n@@ -842,7 +847,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 article,\n                 shadowed_binding,\n                 shadowed_binding_span,\n-            } => self.session.create_err(errs::BindingShadowsSomethingUnacceptable {\n+            } => self.tcx.sess.create_err(errs::BindingShadowsSomethingUnacceptable {\n                 span,\n                 shadowing_binding,\n                 shadowed_binding,\n@@ -859,13 +864,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 name,\n             }),\n             ResolutionError::ForwardDeclaredGenericParam => {\n-                self.session.create_err(errs::ForwardDeclaredGenericParam { span })\n+                self.tcx.sess.create_err(errs::ForwardDeclaredGenericParam { span })\n             }\n             ResolutionError::ParamInTyOfConstParam(name) => {\n-                self.session.create_err(errs::ParamInTyOfConstParam { span, name })\n+                self.tcx.sess.create_err(errs::ParamInTyOfConstParam { span, name })\n             }\n             ResolutionError::ParamInNonTrivialAnonConst { name, is_type } => {\n-                self.session.create_err(errs::ParamInNonTrivialAnonConst {\n+                self.tcx.sess.create_err(errs::ParamInNonTrivialAnonConst {\n                     span,\n                     name,\n                     sub_is_type: if is_type {\n@@ -874,13 +879,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         errs::ParamInNonTrivialAnonConstIsType::NotAType { name }\n                     },\n                     help: self\n-                        .session\n+                        .tcx\n+                        .sess\n                         .is_nightly_build()\n                         .then_some(errs::ParamInNonTrivialAnonConstHelp),\n                 })\n             }\n             ResolutionError::SelfInGenericParamDefault => {\n-                self.session.create_err(errs::SelfInGenericParamDefault { span })\n+                self.tcx.sess.create_err(errs::SelfInGenericParamDefault { span })\n             }\n             ResolutionError::UnreachableLabel { name, definition_span, suggestion } => {\n                 let ((sub_suggestion_label, sub_suggestion), sub_unreachable_label) =\n@@ -908,7 +914,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // No similarly-named labels exist.\n                         None => ((None, None), None),\n                     };\n-                self.session.create_err(errs::UnreachableLabel {\n+                self.tcx.sess.create_err(errs::UnreachableLabel {\n                     span,\n                     name,\n                     definition_span,\n@@ -924,7 +930,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 trait_item_span,\n                 trait_path,\n             } => {\n-                let mut err = self.session.struct_span_err_with_code(\n+                let mut err = self.tcx.sess.struct_span_err_with_code(\n                     span,\n                     &format!(\n                         \"item `{}` is an associated {}, which doesn't match its trait `{}`\",\n@@ -937,9 +943,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 err\n             }\n             ResolutionError::TraitImplDuplicate { name, trait_item_span, old_span } => self\n-                .session\n+                .tcx\n+                .sess\n                 .create_err(errs::TraitImplDuplicate { span, name, trait_item_span, old_span }),\n-            ResolutionError::InvalidAsmSym => self.session.create_err(errs::InvalidAsmSym { span }),\n+            ResolutionError::InvalidAsmSym => {\n+                self.tcx.sess.create_err(errs::InvalidAsmSym { span })\n+            }\n         }\n     }\n \n@@ -949,7 +958,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     ) -> ErrorGuaranteed {\n         match vis_resolution_error {\n             VisResolutionError::Relative2018(span, path) => {\n-                self.session.create_err(errs::Relative2018 {\n+                self.tcx.sess.create_err(errs::Relative2018 {\n                     span,\n                     path_span: path.span,\n                     // intentionally converting to String, as the text would also be used as\n@@ -958,18 +967,20 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 })\n             }\n             VisResolutionError::AncestorOnly(span) => {\n-                self.session.create_err(errs::AncestorOnly(span))\n+                self.tcx.sess.create_err(errs::AncestorOnly(span))\n             }\n             VisResolutionError::FailedToResolve(span, label, suggestion) => {\n                 self.into_struct_error(span, ResolutionError::FailedToResolve { label, suggestion })\n             }\n             VisResolutionError::ExpectedFound(span, path_str, res) => {\n-                self.session.create_err(errs::ExpectedFound { span, res, path_str })\n+                self.tcx.sess.create_err(errs::ExpectedFound { span, res, path_str })\n             }\n             VisResolutionError::Indeterminate(span) => {\n-                self.session.create_err(errs::Indeterminate(span))\n+                self.tcx.sess.create_err(errs::Indeterminate(span))\n+            }\n+            VisResolutionError::ModuleOnly(span) => {\n+                self.tcx.sess.create_err(errs::ModuleOnly(span))\n             }\n-            VisResolutionError::ModuleOnly(span) => self.session.create_err(errs::ModuleOnly(span)),\n         }\n         .emit()\n     }\n@@ -1206,7 +1217,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // a note about editions\n                             let note = if let Some(did) = did {\n                                 let requires_note = !did.is_local()\n-                                    && this.cstore().item_attrs_untracked(did, this.session).any(\n+                                    && this.cstore().item_attrs_untracked(did, this.tcx.sess).any(\n                                         |attr| {\n                                             if attr.has_name(sym::rustc_diagnostic_item) {\n                                                 [sym::TryInto, sym::TryFrom, sym::FromIterator]\n@@ -1304,7 +1315,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // otherwise cause duplicate suggestions.\n                     continue;\n                 }\n-                let crate_id = self.crate_loader().maybe_process_path_extern(ident.name);\n+                let crate_id = self.crate_loader(|c| c.maybe_process_path_extern(ident.name));\n                 if let Some(crate_id) = crate_id {\n                     let crate_root = self.expect_module(crate_id.as_def_id());\n                     suggestions.extend(self.lookup_import_candidates_from_module(\n@@ -1341,8 +1352,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let import_suggestions =\n             self.lookup_import_candidates(ident, Namespace::MacroNS, parent_scope, is_expected);\n         show_candidates(\n-            &self.session,\n-            &self.untracked.source_span,\n+            &self.tcx.sess,\n+            &self.tcx.untracked().source_span.read(),\n             err,\n             None,\n             &import_suggestions,\n@@ -1366,7 +1377,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             && let ModuleKind::Def(DefKind::Enum, def_id, _) = parent_scope.module.kind\n             && let Some(span) = self.opt_span(def_id)\n         {\n-            let source_map = self.session.source_map();\n+            let source_map = self.tcx.sess.source_map();\n             let head_span = source_map.guess_head_span(span);\n             if let Ok(head) = source_map.span_to_snippet(head_span) {\n                 err.span_suggestion(head_span, \"consider adding a derive\", format!(\"#[derive(Default)]\\n{head}\"), Applicability::MaybeIncorrect);\n@@ -1443,7 +1454,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         };\n         let def_span = suggestion.res.opt_def_id().and_then(|def_id| match def_id.krate {\n             LOCAL_CRATE => self.opt_span(def_id),\n-            _ => Some(self.cstore().get_span_untracked(def_id, self.session)),\n+            _ => Some(self.cstore().get_span_untracked(def_id, self.tcx.sess)),\n         });\n         if let Some(def_span) = def_span {\n             if span.overlaps(def_span) {\n@@ -1473,7 +1484,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             };\n \n             err.span_label(\n-                self.session.source_map().guess_head_span(def_span),\n+                self.tcx.sess.source_map().guess_head_span(def_span),\n                 &format!(\n                     \"{}{} `{}` defined here\",\n                     prefix,\n@@ -1498,15 +1509,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn binding_description(&self, b: &NameBinding<'_>, ident: Ident, from_prelude: bool) -> String {\n         let res = b.res();\n-        if b.span.is_dummy() || !self.session.source_map().is_span_accessible(b.span) {\n+        if b.span.is_dummy() || !self.tcx.sess.source_map().is_span_accessible(b.span) {\n             // These already contain the \"built-in\" prefix or look bad with it.\n             let add_built_in =\n                 !matches!(b.res(), Res::NonMacroAttr(..) | Res::PrimTy(..) | Res::ToolMod);\n             let (built_in, from) = if from_prelude {\n                 (\"\", \" from prelude\")\n             } else if b.is_extern_crate()\n                 && !b.is_import()\n-                && self.session.opts.externs.get(ident.as_str()).is_some()\n+                && self.tcx.sess.opts.externs.get(ident.as_str()).is_some()\n             {\n                 (\"\", \" passed with `--extern`\")\n             } else if add_built_in {\n@@ -1532,7 +1543,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             (b1, b2, misc1, misc2, false)\n         };\n \n-        let mut err = struct_span_err!(self.session, ident.span, E0659, \"`{ident}` is ambiguous\");\n+        let mut err = struct_span_err!(self.tcx.sess, ident.span, E0659, \"`{ident}` is ambiguous\");\n         err.span_label(ident.span, \"ambiguous name\");\n         err.note(&format!(\"ambiguous because of {}\", kind.descr()));\n \n@@ -1604,7 +1615,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Print the primary message.\n         let descr = get_descr(binding);\n         let mut err =\n-            struct_span_err!(self.session, ident.span, E0603, \"{} `{}` is private\", descr, ident);\n+            struct_span_err!(self.tcx.sess, ident.span, E0603, \"{} `{}` is private\", descr, ident);\n         err.span_label(ident.span, &format!(\"private {}\", descr));\n         if let Some(span) = ctor_fields_span {\n             err.span_label(span, \"a constructor is private if any of the fields is private\");\n@@ -1650,7 +1661,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 which = if first { \"\" } else { \" which\" },\n                 dots = if next_binding.is_some() { \"...\" } else { \"\" },\n             );\n-            let def_span = self.session.source_map().guess_head_span(binding.span);\n+            let def_span = self.tcx.sess.source_map().guess_head_span(binding.span);\n             let mut note_span = MultiSpan::from_span(def_span);\n             if !first && binding.vis.is_public() {\n                 note_span.push_span_label(def_span, \"consider importing it directly\");\n@@ -1719,7 +1730,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         Applicability::MaybeIncorrect,\n                     )),\n                 )\n-            } else if self.session.is_rust_2015() {\n+            } else if self.tcx.sess.is_rust_2015() {\n                 (\n                     format!(\"maybe a missing crate `{ident}`?\"),\n                     Some((\n@@ -1738,7 +1749,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             let parent = match parent {\n                 // ::foo is mounted at the crate root for 2015, and is the extern\n                 // prelude for 2018+\n-                kw::PathRoot if self.session.edition() > Edition::Edition2015 => {\n+                kw::PathRoot if self.tcx.sess.edition() > Edition::Edition2015 => {\n                     \"the list of imported crates\".to_owned()\n                 }\n                 kw::PathRoot | kw::Crate => \"the crate root\".to_owned(),\n@@ -2079,7 +2090,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                 //   ie. `use a::b::{c, d, e};`\n                 //                      ^^^\n                 let (found_closing_brace, binding_span) = find_span_of_binding_until_next_binding(\n-                    self.r.session,\n+                    self.r.tcx.sess,\n                     import.span,\n                     import.use_span,\n                 );\n@@ -2098,7 +2109,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                     //   ie. `use a::b::{c, d};`\n                     //                    ^^^\n                     if let Some(previous_span) =\n-                        extend_span_to_previous_binding(self.r.session, binding_span)\n+                        extend_span_to_previous_binding(self.r.tcx.sess, binding_span)\n                     {\n                         debug!(\"check_for_module_export_macro: previous_span={:?}\", previous_span);\n                         removal_span = removal_span.with_lo(previous_span.lo());\n@@ -2116,7 +2127,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                 //   or  `use a::{b, c, d}};`\n                 //               ^^^^^^^^^^^\n                 let (has_nested, after_crate_name) = find_span_immediately_after_crate_name(\n-                    self.r.session,\n+                    self.r.tcx.sess,\n                     module_name,\n                     import.use_span,\n                 );\n@@ -2125,7 +2136,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                     has_nested, after_crate_name\n                 );\n \n-                let source_map = self.r.session.source_map();\n+                let source_map = self.r.tcx.sess.source_map();\n \n                 // Make sure this is actually crate-relative.\n                 let is_definitely_crate = import"}, {"sha": "7bd90d7e3455b7e365e165afd1c7d5cce64e01ac", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1,4 +1,4 @@\n-use crate::{NameBinding, NameBindingKind, Resolver, ResolverTree};\n+use crate::{NameBinding, NameBindingKind, Resolver};\n use rustc_ast::ast;\n use rustc_ast::visit;\n use rustc_ast::visit::Visitor;\n@@ -7,8 +7,8 @@ use rustc_ast::EnumDef;\n use rustc_data_structures::intern::Interned;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::def_id::CRATE_DEF_ID;\n+use rustc_middle::middle::privacy::Level;\n use rustc_middle::middle::privacy::{EffectiveVisibilities, EffectiveVisibility};\n-use rustc_middle::middle::privacy::{IntoDefIdTree, Level};\n use rustc_middle::ty::{DefIdTree, Visibility};\n use std::mem;\n \n@@ -67,13 +67,6 @@ impl Resolver<'_, '_> {\n     }\n }\n \n-impl<'a, 'b, 'tcx> IntoDefIdTree for &'b mut Resolver<'a, 'tcx> {\n-    type Tree = &'b Resolver<'a, 'tcx>;\n-    fn tree(self) -> Self::Tree {\n-        self\n-    }\n-}\n-\n impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n     /// Fills the `Resolver::effective_visibilities` table with public & exported items\n     /// For now, this doesn't resolve macros (FIXME) and cannot resolve Impl, as we\n@@ -107,11 +100,7 @@ impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n         for (binding, eff_vis) in visitor.import_effective_visibilities.iter() {\n             let NameBindingKind::Import { import, .. } = binding.kind else { unreachable!() };\n             if let Some(node_id) = import.id() {\n-                r.effective_visibilities.update_eff_vis(\n-                    r.local_def_id(node_id),\n-                    eff_vis,\n-                    ResolverTree(&r.untracked),\n-                )\n+                r.effective_visibilities.update_eff_vis(r.local_def_id(node_id), eff_vis, r.tcx)\n             }\n         }\n \n@@ -167,26 +156,28 @@ impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n         let nominal_vis = binding.vis.expect_local();\n         let private_vis = self.cheap_private_vis(parent_id);\n         let inherited_eff_vis = self.effective_vis_or_private(parent_id);\n+        let tcx = self.r.tcx;\n         self.changed |= self.import_effective_visibilities.update(\n             binding,\n             nominal_vis,\n-            |r| (private_vis.unwrap_or_else(|| r.private_vis_import(binding)), r),\n+            || private_vis.unwrap_or_else(|| self.r.private_vis_import(binding)),\n             inherited_eff_vis,\n             parent_id.level(),\n-            &mut *self.r,\n+            tcx,\n         );\n     }\n \n     fn update_def(&mut self, def_id: LocalDefId, nominal_vis: Visibility, parent_id: ParentId<'a>) {\n         let private_vis = self.cheap_private_vis(parent_id);\n         let inherited_eff_vis = self.effective_vis_or_private(parent_id);\n+        let tcx = self.r.tcx;\n         self.changed |= self.def_effective_visibilities.update(\n             def_id,\n             nominal_vis,\n-            |r| (private_vis.unwrap_or_else(|| r.private_vis_def(def_id)), r),\n+            || private_vis.unwrap_or_else(|| self.r.private_vis_def(def_id)),\n             inherited_eff_vis,\n             parent_id.level(),\n-            &mut *self.r,\n+            tcx,\n         );\n     }\n "}, {"sha": "ba7f04239c35fd822e998c719e8122f372a3d100", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1179,7 +1179,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         }\n \n                         ConstantItemRibKind(trivial, _) => {\n-                            let features = self.session.features_untracked();\n+                            let features = self.tcx.sess.features_untracked();\n                             // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n                             if !(trivial == ConstantHasGenerics::Yes\n                                 || features.generic_const_exprs)\n@@ -1208,7 +1208,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                 is_type: true,\n                                             },\n                                         );\n-                                        self.session.delay_span_bug(span, CG_BUG_STR);\n+                                        self.tcx.sess.delay_span_bug(span, CG_BUG_STR);\n                                     }\n \n                                     return Res::Err;\n@@ -1255,7 +1255,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         | ForwardGenericParamBanRibKind => continue,\n \n                         ConstantItemRibKind(trivial, _) => {\n-                            let features = self.session.features_untracked();\n+                            let features = self.tcx.sess.features_untracked();\n                             // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n                             if !(trivial == ConstantHasGenerics::Yes\n                                 || features.generic_const_exprs)\n@@ -1268,7 +1268,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                             is_type: false,\n                                         },\n                                     );\n-                                    self.session.delay_span_bug(span, CG_BUG_STR);\n+                                    self.tcx.sess.delay_span_bug(span, CG_BUG_STR);\n                                 }\n \n                                 return Res::Err;\n@@ -1397,7 +1397,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         module = Some(ModuleOrUniformRoot::ExternPrelude);\n                         continue;\n                     }\n-                    if name == kw::PathRoot && ident.span.is_rust_2015() && self.session.rust_2018()\n+                    if name == kw::PathRoot\n+                        && ident.span.is_rust_2015()\n+                        && self.tcx.sess.rust_2018()\n                     {\n                         // `::a::b` from 2015 macro on 2018 global edition\n                         module = Some(ModuleOrUniformRoot::CrateRootAndExternPrelude);\n@@ -1494,7 +1496,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         record_segment_res(self, res);\n                     } else if res == Res::ToolMod && i + 1 != path.len() {\n                         if binding.is_import() {\n-                            self.session\n+                            self.tcx\n+                                .sess\n                                 .struct_span_err(\n                                     ident.span,\n                                     \"cannot use a tool module through an import\","}, {"sha": "449d8094bd60a168042f3465137b3bb8001ef2aa", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -21,8 +21,8 @@ use rustc_middle::span_bug;\n use rustc_middle::ty;\n use rustc_session::lint::builtin::{PUB_USE_OF_PRIVATE_EXTERN_CRATE, UNUSED_IMPORTS};\n use rustc_session::lint::BuiltinLintDiagnostics;\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::hygiene::LocalExpnId;\n-use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::Span;\n \n@@ -526,7 +526,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n             .collect::<Vec<_>>();\n         let msg = format!(\"unresolved import{} {}\", pluralize!(paths.len()), paths.join(\", \"),);\n \n-        let mut diag = struct_span_err!(self.r.session, span, E0432, \"{}\", &msg);\n+        let mut diag = struct_span_err!(self.r.tcx.sess, span, E0432, \"{}\", &msg);\n \n         if let Some((_, UnresolvedImportError { note: Some(note), .. })) = errors.iter().last() {\n             diag.note(note);\n@@ -548,8 +548,8 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n             if let Some(candidates) = &err.candidates {\n                 match &import.kind {\n                     ImportKind::Single { nested: false, source, target, .. } => import_candidates(\n-                        self.r.session,\n-                        &self.r.untracked.source_span,\n+                        self.r.tcx.sess,\n+                        &self.r.tcx.untracked().source_span.read(),\n                         &mut diag,\n                         Some(err.span),\n                         &candidates,\n@@ -561,8 +561,8 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                     ),\n                     ImportKind::Single { nested: true, source, target, .. } => {\n                         import_candidates(\n-                            self.r.session,\n-                            &self.r.untracked.source_span,\n+                            self.r.tcx.sess,\n+                            &self.r.tcx.untracked().source_span.read(),\n                             &mut diag,\n                             None,\n                             &candidates,\n@@ -658,7 +658,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                     source_binding @ (Ok(..) | Err(Determined)) => {\n                         if source_binding.is_ok() {\n                             let msg = format!(\"`{}` is not directly importable\", target);\n-                            struct_span_err!(this.session, import.span, E0253, \"{}\", &msg)\n+                            struct_span_err!(this.tcx.sess, import.span, E0253, \"{}\", &msg)\n                                 .span_label(import.span, \"cannot be imported directly\")\n                                 .emit();\n                         }\n@@ -706,7 +706,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                 } else if self.r.privacy_errors.is_empty() {\n                     let msg = \"cannot determine resolution for the import\";\n                     let msg_note = \"import resolution is stuck, try simplifying other imports\";\n-                    self.r.session.struct_span_err(import.span, msg).note(msg_note).emit();\n+                    self.r.tcx.sess.struct_span_err(import.span, msg).note(msg_note).emit();\n                 }\n \n                 module\n@@ -859,7 +859,7 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                             let msg = \"cannot determine resolution for the import\";\n                             let msg_note =\n                                 \"import resolution is stuck, try simplifying other imports\";\n-                            this.session.struct_span_err(import.span, msg).note(msg_note).emit();\n+                            this.tcx.sess.struct_span_err(import.span, msg).note(msg_note).emit();\n                         }\n                     }\n                     Err(..) => {\n@@ -1035,13 +1035,13 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n                         format!(\"re-export of private `{}`\", ident)\n                     };\n \n-                    struct_span_err!(self.r.session, import.span, E0365, \"{}\", error_msg)\n+                    struct_span_err!(self.r.tcx.sess, import.span, E0365, \"{}\", error_msg)\n                         .span_label(import.span, label_msg)\n                         .note(&format!(\"consider declaring type or module `{}` with `pub`\", ident))\n                         .emit();\n                 } else {\n                     let mut err =\n-                        struct_span_err!(self.r.session, import.span, E0364, \"{error_msg}\");\n+                        struct_span_err!(self.r.tcx.sess, import.span, E0364, \"{error_msg}\");\n                     match binding.kind {\n                         NameBindingKind::Res(Res::Def(DefKind::Macro(_), def_id))\n                             // exclude decl_macro\n@@ -1164,12 +1164,12 @@ impl<'a, 'b, 'tcx> ImportResolver<'a, 'b, 'tcx> {\n         let ImportKind::Glob { id, is_prelude, .. } = import.kind else { unreachable!() };\n \n         let ModuleOrUniformRoot::Module(module) = import.imported_module.get().unwrap() else {\n-            self.r.session.span_err(import.span, \"cannot glob-import all possible crates\");\n+            self.r.tcx.sess.span_err(import.span, \"cannot glob-import all possible crates\");\n             return;\n         };\n \n         if module.is_trait() {\n-            self.r.session.span_err(import.span, \"items in traits are not importable\");\n+            self.r.tcx.sess.span_err(import.span, \"items in traits are not importable\");\n             return;\n         } else if ptr::eq(module, import.parent_scope.module) {\n             return;"}, {"sha": "7df17376b3eaeb13a558e6c0d2a66ba2a340d22b", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -682,7 +682,7 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n                 // Elided lifetime in reference: we resolve as if there was some lifetime `'_` with\n                 // NodeId `ty.id`.\n                 // This span will be used in case of elision failure.\n-                let span = self.r.session.source_map().start_point(ty.span);\n+                let span = self.r.tcx.sess.source_map().start_point(ty.span);\n                 self.resolve_elided_lifetime(ty.id, span);\n                 visit::walk_ty(self, ty);\n             }\n@@ -1571,7 +1571,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                         (\"`'_` cannot be used here\", \"`'_` is a reserved lifetime name\")\n                     };\n                     let mut diag = rustc_errors::struct_span_err!(\n-                        self.r.session,\n+                        self.r.tcx.sess,\n                         lifetime.ident.span,\n                         E0637,\n                         \"{}\",\n@@ -1748,7 +1748,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                     //     impl Foo for std::cell::Ref<u32> // note lack of '_\n                     //     async fn foo(_: std::cell::Ref<u32>) { ... }\n                     LifetimeRibKind::AnonymousCreateParameter { report_in_path: true, .. } => {\n-                        let sess = self.r.session;\n+                        let sess = self.r.tcx.sess;\n                         let mut err = rustc_errors::struct_span_err!(\n                             sess,\n                             path_span,\n@@ -2194,7 +2194,8 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                 let what = if ns == TypeNS { \"type parameters\" } else { \"local variables\" };\n                 if this.should_report_errs() {\n                     this.r\n-                        .session\n+                        .tcx\n+                        .sess\n                         .span_err(ident.span, &format!(\"imports cannot refer to {}\", what));\n                 }\n             };\n@@ -2438,7 +2439,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n             if let GenericParamKind::Lifetime = param.kind\n                 && let Some(&original) = seen_lifetimes.get(&ident)\n             {\n-                diagnostics::signal_lifetime_shadowing(self.r.session, original, param.ident);\n+                diagnostics::signal_lifetime_shadowing(self.r.tcx.sess, original, param.ident);\n                 // Record lifetime res, so lowering knows there is something fishy.\n                 self.record_lifetime_param(param.id, LifetimeRes::Error);\n                 continue;\n@@ -2462,7 +2463,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n \n             if param.ident.name == kw::UnderscoreLifetime {\n                 rustc_errors::struct_span_err!(\n-                    self.r.session,\n+                    self.r.tcx.sess,\n                     param.ident.span,\n                     E0637,\n                     \"`'_` cannot be used here\"\n@@ -2476,7 +2477,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n \n             if param.ident.name == kw::StaticLifetime {\n                 rustc_errors::struct_span_err!(\n-                    self.r.session,\n+                    self.r.tcx.sess,\n                     param.ident.span,\n                     E0262,\n                     \"invalid lifetime parameter name: `{}`\",\n@@ -2506,7 +2507,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n             let res = match kind {\n                 ItemRibKind(..) | AssocItemRibKind => Res::Def(def_kind, def_id.to_def_id()),\n                 NormalRibKind => {\n-                    if self.r.session.features_untracked().non_lifetime_binders {\n+                    if self.r.tcx.sess.features_untracked().non_lifetime_binders {\n                         Res::Def(def_kind, def_id.to_def_id())\n                     } else {\n                         Res::Err\n@@ -3384,7 +3385,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n             Res::SelfCtor(_) => {\n                 // We resolve `Self` in pattern position as an ident sometimes during recovery,\n                 // so delay a bug instead of ICEing.\n-                self.r.session.delay_span_bug(\n+                self.r.tcx.sess.delay_span_bug(\n                     ident.span,\n                     \"unexpected `SelfCtor` in pattern, expected identifier\"\n                 );\n@@ -3664,7 +3665,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n     #[inline]\n     /// If we're actually rustdoc then avoid giving a name resolution error for `cfg()` items.\n     fn should_report_errs(&self) -> bool {\n-        !(self.r.session.opts.actually_rustdoc && self.in_func_body)\n+        !(self.r.tcx.sess.opts.actually_rustdoc && self.in_func_body)\n     }\n \n     // Resolve in alternative namespaces if resolution in the primary namespace fails.\n@@ -3829,7 +3830,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n             }\n \n             if let Ok((_, orig_span)) = self.resolve_label(label.ident) {\n-                diagnostics::signal_label_shadowing(self.r.session, orig_span, label.ident)\n+                diagnostics::signal_label_shadowing(self.r.tcx.sess, orig_span, label.ident)\n             }\n \n             self.with_label_rib(NormalRibKind, |this| {\n@@ -4135,9 +4136,9 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n     fn record_candidate_traits_for_expr_if_necessary(&mut self, expr: &'ast Expr) {\n         match expr.kind {\n             ExprKind::Field(_, ident) => {\n-                // FIXME(#6890): Even though you can't treat a method like a\n-                // field, we need to add any trait methods we find that match\n-                // the field name so that we can do some nice error reporting\n+                // #6890: Even though you can't treat a method like a field,\n+                // we need to add any trait methods we find that match the\n+                // field name so that we can do some nice error reporting\n                 // later on in typeck.\n                 let traits = self.traits_in_scope(ident, ValueNS);\n                 self.r.trait_map.insert(expr.id, traits);\n@@ -4211,8 +4212,8 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                 if let Some(res) = res\n                     && let Some(def_id) = res.opt_def_id()\n                     && !def_id.is_local()\n-                    && self.r.session.crate_types().contains(&CrateType::ProcMacro)\n-                    && matches!(self.r.session.opts.resolve_doc_links, ResolveDocLinks::ExportedMetadata) {\n+                    && self.r.tcx.sess.crate_types().contains(&CrateType::ProcMacro)\n+                    && matches!(self.r.tcx.sess.opts.resolve_doc_links, ResolveDocLinks::ExportedMetadata) {\n                     // Encoding foreign def ids in proc macro crate metadata will ICE.\n                     return None;\n                 }\n@@ -4224,10 +4225,10 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n     }\n \n     fn resolve_doc_links(&mut self, attrs: &[Attribute], maybe_exported: MaybeExported<'_>) {\n-        match self.r.session.opts.resolve_doc_links {\n+        match self.r.tcx.sess.opts.resolve_doc_links {\n             ResolveDocLinks::None => return,\n             ResolveDocLinks::ExportedMetadata\n-                if !self.r.session.crate_types().iter().copied().any(CrateType::has_metadata)\n+                if !self.r.tcx.sess.crate_types().iter().copied().any(CrateType::has_metadata)\n                     || !maybe_exported.eval(self.r) =>\n             {\n                 return;\n@@ -4281,9 +4282,9 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                         .into_iter()\n                         .filter_map(|tr| {\n                             if !tr.def_id.is_local()\n-                                && self.r.session.crate_types().contains(&CrateType::ProcMacro)\n+                                && self.r.tcx.sess.crate_types().contains(&CrateType::ProcMacro)\n                                 && matches!(\n-                                    self.r.session.opts.resolve_doc_links,\n+                                    self.r.tcx.sess.opts.resolve_doc_links,\n                                     ResolveDocLinks::ExportedMetadata\n                                 )\n                             {"}, {"sha": "36415936bdc6512820503cd2e9acdfe2a297b56b", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 44, "deletions": 33, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -25,9 +25,9 @@ use rustc_middle::ty::DefIdTree;\n use rustc_session::lint;\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n+use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::MacroKind;\n-use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, Span};\n \n@@ -170,7 +170,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n     fn def_span(&self, def_id: DefId) -> Option<Span> {\n         match def_id.krate {\n             LOCAL_CRATE => self.r.opt_span(def_id),\n-            _ => Some(self.r.cstore().get_span_untracked(def_id, self.r.session)),\n+            _ => Some(self.r.cstore().get_span_untracked(def_id, self.r.tcx.sess)),\n         }\n     }\n \n@@ -200,7 +200,8 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                     Res::Def(DefKind::Fn, _) => {\n                         // Verify whether this is a fn call or an Fn used as a type.\n                         self.r\n-                            .session\n+                            .tcx\n+                            .sess\n                             .source_map()\n                             .span_to_snippet(span)\n                             .map(|snippet| snippet.ends_with(')'))\n@@ -255,7 +256,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 };\n                 (String::new(), \"this scope\".to_string(), suggestion)\n             } else if path.len() == 2 && path[0].ident.name == kw::PathRoot {\n-                if self.r.session.edition() > Edition::Edition2015 {\n+                if self.r.tcx.sess.edition() > Edition::Edition2015 {\n                     // In edition 2018 onwards, the `::foo` syntax may only pull from the extern prelude\n                     // which overrides all other expectations of item type\n                     expected = \"crate\";\n@@ -323,7 +324,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         let base_error = self.make_base_error(path, span, source, res);\n         let code = source.error_code(res.is_some());\n         let mut err =\n-            self.r.session.struct_span_err_with_code(base_error.span, &base_error.msg, code);\n+            self.r.tcx.sess.struct_span_err_with_code(base_error.span, &base_error.msg, code);\n \n         self.suggest_swapping_misplaced_self_ty_and_trait(&mut err, source, res, base_error.span);\n \n@@ -432,7 +433,8 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                     } else {\n                         (\n                             self.r\n-                                .session\n+                                .tcx\n+                                .sess\n                                 .source_map()\n                                 .span_through_char(*fn_span, '(')\n                                 .shrink_to_hi(),\n@@ -505,7 +507,8 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 {\n                     if self\n                         .r\n-                        .session\n+                        .tcx\n+                        .sess\n                         .parse_sess\n                         .type_ascription_path_suggestions\n                         .borrow()\n@@ -542,7 +545,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             }\n         }\n \n-        // Try Levenshtein algorithm.\n+        // Try finding a suitable replacement.\n         let typo_sugg =\n             self.lookup_typo_candidate(path, source.namespace(), is_expected).to_opt_suggestion();\n         if path.len() == 1 && self.self_type_is_available() {\n@@ -596,7 +599,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             if let Some((call_span, args_span)) = self.call_has_self_arg(source) {\n                 let mut args_snippet = String::new();\n                 if let Some(args_span) = args_span {\n-                    if let Ok(snippet) = self.r.session.source_map().span_to_snippet(args_span) {\n+                    if let Ok(snippet) = self.r.tcx.sess.source_map().span_to_snippet(args_span) {\n                         args_snippet = snippet;\n                     }\n                 }\n@@ -732,7 +735,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n         let typo_sugg = self.lookup_typo_candidate(path, source.namespace(), is_expected);\n         let is_in_same_file = &|sp1, sp2| {\n-            let source_map = self.r.session.source_map();\n+            let source_map = self.r.tcx.sess.source_map();\n             let file1 = source_map.span_to_filename(sp1);\n             let file2 = source_map.span_to_filename(sp2);\n             file1 == file2\n@@ -770,7 +773,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 _ => {}\n             }\n \n-            // If the trait has a single item (which wasn't matched by Levenshtein), suggest it\n+            // If the trait has a single item (which wasn't matched by the algorithm), suggest it\n             let suggestion = self.get_single_associated_item(&path, &source, is_expected);\n             if !self.r.add_typo_suggestion(err, suggestion, ident_span) {\n                 fallback = !self.let_binding_suggestion(err, ident_span);\n@@ -895,7 +898,8 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                                 .map_or(*span, |ident| span.with_lo(ident.span.hi()));\n                             (\n                                 self.r\n-                                    .session\n+                                    .tcx\n+                                    .sess\n                                     .source_map()\n                                     .span_through_char(span, '(')\n                                     .shrink_to_hi(),\n@@ -949,9 +953,9 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             && let PathSource::Trait(_) = source\n             && let Some(Res::Def(DefKind::Struct | DefKind::Enum | DefKind::Union, _)) = res\n             && let Ok(self_ty_str) =\n-                self.r.session.source_map().span_to_snippet(self_ty.span)\n+                self.r.tcx.sess.source_map().span_to_snippet(self_ty.span)\n             && let Ok(trait_ref_str) =\n-                self.r.session.source_map().span_to_snippet(trait_ref.path.span)\n+                self.r.tcx.sess.source_map().span_to_snippet(trait_ref.path.span)\n         {\n                 err.multipart_suggestion(\n                     \"`impl` items mention the trait being implemented first and the type it is being implemented for second\",\n@@ -1095,7 +1099,8 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                             format!(\n                                 \"{}: {}<{} = {}>\",\n                                 self.r\n-                                    .session\n+                                    .tcx\n+                                    .sess\n                                     .source_map()\n                                     .span_to_snippet(ty.span) // Account for `<&'a T as Foo>::Bar`.\n                                     .unwrap_or_else(|_| constrain_ident.to_string()),\n@@ -1164,7 +1169,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         // parser issue where a struct literal is being used on an expression\n         // where a brace being opened means a block is being started. Look\n         // ahead for the next text to see if `span` is followed by a `{`.\n-        let sm = self.r.session.source_map();\n+        let sm = self.r.tcx.sess.source_map();\n         let sp = sm.span_look_ahead(span, None, Some(50));\n         let followed_by_brace = matches!(sm.span_to_snippet(sp), Ok(ref snippet) if snippet == \"{\");\n         // In case this could be a struct literal that needs to be surrounded\n@@ -1212,7 +1217,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 true\n             } else if kind == DefKind::Struct\n             && let Some(lhs_source_span) = lhs_span.find_ancestor_inside(expr.span)\n-            && let Ok(snippet) = self.r.session.source_map().span_to_snippet(lhs_source_span)\n+            && let Ok(snippet) = self.r.tcx.sess.source_map().span_to_snippet(lhs_source_span)\n             {\n                 // The LHS is a type that originates from a macro call.\n                 // We have to add angle brackets around it.\n@@ -1352,11 +1357,11 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             }\n             (Res::Def(DefKind::TyAlias, def_id), PathSource::Trait(_)) => {\n                 err.span_label(span, \"type aliases cannot be used as traits\");\n-                if self.r.session.is_nightly_build() {\n+                if self.r.tcx.sess.is_nightly_build() {\n                     let msg = \"you might have meant to use `#![feature(trait_alias)]` instead of a \\\n                                `type` alias\";\n                     if let Some(span) = self.def_span(def_id) {\n-                        if let Ok(snip) = self.r.session.source_map().span_to_snippet(span) {\n+                        if let Ok(snip) = self.r.tcx.sess.source_map().span_to_snippet(span) {\n                             // The span contains a type alias so we should be able to\n                             // replace `type` with `trait`.\n                             let snip = snip.replacen(\"type\", \"trait\", 1);\n@@ -1387,7 +1392,8 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                     .last()\n                     .map(|sp| {\n                         self.r\n-                            .session\n+                            .tcx\n+                            .sess\n                             .parse_sess\n                             .type_ascription_path_suggestions\n                             .borrow()\n@@ -1694,8 +1700,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                             let extern_prelude = self.r.extern_prelude.clone();\n                             names.extend(extern_prelude.iter().flat_map(|(ident, _)| {\n                                 self.r\n-                                    .crate_loader()\n-                                    .maybe_process_path_extern(ident.name)\n+                                    .crate_loader(|c| c.maybe_process_path_extern(ident.name))\n                                     .and_then(|crate_id| {\n                                         let crate_mod =\n                                             Res::Def(DefKind::Mod, crate_id.as_def_id());\n@@ -1774,12 +1779,12 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n \n     /// Only used in a specific case of type ascription suggestions\n     fn get_colon_suggestion_span(&self, start: Span) -> Span {\n-        let sm = self.r.session.source_map();\n+        let sm = self.r.tcx.sess.source_map();\n         start.to(sm.next_point(start))\n     }\n \n     fn type_ascription_suggestion(&self, err: &mut Diagnostic, base_span: Span) -> bool {\n-        let sm = self.r.session.source_map();\n+        let sm = self.r.tcx.sess.source_map();\n         let base_snippet = sm.span_to_snippet(base_span);\n         if let Some(&sp) = self.diagnostic_metadata.current_type_ascription.last() {\n             if let Ok(snippet) = sm.span_to_snippet(sp) {\n@@ -1809,7 +1814,8 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                             show_label = false;\n                             if !self\n                                 .r\n-                                .session\n+                                .tcx\n+                                .sess\n                                 .parse_sess\n                                 .type_ascription_path_suggestions\n                                 .borrow_mut()\n@@ -2272,7 +2278,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         debug_assert_ne!(lifetime_ref.ident.name, kw::UnderscoreLifetime);\n         let mut err = if let Some(outer) = outer_lifetime_ref {\n             let mut err = struct_span_err!(\n-                self.r.session,\n+                self.r.tcx.sess,\n                 lifetime_ref.ident.span,\n                 E0401,\n                 \"can't use generic parameters from outer item\",\n@@ -2282,7 +2288,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             err\n         } else {\n             let mut err = struct_span_err!(\n-                self.r.session,\n+                self.r.tcx.sess,\n                 lifetime_ref.ident.span,\n                 E0261,\n                 \"use of undeclared lifetime name `{}`\",\n@@ -2340,8 +2346,13 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                         );\n                         (span, sugg)\n                     } else {\n-                        let span =\n-                            self.r.session.source_map().span_through_char(span, '<').shrink_to_hi();\n+                        let span = self\n+                            .r\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .span_through_char(span, '<')\n+                            .shrink_to_hi();\n                         let sugg = format!(\"{}, \", name.unwrap_or(\"'a\"));\n                         (span, sugg)\n                     };\n@@ -2375,7 +2386,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n \n     pub(crate) fn emit_non_static_lt_in_const_generic_error(&self, lifetime_ref: &ast::Lifetime) {\n         struct_span_err!(\n-            self.r.session,\n+            self.r.tcx.sess,\n             lifetime_ref.ident.span,\n             E0771,\n             \"use of non-static lifetime `{}` in const generic\",\n@@ -2395,10 +2406,10 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         &self,\n         lifetime_ref: &ast::Lifetime,\n     ) {\n-        let feature_active = self.r.session.features_untracked().generic_const_exprs;\n+        let feature_active = self.r.tcx.sess.features_untracked().generic_const_exprs;\n         if !feature_active {\n             feature_err(\n-                &self.r.session.parse_sess,\n+                &self.r.tcx.sess.parse_sess,\n                 sym::generic_const_exprs,\n                 lifetime_ref.ident.span,\n                 \"a non-static lifetime is not allowed in a `const`\",\n@@ -2416,7 +2427,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         let spans: Vec<_> = lifetime_refs.iter().map(|lt| lt.span).collect();\n \n         let mut err = struct_span_err!(\n-            self.r.session,\n+            self.r.tcx.sess,\n             spans,\n             E0106,\n             \"missing lifetime specifier{}\","}, {"sha": "66034baaa0b6b7a89b4ab2ad02b591763ca11291", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 56, "deletions": 85, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -27,26 +27,25 @@ use rustc_ast::{self as ast, NodeId, CRATE_NODE_ID};\n use rustc_ast::{AngleBracketedArg, Crate, Expr, ExprKind, GenericArg, GenericArgs, LitKind, Path};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_data_structures::intern::Interned;\n-use rustc_data_structures::sync::{Lrc, RwLock};\n+use rustc_data_structures::sync::{Lrc, MappedReadGuard};\n use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_expand::base::{DeriveResolutions, SyntaxExtension, SyntaxExtensionKind};\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorOf, DefKind, DocLinkResMap, LifetimeRes, PartialRes, PerNS};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId};\n use rustc_hir::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n-use rustc_hir::definitions::{DefPathData, Definitions};\n+use rustc_hir::definitions::DefPathData;\n use rustc_hir::TraitCandidate;\n use rustc_index::vec::IndexVec;\n use rustc_metadata::creader::{CStore, CrateLoader};\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::privacy::EffectiveVisibilities;\n use rustc_middle::span_bug;\n-use rustc_middle::ty::{self, DefIdTree, MainDefinition, RegisteredTools};\n+use rustc_middle::ty::{self, DefIdTree, MainDefinition, RegisteredTools, TyCtxt};\n use rustc_middle::ty::{ResolverGlobalCtxt, ResolverOutputs};\n use rustc_query_system::ich::StableHashingContext;\n-use rustc_session::cstore::{CrateStore, MetadataLoaderDyn, Untracked};\n+use rustc_session::cstore::CrateStore;\n use rustc_session::lint::LintBuffer;\n-use rustc_session::Session;\n use rustc_span::hygiene::{ExpnId, LocalExpnId, MacroKind, SyntaxContext, Transparency};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -865,7 +864,7 @@ struct MacroData {\n ///\n /// This is the visitor that walks the whole crate.\n pub struct Resolver<'a, 'tcx> {\n-    session: &'tcx Session,\n+    tcx: TyCtxt<'tcx>,\n \n     /// Item with a given `LocalDefId` was defined during macro expansion with ID `ExpnId`.\n     expn_that_defined: FxHashMap<LocalDefId, ExpnId>,\n@@ -956,9 +955,6 @@ pub struct Resolver<'a, 'tcx> {\n     arenas: &'a ResolverArenas<'a>,\n     dummy_binding: &'a NameBinding<'a>,\n \n-    local_crate_name: Symbol,\n-    metadata_loader: Box<MetadataLoaderDyn>,\n-    untracked: Untracked,\n     used_extern_options: FxHashSet<Symbol>,\n     macro_names: FxHashSet<Ident>,\n     builtin_macros: FxHashMap<Symbol, BuiltinMacroState>,\n@@ -1117,27 +1113,10 @@ impl<'a, 'tcx> AsMut<Resolver<'a, 'tcx>> for Resolver<'a, 'tcx> {\n     }\n }\n \n-/// A minimal subset of resolver that can implemenent `DefIdTree`, sometimes\n-/// required to satisfy borrow checker by avoiding borrowing the whole resolver.\n-#[derive(Clone, Copy)]\n-struct ResolverTree<'a>(&'a Untracked);\n-\n-impl DefIdTree for ResolverTree<'_> {\n-    #[inline]\n-    fn opt_parent(self, id: DefId) -> Option<DefId> {\n-        let ResolverTree(Untracked { definitions, cstore, .. }) = self;\n-        match id.as_local() {\n-            Some(id) => definitions.read().def_key(id).parent,\n-            None => cstore.as_any().downcast_ref::<CStore>().unwrap().def_key(id).parent,\n-        }\n-        .map(|index| DefId { index, ..id })\n-    }\n-}\n-\n impl<'a, 'b, 'tcx> DefIdTree for &'a Resolver<'b, 'tcx> {\n     #[inline]\n     fn opt_parent(self, id: DefId) -> Option<DefId> {\n-        ResolverTree(&self.untracked).opt_parent(id)\n+        self.tcx.opt_parent(id)\n     }\n }\n \n@@ -1164,10 +1143,11 @@ impl<'tcx> Resolver<'_, 'tcx> {\n             \"adding a def'n for node-id {:?} and data {:?} but a previous def'n exists: {:?}\",\n             node_id,\n             data,\n-            self.untracked.definitions.read().def_key(self.node_id_to_def_id[&node_id]),\n+            self.tcx.definitions_untracked().def_key(self.node_id_to_def_id[&node_id]),\n         );\n \n-        let def_id = self.untracked.definitions.write().create_def(parent, data);\n+        // FIXME: remove `def_span` body, pass in the right spans here and call `tcx.at().create_def()`\n+        let def_id = self.tcx.untracked().definitions.write().create_def(parent, data);\n \n         // Create the definition.\n         if expn_id != ExpnId::root() {\n@@ -1176,7 +1156,7 @@ impl<'tcx> Resolver<'_, 'tcx> {\n \n         // A relative span's parent must be an absolute span.\n         debug_assert_eq!(span.data_untracked().parent, None);\n-        let _id = self.untracked.source_span.push(span);\n+        let _id = self.tcx.untracked().source_span.write().push(span);\n         debug_assert_eq!(_id, def_id);\n \n         // Some things for which we allocate `LocalDefId`s don't correspond to\n@@ -1195,17 +1175,19 @@ impl<'tcx> Resolver<'_, 'tcx> {\n         if let Some(def_id) = def_id.as_local() {\n             self.item_generics_num_lifetimes[&def_id]\n         } else {\n-            self.cstore().item_generics_num_lifetimes(def_id, self.session)\n+            self.cstore().item_generics_num_lifetimes(def_id, self.tcx.sess)\n         }\n     }\n+\n+    pub fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n }\n \n impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     pub fn new(\n-        session: &'tcx Session,\n+        tcx: TyCtxt<'tcx>,\n         krate: &Crate,\n-        crate_name: Symbol,\n-        metadata_loader: Box<MetadataLoaderDyn>,\n         arenas: &'a ResolverArenas<'a>,\n     ) -> Resolver<'a, 'tcx> {\n         let root_def_id = CRATE_DEF_ID.to_def_id();\n@@ -1215,7 +1197,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             ModuleKind::Def(DefKind::Mod, root_def_id, kw::Empty),\n             ExpnId::root(),\n             krate.spans.inner_span,\n-            session.contains_name(&krate.attrs, sym::no_implicit_prelude),\n+            tcx.sess.contains_name(&krate.attrs, sym::no_implicit_prelude),\n             &mut module_map,\n         );\n         let empty_module = arenas.new_module(\n@@ -1227,8 +1209,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             &mut FxHashMap::default(),\n         );\n \n-        let definitions = Definitions::new(session.local_stable_crate_id());\n-\n         let mut visibilities = FxHashMap::default();\n         visibilities.insert(CRATE_DEF_ID, ty::Visibility::Public);\n \n@@ -1240,31 +1220,28 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mut invocation_parents = FxHashMap::default();\n         invocation_parents.insert(LocalExpnId::ROOT, (CRATE_DEF_ID, ImplTraitContext::Existential));\n \n-        let mut source_span = IndexVec::default();\n-        let _id = source_span.push(krate.spans.inner_span);\n-        debug_assert_eq!(_id, CRATE_DEF_ID);\n-\n-        let mut extern_prelude: FxHashMap<Ident, ExternPreludeEntry<'_>> = session\n+        let mut extern_prelude: FxHashMap<Ident, ExternPreludeEntry<'_>> = tcx\n+            .sess\n             .opts\n             .externs\n             .iter()\n             .filter(|(_, entry)| entry.add_prelude)\n             .map(|(name, _)| (Ident::from_str(name), Default::default()))\n             .collect();\n \n-        if !session.contains_name(&krate.attrs, sym::no_core) {\n+        if !tcx.sess.contains_name(&krate.attrs, sym::no_core) {\n             extern_prelude.insert(Ident::with_dummy_span(sym::core), Default::default());\n-            if !session.contains_name(&krate.attrs, sym::no_std) {\n+            if !tcx.sess.contains_name(&krate.attrs, sym::no_std) {\n                 extern_prelude.insert(Ident::with_dummy_span(sym::std), Default::default());\n             }\n         }\n \n-        let registered_tools = macros::registered_tools(session, &krate.attrs);\n+        let registered_tools = macros::registered_tools(tcx.sess, &krate.attrs);\n \n-        let features = session.features_untracked();\n+        let features = tcx.sess.features_untracked();\n \n         let mut resolver = Resolver {\n-            session,\n+            tcx,\n \n             expn_that_defined: Default::default(),\n \n@@ -1318,23 +1295,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 vis: ty::Visibility::Public,\n             }),\n \n-            metadata_loader,\n-            local_crate_name: crate_name,\n             used_extern_options: Default::default(),\n-            untracked: Untracked {\n-                cstore: Box::new(CStore::new(session)),\n-                source_span,\n-                definitions: RwLock::new(definitions),\n-            },\n             macro_names: FxHashSet::default(),\n             builtin_macros: Default::default(),\n             builtin_macro_kinds: Default::default(),\n             registered_tools,\n             macro_use_prelude: FxHashMap::default(),\n             macro_map: FxHashMap::default(),\n-            dummy_ext_bang: Lrc::new(SyntaxExtension::dummy_bang(session.edition())),\n-            dummy_ext_derive: Lrc::new(SyntaxExtension::dummy_derive(session.edition())),\n-            non_macro_attr: Lrc::new(SyntaxExtension::non_macro_attr(session.edition())),\n+            dummy_ext_bang: Lrc::new(SyntaxExtension::dummy_bang(tcx.sess.edition())),\n+            dummy_ext_derive: Lrc::new(SyntaxExtension::dummy_derive(tcx.sess.edition())),\n+            non_macro_attr: Lrc::new(SyntaxExtension::non_macro_attr(tcx.sess.edition())),\n             invocation_parent_scopes: Default::default(),\n             output_macro_rules_scopes: Default::default(),\n             macro_rules_scopes: Default::default(),\n@@ -1430,7 +1400,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let main_def = self.main_def;\n         let confused_type_with_std_module = self.confused_type_with_std_module;\n         let effective_visibilities = self.effective_visibilities;\n-        let untracked = self.untracked;\n         let global_ctxt = ResolverGlobalCtxt {\n             expn_that_defined,\n             visibilities,\n@@ -1469,26 +1438,21 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             builtin_macro_kinds: self.builtin_macro_kinds,\n             lifetime_elision_allowed: self.lifetime_elision_allowed,\n         };\n-        ResolverOutputs { global_ctxt, ast_lowering, untracked }\n+        ResolverOutputs { global_ctxt, ast_lowering }\n     }\n \n     fn create_stable_hashing_context(&self) -> StableHashingContext<'_> {\n-        StableHashingContext::new(self.session, &self.untracked)\n+        StableHashingContext::new(self.tcx.sess, self.tcx.untracked())\n     }\n \n-    fn crate_loader(&mut self) -> CrateLoader<'_> {\n-        CrateLoader::new(\n-            &self.session,\n-            &*self.metadata_loader,\n-            self.local_crate_name,\n-            &mut *self.untracked.cstore.untracked_as_any().downcast_mut().unwrap(),\n-            self.untracked.definitions.read(),\n-            &mut self.used_extern_options,\n-        )\n+    fn crate_loader<T>(&mut self, f: impl FnOnce(&mut CrateLoader<'_, '_>) -> T) -> T {\n+        let mut cstore = self.tcx.untracked().cstore.write();\n+        let cstore = cstore.untracked_as_any().downcast_mut().unwrap();\n+        f(&mut CrateLoader::new(self.tcx, &mut *cstore, &mut self.used_extern_options))\n     }\n \n-    fn cstore(&self) -> &CStore {\n-        self.untracked.cstore.as_any().downcast_ref().unwrap()\n+    fn cstore(&self) -> MappedReadGuard<'_, CStore> {\n+        CStore::from_tcx(self.tcx)\n     }\n \n     fn dummy_ext(&self, macro_kind: MacroKind) -> Lrc<SyntaxExtension> {\n@@ -1521,18 +1485,25 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n-        self.session.time(\"resolve_crate\", || {\n-            self.session.time(\"finalize_imports\", || ImportResolver { r: self }.finalize_imports());\n-            self.session.time(\"compute_effective_visibilities\", || {\n+        self.tcx.sess.time(\"resolve_crate\", || {\n+            self.tcx\n+                .sess\n+                .time(\"finalize_imports\", || ImportResolver { r: self }.finalize_imports());\n+            self.tcx.sess.time(\"compute_effective_visibilities\", || {\n                 EffectiveVisibilitiesVisitor::compute_effective_visibilities(self, krate)\n             });\n-            self.session.time(\"finalize_macro_resolutions\", || self.finalize_macro_resolutions());\n-            self.session.time(\"late_resolve_crate\", || self.late_resolve_crate(krate));\n-            self.session.time(\"resolve_main\", || self.resolve_main());\n-            self.session.time(\"resolve_check_unused\", || self.check_unused(krate));\n-            self.session.time(\"resolve_report_errors\", || self.report_errors(krate));\n-            self.session.time(\"resolve_postprocess\", || self.crate_loader().postprocess(krate));\n+            self.tcx.sess.time(\"finalize_macro_resolutions\", || self.finalize_macro_resolutions());\n+            self.tcx.sess.time(\"late_resolve_crate\", || self.late_resolve_crate(krate));\n+            self.tcx.sess.time(\"resolve_main\", || self.resolve_main());\n+            self.tcx.sess.time(\"resolve_check_unused\", || self.check_unused(krate));\n+            self.tcx.sess.time(\"resolve_report_errors\", || self.report_errors(krate));\n+            self.tcx\n+                .sess\n+                .time(\"resolve_postprocess\", || self.crate_loader(|c| c.postprocess(krate)));\n         });\n+\n+        // Make sure we don't mutate the cstore from here on.\n+        self.tcx.untracked().cstore.leak();\n     }\n \n     fn traits_in_scope(\n@@ -1871,10 +1842,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             } else {\n                 let crate_id = if finalize {\n                     let Some(crate_id) =\n-                        self.crate_loader().process_path_extern(ident.name, ident.span) else { return Some(self.dummy_binding); };\n+                        self.crate_loader(|c| c.process_path_extern(ident.name, ident.span)) else { return Some(self.dummy_binding); };\n                     crate_id\n                 } else {\n-                    self.crate_loader().maybe_process_path_extern(ident.name)?\n+                    self.crate_loader(|c| c.maybe_process_path_extern(ident.name))?\n                 };\n                 let crate_root = self.expect_module(crate_id.as_def_id());\n                 let vis = ty::Visibility::<LocalDefId>::Public;\n@@ -1922,14 +1893,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// Retrieves the span of the given `DefId` if `DefId` is in the local crate.\n     #[inline]\n     fn opt_span(&self, def_id: DefId) -> Option<Span> {\n-        def_id.as_local().map(|def_id| self.untracked.source_span[def_id])\n+        def_id.as_local().map(|def_id| self.tcx.source_span(def_id))\n     }\n \n     /// Retrieves the name of the given `DefId`.\n     #[inline]\n     fn opt_name(&self, def_id: DefId) -> Option<Symbol> {\n         let def_key = match def_id.as_local() {\n-            Some(def_id) => self.untracked.definitions.read().def_key(def_id),\n+            Some(def_id) => self.tcx.definitions_untracked().def_key(def_id),\n             None => self.cstore().def_key(def_id),\n         };\n         def_key.get_opt_name()\n@@ -1961,7 +1932,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 let attr = self\n                     .cstore()\n-                    .item_attrs_untracked(def_id, self.session)\n+                    .item_attrs_untracked(def_id, self.tcx.sess)\n                     .find(|a| a.has_name(sym::rustc_legacy_const_generics))?;\n                 let mut ret = Vec::new();\n                 for meta in attr.meta_item_list()? {"}, {"sha": "341db774b4d3919a98979b2bda028d0742a94506", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -195,7 +195,8 @@ impl<'a, 'tcx> ResolverExpand for Resolver<'a, 'tcx> {\n \n     fn register_builtin_macro(&mut self, name: Symbol, ext: SyntaxExtensionKind) {\n         if self.builtin_macros.insert(name, BuiltinMacroState::NotYetSeen(ext)).is_some() {\n-            self.session\n+            self.tcx\n+                .sess\n                 .diagnostic()\n                 .bug(&format!(\"built-in macro `{}` was already registered\", name));\n         }\n@@ -216,7 +217,7 @@ impl<'a, 'tcx> ResolverExpand for Resolver<'a, 'tcx> {\n             ExpnData::allow_unstable(\n                 ExpnKind::AstPass(pass),\n                 call_site,\n-                self.session.edition(),\n+                self.tcx.sess.edition(),\n                 features.into(),\n                 None,\n                 parent_module,\n@@ -430,7 +431,7 @@ impl<'a, 'tcx> ResolverExpand for Resolver<'a, 'tcx> {\n                 PathResult::NonModule(..) |\n                 // HACK(Urgau): This shouldn't be necessary\n                 PathResult::Failed { is_error_from_last_segment: false, .. } => {\n-                    self.session\n+                    self.tcx.sess\n                         .struct_span_err(span, \"not sure whether the path is accessible or not\")\n                         .note(\"the type may have associated items, but we are currently not checking them\")\n                         .emit();\n@@ -455,7 +456,7 @@ impl<'a, 'tcx> ResolverExpand for Resolver<'a, 'tcx> {\n     }\n \n     fn get_proc_macro_quoted_span(&self, krate: CrateNum, id: usize) -> Span {\n-        self.cstore().get_proc_macro_quoted_span_untracked(krate, id, self.session)\n+        self.cstore().get_proc_macro_quoted_span_untracked(krate, id, self.tcx.sess)\n     }\n \n     fn declare_proc_macro(&mut self, id: NodeId) {\n@@ -493,10 +494,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Report errors for the resolved macro.\n         for segment in &path.segments {\n             if let Some(args) = &segment.args {\n-                self.session.span_err(args.span(), \"generic arguments in macro path\");\n+                self.tcx.sess.span_err(args.span(), \"generic arguments in macro path\");\n             }\n             if kind == MacroKind::Attr && segment.ident.as_str().starts_with(\"rustc\") {\n-                self.session.span_err(\n+                self.tcx.sess.span_err(\n                     segment.ident.span,\n                     \"attributes starting with `rustc` are reserved for use by the `rustc` compiler\",\n                 );\n@@ -508,7 +509,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 if let Some(def_id) = def_id.as_local() {\n                     self.unused_macros.remove(&def_id);\n                     if self.proc_macro_stubs.contains(&def_id) {\n-                        self.session.span_err(\n+                        self.tcx.sess.span_err(\n                             path.span,\n                             \"can't use a procedural macro from the same crate that defines it\",\n                         );\n@@ -540,7 +541,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if let Some((article, expected)) = unexpected_res {\n             let path_str = pprust::path_to_string(path);\n             let msg = format!(\"expected {}, found {} `{}`\", expected, res.descr(), path_str);\n-            self.session\n+            self.tcx\n+                .sess\n                 .struct_span_err(path.span, &msg)\n                 .span_label(path.span, format!(\"not {} {}\", article, expected))\n                 .emit();\n@@ -550,18 +552,23 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // We are trying to avoid reporting this error if other related errors were reported.\n         if res != Res::Err\n             && inner_attr\n-            && !self.session.features_untracked().custom_inner_attributes\n+            && !self.tcx.sess.features_untracked().custom_inner_attributes\n         {\n             let msg = match res {\n                 Res::Def(..) => \"inner macro attributes are unstable\",\n                 Res::NonMacroAttr(..) => \"custom inner attributes are unstable\",\n                 _ => unreachable!(),\n             };\n             if soft_custom_inner_attributes_gate {\n-                self.session.parse_sess.buffer_lint(SOFT_UNSTABLE, path.span, node_id, msg);\n+                self.tcx.sess.parse_sess.buffer_lint(SOFT_UNSTABLE, path.span, node_id, msg);\n             } else {\n-                feature_err(&self.session.parse_sess, sym::custom_inner_attributes, path.span, msg)\n-                    .emit();\n+                feature_err(\n+                    &self.tcx.sess.parse_sess,\n+                    sym::custom_inner_attributes,\n+                    path.span,\n+                    msg,\n+                )\n+                .emit();\n             }\n         }\n \n@@ -655,7 +662,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // Make sure compilation does not succeed if preferred macro resolution\n                     // has changed after the macro had been expanded. In theory all such\n                     // situations should be reported as errors, so this is a bug.\n-                    this.session.delay_span_bug(span, \"inconsistent resolution for a macro\");\n+                    this.tcx.sess.delay_span_bug(span, \"inconsistent resolution for a macro\");\n                 }\n             } else {\n                 // It's possible that the macro was unresolved (indeterminate) and silently\n@@ -672,7 +679,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         Segment::names_to_string(path)\n                     );\n                     let msg_note = \"import resolution is stuck, try simplifying macro imports\";\n-                    this.session.struct_span_err(span, &msg).note(msg_note).emit();\n+                    this.tcx.sess.struct_span_err(span, &msg).note(msg_note).emit();\n                 }\n             }\n         };\n@@ -699,7 +706,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // try to suggest if it's not a macro, maybe a function\n                         if let PathResult::NonModule(partial_res) = self.maybe_resolve_path(&path, Some(ValueNS), &parent_scope)\n                             && partial_res.unresolved_segments() == 0 {\n-                            let sm = self.session.source_map();\n+                            let sm = self.tcx.sess.source_map();\n                             let exclamation_span = sm.next_point(span);\n                             suggestion = Some((\n                                 vec![(exclamation_span, \"\".to_string())],\n@@ -762,7 +769,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 Err(..) => {\n                     let expected = kind.descr_expected();\n                     let msg = format!(\"cannot find {} `{}` in this scope\", expected, ident);\n-                    let mut err = self.session.struct_span_err(ident.span, &msg);\n+                    let mut err = self.tcx.sess.struct_span_err(ident.span, &msg);\n                     self.unresolved_macro_suggestions(&mut err, kind, &parent_scope, ident);\n                     err.emit();\n                 }\n@@ -804,7 +811,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let soft_handler =\n                         |lint, span, msg: &_| lint_buffer.buffer_lint(lint, node_id, span, msg);\n                     stability::report_unstable(\n-                        self.session,\n+                        self.tcx.sess,\n                         feature,\n                         reason.to_opt_reason(),\n                         issue,\n@@ -840,7 +847,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             if kind != NonMacroAttrKind::Tool && binding.map_or(true, |b| b.is_import()) {\n                 let msg =\n                     format!(\"cannot use {} {} through an import\", kind.article(), kind.descr());\n-                let mut err = self.session.struct_span_err(span, &msg);\n+                let mut err = self.tcx.sess.struct_span_err(span, &msg);\n                 if let Some(binding) = binding {\n                     err.span_note(binding.span, &format!(\"the {} imported here\", kind.descr()));\n                 }\n@@ -855,7 +862,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if ident.name == sym::cfg || ident.name == sym::cfg_attr {\n             let macro_kind = self.get_macro(res).map(|macro_data| macro_data.ext.macro_kind());\n             if macro_kind.is_some() && sub_namespace_match(macro_kind, Some(MacroKind::Attr)) {\n-                self.session.span_err(\n+                self.tcx.sess.span_err(\n                     ident.span,\n                     &format!(\"name `{}` is reserved in attribute namespace\", ident),\n                 );\n@@ -871,12 +878,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         item: &ast::Item,\n         edition: Edition,\n     ) -> (SyntaxExtension, Vec<(usize, Span)>) {\n-        let (mut result, mut rule_spans) = compile_declarative_macro(\n-            &self.session,\n-            self.session.features_untracked(),\n-            item,\n-            edition,\n-        );\n+        let (mut result, mut rule_spans) = compile_declarative_macro(self.tcx.sess, item, edition);\n \n         if let Some(builtin_name) = result.builtin_name {\n             // The macro was marked with `#[rustc_builtin_macro]`.\n@@ -895,7 +897,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                     BuiltinMacroState::AlreadySeen(span) => {\n                         struct_span_err!(\n-                            self.session,\n+                            self.tcx.sess,\n                             item.span,\n                             E0773,\n                             \"attempted to define built-in macro more than once\"\n@@ -906,7 +908,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             } else {\n                 let msg = format!(\"cannot find a built-in macro with name `{}`\", item.ident);\n-                self.session.span_err(item.span, &msg);\n+                self.tcx.sess.span_err(item.span, &msg);\n             }\n         }\n "}, {"sha": "377c364961b9dd1ed6f673b589a888b7365d8af3", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -430,11 +430,6 @@ impl<D: Decoder, T: Decodable<D> + Copy> Decodable<D> for Cell<T> {\n     }\n }\n \n-// FIXME: #15036\n-// Should use `try_borrow`, returning an\n-// `encoder.error(\"attempting to Encode borrowed RefCell\")`\n-// from `encode` when `try_borrow` returns `None`.\n-\n impl<S: Encoder, T: Encodable<S>> Encodable<S> for RefCell<T> {\n     fn encode(&self, s: &mut S) {\n         self.borrow().encode(s);"}, {"sha": "97aa930b5ec8e8b5422df3ae9d79b9d5a0d57ebd", "filename": "compiler/rustc_session/src/cstore.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_session%2Fsrc%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_session%2Fsrc%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fcstore.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -200,12 +200,12 @@ pub enum ExternCrateSource {\n /// At the time of this writing, there is only one backend and one way to store\n /// metadata in library -- this trait just serves to decouple rustc_metadata from\n /// the archive reader, which depends on LLVM.\n-pub trait MetadataLoader {\n+pub trait MetadataLoader: std::fmt::Debug {\n     fn get_rlib_metadata(&self, target: &Target, filename: &Path) -> Result<MetadataRef, String>;\n     fn get_dylib_metadata(&self, target: &Target, filename: &Path) -> Result<MetadataRef, String>;\n }\n \n-pub type MetadataLoaderDyn = dyn MetadataLoader + Sync;\n+pub type MetadataLoaderDyn = dyn MetadataLoader + Send + Sync;\n \n /// A store of Rust crates, through which their metadata can be accessed.\n ///\n@@ -250,12 +250,12 @@ pub trait CrateStore: std::fmt::Debug {\n     fn import_source_files(&self, sess: &Session, cnum: CrateNum);\n }\n \n-pub type CrateStoreDyn = dyn CrateStore + sync::Sync;\n+pub type CrateStoreDyn = dyn CrateStore + sync::Sync + sync::Send;\n \n #[derive(Debug)]\n pub struct Untracked {\n-    pub cstore: Box<CrateStoreDyn>,\n+    pub cstore: RwLock<Box<CrateStoreDyn>>,\n     /// Reference span for definitions.\n-    pub source_span: IndexVec<LocalDefId, Span>,\n+    pub source_span: RwLock<IndexVec<LocalDefId, Span>>,\n     pub definitions: RwLock<Definitions>,\n }"}, {"sha": "89f0386e3e97fe934abdfb4d73ee8a0f1b3b34e5", "filename": "compiler/rustc_span/src/edit_distance.rs", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_span%2Fsrc%2Fedit_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_span%2Fsrc%2Fedit_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fedit_distance.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -0,0 +1,229 @@\n+//! Edit distances.\n+//!\n+//! The [edit distance] is a metric for measuring the difference between two strings.\n+//!\n+//! [edit distance]: https://en.wikipedia.org/wiki/Edit_distance\n+\n+// The current implementation is the restricted Damerau-Levenshtein algorithm. It is restricted\n+// because it does not permit modifying characters that have already been transposed. The specific\n+// algorithm should not matter to the caller of the methods, which is why it is not noted in the\n+// documentation.\n+\n+use crate::symbol::Symbol;\n+use std::{cmp, mem};\n+\n+#[cfg(test)]\n+mod tests;\n+\n+/// Finds the [edit distance] between two strings.\n+///\n+/// Returns `None` if the distance exceeds the limit.\n+///\n+/// [edit distance]: https://en.wikipedia.org/wiki/Edit_distance\n+pub fn edit_distance(a: &str, b: &str, limit: usize) -> Option<usize> {\n+    let mut a = &a.chars().collect::<Vec<_>>()[..];\n+    let mut b = &b.chars().collect::<Vec<_>>()[..];\n+\n+    // Ensure that `b` is the shorter string, minimizing memory use.\n+    if a.len() < b.len() {\n+        mem::swap(&mut a, &mut b);\n+    }\n+\n+    let min_dist = a.len() - b.len();\n+    // If we know the limit will be exceeded, we can return early.\n+    if min_dist > limit {\n+        return None;\n+    }\n+\n+    // Strip common prefix.\n+    while let Some(((b_char, b_rest), (a_char, a_rest))) = b.split_first().zip(a.split_first())\n+        && a_char == b_char\n+    {\n+        a = a_rest;\n+        b = b_rest;\n+    }\n+    // Strip common suffix.\n+    while let Some(((b_char, b_rest), (a_char, a_rest))) = b.split_last().zip(a.split_last())\n+        && a_char == b_char\n+    {\n+        a = a_rest;\n+        b = b_rest;\n+    }\n+\n+    // If either string is empty, the distance is the length of the other.\n+    // We know that `b` is the shorter string, so we don't need to check `a`.\n+    if b.len() == 0 {\n+        return Some(min_dist);\n+    }\n+\n+    let mut prev_prev = vec![usize::MAX; b.len() + 1];\n+    let mut prev = (0..=b.len()).collect::<Vec<_>>();\n+    let mut current = vec![0; b.len() + 1];\n+\n+    // row by row\n+    for i in 1..=a.len() {\n+        current[0] = i;\n+        let a_idx = i - 1;\n+\n+        // column by column\n+        for j in 1..=b.len() {\n+            let b_idx = j - 1;\n+\n+            // There is no cost to substitute a character with itself.\n+            let substitution_cost = if a[a_idx] == b[b_idx] { 0 } else { 1 };\n+\n+            current[j] = cmp::min(\n+                // deletion\n+                prev[j] + 1,\n+                cmp::min(\n+                    // insertion\n+                    current[j - 1] + 1,\n+                    // substitution\n+                    prev[j - 1] + substitution_cost,\n+                ),\n+            );\n+\n+            if (i > 1) && (j > 1) && (a[a_idx] == b[b_idx - 1]) && (a[a_idx - 1] == b[b_idx]) {\n+                // transposition\n+                current[j] = cmp::min(current[j], prev_prev[j - 2] + 1);\n+            }\n+        }\n+\n+        // Rotate the buffers, reusing the memory.\n+        [prev_prev, prev, current] = [prev, current, prev_prev];\n+    }\n+\n+    // `prev` because we already rotated the buffers.\n+    let distance = prev[b.len()];\n+    (distance <= limit).then_some(distance)\n+}\n+\n+/// Provides a word similarity score between two words that accounts for substrings being more\n+/// meaningful than a typical edit distance. The lower the score, the closer the match. 0 is an\n+/// identical match.\n+///\n+/// Uses the edit distance between the two strings and removes the cost of the length difference.\n+/// If this is 0 then it is either a substring match or a full word match, in the substring match\n+/// case we detect this and return `1`. To prevent finding meaningless substrings, eg. \"in\" in\n+/// \"shrink\", we only perform this subtraction of length difference if one of the words is not\n+/// greater than twice the length of the other. For cases where the words are close in size but not\n+/// an exact substring then the cost of the length difference is discounted by half.\n+///\n+/// Returns `None` if the distance exceeds the limit.\n+pub fn edit_distance_with_substrings(a: &str, b: &str, limit: usize) -> Option<usize> {\n+    let n = a.chars().count();\n+    let m = b.chars().count();\n+\n+    // Check one isn't less than half the length of the other. If this is true then there is a\n+    // big difference in length.\n+    let big_len_diff = (n * 2) < m || (m * 2) < n;\n+    let len_diff = if n < m { m - n } else { n - m };\n+    let distance = edit_distance(a, b, limit + len_diff)?;\n+\n+    // This is the crux, subtracting length difference means exact substring matches will now be 0\n+    let score = distance - len_diff;\n+\n+    // If the score is 0 but the words have different lengths then it's a substring match not a full\n+    // word match\n+    let score = if score == 0 && len_diff > 0 && !big_len_diff {\n+        1 // Exact substring match, but not a total word match so return non-zero\n+    } else if !big_len_diff {\n+        // Not a big difference in length, discount cost of length difference\n+        score + (len_diff + 1) / 2\n+    } else {\n+        // A big difference in length, add back the difference in length to the score\n+        score + len_diff\n+    };\n+\n+    (score <= limit).then_some(score)\n+}\n+\n+/// Finds the best match for given word in the given iterator where substrings are meaningful.\n+///\n+/// A version of [`find_best_match_for_name`] that uses [`edit_distance_with_substrings`] as the\n+/// score for word similarity. This takes an optional distance limit which defaults to one-third of\n+/// the given word.\n+///\n+/// We use case insensitive comparison to improve accuracy on an edge case with a lower(upper)case\n+/// letters mismatch.\n+pub fn find_best_match_for_name_with_substrings(\n+    candidates: &[Symbol],\n+    lookup: Symbol,\n+    dist: Option<usize>,\n+) -> Option<Symbol> {\n+    find_best_match_for_name_impl(true, candidates, lookup, dist)\n+}\n+\n+/// Finds the best match for a given word in the given iterator.\n+///\n+/// As a loose rule to avoid the obviously incorrect suggestions, it takes\n+/// an optional limit for the maximum allowable edit distance, which defaults\n+/// to one-third of the given word.\n+///\n+/// We use case insensitive comparison to improve accuracy on an edge case with a lower(upper)case\n+/// letters mismatch.\n+pub fn find_best_match_for_name(\n+    candidates: &[Symbol],\n+    lookup: Symbol,\n+    dist: Option<usize>,\n+) -> Option<Symbol> {\n+    find_best_match_for_name_impl(false, candidates, lookup, dist)\n+}\n+\n+#[cold]\n+fn find_best_match_for_name_impl(\n+    use_substring_score: bool,\n+    candidates: &[Symbol],\n+    lookup: Symbol,\n+    dist: Option<usize>,\n+) -> Option<Symbol> {\n+    let lookup = lookup.as_str();\n+    let lookup_uppercase = lookup.to_uppercase();\n+\n+    // Priority of matches:\n+    // 1. Exact case insensitive match\n+    // 2. Edit distance match\n+    // 3. Sorted word match\n+    if let Some(c) = candidates.iter().find(|c| c.as_str().to_uppercase() == lookup_uppercase) {\n+        return Some(*c);\n+    }\n+\n+    let mut dist = dist.unwrap_or_else(|| cmp::max(lookup.len(), 3) / 3);\n+    let mut best = None;\n+    for c in candidates {\n+        match if use_substring_score {\n+            edit_distance_with_substrings(lookup, c.as_str(), dist)\n+        } else {\n+            edit_distance(lookup, c.as_str(), dist)\n+        } {\n+            Some(0) => return Some(*c),\n+            Some(d) => {\n+                dist = d - 1;\n+                best = Some(*c);\n+            }\n+            None => {}\n+        }\n+    }\n+    if best.is_some() {\n+        return best;\n+    }\n+\n+    find_match_by_sorted_words(candidates, lookup)\n+}\n+\n+fn find_match_by_sorted_words(iter_names: &[Symbol], lookup: &str) -> Option<Symbol> {\n+    iter_names.iter().fold(None, |result, candidate| {\n+        if sort_by_words(candidate.as_str()) == sort_by_words(lookup) {\n+            Some(*candidate)\n+        } else {\n+            result\n+        }\n+    })\n+}\n+\n+fn sort_by_words(name: &str) -> String {\n+    let mut split_words: Vec<&str> = name.split('_').collect();\n+    // We are sorting primitive &strs and can use unstable sort here.\n+    split_words.sort_unstable();\n+    split_words.join(\"_\")\n+}"}, {"sha": "c9c7a1f1bf2f687f9a0290cdc6471ddf659ea969", "filename": "compiler/rustc_span/src/edit_distance/tests.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_span%2Fsrc%2Fedit_distance%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_span%2Fsrc%2Fedit_distance%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fedit_distance%2Ftests.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -0,0 +1,80 @@\n+use super::*;\n+\n+#[test]\n+fn test_edit_distance() {\n+    // Test bytelength agnosticity\n+    for c in (0..char::MAX as u32).filter_map(char::from_u32).map(|i| i.to_string()) {\n+        assert_eq!(edit_distance(&c[..], &c[..], usize::MAX), Some(0));\n+    }\n+\n+    let a = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n+    let b = \"\\nMary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n+    let c = \"Mary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n+    assert_eq!(edit_distance(a, b, usize::MAX), Some(1));\n+    assert_eq!(edit_distance(b, a, usize::MAX), Some(1));\n+    assert_eq!(edit_distance(a, c, usize::MAX), Some(2));\n+    assert_eq!(edit_distance(c, a, usize::MAX), Some(2));\n+    assert_eq!(edit_distance(b, c, usize::MAX), Some(1));\n+    assert_eq!(edit_distance(c, b, usize::MAX), Some(1));\n+}\n+\n+#[test]\n+fn test_edit_distance_limit() {\n+    assert_eq!(edit_distance(\"abc\", \"abcd\", 1), Some(1));\n+    assert_eq!(edit_distance(\"abc\", \"abcd\", 0), None);\n+    assert_eq!(edit_distance(\"abc\", \"xyz\", 3), Some(3));\n+    assert_eq!(edit_distance(\"abc\", \"xyz\", 2), None);\n+}\n+\n+#[test]\n+fn test_method_name_similarity_score() {\n+    assert_eq!(edit_distance_with_substrings(\"empty\", \"is_empty\", 1), Some(1));\n+    assert_eq!(edit_distance_with_substrings(\"shrunk\", \"rchunks\", 2), None);\n+    assert_eq!(edit_distance_with_substrings(\"abc\", \"abcd\", 1), Some(1));\n+    assert_eq!(edit_distance_with_substrings(\"a\", \"abcd\", 1), None);\n+    assert_eq!(edit_distance_with_substrings(\"edf\", \"eq\", 1), None);\n+    assert_eq!(edit_distance_with_substrings(\"abc\", \"xyz\", 3), Some(3));\n+    assert_eq!(edit_distance_with_substrings(\"abcdef\", \"abcdef\", 2), Some(0));\n+}\n+\n+#[test]\n+fn test_find_best_match_for_name() {\n+    use crate::create_default_session_globals_then;\n+    create_default_session_globals_then(|| {\n+        let input = vec![Symbol::intern(\"aaab\"), Symbol::intern(\"aaabc\")];\n+        assert_eq!(\n+            find_best_match_for_name(&input, Symbol::intern(\"aaaa\"), None),\n+            Some(Symbol::intern(\"aaab\"))\n+        );\n+\n+        assert_eq!(find_best_match_for_name(&input, Symbol::intern(\"1111111111\"), None), None);\n+\n+        let input = vec![Symbol::intern(\"AAAA\")];\n+        assert_eq!(\n+            find_best_match_for_name(&input, Symbol::intern(\"aaaa\"), None),\n+            Some(Symbol::intern(\"AAAA\"))\n+        );\n+\n+        let input = vec![Symbol::intern(\"AAAA\")];\n+        assert_eq!(\n+            find_best_match_for_name(&input, Symbol::intern(\"aaaa\"), Some(4)),\n+            Some(Symbol::intern(\"AAAA\"))\n+        );\n+\n+        let input = vec![Symbol::intern(\"a_longer_variable_name\")];\n+        assert_eq!(\n+            find_best_match_for_name(&input, Symbol::intern(\"a_variable_longer_name\"), None),\n+            Some(Symbol::intern(\"a_longer_variable_name\"))\n+        );\n+    })\n+}\n+\n+#[test]\n+fn test_precise_algorithm() {\n+    // Not Levenshtein distance.\n+    assert_ne!(edit_distance(\"ab\", \"ba\", usize::MAX), Some(2));\n+    // Not unrestricted Damerau-Levenshtein distance.\n+    assert_ne!(edit_distance(\"abde\", \"bcaed\", usize::MAX), Some(3));\n+    // The current implementation is a restricted Damerau-Levenshtein distance.\n+    assert_eq!(edit_distance(\"abde\", \"bcaed\", usize::MAX), Some(4));\n+}"}, {"sha": "61e4b98a8d28bbda31d873b007217a5a2fc5e350", "filename": "compiler/rustc_span/src/lev_distance.rs", "status": "removed", "additions": 0, "deletions": 177, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/9669e57ed1cd81c7f04db39f9b401198ae574c30/compiler%2Frustc_span%2Fsrc%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9669e57ed1cd81c7f04db39f9b401198ae574c30/compiler%2Frustc_span%2Fsrc%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flev_distance.rs?ref=9669e57ed1cd81c7f04db39f9b401198ae574c30", "patch": "@@ -1,177 +0,0 @@\n-//! Levenshtein distances.\n-//!\n-//! The [Levenshtein distance] is a metric for measuring the difference between two strings.\n-//!\n-//! [Levenshtein distance]: https://en.wikipedia.org/wiki/Levenshtein_distance\n-\n-use crate::symbol::Symbol;\n-use std::cmp;\n-\n-#[cfg(test)]\n-mod tests;\n-\n-/// Finds the Levenshtein distance between two strings.\n-///\n-/// Returns None if the distance exceeds the limit.\n-pub fn lev_distance(a: &str, b: &str, limit: usize) -> Option<usize> {\n-    let n = a.chars().count();\n-    let m = b.chars().count();\n-    let min_dist = if n < m { m - n } else { n - m };\n-\n-    if min_dist > limit {\n-        return None;\n-    }\n-    if n == 0 || m == 0 {\n-        return (min_dist <= limit).then_some(min_dist);\n-    }\n-\n-    let mut dcol: Vec<_> = (0..=m).collect();\n-\n-    for (i, sc) in a.chars().enumerate() {\n-        let mut current = i;\n-        dcol[0] = current + 1;\n-\n-        for (j, tc) in b.chars().enumerate() {\n-            let next = dcol[j + 1];\n-            if sc == tc {\n-                dcol[j + 1] = current;\n-            } else {\n-                dcol[j + 1] = cmp::min(current, next);\n-                dcol[j + 1] = cmp::min(dcol[j + 1], dcol[j]) + 1;\n-            }\n-            current = next;\n-        }\n-    }\n-\n-    (dcol[m] <= limit).then_some(dcol[m])\n-}\n-\n-/// Provides a word similarity score between two words that accounts for substrings being more\n-/// meaningful than a typical Levenshtein distance. The lower the score, the closer the match.\n-/// 0 is an identical match.\n-///\n-/// Uses the Levenshtein distance between the two strings and removes the cost of the length\n-/// difference. If this is 0 then it is either a substring match or a full word match, in the\n-/// substring match case we detect this and return `1`. To prevent finding meaningless substrings,\n-/// eg. \"in\" in \"shrink\", we only perform this subtraction of length difference if one of the words\n-/// is not greater than twice the length of the other. For cases where the words are close in size\n-/// but not an exact substring then the cost of the length difference is discounted by half.\n-///\n-/// Returns `None` if the distance exceeds the limit.\n-pub fn lev_distance_with_substrings(a: &str, b: &str, limit: usize) -> Option<usize> {\n-    let n = a.chars().count();\n-    let m = b.chars().count();\n-\n-    // Check one isn't less than half the length of the other. If this is true then there is a\n-    // big difference in length.\n-    let big_len_diff = (n * 2) < m || (m * 2) < n;\n-    let len_diff = if n < m { m - n } else { n - m };\n-    let lev = lev_distance(a, b, limit + len_diff)?;\n-\n-    // This is the crux, subtracting length difference means exact substring matches will now be 0\n-    let score = lev - len_diff;\n-\n-    // If the score is 0 but the words have different lengths then it's a substring match not a full\n-    // word match\n-    let score = if score == 0 && len_diff > 0 && !big_len_diff {\n-        1 // Exact substring match, but not a total word match so return non-zero\n-    } else if !big_len_diff {\n-        // Not a big difference in length, discount cost of length difference\n-        score + (len_diff + 1) / 2\n-    } else {\n-        // A big difference in length, add back the difference in length to the score\n-        score + len_diff\n-    };\n-\n-    (score <= limit).then_some(score)\n-}\n-\n-/// Finds the best match for given word in the given iterator where substrings are meaningful.\n-///\n-/// A version of [`find_best_match_for_name`] that uses [`lev_distance_with_substrings`] as the score\n-/// for word similarity. This takes an optional distance limit which defaults to one-third of the\n-/// given word.\n-///\n-/// Besides the modified Levenshtein, we use case insensitive comparison to improve accuracy\n-/// on an edge case with a lower(upper)case letters mismatch.\n-pub fn find_best_match_for_name_with_substrings(\n-    candidates: &[Symbol],\n-    lookup: Symbol,\n-    dist: Option<usize>,\n-) -> Option<Symbol> {\n-    find_best_match_for_name_impl(true, candidates, lookup, dist)\n-}\n-\n-/// Finds the best match for a given word in the given iterator.\n-///\n-/// As a loose rule to avoid the obviously incorrect suggestions, it takes\n-/// an optional limit for the maximum allowable edit distance, which defaults\n-/// to one-third of the given word.\n-///\n-/// Besides Levenshtein, we use case insensitive comparison to improve accuracy\n-/// on an edge case with a lower(upper)case letters mismatch.\n-pub fn find_best_match_for_name(\n-    candidates: &[Symbol],\n-    lookup: Symbol,\n-    dist: Option<usize>,\n-) -> Option<Symbol> {\n-    find_best_match_for_name_impl(false, candidates, lookup, dist)\n-}\n-\n-#[cold]\n-fn find_best_match_for_name_impl(\n-    use_substring_score: bool,\n-    candidates: &[Symbol],\n-    lookup: Symbol,\n-    dist: Option<usize>,\n-) -> Option<Symbol> {\n-    let lookup = lookup.as_str();\n-    let lookup_uppercase = lookup.to_uppercase();\n-\n-    // Priority of matches:\n-    // 1. Exact case insensitive match\n-    // 2. Levenshtein distance match\n-    // 3. Sorted word match\n-    if let Some(c) = candidates.iter().find(|c| c.as_str().to_uppercase() == lookup_uppercase) {\n-        return Some(*c);\n-    }\n-\n-    let mut dist = dist.unwrap_or_else(|| cmp::max(lookup.len(), 3) / 3);\n-    let mut best = None;\n-    for c in candidates {\n-        match if use_substring_score {\n-            lev_distance_with_substrings(lookup, c.as_str(), dist)\n-        } else {\n-            lev_distance(lookup, c.as_str(), dist)\n-        } {\n-            Some(0) => return Some(*c),\n-            Some(d) => {\n-                dist = d - 1;\n-                best = Some(*c);\n-            }\n-            None => {}\n-        }\n-    }\n-    if best.is_some() {\n-        return best;\n-    }\n-\n-    find_match_by_sorted_words(candidates, lookup)\n-}\n-\n-fn find_match_by_sorted_words(iter_names: &[Symbol], lookup: &str) -> Option<Symbol> {\n-    iter_names.iter().fold(None, |result, candidate| {\n-        if sort_by_words(candidate.as_str()) == sort_by_words(lookup) {\n-            Some(*candidate)\n-        } else {\n-            result\n-        }\n-    })\n-}\n-\n-fn sort_by_words(name: &str) -> String {\n-    let mut split_words: Vec<&str> = name.split('_').collect();\n-    // We are sorting primitive &strs and can use unstable sort here.\n-    split_words.sort_unstable();\n-    split_words.join(\"_\")\n-}"}, {"sha": "ed03b22c61fd6a2eb20675ee7de0f799322e53b5", "filename": "compiler/rustc_span/src/lev_distance/tests.rs", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/9669e57ed1cd81c7f04db39f9b401198ae574c30/compiler%2Frustc_span%2Fsrc%2Flev_distance%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9669e57ed1cd81c7f04db39f9b401198ae574c30/compiler%2Frustc_span%2Fsrc%2Flev_distance%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flev_distance%2Ftests.rs?ref=9669e57ed1cd81c7f04db39f9b401198ae574c30", "patch": "@@ -1,70 +0,0 @@\n-use super::*;\n-\n-#[test]\n-fn test_lev_distance() {\n-    // Test bytelength agnosticity\n-    for c in (0..char::MAX as u32).filter_map(char::from_u32).map(|i| i.to_string()) {\n-        assert_eq!(lev_distance(&c[..], &c[..], usize::MAX), Some(0));\n-    }\n-\n-    let a = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n-    let b = \"\\nMary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n-    let c = \"Mary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n-    assert_eq!(lev_distance(a, b, usize::MAX), Some(1));\n-    assert_eq!(lev_distance(b, a, usize::MAX), Some(1));\n-    assert_eq!(lev_distance(a, c, usize::MAX), Some(2));\n-    assert_eq!(lev_distance(c, a, usize::MAX), Some(2));\n-    assert_eq!(lev_distance(b, c, usize::MAX), Some(1));\n-    assert_eq!(lev_distance(c, b, usize::MAX), Some(1));\n-}\n-\n-#[test]\n-fn test_lev_distance_limit() {\n-    assert_eq!(lev_distance(\"abc\", \"abcd\", 1), Some(1));\n-    assert_eq!(lev_distance(\"abc\", \"abcd\", 0), None);\n-    assert_eq!(lev_distance(\"abc\", \"xyz\", 3), Some(3));\n-    assert_eq!(lev_distance(\"abc\", \"xyz\", 2), None);\n-}\n-\n-#[test]\n-fn test_method_name_similarity_score() {\n-    assert_eq!(lev_distance_with_substrings(\"empty\", \"is_empty\", 1), Some(1));\n-    assert_eq!(lev_distance_with_substrings(\"shrunk\", \"rchunks\", 2), None);\n-    assert_eq!(lev_distance_with_substrings(\"abc\", \"abcd\", 1), Some(1));\n-    assert_eq!(lev_distance_with_substrings(\"a\", \"abcd\", 1), None);\n-    assert_eq!(lev_distance_with_substrings(\"edf\", \"eq\", 1), None);\n-    assert_eq!(lev_distance_with_substrings(\"abc\", \"xyz\", 3), Some(3));\n-    assert_eq!(lev_distance_with_substrings(\"abcdef\", \"abcdef\", 2), Some(0));\n-}\n-\n-#[test]\n-fn test_find_best_match_for_name() {\n-    use crate::create_default_session_globals_then;\n-    create_default_session_globals_then(|| {\n-        let input = vec![Symbol::intern(\"aaab\"), Symbol::intern(\"aaabc\")];\n-        assert_eq!(\n-            find_best_match_for_name(&input, Symbol::intern(\"aaaa\"), None),\n-            Some(Symbol::intern(\"aaab\"))\n-        );\n-\n-        assert_eq!(find_best_match_for_name(&input, Symbol::intern(\"1111111111\"), None), None);\n-\n-        let input = vec![Symbol::intern(\"AAAA\")];\n-        assert_eq!(\n-            find_best_match_for_name(&input, Symbol::intern(\"aaaa\"), None),\n-            Some(Symbol::intern(\"AAAA\"))\n-        );\n-\n-        let input = vec![Symbol::intern(\"AAAA\")];\n-        assert_eq!(\n-            find_best_match_for_name(&input, Symbol::intern(\"aaaa\"), Some(4)),\n-            Some(Symbol::intern(\"AAAA\"))\n-        );\n-\n-        let input = vec![Symbol::intern(\"a_longer_variable_name\")];\n-        assert_eq!(\n-            find_best_match_for_name(&input, Symbol::intern(\"a_variable_longer_name\"), None),\n-            Some(Symbol::intern(\"a_longer_variable_name\"))\n-        );\n-    })\n-}"}, {"sha": "e112100aa5fcdb05fcb8e48f7a0c8a17c3f08ef2", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -19,6 +19,7 @@\n #![feature(negative_impls)]\n #![feature(min_specialization)]\n #![feature(rustc_attrs)]\n+#![feature(let_chains)]\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n \n@@ -46,7 +47,7 @@ pub use hygiene::{ExpnData, ExpnHash, ExpnId, LocalExpnId, SyntaxContext};\n use rustc_data_structures::stable_hasher::HashingControls;\n pub mod def_id;\n use def_id::{CrateNum, DefId, DefPathHash, LocalDefId, LOCAL_CRATE};\n-pub mod lev_distance;\n+pub mod edit_distance;\n mod span_encoding;\n pub use span_encoding::{Span, DUMMY_SP};\n "}, {"sha": "aec15212d7ff7fd4d352b0350f06fd2144e1c2c1", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 32, "deletions": 12, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1,9 +1,29 @@\n macro_rules! int_impl {\n-    ($SelfT:ty, $ActualT:ident, $UnsignedT:ty, $BITS:expr, $BITS_MINUS_ONE:expr, $Min:expr, $Max:expr,\n-     $rot:expr, $rot_op:expr, $rot_result:expr, $swap_op:expr, $swapped:expr,\n-     $reversed:expr, $le_bytes:expr, $be_bytes:expr,\n-     $to_xe_bytes_doc:expr, $from_xe_bytes_doc:expr,\n-     $bound_condition:expr) => {\n+    (\n+        Self = $SelfT:ty,\n+        ActualT = $ActualT:ident,\n+        UnsignedT = $UnsignedT:ty,\n+\n+        // There are all for use *only* in doc comments.\n+        // As such, they're all passed as literals -- passing them as a string\n+        // literal is fine if they need to be multiple code tokens.\n+        // In non-comments, use the associated constants rather than these.\n+        BITS = $BITS:literal,\n+        BITS_MINUS_ONE = $BITS_MINUS_ONE:literal,\n+        Min = $Min:literal,\n+        Max = $Max:literal,\n+        rot = $rot:literal,\n+        rot_op = $rot_op:literal,\n+        rot_result = $rot_result:literal,\n+        swap_op = $swap_op:literal,\n+        swapped = $swapped:literal,\n+        reversed = $reversed:literal,\n+        le_bytes = $le_bytes:literal,\n+        be_bytes = $be_bytes:literal,\n+        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n+        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n+        bound_condition = $bound_condition:literal,\n+    ) => {\n         /// The smallest value that can be represented by this integer type\n         #[doc = concat!(\"(&minus;2<sup>\", $BITS_MINUS_ONE, \"</sup>\", $bound_condition, \").\")]\n         ///\n@@ -15,7 +35,7 @@ macro_rules! int_impl {\n         #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, \", stringify!($Min), \");\")]\n         /// ```\n         #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n-        pub const MIN: Self = !0 ^ ((!0 as $UnsignedT) >> 1) as Self;\n+        pub const MIN: Self = !Self::MAX;\n \n         /// The largest value that can be represented by this integer type\n         #[doc = concat!(\"(2<sup>\", $BITS_MINUS_ONE, \"</sup> &minus; 1\", $bound_condition, \").\")]\n@@ -28,7 +48,7 @@ macro_rules! int_impl {\n         #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($Max), \");\")]\n         /// ```\n         #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n-        pub const MAX: Self = !Self::MIN;\n+        pub const MAX: Self = (<$UnsignedT>::MAX >> 1) as Self;\n \n         /// The size of this integer type in bits.\n         ///\n@@ -38,7 +58,7 @@ macro_rules! int_impl {\n         #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n         /// ```\n         #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n-        pub const BITS: u32 = $BITS;\n+        pub const BITS: u32 = <$UnsignedT>::BITS;\n \n         /// Converts a string slice in a given base to an integer.\n         ///\n@@ -1365,7 +1385,7 @@ macro_rules! int_impl {\n             // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n             // out of bounds\n             unsafe {\n-                self.unchecked_shl(rhs & ($BITS - 1))\n+                self.unchecked_shl(rhs & (Self::BITS - 1))\n             }\n         }\n \n@@ -1395,7 +1415,7 @@ macro_rules! int_impl {\n             // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n             // out of bounds\n             unsafe {\n-                self.unchecked_shr(rhs & ($BITS - 1))\n+                self.unchecked_shr(rhs & (Self::BITS - 1))\n             }\n         }\n \n@@ -1901,7 +1921,7 @@ macro_rules! int_impl {\n                       without modifying the original\"]\n         #[inline]\n         pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n-            (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n+            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n         }\n \n         /// Shifts self right by `rhs` bits.\n@@ -1924,7 +1944,7 @@ macro_rules! int_impl {\n                       without modifying the original\"]\n         #[inline]\n         pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n-            (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n+            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n         }\n \n         /// Computes the absolute value of `self`."}, {"sha": "a50c91579fa76818e4c467148616f9654464b738", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 317, "deletions": 67, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -226,72 +226,217 @@ macro_rules! widening_impl {\n }\n \n impl i8 {\n-    int_impl! { i8, i8, u8, 8, 7, -128, 127, 2, \"-0x7e\", \"0xa\", \"0x12\", \"0x12\", \"0x48\",\n-    \"[0x12]\", \"[0x12]\", \"\", \"\", \"\" }\n+    int_impl! {\n+        Self = i8,\n+        ActualT = i8,\n+        UnsignedT = u8,\n+        BITS = 8,\n+        BITS_MINUS_ONE = 7,\n+        Min = -128,\n+        Max = 127,\n+        rot = 2,\n+        rot_op = \"-0x7e\",\n+        rot_result = \"0xa\",\n+        swap_op = \"0x12\",\n+        swapped = \"0x12\",\n+        reversed = \"0x48\",\n+        le_bytes = \"[0x12]\",\n+        be_bytes = \"[0x12]\",\n+        to_xe_bytes_doc = \"\",\n+        from_xe_bytes_doc = \"\",\n+        bound_condition = \"\",\n+    }\n }\n \n impl i16 {\n-    int_impl! { i16, i16, u16, 16, 15, -32768, 32767, 4, \"-0x5ffd\", \"0x3a\", \"0x1234\", \"0x3412\",\n-    \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\", \"\" }\n+    int_impl! {\n+        Self = i16,\n+        ActualT = i16,\n+        UnsignedT = u16,\n+        BITS = 16,\n+        BITS_MINUS_ONE = 15,\n+        Min = -32768,\n+        Max = 32767,\n+        rot = 4,\n+        rot_op = \"-0x5ffd\",\n+        rot_result = \"0x3a\",\n+        swap_op = \"0x1234\",\n+        swapped = \"0x3412\",\n+        reversed = \"0x2c48\",\n+        le_bytes = \"[0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34]\",\n+        to_xe_bytes_doc = \"\",\n+        from_xe_bytes_doc = \"\",\n+        bound_condition = \"\",\n+    }\n }\n \n impl i32 {\n-    int_impl! { i32, i32, u32, 32, 31, -2147483648, 2147483647, 8, \"0x10000b3\", \"0xb301\",\n-    \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n-    \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\", \"\" }\n+    int_impl! {\n+        Self = i32,\n+        ActualT = i32,\n+        UnsignedT = u32,\n+        BITS = 32,\n+        BITS_MINUS_ONE = 31,\n+        Min = -2147483648,\n+        Max = 2147483647,\n+        rot = 8,\n+        rot_op = \"0x10000b3\",\n+        rot_result = \"0xb301\",\n+        swap_op = \"0x12345678\",\n+        swapped = \"0x78563412\",\n+        reversed = \"0x1e6a2c48\",\n+        le_bytes = \"[0x78, 0x56, 0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34, 0x56, 0x78]\",\n+        to_xe_bytes_doc = \"\",\n+        from_xe_bytes_doc = \"\",\n+        bound_condition = \"\",\n+    }\n }\n \n impl i64 {\n-    int_impl! { i64, i64, u64, 64, 63, -9223372036854775808, 9223372036854775807, 12,\n-    \"0xaa00000000006e1\", \"0x6e10aa\", \"0x1234567890123456\", \"0x5634129078563412\",\n-    \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n-    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\", \"\", \"\", \"\" }\n+    int_impl! {\n+        Self = i64,\n+        ActualT = i64,\n+        UnsignedT = u64,\n+        BITS = 64,\n+        BITS_MINUS_ONE = 63,\n+        Min = -9223372036854775808,\n+        Max = 9223372036854775807,\n+        rot = 12,\n+        rot_op = \"0xaa00000000006e1\",\n+        rot_result = \"0x6e10aa\",\n+        swap_op = \"0x1234567890123456\",\n+        swapped = \"0x5634129078563412\",\n+        reversed = \"0x6a2c48091e6a2c48\",\n+        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n+        to_xe_bytes_doc = \"\",\n+        from_xe_bytes_doc = \"\",\n+        bound_condition = \"\",\n+    }\n }\n \n impl i128 {\n-    int_impl! { i128, i128, u128, 128, 127, -170141183460469231731687303715884105728,\n-    170141183460469231731687303715884105727, 16,\n-    \"0x13f40000000000000000000000004f76\", \"0x4f7613f4\", \"0x12345678901234567890123456789012\",\n-    \"0x12907856341290785634129078563412\", \"0x48091e6a2c48091e6a2c48091e6a2c48\",\n-    \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n-      0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n-    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, \\\n-      0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]\", \"\", \"\", \"\" }\n+    int_impl! {\n+        Self = i128,\n+        ActualT = i128,\n+        UnsignedT = u128,\n+        BITS = 128,\n+        BITS_MINUS_ONE = 127,\n+        Min = -170141183460469231731687303715884105728,\n+        Max = 170141183460469231731687303715884105727,\n+        rot = 16,\n+        rot_op = \"0x13f40000000000000000000000004f76\",\n+        rot_result = \"0x4f7613f4\",\n+        swap_op = \"0x12345678901234567890123456789012\",\n+        swapped = \"0x12907856341290785634129078563412\",\n+        reversed = \"0x48091e6a2c48091e6a2c48091e6a2c48\",\n+        le_bytes = \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n+            0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, \\\n+            0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]\",\n+        to_xe_bytes_doc = \"\",\n+        from_xe_bytes_doc = \"\",\n+        bound_condition = \"\",\n+    }\n }\n \n #[cfg(target_pointer_width = \"16\")]\n impl isize {\n-    int_impl! { isize, i16, usize, 16, 15, -32768, 32767, 4, \"-0x5ffd\", \"0x3a\", \"0x1234\",\n-    \"0x3412\", \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n-    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!(),\n-    \" on 16-bit targets\" }\n+    int_impl! {\n+        Self = isize,\n+        ActualT = i16,\n+        UnsignedT = usize,\n+        BITS = 16,\n+        BITS_MINUS_ONE = 15,\n+        Min = -32768,\n+        Max = 32767,\n+        rot = 4,\n+        rot_op = \"-0x5ffd\",\n+        rot_result = \"0x3a\",\n+        swap_op = \"0x1234\",\n+        swapped = \"0x3412\",\n+        reversed = \"0x2c48\",\n+        le_bytes = \"[0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34]\",\n+        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n+        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n+        bound_condition = \" on 16-bit targets\",\n+    }\n }\n \n #[cfg(target_pointer_width = \"32\")]\n impl isize {\n-    int_impl! { isize, i32, usize, 32, 31, -2147483648, 2147483647, 8, \"0x10000b3\", \"0xb301\",\n-    \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n-    \"[0x12, 0x34, 0x56, 0x78]\",\n-    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!(),\n-    \" on 32-bit targets\" }\n+    int_impl! {\n+        Self = isize,\n+        ActualT = i32,\n+        UnsignedT = usize,\n+        BITS = 32,\n+        BITS_MINUS_ONE = 31,\n+        Min = -2147483648,\n+        Max = 2147483647,\n+        rot = 8,\n+        rot_op = \"0x10000b3\",\n+        rot_result = \"0xb301\",\n+        swap_op = \"0x12345678\",\n+        swapped = \"0x78563412\",\n+        reversed = \"0x1e6a2c48\",\n+        le_bytes = \"[0x78, 0x56, 0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34, 0x56, 0x78]\",\n+        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n+        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n+        bound_condition = \" on 32-bit targets\",\n+    }\n }\n \n #[cfg(target_pointer_width = \"64\")]\n impl isize {\n-    int_impl! { isize, i64, usize, 64, 63, -9223372036854775808, 9223372036854775807,\n-    12, \"0xaa00000000006e1\", \"0x6e10aa\",  \"0x1234567890123456\", \"0x5634129078563412\",\n-    \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n-    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n-    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!(),\n-    \" on 64-bit targets\" }\n+    int_impl! {\n+        Self = isize,\n+        ActualT = i64,\n+        UnsignedT = usize,\n+        BITS = 64,\n+        BITS_MINUS_ONE = 63,\n+        Min = -9223372036854775808,\n+        Max = 9223372036854775807,\n+        rot = 12,\n+        rot_op = \"0xaa00000000006e1\",\n+        rot_result = \"0x6e10aa\",\n+        swap_op = \"0x1234567890123456\",\n+        swapped = \"0x5634129078563412\",\n+        reversed = \"0x6a2c48091e6a2c48\",\n+        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n+        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n+        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n+        bound_condition = \" on 64-bit targets\",\n+    }\n }\n \n /// If 6th bit set ascii is upper case.\n const ASCII_CASE_MASK: u8 = 0b0010_0000;\n \n impl u8 {\n-    uint_impl! { u8, u8, i8, NonZeroU8, 8, 255, 2, \"0x82\", \"0xa\", \"0x12\", \"0x12\", \"0x48\", \"[0x12]\",\n-    \"[0x12]\", \"\", \"\", \"\" }\n+    uint_impl! {\n+        Self = u8,\n+        ActualT = u8,\n+        SignedT = i8,\n+        NonZeroT = NonZeroU8,\n+        BITS = 8,\n+        MAX = 255,\n+        rot = 2,\n+        rot_op = \"0x82\",\n+        rot_result = \"0xa\",\n+        swap_op = \"0x12\",\n+        swapped = \"0x12\",\n+        reversed = \"0x48\",\n+        le_bytes = \"[0x12]\",\n+        be_bytes = \"[0x12]\",\n+        to_xe_bytes_doc = \"\",\n+        from_xe_bytes_doc = \"\",\n+        bound_condition = \"\",\n+    }\n     widening_impl! { u8, u16, 8, unsigned }\n \n     /// Checks if the value is within the ASCII range.\n@@ -875,8 +1020,25 @@ impl u8 {\n }\n \n impl u16 {\n-    uint_impl! { u16, u16, i16, NonZeroU16, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n-    \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\", \"\" }\n+    uint_impl! {\n+        Self = u16,\n+        ActualT = u16,\n+        SignedT = i16,\n+        NonZeroT = NonZeroU16,\n+        BITS = 16,\n+        MAX = 65535,\n+        rot = 4,\n+        rot_op = \"0xa003\",\n+        rot_result = \"0x3a\",\n+        swap_op = \"0x1234\",\n+        swapped = \"0x3412\",\n+        reversed = \"0x2c48\",\n+        le_bytes = \"[0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34]\",\n+        to_xe_bytes_doc = \"\",\n+        from_xe_bytes_doc = \"\",\n+        bound_condition = \"\",\n+    }\n     widening_impl! { u16, u32, 16, unsigned }\n \n     /// Checks if the value is a Unicode surrogate code point, which are disallowed values for [`char`].\n@@ -906,56 +1068,144 @@ impl u16 {\n }\n \n impl u32 {\n-    uint_impl! { u32, u32, i32, NonZeroU32, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n-    \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\", \"\" }\n+    uint_impl! {\n+        Self = u32,\n+        ActualT = u32,\n+        SignedT = i32,\n+        NonZeroT = NonZeroU32,\n+        BITS = 32,\n+        MAX = 4294967295,\n+        rot = 8,\n+        rot_op = \"0x10000b3\",\n+        rot_result = \"0xb301\",\n+        swap_op = \"0x12345678\",\n+        swapped = \"0x78563412\",\n+        reversed = \"0x1e6a2c48\",\n+        le_bytes = \"[0x78, 0x56, 0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34, 0x56, 0x78]\",\n+        to_xe_bytes_doc = \"\",\n+        from_xe_bytes_doc = \"\",\n+        bound_condition = \"\",\n+    }\n     widening_impl! { u32, u64, 32, unsigned }\n }\n \n impl u64 {\n-    uint_impl! { u64, u64, i64, NonZeroU64, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n-    \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n-    \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n-    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n-    \"\", \"\", \"\"}\n+    uint_impl! {\n+        Self = u64,\n+        ActualT = u64,\n+        SignedT = i64,\n+        NonZeroT = NonZeroU64,\n+        BITS = 64,\n+        MAX = 18446744073709551615,\n+        rot = 12,\n+        rot_op = \"0xaa00000000006e1\",\n+        rot_result = \"0x6e10aa\",\n+        swap_op = \"0x1234567890123456\",\n+        swapped = \"0x5634129078563412\",\n+        reversed = \"0x6a2c48091e6a2c48\",\n+        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n+        to_xe_bytes_doc = \"\",\n+        from_xe_bytes_doc = \"\",\n+        bound_condition = \"\",\n+    }\n     widening_impl! { u64, u128, 64, unsigned }\n }\n \n impl u128 {\n-    uint_impl! { u128, u128, i128, NonZeroU128, 128, 340282366920938463463374607431768211455, 16,\n-    \"0x13f40000000000000000000000004f76\", \"0x4f7613f4\", \"0x12345678901234567890123456789012\",\n-    \"0x12907856341290785634129078563412\", \"0x48091e6a2c48091e6a2c48091e6a2c48\",\n-    \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n-      0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n-    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, \\\n-      0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]\",\n-     \"\", \"\", \"\"}\n+    uint_impl! {\n+        Self = u128,\n+        ActualT = u128,\n+        SignedT = i128,\n+        NonZeroT = NonZeroU128,\n+        BITS = 128,\n+        MAX = 340282366920938463463374607431768211455,\n+        rot = 16,\n+        rot_op = \"0x13f40000000000000000000000004f76\",\n+        rot_result = \"0x4f7613f4\",\n+        swap_op = \"0x12345678901234567890123456789012\",\n+        swapped = \"0x12907856341290785634129078563412\",\n+        reversed = \"0x48091e6a2c48091e6a2c48091e6a2c48\",\n+        le_bytes = \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n+            0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, \\\n+            0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]\",\n+        to_xe_bytes_doc = \"\",\n+        from_xe_bytes_doc = \"\",\n+        bound_condition = \"\",\n+    }\n }\n \n #[cfg(target_pointer_width = \"16\")]\n impl usize {\n-    uint_impl! { usize, u16, isize, NonZeroUsize, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n-    \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n-    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!(),\n-    \" on 16-bit targets\" }\n+    uint_impl! {\n+        Self = usize,\n+        ActualT = u16,\n+        SignedT = isize,\n+        NonZeroT = NonZeroUsize,\n+        BITS = 16,\n+        MAX = 65535,\n+        rot = 4,\n+        rot_op = \"0xa003\",\n+        rot_result = \"0x3a\",\n+        swap_op = \"0x1234\",\n+        swapped = \"0x3412\",\n+        reversed = \"0x2c48\",\n+        le_bytes = \"[0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34]\",\n+        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n+        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n+        bound_condition = \" on 16-bit targets\",\n+    }\n     widening_impl! { usize, u32, 16, unsigned }\n }\n+\n #[cfg(target_pointer_width = \"32\")]\n impl usize {\n-    uint_impl! { usize, u32, isize, NonZeroUsize, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n-    \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\",\n-    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!(),\n-    \" on 32-bit targets\" }\n+    uint_impl! {\n+        Self = usize,\n+        ActualT = u32,\n+        SignedT = isize,\n+        NonZeroT = NonZeroUsize,\n+        BITS = 32,\n+        MAX = 4294967295,\n+        rot = 8,\n+        rot_op = \"0x10000b3\",\n+        rot_result = \"0xb301\",\n+        swap_op = \"0x12345678\",\n+        swapped = \"0x78563412\",\n+        reversed = \"0x1e6a2c48\",\n+        le_bytes = \"[0x78, 0x56, 0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34, 0x56, 0x78]\",\n+        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n+        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n+        bound_condition = \" on 32-bit targets\",\n+    }\n     widening_impl! { usize, u64, 32, unsigned }\n }\n \n #[cfg(target_pointer_width = \"64\")]\n impl usize {\n-    uint_impl! { usize, u64, isize, NonZeroUsize, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n-    \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n-    \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n-    \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n-    usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!(),\n-    \" on 64-bit targets\" }\n+    uint_impl! {\n+        Self = usize,\n+        ActualT = u64,\n+        SignedT = isize,\n+        NonZeroT = NonZeroUsize,\n+        BITS = 64,\n+        MAX = 18446744073709551615,\n+        rot = 12,\n+        rot_op = \"0xaa00000000006e1\",\n+        rot_result = \"0x6e10aa\",\n+        swap_op = \"0x1234567890123456\",\n+        swapped = \"0x5634129078563412\",\n+        reversed = \"0x6a2c48091e6a2c48\",\n+        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n+        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n+        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n+        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n+        bound_condition = \" on 64-bit targets\",\n+    }\n     widening_impl! { usize, u128, 64, unsigned }\n }\n "}, {"sha": "932038a0b012a1a86e82781c4870346fcb43b7af", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1,10 +1,28 @@\n macro_rules! uint_impl {\n-    ($SelfT:ty, $ActualT:ident, $SignedT:ident, $NonZeroT:ident,\n-        $BITS:expr, $MaxV:expr,\n-        $rot:expr, $rot_op:expr, $rot_result:expr, $swap_op:expr, $swapped:expr,\n-        $reversed:expr, $le_bytes:expr, $be_bytes:expr,\n-        $to_xe_bytes_doc:expr, $from_xe_bytes_doc:expr,\n-        $bound_condition:expr) => {\n+    (\n+        Self = $SelfT:ty,\n+        ActualT = $ActualT:ident,\n+        SignedT = $SignedT:ident,\n+        NonZeroT = $NonZeroT:ident,\n+\n+        // There are all for use *only* in doc comments.\n+        // As such, they're all passed as literals -- passing them as a string\n+        // literal is fine if they need to be multiple code tokens.\n+        // In non-comments, use the associated constants rather than these.\n+        BITS = $BITS:literal,\n+        MAX = $MaxV:literal,\n+        rot = $rot:literal,\n+        rot_op = $rot_op:literal,\n+        rot_result = $rot_result:literal,\n+        swap_op = $swap_op:literal,\n+        swapped = $swapped:literal,\n+        reversed = $reversed:literal,\n+        le_bytes = $le_bytes:literal,\n+        be_bytes = $be_bytes:literal,\n+        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n+        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n+        bound_condition = $bound_condition:literal,\n+    ) => {\n         /// The smallest value that can be represented by this integer type.\n         ///\n         /// # Examples\n@@ -38,7 +56,7 @@ macro_rules! uint_impl {\n         #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n         /// ```\n         #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n-        pub const BITS: u32 = $BITS;\n+        pub const BITS: u32 = Self::MAX.count_ones();\n \n         /// Converts a string slice in a given base to an integer.\n         ///\n@@ -1390,7 +1408,7 @@ macro_rules! uint_impl {\n             // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n             // out of bounds\n             unsafe {\n-                self.unchecked_shl(rhs & ($BITS - 1))\n+                self.unchecked_shl(rhs & (Self::BITS - 1))\n             }\n         }\n \n@@ -1423,7 +1441,7 @@ macro_rules! uint_impl {\n             // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n             // out of bounds\n             unsafe {\n-                self.unchecked_shr(rhs & ($BITS - 1))\n+                self.unchecked_shr(rhs & (Self::BITS - 1))\n             }\n         }\n \n@@ -1847,7 +1865,7 @@ macro_rules! uint_impl {\n                       without modifying the original\"]\n         #[inline(always)]\n         pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n-            (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n+            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n         }\n \n         /// Shifts self right by `rhs` bits.\n@@ -1872,7 +1890,7 @@ macro_rules! uint_impl {\n                       without modifying the original\"]\n         #[inline(always)]\n         pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n-            (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n+            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n         }\n \n         /// Raises self to the power of `exp`, using exponentiation by squaring."}, {"sha": "f0fcdf0d5a0cd7a59deffae657c8d286025810cd", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 78, "deletions": 33, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -111,10 +111,18 @@ impl Step for Std {\n         let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n         if compiler_to_use != compiler {\n             builder.ensure(Std::new(compiler_to_use, target));\n-            builder.info(&format!(\n-                \"Uplifting stage1 library ({} -> {})\",\n-                compiler_to_use.host, target\n-            ));\n+            let msg = if compiler_to_use.host == target {\n+                format!(\n+                    \"Uplifting library (stage{} -> stage{})\",\n+                    compiler_to_use.stage, compiler.stage\n+                )\n+            } else {\n+                format!(\n+                    \"Uplifting library (stage{}:{} -> stage{}:{})\",\n+                    compiler_to_use.stage, compiler_to_use.host, compiler.stage, target\n+                )\n+            };\n+            builder.info(&msg);\n \n             // Even if we're not building std this stage, the new sysroot must\n             // still contain the third party objects needed by various targets.\n@@ -134,13 +142,23 @@ impl Step for Std {\n             cargo.arg(\"-p\").arg(krate);\n         }\n \n-        builder.info(&format!(\n-            \"Building{} stage{} library artifacts ({} -> {})\",\n-            crate_description(&self.crates),\n-            compiler.stage,\n-            &compiler.host,\n-            target,\n-        ));\n+        let msg = if compiler.host == target {\n+            format!(\n+                \"Building{} stage{} library artifacts ({}) \",\n+                crate_description(&self.crates),\n+                compiler.stage,\n+                compiler.host\n+            )\n+        } else {\n+            format!(\n+                \"Building{} stage{} library artifacts ({} -> {})\",\n+                crate_description(&self.crates),\n+                compiler.stage,\n+                compiler.host,\n+                target,\n+            )\n+        };\n+        builder.info(&msg);\n         run_cargo(\n             builder,\n             cargo,\n@@ -438,10 +456,6 @@ impl Step for StdLink {\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n-        builder.info(&format!(\n-            \"Copying stage{} library from stage{} ({} -> {} / {})\",\n-            target_compiler.stage, compiler.stage, &compiler.host, target_compiler.host, target\n-        ));\n         let libdir = builder.sysroot_libdir(target_compiler, target);\n         let hostdir = builder.sysroot_libdir(target_compiler, compiler.host);\n         add_to_sysroot(builder, &libdir, &hostdir, &libstd_stamp(builder, compiler, target));\n@@ -715,8 +729,22 @@ impl Step for Rustc {\n         let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n         if compiler_to_use != compiler {\n             builder.ensure(Rustc::new(compiler_to_use, target));\n-            builder\n-                .info(&format!(\"Uplifting stage1 rustc ({} -> {})\", builder.config.build, target));\n+            let msg = if compiler_to_use.host == target {\n+                format!(\n+                    \"Uplifting rustc (stage{} -> stage{})\",\n+                    compiler_to_use.stage,\n+                    compiler.stage + 1\n+                )\n+            } else {\n+                format!(\n+                    \"Uplifting rustc (stage{}:{} -> stage{}:{})\",\n+                    compiler_to_use.stage,\n+                    compiler_to_use.host,\n+                    compiler.stage + 1,\n+                    target\n+                )\n+            };\n+            builder.info(&msg);\n             builder.ensure(RustcLink::from_rustc(self, compiler_to_use));\n             return;\n         }\n@@ -810,13 +838,24 @@ impl Step for Rustc {\n             cargo.arg(\"-p\").arg(krate);\n         }\n \n-        builder.info(&format!(\n-            \"Building{} stage{} compiler artifacts ({} -> {})\",\n-            crate_description(&self.crates),\n-            compiler.stage,\n-            &compiler.host,\n-            target,\n-        ));\n+        let msg = if compiler.host == target {\n+            format!(\n+                \"Building{} compiler artifacts (stage{} -> stage{})\",\n+                crate_description(&self.crates),\n+                compiler.stage,\n+                compiler.stage + 1\n+            )\n+        } else {\n+            format!(\n+                \"Building{} compiler artifacts (stage{}:{} -> stage{}:{})\",\n+                crate_description(&self.crates),\n+                compiler.stage,\n+                compiler.host,\n+                compiler.stage + 1,\n+                target,\n+            )\n+        };\n+        builder.info(&msg);\n         run_cargo(\n             builder,\n             cargo,\n@@ -1000,10 +1039,6 @@ impl Step for RustcLink {\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n-        builder.info(&format!(\n-            \"Copying stage{} rustc from stage{} ({} -> {} / {})\",\n-            target_compiler.stage, compiler.stage, &compiler.host, target_compiler.host, target\n-        ));\n         add_to_sysroot(\n             builder,\n             &builder.sysroot_libdir(target_compiler, target),\n@@ -1077,10 +1112,15 @@ impl Step for CodegenBackend {\n \n         let tmp_stamp = out_dir.join(\".tmp.stamp\");\n \n-        builder.info(&format!(\n-            \"Building stage{} codegen backend {} ({} -> {})\",\n-            compiler.stage, backend, &compiler.host, target\n-        ));\n+        let msg = if compiler.host == target {\n+            format!(\"Building stage{} codegen backend {}\", compiler.stage, backend)\n+        } else {\n+            format!(\n+                \"Building stage{} codegen backend {} ({} -> {})\",\n+                compiler.stage, backend, compiler.host, target\n+            )\n+        };\n+        builder.info(&msg);\n         let files = run_cargo(builder, cargo, vec![], &tmp_stamp, vec![], false, false);\n         if builder.config.dry_run() {\n             return;\n@@ -1386,7 +1426,12 @@ impl Step for Assemble {\n \n         let stage = target_compiler.stage;\n         let host = target_compiler.host;\n-        builder.info(&format!(\"Assembling stage{} compiler ({})\", stage, host));\n+        let msg = if build_compiler.host == host {\n+            format!(\"Assembling stage{} compiler\", stage)\n+        } else {\n+            format!(\"Assembling stage{} compiler ({})\", stage, host)\n+        };\n+        builder.info(&msg);\n \n         // Link in all dylibs to the libdir\n         let stamp = librustc_stamp(builder, build_compiler, target_compiler.host);"}, {"sha": "d30532ef3c658756ad5f83cfc3040d008b112ea8", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -33,6 +33,44 @@ struct ToolBuild {\n     allow_features: &'static str,\n }\n \n+fn tooling_output(\n+    mode: Mode,\n+    tool: &str,\n+    build_stage: u32,\n+    host: &TargetSelection,\n+    target: &TargetSelection,\n+) -> String {\n+    match mode {\n+        // depends on compiler stage, different to host compiler\n+        Mode::ToolRustc => {\n+            if host == target {\n+                format!(\"Building tool {} (stage{} -> stage{})\", tool, build_stage, build_stage + 1)\n+            } else {\n+                format!(\n+                    \"Building tool {} (stage{}:{} -> stage{}:{})\",\n+                    tool,\n+                    build_stage,\n+                    host,\n+                    build_stage + 1,\n+                    target\n+                )\n+            }\n+        }\n+        // doesn't depend on compiler, same as host compiler\n+        Mode::ToolStd => {\n+            if host == target {\n+                format!(\"Building tool {} (stage{})\", tool, build_stage)\n+            } else {\n+                format!(\n+                    \"Building tool {} (stage{}:{} -> stage{}:{})\",\n+                    tool, build_stage, host, build_stage, target\n+                )\n+            }\n+        }\n+        _ => format!(\"Building tool {} (stage{})\", tool, build_stage),\n+    }\n+}\n+\n impl Step for ToolBuild {\n     type Output = Option<PathBuf>;\n \n@@ -74,8 +112,14 @@ impl Step for ToolBuild {\n         if !self.allow_features.is_empty() {\n             cargo.allow_features(self.allow_features);\n         }\n-\n-        builder.info(&format!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target));\n+        let msg = tooling_output(\n+            self.mode,\n+            self.tool,\n+            self.compiler.stage,\n+            &self.compiler.host,\n+            &self.target,\n+        );\n+        builder.info(&msg);\n         let mut duplicates = Vec::new();\n         let is_expected = compile::stream_cargo(builder, cargo, vec![], &mut |msg| {\n             // Only care about big things like the RLS/Cargo for now\n@@ -562,10 +606,14 @@ impl Step for Rustdoc {\n             features.as_slice(),\n         );\n \n-        builder.info(&format!(\n-            \"Building rustdoc for stage{} ({})\",\n-            target_compiler.stage, target_compiler.host\n-        ));\n+        let msg = tooling_output(\n+            Mode::ToolRustc,\n+            \"rustdoc\",\n+            build_compiler.stage,\n+            &self.compiler.host,\n+            &target,\n+        );\n+        builder.info(&msg);\n         builder.run(&mut cargo.into());\n \n         // Cargo adds a number of paths to the dylib search path on windows, which results in"}, {"sha": "6d289eb996de701705fee3dcc587cec7cfb7c259", "filename": "src/librustdoc/lint.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Flibrustdoc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Flibrustdoc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flint.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -194,7 +194,11 @@ pub(crate) fn register_lints(_sess: &Session, lint_store: &mut LintStore) {\n         true,\n         \"rustdoc::all\",\n         Some(\"rustdoc\"),\n-        RUSTDOC_LINTS.iter().map(|&lint| LintId::of(lint)).collect(),\n+        RUSTDOC_LINTS\n+            .iter()\n+            .filter(|lint| lint.feature_gate.is_none()) // only include stable lints\n+            .map(|&lint| LintId::of(lint))\n+            .collect(),\n     );\n     for lint in &*RUSTDOC_LINTS {\n         let name = lint.name_lower();"}, {"sha": "890b3e8d67f7a9e7a8f9378adfb843aec9bb0823", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'tcx> Stripper<'a, 'tcx> {\n \n     /// In case `i` is a non-hidden impl block, then we special-case it by changing the value\n     /// of `is_in_hidden_item` to `true` because the impl children inherit its visibility.\n-    fn recurse_in_impl(&mut self, i: Item) -> Item {\n+    fn recurse_in_impl_or_exported_macro(&mut self, i: Item) -> Item {\n         let prev = mem::replace(&mut self.is_in_hidden_item, false);\n         let ret = self.fold_item_recur(i);\n         self.is_in_hidden_item = prev;\n@@ -73,9 +73,17 @@ impl<'a, 'tcx> Stripper<'a, 'tcx> {\n impl<'a, 'tcx> DocFolder for Stripper<'a, 'tcx> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         let has_doc_hidden = i.attrs.lists(sym::doc).has_word(sym::hidden);\n-        let is_impl = matches!(*i.kind, clean::ImplItem(..));\n+        let is_impl_or_exported_macro = match *i.kind {\n+            clean::ImplItem(..) => true,\n+            // If the macro has the `#[macro_export]` attribute, it means it's accessible at the\n+            // crate level so it should be handled differently.\n+            clean::MacroItem(..) => {\n+                i.attrs.other_attrs.iter().any(|attr| attr.has_name(sym::macro_export))\n+            }\n+            _ => false,\n+        };\n         let mut is_hidden = has_doc_hidden;\n-        if !is_impl {\n+        if !is_impl_or_exported_macro {\n             is_hidden = self.is_in_hidden_item || has_doc_hidden;\n             if !is_hidden && i.inline_stmt_id.is_none() {\n                 // We don't need to check if it's coming from a reexport since the reexport itself was\n@@ -92,8 +100,8 @@ impl<'a, 'tcx> DocFolder for Stripper<'a, 'tcx> {\n             if self.update_retained {\n                 self.retained.insert(i.item_id);\n             }\n-            return Some(if is_impl {\n-                self.recurse_in_impl(i)\n+            return Some(if is_impl_or_exported_macro {\n+                self.recurse_in_impl_or_exported_macro(i)\n             } else {\n                 self.set_is_in_hidden_item_and_fold(false, i)\n             });"}, {"sha": "461add9f5085370ff857c06a15211eda81235a24", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1 +1 @@\n-7e253a7fb2e2e050021fed32da6fa2ec7bcea0fb\n+f715e430aac0de131e2ad21804013ea405722a66"}, {"sha": "ed3dd741a8be0fe64f6bd107e6c58063b65c9583", "filename": "src/tools/miri/src/helpers.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -478,6 +478,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 } else if matches!(v.layout.fields, FieldsShape::Union(..)) {\n                     // A (non-frozen) union. We fall back to whatever the type says.\n                     (self.unsafe_cell_action)(v)\n+                } else if matches!(v.layout.ty.kind(), ty::Dynamic(_, _, ty::DynStar)) {\n+                    // This needs to read the vtable pointer to proceed type-driven, but we don't\n+                    // want to reentrantly read from memory here.\n+                    (self.unsafe_cell_action)(v)\n                 } else {\n                     // We want to not actually read from memory for this visit. So, before\n                     // walking this value, we have to make sure it is not a"}, {"sha": "f64f216520f00244ad8f8a9e0887e9355bc0c5b2", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -13,6 +13,7 @@\n #![allow(\n     clippy::collapsible_else_if,\n     clippy::collapsible_if,\n+    clippy::if_same_then_else,\n     clippy::comparison_chain,\n     clippy::enum_variant_names,\n     clippy::field_reassign_with_default,"}, {"sha": "d68b4b8dfc675bff6f1387c9cb29deaa5074c851", "filename": "src/tools/miri/tests/fail/branchless-select-i128-pointer.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbranchless-select-i128-pointer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbranchless-select-i128-pointer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbranchless-select-i128-pointer.stderr?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1,12 +1,12 @@\n-error: Undefined Behavior: constructing invalid value: encountered a dangling reference (address $HEX is unallocated)\n+error: Undefined Behavior: constructing invalid value: encountered a dangling reference ($HEX[noalloc] has no provenance)\n   --> $DIR/branchless-select-i128-pointer.rs:LL:CC\n    |\n LL | /             transmute::<_, &str>(\n LL | |\n LL | |                 !mask & transmute::<_, TwoPtrs>(\"false !\")\n LL | |                     | mask & transmute::<_, TwoPtrs>(\"true !\"),\n LL | |             )\n-   | |_____________^ constructing invalid value: encountered a dangling reference (address $HEX is unallocated)\n+   | |_____________^ constructing invalid value: encountered a dangling reference ($HEX[noalloc] has no provenance)\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "fc3a9f344638f96d07fe6688bb5a040de653d95a", "filename": "src/tools/miri/tests/fail/validity/dangling_ref1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fvalidity%2Fdangling_ref1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fvalidity%2Fdangling_ref1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fvalidity%2Fdangling_ref1.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -3,5 +3,5 @@\n use std::mem;\n \n fn main() {\n-    let _x: &i32 = unsafe { mem::transmute(16usize) }; //~ ERROR: encountered a dangling reference (address 0x10 is unallocated)\n+    let _x: &i32 = unsafe { mem::transmute(16usize) }; //~ ERROR: encountered a dangling reference\n }"}, {"sha": "830ab9ca501d8e6ae12c35e364eec41c7f0f2b74", "filename": "src/tools/miri/tests/fail/validity/dangling_ref1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fvalidity%2Fdangling_ref1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fvalidity%2Fdangling_ref1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fvalidity%2Fdangling_ref1.stderr?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: constructing invalid value: encountered a dangling reference (address 0x10 is unallocated)\n+error: Undefined Behavior: constructing invalid value: encountered a dangling reference (0x10[noalloc] has no provenance)\n   --> $DIR/dangling_ref1.rs:LL:CC\n    |\n LL |     let _x: &i32 = unsafe { mem::transmute(16usize) };\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (address 0x10 is unallocated)\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (0x10[noalloc] has no provenance)\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "1fac16352a448f9a9cfe388dc3c15f826ec442f6", "filename": "src/tools/miri/tests/pass/dyn-star.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdyn-star.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdyn-star.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdyn-star.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -0,0 +1,119 @@\n+#![feature(dyn_star)]\n+#![allow(incomplete_features)]\n+#![feature(custom_inner_attributes)]\n+// rustfmt destroys `dyn* Trait` syntax\n+#![rustfmt::skip]\n+\n+use std::fmt::{Debug, Display};\n+\n+fn main() {\n+    make_dyn_star();\n+    method();\n+    box_();\n+    dispatch_on_pin_mut();\n+    dyn_star_to_dyn();\n+    dyn_to_dyn_star();\n+}\n+\n+fn dyn_star_to_dyn() {\n+    let x: dyn* Debug = &42;\n+    let x = Box::new(x) as Box<dyn Debug>;\n+    assert_eq!(\"42\", format!(\"{x:?}\"));\n+}\n+\n+fn dyn_to_dyn_star() {\n+    let x: Box<dyn Debug> = Box::new(42);\n+    let x = &x as dyn* Debug;\n+    assert_eq!(\"42\", format!(\"{x:?}\"));\n+}\n+\n+fn make_dyn_star() {\n+    fn make_dyn_star_coercion(i: usize) {\n+        let _dyn_i: dyn* Debug = i;\n+    }\n+\n+    fn make_dyn_star_explicit(i: usize) {\n+        let _dyn_i: dyn* Debug = i as dyn* Debug;\n+    }\n+\n+    make_dyn_star_coercion(42);\n+    make_dyn_star_explicit(42);\n+}\n+\n+fn method() {\n+    trait Foo {\n+        fn get(&self) -> usize;\n+    }\n+    \n+    impl Foo for usize {\n+        fn get(&self) -> usize {\n+            *self\n+        }\n+    }\n+    \n+    fn invoke_dyn_star(i: dyn* Foo) -> usize {\n+        i.get()\n+    }\n+    \n+    fn make_and_invoke_dyn_star(i: usize) -> usize {\n+        let dyn_i: dyn* Foo = i;\n+        invoke_dyn_star(dyn_i)\n+    }\n+    \n+    assert_eq!(make_and_invoke_dyn_star(42), 42);\n+}\n+\n+fn box_() {\n+    fn make_dyn_star() -> dyn* Display {\n+        Box::new(42) as dyn* Display\n+    }\n+    \n+    let x = make_dyn_star();\n+    assert_eq!(format!(\"{x}\"), \"42\");\n+}\n+\n+fn dispatch_on_pin_mut() {\n+    use std::future::Future;\n+\n+    async fn foo(f: dyn* Future<Output = i32>) {\n+        println!(\"dispatch_on_pin_mut: value: {}\", f.await);\n+    }\n+\n+    async fn async_main() {\n+        foo(Box::pin(async { 1 })).await\n+    }\n+\n+    // ------------------------------------------------------------------------- //\n+    // Implementation Details Below...\n+\n+    use std::pin::Pin;\n+    use std::task::*;\n+\n+    pub fn noop_waker() -> Waker {\n+        let raw = RawWaker::new(std::ptr::null(), &NOOP_WAKER_VTABLE);\n+\n+        // SAFETY: the contracts for RawWaker and RawWakerVTable are upheld\n+        unsafe { Waker::from_raw(raw) }\n+    }\n+\n+    const NOOP_WAKER_VTABLE: RawWakerVTable = RawWakerVTable::new(noop_clone, noop, noop, noop);\n+\n+    unsafe fn noop_clone(_p: *const ()) -> RawWaker {\n+        RawWaker::new(std::ptr::null(), &NOOP_WAKER_VTABLE)\n+    }\n+\n+    unsafe fn noop(_p: *const ()) {}\n+\n+    let mut fut = async_main();\n+\n+    // Poll loop, just to test the future...\n+    let waker = noop_waker();\n+    let ctx = &mut Context::from_waker(&waker);\n+\n+    loop {\n+        match unsafe { Pin::new_unchecked(&mut fut).poll(ctx) } {\n+            Poll::Pending => {}\n+            Poll::Ready(()) => break,\n+        }\n+    }\n+}"}, {"sha": "e94427ee30531b4cbc8bc2786a635710e1dba177", "filename": "src/tools/miri/tests/pass/dyn-star.stdout", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdyn-star.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdyn-star.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdyn-star.stdout?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -0,0 +1 @@\n+dispatch_on_pin_mut: value: 1"}, {"sha": "ec197767259d4e6d57e33f8b9a3edb4ddd14d572", "filename": "src/tools/rust-analyzer/Cargo.lock", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FCargo.lock?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -711,6 +711,7 @@ dependencies = [\n  \"limit\",\n  \"memchr\",\n  \"once_cell\",\n+ \"oorandom\",\n  \"parser\",\n  \"profile\",\n  \"rayon\",\n@@ -932,9 +933,9 @@ dependencies = [\n \n [[package]]\n name = \"lsp-types\"\n-version = \"0.93.2\"\n+version = \"0.94.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9be6e9c7e2d18f651974370d7aff703f9513e0df6e464fd795660edc77e6ca51\"\n+checksum = \"0b63735a13a1f9cd4f4835223d828ed9c2e35c8c5e61837774399f558b6a1237\"\n dependencies = [\n  \"bitflags\",\n  \"serde\",\n@@ -1173,6 +1174,7 @@ dependencies = [\n  \"limit\",\n  \"rustc-ap-rustc_lexer\",\n  \"sourcegen\",\n+ \"stdx\",\n ]\n \n [[package]]"}, {"sha": "333f03ce2ffe5d6dfeb9c200598ce5d7127c8780", "filename": "src/tools/rust-analyzer/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FCargo.toml?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -74,3 +74,5 @@ toolchain = { path = \"./crates/toolchain\", version = \"0.0.0\" }\n tt = { path = \"./crates/tt\", version = \"0.0.0\" }\n vfs-notify = { path = \"./crates/vfs-notify\", version = \"0.0.0\" }\n vfs = { path = \"./crates/vfs\", version = \"0.0.0\" }\n+# non-local crates\n+smallvec = { version = \"1.10.0\", features = [\"const_new\", \"union\", \"const_generics\"] }"}, {"sha": "31d4018d2b6ab6e863c89c7f2012b96863ad342a", "filename": "src/tools/rust-analyzer/crates/hir-def/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -27,7 +27,7 @@ itertools = \"0.10.5\"\n la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n once_cell = \"1.17.0\"\n rustc-hash = \"1.1.0\"\n-smallvec = \"1.10.0\"\n+smallvec.workspace = true\n tracing = \"0.1.35\"\n \n rustc_abi = { version = \"0.0.20221221\", package = \"hkalbasi-rustc-ap-rustc_abi\", default-features = false }"}, {"sha": "9bc1c54a3c6412eb4531a9aa48decadbf2448bf4", "filename": "src/tools/rust-analyzer/crates/hir-def/src/adt.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fadt.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -2,9 +2,10 @@\n \n use std::sync::Arc;\n \n-use crate::tt::{Delimiter, DelimiterKind, Leaf, Subtree, TokenTree};\n use base_db::CrateId;\n+use cfg::CfgOptions;\n use either::Either;\n+\n use hir_expand::{\n     name::{AsName, Name},\n     HirFileId, InFile,\n@@ -24,12 +25,12 @@ use crate::{\n     src::HasChildSource,\n     src::HasSource,\n     trace::Trace,\n+    tt::{Delimiter, DelimiterKind, Leaf, Subtree, TokenTree},\n     type_ref::TypeRef,\n     visibility::RawVisibility,\n     EnumId, LocalEnumVariantId, LocalFieldId, LocalModuleId, Lookup, ModuleId, StructId, UnionId,\n     VariantId,\n };\n-use cfg::CfgOptions;\n \n /// Note that we use `StructData` for unions as well!\n #[derive(Debug, Clone, PartialEq, Eq)]"}, {"sha": "8fd9255b8b130e1ea963cfbff333f88d6e462cc7", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body.rs", "status": "modified", "additions": 91, "deletions": 49, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -19,7 +19,7 @@ use la_arena::{Arena, ArenaMap};\n use limit::Limit;\n use profile::Count;\n use rustc_hash::FxHashMap;\n-use syntax::{ast, AstPtr, SyntaxNodePtr};\n+use syntax::{ast, AstPtr, SyntaxNode, SyntaxNodePtr};\n \n use crate::{\n     attr::Attrs,\n@@ -51,7 +51,8 @@ pub struct Expander {\n     def_map: Arc<DefMap>,\n     current_file_id: HirFileId,\n     module: LocalModuleId,\n-    recursion_limit: usize,\n+    /// `recursion_depth == usize::MAX` indicates that the recursion limit has been reached.\n+    recursion_depth: usize,\n }\n \n impl CfgExpander {\n@@ -84,7 +85,7 @@ impl Expander {\n             def_map,\n             current_file_id,\n             module: module.local_id,\n-            recursion_limit: 0,\n+            recursion_depth: 0,\n         }\n     }\n \n@@ -93,47 +94,52 @@ impl Expander {\n         db: &dyn DefDatabase,\n         macro_call: ast::MacroCall,\n     ) -> Result<ExpandResult<Option<(Mark, T)>>, UnresolvedMacro> {\n-        if self.recursion_limit(db).check(self.recursion_limit + 1).is_err() {\n-            cov_mark::hit!(your_stack_belongs_to_me);\n-            return Ok(ExpandResult::only_err(ExpandError::Other(\n-                \"reached recursion limit during macro expansion\".into(),\n-            )));\n+        let mut unresolved_macro_err = None;\n+\n+        let result = self.within_limit(db, |this| {\n+            let macro_call = InFile::new(this.current_file_id, &macro_call);\n+\n+            let resolver =\n+                |path| this.resolve_path_as_macro(db, &path).map(|it| macro_id_to_def_id(db, it));\n+\n+            let mut err = None;\n+            let call_id = match macro_call.as_call_id_with_errors(\n+                db,\n+                this.def_map.krate(),\n+                resolver,\n+                &mut |e| {\n+                    err.get_or_insert(e);\n+                },\n+            ) {\n+                Ok(call_id) => call_id,\n+                Err(resolve_err) => {\n+                    unresolved_macro_err = Some(resolve_err);\n+                    return ExpandResult { value: None, err: None };\n+                }\n+            };\n+            ExpandResult { value: call_id.ok(), err }\n+        });\n+\n+        if let Some(err) = unresolved_macro_err {\n+            Err(err)\n+        } else {\n+            Ok(result)\n         }\n-\n-        let macro_call = InFile::new(self.current_file_id, &macro_call);\n-\n-        let resolver =\n-            |path| self.resolve_path_as_macro(db, &path).map(|it| macro_id_to_def_id(db, it));\n-\n-        let mut err = None;\n-        let call_id =\n-            macro_call.as_call_id_with_errors(db, self.def_map.krate(), resolver, &mut |e| {\n-                err.get_or_insert(e);\n-            })?;\n-        let call_id = match call_id {\n-            Ok(it) => it,\n-            Err(_) => {\n-                return Ok(ExpandResult { value: None, err });\n-            }\n-        };\n-\n-        Ok(self.enter_expand_inner(db, call_id, err))\n     }\n \n     pub fn enter_expand_id<T: ast::AstNode>(\n         &mut self,\n         db: &dyn DefDatabase,\n         call_id: MacroCallId,\n     ) -> ExpandResult<Option<(Mark, T)>> {\n-        self.enter_expand_inner(db, call_id, None)\n+        self.within_limit(db, |_this| ExpandResult::ok(Some(call_id)))\n     }\n \n-    fn enter_expand_inner<T: ast::AstNode>(\n-        &mut self,\n+    fn enter_expand_inner(\n         db: &dyn DefDatabase,\n         call_id: MacroCallId,\n         mut err: Option<ExpandError>,\n-    ) -> ExpandResult<Option<(Mark, T)>> {\n+    ) -> ExpandResult<Option<(HirFileId, SyntaxNode)>> {\n         if err.is_none() {\n             err = db.macro_expand_error(call_id);\n         }\n@@ -154,29 +160,21 @@ impl Expander {\n             }\n         };\n \n-        let node = match T::cast(raw_node) {\n-            Some(it) => it,\n-            None => {\n-                // This can happen without being an error, so only forward previous errors.\n-                return ExpandResult { value: None, err };\n-            }\n-        };\n-\n-        tracing::debug!(\"macro expansion {:#?}\", node.syntax());\n-\n-        self.recursion_limit += 1;\n-        let mark =\n-            Mark { file_id: self.current_file_id, bomb: DropBomb::new(\"expansion mark dropped\") };\n-        self.cfg_expander.hygiene = Hygiene::new(db.upcast(), file_id);\n-        self.current_file_id = file_id;\n-\n-        ExpandResult { value: Some((mark, node)), err }\n+        ExpandResult { value: Some((file_id, raw_node)), err }\n     }\n \n     pub fn exit(&mut self, db: &dyn DefDatabase, mut mark: Mark) {\n         self.cfg_expander.hygiene = Hygiene::new(db.upcast(), mark.file_id);\n         self.current_file_id = mark.file_id;\n-        self.recursion_limit -= 1;\n+        if self.recursion_depth == usize::MAX {\n+            // Recursion limit has been reached somewhere in the macro expansion tree. Reset the\n+            // depth only when we get out of the tree.\n+            if !self.current_file_id.is_macro() {\n+                self.recursion_depth = 0;\n+            }\n+        } else {\n+            self.recursion_depth -= 1;\n+        }\n         mark.bomb.defuse();\n     }\n \n@@ -215,6 +213,50 @@ impl Expander {\n         #[cfg(test)]\n         return Limit::new(std::cmp::min(32, limit));\n     }\n+\n+    fn within_limit<F, T: ast::AstNode>(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        op: F,\n+    ) -> ExpandResult<Option<(Mark, T)>>\n+    where\n+        F: FnOnce(&mut Self) -> ExpandResult<Option<MacroCallId>>,\n+    {\n+        if self.recursion_depth == usize::MAX {\n+            // Recursion limit has been reached somewhere in the macro expansion tree. We should\n+            // stop expanding other macro calls in this tree, or else this may result in\n+            // exponential number of macro expansions, leading to a hang.\n+            //\n+            // The overflow error should have been reported when it occurred (see the next branch),\n+            // so don't return overflow error here to avoid diagnostics duplication.\n+            cov_mark::hit!(overflow_but_not_me);\n+            return ExpandResult::only_err(ExpandError::RecursionOverflowPosioned);\n+        } else if self.recursion_limit(db).check(self.recursion_depth + 1).is_err() {\n+            self.recursion_depth = usize::MAX;\n+            cov_mark::hit!(your_stack_belongs_to_me);\n+            return ExpandResult::only_err(ExpandError::Other(\n+                \"reached recursion limit during macro expansion\".into(),\n+            ));\n+        }\n+\n+        let ExpandResult { value, err } = op(self);\n+        let Some(call_id) = value else {\n+            return ExpandResult { value: None, err };\n+        };\n+\n+        Self::enter_expand_inner(db, call_id, err).map(|value| {\n+            value.and_then(|(new_file_id, node)| {\n+                let node = T::cast(node)?;\n+\n+                self.recursion_depth += 1;\n+                self.cfg_expander.hygiene = Hygiene::new(db.upcast(), new_file_id);\n+                let old_file_id = std::mem::replace(&mut self.current_file_id, new_file_id);\n+                let mark =\n+                    Mark { file_id: old_file_id, bomb: DropBomb::new(\"expansion mark dropped\") };\n+                Some((mark, node))\n+            })\n+        })\n+    }\n }\n \n #[derive(Debug)]"}, {"sha": "04b1c4f01e22a4f0c263d9dc794ae413b986abed", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -624,6 +624,10 @@ impl ExprCollector<'_> {\n                         krate: *krate,\n                     });\n                 }\n+                Some(ExpandError::RecursionOverflowPosioned) => {\n+                    // Recursion limit has been reached in the macro expansion tree, but not in\n+                    // this very macro call. Don't add diagnostics to avoid duplication.\n+                }\n                 Some(err) => {\n                     self.source_map.diagnostics.push(BodyDiagnostic::MacroError {\n                         node: InFile::new(outer_file, syntax_ptr),\n@@ -636,6 +640,8 @@ impl ExprCollector<'_> {\n \n         match res.value {\n             Some((mark, expansion)) => {\n+                // Keep collecting even with expansion errors so we can provide completions and\n+                // other services in incomplete macro expressions.\n                 self.source_map.expansions.insert(macro_call_ptr, self.expander.current_file_id);\n                 let prev_ast_id_map = mem::replace(\n                     &mut self.ast_id_map,"}, {"sha": "edee2c7ff96bfb76809bf91a8a03f77e6bc0234b", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/tests.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Ftests.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -61,6 +61,19 @@ fn main() { n_nuple!(1,2,3); }\n     );\n }\n \n+#[test]\n+fn your_stack_belongs_to_me2() {\n+    cov_mark::check!(overflow_but_not_me);\n+    lower(\n+        r#\"\n+macro_rules! foo {\n+    () => {{ foo!(); foo!(); }}\n+}\n+fn main() { foo!(); }\n+\"#,\n+    );\n+}\n+\n #[test]\n fn recursion_limit() {\n     cov_mark::check!(your_stack_belongs_to_me);"}, {"sha": "d4d3c5ef19a60d84d89e7eea8fbc39c1a8a7ca29", "filename": "src/tools/rust-analyzer/crates/hir-def/src/item_tree/lower.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -659,15 +659,16 @@ fn desugar_future_path(orig: TypeRef) -> Path {\n     let path = path![core::future::Future];\n     let mut generic_args: Vec<_> =\n         std::iter::repeat(None).take(path.segments().len() - 1).collect();\n-    let mut last = GenericArgs::empty();\n     let binding = AssociatedTypeBinding {\n         name: name![Output],\n         args: None,\n         type_ref: Some(orig),\n-        bounds: Vec::new(),\n+        bounds: Box::default(),\n     };\n-    last.bindings.push(binding);\n-    generic_args.push(Some(Interned::new(last)));\n+    generic_args.push(Some(Interned::new(GenericArgs {\n+        bindings: Box::new([binding]),\n+        ..GenericArgs::empty()\n+    })));\n \n     Path::from_known_path(path, generic_args)\n }"}, {"sha": "7a3e8c3b05c911037963737f4d48b19aae9b0b03", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/mbe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1476,7 +1476,7 @@ macro_rules! m {\n /* parse error: expected identifier */\n /* parse error: expected SEMICOLON */\n /* parse error: expected SEMICOLON */\n-/* parse error: expected expression */\n+/* parse error: expected expression, item or let statement */\n fn f() {\n     K::(C(\"0\"));\n }"}, {"sha": "8358a46f0a9142f7db24a5ea143f6553ce6d0cf5", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/mbe/regression.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Fregression.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -830,8 +830,7 @@ macro_rules! rgb_color {\n /* parse error: expected COMMA */\n /* parse error: expected R_ANGLE */\n /* parse error: expected SEMICOLON */\n-/* parse error: expected SEMICOLON */\n-/* parse error: expected expression */\n+/* parse error: expected expression, item or let statement */\n pub fn new() {\n     let _ = 0as u32<<(8+8);\n }\n@@ -848,21 +847,21 @@ pub fn new() {\n //     BLOCK_EXPR@10..31\n //       STMT_LIST@10..31\n //         L_CURLY@10..11 \"{\"\n-//         LET_STMT@11..27\n+//         LET_STMT@11..28\n //           LET_KW@11..14 \"let\"\n //           WILDCARD_PAT@14..15\n //             UNDERSCORE@14..15 \"_\"\n //           EQ@15..16 \"=\"\n-//           CAST_EXPR@16..27\n+//           CAST_EXPR@16..28\n //             LITERAL@16..17\n //               INT_NUMBER@16..17 \"0\"\n //             AS_KW@17..19 \"as\"\n-//             PATH_TYPE@19..27\n-//               PATH@19..27\n-//                 PATH_SEGMENT@19..27\n+//             PATH_TYPE@19..28\n+//               PATH@19..28\n+//                 PATH_SEGMENT@19..28\n //                   NAME_REF@19..22\n //                     IDENT@19..22 \"u32\"\n-//                   GENERIC_ARG_LIST@22..27\n+//                   GENERIC_ARG_LIST@22..28\n //                     L_ANGLE@22..23 \"<\"\n //                     TYPE_ARG@23..27\n //                       DYN_TRAIT_TYPE@23..27\n@@ -877,9 +876,9 @@ pub fn new() {\n //                                     ERROR@25..26\n //                                       INT_NUMBER@25..26 \"8\"\n //                           PLUS@26..27 \"+\"\n-//         EXPR_STMT@27..28\n-//           LITERAL@27..28\n-//             INT_NUMBER@27..28 \"8\"\n+//                     CONST_ARG@27..28\n+//                       LITERAL@27..28\n+//                         INT_NUMBER@27..28 \"8\"\n //         ERROR@28..29\n //           R_PAREN@28..29 \")\"\n //         SEMICOLON@29..30 \";\""}, {"sha": "36d4c36a26894550135d732e08ab3f704ae55f7e", "filename": "src/tools/rust-analyzer/crates/hir-def/src/path.rs", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -38,26 +38,26 @@ impl Display for ImportAlias {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {\n     /// Type based path like `<T>::foo`.\n-    /// Note that paths like `<Type as Trait>::foo` are desugard to `Trait::<Self=Type>::foo`.\n+    /// Note that paths like `<Type as Trait>::foo` are desugared to `Trait::<Self=Type>::foo`.\n     type_anchor: Option<Interned<TypeRef>>,\n     mod_path: Interned<ModPath>,\n-    /// Invariant: the same len as `self.mod_path.segments`\n-    generic_args: Box<[Option<Interned<GenericArgs>>]>,\n+    /// Invariant: the same len as `self.mod_path.segments` or `None` if all segments are `None`.\n+    generic_args: Option<Box<[Option<Interned<GenericArgs>>]>>,\n }\n \n /// Generic arguments to a path segment (e.g. the `i32` in `Option<i32>`). This\n /// also includes bindings of associated types, like in `Iterator<Item = Foo>`.\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct GenericArgs {\n-    pub args: Vec<GenericArg>,\n+    pub args: Box<[GenericArg]>,\n     /// This specifies whether the args contain a Self type as the first\n     /// element. This is the case for path segments like `<T as Trait>`, where\n     /// `T` is actually a type parameter for the path `Trait` specifying the\n     /// Self type. Otherwise, when we have a path `Trait<X, Y>`, the Self type\n     /// is left out.\n     pub has_self_type: bool,\n     /// Associated type bindings like in `Iterator<Item = T>`.\n-    pub bindings: Vec<AssociatedTypeBinding>,\n+    pub bindings: Box<[AssociatedTypeBinding]>,\n     /// Whether these generic args were desugared from `Trait(Arg) -> Output`\n     /// parenthesis notation typically used for the `Fn` traits.\n     pub desugared_from_fn: bool,\n@@ -77,7 +77,7 @@ pub struct AssociatedTypeBinding {\n     /// Bounds for the associated type, like in `Iterator<Item:\n     /// SomeOtherTrait>`. (This is the unstable `associated_type_bounds`\n     /// feature.)\n-    pub bounds: Vec<Interned<TypeBound>>,\n+    pub bounds: Box<[Interned<TypeBound>]>,\n }\n \n /// A single generic argument.\n@@ -102,7 +102,7 @@ impl Path {\n     ) -> Path {\n         let generic_args = generic_args.into();\n         assert_eq!(path.len(), generic_args.len());\n-        Path { type_anchor: None, mod_path: Interned::new(path), generic_args }\n+        Path { type_anchor: None, mod_path: Interned::new(path), generic_args: Some(generic_args) }\n     }\n \n     pub fn kind(&self) -> &PathKind {\n@@ -114,7 +114,14 @@ impl Path {\n     }\n \n     pub fn segments(&self) -> PathSegments<'_> {\n-        PathSegments { segments: self.mod_path.segments(), generic_args: &self.generic_args }\n+        let s = PathSegments {\n+            segments: self.mod_path.segments(),\n+            generic_args: self.generic_args.as_deref(),\n+        };\n+        if let Some(generic_args) = s.generic_args {\n+            assert_eq!(s.segments.len(), generic_args.len());\n+        }\n+        s\n     }\n \n     pub fn mod_path(&self) -> &ModPath {\n@@ -131,13 +138,15 @@ impl Path {\n                 self.mod_path.kind,\n                 self.mod_path.segments()[..self.mod_path.segments().len() - 1].iter().cloned(),\n             )),\n-            generic_args: self.generic_args[..self.generic_args.len() - 1].to_vec().into(),\n+            generic_args: self.generic_args.as_ref().map(|it| it[..it.len() - 1].to_vec().into()),\n         };\n         Some(res)\n     }\n \n     pub fn is_self_type(&self) -> bool {\n-        self.type_anchor.is_none() && *self.generic_args == [None] && self.mod_path.is_Self()\n+        self.type_anchor.is_none()\n+            && self.generic_args.as_deref().is_none()\n+            && self.mod_path.is_Self()\n     }\n }\n \n@@ -149,11 +158,11 @@ pub struct PathSegment<'a> {\n \n pub struct PathSegments<'a> {\n     segments: &'a [Name],\n-    generic_args: &'a [Option<Interned<GenericArgs>>],\n+    generic_args: Option<&'a [Option<Interned<GenericArgs>>]>,\n }\n \n impl<'a> PathSegments<'a> {\n-    pub const EMPTY: PathSegments<'static> = PathSegments { segments: &[], generic_args: &[] };\n+    pub const EMPTY: PathSegments<'static> = PathSegments { segments: &[], generic_args: None };\n     pub fn is_empty(&self) -> bool {\n         self.len() == 0\n     }\n@@ -167,26 +176,29 @@ impl<'a> PathSegments<'a> {\n         self.get(self.len().checked_sub(1)?)\n     }\n     pub fn get(&self, idx: usize) -> Option<PathSegment<'a>> {\n-        assert_eq!(self.segments.len(), self.generic_args.len());\n         let res = PathSegment {\n             name: self.segments.get(idx)?,\n-            args_and_bindings: self.generic_args.get(idx).unwrap().as_ref().map(|it| &**it),\n+            args_and_bindings: self.generic_args.and_then(|it| it.get(idx)?.as_deref()),\n         };\n         Some(res)\n     }\n     pub fn skip(&self, len: usize) -> PathSegments<'a> {\n-        assert_eq!(self.segments.len(), self.generic_args.len());\n-        PathSegments { segments: &self.segments[len..], generic_args: &self.generic_args[len..] }\n+        PathSegments {\n+            segments: &self.segments.get(len..).unwrap_or(&[]),\n+            generic_args: self.generic_args.and_then(|it| it.get(len..)),\n+        }\n     }\n     pub fn take(&self, len: usize) -> PathSegments<'a> {\n-        assert_eq!(self.segments.len(), self.generic_args.len());\n-        PathSegments { segments: &self.segments[..len], generic_args: &self.generic_args[..len] }\n+        PathSegments {\n+            segments: &self.segments.get(..len).unwrap_or(&self.segments),\n+            generic_args: self.generic_args.map(|it| it.get(..len).unwrap_or(it)),\n+        }\n     }\n     pub fn iter(&self) -> impl Iterator<Item = PathSegment<'a>> {\n-        self.segments.iter().zip(self.generic_args.iter()).map(|(name, args)| PathSegment {\n-            name,\n-            args_and_bindings: args.as_ref().map(|it| &**it),\n-        })\n+        self.segments\n+            .iter()\n+            .zip(self.generic_args.into_iter().flatten().chain(iter::repeat(&None)))\n+            .map(|(name, args)| PathSegment { name, args_and_bindings: args.as_deref() })\n     }\n }\n \n@@ -200,9 +212,9 @@ impl GenericArgs {\n \n     pub(crate) fn empty() -> GenericArgs {\n         GenericArgs {\n-            args: Vec::new(),\n+            args: Box::default(),\n             has_self_type: false,\n-            bindings: Vec::new(),\n+            bindings: Box::default(),\n             desugared_from_fn: false,\n         }\n     }\n@@ -213,7 +225,7 @@ impl From<Name> for Path {\n         Path {\n             type_anchor: None,\n             mod_path: Interned::new(ModPath::from_segments(PathKind::Plain, iter::once(name))),\n-            generic_args: Box::new([None]),\n+            generic_args: None,\n         }\n     }\n }"}, {"sha": "c85a11db6d1947fa6bdf0f8e11a81eeed8fb6e73", "filename": "src/tools/rust-analyzer/crates/hir-def/src/path/lower.rs", "status": "modified", "additions": 56, "deletions": 28, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1,5 +1,7 @@\n //! Transforms syntax into `Path` objects, ideally with accounting for hygiene\n \n+use std::iter;\n+\n use crate::type_ref::ConstScalarOrPath;\n \n use either::Either;\n@@ -45,8 +47,11 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx<'_>) -> Option<Path\n                                 )\n                             })\n                             .map(Interned::new);\n+                        if let Some(_) = args {\n+                            generic_args.resize(segments.len(), None);\n+                            generic_args.push(args);\n+                        }\n                         segments.push(name);\n-                        generic_args.push(args)\n                     }\n                     Either::Right(crate_id) => {\n                         kind = PathKind::DollarCrate(crate_id);\n@@ -56,7 +61,6 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx<'_>) -> Option<Path\n             }\n             ast::PathSegmentKind::SelfTypeKw => {\n                 segments.push(name![Self]);\n-                generic_args.push(None)\n             }\n             ast::PathSegmentKind::Type { type_ref, trait_ref } => {\n                 assert!(path.qualifier().is_none()); // this can only occur at the first segment\n@@ -77,18 +81,33 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx<'_>) -> Option<Path\n                         kind = mod_path.kind;\n \n                         segments.extend(mod_path.segments().iter().cloned().rev());\n-                        generic_args.extend(Vec::from(path_generic_args).into_iter().rev());\n+                        if let Some(path_generic_args) = path_generic_args {\n+                            generic_args.resize(segments.len() - num_segments, None);\n+                            generic_args.extend(Vec::from(path_generic_args).into_iter().rev());\n+                        } else {\n+                            generic_args.resize(segments.len(), None);\n+                        }\n+\n+                        let self_type = GenericArg::Type(self_type);\n \n                         // Insert the type reference (T in the above example) as Self parameter for the trait\n-                        let last_segment =\n-                            generic_args.iter_mut().rev().nth(num_segments.saturating_sub(1))?;\n-                        let mut args_inner = match last_segment {\n-                            Some(it) => it.as_ref().clone(),\n-                            None => GenericArgs::empty(),\n-                        };\n-                        args_inner.has_self_type = true;\n-                        args_inner.args.insert(0, GenericArg::Type(self_type));\n-                        *last_segment = Some(Interned::new(args_inner));\n+                        let last_segment = generic_args.get_mut(segments.len() - num_segments)?;\n+                        *last_segment = Some(Interned::new(match last_segment.take() {\n+                            Some(it) => GenericArgs {\n+                                args: iter::once(self_type)\n+                                    .chain(it.args.iter().cloned())\n+                                    .collect(),\n+\n+                                has_self_type: true,\n+                                bindings: it.bindings.clone(),\n+                                desugared_from_fn: it.desugared_from_fn,\n+                            },\n+                            None => GenericArgs {\n+                                args: Box::new([self_type]),\n+                                has_self_type: true,\n+                                ..GenericArgs::empty()\n+                            },\n+                        }));\n                     }\n                 }\n             }\n@@ -115,7 +134,10 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx<'_>) -> Option<Path\n         };\n     }\n     segments.reverse();\n-    generic_args.reverse();\n+    if !generic_args.is_empty() {\n+        generic_args.resize(segments.len(), None);\n+        generic_args.reverse();\n+    }\n \n     if segments.is_empty() && kind == PathKind::Plain && type_anchor.is_none() {\n         // plain empty paths don't exist, this means we got a single `self` segment as our path\n@@ -135,7 +157,11 @@ pub(super) fn lower_path(mut path: ast::Path, ctx: &LowerCtx<'_>) -> Option<Path\n     }\n \n     let mod_path = Interned::new(ModPath::from_segments(kind, segments));\n-    return Some(Path { type_anchor, mod_path, generic_args: generic_args.into() });\n+    return Some(Path {\n+        type_anchor,\n+        mod_path,\n+        generic_args: if generic_args.is_empty() { None } else { Some(generic_args.into()) },\n+    });\n \n     fn qualifier(path: &ast::Path) -> Option<ast::Path> {\n         if let Some(q) = path.qualifier() {\n@@ -174,7 +200,7 @@ pub(super) fn lower_generic_args(\n                             .map(|it| Interned::new(TypeBound::from_ast(lower_ctx, it)))\n                             .collect()\n                     } else {\n-                        Vec::new()\n+                        Box::default()\n                     };\n                     bindings.push(AssociatedTypeBinding { name, args, type_ref, bounds });\n                 }\n@@ -195,7 +221,12 @@ pub(super) fn lower_generic_args(\n     if args.is_empty() && bindings.is_empty() {\n         return None;\n     }\n-    Some(GenericArgs { args, has_self_type: false, bindings, desugared_from_fn: false })\n+    Some(GenericArgs {\n+        args: args.into_boxed_slice(),\n+        has_self_type: false,\n+        bindings: bindings.into_boxed_slice(),\n+        desugared_from_fn: false,\n+    })\n }\n \n /// Collect `GenericArgs` from the parts of a fn-like path, i.e. `Fn(X, Y)\n@@ -205,33 +236,30 @@ fn lower_generic_args_from_fn_path(\n     params: Option<ast::ParamList>,\n     ret_type: Option<ast::RetType>,\n ) -> Option<GenericArgs> {\n-    let mut args = Vec::new();\n-    let mut bindings = Vec::new();\n     let params = params?;\n     let mut param_types = Vec::new();\n     for param in params.params() {\n         let type_ref = TypeRef::from_ast_opt(ctx, param.ty());\n         param_types.push(type_ref);\n     }\n-    let arg = GenericArg::Type(TypeRef::Tuple(param_types));\n-    args.push(arg);\n-    if let Some(ret_type) = ret_type {\n+    let args = Box::new([GenericArg::Type(TypeRef::Tuple(param_types))]);\n+    let bindings = if let Some(ret_type) = ret_type {\n         let type_ref = TypeRef::from_ast_opt(ctx, ret_type.ty());\n-        bindings.push(AssociatedTypeBinding {\n+        Box::new([AssociatedTypeBinding {\n             name: name![Output],\n             args: None,\n             type_ref: Some(type_ref),\n-            bounds: Vec::new(),\n-        });\n+            bounds: Box::default(),\n+        }])\n     } else {\n         // -> ()\n         let type_ref = TypeRef::Tuple(Vec::new());\n-        bindings.push(AssociatedTypeBinding {\n+        Box::new([AssociatedTypeBinding {\n             name: name![Output],\n             args: None,\n             type_ref: Some(type_ref),\n-            bounds: Vec::new(),\n-        });\n-    }\n+            bounds: Box::default(),\n+        }])\n+    };\n     Some(GenericArgs { args, has_self_type: false, bindings, desugared_from_fn: true })\n }"}, {"sha": "2d45c8c8da1a5ba56db35223a4a59abf06bf0d6f", "filename": "src/tools/rust-analyzer/crates/hir-def/src/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fpretty.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -71,7 +71,7 @@ pub(crate) fn print_generic_args(generics: &GenericArgs, buf: &mut dyn Write) ->\n         first = false;\n         print_generic_arg(arg, buf)?;\n     }\n-    for binding in &generics.bindings {\n+    for binding in generics.bindings.iter() {\n         if !first {\n             write!(buf, \", \")?;\n         }"}, {"sha": "9652b01b91bf6bd8f593560ea332904d98f307ca", "filename": "src/tools/rust-analyzer/crates/hir-def/src/type_ref.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Ftype_ref.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -292,7 +292,7 @@ impl TypeRef {\n             }\n             for segment in path.segments().iter() {\n                 if let Some(args_and_bindings) = segment.args_and_bindings {\n-                    for arg in &args_and_bindings.args {\n+                    for arg in args_and_bindings.args.iter() {\n                         match arg {\n                             crate::path::GenericArg::Type(type_ref) => {\n                                 go(type_ref, f);\n@@ -301,11 +301,11 @@ impl TypeRef {\n                             | crate::path::GenericArg::Lifetime(_) => {}\n                         }\n                     }\n-                    for binding in &args_and_bindings.bindings {\n+                    for binding in args_and_bindings.bindings.iter() {\n                         if let Some(type_ref) = &binding.type_ref {\n                             go(type_ref, f);\n                         }\n-                        for bound in &binding.bounds {\n+                        for bound in binding.bounds.iter() {\n                             match bound.as_ref() {\n                                 TypeBound::Path(path, _) | TypeBound::ForLifetime(_, path) => {\n                                     go_path(path, f)"}, {"sha": "5c684be03cf246c21ca2f6e9dfc86593a6739914", "filename": "src/tools/rust-analyzer/crates/hir-expand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2FCargo.toml?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -21,7 +21,7 @@ itertools = \"0.10.5\"\n hashbrown = { version = \"0.12.1\", features = [\n     \"inline-more\",\n ], default-features = false }\n-smallvec = { version = \"1.10.0\", features = [\"const_new\"] }\n+smallvec.workspace = true\n \n # local deps\n stdx.workspace = true"}, {"sha": "a52716cc02c2589fa459b1d6015e8b1c59747ed8", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -55,6 +55,7 @@ pub type ExpandResult<T> = ValueResult<T, ExpandError>;\n pub enum ExpandError {\n     UnresolvedProcMacro(CrateId),\n     Mbe(mbe::ExpandError),\n+    RecursionOverflowPosioned,\n     Other(Box<str>),\n }\n \n@@ -69,6 +70,9 @@ impl fmt::Display for ExpandError {\n         match self {\n             ExpandError::UnresolvedProcMacro(_) => f.write_str(\"unresolved proc-macro\"),\n             ExpandError::Mbe(it) => it.fmt(f),\n+            ExpandError::RecursionOverflowPosioned => {\n+                f.write_str(\"overflow expanding the original macro\")\n+            }\n             ExpandError::Other(it) => f.write_str(it),\n         }\n     }"}, {"sha": "a8b8d5222e49c58478c8e272ce8635f9d180191a", "filename": "src/tools/rust-analyzer/crates/hir-ty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -16,7 +16,7 @@ cov-mark = \"2.0.0-pre.1\"\n itertools = \"0.10.5\"\n arrayvec = \"0.7.2\"\n bitflags = \"1.3.2\"\n-smallvec = \"1.10.0\"\n+smallvec.workspace = true\n ena = \"0.14.0\"\n tracing = \"0.1.35\"\n rustc-hash = \"1.1.0\""}, {"sha": "b22064d8c42e49be63b872eeb35733b276c34256", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/display.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1419,7 +1419,7 @@ impl HirDisplay for Path {\n \n                 write!(f, \"<\")?;\n                 let mut first = true;\n-                for arg in &generic_args.args {\n+                for arg in generic_args.args.iter() {\n                     if first {\n                         first = false;\n                         if generic_args.has_self_type {\n@@ -1431,7 +1431,7 @@ impl HirDisplay for Path {\n                     }\n                     arg.hir_fmt(f)?;\n                 }\n-                for binding in &generic_args.bindings {\n+                for binding in generic_args.bindings.iter() {\n                     if first {\n                         first = false;\n                     } else {\n@@ -1445,7 +1445,7 @@ impl HirDisplay for Path {\n                         }\n                         None => {\n                             write!(f, \": \")?;\n-                            f.write_joined(&binding.bounds, \" + \")?;\n+                            f.write_joined(binding.bounds.iter(), \" + \")?;\n                         }\n                     }\n                 }"}, {"sha": "299646737221d9cdd97d45d636b51dda9700f4c5", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lower.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1025,7 +1025,7 @@ impl<'a> TyLoweringContext<'a> {\n         last_segment\n             .into_iter()\n             .filter_map(|segment| segment.args_and_bindings)\n-            .flat_map(|args_and_bindings| &args_and_bindings.bindings)\n+            .flat_map(|args_and_bindings| args_and_bindings.bindings.iter())\n             .flat_map(move |binding| {\n                 let found = associated_type_by_name_including_super_traits(\n                     self.db,\n@@ -1068,7 +1068,7 @@ impl<'a> TyLoweringContext<'a> {\n                         AliasEq { alias: AliasTy::Projection(projection_ty.clone()), ty };\n                     preds.push(crate::wrap_empty_binders(WhereClause::AliasEq(alias_eq)));\n                 }\n-                for bound in &binding.bounds {\n+                for bound in binding.bounds.iter() {\n                     preds.extend(self.lower_type_bound(\n                         bound,\n                         TyKind::Alias(AliasTy::Projection(projection_ty.clone())).intern(Interner),"}, {"sha": "ef40a8902d73f78a4fbba3c75a890095a3296ed3", "filename": "src/tools/rust-analyzer/crates/hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2FCargo.toml?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -16,7 +16,7 @@ rustc-hash = \"1.1.0\"\n either = \"1.7.0\"\n arrayvec = \"0.7.2\"\n itertools = \"0.10.5\"\n-smallvec = \"1.10.0\"\n+smallvec.workspace = true\n once_cell = \"1.17.0\"\n \n # local deps"}, {"sha": "447e38f91f43e04bf6ad16f8b8e9c326c0387a31", "filename": "src/tools/rust-analyzer/crates/ide-assists/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2FCargo.toml?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -16,7 +16,7 @@ cov-mark = \"2.0.0-pre.1\"\n \n itertools = \"0.10.5\"\n either = \"1.7.0\"\n-smallvec = \"1.10.0\"\n+smallvec.workspace = true\n \n # local deps\n stdx.workspace = true"}, {"sha": "4595cfe29c85d1e5d685523881b9cf2e69d344f0", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_getter.rs", "status": "modified", "additions": 105, "deletions": 2, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -180,7 +180,9 @@ pub(crate) fn generate_getter_impl(\n \n                 // Insert `$0` only for last getter we generate\n                 if i == record_fields_count - 1 {\n-                    getter_buf = getter_buf.replacen(\"fn \", \"fn $0\", 1);\n+                    if ctx.config.snippet_cap.is_some() {\n+                        getter_buf = getter_buf.replacen(\"fn \", \"fn $0\", 1);\n+                    }\n                 }\n \n                 // For first element we do not merge with '\\n', as\n@@ -330,7 +332,7 @@ fn parse_record_field(record_field: ast::RecordField, mutable: bool) -> Option<R\n \n #[cfg(test)]\n mod tests {\n-    use crate::tests::{check_assist, check_assist_not_applicable};\n+    use crate::tests::{check_assist, check_assist_no_snippet_cap, check_assist_not_applicable};\n \n     use super::*;\n \n@@ -377,6 +379,49 @@ impl Context {\n         );\n     }\n \n+    #[test]\n+    fn test_generate_getter_from_field_no_snippet_cap() {\n+        check_assist_no_snippet_cap(\n+            generate_getter,\n+            r#\"\n+struct Context {\n+    dat$0a: Data,\n+}\n+\"#,\n+            r#\"\n+struct Context {\n+    data: Data,\n+}\n+\n+impl Context {\n+    fn data(&self) -> &Data {\n+        &self.data\n+    }\n+}\n+\"#,\n+        );\n+\n+        check_assist_no_snippet_cap(\n+            generate_getter_mut,\n+            r#\"\n+struct Context {\n+    dat$0a: Data,\n+}\n+\"#,\n+            r#\"\n+struct Context {\n+    data: Data,\n+}\n+\n+impl Context {\n+    fn data_mut(&mut self) -> &mut Data {\n+        &mut self.data\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_generate_getter_already_implemented() {\n         check_assist_not_applicable(\n@@ -433,6 +478,29 @@ impl Context {\n         );\n     }\n \n+    #[test]\n+    fn test_generate_getter_from_field_with_visibility_marker_no_snippet_cap() {\n+        check_assist_no_snippet_cap(\n+            generate_getter,\n+            r#\"\n+pub(crate) struct Context {\n+    dat$0a: Data,\n+}\n+\"#,\n+            r#\"\n+pub(crate) struct Context {\n+    data: Data,\n+}\n+\n+impl Context {\n+    pub(crate) fn data(&self) -> &Data {\n+        &self.data\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_multiple_generate_getter() {\n         check_assist(\n@@ -468,6 +536,41 @@ impl Context {\n         );\n     }\n \n+    #[test]\n+    fn test_multiple_generate_getter_no_snippet_cap() {\n+        check_assist_no_snippet_cap(\n+            generate_getter,\n+            r#\"\n+struct Context {\n+    data: Data,\n+    cou$0nt: usize,\n+}\n+\n+impl Context {\n+    fn data(&self) -> &Data {\n+        &self.data\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Context {\n+    data: Data,\n+    count: usize,\n+}\n+\n+impl Context {\n+    fn data(&self) -> &Data {\n+        &self.data\n+    }\n+\n+    fn count(&self) -> &usize {\n+        &self.count\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_not_a_special_case() {\n         cov_mark::check_count!(convert_reference_type, 0);"}, {"sha": "94be99fd7abf896bf06e05958c2a0bfdd60daefc", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/tests.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -33,6 +33,20 @@ pub(crate) const TEST_CONFIG: AssistConfig = AssistConfig {\n     assist_emit_must_use: false,\n };\n \n+pub(crate) const TEST_CONFIG_NO_SNIPPET_CAP: AssistConfig = AssistConfig {\n+    snippet_cap: None,\n+    allowed: None,\n+    insert_use: InsertUseConfig {\n+        granularity: ImportGranularity::Crate,\n+        prefix_kind: hir::PrefixKind::Plain,\n+        enforce_granularity: true,\n+        group: true,\n+        skip_glob_imports: true,\n+    },\n+    prefer_no_std: false,\n+    assist_emit_must_use: false,\n+};\n+\n pub(crate) fn with_single_file(text: &str) -> (RootDatabase, FileId) {\n     RootDatabase::with_single_file(text)\n }\n@@ -43,6 +57,22 @@ pub(crate) fn check_assist(assist: Handler, ra_fixture_before: &str, ra_fixture_\n     check(assist, ra_fixture_before, ExpectedResult::After(&ra_fixture_after), None);\n }\n \n+#[track_caller]\n+pub(crate) fn check_assist_no_snippet_cap(\n+    assist: Handler,\n+    ra_fixture_before: &str,\n+    ra_fixture_after: &str,\n+) {\n+    let ra_fixture_after = trim_indent(ra_fixture_after);\n+    check_with_config(\n+        TEST_CONFIG_NO_SNIPPET_CAP,\n+        assist,\n+        ra_fixture_before,\n+        ExpectedResult::After(&ra_fixture_after),\n+        None,\n+    );\n+}\n+\n // There is no way to choose what assist within a group you want to test against,\n // so this is here to allow you choose.\n pub(crate) fn check_assist_by_label(\n@@ -119,14 +149,24 @@ enum ExpectedResult<'a> {\n \n #[track_caller]\n fn check(handler: Handler, before: &str, expected: ExpectedResult<'_>, assist_label: Option<&str>) {\n+    check_with_config(TEST_CONFIG, handler, before, expected, assist_label);\n+}\n+\n+#[track_caller]\n+fn check_with_config(\n+    config: AssistConfig,\n+    handler: Handler,\n+    before: &str,\n+    expected: ExpectedResult<'_>,\n+    assist_label: Option<&str>,\n+) {\n     let (mut db, file_with_caret_id, range_or_offset) = RootDatabase::with_range_or_offset(before);\n     db.set_enable_proc_attr_macros(true);\n     let text_without_caret = db.file_text(file_with_caret_id).to_string();\n \n     let frange = FileRange { file_id: file_with_caret_id, range: range_or_offset.into() };\n \n     let sema = Semantics::new(&db);\n-    let config = TEST_CONFIG;\n     let ctx = AssistContext::new(sema, &config, frange);\n     let resolve = match expected {\n         ExpectedResult::Unresolved => AssistResolveStrategy::None,"}, {"sha": "092fb303668fe73e7ef3a578f9677fb0e7ef4fb3", "filename": "src/tools/rust-analyzer/crates/ide-completion/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2FCargo.toml?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -16,7 +16,7 @@ cov-mark = \"2.0.0-pre.1\"\n itertools = \"0.10.5\"\n \n once_cell = \"1.17.0\"\n-smallvec = \"1.10.0\"\n+smallvec.workspace = true\n \n \n # local deps"}, {"sha": "c55bd9aaae521b250d4d9217c51d1ad6220c7061", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/postfix.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -747,4 +747,16 @@ fn main() {\n             \"#,\n         );\n     }\n+\n+    #[test]\n+    fn no_postfix_completions_in_if_block_that_has_an_else() {\n+        check(\n+            r#\"\n+fn test() {\n+    if true {}.$0 else {}\n+}\n+\"#,\n+            expect![[r#\"\"#]],\n+        );\n+    }\n }"}, {"sha": "ea54068b0f8bf811089e155c078f38a0223b14e8", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -571,28 +571,25 @@ impl<'a> CompletionContext<'a> {\n \n         // try to skip completions on path with invalid colons\n         // this approach works in normal path and inside token tree\n-        match original_token.kind() {\n-            T![:] => {\n-                // return if no prev token before colon\n-                let prev_token = original_token.prev_token()?;\n-\n-                // only has a single colon\n-                if prev_token.kind() != T![:] {\n-                    return None;\n-                }\n+        if original_token.kind() == T![:] {\n+            // return if no prev token before colon\n+            let prev_token = original_token.prev_token()?;\n \n-                // has 3 colon or 2 coloncolon in a row\n-                // special casing this as per discussion in https://github.com/rust-lang/rust-analyzer/pull/13611#discussion_r1031845205\n-                // and https://github.com/rust-lang/rust-analyzer/pull/13611#discussion_r1032812751\n-                if prev_token\n-                    .prev_token()\n-                    .map(|t| t.kind() == T![:] || t.kind() == T![::])\n-                    .unwrap_or(false)\n-                {\n-                    return None;\n-                }\n+            // only has a single colon\n+            if prev_token.kind() != T![:] {\n+                return None;\n+            }\n+\n+            // has 3 colon or 2 coloncolon in a row\n+            // special casing this as per discussion in https://github.com/rust-lang/rust-analyzer/pull/13611#discussion_r1031845205\n+            // and https://github.com/rust-lang/rust-analyzer/pull/13611#discussion_r1032812751\n+            if prev_token\n+                .prev_token()\n+                .map(|t| t.kind() == T![:] || t.kind() == T![::])\n+                .unwrap_or(false)\n+            {\n+                return None;\n             }\n-            _ => {}\n         }\n \n         let AnalysisResult {"}, {"sha": "db0045aef6e0b23b77b31e3eef799a8e0f83b9ac", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 94, "deletions": 66, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -29,6 +29,7 @@ pub(super) struct AnalysisResult {\n     pub(super) analysis: CompletionAnalysis,\n     pub(super) expected: (Option<Type>, Option<ast::NameOrNameRef>),\n     pub(super) qualifier_ctx: QualifierCtx,\n+    /// the original token of the expanded file\n     pub(super) token: SyntaxToken,\n     pub(super) offset: TextSize,\n }\n@@ -213,15 +214,6 @@ fn analyze(\n     let _p = profile::span(\"CompletionContext::analyze\");\n     let ExpansionResult { original_file, speculative_file, offset, fake_ident_token, derive_ctx } =\n         expansion_result;\n-    let syntax_element = NodeOrToken::Token(fake_ident_token);\n-    if is_in_token_of_for_loop(syntax_element.clone()) {\n-        // for pat $0\n-        // there is nothing to complete here except `in` keyword\n-        // don't bother populating the context\n-        // FIXME: the completion calculations should end up good enough\n-        // such that this special case becomes unnecessary\n-        return None;\n-    }\n \n     // Overwrite the path kind for derives\n     if let Some((original_file, file_with_fake_ident, offset, origin_attr)) = derive_ctx {\n@@ -249,37 +241,35 @@ fn analyze(\n         return None;\n     }\n \n-    let name_like = match find_node_at_offset(&speculative_file, offset) {\n-        Some(it) => it,\n-        None => {\n-            let analysis = if let Some(original) = ast::String::cast(original_token.clone()) {\n-                CompletionAnalysis::String {\n-                    original,\n-                    expanded: ast::String::cast(self_token.clone()),\n+    let Some(name_like) = find_node_at_offset(&speculative_file, offset) else {\n+        let analysis = if let Some(original) = ast::String::cast(original_token.clone()) {\n+            CompletionAnalysis::String {\n+                original,\n+                expanded: ast::String::cast(self_token.clone()),\n+            }\n+        } else {\n+            // Fix up trailing whitespace problem\n+            // #[attr(foo = $0\n+            let token = syntax::algo::skip_trivia_token(self_token.clone(), Direction::Prev)?;\n+            let p = token.parent()?;\n+            if p.kind() == SyntaxKind::TOKEN_TREE\n+                && p.ancestors().any(|it| it.kind() == SyntaxKind::META)\n+            {\n+                let colon_prefix = previous_non_trivia_token(self_token.clone())\n+                    .map_or(false, |it| T![:] == it.kind());\n+                CompletionAnalysis::UnexpandedAttrTT {\n+                    fake_attribute_under_caret: fake_ident_token\n+                        .parent_ancestors()\n+                        .find_map(ast::Attr::cast),\n+                    colon_prefix,\n                 }\n             } else {\n-                // Fix up trailing whitespace problem\n-                // #[attr(foo = $0\n-                let token = syntax::algo::skip_trivia_token(self_token.clone(), Direction::Prev)?;\n-                let p = token.parent()?;\n-                if p.kind() == SyntaxKind::TOKEN_TREE\n-                    && p.ancestors().any(|it| it.kind() == SyntaxKind::META)\n-                {\n-                    let colon_prefix = previous_non_trivia_token(self_token.clone())\n-                        .map_or(false, |it| T![:] == it.kind());\n-                    CompletionAnalysis::UnexpandedAttrTT {\n-                        fake_attribute_under_caret: syntax_element\n-                            .ancestors()\n-                            .find_map(ast::Attr::cast),\n-                        colon_prefix,\n-                    }\n-                } else {\n-                    return None;\n-                }\n-            };\n-            return Some((analysis, (None, None), QualifierCtx::default()));\n-        }\n+                return None;\n+            }\n+        };\n+        return Some((analysis, (None, None), QualifierCtx::default()));\n     };\n+\n     let expected = expected_type_and_name(sema, self_token, &name_like);\n     let mut qual_ctx = QualifierCtx::default();\n     let analysis = match name_like {\n@@ -290,6 +280,22 @@ fn analyze(\n             let parent = name_ref.syntax().parent()?;\n             let (nameref_ctx, qualifier_ctx) =\n                 classify_name_ref(sema, &original_file, name_ref, parent)?;\n+\n+            if let NameRefContext {\n+                kind:\n+                    NameRefKind::Path(PathCompletionCtx { kind: PathKind::Expr { .. }, path, .. }, ..),\n+                ..\n+            } = &nameref_ctx\n+            {\n+                if is_in_token_of_for_loop(path) {\n+                    // for pat $0\n+                    // there is nothing to complete here except `in` keyword\n+                    // don't bother populating the context\n+                    // Ideally this special casing wouldn't be needed, but the parser recovers\n+                    return None;\n+                }\n+            }\n+\n             qual_ctx = qualifier_ctx;\n             CompletionAnalysis::NameRef(nameref_ctx)\n         }\n@@ -323,16 +329,14 @@ fn expected_type_and_name(\n                     ast::FieldExpr(e) => e\n                         .syntax()\n                         .ancestors()\n-                        .map_while(ast::FieldExpr::cast)\n-                        .last()\n-                        .map(|it| it.syntax().clone()),\n+                        .take_while(|it| ast::FieldExpr::can_cast(it.kind()))\n+                        .last(),\n                     ast::PathSegment(e) => e\n                         .syntax()\n                         .ancestors()\n                         .skip(1)\n                         .take_while(|it| ast::Path::can_cast(it.kind()) || ast::PathExpr::can_cast(it.kind()))\n-                        .find_map(ast::PathExpr::cast)\n-                        .map(|it| it.syntax().clone()),\n+                        .find(|it| ast::PathExpr::can_cast(it.kind())),\n                     _ => None\n                 }\n             };\n@@ -605,6 +609,18 @@ fn classify_name_ref(\n                     },\n                     _ => false,\n                 };\n+\n+                let reciever_is_part_of_indivisible_expression = match &receiver {\n+                    Some(ast::Expr::IfExpr(_)) => {\n+                        let next_token_kind = next_non_trivia_token(name_ref.syntax().clone()).map(|t| t.kind());\n+                        next_token_kind == Some(SyntaxKind::ELSE_KW)\n+                    },\n+                    _ => false\n+                };\n+                if reciever_is_part_of_indivisible_expression {\n+                    return None;\n+                }\n+\n                 let kind = NameRefKind::DotAccess(DotAccess {\n                     receiver_ty: receiver.as_ref().and_then(|it| sema.type_of_expr(it)),\n                     kind: DotAccessKind::Field { receiver_is_ambiguous_float_literal },\n@@ -656,8 +672,15 @@ fn classify_name_ref(\n     };\n     let after_if_expr = |node: SyntaxNode| {\n         let prev_expr = (|| {\n+            let node = match node.parent().and_then(ast::ExprStmt::cast) {\n+                Some(stmt) => stmt.syntax().clone(),\n+                None => node,\n+            };\n             let prev_sibling = non_trivia_sibling(node.into(), Direction::Prev)?.into_node()?;\n-            ast::ExprStmt::cast(prev_sibling)?.expr()\n+\n+            ast::ExprStmt::cast(prev_sibling.clone())\n+                .and_then(|it| it.expr())\n+                .or_else(|| ast::Expr::cast(prev_sibling))\n         })();\n         matches!(prev_expr, Some(ast::Expr::IfExpr(_)))\n     };\n@@ -1251,40 +1274,29 @@ fn path_or_use_tree_qualifier(path: &ast::Path) -> Option<(ast::Path, bool)> {\n     Some((use_tree.path()?, true))\n }\n \n-pub(crate) fn is_in_token_of_for_loop(element: SyntaxElement) -> bool {\n+fn is_in_token_of_for_loop(path: &ast::Path) -> bool {\n     // oh my ...\n     (|| {\n-        let syntax_token = element.into_token()?;\n-        let range = syntax_token.text_range();\n-        let for_expr = syntax_token.parent_ancestors().find_map(ast::ForExpr::cast)?;\n-\n-        // check if the current token is the `in` token of a for loop\n-        if let Some(token) = for_expr.in_token() {\n-            return Some(syntax_token == token);\n+        let expr = path.syntax().parent().and_then(ast::PathExpr::cast)?;\n+        let for_expr = expr.syntax().parent().and_then(ast::ForExpr::cast)?;\n+        if for_expr.in_token().is_some() {\n+            return Some(false);\n         }\n         let pat = for_expr.pat()?;\n-        if range.end() < pat.syntax().text_range().end() {\n-            // if we are inside or before the pattern we can't be at the `in` token position\n-            return None;\n-        }\n         let next_sibl = next_non_trivia_sibling(pat.syntax().clone().into())?;\n         Some(match next_sibl {\n-            // the loop body is some node, if our token is at the start we are at the `in` position,\n-            // otherwise we could be in a recovered expression, we don't wanna ruin completions there\n-            syntax::NodeOrToken::Node(n) => n.text_range().start() == range.start(),\n-            // the loop body consists of a single token, if we are this we are certainly at the `in` token position\n-            syntax::NodeOrToken::Token(t) => t == syntax_token,\n+            syntax::NodeOrToken::Node(n) => {\n+                n.text_range().start() == path.syntax().text_range().start()\n+            }\n+            syntax::NodeOrToken::Token(t) => {\n+                t.text_range().start() == path.syntax().text_range().start()\n+            }\n         })\n     })()\n     .unwrap_or(false)\n }\n \n-#[test]\n-fn test_for_is_prev2() {\n-    crate::tests::check_pattern_is_applicable(r\"fn __() { for i i$0 }\", is_in_token_of_for_loop);\n-}\n-\n-pub(crate) fn is_in_loop_body(node: &SyntaxNode) -> bool {\n+fn is_in_loop_body(node: &SyntaxNode) -> bool {\n     node.ancestors()\n         .take_while(|it| it.kind() != SyntaxKind::FN && it.kind() != SyntaxKind::CLOSURE_EXPR)\n         .find_map(|it| {\n@@ -1317,6 +1329,22 @@ fn previous_non_trivia_token(e: impl Into<SyntaxElement>) -> Option<SyntaxToken>\n     None\n }\n \n+fn next_non_trivia_token(e: impl Into<SyntaxElement>) -> Option<SyntaxToken> {\n+    let mut token = match e.into() {\n+        SyntaxElement::Node(n) => n.last_token()?,\n+        SyntaxElement::Token(t) => t,\n+    }\n+    .next_token();\n+    while let Some(inner) = token {\n+        if !inner.kind().is_trivia() {\n+            return Some(inner);\n+        } else {\n+            token = inner.next_token();\n+        }\n+    }\n+    None\n+}\n+\n fn next_non_trivia_sibling(ele: SyntaxElement) -> Option<SyntaxElement> {\n     let mut e = ele.next_sibling_or_token();\n     while let Some(inner) = e {"}, {"sha": "2f65491d85e14f920474a0bbea16baf0c2666b7c", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/item.rs", "status": "modified", "additions": 35, "deletions": 69, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fitem.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -14,13 +14,14 @@ use crate::{\n     render::{render_path_resolution, RenderContext},\n };\n \n-/// `CompletionItem` describes a single completion variant in the editor pop-up.\n-/// It is basically a POD with various properties. To construct a\n-/// `CompletionItem`, use `new` method and the `Builder` struct.\n+/// `CompletionItem` describes a single completion entity which expands to 1 or more entries in the\n+/// editor pop-up. It is basically a POD with various properties. To construct a\n+/// [`CompletionItem`], use [`Builder::new`] method and the [`Builder`] struct.\n #[derive(Clone)]\n+#[non_exhaustive]\n pub struct CompletionItem {\n     /// Label in the completion pop up which identifies completion.\n-    label: SmolStr,\n+    pub label: SmolStr,\n     /// Range of identifier that is being completed.\n     ///\n     /// It should be used primarily for UI, but we also use this to convert\n@@ -29,33 +30,33 @@ pub struct CompletionItem {\n     /// `source_range` must contain the completion offset. `text_edit` should\n     /// start with what `source_range` points to, or VSCode will filter out the\n     /// completion silently.\n-    source_range: TextRange,\n+    pub source_range: TextRange,\n     /// What happens when user selects this item.\n     ///\n     /// Typically, replaces `source_range` with new identifier.\n-    text_edit: TextEdit,\n-    is_snippet: bool,\n+    pub text_edit: TextEdit,\n+    pub is_snippet: bool,\n \n     /// What item (struct, function, etc) are we completing.\n-    kind: CompletionItemKind,\n+    pub kind: CompletionItemKind,\n \n     /// Lookup is used to check if completion item indeed can complete current\n     /// ident.\n     ///\n     /// That is, in `foo.bar$0` lookup of `abracadabra` will be accepted (it\n     /// contains `bar` sub sequence), and `quux` will rejected.\n-    lookup: Option<SmolStr>,\n+    pub lookup: Option<SmolStr>,\n \n     /// Additional info to show in the UI pop up.\n-    detail: Option<String>,\n-    documentation: Option<Documentation>,\n+    pub detail: Option<String>,\n+    pub documentation: Option<Documentation>,\n \n     /// Whether this item is marked as deprecated\n-    deprecated: bool,\n+    pub deprecated: bool,\n \n     /// If completing a function call, ask the editor to show parameter popup\n     /// after completion.\n-    trigger_call_info: bool,\n+    pub trigger_call_info: bool,\n \n     /// We use this to sort completion. Relevance records facts like \"do the\n     /// types align precisely?\". We can't sort by relevances directly, they are\n@@ -64,36 +65,39 @@ pub struct CompletionItem {\n     /// Note that Relevance ignores fuzzy match score. We compute Relevance for\n     /// all possible items, and then separately build an ordered completion list\n     /// based on relevance and fuzzy matching with the already typed identifier.\n-    relevance: CompletionRelevance,\n+    pub relevance: CompletionRelevance,\n \n     /// Indicates that a reference or mutable reference to this variable is a\n     /// possible match.\n-    ref_match: Option<(Mutability, TextSize)>,\n+    // FIXME: We shouldn't expose Mutability here (that is HIR types at all), its fine for now though\n+    // until we have more splitting completions in which case we should think about\n+    // generalizing this. See https://github.com/rust-lang/rust-analyzer/issues/12571\n+    pub ref_match: Option<(Mutability, TextSize)>,\n \n     /// The import data to add to completion's edits.\n-    import_to_add: SmallVec<[LocatedImport; 1]>,\n+    pub import_to_add: SmallVec<[LocatedImport; 1]>,\n }\n \n // We use custom debug for CompletionItem to make snapshot tests more readable.\n impl fmt::Debug for CompletionItem {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut s = f.debug_struct(\"CompletionItem\");\n-        s.field(\"label\", &self.label()).field(\"source_range\", &self.source_range());\n-        if self.text_edit().len() == 1 {\n-            let atom = &self.text_edit().iter().next().unwrap();\n+        s.field(\"label\", &self.label).field(\"source_range\", &self.source_range);\n+        if self.text_edit.len() == 1 {\n+            let atom = &self.text_edit.iter().next().unwrap();\n             s.field(\"delete\", &atom.delete);\n             s.field(\"insert\", &atom.insert);\n         } else {\n             s.field(\"text_edit\", &self.text_edit);\n         }\n-        s.field(\"kind\", &self.kind());\n-        if self.lookup() != self.label() {\n+        s.field(\"kind\", &self.kind);\n+        if self.lookup() != self.label {\n             s.field(\"lookup\", &self.lookup());\n         }\n-        if let Some(detail) = self.detail() {\n+        if let Some(detail) = &self.detail {\n             s.field(\"detail\", &detail);\n         }\n-        if let Some(documentation) = self.documentation() {\n+        if let Some(documentation) = &self.documentation {\n             s.field(\"documentation\", &documentation);\n         }\n         if self.deprecated {\n@@ -351,63 +355,25 @@ impl CompletionItem {\n         }\n     }\n \n-    /// What user sees in pop-up in the UI.\n-    pub fn label(&self) -> &str {\n-        &self.label\n-    }\n-    pub fn source_range(&self) -> TextRange {\n-        self.source_range\n-    }\n-\n-    pub fn text_edit(&self) -> &TextEdit {\n-        &self.text_edit\n-    }\n-    /// Whether `text_edit` is a snippet (contains `$0` markers).\n-    pub fn is_snippet(&self) -> bool {\n-        self.is_snippet\n-    }\n-\n-    /// Short one-line additional information, like a type\n-    pub fn detail(&self) -> Option<&str> {\n-        self.detail.as_deref()\n-    }\n-    /// A doc-comment\n-    pub fn documentation(&self) -> Option<Documentation> {\n-        self.documentation.clone()\n-    }\n     /// What string is used for filtering.\n     pub fn lookup(&self) -> &str {\n         self.lookup.as_deref().unwrap_or(&self.label)\n     }\n \n-    pub fn kind(&self) -> CompletionItemKind {\n-        self.kind\n-    }\n-\n-    pub fn deprecated(&self) -> bool {\n-        self.deprecated\n-    }\n-\n-    pub fn relevance(&self) -> CompletionRelevance {\n-        self.relevance\n-    }\n-\n-    pub fn trigger_call_info(&self) -> bool {\n-        self.trigger_call_info\n-    }\n-\n-    pub fn ref_match(&self) -> Option<(Mutability, TextSize, CompletionRelevance)> {\n+    pub fn ref_match(&self) -> Option<(String, text_edit::Indel, CompletionRelevance)> {\n         // Relevance of the ref match should be the same as the original\n         // match, but with exact type match set because self.ref_match\n         // is only set if there is an exact type match.\n         let mut relevance = self.relevance;\n         relevance.type_match = Some(CompletionRelevanceTypeMatch::Exact);\n \n-        self.ref_match.map(|(mutability, offset)| (mutability, offset, relevance))\n-    }\n-\n-    pub fn imports_to_add(&self) -> &[LocatedImport] {\n-        &self.import_to_add\n+        self.ref_match.map(|(mutability, offset)| {\n+            (\n+                format!(\"&{}{}\", mutability.as_keyword_for_ref(), self.label),\n+                text_edit::Indel::insert(offset, format!(\"&{}\", mutability.as_keyword_for_ref())),\n+                relevance,\n+            )\n+        })\n     }\n }\n "}, {"sha": "6fe781114039921d1376418f46a39c561089eed4", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/lib.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Flib.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -156,21 +156,23 @@ pub fn completions(\n \n     // prevent `(` from triggering unwanted completion noise\n     if trigger_character == Some('(') {\n-        if let CompletionAnalysis::NameRef(NameRefContext { kind, .. }) = &analysis {\n-            if let NameRefKind::Path(\n-                path_ctx @ PathCompletionCtx { kind: PathKind::Vis { has_in_token }, .. },\n-            ) = kind\n-            {\n-                completions::vis::complete_vis_path(&mut completions, ctx, path_ctx, has_in_token);\n-            }\n+        if let CompletionAnalysis::NameRef(NameRefContext {\n+            kind:\n+                NameRefKind::Path(\n+                    path_ctx @ PathCompletionCtx { kind: PathKind::Vis { has_in_token }, .. },\n+                ),\n+            ..\n+        }) = analysis\n+        {\n+            completions::vis::complete_vis_path(&mut completions, ctx, path_ctx, has_in_token);\n         }\n         return Some(completions.into());\n     }\n \n     {\n         let acc = &mut completions;\n \n-        match &analysis {\n+        match analysis {\n             CompletionAnalysis::Name(name_ctx) => completions::complete_name(acc, ctx, name_ctx),\n             CompletionAnalysis::NameRef(name_ref_ctx) => {\n                 completions::complete_name_ref(acc, ctx, name_ref_ctx)"}, {"sha": "d99ad5f9f04ba14bbf942136c0a5687ad091e12d", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -503,18 +503,18 @@ mod tests {\n     #[track_caller]\n     fn check_relevance_for_kinds(ra_fixture: &str, kinds: &[CompletionItemKind], expect: Expect) {\n         let mut actual = get_all_items(TEST_CONFIG, ra_fixture, None);\n-        actual.retain(|it| kinds.contains(&it.kind()));\n-        actual.sort_by_key(|it| cmp::Reverse(it.relevance().score()));\n+        actual.retain(|it| kinds.contains(&it.kind));\n+        actual.sort_by_key(|it| cmp::Reverse(it.relevance.score()));\n         check_relevance_(actual, expect);\n     }\n \n     #[track_caller]\n     fn check_relevance(ra_fixture: &str, expect: Expect) {\n         let mut actual = get_all_items(TEST_CONFIG, ra_fixture, None);\n-        actual.retain(|it| it.kind() != CompletionItemKind::Snippet);\n-        actual.retain(|it| it.kind() != CompletionItemKind::Keyword);\n-        actual.retain(|it| it.kind() != CompletionItemKind::BuiltinType);\n-        actual.sort_by_key(|it| cmp::Reverse(it.relevance().score()));\n+        actual.retain(|it| it.kind != CompletionItemKind::Snippet);\n+        actual.retain(|it| it.kind != CompletionItemKind::Keyword);\n+        actual.retain(|it| it.kind != CompletionItemKind::BuiltinType);\n+        actual.sort_by_key(|it| cmp::Reverse(it.relevance.score()));\n         check_relevance_(actual, expect);\n     }\n \n@@ -525,12 +525,11 @@ mod tests {\n             .flat_map(|it| {\n                 let mut items = vec![];\n \n-                let tag = it.kind().tag();\n-                let relevance = display_relevance(it.relevance());\n-                items.push(format!(\"{tag} {} {relevance}\\n\", it.label()));\n+                let tag = it.kind.tag();\n+                let relevance = display_relevance(it.relevance);\n+                items.push(format!(\"{tag} {} {relevance}\\n\", it.label));\n \n-                if let Some((mutability, _offset, relevance)) = it.ref_match() {\n-                    let label = format!(\"&{}{}\", mutability.as_keyword_for_ref(), it.label());\n+                if let Some((label, _indel, relevance)) = it.ref_match() {\n                     let relevance = display_relevance(relevance);\n \n                     items.push(format!(\"{tag} {label} {relevance}\\n\"));\n@@ -587,6 +586,7 @@ fn main() { Foo::Fo$0 }\n                         ),\n                         lookup: \"Foo{}\",\n                         detail: \"Foo { x: i32, y: i32 }\",\n+                        trigger_call_info: true,\n                     },\n                 ]\n             \"#]],\n@@ -614,6 +614,7 @@ fn main() { Foo::Fo$0 }\n                         ),\n                         lookup: \"Foo()\",\n                         detail: \"Foo(i32, i32)\",\n+                        trigger_call_info: true,\n                     },\n                 ]\n             \"#]],\n@@ -679,6 +680,7 @@ fn main() { Foo::Fo$0 }\n                             Variant,\n                         ),\n                         detail: \"Foo\",\n+                        trigger_call_info: true,\n                     },\n                 ]\n             \"#]],\n@@ -745,6 +747,7 @@ fn main() { let _: m::Spam = S$0 }\n                             postfix_match: None,\n                             is_definite: false,\n                         },\n+                        trigger_call_info: true,\n                     },\n                     CompletionItem {\n                         label: \"m::Spam::Foo\",\n@@ -770,6 +773,7 @@ fn main() { let _: m::Spam = S$0 }\n                             postfix_match: None,\n                             is_definite: false,\n                         },\n+                        trigger_call_info: true,\n                     },\n                 ]\n             \"#]],\n@@ -942,6 +946,7 @@ use self::E::*;\n                         documentation: Documentation(\n                             \"variant docs\",\n                         ),\n+                        trigger_call_info: true,\n                     },\n                     CompletionItem {\n                         label: \"E\","}, {"sha": "ed78fcd8e6529049c5b4e869a945bd738cb6ce04", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -113,7 +113,7 @@ fn render(\n     item.detail(rendered.detail);\n \n     match snippet_cap {\n-        Some(snippet_cap) => item.insert_snippet(snippet_cap, rendered.literal),\n+        Some(snippet_cap) => item.insert_snippet(snippet_cap, rendered.literal).trigger_call_info(),\n         None => item.insert_text(rendered.literal),\n     };\n "}, {"sha": "6e0c53ec94c437d34d8bb7954e951ba16fa9436e", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/render/union_literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Funion_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Funion_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Frender%2Funion_literal.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -72,7 +72,7 @@ pub(crate) fn render_union_literal(\n         .set_relevance(ctx.completion_relevance());\n \n     match ctx.snippet_cap() {\n-        Some(snippet_cap) => item.insert_snippet(snippet_cap, literal),\n+        Some(snippet_cap) => item.insert_snippet(snippet_cap, literal).trigger_call_info(),\n         None => item.insert_text(literal),\n     };\n "}, {"sha": "1fe48b9e96f9dcaf5eb69b5dfce0bc09fb8a0987", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests.rs", "status": "modified", "additions": 18, "deletions": 27, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -23,15 +23,14 @@ mod type_pos;\n mod use_tree;\n mod visibility;\n \n-use hir::{db::DefDatabase, PrefixKind, Semantics};\n+use hir::{db::DefDatabase, PrefixKind};\n use ide_db::{\n     base_db::{fixture::ChangeFixture, FileLoader, FilePosition},\n     imports::insert_use::{ImportGranularity, InsertUseConfig},\n     RootDatabase, SnippetCap,\n };\n use itertools::Itertools;\n use stdx::{format_to, trim_indent};\n-use syntax::{AstNode, NodeOrToken, SyntaxElement};\n use test_utils::assert_eq_text;\n \n use crate::{\n@@ -109,10 +108,10 @@ fn completion_list_with_config(\n     let items = get_all_items(config, ra_fixture, trigger_character);\n     let items = items\n         .into_iter()\n-        .filter(|it| it.kind() != CompletionItemKind::BuiltinType || it.label() == \"u32\")\n-        .filter(|it| include_keywords || it.kind() != CompletionItemKind::Keyword)\n-        .filter(|it| include_keywords || it.kind() != CompletionItemKind::Snippet)\n-        .sorted_by_key(|it| (it.kind(), it.label().to_owned(), it.detail().map(ToOwned::to_owned)))\n+        .filter(|it| it.kind != CompletionItemKind::BuiltinType || it.label == \"u32\")\n+        .filter(|it| include_keywords || it.kind != CompletionItemKind::Keyword)\n+        .filter(|it| include_keywords || it.kind != CompletionItemKind::Snippet)\n+        .sorted_by_key(|it| (it.kind, it.label.clone(), it.detail.as_ref().map(ToOwned::to_owned)))\n         .collect();\n     render_completion_list(items)\n }\n@@ -139,8 +138,8 @@ pub(crate) fn do_completion_with_config(\n ) -> Vec<CompletionItem> {\n     get_all_items(config, code, None)\n         .into_iter()\n-        .filter(|c| c.kind() == kind)\n-        .sorted_by(|l, r| l.label().cmp(r.label()))\n+        .filter(|c| c.kind == kind)\n+        .sorted_by(|l, r| l.label.cmp(&r.label))\n         .collect()\n }\n \n@@ -149,18 +148,18 @@ fn render_completion_list(completions: Vec<CompletionItem>) -> String {\n         s.chars().count()\n     }\n     let label_width =\n-        completions.iter().map(|it| monospace_width(it.label())).max().unwrap_or_default().min(22);\n+        completions.iter().map(|it| monospace_width(&it.label)).max().unwrap_or_default().min(22);\n     completions\n         .into_iter()\n         .map(|it| {\n-            let tag = it.kind().tag();\n-            let var_name = format!(\"{tag} {}\", it.label());\n+            let tag = it.kind.tag();\n+            let var_name = format!(\"{tag} {}\", it.label);\n             let mut buf = var_name;\n-            if let Some(detail) = it.detail() {\n-                let width = label_width.saturating_sub(monospace_width(it.label()));\n+            if let Some(detail) = it.detail {\n+                let width = label_width.saturating_sub(monospace_width(&it.label));\n                 format_to!(buf, \"{:width$} {}\", \"\", detail, width = width);\n             }\n-            if it.deprecated() {\n+            if it.deprecated {\n                 format_to!(buf, \" DEPRECATED\");\n             }\n             format_to!(buf, \"\\n\");\n@@ -192,13 +191,13 @@ pub(crate) fn check_edit_with_config(\n         .unwrap_or_else(|| panic!(\"can't find {what:?} completion in {completions:#?}\"));\n     let mut actual = db.file_text(position.file_id).to_string();\n \n-    let mut combined_edit = completion.text_edit().to_owned();\n+    let mut combined_edit = completion.text_edit.clone();\n \n     resolve_completion_edits(\n         &db,\n         &config,\n         position,\n-        completion.imports_to_add().iter().filter_map(|import_edit| {\n+        completion.import_to_add.iter().filter_map(|import_edit| {\n             let import_path = &import_edit.import_path;\n             let import_name = import_path.segments().last()?;\n             Some((import_path.to_string(), import_name.to_string()))\n@@ -216,15 +215,6 @@ pub(crate) fn check_edit_with_config(\n     assert_eq_text!(&ra_fixture_after, &actual)\n }\n \n-pub(crate) fn check_pattern_is_applicable(code: &str, check: impl FnOnce(SyntaxElement) -> bool) {\n-    let (db, pos) = position(code);\n-\n-    let sema = Semantics::new(&db);\n-    let original_file = sema.parse(pos.file_id);\n-    let token = original_file.syntax().token_at_offset(pos.offset).left_biased().unwrap();\n-    assert!(check(NodeOrToken::Token(token)));\n-}\n-\n pub(crate) fn get_all_items(\n     config: CompletionConfig,\n     code: &str,\n@@ -235,7 +225,7 @@ pub(crate) fn get_all_items(\n         .map_or_else(Vec::default, Into::into);\n     // validate\n     res.iter().for_each(|it| {\n-        let sr = it.source_range();\n+        let sr = it.source_range;\n         assert!(\n             sr.contains_inclusive(position.offset),\n             \"source range {sr:?} does not contain the offset {:?} of the completion request: {it:?}\",\n@@ -246,8 +236,9 @@ pub(crate) fn get_all_items(\n }\n \n #[test]\n-fn test_no_completions_required() {\n+fn test_no_completions_in_for_loop_in_kw_pos() {\n     assert_eq!(completion_list(r#\"fn foo() { for i i$0 }\"#), String::new());\n+    assert_eq!(completion_list(r#\"fn foo() { for i in$0 }\"#), String::new());\n }\n \n #[test]"}, {"sha": "c1c6a689eb18a29a2e3e10e339dcb300ac0f99be", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/expression.rs", "status": "modified", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -745,3 +745,255 @@ fn return_value_no_block() {\n         r#\"fn f() -> i32 { match () { () => return $0 } }\"#,\n     );\n }\n+\n+#[test]\n+fn else_completion_after_if() {\n+    check_empty(\n+        r#\"\n+fn foo() { if foo {} $0 }\n+\"#,\n+        expect![[r#\"\n+            fn foo()       fn()\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+fn foo() { if foo {} el$0 }\n+\"#,\n+        expect![[r#\"\n+            fn foo()       fn()\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+fn foo() { bar(if foo {} $0) }\n+\"#,\n+        expect![[r#\"\n+            fn foo()     fn()\n+            bt u32\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw false\n+            kw for\n+            kw if\n+            kw if let\n+            kw loop\n+            kw match\n+            kw return\n+            kw self::\n+            kw true\n+            kw unsafe\n+            kw while\n+            kw while let\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+fn foo() { bar(if foo {} el$0) }\n+\"#,\n+        expect![[r#\"\n+            fn foo()     fn()\n+            bt u32\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw false\n+            kw for\n+            kw if\n+            kw if let\n+            kw loop\n+            kw match\n+            kw return\n+            kw self::\n+            kw true\n+            kw unsafe\n+            kw while\n+            kw while let\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+fn foo() { if foo {} $0 let x = 92; }\n+\"#,\n+        expect![[r#\"\n+            fn foo()       fn()\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+fn foo() { if foo {} el$0 let x = 92; }\n+\"#,\n+        expect![[r#\"\n+            fn foo()       fn()\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+    check_empty(\n+        r#\"\n+fn foo() { if foo {} el$0 { let x = 92; } }\n+\"#,\n+        expect![[r#\"\n+            fn foo()       fn()\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw else\n+            kw else if\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+}"}, {"sha": "cb71c7b2bdef3ff6a87e8c0d19afafff2de57a91", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/special.rs", "status": "modified", "additions": 44, "deletions": 37, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -2,13 +2,20 @@\n \n use expect_test::{expect, Expect};\n \n-use crate::tests::{check_edit, completion_list_no_kw, completion_list_with_trigger_character};\n+use crate::tests::{\n+    check_edit, completion_list, completion_list_no_kw, completion_list_with_trigger_character,\n+};\n \n-fn check(ra_fixture: &str, expect: Expect) {\n+fn check_no_kw(ra_fixture: &str, expect: Expect) {\n     let actual = completion_list_no_kw(ra_fixture);\n     expect.assert_eq(&actual)\n }\n \n+fn check(ra_fixture: &str, expect: Expect) {\n+    let actual = completion_list(ra_fixture);\n+    expect.assert_eq(&actual)\n+}\n+\n pub(crate) fn check_with_trigger_character(\n     ra_fixture: &str,\n     trigger_character: Option<char>,\n@@ -59,7 +66,7 @@ fn _alpha() {}\n \n #[test]\n fn completes_prelude() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /main.rs edition:2018 crate:main deps:std\n fn foo() { let x: $0 }\n@@ -81,7 +88,7 @@ pub mod prelude {\n \n #[test]\n fn completes_prelude_macros() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /main.rs edition:2018 crate:main deps:std\n fn f() {$0}\n@@ -110,7 +117,7 @@ mod macros {\n \n #[test]\n fn completes_std_prelude_if_core_is_defined() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /main.rs crate:main deps:core,std\n fn foo() { let x: $0 }\n@@ -140,7 +147,7 @@ pub mod prelude {\n \n #[test]\n fn respects_doc_hidden() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /lib.rs crate:lib deps:std\n fn f() {\n@@ -168,7 +175,7 @@ pub mod prelude {\n \n #[test]\n fn respects_doc_hidden_in_assoc_item_list() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /lib.rs crate:lib deps:std\n struct S;\n@@ -195,7 +202,7 @@ pub mod prelude {\n \n #[test]\n fn associated_item_visibility() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /lib.rs crate:lib new_source_root:library\n pub struct S;\n@@ -222,7 +229,7 @@ fn foo() { let _ = lib::S::$0 }\n \n #[test]\n fn completes_union_associated_method() {\n-    check(\n+    check_no_kw(\n         r#\"\n union U {};\n impl U { fn m() { } }\n@@ -237,7 +244,7 @@ fn foo() { let _ = U::$0 }\n \n #[test]\n fn completes_trait_associated_method_1() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Trait { fn m(); }\n \n@@ -251,7 +258,7 @@ fn foo() { let _ = Trait::$0 }\n \n #[test]\n fn completes_trait_associated_method_2() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Trait { fn m(); }\n \n@@ -268,7 +275,7 @@ fn foo() { let _ = S::$0 }\n \n #[test]\n fn completes_trait_associated_method_3() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Trait { fn m(); }\n \n@@ -285,7 +292,7 @@ fn foo() { let _ = <S as Trait>::$0 }\n \n #[test]\n fn completes_ty_param_assoc_ty() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Super {\n     type Ty;\n@@ -318,7 +325,7 @@ fn foo<T: Sub>() { T::$0 }\n \n #[test]\n fn completes_self_param_assoc_ty() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Super {\n     type Ty;\n@@ -358,7 +365,7 @@ impl<T> Sub for Wrap<T> {\n \n #[test]\n fn completes_type_alias() {\n-    check(\n+    check_no_kw(\n         r#\"\n struct S;\n impl S { fn foo() {} }\n@@ -376,7 +383,7 @@ fn main() { T::$0; }\n \n #[test]\n fn completes_qualified_macros() {\n-    check(\n+    check_no_kw(\n         r#\"\n #[macro_export]\n macro_rules! foo { () => {} }\n@@ -392,7 +399,7 @@ fn main() { let _ = crate::$0 }\n \n #[test]\n fn does_not_complete_non_fn_macros() {\n-    check(\n+    check_no_kw(\n         r#\"\n mod m {\n     #[rustc_builtin_macro]\n@@ -403,7 +410,7 @@ fn f() {m::$0}\n \"#,\n         expect![[r#\"\"#]],\n     );\n-    check(\n+    check_no_kw(\n         r#\"\n mod m {\n     #[rustc_builtin_macro]\n@@ -418,7 +425,7 @@ fn f() {m::$0}\n \n #[test]\n fn completes_reexported_items_under_correct_name() {\n-    check(\n+    check_no_kw(\n         r#\"\n fn foo() { self::m::$0 }\n \n@@ -475,7 +482,7 @@ mod p {\n \n #[test]\n fn completes_in_simple_macro_call() {\n-    check(\n+    check_no_kw(\n         r#\"\n macro_rules! m { ($e:expr) => { $e } }\n fn main() { m!(self::f$0); }\n@@ -490,7 +497,7 @@ fn foo() {}\n \n #[test]\n fn function_mod_share_name() {\n-    check(\n+    check_no_kw(\n         r#\"\n fn foo() { self::m::$0 }\n \n@@ -508,7 +515,7 @@ mod m {\n \n #[test]\n fn completes_hashmap_new() {\n-    check(\n+    check_no_kw(\n         r#\"\n struct RandomState;\n struct HashMap<K, V, S = RandomState> {}\n@@ -529,7 +536,7 @@ fn foo() {\n #[test]\n fn completes_variant_through_self() {\n     cov_mark::check!(completes_variant_through_self);\n-    check(\n+    check_no_kw(\n         r#\"\n enum Foo {\n     Bar,\n@@ -552,7 +559,7 @@ impl Foo {\n \n #[test]\n fn completes_non_exhaustive_variant_within_the_defining_crate() {\n-    check(\n+    check_no_kw(\n         r#\"\n enum Foo {\n     #[non_exhaustive]\n@@ -570,7 +577,7 @@ fn foo(self) {\n             \"#]],\n     );\n \n-    check(\n+    check_no_kw(\n         r#\"\n //- /main.rs crate:main deps:e\n fn foo(self) {\n@@ -593,7 +600,7 @@ enum Foo {\n #[test]\n fn completes_primitive_assoc_const() {\n     cov_mark::check!(completes_primitive_assoc_const);\n-    check(\n+    check_no_kw(\n         r#\"\n //- /lib.rs crate:lib deps:core\n fn f() {\n@@ -618,7 +625,7 @@ impl u8 {\n #[test]\n fn completes_variant_through_alias() {\n     cov_mark::check!(completes_variant_through_alias);\n-    check(\n+    check_no_kw(\n         r#\"\n enum Foo {\n     Bar\n@@ -636,7 +643,7 @@ fn main() {\n \n #[test]\n fn respects_doc_hidden2() {\n-    check(\n+    check_no_kw(\n         r#\"\n //- /lib.rs crate:lib deps:dep\n fn f() {\n@@ -665,7 +672,7 @@ pub mod m {}\n \n #[test]\n fn type_anchor_empty() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Foo {\n     fn foo() -> Self;\n@@ -688,7 +695,7 @@ fn bar() -> Bar {\n \n #[test]\n fn type_anchor_type() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Foo {\n     fn foo() -> Self;\n@@ -715,7 +722,7 @@ fn bar() -> Bar {\n \n #[test]\n fn type_anchor_type_trait() {\n-    check(\n+    check_no_kw(\n         r#\"\n trait Foo {\n     fn foo() -> Self;\n@@ -741,7 +748,7 @@ fn bar() -> Bar {\n \n #[test]\n fn completes_fn_in_pub_trait_generated_by_macro() {\n-    check(\n+    check_no_kw(\n         r#\"\n mod other_mod {\n     macro_rules! make_method {\n@@ -775,7 +782,7 @@ fn main() {\n \n #[test]\n fn completes_fn_in_pub_trait_generated_by_recursive_macro() {\n-    check(\n+    check_no_kw(\n         r#\"\n mod other_mod {\n     macro_rules! make_method {\n@@ -815,7 +822,7 @@ fn main() {\n \n #[test]\n fn completes_const_in_pub_trait_generated_by_macro() {\n-    check(\n+    check_no_kw(\n         r#\"\n mod other_mod {\n     macro_rules! make_const {\n@@ -847,7 +854,7 @@ fn main() {\n \n #[test]\n fn completes_locals_from_macros() {\n-    check(\n+    check_no_kw(\n         r#\"\n \n macro_rules! x {\n@@ -875,7 +882,7 @@ fn main() {\n \n #[test]\n fn regression_12644() {\n-    check(\n+    check_no_kw(\n         r#\"\n macro_rules! __rust_force_expr {\n     ($e:expr) => {\n@@ -974,7 +981,7 @@ fn foo { crate:::$0 }\n \"#,\n         expect![\"\"],\n     );\n-    check(\n+    check_no_kw(\n         r#\"\n fn foo { crate::::$0 }\n \"#,"}, {"sha": "57daaf623df29864c47bbe1bc1f9841fc8066316", "filename": "src/tools/rust-analyzer/crates/ide-db/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2FCargo.toml?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -37,8 +37,9 @@ text-edit.workspace = true\n hir.workspace = true\n \n [dev-dependencies]\n-xshell = \"0.2.2\"\n expect-test = \"1.4.0\"\n+oorandom = \"11.1.3\"\n+xshell = \"0.2.2\"\n \n # local deps\n test-utils.workspace = true"}, {"sha": "2b6b60547b355e9bb41f6f381f479f8101ddbbc4", "filename": "src/tools/rust-analyzer/crates/ide-db/src/active_parameter.rs", "status": "modified", "additions": 73, "deletions": 7, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Factive_parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Factive_parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Factive_parameter.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -2,9 +2,10 @@\n \n use either::Either;\n use hir::{Semantics, Type};\n+use parser::T;\n use syntax::{\n     ast::{self, HasArgList, HasName},\n-    AstNode, SyntaxToken,\n+    match_ast, AstNode, NodeOrToken, SyntaxToken,\n };\n \n use crate::RootDatabase;\n@@ -58,21 +59,86 @@ pub fn callable_for_node(\n     calling_node: &ast::CallableExpr,\n     token: &SyntaxToken,\n ) -> Option<(hir::Callable, Option<usize>)> {\n-    let callable = match &calling_node {\n+    let callable = match calling_node {\n         ast::CallableExpr::Call(call) => {\n             let expr = call.expr()?;\n             sema.type_of_expr(&expr)?.adjusted().as_callable(sema.db)\n         }\n         ast::CallableExpr::MethodCall(call) => sema.resolve_method_call_as_callable(call),\n     }?;\n     let active_param = if let Some(arg_list) = calling_node.arg_list() {\n-        let param = arg_list\n-            .args()\n-            .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n-            .count();\n-        Some(param)\n+        Some(\n+            arg_list\n+                .syntax()\n+                .children_with_tokens()\n+                .filter_map(NodeOrToken::into_token)\n+                .filter(|t| t.kind() == T![,])\n+                .take_while(|t| t.text_range().start() <= token.text_range().start())\n+                .count(),\n+        )\n     } else {\n         None\n     };\n     Some((callable, active_param))\n }\n+\n+pub fn generic_def_for_node(\n+    sema: &Semantics<'_, RootDatabase>,\n+    generic_arg_list: &ast::GenericArgList,\n+    token: &SyntaxToken,\n+) -> Option<(hir::GenericDef, usize, bool)> {\n+    let parent = generic_arg_list.syntax().parent()?;\n+    let def = match_ast! {\n+        match parent {\n+            ast::PathSegment(ps) => {\n+                let res = sema.resolve_path(&ps.parent_path())?;\n+                let generic_def: hir::GenericDef = match res {\n+                    hir::PathResolution::Def(hir::ModuleDef::Adt(it)) => it.into(),\n+                    hir::PathResolution::Def(hir::ModuleDef::Function(it)) => it.into(),\n+                    hir::PathResolution::Def(hir::ModuleDef::Trait(it)) => it.into(),\n+                    hir::PathResolution::Def(hir::ModuleDef::TypeAlias(it)) => it.into(),\n+                    hir::PathResolution::Def(hir::ModuleDef::Variant(it)) => it.into(),\n+                    hir::PathResolution::Def(hir::ModuleDef::BuiltinType(_))\n+                    | hir::PathResolution::Def(hir::ModuleDef::Const(_))\n+                    | hir::PathResolution::Def(hir::ModuleDef::Macro(_))\n+                    | hir::PathResolution::Def(hir::ModuleDef::Module(_))\n+                    | hir::PathResolution::Def(hir::ModuleDef::Static(_)) => return None,\n+                    hir::PathResolution::BuiltinAttr(_)\n+                    | hir::PathResolution::ToolModule(_)\n+                    | hir::PathResolution::Local(_)\n+                    | hir::PathResolution::TypeParam(_)\n+                    | hir::PathResolution::ConstParam(_)\n+                    | hir::PathResolution::SelfType(_)\n+                    | hir::PathResolution::DeriveHelper(_) => return None,\n+                };\n+\n+                generic_def\n+            },\n+            ast::AssocTypeArg(_) => {\n+                // FIXME: We don't record the resolutions for this anywhere atm\n+                return None;\n+            },\n+            ast::MethodCallExpr(mcall) => {\n+                // recv.method::<$0>()\n+                let method = sema.resolve_method_call(&mcall)?;\n+                method.into()\n+            },\n+            _ => return None,\n+        }\n+    };\n+\n+    let active_param = generic_arg_list\n+        .syntax()\n+        .children_with_tokens()\n+        .filter_map(NodeOrToken::into_token)\n+        .filter(|t| t.kind() == T![,])\n+        .take_while(|t| t.text_range().start() <= token.text_range().start())\n+        .count();\n+\n+    let first_arg_is_non_lifetime = generic_arg_list\n+        .generic_args()\n+        .next()\n+        .map_or(false, |arg| !matches!(arg, ast::GenericArg::LifetimeArg(_)));\n+\n+    Some((def, active_param, first_arg_is_non_lifetime))\n+}"}, {"sha": "16814a1e636fa2e51376bd86cafb7ab0d3215927", "filename": "src/tools/rust-analyzer/crates/ide-db/src/line_index.rs", "status": "modified", "additions": 103, "deletions": 92, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fline_index.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -7,56 +7,72 @@ use syntax::{TextRange, TextSize};\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct LineIndex {\n-    /// Offset the the beginning of each line, zero-based\n+    /// Offset the beginning of each line, zero-based.\n     pub(crate) newlines: Vec<TextSize>,\n-    /// List of non-ASCII characters on each line\n-    pub(crate) utf16_lines: NoHashHashMap<u32, Vec<Utf16Char>>,\n+    /// List of non-ASCII characters on each line.\n+    pub(crate) line_wide_chars: NoHashHashMap<u32, Vec<WideChar>>,\n }\n \n+/// Line/Column information in native, utf8 format.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct LineColUtf16 {\n+pub struct LineCol {\n     /// Zero-based\n     pub line: u32,\n-    /// Zero-based\n+    /// Zero-based utf8 offset\n     pub col: u32,\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub struct LineCol {\n+pub enum WideEncoding {\n+    Utf16,\n+    Utf32,\n+}\n+\n+/// Line/Column information in legacy encodings.\n+///\n+/// Deliberately not a generic type and different from `LineCol`.\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct WideLineCol {\n     /// Zero-based\n     pub line: u32,\n-    /// Zero-based utf8 offset\n+    /// Zero-based\n     pub col: u32,\n }\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n-pub(crate) struct Utf16Char {\n+pub(crate) struct WideChar {\n     /// Start offset of a character inside a line, zero-based\n     pub(crate) start: TextSize,\n     /// End offset of a character inside a line, zero-based\n     pub(crate) end: TextSize,\n }\n \n-impl Utf16Char {\n+impl WideChar {\n     /// Returns the length in 8-bit UTF-8 code units.\n     fn len(&self) -> TextSize {\n         self.end - self.start\n     }\n \n-    /// Returns the length in 16-bit UTF-16 code units.\n-    fn len_utf16(&self) -> usize {\n-        if self.len() == TextSize::from(4) {\n-            2\n-        } else {\n-            1\n+    /// Returns the length in UTF-16 or UTF-32 code units.\n+    fn wide_len(&self, enc: WideEncoding) -> usize {\n+        match enc {\n+            WideEncoding::Utf16 => {\n+                if self.len() == TextSize::from(4) {\n+                    2\n+                } else {\n+                    1\n+                }\n+            }\n+\n+            WideEncoding::Utf32 => 1,\n         }\n     }\n }\n \n impl LineIndex {\n     pub fn new(text: &str) -> LineIndex {\n-        let mut utf16_lines = NoHashHashMap::default();\n-        let mut utf16_chars = Vec::new();\n+        let mut line_wide_chars = NoHashHashMap::default();\n+        let mut wide_chars = Vec::new();\n \n         let mut newlines = Vec::with_capacity(16);\n         newlines.push(TextSize::from(0));\n@@ -71,8 +87,8 @@ impl LineIndex {\n                 newlines.push(curr_row);\n \n                 // Save any utf-16 characters seen in the previous line\n-                if !utf16_chars.is_empty() {\n-                    utf16_lines.insert(line, mem::take(&mut utf16_chars));\n+                if !wide_chars.is_empty() {\n+                    line_wide_chars.insert(line, mem::take(&mut wide_chars));\n                 }\n \n                 // Prepare for processing the next line\n@@ -82,18 +98,18 @@ impl LineIndex {\n             }\n \n             if !c.is_ascii() {\n-                utf16_chars.push(Utf16Char { start: curr_col, end: curr_col + c_len });\n+                wide_chars.push(WideChar { start: curr_col, end: curr_col + c_len });\n             }\n \n             curr_col += c_len;\n         }\n \n         // Save any utf-16 characters seen in the last line\n-        if !utf16_chars.is_empty() {\n-            utf16_lines.insert(line, utf16_chars);\n+        if !wide_chars.is_empty() {\n+            line_wide_chars.insert(line, wide_chars);\n         }\n \n-        LineIndex { newlines, utf16_lines }\n+        LineIndex { newlines, line_wide_chars }\n     }\n \n     pub fn line_col(&self, offset: TextSize) -> LineCol {\n@@ -109,13 +125,13 @@ impl LineIndex {\n             .map(|offset| offset + TextSize::from(line_col.col))\n     }\n \n-    pub fn to_utf16(&self, line_col: LineCol) -> LineColUtf16 {\n-        let col = self.utf8_to_utf16_col(line_col.line, line_col.col.into());\n-        LineColUtf16 { line: line_col.line, col: col as u32 }\n+    pub fn to_wide(&self, enc: WideEncoding, line_col: LineCol) -> WideLineCol {\n+        let col = self.utf8_to_wide_col(enc, line_col.line, line_col.col.into());\n+        WideLineCol { line: line_col.line, col: col as u32 }\n     }\n \n-    pub fn to_utf8(&self, line_col: LineColUtf16) -> LineCol {\n-        let col = self.utf16_to_utf8_col(line_col.line, line_col.col);\n+    pub fn to_utf8(&self, enc: WideEncoding, line_col: WideLineCol) -> LineCol {\n+        let col = self.wide_to_utf8_col(enc, line_col.line, line_col.col);\n         LineCol { line: line_col.line, col: col.into() }\n     }\n \n@@ -132,12 +148,12 @@ impl LineIndex {\n             .filter(|it| !it.is_empty())\n     }\n \n-    fn utf8_to_utf16_col(&self, line: u32, col: TextSize) -> usize {\n+    fn utf8_to_wide_col(&self, enc: WideEncoding, line: u32, col: TextSize) -> usize {\n         let mut res: usize = col.into();\n-        if let Some(utf16_chars) = self.utf16_lines.get(&line) {\n-            for c in utf16_chars {\n+        if let Some(wide_chars) = self.line_wide_chars.get(&line) {\n+            for c in wide_chars {\n                 if c.end <= col {\n-                    res -= usize::from(c.len()) - c.len_utf16();\n+                    res -= usize::from(c.len()) - c.wide_len(enc);\n                 } else {\n                     // From here on, all utf16 characters come *after* the character we are mapping,\n                     // so we don't need to take them into account\n@@ -148,11 +164,11 @@ impl LineIndex {\n         res\n     }\n \n-    fn utf16_to_utf8_col(&self, line: u32, mut col: u32) -> TextSize {\n-        if let Some(utf16_chars) = self.utf16_lines.get(&line) {\n-            for c in utf16_chars {\n+    fn wide_to_utf8_col(&self, enc: WideEncoding, line: u32, mut col: u32) -> TextSize {\n+        if let Some(wide_chars) = self.line_wide_chars.get(&line) {\n+            for c in wide_chars {\n                 if col > u32::from(c.start) {\n-                    col += u32::from(c.len()) - c.len_utf16() as u32;\n+                    col += u32::from(c.len()) - c.wide_len(enc) as u32;\n                 } else {\n                     // From here on, all utf16 characters come *after* the character we are mapping,\n                     // so we don't need to take them into account\n@@ -167,6 +183,9 @@ impl LineIndex {\n \n #[cfg(test)]\n mod tests {\n+    use test_utils::skip_slow_tests;\n+\n+    use super::WideEncoding::{Utf16, Utf32};\n     use super::*;\n \n     #[test]\n@@ -210,67 +229,59 @@ mod tests {\n const C: char = 'x';\n \",\n         );\n-        assert_eq!(col_index.utf16_lines.len(), 0);\n+        assert_eq!(col_index.line_wide_chars.len(), 0);\n     }\n \n     #[test]\n-    fn test_single_char() {\n-        let col_index = LineIndex::new(\n-            \"\n-const C: char = '\u30e1';\n-\",\n-        );\n-\n-        assert_eq!(col_index.utf16_lines.len(), 1);\n-        assert_eq!(col_index.utf16_lines[&1].len(), 1);\n-        assert_eq!(col_index.utf16_lines[&1][0], Utf16Char { start: 17.into(), end: 20.into() });\n-\n-        // UTF-8 to UTF-16, no changes\n-        assert_eq!(col_index.utf8_to_utf16_col(1, 15.into()), 15);\n-\n-        // UTF-8 to UTF-16\n-        assert_eq!(col_index.utf8_to_utf16_col(1, 22.into()), 20);\n-\n-        // UTF-16 to UTF-8, no changes\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 15), TextSize::from(15));\n-\n-        // UTF-16 to UTF-8\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 19), TextSize::from(21));\n-\n-        let col_index = LineIndex::new(\"a\ud801\udc0fb\");\n-        assert_eq!(col_index.utf16_to_utf8_col(0, 3), TextSize::from(5));\n-    }\n-\n-    #[test]\n-    fn test_string() {\n-        let col_index = LineIndex::new(\n-            \"\n-const C: char = \\\"\u30e1 \u30e1\\\";\n-\",\n-        );\n-\n-        assert_eq!(col_index.utf16_lines.len(), 1);\n-        assert_eq!(col_index.utf16_lines[&1].len(), 2);\n-        assert_eq!(col_index.utf16_lines[&1][0], Utf16Char { start: 17.into(), end: 20.into() });\n-        assert_eq!(col_index.utf16_lines[&1][1], Utf16Char { start: 21.into(), end: 24.into() });\n-\n-        // UTF-8 to UTF-16\n-        assert_eq!(col_index.utf8_to_utf16_col(1, 15.into()), 15);\n-\n-        assert_eq!(col_index.utf8_to_utf16_col(1, 21.into()), 19);\n-        assert_eq!(col_index.utf8_to_utf16_col(1, 25.into()), 21);\n-\n-        assert!(col_index.utf8_to_utf16_col(2, 15.into()) == 15);\n-\n-        // UTF-16 to UTF-8\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 15), TextSize::from(15));\n+    fn test_every_chars() {\n+        if skip_slow_tests() {\n+            return;\n+        }\n \n-        // \u30e1 UTF-8: 0xE3 0x83 0xA1, UTF-16: 0x30E1\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 17), TextSize::from(17)); // first \u30e1 at 17..20\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 18), TextSize::from(20)); // space\n-        assert_eq!(col_index.utf16_to_utf8_col(1, 19), TextSize::from(21)); // second \u30e1 at 21..24\n+        let text: String = {\n+            let mut chars: Vec<char> = ((0 as char)..char::MAX).collect(); // Neat!\n+            chars.extend(\"\\n\".repeat(chars.len() / 16).chars());\n+            let mut rng = oorandom::Rand32::new(stdx::rand::seed());\n+            stdx::rand::shuffle(&mut chars, |i| rng.rand_range(0..i as u32) as usize);\n+            chars.into_iter().collect()\n+        };\n+        assert!(text.contains('\ud83d\udca9')); // Sanity check.\n+\n+        let line_index = LineIndex::new(&text);\n+\n+        let mut lin_col = LineCol { line: 0, col: 0 };\n+        let mut col_utf16 = 0;\n+        let mut col_utf32 = 0;\n+        for (offset, c) in text.char_indices() {\n+            let got_offset = line_index.offset(lin_col).unwrap();\n+            assert_eq!(usize::from(got_offset), offset);\n+\n+            let got_lin_col = line_index.line_col(got_offset);\n+            assert_eq!(got_lin_col, lin_col);\n+\n+            for enc in [Utf16, Utf32] {\n+                let wide_lin_col = line_index.to_wide(enc, lin_col);\n+                let got_lin_col = line_index.to_utf8(enc, wide_lin_col);\n+                assert_eq!(got_lin_col, lin_col);\n+\n+                let want_col = match enc {\n+                    Utf16 => col_utf16,\n+                    Utf32 => col_utf32,\n+                };\n+                assert_eq!(wide_lin_col.col, want_col)\n+            }\n \n-        assert_eq!(col_index.utf16_to_utf8_col(2, 15), TextSize::from(15));\n+            if c == '\\n' {\n+                lin_col.line += 1;\n+                lin_col.col = 0;\n+                col_utf16 = 0;\n+                col_utf32 = 0;\n+            } else {\n+                lin_col.col += c.len_utf8() as u32;\n+                col_utf16 += c.len_utf16() as u32;\n+                col_utf32 += 1;\n+            }\n+        }\n     }\n \n     #[test]"}, {"sha": "c18a27f17d22cdcd5253299a59484405b04b28fc", "filename": "src/tools/rust-analyzer/crates/ide-db/src/search.rs", "status": "modified", "additions": 40, "deletions": 42, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsearch.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -455,46 +455,45 @@ impl<'a> FindUsages<'a> {\n         }\n \n         let find_nodes = move |name: &str, node: &syntax::SyntaxNode, offset: TextSize| {\n-            node.token_at_offset(offset).find(|it| it.text() == name).map(|token| {\n-                // FIXME: There should be optimization potential here\n-                // Currently we try to descend everything we find which\n-                // means we call `Semantics::descend_into_macros` on\n-                // every textual hit. That function is notoriously\n-                // expensive even for things that do not get down mapped\n-                // into macros.\n-                sema.descend_into_macros(token).into_iter().filter_map(|it| it.parent())\n-            })\n+            node.token_at_offset(offset)\n+                .find(|it| {\n+                    // `name` is stripped of raw ident prefix. See the comment on name retrieval above.\n+                    it.text().trim_start_matches(\"r#\") == name\n+                })\n+                .into_iter()\n+                .flat_map(|token| {\n+                    // FIXME: There should be optimization potential here\n+                    // Currently we try to descend everything we find which\n+                    // means we call `Semantics::descend_into_macros` on\n+                    // every textual hit. That function is notoriously\n+                    // expensive even for things that do not get down mapped\n+                    // into macros.\n+                    sema.descend_into_macros(token).into_iter().filter_map(|it| it.parent())\n+                })\n         };\n \n         for (text, file_id, search_range) in scope_files(sema, &search_scope) {\n             let tree = Lazy::new(move || sema.parse(file_id).syntax().clone());\n \n             // Search for occurrences of the items name\n             for offset in match_indices(&text, finder, search_range) {\n-                if let Some(iter) = find_nodes(name, &tree, offset) {\n-                    for name in iter.filter_map(ast::NameLike::cast) {\n-                        if match name {\n-                            ast::NameLike::NameRef(name_ref) => {\n-                                self.found_name_ref(&name_ref, sink)\n-                            }\n-                            ast::NameLike::Name(name) => self.found_name(&name, sink),\n-                            ast::NameLike::Lifetime(lifetime) => {\n-                                self.found_lifetime(&lifetime, sink)\n-                            }\n-                        } {\n-                            return;\n-                        }\n+                for name in find_nodes(name, &tree, offset).filter_map(ast::NameLike::cast) {\n+                    if match name {\n+                        ast::NameLike::NameRef(name_ref) => self.found_name_ref(&name_ref, sink),\n+                        ast::NameLike::Name(name) => self.found_name(&name, sink),\n+                        ast::NameLike::Lifetime(lifetime) => self.found_lifetime(&lifetime, sink),\n+                    } {\n+                        return;\n                     }\n                 }\n             }\n             // Search for occurrences of the `Self` referring to our type\n             if let Some((self_ty, finder)) = &include_self_kw_refs {\n                 for offset in match_indices(&text, finder, search_range) {\n-                    if let Some(iter) = find_nodes(\"Self\", &tree, offset) {\n-                        for name_ref in iter.filter_map(ast::NameRef::cast) {\n-                            if self.found_self_ty_name_ref(self_ty, &name_ref, sink) {\n-                                return;\n-                            }\n+                    for name_ref in find_nodes(\"Self\", &tree, offset).filter_map(ast::NameRef::cast)\n+                    {\n+                        if self.found_self_ty_name_ref(self_ty, &name_ref, sink) {\n+                            return;\n                         }\n                     }\n                 }\n@@ -513,21 +512,21 @@ impl<'a> FindUsages<'a> {\n                 let tree = Lazy::new(move || sema.parse(file_id).syntax().clone());\n \n                 for offset in match_indices(&text, finder, search_range) {\n-                    if let Some(iter) = find_nodes(\"super\", &tree, offset) {\n-                        for name_ref in iter.filter_map(ast::NameRef::cast) {\n-                            if self.found_name_ref(&name_ref, sink) {\n-                                return;\n-                            }\n+                    for name_ref in\n+                        find_nodes(\"super\", &tree, offset).filter_map(ast::NameRef::cast)\n+                    {\n+                        if self.found_name_ref(&name_ref, sink) {\n+                            return;\n                         }\n                     }\n                 }\n                 if let Some(finder) = &is_crate_root {\n                     for offset in match_indices(&text, finder, search_range) {\n-                        if let Some(iter) = find_nodes(\"crate\", &tree, offset) {\n-                            for name_ref in iter.filter_map(ast::NameRef::cast) {\n-                                if self.found_name_ref(&name_ref, sink) {\n-                                    return;\n-                                }\n+                        for name_ref in\n+                            find_nodes(\"crate\", &tree, offset).filter_map(ast::NameRef::cast)\n+                        {\n+                            if self.found_name_ref(&name_ref, sink) {\n+                                return;\n                             }\n                         }\n                     }\n@@ -566,11 +565,10 @@ impl<'a> FindUsages<'a> {\n                 let finder = &Finder::new(\"self\");\n \n                 for offset in match_indices(&text, finder, search_range) {\n-                    if let Some(iter) = find_nodes(\"self\", &tree, offset) {\n-                        for name_ref in iter.filter_map(ast::NameRef::cast) {\n-                            if self.found_self_module_name_ref(&name_ref, sink) {\n-                                return;\n-                            }\n+                    for name_ref in find_nodes(\"self\", &tree, offset).filter_map(ast::NameRef::cast)\n+                    {\n+                        if self.found_self_module_name_ref(&name_ref, sink) {\n+                            return;\n                         }\n                     }\n                 }"}, {"sha": "30e514e4136a4243290d1bb5ca136711eb22cc60", "filename": "src/tools/rust-analyzer/crates/ide/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2FCargo.toml?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -22,7 +22,7 @@ pulldown-cmark-to-cmark = \"10.0.4\"\n pulldown-cmark = { version = \"0.9.1\", default-features = false }\n url = \"2.3.1\"\n dot = \"0.1.4\"\n-smallvec = \"1.10.0\"\n+smallvec.workspace = true\n \n # local deps\n cfg.workspace = true"}, {"sha": "5f2c61f5b5f80afdb7bef5d3a474fda9a90e2dc1", "filename": "src/tools/rust-analyzer/crates/ide/src/hover.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -201,6 +201,23 @@ fn hover_simple(\n \n                 Some(render::struct_rest_pat(sema, config, &record_pat))\n             })\n+        })\n+        // try () call hovers\n+        .or_else(|| {\n+            descended().find_map(|token| {\n+                if token.kind() != T!['('] && token.kind() != T![')'] {\n+                    return None;\n+                }\n+                let arg_list = token.parent().and_then(ast::ArgList::cast)?.syntax().parent()?;\n+                let call_expr = syntax::match_ast! {\n+                    match arg_list {\n+                        ast::CallExpr(expr) => expr.into(),\n+                        ast::MethodCallExpr(expr) => expr.into(),\n+                        _ => return None,\n+                    }\n+                };\n+                render::type_info_of(sema, config, &Either::Left(call_expr))\n+            })\n         });\n \n     result.map(|mut res: HoverResult| {"}, {"sha": "bd7ce2f1d0d079eee1a166c86615ac54af1e641f", "filename": "src/tools/rust-analyzer/crates/ide/src/hover/tests.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -5612,3 +5612,38 @@ fn main() {\n \"#,\n     );\n }\n+\n+#[test]\n+fn hover_call_parens() {\n+    check(\n+        r#\"\n+fn foo() -> i32 {}\n+fn main() {\n+    foo($0);\n+}\n+\"#,\n+        expect![[r#\"\n+            *)*\n+            ```rust\n+            i32\n+            ```\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+struct S;\n+impl S {\n+    fn foo(self) -> i32 {}\n+}\n+fn main() {\n+    S.foo($0);\n+}\n+\"#,\n+        expect![[r#\"\n+            *)*\n+            ```rust\n+            i32\n+            ```\n+        \"#]],\n+    );\n+}"}, {"sha": "5d9729263c270381b4e7c9dfd81754fa22e64775", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints/binding_mode.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fbinding_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fbinding_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints%2Fbinding_mode.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -29,8 +29,17 @@ pub(super) fn hints(\n             _ => None,\n         })\n         .last();\n-    let range =\n-        outer_paren_pat.as_ref().map_or_else(|| pat.syntax(), |it| it.syntax()).text_range();\n+    let range = outer_paren_pat.as_ref().map_or_else(\n+        || match pat {\n+            // for ident patterns that @ bind a name, render the un-ref patterns in front of the inner pattern\n+            // instead of the name as that makes it more clear and doesn't really change the outcome\n+            ast::Pat::IdentPat(it) => {\n+                it.pat().map_or_else(|| it.syntax().text_range(), |it| it.syntax().text_range())\n+            }\n+            it => it.syntax().text_range(),\n+        },\n+        |it| it.syntax().text_range(),\n+    );\n     let pattern_adjustments = sema.pattern_adjustments(pat);\n     pattern_adjustments.iter().for_each(|ty| {\n         let reference = ty.is_reference();\n@@ -123,4 +132,20 @@ fn __(\n }\"#,\n         );\n     }\n+\n+    #[test]\n+    fn hints_binding_modes_complex_ident_pat() {\n+        check_with_config(\n+            InlayHintsConfig { binding_mode_hints: true, ..DISABLED_CONFIG },\n+            r#\"\n+struct Struct {\n+    field: &'static str,\n+}\n+fn foo(s @ Struct { field, .. }: &Struct) {}\n+     //^^^^^^^^^^^^^^^^^^^^^^^^ref\n+         //^^^^^^^^^^^^^^^^^^^^&\n+                  //^^^^^ref\n+\"#,\n+        );\n+    }\n }"}, {"sha": "f2b535bdc7efed42599e2c7a29b8fbdcf215d63a", "filename": "src/tools/rust-analyzer/crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Flib.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -115,7 +115,7 @@ pub use ide_db::{\n         SourceRoot, SourceRootId,\n     },\n     label::Label,\n-    line_index::{LineCol, LineColUtf16, LineIndex},\n+    line_index::{LineCol, LineIndex},\n     search::{ReferenceCategory, SearchScope},\n     source_change::{FileSystemEdit, SourceChange},\n     symbol_index::Query,"}, {"sha": "cabbc287279f691938c5ec45f68edb31462acfda", "filename": "src/tools/rust-analyzer/crates/ide/src/references.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Freferences.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -2016,4 +2016,19 @@ fn method$0() {}\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn raw_identifier() {\n+        check(\n+            r#\"\n+fn r#fn$0() {}\n+fn main() { r#fn(); }\n+\"#,\n+            expect![[r#\"\n+                r#fn Function FileId(0) 0..12 3..7\n+\n+                FileId(0) 25..29\n+            \"#]],\n+        );\n+    }\n }"}, {"sha": "c0237e1edd0d39fe5e2cece547bbdbaf200799dc", "filename": "src/tools/rust-analyzer/crates/ide/src/rename.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Frename.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1371,7 +1371,6 @@ pub fn baz() {}\n \n     #[test]\n     fn test_rename_mod_from_raw_ident() {\n-        // FIXME: `r#fn` in path expression is not renamed.\n         check_expect(\n             \"foo\",\n             r#\"\n@@ -1397,6 +1396,10 @@ pub fn baz() {}\n                                     insert: \"foo\",\n                                     delete: 4..8,\n                                 },\n+                                Indel {\n+                                    insert: \"foo\",\n+                                    delete: 23..27,\n+                                },\n                             ],\n                         },\n                     },"}, {"sha": "e606072a82375de5c67dda98688b272bce281441", "filename": "src/tools/rust-analyzer/crates/ide/src/shuffle_crate_graph.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fshuffle_crate_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fshuffle_crate_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fshuffle_crate_graph.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -18,7 +18,9 @@ pub(crate) fn shuffle_crate_graph(db: &mut RootDatabase) {\n     let crate_graph = db.crate_graph();\n \n     let mut shuffled_ids = crate_graph.iter().collect::<Vec<_>>();\n-    shuffle(&mut shuffled_ids);\n+\n+    let mut rng = oorandom::Rand32::new(stdx::rand::seed());\n+    stdx::rand::shuffle(&mut shuffled_ids, |i| rng.rand_range(0..i as u32) as usize);\n \n     let mut new_graph = CrateGraph::default();\n \n@@ -52,21 +54,3 @@ pub(crate) fn shuffle_crate_graph(db: &mut RootDatabase) {\n \n     db.set_crate_graph_with_durability(Arc::new(new_graph), Durability::HIGH);\n }\n-\n-fn shuffle<T>(slice: &mut [T]) {\n-    let mut rng = oorandom::Rand32::new(seed());\n-\n-    let mut remaining = slice.len() - 1;\n-    while remaining > 0 {\n-        let index = rng.rand_range(0..remaining as u32);\n-        slice.swap(remaining, index as usize);\n-        remaining -= 1;\n-    }\n-}\n-\n-fn seed() -> u64 {\n-    use std::collections::hash_map::RandomState;\n-    use std::hash::{BuildHasher, Hasher};\n-\n-    RandomState::new().build_hasher().finish()\n-}"}, {"sha": "f70ca55a508d2b8045e841aa668b2a422342560b", "filename": "src/tools/rust-analyzer/crates/ide/src/signature_help.rs", "status": "modified", "additions": 49, "deletions": 75, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsignature_help.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -7,12 +7,16 @@ use either::Either;\n use hir::{\n     AssocItem, GenericParam, HasAttrs, HirDisplay, ModuleDef, PathResolution, Semantics, Trait,\n };\n-use ide_db::{active_parameter::callable_for_node, base_db::FilePosition, FxIndexMap};\n+use ide_db::{\n+    active_parameter::{callable_for_node, generic_def_for_node},\n+    base_db::FilePosition,\n+    FxIndexMap,\n+};\n use stdx::format_to;\n use syntax::{\n     algo,\n     ast::{self, HasArgList},\n-    match_ast, AstNode, Direction, SyntaxKind, SyntaxToken, TextRange, TextSize,\n+    match_ast, AstNode, Direction, SyntaxToken, TextRange, TextSize,\n };\n \n use crate::RootDatabase;\n@@ -105,10 +109,10 @@ pub(crate) fn signature_help(db: &RootDatabase, position: FilePosition) -> Optio\n         // Stop at multi-line expressions, since the signature of the outer call is not very\n         // helpful inside them.\n         if let Some(expr) = ast::Expr::cast(node.clone()) {\n-            if expr.syntax().text().contains_char('\\n')\n-                && expr.syntax().kind() != SyntaxKind::RECORD_EXPR\n+            if !matches!(expr, ast::Expr::RecordExpr(..))\n+                && expr.syntax().text().contains_char('\\n')\n             {\n-                return None;\n+                break;\n             }\n         }\n     }\n@@ -122,18 +126,16 @@ fn signature_help_for_call(\n     token: SyntaxToken,\n ) -> Option<SignatureHelp> {\n     // Find the calling expression and its NameRef\n-    let mut node = arg_list.syntax().parent()?;\n+    let mut nodes = arg_list.syntax().ancestors().skip(1);\n     let calling_node = loop {\n-        if let Some(callable) = ast::CallableExpr::cast(node.clone()) {\n-            if callable\n+        if let Some(callable) = ast::CallableExpr::cast(nodes.next()?) {\n+            let inside_callable = callable\n                 .arg_list()\n-                .map_or(false, |it| it.syntax().text_range().contains(token.text_range().start()))\n-            {\n+                .map_or(false, |it| it.syntax().text_range().contains(token.text_range().start()));\n+            if inside_callable {\n                 break callable;\n             }\n         }\n-\n-        node = node.parent()?;\n     };\n \n     let (callable, active_parameter) = callable_for_node(sema, &calling_node, &token)?;\n@@ -216,59 +218,11 @@ fn signature_help_for_call(\n \n fn signature_help_for_generics(\n     sema: &Semantics<'_, RootDatabase>,\n-    garg_list: ast::GenericArgList,\n+    arg_list: ast::GenericArgList,\n     token: SyntaxToken,\n ) -> Option<SignatureHelp> {\n-    let arg_list = garg_list\n-        .syntax()\n-        .ancestors()\n-        .filter_map(ast::GenericArgList::cast)\n-        .find(|list| list.syntax().text_range().contains(token.text_range().start()))?;\n-\n-    let mut active_parameter = arg_list\n-        .generic_args()\n-        .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n-        .count();\n-\n-    let first_arg_is_non_lifetime = arg_list\n-        .generic_args()\n-        .next()\n-        .map_or(false, |arg| !matches!(arg, ast::GenericArg::LifetimeArg(_)));\n-\n-    let mut generics_def = if let Some(path) =\n-        arg_list.syntax().ancestors().find_map(ast::Path::cast)\n-    {\n-        let res = sema.resolve_path(&path)?;\n-        let generic_def: hir::GenericDef = match res {\n-            hir::PathResolution::Def(hir::ModuleDef::Adt(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::Function(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::Trait(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::TypeAlias(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::Variant(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::BuiltinType(_))\n-            | hir::PathResolution::Def(hir::ModuleDef::Const(_))\n-            | hir::PathResolution::Def(hir::ModuleDef::Macro(_))\n-            | hir::PathResolution::Def(hir::ModuleDef::Module(_))\n-            | hir::PathResolution::Def(hir::ModuleDef::Static(_)) => return None,\n-            hir::PathResolution::BuiltinAttr(_)\n-            | hir::PathResolution::ToolModule(_)\n-            | hir::PathResolution::Local(_)\n-            | hir::PathResolution::TypeParam(_)\n-            | hir::PathResolution::ConstParam(_)\n-            | hir::PathResolution::SelfType(_)\n-            | hir::PathResolution::DeriveHelper(_) => return None,\n-        };\n-\n-        generic_def\n-    } else if let Some(method_call) = arg_list.syntax().parent().and_then(ast::MethodCallExpr::cast)\n-    {\n-        // recv.method::<$0>()\n-        let method = sema.resolve_method_call(&method_call)?;\n-        method.into()\n-    } else {\n-        return None;\n-    };\n-\n+    let (mut generics_def, mut active_parameter, first_arg_is_non_lifetime) =\n+        generic_def_for_node(sema, &arg_list, &token)?;\n     let mut res = SignatureHelp {\n         doc: None,\n         signature: String::new(),\n@@ -307,9 +261,9 @@ fn signature_help_for_generics(\n             // eg. `None::<u8>`\n             // We'll use the signature of the enum, but include the docs of the variant.\n             res.doc = it.docs(db).map(|it| it.into());\n-            let it = it.parent_enum(db);\n-            format_to!(res.signature, \"enum {}\", it.name(db));\n-            generics_def = it.into();\n+            let enum_ = it.parent_enum(db);\n+            format_to!(res.signature, \"enum {}\", enum_.name(db));\n+            generics_def = enum_.into();\n         }\n         // These don't have generic args that can be specified\n         hir::GenericDef::Impl(_) | hir::GenericDef::Const(_) => return None,\n@@ -388,16 +342,13 @@ fn signature_help_for_record_lit(\n     record: ast::RecordExpr,\n     token: SyntaxToken,\n ) -> Option<SignatureHelp> {\n-    let arg_list = record\n-        .syntax()\n-        .ancestors()\n-        .filter_map(ast::RecordExpr::cast)\n-        .find(|list| list.syntax().text_range().contains(token.text_range().start()))?;\n-\n-    let active_parameter = arg_list\n+    let active_parameter = record\n         .record_expr_field_list()?\n-        .fields()\n-        .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n+        .syntax()\n+        .children_with_tokens()\n+        .filter_map(syntax::NodeOrToken::into_token)\n+        .filter(|t| t.kind() == syntax::T![,])\n+        .take_while(|t| t.text_range().start() <= token.text_range().start())\n         .count();\n \n     let mut res = SignatureHelp {\n@@ -1594,4 +1545,27 @@ impl S {\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn test_enum_in_nested_method_in_lambda() {\n+        check(\n+            r#\"\n+enum A {\n+    A,\n+    B\n+}\n+\n+fn bar(_: A) { }\n+\n+fn main() {\n+    let foo = Foo;\n+    std::thread::spawn(move || { bar(A:$0) } );\n+}\n+\"#,\n+            expect![[r#\"\n+                fn bar(_: A)\n+                       ^^^^\n+            \"#]],\n+        );\n+    }\n }"}, {"sha": "fc9b5d3ba4cd79303f3254b2306d20190e825ba7", "filename": "src/tools/rust-analyzer/crates/ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1126,5 +1126,5 @@ fn benchmark_syntax_highlighting_parser() {\n             .filter(|it| it.highlight.tag == HlTag::Symbol(SymbolKind::Function))\n             .count()\n     };\n-    assert_eq!(hash, 1609);\n+    assert_eq!(hash, 1608);\n }"}, {"sha": "82105522ebdd9fa2b32ca0cc2ed29aa02c5ac01a", "filename": "src/tools/rust-analyzer/crates/mbe/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2FCargo.toml?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -14,7 +14,7 @@ doctest = false\n [dependencies]\n cov-mark = \"2.0.0-pre.1\"\n rustc-hash = \"1.1.0\"\n-smallvec = \"1.10.0\"\n+smallvec.workspace = true\n tracing = \"0.1.35\"\n \n # local deps"}, {"sha": "6e962abd75477aa09bf20ea94f3f18d9afe4e2f1", "filename": "src/tools/rust-analyzer/crates/parser/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2FCargo.toml?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -20,4 +20,5 @@ limit.workspace = true\n [dev-dependencies]\n expect-test = \"1.4.0\"\n \n+stdx.workspace = true\n sourcegen.workspace = true"}, {"sha": "15ec9e167e025534ffb2ceb63830a96f10aaaa72", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -200,6 +200,8 @@ impl BlockLike {\n     }\n }\n \n+const VISIBILITY_FIRST: TokenSet = TokenSet::new(&[T![pub], T![crate]]);\n+\n fn opt_visibility(p: &mut Parser<'_>, in_tuple_field: bool) -> bool {\n     match p.current() {\n         T![pub] => {\n@@ -340,3 +342,31 @@ fn error_block(p: &mut Parser<'_>, message: &str) {\n     p.eat(T!['}']);\n     m.complete(p, ERROR);\n }\n+\n+/// The `parser` passed this is required to at least consume one token if it returns `true`.\n+/// If the `parser` returns false, parsing will stop.\n+fn delimited(\n+    p: &mut Parser<'_>,\n+    bra: SyntaxKind,\n+    ket: SyntaxKind,\n+    delim: SyntaxKind,\n+    first_set: TokenSet,\n+    mut parser: impl FnMut(&mut Parser<'_>) -> bool,\n+) {\n+    p.bump(bra);\n+    while !p.at(ket) && !p.at(EOF) {\n+        if !parser(p) {\n+            break;\n+        }\n+        if !p.at(delim) {\n+            if p.at_ts(first_set) {\n+                p.error(format!(\"expected {:?}\", delim));\n+            } else {\n+                break;\n+            }\n+        } else {\n+            p.bump(delim);\n+        }\n+    }\n+    p.expect(ket);\n+}"}, {"sha": "4ecaa6e6a85e9a507780f24ebc075947ff0f753f", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/attributes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fattributes.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1,5 +1,7 @@\n use super::*;\n \n+pub(super) const ATTRIBUTE_FIRST: TokenSet = TokenSet::new(&[T![#]]);\n+\n pub(super) fn inner_attrs(p: &mut Parser<'_>) {\n     while p.at(T![#]) && p.nth(1) == T![!] {\n         attr(p, true);"}, {"sha": "4b080102a2c3de1659e67d51b0ee472c5c770eb0", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/expressions.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1,5 +1,7 @@\n mod atom;\n \n+use crate::grammar::attributes::ATTRIBUTE_FIRST;\n+\n use super::*;\n \n pub(crate) use self::atom::{block_expr, match_arm_list};\n@@ -68,6 +70,12 @@ pub(super) fn stmt(p: &mut Parser<'_>, semicolon: Semicolon) {\n         Err(m) => m,\n     };\n \n+    if !p.at_ts(EXPR_FIRST) {\n+        p.err_and_bump(\"expected expression, item or let statement\");\n+        m.abandon(p);\n+        return;\n+    }\n+\n     if let Some((cm, blocklike)) = expr_stmt(p, Some(m)) {\n         if !(p.at(T!['}']) || (semicolon != Semicolon::Required && p.at(EOF))) {\n             // test no_semi_after_block\n@@ -227,6 +235,12 @@ fn expr_bp(\n         attributes::outer_attrs(p);\n         m\n     });\n+\n+    if !p.at_ts(EXPR_FIRST) {\n+        p.err_recover(\"expected expression\", atom::EXPR_RECOVERY_SET);\n+        m.abandon(p);\n+        return None;\n+    }\n     let mut lhs = match lhs(p, r) {\n         Some((lhs, blocklike)) => {\n             let lhs = lhs.extend_to(p, m);\n@@ -551,23 +565,20 @@ fn cast_expr(p: &mut Parser<'_>, lhs: CompletedMarker) -> CompletedMarker {\n     m.complete(p, CAST_EXPR)\n }\n \n+// test_err arg_list_recovery\n+// fn main() {\n+//     foo(bar::);\n+//     foo(bar:);\n+//     foo(bar+);\n+// }\n fn arg_list(p: &mut Parser<'_>) {\n     assert!(p.at(T!['(']));\n     let m = p.start();\n-    p.bump(T!['(']);\n-    while !p.at(T![')']) && !p.at(EOF) {\n-        // test arg_with_attr\n-        // fn main() {\n-        //     foo(#[attr] 92)\n-        // }\n-        if !expr(p) {\n-            break;\n-        }\n-        if !p.at(T![')']) && !p.expect(T![,]) {\n-            break;\n-        }\n-    }\n-    p.eat(T![')']);\n+    // test arg_with_attr\n+    // fn main() {\n+    //     foo(#[attr] 92)\n+    // }\n+    delimited(p, T!['('], T![')'], T![,], EXPR_FIRST.union(ATTRIBUTE_FIRST), expr);\n     m.complete(p, ARG_LIST);\n }\n "}, {"sha": "efc2603835e8f4edd524cfb07d720b241081c5da", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/expressions/atom.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -40,26 +40,28 @@ pub(super) const ATOM_EXPR_FIRST: TokenSet =\n         T!['{'],\n         T!['['],\n         T![|],\n-        T![move],\n+        T![async],\n         T![box],\n+        T![break],\n+        T![const],\n+        T![continue],\n+        T![do],\n+        T![for],\n         T![if],\n-        T![while],\n+        T![let],\n+        T![loop],\n         T![match],\n-        T![unsafe],\n+        T![move],\n         T![return],\n-        T![yield],\n-        T![do],\n-        T![break],\n-        T![continue],\n-        T![async],\n+        T![static],\n         T![try],\n-        T![const],\n-        T![loop],\n-        T![for],\n+        T![unsafe],\n+        T![while],\n+        T![yield],\n         LIFETIME_IDENT,\n     ]));\n \n-const EXPR_RECOVERY_SET: TokenSet = TokenSet::new(&[T![let]]);\n+pub(super) const EXPR_RECOVERY_SET: TokenSet = TokenSet::new(&[T![')'], T![']']]);\n \n pub(super) fn atom_expr(\n     p: &mut Parser<'_>,\n@@ -116,7 +118,7 @@ pub(super) fn atom_expr(\n                     // fn main() {\n                     //     'loop: impl\n                     // }\n-                    p.error(\"expected a loop\");\n+                    p.error(\"expected a loop or block\");\n                     m.complete(p, ERROR);\n                     return None;\n                 }\n@@ -157,7 +159,7 @@ pub(super) fn atom_expr(\n         T![for] => for_expr(p, None),\n \n         _ => {\n-            p.err_recover(\"expected expression\", EXPR_RECOVERY_SET);\n+            p.err_and_bump(\"expected expression\");\n             return None;\n         }\n     };"}, {"sha": "919d9b91ebab5dede8a8f5b3fce37348e8874338", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/generic_args.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_args.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -5,27 +5,35 @@ pub(super) fn opt_generic_arg_list(p: &mut Parser<'_>, colon_colon_required: boo\n     if p.at(T![::]) && p.nth(2) == T![<] {\n         m = p.start();\n         p.bump(T![::]);\n-        p.bump(T![<]);\n     } else if !colon_colon_required && p.at(T![<]) && p.nth(1) != T![=] {\n         m = p.start();\n-        p.bump(T![<]);\n     } else {\n         return;\n     }\n \n-    while !p.at(EOF) && !p.at(T![>]) {\n-        generic_arg(p);\n-        if !p.at(T![>]) && !p.expect(T![,]) {\n-            break;\n-        }\n-    }\n-    p.expect(T![>]);\n+    delimited(p, T![<], T![>], T![,], GENERIC_ARG_FIRST, generic_arg);\n     m.complete(p, GENERIC_ARG_LIST);\n }\n \n+const GENERIC_ARG_FIRST: TokenSet = TokenSet::new(&[\n+    LIFETIME_IDENT,\n+    IDENT,\n+    T!['{'],\n+    T![true],\n+    T![false],\n+    T![-],\n+    INT_NUMBER,\n+    FLOAT_NUMBER,\n+    CHAR,\n+    BYTE,\n+    STRING,\n+    BYTE_STRING,\n+])\n+.union(types::TYPE_FIRST);\n+\n // test generic_arg\n // type T = S<i32>;\n-fn generic_arg(p: &mut Parser<'_>) {\n+fn generic_arg(p: &mut Parser<'_>) -> bool {\n     match p.current() {\n         LIFETIME_IDENT => lifetime_arg(p),\n         T!['{'] | T![true] | T![false] | T![-] => const_arg(p),\n@@ -68,8 +76,10 @@ fn generic_arg(p: &mut Parser<'_>) {\n                 }\n             }\n         }\n-        _ => type_arg(p),\n+        _ if p.at_ts(types::TYPE_FIRST) => type_arg(p),\n+        _ => return false,\n     }\n+    true\n }\n \n // test lifetime_arg"}, {"sha": "7fcf938babdb1ef22f30bca1dc8674b69f60e592", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/generic_params.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fgeneric_params.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1,3 +1,5 @@\n+use crate::grammar::attributes::ATTRIBUTE_FIRST;\n+\n use super::*;\n \n pub(super) fn opt_generic_param_list(p: &mut Parser<'_>) {\n@@ -11,32 +13,31 @@ pub(super) fn opt_generic_param_list(p: &mut Parser<'_>) {\n fn generic_param_list(p: &mut Parser<'_>) {\n     assert!(p.at(T![<]));\n     let m = p.start();\n-    p.bump(T![<]);\n+    delimited(p, T![<], T![>], T![,], GENERIC_PARAM_FIRST.union(ATTRIBUTE_FIRST), |p| {\n+        // test generic_param_attribute\n+        // fn foo<#[lt_attr] 'a, #[t_attr] T>() {}\n+        let m = p.start();\n+        attributes::outer_attrs(p);\n+        generic_param(p, m)\n+    });\n \n-    while !p.at(EOF) && !p.at(T![>]) {\n-        generic_param(p);\n-        if !p.at(T![>]) && !p.expect(T![,]) {\n-            break;\n-        }\n-    }\n-    p.expect(T![>]);\n     m.complete(p, GENERIC_PARAM_LIST);\n }\n \n-fn generic_param(p: &mut Parser<'_>) {\n-    let m = p.start();\n-    // test generic_param_attribute\n-    // fn foo<#[lt_attr] 'a, #[t_attr] T>() {}\n-    attributes::outer_attrs(p);\n+const GENERIC_PARAM_FIRST: TokenSet = TokenSet::new(&[IDENT, LIFETIME_IDENT, T![const]]);\n+\n+fn generic_param(p: &mut Parser<'_>, m: Marker) -> bool {\n     match p.current() {\n         LIFETIME_IDENT => lifetime_param(p, m),\n         IDENT => type_param(p, m),\n         T![const] => const_param(p, m),\n         _ => {\n             m.abandon(p);\n-            p.err_and_bump(\"expected type parameter\");\n+            p.err_and_bump(\"expected generic parameter\");\n+            return false;\n         }\n     }\n+    true\n }\n \n // test lifetime_param"}, {"sha": "17f41b8e13a40d1c3e88e35724eadce199e652e9", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/items/adt.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1,3 +1,5 @@\n+use crate::grammar::attributes::ATTRIBUTE_FIRST;\n+\n use super::*;\n \n // test struct_item\n@@ -141,28 +143,31 @@ pub(crate) fn record_field_list(p: &mut Parser<'_>) {\n     }\n }\n \n+const TUPLE_FIELD_FIRST: TokenSet =\n+    types::TYPE_FIRST.union(ATTRIBUTE_FIRST).union(VISIBILITY_FIRST);\n+\n fn tuple_field_list(p: &mut Parser<'_>) {\n     assert!(p.at(T!['(']));\n     let m = p.start();\n-    p.bump(T!['(']);\n-    while !p.at(T![')']) && !p.at(EOF) {\n+    delimited(p, T!['('], T![')'], T![,], TUPLE_FIELD_FIRST, |p| {\n         let m = p.start();\n         // test tuple_field_attrs\n         // struct S (#[attr] f32);\n         attributes::outer_attrs(p);\n-        opt_visibility(p, true);\n+        let has_vis = opt_visibility(p, true);\n         if !p.at_ts(types::TYPE_FIRST) {\n             p.error(\"expected a type\");\n-            m.complete(p, ERROR);\n-            break;\n+            if has_vis {\n+                m.complete(p, ERROR);\n+            } else {\n+                m.abandon(p);\n+            }\n+            return false;\n         }\n         types::type_(p);\n         m.complete(p, TUPLE_FIELD);\n+        true\n+    });\n \n-        if !p.at(T![')']) {\n-            p.expect(T![,]);\n-        }\n-    }\n-    p.expect(T![')']);\n     m.complete(p, TUPLE_FIELD_LIST);\n }"}, {"sha": "74eae9151a2650cb934ec94e8fbff9d8e378feac", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/params.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fparams.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fparams.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fparams.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1,3 +1,5 @@\n+use crate::grammar::attributes::ATTRIBUTE_FIRST;\n+\n use super::*;\n \n // test param_list\n@@ -66,14 +68,20 @@ fn list_(p: &mut Parser<'_>, flavor: Flavor) {\n             }\n         };\n \n-        if !p.at_ts(PARAM_FIRST) {\n+        if !p.at_ts(PARAM_FIRST.union(ATTRIBUTE_FIRST)) {\n             p.error(\"expected value parameter\");\n             m.abandon(p);\n             break;\n         }\n         param(p, m, flavor);\n-        if !p.at(ket) {\n-            p.expect(T![,]);\n+        if !p.at(T![,]) {\n+            if p.at_ts(PARAM_FIRST.union(ATTRIBUTE_FIRST)) {\n+                p.error(\"expected `,`\");\n+            } else {\n+                break;\n+            }\n+        } else {\n+            p.bump(T![,]);\n         }\n     }\n "}, {"sha": "1064ae9970c99cd36b0893d180dec8ceaff02e13", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/paths.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -67,6 +67,10 @@ fn path_for_qualifier(\n     }\n }\n \n+const EXPR_PATH_SEGMENT_RECOVERY_SET: TokenSet =\n+    items::ITEM_RECOVERY_SET.union(TokenSet::new(&[T![')'], T![,], T![let]]));\n+const TYPE_PATH_SEGMENT_RECOVERY_SET: TokenSet = types::TYPE_RECOVERY_SET;\n+\n fn path_segment(p: &mut Parser<'_>, mode: Mode, first: bool) {\n     let m = p.start();\n     // test qual_paths\n@@ -102,7 +106,12 @@ fn path_segment(p: &mut Parser<'_>, mode: Mode, first: bool) {\n                 m.complete(p, NAME_REF);\n             }\n             _ => {\n-                p.err_recover(\"expected identifier\", items::ITEM_RECOVERY_SET);\n+                let recover_set = match mode {\n+                    Mode::Use => items::ITEM_RECOVERY_SET,\n+                    Mode::Type => TYPE_PATH_SEGMENT_RECOVERY_SET,\n+                    Mode::Expr => EXPR_PATH_SEGMENT_RECOVERY_SET,\n+                };\n+                p.err_recover(\"expected identifier\", recover_set);\n                 if empty {\n                     // test_err empty_segment\n                     // use crate::;"}, {"sha": "7d0b156c5a06ae9cc61fe753bf4823e26f404e0e", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/types.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -17,8 +17,9 @@ pub(super) const TYPE_FIRST: TokenSet = paths::PATH_FIRST.union(TokenSet::new(&[\n     T![Self],\n ]));\n \n-const TYPE_RECOVERY_SET: TokenSet = TokenSet::new(&[\n+pub(super) const TYPE_RECOVERY_SET: TokenSet = TokenSet::new(&[\n     T![')'],\n+    T![>],\n     T![,],\n     // test_err struct_field_recover\n     // struct S { f pub g: () }"}, {"sha": "2fec765bd7871f2c2edc9ce06e54e660c3ce29a1", "filename": "src/tools/rust-analyzer/crates/parser/src/tests.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Ftests.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -15,6 +15,7 @@ use crate::{LexedStr, TopEntryPoint};\n #[test]\n fn lex_ok() {\n     for case in TestCase::list(\"lexer/ok\") {\n+        let _guard = stdx::panic_context::enter(format!(\"{:?}\", case.rs));\n         let actual = lex(&case.text);\n         expect_file![case.rast].assert_eq(&actual)\n     }\n@@ -23,6 +24,7 @@ fn lex_ok() {\n #[test]\n fn lex_err() {\n     for case in TestCase::list(\"lexer/err\") {\n+        let _guard = stdx::panic_context::enter(format!(\"{:?}\", case.rs));\n         let actual = lex(&case.text);\n         expect_file![case.rast].assert_eq(&actual)\n     }\n@@ -46,6 +48,7 @@ fn lex(text: &str) -> String {\n #[test]\n fn parse_ok() {\n     for case in TestCase::list(\"parser/ok\") {\n+        let _guard = stdx::panic_context::enter(format!(\"{:?}\", case.rs));\n         let (actual, errors) = parse(TopEntryPoint::SourceFile, &case.text);\n         assert!(!errors, \"errors in an OK file {}:\\n{actual}\", case.rs.display());\n         expect_file![case.rast].assert_eq(&actual);\n@@ -55,6 +58,7 @@ fn parse_ok() {\n #[test]\n fn parse_inline_ok() {\n     for case in TestCase::list(\"parser/inline/ok\") {\n+        let _guard = stdx::panic_context::enter(format!(\"{:?}\", case.rs));\n         let (actual, errors) = parse(TopEntryPoint::SourceFile, &case.text);\n         assert!(!errors, \"errors in an OK file {}:\\n{actual}\", case.rs.display());\n         expect_file![case.rast].assert_eq(&actual);\n@@ -64,6 +68,7 @@ fn parse_inline_ok() {\n #[test]\n fn parse_err() {\n     for case in TestCase::list(\"parser/err\") {\n+        let _guard = stdx::panic_context::enter(format!(\"{:?}\", case.rs));\n         let (actual, errors) = parse(TopEntryPoint::SourceFile, &case.text);\n         assert!(errors, \"no errors in an ERR file {}:\\n{actual}\", case.rs.display());\n         expect_file![case.rast].assert_eq(&actual)\n@@ -73,6 +78,7 @@ fn parse_err() {\n #[test]\n fn parse_inline_err() {\n     for case in TestCase::list(\"parser/inline/err\") {\n+        let _guard = stdx::panic_context::enter(format!(\"{:?}\", case.rs));\n         let (actual, errors) = parse(TopEntryPoint::SourceFile, &case.text);\n         assert!(errors, \"no errors in an ERR file {}:\\n{actual}\", case.rs.display());\n         expect_file![case.rast].assert_eq(&actual)"}, {"sha": "49dd9e293b8feb1f75ca48333920828ba31b6c40", "filename": "src/tools/rust-analyzer/crates/parser/src/tests/top_entries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Ftests%2Ftop_entries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Ftests%2Ftop_entries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Ftests%2Ftop_entries.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -65,7 +65,7 @@ fn macro_stmt() {\n             MACRO_STMTS\n               ERROR\n                 SHEBANG \"#!/usr/bin/rust\"\n-            error 0: expected expression\n+            error 0: expected expression, item or let statement\n         \"##]],\n     );\n     check("}, {"sha": "cdc01863ab04cd3e178006865f572fcc66b08416", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/err/0009_broken_struct_type_parameter.rast", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0009_broken_struct_type_parameter.rast", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0009_broken_struct_type_parameter.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0009_broken_struct_type_parameter.rast?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -44,8 +44,7 @@ SOURCE_FILE\n       IDENT \"T\"\n     SEMICOLON \";\"\n   WHITESPACE \"\\n\"\n-error 9: expected type parameter\n-error 11: expected COMMA\n+error 9: expected generic parameter\n error 11: expected R_ANGLE\n error 11: expected `;`, `{`, or `(`\n error 12: expected an item"}, {"sha": "b485c71ab394f2699599bf8dca47d98f952ce376", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/err/0013_invalid_type.rast", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0013_invalid_type.rast", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0013_invalid_type.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0013_invalid_type.rast?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -43,17 +43,14 @@ SOURCE_FILE\n                                     IDENT \"Box\"\n                                   GENERIC_ARG_LIST\n                                     L_ANGLE \"<\"\n-                                    TYPE_ARG\n-                                      ERROR\n-                                        AT \"@\"\n-      WHITESPACE \" \"\n-      TUPLE_FIELD\n-        PATH_TYPE\n-          PATH\n-            PATH_SEGMENT\n-              NAME_REF\n-                IDENT \"Any\"\n-      ERROR\n+  ERROR\n+    AT \"@\"\n+  WHITESPACE \" \"\n+  MACRO_CALL\n+    PATH\n+      PATH_SEGMENT\n+        NAME_REF\n+          IDENT \"Any\"\n   ERROR\n     R_ANGLE \">\"\n   ERROR\n@@ -69,17 +66,14 @@ SOURCE_FILE\n   ERROR\n     SEMICOLON \";\"\n   WHITESPACE \"\\n\\n\"\n-error 67: expected type\n-error 68: expected COMMA\n-error 68: expected R_ANGLE\n-error 68: expected COMMA\n-error 68: expected R_ANGLE\n-error 68: expected COMMA\n-error 68: expected R_ANGLE\n-error 68: expected COMMA\n-error 72: expected COMMA\n-error 72: expected a type\n-error 72: expected R_PAREN\n+error 67: expected R_ANGLE\n+error 67: expected R_ANGLE\n+error 67: expected R_ANGLE\n+error 67: expected R_PAREN\n+error 67: expected SEMICOLON\n+error 67: expected an item\n+error 72: expected BANG\n+error 72: expected `{`, `[`, `(`\n error 72: expected SEMICOLON\n error 72: expected an item\n error 73: expected an item"}, {"sha": "d97fc6c72091d8ff88a2aac7799bcfba150c35ce", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/err/0022_bad_exprs.rast", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0022_bad_exprs.rast", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0022_bad_exprs.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0022_bad_exprs.rast?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -145,27 +145,29 @@ SOURCE_FILE\n error 16: expected expression\n error 17: expected R_BRACK\n error 17: expected SEMICOLON\n-error 17: expected expression\n+error 17: expected expression, item or let statement\n error 25: expected a name\n error 26: expected `;`, `{`, or `(`\n error 30: expected pattern\n error 31: expected SEMICOLON\n error 53: expected expression\n+error 54: expected R_PAREN\n error 54: expected SEMICOLON\n-error 54: expected expression\n+error 54: expected expression, item or let statement\n error 60: expected type\n error 60: expected `{`\n-error 60: expected expression\n+error 60: expected expression, item or let statement\n error 65: expected pattern\n error 65: expected SEMICOLON\n-error 65: expected expression\n+error 65: expected expression, item or let statement\n error 92: expected expression\n+error 93: expected R_PAREN\n error 93: expected SEMICOLON\n-error 93: expected expression\n-error 95: expected expression\n-error 96: expected expression\n+error 93: expected expression, item or let statement\n+error 95: expected expression, item or let statement\n+error 96: expected expression, item or let statement\n error 103: expected a name\n error 104: expected `{`\n error 108: expected pattern\n error 108: expected SEMICOLON\n-error 108: expected expression\n+error 108: expected expression, item or let statement"}, {"sha": "f0dbc9b1027fa9221576974820bd80ebf7cd12f5", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/err/0024_many_type_parens.rast", "status": "modified", "additions": 98, "deletions": 113, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0024_many_type_parens.rast", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0024_many_type_parens.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0024_many_type_parens.rast?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -168,75 +168,21 @@ SOURCE_FILE\n                       L_PAREN \"(\"\n                       ERROR\n                         QUESTION \"?\"\n-        EXPR_STMT\n-          PATH_EXPR\n-            PATH\n-              PATH_SEGMENT\n-                NAME_REF\n-                  IDENT \"Sized\"\n+                  TYPE_ARG\n+                    PATH_TYPE\n+                      PATH\n+                        PATH_SEGMENT\n+                          NAME_REF\n+                            IDENT \"Sized\"\n         ERROR\n           R_PAREN \")\"\n         WHITESPACE \" \"\n         ERROR\n           PLUS \"+\"\n         WHITESPACE \" \"\n-        TUPLE_EXPR\n-          L_PAREN \"(\"\n-          CLOSURE_EXPR\n-            FOR_KW \"for\"\n-            GENERIC_PARAM_LIST\n-              L_ANGLE \"<\"\n-              LIFETIME_PARAM\n-                LIFETIME\n-                  LIFETIME_IDENT \"'a\"\n-              R_ANGLE \">\"\n-          WHITESPACE \" \"\n-          BIN_EXPR\n-            BIN_EXPR\n-              BIN_EXPR\n-                BIN_EXPR\n-                  PATH_EXPR\n-                    PATH\n-                      PATH_SEGMENT\n-                        NAME_REF\n-                          IDENT \"Trait\"\n-                  L_ANGLE \"<\"\n-                  ERROR\n-                    LIFETIME_IDENT \"'a\"\n-                R_ANGLE \">\"\n-                ERROR\n-                  R_PAREN \")\"\n-              WHITESPACE \" \"\n-              PLUS \"+\"\n-              WHITESPACE \" \"\n-              PAREN_EXPR\n-                L_PAREN \"(\"\n-                PATH_EXPR\n-                  PATH\n-                    PATH_SEGMENT\n-                      NAME_REF\n-                        IDENT \"Copy\"\n-                R_PAREN \")\"\n-            R_ANGLE \">\"\n-            ERROR\n-              SEMICOLON \";\"\n-          WHITESPACE \"\\n    \"\n-          LET_EXPR\n-            LET_KW \"let\"\n-            WHITESPACE \" \"\n-            WILDCARD_PAT\n-              UNDERSCORE \"_\"\n-            ERROR\n-              COLON \":\"\n-          WHITESPACE \" \"\n+        EXPR_STMT\n           BIN_EXPR\n             BIN_EXPR\n-              PATH_EXPR\n-                PATH\n-                  PATH_SEGMENT\n-                    NAME_REF\n-                      IDENT \"Box\"\n-              L_ANGLE \"<\"\n               TUPLE_EXPR\n                 L_PAREN \"(\"\n                 CLOSURE_EXPR\n@@ -250,78 +196,117 @@ SOURCE_FILE\n                 WHITESPACE \" \"\n                 BIN_EXPR\n                   BIN_EXPR\n-                    BIN_EXPR\n-                      BIN_EXPR\n-                        PATH_EXPR\n-                          PATH\n-                            PATH_SEGMENT\n-                              NAME_REF\n-                                IDENT \"Trait\"\n-                        L_ANGLE \"<\"\n-                        ERROR\n-                          LIFETIME_IDENT \"'a\"\n-                      R_ANGLE \">\"\n-                      ERROR\n-                        R_PAREN \")\"\n-                    WHITESPACE \" \"\n-                    PLUS \"+\"\n-                    WHITESPACE \" \"\n-                    PAREN_EXPR\n-                      L_PAREN \"(\"\n-                      PATH_EXPR\n-                        PATH\n-                          PATH_SEGMENT\n-                            NAME_REF\n-                              IDENT \"Copy\"\n-                      R_PAREN \")\"\n-                  WHITESPACE \" \"\n-                  PLUS \"+\"\n-                  WHITESPACE \" \"\n-                  PAREN_EXPR\n-                    L_PAREN \"(\"\n+                    PATH_EXPR\n+                      PATH\n+                        PATH_SEGMENT\n+                          NAME_REF\n+                            IDENT \"Trait\"\n+                    L_ANGLE \"<\"\n                     ERROR\n-                      QUESTION \"?\"\n+                      LIFETIME_IDENT \"'a\"\n+                  R_ANGLE \">\"\n+                R_PAREN \")\"\n+              WHITESPACE \" \"\n+              PLUS \"+\"\n+              WHITESPACE \" \"\n+              PAREN_EXPR\n+                L_PAREN \"(\"\n                 PATH_EXPR\n                   PATH\n                     PATH_SEGMENT\n                       NAME_REF\n-                        IDENT \"Sized\"\n+                        IDENT \"Copy\"\n                 R_PAREN \")\"\n             R_ANGLE \">\"\n             ERROR\n               SEMICOLON \";\"\n+        WHITESPACE \"\\n    \"\n+        LET_STMT\n+          LET_KW \"let\"\n+          WHITESPACE \" \"\n+          WILDCARD_PAT\n+            UNDERSCORE \"_\"\n+          COLON \":\"\n+          WHITESPACE \" \"\n+          DYN_TRAIT_TYPE\n+            TYPE_BOUND_LIST\n+              TYPE_BOUND\n+                PATH_TYPE\n+                  PATH\n+                    PATH_SEGMENT\n+                      NAME_REF\n+                        IDENT \"Box\"\n+                      GENERIC_ARG_LIST\n+                        L_ANGLE \"<\"\n+                        TYPE_ARG\n+                          PAREN_TYPE\n+                            L_PAREN \"(\"\n+                            FOR_TYPE\n+                              FOR_KW \"for\"\n+                              GENERIC_PARAM_LIST\n+                                L_ANGLE \"<\"\n+                                LIFETIME_PARAM\n+                                  LIFETIME\n+                                    LIFETIME_IDENT \"'a\"\n+                                R_ANGLE \">\"\n+                              WHITESPACE \" \"\n+                              PATH_TYPE\n+                                PATH\n+                                  PATH_SEGMENT\n+                                    NAME_REF\n+                                      IDENT \"Trait\"\n+                                    GENERIC_ARG_LIST\n+                                      L_ANGLE \"<\"\n+                                      LIFETIME_ARG\n+                                        LIFETIME\n+                                          LIFETIME_IDENT \"'a\"\n+                                      R_ANGLE \">\"\n+                            R_PAREN \")\"\n+              WHITESPACE \" \"\n+              PLUS \"+\"\n+              WHITESPACE \" \"\n+              TYPE_BOUND\n+                L_PAREN \"(\"\n+                PATH_TYPE\n+                  PATH\n+                    PATH_SEGMENT\n+                      NAME_REF\n+                        IDENT \"Copy\"\n+                R_PAREN \")\"\n+              WHITESPACE \" \"\n+              PLUS \"+\"\n+              WHITESPACE \" \"\n+              TYPE_BOUND\n+                L_PAREN \"(\"\n+                QUESTION \"?\"\n+                PATH_TYPE\n+                  PATH\n+                    PATH_SEGMENT\n+                      NAME_REF\n+                        IDENT \"Sized\"\n+                R_PAREN \")\"\n+        ERROR\n+          R_ANGLE \">\"\n+        SEMICOLON \";\"\n         WHITESPACE \"\\n\"\n         R_CURLY \"}\"\n   WHITESPACE \"\\n\"\n-error 88: expected COMMA\n error 88: expected R_ANGLE\n error 121: expected SEMICOLON\n-error 121: expected expression\n+error 121: expected expression, item or let statement\n error 140: expected type\n error 141: expected R_PAREN\n error 141: expected COMMA\n-error 141: expected R_ANGLE\n-error 141: expected SEMICOLON\n+error 146: expected R_ANGLE\n error 146: expected SEMICOLON\n-error 146: expected expression\n-error 148: expected expression\n+error 146: expected expression, item or let statement\n+error 148: expected expression, item or let statement\n error 158: expected `|`\n error 158: expected COMMA\n error 165: expected expression\n error 168: expected expression\n error 179: expected expression\n-error 180: expected COMMA\n-error 190: expected EQ\n-error 190: expected expression\n-error 191: expected COMMA\n-error 204: expected `|`\n-error 204: expected COMMA\n-error 211: expected expression\n-error 214: expected expression\n-error 228: expected expression\n-error 229: expected R_PAREN\n-error 229: expected COMMA\n-error 236: expected expression\n-error 237: expected COMMA\n-error 237: expected expression\n-error 237: expected R_PAREN\n+error 180: expected SEMICOLON\n+error 215: expected R_ANGLE\n+error 235: expected SEMICOLON\n+error 235: expected expression, item or let statement"}, {"sha": "b6bc0088374fb8860fdb08064963877993c932ca", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/err/0025_nope.rast", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0025_nope.rast", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0025_nope.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0025_nope.rast?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -156,8 +156,7 @@ SOURCE_FILE\n                             PATH_SEGMENT\n                               NAME_REF\n                                 IDENT \"i32\"\n-                      WHITESPACE \" \"\n-                      ERROR\n+                  WHITESPACE \" \"\n                   ERROR\n                     L_CURLY \"{\"\n                     R_CURLY \"}\"\n@@ -199,10 +198,8 @@ error 95: expected type\n error 95: expected COMMA\n error 96: expected field\n error 98: expected field declaration\n+error 371: expected R_PAREN\n error 371: expected COMMA\n-error 372: expected a type\n-error 372: expected R_PAREN\n-error 372: expected COMMA\n error 372: expected enum variant\n error 374: expected enum variant\n error 494: expected pattern"}, {"sha": "1cdc6e6e7192736c39e4e56ea6d69fe2dd2ed121", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/err/0042_weird_blocks.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0042_weird_blocks.rast", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0042_weird_blocks.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0042_weird_blocks.rast?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -72,4 +72,4 @@ SOURCE_FILE\n error 24: expected existential, fn, trait or impl\n error 41: expected existential, fn, trait or impl\n error 56: expected a block\n-error 75: expected a loop\n+error 75: expected a loop or block"}, {"sha": "207a5c24dffd4840cdfcb6a721faf7aa974923f7", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/err/0048_double_fish.rast", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0048_double_fish.rast", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0048_double_fish.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Ferr%2F0048_double_fish.rast?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -12,7 +12,7 @@ SOURCE_FILE\n       STMT_LIST\n         L_CURLY \"{\"\n         WHITESPACE \"\\n    \"\n-        EXPR_STMT\n+        BIN_EXPR\n           PATH_EXPR\n             PATH\n               PATH_SEGMENT\n@@ -41,13 +41,14 @@ SOURCE_FILE\n                         COLON2 \"::\"\n                         ERROR\n                           L_ANGLE \"<\"\n-        BIN_EXPR\n-          PATH_EXPR\n-            PATH\n-              PATH_SEGMENT\n-                NAME_REF\n-                  IDENT \"nope\"\n-          SHR \">>\"\n+                  TYPE_ARG\n+                    PATH_TYPE\n+                      PATH\n+                        PATH_SEGMENT\n+                          NAME_REF\n+                            IDENT \"nope\"\n+                  R_ANGLE \">\"\n+          R_ANGLE \">\"\n           ERROR\n             SEMICOLON \";\"\n         WHITESPACE \"\\n\"\n@@ -114,8 +115,6 @@ SOURCE_FILE\n   WHITESPACE \"\\n\"\n error 30: expected identifier\n error 31: expected COMMA\n-error 31: expected R_ANGLE\n-error 31: expected SEMICOLON\n error 37: expected expression\n error 75: expected identifier\n error 76: expected SEMICOLON"}, {"sha": "ea5203fb96e00bdc8abd84730af2f941176e947f", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/err/0002_misplaced_label_err.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0002_misplaced_label_err.rast", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0002_misplaced_label_err.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0002_misplaced_label_err.rast?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -23,6 +23,6 @@ SOURCE_FILE\n         WHITESPACE \"\\n\"\n         R_CURLY \"}\"\n   WHITESPACE \"\\n\"\n-error 22: expected a loop\n+error 22: expected a loop or block\n error 27: expected type\n error 27: expected `{`"}, {"sha": "5d0fe859c2965290238f1b16d5586b981ba4d646", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/err/0015_arg_list_recovery.rast", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_arg_list_recovery.rast", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_arg_list_recovery.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_arg_list_recovery.rast?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -0,0 +1,77 @@\n+SOURCE_FILE\n+  FN\n+    FN_KW \"fn\"\n+    WHITESPACE \" \"\n+    NAME\n+      IDENT \"main\"\n+    PARAM_LIST\n+      L_PAREN \"(\"\n+      R_PAREN \")\"\n+    WHITESPACE \" \"\n+    BLOCK_EXPR\n+      STMT_LIST\n+        L_CURLY \"{\"\n+        WHITESPACE \"\\n    \"\n+        EXPR_STMT\n+          CALL_EXPR\n+            PATH_EXPR\n+              PATH\n+                PATH_SEGMENT\n+                  NAME_REF\n+                    IDENT \"foo\"\n+            ARG_LIST\n+              L_PAREN \"(\"\n+              PATH_EXPR\n+                PATH\n+                  PATH\n+                    PATH_SEGMENT\n+                      NAME_REF\n+                        IDENT \"bar\"\n+                  COLON2 \"::\"\n+              R_PAREN \")\"\n+          SEMICOLON \";\"\n+        WHITESPACE \"\\n    \"\n+        EXPR_STMT\n+          CALL_EXPR\n+            PATH_EXPR\n+              PATH\n+                PATH_SEGMENT\n+                  NAME_REF\n+                    IDENT \"foo\"\n+            ARG_LIST\n+              L_PAREN \"(\"\n+              PATH_EXPR\n+                PATH\n+                  PATH_SEGMENT\n+                    NAME_REF\n+                      IDENT \"bar\"\n+              ERROR\n+                COLON \":\"\n+              R_PAREN \")\"\n+          SEMICOLON \";\"\n+        WHITESPACE \"\\n    \"\n+        EXPR_STMT\n+          CALL_EXPR\n+            PATH_EXPR\n+              PATH\n+                PATH_SEGMENT\n+                  NAME_REF\n+                    IDENT \"foo\"\n+            ARG_LIST\n+              L_PAREN \"(\"\n+              BIN_EXPR\n+                PATH_EXPR\n+                  PATH\n+                    PATH_SEGMENT\n+                      NAME_REF\n+                        IDENT \"bar\"\n+                PLUS \"+\"\n+              R_PAREN \")\"\n+          SEMICOLON \";\"\n+        WHITESPACE \"\\n\"\n+        R_CURLY \"}\"\n+  WHITESPACE \"\\n\"\n+error 25: expected identifier\n+error 39: expected COMMA\n+error 39: expected expression\n+error 55: expected expression"}, {"sha": "0e7ac9cc3075533cb4836f00fafd6a4230ae066a", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/err/0015_arg_list_recovery.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_arg_list_recovery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_arg_list_recovery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_arg_list_recovery.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    foo(bar::);\n+    foo(bar:);\n+    foo(bar+);\n+}"}, {"sha": "ea50ad35d74db1f480aad1619dcd450ce43beaf5", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/err/0015_missing_fn_param_type.rast", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_missing_fn_param_type.rast", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_missing_fn_param_type.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0015_missing_fn_param_type.rast?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -49,5 +49,5 @@ SOURCE_FILE\n         R_CURLY \"}\"\n   WHITESPACE \"\\n\"\n error 6: missing type for function parameter\n-error 6: expected COMMA\n+error 6: expected `,`\n error 16: missing type for function parameter"}, {"sha": "cf637ec359a2da28b74bf8a45c86a2e11cef5226", "filename": "src/tools/rust-analyzer/crates/proc-macro-api/src/version.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2Fsrc%2Fversion.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -120,17 +120,20 @@ pub fn read_version(dylib_path: &AbsPath) -> io::Result<String> {\n     let version = u32::from_be_bytes([dot_rustc[4], dot_rustc[5], dot_rustc[6], dot_rustc[7]]);\n     // Last supported version is:\n     // https://github.com/rust-lang/rust/commit/0696e79f2740ad89309269b460579e548a5cd632\n-    match version {\n-        5 | 6 => {}\n+    let snappy_portion = match version {\n+        5 | 6 => &dot_rustc[8..],\n+        7 => {\n+            let len_bytes = &dot_rustc[8..12];\n+            let data_len = u32::from_be_bytes(len_bytes.try_into().unwrap()) as usize;\n+            &dot_rustc[12..data_len + 12]\n+        }\n         _ => {\n             return Err(io::Error::new(\n                 io::ErrorKind::InvalidData,\n                 format!(\"unsupported metadata version {version}\"),\n             ));\n         }\n-    }\n-\n-    let snappy_portion = &dot_rustc[8..];\n+    };\n \n     let mut snappy_decoder = SnapDecoder::new(snappy_portion);\n "}, {"sha": "f0f1900c78c56c7584faf1656f7017ffe023cecd", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -24,7 +24,7 @@ crossbeam-channel = \"0.5.5\"\n dissimilar = \"1.0.4\"\n itertools = \"0.10.5\"\n scip = \"0.1.1\"\n-lsp-types = { version = \"=0.93.2\", features = [\"proposed\"] }\n+lsp-types = { version = \"=0.94\", features = [\"proposed\"] }\n parking_lot = \"0.12.1\"\n xflags = \"0.3.0\"\n oorandom = \"11.1.3\""}, {"sha": "e49d7c144922d09aeca6dc5f31c8791b6c0939e2", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/default_12483297303756020505_0.profraw", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fdefault_12483297303756020505_0.profraw", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fdefault_12483297303756020505_0.profraw", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fdefault_12483297303756020505_0.profraw?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028"}, {"sha": "3628670ac98b98a74e0420e7f7d29aec9b8500db", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/caps.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcaps.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1,4 +1,5 @@\n //! Advertises the capabilities of the LSP Server.\n+use ide_db::line_index::WideEncoding;\n use lsp_types::{\n     CallHierarchyServerCapability, ClientCapabilities, CodeActionKind, CodeActionOptions,\n     CodeActionProviderCapability, CodeLensOptions, CompletionOptions,\n@@ -16,16 +17,19 @@ use lsp_types::{\n use serde_json::json;\n \n use crate::config::{Config, RustfmtConfig};\n-use crate::lsp_ext::supports_utf8;\n+use crate::line_index::PositionEncoding;\n+use crate::lsp_ext::negotiated_encoding;\n use crate::semantic_tokens;\n \n pub fn server_capabilities(config: &Config) -> ServerCapabilities {\n     ServerCapabilities {\n-        position_encoding: if supports_utf8(config.caps()) {\n-            Some(PositionEncodingKind::UTF8)\n-        } else {\n-            None\n-        },\n+        position_encoding: Some(match negotiated_encoding(config.caps()) {\n+            PositionEncoding::Utf8 => PositionEncodingKind::UTF8,\n+            PositionEncoding::Wide(wide) => match wide {\n+                WideEncoding::Utf16 => PositionEncodingKind::UTF16,\n+                WideEncoding::Utf32 => PositionEncodingKind::UTF32,\n+            },\n+        }),\n         text_document_sync: Some(TextDocumentSyncCapability::Options(TextDocumentSyncOptions {\n             open_close: Some(true),\n             change: Some(TextDocumentSyncKind::INCREMENTAL),\n@@ -134,6 +138,7 @@ pub fn server_capabilities(config: &Config) -> ServerCapabilities {\n                 resolve_provider: Some(true),\n             },\n         ))),\n+        inline_value_provider: None,\n         experimental: Some(json!({\n             \"externalDocs\": true,\n             \"hoverRange\": true,"}, {"sha": "3fc1aa4eaeb4aaaad35bb744ebfcbc53f4d0ecd6", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/cli/lsif.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -11,6 +11,7 @@ use ide::{\n use ide_db::LineIndexDatabase;\n \n use ide_db::base_db::salsa::{self, ParallelDatabase};\n+use ide_db::line_index::WideEncoding;\n use lsp_types::{self, lsif};\n use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace};\n use vfs::{AbsPathBuf, Vfs};\n@@ -127,7 +128,7 @@ impl LsifManager<'_> {\n         let line_index = self.db.line_index(file_id);\n         let line_index = LineIndex {\n             index: line_index,\n-            encoding: PositionEncoding::Utf16,\n+            encoding: PositionEncoding::Wide(WideEncoding::Utf16),\n             endings: LineEndings::Unix,\n         };\n         let range_id = self.add_vertex(lsif::Vertex::Range {\n@@ -249,7 +250,7 @@ impl LsifManager<'_> {\n         let line_index = self.db.line_index(file_id);\n         let line_index = LineIndex {\n             index: line_index,\n-            encoding: PositionEncoding::Utf16,\n+            encoding: PositionEncoding::Wide(WideEncoding::Utf16),\n             endings: LineEndings::Unix,\n         };\n         let result = folds"}, {"sha": "f609a50a05fafdd82de792cc63af4e4c84b2b2b0", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -33,7 +33,7 @@ use crate::{\n     caps::completion_item_edit_resolve,\n     diagnostics::DiagnosticsMapConfig,\n     line_index::PositionEncoding,\n-    lsp_ext::{self, supports_utf8, WorkspaceSymbolSearchKind, WorkspaceSymbolSearchScope},\n+    lsp_ext::{self, negotiated_encoding, WorkspaceSymbolSearchKind, WorkspaceSymbolSearchScope},\n };\n \n mod patch_old_style;\n@@ -999,11 +999,7 @@ impl Config {\n     }\n \n     pub fn position_encoding(&self) -> PositionEncoding {\n-        if supports_utf8(&self.caps) {\n-            PositionEncoding::Utf8\n-        } else {\n-            PositionEncoding::Utf16\n-        }\n+        negotiated_encoding(&self.caps)\n     }\n \n     fn experimental(&self, index: &'static str) -> bool {"}, {"sha": "415fa4e02f20cf7805c46b5d456c54916da65c8b", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/diagnostics/to_proto.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -3,6 +3,7 @@\n use std::collections::HashMap;\n \n use flycheck::{Applicability, DiagnosticLevel, DiagnosticSpan};\n+use ide_db::line_index::WideEncoding;\n use itertools::Itertools;\n use stdx::format_to;\n use vfs::{AbsPath, AbsPathBuf};\n@@ -95,7 +96,8 @@ fn position(\n         let mut char_offset = 0;\n         let len_func = match position_encoding {\n             PositionEncoding::Utf8 => char::len_utf8,\n-            PositionEncoding::Utf16 => char::len_utf16,\n+            PositionEncoding::Wide(WideEncoding::Utf16) => char::len_utf16,\n+            PositionEncoding::Wide(WideEncoding::Utf32) => |_| 1,\n         };\n         for c in line.text.chars() {\n             char_offset += 1;"}, {"sha": "50af38cd6fe3746d70df37bfcfdde8cf1a53fd94", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/from_proto.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Ffrom_proto.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1,7 +1,10 @@\n //! Conversion lsp_types types to rust-analyzer specific ones.\n use anyhow::format_err;\n-use ide::{Annotation, AnnotationKind, AssistKind, LineCol, LineColUtf16};\n-use ide_db::base_db::{FileId, FilePosition, FileRange};\n+use ide::{Annotation, AnnotationKind, AssistKind, LineCol};\n+use ide_db::{\n+    base_db::{FileId, FilePosition, FileRange},\n+    line_index::WideLineCol,\n+};\n use syntax::{TextRange, TextSize};\n use vfs::AbsPathBuf;\n \n@@ -26,9 +29,9 @@ pub(crate) fn vfs_path(url: &lsp_types::Url) -> Result<vfs::VfsPath> {\n pub(crate) fn offset(line_index: &LineIndex, position: lsp_types::Position) -> Result<TextSize> {\n     let line_col = match line_index.encoding {\n         PositionEncoding::Utf8 => LineCol { line: position.line, col: position.character },\n-        PositionEncoding::Utf16 => {\n-            let line_col = LineColUtf16 { line: position.line, col: position.character };\n-            line_index.index.to_utf8(line_col)\n+        PositionEncoding::Wide(enc) => {\n+            let line_col = WideLineCol { line: position.line, col: position.character };\n+            line_index.index.to_utf8(enc, line_col)\n         }\n     };\n     let text_size ="}, {"sha": "791cd931d42a6bb0b90fb7de8de69a79b4ed1865", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/line_index.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fline_index.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -7,9 +7,12 @@\n \n use std::sync::Arc;\n \n+use ide_db::line_index::WideEncoding;\n+\n+#[derive(Clone, Copy)]\n pub enum PositionEncoding {\n     Utf8,\n-    Utf16,\n+    Wide(WideEncoding),\n }\n \n pub(crate) struct LineIndex {"}, {"sha": "e33589cc53696a90890c4d57e70e10ec12f3d8e8", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/lsp_ext.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_ext.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -2,6 +2,7 @@\n \n use std::{collections::HashMap, path::PathBuf};\n \n+use ide_db::line_index::WideEncoding;\n use lsp_types::request::Request;\n use lsp_types::PositionEncodingKind;\n use lsp_types::{\n@@ -10,6 +11,8 @@ use lsp_types::{\n };\n use serde::{Deserialize, Serialize};\n \n+use crate::line_index::PositionEncoding;\n+\n pub enum AnalyzerStatus {}\n \n impl Request for AnalyzerStatus {\n@@ -481,16 +484,22 @@ pub(crate) enum CodeLensResolveData {\n     References(lsp_types::TextDocumentPositionParams),\n }\n \n-pub fn supports_utf8(caps: &lsp_types::ClientCapabilities) -> bool {\n-    match &caps.general {\n-        Some(general) => general\n-            .position_encodings\n-            .as_deref()\n-            .unwrap_or_default()\n-            .iter()\n-            .any(|it| it == &PositionEncodingKind::UTF8),\n-        _ => false,\n+pub fn negotiated_encoding(caps: &lsp_types::ClientCapabilities) -> PositionEncoding {\n+    let client_encodings = match &caps.general {\n+        Some(general) => general.position_encodings.as_deref().unwrap_or_default(),\n+        None => &[],\n+    };\n+\n+    for enc in client_encodings {\n+        if enc == &PositionEncodingKind::UTF8 {\n+            return PositionEncoding::Utf8;\n+        } else if enc == &PositionEncodingKind::UTF32 {\n+            return PositionEncoding::Wide(WideEncoding::Utf32);\n+        }\n+        // NB: intentionally prefer just about anything else to utf-16.\n     }\n+\n+    PositionEncoding::Wide(WideEncoding::Utf16)\n }\n \n pub enum MoveItem {}"}, {"sha": "30f1c53c198f31d54e8668f8f2fe52d33bea46d1", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/lsp_utils.rs", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Flsp_utils.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -161,6 +161,7 @@ impl GlobalState {\n }\n \n pub(crate) fn apply_document_changes(\n+    encoding: PositionEncoding,\n     file_contents: impl FnOnce() -> String,\n     mut content_changes: Vec<lsp_types::TextDocumentContentChangeEvent>,\n ) -> String {\n@@ -192,9 +193,9 @@ pub(crate) fn apply_document_changes(\n     let mut line_index = LineIndex {\n         // the index will be overwritten in the bottom loop's first iteration\n         index: Arc::new(ide::LineIndex::new(&text)),\n-        // We don't care about line endings or offset encoding here.\n+        // We don't care about line endings here.\n         endings: LineEndings::Unix,\n-        encoding: PositionEncoding::Utf16,\n+        encoding,\n     };\n \n     // The changes we got must be applied sequentially, but can cross lines so we\n@@ -256,6 +257,7 @@ pub(crate) fn all_edits_are_disjoint(\n \n #[cfg(test)]\n mod tests {\n+    use ide_db::line_index::WideEncoding;\n     use lsp_types::{\n         CompletionItem, CompletionTextEdit, InsertReplaceEdit, Position, Range,\n         TextDocumentContentChangeEvent,\n@@ -278,9 +280,11 @@ mod tests {\n             };\n         }\n \n-        let text = apply_document_changes(|| String::new(), vec![]);\n+        let encoding = PositionEncoding::Wide(WideEncoding::Utf16);\n+        let text = apply_document_changes(encoding, || String::new(), vec![]);\n         assert_eq!(text, \"\");\n         let text = apply_document_changes(\n+            encoding,\n             || text,\n             vec![TextDocumentContentChangeEvent {\n                 range: None,\n@@ -289,39 +293,49 @@ mod tests {\n             }],\n         );\n         assert_eq!(text, \"the\");\n-        let text = apply_document_changes(|| text, c![0, 3; 0, 3 => \" quick\"]);\n+        let text = apply_document_changes(encoding, || text, c![0, 3; 0, 3 => \" quick\"]);\n         assert_eq!(text, \"the quick\");\n-        let text = apply_document_changes(|| text, c![0, 0; 0, 4 => \"\", 0, 5; 0, 5 => \" foxes\"]);\n+        let text =\n+            apply_document_changes(encoding, || text, c![0, 0; 0, 4 => \"\", 0, 5; 0, 5 => \" foxes\"]);\n         assert_eq!(text, \"quick foxes\");\n-        let text = apply_document_changes(|| text, c![0, 11; 0, 11 => \"\\ndream\"]);\n+        let text = apply_document_changes(encoding, || text, c![0, 11; 0, 11 => \"\\ndream\"]);\n         assert_eq!(text, \"quick foxes\\ndream\");\n-        let text = apply_document_changes(|| text, c![1, 0; 1, 0 => \"have \"]);\n+        let text = apply_document_changes(encoding, || text, c![1, 0; 1, 0 => \"have \"]);\n         assert_eq!(text, \"quick foxes\\nhave dream\");\n         let text = apply_document_changes(\n+            encoding,\n             || text,\n             c![0, 0; 0, 0 => \"the \", 1, 4; 1, 4 => \" quiet\", 1, 16; 1, 16 => \"s\\n\"],\n         );\n         assert_eq!(text, \"the quick foxes\\nhave quiet dreams\\n\");\n-        let text = apply_document_changes(|| text, c![0, 15; 0, 15 => \"\\n\", 2, 17; 2, 17 => \"\\n\"]);\n+        let text = apply_document_changes(\n+            encoding,\n+            || text,\n+            c![0, 15; 0, 15 => \"\\n\", 2, 17; 2, 17 => \"\\n\"],\n+        );\n         assert_eq!(text, \"the quick foxes\\n\\nhave quiet dreams\\n\\n\");\n         let text = apply_document_changes(\n+            encoding,\n             || text,\n             c![1, 0; 1, 0 => \"DREAM\", 2, 0; 2, 0 => \"they \", 3, 0; 3, 0 => \"DON'T THEY?\"],\n         );\n         assert_eq!(text, \"the quick foxes\\nDREAM\\nthey have quiet dreams\\nDON'T THEY?\\n\");\n-        let text = apply_document_changes(|| text, c![0, 10; 1, 5 => \"\", 2, 0; 2, 12 => \"\"]);\n+        let text =\n+            apply_document_changes(encoding, || text, c![0, 10; 1, 5 => \"\", 2, 0; 2, 12 => \"\"]);\n         assert_eq!(text, \"the quick \\nthey have quiet dreams\\n\");\n \n         let text = String::from(\"\u2764\ufe0f\");\n-        let text = apply_document_changes(|| text, c![0, 0; 0, 0 => \"a\"]);\n+        let text = apply_document_changes(encoding, || text, c![0, 0; 0, 0 => \"a\"]);\n         assert_eq!(text, \"a\u2764\ufe0f\");\n \n         let text = String::from(\"a\\nb\");\n-        let text = apply_document_changes(|| text, c![0, 1; 1, 0 => \"\\n\u021bc\", 0, 1; 1, 1 => \"d\"]);\n+        let text =\n+            apply_document_changes(encoding, || text, c![0, 1; 1, 0 => \"\\n\u021bc\", 0, 1; 1, 1 => \"d\"]);\n         assert_eq!(text, \"adcb\");\n \n         let text = String::from(\"a\\nb\");\n-        let text = apply_document_changes(|| text, c![0, 1; 1, 0 => \"\u021b\\nc\", 0, 2; 0, 2 => \"c\"]);\n+        let text =\n+            apply_document_changes(encoding, || text, c![0, 1; 1, 0 => \"\u021b\\nc\", 0, 2; 0, 2 => \"c\"]);\n         assert_eq!(text, \"a\u021bc\\ncb\");\n     }\n "}, {"sha": "d1e38b33c7de2e38f342801e612c57a8c9787270", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -831,6 +831,7 @@ impl GlobalState {\n                     let vfs = &mut this.vfs.write().0;\n                     let file_id = vfs.file_id(&path).unwrap();\n                     let text = apply_document_changes(\n+                        this.config.position_encoding(),\n                         || std::str::from_utf8(vfs.file_contents(file_id)).unwrap().into(),\n                         params.content_changes,\n                     );"}, {"sha": "abce0d7378277dace857f14717e72aa97343dd04", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -268,7 +268,10 @@ impl GlobalState {\n                             ]\n                         })\n                     })\n-                    .map(|glob_pattern| lsp_types::FileSystemWatcher { glob_pattern, kind: None })\n+                    .map(|glob_pattern| lsp_types::FileSystemWatcher {\n+                        glob_pattern: lsp_types::GlobPattern::String(glob_pattern),\n+                        kind: None,\n+                    })\n                     .collect(),\n             };\n             let registration = lsp_types::Registration {"}, {"sha": "92029dc1de78f01e5b9b7878f1ad839402a55040", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -31,8 +31,8 @@ pub(crate) fn position(line_index: &LineIndex, offset: TextSize) -> lsp_types::P\n     let line_col = line_index.index.line_col(offset);\n     match line_index.encoding {\n         PositionEncoding::Utf8 => lsp_types::Position::new(line_col.line, line_col.col),\n-        PositionEncoding::Utf16 => {\n-            let line_col = line_index.index.to_utf16(line_col);\n+        PositionEncoding::Wide(enc) => {\n+            let line_col = line_index.index.to_wide(enc, line_col);\n             lsp_types::Position::new(line_col.line, line_col.col)\n         }\n     }\n@@ -212,7 +212,7 @@ pub(crate) fn completion_items(\n     tdpp: lsp_types::TextDocumentPositionParams,\n     items: Vec<CompletionItem>,\n ) -> Vec<lsp_types::CompletionItem> {\n-    let max_relevance = items.iter().map(|it| it.relevance().score()).max().unwrap_or_default();\n+    let max_relevance = items.iter().map(|it| it.relevance.score()).max().unwrap_or_default();\n     let mut res = Vec::with_capacity(items.len());\n     for item in items {\n         completion_item(&mut res, config, line_index, &tdpp, max_relevance, item);\n@@ -235,22 +235,26 @@ fn completion_item(\n     item: CompletionItem,\n ) {\n     let insert_replace_support = config.insert_replace_support().then_some(tdpp.position);\n+    let ref_match = item.ref_match();\n+    let lookup = item.lookup().to_string();\n+\n     let mut additional_text_edits = Vec::new();\n \n     // LSP does not allow arbitrary edits in completion, so we have to do a\n     // non-trivial mapping here.\n     let text_edit = {\n         let mut text_edit = None;\n-        let source_range = item.source_range();\n-        for indel in item.text_edit().iter() {\n+        let source_range = item.source_range;\n+        for indel in item.text_edit {\n             if indel.delete.contains_range(source_range) {\n+                // Extract this indel as the main edit\n                 text_edit = Some(if indel.delete == source_range {\n                     self::completion_text_edit(line_index, insert_replace_support, indel.clone())\n                 } else {\n                     assert!(source_range.end() == indel.delete.end());\n                     let range1 = TextRange::new(indel.delete.start(), source_range.start());\n                     let range2 = source_range;\n-                    let indel1 = Indel::replace(range1, String::new());\n+                    let indel1 = Indel::delete(range1);\n                     let indel2 = Indel::replace(range2, indel.insert.clone());\n                     additional_text_edits.push(self::text_edit(line_index, indel1));\n                     self::completion_text_edit(line_index, insert_replace_support, indel2)\n@@ -264,23 +268,23 @@ fn completion_item(\n         text_edit.unwrap()\n     };\n \n-    let insert_text_format = item.is_snippet().then_some(lsp_types::InsertTextFormat::SNIPPET);\n-    let tags = item.deprecated().then(|| vec![lsp_types::CompletionItemTag::DEPRECATED]);\n-    let command = if item.trigger_call_info() && config.client_commands().trigger_parameter_hints {\n+    let insert_text_format = item.is_snippet.then_some(lsp_types::InsertTextFormat::SNIPPET);\n+    let tags = item.deprecated.then(|| vec![lsp_types::CompletionItemTag::DEPRECATED]);\n+    let command = if item.trigger_call_info && config.client_commands().trigger_parameter_hints {\n         Some(command::trigger_parameter_hints())\n     } else {\n         None\n     };\n \n     let mut lsp_item = lsp_types::CompletionItem {\n-        label: item.label().to_string(),\n-        detail: item.detail().map(|it| it.to_string()),\n-        filter_text: Some(item.lookup().to_string()),\n-        kind: Some(completion_item_kind(item.kind())),\n+        label: item.label.to_string(),\n+        detail: item.detail.map(|it| it.to_string()),\n+        filter_text: Some(lookup),\n+        kind: Some(completion_item_kind(item.kind)),\n         text_edit: Some(text_edit),\n         additional_text_edits: Some(additional_text_edits),\n-        documentation: item.documentation().map(documentation),\n-        deprecated: Some(item.deprecated()),\n+        documentation: item.documentation.map(documentation),\n+        deprecated: Some(item.deprecated),\n         tags,\n         command,\n         insert_text_format,\n@@ -294,12 +298,13 @@ fn completion_item(\n         });\n     }\n \n-    set_score(&mut lsp_item, max_relevance, item.relevance());\n+    set_score(&mut lsp_item, max_relevance, item.relevance);\n \n     if config.completion().enable_imports_on_the_fly {\n-        if let imports @ [_, ..] = item.imports_to_add() {\n-            let imports: Vec<_> = imports\n-                .iter()\n+        if !item.import_to_add.is_empty() {\n+            let imports: Vec<_> = item\n+                .import_to_add\n+                .into_iter()\n                 .filter_map(|import_edit| {\n                     let import_path = &import_edit.import_path;\n                     let import_name = import_path.segments().last()?;\n@@ -316,18 +321,13 @@ fn completion_item(\n         }\n     }\n \n-    if let Some((mutability, offset, relevance)) = item.ref_match() {\n-        let mut lsp_item_with_ref = lsp_item.clone();\n+    if let Some((label, indel, relevance)) = ref_match {\n+        let mut lsp_item_with_ref = lsp_types::CompletionItem { label, ..lsp_item.clone() };\n+        lsp_item_with_ref\n+            .additional_text_edits\n+            .get_or_insert_with(Default::default)\n+            .push(self::text_edit(line_index, indel));\n         set_score(&mut lsp_item_with_ref, max_relevance, relevance);\n-        lsp_item_with_ref.label =\n-            format!(\"&{}{}\", mutability.as_keyword_for_ref(), lsp_item_with_ref.label);\n-        lsp_item_with_ref.additional_text_edits.get_or_insert_with(Default::default).push(\n-            self::text_edit(\n-                line_index,\n-                Indel::insert(offset, format!(\"&{}\", mutability.as_keyword_for_ref())),\n-            ),\n-        );\n-\n         acc.push(lsp_item_with_ref);\n     };\n \n@@ -766,6 +766,7 @@ pub(crate) fn folding_range(\n             end_line,\n             end_character: None,\n             kind,\n+            collapsed_text: None,\n         }\n     } else {\n         lsp_types::FoldingRange {\n@@ -774,6 +775,7 @@ pub(crate) fn folding_range(\n             end_line: range.end.line,\n             end_character: Some(range.end.character),\n             kind,\n+            collapsed_text: None,\n         }\n     }\n }\n@@ -1360,7 +1362,7 @@ pub(crate) mod command {\n     pub(crate) fn trigger_parameter_hints() -> lsp_types::Command {\n         lsp_types::Command {\n             title: \"triggerParameterHints\".into(),\n-            command: \"editor.action.triggerParameterHints\".into(),\n+            command: \"rust-analyzer.triggerParameterHints\".into(),\n             arguments: None,\n         }\n     }\n@@ -1429,7 +1431,7 @@ fn main() {\n         let line_index = LineIndex {\n             index: Arc::new(ide::LineIndex::new(text)),\n             endings: LineEndings::Unix,\n-            encoding: PositionEncoding::Utf16,\n+            encoding: PositionEncoding::Utf8,\n         };\n         let converted: Vec<lsp_types::FoldingRange> =\n             folds.into_iter().map(|it| folding_range(text, &line_index, true, it)).collect();"}, {"sha": "587d640969aac7394ef0063810e86046975eef6a", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/tests/slow-tests/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fmain.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -22,7 +22,7 @@ use lsp_types::{\n     notification::DidOpenTextDocument,\n     request::{\n         CodeActionRequest, Completion, Formatting, GotoTypeDefinition, HoverRequest,\n-        WillRenameFiles, WorkspaceSymbol,\n+        WillRenameFiles, WorkspaceSymbolRequest,\n     },\n     CodeActionContext, CodeActionParams, CompletionParams, DidOpenTextDocumentParams,\n     DocumentFormattingParams, FileRename, FormattingOptions, GotoDefinitionParams, HoverParams,\n@@ -1095,5 +1095,5 @@ pub fn bar() {}\n     .server()\n     .wait_until_workspace_is_loaded();\n \n-    server.request::<WorkspaceSymbol>(Default::default(), json!([]));\n+    server.request::<WorkspaceSymbolRequest>(Default::default(), json!([]));\n }"}, {"sha": "037fc89ace09098f923eeec0b5153cb4df6a9d43", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/tests/slow-tests/support.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Fsupport.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -107,6 +107,7 @@ impl<'a> Project<'a> {\n                     did_change_watched_files: Some(\n                         lsp_types::DidChangeWatchedFilesClientCapabilities {\n                             dynamic_registration: Some(true),\n+                            relative_pattern_support: None,\n                         },\n                     ),\n                     ..Default::default()"}, {"sha": "5639aaf57cd9713162e671258a7d3e6fccda299d", "filename": "src/tools/rust-analyzer/crates/stdx/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Flib.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -11,6 +11,7 @@ pub mod hash;\n pub mod process;\n pub mod panic_context;\n pub mod non_empty_vec;\n+pub mod rand;\n \n pub use always_assert::{always, never};\n "}, {"sha": "64aa57eae09cd9ac27483c5d4c2ce71042c4ee0b", "filename": "src/tools/rust-analyzer/crates/stdx/src/rand.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2Fsrc%2Frand.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -0,0 +1,21 @@\n+//! We don't use `rand`, as that's too many things for us.\n+//!\n+//! We currently use oorandom instead, but it's missing these two utilities.\n+//! Perhaps we should switch to `fastrand`, or our own small PRNG, it's not like\n+//! we need anything more complicated than xor-shift.\n+\n+pub fn shuffle<T>(slice: &mut [T], mut rand_index: impl FnMut(usize) -> usize) {\n+    let mut remaining = slice.len() - 1;\n+    while remaining > 0 {\n+        let index = rand_index(remaining);\n+        slice.swap(remaining, index);\n+        remaining -= 1;\n+    }\n+}\n+\n+pub fn seed() -> u64 {\n+    use std::collections::hash_map::RandomState;\n+    use std::hash::{BuildHasher, Hasher};\n+\n+    RandomState::new().build_hasher().finish()\n+}"}, {"sha": "6f57cbad66b16b5d947f0b5d437b69c873481aa9", "filename": "src/tools/rust-analyzer/crates/syntax/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Flib.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -186,7 +186,7 @@ impl SourceFile {\n /// ```\n #[macro_export]\n macro_rules! match_ast {\n-    (match $node:ident { $($tt:tt)* }) => { match_ast!(match ($node) { $($tt)* }) };\n+    (match $node:ident { $($tt:tt)* }) => { $crate::match_ast!(match ($node) { $($tt)* }) };\n \n     (match ($node:expr) {\n         $( $( $path:ident )::+ ($it:pat) => $res:expr, )*"}, {"sha": "895de5798ac30eefcdb4abf0b134b5741bd9dbdc", "filename": "src/tools/rust-analyzer/docs/dev/architecture.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Farchitecture.md", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Farchitecture.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Farchitecture.md?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -119,7 +119,7 @@ See [#93](https://github.com/rust-lang/rust-analyzer/pull/93) for an example PR\n **Architecture Invariant:** `syntax` crate is completely independent from the rest of rust-analyzer. It knows nothing about salsa or LSP.\n This is important because it is possible to make useful tooling using only the syntax tree.\n Without semantic information, you don't need to be able to _build_ code, which makes the tooling more robust.\n-See also https://web.stanford.edu/~mlfbrown/paper.pdf.\n+See also https://mlfbrown.com/paper.pdf.\n You can view the `syntax` crate as an entry point to rust-analyzer.\n `syntax` crate is an **API Boundary**.\n "}, {"sha": "c3623a5cc46cf841d0c2ead53b6d21bfdc5c9dbd", "filename": "src/tools/rust-analyzer/docs/dev/lsp-extensions.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Flsp-extensions.md", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Flsp-extensions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Flsp-extensions.md?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1,5 +1,5 @@\n <!---\n-lsp_ext.rs hash: ec29403e67dfd15b\n+lsp_ext.rs hash: d87477896dfe41d4\n \n If you need to change the above hash to make the test pass, please check if you\n need to adjust this doc as well and ping this issue:"}, {"sha": "49a8ca4edba38a79ab3181b05a033c9eec817398", "filename": "src/tools/rust-analyzer/editors/code/src/commands.ts", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fcommands.ts?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -87,6 +87,12 @@ export function shuffleCrateGraph(ctx: CtxInit): Cmd {\n     };\n }\n \n+export function triggerParameterHints(_: CtxInit): Cmd {\n+    return async () => {\n+        await vscode.commands.executeCommand(\"editor.action.triggerParameterHints\");\n+    };\n+}\n+\n export function matchingBrace(ctx: CtxInit): Cmd {\n     return async () => {\n         const editor = ctx.activeRustEditor;"}, {"sha": "5987368e6e08fab6efc75c4567f695e541af9e0f", "filename": "src/tools/rust-analyzer/editors/code/src/main.ts", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fmain.ts?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -186,5 +186,6 @@ function createCommands(): Record<string, CommandFactory> {\n         resolveCodeAction: { enabled: commands.resolveCodeAction },\n         runSingle: { enabled: commands.runSingle },\n         showReferences: { enabled: commands.showReferences },\n+        triggerParameterHints: { enabled: commands.triggerParameterHints },\n     };\n }"}, {"sha": "6e32e3960526fcb8cc29458878eb77994516746e", "filename": "src/tools/rust-analyzer/lib/lsp-server/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Flib%2Flsp-server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/src%2Ftools%2Frust-analyzer%2Flib%2Flsp-server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Flib%2Flsp-server%2FCargo.toml?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -13,4 +13,4 @@ serde = { version = \"1.0.144\", features = [\"derive\"] }\n crossbeam-channel = \"0.5.6\"\n \n [dev-dependencies]\n-lsp-types = \"=0.93.2\"\n+lsp-types = \"=0.94\""}, {"sha": "580f70c974290ef84a59864358e8aac0f5d6dd1b", "filename": "tests/rustdoc-ui/bounded-hr-lifetime.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Fbounded-hr-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Fbounded-hr-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fbounded-hr-lifetime.stderr?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -4,7 +4,5 @@ error: lifetime bounds cannot be used in this context\n LL |     for<'a: 'b + 'c> &'a (): std::fmt::Debug,\n    |             ^^   ^^\n \n-error: Compilation failed, aborting rustdoc\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "02632b4ce7d3cb3ca6768acca5a96d10205154db", "filename": "tests/rustdoc-ui/check-fail.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Fcheck-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Fcheck-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fcheck-fail.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -2,6 +2,7 @@\n \n #![feature(rustdoc_missing_doc_code_examples)]\n #![deny(missing_docs)]\n+#![deny(rustdoc::missing_doc_code_examples)]\n #![deny(rustdoc::all)]\n \n //! ```rust,testharness"}, {"sha": "f05e457af6452fd5789f87550bf3b21a5834b366", "filename": "tests/rustdoc-ui/check-fail.stderr", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Fcheck-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Fcheck-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fcheck-fail.stderr?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1,5 +1,5 @@\n error: missing documentation for a function\n-  --> $DIR/check-fail.rs:12:1\n+  --> $DIR/check-fail.rs:13:1\n    |\n LL | pub fn foo() {}\n    | ^^^^^^^^^^^^\n@@ -11,20 +11,19 @@ LL | #![deny(missing_docs)]\n    |         ^^^^^^^^^^^^\n \n error: missing code example in this documentation\n-  --> $DIR/check-fail.rs:12:1\n+  --> $DIR/check-fail.rs:13:1\n    |\n LL | pub fn foo() {}\n    | ^^^^^^^^^^^^^^^\n    |\n note: the lint level is defined here\n   --> $DIR/check-fail.rs:5:9\n    |\n-LL | #![deny(rustdoc::all)]\n-   |         ^^^^^^^^^^^^\n-   = note: `#[deny(rustdoc::missing_doc_code_examples)]` implied by `#[deny(rustdoc::all)]`\n+LL | #![deny(rustdoc::missing_doc_code_examples)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: unknown attribute `testharness`. Did you mean `test_harness`?\n-  --> $DIR/check-fail.rs:7:1\n+  --> $DIR/check-fail.rs:8:1\n    |\n LL | / //! ```rust,testharness\n LL | |\n@@ -33,10 +32,15 @@ LL | | //! ```\n    | |_______^\n    |\n    = help: the code block will either not be tested if not marked as a rust one or the code will be wrapped inside a main function\n+note: the lint level is defined here\n+  --> $DIR/check-fail.rs:6:9\n+   |\n+LL | #![deny(rustdoc::all)]\n+   |         ^^^^^^^^^^^^\n    = note: `#[deny(rustdoc::invalid_codeblock_attributes)]` implied by `#[deny(rustdoc::all)]`\n \n error: unknown attribute `testharness`. Did you mean `test_harness`?\n-  --> $DIR/check-fail.rs:16:1\n+  --> $DIR/check-fail.rs:17:1\n    |\n LL | / /// hello\n LL | |"}, {"sha": "e389a81bb33cc93fae6a4591317d53b54c677ff8", "filename": "tests/rustdoc-ui/check.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fcheck.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -7,6 +7,7 @@\n //~^^ WARN\n \n #![warn(missing_docs)]\n+#![warn(rustdoc::missing_doc_code_examples)]\n #![warn(rustdoc::all)]\n \n pub fn foo() {}"}, {"sha": "c5ed5d0c3efbe214732794e9d812d74eb2b9304e", "filename": "tests/rustdoc-ui/check.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Fcheck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Fcheck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fcheck.stderr?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -17,7 +17,7 @@ LL | #![warn(missing_docs)]\n    |         ^^^^^^^^^^^^\n \n warning: missing documentation for a function\n-  --> $DIR/check.rs:12:1\n+  --> $DIR/check.rs:13:1\n    |\n LL | pub fn foo() {}\n    | ^^^^^^^^^^^^\n@@ -27,7 +27,7 @@ warning: no documentation found for this crate's top-level module\n    = help: The following guide may be of use:\n            https://doc.rust-lang.org/$CHANNEL/rustdoc/how-to-write-documentation.html\n note: the lint level is defined here\n-  --> $DIR/check.rs:10:9\n+  --> $DIR/check.rs:11:9\n    |\n LL | #![warn(rustdoc::all)]\n    |         ^^^^^^^^^^^^\n@@ -45,10 +45,14 @@ LL | |\n LL | | pub fn foo() {}\n    | |_______________^\n    |\n-   = note: `#[warn(rustdoc::missing_doc_code_examples)]` implied by `#[warn(rustdoc::all)]`\n+note: the lint level is defined here\n+  --> $DIR/check.rs:10:9\n+   |\n+LL | #![warn(rustdoc::missing_doc_code_examples)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: missing code example in this documentation\n-  --> $DIR/check.rs:12:1\n+  --> $DIR/check.rs:13:1\n    |\n LL | pub fn foo() {}\n    | ^^^^^^^^^^^^^^^"}, {"sha": "0864159c8e222b53fa1f9881f5a9982e34d44430", "filename": "tests/rustdoc-ui/feature-gate-doc_cfg_hide.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Ffeature-gate-doc_cfg_hide.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Ffeature-gate-doc_cfg_hide.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Ffeature-gate-doc_cfg_hide.stderr?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -7,8 +7,6 @@ LL | #![doc(cfg_hide(test))]\n    = note: see issue #43781 <https://github.com/rust-lang/rust/issues/43781> for more information\n    = help: add `#![feature(doc_cfg_hide)]` to the crate attributes to enable\n \n-error: Compilation failed, aborting rustdoc\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "c34ea0567a9d4f1430271e4da9199c7d562ee0eb", "filename": "tests/rustdoc-ui/feature-gate-rustdoc_missing_doc_code_examples.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Ffeature-gate-rustdoc_missing_doc_code_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Ffeature-gate-rustdoc_missing_doc_code_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Ffeature-gate-rustdoc_missing_doc_code_examples.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1,10 +1,12 @@\n #![deny(unknown_lints)]\n //~^ NOTE defined here\n-\n #![allow(rustdoc::missing_doc_code_examples)]\n //~^ ERROR unknown lint\n //~| ERROR unknown lint\n+//~| ERROR unknown lint\n+//~| NOTE lint is unstable\n //~| NOTE lint is unstable\n //~| NOTE lint is unstable\n //~| NOTE see issue\n //~| NOTE see issue\n+//~| NOTE see issue"}, {"sha": "326dcfe3bdef0d89e390bcdef6c8b286cbd7c08d", "filename": "tests/rustdoc-ui/feature-gate-rustdoc_missing_doc_code_examples.stderr", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Ffeature-gate-rustdoc_missing_doc_code_examples.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Ffeature-gate-rustdoc_missing_doc_code_examples.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Ffeature-gate-rustdoc_missing_doc_code_examples.stderr?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1,5 +1,5 @@\n error: unknown lint: `rustdoc::missing_doc_code_examples`\n-  --> $DIR/feature-gate-rustdoc_missing_doc_code_examples.rs:4:1\n+  --> $DIR/feature-gate-rustdoc_missing_doc_code_examples.rs:3:1\n    |\n LL | #![allow(rustdoc::missing_doc_code_examples)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -14,7 +14,7 @@ LL | #![deny(unknown_lints)]\n    |         ^^^^^^^^^^^^^\n \n error: unknown lint: `rustdoc::missing_doc_code_examples`\n-  --> $DIR/feature-gate-rustdoc_missing_doc_code_examples.rs:4:1\n+  --> $DIR/feature-gate-rustdoc_missing_doc_code_examples.rs:3:1\n    |\n LL | #![allow(rustdoc::missing_doc_code_examples)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -23,7 +23,15 @@ LL | #![allow(rustdoc::missing_doc_code_examples)]\n    = note: see issue #101730 <https://github.com/rust-lang/rust/issues/101730> for more information\n    = help: add `#![feature(rustdoc_missing_doc_code_examples)]` to the crate attributes to enable\n \n-error: Compilation failed, aborting rustdoc\n+error: unknown lint: `rustdoc::missing_doc_code_examples`\n+  --> $DIR/feature-gate-rustdoc_missing_doc_code_examples.rs:3:1\n+   |\n+LL | #![allow(rustdoc::missing_doc_code_examples)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the `rustdoc::missing_doc_code_examples` lint is unstable\n+   = note: see issue #101730 <https://github.com/rust-lang/rust/issues/101730> for more information\n+   = help: add `#![feature(rustdoc_missing_doc_code_examples)]` to the crate attributes to enable\n \n error: aborting due to 3 previous errors\n "}, {"sha": "75e6b4ed217ddb44eb7a44447754656fa8f28940", "filename": "tests/rustdoc-ui/impl-fn-nesting.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Fimpl-fn-nesting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Fimpl-fn-nesting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fimpl-fn-nesting.stderr?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -58,9 +58,7 @@ error[E0412]: cannot find type `UnknownType` in this scope\n LL |             pub fn doubly_nested(c: UnknownType) {\n    |                                     ^^^^^^^^^^^ not found in this scope\n \n-error: Compilation failed, aborting rustdoc\n-\n-error: aborting due to 11 previous errors\n+error: aborting due to 10 previous errors\n \n Some errors have detailed explanations: E0405, E0412.\n For more information about an error, try `rustc --explain E0405`."}, {"sha": "14f560618521d73afc0b6bd179994fb33a57cc88", "filename": "tests/rustdoc-ui/intra-doc/unresolved-import-recovery.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Fintra-doc%2Funresolved-import-recovery.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Fintra-doc%2Funresolved-import-recovery.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fintra-doc%2Funresolved-import-recovery.stderr?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -6,8 +6,6 @@ LL | use unresolved_crate::module::Name;\n    |\n    = help: consider adding `extern crate unresolved_crate` to use the `unresolved_crate` crate\n \n-error: Compilation failed, aborting rustdoc\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0433`."}, {"sha": "d16ec6a853a5ca68da33ca341c170f9f3868c6b2", "filename": "tests/rustdoc-ui/issue-61732.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Fissue-61732.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Fissue-61732.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fissue-61732.stderr?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -6,8 +6,6 @@ LL | pub(in crate::r#mod) fn main() {}\n    |\n    = help: consider adding `extern crate r#mod` to use the `r#mod` crate\n \n-error: Compilation failed, aborting rustdoc\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0433`."}, {"sha": "ad88157f64f7920dc04cb6f856d988c30c4dd97e", "filename": "tests/rustdoc-ui/lint-group.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Flint-group.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Flint-group.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Flint-group.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -6,6 +6,7 @@\n //! println!(\"sup\");\n //! ```\n \n+#![deny(rustdoc::missing_doc_code_examples)]\n #![deny(rustdoc::all)]\n \n /// what up, let's make an [error]"}, {"sha": "7ff09fcc45a1243660ab5f3892f7545850432d10", "filename": "tests/rustdoc-ui/lint-group.stderr", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Flint-group.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Flint-group.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Flint-group.stderr?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1,18 +1,17 @@\n error: missing code example in this documentation\n-  --> $DIR/lint-group.rs:18:1\n+  --> $DIR/lint-group.rs:19:1\n    |\n LL | /// wait, this doesn't have a doctest?\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: the lint level is defined here\n   --> $DIR/lint-group.rs:9:9\n    |\n-LL | #![deny(rustdoc::all)]\n-   |         ^^^^^^^^^^^^\n-   = note: `#[deny(rustdoc::missing_doc_code_examples)]` implied by `#[deny(rustdoc::all)]`\n+LL | #![deny(rustdoc::missing_doc_code_examples)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: documentation test in private item\n-  --> $DIR/lint-group.rs:21:1\n+  --> $DIR/lint-group.rs:22:1\n    |\n LL | / /// wait, this *does* have a doctest?\n LL | | ///\n@@ -21,16 +20,21 @@ LL | | /// println!(\"sup\");\n LL | | /// ```\n    | |_______^\n    |\n+note: the lint level is defined here\n+  --> $DIR/lint-group.rs:10:9\n+   |\n+LL | #![deny(rustdoc::all)]\n+   |         ^^^^^^^^^^^^\n    = note: `#[deny(rustdoc::private_doc_tests)]` implied by `#[deny(rustdoc::all)]`\n \n error: missing code example in this documentation\n-  --> $DIR/lint-group.rs:28:1\n+  --> $DIR/lint-group.rs:29:1\n    |\n LL | /// <unknown>\n    | ^^^^^^^^^^^^^\n \n error: unresolved link to `error`\n-  --> $DIR/lint-group.rs:11:29\n+  --> $DIR/lint-group.rs:12:29\n    |\n LL | /// what up, let's make an [error]\n    |                             ^^^^^ no item named `error` in scope\n@@ -39,7 +43,7 @@ LL | /// what up, let's make an [error]\n    = note: `#[deny(rustdoc::broken_intra_doc_links)]` implied by `#[deny(rustdoc::all)]`\n \n error: unclosed HTML tag `unknown`\n-  --> $DIR/lint-group.rs:28:5\n+  --> $DIR/lint-group.rs:29:5\n    |\n LL | /// <unknown>\n    |     ^^^^^^^^^"}, {"sha": "e106d06aff592dd2e9e97b272336d2511df709b2", "filename": "tests/rustdoc-ui/rustdoc-all-only-stable-lints.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Frustdoc-all-only-stable-lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Frustdoc-all-only-stable-lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Frustdoc-all-only-stable-lints.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -0,0 +1,6 @@\n+// check-pass\n+\n+// Ensure `rustdoc::all` only affects stable lints. See #106289.\n+\n+#![deny(unknown_lints)]\n+#![allow(rustdoc::all)]"}, {"sha": "bf529b9f8e26327b6add65ba5a79f8d550afade4", "filename": "tests/rustdoc-ui/unknown-renamed-lints.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Funknown-renamed-lints.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc-ui%2Funknown-renamed-lints.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Funknown-renamed-lints.stderr?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -58,7 +58,5 @@ error: unknown lint: `rustdoc::intra_doc_link_resolution_failure`\n LL | #![deny(rustdoc::intra_doc_link_resolution_failure)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: Compilation failed, aborting rustdoc\n-\n-error: aborting due to 9 previous errors\n+error: aborting due to 8 previous errors\n "}, {"sha": "684f0494fd5e7cb5863789e4f4ee9d2974a1daf6", "filename": "tests/rustdoc/issue-108231.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc%2Fissue-108231.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc%2Fissue-108231.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-108231.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -0,0 +1,23 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/108231>.\n+// Macros with `#[macro_export]` attribute should be visible at the top level\n+// even if they are inside a doc hidden item.\n+\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/index.html'\n+// @count - '//*[@id=\"main-content\"]//a[@class=\"macro\"]' 1\n+// @has - '//*[@id=\"main-content\"]//a[@class=\"macro\"]' 'foo'\n+\n+#[doc(hidden)]\n+pub mod __internal {\n+    /// This one should be visible.\n+    #[macro_export]\n+    macro_rules! foo {\n+        () => {};\n+    }\n+\n+    /// This one should be hidden.\n+    macro_rules! bar {\n+        () => {};\n+    }\n+}"}, {"sha": "afcfa979616ecba9fef8fee430fb30d175db9d33", "filename": "tests/rustdoc/reexport-hidden-macro.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc%2Freexport-hidden-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Frustdoc%2Freexport-hidden-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Freexport-hidden-macro.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -0,0 +1,22 @@\n+// Ensure that inlined reexport of hidden macros is working as expected.\n+// Part of <https://github.com/rust-lang/rust/issues/59368>.\n+\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/index.html'\n+// @has - '//*[@id=\"main-content\"]//a[@href=\"macro.Macro2.html\"]' 'Macro2'\n+\n+// @has 'foo/macro.Macro2.html'\n+// @has - '//*[@class=\"docblock\"]' 'Displayed'\n+\n+#[macro_export]\n+#[doc(hidden)]\n+macro_rules! foo {\n+    () => {};\n+}\n+\n+/// not displayed\n+pub use crate::foo as Macro;\n+/// Displayed\n+#[doc(inline)]\n+pub use crate::foo as Macro2;"}, {"sha": "83383ea61a4ab20a20ccd66be9220d394e384589", "filename": "tests/ui/check-cfg/invalid-cfg-value.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fcheck-cfg%2Finvalid-cfg-value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fcheck-cfg%2Finvalid-cfg-value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcheck-cfg%2Finvalid-cfg-value.stderr?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -2,7 +2,9 @@ warning: unexpected `cfg` condition value\n   --> $DIR/invalid-cfg-value.rs:7:7\n    |\n LL | #[cfg(feature = \"sedre\")]\n-   |       ^^^^^^^^^^^^^^^^^\n+   |       ^^^^^^^^^^-------\n+   |                 |\n+   |                 help: did you mean: `\"serde\"`\n    |\n    = note: expected values for `feature` are: full, serde\n    = note: `#[warn(unexpected_cfgs)]` on by default"}, {"sha": "cee34e3b7159372c46c44e06a75c29b9c0dfe8d5", "filename": "tests/ui/const-generics/early/invalid-const-arguments.stderr", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fconst-generics%2Fearly%2Finvalid-const-arguments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fconst-generics%2Fearly%2Finvalid-const-arguments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fearly%2Finvalid-const-arguments.stderr?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -49,12 +49,9 @@ error[E0747]: type provided when a constant was expected\n   --> $DIR/invalid-const-arguments.rs:10:19\n    |\n LL | impl<N> Foo for B<N> {}\n-   |                   ^\n-   |\n-help: consider changing this type parameter to be a `const` generic\n-   |\n-LL | impl<const N: u8> Foo for B<N> {}\n-   |      ~~~~~~~~~~~\n+   |      -            ^\n+   |      |\n+   |      help: consider changing this type parameter to a const parameter: `const N: u8`\n \n error[E0747]: unresolved item provided when a constant was expected\n   --> $DIR/invalid-const-arguments.rs:14:32"}, {"sha": "a0f8dd097c7955c3d663d7ae91b0dd5e71d021f6", "filename": "tests/ui/consts/const-eval/raw-bytes.32bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.32bit.stderr?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -167,7 +167,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/raw-bytes.rs:96:1\n    |\n LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (address 0x539 is unallocated)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (0x539[noalloc] has no provenance)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {\n@@ -178,7 +178,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/raw-bytes.rs:99:1\n    |\n LL | const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (address 0x539 is unallocated)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (0x539[noalloc] has no provenance)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {"}, {"sha": "9706f3ec2e01b3da7d95a874e5269a40d84c91d7", "filename": "tests/ui/consts/const-eval/raw-bytes.64bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fraw-bytes.64bit.stderr?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -167,7 +167,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/raw-bytes.rs:96:1\n    |\n LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (address 0x539 is unallocated)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (0x539[noalloc] has no provenance)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {\n@@ -178,7 +178,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/raw-bytes.rs:99:1\n    |\n LL | const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (address 0x539 is unallocated)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (0x539[noalloc] has no provenance)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {"}, {"sha": "6bd367b646902c07484f8658cb0a63eff096b521", "filename": "tests/ui/consts/const-eval/ub-ref-ptr.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.stderr?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -85,7 +85,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:43:1\n    |\n LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (address 0x539 is unallocated)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (0x539[noalloc] has no provenance)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {\n@@ -96,7 +96,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/ub-ref-ptr.rs:46:1\n    |\n LL | const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (address 0x539 is unallocated)\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (0x539[noalloc] has no provenance)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: $SIZE, align: $ALIGN) {"}, {"sha": "685b5e1f284035c1ded45649ea69dd22bf1c7c21", "filename": "tests/ui/did_you_mean/println-typo.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fdid_you_mean%2Fprintln-typo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fdid_you_mean%2Fprintln-typo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdid_you_mean%2Fprintln-typo.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -0,0 +1,6 @@\n+// https://internals.rust-lang.org/t/18227\n+\n+fn main() {\n+    prinltn!(); //~ ERROR cannot find macro `prinltn` in this scope\n+    //^ a macro with a similar name exists: `println`\n+}"}, {"sha": "43b7b1894e2ae31e718403f5e34466c69da38ba0", "filename": "tests/ui/did_you_mean/println-typo.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fdid_you_mean%2Fprintln-typo.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fdid_you_mean%2Fprintln-typo.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdid_you_mean%2Fprintln-typo.stderr?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -0,0 +1,11 @@\n+error: cannot find macro `prinltn` in this scope\n+  --> $DIR/println-typo.rs:4:5\n+   |\n+LL |     prinltn!();\n+   |     ^^^^^^^ help: a macro with a similar name exists: `println`\n+  --> $SRC_DIR/std/src/macros.rs:LL:COL\n+   |\n+   = note: similarly named macro `println` defined here\n+\n+error: aborting due to previous error\n+"}, {"sha": "1d974b7ecb211f744893e1ea508d1e53b71c9a97", "filename": "tests/ui/dyn-star/dyn-star-to-dyn.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fdyn-star%2Fdyn-star-to-dyn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fdyn-star%2Fdyn-star-to-dyn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdyn-star%2Fdyn-star-to-dyn.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1,9 +1,17 @@\n-// build-pass\n+// run-pass\n \n #![feature(dyn_star)]\n //~^ WARN the feature `dyn_star` is incomplete and may not be safe to use and/or cause compiler crashes\n \n+use std::fmt::Debug;\n+\n fn main() {\n-    let x: dyn* Send = &();\n-    let x = Box::new(x) as Box<dyn Send>;\n+    let x: dyn* Debug = &42;\n+    let x = Box::new(x) as Box<dyn Debug>;\n+    assert_eq!(\"42\", format!(\"{x:?}\"));\n+\n+    // Also test opposite direction.\n+    let x: Box<dyn Debug> = Box::new(42);\n+    let x = &x as dyn* Debug;\n+    assert_eq!(\"42\", format!(\"{x:?}\"));\n }"}, {"sha": "6fea409ed4716244a484c2ba1c86f3ff4c86e76c", "filename": "tests/ui/errors/traits/blame-trait-error-spans-on-exprs.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -71,6 +71,8 @@ struct DoubleWrapper<T> {\n \n impl<T: T1> T1 for DoubleWrapper<T> {}\n \n+impl<'a, T: T2> T1 for &'a T {}\n+\n fn example<Q>(q: Q) {\n     // In each of the following examples, we expect the error span to point at the 'q' variable,\n     // since the missing constraint is `Q: T3`.\n@@ -126,6 +128,10 @@ fn example<Q>(q: Q) {\n         Two { a: Two { a: (), b: Two { a: Two { a: (), b: q }, b: () } }, b: () },\n         //~^ ERROR the trait bound `Q: T1` is not satisfied [E0277]\n     );\n+\n+    // Verifies for reference:\n+    want(&Burrito { spicy: false, filling: q });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n }\n \n fn main() {}"}, {"sha": "6913771f2883e020f23898696f41545245c73246", "filename": "tests/ui/errors/traits/blame-trait-error-spans-on-exprs.stderr", "status": "modified", "additions": 46, "deletions": 14, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.stderr?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the trait bound `Q: T3` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:79:60\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:81:60\n    |\n LL |     want(Wrapper { value: Burrito { spicy: false, filling: q } });\n    |     ---- required by a bound introduced by this call       ^ the trait `T3` is not implemented for `Q`\n@@ -29,7 +29,7 @@ LL | fn example<Q: T3>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T3` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:83:84\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:85:84\n    |\n LL |     want(Wrapper { value: BurritoKinds::SmallBurrito { spicy: true, small_filling: q } });\n    |     ---- required by a bound introduced by this call                               ^ the trait `T3` is not implemented for `Q`\n@@ -59,7 +59,7 @@ LL | fn example<Q: T3>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T3` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:87:39\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:89:39\n    |\n LL |     want(Wrapper { value: Taco(false, q) });\n    |     ----                              ^ the trait `T3` is not implemented for `Q`\n@@ -91,7 +91,7 @@ LL | fn example<Q: T3>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T3` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:91:27\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:93:27\n    |\n LL |     want(Wrapper { value: TacoKinds::OneTaco(false, q) });\n    |     ----                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `T3` is not implemented for `Q`\n@@ -123,7 +123,7 @@ LL | fn example<Q: T3>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T3` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:95:74\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:97:74\n    |\n LL |     want(Wrapper { value: GenericBurrito { spiciness: NotSpicy, filling: q } });\n    |     ---- required by a bound introduced by this call                     ^ the trait `T3` is not implemented for `Q`\n@@ -153,7 +153,7 @@ LL | fn example<Q: T3>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T2` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:99:14\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:101:14\n    |\n LL |     want((3, q));\n    |     ----     ^ the trait `T2` is not implemented for `Q`\n@@ -178,7 +178,7 @@ LL | fn example<Q: T2>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T3` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:103:31\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:105:31\n    |\n LL |     want(Wrapper { value: (3, q) });\n    |     ----                      ^ the trait `T3` is not implemented for `Q`\n@@ -210,7 +210,7 @@ LL | fn example<Q: T3>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T3` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:107:15\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:109:15\n    |\n LL |     want(((3, q), 5));\n    |     ----      ^ the trait `T3` is not implemented for `Q`\n@@ -242,7 +242,7 @@ LL | fn example<Q: T3>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T1` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:110:49\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:112:49\n    |\n LL |     want(DoubleWrapper { item: Wrapper { value: q } });\n    |     ----                                        ^ the trait `T1` is not implemented for `Q`\n@@ -267,7 +267,7 @@ LL | fn example<Q: T1>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T1` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:113:88\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:115:88\n    |\n LL |     want(DoubleWrapper { item: Wrapper { value: DoubleWrapper { item: Wrapper { value: q } } } });\n    |     ---- required by a bound introduced by this call                                   ^ the trait `T1` is not implemented for `Q`\n@@ -292,7 +292,7 @@ LL | fn example<Q: T1>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T3` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:117:27\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:119:27\n    |\n LL |     want(Wrapper { value: AliasBurrito { spiciness: q, filling: q } });\n    |     ----                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `T3` is not implemented for `Q`\n@@ -324,7 +324,7 @@ LL | fn example<Q: T3>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T1` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:120:35\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:122:35\n    |\n LL |     want(Two { a: Two { a: (), b: q }, b: () });\n    |     ----                          ^ the trait `T1` is not implemented for `Q`\n@@ -349,7 +349,7 @@ LL | fn example<Q: T1>(q: Q) {\n    |             ++++\n \n error[E0277]: the trait bound `Q: T1` is not satisfied\n-  --> $DIR/blame-trait-error-spans-on-exprs.rs:126:59\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:128:59\n    |\n LL |     want(\n    |     ---- required by a bound introduced by this call\n@@ -375,6 +375,38 @@ help: consider restricting type parameter `Q`\n LL | fn example<Q: T1>(q: Q) {\n    |             ++++\n \n-error: aborting due to 13 previous errors\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:133:44\n+   |\n+LL |     want(&Burrito { spicy: false, filling: q });\n+   |     ----                                   ^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `Burrito<Q>` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:22:13\n+   |\n+LL | impl<A: T3> T2 for Burrito<A> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required for `&Burrito<Q>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:74:17\n+   |\n+LL | impl<'a, T: T2> T1 for &'a T {}\n+   |             --  ^^     ^^^^^\n+   |             |\n+   |             unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error: aborting due to 14 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "b5d6add043cb93520dbbe0887266cfa76735a693", "filename": "tests/ui/mir/field-projection-invariant.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fmir%2Ffield-projection-invariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fmir%2Ffield-projection-invariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmir%2Ffield-projection-invariant.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -0,0 +1,24 @@\n+// build-pass\n+struct Inv<'a>(&'a mut &'a ());\n+enum Foo<T> {\n+    Bar,\n+    Var(T),\n+}\n+type Supertype = Foo<for<'a> fn(Inv<'a>, Inv<'a>)>;\n+\n+fn foo(x: Foo<for<'a, 'b> fn(Inv<'a>, Inv<'b>)>) {\n+    match x {\n+        Supertype::Bar => {}\n+        Supertype::Var(x) => {}\n+    }\n+}\n+\n+fn foo_nested(x: Foo<Foo<for<'a, 'b> fn(Inv<'a>, Inv<'b>)>>) {\n+    match x {\n+        Foo::Bar => {}\n+        Foo::Var(Supertype::Bar) => {}\n+        Foo::Var(Supertype::Var(x)) => {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "a1002c088dc1cbe071495b1de7ddcaea53bbc1b3", "filename": "tests/ui/mir/field-projection-mutating-context.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fmir%2Ffield-projection-mutating-context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fmir%2Ffield-projection-mutating-context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmir%2Ffield-projection-mutating-context.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -0,0 +1,19 @@\n+use std::sync::Mutex;\n+\n+static GLOBAL: Mutex<&'static str> = Mutex::new(\"global str\");\n+\n+struct Foo<T>(T); // `T` is covariant.\n+\n+fn foo() {\n+    let mut x: Foo<for<'a> fn(&'a str)> = Foo(|_| ());\n+    let Foo(ref mut y): Foo<fn(&'static str)> = x;\n+    //~^ ERROR mismatched types\n+    *y = |s| *GLOBAL.lock().unwrap() = s;\n+    let string = String::from(\"i am shortlived\");\n+    (x.0)(&string);\n+}\n+\n+fn main() {\n+    foo();\n+    println!(\"{}\", GLOBAL.lock().unwrap());\n+}"}, {"sha": "9b18b3427adff2f45b842e990ced3e3043b40b3f", "filename": "tests/ui/mir/field-projection-mutating-context.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fmir%2Ffield-projection-mutating-context.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fmir%2Ffield-projection-mutating-context.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmir%2Ffield-projection-mutating-context.stderr?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -0,0 +1,12 @@\n+error[E0308]: mismatched types\n+  --> $DIR/field-projection-mutating-context.rs:9:13\n+   |\n+LL |     let Foo(ref mut y): Foo<fn(&'static str)> = x;\n+   |             ^^^^^^^^^ one type is more general than the other\n+   |\n+   = note: expected fn pointer `for<'a> fn(&'a str)`\n+              found fn pointer `fn(&str)`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "dd9c44a16d3d5f91e9a27990f13c192375d2c25f", "filename": "tests/ui/mir/field-projection-mutating-context2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fmir%2Ffield-projection-mutating-context2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fmir%2Ffield-projection-mutating-context2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmir%2Ffield-projection-mutating-context2.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -0,0 +1,17 @@\n+use std::sync::Mutex;\n+\n+static GLOBAL: Mutex<&'static str> = Mutex::new(\"global str\");\n+\n+struct Foo<T>(T); // `T` is covariant.\n+\n+fn foo<'a>(mut x: Foo<fn(&'a str)>, string: &'a str) {\n+    let Foo(ref mut y): Foo<fn(&'static str)> = x;\n+    //~^ ERROR lifetime may not live long enough\n+    *y = |s| *GLOBAL.lock().unwrap() = s;\n+    (x.0)(&string);\n+}\n+\n+fn main() {\n+    foo(Foo(|_| ()), &String::from(\"i am shortlived\"));\n+    println!(\"{}\", GLOBAL.lock().unwrap());\n+}"}, {"sha": "a7b66fe10ce717a1c919dc136d01495938bdc134", "filename": "tests/ui/mir/field-projection-mutating-context2.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fmir%2Ffield-projection-mutating-context2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fmir%2Ffield-projection-mutating-context2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmir%2Ffield-projection-mutating-context2.stderr?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -0,0 +1,10 @@\n+error: lifetime may not live long enough\n+  --> $DIR/field-projection-mutating-context2.rs:8:25\n+   |\n+LL | fn foo<'a>(mut x: Foo<fn(&'a str)>, string: &'a str) {\n+   |        -- lifetime `'a` defined here\n+LL |     let Foo(ref mut y): Foo<fn(&'static str)> = x;\n+   |                         ^^^^^^^^^^^^^^^^^^^^^ type annotation requires that `'a` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "179af617090635ade42d828a10a9082d732ee1e3", "filename": "tests/ui/mir/field-ty-ascription-enums.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fmir%2Ffield-ty-ascription-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fmir%2Ffield-ty-ascription-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmir%2Ffield-ty-ascription-enums.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -0,0 +1,15 @@\n+// build-pass\n+\n+enum Foo<T> {\n+    Var(T),\n+} // `T` is covariant.\n+\n+fn foo<'b>(x: Foo<for<'a> fn(&'a ())>) {\n+    let Foo::Var(x): Foo<fn(&'b ())> = x;\n+}\n+\n+fn foo_nested<'b>(x: Foo<Foo<for<'a> fn(&'a ())>>) {\n+    let Foo::Var(Foo::Var(x)): Foo<Foo<fn(&'b ())>> = x;\n+}\n+\n+fn main() {}"}, {"sha": "178c7916bc59fe9215672c29fa266918d40ff940", "filename": "tests/ui/mir/field-ty-ascription.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fmir%2Ffield-ty-ascription.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fmir%2Ffield-ty-ascription.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmir%2Ffield-ty-ascription.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -0,0 +1,37 @@\n+// build-pass\n+\n+struct Foo<T>(T); // `T` is covariant.\n+\n+struct Bar<T> {\n+    x: T,\n+} // `T` is covariant.\n+\n+fn bar<'b>(x: Bar<for<'a> fn(&'a ())>) {\n+    let Bar { x }: Bar<fn(&'b ())> = x;\n+}\n+\n+fn bar_nested<'b>(x: Bar<Bar<for<'a> fn(&'a ())>>) {\n+    let Bar { x: Bar { x } }: Bar<Bar<fn(&'b ())>> = x;\n+}\n+\n+fn bar_foo_nested<'b>(x: Bar<Foo<for<'a> fn(&'a ())>>) {\n+    let Bar { x: Foo ( x ) }: Bar<Foo<fn(&'b ())>> = x;\n+}\n+\n+fn foo<'b>(x: Foo<for<'a> fn(&'a ())>) {\n+    let Foo(y): Foo<fn(&'b ())> = x;\n+}\n+\n+fn foo_nested<'b>(x: Foo<Foo<for<'a> fn(&'a ())>>) {\n+    let Foo(Foo(y)): Foo<Foo<fn(&'b ())>> = x;\n+}\n+\n+fn tuple<'b>(x: (u32, for<'a> fn(&'a ()))) {\n+    let (_, y): (u32, fn(&'b ())) = x;\n+}\n+\n+fn tuple_nested<'b>(x: (u32, (u32, for<'a> fn(&'a ())))) {\n+    let (_, (_, y)): (u32, (u32, fn(&'b ()))) = x;\n+}\n+\n+fn main() {}"}, {"sha": "4bd4780e25f6b0e42fa58cb9e58c7b658144f949", "filename": "tests/ui/panics/default-backtrace-ice.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fpanics%2Fdefault-backtrace-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Fpanics%2Fdefault-backtrace-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanics%2Fdefault-backtrace-ice.stderr?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -13,4 +13,5 @@ error: the compiler unexpectedly panicked. this is a bug.\n \n \n query stack during panic:\n+#0 [resolver_for_lowering] getting the resolver for lowering\n end of query stack"}, {"sha": "e1fee46313d50cfc560f9b6febd69ff5ca0174b0", "filename": "tests/ui/recursion_limit/issue_21102.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Frecursion_limit%2Fissue_21102.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Frecursion_limit%2Fissue_21102.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frecursion_limit%2Fissue_21102.rs?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -0,0 +1,9 @@\n+#![recursion_limit=\"4\"]\n+#![invalid_attribute]\n+#![invalid_attribute]\n+#![invalid_attribute]\n+#![invalid_attribute]\n+#![invalid_attribute]\n+//~^ERROR recursion limit reached while expanding\n+\n+fn main() {}"}, {"sha": "1bd722c492badb28afc988c8bbc776fe503cd419", "filename": "tests/ui/recursion_limit/issue_21102.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Frecursion_limit%2Fissue_21102.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Frecursion_limit%2Fissue_21102.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frecursion_limit%2Fissue_21102.stderr?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -0,0 +1,10 @@\n+error: recursion limit reached while expanding `#[invalid_attribute]`\n+  --> $DIR/issue_21102.rs:6:1\n+   |\n+LL | #![invalid_attribute]\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"8\"]` attribute to your crate (`issue_21102`)\n+\n+error: aborting due to previous error\n+"}, {"sha": "49105de3d691dd395b7f7f450c8fba5b862d69a6", "filename": "tests/ui/traits/suggest-deferences/issue-39029.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Ftraits%2Fsuggest-deferences%2Fissue-39029.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2a979f8ba02f0c60e327c9764ea27837ba4bb028/tests%2Fui%2Ftraits%2Fsuggest-deferences%2Fissue-39029.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fsuggest-deferences%2Fissue-39029.stderr?ref=2a979f8ba02f0c60e327c9764ea27837ba4bb028", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `NoToSocketAddrs: ToSocketAddrs` is not satisfied\n-  --> $DIR/issue-39029.rs:16:37\n+  --> $DIR/issue-39029.rs:16:38\n    |\n LL |     let _errors = TcpListener::bind(&bad);\n-   |                   ----------------- ^^^^ the trait `ToSocketAddrs` is not implemented for `NoToSocketAddrs`\n+   |                   -----------------  ^^^ the trait `ToSocketAddrs` is not implemented for `NoToSocketAddrs`\n    |                   |\n    |                   required by a bound introduced by this call\n    |"}]}