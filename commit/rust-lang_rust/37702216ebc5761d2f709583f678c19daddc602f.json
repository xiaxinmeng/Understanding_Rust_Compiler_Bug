{"sha": "37702216ebc5761d2f709583f678c19daddc602f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3NzAyMjE2ZWJjNTc2MWQyZjcwOTU4M2Y2NzhjMTlkYWRkYzYwMmY=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-07-13T01:26:07Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-07-18T20:56:14Z"}, "message": "Start of data structure cleanup for trait system. Get rid of CoherenceInfo, make trait_impls less bogus.", "tree": {"sha": "04f4dffed066650cd5623abdd9b60b16535502ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04f4dffed066650cd5623abdd9b60b16535502ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37702216ebc5761d2f709583f678c19daddc602f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37702216ebc5761d2f709583f678c19daddc602f", "html_url": "https://github.com/rust-lang/rust/commit/37702216ebc5761d2f709583f678c19daddc602f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37702216ebc5761d2f709583f678c19daddc602f/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "874eb1939b2adeef7c9e7181d3b839948ab3cfe7", "url": "https://api.github.com/repos/rust-lang/rust/commits/874eb1939b2adeef7c9e7181d3b839948ab3cfe7", "html_url": "https://github.com/rust-lang/rust/commit/874eb1939b2adeef7c9e7181d3b839948ab3cfe7"}], "stats": {"total": 155, "additions": 50, "deletions": 105}, "files": [{"sha": "37c4b18317896c792c15b819085a8a9bd19b39cb", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37702216ebc5761d2f709583f678c19daddc602f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37702216ebc5761d2f709583f678c19daddc602f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=37702216ebc5761d2f709583f678c19daddc602f", "patch": "@@ -396,7 +396,7 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n                                          ebml_w: &mut writer::Encoder,\n                                          exp: &middle::resolve::Export2)\n                                          -> bool {\n-    match ecx.tcx.base_impls.find(&exp.def_id) {\n+    match ecx.tcx.inherent_impls.find(&exp.def_id) {\n         Some(implementations) => {\n             for implementations.iter().advance |&base_impl| {\n                 for base_impl.methods.iter().advance |&m| {"}, {"sha": "6d0f851d83d98e179fbd56e8b536ba3330bfb691", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37702216ebc5761d2f709583f678c19daddc602f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37702216ebc5761d2f709583f678c19daddc602f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=37702216ebc5761d2f709583f678c19daddc602f", "patch": "@@ -162,7 +162,7 @@ pub fn trans_method_callee(bcx: block,\n             let self_ty = node_id_type(bcx, this.id);\n             // <impl_id> is the ID of the implementation of\n             // trait <trait_id> for type <self_ty>\n-            let impl_id = ty::get_impl_id(tcx, trait_id, self_ty);\n+            let impl_id = ty::bogus_get_impl_id_from_ty(tcx, trait_id, self_ty);\n             // Get the supertrait's methods\n             let supertrait_method_def_ids = ty::trait_method_def_ids(tcx, trait_id);\n             // Make sure to fail with a readable error message if"}, {"sha": "bad29b1c61844a7ef8109733516bfbd4f0f874a7", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/37702216ebc5761d2f709583f678c19daddc602f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37702216ebc5761d2f709583f678c19daddc602f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=37702216ebc5761d2f709583f678c19daddc602f", "patch": "@@ -303,11 +303,13 @@ struct ctxt_ {\n     // A method will be in this list if and only if it is a destructor.\n     destructors: @mut HashSet<ast::def_id>,\n \n-    // Maps a trait onto a mapping from self-ty to impl\n-    trait_impls: @mut HashMap<ast::def_id, @mut HashMap<t, @Impl>>,\n+    // Maps a trait onto a list of impls of that trait.\n+    trait_impls: @mut HashMap<ast::def_id, @mut ~[@Impl]>,\n \n-    // Maps a base type to its impl\n-    base_impls: @mut HashMap<ast::def_id, @mut ~[@Impl]>,\n+    // Maps a def_id of a type to a list of its inherent impls.\n+    // Contains implementations of methods that are inherent to a type.\n+    // Methods in these implementations don't need to be exported.\n+    inherent_impls: @mut HashMap<ast::def_id, @mut ~[@Impl]>,\n \n     // Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n     // present in this set can be warned about.\n@@ -908,7 +910,7 @@ pub fn mk_ctxt(s: session::Session,\n         destructor_for_type: @mut HashMap::new(),\n         destructors: @mut HashSet::new(),\n         trait_impls: @mut HashMap::new(),\n-        base_impls:  @mut HashMap::new(),\n+        inherent_impls:  @mut HashMap::new(),\n         used_unsafe: @mut HashSet::new(),\n         used_mut_nodes: @mut HashSet::new(),\n      }\n@@ -3596,20 +3598,6 @@ pub fn trait_method(cx: ctxt, trait_did: ast::def_id, idx: uint) -> @Method {\n }\n \n \n-pub fn add_base_impl(cx: ctxt, base_def_id: def_id, implementation: @Impl) {\n-    let implementations;\n-    match cx.base_impls.find(&base_def_id) {\n-        None => {\n-            implementations = @mut ~[];\n-            cx.base_impls.insert(base_def_id, implementations);\n-        }\n-        Some(&existing) => {\n-            implementations = existing;\n-        }\n-    }\n-    implementations.push(implementation);\n-}\n-\n pub fn trait_methods(cx: ctxt, trait_did: ast::def_id) -> @~[@Method] {\n     match cx.trait_methods_cache.find(&trait_did) {\n         Some(&methods) => methods,\n@@ -4375,16 +4363,25 @@ pub fn count_traits_and_supertraits(tcx: ctxt,\n     return total;\n }\n \n-// Given a trait and a type, returns the impl of that type\n-pub fn get_impl_id(tcx: ctxt, trait_id: def_id, self_ty: t) -> def_id {\n+// Given a trait and a type, returns the impl of that type.\n+// This is broken, of course, by parametric impls. This used to use\n+// a table specifically for this mapping, but I removed that table.\n+// This is only used when calling a supertrait method from a default method,\n+// and should go away once I fix how that works. -sully\n+pub fn bogus_get_impl_id_from_ty(tcx: ctxt,\n+                                 trait_id: def_id, self_ty: t) -> def_id {\n     match tcx.trait_impls.find(&trait_id) {\n-        Some(ty_to_impl) => match ty_to_impl.find(&self_ty) {\n-            Some(the_impl) => the_impl.did,\n-            None => // try autoderef!\n-                match deref(tcx, self_ty, false) {\n-                    Some(some_ty) => get_impl_id(tcx, trait_id, some_ty.ty),\n-                    None => tcx.sess.bug(\"get_impl_id: no impl of trait for \\\n-                                          this type\")\n+        Some(ty_to_impl) => {\n+            for ty_to_impl.iter().advance |imp| {\n+                let impl_ty = tcx.tcache.get_copy(&imp.did);\n+                if impl_ty.ty == self_ty { return imp.did; }\n+            }\n+            // try autoderef!\n+            match deref(tcx, self_ty, false) {\n+                Some(some_ty) =>\n+                  bogus_get_impl_id_from_ty(tcx, trait_id, some_ty.ty),\n+                None => tcx.sess.bug(\"get_impl_id: no impl of trait for \\\n+                                      this type\")\n             }\n         },\n         None => tcx.sess.bug(\"get_impl_id: trait isn't in trait_impls\")"}, {"sha": "06ce6420123d0623d390761c6343c0888b66a78e", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37702216ebc5761d2f709583f678c19daddc602f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37702216ebc5761d2f709583f678c19daddc602f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=37702216ebc5761d2f709583f678c19daddc602f", "patch": "@@ -330,8 +330,7 @@ impl<'self> LookupContext<'self> {\n         for opt_applicable_traits.iter().advance |applicable_traits| {\n             for applicable_traits.iter().advance |trait_did| {\n                 // Look for explicit implementations.\n-                let opt_impl_infos =\n-                    self.fcx.ccx.coherence_info.extension_methods.find(trait_did);\n+                let opt_impl_infos = self.tcx().trait_impls.find(trait_did);\n                 for opt_impl_infos.iter().advance |impl_infos| {\n                     for impl_infos.iter().advance |impl_info| {\n                         self.push_candidates_from_impl(\n@@ -517,8 +516,7 @@ impl<'self> LookupContext<'self> {\n     }\n \n     pub fn push_inherent_impl_candidates_for_type(&self, did: def_id) {\n-        let opt_impl_infos =\n-            self.fcx.ccx.coherence_info.inherent_methods.find(&did);\n+        let opt_impl_infos = self.tcx().inherent_impls.find(&did);\n         for opt_impl_infos.iter().advance |impl_infos| {\n             for impl_infos.iter().advance |impl_info| {\n                 self.push_candidates_from_impl("}, {"sha": "6af0be48e47d8cd48ef57ab0f9539c6dfd8d305f", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37702216ebc5761d2f709583f678c19daddc602f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37702216ebc5761d2f709583f678c19daddc602f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=37702216ebc5761d2f709583f678c19daddc602f", "patch": "@@ -260,7 +260,7 @@ fn lookup_vtable(vcx: &VtableContext,\n \n             let mut impls_seen = HashSet::new();\n \n-            match vcx.ccx.coherence_info.extension_methods.find(&trait_ref.def_id) {\n+            match tcx.trait_impls.find(&trait_ref.def_id) {\n                 None => {\n                     // Nothing found. Continue.\n                 }"}, {"sha": "b6555625f659d426f5cc0a40ed4cbdee4c8507f7", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 20, "deletions": 68, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/37702216ebc5761d2f709583f678c19daddc602f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37702216ebc5761d2f709583f678c19daddc602f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=37702216ebc5761d2f709583f678c19daddc602f", "patch": "@@ -159,23 +159,6 @@ pub fn method_to_MethodInfo(ast_method: @method) -> @MethodInfo {\n     }\n }\n \n-pub struct CoherenceInfo {\n-    // Contains implementations of methods that are inherent to a type.\n-    // Methods in these implementations don't need to be exported.\n-    inherent_methods: @mut HashMap<def_id, @mut ~[@Impl]>,\n-\n-    // Contains implementations of methods associated with a trait. For these,\n-    // the associated trait must be imported at the call site.\n-    extension_methods: @mut HashMap<def_id, @mut ~[@Impl]>,\n-}\n-\n-pub fn CoherenceInfo() -> CoherenceInfo {\n-    CoherenceInfo {\n-        inherent_methods: @mut HashMap::new(),\n-        extension_methods: @mut HashMap::new(),\n-    }\n-}\n-\n pub fn CoherenceChecker(crate_context: @mut CrateCtxt) -> CoherenceChecker {\n     CoherenceChecker {\n         crate_context: crate_context,\n@@ -287,7 +270,7 @@ impl CoherenceChecker {\n                 implementation_opt = Some(implementation);\n             }\n \n-            self.add_trait_method(trait_ref.def_id, implementation_opt.get());\n+            self.add_trait_impl(trait_ref.def_id, implementation_opt.get());\n         }\n \n         // Add the implementation to the mapping from implementation to base\n@@ -313,8 +296,7 @@ impl CoherenceChecker {\n                         }\n                     }\n \n-                    self.add_inherent_method(base_type_def_id,\n-                                             implementation);\n+                    self.add_inherent_impl(base_type_def_id, implementation);\n                 }\n \n                 self.base_type_def_ids.insert(local_def(item.id),\n@@ -418,35 +400,33 @@ impl CoherenceChecker {\n         }\n     }\n \n-    pub fn add_inherent_method(&self,\n-                               base_def_id: def_id,\n-                               implementation: @Impl) {\n+    pub fn add_inherent_impl(&self,\n+                             base_def_id: def_id,\n+                             implementation: @Impl) {\n+        let tcx = self.crate_context.tcx;\n         let implementation_list;\n-        match self.crate_context.coherence_info.inherent_methods\n-                  .find(&base_def_id) {\n+        match tcx.inherent_impls.find(&base_def_id) {\n             None => {\n                 implementation_list = @mut ~[];\n-                self.crate_context.coherence_info.inherent_methods\n-                    .insert(base_def_id, implementation_list);\n+                tcx.inherent_impls.insert(base_def_id, implementation_list);\n             }\n             Some(&existing_implementation_list) => {\n                 implementation_list = existing_implementation_list;\n             }\n         }\n \n         implementation_list.push(implementation);\n-\n-        ty::add_base_impl(self.crate_context.tcx, base_def_id, implementation);\n     }\n \n-    pub fn add_trait_method(&self, trait_id: def_id, implementation: @Impl) {\n+    pub fn add_trait_impl(&self,\n+                          base_def_id: def_id,\n+                          implementation: @Impl) {\n+        let tcx = self.crate_context.tcx;\n         let implementation_list;\n-        match self.crate_context.coherence_info.extension_methods\n-                  .find(&trait_id) {\n+        match tcx.trait_impls.find(&base_def_id) {\n             None => {\n                 implementation_list = @mut ~[];\n-                self.crate_context.coherence_info.extension_methods\n-                    .insert(trait_id, implementation_list);\n+                tcx.trait_impls.insert(base_def_id, implementation_list);\n             }\n             Some(&existing_implementation_list) => {\n                 implementation_list = existing_implementation_list;\n@@ -457,8 +437,7 @@ impl CoherenceChecker {\n     }\n \n     pub fn check_implementation_coherence(&self) {\n-        let coherence_info = &self.crate_context.coherence_info;\n-        for coherence_info.extension_methods.each_key |&trait_id| {\n+        for self.crate_context.tcx.trait_impls.each_key |&trait_id| {\n             self.check_implementation_coherence_of(trait_id);\n         }\n     }\n@@ -472,8 +451,6 @@ impl CoherenceChecker {\n \n             // \"We have an impl of trait <trait_def_id> for type <polytype_a>,\n             // and that impl is <implementation_a>\"\n-            self.add_impl_for_trait(trait_def_id, polytype_a.ty,\n-                                    implementation_a);\n             do self.iter_impls_of_trait(trait_def_id) |b| {\n                 let implementation_b = b;\n \n@@ -494,32 +471,8 @@ impl CoherenceChecker {\n         }\n     }\n \n-    // Adds an impl of trait trait_t for self type self_t; that impl\n-    // is the_impl\n-    pub fn add_impl_for_trait(&self,\n-                              trait_t: def_id,\n-                              self_t: t,\n-                              the_impl: @Impl) {\n-        debug!(\"Adding impl %? of %? for %s\",\n-               the_impl.did, trait_t,\n-               ty_to_str(self.crate_context.tcx, self_t));\n-        match self.crate_context.tcx.trait_impls.find(&trait_t) {\n-            None => {\n-                let m = @mut HashMap::new();\n-                m.insert(self_t, the_impl);\n-                self.crate_context.tcx.trait_impls.insert(trait_t, m);\n-            }\n-            Some(&m) => {\n-                m.insert(self_t, the_impl);\n-            }\n-        }\n-    }\n-\n     pub fn iter_impls_of_trait(&self, trait_def_id: def_id, f: &fn(@Impl)) {\n-        let coherence_info = &self.crate_context.coherence_info;\n-        let extension_methods = &*coherence_info.extension_methods;\n-\n-        match extension_methods.find(&trait_def_id) {\n+        match self.crate_context.tcx.trait_impls.find(&trait_def_id) {\n             Some(impls) => {\n                 for impls.iter().advance |&im| {\n                     f(im);\n@@ -874,7 +827,7 @@ impl CoherenceChecker {\n                 ..*implementation\n             };\n \n-            self.add_trait_method(trait_ref.def_id, implementation);\n+            self.add_trait_impl(trait_ref.def_id, implementation);\n         }\n \n         // Add the implementation to the mapping from implementation to base\n@@ -887,8 +840,8 @@ impl CoherenceChecker {\n                 // inherent methods apply to `impl Type` but not\n                 // `impl Trait for Type`:\n                 if associated_traits.is_none() {\n-                    self.add_inherent_method(base_type_def_id,\n-                                             implementation);\n+                    self.add_inherent_impl(base_type_def_id,\n+                                           implementation);\n                 }\n \n                 self.base_type_def_ids.insert(implementation.did,\n@@ -922,12 +875,11 @@ impl CoherenceChecker {\n     //\n \n     pub fn populate_destructor_table(&self) {\n-        let coherence_info = &self.crate_context.coherence_info;\n         let tcx = self.crate_context.tcx;\n         let drop_trait = match tcx.lang_items.drop_trait() {\n             Some(id) => id, None => { return }\n         };\n-        let impls_opt = coherence_info.extension_methods.find(&drop_trait);\n+        let impls_opt = tcx.trait_impls.find(&drop_trait);\n \n         let impls;\n         match impls_opt {"}, {"sha": "bfbebd0a52e9d0abe008104ed599d746fb8c7867", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37702216ebc5761d2f709583f678c19daddc602f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37702216ebc5761d2f709583f678c19daddc602f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=37702216ebc5761d2f709583f678c19daddc602f", "patch": "@@ -192,7 +192,6 @@ pub struct CrateCtxt {\n     trait_map: resolve::TraitMap,\n     method_map: method_map,\n     vtable_map: vtable_map,\n-    coherence_info: coherence::CoherenceInfo,\n     tcx: ty::ctxt\n }\n \n@@ -415,7 +414,6 @@ pub fn check_crate(tcx: ty::ctxt,\n         trait_map: trait_map,\n         method_map: @mut HashMap::new(),\n         vtable_map: @mut HashMap::new(),\n-        coherence_info: coherence::CoherenceInfo(),\n         tcx: tcx\n     };\n "}]}