{"sha": "da971b765217bb3d729c448e88509fe817b94a8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhOTcxYjc2NTIxN2JiM2Q3MjljNDQ4ZTg4NTA5ZmU4MTdiOTRhOGI=", "commit": {"author": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-12T22:08:12Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:02:49Z"}, "message": "Pull out get_or_create landing pad to avoid issues with dynamic borrowck.", "tree": {"sha": "69488467c2b5a670d8f3deb3d714a4e95171450a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69488467c2b5a670d8f3deb3d714a4e95171450a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da971b765217bb3d729c448e88509fe817b94a8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da971b765217bb3d729c448e88509fe817b94a8b", "html_url": "https://github.com/rust-lang/rust/commit/da971b765217bb3d729c448e88509fe817b94a8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da971b765217bb3d729c448e88509fe817b94a8b/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48715a15ff8396c4661183df9769b1c7a881791d", "url": "https://api.github.com/repos/rust-lang/rust/commits/48715a15ff8396c4661183df9769b1c7a881791d", "html_url": "https://github.com/rust-lang/rust/commit/48715a15ff8396c4661183df9769b1c7a881791d"}], "stats": {"total": 133, "additions": 73, "deletions": 60}, "files": [{"sha": "ebc2ff1f166da1652b17721330d88f850a84e2ca", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 73, "deletions": 60, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/da971b765217bb3d729c448e88509fe817b94a8b/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da971b765217bb3d729c448e88509fe817b94a8b/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=da971b765217bb3d729c448e88509fe817b94a8b", "patch": "@@ -242,6 +242,78 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n         self.scopes.borrow().iter().rev().any(|s| s.needs_invoke())\n     }\n \n+    /// Creates a landing pad for the top scope, if one does not exist.  The\n+    /// landing pad will perform all cleanups necessary for an unwind and then\n+    /// `resume` to continue error propagation:\n+    ///\n+    ///     landing_pad -> ... cleanups ... -> [resume]\n+    ///\n+    /// (The cleanups and resume instruction are created by\n+    /// `trans_cleanups_to_exit_scope()`, not in this function itself.)\n+    fn get_or_create_landing_pad(&'blk self) -> BasicBlockRef {\n+        let pad_bcx;\n+\n+        debug!(\"get_or_create_landing_pad\");\n+\n+        // Check if a landing pad block exists; if not, create one.\n+        {\n+            let mut scopes = self.scopes.borrow_mut();\n+            let last_scope = scopes.last_mut().unwrap();\n+            match last_scope.cached_landing_pad {\n+                Some(llbb) => return llbb,\n+                None => {\n+                    let name = last_scope.block_name(\"unwind\");\n+                    pad_bcx = self.build_new_block(&name[..]);\n+                    last_scope.cached_landing_pad = Some(pad_bcx.llbb());\n+                }\n+            }\n+        };\n+\n+        let llpersonality = pad_bcx.fcx().eh_personality();\n+\n+        let val = if base::wants_msvc_seh(self.ccx.sess()) {\n+            // A cleanup pad requires a personality function to be specified, so\n+            // we do that here explicitly (happens implicitly below through\n+            // creation of the landingpad instruction). We then create a\n+            // cleanuppad instruction which has no filters to run cleanup on all\n+            // exceptions.\n+            pad_bcx.set_personality_fn(llpersonality);\n+            let llretval = pad_bcx.cleanup_pad(None, &[]);\n+            UnwindKind::CleanupPad(llretval)\n+        } else {\n+            // The landing pad return type (the type being propagated). Not sure\n+            // what this represents but it's determined by the personality\n+            // function and this is what the EH proposal example uses.\n+            let llretty = Type::struct_(self.ccx,\n+                                        &[Type::i8p(self.ccx), Type::i32(self.ccx)],\n+                                        false);\n+\n+            // The only landing pad clause will be 'cleanup'\n+            let llretval = pad_bcx.landing_pad(llretty, llpersonality, 1, pad_bcx.fcx().llfn);\n+\n+            // The landing pad block is a cleanup\n+            pad_bcx.set_cleanup(llretval);\n+\n+            let addr = match self.landingpad_alloca.get() {\n+                Some(addr) => addr,\n+                None => {\n+                    let addr = base::alloca(&pad_bcx, common::val_ty(llretval), \"\");\n+                    Lifetime::Start.call(&pad_bcx, addr);\n+                    self.landingpad_alloca.set(Some(addr));\n+                    addr\n+                }\n+            };\n+            pad_bcx.store(llretval, addr);\n+            UnwindKind::LandingPad\n+        };\n+\n+        // Generate the cleanup block and branch to it.\n+        let cleanup_llbb = self.trans_cleanups_to_exit_scope(val);\n+        val.branch(&pad_bcx, cleanup_llbb);\n+\n+        return pad_bcx.llbb();\n+    }\n+\n     /// Returns a basic block to branch to in the event of a panic. This block\n     /// will run the panic cleanups and eventually resume the exception that\n     /// caused the landing pad to be run.\n@@ -260,66 +332,7 @@ impl<'blk, 'tcx> FunctionContext<'blk, 'tcx> {\n             popped_scopes.push(self.pop_scope());\n         }\n \n-        // Creates a landing pad for the top scope, if one does not exist.  The\n-        // landing pad will perform all cleanups necessary for an unwind and then\n-        // `resume` to continue error propagation:\n-        //\n-        //     landing_pad -> ... cleanups ... -> [resume]\n-        //\n-        // (The cleanups and resume instruction are created by\n-        // `trans_cleanups_to_exit_scope()`, not in this function itself.)\n-        let mut scopes = self.scopes.borrow_mut();\n-        let last_scope = scopes.last_mut().unwrap();\n-        let llbb = if let Some(llbb) = last_scope.cached_landing_pad {\n-            llbb\n-        } else {\n-            let name = last_scope.block_name(\"unwind\");\n-            let pad_bcx = self.build_new_block(&name[..]);\n-            last_scope.cached_landing_pad = Some(pad_bcx.llbb());\n-            let llpersonality = pad_bcx.fcx().eh_personality();\n-\n-            let val = if base::wants_msvc_seh(self.ccx.sess()) {\n-                // A cleanup pad requires a personality function to be specified, so\n-                // we do that here explicitly (happens implicitly below through\n-                // creation of the landingpad instruction). We then create a\n-                // cleanuppad instruction which has no filters to run cleanup on all\n-                // exceptions.\n-                pad_bcx.set_personality_fn(llpersonality);\n-                let llretval = pad_bcx.cleanup_pad(None, &[]);\n-                UnwindKind::CleanupPad(llretval)\n-            } else {\n-                // The landing pad return type (the type being propagated). Not sure\n-                // what this represents but it's determined by the personality\n-                // function and this is what the EH proposal example uses.\n-                let llretty = Type::struct_(self.ccx,\n-                    &[Type::i8p(self.ccx), Type::i32(self.ccx)],\n-                    false);\n-\n-                // The only landing pad clause will be 'cleanup'\n-                let llretval = pad_bcx.landing_pad(llretty, llpersonality, 1,\n-                    pad_bcx.fcx().llfn);\n-\n-                // The landing pad block is a cleanup\n-                pad_bcx.set_cleanup(llretval);\n-\n-                let addr = match self.landingpad_alloca.get() {\n-                    Some(addr) => addr,\n-                    None => {\n-                        let addr = base::alloca(&pad_bcx, common::val_ty(llretval), \"\");\n-                        Lifetime::Start.call(&pad_bcx, addr);\n-                        self.landingpad_alloca.set(Some(addr));\n-                        addr\n-                    }\n-                };\n-                pad_bcx.store(llretval, addr);\n-                UnwindKind::LandingPad\n-            };\n-\n-            // Generate the cleanup block and branch to it.\n-            let cleanup_llbb = self.trans_cleanups_to_exit_scope(val);\n-            val.branch(&pad_bcx, cleanup_llbb);\n-            pad_bcx.llbb()\n-        };\n+        let llbb = self.get_or_create_landing_pad();\n \n         // Push the scopes we removed back on:\n         loop {"}]}