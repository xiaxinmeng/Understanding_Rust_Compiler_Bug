{"sha": "aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhODAzZjRmYTY2NGZlNWU1ZmI5MWJkMWU4Njc5YjM3YzlkZGUzZjg=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-07-30T13:42:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-30T13:42:29Z"}, "message": "Merge pull request #650 from bjorn3/simd_emulation\n\nSimd emulation", "tree": {"sha": "bf6d5fb531777ca2a2113edaab643e724653bd60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf6d5fb531777ca2a2113edaab643e724653bd60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdQElFCRBK7hj4Ov3rIwAAdHIIAAPRd6lZAOcIlRr76qIHhYbO\nzc8CvF7tBe9caX4RiR1zsVHUiLQHwhHt+tvWkvNVM/bb7U7A2UfnqYhbUoZ0pa78\n9jZE4O+NyzFc0eKdmuR6R/xw851lMkCtE0vlZJIgkJZOdS9l1/VaNoGk6AiUVjWP\nQwR4Zfdhpqe10kjMF6xVNhGc7dtgm272jF+azQsI3tF3+OGEgpDImdnjT+h/tH5Z\n5dauOTADL+fQHLJN+CbF6GsZGg/6cLxDGU9Q92V/JIWiQh/TYQRbi/MKgMpZtxI7\nHjhJ4E0DHUSovTzgfRuz/lNJJP6TraO+Bf3U33GLPSCofLAs4QQIq7I1BOj8O/w=\n=eeWQ\n-----END PGP SIGNATURE-----\n", "payload": "tree bf6d5fb531777ca2a2113edaab643e724653bd60\nparent 3f7660788042796773fd12e80dccd9af997f7242\nparent 1028fbb68c5f2caaeda4679a59258275b8c3d26e\nauthor bjorn3 <bjorn3@users.noreply.github.com> 1564494149 +0200\ncommitter GitHub <noreply@github.com> 1564494149 +0200\n\nMerge pull request #650 from bjorn3/simd_emulation\n\nSimd emulation"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8", "html_url": "https://github.com/rust-lang/rust/commit/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f7660788042796773fd12e80dccd9af997f7242", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f7660788042796773fd12e80dccd9af997f7242", "html_url": "https://github.com/rust-lang/rust/commit/3f7660788042796773fd12e80dccd9af997f7242"}, {"sha": "1028fbb68c5f2caaeda4679a59258275b8c3d26e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1028fbb68c5f2caaeda4679a59258275b8c3d26e", "html_url": "https://github.com/rust-lang/rust/commit/1028fbb68c5f2caaeda4679a59258275b8c3d26e"}], "stats": {"total": 854, "additions": 772, "deletions": 82}, "files": [{"sha": "c455aa46a0c437685c4a9502a021e6316180af5c", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8", "patch": "@@ -8,3 +8,4 @@ perf.data.old\n /build_sysroot/sysroot_src\n /build_sysroot/Cargo.lock\n /rust\n+/regex"}, {"sha": "d26e453b2a25e0c3f0c82a174b72b285c1af80ed", "filename": "Readme.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/Readme.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/Readme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Readme.md?ref=aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8", "patch": "@@ -32,7 +32,7 @@ $ RUSTFLAGS=\"-Cpanic=abort -Zcodegen-backend=$cg_clif_dir/target/debug/librustc_\n * Good non-rust abi support ([vectors are passed by-ref](https://github.com/bjorn3/rustc_codegen_cranelift/issues/10))\n * Checked binops ([some missing instructions in cranelift](https://github.com/CraneStation/cranelift/issues/460))\n * Inline assembly ([no cranelift support](https://github.com/CraneStation/cranelift/issues/444))\n-* SIMD ([tracked here](https://github.com/bjorn3/rustc_codegen_cranelift/issues/171))\n+* SIMD ([tracked here](https://github.com/bjorn3/rustc_codegen_cranelift/issues/171), some basic things work)\n \n ## Troubleshooting\n "}, {"sha": "165d67a8146cc64e719fdf803fc6d55c2a69f40c", "filename": "build_sysroot/build_sysroot.sh", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/build_sysroot%2Fbuild_sysroot.sh", "raw_url": "https://github.com/rust-lang/rust/raw/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/build_sysroot%2Fbuild_sysroot.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2Fbuild_sysroot.sh?ref=aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8", "patch": "@@ -1,34 +1,30 @@\n #!/bin/bash\n+\n+# Requires the CHANNEL env var to be set to `debug` or `release.`\n+\n set -e\n cd $(dirname \"$0\")\n \n+pushd ../ >/dev/null\n+source ./config.sh\n+popd >/dev/null\n+\n # Cleanup for previous run\n #     v Clean target dir except for build scripts and incremental cache\n rm -r target/*/{debug,release}/{build,deps,examples,libsysroot*,native} || true\n rm Cargo.lock 2>/dev/null || true\n rm -r sysroot 2>/dev/null || true\n \n-# FIXME find a better way to get the target triple\n-unamestr=`uname`\n-if [[ \"$unamestr\" == 'Linux' ]]; then\n-   TARGET_TRIPLE='x86_64-unknown-linux-gnu'\n-elif [[ \"$unamestr\" == 'Darwin' ]]; then\n-   TARGET_TRIPLE='x86_64-apple-darwin'\n-else\n-   echo \"Unsupported os\"\n-   exit 1\n-fi\n-\n # Build libs\n-mkdir -p sysroot/lib/rustlib/$TARGET_TRIPLE/lib/\n export RUSTFLAGS=\"$RUSTFLAGS -Z force-unstable-if-unmarked\"\n if [[ \"$1\" == \"--release\" ]]; then\n-    channel='release'\n+    sysroot_channel='release'\n     RUSTFLAGS=\"$RUSTFLAGS -Zmir-opt-level=3\" cargo build --target $TARGET_TRIPLE --release\n else\n-    channel='debug'\n+    sysroot_channel='debug'\n     cargo build --target $TARGET_TRIPLE\n fi\n \n # Copy files to sysroot\n-cp target/$TARGET_TRIPLE/$channel/deps/*.rlib sysroot/lib/rustlib/$TARGET_TRIPLE/lib/\n+mkdir -p sysroot/lib/rustlib/$TARGET_TRIPLE/lib/\n+cp target/$TARGET_TRIPLE/$sysroot_channel/deps/*.rlib sysroot/lib/rustlib/$TARGET_TRIPLE/lib/"}, {"sha": "42c137030a5d82cf017068751ac43601faee67ff", "filename": "cargo.sh", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/cargo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/cargo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo.sh?ref=aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8", "patch": "@@ -0,0 +1,14 @@\n+#!/bin/bash\n+\n+if [ -z $CHANNEL ]; then\n+export CHANNEL='debug'\n+fi\n+\n+pushd $(dirname \"$0\") >/dev/null\n+source config.sh\n+popd >/dev/null\n+\n+cmd=$1\n+shift\n+\n+cargo $cmd --target $TARGET_TRIPLE $@"}, {"sha": "ced73acc57972c5bf7640685de53ebb56ec1bdcd", "filename": "clean_all.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/clean_all.sh", "raw_url": "https://github.com/rust-lang/rust/raw/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/clean_all.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clean_all.sh?ref=aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8", "patch": "@@ -2,3 +2,4 @@\n set -e\n \n rm -rf target/ build_sysroot/{sysroot/,sysroot_src/,target/,Cargo.lock} perf.data{,.old}\n+rm -rf regex/"}, {"sha": "a6868f792decf2dd402b460d268aa264ba97809b", "filename": "config.sh", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/config.sh", "raw_url": "https://github.com/rust-lang/rust/raw/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/config.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.sh?ref=aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8", "patch": "@@ -10,14 +10,8 @@ else\n    exit 1\n fi\n \n-if [[ \"$1\" == \"--release\" ]]; then\n-    channel='release'\n-    cargo build --release\n-else\n-    channel='debug'\n-    cargo build\n-fi\n+TARGET_TRIPLE=$(rustc -vV | grep host | cut -d: -f2 | tr -d \" \")\n \n-export RUSTFLAGS='-Zalways-encode-mir -Cpanic=abort -Cdebuginfo=2 -Zcodegen-backend='$(pwd)'/target/'$channel'/librustc_codegen_cranelift.'$dylib_ext' --sysroot '$(pwd)'/build_sysroot/sysroot'\n+export RUSTFLAGS='-Zalways-encode-mir -Cpanic=abort -Cdebuginfo=2 -Zcodegen-backend='$(pwd)'/target/'$CHANNEL'/librustc_codegen_cranelift.'$dylib_ext' --sysroot '$(pwd)'/build_sysroot/sysroot'\n RUSTC=\"rustc $RUSTFLAGS -L crate=target/out --out-dir target/out\"\n export RUSTC_LOG=warn # display metadata load errors"}, {"sha": "4209ccfbdd2a90589fb2842c895bbf3266687716", "filename": "crate_patches/regex.patch", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/crate_patches%2Fregex.patch", "raw_url": "https://github.com/rust-lang/rust/raw/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/crate_patches%2Fregex.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crate_patches%2Fregex.patch?ref=aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8", "patch": "@@ -0,0 +1,34 @@\n+From febff2a8c639efb5de1e1b4758cdb473847d80ce Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Tue, 30 Jul 2019 12:12:37 +0200\n+Subject: [PATCH] Disable threads in shootout-regex-dna example\n+\n+---\n+ examples/shootout-regex-dna.rs | 4 ++--\n+ 1 file changed, 2 insertions(+), 2 deletions(-)\n+\n+diff --git a/examples/shootout-regex-dna.rs b/examples/shootout-regex-dna.rs\n+index 2171bb3..37382f8 100644\n+--- a/examples/shootout-regex-dna.rs\n++++ b/examples/shootout-regex-dna.rs\n+@@ -37,7 +37,7 @@ fn main() {\n+     for variant in variants {\n+         let seq = seq_arc.clone();\n+         let restr = variant.to_string();\n+-        let future = thread::spawn(move || variant.find_iter(&seq).count());\n++        let future = variant.find_iter(&seq).count();\n+         counts.push((restr, future));\n+     }\n+ \n+@@ -60,7 +60,7 @@ fn main() {\n+     }\n+ \n+     for (variant, count) in counts {\n+-        println!(\"{} {}\", variant, count.join().unwrap());\n++        println!(\"{} {}\", variant, count);\n+     }\n+     println!(\"\\n{}\\n{}\\n{}\", ilen, clen, seq.len());\n+ }\n+-- \n+2.11.0\n+"}, {"sha": "380bc487bcc9611cd4382872d37f5bec39ab74af", "filename": "example/mini_core_hello_world.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/example%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/example%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fmini_core_hello_world.rs?ref=aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8", "patch": "@@ -117,13 +117,23 @@ impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsiz\n fn take_f32(_f: f32) {}\n fn take_unique(_u: Unique<()>) {}\n \n+fn return_u128_pair() -> (u128, u128) {\n+    (0, 0)\n+}\n+\n+fn call_return_u128_pair() {\n+    return_u128_pair();\n+}\n+\n fn main() {\n     take_unique(Unique {\n         pointer: 0 as *const (),\n         _marker: PhantomData,\n     });\n     take_f32(0.1);\n \n+    call_return_u128_pair();\n+\n     //return;\n \n     unsafe {"}, {"sha": "33523a12871aad94e06410d26a16f14696ec4c54", "filename": "example/std_example.rs", "status": "modified", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/example%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/example%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fstd_example.rs?ref=aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8", "patch": "@@ -1,8 +1,10 @@\n #![feature(core_intrinsics)]\n \n+use std::arch::x86_64::*;\n use std::io::Write;\n use std::intrinsics;\n \n+\n fn main() {\n     let _ = ::std::iter::repeat('a' as u8).take(10).collect::<Vec<_>>();\n     let stderr = ::std::io::stderr();\n@@ -43,6 +45,129 @@ fn main() {\n     assert_eq!(0xFEDCBA987654321123456789ABCDEFu128 >> 64, 0xFEDCBA98765432u128);\n     assert_eq!(0xFEDCBA987654321123456789ABCDEFu128 as i128 >> 64, 0xFEDCBA98765432i128);\n     assert_eq!(353985398u128 * 932490u128, 330087843781020u128);\n+\n+    unsafe {\n+        test_simd();\n+    }\n+}\n+\n+#[target_feature(enable = \"sse2\")]\n+unsafe fn test_simd() {\n+    let x = _mm_setzero_si128();\n+    let y = _mm_set1_epi16(7);\n+    let or = _mm_or_si128(x, y);\n+    let cmp_eq = _mm_cmpeq_epi8(y, y);\n+    let cmp_lt = _mm_cmplt_epi8(y, y);\n+\n+    assert_eq!(std::mem::transmute::<_, [u16; 8]>(or), [7, 7, 7, 7, 7, 7, 7, 7]);\n+    assert_eq!(std::mem::transmute::<_, [u16; 8]>(cmp_eq), [0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff]);\n+    assert_eq!(std::mem::transmute::<_, [u16; 8]>(cmp_lt), [0, 0, 0, 0, 0, 0, 0, 0]);\n+\n+    test_mm_slli_si128();\n+    test_mm_movemask_epi8();\n+    test_mm256_movemask_epi8();\n+    test_mm_add_epi8();\n+    test_mm_add_pd();\n+\n+    let mask1 = _mm_movemask_epi8(dbg!(_mm_setr_epi8(255u8 as i8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)));\n+    assert_eq!(mask1, 1);\n+}\n+\n+#[target_feature(enable = \"sse2\")]\n+unsafe fn test_mm_slli_si128() {\n+    #[rustfmt::skip]\n+    let a = _mm_setr_epi8(\n+        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n+    );\n+    let r = _mm_slli_si128(a, 1);\n+    let e = _mm_setr_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\n+    assert_eq_m128i(r, e);\n+\n+    #[rustfmt::skip]\n+    let a = _mm_setr_epi8(\n+        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n+    );\n+    let r = _mm_slli_si128(a, 15);\n+    let e = _mm_setr_epi8(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);\n+    assert_eq_m128i(r, e);\n+\n+    #[rustfmt::skip]\n+    let a = _mm_setr_epi8(\n+        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n+    );\n+    let r = _mm_slli_si128(a, 16);\n+    assert_eq_m128i(r, _mm_set1_epi8(0));\n+\n+    #[rustfmt::skip]\n+    let a = _mm_setr_epi8(\n+        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n+    );\n+    let r = _mm_slli_si128(a, -1);\n+    assert_eq_m128i(_mm_set1_epi8(0), r);\n+\n+    #[rustfmt::skip]\n+    let a = _mm_setr_epi8(\n+        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n+    );\n+    let r = _mm_slli_si128(a, -0x80000000);\n+    assert_eq_m128i(r, _mm_set1_epi8(0));\n+}\n+\n+#[target_feature(enable = \"sse2\")]\n+unsafe fn test_mm_movemask_epi8() {\n+    #[rustfmt::skip]\n+    let a = _mm_setr_epi8(\n+        0b1000_0000u8 as i8, 0b0, 0b1000_0000u8 as i8, 0b01,\n+        0b0101, 0b1111_0000u8 as i8, 0, 0,\n+        0, 0, 0b1111_0000u8 as i8, 0b0101,\n+        0b01, 0b1000_0000u8 as i8, 0b0, 0b1000_0000u8 as i8,\n+    );\n+    let r = _mm_movemask_epi8(a);\n+    assert_eq!(r, 0b10100100_00100101);\n+}\n+\n+#[target_feature(enable = \"avx2\")]\n+unsafe fn test_mm256_movemask_epi8() {\n+    let a = _mm256_set1_epi8(-1);\n+    let r = _mm256_movemask_epi8(a);\n+    let e = -1;\n+    assert_eq!(r, e);\n+}\n+\n+#[target_feature(enable = \"sse2\")]\n+unsafe fn test_mm_add_epi8() {\n+    let a = _mm_setr_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\n+    #[rustfmt::skip]\n+    let b = _mm_setr_epi8(\n+        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\n+    );\n+    let r = _mm_add_epi8(a, b);\n+    #[rustfmt::skip]\n+    let e = _mm_setr_epi8(\n+        16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46,\n+    );\n+    assert_eq_m128i(r, e);\n+}\n+\n+#[target_feature(enable = \"sse2\")]\n+unsafe fn test_mm_add_pd() {\n+    let a = _mm_setr_pd(1.0, 2.0);\n+    let b = _mm_setr_pd(5.0, 10.0);\n+    let r = _mm_add_pd(a, b);\n+    assert_eq_m128d(r, _mm_setr_pd(6.0, 12.0));\n+}\n+\n+fn assert_eq_m128i(x: std::arch::x86_64::__m128i, y: std::arch::x86_64::__m128i) {\n+    unsafe {\n+        assert_eq!(std::mem::transmute::<_, [u8; 16]>(x), std::mem::transmute::<_, [u8; 16]>(x));\n+    }\n+}\n+\n+#[target_feature(enable = \"sse2\")]\n+pub unsafe fn assert_eq_m128d(a: __m128d, b: __m128d) {\n+    if _mm_movemask_pd(_mm_cmpeq_pd(a, b)) != 0b11 {\n+        panic!(\"{:?} != {:?}\", a, b);\n+    }\n }\n \n #[derive(PartialEq)]"}, {"sha": "14504cce09ff7ca3e860a19c604058bbb8998d1d", "filename": "patches/0015-Remove-usage-of-unsized-locals.patch", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/patches%2F0015-Remove-usage-of-unsized-locals.patch", "raw_url": "https://github.com/rust-lang/rust/raw/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/patches%2F0015-Remove-usage-of-unsized-locals.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0015-Remove-usage-of-unsized-locals.patch?ref=aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8", "patch": "@@ -94,5 +94,18 @@ index b2142e7..718bb1c 100644\n  }\n  \n  pub fn min_stack() -> usize {\n+diff --git a/src/libstd/sys/unix/thread.rs b/src/libstd/sys/unix/thread.rs\n+index f4a1783..362b537 100644\n+--- a/src/libstd/sys/unix/thread.rs\n++++ b/src/libstd/sys/unix/thread.rs\n+@@ -40,6 +40,8 @@ impl Thread {\n+     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n+     pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>)\n+                           -> io::Result<Thread> {\n++        panic!(\"Threads are not yet supported, because cranelift doesn't support atomics.\");\n++\n+         let p = box p;\n+         let mut native: libc::pthread_t = mem::zeroed();\n+         let mut attr: libc::pthread_attr_t = mem::zeroed();\n -- \n 2.20.1 (Apple Git-117)"}, {"sha": "ac24bc6e88c245354244c82ecadeec14b7f58aae", "filename": "patches/0016-Disable-cpuid-intrinsic.patch", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/patches%2F0016-Disable-cpuid-intrinsic.patch", "raw_url": "https://github.com/rust-lang/rust/raw/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/patches%2F0016-Disable-cpuid-intrinsic.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0016-Disable-cpuid-intrinsic.patch?ref=aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8", "patch": "@@ -0,0 +1,25 @@\n+From 7403e2998345ef0650fd50628d7098d4d1e88e5c Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Sat, 6 Apr 2019 12:16:21 +0200\n+Subject: [PATCH] Remove usage of unsized locals\n+\n+---\n+ src/stdarch/crates/core_arch/src/x86/cpuid.rs | 2 ++\n+ 1 files changed, 2 insertions(+), 0 deletions(-)\n+\n+diff --git a/src/stdarch/crates/core_arch/src/x86/cpuid.rs b/src/stdarch/crates/core_arch/src/x86/cpuid.rs\n+index f313c42..ff952bc 100644\n+--- a/src/stdarch/crates/core_arch/src/x86/cpuid.rs\n++++ b/src/stdarch/crates/core_arch/src/x86/cpuid.rs\n+@@ -84,6 +84,9 @@ pub unsafe fn __cpuid(leaf: u32) -> CpuidResult {\n+ /// Does the host support the `cpuid` instruction?\n+ #[inline]\n+ pub fn has_cpuid() -> bool {\n++    // __cpuid intrinsic is not yet implemented\n++    return false;\n++\n+     #[cfg(target_env = \"sgx\")]\n+     {\n+         false\n+-- \n+2.20.1 (Apple Git-117)"}, {"sha": "32cfa4b8c8830ee818cd186cd9881a71a013e606", "filename": "prepare.sh", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/prepare.sh", "raw_url": "https://github.com/rust-lang/rust/raw/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/prepare.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/prepare.sh?ref=aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8", "patch": "@@ -4,3 +4,10 @@ set -e\n rustup component add rust-src\n ./build_sysroot/prepare_sysroot_src.sh\n cargo install hyperfine || echo \"Skipping hyperfine install\"\n+\n+git clone https://github.com/rust-lang/regex.git || echo \"rust-lang/regex has already been cloned\"\n+pushd regex\n+git checkout -- .\n+git checkout 341f207c1071f7290e3f228c710817c280c8dca1\n+git apply ../crate_patches/regex.patch\n+popd"}, {"sha": "c66dbe3958d91c1d436bc1de0302054928bd9d94", "filename": "src/abi.rs", "status": "modified", "additions": 40, "deletions": 27, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8", "patch": "@@ -113,10 +113,16 @@ fn get_pass_mode<'tcx>(\n                 PassMode::ByVal(scalar_to_clif_type(tcx, scalar.clone()))\n             }\n             layout::Abi::ScalarPair(a, b) => {\n-                PassMode::ByValPair(\n-                    scalar_to_clif_type(tcx, a.clone()),\n-                    scalar_to_clif_type(tcx, b.clone()),\n-                )\n+                let a = scalar_to_clif_type(tcx, a.clone());\n+                let b = scalar_to_clif_type(tcx, b.clone());\n+                if a == types::I128 && b == types::I128 {\n+                    // Returning (i128, i128) by-val-pair would take 4 regs, while only 3 are\n+                    // available on x86_64. Cranelift gets confused when too many return params\n+                    // are used.\n+                    PassMode::ByRef\n+                } else {\n+                    PassMode::ByValPair(a, b)\n+                }\n             }\n \n             // FIXME implement Vector Abi in a cg_llvm compatible way\n@@ -268,7 +274,9 @@ impl<'a, 'tcx: 'a, B: Backend + 'a> FunctionCx<'a, 'tcx, B> {\n             .module\n             .declare_func_in_func(func_id, &mut self.bcx.func);\n         let call_inst = self.bcx.ins().call(func_ref, args);\n-        self.add_comment(call_inst, format!(\"easy_call {}\", name));\n+        #[cfg(debug_assertions)] {\n+            self.add_comment(call_inst, format!(\"easy_call {}\", name));\n+        }\n         let results = self.bcx.inst_results(call_inst);\n         assert!(results.len() <= 2, \"{}\", results.len());\n         results\n@@ -613,28 +621,6 @@ pub fn codegen_terminator_call<'a, 'tcx: 'a>(\n     let fn_ty = fx.monomorphize(&func.ty(fx.mir, fx.tcx));\n     let sig = fx.tcx.normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), &fn_ty.fn_sig(fx.tcx));\n \n-    // Unpack arguments tuple for closures\n-    let args = if sig.abi == Abi::RustCall {\n-        assert_eq!(args.len(), 2, \"rust-call abi requires two arguments\");\n-        let self_arg = trans_operand(fx, &args[0]);\n-        let pack_arg = trans_operand(fx, &args[1]);\n-        let mut args = Vec::new();\n-        args.push(self_arg);\n-        match pack_arg.layout().ty.sty {\n-            ty::Tuple(ref tupled_arguments) => {\n-                for (i, _) in tupled_arguments.iter().enumerate() {\n-                    args.push(pack_arg.value_field(fx, mir::Field::new(i)));\n-                }\n-            }\n-            _ => bug!(\"argument to function with \\\"rust-call\\\" ABI is not a tuple\"),\n-        }\n-        args\n-    } else {\n-        args.into_iter()\n-            .map(|arg| trans_operand(fx, arg))\n-            .collect::<Vec<_>>()\n-    };\n-\n     let destination = destination\n         .as_ref()\n         .map(|&(ref place, bb)| (trans_place(fx, place), bb));\n@@ -643,6 +629,11 @@ pub fn codegen_terminator_call<'a, 'tcx: 'a>(\n         let instance =\n             ty::Instance::resolve(fx.tcx, ty::ParamEnv::reveal_all(), def_id, substs).unwrap();\n \n+        if fx.tcx.symbol_name(instance).as_str().starts_with(\"llvm.\") {\n+            crate::llvm_intrinsics::codegen_llvm_intrinsic_call(fx, &fx.tcx.symbol_name(instance).as_str(), substs, args, destination);\n+            return;\n+        }\n+\n         match instance.def {\n             InstanceDef::Intrinsic(_) => {\n                 crate::intrinsics::codegen_intrinsic_call(fx, def_id, substs, args, destination);\n@@ -659,6 +650,28 @@ pub fn codegen_terminator_call<'a, 'tcx: 'a>(\n         }\n     }\n \n+    // Unpack arguments tuple for closures\n+    let args = if sig.abi == Abi::RustCall {\n+        assert_eq!(args.len(), 2, \"rust-call abi requires two arguments\");\n+        let self_arg = trans_operand(fx, &args[0]);\n+        let pack_arg = trans_operand(fx, &args[1]);\n+        let mut args = Vec::new();\n+        args.push(self_arg);\n+        match pack_arg.layout().ty.sty {\n+            ty::Tuple(ref tupled_arguments) => {\n+                for (i, _) in tupled_arguments.iter().enumerate() {\n+                    args.push(pack_arg.value_field(fx, mir::Field::new(i)));\n+                }\n+            }\n+            _ => bug!(\"argument to function with \\\"rust-call\\\" ABI is not a tuple\"),\n+        }\n+        args\n+    } else {\n+        args.into_iter()\n+            .map(|arg| trans_operand(fx, arg))\n+            .collect::<Vec<_>>()\n+    };\n+\n     codegen_call_inner(\n         fx,\n         Some(func),"}, {"sha": "c8fb2767f9a32618234a6baf648b655d064bd81c", "filename": "src/constant.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8", "patch": "@@ -88,7 +88,7 @@ pub fn trans_constant<'a, 'tcx: 'a>(\n }\n \n pub fn force_eval_const<'a, 'tcx: 'a>(\n-    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    fx: &FunctionCx<'a, 'tcx, impl Backend>,\n     const_: &'tcx Const,\n ) -> &'tcx Const<'tcx> {\n     match const_.val {\n@@ -422,3 +422,32 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for TransPlaceInterpreter {\n         Ok(())\n     }\n }\n+\n+pub fn mir_operand_get_const_val<'tcx>(\n+    fx: &FunctionCx<'_, 'tcx, impl Backend>,\n+    operand: &Operand<'tcx>,\n+) -> Result<&'tcx Const<'tcx>, String> {\n+    let place = match operand {\n+        Operand::Copy(place) => place,\n+        Operand::Constant(const_) => return Ok(force_eval_const(fx, const_.literal)),\n+        _ => return Err(format!(\"{:?}\", operand)),\n+    };\n+\n+    assert!(place.projection.is_none());\n+    let static_ = match &place.base {\n+        PlaceBase::Static(static_) => {\n+            static_\n+        }\n+        PlaceBase::Local(_) => return Err(\"local\".to_string()),\n+    };\n+\n+    Ok(match &static_.kind {\n+        StaticKind::Static(_) => unimplemented!(),\n+        StaticKind::Promoted(promoted) => {\n+            fx.tcx.const_eval(ParamEnv::reveal_all().and(GlobalId {\n+                instance: fx.instance,\n+                promoted: Some(*promoted),\n+            })).unwrap()\n+        }\n+    })\n+}"}, {"sha": "a456cac1d747bf605545146971284a0a99e9802f", "filename": "src/intrinsics.rs", "status": "modified", "additions": 316, "deletions": 28, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/src%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/src%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics.rs?ref=aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8", "patch": "@@ -2,47 +2,58 @@ use crate::prelude::*;\n \n use rustc::ty::subst::SubstsRef;\n \n-macro_rules! intrinsic_pat {\n+macro intrinsic_pat {\n     (_) => {\n         _\n-    };\n+    },\n     ($name:ident) => {\n         stringify!($name)\n+    },\n+    ($name:literal) => {\n+        stringify!($name)\n+    },\n+    ($x:ident . $($xs:tt).*) => {\n+        concat!(stringify!($x), \".\", intrinsic_pat!($($xs).*))\n     }\n }\n \n-macro_rules! intrinsic_arg {\n-    (c $fx:expr, $arg:ident) => {\n+macro intrinsic_arg {\n+    (o $fx:expr, $arg:ident) => {\n         $arg\n-    };\n+    },\n+    (c $fx:expr, $arg:ident) => {\n+        trans_operand($fx, $arg)\n+    },\n     (v $fx:expr, $arg:ident) => {\n-        $arg.load_scalar($fx)\n-    };\n+        trans_operand($fx, $arg).load_scalar($fx)\n+    }\n }\n \n-macro_rules! intrinsic_substs {\n-    ($substs:expr, $index:expr,) => {};\n+macro intrinsic_substs {\n+    ($substs:expr, $index:expr,) => {},\n     ($substs:expr, $index:expr, $first:ident $(,$rest:ident)*) => {\n         let $first = $substs.type_at($index);\n         intrinsic_substs!($substs, $index+1, $($rest),*);\n-    };\n+    }\n }\n \n-macro_rules! intrinsic_match {\n-    ($fx:expr, $intrinsic:expr, $substs:expr, $args:expr, $(\n-        $($name:tt)|+ $(if $cond:expr)?, $(<$($subst:ident),*>)? ($($a:ident $arg:ident),*) $content:block;\n+pub macro intrinsic_match {\n+    ($fx:expr, $intrinsic:expr, $substs:expr, $args:expr,\n+    _ => $unknown:block;\n+    $(\n+        $($($name:tt).*)|+ $(if $cond:expr)?, $(<$($subst:ident),*>)? ($($a:ident $arg:ident),*) $content:block;\n     )*) => {\n         match $intrinsic {\n             $(\n-                $(intrinsic_pat!($name))|* $(if $cond)? => {\n+                $(intrinsic_pat!($($name).*))|* $(if $cond)? => {\n                     #[allow(unused_parens, non_snake_case)]\n                     {\n                         $(\n                             intrinsic_substs!($substs, 0, $($subst),*);\n                         )?\n-                        if let [$($arg),*] = *$args {\n-                            let ($($arg),*) = (\n-                                $(intrinsic_arg!($a $fx, $arg)),*\n+                        if let [$($arg),*] = $args {\n+                            let ($($arg,)*) = (\n+                                $(intrinsic_arg!($a $fx, $arg),)*\n                             );\n                             #[warn(unused_parens, non_snake_case)]\n                             {\n@@ -54,9 +65,9 @@ macro_rules! intrinsic_match {\n                     }\n                 }\n             )*\n-            _ => unimpl!(\"unsupported intrinsic {}\", $intrinsic),\n+            _ => $unknown,\n         }\n-    };\n+    }\n }\n \n macro_rules! call_intrinsic_match {\n@@ -67,7 +78,10 @@ macro_rules! call_intrinsic_match {\n             $(\n                 stringify!($name) => {\n                     assert!($substs.is_noop());\n-                    if let [$($arg),*] = *$args {\n+                    if let [$(ref $arg),*] = *$args {\n+                        let ($($arg,)*) = (\n+                            $(trans_operand($fx, $arg),)*\n+                        );\n                         let res = $fx.easy_call(stringify!($func), &[$($arg),*], $fx.tcx.types.$ty);\n                         $ret.write_cvalue($fx, res);\n \n@@ -116,11 +130,156 @@ macro_rules! atomic_minmax {\n     };\n }\n \n+pub fn lane_type_and_count<'tcx>(\n+    fx: &FunctionCx<'_, 'tcx, impl Backend>,\n+    layout: TyLayout<'tcx>,\n+    intrinsic: &str,\n+) -> (TyLayout<'tcx>, u32) {\n+    assert!(layout.ty.is_simd());\n+    let lane_count = match layout.fields {\n+        layout::FieldPlacement::Array { stride: _, count } => u32::try_from(count).unwrap(),\n+        _ => panic!(\"Non vector type {:?} passed to or returned from simd_* intrinsic {}\", layout.ty, intrinsic),\n+    };\n+    let lane_layout = layout.field(fx, 0);\n+    (lane_layout, lane_count)\n+}\n+\n+pub fn simd_for_each_lane<'tcx, B: Backend>(\n+    fx: &mut FunctionCx<'_, 'tcx, B>,\n+    intrinsic: &str,\n+    x: CValue<'tcx>,\n+    y: CValue<'tcx>,\n+    ret: CPlace<'tcx>,\n+    f: impl Fn(&mut FunctionCx<'_, 'tcx, B>, TyLayout<'tcx>, TyLayout<'tcx>, Value, Value) -> CValue<'tcx>,\n+) {\n+    assert_eq!(x.layout(), y.layout());\n+    let layout = x.layout();\n+\n+    let (lane_layout, lane_count) = lane_type_and_count(fx, layout, intrinsic);\n+    let (ret_lane_layout, ret_lane_count) = lane_type_and_count(fx, ret.layout(), intrinsic);\n+    assert_eq!(lane_count, ret_lane_count);\n+\n+    for lane in 0..lane_count {\n+        let lane = mir::Field::new(lane.try_into().unwrap());\n+        let x_lane = x.value_field(fx, lane).load_scalar(fx);\n+        let y_lane = y.value_field(fx, lane).load_scalar(fx);\n+\n+        let res_lane = f(fx, lane_layout, ret_lane_layout, x_lane, y_lane);\n+\n+        ret.place_field(fx, lane).write_cvalue(fx, res_lane);\n+    }\n+}\n+\n+pub fn bool_to_zero_or_max_uint<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n+    layout: TyLayout<'tcx>,\n+    val: Value,\n+) -> CValue<'tcx> {\n+    let ty = fx.clif_type(layout.ty).unwrap();\n+\n+    let int_ty = match ty {\n+        types::F32 => types::I32,\n+        types::F64 => types::I64,\n+        ty => ty,\n+    };\n+\n+    let zero = fx.bcx.ins().iconst(int_ty, 0);\n+    let max = fx.bcx.ins().iconst(int_ty, (u64::max_value() >> (64 - int_ty.bits())) as i64);\n+    let mut res = crate::common::codegen_select(&mut fx.bcx, val, max, zero);\n+\n+    if ty.is_float() {\n+        res = fx.bcx.ins().bitcast(ty, res);\n+    }\n+\n+    CValue::by_val(res, layout)\n+}\n+\n+macro_rules! simd_cmp {\n+    ($fx:expr, $intrinsic:expr, $cc:ident($x:ident, $y:ident) -> $ret:ident) => {\n+        simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, lane_layout, res_lane_layout, x_lane, y_lane| {\n+            let res_lane = match lane_layout.ty.sty {\n+                ty::Uint(_) | ty::Int(_) => fx.bcx.ins().icmp(IntCC::$cc, x_lane, y_lane),\n+                _ => unreachable!(\"{:?}\", lane_layout.ty),\n+            };\n+            bool_to_zero_or_max_uint(fx, res_lane_layout, res_lane)\n+        });\n+    };\n+    ($fx:expr, $intrinsic:expr, $cc_u:ident|$cc_s:ident($x:ident, $y:ident) -> $ret:ident) => {\n+        simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, lane_layout, res_lane_layout, x_lane, y_lane| {\n+            let res_lane = match lane_layout.ty.sty {\n+                ty::Uint(_) => fx.bcx.ins().icmp(IntCC::$cc_u, x_lane, y_lane),\n+                ty::Int(_) => fx.bcx.ins().icmp(IntCC::$cc_s, x_lane, y_lane),\n+                _ => unreachable!(\"{:?}\", lane_layout.ty),\n+            };\n+            bool_to_zero_or_max_uint(fx, res_lane_layout, res_lane)\n+        });\n+    };\n+\n+}\n+\n+macro_rules! simd_int_binop {\n+    ($fx:expr, $intrinsic:expr, $op:ident($x:ident, $y:ident) -> $ret:ident) => {\n+        simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n+            let res_lane = match lane_layout.ty.sty {\n+                ty::Uint(_) | ty::Int(_) => fx.bcx.ins().$op(x_lane, y_lane),\n+                _ => unreachable!(\"{:?}\", lane_layout.ty),\n+            };\n+            CValue::by_val(res_lane, ret_lane_layout)\n+        });\n+    };\n+    ($fx:expr, $intrinsic:expr, $op_u:ident|$op_s:ident($x:ident, $y:ident) -> $ret:ident) => {\n+        simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n+            let res_lane = match lane_layout.ty.sty {\n+                ty::Uint(_) => fx.bcx.ins().$op_u(x_lane, y_lane),\n+                ty::Int(_) => fx.bcx.ins().$op_s(x_lane, y_lane),\n+                _ => unreachable!(\"{:?}\", lane_layout.ty),\n+            };\n+            CValue::by_val(res_lane, ret_lane_layout)\n+        });\n+    };\n+}\n+\n+macro_rules! simd_int_flt_binop {\n+    ($fx:expr, $intrinsic:expr, $op:ident|$op_f:ident($x:ident, $y:ident) -> $ret:ident) => {\n+        simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n+            let res_lane = match lane_layout.ty.sty {\n+                ty::Uint(_) | ty::Int(_) => fx.bcx.ins().$op(x_lane, y_lane),\n+                ty::Float(_) => fx.bcx.ins().$op_f(x_lane, y_lane),\n+                _ => unreachable!(\"{:?}\", lane_layout.ty),\n+            };\n+            CValue::by_val(res_lane, ret_lane_layout)\n+        });\n+    };\n+    ($fx:expr, $intrinsic:expr, $op_u:ident|$op_s:ident|$op_f:ident($x:ident, $y:ident) -> $ret:ident) => {\n+        simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n+            let res_lane = match lane_layout.ty.sty {\n+                ty::Uint(_) => fx.bcx.ins().$op_u(x_lane, y_lane),\n+                ty::Int(_) => fx.bcx.ins().$op_s(x_lane, y_lane),\n+                ty::Float(_) => fx.bcx.ins().$op_f(x_lane, y_lane),\n+                _ => unreachable!(\"{:?}\", lane_layout.ty),\n+            };\n+            CValue::by_val(res_lane, ret_lane_layout)\n+        });\n+    };\n+}\n+\n+macro_rules! simd_flt_binop {\n+    ($fx:expr, $intrinsic:expr, $op:ident($x:ident, $y:ident) -> $ret:ident) => {\n+        simd_for_each_lane($fx, $intrinsic, $x, $y, $ret, |fx, lane_layout, ret_lane_layout, x_lane, y_lane| {\n+            let res_lane = match lane_layout.ty.sty {\n+                ty::Float(_) => fx.bcx.ins().$op(x_lane, y_lane),\n+                _ => unreachable!(\"{:?}\", lane_layout.ty),\n+            };\n+            CValue::by_val(res_lane, ret_lane_layout)\n+        });\n+    }\n+}\n+\n pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     def_id: DefId,\n     substs: SubstsRef<'tcx>,\n-    args: Vec<CValue<'tcx>>,\n+    args: &[mir::Operand<'tcx>],\n     destination: Option<(CPlace<'tcx>, BasicBlock)>,\n ) {\n     let intrinsic = fx.tcx.item_name(def_id).as_str();\n@@ -180,16 +339,13 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n         cosf64(flt) -> f64 => cos,\n         tanf32(flt) -> f32 => tanf,\n         tanf64(flt) -> f64 => tan,\n-\n-        // minmax\n-        minnumf32(a, b) -> f32 => fminf,\n-        minnumf64(a, b) -> f64 => fmin,\n-        maxnumf32(a, b) -> f32 => fmaxf,\n-        maxnumf64(a, b) -> f64 => fmax,\n     }\n \n     intrinsic_match! {\n         fx, intrinsic, substs, args,\n+        _ => {\n+            unimpl!(\"unsupported intrinsic {}\", intrinsic)\n+        };\n \n         assume, (c _a) {};\n         likely | unlikely, (c a) {\n@@ -413,7 +569,7 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n             let ptr_diff = fx.bcx.ins().imul_imm(offset, pointee_size as i64);\n             let base_val = base.load_scalar(fx);\n             let res = fx.bcx.ins().iadd(base_val, ptr_diff);\n-            ret.write_cvalue(fx, CValue::by_val(res, args[0].layout()));\n+            ret.write_cvalue(fx, CValue::by_val(res, base.layout()));\n         };\n \n         transmute, <src_ty, dst_ty> (c from) {\n@@ -675,6 +831,138 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n         _ if intrinsic.starts_with(\"atomic_umin\"), <T> (v ptr, v src) {\n             atomic_minmax!(fx, IntCC::UnsignedLessThan, <T> (ptr, src) -> ret);\n         };\n+\n+        minnumf32, (v a, v b) {\n+            let val = fx.bcx.ins().fmin(a, b);\n+            let val = CValue::by_val(val, fx.layout_of(fx.tcx.types.f32));\n+            ret.write_cvalue(fx, val);\n+        };\n+        minnumf64, (v a, v b) {\n+            let val = fx.bcx.ins().fmin(a, b);\n+            let val = CValue::by_val(val, fx.layout_of(fx.tcx.types.f64));\n+            ret.write_cvalue(fx, val);\n+        };\n+        maxnumf32, (v a, v b) {\n+            let val = fx.bcx.ins().fmax(a, b);\n+            let val = CValue::by_val(val, fx.layout_of(fx.tcx.types.f32));\n+            ret.write_cvalue(fx, val);\n+        };\n+        maxnumf64, (v a, v b) {\n+            let val = fx.bcx.ins().fmax(a, b);\n+            let val = CValue::by_val(val, fx.layout_of(fx.tcx.types.f64));\n+            ret.write_cvalue(fx, val);\n+        };\n+\n+        simd_cast, (c x) {\n+            ret.write_cvalue(fx, x.unchecked_cast_to(ret.layout()));\n+        };\n+\n+        simd_eq, (c x, c y) {\n+            simd_cmp!(fx, intrinsic, Equal(x, y) -> ret);\n+        };\n+        simd_ne, (c x, c y) {\n+            simd_cmp!(fx, intrinsic, NotEqual(x, y) -> ret);\n+        };\n+        simd_lt, (c x, c y) {\n+            simd_cmp!(fx, intrinsic, UnsignedLessThan|SignedLessThan(x, y) -> ret);\n+        };\n+        simd_le, (c x, c y) {\n+            simd_cmp!(fx, intrinsic, UnsignedLessThanOrEqual|SignedLessThanOrEqual(x, y) -> ret);\n+        };\n+        simd_gt, (c x, c y) {\n+            simd_cmp!(fx, intrinsic, UnsignedGreaterThan|SignedGreaterThan(x, y) -> ret);\n+        };\n+        simd_ge, (c x, c y) {\n+            simd_cmp!(fx, intrinsic, UnsignedGreaterThanOrEqual|SignedGreaterThanOrEqual(x, y) -> ret);\n+        };\n+\n+        // simd_shuffle32<T, U>(x: T, y: T, idx: [u32; 32]) -> U\n+        _ if intrinsic.starts_with(\"simd_shuffle\"), (c x, c y, o idx) {\n+            let n: u32 = intrinsic[\"simd_shuffle\".len()..].parse().unwrap();\n+\n+            assert_eq!(x.layout(), y.layout());\n+            let layout = x.layout();\n+\n+            let (lane_type, lane_count) = lane_type_and_count(fx, layout, intrinsic);\n+            let (ret_lane_type, ret_lane_count) = lane_type_and_count(fx, ret.layout(), intrinsic);\n+\n+            assert_eq!(lane_type, ret_lane_type);\n+            assert_eq!(n, ret_lane_count);\n+\n+            let total_len = lane_count * 2;\n+\n+            let indexes = {\n+                use rustc::mir::interpret::*;\n+                let idx_const = crate::constant::mir_operand_get_const_val(fx, idx).expect(\"simd_shuffle* idx not const\");\n+\n+                let idx_bytes = match idx_const.val {\n+                    ConstValue::ByRef { align: _, offset, alloc } => {\n+                        let ptr = Pointer::new(AllocId(0 /* dummy */), offset);\n+                        let size = Size::from_bytes(4 * u64::from(ret_lane_count) /* size_of([u32; ret_lane_count]) */);\n+                        alloc.get_bytes(fx, ptr, size).unwrap()\n+                    }\n+                    _ => unreachable!(\"{:?}\", idx_const),\n+                };\n+\n+                (0..ret_lane_count).map(|i| {\n+                    let i = usize::try_from(i).unwrap();\n+                    let idx = rustc::mir::interpret::read_target_uint(\n+                        fx.tcx.data_layout.endian,\n+                        &idx_bytes[4*i.. 4*i + 4],\n+                    ).expect(\"read_target_uint\");\n+                    u32::try_from(idx).expect(\"try_from u32\")\n+                }).collect::<Vec<u32>>()\n+            };\n+\n+            for &idx in &indexes {\n+                assert!(idx < total_len, \"idx {} out of range 0..{}\", idx, total_len);\n+            }\n+\n+            for (out_idx, in_idx) in indexes.into_iter().enumerate() {\n+                let in_lane = if in_idx < lane_count {\n+                    x.value_field(fx, mir::Field::new(in_idx.try_into().unwrap()))\n+                } else {\n+                    y.value_field(fx, mir::Field::new((in_idx - lane_count).try_into().unwrap()))\n+                };\n+                let out_lane = ret.place_field(fx, mir::Field::new(out_idx));\n+                out_lane.write_cvalue(fx, in_lane);\n+            }\n+        };\n+\n+        simd_add, (c x, c y) {\n+            simd_int_flt_binop!(fx, intrinsic, iadd|fadd(x, y) -> ret);\n+        };\n+        simd_sub, (c x, c y) {\n+            simd_int_flt_binop!(fx, intrinsic, isub|fsub(x, y) -> ret);\n+        };\n+        simd_mul, (c x, c y) {\n+            simd_int_flt_binop!(fx, intrinsic, imul|fmul(x, y) -> ret);\n+        };\n+        simd_div, (c x, c y) {\n+            simd_int_flt_binop!(fx, intrinsic, udiv|sdiv|fdiv(x, y) -> ret);\n+        };\n+        simd_shl, (c x, c y) {\n+            simd_int_binop!(fx, intrinsic, ishl(x, y) -> ret);\n+        };\n+        simd_shr, (c x, c y) {\n+            simd_int_binop!(fx, intrinsic, ushr|sshr(x, y) -> ret);\n+        };\n+        simd_and, (c x, c y) {\n+            simd_int_binop!(fx, intrinsic, band(x, y) -> ret);\n+        };\n+        simd_or, (c x, c y) {\n+            simd_int_binop!(fx, intrinsic, bor(x, y) -> ret);\n+        };\n+        simd_xor, (c x, c y) {\n+            simd_int_binop!(fx, intrinsic, bxor(x, y) -> ret);\n+        };\n+\n+        simd_fmin, (c x, c y) {\n+            simd_flt_binop!(fx, intrinsic, fmin(x, y) -> ret);\n+        };\n+        simd_fmax, (c x, c y) {\n+            simd_flt_binop!(fx, intrinsic, fmax(x, y) -> ret);\n+        };\n     }\n \n     if let Some((_, dest)) = destination {"}, {"sha": "cdaabcf9a390326cc28b3f690ce7ca4855323d97", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8", "patch": "@@ -40,6 +40,7 @@ mod debuginfo;\n mod driver;\n mod intrinsics;\n mod linkage;\n+mod llvm_intrinsics;\n mod main_shim;\n mod metadata;\n mod pretty_clif;"}, {"sha": "284bdee52b8cefc9c75b3cec01c9685ff5736f83", "filename": "src/llvm_intrinsics.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/src%2Fllvm_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/src%2Fllvm_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm_intrinsics.rs?ref=aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8", "patch": "@@ -0,0 +1,111 @@\n+use crate::prelude::*;\n+use crate::intrinsics::*;\n+\n+use rustc::ty::subst::SubstsRef;\n+\n+pub fn codegen_llvm_intrinsic_call<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    intrinsic: &str,\n+    substs: SubstsRef<'tcx>,\n+    args: &[mir::Operand<'tcx>],\n+    destination: Option<(CPlace<'tcx>, BasicBlock)>,\n+) {\n+    let ret = match destination {\n+        Some((place, _)) => place,\n+        None => {\n+            // Insert non returning intrinsics here\n+            match intrinsic {\n+                \"abort\" => {\n+                    trap_panic(fx, \"Called intrinsic::abort.\");\n+                }\n+                \"unreachable\" => {\n+                    trap_unreachable(fx, \"[corruption] Called intrinsic::unreachable.\");\n+                }\n+                _ => unimplemented!(\"unsupported instrinsic {}\", intrinsic),\n+            }\n+            return;\n+        }\n+    };\n+\n+    intrinsic_match! {\n+        fx, intrinsic, substs, args,\n+        _ => {\n+            fx.tcx.sess.warn(&format!(\"unsupported llvm intrinsic {}; replacing with trap\", intrinsic));\n+            crate::trap::trap_unimplemented(fx, intrinsic);\n+        };\n+\n+        // Used by `_mm_movemask_epi8` and `_mm256_movemask_epi8`\n+        llvm.x86.sse2.pmovmskb.128 | llvm.x86.avx2.pmovmskb | llvm.x86.sse2.movmsk.pd, (c a) {\n+            let (lane_layout, lane_count) = lane_type_and_count(fx, a.layout(), intrinsic);\n+            let lane_ty = fx.clif_type(lane_layout.ty).unwrap();\n+            assert!(lane_count <= 32);\n+\n+            let mut res = fx.bcx.ins().iconst(types::I32, 0);\n+\n+            for lane in (0..lane_count).rev() {\n+                let a_lane = a.value_field(fx, mir::Field::new(lane.try_into().unwrap())).load_scalar(fx);\n+\n+                // cast float to int\n+                let a_lane = match lane_ty {\n+                    types::F32 => fx.bcx.ins().bitcast(types::I32, a_lane),\n+                    types::F64 => fx.bcx.ins().bitcast(types::I64, a_lane),\n+                    _ => a_lane,\n+                };\n+\n+                // extract sign bit of an int\n+                let a_lane_sign = fx.bcx.ins().ushr_imm(a_lane, i64::from(lane_ty.bits() - 1));\n+\n+                // shift sign bit into result\n+                let a_lane_sign = clif_intcast(fx, a_lane_sign, types::I32, false);\n+                res = fx.bcx.ins().ishl_imm(res, 1);\n+                res = fx.bcx.ins().bor(res, a_lane_sign);\n+            }\n+\n+            let res = CValue::by_val(res, fx.layout_of(fx.tcx.types.i32));\n+            ret.write_cvalue(fx, res);\n+        };\n+        llvm.x86.sse2.cmp.ps | llvm.x86.sse2.cmp.pd, (c x, c y, o kind) {\n+            let kind_const = crate::constant::mir_operand_get_const_val(fx, kind).expect(\"llvm.x86.sse2.cmp.* kind not const\");\n+            let flt_cc = match kind_const.val.try_to_bits(Size::from_bytes(1)).expect(&format!(\"kind not scalar: {:?}\", kind_const)) {\n+                0 => FloatCC::Equal,\n+                1 => FloatCC::LessThan,\n+                2 => FloatCC::LessThanOrEqual,\n+                7 => {\n+                    unimplemented!(\"Compares corresponding elements in `a` and `b` to see if neither is `NaN`.\");\n+                }\n+                3 => {\n+                    unimplemented!(\"Compares corresponding elements in `a` and `b` to see if either is `NaN`.\");\n+                }\n+                4 => FloatCC::NotEqual,\n+                5 => {\n+                    unimplemented!(\"not less than\");\n+                }\n+                6 => {\n+                    unimplemented!(\"not less than or equal\");\n+                }\n+                kind => unreachable!(\"kind {:?}\", kind),\n+            };\n+\n+            simd_for_each_lane(fx, intrinsic, x, y, ret, |fx, lane_layout, res_lane_layout, x_lane, y_lane| {\n+                let res_lane = match lane_layout.ty.sty {\n+                    ty::Float(_) => fx.bcx.ins().fcmp(flt_cc, x_lane, y_lane),\n+                    _ => unreachable!(\"{:?}\", lane_layout.ty),\n+                };\n+                bool_to_zero_or_max_uint(fx, res_lane_layout, res_lane)\n+            });\n+        };\n+    }\n+\n+    if let Some((_, dest)) = destination {\n+        let ret_ebb = fx.get_ebb(dest);\n+        fx.bcx.ins().jump(ret_ebb, &[]);\n+    } else {\n+        trap_unreachable(fx, \"[corruption] Diverging intrinsic returned.\");\n+    }\n+}\n+\n+// llvm.x86.avx2.vperm2i128\n+// llvm.x86.ssse3.pshuf.b.128\n+// llvm.x86.avx2.pshuf.b\n+// llvm.x86.avx2.psrli.w\n+// llvm.x86.sse2.psrli.w"}, {"sha": "c4e2cf35766bce5f3565dd9d8a4fa504fea914d2", "filename": "src/trap.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/src%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/src%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftrap.rs?ref=aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8", "patch": "@@ -7,7 +7,9 @@ fn codegen_print(fx: &mut FunctionCx<'_, '_, impl cranelift_module::Backend>, ms\n         returns: vec![],\n     }).unwrap();\n     let puts = fx.module.declare_func_in_func(puts, &mut fx.bcx.func);\n-    fx.add_entity_comment(puts, \"puts\");\n+    #[cfg(debug_assertions)] {\n+        fx.add_entity_comment(puts, \"puts\");\n+    }\n \n     let symbol_name = fx.tcx.symbol_name(fx.instance);\n     let real_msg = format!(\"trap at {:?} ({}): {}\\0\", fx.instance, symbol_name, msg);\n@@ -19,7 +21,9 @@ fn codegen_print(fx: &mut FunctionCx<'_, '_, impl cranelift_module::Backend>, ms\n     let _ = fx.module.define_data(msg_id, &data_ctx);\n \n     let local_msg_id = fx.module.declare_data_in_func(msg_id, fx.bcx.func);\n-    fx.add_entity_comment(local_msg_id, msg);\n+    #[cfg(debug_assertions)] {\n+        fx.add_entity_comment(local_msg_id, msg);\n+    }\n     let msg_ptr = fx.bcx.ins().global_value(pointer_ty(fx.tcx), local_msg_id);\n     fx.bcx.ins().call(puts, &[msg_ptr]);\n }"}, {"sha": "8df6b207964578b250d6c628b5257ab675f85569", "filename": "test.sh", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/test.sh", "raw_url": "https://github.com/rust-lang/rust/raw/aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8/test.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test.sh?ref=aa803f4fa664fe5e5fb91bd1e8679b37c9dde3f8", "patch": "@@ -1,4 +1,15 @@\n #!/bin/bash\n+\n+set -e\n+\n+if [[ \"$1\" == \"--release\" ]]; then\n+    export CHANNEL='release'\n+    cargo build --release\n+else\n+    export CHANNEL='debug'\n+    cargo build\n+fi\n+\n source config.sh\n \n rm -r target/out || true\n@@ -39,6 +50,19 @@ $RUSTC example/mod_bench.rs --crate-type bin\n #echo \"[BUILD] sysroot in release mode\"\n #./build_sysroot/build_sysroot.sh --release\n \n+pushd regex\n+echo \"[TEST] rust-lang/regex example shootout-regex-dna\"\n+../cargo.sh clean\n+# Make sure `[codegen mono items] start` doesn't poison the diff\n+../cargo.sh build --example shootout-regex-dna\n+cat examples/regexdna-input.txt | ../cargo.sh run --example shootout-regex-dna > res.txt\n+diff -u res.txt examples/regexdna-output.txt\n+\n+# FIXME compile libtest\n+# echo \"[TEST] rust-lang/regex standalone tests\"\n+# ../cargo.sh test\n+popd\n+\n COMPILE_MOD_BENCH_INLINE=\"$RUSTC example/mod_bench.rs --crate-type bin -Zmir-opt-level=3 -O --crate-name mod_bench_inline\"\n COMPILE_MOD_BENCH_LLVM_0=\"rustc example/mod_bench.rs --crate-type bin -Copt-level=0 -o target/out/mod_bench_llvm_0 -Cpanic=abort\"\n COMPILE_MOD_BENCH_LLVM_1=\"rustc example/mod_bench.rs --crate-type bin -Copt-level=1 -o target/out/mod_bench_llvm_1 -Cpanic=abort\""}]}