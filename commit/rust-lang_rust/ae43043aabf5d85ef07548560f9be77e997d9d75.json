{"sha": "ae43043aabf5d85ef07548560f9be77e997d9d75", "node_id": "C_kwDOAAsO6NoAKGFlNDMwNDNhYWJmNWQ4NWVmMDc1NDg1NjBmOWJlNzdlOTk3ZDlkNzU", "commit": {"author": {"name": "Amos Wenger", "email": "amoswenger@gmail.com", "date": "2022-11-25T12:06:01Z"}, "committer": {"name": "Amos Wenger", "email": "amoswenger@gmail.com", "date": "2022-11-25T12:06:01Z"}, "message": "Merge commit '79923c382' into HEAD", "tree": {"sha": "81031442e82a02cd3e145e512c7f504d7a00345a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81031442e82a02cd3e145e512c7f504d7a00345a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae43043aabf5d85ef07548560f9be77e997d9d75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae43043aabf5d85ef07548560f9be77e997d9d75", "html_url": "https://github.com/rust-lang/rust/commit/ae43043aabf5d85ef07548560f9be77e997d9d75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae43043aabf5d85ef07548560f9be77e997d9d75/comments", "author": {"login": "fasterthanlime", "id": 7998310, "node_id": "MDQ6VXNlcjc5OTgzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/7998310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fasterthanlime", "html_url": "https://github.com/fasterthanlime", "followers_url": "https://api.github.com/users/fasterthanlime/followers", "following_url": "https://api.github.com/users/fasterthanlime/following{/other_user}", "gists_url": "https://api.github.com/users/fasterthanlime/gists{/gist_id}", "starred_url": "https://api.github.com/users/fasterthanlime/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fasterthanlime/subscriptions", "organizations_url": "https://api.github.com/users/fasterthanlime/orgs", "repos_url": "https://api.github.com/users/fasterthanlime/repos", "events_url": "https://api.github.com/users/fasterthanlime/events{/privacy}", "received_events_url": "https://api.github.com/users/fasterthanlime/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fasterthanlime", "id": 7998310, "node_id": "MDQ6VXNlcjc5OTgzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/7998310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fasterthanlime", "html_url": "https://github.com/fasterthanlime", "followers_url": "https://api.github.com/users/fasterthanlime/followers", "following_url": "https://api.github.com/users/fasterthanlime/following{/other_user}", "gists_url": "https://api.github.com/users/fasterthanlime/gists{/gist_id}", "starred_url": "https://api.github.com/users/fasterthanlime/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fasterthanlime/subscriptions", "organizations_url": "https://api.github.com/users/fasterthanlime/orgs", "repos_url": "https://api.github.com/users/fasterthanlime/repos", "events_url": "https://api.github.com/users/fasterthanlime/events{/privacy}", "received_events_url": "https://api.github.com/users/fasterthanlime/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8514f3fe7e957670570cbadb16b96d53b4c368f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8514f3fe7e957670570cbadb16b96d53b4c368f7", "html_url": "https://github.com/rust-lang/rust/commit/8514f3fe7e957670570cbadb16b96d53b4c368f7"}, {"sha": "79923c382a0f206d78f601eb42dd89c03c4dad4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/79923c382a0f206d78f601eb42dd89c03c4dad4e", "html_url": "https://github.com/rust-lang/rust/commit/79923c382a0f206d78f601eb42dd89c03c4dad4e"}], "stats": {"total": 1638, "additions": 1216, "deletions": 422}, "files": [{"sha": "c2e21933c9a6811bcd47a61e2378c88e79a37fb3", "filename": ".github/ISSUE_TEMPLATE/bug_report.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/.github%2FISSUE_TEMPLATE%2Fbug_report.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/.github%2FISSUE_TEMPLATE%2Fbug_report.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fbug_report.md?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -13,8 +13,7 @@ Forum for questions: https://users.rust-lang.org/c/ide/14\n \n Before submitting, please make sure that you're not running into one of these known issues:\n \n- 1. extension doesn't load in VSCodium: #11080\n- 2. on-the-fly diagnostics are mostly unimplemented (`cargo check` diagnostics will be shown when saving a file): #3107\n+ 1. on-the-fly diagnostics are mostly unimplemented (`cargo check` diagnostics will be shown when saving a file): #3107\n \n Otherwise please try to provide information which will help us to fix the issue faster. Minimal reproducible examples with few dependencies are especially lovely <3.\n -->"}, {"sha": "ad220ff65ca14997564c2d3186beb826fd1482b3", "filename": ".github/ISSUE_TEMPLATE/critical_nightly_regression.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/.github%2FISSUE_TEMPLATE%2Fcritical_nightly_regression.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/.github%2FISSUE_TEMPLATE%2Fcritical_nightly_regression.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fcritical_nightly_regression.md?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -2,8 +2,8 @@\n name: Critical Nightly Regression\n about: You are using nightly rust-analyzer and the latest version is unusable.\n title: ''\n-labels: ''\n-assignees: 'matklad'\n+labels: 'Broken Window'\n+assignees: ''\n \n ---\n \n@@ -14,4 +14,3 @@ Please try to provide information which will help us to fix the issue faster. Mi\n -->\n \n This is a serious regression in nightly and it's important to fix it before the next release.\n-@matklad, please take a look."}, {"sha": "b070dd3406f203877c2528f4e6a8805cb344737b", "filename": ".github/workflows/release.yaml", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/.github%2Fworkflows%2Frelease.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/.github%2Fworkflows%2Frelease.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Frelease.yaml?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -257,8 +257,7 @@ jobs:\n       - name: Publish Extension (OpenVSX, release)\n         if: github.ref == 'refs/heads/release' && (github.repository == 'rust-analyzer/rust-analyzer' || github.repository == 'rust-lang/rust-analyzer')\n         working-directory: ./editors/code\n-        # token from https://dev.azure.com/rust-analyzer/\n-        run: npx ovsx publish --pat ${{ secrets.OPENVSX_TOKEN }} --packagePath ../../dist/rust-analyzer-*.vsix || true\n+        run: npx ovsx publish --pat ${{ secrets.OPENVSX_TOKEN }} --packagePath ../../dist/rust-analyzer-*.vsix\n         timeout-minutes: 2\n \n       - name: Publish Extension (Code Marketplace, nightly)\n@@ -269,5 +268,5 @@ jobs:\n       - name: Publish Extension (OpenVSX, nightly)\n         if: github.ref != 'refs/heads/release' && (github.repository == 'rust-analyzer/rust-analyzer' || github.repository == 'rust-lang/rust-analyzer')\n         working-directory: ./editors/code\n-        run: npx ovsx publish --pat ${{ secrets.OPENVSX_TOKEN }} --packagePath ../../dist/rust-analyzer-*.vsix || true\n+        run: npx ovsx publish --pat ${{ secrets.OPENVSX_TOKEN }} --packagePath ../../dist/rust-analyzer-*.vsix\n         timeout-minutes: 2"}, {"sha": "933970d10e47282924e6496cbac5a33a2d17d76d", "filename": "crates/hir-def/src/pretty.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fhir-def%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fhir-def%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpretty.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -143,9 +143,12 @@ pub(crate) fn print_type_ref(type_ref: &TypeRef, buf: &mut dyn Write) -> fmt::Re\n             print_type_ref(elem, buf)?;\n             write!(buf, \"]\")?;\n         }\n-        TypeRef::Fn(args_and_ret, varargs) => {\n+        TypeRef::Fn(args_and_ret, varargs, is_unsafe) => {\n             let ((_, return_type), args) =\n                 args_and_ret.split_last().expect(\"TypeRef::Fn is missing return type\");\n+            if *is_unsafe {\n+                write!(buf, \"unsafe \")?;\n+            }\n             write!(buf, \"fn(\")?;\n             for (i, (_, typeref)) in args.iter().enumerate() {\n                 if i != 0 {"}, {"sha": "f8bb78ddcfe02d26b790869308108f7454e6509a", "filename": "crates/hir-def/src/type_ref.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Ftype_ref.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -119,7 +119,7 @@ pub enum TypeRef {\n     Array(Box<TypeRef>, ConstScalarOrPath),\n     Slice(Box<TypeRef>),\n     /// A fn pointer. Last element of the vector is the return type.\n-    Fn(Vec<(Option<Name>, TypeRef)>, bool /*varargs*/),\n+    Fn(Vec<(Option<Name>, TypeRef)>, bool /*varargs*/, bool /*is_unsafe*/),\n     ImplTrait(Vec<Interned<TypeBound>>),\n     DynTrait(Vec<Interned<TypeBound>>),\n     Macro(AstId<ast::MacroCall>),\n@@ -229,7 +229,7 @@ impl TypeRef {\n                     Vec::new()\n                 };\n                 params.push((None, ret_ty));\n-                TypeRef::Fn(params, is_varargs)\n+                TypeRef::Fn(params, is_varargs, inner.unsafe_token().is_some())\n             }\n             // for types are close enough for our purposes to the inner type for now...\n             ast::Type::ForType(inner) => TypeRef::from_ast_opt(ctx, inner.ty()),\n@@ -263,7 +263,7 @@ impl TypeRef {\n         fn go(type_ref: &TypeRef, f: &mut impl FnMut(&TypeRef)) {\n             f(type_ref);\n             match type_ref {\n-                TypeRef::Fn(params, _) => {\n+                TypeRef::Fn(params, _, _) => {\n                     params.iter().for_each(|(_, param_type)| go(param_type, f))\n                 }\n                 TypeRef::Tuple(types) => types.iter().for_each(|t| go(t, f)),"}, {"sha": "a22a4b170f61c749e68e929368ebb6233060ffd1", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -1187,8 +1187,11 @@ impl HirDisplay for TypeRef {\n                 inner.hir_fmt(f)?;\n                 write!(f, \"]\")?;\n             }\n-            TypeRef::Fn(parameters, is_varargs) => {\n+            &TypeRef::Fn(ref parameters, is_varargs, is_unsafe) => {\n                 // FIXME: Function pointer qualifiers.\n+                if is_unsafe {\n+                    write!(f, \"unsafe \")?;\n+                }\n                 write!(f, \"fn(\")?;\n                 if let Some(((_, return_type), function_parameters)) = parameters.split_last() {\n                     for index in 0..function_parameters.len() {\n@@ -1203,7 +1206,7 @@ impl HirDisplay for TypeRef {\n                             write!(f, \", \")?;\n                         }\n                     }\n-                    if *is_varargs {\n+                    if is_varargs {\n                         write!(f, \"{}...\", if parameters.len() == 1 { \"\" } else { \", \" })?;\n                     }\n                     write!(f, \")\")?;"}, {"sha": "0b3c23f5747adc303cf7b66edf8f5ba3a0c636b0", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -1020,7 +1020,7 @@ impl Expectation {\n     /// The primary use case is where the expected type is a fat pointer,\n     /// like `&[isize]`. For example, consider the following statement:\n     ///\n-    ///    let x: &[isize] = &[1, 2, 3];\n+    ///     let x: &[isize] = &[1, 2, 3];\n     ///\n     /// In this case, the expected type for the `&[1, 2, 3]` expression is\n     /// `&[isize]`. If however we were to say that `[1, 2, 3]` has the"}, {"sha": "b1f4de826077542ad5b54ceaa1d52fb16b99d992", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -85,6 +85,7 @@ impl<'a> InferenceContext<'a> {\n         let ty = match &self.body[tgt_expr] {\n             Expr::Missing => self.err_ty(),\n             &Expr::If { condition, then_branch, else_branch } => {\n+                let expected = &expected.adjust_for_branches(&mut self.table);\n                 self.infer_expr(\n                     condition,\n                     &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(Interner)),"}, {"sha": "b68c764bdca09fa1637bf3c8a9cb37ea1742ee03", "filename": "crates/hir-ty/src/lib.rs", "status": "modified", "additions": 83, "deletions": 5, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flib.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -38,10 +38,12 @@ use std::sync::Arc;\n use chalk_ir::{\n     fold::{Shift, TypeFoldable},\n     interner::HasInterner,\n-    NoSolution,\n+    NoSolution, UniverseIndex,\n };\n use hir_def::{expr::ExprId, type_ref::Rawness, TypeOrConstParamId};\n+use hir_expand::name;\n use itertools::Either;\n+use traits::FnTrait;\n use utils::Generics;\n \n use crate::{consteval::unknown_const, db::HirDatabase, utils::generics};\n@@ -208,6 +210,7 @@ pub(crate) fn make_binders<T: HasInterner<Interner = Interner>>(\n pub struct CallableSig {\n     params_and_return: Arc<[Ty]>,\n     is_varargs: bool,\n+    safety: Safety,\n }\n \n has_interner!(CallableSig);\n@@ -216,9 +219,14 @@ has_interner!(CallableSig);\n pub type PolyFnSig = Binders<CallableSig>;\n \n impl CallableSig {\n-    pub fn from_params_and_return(mut params: Vec<Ty>, ret: Ty, is_varargs: bool) -> CallableSig {\n+    pub fn from_params_and_return(\n+        mut params: Vec<Ty>,\n+        ret: Ty,\n+        is_varargs: bool,\n+        safety: Safety,\n+    ) -> CallableSig {\n         params.push(ret);\n-        CallableSig { params_and_return: params.into(), is_varargs }\n+        CallableSig { params_and_return: params.into(), is_varargs, safety }\n     }\n \n     pub fn from_fn_ptr(fn_ptr: &FnPointer) -> CallableSig {\n@@ -235,13 +243,14 @@ impl CallableSig {\n                 .map(|arg| arg.assert_ty_ref(Interner).clone())\n                 .collect(),\n             is_varargs: fn_ptr.sig.variadic,\n+            safety: fn_ptr.sig.safety,\n         }\n     }\n \n     pub fn to_fn_ptr(&self) -> FnPointer {\n         FnPointer {\n             num_binders: 0,\n-            sig: FnSig { abi: (), safety: Safety::Safe, variadic: self.is_varargs },\n+            sig: FnSig { abi: (), safety: self.safety, variadic: self.is_varargs },\n             substitution: FnSubst(Substitution::from_iter(\n                 Interner,\n                 self.params_and_return.iter().cloned(),\n@@ -266,7 +275,11 @@ impl TypeFoldable<Interner> for CallableSig {\n     ) -> Result<Self, E> {\n         let vec = self.params_and_return.to_vec();\n         let folded = vec.try_fold_with(folder, outer_binder)?;\n-        Ok(CallableSig { params_and_return: folded.into(), is_varargs: self.is_varargs })\n+        Ok(CallableSig {\n+            params_and_return: folded.into(),\n+            is_varargs: self.is_varargs,\n+            safety: self.safety,\n+        })\n     }\n }\n \n@@ -508,3 +521,68 @@ where\n     });\n     Canonical { value, binders: chalk_ir::CanonicalVarKinds::from_iter(Interner, kinds) }\n }\n+\n+pub fn callable_sig_from_fnonce(\n+    self_ty: &Canonical<Ty>,\n+    env: Arc<TraitEnvironment>,\n+    db: &dyn HirDatabase,\n+) -> Option<CallableSig> {\n+    let krate = env.krate;\n+    let fn_once_trait = FnTrait::FnOnce.get_id(db, krate)?;\n+    let output_assoc_type = db.trait_data(fn_once_trait).associated_type_by_name(&name![Output])?;\n+\n+    let mut kinds = self_ty.binders.interned().to_vec();\n+    let b = TyBuilder::trait_ref(db, fn_once_trait);\n+    if b.remaining() != 2 {\n+        return None;\n+    }\n+    let fn_once = b\n+        .push(self_ty.value.clone())\n+        .fill_with_bound_vars(DebruijnIndex::INNERMOST, kinds.len())\n+        .build();\n+    kinds.extend(fn_once.substitution.iter(Interner).skip(1).map(|x| {\n+        let vk = match x.data(Interner) {\n+            chalk_ir::GenericArgData::Ty(_) => {\n+                chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General)\n+            }\n+            chalk_ir::GenericArgData::Lifetime(_) => chalk_ir::VariableKind::Lifetime,\n+            chalk_ir::GenericArgData::Const(c) => {\n+                chalk_ir::VariableKind::Const(c.data(Interner).ty.clone())\n+            }\n+        };\n+        chalk_ir::WithKind::new(vk, UniverseIndex::ROOT)\n+    }));\n+\n+    // FIXME: chalk refuses to solve `<Self as FnOnce<^0.0>>::Output == ^0.1`, so we first solve\n+    // `<Self as FnOnce<^0.0>>` and then replace `^0.0` with the concrete argument tuple.\n+    let trait_env = env.env.clone();\n+    let obligation = InEnvironment { goal: fn_once.cast(Interner), environment: trait_env };\n+    let canonical =\n+        Canonical { binders: CanonicalVarKinds::from_iter(Interner, kinds), value: obligation };\n+    let subst = match db.trait_solve(krate, canonical) {\n+        Some(Solution::Unique(vars)) => vars.value.subst,\n+        _ => return None,\n+    };\n+    let args = subst.at(Interner, self_ty.binders.interned().len()).ty(Interner)?;\n+    let params = match args.kind(Interner) {\n+        chalk_ir::TyKind::Tuple(_, subst) => {\n+            subst.iter(Interner).filter_map(|arg| arg.ty(Interner).cloned()).collect::<Vec<_>>()\n+        }\n+        _ => return None,\n+    };\n+    if params.iter().any(|ty| ty.is_unknown()) {\n+        return None;\n+    }\n+\n+    let fn_once = TyBuilder::trait_ref(db, fn_once_trait)\n+        .push(self_ty.value.clone())\n+        .push(args.clone())\n+        .build();\n+    let projection =\n+        TyBuilder::assoc_type_projection(db, output_assoc_type, Some(fn_once.substitution.clone()))\n+            .build();\n+\n+    let ret_ty = db.normalize_projection(projection, env);\n+\n+    Some(CallableSig::from_params_and_return(params, ret_ty.clone(), false, Safety::Safe))\n+}"}, {"sha": "baf9842d5fbf262101c6171f215456f48e31895e", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -227,13 +227,17 @@ impl<'a> TyLoweringContext<'a> {\n                     .intern(Interner)\n             }\n             TypeRef::Placeholder => TyKind::Error.intern(Interner),\n-            TypeRef::Fn(params, is_varargs) => {\n+            &TypeRef::Fn(ref params, variadic, is_unsafe) => {\n                 let substs = self.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n                     Substitution::from_iter(Interner, params.iter().map(|(_, tr)| ctx.lower_ty(tr)))\n                 });\n                 TyKind::Function(FnPointer {\n                     num_binders: 0, // FIXME lower `for<'a> fn()` correctly\n-                    sig: FnSig { abi: (), safety: Safety::Safe, variadic: *is_varargs },\n+                    sig: FnSig {\n+                        abi: (),\n+                        safety: if is_unsafe { Safety::Unsafe } else { Safety::Safe },\n+                        variadic,\n+                    },\n                     substitution: FnSubst(substs),\n                 })\n                 .intern(Interner)\n@@ -1573,7 +1577,12 @@ fn fn_sig_for_fn(db: &dyn HirDatabase, def: FunctionId) -> PolyFnSig {\n         .with_type_param_mode(ParamLoweringMode::Variable);\n     let ret = ctx_ret.lower_ty(&data.ret_type);\n     let generics = generics(db.upcast(), def.into());\n-    let sig = CallableSig::from_params_and_return(params, ret, data.is_varargs());\n+    let sig = CallableSig::from_params_and_return(\n+        params,\n+        ret,\n+        data.is_varargs(),\n+        if data.has_unsafe_kw() { Safety::Unsafe } else { Safety::Safe },\n+    );\n     make_binders(db, &generics, sig)\n }\n \n@@ -1617,7 +1626,7 @@ fn fn_sig_for_struct_constructor(db: &dyn HirDatabase, def: StructId) -> PolyFnS\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(ParamLoweringMode::Variable);\n     let params = fields.iter().map(|(_, field)| ctx.lower_ty(&field.type_ref)).collect::<Vec<_>>();\n     let (ret, binders) = type_for_adt(db, def.into()).into_value_and_skipped_binders();\n-    Binders::new(binders, CallableSig::from_params_and_return(params, ret, false))\n+    Binders::new(binders, CallableSig::from_params_and_return(params, ret, false, Safety::Safe))\n }\n \n /// Build the type of a tuple struct constructor.\n@@ -1644,7 +1653,7 @@ fn fn_sig_for_enum_variant_constructor(db: &dyn HirDatabase, def: EnumVariantId)\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(ParamLoweringMode::Variable);\n     let params = fields.iter().map(|(_, field)| ctx.lower_ty(&field.type_ref)).collect::<Vec<_>>();\n     let (ret, binders) = type_for_adt(db, def.parent.into()).into_value_and_skipped_binders();\n-    Binders::new(binders, CallableSig::from_params_and_return(params, ret, false))\n+    Binders::new(binders, CallableSig::from_params_and_return(params, ret, false, Safety::Safe))\n }\n \n /// Build the type of a tuple enum variant constructor."}, {"sha": "7e3aecc2ae0ae4688d687440390d81b29fc0356d", "filename": "crates/hir-ty/src/tests/coercion.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -122,6 +122,23 @@ fn test() {\n     )\n }\n \n+#[test]\n+fn if_else_adjust_for_branches_discard_type_var() {\n+    check_no_mismatches(\n+        r#\"\n+fn test() {\n+    let f = || {\n+        if true {\n+            &\"\"\n+        } else {\n+            \"\"\n+        }\n+    };\n+}\n+\"#,\n+    );\n+}\n+\n #[test]\n fn match_first_coerce() {\n     check_no_mismatches(\n@@ -182,6 +199,22 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn match_adjust_for_branches_discard_type_var() {\n+    check_no_mismatches(\n+        r#\"\n+fn test() {\n+    let f = || {\n+        match 0i32 {\n+            0i32 => &\"\",\n+            _ => \"\",\n+        }\n+    };\n+}\n+\"#,\n+    );\n+}\n+\n #[test]\n fn return_coerce_unknown() {\n     check_types(\n@@ -357,7 +390,7 @@ fn test() {\n     let f: fn(u32) -> isize = foo;\n                            // ^^^ adjustments: Pointer(ReifyFnPointer)\n     let f: unsafe fn(u32) -> isize = foo;\n-                                  // ^^^ adjustments: Pointer(ReifyFnPointer)\n+                                  // ^^^ adjustments: Pointer(ReifyFnPointer), Pointer(UnsafeFnPointer)\n }\",\n     );\n }\n@@ -388,7 +421,10 @@ fn coerce_closure_to_fn_ptr() {\n     check_no_mismatches(\n         r\"\n fn test() {\n-    let f: fn(u32) -> isize = |x| { 1 };\n+    let f: fn(u32) -> u32 = |x| x;\n+                         // ^^^^^ adjustments: Pointer(ClosureFnPointer(Safe))\n+    let f: unsafe fn(u32) -> u32 = |x| x;\n+                                // ^^^^^ adjustments: Pointer(ClosureFnPointer(Unsafe))\n }\",\n     );\n }"}, {"sha": "cbd9bf32a548655bcb81d5c469a6f4c794328de7", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -2995,7 +2995,17 @@ impl Type {\n         let callee = match self.ty.kind(Interner) {\n             TyKind::Closure(id, _) => Callee::Closure(*id),\n             TyKind::Function(_) => Callee::FnPtr,\n-            _ => Callee::Def(self.ty.callable_def(db)?),\n+            TyKind::FnDef(..) => Callee::Def(self.ty.callable_def(db)?),\n+            _ => {\n+                let ty = hir_ty::replace_errors_with_variables(&self.ty);\n+                let sig = hir_ty::callable_sig_from_fnonce(&ty, self.env.clone(), db)?;\n+                return Some(Callable {\n+                    ty: self.clone(),\n+                    sig,\n+                    callee: Callee::Other,\n+                    is_bound_method: false,\n+                });\n+            }\n         };\n \n         let sig = self.ty.callable_sig(db)?;\n@@ -3464,6 +3474,7 @@ enum Callee {\n     Def(CallableDefId),\n     Closure(ClosureId),\n     FnPtr,\n+    Other,\n }\n \n pub enum CallableKind {\n@@ -3472,6 +3483,8 @@ pub enum CallableKind {\n     TupleEnumVariant(Variant),\n     Closure,\n     FnPtr,\n+    /// Some other type that implements `FnOnce`.\n+    Other,\n }\n \n impl Callable {\n@@ -3483,6 +3496,7 @@ impl Callable {\n             Def(CallableDefId::EnumVariantId(it)) => CallableKind::TupleEnumVariant(it.into()),\n             Closure(_) => CallableKind::Closure,\n             FnPtr => CallableKind::FnPtr,\n+            Other => CallableKind::Other,\n         }\n     }\n     pub fn receiver_param(&self, db: &dyn HirDatabase) -> Option<ast::SelfParam> {"}, {"sha": "b273ebc85a50687c8afc65097e8f182a40c935a4", "filename": "crates/ide-assists/src/assist_config.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fassist_config.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fassist_config.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fassist_config.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -14,4 +14,5 @@ pub struct AssistConfig {\n     pub allowed: Option<Vec<AssistKind>>,\n     pub insert_use: InsertUseConfig,\n     pub prefer_no_std: bool,\n+    pub assist_emit_must_use: bool,\n }"}, {"sha": "b5f99726fe1c8a815a5656e07e7dc73b57366b71", "filename": "crates/ide-assists/src/handlers/add_explicit_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -69,14 +69,14 @@ pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext<'_>) -> O\n     let inferred_type = ty.display_source_code(ctx.db(), module.into()).ok()?;\n     acc.add(\n         AssistId(\"add_explicit_type\", AssistKind::RefactorRewrite),\n-        format!(\"Insert explicit type `{}`\", inferred_type),\n+        format!(\"Insert explicit type `{inferred_type}`\"),\n         pat_range,\n         |builder| match ascribed_ty {\n             Some(ascribed_ty) => {\n                 builder.replace(ascribed_ty.syntax().text_range(), inferred_type);\n             }\n             None => {\n-                builder.insert(pat_range.end(), format!(\": {}\", inferred_type));\n+                builder.insert(pat_range.end(), format!(\": {inferred_type}\"));\n             }\n         },\n     )"}, {"sha": "89040a8569e63cb200ae5986c59e903e5693313c", "filename": "crates/ide-assists/src/handlers/add_return_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_return_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_return_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_return_type.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -35,16 +35,16 @@ pub(crate) fn add_return_type(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opt\n             match builder_edit_pos {\n                 InsertOrReplace::Insert(insert_pos, needs_whitespace) => {\n                     let preceeding_whitespace = if needs_whitespace { \" \" } else { \"\" };\n-                    builder.insert(insert_pos, &format!(\"{}-> {} \", preceeding_whitespace, ty))\n+                    builder.insert(insert_pos, &format!(\"{preceeding_whitespace}-> {ty} \"))\n                 }\n                 InsertOrReplace::Replace(text_range) => {\n-                    builder.replace(text_range, &format!(\"-> {}\", ty))\n+                    builder.replace(text_range, &format!(\"-> {ty}\"))\n                 }\n             }\n             if let FnType::Closure { wrap_expr: true } = fn_type {\n                 cov_mark::hit!(wrap_closure_non_block_expr);\n                 // `|x| x` becomes `|x| -> T x` which is invalid, so wrap it in a block\n-                builder.replace(tail_expr.syntax().text_range(), &format!(\"{{{}}}\", tail_expr));\n+                builder.replace(tail_expr.syntax().text_range(), &format!(\"{{{tail_expr}}}\"));\n             }\n         },\n     )"}, {"sha": "acf82e4b257943df6e974a934beb6f6f3d454feb", "filename": "crates/ide-assists/src/handlers/add_turbo_fish.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -93,12 +93,13 @@ pub(crate) fn add_turbo_fish(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opti\n             builder.trigger_signature_help();\n             match ctx.config.snippet_cap {\n                 Some(cap) => {\n-                    let snip = format!(\"::<{}>\", get_snippet_fish_head(number_of_arguments));\n+                    let fish_head = get_snippet_fish_head(number_of_arguments);\n+                    let snip = format!(\"::<{fish_head}>\");\n                     builder.insert_snippet(cap, ident.text_range().end(), snip)\n                 }\n                 None => {\n                     let fish_head = std::iter::repeat(\"_\").take(number_of_arguments).format(\", \");\n-                    let snip = format!(\"::<{}>\", fish_head);\n+                    let snip = format!(\"::<{fish_head}>\");\n                     builder.insert(ident.text_range().end(), snip);\n                 }\n             }\n@@ -109,7 +110,7 @@ pub(crate) fn add_turbo_fish(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opti\n /// This will create a snippet string with tabstops marked\n fn get_snippet_fish_head(number_of_arguments: usize) -> String {\n     let mut fish_head = (1..number_of_arguments)\n-        .format_with(\"\", |i, f| f(&format_args!(\"${{{}:_}}, \", i)))\n+        .format_with(\"\", |i, f| f(&format_args!(\"${{{i}:_}}, \")))\n         .to_string();\n \n     // tabstop 0 is a special case and always the last one"}, {"sha": "57cfa17cc8e13ae7fe39b15347416f3d045bf553", "filename": "crates/ide-assists/src/handlers/apply_demorgan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -123,20 +123,20 @@ pub(crate) fn apply_demorgan(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opti\n                     let lhs_range = lhs.syntax().text_range();\n                     let not_lhs = invert_boolean_expression(lhs);\n \n-                    edit.replace(lhs_range, format!(\"!({}\", not_lhs.syntax().text()));\n+                    edit.replace(lhs_range, format!(\"!({not_lhs}\"));\n                 }\n \n                 if let Some(rhs) = terms.pop_back() {\n                     let rhs_range = rhs.syntax().text_range();\n                     let not_rhs = invert_boolean_expression(rhs);\n \n-                    edit.replace(rhs_range, format!(\"{})\", not_rhs.syntax().text()));\n+                    edit.replace(rhs_range, format!(\"{not_rhs})\"));\n                 }\n \n                 for term in terms {\n                     let term_range = term.syntax().text_range();\n                     let not_term = invert_boolean_expression(term);\n-                    edit.replace(term_range, not_term.syntax().text());\n+                    edit.replace(term_range, not_term.to_string());\n                 }\n             }\n         },"}, {"sha": "a689270bc0915b13a62253c92fbe62623618ab42", "filename": "crates/ide-assists/src/handlers/auto_import.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -127,18 +127,20 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<\n         .sort_by_key(|import| Reverse(relevance_score(ctx, import, current_module.as_ref())));\n \n     for import in proposed_imports {\n+        let import_path = import.import_path;\n+\n         acc.add_group(\n             &group_label,\n             AssistId(\"auto_import\", AssistKind::QuickFix),\n-            format!(\"Import `{}`\", import.import_path),\n+            format!(\"Import `{import_path}`\"),\n             range,\n             |builder| {\n                 let scope = match scope.clone() {\n                     ImportScope::File(it) => ImportScope::File(builder.make_mut(it)),\n                     ImportScope::Module(it) => ImportScope::Module(builder.make_mut(it)),\n                     ImportScope::Block(it) => ImportScope::Block(builder.make_mut(it)),\n                 };\n-                insert_use(&scope, mod_path_to_ast(&import.import_path), &ctx.config.insert_use);\n+                insert_use(&scope, mod_path_to_ast(&import_path), &ctx.config.insert_use);\n             },\n         );\n     }"}, {"sha": "312cb65abd2a1ce5d7699db05308bbb912c92981", "filename": "crates/ide-assists/src/handlers/convert_comment_block.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_comment_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_comment_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_comment_block.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -54,16 +54,17 @@ fn block_to_line(acc: &mut Assists, comment: ast::Comment) -> Option<()> {\n \n             let indent_spaces = indentation.to_string();\n             let output = lines\n-                .map(|l| l.trim_start_matches(&indent_spaces))\n-                .map(|l| {\n+                .map(|line| {\n+                    let line = line.trim_start_matches(&indent_spaces);\n+\n                     // Don't introduce trailing whitespace\n-                    if l.is_empty() {\n+                    if line.is_empty() {\n                         line_prefix.to_string()\n                     } else {\n-                        format!(\"{} {}\", line_prefix, l.trim_start_matches(&indent_spaces))\n+                        format!(\"{line_prefix} {line}\")\n                     }\n                 })\n-                .join(&format!(\"\\n{}\", indent_spaces));\n+                .join(&format!(\"\\n{indent_spaces}\"));\n \n             edit.replace(target, output)\n         },\n@@ -96,7 +97,7 @@ fn line_to_block(acc: &mut Assists, comment: ast::Comment) -> Option<()> {\n             let block_prefix =\n                 CommentKind { shape: CommentShape::Block, ..comment.kind() }.prefix();\n \n-            let output = format!(\"{}\\n{}\\n{}*/\", block_prefix, block_comment_body, indentation);\n+            let output = format!(\"{block_prefix}\\n{block_comment_body}\\n{indentation}*/\");\n \n             edit.replace(target, output)\n         },"}, {"sha": "ff2195f7e6c4a2ebf6829889b3336eb52570c779", "filename": "crates/ide-assists/src/handlers/convert_integer_literal.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_integer_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_integer_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_integer_literal.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -32,19 +32,19 @@ pub(crate) fn convert_integer_literal(acc: &mut Assists, ctx: &AssistContext<'_>\n         }\n \n         let mut converted = match target_radix {\n-            Radix::Binary => format!(\"0b{:b}\", value),\n-            Radix::Octal => format!(\"0o{:o}\", value),\n+            Radix::Binary => format!(\"0b{value:b}\"),\n+            Radix::Octal => format!(\"0o{value:o}\"),\n             Radix::Decimal => value.to_string(),\n-            Radix::Hexadecimal => format!(\"0x{:X}\", value),\n+            Radix::Hexadecimal => format!(\"0x{value:X}\"),\n         };\n \n-        let label = format!(\"Convert {} to {}{}\", literal, converted, suffix.unwrap_or_default());\n-\n         // Appends the type suffix back into the new literal if it exists.\n         if let Some(suffix) = suffix {\n             converted.push_str(suffix);\n         }\n \n+        let label = format!(\"Convert {literal} to {converted}\");\n+\n         acc.add_group(\n             &group_id,\n             AssistId(\"convert_integer_literal\", AssistKind::RefactorInline),"}, {"sha": "872b52c98fff2fbf5a3e56d1c27165eb2bdb61f9", "filename": "crates/ide-assists/src/handlers/convert_into_to_from.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_into_to_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_into_to_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_into_to_from.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -86,9 +86,9 @@ pub(crate) fn convert_into_to_from(acc: &mut Assists, ctx: &AssistContext<'_>) -\n         impl_.syntax().text_range(),\n         |builder| {\n             builder.replace(src_type.syntax().text_range(), dest_type.to_string());\n-            builder.replace(ast_trait.syntax().text_range(), format!(\"From<{}>\", src_type));\n+            builder.replace(ast_trait.syntax().text_range(), format!(\"From<{src_type}>\"));\n             builder.replace(into_fn_return.syntax().text_range(), \"-> Self\");\n-            builder.replace(into_fn_params.syntax().text_range(), format!(\"(val: {})\", src_type));\n+            builder.replace(into_fn_params.syntax().text_range(), format!(\"(val: {src_type})\"));\n             builder.replace(into_fn_name.syntax().text_range(), \"from\");\n \n             for s in selfs {"}, {"sha": "80eecf4a09868980f94d68b7ed8854674bcd2eee", "filename": "crates/ide-assists/src/handlers/convert_iter_for_each_to_for.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -119,19 +119,19 @@ pub(crate) fn convert_for_loop_with_for_each(\n             {\n                 // We have either \"for x in &col\" and col implements a method called iter\n                 //             or \"for x in &mut col\" and col implements a method called iter_mut\n-                format_to!(buf, \"{}.{}()\", expr_behind_ref, method);\n+                format_to!(buf, \"{expr_behind_ref}.{method}()\");\n             } else if let ast::Expr::RangeExpr(..) = iterable {\n                 // range expressions need to be parenthesized for the syntax to be correct\n-                format_to!(buf, \"({})\", iterable);\n+                format_to!(buf, \"({iterable})\");\n             } else if impls_core_iter(&ctx.sema, &iterable) {\n-                format_to!(buf, \"{}\", iterable);\n+                format_to!(buf, \"{iterable}\");\n             } else if let ast::Expr::RefExpr(_) = iterable {\n-                format_to!(buf, \"({}).into_iter()\", iterable);\n+                format_to!(buf, \"({iterable}).into_iter()\");\n             } else {\n-                format_to!(buf, \"{}.into_iter()\", iterable);\n+                format_to!(buf, \"{iterable}.into_iter()\");\n             }\n \n-            format_to!(buf, \".for_each(|{}| {});\", pat, body);\n+            format_to!(buf, \".for_each(|{pat}| {body});\");\n \n             builder.replace(for_loop.syntax().text_range(), buf)\n         },"}, {"sha": "c82a3b53032595217e7f7b69f12557829c644574", "filename": "crates/ide-assists/src/handlers/convert_let_else_to_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_let_else_to_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_let_else_to_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_let_else_to_match.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -80,7 +80,7 @@ fn binders_to_str(binders: &[(Name, bool)], addmut: bool) -> String {\n         .map(\n             |(ident, ismut)| {\n                 if *ismut && addmut {\n-                    format!(\"mut {}\", ident)\n+                    format!(\"mut {ident}\")\n                 } else {\n                     ident.to_string()\n                 }\n@@ -93,7 +93,7 @@ fn binders_to_str(binders: &[(Name, bool)], addmut: bool) -> String {\n     } else if binders.len() == 1 {\n         vars\n     } else {\n-        format!(\"({})\", vars)\n+        format!(\"({vars})\")\n     }\n }\n \n@@ -153,7 +153,7 @@ pub(crate) fn convert_let_else_to_match(acc: &mut Assists, ctx: &AssistContext<'\n \n             let only_expr = let_else_block.statements().next().is_none();\n             let branch2 = match &let_else_block.tail_expr() {\n-                Some(tail) if only_expr => format!(\"{},\", tail.syntax().text()),\n+                Some(tail) if only_expr => format!(\"{tail},\"),\n                 _ => let_else_block.syntax().text().to_string(),\n             };\n             let replace = if binders.is_empty() {"}, {"sha": "5bf04a3ad3719fadf64a91d989b00eff4bac0e2d", "filename": "crates/ide-assists/src/handlers/convert_match_to_let_else.rs", "status": "added", "additions": 413, "deletions": 0, "changes": 413, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -0,0 +1,413 @@\n+use ide_db::defs::{Definition, NameRefClass};\n+use syntax::{\n+    ast::{self, HasName},\n+    ted, AstNode, SyntaxNode,\n+};\n+\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    AssistId, AssistKind,\n+};\n+\n+// Assist: convert_match_to_let_else\n+//\n+// Converts let statement with match initializer to let-else statement.\n+//\n+// ```\n+// # //- minicore: option\n+// fn foo(opt: Option<()>) {\n+//     let val = $0match opt {\n+//         Some(it) => it,\n+//         None => return,\n+//     };\n+// }\n+// ```\n+// ->\n+// ```\n+// fn foo(opt: Option<()>) {\n+//     let Some(val) = opt else { return };\n+// }\n+// ```\n+pub(crate) fn convert_match_to_let_else(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let let_stmt: ast::LetStmt = ctx.find_node_at_offset()?;\n+    let binding = find_binding(let_stmt.pat()?)?;\n+\n+    let initializer = match let_stmt.initializer() {\n+        Some(ast::Expr::MatchExpr(it)) => it,\n+        _ => return None,\n+    };\n+    let initializer_expr = initializer.expr()?;\n+\n+    let (extracting_arm, diverging_arm) = match find_arms(ctx, &initializer) {\n+        Some(it) => it,\n+        None => return None,\n+    };\n+    if extracting_arm.guard().is_some() {\n+        cov_mark::hit!(extracting_arm_has_guard);\n+        return None;\n+    }\n+\n+    let diverging_arm_expr = diverging_arm.expr()?;\n+    let extracting_arm_pat = extracting_arm.pat()?;\n+    let extracted_variable = find_extracted_variable(ctx, &extracting_arm)?;\n+\n+    acc.add(\n+        AssistId(\"convert_match_to_let_else\", AssistKind::RefactorRewrite),\n+        \"Convert match to let-else\",\n+        let_stmt.syntax().text_range(),\n+        |builder| {\n+            let extracting_arm_pat = rename_variable(&extracting_arm_pat, extracted_variable, binding);\n+            builder.replace(\n+                let_stmt.syntax().text_range(),\n+                format!(\"let {extracting_arm_pat} = {initializer_expr} else {{ {diverging_arm_expr} }};\")\n+            )\n+        },\n+    )\n+}\n+\n+// Given a pattern, find the name introduced to the surrounding scope.\n+fn find_binding(pat: ast::Pat) -> Option<ast::IdentPat> {\n+    if let ast::Pat::IdentPat(ident) = pat {\n+        Some(ident)\n+    } else {\n+        None\n+    }\n+}\n+\n+// Given a match expression, find extracting and diverging arms.\n+fn find_arms(\n+    ctx: &AssistContext<'_>,\n+    match_expr: &ast::MatchExpr,\n+) -> Option<(ast::MatchArm, ast::MatchArm)> {\n+    let arms = match_expr.match_arm_list()?.arms().collect::<Vec<_>>();\n+    if arms.len() != 2 {\n+        return None;\n+    }\n+\n+    let mut extracting = None;\n+    let mut diverging = None;\n+    for arm in arms {\n+        if ctx.sema.type_of_expr(&arm.expr().unwrap()).unwrap().original().is_never() {\n+            diverging = Some(arm);\n+        } else {\n+            extracting = Some(arm);\n+        }\n+    }\n+\n+    match (extracting, diverging) {\n+        (Some(extracting), Some(diverging)) => Some((extracting, diverging)),\n+        _ => {\n+            cov_mark::hit!(non_diverging_match);\n+            None\n+        }\n+    }\n+}\n+\n+// Given an extracting arm, find the extracted variable.\n+fn find_extracted_variable(ctx: &AssistContext<'_>, arm: &ast::MatchArm) -> Option<ast::Name> {\n+    match arm.expr()? {\n+        ast::Expr::PathExpr(path) => {\n+            let name_ref = path.syntax().descendants().find_map(ast::NameRef::cast)?;\n+            match NameRefClass::classify(&ctx.sema, &name_ref)? {\n+                NameRefClass::Definition(Definition::Local(local)) => {\n+                    let source = local.source(ctx.db()).value.left()?;\n+                    Some(source.name()?)\n+                }\n+                _ => None,\n+            }\n+        }\n+        _ => {\n+            cov_mark::hit!(extracting_arm_is_not_an_identity_expr);\n+            return None;\n+        }\n+    }\n+}\n+\n+// Rename `extracted` with `binding` in `pat`.\n+fn rename_variable(pat: &ast::Pat, extracted: ast::Name, binding: ast::IdentPat) -> SyntaxNode {\n+    let syntax = pat.syntax().clone_for_update();\n+    let extracted_syntax = syntax.covering_element(extracted.syntax().text_range());\n+\n+    // If `extracted` variable is a record field, we should rename it to `binding`,\n+    // otherwise we just need to replace `extracted` with `binding`.\n+\n+    if let Some(record_pat_field) = extracted_syntax.ancestors().find_map(ast::RecordPatField::cast)\n+    {\n+        if let Some(name_ref) = record_pat_field.field_name() {\n+            ted::replace(\n+                record_pat_field.syntax(),\n+                ast::make::record_pat_field(ast::make::name_ref(&name_ref.text()), binding.into())\n+                    .syntax()\n+                    .clone_for_update(),\n+            );\n+        }\n+    } else {\n+        ted::replace(extracted_syntax, binding.syntax().clone_for_update());\n+    }\n+\n+    syntax\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn should_not_be_applicable_for_non_diverging_match() {\n+        cov_mark::check!(non_diverging_match);\n+        check_assist_not_applicable(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+fn foo(opt: Option<()>) {\n+    let val = $0match opt {\n+        Some(it) => it,\n+        None => (),\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn should_not_be_applicable_if_extracting_arm_is_not_an_identity_expr() {\n+        cov_mark::check_count!(extracting_arm_is_not_an_identity_expr, 2);\n+        check_assist_not_applicable(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+fn foo(opt: Option<i32>) {\n+    let val = $0match opt {\n+        Some(it) => it + 1,\n+        None => return,\n+    };\n+}\n+\"#,\n+        );\n+\n+        check_assist_not_applicable(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+fn foo(opt: Option<()>) {\n+    let val = $0match opt {\n+        Some(it) => {\n+            let _ = 1 + 1;\n+            it\n+        },\n+        None => return,\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn should_not_be_applicable_if_extracting_arm_has_guard() {\n+        cov_mark::check!(extracting_arm_has_guard);\n+        check_assist_not_applicable(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+fn foo(opt: Option<()>) {\n+    let val = $0match opt {\n+        Some(it) if 2 > 1 => it,\n+        None => return,\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn basic_pattern() {\n+        check_assist(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+fn foo(opt: Option<()>) {\n+    let val = $0match opt {\n+        Some(it) => it,\n+        None => return,\n+    };\n+}\n+    \"#,\n+            r#\"\n+fn foo(opt: Option<()>) {\n+    let Some(val) = opt else { return };\n+}\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn keeps_modifiers() {\n+        check_assist(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+fn foo(opt: Option<()>) {\n+    let ref mut val = $0match opt {\n+        Some(it) => it,\n+        None => return,\n+    };\n+}\n+    \"#,\n+            r#\"\n+fn foo(opt: Option<()>) {\n+    let Some(ref mut val) = opt else { return };\n+}\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn nested_pattern() {\n+        check_assist(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option, result\n+fn foo(opt: Option<Result<()>>) {\n+    let val = $0match opt {\n+        Some(Ok(it)) => it,\n+        _ => return,\n+    };\n+}\n+    \"#,\n+            r#\"\n+fn foo(opt: Option<Result<()>>) {\n+    let Some(Ok(val)) = opt else { return };\n+}\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn works_with_any_diverging_block() {\n+        check_assist(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+fn foo(opt: Option<()>) {\n+    loop {\n+        let val = $0match opt {\n+            Some(it) => it,\n+            None => break,\n+        };\n+    }\n+}\n+    \"#,\n+            r#\"\n+fn foo(opt: Option<()>) {\n+    loop {\n+        let Some(val) = opt else { break };\n+    }\n+}\n+    \"#,\n+        );\n+\n+        check_assist(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+fn foo(opt: Option<()>) {\n+    loop {\n+        let val = $0match opt {\n+            Some(it) => it,\n+            None => continue,\n+        };\n+    }\n+}\n+    \"#,\n+            r#\"\n+fn foo(opt: Option<()>) {\n+    loop {\n+        let Some(val) = opt else { continue };\n+    }\n+}\n+    \"#,\n+        );\n+\n+        check_assist(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+fn panic() -> ! {}\n+\n+fn foo(opt: Option<()>) {\n+    loop {\n+        let val = $0match opt {\n+            Some(it) => it,\n+            None => panic(),\n+        };\n+    }\n+}\n+    \"#,\n+            r#\"\n+fn panic() -> ! {}\n+\n+fn foo(opt: Option<()>) {\n+    loop {\n+        let Some(val) = opt else { panic() };\n+    }\n+}\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn struct_pattern() {\n+        check_assist(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn foo(opt: Option<Point>) {\n+    let val = $0match opt {\n+        Some(Point { x: 0, y }) => y,\n+        _ => return,\n+    };\n+}\n+    \"#,\n+            r#\"\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn foo(opt: Option<Point>) {\n+    let Some(Point { x: 0, y: val }) = opt else { return };\n+}\n+    \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn renames_whole_binding() {\n+        check_assist(\n+            convert_match_to_let_else,\n+            r#\"\n+//- minicore: option\n+fn foo(opt: Option<i32>) -> Option<i32> {\n+    let val = $0match opt {\n+        it @ Some(42) => it,\n+        _ => return None,\n+    };\n+    val\n+}\n+    \"#,\n+            r#\"\n+fn foo(opt: Option<i32>) -> Option<i32> {\n+    let val @ Some(42) = opt else { return None };\n+    val\n+}\n+    \"#,\n+        );\n+    }\n+}"}, {"sha": "b97be34c5f7e48324ff86a7c701dad8d6d96de38", "filename": "crates/ide-assists/src/handlers/convert_to_guarded_return.rs", "status": "modified", "additions": 16, "deletions": 54, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_to_guarded_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_to_guarded_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_to_guarded_return.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -129,32 +129,15 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext<'\n                 }\n                 Some((path, bound_ident)) => {\n                     // If-let.\n-                    let match_expr = {\n-                        let happy_arm = {\n-                            let pat = make::tuple_struct_pat(\n-                                path,\n-                                once(make::ext::simple_ident_pat(make::name(\"it\")).into()),\n-                            );\n-                            let expr = {\n-                                let path = make::ext::ident_path(\"it\");\n-                                make::expr_path(path)\n-                            };\n-                            make::match_arm(once(pat.into()), None, expr)\n-                        };\n-\n-                        let sad_arm = make::match_arm(\n-                            // FIXME: would be cool to use `None` or `Err(_)` if appropriate\n-                            once(make::wildcard_pat().into()),\n-                            None,\n-                            early_expression,\n-                        );\n-\n-                        make::expr_match(cond_expr, make::match_arm_list(vec![happy_arm, sad_arm]))\n-                    };\n-\n-                    let let_stmt = make::let_stmt(bound_ident, None, Some(match_expr));\n-                    let let_stmt = let_stmt.indent(if_indent_level);\n-                    let_stmt.syntax().clone_for_update()\n+                    let pat = make::tuple_struct_pat(path, once(bound_ident));\n+                    let let_else_stmt = make::let_else_stmt(\n+                        pat.into(),\n+                        None,\n+                        cond_expr,\n+                        ast::make::tail_only_block_expr(early_expression),\n+                    );\n+                    let let_else_stmt = let_else_stmt.indent(if_indent_level);\n+                    let_else_stmt.syntax().clone_for_update()\n                 }\n             };\n \n@@ -238,10 +221,7 @@ fn main(n: Option<String>) {\n             r#\"\n fn main(n: Option<String>) {\n     bar();\n-    let n = match n {\n-        Some(it) => it,\n-        _ => return,\n-    };\n+    let Some(n) = n else { return };\n     foo(n);\n \n     // comment\n@@ -264,10 +244,7 @@ fn main() {\n \"#,\n             r#\"\n fn main() {\n-    let x = match Err(92) {\n-        Ok(it) => it,\n-        _ => return,\n-    };\n+    let Ok(x) = Err(92) else { return };\n     foo(x);\n }\n \"#,\n@@ -292,10 +269,7 @@ fn main(n: Option<String>) {\n             r#\"\n fn main(n: Option<String>) {\n     bar();\n-    let n = match n {\n-        Some(it) => it,\n-        _ => return,\n-    };\n+    let Some(n) = n else { return };\n     foo(n);\n \n     // comment\n@@ -323,10 +297,7 @@ fn main(n: Option<String>) {\n             r#\"\n fn main(n: Option<String>) {\n     bar();\n-    let mut n = match n {\n-        Some(it) => it,\n-        _ => return,\n-    };\n+    let Some(mut n) = n else { return };\n     foo(n);\n \n     // comment\n@@ -354,10 +325,7 @@ fn main(n: Option<&str>) {\n             r#\"\n fn main(n: Option<&str>) {\n     bar();\n-    let ref n = match n {\n-        Some(it) => it,\n-        _ => return,\n-    };\n+    let Some(ref n) = n else { return };\n     foo(n);\n \n     // comment\n@@ -412,10 +380,7 @@ fn main() {\n             r#\"\n fn main() {\n     while true {\n-        let n = match n {\n-            Some(it) => it,\n-            _ => continue,\n-        };\n+        let Some(n) = n else { continue };\n         foo(n);\n         bar();\n     }\n@@ -469,10 +434,7 @@ fn main() {\n             r#\"\n fn main() {\n     loop {\n-        let n = match n {\n-            Some(it) => it,\n-            _ => continue,\n-        };\n+        let Some(n) = n else { continue };\n         foo(n);\n         bar();\n     }"}, {"sha": "92e091fca126c9ac3bbfe8da5a8de017f326fec8", "filename": "crates/ide-assists/src/handlers/convert_tuple_struct_to_named_struct.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_tuple_struct_to_named_struct.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -226,7 +226,13 @@ fn edit_field_references(\n }\n \n fn generate_names(fields: impl Iterator<Item = ast::TupleField>) -> Vec<ast::Name> {\n-    fields.enumerate().map(|(i, _)| ast::make::name(&format!(\"field{}\", i + 1))).collect()\n+    fields\n+        .enumerate()\n+        .map(|(i, _)| {\n+            let idx = i + 1;\n+            ast::make::name(&format!(\"field{idx}\"))\n+        })\n+        .collect()\n }\n \n #[cfg(test)]"}, {"sha": "b1b0f587cd33d0edc338f93c7cdfcb66d0a7b61c", "filename": "crates/ide-assists/src/handlers/convert_two_arm_bool_match_to_matches_macro.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_two_arm_bool_match_to_matches_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_two_arm_bool_match_to_matches_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_two_arm_bool_match_to_matches_macro.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -58,16 +58,16 @@ pub(crate) fn convert_two_arm_bool_match_to_matches_macro(\n         target_range,\n         |builder| {\n             let mut arm_str = String::new();\n-            if let Some(ref pat) = first_arm.pat() {\n+            if let Some(pat) = &first_arm.pat() {\n                 arm_str += &pat.to_string();\n             }\n-            if let Some(ref guard) = first_arm.guard() {\n-                arm_str += &format!(\" {}\", &guard.to_string());\n+            if let Some(guard) = &first_arm.guard() {\n+                arm_str += &format!(\" {guard}\");\n             }\n             if invert_matches {\n-                builder.replace(target_range, format!(\"!matches!({}, {})\", expr, arm_str));\n+                builder.replace(target_range, format!(\"!matches!({expr}, {arm_str})\"));\n             } else {\n-                builder.replace(target_range, format!(\"matches!({}, {})\", expr, arm_str));\n+                builder.replace(target_range, format!(\"matches!({expr}, {arm_str})\"));\n             }\n         },\n     )"}, {"sha": "31c2ce7c1b54ae93a6e16bbf4d34243b1e07d6f6", "filename": "crates/ide-assists/src/handlers/destructure_tuple_binding.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -133,7 +133,7 @@ fn generate_name(\n     _usages: &Option<UsageSearchResult>,\n ) -> String {\n     // FIXME: detect if name already used\n-    format!(\"_{}\", index)\n+    format!(\"_{index}\")\n }\n \n enum RefType {\n@@ -168,12 +168,12 @@ fn edit_tuple_assignment(\n     let add_cursor = |text: &str| {\n         // place cursor on first tuple item\n         let first_tuple = &data.field_names[0];\n-        text.replacen(first_tuple, &format!(\"$0{}\", first_tuple), 1)\n+        text.replacen(first_tuple, &format!(\"$0{first_tuple}\"), 1)\n     };\n \n     // with sub_pattern: keep original tuple and add subpattern: `tup @ (_0, _1)`\n     if in_sub_pattern {\n-        let text = format!(\" @ {}\", tuple_pat);\n+        let text = format!(\" @ {tuple_pat}\");\n         match ctx.config.snippet_cap {\n             Some(cap) => {\n                 let snip = add_cursor(&text);\n@@ -314,9 +314,9 @@ struct RefData {\n impl RefData {\n     fn format(&self, field_name: &str) -> String {\n         match (self.needs_deref, self.needs_parentheses) {\n-            (true, true) => format!(\"(*{})\", field_name),\n-            (true, false) => format!(\"*{}\", field_name),\n-            (false, true) => format!(\"({})\", field_name),\n+            (true, true) => format!(\"(*{field_name})\"),\n+            (true, false) => format!(\"*{field_name}\"),\n+            (false, true) => format!(\"({field_name})\"),\n             (false, false) => field_name.to_string(),\n         }\n     }"}, {"sha": "0605883584922ee329ff9fcc879561a18b7a7c98", "filename": "crates/ide-assists/src/handlers/extract_function.rs", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -181,7 +181,7 @@ fn make_function_name(semantics_scope: &hir::SemanticsScope<'_>) -> ast::NameRef\n     let mut counter = 0;\n     while names_in_scope.contains(&name) {\n         counter += 1;\n-        name = format!(\"{}{}\", &default_name, counter)\n+        name = format!(\"{default_name}{counter}\")\n     }\n     make::name_ref(&name)\n }\n@@ -1291,19 +1291,23 @@ fn make_call(ctx: &AssistContext<'_>, fun: &Function, indent: IndentLevel) -> St\n     match fun.outliving_locals.as_slice() {\n         [] => {}\n         [var] => {\n-            format_to!(buf, \"let {}{} = \", mut_modifier(var), var.local.name(ctx.db()))\n+            let modifier = mut_modifier(var);\n+            let name = var.local.name(ctx.db());\n+            format_to!(buf, \"let {modifier}{name} = \")\n         }\n         vars => {\n             buf.push_str(\"let (\");\n             let bindings = vars.iter().format_with(\", \", |local, f| {\n-                f(&format_args!(\"{}{}\", mut_modifier(local), local.local.name(ctx.db())))\n+                let modifier = mut_modifier(local);\n+                let name = local.local.name(ctx.db());\n+                f(&format_args!(\"{modifier}{name}\"))\n             });\n-            format_to!(buf, \"{}\", bindings);\n+            format_to!(buf, \"{bindings}\");\n             buf.push_str(\") = \");\n         }\n     }\n \n-    format_to!(buf, \"{}\", expr);\n+    format_to!(buf, \"{expr}\");\n     let insert_comma = fun\n         .body\n         .parent()\n@@ -1447,49 +1451,37 @@ fn format_function(\n     new_indent: IndentLevel,\n ) -> String {\n     let mut fn_def = String::new();\n+\n+    let fun_name = &fun.name;\n     let params = fun.make_param_list(ctx, module);\n     let ret_ty = fun.make_ret_ty(ctx, module);\n     let body = make_body(ctx, old_indent, new_indent, fun);\n     let const_kw = if fun.mods.is_const { \"const \" } else { \"\" };\n     let async_kw = if fun.control_flow.is_async { \"async \" } else { \"\" };\n     let unsafe_kw = if fun.control_flow.is_unsafe { \"unsafe \" } else { \"\" };\n     let (generic_params, where_clause) = make_generic_params_and_where_clause(ctx, fun);\n+\n+    format_to!(fn_def, \"\\n\\n{new_indent}{const_kw}{async_kw}{unsafe_kw}\");\n     match ctx.config.snippet_cap {\n-        Some(_) => format_to!(\n-            fn_def,\n-            \"\\n\\n{}{}{}{}fn $0{}\",\n-            new_indent,\n-            const_kw,\n-            async_kw,\n-            unsafe_kw,\n-            fun.name,\n-        ),\n-        None => format_to!(\n-            fn_def,\n-            \"\\n\\n{}{}{}{}fn {}\",\n-            new_indent,\n-            const_kw,\n-            async_kw,\n-            unsafe_kw,\n-            fun.name,\n-        ),\n+        Some(_) => format_to!(fn_def, \"fn $0{fun_name}\"),\n+        None => format_to!(fn_def, \"fn {fun_name}\"),\n     }\n \n     if let Some(generic_params) = generic_params {\n-        format_to!(fn_def, \"{}\", generic_params);\n+        format_to!(fn_def, \"{generic_params}\");\n     }\n \n-    format_to!(fn_def, \"{}\", params);\n+    format_to!(fn_def, \"{params}\");\n \n     if let Some(ret_ty) = ret_ty {\n-        format_to!(fn_def, \" {}\", ret_ty);\n+        format_to!(fn_def, \" {ret_ty}\");\n     }\n \n     if let Some(where_clause) = where_clause {\n-        format_to!(fn_def, \" {}\", where_clause);\n+        format_to!(fn_def, \" {where_clause}\");\n     }\n \n-    format_to!(fn_def, \" {}\", body);\n+    format_to!(fn_def, \" {body}\");\n \n     fn_def\n }"}, {"sha": "56834394aebaa8fbe7a125dc647280aa58920628", "filename": "crates/ide-assists/src/handlers/extract_module.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -127,7 +127,7 @@ pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opti\n             for item in items_to_be_processed {\n                 let item = item.indent(IndentLevel(1));\n                 let mut indented_item = String::new();\n-                format_to!(indented_item, \"{}{}\", new_item_indent, item.to_string());\n+                format_to!(indented_item, \"{new_item_indent}{item}\");\n                 body_items.push(indented_item);\n             }\n \n@@ -137,30 +137,28 @@ pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opti\n                 let mut impl_body_def = String::new();\n \n                 if let Some(self_ty) = impl_.self_ty() {\n-                    format_to!(\n-                        impl_body_def,\n-                        \"{}impl {} {{\\n{}\\n{}}}\",\n-                        old_item_indent + 1,\n-                        self_ty.to_string(),\n-                        body,\n-                        old_item_indent + 1\n-                    );\n-\n+                    {\n+                        let impl_indent = old_item_indent + 1;\n+                        format_to!(\n+                            impl_body_def,\n+                            \"{impl_indent}impl {self_ty} {{\\n{body}\\n{impl_indent}}}\",\n+                        );\n+                    }\n                     body = impl_body_def;\n \n                     // Add the import for enum/struct corresponding to given impl block\n                     module.make_use_stmt_of_node_with_super(self_ty.syntax());\n                     for item in module.use_items {\n-                        let mut indented_item = String::new();\n-                        format_to!(indented_item, \"{}{}\", old_item_indent + 1, item.to_string());\n-                        body = format!(\"{}\\n\\n{}\", indented_item, body);\n+                        let item_indent = old_item_indent + 1;\n+                        body = format!(\"{item_indent}{item}\\n\\n{body}\");\n                     }\n                 }\n             }\n \n             let mut module_def = String::new();\n \n-            format_to!(module_def, \"mod {} {{\\n{}\\n{}}}\", module.name, body, old_item_indent);\n+            let module_name = module.name;\n+            format_to!(module_def, \"mod {module_name} {{\\n{body}\\n{old_item_indent}}}\");\n \n             let mut usages_to_be_updated_for_curr_file = vec![];\n             for usages_to_be_updated_for_file in usages_to_be_processed {\n@@ -199,7 +197,7 @@ pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opti\n                     builder.delete(range);\n                 }\n \n-                builder.insert(impl_.syntax().text_range().end(), format!(\"\\n\\n{}\", module_def));\n+                builder.insert(impl_.syntax().text_range().end(), format!(\"\\n\\n{module_def}\"));\n             } else {\n                 builder.replace(module.text_range, module_def)\n             }\n@@ -343,9 +341,10 @@ impl Module {\n                 && !self.text_range.contains_range(desc.text_range())\n             {\n                 if let Some(name_ref) = ast::NameRef::cast(desc) {\n+                    let mod_name = self.name;\n                     return Some((\n                         name_ref.syntax().text_range(),\n-                        format!(\"{}::{}\", self.name, name_ref),\n+                        format!(\"{mod_name}::{name_ref}\"),\n                     ));\n                 }\n             }"}, {"sha": "b4e10667b07abe4a4bf196973bdcadd98018fe92", "filename": "crates/ide-assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -296,10 +296,14 @@ fn create_struct_def(\n \n fn update_variant(variant: &ast::Variant, generics: Option<ast::GenericParamList>) -> Option<()> {\n     let name = variant.name()?;\n-    let ty = generics\n+    let generic_args = generics\n         .filter(|generics| generics.generic_params().count() > 0)\n-        .map(|generics| make::ty(&format!(\"{}{}\", &name.text(), generics.to_generic_args())))\n-        .unwrap_or_else(|| make::ty(&name.text()));\n+        .map(|generics| generics.to_generic_args());\n+    // FIXME: replace with a `ast::make` constructor\n+    let ty = match generic_args {\n+        Some(generic_args) => make::ty(&format!(\"{name}{generic_args}\")),\n+        None => make::ty(&name.text()),\n+    };\n \n     // change from a record to a tuple field list\n     let tuple_field = make::tuple_field(None, ty);"}, {"sha": "3116935fc5e7590c81b86632cc0ba618fc9b4ea1", "filename": "crates/ide-assists/src/handlers/extract_type_alias.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -1,8 +1,7 @@\n use either::Either;\n use ide_db::syntax_helpers::node_ext::walk_ty;\n-use itertools::Itertools;\n use syntax::{\n-    ast::{self, edit::IndentLevel, AstNode, HasGenericParams, HasName},\n+    ast::{self, edit::IndentLevel, make, AstNode, HasGenericParams, HasName},\n     match_ast,\n };\n \n@@ -64,41 +63,29 @@ pub(crate) fn extract_type_alias(acc: &mut Assists, ctx: &AssistContext<'_>) ->\n                 known_generics.extend(it.generic_params());\n             }\n             let generics = collect_used_generics(&ty, &known_generics);\n+            let generic_params =\n+                generics.map(|it| make::generic_param_list(it.into_iter().cloned()));\n \n-            let replacement = if !generics.is_empty() {\n-                format!(\n-                    \"Type<{}>\",\n-                    generics.iter().format_with(\", \", |generic, f| {\n-                        match generic {\n-                            ast::GenericParam::ConstParam(cp) => f(&cp.name().unwrap()),\n-                            ast::GenericParam::LifetimeParam(lp) => f(&lp.lifetime().unwrap()),\n-                            ast::GenericParam::TypeParam(tp) => f(&tp.name().unwrap()),\n-                        }\n-                    })\n-                )\n-            } else {\n-                String::from(\"Type\")\n-            };\n+            let ty_args = generic_params\n+                .as_ref()\n+                .map_or(String::new(), |it| it.to_generic_args().to_string());\n+            let replacement = format!(\"Type{ty_args}\");\n             builder.replace(target, replacement);\n \n             let indent = IndentLevel::from_node(node);\n-            let generics = if !generics.is_empty() {\n-                format!(\"<{}>\", generics.iter().format(\", \"))\n-            } else {\n-                String::new()\n-            };\n+            let generic_params = generic_params.map_or(String::new(), |it| it.to_string());\n             match ctx.config.snippet_cap {\n                 Some(cap) => {\n                     builder.insert_snippet(\n                         cap,\n                         insert_pos,\n-                        format!(\"type $0Type{} = {};\\n\\n{}\", generics, ty, indent),\n+                        format!(\"type $0Type{generic_params} = {ty};\\n\\n{indent}\"),\n                     );\n                 }\n                 None => {\n                     builder.insert(\n                         insert_pos,\n-                        format!(\"type Type{} = {};\\n\\n{}\", generics, ty, indent),\n+                        format!(\"type Type{generic_params} = {ty};\\n\\n{indent}\"),\n                     );\n                 }\n             }\n@@ -109,7 +96,7 @@ pub(crate) fn extract_type_alias(acc: &mut Assists, ctx: &AssistContext<'_>) ->\n fn collect_used_generics<'gp>(\n     ty: &ast::Type,\n     known_generics: &'gp [ast::GenericParam],\n-) -> Vec<&'gp ast::GenericParam> {\n+) -> Option<Vec<&'gp ast::GenericParam>> {\n     // can't use a closure -> closure here cause lifetime inference fails for that\n     fn find_lifetime(text: &str) -> impl Fn(&&ast::GenericParam) -> bool + '_ {\n         move |gp: &&ast::GenericParam| match gp {\n@@ -198,7 +185,8 @@ fn collect_used_generics<'gp>(\n         ast::GenericParam::LifetimeParam(_) => 0,\n         ast::GenericParam::TypeParam(_) => 1,\n     });\n-    generics\n+\n+    Some(generics).filter(|it| it.len() > 0)\n }\n \n #[cfg(test)]"}, {"sha": "a738deffb95b302c5d02e23fc1199bb025329792", "filename": "crates/ide-assists/src/handlers/extract_variable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_variable.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -91,13 +91,13 @@ pub(crate) fn extract_variable(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n \n             match anchor {\n                 Anchor::Before(_) | Anchor::Replace(_) => {\n-                    format_to!(buf, \"let {}{} = {}\", var_modifier, var_name, reference_modifier)\n+                    format_to!(buf, \"let {var_modifier}{var_name} = {reference_modifier}\")\n                 }\n                 Anchor::WrapInBlock(_) => {\n-                    format_to!(buf, \"{{ let {} = {}\", var_name, reference_modifier)\n+                    format_to!(buf, \"{{ let {var_name} = {reference_modifier}\")\n                 }\n             };\n-            format_to!(buf, \"{}\", to_extract.syntax());\n+            format_to!(buf, \"{to_extract}\");\n \n             if let Anchor::Replace(stmt) = anchor {\n                 cov_mark::hit!(test_extract_var_expr_stmt);\n@@ -107,8 +107,8 @@ pub(crate) fn extract_variable(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n                 match ctx.config.snippet_cap {\n                     Some(cap) => {\n                         let snip = buf.replace(\n-                            &format!(\"let {}{}\", var_modifier, var_name),\n-                            &format!(\"let {}$0{}\", var_modifier, var_name),\n+                            &format!(\"let {var_modifier}{var_name}\"),\n+                            &format!(\"let {var_modifier}$0{var_name}\"),\n                         );\n                         edit.replace_snippet(cap, expr_range, snip)\n                     }\n@@ -135,8 +135,8 @@ pub(crate) fn extract_variable(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n             match ctx.config.snippet_cap {\n                 Some(cap) => {\n                     let snip = buf.replace(\n-                        &format!(\"let {}{}\", var_modifier, var_name),\n-                        &format!(\"let {}$0{}\", var_modifier, var_name),\n+                        &format!(\"let {var_modifier}{var_name}\"),\n+                        &format!(\"let {var_modifier}$0{var_name}\"),\n                     );\n                     edit.insert_snippet(cap, offset, snip)\n                 }"}, {"sha": "8764543028706f9d37d068397d283d525b029d77", "filename": "crates/ide-assists/src/handlers/fix_visibility.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -57,8 +57,8 @@ fn add_vis_to_referenced_module_def(acc: &mut Assists, ctx: &AssistContext<'_>)\n         if current_module.krate() == target_module.krate() { \"pub(crate)\" } else { \"pub\" };\n \n     let assist_label = match target_name {\n-        None => format!(\"Change visibility to {}\", missing_visibility),\n-        Some(name) => format!(\"Change visibility of {} to {}\", name, missing_visibility),\n+        None => format!(\"Change visibility to {missing_visibility}\"),\n+        Some(name) => format!(\"Change visibility of {name} to {missing_visibility}\"),\n     };\n \n     acc.add(AssistId(\"fix_visibility\", AssistKind::QuickFix), assist_label, target, |builder| {\n@@ -68,15 +68,15 @@ fn add_vis_to_referenced_module_def(acc: &mut Assists, ctx: &AssistContext<'_>)\n                 Some(current_visibility) => builder.replace_snippet(\n                     cap,\n                     current_visibility.syntax().text_range(),\n-                    format!(\"$0{}\", missing_visibility),\n+                    format!(\"$0{missing_visibility}\"),\n                 ),\n-                None => builder.insert_snippet(cap, offset, format!(\"$0{} \", missing_visibility)),\n+                None => builder.insert_snippet(cap, offset, format!(\"$0{missing_visibility} \")),\n             },\n             None => match current_visibility {\n                 Some(current_visibility) => {\n                     builder.replace(current_visibility.syntax().text_range(), missing_visibility)\n                 }\n-                None => builder.insert(offset, format!(\"{} \", missing_visibility)),\n+                None => builder.insert(offset, format!(\"{missing_visibility} \")),\n             },\n         }\n     })\n@@ -114,7 +114,7 @@ fn add_vis_to_referenced_record_field(acc: &mut Assists, ctx: &AssistContext<'_>\n \n     let target_name = record_field_def.name(ctx.db());\n     let assist_label =\n-        format!(\"Change visibility of {}.{} to {}\", parent_name, target_name, missing_visibility);\n+        format!(\"Change visibility of {parent_name}.{target_name} to {missing_visibility}\");\n \n     acc.add(AssistId(\"fix_visibility\", AssistKind::QuickFix), assist_label, target, |builder| {\n         builder.edit_file(target_file);\n@@ -123,15 +123,15 @@ fn add_vis_to_referenced_record_field(acc: &mut Assists, ctx: &AssistContext<'_>\n                 Some(current_visibility) => builder.replace_snippet(\n                     cap,\n                     current_visibility.syntax().text_range(),\n-                    format!(\"$0{}\", missing_visibility),\n+                    format!(\"$0{missing_visibility}\"),\n                 ),\n-                None => builder.insert_snippet(cap, offset, format!(\"$0{} \", missing_visibility)),\n+                None => builder.insert_snippet(cap, offset, format!(\"$0{missing_visibility} \")),\n             },\n             None => match current_visibility {\n                 Some(current_visibility) => {\n                     builder.replace(current_visibility.syntax().text_range(), missing_visibility)\n                 }\n-                None => builder.insert(offset, format!(\"{} \", missing_visibility)),\n+                None => builder.insert(offset, format!(\"{missing_visibility} \")),\n             },\n         }\n     })"}, {"sha": "c9aa41c845ad5c0b0a964cb6d0d059167dd1d416", "filename": "crates/ide-assists/src/handlers/generate_enum_projection_method.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_projection_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_projection_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_projection_method.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -124,6 +124,7 @@ fn generate_enum_projection_method(\n         happy_case,\n         sad_case,\n     } = props;\n+\n     let variant = ctx.find_node_at_offset::<ast::Variant>()?;\n     let variant_name = variant.name()?;\n     let parent_enum = ast::Adt::Enum(variant.parent_enum());\n@@ -144,7 +145,7 @@ fn generate_enum_projection_method(\n         ast::StructKind::Unit => return None,\n     };\n \n-    let fn_name = format!(\"{}_{}\", fn_name_prefix, &to_lower_snake_case(&variant_name.text()));\n+    let fn_name = format!(\"{fn_name_prefix}_{}\", &to_lower_snake_case(&variant_name.text()));\n \n     // Return early if we've found an existing new fn\n     let impl_def = find_struct_impl(ctx, &parent_enum, &[fn_name.clone()])?;\n@@ -156,15 +157,25 @@ fn generate_enum_projection_method(\n         assist_description,\n         target,\n         |builder| {\n-            let vis = parent_enum.visibility().map_or(String::new(), |v| format!(\"{v} \"));\n+            let vis = parent_enum.visibility().map_or(String::new(), |v| format!(\"{} \", v));\n+\n+            let field_type_syntax = field_type.syntax();\n+\n+            let must_use = if ctx.config.assist_emit_must_use {\n+                \"#[must_use]\\n    \"\n+            } else {\n+                \"\"\n+            };\n+\n             let method = format!(\n-                \"    {vis}fn {fn_name}({self_param}) -> {return_prefix}{field_type}{return_suffix} {{\n+                \"    {must_use}{vis}fn {fn_name}({self_param}) -> {return_prefix}{field_type_syntax}{return_suffix} {{\n         if let Self::{variant_name}{pattern_suffix} = self {{\n             {happy_case}({bound_name})\n         }} else {{\n             {sad_case}\n         }}\n-    }}\");\n+    }}\"\n+            );\n \n             add_method_to_adt(builder, &parent_enum, impl_def, &method);\n         },"}, {"sha": "0c546ce5d41c6520bc9df8402d8d77753f6933b6", "filename": "crates/ide-assists/src/handlers/inline_call.rs", "status": "modified", "additions": 76, "deletions": 14, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_call.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -1,3 +1,5 @@\n+use std::collections::BTreeSet;\n+\n use ast::make;\n use either::Either;\n use hir::{db::HirDatabase, PathResolution, Semantics, TypeInfo};\n@@ -190,10 +192,10 @@ pub(crate) fn inline_call(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<\n                 PathResolution::Def(hir::ModuleDef::Function(f)) => f,\n                 _ => return None,\n             };\n-            (function, format!(\"Inline `{}`\", path))\n+            (function, format!(\"Inline `{path}`\"))\n         }\n         ast::CallableExpr::MethodCall(call) => {\n-            (ctx.sema.resolve_method_call(call)?, format!(\"Inline `{}`\", name_ref))\n+            (ctx.sema.resolve_method_call(call)?, format!(\"Inline `{name_ref}`\"))\n         }\n     };\n \n@@ -373,8 +375,44 @@ fn inline(\n                 })\n         }\n     }\n+\n+    let mut func_let_vars: BTreeSet<String> = BTreeSet::new();\n+\n+    // grab all of the local variable declarations in the function\n+    for stmt in fn_body.statements() {\n+        if let Some(let_stmt) = ast::LetStmt::cast(stmt.syntax().to_owned()) {\n+            for has_token in let_stmt.syntax().children_with_tokens() {\n+                if let Some(node) = has_token.as_node() {\n+                    if let Some(ident_pat) = ast::IdentPat::cast(node.to_owned()) {\n+                        func_let_vars.insert(ident_pat.syntax().text().to_string());\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     // Inline parameter expressions or generate `let` statements depending on whether inlining works or not.\n     for ((pat, param_ty, _), usages, expr) in izip!(params, param_use_nodes, arguments).rev() {\n+        // izip confuses RA due to our lack of hygiene info currently losing us type info causing incorrect errors\n+        let usages: &[ast::PathExpr] = &*usages;\n+        let expr: &ast::Expr = expr;\n+\n+        let insert_let_stmt = || {\n+            let ty = sema.type_of_expr(expr).filter(TypeInfo::has_adjustment).and(param_ty.clone());\n+            if let Some(stmt_list) = body.stmt_list() {\n+                stmt_list.push_front(\n+                    make::let_stmt(pat.clone(), ty, Some(expr.clone())).clone_for_update().into(),\n+                )\n+            }\n+        };\n+\n+        // check if there is a local var in the function that conflicts with parameter\n+        // if it does then emit a let statement and continue\n+        if func_let_vars.contains(&expr.syntax().text().to_string()) {\n+            insert_let_stmt();\n+            continue;\n+        }\n+\n         let inline_direct = |usage, replacement: &ast::Expr| {\n             if let Some(field) = path_expr_as_record_field(usage) {\n                 cov_mark::hit!(inline_call_inline_direct_field);\n@@ -383,9 +421,7 @@ fn inline(\n                 ted::replace(usage.syntax(), &replacement.syntax().clone_for_update());\n             }\n         };\n-        // izip confuses RA due to our lack of hygiene info currently losing us type info causing incorrect errors\n-        let usages: &[ast::PathExpr] = &*usages;\n-        let expr: &ast::Expr = expr;\n+\n         match usages {\n             // inline single use closure arguments\n             [usage]\n@@ -408,18 +444,11 @@ fn inline(\n             }\n             // can't inline, emit a let statement\n             _ => {\n-                let ty =\n-                    sema.type_of_expr(expr).filter(TypeInfo::has_adjustment).and(param_ty.clone());\n-                if let Some(stmt_list) = body.stmt_list() {\n-                    stmt_list.push_front(\n-                        make::let_stmt(pat.clone(), ty, Some(expr.clone()))\n-                            .clone_for_update()\n-                            .into(),\n-                    )\n-                }\n+                insert_let_stmt();\n             }\n         }\n     }\n+\n     if let Some(generic_arg_list) = generic_arg_list.clone() {\n         if let Some((target, source)) = &sema.scope(node.syntax()).zip(sema.scope(fn_body.syntax()))\n         {\n@@ -1256,4 +1285,37 @@ impl A {\n \"#,\n         )\n     }\n+\n+    #[test]\n+    fn local_variable_shadowing_callers_argument() {\n+        check_assist(\n+            inline_call,\n+            r#\"\n+fn foo(bar: u32, baz: u32) -> u32 {\n+    let a = 1;\n+    bar * baz * a * 6\n+}\n+fn main() {\n+    let a = 7;\n+    let b = 1;\n+    let res = foo$0(a, b);\n+}\n+\"#,\n+            r#\"\n+fn foo(bar: u32, baz: u32) -> u32 {\n+    let a = 1;\n+    bar * baz * a * 6\n+}\n+fn main() {\n+    let a = 7;\n+    let b = 1;\n+    let res = {\n+        let bar = a;\n+        let a = 1;\n+        bar * b * a * 6\n+    };\n+}\n+\"#,\n+        );\n+    }\n }"}, {"sha": "ce44100e34bebee523197b6bf66035b810459917", "filename": "crates/ide-assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -113,7 +113,7 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext<'_>)\n         .collect::<Option<Vec<_>>>()?;\n \n     let init_str = initializer_expr.syntax().text().to_string();\n-    let init_in_paren = format!(\"({})\", &init_str);\n+    let init_in_paren = format!(\"({init_str})\");\n \n     let target = match target {\n         ast::NameOrNameRef::Name(it) => it.syntax().text_range(),\n@@ -132,7 +132,7 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext<'_>)\n                 let replacement = if should_wrap { &init_in_paren } else { &init_str };\n                 if ast::RecordExprField::for_field_name(&name).is_some() {\n                     cov_mark::hit!(inline_field_shorthand);\n-                    builder.insert(range.end(), format!(\": {}\", replacement));\n+                    builder.insert(range.end(), format!(\": {replacement}\"));\n                 } else {\n                     builder.replace(range, replacement.clone())\n                 }"}, {"sha": "a54dc4f96de00e0f198b8c86b9d26a6d8b8bd484", "filename": "crates/ide-assists/src/handlers/introduce_named_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -127,7 +127,7 @@ fn generate_unique_lifetime_param_name(\n         Some(type_params) => {\n             let used_lifetime_params: FxHashSet<_> =\n                 type_params.lifetime_params().map(|p| p.syntax().text().to_string()).collect();\n-            ('a'..='z').map(|it| format!(\"'{}\", it)).find(|it| !used_lifetime_params.contains(it))\n+            ('a'..='z').map(|it| format!(\"'{it}\")).find(|it| !used_lifetime_params.contains(it))\n         }\n         None => Some(\"'a\".to_string()),\n     }"}, {"sha": "641c90885bf530d09a509a10e496879f5f61598a", "filename": "crates/ide-assists/src/handlers/merge_match_arms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -78,7 +78,7 @@ pub(crate) fn merge_match_arms(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n                     .join(\" | \")\n             };\n \n-            let arm = format!(\"{} => {},\", pats, current_expr.syntax().text());\n+            let arm = format!(\"{pats} => {current_expr},\");\n \n             if let [first, .., last] = &*arms_to_merge {\n                 let start = first.syntax().text_range().start();"}, {"sha": "1728c03cd03e2e36f553c5dc6af983edbcfab83e", "filename": "crates/ide-assists/src/handlers/move_from_mod_rs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_from_mod_rs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_from_mod_rs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_from_mod_rs.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -40,11 +40,11 @@ pub(crate) fn move_from_mod_rs(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n \n     let target = source_file.syntax().text_range();\n     let module_name = module.name(ctx.db())?.to_string();\n-    let path = format!(\"../{}.rs\", module_name);\n+    let path = format!(\"../{module_name}.rs\");\n     let dst = AnchoredPathBuf { anchor: ctx.file_id(), path };\n     acc.add(\n         AssistId(\"move_from_mod_rs\", AssistKind::Refactor),\n-        format!(\"Convert {}/mod.rs to {}.rs\", module_name, module_name),\n+        format!(\"Convert {module_name}/mod.rs to {module_name}.rs\"),\n         target,\n         |builder| {\n             builder.move_file(ctx.file_id(), dst);"}, {"sha": "ec3281619cc3ff7bb21d889d63dfc0d268582632", "filename": "crates/ide-assists/src/handlers/move_guard.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_guard.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -133,16 +133,16 @@ pub(crate) fn move_arm_cond_to_match_guard(\n             };\n             let then_arm_end = match_arm.syntax().text_range().end();\n             let indent_level = match_arm.indent_level();\n-            let spaces = \"    \".repeat(indent_level.0 as _);\n+            let spaces = indent_level;\n \n             let mut first = true;\n             for (cond, block) in conds_blocks {\n                 if !first {\n-                    edit.insert(then_arm_end, format!(\"\\n{}\", spaces));\n+                    edit.insert(then_arm_end, format!(\"\\n{spaces}\"));\n                 } else {\n                     first = false;\n                 }\n-                let guard = format!(\"{} if {} => \", match_pat, cond.syntax().text());\n+                let guard = format!(\"{match_pat} if {cond} => \");\n                 edit.insert(then_arm_end, guard);\n                 let only_expr = block.statements().next().is_none();\n                 match &block.tail_expr() {\n@@ -158,7 +158,7 @@ pub(crate) fn move_arm_cond_to_match_guard(\n             }\n             if let Some(e) = tail {\n                 cov_mark::hit!(move_guard_ifelse_else_tail);\n-                let guard = format!(\"\\n{}{} => \", spaces, match_pat);\n+                let guard = format!(\"\\n{spaces}{match_pat} => \");\n                 edit.insert(then_arm_end, guard);\n                 let only_expr = e.statements().next().is_none();\n                 match &e.tail_expr() {\n@@ -183,7 +183,7 @@ pub(crate) fn move_arm_cond_to_match_guard(\n                     {\n                         cov_mark::hit!(move_guard_ifelse_has_wildcard);\n                     }\n-                    _ => edit.insert(then_arm_end, format!(\"\\n{}{} => {{}}\", spaces, match_pat)),\n+                    _ => edit.insert(then_arm_end, format!(\"\\n{spaces}{match_pat} => {{}}\")),\n                 }\n             }\n         },"}, {"sha": "a7c605325ea6938cfe3f102bf500add03efdf5da", "filename": "crates/ide-assists/src/handlers/move_module_to_file.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_module_to_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_module_to_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_module_to_file.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -52,7 +52,7 @@ pub(crate) fn move_module_to_file(acc: &mut Assists, ctx: &AssistContext<'_>) ->\n                 let mut buf = String::from(\"./\");\n                 match parent_module.name(ctx.db()) {\n                     Some(name) if !parent_module.is_mod_rs(ctx.db()) => {\n-                        format_to!(buf, \"{}/\", name)\n+                        format_to!(buf, \"{name}/\")\n                     }\n                     _ => (),\n                 }\n@@ -82,7 +82,7 @@ pub(crate) fn move_module_to_file(acc: &mut Assists, ctx: &AssistContext<'_>) ->\n                 items\n             };\n \n-            let buf = format!(\"mod {};\", module_name);\n+            let buf = format!(\"mod {module_name};\");\n \n             let replacement_start = match module_ast.mod_token() {\n                 Some(mod_token) => mod_token.text_range(),"}, {"sha": "076d25411a8180e7627fbf93084b786144270443", "filename": "crates/ide-assists/src/handlers/move_to_mod_rs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_to_mod_rs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_to_mod_rs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_to_mod_rs.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -40,11 +40,11 @@ pub(crate) fn move_to_mod_rs(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opti\n \n     let target = source_file.syntax().text_range();\n     let module_name = module.name(ctx.db())?.to_string();\n-    let path = format!(\"./{}/mod.rs\", module_name);\n+    let path = format!(\"./{module_name}/mod.rs\");\n     let dst = AnchoredPathBuf { anchor: ctx.file_id(), path };\n     acc.add(\n         AssistId(\"move_to_mod_rs\", AssistKind::Refactor),\n-        format!(\"Convert {}.rs to {}/mod.rs\", module_name, module_name),\n+        format!(\"Convert {module_name}.rs to {module_name}/mod.rs\"),\n         target,\n         |builder| {\n             builder.move_file(ctx.file_id(), dst);"}, {"sha": "7e3fef516bfd8f2f399aba6e2c97e4fee3d6b792", "filename": "crates/ide-assists/src/handlers/number_representation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fnumber_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fnumber_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fnumber_representation.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -38,7 +38,7 @@ pub(crate) fn reformat_number_literal(acc: &mut Assists, ctx: &AssistContext<'_>\n     converted.push_str(suffix);\n \n     let group_id = GroupLabel(\"Reformat number literal\".into());\n-    let label = format!(\"Convert {} to {}\", literal, converted);\n+    let label = format!(\"Convert {literal} to {converted}\");\n     let range = literal.syntax().text_range();\n     acc.add_group(\n         &group_id,"}, {"sha": "1ea87429c50928bc3dfc5cffe738c46c3297b4a9", "filename": "crates/ide-assists/src/handlers/qualify_method_call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_method_call.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -54,7 +54,7 @@ pub(crate) fn qualify_method_call(acc: &mut Assists, ctx: &AssistContext<'_>) ->\n \n     acc.add(\n         AssistId(\"qualify_method_call\", AssistKind::RefactorInline),\n-        format!(\"Qualify `{}` method call\", ident.text()),\n+        format!(\"Qualify `{ident}` method call\"),\n         range,\n         |builder| {\n             qualify_candidate.qualify("}, {"sha": "e759e1561cbd0a5ba956f42bacabd232de330d58", "filename": "crates/ide-assists/src/handlers/qualify_path.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -118,14 +118,14 @@ impl QualifyCandidate<'_> {\n         match self {\n             QualifyCandidate::QualifierStart(segment, generics) => {\n                 let generics = generics.as_ref().map_or_else(String::new, ToString::to_string);\n-                replacer(format!(\"{}{}::{}\", import, generics, segment));\n+                replacer(format!(\"{import}{generics}::{segment}\"));\n             }\n             QualifyCandidate::UnqualifiedName(generics) => {\n                 let generics = generics.as_ref().map_or_else(String::new, ToString::to_string);\n-                replacer(format!(\"{}{}\", import, generics));\n+                replacer(format!(\"{import}{generics}\"));\n             }\n             QualifyCandidate::TraitAssocItem(qualifier, segment) => {\n-                replacer(format!(\"<{} as {}>::{}\", qualifier, import, segment));\n+                replacer(format!(\"<{qualifier} as {import}>::{segment}\"));\n             }\n             QualifyCandidate::TraitMethod(db, mcall_expr) => {\n                 Self::qualify_trait_method(db, mcall_expr, replacer, import, item);\n@@ -155,16 +155,11 @@ impl QualifyCandidate<'_> {\n                 hir::Access::Exclusive => make::expr_ref(receiver, true),\n                 hir::Access::Owned => receiver,\n             };\n-            replacer(format!(\n-                \"{}::{}{}{}\",\n-                import,\n-                method_name,\n-                generics,\n-                match arg_list {\n-                    Some(args) => make::arg_list(iter::once(receiver).chain(args)),\n-                    None => make::arg_list(iter::once(receiver)),\n-                }\n-            ));\n+            let arg_list = match arg_list {\n+                Some(args) => make::arg_list(iter::once(receiver).chain(args)),\n+                None => make::arg_list(iter::once(receiver)),\n+            };\n+            replacer(format!(\"{import}::{method_name}{generics}{arg_list}\"));\n         }\n         Some(())\n     }\n@@ -218,15 +213,17 @@ fn group_label(candidate: &ImportCandidate) -> GroupLabel {\n         }\n     }\n     .text();\n-    GroupLabel(format!(\"Qualify {}\", name))\n+    GroupLabel(format!(\"Qualify {name}\"))\n }\n \n fn label(candidate: &ImportCandidate, import: &LocatedImport) -> String {\n+    let import_path = &import.import_path;\n+\n     match candidate {\n         ImportCandidate::Path(candidate) if candidate.qualifier.is_none() => {\n-            format!(\"Qualify as `{}`\", import.import_path)\n+            format!(\"Qualify as `{import_path}`\")\n         }\n-        _ => format!(\"Qualify with `{}`\", import.import_path),\n+        _ => format!(\"Qualify with `{import_path}`\"),\n     }\n }\n "}, {"sha": "c9bc25b27a5ed8c0d1c3543d1d2be932cb50c139", "filename": "crates/ide-assists/src/handlers/raw_string.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fraw_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fraw_string.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -34,13 +34,10 @@ pub(crate) fn make_raw_string(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opt\n             let hashes = \"#\".repeat(required_hashes(&value).max(1));\n             if matches!(value, Cow::Borrowed(_)) {\n                 // Avoid replacing the whole string to better position the cursor.\n-                edit.insert(token.syntax().text_range().start(), format!(\"r{}\", hashes));\n+                edit.insert(token.syntax().text_range().start(), format!(\"r{hashes}\"));\n                 edit.insert(token.syntax().text_range().end(), hashes);\n             } else {\n-                edit.replace(\n-                    token.syntax().text_range(),\n-                    format!(\"r{}\\\"{}\\\"{}\", hashes, value, hashes),\n-                );\n+                edit.replace(token.syntax().text_range(), format!(\"r{hashes}\\\"{value}\\\"{hashes}\"));\n             }\n         },\n     )\n@@ -83,7 +80,7 @@ pub(crate) fn make_usual_string(acc: &mut Assists, ctx: &AssistContext<'_>) -> O\n                 }\n             }\n \n-            edit.replace(token.syntax().text_range(), format!(\"\\\"{}\\\"\", escaped));\n+            edit.replace(token.syntax().text_range(), format!(\"\\\"{escaped}\\\"\"));\n         },\n     )\n }"}, {"sha": "3d9cbff177ba9c68bfed291a2c2ca58eea3c1051", "filename": "crates/ide-assists/src/handlers/remove_dbg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fremove_dbg.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -102,7 +102,7 @@ pub(crate) fn remove_dbg(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<(\n             };\n             (\n                 macro_call.syntax().text_range(),\n-                if wrap { format!(\"({})\", expr) } else { expr.to_string() },\n+                if wrap { format!(\"({expr})\") } else { expr.to_string() },\n             )\n         }\n         // dbg!(expr0, expr1, ...)\n@@ -127,8 +127,8 @@ mod tests {\n     fn check(ra_fixture_before: &str, ra_fixture_after: &str) {\n         check_assist(\n             remove_dbg,\n-            &format!(\"fn main() {{\\n{}\\n}}\", ra_fixture_before),\n-            &format!(\"fn main() {{\\n{}\\n}}\", ra_fixture_after),\n+            &format!(\"fn main() {{\\n{ra_fixture_before}\\n}}\"),\n+            &format!(\"fn main() {{\\n{ra_fixture_after}\\n}}\"),\n         );\n     }\n "}, {"sha": "f9ba289ee175fe76d554aeb28811b774b5fc34a1", "filename": "crates/ide-assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -124,7 +124,7 @@ fn add_assist(\n ) -> Option<()> {\n     let target = attr.syntax().text_range();\n     let annotated_name = adt.name()?;\n-    let label = format!(\"Convert to manual `impl {} for {}`\", replace_trait_path, annotated_name);\n+    let label = format!(\"Convert to manual `impl {replace_trait_path} for {annotated_name}`\");\n \n     acc.add(\n         AssistId(\"replace_derive_with_manual_impl\", AssistKind::Refactor),\n@@ -158,11 +158,8 @@ fn add_assist(\n                         }\n                     }\n \n-                    builder.insert_snippet(\n-                        cap,\n-                        insert_pos,\n-                        format!(\"\\n\\n{}\", render_snippet(cap, impl_def.syntax(), cursor)),\n-                    )\n+                    let rendered = render_snippet(cap, impl_def.syntax(), cursor);\n+                    builder.insert_snippet(cap, insert_pos, format!(\"\\n\\n{rendered}\"))\n                 }\n             };\n         },"}, {"sha": "77382056c18339eb8d29335c5aa50d2cc8d58106", "filename": "crates/ide-assists/src/handlers/replace_or_with_or_else.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_or_with_or_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_or_with_or_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_or_with_or_else.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -62,7 +62,7 @@ pub(crate) fn replace_or_with_or_else(acc: &mut Assists, ctx: &AssistContext<'_>\n \n     acc.add(\n         AssistId(\"replace_or_with_or_else\", AssistKind::RefactorRewrite),\n-        format!(\"Replace {} with {}\", name.text(), replace),\n+        format!(\"Replace {name} with {replace}\"),\n         call.syntax().text_range(),\n         |builder| {\n             builder.replace(name.syntax().text_range(), replace);\n@@ -138,7 +138,7 @@ pub(crate) fn replace_or_else_with_or(acc: &mut Assists, ctx: &AssistContext<'_>\n \n     acc.add(\n         AssistId(\"replace_or_else_with_or\", AssistKind::RefactorRewrite),\n-        format!(\"Replace {} with {}\", name.text(), replace),\n+        format!(\"Replace {name} with {replace}\"),\n         call.syntax().text_range(),\n         |builder| {\n             builder.replace(name.syntax().text_range(), replace);"}, {"sha": "c177adc7a10d73a78cb034e8388f4e0200d79852", "filename": "crates/ide-assists/src/handlers/replace_turbofish_with_explicit_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -79,7 +79,7 @@ pub(crate) fn replace_turbofish_with_explicit_type(\n             \"Replace turbofish with explicit type\",\n             TextRange::new(initializer_start, turbofish_range.end()),\n             |builder| {\n-                builder.insert(ident_range.end(), format!(\": {}\", returned_type));\n+                builder.insert(ident_range.end(), format!(\": {returned_type}\"));\n                 builder.delete(turbofish_range);\n             },\n         );"}, {"sha": "04398832253307be610ef1da72c05d5b33fa7d20", "filename": "crates/ide-assists/src/handlers/unnecessary_async.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funnecessary_async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funnecessary_async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funnecessary_async.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -44,6 +44,12 @@ pub(crate) fn unnecessary_async(acc: &mut Assists, ctx: &AssistContext<'_>) -> O\n     if function.body()?.syntax().descendants().find_map(ast::AwaitExpr::cast).is_some() {\n         return None;\n     }\n+    // Do nothing if the method is a member of trait.\n+    if let Some(impl_) = function.syntax().ancestors().nth(2).and_then(ast::Impl::cast) {\n+        if let Some(_) = impl_.trait_() {\n+            return None;\n+        }\n+    }\n \n     // Remove the `async` keyword plus whitespace after it, if any.\n     let async_range = {\n@@ -254,4 +260,18 @@ pub async fn f(s: &S) { s.f2() }\"#,\n     fn does_not_apply_when_not_on_prototype() {\n         check_assist_not_applicable(unnecessary_async, \"pub async fn f() { $0f2() }\")\n     }\n+\n+    #[test]\n+    fn does_not_apply_on_async_trait_method() {\n+        check_assist_not_applicable(\n+            unnecessary_async,\n+            r#\"\n+trait Trait {\n+    async fn foo();\n+}\n+impl Trait for () {\n+    $0async fn foo() {}\n+}\"#,\n+        );\n+    }\n }"}, {"sha": "d09614c51127ed8232c86e8c02b3cc4f57ddd858", "filename": "crates/ide-assists/src/handlers/unwrap_tuple.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_tuple.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -69,13 +69,13 @@ pub(crate) fn unwrap_tuple(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option\n                 for (pat, ty, expr) in\n                     itertools::izip!(tuple_pat.fields(), tys.fields(), tuple_init.fields())\n                 {\n-                    zipped_decls.push_str(&format!(\"{}let {pat}: {ty} = {expr};\\n\", indents))\n+                    zipped_decls.push_str(&format!(\"{indents}let {pat}: {ty} = {expr};\\n\"))\n                 }\n                 edit.replace(parent.text_range(), zipped_decls.trim());\n             } else {\n                 let mut zipped_decls = String::new();\n                 for (pat, expr) in itertools::izip!(tuple_pat.fields(), tuple_init.fields()) {\n-                    zipped_decls.push_str(&format!(\"{}let {pat} = {expr};\\n\", indents));\n+                    zipped_decls.push_str(&format!(\"{indents}let {pat} = {expr};\\n\"));\n                 }\n                 edit.replace(parent.text_range(), zipped_decls.trim());\n             }"}, {"sha": "b6c489eb62eef2c734e9fdf726f5fcd455ef22c0", "filename": "crates/ide-assists/src/handlers/wrap_return_type_in_result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fwrap_return_type_in_result.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -76,11 +76,11 @@ pub(crate) fn wrap_return_type_in_result(acc: &mut Assists, ctx: &AssistContext<\n \n             match ctx.config.snippet_cap {\n                 Some(cap) => {\n-                    let snippet = format!(\"Result<{}, ${{0:_}}>\", type_ref);\n+                    let snippet = format!(\"Result<{type_ref}, ${{0:_}}>\");\n                     builder.replace_snippet(cap, type_ref.syntax().text_range(), snippet)\n                 }\n                 None => builder\n-                    .replace(type_ref.syntax().text_range(), format!(\"Result<{}, _>\", type_ref)),\n+                    .replace(type_ref.syntax().text_range(), format!(\"Result<{type_ref}, _>\")),\n             }\n         },\n     )"}, {"sha": "387cc631428250e9fa82ee9afe72a9a8608849f0", "filename": "crates/ide-assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Flib.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -120,6 +120,7 @@ mod handlers {\n     mod convert_into_to_from;\n     mod convert_iter_for_each_to_for;\n     mod convert_let_else_to_match;\n+    mod convert_match_to_let_else;\n     mod convert_tuple_struct_to_named_struct;\n     mod convert_named_struct_to_tuple_struct;\n     mod convert_to_guarded_return;\n@@ -220,6 +221,7 @@ mod handlers {\n             convert_iter_for_each_to_for::convert_for_loop_with_for_each,\n             convert_let_else_to_match::convert_let_else_to_match,\n             convert_named_struct_to_tuple_struct::convert_named_struct_to_tuple_struct,\n+            convert_match_to_let_else::convert_match_to_let_else,\n             convert_to_guarded_return::convert_to_guarded_return,\n             convert_tuple_struct_to_named_struct::convert_tuple_struct_to_named_struct,\n             convert_two_arm_bool_match_to_matches_macro::convert_two_arm_bool_match_to_matches_macro,"}, {"sha": "92ced27c78aedf801b3c5eee80a066aea043be72", "filename": "crates/ide-assists/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -30,6 +30,7 @@ pub(crate) const TEST_CONFIG: AssistConfig = AssistConfig {\n         skip_glob_imports: true,\n     },\n     prefer_no_std: false,\n+    assist_emit_must_use: false,\n };\n \n pub(crate) fn with_single_file(text: &str) -> (RootDatabase, FileId) {"}, {"sha": "029d169899bb44a9e5ee76f49b1891fabdd3f991", "filename": "crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -407,6 +407,27 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_convert_match_to_let_else() {\n+    check_doc_test(\n+        \"convert_match_to_let_else\",\n+        r#####\"\n+//- minicore: option\n+fn foo(opt: Option<()>) {\n+    let val = $0match opt {\n+        Some(it) => it,\n+        None => return,\n+    };\n+}\n+\"#####,\n+        r#####\"\n+fn foo(opt: Option<()>) {\n+    let Some(val) = opt else { return };\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_convert_named_struct_to_tuple_struct() {\n     check_doc_test("}, {"sha": "307e67927056ba9a4eefce68b72bef495c63ac1a", "filename": "crates/ide-assists/src/utils.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Futils.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -189,8 +189,8 @@ pub(crate) fn render_snippet(_cap: SnippetCap, node: &SyntaxNode, cursor: Cursor\n     let mut placeholder = cursor.node().to_string();\n     escape(&mut placeholder);\n     let tab_stop = match cursor {\n-        Cursor::Replace(placeholder) => format!(\"${{0:{}}}\", placeholder),\n-        Cursor::Before(placeholder) => format!(\"$0{}\", placeholder),\n+        Cursor::Replace(placeholder) => format!(\"${{0:{placeholder}}}\"),\n+        Cursor::Before(placeholder) => format!(\"$0{placeholder}\"),\n     };\n \n     let mut buf = node.to_string();\n@@ -539,37 +539,37 @@ impl ReferenceConversion {\n             ReferenceConversionType::AsRefSlice => {\n                 let type_argument_name =\n                     self.ty.type_arguments().next().unwrap().display(db).to_string();\n-                format!(\"&[{}]\", type_argument_name)\n+                format!(\"&[{type_argument_name}]\")\n             }\n             ReferenceConversionType::Dereferenced => {\n                 let type_argument_name =\n                     self.ty.type_arguments().next().unwrap().display(db).to_string();\n-                format!(\"&{}\", type_argument_name)\n+                format!(\"&{type_argument_name}\")\n             }\n             ReferenceConversionType::Option => {\n                 let type_argument_name =\n                     self.ty.type_arguments().next().unwrap().display(db).to_string();\n-                format!(\"Option<&{}>\", type_argument_name)\n+                format!(\"Option<&{type_argument_name}>\")\n             }\n             ReferenceConversionType::Result => {\n                 let mut type_arguments = self.ty.type_arguments();\n                 let first_type_argument_name =\n                     type_arguments.next().unwrap().display(db).to_string();\n                 let second_type_argument_name =\n                     type_arguments.next().unwrap().display(db).to_string();\n-                format!(\"Result<&{}, &{}>\", first_type_argument_name, second_type_argument_name)\n+                format!(\"Result<&{first_type_argument_name}, &{second_type_argument_name}>\")\n             }\n         }\n     }\n \n     pub(crate) fn getter(&self, field_name: String) -> String {\n         match self.conversion {\n-            ReferenceConversionType::Copy => format!(\"self.{}\", field_name),\n+            ReferenceConversionType::Copy => format!(\"self.{field_name}\"),\n             ReferenceConversionType::AsRefStr\n             | ReferenceConversionType::AsRefSlice\n             | ReferenceConversionType::Dereferenced\n             | ReferenceConversionType::Option\n-            | ReferenceConversionType::Result => format!(\"self.{}.as_ref()\", field_name),\n+            | ReferenceConversionType::Result => format!(\"self.{field_name}.as_ref()\"),\n         }\n     }\n }"}, {"sha": "6c87e66c134d72a28642c8e614d0e372e63073fc", "filename": "crates/ide-assists/src/utils/gen_trait_fn_body.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -41,7 +41,7 @@ fn gen_clone_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n             let mut arms = vec![];\n             for variant in list.variants() {\n                 let name = variant.name()?;\n-                let variant_name = make::ext::path_from_idents([\"Self\", &format!(\"{}\", name)])?;\n+                let variant_name = make::ext::path_from_idents([\"Self\", &format!(\"{name}\")])?;\n \n                 match variant.field_list() {\n                     // => match self { Self::Name { x } => Self::Name { x: x.clone() } }\n@@ -70,7 +70,7 @@ fn gen_clone_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                         let mut pats = vec![];\n                         let mut fields = vec![];\n                         for (i, _) in list.fields().enumerate() {\n-                            let field_name = format!(\"arg{}\", i);\n+                            let field_name = format!(\"arg{i}\");\n                             let pat = make::ident_pat(false, false, make::name(&field_name));\n                             pats.push(pat.into());\n \n@@ -118,7 +118,7 @@ fn gen_clone_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                     let mut fields = vec![];\n                     for (i, _) in field_list.fields().enumerate() {\n                         let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n-                        let target = make::expr_field(f_path, &format!(\"{}\", i));\n+                        let target = make::expr_field(f_path, &format!(\"{i}\"));\n                         fields.push(gen_clone_call(target));\n                     }\n                     let struct_name = make::expr_path(make::ext::ident_path(\"Self\"));\n@@ -151,15 +151,15 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n             let mut arms = vec![];\n             for variant in list.variants() {\n                 let name = variant.name()?;\n-                let variant_name = make::ext::path_from_idents([\"Self\", &format!(\"{}\", name)])?;\n+                let variant_name = make::ext::path_from_idents([\"Self\", &format!(\"{name}\")])?;\n                 let target = make::expr_path(make::ext::ident_path(\"f\"));\n \n                 match variant.field_list() {\n                     Some(ast::FieldList::RecordFieldList(list)) => {\n                         // => f.debug_struct(name)\n                         let target = make::expr_path(make::ext::ident_path(\"f\"));\n                         let method = make::name_ref(\"debug_struct\");\n-                        let struct_name = format!(\"\\\"{}\\\"\", name);\n+                        let struct_name = format!(\"\\\"{name}\\\"\");\n                         let args = make::arg_list(Some(make::expr_literal(&struct_name).into()));\n                         let mut expr = make::expr_method_call(target, method, args);\n \n@@ -173,8 +173,8 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n \n                             // => <expr>.field(\"field_name\", field)\n                             let method_name = make::name_ref(\"field\");\n-                            let name = make::expr_literal(&(format!(\"\\\"{}\\\"\", field_name))).into();\n-                            let path = &format!(\"{}\", field_name);\n+                            let name = make::expr_literal(&(format!(\"\\\"{field_name}\\\"\"))).into();\n+                            let path = &format!(\"{field_name}\");\n                             let path = make::expr_path(make::ext::ident_path(path));\n                             let args = make::arg_list(vec![name, path]);\n                             expr = make::expr_method_call(expr, method_name, args);\n@@ -192,13 +192,13 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                         // => f.debug_tuple(name)\n                         let target = make::expr_path(make::ext::ident_path(\"f\"));\n                         let method = make::name_ref(\"debug_tuple\");\n-                        let struct_name = format!(\"\\\"{}\\\"\", name);\n+                        let struct_name = format!(\"\\\"{name}\\\"\");\n                         let args = make::arg_list(Some(make::expr_literal(&struct_name).into()));\n                         let mut expr = make::expr_method_call(target, method, args);\n \n                         let mut pats = vec![];\n                         for (i, _) in list.fields().enumerate() {\n-                            let name = format!(\"arg{}\", i);\n+                            let name = format!(\"arg{i}\");\n \n                             // create a field pattern for use in `MyStruct(fields..)`\n                             let field_name = make::name(&name);\n@@ -222,7 +222,7 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                         arms.push(make::match_arm(Some(pat.into()), None, expr));\n                     }\n                     None => {\n-                        let fmt_string = make::expr_literal(&(format!(\"\\\"{}\\\"\", name))).into();\n+                        let fmt_string = make::expr_literal(&(format!(\"\\\"{name}\\\"\"))).into();\n                         let args = make::arg_list([target, fmt_string]);\n                         let macro_name = make::expr_path(make::ext::ident_path(\"write\"));\n                         let macro_call = make::expr_macro_call(macro_name, args);\n@@ -244,7 +244,7 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n         }\n \n         ast::Adt::Struct(strukt) => {\n-            let name = format!(\"\\\"{}\\\"\", annotated_name);\n+            let name = format!(\"\\\"{annotated_name}\\\"\");\n             let args = make::arg_list(Some(make::expr_literal(&name).into()));\n             let target = make::expr_path(make::ext::ident_path(\"f\"));\n \n@@ -258,10 +258,10 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                     let mut expr = make::expr_method_call(target, method, args);\n                     for field in field_list.fields() {\n                         let name = field.name()?;\n-                        let f_name = make::expr_literal(&(format!(\"\\\"{}\\\"\", name))).into();\n+                        let f_name = make::expr_literal(&(format!(\"\\\"{name}\\\"\"))).into();\n                         let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n                         let f_path = make::expr_ref(f_path, false);\n-                        let f_path = make::expr_field(f_path, &format!(\"{}\", name));\n+                        let f_path = make::expr_field(f_path, &format!(\"{name}\"));\n                         let args = make::arg_list([f_name, f_path]);\n                         expr = make::expr_method_call(expr, make::name_ref(\"field\"), args);\n                     }\n@@ -275,7 +275,7 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                     for (i, _) in field_list.fields().enumerate() {\n                         let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n                         let f_path = make::expr_ref(f_path, false);\n-                        let f_path = make::expr_field(f_path, &format!(\"{}\", i));\n+                        let f_path = make::expr_field(f_path, &format!(\"{i}\"));\n                         let method = make::name_ref(\"field\");\n                         expr = make::expr_method_call(expr, method, make::arg_list(Some(f_path)));\n                     }\n@@ -379,7 +379,7 @@ fn gen_hash_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                 let mut stmts = vec![];\n                 for (i, _) in field_list.fields().enumerate() {\n                     let base = make::expr_path(make::ext::ident_path(\"self\"));\n-                    let target = make::expr_field(base, &format!(\"{}\", i));\n+                    let target = make::expr_field(base, &format!(\"{i}\"));\n                     stmts.push(gen_hash_call(target));\n                 }\n                 make::block_expr(stmts, None).indent(ast::edit::IndentLevel(1))\n@@ -453,10 +453,10 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                         for field in list.fields() {\n                             let field_name = field.name()?.to_string();\n \n-                            let l_name = &format!(\"l_{}\", field_name);\n+                            let l_name = &format!(\"l_{field_name}\");\n                             l_fields.push(gen_record_pat_field(&field_name, l_name));\n \n-                            let r_name = &format!(\"r_{}\", field_name);\n+                            let r_name = &format!(\"r_{field_name}\");\n                             r_fields.push(gen_record_pat_field(&field_name, r_name));\n \n                             let lhs = make::expr_path(make::ext::ident_path(l_name));\n@@ -484,12 +484,12 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                         let mut r_fields = vec![];\n \n                         for (i, _) in list.fields().enumerate() {\n-                            let field_name = format!(\"{}\", i);\n+                            let field_name = format!(\"{i}\");\n \n-                            let l_name = format!(\"l{}\", field_name);\n+                            let l_name = format!(\"l{field_name}\");\n                             l_fields.push(gen_tuple_field(&l_name));\n \n-                            let r_name = format!(\"r{}\", field_name);\n+                            let r_name = format!(\"r{field_name}\");\n                             r_fields.push(gen_tuple_field(&r_name));\n \n                             let lhs = make::expr_path(make::ext::ident_path(&l_name));\n@@ -548,7 +548,7 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n             Some(ast::FieldList::TupleFieldList(field_list)) => {\n                 let mut expr = None;\n                 for (i, _) in field_list.fields().enumerate() {\n-                    let idx = format!(\"{}\", i);\n+                    let idx = format!(\"{i}\");\n                     let lhs = make::expr_path(make::ext::ident_path(\"self\"));\n                     let lhs = make::expr_field(lhs, &idx);\n                     let rhs = make::expr_path(make::ext::ident_path(\"other\"));\n@@ -628,7 +628,7 @@ fn gen_partial_ord(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n             Some(ast::FieldList::TupleFieldList(field_list)) => {\n                 let mut exprs = vec![];\n                 for (i, _) in field_list.fields().enumerate() {\n-                    let idx = format!(\"{}\", i);\n+                    let idx = format!(\"{i}\");\n                     let lhs = make::expr_path(make::ext::ident_path(\"self\"));\n                     let lhs = make::expr_field(lhs, &idx);\n                     let rhs = make::expr_path(make::ext::ident_path(\"other\"));"}, {"sha": "b9bd47f7da504609b4c3b78947bd00bc9774164a", "filename": "crates/ide-completion/src/completions/postfix.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -69,10 +69,6 @@ pub(crate) fn complete_postfix(\n         }\n     }\n \n-    if !ctx.config.snippets.is_empty() {\n-        add_custom_postfix_completions(acc, ctx, &postfix_snippet, &receiver_text);\n-    }\n-\n     let try_enum = TryEnum::from_ty(&ctx.sema, &receiver_ty.strip_references());\n     if let Some(try_enum) = &try_enum {\n         match try_enum {\n@@ -140,6 +136,10 @@ pub(crate) fn complete_postfix(\n         None => return,\n     };\n \n+    if !ctx.config.snippets.is_empty() {\n+        add_custom_postfix_completions(acc, ctx, &postfix_snippet, &receiver_text);\n+    }\n+\n     match try_enum {\n         Some(try_enum) => match try_enum {\n             TryEnum::Result => {\n@@ -613,4 +613,25 @@ fn main() {\n             r#\"fn main() { log::error!(\"{}\", 2+2) }\"#,\n         );\n     }\n+\n+    #[test]\n+    fn postfix_custom_snippets_completion_for_references() {\n+        check_edit_with_config(\n+            CompletionConfig {\n+                snippets: vec![Snippet::new(\n+                    &[],\n+                    &[\"ok\".into()],\n+                    &[\"Ok(${receiver})\".into()],\n+                    \"\",\n+                    &[],\n+                    crate::SnippetScope::Expr,\n+                )\n+                .unwrap()],\n+                ..TEST_CONFIG\n+            },\n+            \"ok\",\n+            r#\"fn main() { &&42.$0 }\"#,\n+            r#\"fn main() { Ok(&&42) }\"#,\n+        );\n+    }\n }"}, {"sha": "aa5d7e9beb54f155c9b1753d1ca6283f11f0b99a", "filename": "crates/ide-db/src/search.rs", "status": "modified", "additions": 45, "deletions": 25, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide-db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsearch.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -446,33 +446,47 @@ impl<'a> FindUsages<'a> {\n             })\n         }\n \n-        // FIXME: There should be optimization potential here\n-        // Currently we try to descend everything we find which\n-        // means we call `Semantics::descend_into_macros` on\n-        // every textual hit. That function is notoriously\n-        // expensive even for things that do not get down mapped\n-        // into macros.\n+        let find_nodes = move |name: &str, node: &syntax::SyntaxNode, offset: TextSize| {\n+            node.token_at_offset(offset).find(|it| it.text() == name).map(|token| {\n+                // FIXME: There should be optimization potential here\n+                // Currently we try to descend everything we find which\n+                // means we call `Semantics::descend_into_macros` on\n+                // every textual hit. That function is notoriously\n+                // expensive even for things that do not get down mapped\n+                // into macros.\n+                sema.descend_into_macros(token).into_iter().filter_map(|it| it.parent())\n+            })\n+        };\n+\n         for (text, file_id, search_range) in scope_files(sema, &search_scope) {\n             let tree = Lazy::new(move || sema.parse(file_id).syntax().clone());\n \n             // Search for occurrences of the items name\n             for offset in match_indices(&text, finder, search_range) {\n-                for name in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n-                    if match name {\n-                        ast::NameLike::NameRef(name_ref) => self.found_name_ref(&name_ref, sink),\n-                        ast::NameLike::Name(name) => self.found_name(&name, sink),\n-                        ast::NameLike::Lifetime(lifetime) => self.found_lifetime(&lifetime, sink),\n-                    } {\n-                        return;\n+                if let Some(iter) = find_nodes(name, &tree, offset) {\n+                    for name in iter.filter_map(ast::NameLike::cast) {\n+                        if match name {\n+                            ast::NameLike::NameRef(name_ref) => {\n+                                self.found_name_ref(&name_ref, sink)\n+                            }\n+                            ast::NameLike::Name(name) => self.found_name(&name, sink),\n+                            ast::NameLike::Lifetime(lifetime) => {\n+                                self.found_lifetime(&lifetime, sink)\n+                            }\n+                        } {\n+                            return;\n+                        }\n                     }\n                 }\n             }\n             // Search for occurrences of the `Self` referring to our type\n             if let Some((self_ty, finder)) = &include_self_kw_refs {\n                 for offset in match_indices(&text, finder, search_range) {\n-                    for name_ref in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n-                        if self.found_self_ty_name_ref(self_ty, &name_ref, sink) {\n-                            return;\n+                    if let Some(iter) = find_nodes(\"Self\", &tree, offset) {\n+                        for name_ref in iter.filter_map(ast::NameRef::cast) {\n+                            if self.found_self_ty_name_ref(self_ty, &name_ref, sink) {\n+                                return;\n+                            }\n                         }\n                     }\n                 }\n@@ -493,17 +507,21 @@ impl<'a> FindUsages<'a> {\n                     let tree = Lazy::new(move || sema.parse(file_id).syntax().clone());\n \n                     for offset in match_indices(&text, finder, search_range) {\n-                        for name_ref in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n-                            if self.found_name_ref(&name_ref, sink) {\n-                                return;\n+                        if let Some(iter) = find_nodes(\"super\", &tree, offset) {\n+                            for name_ref in iter.filter_map(ast::NameRef::cast) {\n+                                if self.found_name_ref(&name_ref, sink) {\n+                                    return;\n+                                }\n                             }\n                         }\n                     }\n                     if let Some(finder) = &is_crate_root {\n                         for offset in match_indices(&text, finder, search_range) {\n-                            for name_ref in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n-                                if self.found_name_ref(&name_ref, sink) {\n-                                    return;\n+                            if let Some(iter) = find_nodes(\"crate\", &tree, offset) {\n+                                for name_ref in iter.filter_map(ast::NameRef::cast) {\n+                                    if self.found_name_ref(&name_ref, sink) {\n+                                        return;\n+                                    }\n                                 }\n                             }\n                         }\n@@ -544,9 +562,11 @@ impl<'a> FindUsages<'a> {\n                 let finder = &Finder::new(\"self\");\n \n                 for offset in match_indices(&text, finder, search_range) {\n-                    for name_ref in sema.find_nodes_at_offset_with_descend(&tree, offset) {\n-                        if self.found_self_module_name_ref(&name_ref, sink) {\n-                            return;\n+                    if let Some(iter) = find_nodes(\"self\", &tree, offset) {\n+                        for name_ref in iter.filter_map(ast::NameRef::cast) {\n+                            if self.found_self_module_name_ref(&name_ref, sink) {\n+                                return;\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "07d117aff10bd8fa9bbdc3dff5ee5aaed8e38153", "filename": "crates/ide/src/moniker.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide%2Fsrc%2Fmoniker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide%2Fsrc%2Fmoniker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fmoniker.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -73,8 +73,8 @@ impl MonikerResult {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PackageInformation {\n     pub name: String,\n-    pub repo: String,\n-    pub version: String,\n+    pub repo: Option<String>,\n+    pub version: Option<String>,\n }\n \n pub(crate) fn crate_for_file(db: &RootDatabase, file_id: FileId) -> Option<Crate> {\n@@ -256,18 +256,18 @@ pub(crate) fn def_to_moniker(\n             let (name, repo, version) = match krate.origin(db) {\n                 CrateOrigin::CratesIo { repo, name } => (\n                     name.unwrap_or(krate.display_name(db)?.canonical_name().to_string()),\n-                    repo?,\n-                    krate.version(db)?,\n+                    repo,\n+                    krate.version(db),\n                 ),\n                 CrateOrigin::Lang(lang) => (\n                     krate.display_name(db)?.canonical_name().to_string(),\n-                    \"https://github.com/rust-lang/rust/\".to_string(),\n-                    match lang {\n+                    Some(\"https://github.com/rust-lang/rust/\".to_string()),\n+                    Some(match lang {\n                         LangCrateOrigin::Other => {\n                             \"https://github.com/rust-lang/rust/library/\".into()\n                         }\n                         lang => format!(\"https://github.com/rust-lang/rust/library/{lang}\",),\n-                    },\n+                    }),\n                 ),\n             };\n             PackageInformation { name, repo, version }\n@@ -315,7 +315,7 @@ pub mod module {\n }\n \"#,\n             \"foo::module::func\",\n-            r#\"PackageInformation { name: \"foo\", repo: \"https://a.b/foo.git\", version: \"0.1.0\" }\"#,\n+            r#\"PackageInformation { name: \"foo\", repo: Some(\"https://a.b/foo.git\"), version: Some(\"0.1.0\") }\"#,\n             MonikerKind::Import,\n         );\n         check_moniker(\n@@ -331,7 +331,7 @@ pub mod module {\n }\n \"#,\n             \"foo::module::func\",\n-            r#\"PackageInformation { name: \"foo\", repo: \"https://a.b/foo.git\", version: \"0.1.0\" }\"#,\n+            r#\"PackageInformation { name: \"foo\", repo: Some(\"https://a.b/foo.git\"), version: Some(\"0.1.0\") }\"#,\n             MonikerKind::Export,\n         );\n     }\n@@ -348,7 +348,7 @@ pub mod module {\n }\n \"#,\n             \"foo::module::MyTrait::func\",\n-            r#\"PackageInformation { name: \"foo\", repo: \"https://a.b/foo.git\", version: \"0.1.0\" }\"#,\n+            r#\"PackageInformation { name: \"foo\", repo: Some(\"https://a.b/foo.git\"), version: Some(\"0.1.0\") }\"#,\n             MonikerKind::Export,\n         );\n     }\n@@ -365,7 +365,7 @@ pub mod module {\n }\n \"#,\n             \"foo::module::MyTrait::MY_CONST\",\n-            r#\"PackageInformation { name: \"foo\", repo: \"https://a.b/foo.git\", version: \"0.1.0\" }\"#,\n+            r#\"PackageInformation { name: \"foo\", repo: Some(\"https://a.b/foo.git\"), version: Some(\"0.1.0\") }\"#,\n             MonikerKind::Export,\n         );\n     }\n@@ -382,7 +382,7 @@ pub mod module {\n }\n \"#,\n             \"foo::module::MyTrait::MyType\",\n-            r#\"PackageInformation { name: \"foo\", repo: \"https://a.b/foo.git\", version: \"0.1.0\" }\"#,\n+            r#\"PackageInformation { name: \"foo\", repo: Some(\"https://a.b/foo.git\"), version: Some(\"0.1.0\") }\"#,\n             MonikerKind::Export,\n         );\n     }\n@@ -405,7 +405,7 @@ pub mod module {\n }\n \"#,\n             \"foo::module::MyStruct::MyTrait::func\",\n-            r#\"PackageInformation { name: \"foo\", repo: \"https://a.b/foo.git\", version: \"0.1.0\" }\"#,\n+            r#\"PackageInformation { name: \"foo\", repo: Some(\"https://a.b/foo.git\"), version: Some(\"0.1.0\") }\"#,\n             MonikerKind::Export,\n         );\n     }\n@@ -425,7 +425,7 @@ pub struct St {\n }\n \"#,\n             \"foo::St::a\",\n-            r#\"PackageInformation { name: \"foo\", repo: \"https://a.b/foo.git\", version: \"0.1.0\" }\"#,\n+            r#\"PackageInformation { name: \"foo\", repo: Some(\"https://a.b/foo.git\"), version: Some(\"0.1.0\") }\"#,\n             MonikerKind::Import,\n         );\n     }"}, {"sha": "b4df0437050f4d4de0be9b6886c1b0b4d66e00b4", "filename": "crates/ide/src/rename.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frename.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -40,7 +40,9 @@ pub(crate) fn prepare_rename(\n             if def.range_for_rename(&sema).is_none() {\n                 bail!(\"No references found at position\")\n             }\n-            let frange = sema.original_range(name_like.syntax());\n+            let Some(frange) = sema.original_range_opt(name_like.syntax()) else {\n+                bail!(\"No references found at position\");\n+            };\n \n             always!(\n                 frange.range.contains_inclusive(position.offset)\n@@ -51,7 +53,7 @@ pub(crate) fn prepare_rename(\n         .reduce(|acc, cur| match (acc, cur) {\n             // ensure all ranges are the same\n             (Ok(acc_inner), Ok(cur_inner)) if acc_inner == cur_inner => Ok(acc_inner),\n-            (Err(e), _) => Err(e),\n+            (e @ Err(_), _) | (_, e @ Err(_)) => e,\n             _ => bail!(\"inconsistent text range\"),\n         });\n \n@@ -2249,4 +2251,33 @@ fn foo((bar | bar | bar): ()) {\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn regression_13498() {\n+        check(\n+            \"Testing\",\n+            r\"\n+mod foo {\n+    pub struct Test$0;\n+}\n+\n+use foo::Test as Tester;\n+\n+fn main() {\n+    let t = Tester;\n+}\n+\",\n+            r\"\n+mod foo {\n+    pub struct Testing;\n+}\n+\n+use foo::Testing as Tester;\n+\n+fn main() {\n+    let t = Tester;\n+}\n+\",\n+        )\n+    }\n }"}, {"sha": "7486b20293a664b7fc048dc247332ff7118f8491", "filename": "crates/ide/src/signature_help.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsignature_help.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -149,7 +149,7 @@ fn signature_help_for_call(\n                 variant.name(db)\n             );\n         }\n-        hir::CallableKind::Closure | hir::CallableKind::FnPtr => (),\n+        hir::CallableKind::Closure | hir::CallableKind::FnPtr | hir::CallableKind::Other => (),\n     }\n \n     res.signature.push('(');\n@@ -189,9 +189,10 @@ fn signature_help_for_call(\n         hir::CallableKind::Function(func) if callable.return_type().contains_unknown() => {\n             render(func.ret_type(db))\n         }\n-        hir::CallableKind::Function(_) | hir::CallableKind::Closure | hir::CallableKind::FnPtr => {\n-            render(callable.return_type())\n-        }\n+        hir::CallableKind::Function(_)\n+        | hir::CallableKind::Closure\n+        | hir::CallableKind::FnPtr\n+        | hir::CallableKind::Other => render(callable.return_type()),\n         hir::CallableKind::TupleStruct(_) | hir::CallableKind::TupleEnumVariant(_) => {}\n     }\n     Some(res)\n@@ -387,10 +388,9 @@ mod tests {\n     }\n \n     fn check(ra_fixture: &str, expect: Expect) {\n-        // Implicitly add `Sized` to avoid noisy `T: ?Sized` in the results.\n         let fixture = format!(\n             r#\"\n-#[lang = \"sized\"] trait Sized {{}}\n+//- minicore: sized, fn\n {ra_fixture}\n             \"#\n         );\n@@ -1331,4 +1331,19 @@ fn f() {\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn help_for_generic_call() {\n+        check(\n+            r#\"\n+fn f<F: FnOnce(u8, u16) -> i32>(f: F) {\n+    f($0)\n+}\n+\"#,\n+            expect![[r#\"\n+                (u8, u16) -> i32\n+                 ^^  ---\n+            \"#]],\n+        );\n+    }\n }"}, {"sha": "c74ddabb17770392dbb576059d61231285d7f3bb", "filename": "crates/rust-analyzer/src/cli/lsif.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Flsif.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -106,12 +106,12 @@ impl LsifManager<'_> {\n                 manager: \"cargo\".to_string(),\n                 uri: None,\n                 content: None,\n-                repository: Some(lsif::Repository {\n-                    url: pi.repo,\n+                repository: pi.repo.map(|url| lsif::Repository {\n+                    url,\n                     r#type: \"git\".to_string(),\n                     commit_id: None,\n                 }),\n-                version: Some(pi.version),\n+                version: pi.version,\n             }));\n         self.package_map.insert(package_information, result_set_id);\n         result_set_id"}, {"sha": "ca7ba896b67cfc8bbbce7dca755bc520e3998beb", "filename": "crates/rust-analyzer/src/cli/scip.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -231,7 +231,7 @@ fn token_to_symbol(token: &TokenStaticData) -> Option<scip_types::Symbol> {\n         package: Some(scip_types::Package {\n             manager: \"cargo\".to_string(),\n             name: package_name,\n-            version,\n+            version: version.unwrap_or_else(|| \".\".to_string()),\n             ..Default::default()\n         })\n         .into(),\n@@ -415,4 +415,42 @@ pub mod module {\n             \"\",\n         );\n     }\n+\n+    #[test]\n+    fn global_symbol_for_pub_struct() {\n+        check_symbol(\n+            r#\"\n+    //- /lib.rs crate:main\n+    mod foo;\n+\n+    fn main() {\n+        let _bar = foo::Bar { i: 0 };\n+    }\n+    //- /foo.rs\n+    pub struct Bar$0 {\n+        pub i: i32,\n+    }\n+    \"#,\n+            \"rust-analyzer cargo main . foo/Bar#\",\n+        );\n+    }\n+\n+    #[test]\n+    fn global_symbol_for_pub_struct_reference() {\n+        check_symbol(\n+            r#\"\n+    //- /lib.rs crate:main\n+    mod foo;\n+\n+    fn main() {\n+        let _bar = foo::Bar$0 { i: 0 };\n+    }\n+    //- /foo.rs\n+    pub struct Bar {\n+        pub i: i32,\n+    }\n+    \"#,\n+            \"rust-analyzer cargo main . foo/Bar#\",\n+        );\n+    }\n }"}, {"sha": "4072ae585dbd913d036fbaad37a559db33af3117", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -56,6 +56,9 @@ mod patch_old_style;\n // parsing the old name.\n config_data! {\n     struct ConfigData {\n+        /// Whether to insert #[must_use] when generating `as_` methods\n+        /// for enum variants.\n+        assist_emitMustUse: bool               = \"false\",\n         /// Placeholder expression to use for missing expressions in assists.\n         assist_expressionFillDefault: ExprFillDefaultDef              = \"\\\"todo\\\"\",\n \n@@ -1276,6 +1279,7 @@ impl Config {\n             allowed: None,\n             insert_use: self.insert_use_config(),\n             prefer_no_std: self.data.imports_prefer_no_std,\n+            assist_emit_must_use: self.data.assist_emitMustUse,\n         }\n     }\n "}, {"sha": "8c26009add2bb04fbab8203720e32518213270bc", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -334,6 +334,10 @@ pub fn block_expr(\n     ast_from_text(&format!(\"fn f() {buf}\"))\n }\n \n+pub fn tail_only_block_expr(tail_expr: ast::Expr) -> ast::BlockExpr {\n+    ast_from_text(&format!(\"fn f() {{ {tail_expr} }}\"))\n+}\n+\n /// Ideally this function wouldn't exist since it involves manual indenting.\n /// It differs from `make::block_expr` by also supporting comments.\n ///\n@@ -656,6 +660,22 @@ pub fn let_stmt(\n     };\n     ast_from_text(&format!(\"fn f() {{ {text} }}\"))\n }\n+\n+pub fn let_else_stmt(\n+    pattern: ast::Pat,\n+    ty: Option<ast::Type>,\n+    expr: ast::Expr,\n+    diverging: ast::BlockExpr,\n+) -> ast::LetStmt {\n+    let mut text = String::new();\n+    format_to!(text, \"let {pattern}\");\n+    if let Some(ty) = ty {\n+        format_to!(text, \": {ty}\");\n+    }\n+    format_to!(text, \" = {expr} else {diverging};\");\n+    ast_from_text(&format!(\"fn f() {{ {text} }}\"))\n+}\n+\n pub fn expr_stmt(expr: ast::Expr) -> ast::ExprStmt {\n     let semi = if expr.is_block_like() { \"\" } else { \";\" };\n     ast_from_text(&format!(\"fn f() {{ {expr}{semi} (); }}\"))"}, {"sha": "56a68ef04379036f0dd95701cc1407d3ba318b58", "filename": "docs/dev/guide.md", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/docs%2Fdev%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/docs%2Fdev%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Fguide.md?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -338,7 +338,7 @@ The algorithm for building a tree of modules is to start with a crate root\n declarations and recursively process child modules. This is handled by the\n [`module_tree_query`], with two slight variations.\n \n-[`module_tree_query`]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/hir/src/module_tree.rs#L116-L123\n+[`module_tree_query`]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/module_tree.rs#L115-L133\n \n First, rust-analyzer builds a module tree for all crates in a source root\n simultaneously. The main reason for this is historical (`module_tree` predates\n@@ -361,7 +361,7 @@ the same, we don't have to re-execute [`module_tree_query`]. In fact, we only\n need to re-execute it when we add/remove new files or when we change mod\n declarations.\n \n-[`submodules_query`]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/hir/src/module_tree.rs#L41\n+[`submodules_query`]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/module_tree.rs#L41\n \n We store the resulting modules in a `Vec`-based indexed arena. The indices in\n the arena becomes module IDs. And this brings us to the next topic:\n@@ -389,8 +389,8 @@ integers which can \"intern\" a location and return an integer ID back. The salsa\n database we use includes a couple of [interners]. How to \"garbage collect\"\n unused locations is an open question.\n \n-[`LocationInterner`]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/base_db/src/loc2id.rs#L65-L71\n-[interners]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/hir/src/db.rs#L22-L23\n+[`LocationInterner`]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_db/src/loc2id.rs#L65-L71\n+[interners]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/db.rs#L22-L23\n \n For example, we use `LocationInterner` to assign IDs to definitions of functions,\n structs, enums, etc. The location, [`DefLoc`] contains two bits of information:\n@@ -404,7 +404,7 @@ using offsets, text ranges or syntax trees as keys and values for queries. What\n we do instead is we store \"index\" of the item among all of the items of a file\n (so, a positional based ID, but localized to a single file).\n \n-[`DefLoc`]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/hir/src/ids.rs#L127-L139\n+[`DefLoc`]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/ids.rs#L129-L139\n \n One thing we've glossed over for the time being is support for macros. We have\n only proof of concept handling of macros at the moment, but they are extremely\n@@ -437,7 +437,7 @@ terms of `HirFileId`! This does not recur infinitely though: any chain of\n `HirFileId`s bottoms out in `HirFileId::FileId`, that is, some source file\n actually written by the user.\n \n-[`HirFileId`]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/hir/src/ids.rs#L18-L125\n+[`HirFileId`]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/ids.rs#L31-L93\n \n Now that we understand how to identify a definition, in a source or in a\n macro-generated file, we can discuss name resolution a bit.\n@@ -451,14 +451,13 @@ each module into a position-independent representation which does not change if\n we modify bodies of the items. After that we [loop] resolving all imports until\n we've reached a fixed point.\n \n-[lower]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/hir/src/nameres/lower.rs#L113-L117\n-[loop]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/hir/src/nameres.rs#L186-L196\n-\n+[lower]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/nameres/lower.rs#L113-L147\n+[loop]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/nameres.rs#L186-L196\n And, given all our preparation with IDs and a position-independent representation,\n it is satisfying to [test] that typing inside function body does not invalidate\n name resolution results.\n \n-[test]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/hir/src/nameres/tests.rs#L376\n+[test]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/nameres/tests.rs#L376\n \n An interesting fact about name resolution is that it \"erases\" all of the\n intermediate paths from the imports: in the end, we know which items are defined\n@@ -493,10 +492,10 @@ there's an intermediate [projection query] which returns only the first\n position-independent part of the lowering. The result of this query is stable.\n Naturally, name resolution [uses] this stable projection query.\n \n-[imports]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/hir/src/nameres/lower.rs#L52-L59\n-[`SourceMap`]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/hir/src/nameres/lower.rs#L52-L59\n-[projection query]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/hir/src/nameres/lower.rs#L97-L103\n-[uses]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/hir/src/query_definitions.rs#L49\n+[imports]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/nameres/lower.rs#L52-L59\n+[`SourceMap`]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/nameres/lower.rs#L52-L59\n+[projection query]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/nameres/lower.rs#L97-L103\n+[uses]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/query_definitions.rs#L49\n \n ## Type inference\n \n@@ -518,10 +517,10 @@ construct a mapping from `ExprId`s to types.\n \n [@flodiebold]: https://github.com/flodiebold\n [#327]: https://github.com/rust-lang/rust-analyzer/pull/327\n-[lower the AST]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/hir/src/expr.rs\n-[positional ID]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/hir/src/expr.rs#L13-L15\n-[a source map]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/hir/src/expr.rs#L41-L44\n-[type inference]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/hir/src/ty.rs#L1208-L1223\n+[lower the AST]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/expr.rs\n+[positional ID]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/expr.rs#L13-L15\n+[a source map]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/expr.rs#L41-L44\n+[type inference]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_hir/src/ty.rs#L1208-L1223\n \n ## Tying it all together: completion\n \n@@ -563,10 +562,11 @@ the type to completion.\n [catch]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_lsp_server/src/main_loop.rs#L436-L442\n [the handler]: https://salsa.zulipchat.com/#narrow/stream/181542-rfcs.2Fsalsa-query-group/topic/design.20next.20steps\n [ask analysis for completion]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ide_api/src/lib.rs#L439-L444\n-[completion implementation]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ide_api/src/completion.rs#L46-L62\n-[`CompletionContext`]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ide_api/src/completion/completion_context.rs#L14-L37\n-[\"IntelliJ Trick\"]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ide_api/src/completion/completion_context.rs#L72-L75\n-[find an ancestor `fn` node]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ide_api/src/completion/completion_context.rs#L116-L120\n-[semantic model]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ide_api/src/completion/completion_context.rs#L123\n-[series of independent completion routines]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ide_api/src/completion.rs#L52-L59\n-[`complete_dot`]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ide_api/src/completion/complete_dot.rs#L6-L22\n+[ask analysis for completion]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/lib.rs#L439-L444\n+[completion implementation]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/completion.rs#L46-L62\n+[`CompletionContext`]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/completion/completion_context.rs#L14-L37\n+[\"IntelliJ Trick\"]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/completion/completion_context.rs#L72-L75\n+[find an ancestor `fn` node]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/completion/completion_context.rs#L116-L120\n+[semantic model]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/completion/completion_context.rs#L123\n+[series of independent completion routines]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/completion.rs#L52-L59\n+[`complete_dot`]: https://github.com/rust-lang/rust-analyzer/blob/guide-2019-01/crates/ra_ide_api/src/completion/complete_dot.rs#L6-L22"}, {"sha": "36794efe42726126311af4cfcdb3e2500ca1c7ec", "filename": "docs/user/generated_config.adoc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/docs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/docs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_config.adoc?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -1,3 +1,9 @@\n+[[rust-analyzer.assist.emitMustUse]]rust-analyzer.assist.emitMustUse (default: `false`)::\n++\n+--\n+Whether to insert #[must_use] when generating `as_` methods\n+for enum variants.\n+--\n [[rust-analyzer.assist.expressionFillDefault]]rust-analyzer.assist.expressionFillDefault (default: `\"todo\"`)::\n +\n --"}, {"sha": "49500e390a50246bb90b4da3a53544610abd7908", "filename": "docs/user/manual.adoc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/docs%2Fuser%2Fmanual.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/docs%2Fuser%2Fmanual.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fmanual.adoc?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -487,6 +487,12 @@ https://docs.helix-editor.com/[Helix] supports LSP by default.\n However, it won't install `rust-analyzer` automatically.\n You can follow instructions for installing <<rust-analyzer-language-server-binary,`rust-analyzer` binary>>.\n \n+=== Crates\n+\n+There is a package named `ra_ap_rust_analyzer` available on https://crates.io/crates/ra_ap_rust-analyzer[crates.io], for someone who wants to use it programmatically.\n+\n+For more details, see https://github.com/rust-lang/rust-analyzer/blob/master/.github/workflows/publish.yml[the publish workflow].\n+\n == Troubleshooting\n \n Start with looking at the rust-analyzer version."}, {"sha": "0b25564e28d3763240ad5652f5f82aef0e428179", "filename": "editors/code/package-lock.json", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/editors%2Fcode%2Fpackage-lock.json", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/editors%2Fcode%2Fpackage-lock.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage-lock.json?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -23,7 +23,7 @@\n                 \"esbuild\": \"^0.14.48\",\n                 \"eslint\": \"^8.19.0\",\n                 \"eslint-config-prettier\": \"^8.5.0\",\n-                \"ovsx\": \"^0.5.1\",\n+                \"ovsx\": \"^0.5.2\",\n                 \"prettier\": \"^2.7.1\",\n                 \"tslib\": \"^2.4.0\",\n                 \"typescript\": \"^4.7.4\",\n@@ -2874,9 +2874,9 @@\n             }\n         },\n         \"node_modules/ovsx\": {\n-            \"version\": \"0.5.1\",\n-            \"resolved\": \"https://registry.npmjs.org/ovsx/-/ovsx-0.5.1.tgz\",\n-            \"integrity\": \"sha512-3OWq0l7DuVHi2bd2aQe5+QVQlFIqvrcw3/2vGXL404L6Tr+R4QHtzfnYYghv8CCa85xJHjU0RhcaC7pyXkAUbg==\",\n+            \"version\": \"0.5.2\",\n+            \"resolved\": \"https://registry.npmjs.org/ovsx/-/ovsx-0.5.2.tgz\",\n+            \"integrity\": \"sha512-UbLultRCk46WddeA0Cly4hoRhzBJUiLgbIEViXlgOvV54LbsppClDkMLoCevUUBHoiNdMX2NuiSgURAEXgCZdw==\",\n             \"dev\": true,\n             \"dependencies\": {\n                 \"commander\": \"^6.1.0\",\n@@ -5958,9 +5958,9 @@\n             }\n         },\n         \"ovsx\": {\n-            \"version\": \"0.5.1\",\n-            \"resolved\": \"https://registry.npmjs.org/ovsx/-/ovsx-0.5.1.tgz\",\n-            \"integrity\": \"sha512-3OWq0l7DuVHi2bd2aQe5+QVQlFIqvrcw3/2vGXL404L6Tr+R4QHtzfnYYghv8CCa85xJHjU0RhcaC7pyXkAUbg==\",\n+            \"version\": \"0.5.2\",\n+            \"resolved\": \"https://registry.npmjs.org/ovsx/-/ovsx-0.5.2.tgz\",\n+            \"integrity\": \"sha512-UbLultRCk46WddeA0Cly4hoRhzBJUiLgbIEViXlgOvV54LbsppClDkMLoCevUUBHoiNdMX2NuiSgURAEXgCZdw==\",\n             \"dev\": true,\n             \"requires\": {\n                 \"commander\": \"^6.1.0\","}, {"sha": "1a97a9c0893752f5ddfe357086ca0c8326ac61db", "filename": "editors/code/package.json", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -49,7 +49,7 @@\n         \"esbuild\": \"^0.14.48\",\n         \"eslint\": \"^8.19.0\",\n         \"eslint-config-prettier\": \"^8.5.0\",\n-        \"ovsx\": \"^0.5.1\",\n+        \"ovsx\": \"^0.5.2\",\n         \"prettier\": \"^2.7.1\",\n         \"tslib\": \"^2.4.0\",\n         \"typescript\": \"^4.7.4\",\n@@ -100,22 +100,32 @@\n             {\n                 \"command\": \"rust-analyzer.syntaxTree\",\n                 \"title\": \"Show Syntax Tree\",\n-                \"category\": \"rust-analyzer\"\n+                \"category\": \"rust-analyzer (debug command)\"\n             },\n             {\n                 \"command\": \"rust-analyzer.viewHir\",\n                 \"title\": \"View Hir\",\n-                \"category\": \"rust-analyzer\"\n+                \"category\": \"rust-analyzer (debug command)\"\n             },\n             {\n                 \"command\": \"rust-analyzer.viewFileText\",\n                 \"title\": \"View File Text (as seen by the server)\",\n-                \"category\": \"rust-analyzer\"\n+                \"category\": \"rust-analyzer (debug command)\"\n             },\n             {\n                 \"command\": \"rust-analyzer.viewItemTree\",\n                 \"title\": \"Debug ItemTree\",\n-                \"category\": \"rust-analyzer\"\n+                \"category\": \"rust-analyzer (debug command)\"\n+            },\n+            {\n+                \"command\": \"rust-analyzer.shuffleCrateGraph\",\n+                \"title\": \"Shuffle Crate Graph\",\n+                \"category\": \"rust-analyzer (debug command)\"\n+            },\n+            {\n+                \"command\": \"rust-analyzer.memoryUsage\",\n+                \"title\": \"Memory Usage (Clears Database)\",\n+                \"category\": \"rust-analyzer (debug command)\"\n             },\n             {\n                 \"command\": \"rust-analyzer.viewCrateGraph\",\n@@ -172,16 +182,6 @@\n                 \"title\": \"Status\",\n                 \"category\": \"rust-analyzer\"\n             },\n-            {\n-                \"command\": \"rust-analyzer.memoryUsage\",\n-                \"title\": \"Memory Usage (Clears Database)\",\n-                \"category\": \"rust-analyzer\"\n-            },\n-            {\n-                \"command\": \"rust-analyzer.shuffleCrateGraph\",\n-                \"title\": \"Shuffle Crate Graph\",\n-                \"category\": \"rust-analyzer\"\n-            },\n             {\n                 \"command\": \"rust-analyzer.reloadWorkspace\",\n                 \"title\": \"Reload workspace\",\n@@ -397,6 +397,11 @@\n                     \"type\": \"boolean\"\n                 },\n                 \"$generated-start\": {},\n+                \"rust-analyzer.assist.emitMustUse\": {\n+                    \"markdownDescription\": \"Whether to insert #[must_use] when generating `as_` methods\\nfor enum variants.\",\n+                    \"default\": false,\n+                    \"type\": \"boolean\"\n+                },\n                 \"rust-analyzer.assist.expressionFillDefault\": {\n                     \"markdownDescription\": \"Placeholder expression to use for missing expressions in assists.\",\n                     \"default\": \"todo\","}, {"sha": "a910e012b73499449e8b9f37077a9030f0fc7a05", "filename": "triagebot.toml", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ae43043aabf5d85ef07548560f9be77e997d9d75/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ae43043aabf5d85ef07548560f9be77e997d9d75/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=ae43043aabf5d85ef07548560f9be77e997d9d75", "patch": "@@ -1 +1,11 @@\n [assign]\n+\n+[shortcut]\n+\n+[relabel]\n+allow-unauthenticated = [\n+    \"S-*\",\n+]\n+\n+[autolabel.\"S-waiting-on-review\"]\n+new_pr = true"}]}