{"sha": "a489c33bebaee645efa8be0c9455bed89ef6dd41", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0ODljMzNiZWJhZWU2NDVlZmE4YmUwYzk0NTViZWQ4OWVmNmRkNDE=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-07T18:38:25Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-16T04:19:00Z"}, "message": "Take sys/vxworks/ext/* from sys/unix instead.", "tree": {"sha": "4623700a26fb6e4b883669177746f7d8b4f50022", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4623700a26fb6e4b883669177746f7d8b4f50022"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a489c33bebaee645efa8be0c9455bed89ef6dd41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a489c33bebaee645efa8be0c9455bed89ef6dd41", "html_url": "https://github.com/rust-lang/rust/commit/a489c33bebaee645efa8be0c9455bed89ef6dd41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a489c33bebaee645efa8be0c9455bed89ef6dd41/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c909ff957752104e1c52d20d7e0e98cf50781a25", "url": "https://api.github.com/repos/rust-lang/rust/commits/c909ff957752104e1c52d20d7e0e98cf50781a25", "html_url": "https://github.com/rust-lang/rust/commit/c909ff957752104e1c52d20d7e0e98cf50781a25"}], "stats": {"total": 1322, "additions": 1, "deletions": 1321}, "files": [{"sha": "76b34a6b5d84aa64a0a9a429e56218fc59931752", "filename": "library/std/src/sys/vxworks/ext/ffi.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c909ff957752104e1c52d20d7e0e98cf50781a25/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c909ff957752104e1c52d20d7e0e98cf50781a25/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fffi.rs?ref=c909ff957752104e1c52d20d7e0e98cf50781a25", "patch": "@@ -1,38 +0,0 @@\n-//! Unix-specific extension to the primitives in the `std::ffi` module\n-//!\n-//! # Examples\n-//!\n-//! ```\n-//! use std::ffi::OsString;\n-//! use std::os::unix::ffi::OsStringExt;\n-//!\n-//! let bytes = b\"foo\".to_vec();\n-//!\n-//! // OsStringExt::from_vec\n-//! let os_string = OsString::from_vec(bytes);\n-//! assert_eq!(os_string.to_str(), Some(\"foo\"));\n-//!\n-//! // OsStringExt::into_vec\n-//! let bytes = os_string.into_vec();\n-//! assert_eq!(bytes, b\"foo\");\n-//! ```\n-//!\n-//! ```\n-//! use std::ffi::OsStr;\n-//! use std::os::unix::ffi::OsStrExt;\n-//!\n-//! let bytes = b\"foo\";\n-//!\n-//! // OsStrExt::from_bytes\n-//! let os_str = OsStr::from_bytes(bytes);\n-//! assert_eq!(os_str.to_str(), Some(\"foo\"));\n-//!\n-//! // OsStrExt::as_bytes\n-//! let bytes = os_str.as_bytes();\n-//! assert_eq!(bytes, b\"foo\");\n-//! ```\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use crate::sys_common::os_str_bytes::*;"}, {"sha": "68dc21b806c0fd70cb0be6555939bf9dc8b3a3bb", "filename": "library/std/src/sys/vxworks/ext/fs.rs", "status": "removed", "additions": 0, "deletions": 817, "changes": 817, "blob_url": "https://github.com/rust-lang/rust/blob/c909ff957752104e1c52d20d7e0e98cf50781a25/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c909ff957752104e1c52d20d7e0e98cf50781a25/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Ffs.rs?ref=c909ff957752104e1c52d20d7e0e98cf50781a25", "patch": "@@ -1,817 +0,0 @@\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-use crate::fs::{self, Permissions};\n-use crate::io;\n-use crate::path::Path;\n-use crate::sys;\n-use crate::sys::platform::fs::MetadataExt as UnixMetadataExt;\n-use crate::sys_common::{AsInner, AsInnerMut, FromInner};\n-\n-/// Unix-specific extensions to [`fs::File`].\n-#[stable(feature = \"file_offset\", since = \"1.15.0\")]\n-pub trait FileExt {\n-    /// Reads a number of bytes starting from a given offset.\n-    ///\n-    /// Returns the number of bytes read.\n-    ///\n-    /// The offset is relative to the start of the file and thus independent\n-    /// from the current cursor.\n-    ///\n-    /// The current file cursor is not affected by this function.\n-    ///\n-    /// Note that similar to [`File::read`], it is not an error to return with a\n-    /// short read.\n-    ///\n-    /// [`File::read`]: fs::File::read\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::fs::File;\n-    /// use std::os::unix::prelude::FileExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let mut buf = [0u8; 8];\n-    ///     let file = File::open(\"foo.txt\")?;\n-    ///\n-    ///     // We now read 8 bytes from the offset 10.\n-    ///     let num_bytes_read = file.read_at(&mut buf, 10)?;\n-    ///     println!(\"read {} bytes: {:?}\", num_bytes_read, buf);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n-    fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize>;\n-\n-    /// Reads the exact number of byte required to fill `buf` from the given offset.\n-    ///\n-    /// The offset is relative to the start of the file and thus independent\n-    /// from the current cursor.\n-    ///\n-    /// The current file cursor is not affected by this function.\n-    ///\n-    /// Similar to [`Read::read_exact`] but uses [`read_at`] instead of `read`.\n-    ///\n-    /// [`Read::read_exact`]: io::Read::read_exact\n-    /// [`read_at`]: FileExt::read_at\n-    ///\n-    /// # Errors\n-    ///\n-    /// If this function encounters an error of the kind\n-    /// [`ErrorKind::Interrupted`] then the error is ignored and the operation\n-    /// will continue.\n-    ///\n-    /// If this function encounters an \"end of file\" before completely filling\n-    /// the buffer, it returns an error of the kind [`ErrorKind::UnexpectedEof`].\n-    /// The contents of `buf` are unspecified in this case.\n-    ///\n-    /// If any other read error is encountered then this function immediately\n-    /// returns. The contents of `buf` are unspecified in this case.\n-    ///\n-    /// If this function returns an error, it is unspecified how many bytes it\n-    /// has read, but it will never read more than would be necessary to\n-    /// completely fill the buffer.\n-    ///\n-    /// [`ErrorKind::Interrupted`]: io::ErrorKind::Interrupted\n-    /// [`ErrorKind::UnexpectedEof`]: io::ErrorKind::UnexpectedEof\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(rw_exact_all_at)]\n-    /// use std::io;\n-    /// use std::fs::File;\n-    /// use std::os::unix::prelude::FileExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let mut buf = [0u8; 8];\n-    ///     let file = File::open(\"foo.txt\")?;\n-    ///\n-    ///     // We now read exactly 8 bytes from the offset 10.\n-    ///     file.read_exact_at(&mut buf, 10)?;\n-    ///     println!(\"read {} bytes: {:?}\", buf.len(), buf);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rw_exact_all_at\", since = \"1.33.0\")]\n-    fn read_exact_at(&self, mut buf: &mut [u8], mut offset: u64) -> io::Result<()> {\n-        while !buf.is_empty() {\n-            match self.read_at(buf, offset) {\n-                Ok(0) => break,\n-                Ok(n) => {\n-                    let tmp = buf;\n-                    buf = &mut tmp[n..];\n-                    offset += n as u64;\n-                }\n-                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n-                Err(e) => return Err(e),\n-            }\n-        }\n-        if !buf.is_empty() {\n-            Err(io::Error::new(io::ErrorKind::UnexpectedEof, \"failed to fill whole buffer\"))\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    /// Writes a number of bytes starting from a given offset.\n-    ///\n-    /// Returns the number of bytes written.\n-    ///\n-    /// The offset is relative to the start of the file and thus independent\n-    /// from the current cursor.\n-    ///\n-    /// The current file cursor is not affected by this function.\n-    ///\n-    /// When writing beyond the end of the file, the file is appropriately\n-    /// extended and the intermediate bytes are initialized with the value 0.\n-    ///\n-    /// Note that similar to [`File::write`], it is not an error to return a\n-    /// short write.\n-    ///\n-    /// [`File::write`]: fs::File::write\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::File;\n-    /// use std::io;\n-    /// use std::os::unix::prelude::FileExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let file = File::open(\"foo.txt\")?;\n-    ///\n-    ///     // We now write at the offset 10.\n-    ///     file.write_at(b\"sushi\", 10)?;\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n-    fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize>;\n-\n-    /// Attempts to write an entire buffer starting from a given offset.\n-    ///\n-    /// The offset is relative to the start of the file and thus independent\n-    /// from the current cursor.\n-    ///\n-    /// The current file cursor is not affected by this function.\n-    ///\n-    /// This method will continuously call [`write_at`] until there is no more data\n-    /// to be written or an error of non-[`ErrorKind::Interrupted`] kind is\n-    /// returned. This method will not return until the entire buffer has been\n-    /// successfully written or such an error occurs. The first error that is\n-    /// not of [`ErrorKind::Interrupted`] kind generated from this method will be\n-    /// returned.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function will return the first error of\n-    /// non-[`ErrorKind::Interrupted`] kind that [`write_at`] returns.\n-    ///\n-    /// [`ErrorKind::Interrupted`]: io::ErrorKind::Interrupted\n-    /// [`write_at`]: FileExt::write_at\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(rw_exact_all_at)]\n-    /// use std::fs::File;\n-    /// use std::io;\n-    /// use std::os::unix::prelude::FileExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let file = File::open(\"foo.txt\")?;\n-    ///\n-    ///     // We now write at the offset 10.\n-    ///     file.write_all_at(b\"sushi\", 10)?;\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rw_exact_all_at\", since = \"1.33.0\")]\n-    fn write_all_at(&self, mut buf: &[u8], mut offset: u64) -> io::Result<()> {\n-        while !buf.is_empty() {\n-            match self.write_at(buf, offset) {\n-                Ok(0) => {\n-                    return Err(io::Error::new(\n-                        io::ErrorKind::WriteZero,\n-                        \"failed to write whole buffer\",\n-                    ));\n-                }\n-                Ok(n) => {\n-                    buf = &buf[n..];\n-                    offset += n as u64\n-                }\n-                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n-                Err(e) => return Err(e),\n-            }\n-        }\n-        Ok(())\n-    }\n-}\n-\n-#[stable(feature = \"file_offset\", since = \"1.15.0\")]\n-impl FileExt for fs::File {\n-    fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n-        self.as_inner().read_at(buf, offset)\n-    }\n-    fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n-        self.as_inner().write_at(buf, offset)\n-    }\n-}\n-\n-/// Unix-specific extensions to [`fs::Permissions`].\n-#[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n-pub trait PermissionsExt {\n-    /// Returns the underlying raw `st_mode` bits that contain the standard\n-    /// Unix permissions for this file.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::File;\n-    /// use std::os::unix::fs::PermissionsExt;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let f = File::create(\"foo.txt\")?;\n-    ///     let metadata = f.metadata()?;\n-    ///     let permissions = metadata.permissions();\n-    ///\n-    ///     println!(\"permissions: {}\", permissions.mode());\n-    ///     Ok(()) }\n-    /// ```\n-    #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n-    fn mode(&self) -> u32;\n-\n-    /// Sets the underlying raw bits for this set of permissions.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::File;\n-    /// use std::os::unix::fs::PermissionsExt;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let f = File::create(\"foo.txt\")?;\n-    ///     let metadata = f.metadata()?;\n-    ///     let mut permissions = metadata.permissions();\n-    ///\n-    ///     permissions.set_mode(0o644); // Read/write for owner and read for others.\n-    ///     assert_eq!(permissions.mode(), 0o644);\n-    ///     Ok(()) }\n-    /// ```\n-    #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n-    fn set_mode(&mut self, mode: u32);\n-\n-    /// Creates a new instance of `Permissions` from the given set of Unix\n-    /// permission bits.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::fs::Permissions;\n-    /// use std::os::unix::fs::PermissionsExt;\n-    ///\n-    /// // Read/write for owner and read for others.\n-    /// let permissions = Permissions::from_mode(0o644);\n-    /// assert_eq!(permissions.mode(), 0o644);\n-    /// ```\n-    #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n-    fn from_mode(mode: u32) -> Self;\n-}\n-\n-#[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n-impl PermissionsExt for Permissions {\n-    fn mode(&self) -> u32 {\n-        self.as_inner().mode()\n-    }\n-\n-    fn set_mode(&mut self, mode: u32) {\n-        *self = Permissions::from_inner(FromInner::from_inner(mode));\n-    }\n-\n-    fn from_mode(mode: u32) -> Permissions {\n-        Permissions::from_inner(FromInner::from_inner(mode))\n-    }\n-}\n-\n-/// Unix-specific extensions to [`fs::OpenOptions`].\n-#[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n-pub trait OpenOptionsExt {\n-    /// Sets the mode bits that a new file will be created with.\n-    ///\n-    /// If a new file is created as part of an `OpenOptions::open` call then this\n-    /// specified `mode` will be used as the permission bits for the new file.\n-    /// If no `mode` is set, the default of `0o666` will be used.\n-    /// The operating system masks out bits with the system's `umask`, to produce\n-    /// the final permissions.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::OpenOptions;\n-    /// use std::os::unix::fs::OpenOptionsExt;\n-    ///\n-    /// # fn main() {\n-    /// let mut options = OpenOptions::new();\n-    /// options.mode(0o644); // Give read/write for owner and read for others.\n-    /// let file = options.open(\"foo.txt\");\n-    /// # }\n-    /// ```\n-    #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n-    fn mode(&mut self, mode: u32) -> &mut Self;\n-\n-    /// Pass custom flags to the `flags` argument of `open`.\n-    ///\n-    /// The bits that define the access mode are masked out with `O_ACCMODE`, to\n-    /// ensure they do not interfere with the access mode set by Rusts options.\n-    ///\n-    /// Custom flags can only set flags, not remove flags set by Rusts options.\n-    /// This options overwrites any previously set custom flags.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// # #![feature(libc)]\n-    /// extern crate libc;\n-    /// use std::fs::OpenOptions;\n-    /// use std::os::unix::fs::OpenOptionsExt;\n-    ///\n-    /// # fn main() {\n-    /// let mut options = OpenOptions::new();\n-    /// options.write(true);\n-    /// if cfg!(unix) {\n-    ///     options.custom_flags(libc::O_NOFOLLOW);\n-    /// }\n-    /// let file = options.open(\"foo.txt\");\n-    /// # }\n-    /// ```\n-    #[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n-    fn custom_flags(&mut self, flags: i32) -> &mut Self;\n-}\n-\n-/*#[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n-impl OpenOptionsExt for OpenOptions {\n-    fn mode(&mut self, mode: u32) -> &mut OpenOptions {\n-        self.as_inner_mut().mode(mode); self\n-    }\n-\n-    fn custom_flags(&mut self, flags: i32) -> &mut OpenOptions {\n-        self.as_inner_mut().custom_flags(flags); self\n-    }\n-}\n-*/\n-\n-/// Unix-specific extensions to [`fs::Metadata`].\n-#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-pub trait MetadataExt {\n-    /// Returns the ID of the device containing the file.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let dev_id = meta.dev();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn dev(&self) -> u64;\n-    /// Returns the inode number.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let inode = meta.ino();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn ino(&self) -> u64;\n-    /// Returns the rights applied to this file.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let mode = meta.mode();\n-    ///     let user_has_write_access      = mode & 0o200;\n-    ///     let user_has_read_write_access = mode & 0o600;\n-    ///     let group_has_read_access      = mode & 0o040;\n-    ///     let others_have_exec_access    = mode & 0o001;\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn mode(&self) -> u32;\n-    /// Returns the number of hard links pointing to this file.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let nb_hard_links = meta.nlink();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn nlink(&self) -> u64;\n-    /// Returns the user ID of the owner of this file.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let user_id = meta.uid();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn uid(&self) -> u32;\n-    /// Returns the group ID of the owner of this file.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let group_id = meta.gid();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn gid(&self) -> u32;\n-    /// Returns the device ID of this file (if it is a special one).\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let device_id = meta.rdev();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn rdev(&self) -> u64;\n-    /// Returns the total size of this file in bytes.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let file_size = meta.size();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn size(&self) -> u64;\n-    /// Returns the time of the last access to the file.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let last_access_time = meta.atime();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn atime(&self) -> i64;\n-    /// Returns the time of the last access to the file in nanoseconds.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let nano_last_access_time = meta.atime_nsec();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn mtime(&self) -> i64;\n-    /// Returns the time of the last modification of the file in nanoseconds.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let nano_last_modification_time = meta.mtime_nsec();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn ctime(&self) -> i64;\n-    /// Returns the time of the last status change of the file in nanoseconds.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let nano_last_status_change_time = meta.ctime_nsec();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn blksize(&self) -> u64;\n-    /// Returns the number of blocks allocated to the file, in 512-byte units.\n-    ///\n-    /// Please note that this may be smaller than `st_size / 512` when the file has holes.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let blocks = meta.blocks();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn blocks(&self) -> u64;\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn attrib(&self) -> u8;\n-}\n-\n-#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-impl MetadataExt for fs::Metadata {\n-    fn dev(&self) -> u64 {\n-        self.st_dev()\n-    }\n-    fn ino(&self) -> u64 {\n-        self.st_ino()\n-    }\n-    fn mode(&self) -> u32 {\n-        self.st_mode()\n-    }\n-    fn nlink(&self) -> u64 {\n-        self.st_nlink()\n-    }\n-    fn uid(&self) -> u32 {\n-        self.st_uid()\n-    }\n-    fn gid(&self) -> u32 {\n-        self.st_gid()\n-    }\n-    fn rdev(&self) -> u64 {\n-        self.st_rdev()\n-    }\n-    fn size(&self) -> u64 {\n-        self.st_size()\n-    }\n-    fn atime(&self) -> i64 {\n-        self.st_atime()\n-    }\n-    fn mtime(&self) -> i64 {\n-        self.st_mtime()\n-    }\n-    fn ctime(&self) -> i64 {\n-        self.st_ctime()\n-    }\n-    fn blksize(&self) -> u64 {\n-        self.st_blksize()\n-    }\n-    fn blocks(&self) -> u64 {\n-        self.st_blocks()\n-    }\n-    fn attrib(&self) -> u8 {\n-        self.st_attrib()\n-    }\n-}\n-\n-/// Unix-specific extensions for [`fs::FileType`].\n-///\n-/// Adds support for special Unix file types such as block/character devices,\n-/// pipes, and sockets.\n-#[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n-pub trait FileTypeExt {\n-    /// Returns whether this file type is a block device.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::FileTypeExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"block_device_file\")?;\n-    ///     let file_type = meta.file_type();\n-    ///     assert!(file_type.is_block_device());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n-    fn is_block_device(&self) -> bool;\n-    /// Returns whether this file type is a char device.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::FileTypeExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"char_device_file\")?;\n-    ///     let file_type = meta.file_type();\n-    ///     assert!(file_type.is_char_device());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n-    fn is_char_device(&self) -> bool;\n-    /// Returns whether this file type is a fifo.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::FileTypeExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"fifo_file\")?;\n-    ///     let file_type = meta.file_type();\n-    ///     assert!(file_type.is_fifo());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n-    fn is_fifo(&self) -> bool;\n-    /// Returns whether this file type is a socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::FileTypeExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"unix.socket\")?;\n-    ///     let file_type = meta.file_type();\n-    ///     assert!(file_type.is_socket());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n-    fn is_socket(&self) -> bool;\n-}\n-\n-#[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n-impl FileTypeExt for fs::FileType {\n-    fn is_block_device(&self) -> bool {\n-        self.as_inner().is(libc::S_IFBLK)\n-    }\n-    fn is_char_device(&self) -> bool {\n-        self.as_inner().is(libc::S_IFCHR)\n-    }\n-    fn is_fifo(&self) -> bool {\n-        self.as_inner().is(libc::S_IFIFO)\n-    }\n-    fn is_socket(&self) -> bool {\n-        self.as_inner().is(libc::S_IFSOCK)\n-    }\n-}\n-\n-/// Unix-specific extension methods for [`fs::DirEntry`].\n-#[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n-pub trait DirEntryExt {\n-    /// Returns the underlying `d_ino` field in the contained `dirent`\n-    /// structure.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::fs;\n-    /// use std::os::unix::fs::DirEntryExt;\n-    ///\n-    /// if let Ok(entries) = fs::read_dir(\".\") {\n-    ///     for entry in entries {\n-    ///         if let Ok(entry) = entry {\n-    ///             // Here, `entry` is a `DirEntry`.\n-    ///             println!(\"{:?}: {}\", entry.file_name(), entry.ino());\n-    ///         }\n-    ///     }\n-    /// }\n-    /// ```\n-    #[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n-    fn ino(&self) -> u64;\n-}\n-\n-#[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n-impl DirEntryExt for fs::DirEntry {\n-    fn ino(&self) -> u64 {\n-        self.as_inner().ino()\n-    }\n-}\n-\n-/// Creates a new symbolic link on the filesystem.\n-///\n-/// The `dst` path will be a symbolic link pointing to the `src` path.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::os::unix::fs;\n-///\n-/// fn main() -> std::io::Result<()> {\n-///     fs::symlink(\"a.txt\", \"b.txt\")?;\n-///     Ok(())\n-/// }\n-/// ```\n-#[stable(feature = \"symlink\", since = \"1.1.0\")]\n-pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n-    sys::fs::symlink(src.as_ref(), dst.as_ref())\n-}\n-\n-/// Unix-specific extensions to [`fs::DirBuilder`].\n-#[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n-pub trait DirBuilderExt {\n-    /// Sets the mode to create new directories with. This option defaults to\n-    /// 0o777.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::DirBuilder;\n-    /// use std::os::unix::fs::DirBuilderExt;\n-    ///\n-    /// let mut builder = DirBuilder::new();\n-    /// builder.mode(0o755);\n-    /// ```\n-    #[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n-    fn mode(&mut self, mode: u32) -> &mut Self;\n-}\n-\n-#[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n-impl DirBuilderExt for fs::DirBuilder {\n-    fn mode(&mut self, mode: u32) -> &mut fs::DirBuilder {\n-        self.as_inner_mut().set_mode(mode);\n-        self\n-    }\n-}"}, {"sha": "8b5a2d12af74f74a29b880766aea4ca21d1f7e74", "filename": "library/std/src/sys/vxworks/ext/io.rs", "status": "removed", "additions": 0, "deletions": 208, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/c909ff957752104e1c52d20d7e0e98cf50781a25/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c909ff957752104e1c52d20d7e0e98cf50781a25/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fio.rs?ref=c909ff957752104e1c52d20d7e0e98cf50781a25", "patch": "@@ -1,208 +0,0 @@\n-//! Unix-specific extensions to general I/O primitives\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-use crate::fs;\n-use crate::io;\n-use crate::net;\n-use crate::os::raw;\n-use crate::sys;\n-use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n-\n-/// Raw file descriptors.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub type RawFd = raw::c_int;\n-\n-/// A trait to extract the raw unix file descriptor from an underlying\n-/// object.\n-///\n-/// This is only available on unix platforms and must be imported in order\n-/// to call the method. Windows platforms have a corresponding `AsRawHandle`\n-/// and `AsRawSocket` set of traits.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait AsRawFd {\n-    /// Extracts the raw file descriptor.\n-    ///\n-    /// This method does **not** pass ownership of the raw file descriptor\n-    /// to the caller. The descriptor is only guaranteed to be valid while\n-    /// the original object has not yet been destroyed.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn as_raw_fd(&self) -> RawFd;\n-}\n-\n-/// A trait to express the ability to construct an object from a raw file\n-/// descriptor.\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-pub trait FromRawFd {\n-    /// Constructs a new instance of `Self` from the given raw file\n-    /// descriptor.\n-    ///\n-    /// This function **consumes ownership** of the specified file\n-    /// descriptor. The returned object will take responsibility for closing\n-    /// it when the object goes out of scope.\n-    ///\n-    /// This function is also unsafe as the primitives currently returned\n-    /// have the contract that they are the sole owner of the file\n-    /// descriptor they are wrapping. Usage of this function could\n-    /// accidentally allow violating this contract which can cause memory\n-    /// unsafety in code that relies on it being true.\n-    #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-    unsafe fn from_raw_fd(fd: RawFd) -> Self;\n-}\n-\n-/// A trait to express the ability to consume an object and acquire ownership of\n-/// its raw file descriptor.\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-pub trait IntoRawFd {\n-    /// Consumes this object, returning the raw underlying file descriptor.\n-    ///\n-    /// This function **transfers ownership** of the underlying file descriptor\n-    /// to the caller. Callers are then the unique owners of the file descriptor\n-    /// and must close the descriptor once it's no longer needed.\n-    #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-    fn into_raw_fd(self) -> RawFd;\n-}\n-\n-#[stable(feature = \"raw_fd_reflexive_traits\", since = \"1.48.0\")]\n-impl AsRawFd for RawFd {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self\n-    }\n-}\n-#[stable(feature = \"raw_fd_reflexive_traits\", since = \"1.48.0\")]\n-impl IntoRawFd for RawFd {\n-    fn into_raw_fd(self) -> RawFd {\n-        self\n-    }\n-}\n-#[stable(feature = \"raw_fd_reflexive_traits\", since = \"1.48.0\")]\n-impl FromRawFd for RawFd {\n-    unsafe fn from_raw_fd(fd: RawFd) -> RawFd {\n-        fd\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for fs::File {\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.as_inner().fd().raw()\n-    }\n-}\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for fs::File {\n-    unsafe fn from_raw_fd(fd: RawFd) -> fs::File {\n-        fs::File::from_inner(sys::fs::File::from_inner(fd))\n-    }\n-}\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for fs::File {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_fd().into_raw()\n-    }\n-}\n-\n-#[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n-impl AsRawFd for io::Stdin {\n-    fn as_raw_fd(&self) -> RawFd {\n-        libc::STDIN_FILENO\n-    }\n-}\n-\n-#[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n-impl AsRawFd for io::Stdout {\n-    fn as_raw_fd(&self) -> RawFd {\n-        libc::STDOUT_FILENO\n-    }\n-}\n-\n-#[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n-impl AsRawFd for io::Stderr {\n-    fn as_raw_fd(&self) -> RawFd {\n-        libc::STDERR_FILENO\n-    }\n-}\n-\n-#[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n-impl<'a> AsRawFd for io::StdinLock<'a> {\n-    fn as_raw_fd(&self) -> RawFd {\n-        libc::STDIN_FILENO\n-    }\n-}\n-\n-#[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n-impl<'a> AsRawFd for io::StdoutLock<'a> {\n-    fn as_raw_fd(&self) -> RawFd {\n-        libc::STDOUT_FILENO\n-    }\n-}\n-\n-#[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n-impl<'a> AsRawFd for io::StderrLock<'a> {\n-    fn as_raw_fd(&self) -> RawFd {\n-        libc::STDERR_FILENO\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for net::TcpStream {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.as_inner().socket().as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for net::TcpListener {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.as_inner().socket().as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for net::UdpSocket {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.as_inner().socket().as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for net::TcpStream {\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n-        let socket = sys::net::Socket::from_inner(fd);\n-        net::TcpStream::from_inner(sys_common::net::TcpStream::from_inner(socket))\n-    }\n-}\n-\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for net::TcpListener {\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n-        let socket = sys::net::Socket::from_inner(fd);\n-        net::TcpListener::from_inner(sys_common::net::TcpListener::from_inner(socket))\n-    }\n-}\n-\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for net::UdpSocket {\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket {\n-        let socket = sys::net::Socket::from_inner(fd);\n-        net::UdpSocket::from_inner(sys_common::net::UdpSocket::from_inner(socket))\n-    }\n-}\n-\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for net::TcpStream {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_socket().into_inner()\n-    }\n-}\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for net::TcpListener {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_socket().into_inner()\n-    }\n-}\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for net::UdpSocket {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_socket().into_inner()\n-    }\n-}"}, {"sha": "8fa9bd9d1e27f0da8911671268c44e6d08cd2099", "filename": "library/std/src/sys/vxworks/ext/mod.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c909ff957752104e1c52d20d7e0e98cf50781a25/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c909ff957752104e1c52d20d7e0e98cf50781a25/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fmod.rs?ref=c909ff957752104e1c52d20d7e0e98cf50781a25", "patch": "@@ -1,24 +0,0 @@\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![allow(missing_docs)]\n-\n-pub mod ffi;\n-pub mod fs;\n-pub mod io;\n-pub mod process;\n-pub mod raw;\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub mod prelude {\n-    #[doc(no_inline)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::ffi::{OsStrExt, OsStringExt};\n-    #[doc(no_inline)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::fs::{FileTypeExt, MetadataExt, OpenOptionsExt, PermissionsExt};\n-    #[doc(no_inline)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n-    #[doc(no_inline)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::process::ExitStatusExt;\n-}"}, {"sha": "3ffa5be1b3bf1c64eafd74e09694cb4723822ae5", "filename": "library/std/src/sys/vxworks/ext/process.rs", "status": "removed", "additions": 0, "deletions": 229, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/c909ff957752104e1c52d20d7e0e98cf50781a25/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c909ff957752104e1c52d20d7e0e98cf50781a25/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fprocess.rs?ref=c909ff957752104e1c52d20d7e0e98cf50781a25", "patch": "@@ -1,229 +0,0 @@\n-//! Unix-specific extensions to primitives in the `std::process` module.\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-use crate::ffi::OsStr;\n-use crate::io;\n-use crate::process;\n-use crate::sys;\n-use crate::sys::vxworks::ext::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n-use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n-\n-/// Unix-specific extensions to the [`process::Command`] builder.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait CommandExt {\n-    /// Sets the child process's user ID. This translates to a\n-    /// `setuid` call in the child process. Failure in the `setuid`\n-    /// call will cause the spawn to fail.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn uid(&mut self, id: u16) -> &mut process::Command;\n-\n-    /// Similar to `uid`, but sets the group ID of the child process. This has\n-    /// the same semantics as the `uid` field.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn gid(&mut self, id: u16) -> &mut process::Command;\n-\n-    /// Schedules a closure to be run just before the `exec` function is\n-    /// invoked.\n-    ///\n-    /// The closure is allowed to return an I/O error whose OS error code will\n-    /// be communicated back to the parent and returned as an error from when\n-    /// the spawn was requested.\n-    ///\n-    /// Multiple closures can be registered and they will be called in order of\n-    /// their registration. If a closure returns `Err` then no further closures\n-    /// will be called and the spawn operation will immediately return with a\n-    /// failure.\n-    ///\n-    /// # Notes and Safety\n-    ///\n-    /// This closure will be run in the context of the child process after a\n-    /// `fork`. This primarily means that any modifications made to memory on\n-    /// behalf of this closure will **not** be visible to the parent process.\n-    /// This is often a very constrained environment where normal operations\n-    /// like `malloc` or acquiring a mutex are not guaranteed to work (due to\n-    /// other threads perhaps still running when the `fork` was run).\n-    ///\n-    /// This also means that all resources such as file descriptors and\n-    /// memory-mapped regions got duplicated. It is your responsibility to make\n-    /// sure that the closure does not violate library invariants by making\n-    /// invalid use of these duplicates.\n-    ///\n-    /// When this closure is run, aspects such as the stdio file descriptors and\n-    /// working directory have successfully been changed, so output to these\n-    /// locations may not appear where intended.\n-    #[stable(feature = \"process_pre_exec\", since = \"1.34.0\")]\n-    unsafe fn pre_exec<F>(&mut self, f: F) -> &mut process::Command\n-    where\n-        F: FnMut() -> io::Result<()> + Send + Sync + 'static;\n-\n-    /// Schedules a closure to be run just before the `exec` function is\n-    /// invoked.\n-    ///\n-    /// This method is stable and usable, but it should be unsafe. To fix\n-    /// that, it got deprecated in favor of the unsafe [`pre_exec`].\n-    ///\n-    /// [`pre_exec`]: CommandExt::pre_exec\n-    #[stable(feature = \"process_exec\", since = \"1.15.0\")]\n-    #[rustc_deprecated(since = \"1.37.0\", reason = \"should be unsafe, use `pre_exec` instead\")]\n-    fn before_exec<F>(&mut self, f: F) -> &mut process::Command\n-    where\n-        F: FnMut() -> io::Result<()> + Send + Sync + 'static,\n-    {\n-        unsafe { self.pre_exec(f) }\n-    }\n-\n-    /// Performs all the required setup by this `Command`, followed by calling\n-    /// the `execvp` syscall.\n-    ///\n-    /// On success this function will not return, and otherwise it will return\n-    /// an error indicating why the exec (or another part of the setup of the\n-    /// `Command`) failed.\n-    ///\n-    /// `exec` not returning has the same implications as calling\n-    /// [`process::exit`] \u2013 no destructors on the current stack or any other\n-    /// thread\u2019s stack will be run. Therefore, it is recommended to only call\n-    /// `exec` at a point where it is fine to not run any destructors. Note,\n-    /// that the `execvp` syscall independently guarantees that all memory is\n-    /// freed and all file descriptors with the `CLOEXEC` option (set by default\n-    /// on all file descriptors opened by the standard library) are closed.\n-    ///\n-    /// This function, unlike `spawn`, will **not** `fork` the process to create\n-    /// a new child. Like spawn, however, the default behavior for the stdio\n-    /// descriptors will be to inherited from the current process.\n-    ///\n-    ///\n-    /// # Notes\n-    ///\n-    /// The process may be in a \"broken state\" if this function returns in\n-    /// error. For example the working directory, environment variables, signal\n-    /// handling settings, various user/group information, or aspects of stdio\n-    /// file descriptors may have changed. If a \"transactional spawn\" is\n-    /// required to gracefully handle errors it is recommended to use the\n-    /// cross-platform `spawn` instead.\n-    #[stable(feature = \"process_exec2\", since = \"1.9.0\")]\n-    fn exec(&mut self) -> io::Error;\n-\n-    /// Set executable argument\n-    ///\n-    /// Set the first process argument, `argv[0]`, to something other than the\n-    /// default executable path.\n-    #[stable(feature = \"process_set_argv0\", since = \"1.45.0\")]\n-    fn arg0<S>(&mut self, arg: S) -> &mut process::Command\n-    where\n-        S: AsRef<OsStr>;\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl CommandExt for process::Command {\n-    fn uid(&mut self, id: u16) -> &mut process::Command {\n-        self.as_inner_mut().uid(id);\n-        self\n-    }\n-\n-    fn gid(&mut self, id: u16) -> &mut process::Command {\n-        self.as_inner_mut().gid(id);\n-        self\n-    }\n-\n-    unsafe fn pre_exec<F>(&mut self, f: F) -> &mut process::Command\n-    where\n-        F: FnMut() -> io::Result<()> + Send + Sync + 'static,\n-    {\n-        self.as_inner_mut().pre_exec(Box::new(f));\n-        self\n-    }\n-\n-    fn exec(&mut self) -> io::Error {\n-        self.as_inner_mut().exec(sys::process::Stdio::Inherit)\n-    }\n-\n-    fn arg0<S>(&mut self, arg: S) -> &mut process::Command\n-    where\n-        S: AsRef<OsStr>,\n-    {\n-        self.as_inner_mut().set_arg_0(arg.as_ref());\n-        self\n-    }\n-}\n-\n-/// Unix-specific extensions to [`process::ExitStatus`].\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait ExitStatusExt {\n-    /// Creates a new `ExitStatus` from the raw underlying `i32` return value of\n-    /// a process.\n-    #[stable(feature = \"exit_status_from\", since = \"1.12.0\")]\n-    fn from_raw(raw: i32) -> Self;\n-\n-    /// If the process was terminated by a signal, returns that signal.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn signal(&self) -> Option<i32>;\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl ExitStatusExt for process::ExitStatus {\n-    fn from_raw(raw: i32) -> Self {\n-        process::ExitStatus::from_inner(From::from(raw))\n-    }\n-\n-    fn signal(&self) -> Option<i32> {\n-        self.as_inner().signal()\n-    }\n-}\n-\n-#[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n-impl FromRawFd for process::Stdio {\n-    unsafe fn from_raw_fd(fd: RawFd) -> process::Stdio {\n-        let fd = sys::fd::FileDesc::new(fd);\n-        let io = sys::process::Stdio::Fd(fd);\n-        process::Stdio::from_inner(io)\n-    }\n-}\n-\n-#[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n-impl AsRawFd for process::ChildStdin {\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.as_inner().fd().raw()\n-    }\n-}\n-\n-#[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n-impl AsRawFd for process::ChildStdout {\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.as_inner().fd().raw()\n-    }\n-}\n-\n-#[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n-impl AsRawFd for process::ChildStderr {\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.as_inner().fd().raw()\n-    }\n-}\n-\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for process::ChildStdin {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_fd().into_raw()\n-    }\n-}\n-\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for process::ChildStdout {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_fd().into_raw()\n-    }\n-}\n-\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for process::ChildStderr {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_fd().into_raw()\n-    }\n-}\n-\n-/// Returns the OS-assigned process identifier associated with this process's parent.\n-#[stable(feature = \"unix_ppid\", since = \"1.27.0\")]\n-pub fn parent_id() -> u32 {\n-    crate::sys::os::getppid()\n-}"}, {"sha": "1f134f4e2d1bddd7bc427099fbf562b158a0717a", "filename": "library/std/src/sys/vxworks/ext/raw.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c909ff957752104e1c52d20d7e0e98cf50781a25/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c909ff957752104e1c52d20d7e0e98cf50781a25/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fraw.rs?ref=c909ff957752104e1c52d20d7e0e98cf50781a25", "patch": "@@ -1,5 +0,0 @@\n-#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-\n-#[doc(inline)]\n-#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n-pub use crate::sys::platform::raw::pthread_t;"}, {"sha": "1354c0802e85e3c446b18653910b9ee68512c91a", "filename": "library/std/src/sys/vxworks/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a489c33bebaee645efa8be0c9455bed89ef6dd41/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a489c33bebaee645efa8be0c9455bed89ef6dd41/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmod.rs?ref=a489c33bebaee645efa8be0c9455bed89ef6dd41", "patch": "@@ -18,6 +18,7 @@ pub mod cmath;\n #[path = \"../unix/condvar.rs\"]\n pub mod condvar;\n pub mod env;\n+#[path = \"../unix/ext/mod.rs\"]\n pub mod ext;\n pub mod fd;\n pub mod fs;"}]}