{"sha": "6805b016efdfcd99e706003fab1336df73f6811b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4MDViMDE2ZWZkZmNkOTllNzA2MDAzZmFiMTMzNmRmNzNmNjgxMWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-01T16:01:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-01T16:01:22Z"}, "message": "Auto merge of #46338 - michaelwoerister:lazy-diagnostics, r=nikomatsakis\n\nincr.comp.: Load cached diagnostics lazily and allow more things in the cache.\n\nThis PR implements makes two changes:\n1. Diagnostics are loaded lazily from the incr. comp. cache now. This turned out to be necessary for correctness because diagnostics contain `Span` values and deserializing those requires that the source file they point to is still around in the current compilation session. Obviously this isn't always the case. Loading them lazily allows for never touching diagnostics that are not valid anymore.\n2. The compiler can now deal with there being no cache entry for a given query invocation. Before, all query results of a cacheable query were always expected to be present in the cache. Now, the compiler can fall back to re-computing the result if there is no cache entry found. This allows for caching things that we cannot force from dep-node (like the `symbol_name` query). In such a case we'll just have a \"best effort\" caching strategy.\n\n~~This PR is based on https://github.com/rust-lang/rust/pull/46301 (=first 2 commits), so please don't merge until that has landed. The rest of the commits are ready for review though.~~\n\nr? @nikomatsakis", "tree": {"sha": "c629f376a62d81699c34474832c66e6e7c21df95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c629f376a62d81699c34474832c66e6e7c21df95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6805b016efdfcd99e706003fab1336df73f6811b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6805b016efdfcd99e706003fab1336df73f6811b", "html_url": "https://github.com/rust-lang/rust/commit/6805b016efdfcd99e706003fab1336df73f6811b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6805b016efdfcd99e706003fab1336df73f6811b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3ed21272d5f50c37c09f2a7f06c40f56b6ac298", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3ed21272d5f50c37c09f2a7f06c40f56b6ac298", "html_url": "https://github.com/rust-lang/rust/commit/e3ed21272d5f50c37c09f2a7f06c40f56b6ac298"}, {"sha": "966eead9ec4d95f887d1eb5d0fc4b72b5779e952", "url": "https://api.github.com/repos/rust-lang/rust/commits/966eead9ec4d95f887d1eb5d0fc4b72b5779e952", "html_url": "https://github.com/rust-lang/rust/commit/966eead9ec4d95f887d1eb5d0fc4b72b5779e952"}], "stats": {"total": 702, "additions": 476, "deletions": 226}, "files": [{"sha": "96d6b0f79cffffaf74641a18a7689b187c3cfc33", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6805b016efdfcd99e706003fab1336df73f6811b/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6805b016efdfcd99e706003fab1336df73f6811b/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=6805b016efdfcd99e706003fab1336df73f6811b", "patch": "@@ -461,10 +461,10 @@ impl DepGraph {\n         self.data.as_ref().and_then(|data| data.colors.borrow().get(dep_node).cloned())\n     }\n \n-    pub fn try_mark_green(&self,\n-                          tcx: TyCtxt,\n-                          dep_node: &DepNode)\n-                          -> Option<DepNodeIndex> {\n+    pub fn try_mark_green<'tcx>(&self,\n+                                tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+                                dep_node: &DepNode)\n+                                -> Option<DepNodeIndex> {\n         debug!(\"try_mark_green({:?}) - BEGIN\", dep_node);\n         let data = self.data.as_ref().unwrap();\n \n@@ -621,7 +621,7 @@ impl DepGraph {\n         // ... emitting any stored diagnostic ...\n         {\n             let diagnostics = tcx.on_disk_query_result_cache\n-                                 .load_diagnostics(prev_dep_node_index);\n+                                 .load_diagnostics(tcx, prev_dep_node_index);\n \n             if diagnostics.len() > 0 {\n                 let handle = tcx.sess.diagnostic();"}, {"sha": "d95b825b9e562782a07e30ac539f01a03b79cf12", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 33, "deletions": 44, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/6805b016efdfcd99e706003fab1336df73f6811b/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6805b016efdfcd99e706003fab1336df73f6811b/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=6805b016efdfcd99e706003fab1336df73f6811b", "patch": "@@ -28,7 +28,7 @@ use syntax::attr;\n use syntax::codemap::CodeMap;\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::symbol::Symbol;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHashingContextProvider,\n                                            StableHasher, StableHasherResult,\n@@ -362,64 +362,53 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Span {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        use syntax_pos::Pos;\n+        const TAG_VALID_SPAN: u8 = 0;\n+        const TAG_INVALID_SPAN: u8 = 1;\n+        const TAG_EXPANSION: u8 = 0;\n+        const TAG_NO_EXPANSION: u8 = 1;\n \n         if !hcx.hash_spans {\n             return\n         }\n \n+        if *self == DUMMY_SP {\n+            return std_hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n+        }\n+\n         // If this is not an empty or invalid span, we want to hash the last\n         // position that belongs to it, as opposed to hashing the first\n         // position past it.\n         let span = self.data();\n-        let span_hi = if span.hi > span.lo {\n-            // We might end up in the middle of a multibyte character here,\n-            // but that's OK, since we are not trying to decode anything at\n-            // this position.\n-            span.hi - ::syntax_pos::BytePos(1)\n-        } else {\n-            span.hi\n-        };\n \n-        {\n-            let loc1 = hcx.codemap().byte_pos_to_line_and_col(span.lo);\n-            let loc1 = loc1.as_ref()\n-                           .map(|&(ref fm, line, col)| (&fm.name[..], line, col.to_usize()))\n-                           .unwrap_or((\"???\", 0, 0));\n-\n-            let loc2 = hcx.codemap().byte_pos_to_line_and_col(span_hi);\n-            let loc2 = loc2.as_ref()\n-                           .map(|&(ref fm, line, col)| (&fm.name[..], line, col.to_usize()))\n-                           .unwrap_or((\"???\", 0, 0));\n-\n-            if loc1.0 == loc2.0 {\n-                std_hash::Hash::hash(&0u8, hasher);\n-\n-                std_hash::Hash::hash(loc1.0, hasher);\n-                std_hash::Hash::hash(&loc1.1, hasher);\n-                std_hash::Hash::hash(&loc1.2, hasher);\n-\n-                // Do not hash the file name twice\n-                std_hash::Hash::hash(&loc2.1, hasher);\n-                std_hash::Hash::hash(&loc2.2, hasher);\n-            } else {\n-                std_hash::Hash::hash(&1u8, hasher);\n-\n-                std_hash::Hash::hash(loc1.0, hasher);\n-                std_hash::Hash::hash(&loc1.1, hasher);\n-                std_hash::Hash::hash(&loc1.2, hasher);\n-\n-                std_hash::Hash::hash(loc2.0, hasher);\n-                std_hash::Hash::hash(&loc2.1, hasher);\n-                std_hash::Hash::hash(&loc2.2, hasher);\n+        if span.hi < span.lo {\n+            return std_hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n+        }\n+\n+        let (file_lo, line_lo, col_lo) = match hcx.codemap()\n+                                                  .byte_pos_to_line_and_col(span.lo) {\n+            Some(pos) => pos,\n+            None => {\n+                return std_hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n             }\n+        };\n+\n+        if !file_lo.contains(span.hi) {\n+            return std_hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n         }\n \n+        let len = span.hi - span.lo;\n+\n+        std_hash::Hash::hash(&TAG_VALID_SPAN, hasher);\n+        std_hash::Hash::hash(&file_lo.name, hasher);\n+        std_hash::Hash::hash(&line_lo, hasher);\n+        std_hash::Hash::hash(&col_lo, hasher);\n+        std_hash::Hash::hash(&len, hasher);\n+\n         if span.ctxt == SyntaxContext::empty() {\n-            0u8.hash_stable(hcx, hasher);\n+            TAG_NO_EXPANSION.hash_stable(hcx, hasher);\n         } else {\n-            1u8.hash_stable(hcx, hasher);\n-            self.source_callsite().hash_stable(hcx, hasher);\n+            TAG_EXPANSION.hash_stable(hcx, hasher);\n+            span.ctxt.outer().expn_info().hash_stable(hcx, hasher);\n         }\n     }\n }"}, {"sha": "c414349c8ffd620970f47bde358b80dc4809302d", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6805b016efdfcd99e706003fab1336df73f6811b/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6805b016efdfcd99e706003fab1336df73f6811b/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=6805b016efdfcd99e706003fab1336df73f6811b", "patch": "@@ -347,6 +347,30 @@ impl_stable_hash_for!(enum ::syntax::ast::MetaItemKind {\n     NameValue(lit)\n });\n \n+impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnInfo {\n+    call_site,\n+    callee\n+});\n+\n+impl_stable_hash_for!(struct ::syntax_pos::hygiene::NameAndSpan {\n+    format,\n+    allow_internal_unstable,\n+    allow_internal_unsafe,\n+    span\n+});\n+\n+impl_stable_hash_for!(enum ::syntax_pos::hygiene::ExpnFormat {\n+    MacroAttribute(sym),\n+    MacroBang(sym),\n+    CompilerDesugaring(kind)\n+});\n+\n+impl_stable_hash_for!(enum ::syntax_pos::hygiene::CompilerDesugaringKind {\n+    BackArrow,\n+    DotFill,\n+    QuestionMark\n+});\n+\n impl<'gcx> HashStable<StableHashingContext<'gcx>> for FileMap {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'gcx>,"}, {"sha": "0ab769d4fe307bbbdab59614408cd8c974b8e3c7", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6805b016efdfcd99e706003fab1336df73f6811b/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6805b016efdfcd99e706003fab1336df73f6811b/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=6805b016efdfcd99e706003fab1336df73f6811b", "patch": "@@ -1235,7 +1235,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                            -> Result<(), E::Error>\n         where E: ty::codec::TyEncoder\n     {\n-        self.on_disk_query_result_cache.serialize(self.global_tcx(), self.cstore, encoder)\n+        self.on_disk_query_result_cache.serialize(self.global_tcx(), encoder)\n     }\n \n }"}, {"sha": "496284ad9c9f4b8cb340dfb6b85ee936fe651801", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6805b016efdfcd99e706003fab1336df73f6811b/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6805b016efdfcd99e706003fab1336df73f6811b/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=6805b016efdfcd99e706003fab1336df73f6811b", "patch": "@@ -31,9 +31,9 @@ pub(super) trait QueryDescription<'tcx>: QueryConfig {\n         false\n     }\n \n-    fn load_from_disk<'a>(_: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn try_load_from_disk(_: TyCtxt<'_, 'tcx, 'tcx>,\n                           _: SerializedDepNodeIndex)\n-                          -> Self::Value {\n+                          -> Option<Self::Value> {\n         bug!(\"QueryDescription::load_from_disk() called for unsupport query.\")\n     }\n }\n@@ -556,12 +556,14 @@ impl<'tcx> QueryDescription<'tcx> for queries::typeck_tables_of<'tcx> {\n         def_id.is_local()\n     }\n \n-    fn load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn try_load_from_disk(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n                           id: SerializedDepNodeIndex)\n-                          -> Self::Value {\n-        let typeck_tables: ty::TypeckTables<'tcx> = tcx.on_disk_query_result_cache\n-                                                       .load_query_result(tcx, id);\n-        tcx.alloc_tables(typeck_tables)\n+                          -> Option<Self::Value> {\n+        let typeck_tables: Option<ty::TypeckTables<'tcx>> = tcx\n+            .on_disk_query_result_cache\n+            .try_load_query_result(tcx, id);\n+\n+        typeck_tables.map(|tables| tcx.alloc_tables(tables))\n     }\n }\n "}, {"sha": "8dc9b0877a01c2ec82c9e03e7695df7781be4ef9", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 342, "deletions": 160, "changes": 502, "blob_url": "https://github.com/rust-lang/rust/blob/6805b016efdfcd99e706003fab1336df73f6811b/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6805b016efdfcd99e706003fab1336df73f6811b/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=6805b016efdfcd99e706003fab1336df73f6811b", "patch": "@@ -14,7 +14,7 @@ use hir;\n use hir::def_id::{CrateNum, DefIndex, DefId, LocalDefId,\n                   RESERVED_FOR_INCR_COMP_CACHE, LOCAL_CRATE};\n use hir::map::definitions::DefPathHash;\n-use middle::cstore::CrateStore;\n+use ich::CachingCodemapView;\n use mir;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n@@ -23,23 +23,28 @@ use rustc_serialize::{Decodable, Decoder, Encodable, Encoder, opaque,\n                       UseSpecializedDecodable, UseSpecializedEncodable};\n use session::{CrateDisambiguator, Session};\n use std::cell::RefCell;\n-use std::collections::BTreeMap;\n use std::mem;\n+use std::rc::Rc;\n use syntax::ast::NodeId;\n use syntax::codemap::{CodeMap, StableFilemapId};\n-use syntax_pos::{BytePos, Span, NO_EXPANSION, DUMMY_SP};\n+use syntax_pos::{BytePos, Span, DUMMY_SP, FileMap};\n+use syntax_pos::hygiene::{Mark, SyntaxContext, ExpnInfo};\n use ty;\n use ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n use ty::context::TyCtxt;\n \n-// Some magic values used for verifying that encoding and decoding. These are\n-// basically random numbers.\n-const PREV_DIAGNOSTICS_TAG: u64 = 0x1234_5678_A1A1_A1A1;\n-const QUERY_RESULT_INDEX_TAG: u64 = 0x1234_5678_C3C3_C3C3;\n+const TAG_FILE_FOOTER: u128 = 0xC0FFEE_C0FFEE_C0FFEE_C0FFEE_C0FFEE;\n \n const TAG_CLEAR_CROSS_CRATE_CLEAR: u8 = 0;\n const TAG_CLEAR_CROSS_CRATE_SET: u8 = 1;\n \n+const TAG_NO_EXPANSION_INFO: u8 = 0;\n+const TAG_EXPANSION_INFO_SHORTHAND: u8 = 1;\n+const TAG_EXPANSION_INFO_INLINE: u8 = 2;\n+\n+const TAG_VALID_SPAN: u8 = 0;\n+const TAG_INVALID_SPAN: u8 = 1;\n+\n /// `OnDiskCache` provides an interface to incr. comp. data cached from the\n /// previous compilation session. This data will eventually include the results\n /// of a few selected queries (like `typeck_tables_of` and `mir_optimized`) and\n@@ -49,158 +54,144 @@ pub struct OnDiskCache<'sess> {\n     // The complete cache data in serialized form.\n     serialized_data: Vec<u8>,\n \n-    // The diagnostics emitted during the previous compilation session.\n-    prev_diagnostics: FxHashMap<SerializedDepNodeIndex, Vec<Diagnostic>>,\n-\n     // This field collects all Diagnostics emitted during the current\n     // compilation session.\n     current_diagnostics: RefCell<FxHashMap<DepNodeIndex, Vec<Diagnostic>>>,\n \n     prev_cnums: Vec<(u32, String, CrateDisambiguator)>,\n     cnum_map: RefCell<Option<IndexVec<CrateNum, Option<CrateNum>>>>,\n \n-    prev_filemap_starts: BTreeMap<BytePos, StableFilemapId>,\n     codemap: &'sess CodeMap,\n+    file_index_to_stable_id: FxHashMap<FileMapIndex, StableFilemapId>,\n+\n+    // These two fields caches that are populated lazily during decoding.\n+    file_index_to_file: RefCell<FxHashMap<FileMapIndex, Rc<FileMap>>>,\n+    synthetic_expansion_infos: RefCell<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n \n     // A map from dep-node to the position of the cached query result in\n     // `serialized_data`.\n-    query_result_index: FxHashMap<SerializedDepNodeIndex, usize>,\n+    query_result_index: FxHashMap<SerializedDepNodeIndex, AbsoluteBytePos>,\n+\n+    // A map from dep-node to the position of any associated diagnostics in\n+    // `serialized_data`.\n+    prev_diagnostics_index: FxHashMap<SerializedDepNodeIndex, AbsoluteBytePos>,\n }\n \n // This type is used only for (de-)serialization.\n #[derive(RustcEncodable, RustcDecodable)]\n-struct Header {\n-    prev_filemap_starts: BTreeMap<BytePos, StableFilemapId>,\n+struct Footer {\n+    file_index_to_stable_id: FxHashMap<FileMapIndex, StableFilemapId>,\n     prev_cnums: Vec<(u32, String, CrateDisambiguator)>,\n+    query_result_index: EncodedQueryResultIndex,\n+    diagnostics_index: EncodedQueryResultIndex,\n }\n \n-type EncodedPrevDiagnostics = Vec<(SerializedDepNodeIndex, Vec<Diagnostic>)>;\n-type EncodedQueryResultIndex = Vec<(SerializedDepNodeIndex, usize)>;\n+type EncodedQueryResultIndex = Vec<(SerializedDepNodeIndex, AbsoluteBytePos)>;\n+type EncodedDiagnosticsIndex = Vec<(SerializedDepNodeIndex, AbsoluteBytePos)>;\n+type EncodedDiagnostics = Vec<Diagnostic>;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+struct FileMapIndex(u32);\n+\n+#[derive(Copy, Clone, Debug, Hash, Eq, PartialEq, RustcEncodable, RustcDecodable)]\n+struct AbsoluteBytePos(u32);\n+\n+impl AbsoluteBytePos {\n+    fn new(pos: usize) -> AbsoluteBytePos {\n+        debug_assert!(pos <= ::std::u32::MAX as usize);\n+        AbsoluteBytePos(pos as u32)\n+    }\n+\n+    fn to_usize(self) -> usize {\n+        self.0 as usize\n+    }\n+}\n \n impl<'sess> OnDiskCache<'sess> {\n     /// Create a new OnDiskCache instance from the serialized data in `data`.\n     pub fn new(sess: &'sess Session, data: Vec<u8>, start_pos: usize) -> OnDiskCache<'sess> {\n         debug_assert!(sess.opts.incremental.is_some());\n \n-        // Decode the header\n-        let (header, post_header_pos) = {\n+        // Wrapping in a scope so we can borrow `data`\n+        let footer: Footer = {\n             let mut decoder = opaque::Decoder::new(&data[..], start_pos);\n-            let header = Header::decode(&mut decoder)\n-                .expect(\"Error while trying to decode incr. comp. cache header.\");\n-            (header, decoder.position())\n-        };\n \n-        let (prev_diagnostics, query_result_index) = {\n-            let mut decoder = CacheDecoder {\n-                tcx: None,\n-                opaque: opaque::Decoder::new(&data[..], post_header_pos),\n-                codemap: sess.codemap(),\n-                prev_filemap_starts: &header.prev_filemap_starts,\n-                cnum_map: &IndexVec::new(),\n-            };\n-\n-            // Decode Diagnostics\n-            let prev_diagnostics: FxHashMap<_, _> = {\n-                let diagnostics: EncodedPrevDiagnostics =\n-                    decode_tagged(&mut decoder, PREV_DIAGNOSTICS_TAG)\n-                        .expect(\"Error while trying to decode previous session \\\n-                                 diagnostics from incr. comp. cache.\");\n-                diagnostics.into_iter().collect()\n-            };\n-\n-            // Decode the *position* of the query result index\n-            let query_result_index_pos = {\n-                let pos_pos = data.len() - IntEncodedWithFixedSize::ENCODED_SIZE;\n-                decoder.with_position(pos_pos, |decoder| {\n-                    IntEncodedWithFixedSize::decode(decoder)\n-                }).expect(\"Error while trying to decode query result index position.\")\n-                .0 as usize\n-            };\n-\n-            // Decode the query result index itself\n-            let query_result_index: EncodedQueryResultIndex =\n-                decoder.with_position(query_result_index_pos, |decoder| {\n-                    decode_tagged(decoder, QUERY_RESULT_INDEX_TAG)\n-                }).expect(\"Error while trying to decode query result index.\");\n-\n-            (prev_diagnostics, query_result_index)\n+            // Decode the *position* of the footer which can be found in the\n+            // last 8 bytes of the file.\n+            decoder.set_position(data.len() - IntEncodedWithFixedSize::ENCODED_SIZE);\n+            let query_result_index_pos = IntEncodedWithFixedSize::decode(&mut decoder)\n+                .expect(\"Error while trying to decode query result index position.\")\n+                .0 as usize;\n+\n+            // Decoder the file footer which contains all the lookup tables, etc.\n+            decoder.set_position(query_result_index_pos);\n+            decode_tagged(&mut decoder, TAG_FILE_FOOTER)\n+                .expect(\"Error while trying to decode query result index position.\")\n         };\n \n         OnDiskCache {\n             serialized_data: data,\n-            prev_diagnostics,\n-            prev_filemap_starts: header.prev_filemap_starts,\n-            prev_cnums: header.prev_cnums,\n+            file_index_to_stable_id: footer.file_index_to_stable_id,\n+            file_index_to_file: RefCell::new(FxHashMap()),\n+            prev_cnums: footer.prev_cnums,\n             cnum_map: RefCell::new(None),\n             codemap: sess.codemap(),\n             current_diagnostics: RefCell::new(FxHashMap()),\n-            query_result_index: query_result_index.into_iter().collect(),\n+            query_result_index: footer.query_result_index.into_iter().collect(),\n+            prev_diagnostics_index: footer.diagnostics_index.into_iter().collect(),\n+            synthetic_expansion_infos: RefCell::new(FxHashMap()),\n         }\n     }\n \n     pub fn new_empty(codemap: &'sess CodeMap) -> OnDiskCache<'sess> {\n         OnDiskCache {\n             serialized_data: Vec::new(),\n-            prev_diagnostics: FxHashMap(),\n-            prev_filemap_starts: BTreeMap::new(),\n+            file_index_to_stable_id: FxHashMap(),\n+            file_index_to_file: RefCell::new(FxHashMap()),\n             prev_cnums: vec![],\n             cnum_map: RefCell::new(None),\n             codemap,\n             current_diagnostics: RefCell::new(FxHashMap()),\n             query_result_index: FxHashMap(),\n+            prev_diagnostics_index: FxHashMap(),\n+            synthetic_expansion_infos: RefCell::new(FxHashMap()),\n         }\n     }\n \n     pub fn serialize<'a, 'tcx, E>(&self,\n                                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  cstore: &CrateStore,\n                                   encoder: &mut E)\n                                   -> Result<(), E::Error>\n         where E: ty_codec::TyEncoder\n      {\n         // Serializing the DepGraph should not modify it:\n         let _in_ignore = tcx.dep_graph.in_ignore();\n \n+        // Allocate FileMapIndices\n+        let (file_to_file_index, file_index_to_stable_id) = {\n+            let mut file_to_file_index = FxHashMap();\n+            let mut file_index_to_stable_id = FxHashMap();\n+\n+            for (index, file) in tcx.sess.codemap().files().iter().enumerate() {\n+                let index = FileMapIndex(index as u32);\n+                let file_ptr: *const FileMap = &**file as *const _;\n+                file_to_file_index.insert(file_ptr, index);\n+                file_index_to_stable_id.insert(index, StableFilemapId::new(&file));\n+            }\n+\n+            (file_to_file_index, file_index_to_stable_id)\n+        };\n+\n         let mut encoder = CacheEncoder {\n             tcx,\n             encoder,\n             type_shorthands: FxHashMap(),\n             predicate_shorthands: FxHashMap(),\n+            expn_info_shorthands: FxHashMap(),\n+            codemap: CachingCodemapView::new(tcx.sess.codemap()),\n+            file_to_file_index,\n         };\n \n-\n-        // Encode the file header\n-        let prev_filemap_starts: BTreeMap<_, _> = self\n-            .codemap\n-            .files()\n-            .iter()\n-            .map(|fm| (fm.start_pos, StableFilemapId::new(fm)))\n-            .collect();\n-\n-        let sorted_cnums = sorted_cnums_including_local_crate(cstore);\n-\n-        let prev_cnums: Vec<_> = sorted_cnums.iter().map(|&cnum| {\n-            let crate_name = tcx.original_crate_name(cnum).as_str().to_string();\n-            let crate_disambiguator = tcx.crate_disambiguator(cnum);\n-            (cnum.as_u32(), crate_name, crate_disambiguator)\n-        }).collect();\n-\n-        Header {\n-            prev_filemap_starts,\n-            prev_cnums,\n-        }.encode(&mut encoder)?;\n-\n-\n-        // Encode Diagnostics\n-        let diagnostics: EncodedPrevDiagnostics =\n-            self.current_diagnostics\n-                .borrow()\n-                .iter()\n-                .map(|(k, v)| (SerializedDepNodeIndex::new(k.index()), v.clone()))\n-                .collect();\n-\n-        encoder.encode_tagged(PREV_DIAGNOSTICS_TAG, &diagnostics)?;\n-\n         // Load everything into memory so we can write it out to the on-disk\n         // cache. The vast majority of cacheable query results should already\n         // be in memory, so this should be a cheap operation.\n@@ -218,19 +209,53 @@ impl<'sess> OnDiskCache<'sess> {\n             encode_query_results::<typeck_tables_of, _>(tcx, enc, qri)?;\n         }\n \n-        // Encode query result index\n-        let query_result_index_pos = encoder.position() as u64;\n-        encoder.encode_tagged(QUERY_RESULT_INDEX_TAG, &query_result_index)?;\n+        // Encode diagnostics\n+        let diagnostics_index = {\n+            let mut diagnostics_index = EncodedDiagnosticsIndex::new();\n+\n+            for (dep_node_index, diagnostics) in self.current_diagnostics\n+                                                     .borrow()\n+                                                     .iter() {\n+                let pos = AbsoluteBytePos::new(encoder.position());\n+                // Let's make sure we get the expected type here:\n+                let diagnostics: &EncodedDiagnostics = diagnostics;\n+                let dep_node_index =\n+                    SerializedDepNodeIndex::new(dep_node_index.index());\n+                encoder.encode_tagged(dep_node_index, diagnostics)?;\n+                diagnostics_index.push((dep_node_index, pos));\n+            }\n \n-        // Encode the position of the query result index as the last 8 bytes of\n+            diagnostics_index\n+        };\n+\n+        let sorted_cnums = sorted_cnums_including_local_crate(tcx);\n+        let prev_cnums: Vec<_> = sorted_cnums.iter().map(|&cnum| {\n+            let crate_name = tcx.original_crate_name(cnum).as_str().to_string();\n+            let crate_disambiguator = tcx.crate_disambiguator(cnum);\n+            (cnum.as_u32(), crate_name, crate_disambiguator)\n+        }).collect();\n+\n+        // Encode the file footer\n+        let footer_pos = encoder.position() as u64;\n+        encoder.encode_tagged(TAG_FILE_FOOTER, &Footer {\n+            file_index_to_stable_id,\n+            prev_cnums,\n+            query_result_index,\n+            diagnostics_index,\n+        })?;\n+\n+        // Encode the position of the footer as the last 8 bytes of the\n         // file so we know where to look for it.\n-        IntEncodedWithFixedSize(query_result_index_pos).encode(&mut encoder)?;\n+        IntEncodedWithFixedSize(footer_pos).encode(encoder.encoder)?;\n+\n+        // DO NOT WRITE ANYTHING TO THE ENCODER AFTER THIS POINT! The address\n+        // of the footer must be the last thing in the data stream.\n \n         return Ok(());\n \n-        fn sorted_cnums_including_local_crate(cstore: &CrateStore) -> Vec<CrateNum> {\n+        fn sorted_cnums_including_local_crate(tcx: TyCtxt) -> Vec<CrateNum> {\n             let mut cnums = vec![LOCAL_CRATE];\n-            cnums.extend_from_slice(&cstore.crates_untracked()[..]);\n+            cnums.extend_from_slice(&tcx.crates()[..]);\n             cnums.sort_unstable();\n             // Just to be sure...\n             cnums.dedup();\n@@ -239,10 +264,17 @@ impl<'sess> OnDiskCache<'sess> {\n     }\n \n     /// Load a diagnostic emitted during the previous compilation session.\n-    pub fn load_diagnostics(&self,\n-                            dep_node_index: SerializedDepNodeIndex)\n-                            -> Vec<Diagnostic> {\n-        self.prev_diagnostics.get(&dep_node_index).cloned().unwrap_or(vec![])\n+    pub fn load_diagnostics<'a, 'tcx>(&self,\n+                                      tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      dep_node_index: SerializedDepNodeIndex)\n+                                      -> Vec<Diagnostic> {\n+        let diagnostics: Option<EncodedDiagnostics> = self.load_indexed(\n+            tcx,\n+            dep_node_index,\n+            &self.prev_diagnostics_index,\n+            \"diagnostics\");\n+\n+        diagnostics.unwrap_or(Vec::new())\n     }\n \n     /// Store a diagnostic emitted during the current compilation session.\n@@ -256,53 +288,79 @@ impl<'sess> OnDiskCache<'sess> {\n         debug_assert!(prev.is_none());\n     }\n \n-    pub fn load_query_result<'a, 'tcx, T>(&self,\n-                                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    /// Returns the cached query result if there is something in the cache for\n+    /// the given SerializedDepNodeIndex. Otherwise returns None.\n+    pub fn try_load_query_result<'tcx, T>(&self,\n+                                          tcx: TyCtxt<'_, 'tcx, 'tcx>,\n                                           dep_node_index: SerializedDepNodeIndex)\n-                                          -> T\n+                                          -> Option<T>\n+        where T: Decodable\n+    {\n+        self.load_indexed(tcx,\n+                          dep_node_index,\n+                          &self.query_result_index,\n+                          \"query result\")\n+    }\n+\n+    /// Store a diagnostic emitted during computation of an anonymous query.\n+    /// Since many anonymous queries can share the same `DepNode`, we aggregate\n+    /// them -- as opposed to regular queries where we assume that there is a\n+    /// 1:1 relationship between query-key and `DepNode`.\n+    pub fn store_diagnostics_for_anon_node(&self,\n+                                           dep_node_index: DepNodeIndex,\n+                                           mut diagnostics: Vec<Diagnostic>) {\n+        let mut current_diagnostics = self.current_diagnostics.borrow_mut();\n+\n+        let x = current_diagnostics.entry(dep_node_index).or_insert_with(|| {\n+            mem::replace(&mut diagnostics, Vec::new())\n+        });\n+\n+        x.extend(diagnostics.into_iter());\n+    }\n+\n+    fn load_indexed<'tcx, T>(&self,\n+                             tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+                             dep_node_index: SerializedDepNodeIndex,\n+                             index: &FxHashMap<SerializedDepNodeIndex,\n+                                               AbsoluteBytePos>,\n+                             debug_tag: &'static str)\n+                             -> Option<T>\n         where T: Decodable\n     {\n-        let pos = self.query_result_index[&dep_node_index];\n+        let pos = if let Some(&pos) = index.get(&dep_node_index) {\n+            pos\n+        } else {\n+            return None\n+        };\n \n         let mut cnum_map = self.cnum_map.borrow_mut();\n         if cnum_map.is_none() {\n             *cnum_map = Some(Self::compute_cnum_map(tcx, &self.prev_cnums[..]));\n         }\n \n+        let mut synthetic_expansion_infos = self.synthetic_expansion_infos.borrow_mut();\n+        let mut file_index_to_file = self.file_index_to_file.borrow_mut();\n+\n         let mut decoder = CacheDecoder {\n-            tcx: Some(tcx),\n-            opaque: opaque::Decoder::new(&self.serialized_data[..], pos),\n+            tcx,\n+            opaque: opaque::Decoder::new(&self.serialized_data[..], pos.to_usize()),\n             codemap: self.codemap,\n-            prev_filemap_starts: &self.prev_filemap_starts,\n             cnum_map: cnum_map.as_ref().unwrap(),\n+            file_index_to_file: &mut file_index_to_file,\n+            file_index_to_stable_id: &self.file_index_to_stable_id,\n+            synthetic_expansion_infos: &mut synthetic_expansion_infos,\n         };\n \n         match decode_tagged(&mut decoder, dep_node_index) {\n             Ok(value) => {\n-                value\n+                Some(value)\n             }\n             Err(e) => {\n-                bug!(\"Could not decode cached query result: {}\", e)\n+                bug!(\"Could not decode cached {}: {}\", debug_tag, e)\n             }\n         }\n     }\n \n-    /// Store a diagnostic emitted during computation of an anonymous query.\n-    /// Since many anonymous queries can share the same `DepNode`, we aggregate\n-    /// them -- as opposed to regular queries where we assume that there is a\n-    /// 1:1 relationship between query-key and `DepNode`.\n-    pub fn store_diagnostics_for_anon_node(&self,\n-                                           dep_node_index: DepNodeIndex,\n-                                           mut diagnostics: Vec<Diagnostic>) {\n-        let mut current_diagnostics = self.current_diagnostics.borrow_mut();\n-\n-        let x = current_diagnostics.entry(dep_node_index).or_insert_with(|| {\n-            mem::replace(&mut diagnostics, Vec::new())\n-        });\n-\n-        x.extend(diagnostics.into_iter());\n-    }\n-\n     // This function builds mapping from previous-session-CrateNum to\n     // current-session-CrateNum. There might be CrateNums from the previous\n     // Session that don't occur in the current one. For these, the mapping\n@@ -345,22 +403,45 @@ impl<'sess> OnDiskCache<'sess> {\n /// we use for crate metadata decoding in that it can rebase spans and\n /// eventually will also handle things that contain `Ty` instances.\n struct CacheDecoder<'a, 'tcx: 'a, 'x> {\n-    tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     opaque: opaque::Decoder<'x>,\n     codemap: &'x CodeMap,\n-    prev_filemap_starts: &'x BTreeMap<BytePos, StableFilemapId>,\n     cnum_map: &'x IndexVec<CrateNum, Option<CrateNum>>,\n+    synthetic_expansion_infos: &'x mut FxHashMap<AbsoluteBytePos, SyntaxContext>,\n+    file_index_to_file: &'x mut FxHashMap<FileMapIndex, Rc<FileMap>>,\n+    file_index_to_stable_id: &'x FxHashMap<FileMapIndex, StableFilemapId>,\n }\n \n impl<'a, 'tcx, 'x> CacheDecoder<'a, 'tcx, 'x> {\n-    fn find_filemap_prev_bytepos(&self,\n-                                 prev_bytepos: BytePos)\n-                                 -> Option<(BytePos, StableFilemapId)> {\n-        for (start, id) in self.prev_filemap_starts.range(BytePos(0) ..= prev_bytepos).rev() {\n-            return Some((*start, *id))\n-        }\n+    fn file_index_to_file(&mut self, index: FileMapIndex) -> Rc<FileMap> {\n+        let CacheDecoder {\n+            ref mut file_index_to_file,\n+            ref file_index_to_stable_id,\n+            ref codemap,\n+            ..\n+        } = *self;\n \n-        None\n+        file_index_to_file.entry(index).or_insert_with(|| {\n+            let stable_id = file_index_to_stable_id[&index];\n+            codemap.filemap_by_stable_id(stable_id)\n+                   .expect(\"Failed to lookup FileMap in new context.\")\n+        }).clone()\n+    }\n+}\n+\n+trait DecoderWithPosition: Decoder {\n+    fn position(&self) -> usize;\n+}\n+\n+impl<'enc> DecoderWithPosition for opaque::Decoder<'enc> {\n+    fn position(&self) -> usize {\n+        self.position()\n+    }\n+}\n+\n+impl<'a, 'tcx, 'x> DecoderWithPosition for CacheDecoder<'a, 'tcx, 'x> {\n+    fn position(&self) -> usize {\n+        self.opaque.position()\n     }\n }\n \n@@ -371,7 +452,7 @@ fn decode_tagged<'a, 'tcx, D, T, V>(decoder: &mut D,\n                                     -> Result<V, D::Error>\n     where T: Decodable + Eq + ::std::fmt::Debug,\n           V: Decodable,\n-          D: Decoder + ty_codec::TyDecoder<'a, 'tcx>,\n+          D: DecoderWithPosition,\n           'tcx: 'a,\n {\n     let start_pos = decoder.position();\n@@ -392,7 +473,7 @@ impl<'a, 'tcx: 'a, 'x> ty_codec::TyDecoder<'a, 'tcx> for CacheDecoder<'a, 'tcx,\n \n     #[inline]\n     fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.tcx.expect(\"missing TyCtxt in CacheDecoder\")\n+        self.tcx\n     }\n \n     #[inline]\n@@ -450,18 +531,55 @@ implement_ty_decoder!( CacheDecoder<'a, 'tcx, 'x> );\n \n impl<'a, 'tcx, 'x> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx, 'x> {\n     fn specialized_decode(&mut self) -> Result<Span, Self::Error> {\n-        let lo = BytePos::decode(self)?;\n-        let hi = BytePos::decode(self)?;\n-\n-        if let Some((prev_filemap_start, filemap_id)) = self.find_filemap_prev_bytepos(lo) {\n-            if let Some(current_filemap) = self.codemap.filemap_by_stable_id(filemap_id) {\n-                let lo = (lo + current_filemap.start_pos) - prev_filemap_start;\n-                let hi = (hi + current_filemap.start_pos) - prev_filemap_start;\n-                return Ok(Span::new(lo, hi, NO_EXPANSION));\n-            }\n+        let tag: u8 = Decodable::decode(self)?;\n+\n+        if tag == TAG_INVALID_SPAN {\n+            return Ok(DUMMY_SP);\n+        } else {\n+            debug_assert_eq!(tag, TAG_VALID_SPAN);\n         }\n \n-        Ok(DUMMY_SP)\n+        let file_lo_index = FileMapIndex::decode(self)?;\n+        let line_lo = usize::decode(self)?;\n+        let col_lo = BytePos::decode(self)?;\n+        let len = BytePos::decode(self)?;\n+\n+        let file_lo = self.file_index_to_file(file_lo_index);\n+        let lo = file_lo.lines.borrow()[line_lo - 1] + col_lo;\n+        let hi = lo + len;\n+\n+        let expn_info_tag = u8::decode(self)?;\n+\n+        let ctxt = match expn_info_tag {\n+            TAG_NO_EXPANSION_INFO => {\n+                SyntaxContext::empty()\n+            }\n+            TAG_EXPANSION_INFO_INLINE => {\n+                let pos = AbsoluteBytePos::new(self.opaque.position());\n+                let expn_info: ExpnInfo = Decodable::decode(self)?;\n+                let ctxt = SyntaxContext::allocate_directly(expn_info);\n+                self.synthetic_expansion_infos.insert(pos, ctxt);\n+                ctxt\n+            }\n+            TAG_EXPANSION_INFO_SHORTHAND => {\n+                let pos = AbsoluteBytePos::decode(self)?;\n+                if let Some(ctxt) = self.synthetic_expansion_infos.get(&pos).cloned() {\n+                    ctxt\n+                } else {\n+                    let expn_info = self.with_position(pos.to_usize(), |this| {\n+                         ExpnInfo::decode(this)\n+                    })?;\n+                    let ctxt = SyntaxContext::allocate_directly(expn_info);\n+                    self.synthetic_expansion_infos.insert(pos, ctxt);\n+                    ctxt\n+                }\n+            }\n+            _ => {\n+                unreachable!()\n+            }\n+        };\n+\n+        Ok(Span::new(lo, hi, ctxt))\n     }\n }\n \n@@ -479,6 +597,7 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<DefIndex> for CacheDecoder<'a, 'tcx, 'x> {\n // compilation sessions. We use the DefPathHash, which is stable across\n // sessions, to map the old DefId to the new one.\n impl<'a, 'tcx, 'x> SpecializedDecoder<DefId> for CacheDecoder<'a, 'tcx, 'x> {\n+    #[inline]\n     fn specialized_decode(&mut self) -> Result<DefId, Self::Error> {\n         // Load the DefPathHash which is was we encoded the DefId as.\n         let def_path_hash = DefPathHash::decode(self)?;\n@@ -489,6 +608,7 @@ impl<'a, 'tcx, 'x> SpecializedDecoder<DefId> for CacheDecoder<'a, 'tcx, 'x> {\n }\n \n impl<'a, 'tcx, 'x> SpecializedDecoder<LocalDefId> for CacheDecoder<'a, 'tcx, 'x> {\n+    #[inline]\n     fn specialized_decode(&mut self) -> Result<LocalDefId, Self::Error> {\n         Ok(LocalDefId::from_def_id(DefId::decode(self)?))\n     }\n@@ -558,11 +678,18 @@ struct CacheEncoder<'enc, 'a, 'tcx, E>\n     encoder: &'enc mut E,\n     type_shorthands: FxHashMap<ty::Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n+    expn_info_shorthands: FxHashMap<Mark, AbsoluteBytePos>,\n+    codemap: CachingCodemapView<'tcx>,\n+    file_to_file_index: FxHashMap<*const FileMap, FileMapIndex>,\n }\n \n impl<'enc, 'a, 'tcx, E> CacheEncoder<'enc, 'a, 'tcx, E>\n     where E: 'enc + ty_codec::TyEncoder\n {\n+    fn filemap_index(&mut self, filemap: Rc<FileMap>) -> FileMapIndex {\n+        self.file_to_file_index[&(&*filemap as *const FileMap)]\n+    }\n+\n     /// Encode something with additional information that allows to do some\n     /// sanity checks when decoding the data again. This method will first\n     /// encode the specified tag, then the given value, then the number of\n@@ -584,6 +711,65 @@ impl<'enc, 'a, 'tcx, E> CacheEncoder<'enc, 'a, 'tcx, E>\n     }\n }\n \n+impl<'enc, 'a, 'tcx, E> SpecializedEncoder<Span> for CacheEncoder<'enc, 'a, 'tcx, E>\n+    where E: 'enc + ty_codec::TyEncoder\n+{\n+    fn specialized_encode(&mut self, span: &Span) -> Result<(), Self::Error> {\n+\n+        if *span == DUMMY_SP {\n+            return TAG_INVALID_SPAN.encode(self);\n+        }\n+\n+        let span_data = span.data();\n+\n+        if span_data.hi < span_data.lo {\n+            return TAG_INVALID_SPAN.encode(self);\n+        }\n+\n+        let (file_lo, line_lo, col_lo) = match self.codemap\n+                                                   .byte_pos_to_line_and_col(span_data.lo) {\n+            Some(pos) => pos,\n+            None => {\n+                return TAG_INVALID_SPAN.encode(self);\n+            }\n+        };\n+\n+        if !file_lo.contains(span_data.hi) {\n+            return TAG_INVALID_SPAN.encode(self);\n+        }\n+\n+        let len = span_data.hi - span_data.lo;\n+\n+        let filemap_index = self.filemap_index(file_lo);\n+\n+        TAG_VALID_SPAN.encode(self)?;\n+        filemap_index.encode(self)?;\n+        line_lo.encode(self)?;\n+        col_lo.encode(self)?;\n+        len.encode(self)?;\n+\n+        if span_data.ctxt == SyntaxContext::empty() {\n+            TAG_NO_EXPANSION_INFO.encode(self)\n+        } else {\n+            let mark = span_data.ctxt.outer();\n+\n+            if let Some(expn_info) = mark.expn_info() {\n+                if let Some(pos) = self.expn_info_shorthands.get(&mark).cloned() {\n+                    TAG_EXPANSION_INFO_SHORTHAND.encode(self)?;\n+                    pos.encode(self)\n+                } else {\n+                    TAG_EXPANSION_INFO_INLINE.encode(self)?;\n+                    let pos = AbsoluteBytePos::new(self.position());\n+                    self.expn_info_shorthands.insert(mark, pos);\n+                    expn_info.encode(self)\n+                }\n+            } else {\n+                TAG_NO_EXPANSION_INFO.encode(self)\n+            }\n+        }\n+    }\n+}\n+\n impl<'enc, 'a, 'tcx, E> ty_codec::TyEncoder for CacheEncoder<'enc, 'a, 'tcx, E>\n     where E: 'enc + ty_codec::TyEncoder\n {\n@@ -753,10 +939,7 @@ impl IntEncodedWithFixedSize {\n impl UseSpecializedEncodable for IntEncodedWithFixedSize {}\n impl UseSpecializedDecodable for IntEncodedWithFixedSize {}\n \n-impl<'enc, 'a, 'tcx, E> SpecializedEncoder<IntEncodedWithFixedSize>\n-for CacheEncoder<'enc, 'a, 'tcx, E>\n-    where E: 'enc + ty_codec::TyEncoder\n-{\n+impl<'enc> SpecializedEncoder<IntEncodedWithFixedSize> for opaque::Encoder<'enc> {\n     fn specialized_encode(&mut self, x: &IntEncodedWithFixedSize) -> Result<(), Self::Error> {\n         let start_pos = self.position();\n         for i in 0 .. IntEncodedWithFixedSize::ENCODED_SIZE {\n@@ -768,8 +951,7 @@ for CacheEncoder<'enc, 'a, 'tcx, E>\n     }\n }\n \n-impl<'a, 'tcx, 'x> SpecializedDecoder<IntEncodedWithFixedSize>\n-for CacheDecoder<'a, 'tcx, 'x> {\n+impl<'enc> SpecializedDecoder<IntEncodedWithFixedSize> for opaque::Decoder<'enc> {\n     fn specialized_decode(&mut self) -> Result<IntEncodedWithFixedSize, Self::Error> {\n         let mut value: u64 = 0;\n         let start_pos = self.position();\n@@ -799,7 +981,7 @@ fn encode_query_results<'enc, 'a, 'tcx, Q, E>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n \n             // Record position of the cache entry\n-            query_result_index.push((dep_node, encoder.position()));\n+            query_result_index.push((dep_node, AbsoluteBytePos::new(encoder.position())));\n \n             // Encode the type check tables with the SerializedDepNodeIndex\n             // as tag."}, {"sha": "fdaa13e7fd16fd82848e2688697092fd698843c0", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6805b016efdfcd99e706003fab1336df73f6811b/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6805b016efdfcd99e706003fab1336df73f6811b/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=6805b016efdfcd99e706003fab1336df73f6811b", "patch": "@@ -145,7 +145,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 if !self.dep_graph.is_fully_enabled() {\n                     return None;\n                 }\n-                match self.dep_graph.try_mark_green(self, &dep_node) {\n+                match self.dep_graph.try_mark_green(self.global_tcx(), &dep_node) {\n                     Some(dep_node_index) => {\n                         debug_assert!(self.dep_graph.is_green(dep_node_index));\n                         self.dep_graph.read_index(dep_node_index);\n@@ -392,12 +392,31 @@ macro_rules! define_maps {\n             {\n                 debug_assert!(tcx.dep_graph.is_green(dep_node_index));\n \n-                let result = if tcx.sess.opts.debugging_opts.incremental_queries &&\n-                                Self::cache_on_disk(key) {\n+                // First we try to load the result from the on-disk cache\n+                let result = if Self::cache_on_disk(key) &&\n+                                tcx.sess.opts.debugging_opts.incremental_queries {\n                     let prev_dep_node_index =\n                         tcx.dep_graph.prev_dep_node_index_of(dep_node);\n-                    Self::load_from_disk(tcx.global_tcx(), prev_dep_node_index)\n+                    let result = Self::try_load_from_disk(tcx.global_tcx(),\n+                                                          prev_dep_node_index);\n+\n+                    // We always expect to find a cached result for things that\n+                    // can be forced from DepNode.\n+                    debug_assert!(!dep_node.kind.can_reconstruct_query_key() ||\n+                                  result.is_some(),\n+                                  \"Missing on-disk cache entry for {:?}\",\n+                                  dep_node);\n+                    result\n+                } else {\n+                    // Some things are never cached on disk.\n+                    None\n+                };\n+\n+                let result = if let Some(result) = result {\n+                    result\n                 } else {\n+                    // We could not load a result from the on-disk cache, so\n+                    // recompute.\n                     let (result, _ ) = tcx.cycle_check(span, Query::$name(key), || {\n                         // The diagnostics for this query have already been\n                         // promoted to the current session during"}, {"sha": "99557659b297bfbb794220802b66c8a700439763", "filename": "src/libserialize/opaque.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6805b016efdfcd99e706003fab1336df73f6811b/src%2Flibserialize%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6805b016efdfcd99e706003fab1336df73f6811b/src%2Flibserialize%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fopaque.rs?ref=6805b016efdfcd99e706003fab1336df73f6811b", "patch": "@@ -162,6 +162,10 @@ impl<'a> Decoder<'a> {\n         self.position\n     }\n \n+    pub fn set_position(&mut self, pos: usize) {\n+        self.position = pos\n+    }\n+\n     pub fn advance(&mut self, bytes: usize) {\n         self.position += bytes;\n     }"}, {"sha": "3aac5334a38d6780db5f2abec1d70af5629d7cfd", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6805b016efdfcd99e706003fab1336df73f6811b/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6805b016efdfcd99e706003fab1336df73f6811b/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=6805b016efdfcd99e706003fab1336df73f6811b", "patch": "@@ -105,7 +105,7 @@ impl FileLoader for RealFileLoader {\n // This is a FileMap identifier that is used to correlate FileMaps between\n // subsequent compilation sessions (which is something we need to do during\n // incremental compilation).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub struct StableFilemapId(u128);\n \n impl StableFilemapId {"}, {"sha": "9358e654a9fc8f2604961f81a7992c2bc518ff3e", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6805b016efdfcd99e706003fab1336df73f6811b/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6805b016efdfcd99e706003fab1336df73f6811b/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=6805b016efdfcd99e706003fab1336df73f6811b", "patch": "@@ -140,6 +140,31 @@ impl SyntaxContext {\n         SyntaxContext(0)\n     }\n \n+    // Allocate a new SyntaxContext with the given ExpnInfo. This is used when\n+    // deserializing Spans from the incr. comp. cache.\n+    // FIXME(mw): This method does not restore MarkData::parent or\n+    // SyntaxContextData::prev_ctxt or SyntaxContextData::modern. These things\n+    // don't seem to be used after HIR lowering, so everything should be fine\n+    // as long as incremental compilation does not kick in before that.\n+    pub fn allocate_directly(expansion_info: ExpnInfo) -> Self {\n+        HygieneData::with(|data| {\n+            data.marks.push(MarkData {\n+                parent: Mark::root(),\n+                modern: false,\n+                expn_info: Some(expansion_info)\n+            });\n+\n+            let mark = Mark(data.marks.len() as u32 - 1);\n+\n+            data.syntax_contexts.push(SyntaxContextData {\n+                outer_mark: mark,\n+                prev_ctxt: SyntaxContext::empty(),\n+                modern: SyntaxContext::empty(),\n+            });\n+            SyntaxContext(data.syntax_contexts.len() as u32 - 1)\n+        })\n+    }\n+\n     /// Extend a syntax context with a given mark\n     pub fn apply_mark(self, mark: Mark) -> SyntaxContext {\n         HygieneData::with(|data| {\n@@ -286,7 +311,7 @@ impl fmt::Debug for SyntaxContext {\n }\n \n /// Extra information for tracking spans of macro and syntax sugar expansion\n-#[derive(Clone, Hash, Debug)]\n+#[derive(Clone, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ExpnInfo {\n     /// The location of the actual macro invocation or syntax sugar , e.g.\n     /// `let x = foo!();` or `if let Some(y) = x {}`\n@@ -302,7 +327,7 @@ pub struct ExpnInfo {\n     pub callee: NameAndSpan\n }\n \n-#[derive(Clone, Hash, Debug)]\n+#[derive(Clone, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct NameAndSpan {\n     /// The format with which the macro was invoked.\n     pub format: ExpnFormat,\n@@ -330,7 +355,7 @@ impl NameAndSpan {\n }\n \n /// The source of expansion.\n-#[derive(Clone, Hash, Debug, PartialEq, Eq)]\n+#[derive(Clone, Hash, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum ExpnFormat {\n     /// e.g. #[derive(...)] <item>\n     MacroAttribute(Symbol),\n@@ -341,7 +366,7 @@ pub enum ExpnFormat {\n }\n \n /// The kind of compiler desugaring.\n-#[derive(Clone, Hash, Debug, PartialEq, Eq)]\n+#[derive(Clone, Hash, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum CompilerDesugaringKind {\n     BackArrow,\n     DotFill,"}, {"sha": "bf059cac89152572efd1e72bdbc9734de2d4c233", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6805b016efdfcd99e706003fab1336df73f6811b/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6805b016efdfcd99e706003fab1336df73f6811b/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=6805b016efdfcd99e706003fab1336df73f6811b", "patch": "@@ -931,6 +931,11 @@ impl FileMap {\n             (lines[line_index], lines[line_index + 1])\n         }\n     }\n+\n+    #[inline]\n+    pub fn contains(&self, byte_pos: BytePos) -> bool {\n+        byte_pos >= self.start_pos && byte_pos <= self.end_pos\n+    }\n }\n \n /// Remove utf-8 BOM if any."}]}