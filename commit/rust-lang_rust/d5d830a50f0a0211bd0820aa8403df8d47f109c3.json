{"sha": "d5d830a50f0a0211bd0820aa8403df8d47f109c3", "node_id": "C_kwDOAAsO6NoAKGQ1ZDgzMGE1MGYwYTAyMTFiZDA4MjBhYTg0MDNkZjhkNDdmMTA5YzM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-02T17:27:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-02T17:27:54Z"}, "message": "Auto merge of #7463 - ThibsG:find_any_7392, r=xFrednet\n\nFix `any()` not taking reference in `search_is_some` lint\n\n`find` gives reference to the item, but `any` does not, so suggestion is broken in some specific cases.\n\nFixes: #7392\n\nchangelog: [`search_is_some`] Fix suggestion for `any()` not taking item by reference", "tree": {"sha": "fdc5c68119ce358e98d79738c9de156df2959c8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdc5c68119ce358e98d79738c9de156df2959c8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5d830a50f0a0211bd0820aa8403df8d47f109c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5d830a50f0a0211bd0820aa8403df8d47f109c3", "html_url": "https://github.com/rust-lang/rust/commit/d5d830a50f0a0211bd0820aa8403df8d47f109c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5d830a50f0a0211bd0820aa8403df8d47f109c3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "392b0c5c25ddbd36e4dc480afcf70ed01dce352d", "url": "https://api.github.com/repos/rust-lang/rust/commits/392b0c5c25ddbd36e4dc480afcf70ed01dce352d", "html_url": "https://github.com/rust-lang/rust/commit/392b0c5c25ddbd36e4dc480afcf70ed01dce352d"}, {"sha": "a8e7fed17264bd269c55e8224991d5bf0249472c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8e7fed17264bd269c55e8224991d5bf0249472c", "html_url": "https://github.com/rust-lang/rust/commit/a8e7fed17264bd269c55e8224991d5bf0249472c"}], "stats": {"total": 2087, "additions": 1754, "deletions": 333}, "files": [{"sha": "5ed4ba94884e26b627874b7253608150eca9a0a9", "filename": "clippy_lints/src/methods/search_is_some.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d5d830a50f0a0211bd0820aa8403df8d47f109c3/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d830a50f0a0211bd0820aa8403df8d47f109c3/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsearch_is_some.rs?ref=d5d830a50f0a0211bd0820aa8403df8d47f109c3", "patch": "@@ -1,5 +1,6 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n use clippy_utils::source::{snippet, snippet_with_applicability};\n+use clippy_utils::sugg::deref_closure_args;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{is_trait_method, strip_pat_refs};\n use if_chain::if_chain;\n@@ -37,6 +38,7 @@ pub(super) fn check<'tcx>(\n         if search_snippet.lines().count() <= 1 {\n             // suggest `any(|x| ..)` instead of `any(|&x| ..)` for `find(|&x| ..).is_some()`\n             // suggest `any(|..| *..)` instead of `any(|..| **..)` for `find(|..| **..).is_some()`\n+            let mut applicability = Applicability::MachineApplicable;\n             let any_search_snippet = if_chain! {\n                 if search_method == \"find\";\n                 if let hir::ExprKind::Closure(_, _, body_id, ..) = search_arg.kind;\n@@ -45,9 +47,15 @@ pub(super) fn check<'tcx>(\n                 then {\n                     if let hir::PatKind::Ref(..) = closure_arg.pat.kind {\n                         Some(search_snippet.replacen('&', \"\", 1))\n-                    } else if let PatKind::Binding(_, _, ident, _) = strip_pat_refs(closure_arg.pat).kind {\n-                        let name = &*ident.name.as_str();\n-                        Some(search_snippet.replace(&format!(\"*{}\", name), name))\n+                    } else if let PatKind::Binding(..) = strip_pat_refs(closure_arg.pat).kind {\n+                        // `find()` provides a reference to the item, but `any` does not,\n+                        // so we should fix item usages for suggestion\n+                        if let Some(closure_sugg) = deref_closure_args(cx, search_arg) {\n+                            applicability = closure_sugg.applicability;\n+                            Some(closure_sugg.suggestion)\n+                        } else {\n+                            Some(search_snippet.to_string())\n+                        }\n                     } else {\n                         None\n                     }\n@@ -67,7 +75,7 @@ pub(super) fn check<'tcx>(\n                         \"any({})\",\n                         any_search_snippet.as_ref().map_or(&*search_snippet, String::as_str)\n                     ),\n-                    Applicability::MachineApplicable,\n+                    applicability,\n                 );\n             } else {\n                 let iter = snippet(cx, search_recv.span, \"..\");\n@@ -82,7 +90,7 @@ pub(super) fn check<'tcx>(\n                         iter,\n                         any_search_snippet.as_ref().map_or(&*search_snippet, String::as_str)\n                     ),\n-                    Applicability::MachineApplicable,\n+                    applicability,\n                 );\n             }\n         } else {"}, {"sha": "872942685f0d126cb01dfb6e492aab6b7d5a74e0", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 273, "deletions": 4, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/d5d830a50f0a0211bd0820aa8403df8d47f109c3/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d830a50f0a0211bd0820aa8403df8d47f109c3/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=d5d830a50f0a0211bd0820aa8403df8d47f109c3", "patch": "@@ -1,19 +1,27 @@\n //! Contains utility functions to generate suggestions.\n #![deny(clippy::missing_docs_in_private_items)]\n \n-use crate::higher;\n-use crate::source::{snippet, snippet_opt, snippet_with_context, snippet_with_macro_callsite};\n+use crate::source::{\n+    snippet, snippet_opt, snippet_with_applicability, snippet_with_context, snippet_with_macro_callsite,\n+};\n+use crate::{get_parent_expr_for_hir, higher};\n use rustc_ast::util::parser::AssocOp;\n use rustc_ast::{ast, token};\n use rustc_ast_pretty::pprust::token_kind_to_string;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n+use rustc_hir::{ExprKind, HirId, MutTy, TyKind};\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{EarlyContext, LateContext, LintContext};\n-use rustc_span::source_map::{CharPos, Span};\n-use rustc_span::{BytePos, Pos, SyntaxContext};\n+use rustc_middle::hir::place::ProjectionKind;\n+use rustc_middle::mir::{FakeReadCause, Mutability};\n+use rustc_middle::ty;\n+use rustc_span::source_map::{BytePos, CharPos, Pos, Span, SyntaxContext};\n+use rustc_typeck::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use std::borrow::Cow;\n use std::convert::TryInto;\n use std::fmt::Display;\n+use std::iter;\n use std::ops::{Add, Neg, Not, Sub};\n \n /// A helper type to build suggestion correctly handling parentheses.\n@@ -716,6 +724,267 @@ impl<T: LintContext> DiagnosticBuilderExt<T> for rustc_errors::DiagnosticBuilder\n     }\n }\n \n+/// Suggestion results for handling closure\n+/// args dereferencing and borrowing\n+pub struct DerefClosure {\n+    /// confidence on the built suggestion\n+    pub applicability: Applicability,\n+    /// gradually built suggestion\n+    pub suggestion: String,\n+}\n+\n+/// Build suggestion gradually by handling closure arg specific usages,\n+/// such as explicit deref and borrowing cases.\n+/// Returns `None` if no such use cases have been triggered in closure body\n+///\n+/// note: this only works on single line immutable closures with exactly one input parameter.\n+pub fn deref_closure_args<'tcx>(cx: &LateContext<'_>, closure: &'tcx hir::Expr<'_>) -> Option<DerefClosure> {\n+    if let hir::ExprKind::Closure(_, fn_decl, body_id, ..) = closure.kind {\n+        let closure_body = cx.tcx.hir().body(body_id);\n+        // is closure arg a type annotated double reference (i.e.: `|x: &&i32| ...`)\n+        // a type annotation is present if param `kind` is different from `TyKind::Infer`\n+        let closure_arg_is_type_annotated_double_ref = if let TyKind::Rptr(_, MutTy { ty, .. }) = fn_decl.inputs[0].kind\n+        {\n+            matches!(ty.kind, TyKind::Rptr(_, MutTy { .. }))\n+        } else {\n+            false\n+        };\n+\n+        let mut visitor = DerefDelegate {\n+            cx,\n+            closure_span: closure.span,\n+            closure_arg_is_type_annotated_double_ref,\n+            next_pos: closure.span.lo(),\n+            suggestion_start: String::new(),\n+            applicability: Applicability::MaybeIncorrect,\n+        };\n+\n+        let fn_def_id = cx.tcx.hir().local_def_id(closure.hir_id);\n+        cx.tcx.infer_ctxt().enter(|infcx| {\n+            ExprUseVisitor::new(&mut visitor, &infcx, fn_def_id, cx.param_env, cx.typeck_results())\n+                .consume_body(closure_body);\n+        });\n+\n+        if !visitor.suggestion_start.is_empty() {\n+            return Some(DerefClosure {\n+                applicability: visitor.applicability,\n+                suggestion: visitor.finish(),\n+            });\n+        }\n+    }\n+    None\n+}\n+\n+/// Visitor struct used for tracking down\n+/// dereferencing and borrowing of closure's args\n+struct DerefDelegate<'a, 'tcx> {\n+    /// The late context of the lint\n+    cx: &'a LateContext<'tcx>,\n+    /// The span of the input closure to adapt\n+    closure_span: Span,\n+    /// Indicates if the arg of the closure is a type annotated double reference\n+    closure_arg_is_type_annotated_double_ref: bool,\n+    /// last position of the span to gradually build the suggestion\n+    next_pos: BytePos,\n+    /// starting part of the gradually built suggestion\n+    suggestion_start: String,\n+    /// confidence on the built suggestion\n+    applicability: Applicability,\n+}\n+\n+impl DerefDelegate<'_, 'tcx> {\n+    /// build final suggestion:\n+    /// - create the ending part of suggestion\n+    /// - concatenate starting and ending parts\n+    /// - potentially remove needless borrowing\n+    pub fn finish(&mut self) -> String {\n+        let end_span = Span::new(self.next_pos, self.closure_span.hi(), self.closure_span.ctxt(), None);\n+        let end_snip = snippet_with_applicability(self.cx, end_span, \"..\", &mut self.applicability);\n+        let sugg = format!(\"{}{}\", self.suggestion_start, end_snip);\n+        if self.closure_arg_is_type_annotated_double_ref {\n+            sugg.replacen('&', \"\", 1)\n+        } else {\n+            sugg\n+        }\n+    }\n+\n+    /// indicates whether the function from `parent_expr` takes its args by double reference\n+    fn func_takes_arg_by_double_ref(&self, parent_expr: &'tcx hir::Expr<'_>, cmt_hir_id: HirId) -> bool {\n+        let (call_args, inputs) = match parent_expr.kind {\n+            ExprKind::MethodCall(_, _, call_args, _) => {\n+                if let Some(method_did) = self.cx.typeck_results().type_dependent_def_id(parent_expr.hir_id) {\n+                    (call_args, self.cx.tcx.fn_sig(method_did).skip_binder().inputs())\n+                } else {\n+                    return false;\n+                }\n+            },\n+            ExprKind::Call(func, call_args) => {\n+                let typ = self.cx.typeck_results().expr_ty(func);\n+                (call_args, typ.fn_sig(self.cx.tcx).skip_binder().inputs())\n+            },\n+            _ => return false,\n+        };\n+\n+        iter::zip(call_args, inputs)\n+            .any(|(arg, ty)| arg.hir_id == cmt_hir_id && matches!(ty.kind(), ty::Ref(_, inner, _) if inner.is_ref()))\n+    }\n+}\n+\n+impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n+    fn consume(&mut self, _: &PlaceWithHirId<'tcx>, _: HirId) {}\n+\n+    #[allow(clippy::too_many_lines)]\n+    fn borrow(&mut self, cmt: &PlaceWithHirId<'tcx>, _: HirId, _: ty::BorrowKind) {\n+        if let PlaceBase::Local(id) = cmt.place.base {\n+            let map = self.cx.tcx.hir();\n+            let span = map.span(cmt.hir_id);\n+            let start_span = Span::new(self.next_pos, span.lo(), span.ctxt(), None);\n+            let mut start_snip = snippet_with_applicability(self.cx, start_span, \"..\", &mut self.applicability);\n+\n+            // identifier referring to the variable currently triggered (i.e.: `fp`)\n+            let ident_str = map.name(id).to_string();\n+            // full identifier that includes projection (i.e.: `fp.field`)\n+            let ident_str_with_proj = snippet(self.cx, span, \"..\").to_string();\n+\n+            if cmt.place.projections.is_empty() {\n+                // handle item without any projection, that needs an explicit borrowing\n+                // i.e.: suggest `&x` instead of `x`\n+                self.suggestion_start.push_str(&format!(\"{}&{}\", start_snip, ident_str));\n+            } else {\n+                // cases where a parent `Call` or `MethodCall` is using the item\n+                // i.e.: suggest `.contains(&x)` for `.find(|x| [1, 2, 3].contains(x)).is_none()`\n+                //\n+                // Note about method calls:\n+                // - compiler automatically dereference references if the target type is a reference (works also for\n+                //   function call)\n+                // - `self` arguments in the case of `x.is_something()` are also automatically (de)referenced, and\n+                //   no projection should be suggested\n+                if let Some(parent_expr) = get_parent_expr_for_hir(self.cx, cmt.hir_id) {\n+                    match &parent_expr.kind {\n+                        // given expression is the self argument and will be handled completely by the compiler\n+                        // i.e.: `|x| x.is_something()`\n+                        ExprKind::MethodCall(_, _, [self_expr, ..], _) if self_expr.hir_id == cmt.hir_id => {\n+                            self.suggestion_start\n+                                .push_str(&format!(\"{}{}\", start_snip, ident_str_with_proj));\n+                            self.next_pos = span.hi();\n+                            return;\n+                        },\n+                        // item is used in a call\n+                        // i.e.: `Call`: `|x| please(x)` or `MethodCall`: `|x| [1, 2, 3].contains(x)`\n+                        ExprKind::Call(_, [call_args @ ..]) | ExprKind::MethodCall(_, _, [_, call_args @ ..], _) => {\n+                            let expr = self.cx.tcx.hir().expect_expr(cmt.hir_id);\n+                            let arg_ty_kind = self.cx.typeck_results().expr_ty(expr).kind();\n+\n+                            if matches!(arg_ty_kind, ty::Ref(_, _, Mutability::Not)) {\n+                                // suggest ampersand if call function is taking args by double reference\n+                                let takes_arg_by_double_ref =\n+                                    self.func_takes_arg_by_double_ref(parent_expr, cmt.hir_id);\n+\n+                                // compiler will automatically dereference field or index projection, so no need\n+                                // to suggest ampersand, but full identifier that includes projection is required\n+                                let has_field_or_index_projection =\n+                                    cmt.place.projections.iter().any(|proj| {\n+                                        matches!(proj.kind, ProjectionKind::Field(..) | ProjectionKind::Index)\n+                                    });\n+\n+                                // no need to bind again if the function doesn't take arg by double ref\n+                                // and if the item is already a double ref\n+                                let ident_sugg = if !call_args.is_empty()\n+                                    && !takes_arg_by_double_ref\n+                                    && (self.closure_arg_is_type_annotated_double_ref || has_field_or_index_projection)\n+                                {\n+                                    let ident = if has_field_or_index_projection {\n+                                        ident_str_with_proj\n+                                    } else {\n+                                        ident_str\n+                                    };\n+                                    format!(\"{}{}\", start_snip, ident)\n+                                } else {\n+                                    format!(\"{}&{}\", start_snip, ident_str)\n+                                };\n+                                self.suggestion_start.push_str(&ident_sugg);\n+                                self.next_pos = span.hi();\n+                                return;\n+                            }\n+\n+                            self.applicability = Applicability::Unspecified;\n+                        },\n+                        _ => (),\n+                    }\n+                }\n+\n+                let mut replacement_str = ident_str;\n+                let mut projections_handled = false;\n+                cmt.place.projections.iter().enumerate().for_each(|(i, proj)| {\n+                    match proj.kind {\n+                        // Field projection like `|v| v.foo`\n+                        // no adjustment needed here, as field projections are handled by the compiler\n+                        ProjectionKind::Field(..) => match cmt.place.ty_before_projection(i).kind() {\n+                            ty::Adt(..) | ty::Tuple(_) => {\n+                                replacement_str = ident_str_with_proj.clone();\n+                                projections_handled = true;\n+                            },\n+                            _ => (),\n+                        },\n+                        // Index projection like `|x| foo[x]`\n+                        // the index is dropped so we can't get it to build the suggestion,\n+                        // so the span is set-up again to get more code, using `span.hi()` (i.e.: `foo[x]`)\n+                        // instead of `span.lo()` (i.e.: `foo`)\n+                        ProjectionKind::Index => {\n+                            let start_span = Span::new(self.next_pos, span.hi(), span.ctxt(), None);\n+                            start_snip = snippet_with_applicability(self.cx, start_span, \"..\", &mut self.applicability);\n+                            replacement_str.clear();\n+                            projections_handled = true;\n+                        },\n+                        // note: unable to trigger `Subslice` kind in tests\n+                        ProjectionKind::Subslice => (),\n+                        ProjectionKind::Deref => {\n+                            // Explicit derefs are typically handled later on, but\n+                            // some items do not need explicit deref, such as array accesses,\n+                            // so we mark them as already processed\n+                            // i.e.: don't suggest `*sub[1..4].len()` for `|sub| sub[1..4].len() == 3`\n+                            if let ty::Ref(_, inner, _) = cmt.place.ty_before_projection(i).kind() {\n+                                if matches!(inner.kind(), ty::Ref(_, innermost, _) if innermost.is_array()) {\n+                                    projections_handled = true;\n+                                }\n+                            }\n+                        },\n+                    }\n+                });\n+\n+                // handle `ProjectionKind::Deref` by removing one explicit deref\n+                // if no special case was detected (i.e.: suggest `*x` instead of `**x`)\n+                if !projections_handled {\n+                    let last_deref = cmt\n+                        .place\n+                        .projections\n+                        .iter()\n+                        .rposition(|proj| proj.kind == ProjectionKind::Deref);\n+\n+                    if let Some(pos) = last_deref {\n+                        let mut projections = cmt.place.projections.clone();\n+                        projections.truncate(pos);\n+\n+                        for item in projections {\n+                            if item.kind == ProjectionKind::Deref {\n+                                replacement_str = format!(\"*{}\", replacement_str);\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                self.suggestion_start\n+                    .push_str(&format!(\"{}{}\", start_snip, replacement_str));\n+            }\n+            self.next_pos = span.hi();\n+        }\n+    }\n+\n+    fn mutate(&mut self, _: &PlaceWithHirId<'tcx>, _: HirId) {}\n+\n+    fn fake_read(&mut self, _: rustc_typeck::expr_use_visitor::Place<'tcx>, _: FakeReadCause, _: HirId) {}\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::Sugg;"}, {"sha": "72f335153c1b1282ec812f1fe09b56d6f97a2e48", "filename": "tests/ui/search_is_some.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5d830a50f0a0211bd0820aa8403df8d47f109c3/tests%2Fui%2Fsearch_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d830a50f0a0211bd0820aa8403df8d47f109c3/tests%2Fui%2Fsearch_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some.rs?ref=d5d830a50f0a0211bd0820aa8403df8d47f109c3", "patch": "@@ -36,6 +36,9 @@ fn main() {\n     // check that we don't lint if `find()` is called with\n     // `Pattern` that is not a string\n     let _ = \"hello world\".find(|c: char| c == 'o' || c == 'l').is_some();\n+\n+    let some_closure = |x: &u32| *x == 0;\n+    let _ = (0..1).find(some_closure).is_some();\n }\n \n #[rustfmt::skip]\n@@ -70,4 +73,7 @@ fn is_none() {\n     // check that we don't lint if `find()` is called with\n     // `Pattern` that is not a string\n     let _ = \"hello world\".find(|c: char| c == 'o' || c == 'l').is_none();\n+\n+    let some_closure = |x: &u32| *x == 0;\n+    let _ = (0..1).find(some_closure).is_none();\n }"}, {"sha": "54760545bcedc38cfc536fc63ea90b305048a1a4", "filename": "tests/ui/search_is_some.stderr", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d5d830a50f0a0211bd0820aa8403df8d47f109c3/tests%2Fui%2Fsearch_is_some.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5d830a50f0a0211bd0820aa8403df8d47f109c3/tests%2Fui%2Fsearch_is_some.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some.stderr?ref=d5d830a50f0a0211bd0820aa8403df8d47f109c3", "patch": "@@ -35,8 +35,14 @@ LL | |                    ).is_some();\n    |\n    = help: this is more succinctly expressed by calling `any()`\n \n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some.rs:41:20\n+   |\n+LL |     let _ = (0..1).find(some_closure).is_some();\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(some_closure)`\n+\n error: called `is_none()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some.rs:48:13\n+  --> $DIR/search_is_some.rs:51:13\n    |\n LL |       let _ = v.iter().find(|&x| {\n    |  _____________^\n@@ -48,7 +54,7 @@ LL | |                    ).is_none();\n    = help: this is more succinctly expressed by calling `any()` with negation\n \n error: called `is_none()` after searching an `Iterator` with `position`\n-  --> $DIR/search_is_some.rs:54:13\n+  --> $DIR/search_is_some.rs:57:13\n    |\n LL |       let _ = v.iter().position(|&x| {\n    |  _____________^\n@@ -60,7 +66,7 @@ LL | |                    ).is_none();\n    = help: this is more succinctly expressed by calling `any()` with negation\n \n error: called `is_none()` after searching an `Iterator` with `rposition`\n-  --> $DIR/search_is_some.rs:60:13\n+  --> $DIR/search_is_some.rs:63:13\n    |\n LL |       let _ = v.iter().rposition(|&x| {\n    |  _____________^\n@@ -71,5 +77,11 @@ LL | |                    ).is_none();\n    |\n    = help: this is more succinctly expressed by calling `any()` with negation\n \n-error: aborting due to 6 previous errors\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some.rs:78:13\n+   |\n+LL |     let _ = (0..1).find(some_closure).is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!(0..1).any(some_closure)`\n+\n+error: aborting due to 8 previous errors\n "}, {"sha": "62ff16f67f41b7aa5641af3829a70ec3c04be4fd", "filename": "tests/ui/search_is_some_fixable.fixed", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/392b0c5c25ddbd36e4dc480afcf70ed01dce352d/tests%2Fui%2Fsearch_is_some_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/392b0c5c25ddbd36e4dc480afcf70ed01dce352d/tests%2Fui%2Fsearch_is_some_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable.fixed?ref=392b0c5c25ddbd36e4dc480afcf70ed01dce352d", "patch": "@@ -1,68 +0,0 @@\n-// run-rustfix\n-#![allow(dead_code)]\n-#![warn(clippy::search_is_some)]\n-\n-fn main() {\n-    let v = vec![3, 2, 1, 0, -1, -2, -3];\n-    let y = &&42;\n-\n-    // Check `find().is_some()`, single-line case.\n-    let _ = v.iter().any(|x| *x < 0);\n-    let _ = (0..1).any(|x| **y == x); // one dereference less\n-    let _ = (0..1).any(|x| x == 0);\n-    let _ = v.iter().any(|x| *x == 0);\n-\n-    // Check `position().is_some()`, single-line case.\n-    let _ = v.iter().any(|&x| x < 0);\n-\n-    // Check `rposition().is_some()`, single-line case.\n-    let _ = v.iter().any(|&x| x < 0);\n-\n-    let s1 = String::from(\"hello world\");\n-    let s2 = String::from(\"world\");\n-    // caller of `find()` is a `&`static str`\n-    let _ = \"hello world\".contains(\"world\");\n-    let _ = \"hello world\".contains(&s2);\n-    let _ = \"hello world\".contains(&s2[2..]);\n-    // caller of `find()` is a `String`\n-    let _ = s1.contains(\"world\");\n-    let _ = s1.contains(&s2);\n-    let _ = s1.contains(&s2[2..]);\n-    // caller of `find()` is slice of `String`\n-    let _ = s1[2..].contains(\"world\");\n-    let _ = s1[2..].contains(&s2);\n-    let _ = s1[2..].contains(&s2[2..]);\n-}\n-\n-fn is_none() {\n-    let v = vec![3, 2, 1, 0, -1, -2, -3];\n-    let y = &&42;\n-\n-    // Check `find().is_none()`, single-line case.\n-    let _ = !v.iter().any(|x| *x < 0);\n-    let _ = !(0..1).any(|x| **y == x); // one dereference less\n-    let _ = !(0..1).any(|x| x == 0);\n-    let _ = !v.iter().any(|x| *x == 0);\n-\n-    // Check `position().is_none()`, single-line case.\n-    let _ = !v.iter().any(|&x| x < 0);\n-\n-    // Check `rposition().is_none()`, single-line case.\n-    let _ = !v.iter().any(|&x| x < 0);\n-\n-    let s1 = String::from(\"hello world\");\n-    let s2 = String::from(\"world\");\n-\n-    // caller of `find()` is a `&`static str`\n-    let _ = !\"hello world\".contains(\"world\");\n-    let _ = !\"hello world\".contains(&s2);\n-    let _ = !\"hello world\".contains(&s2[2..]);\n-    // caller of `find()` is a `String`\n-    let _ = !s1.contains(\"world\");\n-    let _ = !s1.contains(&s2);\n-    let _ = !s1.contains(&s2[2..]);\n-    // caller of `find()` is slice of `String`\n-    let _ = !s1[2..].contains(\"world\");\n-    let _ = !s1[2..].contains(&s2);\n-    let _ = !s1[2..].contains(&s2[2..]);\n-}"}, {"sha": "8407f71664740d1aa8a4f6daf33e4841bec1bba3", "filename": "tests/ui/search_is_some_fixable.rs", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/392b0c5c25ddbd36e4dc480afcf70ed01dce352d/tests%2Fui%2Fsearch_is_some_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/392b0c5c25ddbd36e4dc480afcf70ed01dce352d/tests%2Fui%2Fsearch_is_some_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable.rs?ref=392b0c5c25ddbd36e4dc480afcf70ed01dce352d", "patch": "@@ -1,68 +0,0 @@\n-// run-rustfix\n-#![allow(dead_code)]\n-#![warn(clippy::search_is_some)]\n-\n-fn main() {\n-    let v = vec![3, 2, 1, 0, -1, -2, -3];\n-    let y = &&42;\n-\n-    // Check `find().is_some()`, single-line case.\n-    let _ = v.iter().find(|&x| *x < 0).is_some();\n-    let _ = (0..1).find(|x| **y == *x).is_some(); // one dereference less\n-    let _ = (0..1).find(|x| *x == 0).is_some();\n-    let _ = v.iter().find(|x| **x == 0).is_some();\n-\n-    // Check `position().is_some()`, single-line case.\n-    let _ = v.iter().position(|&x| x < 0).is_some();\n-\n-    // Check `rposition().is_some()`, single-line case.\n-    let _ = v.iter().rposition(|&x| x < 0).is_some();\n-\n-    let s1 = String::from(\"hello world\");\n-    let s2 = String::from(\"world\");\n-    // caller of `find()` is a `&`static str`\n-    let _ = \"hello world\".find(\"world\").is_some();\n-    let _ = \"hello world\".find(&s2).is_some();\n-    let _ = \"hello world\".find(&s2[2..]).is_some();\n-    // caller of `find()` is a `String`\n-    let _ = s1.find(\"world\").is_some();\n-    let _ = s1.find(&s2).is_some();\n-    let _ = s1.find(&s2[2..]).is_some();\n-    // caller of `find()` is slice of `String`\n-    let _ = s1[2..].find(\"world\").is_some();\n-    let _ = s1[2..].find(&s2).is_some();\n-    let _ = s1[2..].find(&s2[2..]).is_some();\n-}\n-\n-fn is_none() {\n-    let v = vec![3, 2, 1, 0, -1, -2, -3];\n-    let y = &&42;\n-\n-    // Check `find().is_none()`, single-line case.\n-    let _ = v.iter().find(|&x| *x < 0).is_none();\n-    let _ = (0..1).find(|x| **y == *x).is_none(); // one dereference less\n-    let _ = (0..1).find(|x| *x == 0).is_none();\n-    let _ = v.iter().find(|x| **x == 0).is_none();\n-\n-    // Check `position().is_none()`, single-line case.\n-    let _ = v.iter().position(|&x| x < 0).is_none();\n-\n-    // Check `rposition().is_none()`, single-line case.\n-    let _ = v.iter().rposition(|&x| x < 0).is_none();\n-\n-    let s1 = String::from(\"hello world\");\n-    let s2 = String::from(\"world\");\n-\n-    // caller of `find()` is a `&`static str`\n-    let _ = \"hello world\".find(\"world\").is_none();\n-    let _ = \"hello world\".find(&s2).is_none();\n-    let _ = \"hello world\".find(&s2[2..]).is_none();\n-    // caller of `find()` is a `String`\n-    let _ = s1.find(\"world\").is_none();\n-    let _ = s1.find(&s2).is_none();\n-    let _ = s1.find(&s2[2..]).is_none();\n-    // caller of `find()` is slice of `String`\n-    let _ = s1[2..].find(\"world\").is_none();\n-    let _ = s1[2..].find(&s2).is_none();\n-    let _ = s1[2..].find(&s2[2..]).is_none();\n-}"}, {"sha": "bd1b6955a97283bba14a32d8e9bad58b7c638493", "filename": "tests/ui/search_is_some_fixable.stderr", "status": "removed", "additions": 0, "deletions": 184, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/392b0c5c25ddbd36e4dc480afcf70ed01dce352d/tests%2Fui%2Fsearch_is_some_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/392b0c5c25ddbd36e4dc480afcf70ed01dce352d/tests%2Fui%2Fsearch_is_some_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable.stderr?ref=392b0c5c25ddbd36e4dc480afcf70ed01dce352d", "patch": "@@ -1,184 +0,0 @@\n-error: called `is_some()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable.rs:10:22\n-   |\n-LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| *x < 0)`\n-   |\n-   = note: `-D clippy::search-is-some` implied by `-D warnings`\n-\n-error: called `is_some()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable.rs:11:20\n-   |\n-LL |     let _ = (0..1).find(|x| **y == *x).is_some(); // one dereference less\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| **y == x)`\n-\n-error: called `is_some()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable.rs:12:20\n-   |\n-LL |     let _ = (0..1).find(|x| *x == 0).is_some();\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| x == 0)`\n-\n-error: called `is_some()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable.rs:13:22\n-   |\n-LL |     let _ = v.iter().find(|x| **x == 0).is_some();\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| *x == 0)`\n-\n-error: called `is_some()` after searching an `Iterator` with `position`\n-  --> $DIR/search_is_some_fixable.rs:16:22\n-   |\n-LL |     let _ = v.iter().position(|&x| x < 0).is_some();\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|&x| x < 0)`\n-\n-error: called `is_some()` after searching an `Iterator` with `rposition`\n-  --> $DIR/search_is_some_fixable.rs:19:22\n-   |\n-LL |     let _ = v.iter().rposition(|&x| x < 0).is_some();\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|&x| x < 0)`\n-\n-error: called `is_some()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:24:27\n-   |\n-LL |     let _ = \"hello world\".find(\"world\").is_some();\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(\"world\")`\n-\n-error: called `is_some()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:25:27\n-   |\n-LL |     let _ = \"hello world\".find(&s2).is_some();\n-   |                           ^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(&s2)`\n-\n-error: called `is_some()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:26:27\n-   |\n-LL |     let _ = \"hello world\".find(&s2[2..]).is_some();\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(&s2[2..])`\n-\n-error: called `is_some()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:28:16\n-   |\n-LL |     let _ = s1.find(\"world\").is_some();\n-   |                ^^^^^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(\"world\")`\n-\n-error: called `is_some()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:29:16\n-   |\n-LL |     let _ = s1.find(&s2).is_some();\n-   |                ^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(&s2)`\n-\n-error: called `is_some()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:30:16\n-   |\n-LL |     let _ = s1.find(&s2[2..]).is_some();\n-   |                ^^^^^^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(&s2[2..])`\n-\n-error: called `is_some()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:32:21\n-   |\n-LL |     let _ = s1[2..].find(\"world\").is_some();\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(\"world\")`\n-\n-error: called `is_some()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:33:21\n-   |\n-LL |     let _ = s1[2..].find(&s2).is_some();\n-   |                     ^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(&s2)`\n-\n-error: called `is_some()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:34:21\n-   |\n-LL |     let _ = s1[2..].find(&s2[2..]).is_some();\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(&s2[2..])`\n-\n-error: called `is_none()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable.rs:42:13\n-   |\n-LL |     let _ = v.iter().find(|&x| *x < 0).is_none();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|x| *x < 0)`\n-\n-error: called `is_none()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable.rs:43:13\n-   |\n-LL |     let _ = (0..1).find(|x| **y == *x).is_none(); // one dereference less\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!(0..1).any(|x| **y == x)`\n-\n-error: called `is_none()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable.rs:44:13\n-   |\n-LL |     let _ = (0..1).find(|x| *x == 0).is_none();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!(0..1).any(|x| x == 0)`\n-\n-error: called `is_none()` after searching an `Iterator` with `find`\n-  --> $DIR/search_is_some_fixable.rs:45:13\n-   |\n-LL |     let _ = v.iter().find(|x| **x == 0).is_none();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|x| *x == 0)`\n-\n-error: called `is_none()` after searching an `Iterator` with `position`\n-  --> $DIR/search_is_some_fixable.rs:48:13\n-   |\n-LL |     let _ = v.iter().position(|&x| x < 0).is_none();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|&x| x < 0)`\n-\n-error: called `is_none()` after searching an `Iterator` with `rposition`\n-  --> $DIR/search_is_some_fixable.rs:51:13\n-   |\n-LL |     let _ = v.iter().rposition(|&x| x < 0).is_none();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|&x| x < 0)`\n-\n-error: called `is_none()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:57:13\n-   |\n-LL |     let _ = \"hello world\".find(\"world\").is_none();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!\"hello world\".contains(\"world\")`\n-\n-error: called `is_none()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:58:13\n-   |\n-LL |     let _ = \"hello world\".find(&s2).is_none();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!\"hello world\".contains(&s2)`\n-\n-error: called `is_none()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:59:13\n-   |\n-LL |     let _ = \"hello world\".find(&s2[2..]).is_none();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!\"hello world\".contains(&s2[2..])`\n-\n-error: called `is_none()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:61:13\n-   |\n-LL |     let _ = s1.find(\"world\").is_none();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!s1.contains(\"world\")`\n-\n-error: called `is_none()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:62:13\n-   |\n-LL |     let _ = s1.find(&s2).is_none();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!s1.contains(&s2)`\n-\n-error: called `is_none()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:63:13\n-   |\n-LL |     let _ = s1.find(&s2[2..]).is_none();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!s1.contains(&s2[2..])`\n-\n-error: called `is_none()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:65:13\n-   |\n-LL |     let _ = s1[2..].find(\"world\").is_none();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!s1[2..].contains(\"world\")`\n-\n-error: called `is_none()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:66:13\n-   |\n-LL |     let _ = s1[2..].find(&s2).is_none();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!s1[2..].contains(&s2)`\n-\n-error: called `is_none()` after calling `find()` on a string\n-  --> $DIR/search_is_some_fixable.rs:67:13\n-   |\n-LL |     let _ = s1[2..].find(&s2[2..]).is_none();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!s1[2..].contains(&s2[2..])`\n-\n-error: aborting due to 30 previous errors\n-"}, {"sha": "6831fb2cf59e0476ae0c9ab1ae5b36d4e7fc2a02", "filename": "tests/ui/search_is_some_fixable_none.fixed", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/d5d830a50f0a0211bd0820aa8403df8d47f109c3/tests%2Fui%2Fsearch_is_some_fixable_none.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d5d830a50f0a0211bd0820aa8403df8d47f109c3/tests%2Fui%2Fsearch_is_some_fixable_none.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_none.fixed?ref=d5d830a50f0a0211bd0820aa8403df8d47f109c3", "patch": "@@ -0,0 +1,216 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+#![warn(clippy::search_is_some)]\n+\n+fn main() {\n+    let v = vec![3, 2, 1, 0, -1, -2, -3];\n+    let y = &&42;\n+\n+    // Check `find().is_none()`, single-line case.\n+    let _ = !v.iter().any(|x| *x < 0);\n+    let _ = !(0..1).any(|x| **y == x); // one dereference less\n+    let _ = !(0..1).any(|x| x == 0);\n+    let _ = !v.iter().any(|x| *x == 0);\n+    let _ = !(4..5).any(|x| x == 1 || x == 3 || x == 5);\n+    let _ = !(1..3).any(|x| [1, 2, 3].contains(&x));\n+    let _ = !(1..3).any(|x| x == 0 || [1, 2, 3].contains(&x));\n+    let _ = !(1..3).any(|x| [1, 2, 3].contains(&x) || x == 0);\n+    let _ = !(1..3).any(|x| [1, 2, 3].contains(&x) || x == 0 || [4, 5, 6].contains(&x) || x == -1);\n+\n+    // Check `position().is_none()`, single-line case.\n+    let _ = !v.iter().any(|&x| x < 0);\n+\n+    // Check `rposition().is_none()`, single-line case.\n+    let _ = !v.iter().any(|&x| x < 0);\n+\n+    let s1 = String::from(\"hello world\");\n+    let s2 = String::from(\"world\");\n+\n+    // caller of `find()` is a `&`static str`\n+    let _ = !\"hello world\".contains(\"world\");\n+    let _ = !\"hello world\".contains(&s2);\n+    let _ = !\"hello world\".contains(&s2[2..]);\n+    // caller of `find()` is a `String`\n+    let _ = !s1.contains(\"world\");\n+    let _ = !s1.contains(&s2);\n+    let _ = !s1.contains(&s2[2..]);\n+    // caller of `find()` is slice of `String`\n+    let _ = !s1[2..].contains(\"world\");\n+    let _ = !s1[2..].contains(&s2);\n+    let _ = !s1[2..].contains(&s2[2..]);\n+}\n+\n+#[allow(clippy::clone_on_copy, clippy::map_clone)]\n+mod issue7392 {\n+    struct Player {\n+        hand: Vec<usize>,\n+    }\n+    fn filter() {\n+        let p = Player {\n+            hand: vec![1, 2, 3, 4, 5],\n+        };\n+        let filter_hand = vec![5];\n+        let _ = p\n+            .hand\n+            .iter()\n+            .filter(|c| !filter_hand.iter().any(|cc| c == &cc))\n+            .map(|c| c.clone())\n+            .collect::<Vec<_>>();\n+    }\n+\n+    struct PlayerTuple {\n+        hand: Vec<(usize, char)>,\n+    }\n+    fn filter_tuple() {\n+        let p = PlayerTuple {\n+            hand: vec![(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e')],\n+        };\n+        let filter_hand = vec![5];\n+        let _ = p\n+            .hand\n+            .iter()\n+            .filter(|(c, _)| !filter_hand.iter().any(|cc| c == cc))\n+            .map(|c| c.clone())\n+            .collect::<Vec<_>>();\n+    }\n+\n+    fn field_projection() {\n+        struct Foo {\n+            foo: i32,\n+            bar: u32,\n+        }\n+        let vfoo = vec![Foo { foo: 1, bar: 2 }];\n+        let _ = !vfoo.iter().any(|v| v.foo == 1 && v.bar == 2);\n+\n+        let vfoo = vec![(42, Foo { foo: 1, bar: 2 })];\n+        let _ = !vfoo\n+            .iter().any(|(i, v)| *i == 42 && v.foo == 1 && v.bar == 2);\n+    }\n+\n+    fn index_projection() {\n+        let vfoo = vec![[0, 1, 2, 3]];\n+        let _ = !vfoo.iter().any(|a| a[0] == 42);\n+    }\n+\n+    #[allow(clippy::match_like_matches_macro)]\n+    fn slice_projection() {\n+        let vfoo = vec![[0, 1, 2, 3, 0, 1, 2, 3]];\n+        let _ = !vfoo.iter().any(|sub| sub[1..4].len() == 3);\n+    }\n+\n+    fn please(x: &u32) -> bool {\n+        *x == 9\n+    }\n+\n+    fn deref_enough(x: u32) -> bool {\n+        x == 78\n+    }\n+\n+    fn arg_no_deref(x: &&u32) -> bool {\n+        **x == 78\n+    }\n+\n+    fn more_projections() {\n+        let x = 19;\n+        let ppx: &u32 = &x;\n+        let _ = ![ppx].iter().any(|ppp_x: &&u32| please(ppp_x));\n+        let _ = ![String::from(\"Hey hey\")].iter().any(|s| s.len() == 2);\n+\n+        let v = vec![3, 2, 1, 0];\n+        let _ = !v.iter().any(|x| deref_enough(*x));\n+        let _ = !v.iter().any(|x: &u32| deref_enough(*x));\n+\n+        #[allow(clippy::redundant_closure)]\n+        let _ = !v.iter().any(|x| arg_no_deref(&x));\n+        #[allow(clippy::redundant_closure)]\n+        let _ = !v.iter().any(|x: &u32| arg_no_deref(&x));\n+    }\n+\n+    fn field_index_projection() {\n+        struct FooDouble {\n+            bar: Vec<Vec<i32>>,\n+        }\n+        struct Foo {\n+            bar: Vec<i32>,\n+        }\n+        struct FooOuter {\n+            inner: Foo,\n+            inner_double: FooDouble,\n+        }\n+        let vfoo = vec![FooOuter {\n+            inner: Foo { bar: vec![0, 1, 2, 3] },\n+            inner_double: FooDouble {\n+                bar: vec![vec![0, 1, 2, 3]],\n+            },\n+        }];\n+        let _ = !vfoo\n+            .iter().any(|v| v.inner_double.bar[0][0] == 2 && v.inner.bar[0] == 2);\n+    }\n+\n+    fn index_field_projection() {\n+        struct Foo {\n+            bar: i32,\n+        }\n+        struct FooOuter {\n+            inner: Vec<Foo>,\n+        }\n+        let vfoo = vec![FooOuter {\n+            inner: vec![Foo { bar: 0 }],\n+        }];\n+        let _ = !vfoo.iter().any(|v| v.inner[0].bar == 2);\n+    }\n+\n+    fn double_deref_index_projection() {\n+        let vfoo = vec![&&[0, 1, 2, 3]];\n+        let _ = !vfoo.iter().any(|x| (**x)[0] == 9);\n+    }\n+\n+    fn method_call_by_ref() {\n+        struct Foo {\n+            bar: u32,\n+        }\n+        impl Foo {\n+            pub fn by_ref(&self, x: &u32) -> bool {\n+                *x == self.bar\n+            }\n+        }\n+        let vfoo = vec![Foo { bar: 1 }];\n+        let _ = !vfoo.iter().any(|v| v.by_ref(&v.bar));\n+    }\n+\n+    fn ref_bindings() {\n+        let _ = ![&(&1, 2), &(&3, 4), &(&5, 4)].iter().any(|(&x, y)| x == *y);\n+        let _ = ![&(&1, 2), &(&3, 4), &(&5, 4)].iter().any(|(&x, y)| x == *y);\n+    }\n+\n+    fn test_string_1(s: &str) -> bool {\n+        s.is_empty()\n+    }\n+\n+    fn test_u32_1(s: &u32) -> bool {\n+        s.is_power_of_two()\n+    }\n+\n+    fn test_u32_2(s: u32) -> bool {\n+        s.is_power_of_two()\n+    }\n+\n+    fn projection_in_args_test() {\n+        // Index projections\n+        let lst = &[String::from(\"Hello\"), String::from(\"world\")];\n+        let v: Vec<&[String]> = vec![lst];\n+        let _ = !v.iter().any(|s| s[0].is_empty());\n+        let _ = !v.iter().any(|s| test_string_1(&s[0]));\n+\n+        // Field projections\n+        struct FieldProjection<'a> {\n+            field: &'a u32,\n+        }\n+        let field = 123456789;\n+        let instance = FieldProjection { field: &field };\n+        let v = vec![instance];\n+        let _ = !v.iter().any(|fp| fp.field.is_power_of_two());\n+        let _ = !v.iter().any(|fp| test_u32_1(fp.field));\n+        let _ = !v.iter().any(|fp| test_u32_2(*fp.field));\n+    }\n+}"}, {"sha": "778f4f6fa257e6d9192c8c90ce3a0cea40b00bba", "filename": "tests/ui/search_is_some_fixable_none.rs", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/d5d830a50f0a0211bd0820aa8403df8d47f109c3/tests%2Fui%2Fsearch_is_some_fixable_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d830a50f0a0211bd0820aa8403df8d47f109c3/tests%2Fui%2Fsearch_is_some_fixable_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_none.rs?ref=d5d830a50f0a0211bd0820aa8403df8d47f109c3", "patch": "@@ -0,0 +1,222 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+#![warn(clippy::search_is_some)]\n+\n+fn main() {\n+    let v = vec![3, 2, 1, 0, -1, -2, -3];\n+    let y = &&42;\n+\n+    // Check `find().is_none()`, single-line case.\n+    let _ = v.iter().find(|&x| *x < 0).is_none();\n+    let _ = (0..1).find(|x| **y == *x).is_none(); // one dereference less\n+    let _ = (0..1).find(|x| *x == 0).is_none();\n+    let _ = v.iter().find(|x| **x == 0).is_none();\n+    let _ = (4..5).find(|x| *x == 1 || *x == 3 || *x == 5).is_none();\n+    let _ = (1..3).find(|x| [1, 2, 3].contains(x)).is_none();\n+    let _ = (1..3).find(|x| *x == 0 || [1, 2, 3].contains(x)).is_none();\n+    let _ = (1..3).find(|x| [1, 2, 3].contains(x) || *x == 0).is_none();\n+    let _ = (1..3)\n+        .find(|x| [1, 2, 3].contains(x) || *x == 0 || [4, 5, 6].contains(x) || *x == -1)\n+        .is_none();\n+\n+    // Check `position().is_none()`, single-line case.\n+    let _ = v.iter().position(|&x| x < 0).is_none();\n+\n+    // Check `rposition().is_none()`, single-line case.\n+    let _ = v.iter().rposition(|&x| x < 0).is_none();\n+\n+    let s1 = String::from(\"hello world\");\n+    let s2 = String::from(\"world\");\n+\n+    // caller of `find()` is a `&`static str`\n+    let _ = \"hello world\".find(\"world\").is_none();\n+    let _ = \"hello world\".find(&s2).is_none();\n+    let _ = \"hello world\".find(&s2[2..]).is_none();\n+    // caller of `find()` is a `String`\n+    let _ = s1.find(\"world\").is_none();\n+    let _ = s1.find(&s2).is_none();\n+    let _ = s1.find(&s2[2..]).is_none();\n+    // caller of `find()` is slice of `String`\n+    let _ = s1[2..].find(\"world\").is_none();\n+    let _ = s1[2..].find(&s2).is_none();\n+    let _ = s1[2..].find(&s2[2..]).is_none();\n+}\n+\n+#[allow(clippy::clone_on_copy, clippy::map_clone)]\n+mod issue7392 {\n+    struct Player {\n+        hand: Vec<usize>,\n+    }\n+    fn filter() {\n+        let p = Player {\n+            hand: vec![1, 2, 3, 4, 5],\n+        };\n+        let filter_hand = vec![5];\n+        let _ = p\n+            .hand\n+            .iter()\n+            .filter(|c| filter_hand.iter().find(|cc| c == cc).is_none())\n+            .map(|c| c.clone())\n+            .collect::<Vec<_>>();\n+    }\n+\n+    struct PlayerTuple {\n+        hand: Vec<(usize, char)>,\n+    }\n+    fn filter_tuple() {\n+        let p = PlayerTuple {\n+            hand: vec![(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e')],\n+        };\n+        let filter_hand = vec![5];\n+        let _ = p\n+            .hand\n+            .iter()\n+            .filter(|(c, _)| filter_hand.iter().find(|cc| c == *cc).is_none())\n+            .map(|c| c.clone())\n+            .collect::<Vec<_>>();\n+    }\n+\n+    fn field_projection() {\n+        struct Foo {\n+            foo: i32,\n+            bar: u32,\n+        }\n+        let vfoo = vec![Foo { foo: 1, bar: 2 }];\n+        let _ = vfoo.iter().find(|v| v.foo == 1 && v.bar == 2).is_none();\n+\n+        let vfoo = vec![(42, Foo { foo: 1, bar: 2 })];\n+        let _ = vfoo\n+            .iter()\n+            .find(|(i, v)| *i == 42 && v.foo == 1 && v.bar == 2)\n+            .is_none();\n+    }\n+\n+    fn index_projection() {\n+        let vfoo = vec![[0, 1, 2, 3]];\n+        let _ = vfoo.iter().find(|a| a[0] == 42).is_none();\n+    }\n+\n+    #[allow(clippy::match_like_matches_macro)]\n+    fn slice_projection() {\n+        let vfoo = vec![[0, 1, 2, 3, 0, 1, 2, 3]];\n+        let _ = vfoo.iter().find(|sub| sub[1..4].len() == 3).is_none();\n+    }\n+\n+    fn please(x: &u32) -> bool {\n+        *x == 9\n+    }\n+\n+    fn deref_enough(x: u32) -> bool {\n+        x == 78\n+    }\n+\n+    fn arg_no_deref(x: &&u32) -> bool {\n+        **x == 78\n+    }\n+\n+    fn more_projections() {\n+        let x = 19;\n+        let ppx: &u32 = &x;\n+        let _ = [ppx].iter().find(|ppp_x: &&&u32| please(**ppp_x)).is_none();\n+        let _ = [String::from(\"Hey hey\")].iter().find(|s| s.len() == 2).is_none();\n+\n+        let v = vec![3, 2, 1, 0];\n+        let _ = v.iter().find(|x| deref_enough(**x)).is_none();\n+        let _ = v.iter().find(|x: &&u32| deref_enough(**x)).is_none();\n+\n+        #[allow(clippy::redundant_closure)]\n+        let _ = v.iter().find(|x| arg_no_deref(x)).is_none();\n+        #[allow(clippy::redundant_closure)]\n+        let _ = v.iter().find(|x: &&u32| arg_no_deref(x)).is_none();\n+    }\n+\n+    fn field_index_projection() {\n+        struct FooDouble {\n+            bar: Vec<Vec<i32>>,\n+        }\n+        struct Foo {\n+            bar: Vec<i32>,\n+        }\n+        struct FooOuter {\n+            inner: Foo,\n+            inner_double: FooDouble,\n+        }\n+        let vfoo = vec![FooOuter {\n+            inner: Foo { bar: vec![0, 1, 2, 3] },\n+            inner_double: FooDouble {\n+                bar: vec![vec![0, 1, 2, 3]],\n+            },\n+        }];\n+        let _ = vfoo\n+            .iter()\n+            .find(|v| v.inner_double.bar[0][0] == 2 && v.inner.bar[0] == 2)\n+            .is_none();\n+    }\n+\n+    fn index_field_projection() {\n+        struct Foo {\n+            bar: i32,\n+        }\n+        struct FooOuter {\n+            inner: Vec<Foo>,\n+        }\n+        let vfoo = vec![FooOuter {\n+            inner: vec![Foo { bar: 0 }],\n+        }];\n+        let _ = vfoo.iter().find(|v| v.inner[0].bar == 2).is_none();\n+    }\n+\n+    fn double_deref_index_projection() {\n+        let vfoo = vec![&&[0, 1, 2, 3]];\n+        let _ = vfoo.iter().find(|x| (**x)[0] == 9).is_none();\n+    }\n+\n+    fn method_call_by_ref() {\n+        struct Foo {\n+            bar: u32,\n+        }\n+        impl Foo {\n+            pub fn by_ref(&self, x: &u32) -> bool {\n+                *x == self.bar\n+            }\n+        }\n+        let vfoo = vec![Foo { bar: 1 }];\n+        let _ = vfoo.iter().find(|v| v.by_ref(&v.bar)).is_none();\n+    }\n+\n+    fn ref_bindings() {\n+        let _ = [&(&1, 2), &(&3, 4), &(&5, 4)].iter().find(|(&x, y)| x == *y).is_none();\n+        let _ = [&(&1, 2), &(&3, 4), &(&5, 4)].iter().find(|&(&x, y)| x == *y).is_none();\n+    }\n+\n+    fn test_string_1(s: &String) -> bool {\n+        s.is_empty()\n+    }\n+\n+    fn test_u32_1(s: &u32) -> bool {\n+        s.is_power_of_two()\n+    }\n+\n+    fn test_u32_2(s: u32) -> bool {\n+        s.is_power_of_two()\n+    }\n+\n+    fn projection_in_args_test() {\n+        // Index projections\n+        let lst = &[String::from(\"Hello\"), String::from(\"world\")];\n+        let v: Vec<&[String]> = vec![lst];\n+        let _ = v.iter().find(|s| s[0].is_empty()).is_none();\n+        let _ = v.iter().find(|s| test_string_1(&s[0])).is_none();\n+\n+        // Field projections\n+        struct FieldProjection<'a> {\n+            field: &'a u32,\n+        }\n+        let field = 123456789;\n+        let instance = FieldProjection { field: &field };\n+        let v = vec![instance];\n+        let _ = v.iter().find(|fp| fp.field.is_power_of_two()).is_none();\n+        let _ = v.iter().find(|fp| test_u32_1(fp.field)).is_none();\n+        let _ = v.iter().find(|fp| test_u32_2(*fp.field)).is_none();\n+    }\n+}"}, {"sha": "7c5e5eb589c1a53d2b9deb1ed33639b383843327", "filename": "tests/ui/search_is_some_fixable_none.stderr", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/d5d830a50f0a0211bd0820aa8403df8d47f109c3/tests%2Fui%2Fsearch_is_some_fixable_none.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5d830a50f0a0211bd0820aa8403df8d47f109c3/tests%2Fui%2Fsearch_is_some_fixable_none.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_none.stderr?ref=d5d830a50f0a0211bd0820aa8403df8d47f109c3", "patch": "@@ -0,0 +1,293 @@\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:10:13\n+   |\n+LL |     let _ = v.iter().find(|&x| *x < 0).is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|x| *x < 0)`\n+   |\n+   = note: `-D clippy::search-is-some` implied by `-D warnings`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:11:13\n+   |\n+LL |     let _ = (0..1).find(|x| **y == *x).is_none(); // one dereference less\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!(0..1).any(|x| **y == x)`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:12:13\n+   |\n+LL |     let _ = (0..1).find(|x| *x == 0).is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!(0..1).any(|x| x == 0)`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:13:13\n+   |\n+LL |     let _ = v.iter().find(|x| **x == 0).is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|x| *x == 0)`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:14:13\n+   |\n+LL |     let _ = (4..5).find(|x| *x == 1 || *x == 3 || *x == 5).is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!(4..5).any(|x| x == 1 || x == 3 || x == 5)`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:15:13\n+   |\n+LL |     let _ = (1..3).find(|x| [1, 2, 3].contains(x)).is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!(1..3).any(|x| [1, 2, 3].contains(&x))`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:16:13\n+   |\n+LL |     let _ = (1..3).find(|x| *x == 0 || [1, 2, 3].contains(x)).is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!(1..3).any(|x| x == 0 || [1, 2, 3].contains(&x))`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:17:13\n+   |\n+LL |     let _ = (1..3).find(|x| [1, 2, 3].contains(x) || *x == 0).is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!(1..3).any(|x| [1, 2, 3].contains(&x) || x == 0)`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:18:13\n+   |\n+LL |       let _ = (1..3)\n+   |  _____________^\n+LL | |         .find(|x| [1, 2, 3].contains(x) || *x == 0 || [4, 5, 6].contains(x) || *x == -1)\n+LL | |         .is_none();\n+   | |__________________^ help: use `!_.any()` instead: `!(1..3).any(|x| [1, 2, 3].contains(&x) || x == 0 || [4, 5, 6].contains(&x) || x == -1)`\n+\n+error: called `is_none()` after searching an `Iterator` with `position`\n+  --> $DIR/search_is_some_fixable_none.rs:23:13\n+   |\n+LL |     let _ = v.iter().position(|&x| x < 0).is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|&x| x < 0)`\n+\n+error: called `is_none()` after searching an `Iterator` with `rposition`\n+  --> $DIR/search_is_some_fixable_none.rs:26:13\n+   |\n+LL |     let _ = v.iter().rposition(|&x| x < 0).is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|&x| x < 0)`\n+\n+error: called `is_none()` after calling `find()` on a string\n+  --> $DIR/search_is_some_fixable_none.rs:32:13\n+   |\n+LL |     let _ = \"hello world\".find(\"world\").is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!\"hello world\".contains(\"world\")`\n+\n+error: called `is_none()` after calling `find()` on a string\n+  --> $DIR/search_is_some_fixable_none.rs:33:13\n+   |\n+LL |     let _ = \"hello world\".find(&s2).is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!\"hello world\".contains(&s2)`\n+\n+error: called `is_none()` after calling `find()` on a string\n+  --> $DIR/search_is_some_fixable_none.rs:34:13\n+   |\n+LL |     let _ = \"hello world\".find(&s2[2..]).is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!\"hello world\".contains(&s2[2..])`\n+\n+error: called `is_none()` after calling `find()` on a string\n+  --> $DIR/search_is_some_fixable_none.rs:36:13\n+   |\n+LL |     let _ = s1.find(\"world\").is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!s1.contains(\"world\")`\n+\n+error: called `is_none()` after calling `find()` on a string\n+  --> $DIR/search_is_some_fixable_none.rs:37:13\n+   |\n+LL |     let _ = s1.find(&s2).is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!s1.contains(&s2)`\n+\n+error: called `is_none()` after calling `find()` on a string\n+  --> $DIR/search_is_some_fixable_none.rs:38:13\n+   |\n+LL |     let _ = s1.find(&s2[2..]).is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!s1.contains(&s2[2..])`\n+\n+error: called `is_none()` after calling `find()` on a string\n+  --> $DIR/search_is_some_fixable_none.rs:40:13\n+   |\n+LL |     let _ = s1[2..].find(\"world\").is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!s1[2..].contains(\"world\")`\n+\n+error: called `is_none()` after calling `find()` on a string\n+  --> $DIR/search_is_some_fixable_none.rs:41:13\n+   |\n+LL |     let _ = s1[2..].find(&s2).is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!s1[2..].contains(&s2)`\n+\n+error: called `is_none()` after calling `find()` on a string\n+  --> $DIR/search_is_some_fixable_none.rs:42:13\n+   |\n+LL |     let _ = s1[2..].find(&s2[2..]).is_none();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.contains()` instead: `!s1[2..].contains(&s2[2..])`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:58:25\n+   |\n+LL |             .filter(|c| filter_hand.iter().find(|cc| c == cc).is_none())\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!filter_hand.iter().any(|cc| c == &cc)`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:74:30\n+   |\n+LL |             .filter(|(c, _)| filter_hand.iter().find(|cc| c == *cc).is_none())\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!filter_hand.iter().any(|cc| c == cc)`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:85:17\n+   |\n+LL |         let _ = vfoo.iter().find(|v| v.foo == 1 && v.bar == 2).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!vfoo.iter().any(|v| v.foo == 1 && v.bar == 2)`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:88:17\n+   |\n+LL |           let _ = vfoo\n+   |  _________________^\n+LL | |             .iter()\n+LL | |             .find(|(i, v)| *i == 42 && v.foo == 1 && v.bar == 2)\n+LL | |             .is_none();\n+   | |______________________^\n+   |\n+help: use `!_.any()` instead\n+   |\n+LL ~         let _ = !vfoo\n+LL ~             .iter().any(|(i, v)| *i == 42 && v.foo == 1 && v.bar == 2);\n+   |\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:96:17\n+   |\n+LL |         let _ = vfoo.iter().find(|a| a[0] == 42).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!vfoo.iter().any(|a| a[0] == 42)`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:102:17\n+   |\n+LL |         let _ = vfoo.iter().find(|sub| sub[1..4].len() == 3).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!vfoo.iter().any(|sub| sub[1..4].len() == 3)`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:120:17\n+   |\n+LL |         let _ = [ppx].iter().find(|ppp_x: &&&u32| please(**ppp_x)).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `![ppx].iter().any(|ppp_x: &&u32| please(ppp_x))`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:121:17\n+   |\n+LL |         let _ = [String::from(\"Hey hey\")].iter().find(|s| s.len() == 2).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `![String::from(\"Hey hey\")].iter().any(|s| s.len() == 2)`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:124:17\n+   |\n+LL |         let _ = v.iter().find(|x| deref_enough(**x)).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|x| deref_enough(*x))`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:125:17\n+   |\n+LL |         let _ = v.iter().find(|x: &&u32| deref_enough(**x)).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|x: &u32| deref_enough(*x))`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:128:17\n+   |\n+LL |         let _ = v.iter().find(|x| arg_no_deref(x)).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|x| arg_no_deref(&x))`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:130:17\n+   |\n+LL |         let _ = v.iter().find(|x: &&u32| arg_no_deref(x)).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|x: &u32| arg_no_deref(&x))`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:150:17\n+   |\n+LL |           let _ = vfoo\n+   |  _________________^\n+LL | |             .iter()\n+LL | |             .find(|v| v.inner_double.bar[0][0] == 2 && v.inner.bar[0] == 2)\n+LL | |             .is_none();\n+   | |______________________^\n+   |\n+help: use `!_.any()` instead\n+   |\n+LL ~         let _ = !vfoo\n+LL ~             .iter().any(|v| v.inner_double.bar[0][0] == 2 && v.inner.bar[0] == 2);\n+   |\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:166:17\n+   |\n+LL |         let _ = vfoo.iter().find(|v| v.inner[0].bar == 2).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!vfoo.iter().any(|v| v.inner[0].bar == 2)`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:171:17\n+   |\n+LL |         let _ = vfoo.iter().find(|x| (**x)[0] == 9).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!vfoo.iter().any(|x| (**x)[0] == 9)`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:184:17\n+   |\n+LL |         let _ = vfoo.iter().find(|v| v.by_ref(&v.bar)).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!vfoo.iter().any(|v| v.by_ref(&v.bar))`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:188:17\n+   |\n+LL |         let _ = [&(&1, 2), &(&3, 4), &(&5, 4)].iter().find(|(&x, y)| x == *y).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `![&(&1, 2), &(&3, 4), &(&5, 4)].iter().any(|(&x, y)| x == *y)`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:189:17\n+   |\n+LL |         let _ = [&(&1, 2), &(&3, 4), &(&5, 4)].iter().find(|&(&x, y)| x == *y).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `![&(&1, 2), &(&3, 4), &(&5, 4)].iter().any(|(&x, y)| x == *y)`\n+\n+error: writing `&String` instead of `&str` involves a new object where a slice will do\n+  --> $DIR/search_is_some_fixable_none.rs:192:25\n+   |\n+LL |     fn test_string_1(s: &String) -> bool {\n+   |                         ^^^^^^^ help: change this to: `&str`\n+   |\n+   = note: `-D clippy::ptr-arg` implied by `-D warnings`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:208:17\n+   |\n+LL |         let _ = v.iter().find(|s| s[0].is_empty()).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|s| s[0].is_empty())`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:209:17\n+   |\n+LL |         let _ = v.iter().find(|s| test_string_1(&s[0])).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|s| test_string_1(&s[0]))`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:218:17\n+   |\n+LL |         let _ = v.iter().find(|fp| fp.field.is_power_of_two()).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|fp| fp.field.is_power_of_two())`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:219:17\n+   |\n+LL |         let _ = v.iter().find(|fp| test_u32_1(fp.field)).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|fp| test_u32_1(fp.field))`\n+\n+error: called `is_none()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_none.rs:220:17\n+   |\n+LL |         let _ = v.iter().find(|fp| test_u32_2(*fp.field)).is_none();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `!_.any()` instead: `!v.iter().any(|fp| test_u32_2(*fp.field))`\n+\n+error: aborting due to 44 previous errors\n+"}, {"sha": "7c940a2b069e47ed52a467251fedc3fa99c93fb2", "filename": "tests/ui/search_is_some_fixable_some.fixed", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/d5d830a50f0a0211bd0820aa8403df8d47f109c3/tests%2Fui%2Fsearch_is_some_fixable_some.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d5d830a50f0a0211bd0820aa8403df8d47f109c3/tests%2Fui%2Fsearch_is_some_fixable_some.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_some.fixed?ref=d5d830a50f0a0211bd0820aa8403df8d47f109c3", "patch": "@@ -0,0 +1,218 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+#![warn(clippy::search_is_some)]\n+\n+fn main() {\n+    let v = vec![3, 2, 1, 0, -1, -2, -3];\n+    let y = &&42;\n+\n+    // Check `find().is_some()`, single-line case.\n+    let _ = v.iter().any(|x| *x < 0);\n+    let _ = (0..1).any(|x| **y == x); // one dereference less\n+    let _ = (0..1).any(|x| x == 0);\n+    let _ = v.iter().any(|x| *x == 0);\n+    let _ = (4..5).any(|x| x == 1 || x == 3 || x == 5);\n+    let _ = (1..3).any(|x| [1, 2, 3].contains(&x));\n+    let _ = (1..3).any(|x| x == 0 || [1, 2, 3].contains(&x));\n+    let _ = (1..3).any(|x| [1, 2, 3].contains(&x) || x == 0);\n+    let _ = (1..3)\n+        .any(|x| [1, 2, 3].contains(&x) || x == 0 || [4, 5, 6].contains(&x) || x == -1);\n+\n+    // Check `position().is_some()`, single-line case.\n+    let _ = v.iter().any(|&x| x < 0);\n+\n+    // Check `rposition().is_some()`, single-line case.\n+    let _ = v.iter().any(|&x| x < 0);\n+\n+    let s1 = String::from(\"hello world\");\n+    let s2 = String::from(\"world\");\n+    // caller of `find()` is a `&`static str`\n+    let _ = \"hello world\".contains(\"world\");\n+    let _ = \"hello world\".contains(&s2);\n+    let _ = \"hello world\".contains(&s2[2..]);\n+    // caller of `find()` is a `String`\n+    let _ = s1.contains(\"world\");\n+    let _ = s1.contains(&s2);\n+    let _ = s1.contains(&s2[2..]);\n+    // caller of `find()` is slice of `String`\n+    let _ = s1[2..].contains(\"world\");\n+    let _ = s1[2..].contains(&s2);\n+    let _ = s1[2..].contains(&s2[2..]);\n+}\n+\n+#[allow(clippy::clone_on_copy, clippy::map_clone)]\n+mod issue7392 {\n+    struct Player {\n+        hand: Vec<usize>,\n+    }\n+    fn filter() {\n+        let p = Player {\n+            hand: vec![1, 2, 3, 4, 5],\n+        };\n+        let filter_hand = vec![5];\n+        let _ = p\n+            .hand\n+            .iter()\n+            .filter(|c| filter_hand.iter().any(|cc| c == &cc))\n+            .map(|c| c.clone())\n+            .collect::<Vec<_>>();\n+    }\n+\n+    struct PlayerTuple {\n+        hand: Vec<(usize, char)>,\n+    }\n+    fn filter_tuple() {\n+        let p = PlayerTuple {\n+            hand: vec![(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e')],\n+        };\n+        let filter_hand = vec![5];\n+        let _ = p\n+            .hand\n+            .iter()\n+            .filter(|(c, _)| filter_hand.iter().any(|cc| c == cc))\n+            .map(|c| c.clone())\n+            .collect::<Vec<_>>();\n+    }\n+\n+    fn field_projection() {\n+        struct Foo {\n+            foo: i32,\n+            bar: u32,\n+        }\n+        let vfoo = vec![Foo { foo: 1, bar: 2 }];\n+        let _ = vfoo.iter().any(|v| v.foo == 1 && v.bar == 2);\n+\n+        let vfoo = vec![(42, Foo { foo: 1, bar: 2 })];\n+        let _ = vfoo\n+            .iter()\n+            .any(|(i, v)| *i == 42 && v.foo == 1 && v.bar == 2);\n+    }\n+\n+    fn index_projection() {\n+        let vfoo = vec![[0, 1, 2, 3]];\n+        let _ = vfoo.iter().any(|a| a[0] == 42);\n+    }\n+\n+    #[allow(clippy::match_like_matches_macro)]\n+    fn slice_projection() {\n+        let vfoo = vec![[0, 1, 2, 3, 0, 1, 2, 3]];\n+        let _ = vfoo.iter().any(|sub| sub[1..4].len() == 3);\n+    }\n+\n+    fn please(x: &u32) -> bool {\n+        *x == 9\n+    }\n+\n+    fn deref_enough(x: u32) -> bool {\n+        x == 78\n+    }\n+\n+    fn arg_no_deref(x: &&u32) -> bool {\n+        **x == 78\n+    }\n+\n+    fn more_projections() {\n+        let x = 19;\n+        let ppx: &u32 = &x;\n+        let _ = [ppx].iter().any(|ppp_x: &&u32| please(ppp_x));\n+        let _ = [String::from(\"Hey hey\")].iter().any(|s| s.len() == 2);\n+\n+        let v = vec![3, 2, 1, 0];\n+        let _ = v.iter().any(|x| deref_enough(*x));\n+        let _ = v.iter().any(|x: &u32| deref_enough(*x));\n+\n+        #[allow(clippy::redundant_closure)]\n+        let _ = v.iter().any(|x| arg_no_deref(&x));\n+        #[allow(clippy::redundant_closure)]\n+        let _ = v.iter().any(|x: &u32| arg_no_deref(&x));\n+    }\n+\n+    fn field_index_projection() {\n+        struct FooDouble {\n+            bar: Vec<Vec<i32>>,\n+        }\n+        struct Foo {\n+            bar: Vec<i32>,\n+        }\n+        struct FooOuter {\n+            inner: Foo,\n+            inner_double: FooDouble,\n+        }\n+        let vfoo = vec![FooOuter {\n+            inner: Foo { bar: vec![0, 1, 2, 3] },\n+            inner_double: FooDouble {\n+                bar: vec![vec![0, 1, 2, 3]],\n+            },\n+        }];\n+        let _ = vfoo\n+            .iter()\n+            .any(|v| v.inner_double.bar[0][0] == 2 && v.inner.bar[0] == 2);\n+    }\n+\n+    fn index_field_projection() {\n+        struct Foo {\n+            bar: i32,\n+        }\n+        struct FooOuter {\n+            inner: Vec<Foo>,\n+        }\n+        let vfoo = vec![FooOuter {\n+            inner: vec![Foo { bar: 0 }],\n+        }];\n+        let _ = vfoo.iter().any(|v| v.inner[0].bar == 2);\n+    }\n+\n+    fn double_deref_index_projection() {\n+        let vfoo = vec![&&[0, 1, 2, 3]];\n+        let _ = vfoo.iter().any(|x| (**x)[0] == 9);\n+    }\n+\n+    fn method_call_by_ref() {\n+        struct Foo {\n+            bar: u32,\n+        }\n+        impl Foo {\n+            pub fn by_ref(&self, x: &u32) -> bool {\n+                *x == self.bar\n+            }\n+        }\n+        let vfoo = vec![Foo { bar: 1 }];\n+        let _ = vfoo.iter().any(|v| v.by_ref(&v.bar));\n+    }\n+\n+    fn ref_bindings() {\n+        let _ = [&(&1, 2), &(&3, 4), &(&5, 4)].iter().any(|(&x, y)| x == *y);\n+        let _ = [&(&1, 2), &(&3, 4), &(&5, 4)].iter().any(|(&x, y)| x == *y);\n+    }\n+\n+    fn test_string_1(s: &str) -> bool {\n+        s.is_empty()\n+    }\n+\n+    fn test_u32_1(s: &u32) -> bool {\n+        s.is_power_of_two()\n+    }\n+\n+    fn test_u32_2(s: u32) -> bool {\n+        s.is_power_of_two()\n+    }\n+\n+    fn projection_in_args_test() {\n+        // Index projections\n+        let lst = &[String::from(\"Hello\"), String::from(\"world\")];\n+        let v: Vec<&[String]> = vec![lst];\n+        let _ = v.iter().any(|s| s[0].is_empty());\n+        let _ = v.iter().any(|s| test_string_1(&s[0]));\n+\n+        // Field projections\n+        struct FieldProjection<'a> {\n+            field: &'a u32,\n+        }\n+        let field = 123456789;\n+        let instance = FieldProjection { field: &field };\n+        let v = vec![instance];\n+        let _ = v.iter().any(|fp| fp.field.is_power_of_two());\n+        let _ = v.iter().any(|fp| test_u32_1(fp.field));\n+        let _ = v.iter().any(|fp| test_u32_2(*fp.field));\n+    }\n+}"}, {"sha": "241641fceae3d898fd015ece4b64db063d4f9bf8", "filename": "tests/ui/search_is_some_fixable_some.rs", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/d5d830a50f0a0211bd0820aa8403df8d47f109c3/tests%2Fui%2Fsearch_is_some_fixable_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5d830a50f0a0211bd0820aa8403df8d47f109c3/tests%2Fui%2Fsearch_is_some_fixable_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_some.rs?ref=d5d830a50f0a0211bd0820aa8403df8d47f109c3", "patch": "@@ -0,0 +1,221 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+#![warn(clippy::search_is_some)]\n+\n+fn main() {\n+    let v = vec![3, 2, 1, 0, -1, -2, -3];\n+    let y = &&42;\n+\n+    // Check `find().is_some()`, single-line case.\n+    let _ = v.iter().find(|&x| *x < 0).is_some();\n+    let _ = (0..1).find(|x| **y == *x).is_some(); // one dereference less\n+    let _ = (0..1).find(|x| *x == 0).is_some();\n+    let _ = v.iter().find(|x| **x == 0).is_some();\n+    let _ = (4..5).find(|x| *x == 1 || *x == 3 || *x == 5).is_some();\n+    let _ = (1..3).find(|x| [1, 2, 3].contains(x)).is_some();\n+    let _ = (1..3).find(|x| *x == 0 || [1, 2, 3].contains(x)).is_some();\n+    let _ = (1..3).find(|x| [1, 2, 3].contains(x) || *x == 0).is_some();\n+    let _ = (1..3)\n+        .find(|x| [1, 2, 3].contains(x) || *x == 0 || [4, 5, 6].contains(x) || *x == -1)\n+        .is_some();\n+\n+    // Check `position().is_some()`, single-line case.\n+    let _ = v.iter().position(|&x| x < 0).is_some();\n+\n+    // Check `rposition().is_some()`, single-line case.\n+    let _ = v.iter().rposition(|&x| x < 0).is_some();\n+\n+    let s1 = String::from(\"hello world\");\n+    let s2 = String::from(\"world\");\n+    // caller of `find()` is a `&`static str`\n+    let _ = \"hello world\".find(\"world\").is_some();\n+    let _ = \"hello world\".find(&s2).is_some();\n+    let _ = \"hello world\".find(&s2[2..]).is_some();\n+    // caller of `find()` is a `String`\n+    let _ = s1.find(\"world\").is_some();\n+    let _ = s1.find(&s2).is_some();\n+    let _ = s1.find(&s2[2..]).is_some();\n+    // caller of `find()` is slice of `String`\n+    let _ = s1[2..].find(\"world\").is_some();\n+    let _ = s1[2..].find(&s2).is_some();\n+    let _ = s1[2..].find(&s2[2..]).is_some();\n+}\n+\n+#[allow(clippy::clone_on_copy, clippy::map_clone)]\n+mod issue7392 {\n+    struct Player {\n+        hand: Vec<usize>,\n+    }\n+    fn filter() {\n+        let p = Player {\n+            hand: vec![1, 2, 3, 4, 5],\n+        };\n+        let filter_hand = vec![5];\n+        let _ = p\n+            .hand\n+            .iter()\n+            .filter(|c| filter_hand.iter().find(|cc| c == cc).is_some())\n+            .map(|c| c.clone())\n+            .collect::<Vec<_>>();\n+    }\n+\n+    struct PlayerTuple {\n+        hand: Vec<(usize, char)>,\n+    }\n+    fn filter_tuple() {\n+        let p = PlayerTuple {\n+            hand: vec![(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e')],\n+        };\n+        let filter_hand = vec![5];\n+        let _ = p\n+            .hand\n+            .iter()\n+            .filter(|(c, _)| filter_hand.iter().find(|cc| c == *cc).is_some())\n+            .map(|c| c.clone())\n+            .collect::<Vec<_>>();\n+    }\n+\n+    fn field_projection() {\n+        struct Foo {\n+            foo: i32,\n+            bar: u32,\n+        }\n+        let vfoo = vec![Foo { foo: 1, bar: 2 }];\n+        let _ = vfoo.iter().find(|v| v.foo == 1 && v.bar == 2).is_some();\n+\n+        let vfoo = vec![(42, Foo { foo: 1, bar: 2 })];\n+        let _ = vfoo\n+            .iter()\n+            .find(|(i, v)| *i == 42 && v.foo == 1 && v.bar == 2)\n+            .is_some();\n+    }\n+\n+    fn index_projection() {\n+        let vfoo = vec![[0, 1, 2, 3]];\n+        let _ = vfoo.iter().find(|a| a[0] == 42).is_some();\n+    }\n+\n+    #[allow(clippy::match_like_matches_macro)]\n+    fn slice_projection() {\n+        let vfoo = vec![[0, 1, 2, 3, 0, 1, 2, 3]];\n+        let _ = vfoo.iter().find(|sub| sub[1..4].len() == 3).is_some();\n+    }\n+\n+    fn please(x: &u32) -> bool {\n+        *x == 9\n+    }\n+\n+    fn deref_enough(x: u32) -> bool {\n+        x == 78\n+    }\n+\n+    fn arg_no_deref(x: &&u32) -> bool {\n+        **x == 78\n+    }\n+\n+    fn more_projections() {\n+        let x = 19;\n+        let ppx: &u32 = &x;\n+        let _ = [ppx].iter().find(|ppp_x: &&&u32| please(**ppp_x)).is_some();\n+        let _ = [String::from(\"Hey hey\")].iter().find(|s| s.len() == 2).is_some();\n+\n+        let v = vec![3, 2, 1, 0];\n+        let _ = v.iter().find(|x| deref_enough(**x)).is_some();\n+        let _ = v.iter().find(|x: &&u32| deref_enough(**x)).is_some();\n+\n+        #[allow(clippy::redundant_closure)]\n+        let _ = v.iter().find(|x| arg_no_deref(x)).is_some();\n+        #[allow(clippy::redundant_closure)]\n+        let _ = v.iter().find(|x: &&u32| arg_no_deref(x)).is_some();\n+    }\n+\n+    fn field_index_projection() {\n+        struct FooDouble {\n+            bar: Vec<Vec<i32>>,\n+        }\n+        struct Foo {\n+            bar: Vec<i32>,\n+        }\n+        struct FooOuter {\n+            inner: Foo,\n+            inner_double: FooDouble,\n+        }\n+        let vfoo = vec![FooOuter {\n+            inner: Foo { bar: vec![0, 1, 2, 3] },\n+            inner_double: FooDouble {\n+                bar: vec![vec![0, 1, 2, 3]],\n+            },\n+        }];\n+        let _ = vfoo\n+            .iter()\n+            .find(|v| v.inner_double.bar[0][0] == 2 && v.inner.bar[0] == 2)\n+            .is_some();\n+    }\n+\n+    fn index_field_projection() {\n+        struct Foo {\n+            bar: i32,\n+        }\n+        struct FooOuter {\n+            inner: Vec<Foo>,\n+        }\n+        let vfoo = vec![FooOuter {\n+            inner: vec![Foo { bar: 0 }],\n+        }];\n+        let _ = vfoo.iter().find(|v| v.inner[0].bar == 2).is_some();\n+    }\n+\n+    fn double_deref_index_projection() {\n+        let vfoo = vec![&&[0, 1, 2, 3]];\n+        let _ = vfoo.iter().find(|x| (**x)[0] == 9).is_some();\n+    }\n+\n+    fn method_call_by_ref() {\n+        struct Foo {\n+            bar: u32,\n+        }\n+        impl Foo {\n+            pub fn by_ref(&self, x: &u32) -> bool {\n+                *x == self.bar\n+            }\n+        }\n+        let vfoo = vec![Foo { bar: 1 }];\n+        let _ = vfoo.iter().find(|v| v.by_ref(&v.bar)).is_some();\n+    }\n+\n+    fn ref_bindings() {\n+        let _ = [&(&1, 2), &(&3, 4), &(&5, 4)].iter().find(|(&x, y)| x == *y).is_some();\n+        let _ = [&(&1, 2), &(&3, 4), &(&5, 4)].iter().find(|&(&x, y)| x == *y).is_some();\n+    }\n+\n+    fn test_string_1(s: &String) -> bool {\n+        s.is_empty()\n+    }\n+\n+    fn test_u32_1(s: &u32) -> bool {\n+        s.is_power_of_two()\n+    }\n+\n+    fn test_u32_2(s: u32) -> bool {\n+        s.is_power_of_two()\n+    }\n+\n+    fn projection_in_args_test() {\n+        // Index projections\n+        let lst = &[String::from(\"Hello\"), String::from(\"world\")];\n+        let v: Vec<&[String]> = vec![lst];\n+        let _ = v.iter().find(|s| s[0].is_empty()).is_some();\n+        let _ = v.iter().find(|s| test_string_1(&s[0])).is_some();\n+\n+        // Field projections\n+        struct FieldProjection<'a> {\n+            field: &'a u32,\n+        }\n+        let field = 123456789;\n+        let instance = FieldProjection { field: &field };\n+        let v = vec![instance];\n+        let _ = v.iter().find(|fp| fp.field.is_power_of_two()).is_some();\n+        let _ = v.iter().find(|fp| test_u32_1(fp.field)).is_some();\n+        let _ = v.iter().find(|fp| test_u32_2(*fp.field)).is_some();\n+    }\n+}"}, {"sha": "9212c6e71ff54bb7c3c4286683dadc5ec4be5da7", "filename": "tests/ui/search_is_some_fixable_some.stderr", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/d5d830a50f0a0211bd0820aa8403df8d47f109c3/tests%2Fui%2Fsearch_is_some_fixable_some.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5d830a50f0a0211bd0820aa8403df8d47f109c3/tests%2Fui%2Fsearch_is_some_fixable_some.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsearch_is_some_fixable_some.stderr?ref=d5d830a50f0a0211bd0820aa8403df8d47f109c3", "patch": "@@ -0,0 +1,276 @@\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:10:22\n+   |\n+LL |     let _ = v.iter().find(|&x| *x < 0).is_some();\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| *x < 0)`\n+   |\n+   = note: `-D clippy::search-is-some` implied by `-D warnings`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:11:20\n+   |\n+LL |     let _ = (0..1).find(|x| **y == *x).is_some(); // one dereference less\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| **y == x)`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:12:20\n+   |\n+LL |     let _ = (0..1).find(|x| *x == 0).is_some();\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| x == 0)`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:13:22\n+   |\n+LL |     let _ = v.iter().find(|x| **x == 0).is_some();\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| *x == 0)`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:14:20\n+   |\n+LL |     let _ = (4..5).find(|x| *x == 1 || *x == 3 || *x == 5).is_some();\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| x == 1 || x == 3 || x == 5)`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:15:20\n+   |\n+LL |     let _ = (1..3).find(|x| [1, 2, 3].contains(x)).is_some();\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| [1, 2, 3].contains(&x))`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:16:20\n+   |\n+LL |     let _ = (1..3).find(|x| *x == 0 || [1, 2, 3].contains(x)).is_some();\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| x == 0 || [1, 2, 3].contains(&x))`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:17:20\n+   |\n+LL |     let _ = (1..3).find(|x| [1, 2, 3].contains(x) || *x == 0).is_some();\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| [1, 2, 3].contains(&x) || x == 0)`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:19:10\n+   |\n+LL |           .find(|x| [1, 2, 3].contains(x) || *x == 0 || [4, 5, 6].contains(x) || *x == -1)\n+   |  __________^\n+LL | |         .is_some();\n+   | |__________________^ help: use `any()` instead: `any(|x| [1, 2, 3].contains(&x) || x == 0 || [4, 5, 6].contains(&x) || x == -1)`\n+\n+error: called `is_some()` after searching an `Iterator` with `position`\n+  --> $DIR/search_is_some_fixable_some.rs:23:22\n+   |\n+LL |     let _ = v.iter().position(|&x| x < 0).is_some();\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|&x| x < 0)`\n+\n+error: called `is_some()` after searching an `Iterator` with `rposition`\n+  --> $DIR/search_is_some_fixable_some.rs:26:22\n+   |\n+LL |     let _ = v.iter().rposition(|&x| x < 0).is_some();\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|&x| x < 0)`\n+\n+error: called `is_some()` after calling `find()` on a string\n+  --> $DIR/search_is_some_fixable_some.rs:31:27\n+   |\n+LL |     let _ = \"hello world\".find(\"world\").is_some();\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(\"world\")`\n+\n+error: called `is_some()` after calling `find()` on a string\n+  --> $DIR/search_is_some_fixable_some.rs:32:27\n+   |\n+LL |     let _ = \"hello world\".find(&s2).is_some();\n+   |                           ^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(&s2)`\n+\n+error: called `is_some()` after calling `find()` on a string\n+  --> $DIR/search_is_some_fixable_some.rs:33:27\n+   |\n+LL |     let _ = \"hello world\".find(&s2[2..]).is_some();\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(&s2[2..])`\n+\n+error: called `is_some()` after calling `find()` on a string\n+  --> $DIR/search_is_some_fixable_some.rs:35:16\n+   |\n+LL |     let _ = s1.find(\"world\").is_some();\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(\"world\")`\n+\n+error: called `is_some()` after calling `find()` on a string\n+  --> $DIR/search_is_some_fixable_some.rs:36:16\n+   |\n+LL |     let _ = s1.find(&s2).is_some();\n+   |                ^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(&s2)`\n+\n+error: called `is_some()` after calling `find()` on a string\n+  --> $DIR/search_is_some_fixable_some.rs:37:16\n+   |\n+LL |     let _ = s1.find(&s2[2..]).is_some();\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(&s2[2..])`\n+\n+error: called `is_some()` after calling `find()` on a string\n+  --> $DIR/search_is_some_fixable_some.rs:39:21\n+   |\n+LL |     let _ = s1[2..].find(\"world\").is_some();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(\"world\")`\n+\n+error: called `is_some()` after calling `find()` on a string\n+  --> $DIR/search_is_some_fixable_some.rs:40:21\n+   |\n+LL |     let _ = s1[2..].find(&s2).is_some();\n+   |                     ^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(&s2)`\n+\n+error: called `is_some()` after calling `find()` on a string\n+  --> $DIR/search_is_some_fixable_some.rs:41:21\n+   |\n+LL |     let _ = s1[2..].find(&s2[2..]).is_some();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: use `contains()` instead: `contains(&s2[2..])`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:57:44\n+   |\n+LL |             .filter(|c| filter_hand.iter().find(|cc| c == cc).is_some())\n+   |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|cc| c == &cc)`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:73:49\n+   |\n+LL |             .filter(|(c, _)| filter_hand.iter().find(|cc| c == *cc).is_some())\n+   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|cc| c == cc)`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:84:29\n+   |\n+LL |         let _ = vfoo.iter().find(|v| v.foo == 1 && v.bar == 2).is_some();\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|v| v.foo == 1 && v.bar == 2)`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:89:14\n+   |\n+LL |               .find(|(i, v)| *i == 42 && v.foo == 1 && v.bar == 2)\n+   |  ______________^\n+LL | |             .is_some();\n+   | |______________________^ help: use `any()` instead: `any(|(i, v)| *i == 42 && v.foo == 1 && v.bar == 2)`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:95:29\n+   |\n+LL |         let _ = vfoo.iter().find(|a| a[0] == 42).is_some();\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|a| a[0] == 42)`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:101:29\n+   |\n+LL |         let _ = vfoo.iter().find(|sub| sub[1..4].len() == 3).is_some();\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|sub| sub[1..4].len() == 3)`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:119:30\n+   |\n+LL |         let _ = [ppx].iter().find(|ppp_x: &&&u32| please(**ppp_x)).is_some();\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|ppp_x: &&u32| please(ppp_x))`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:120:50\n+   |\n+LL |         let _ = [String::from(\"Hey hey\")].iter().find(|s| s.len() == 2).is_some();\n+   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|s| s.len() == 2)`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:123:26\n+   |\n+LL |         let _ = v.iter().find(|x| deref_enough(**x)).is_some();\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| deref_enough(*x))`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:124:26\n+   |\n+LL |         let _ = v.iter().find(|x: &&u32| deref_enough(**x)).is_some();\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x: &u32| deref_enough(*x))`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:127:26\n+   |\n+LL |         let _ = v.iter().find(|x| arg_no_deref(x)).is_some();\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| arg_no_deref(&x))`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:129:26\n+   |\n+LL |         let _ = v.iter().find(|x: &&u32| arg_no_deref(x)).is_some();\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x: &u32| arg_no_deref(&x))`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:151:14\n+   |\n+LL |               .find(|v| v.inner_double.bar[0][0] == 2 && v.inner.bar[0] == 2)\n+   |  ______________^\n+LL | |             .is_some();\n+   | |______________________^ help: use `any()` instead: `any(|v| v.inner_double.bar[0][0] == 2 && v.inner.bar[0] == 2)`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:165:29\n+   |\n+LL |         let _ = vfoo.iter().find(|v| v.inner[0].bar == 2).is_some();\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|v| v.inner[0].bar == 2)`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:170:29\n+   |\n+LL |         let _ = vfoo.iter().find(|x| (**x)[0] == 9).is_some();\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|x| (**x)[0] == 9)`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:183:29\n+   |\n+LL |         let _ = vfoo.iter().find(|v| v.by_ref(&v.bar)).is_some();\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|v| v.by_ref(&v.bar))`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:187:55\n+   |\n+LL |         let _ = [&(&1, 2), &(&3, 4), &(&5, 4)].iter().find(|(&x, y)| x == *y).is_some();\n+   |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|(&x, y)| x == *y)`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:188:55\n+   |\n+LL |         let _ = [&(&1, 2), &(&3, 4), &(&5, 4)].iter().find(|&(&x, y)| x == *y).is_some();\n+   |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|(&x, y)| x == *y)`\n+\n+error: writing `&String` instead of `&str` involves a new object where a slice will do\n+  --> $DIR/search_is_some_fixable_some.rs:191:25\n+   |\n+LL |     fn test_string_1(s: &String) -> bool {\n+   |                         ^^^^^^^ help: change this to: `&str`\n+   |\n+   = note: `-D clippy::ptr-arg` implied by `-D warnings`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:207:26\n+   |\n+LL |         let _ = v.iter().find(|s| s[0].is_empty()).is_some();\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|s| s[0].is_empty())`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:208:26\n+   |\n+LL |         let _ = v.iter().find(|s| test_string_1(&s[0])).is_some();\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|s| test_string_1(&s[0]))`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:217:26\n+   |\n+LL |         let _ = v.iter().find(|fp| fp.field.is_power_of_two()).is_some();\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|fp| fp.field.is_power_of_two())`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:218:26\n+   |\n+LL |         let _ = v.iter().find(|fp| test_u32_1(fp.field)).is_some();\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|fp| test_u32_1(fp.field))`\n+\n+error: called `is_some()` after searching an `Iterator` with `find`\n+  --> $DIR/search_is_some_fixable_some.rs:219:26\n+   |\n+LL |         let _ = v.iter().find(|fp| test_u32_2(*fp.field)).is_some();\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `any()` instead: `any(|fp| test_u32_2(*fp.field))`\n+\n+error: aborting due to 44 previous errors\n+"}]}