{"sha": "3a6320f71b1e1bde9ec3b30563d9f8e0ef4bdbce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhNjMyMGY3MWIxZTFiZGU5ZWMzYjMwNTYzZDlmOGUwZWY0YmRiY2U=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-11-18T20:39:13Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-11-18T20:48:54Z"}, "message": "intrinsics: Eliminate recv intrinsic\n\nThis intrinsic existed just to get ahold of the return pointer. I replaced it\nwith a call_with_retptr intrinsic that grabs the return pointer and passes it\nto another Rust function, thereby eliminating the need to call C functions on\nthe Rust stack.", "tree": {"sha": "1db92aea52237c973ee22d83139448f23336f40b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1db92aea52237c973ee22d83139448f23336f40b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a6320f71b1e1bde9ec3b30563d9f8e0ef4bdbce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a6320f71b1e1bde9ec3b30563d9f8e0ef4bdbce", "html_url": "https://github.com/rust-lang/rust/commit/3a6320f71b1e1bde9ec3b30563d9f8e0ef4bdbce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a6320f71b1e1bde9ec3b30563d9f8e0ef4bdbce/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93931311ff1d034ef92e35f36c900bbd74176179", "url": "https://api.github.com/repos/rust-lang/rust/commits/93931311ff1d034ef92e35f36c900bbd74176179", "html_url": "https://github.com/rust-lang/rust/commit/93931311ff1d034ef92e35f36c900bbd74176179"}], "stats": {"total": 164, "additions": 102, "deletions": 62}, "files": [{"sha": "eb96ed546b192b4e40415941089ce7d9670665ae", "filename": "src/lib/comm.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3a6320f71b1e1bde9ec3b30563d9f8e0ef4bdbce/src%2Flib%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a6320f71b1e1bde9ec3b30563d9f8e0ef4bdbce/src%2Flib%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fcomm.rs?ref=3a6320f71b1e1bde9ec3b30563d9f8e0ef4bdbce", "patch": "@@ -48,11 +48,13 @@ native mod rustrt {\n     fn rust_port_detach(po: *rust_port);\n     fn get_port_id(po: *rust_port) -> port_id;\n     fn rust_port_size(po: *rust_port) -> ctypes::size_t;\n+    fn port_recv(dptr: *uint, po: *rust_port,\n+                 yield: *ctypes::uintptr_t);\n }\n \n #[abi = \"rust-intrinsic\"]\n native mod rusti {\n-    fn recv<send T>(port: *rustrt::rust_port) -> T;\n+    fn call_with_retptr<send T>(&&f: fn@(*uint)) -> T;\n }\n \n type port_id = int;\n@@ -87,7 +89,7 @@ resource port_ptr<send T>(po: *rustrt::rust_port) {\n     while rustrt::rust_port_size(po) > 0u {\n         // FIXME: For some reason if we don't assign to something here\n         // we end up with invalid reads in the drop glue.\n-        let _t = rusti::recv::<T>(po);\n+        let _t = recv_::<T>(po);\n     }\n     rustrt::del_port(po);\n }\n@@ -140,7 +142,29 @@ Receive from a port.\n If no data is available on the port then the task will block until data\n becomes available.\n */\n-fn recv<send T>(p: port<T>) -> T { ret rusti::recv(***p) }\n+fn recv<send T>(p: port<T>) -> T { recv_(***p) }\n+\n+// Receive on a raw port pointer\n+fn recv_<send T>(p: *rustrt::rust_port) -> T {\n+    // FIXME: Due to issue 1185 we can't use a return pointer when\n+    // calling C code, and since we can't create our own return\n+    // pointer on the stack, we're going to call a little intrinsic\n+    // that will grab the value of the return pointer, then call this\n+    // function, which we will then use to call the runtime.\n+    fn recv(dptr: *uint, port: *rustrt::rust_port,\n+                    yield: *ctypes::uintptr_t) unsafe {\n+        rustrt::port_recv(dptr,\n+                          port, yield);\n+    }\n+    let yield = 0u;\n+    let yieldp = ptr::addr_of(yield);\n+    let res = rusti::call_with_retptr(bind recv(_, p, yieldp));\n+    if yield != 0u {\n+        // Data isn't available yet, so res has not been initialized.\n+        task::yield();\n+    }\n+    ret res;\n+}\n \n /*\n Function: chan"}, {"sha": "23f4cf50672b649a8f4b9051e3f1fe55f61bc65a", "filename": "src/rt/intrinsics/intrinsics.cpp", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3a6320f71b1e1bde9ec3b30563d9f8e0ef4bdbce/src%2Frt%2Fintrinsics%2Fintrinsics.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3a6320f71b1e1bde9ec3b30563d9f8e0ef4bdbce/src%2Frt%2Fintrinsics%2Fintrinsics.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.cpp?ref=3a6320f71b1e1bde9ec3b30563d9f8e0ef4bdbce", "patch": "@@ -53,12 +53,22 @@ rust_intrinsic_addr_of(void **retptr,\n     *retptr = valptr;\n }\n \n+struct rust_fn {\n+    uintptr_t *fn;\n+    rust_box *env;\n+};\n+\n+typedef void (*retptr_fn)(void **retptr,\n+\t\t\t   void *env,\n+\t\t\t   void **dptr);\n+// FIXME (1185): This exists just to get access to the return pointer\n extern \"C\" void\n-rust_intrinsic_recv(void **retptr,\n-                    void *env,\n-                    type_desc *ty,\n-                    rust_port *port) {\n-    port_recv((uintptr_t*)retptr, port);\n+rust_intrinsic_call_with_retptr(void **retptr,\n+\t\t\t\tvoid *env,\n+\t\t\t\ttype_desc *ty,\n+\t\t\t\trust_fn *recvfn) {\n+    retptr_fn fn = ((retptr_fn)(recvfn->fn));\n+    ((retptr_fn)(*fn))(NULL, recvfn->env, retptr);\n }\n \n extern \"C\" void"}, {"sha": "10267ba17009daffa79d966b65d77d05055cd52b", "filename": "src/rt/intrinsics/intrinsics.i386.ll.in", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3a6320f71b1e1bde9ec3b30563d9f8e0ef4bdbce/src%2Frt%2Fintrinsics%2Fintrinsics.i386.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/3a6320f71b1e1bde9ec3b30563d9f8e0ef4bdbce/src%2Frt%2Fintrinsics%2Fintrinsics.i386.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.i386.ll.in?ref=3a6320f71b1e1bde9ec3b30563d9f8e0ef4bdbce", "patch": "@@ -8,11 +8,20 @@ target triple = \"@CFG_TARGET_TRIPLE@\"\n %struct.UT_hash_table = type { %struct.UT_hash_bucket*, i32, i32, i32, %struct.UT_hash_handle*, i32, i32, i32, i32, i32 }\n %struct.UT_hash_bucket = type { %struct.UT_hash_handle*, i32, i32 }\n %struct.rust_vec = type { i32, i32, [0 x i8] }\n-%class.rust_port = type { i32, i32, %class.rust_kernel*, %struct.rust_task*, i32, %class.circular_buffer, %class.lock_and_signal }\n-%class.rust_kernel = type { i32 (...)**, %class.memory_region, %class.rust_log, %class.rust_srv*, %class.lock_and_signal, %class.array_list.0, %struct.randctx, i32, %class.hash_map, i32, i32, i32, %struct.rust_env* }\n-%class.memory_region = type { i32 (...)**, %class.rust_srv*, %class.memory_region*, i32, %class.array_list, i8, i8, %class.lock_and_signal }\n+%struct.rust_fn = type { i32*, %struct.rust_box* }\n+%struct.rust_box = type opaque\n+%struct.rust_task = type { %struct.rust_task_user, i32, %class.context, %struct.stk_seg*, i32, %struct.rust_scheduler*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %struct.rust_cond*, i8*, %struct.rust_task*, i32, i32, %class.timer, i32*, i32, i32, %class.memory_region, i8, i8, i8, %class.lock_and_signal, %class.hash_map.4, %class.rust_obstack, %\"class.std::map\", i32, %\"class.debug::task_debug_info\" }\n+%struct.rust_task_user = type { i32, i32, %struct.chan_handle, i32 }\n+%struct.chan_handle = type { i32, i32 }\n+%class.context = type { %struct.registers_t, %class.context* }\n+%struct.registers_t = type { i32, i32, i32, i32, i32, i32, i32, i32, i16, i16, i16, i16, i16, i16, i32, i32 }\n+%struct.stk_seg = type { %struct.stk_seg*, i32, i32, i32, [0 x i8] }\n+%struct.rust_scheduler = type { %class.rust_thread, i32, i32, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, i32, i32, %class.lock_and_signal, i32, %union.pthread_attr_t, %struct.rust_env*, %class.context }\n+%class.rust_thread = type { i32 (...)**, i8, i32 }\n+%class.rust_log = type { i32 (...)**, %class.rust_srv*, %struct.rust_scheduler*, i8 }\n %class.rust_srv = type { i32 (...)**, %struct.rust_env*, %class.memory_region }\n %struct.rust_env = type { i32, i32, i8*, i8, i8, i8* }\n+%class.memory_region = type { i32 (...)**, %class.rust_srv*, %class.memory_region*, i32, %class.array_list, i8, i8, %class.lock_and_signal }\n %class.array_list = type { i32, %\"struct.memory_region::alloc_header\"**, i32 }\n %\"struct.memory_region::alloc_header\" = type { i8 }\n %class.lock_and_signal = type { i32 (...)**, %union.pthread_cond_t, %union.pthread_mutex_t, i32, i8, i8 }\n@@ -21,19 +30,16 @@ target triple = \"@CFG_TARGET_TRIPLE@\"\n %union.pthread_mutex_t = type { %\"struct.<anonymous union>::__pthread_mutex_s\" }\n %\"struct.<anonymous union>::__pthread_mutex_s\" = type { i32, i32, i32, i32, i32, %union.anon }\n %union.anon = type { i32 }\n-%class.rust_log = type { i32 (...)**, %class.rust_srv*, %struct.rust_scheduler*, i8 }\n-%struct.rust_scheduler = type { %class.rust_thread, i32, i32, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, i32, i32, %class.lock_and_signal, i32, %union.pthread_attr_t, %struct.rust_env*, %class.context }\n-%class.rust_thread = type { i32 (...)**, i8, i32 }\n %class.rust_task_list = type { %class.indexed_list, %struct.rust_scheduler*, i8* }\n-%class.indexed_list = type { i32 (...)**, %class.array_list.2 }\n-%class.array_list.2 = type { i32, %struct.rust_task**, i32 }\n-%struct.rust_task = type { %struct.rust_task_user, i32, %class.context, %struct.stk_seg*, i32, %struct.rust_scheduler*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %struct.rust_cond*, i8*, %struct.rust_task*, i32, i32, %class.timer, i32*, i32, i32, %class.memory_region, i8, i8, i8, %class.lock_and_signal, %class.hash_map.4, %class.rust_obstack, %\"class.std::map\", i32, %\"class.debug::task_debug_info\" }\n-%struct.rust_task_user = type { i32, i32, %struct.chan_handle, i32 }\n-%struct.chan_handle = type { i32, i32 }\n-%class.context = type { %struct.registers_t, %class.context* }\n-%struct.registers_t = type { i32, i32, i32, i32, i32, i32, i32, i32, i16, i16, i16, i16, i16, i16, i32, i32 }\n-%struct.stk_seg = type { %struct.stk_seg*, i32, i32, i32, [0 x i8] }\n+%class.indexed_list = type { i32 (...)**, %class.array_list.1 }\n+%class.array_list.1 = type { i32, %struct.rust_task**, i32 }\n %class.rust_crate_cache = type { %struct.type_desc*, %struct.rust_scheduler*, i32 }\n+%struct.randctx = type { i32, [256 x i32], [256 x i32], i32, i32, i32 }\n+%class.rust_kernel = type { i32 (...)**, %class.memory_region, %class.rust_log, %class.rust_srv*, %class.lock_and_signal, %class.array_list.3, %struct.randctx, i32, %class.hash_map, i32, i32, i32, %struct.rust_env* }\n+%class.array_list.3 = type { i32, %struct.rust_scheduler**, i32 }\n+%class.hash_map = type { %\"struct.hash_map<int, rust_task *>::map_entry\"* }\n+%\"struct.hash_map<int, rust_task *>::map_entry\" = type opaque\n+%union.pthread_attr_t = type { i32, [32 x i8] }\n %struct.rust_cond = type { i8 }\n %class.timer = type { i32 (...)**, i64, i64 }\n %class.hash_map.4 = type { %\"struct.hash_map<int, rust_port *>::map_entry\"* }\n@@ -49,12 +55,6 @@ target triple = \"@CFG_TARGET_TRIPLE@\"\n %\"class.std::map.5\" = type { %\"class.std::_Rb_tree.6\" }\n %\"class.std::_Rb_tree.6\" = type { %\"struct.std::_Rb_tree<void *, std::pair<void *const, std::basic_string<char> >, std::_Select1st<std::pair<void *const, std::basic_string<char> > >, std::less<void *>, std::allocator<std::pair<void *const, std::basic_string<char> > > >::_Rb_tree_impl\" }\n %\"struct.std::_Rb_tree<void *, std::pair<void *const, std::basic_string<char> >, std::_Select1st<std::pair<void *const, std::basic_string<char> > >, std::less<void *>, std::allocator<std::pair<void *const, std::basic_string<char> > > >::_Rb_tree_impl\" = type { %\"struct.std::less\", %\"struct.std::_Rb_tree_node_base\", i32 }\n-%struct.randctx = type { i32, [256 x i32], [256 x i32], i32, i32, i32 }\n-%union.pthread_attr_t = type { i32, [32 x i8] }\n-%class.array_list.0 = type { i32, %struct.rust_scheduler**, i32 }\n-%class.hash_map = type { %\"struct.hash_map<int, rust_task *>::map_entry\"* }\n-%\"struct.hash_map<int, rust_task *>::map_entry\" = type opaque\n-%class.circular_buffer = type { %class.rust_kernel*, i32, i32, i32, i32, i8* }\n \n define void @rust_intrinsic_vec_len(i32* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, %struct.rust_vec** nocapture %vp) nounwind {\n   %1 = load %struct.rust_vec** %vp, align 4, !tbaa !0\n@@ -90,14 +90,17 @@ define void @rust_intrinsic_addr_of(i8** nocapture %retptr, i8* nocapture %env,\n   ret void\n }\n \n-define void @rust_intrinsic_recv(i8** %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, %class.rust_port* %port) {\n-  %1 = bitcast i8** %retptr to i32*\n-  tail call void @port_recv(i32* %1, %class.rust_port* %port)\n+define void @rust_intrinsic_call_with_retptr(i8** %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, %struct.rust_fn* nocapture %recvfn) {\n+  %1 = getelementptr inbounds %struct.rust_fn* %recvfn, i32 0, i32 0\n+  %2 = load i32** %1, align 4, !tbaa !0\n+  %3 = bitcast i32* %2 to void (i8**, i8*, i8**)*\n+  %4 = getelementptr inbounds %struct.rust_fn* %recvfn, i32 0, i32 1\n+  %5 = load %struct.rust_box** %4, align 4, !tbaa !0\n+  %6 = bitcast %struct.rust_box* %5 to i8*\n+  tail call void %3(i8** null, i8* %6, i8** %retptr)\n   ret void\n }\n \n-declare void @port_recv(i32*, %class.rust_port*)\n-\n define void @rust_intrinsic_get_type_desc(i8** nocapture %retptr, i8* nocapture %env, %struct.type_desc* %ty) nounwind {\n   %ty.c = bitcast %struct.type_desc* %ty to i8*\n   store i8* %ty.c, i8** %retptr, align 4, !tbaa !0"}, {"sha": "849acd5b3e00bf29c38414b69150690a36430ea0", "filename": "src/rt/intrinsics/intrinsics.x86_64.ll.in", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3a6320f71b1e1bde9ec3b30563d9f8e0ef4bdbce/src%2Frt%2Fintrinsics%2Fintrinsics.x86_64.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/3a6320f71b1e1bde9ec3b30563d9f8e0ef4bdbce/src%2Frt%2Fintrinsics%2Fintrinsics.x86_64.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.x86_64.ll.in?ref=3a6320f71b1e1bde9ec3b30563d9f8e0ef4bdbce", "patch": "@@ -8,11 +8,20 @@ target triple = \"@CFG_TARGET_TRIPLE@\"\n %struct.UT_hash_table = type { %struct.UT_hash_bucket*, i32, i32, i32, %struct.UT_hash_handle*, i64, i32, i32, i32, i32 }\n %struct.UT_hash_bucket = type { %struct.UT_hash_handle*, i32, i32 }\n %struct.rust_vec = type { i64, i64, [0 x i8] }\n-%class.rust_port = type { i64, i64, %class.rust_kernel*, %struct.rust_task*, i64, %class.circular_buffer, %class.lock_and_signal }\n-%class.rust_kernel = type { i32 (...)**, %class.memory_region, %class.rust_log, %class.rust_srv*, %class.lock_and_signal, %class.array_list.0, %struct.randctx, i64, %class.hash_map, i64, i32, i32, %struct.rust_env* }\n-%class.memory_region = type { i32 (...)**, %class.rust_srv*, %class.memory_region*, i32, %class.array_list, i8, i8, %class.lock_and_signal }\n+%struct.rust_fn = type { i64*, %struct.rust_box* }\n+%struct.rust_box = type opaque\n+%struct.rust_task = type { %struct.rust_task_user, i64, %class.context, %struct.stk_seg*, i64, %struct.rust_scheduler*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %struct.rust_cond*, i8*, %struct.rust_task*, i32, i64, %class.timer, i64*, i32, i32, %class.memory_region, i8, i8, i8, %class.lock_and_signal, %class.hash_map.4, %class.rust_obstack, %\"class.std::map\", i32, %\"class.debug::task_debug_info\" }\n+%struct.rust_task_user = type { i64, i64, %struct.chan_handle, i64 }\n+%struct.chan_handle = type { i64, i64 }\n+%class.context = type { %struct.registers_t, %class.context* }\n+%struct.registers_t = type { [22 x i64] }\n+%struct.stk_seg = type { %struct.stk_seg*, i64, i32, [0 x i8] }\n+%struct.rust_scheduler = type { %class.rust_thread, i64, i64, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, i32, i32, %class.lock_and_signal, i64, %union.pthread_attr_t, %struct.rust_env*, %class.context }\n+%class.rust_thread = type { i32 (...)**, i8, i64 }\n+%class.rust_log = type { i32 (...)**, %class.rust_srv*, %struct.rust_scheduler*, i8 }\n %class.rust_srv = type { i32 (...)**, %struct.rust_env*, %class.memory_region }\n %struct.rust_env = type { i64, i64, i8*, i8, i8, i8* }\n+%class.memory_region = type { i32 (...)**, %class.rust_srv*, %class.memory_region*, i32, %class.array_list, i8, i8, %class.lock_and_signal }\n %class.array_list = type { i64, %\"struct.memory_region::alloc_header\"**, i64 }\n %\"struct.memory_region::alloc_header\" = type { i8 }\n %class.lock_and_signal = type { i32 (...)**, %union.pthread_cond_t, %union.pthread_mutex_t, i64, i8, i8 }\n@@ -21,19 +30,16 @@ target triple = \"@CFG_TARGET_TRIPLE@\"\n %union.pthread_mutex_t = type { %\"struct.<anonymous union>::__pthread_mutex_s\" }\n %\"struct.<anonymous union>::__pthread_mutex_s\" = type { i32, i32, i32, i32, i32, i32, %struct.__pthread_internal_list }\n %struct.__pthread_internal_list = type { %struct.__pthread_internal_list*, %struct.__pthread_internal_list* }\n-%class.rust_log = type { i32 (...)**, %class.rust_srv*, %struct.rust_scheduler*, i8 }\n-%struct.rust_scheduler = type { %class.rust_thread, i64, i64, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, i32, i32, %class.lock_and_signal, i64, %union.pthread_attr_t, %struct.rust_env*, %class.context }\n-%class.rust_thread = type { i32 (...)**, i8, i64 }\n %class.rust_task_list = type { %class.indexed_list, %struct.rust_scheduler*, i8* }\n-%class.indexed_list = type { i32 (...)**, %class.array_list.2 }\n-%class.array_list.2 = type { i64, %struct.rust_task**, i64 }\n-%struct.rust_task = type { %struct.rust_task_user, i64, %class.context, %struct.stk_seg*, i64, %struct.rust_scheduler*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %struct.rust_cond*, i8*, %struct.rust_task*, i32, i64, %class.timer, i64*, i32, i32, %class.memory_region, i8, i8, i8, %class.lock_and_signal, %class.hash_map.4, %class.rust_obstack, %\"class.std::map\", i32, %\"class.debug::task_debug_info\" }\n-%struct.rust_task_user = type { i64, i64, %struct.chan_handle, i64 }\n-%struct.chan_handle = type { i64, i64 }\n-%class.context = type { %struct.registers_t, %class.context* }\n-%struct.registers_t = type { [22 x i64] }\n-%struct.stk_seg = type { %struct.stk_seg*, i64, i32, [0 x i8] }\n+%class.indexed_list = type { i32 (...)**, %class.array_list.1 }\n+%class.array_list.1 = type { i64, %struct.rust_task**, i64 }\n %class.rust_crate_cache = type { %struct.type_desc*, %struct.rust_scheduler*, i64 }\n+%struct.randctx = type { i64, [256 x i64], [256 x i64], i64, i64, i64 }\n+%class.rust_kernel = type { i32 (...)**, %class.memory_region, %class.rust_log, %class.rust_srv*, %class.lock_and_signal, %class.array_list.3, %struct.randctx, i64, %class.hash_map, i64, i32, i32, %struct.rust_env* }\n+%class.array_list.3 = type { i64, %struct.rust_scheduler**, i64 }\n+%class.hash_map = type { %\"struct.hash_map<long, rust_task *>::map_entry\"* }\n+%\"struct.hash_map<long, rust_task *>::map_entry\" = type opaque\n+%union.pthread_attr_t = type { i64, [48 x i8] }\n %struct.rust_cond = type { i8 }\n %class.timer = type { i32 (...)**, i64, i64 }\n %class.hash_map.4 = type { %\"struct.hash_map<long, rust_port *>::map_entry\"* }\n@@ -49,12 +55,6 @@ target triple = \"@CFG_TARGET_TRIPLE@\"\n %\"class.std::map.5\" = type { %\"class.std::_Rb_tree.6\" }\n %\"class.std::_Rb_tree.6\" = type { %\"struct.std::_Rb_tree<void *, std::pair<void *const, std::basic_string<char> >, std::_Select1st<std::pair<void *const, std::basic_string<char> > >, std::less<void *>, std::allocator<std::pair<void *const, std::basic_string<char> > > >::_Rb_tree_impl\" }\n %\"struct.std::_Rb_tree<void *, std::pair<void *const, std::basic_string<char> >, std::_Select1st<std::pair<void *const, std::basic_string<char> > >, std::less<void *>, std::allocator<std::pair<void *const, std::basic_string<char> > > >::_Rb_tree_impl\" = type { %\"struct.std::less\", %\"struct.std::_Rb_tree_node_base\", i64 }\n-%struct.randctx = type { i64, [256 x i64], [256 x i64], i64, i64, i64 }\n-%union.pthread_attr_t = type { i64, [48 x i8] }\n-%class.array_list.0 = type { i64, %struct.rust_scheduler**, i64 }\n-%class.hash_map = type { %\"struct.hash_map<long, rust_task *>::map_entry\"* }\n-%\"struct.hash_map<long, rust_task *>::map_entry\" = type opaque\n-%class.circular_buffer = type { %class.rust_kernel*, i64, i64, i64, i64, i8* }\n \n define void @rust_intrinsic_vec_len(i64* nocapture %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, %struct.rust_vec** nocapture %vp) nounwind uwtable {\n   %1 = load %struct.rust_vec** %vp, align 8, !tbaa !0\n@@ -90,14 +90,17 @@ define void @rust_intrinsic_addr_of(i8** nocapture %retptr, i8* nocapture %env,\n   ret void\n }\n \n-define void @rust_intrinsic_recv(i8** %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, %class.rust_port* %port) uwtable {\n-  %1 = bitcast i8** %retptr to i64*\n-  tail call void @port_recv(i64* %1, %class.rust_port* %port)\n+define void @rust_intrinsic_call_with_retptr(i8** %retptr, i8* nocapture %env, %struct.type_desc* nocapture %ty, %struct.rust_fn* nocapture %recvfn) uwtable {\n+  %1 = getelementptr inbounds %struct.rust_fn* %recvfn, i64 0, i32 0\n+  %2 = load i64** %1, align 8, !tbaa !0\n+  %3 = bitcast i64* %2 to void (i8**, i8*, i8**)*\n+  %4 = getelementptr inbounds %struct.rust_fn* %recvfn, i64 0, i32 1\n+  %5 = load %struct.rust_box** %4, align 8, !tbaa !0\n+  %6 = bitcast %struct.rust_box* %5 to i8*\n+  tail call void %3(i8** null, i8* %6, i8** %retptr)\n   ret void\n }\n \n-declare void @port_recv(i64*, %class.rust_port*)\n-\n define void @rust_intrinsic_get_type_desc(i8** nocapture %retptr, i8* nocapture %env, %struct.type_desc* %ty) nounwind uwtable {\n   %ty.c = bitcast %struct.type_desc* %ty to i8*\n   store i8* %ty.c, i8** %retptr, align 8, !tbaa !0"}, {"sha": "3460d4609008130ce1ad4c0c2670f9fa256e2c40", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3a6320f71b1e1bde9ec3b30563d9f8e0ef4bdbce/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3a6320f71b1e1bde9ec3b30563d9f8e0ef4bdbce/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=3a6320f71b1e1bde9ec3b30563d9f8e0ef4bdbce", "patch": "@@ -515,10 +515,8 @@ rust_task_sleep(rust_task *task, size_t time_in_us) {\n     task->yield(time_in_us);\n }\n \n-// This is called by an intrinsic on the Rust stack.\n-// Do not call on the C stack.\n extern \"C\" CDECL void\n-port_recv(uintptr_t *dptr, rust_port *port) {\n+port_recv(uintptr_t *dptr, rust_port *port, uintptr_t *yield) {\n     rust_task *task = rust_scheduler::get_task();\n     {\n         scoped_lock with(port->lock);\n@@ -528,6 +526,7 @@ port_recv(uintptr_t *dptr, rust_port *port) {\n             (uintptr_t) port, (uintptr_t) dptr, port->unit_sz);\n \n         if (port->receive(dptr)) {\n+            *yield = false;\n             return;\n         }\n \n@@ -539,7 +538,8 @@ port_recv(uintptr_t *dptr, rust_port *port) {\n         task->rendezvous_ptr = dptr;\n         task->block(port, \"waiting for rendezvous data\");\n     }\n-    task->yield(3);\n+    *yield = true;\n+    return;\n }\n \n //"}]}