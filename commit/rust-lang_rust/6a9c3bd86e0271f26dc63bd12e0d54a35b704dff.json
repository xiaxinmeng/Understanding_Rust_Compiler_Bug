{"sha": "6a9c3bd86e0271f26dc63bd12e0d54a35b704dff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhOWMzYmQ4NmUwMjcxZjI2ZGM2M2JkMTJlMGQ1NGEzNWI3MDRkZmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-15T20:28:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-15T20:28:49Z"}, "message": "auto merge of #6418 : catamorphism/rust/rustpkg, r=catamorphism\n\nr? @brson This patch implements package IDs like\r\ngithub.com/catamorphism/test-pkg.\r\n\r\nTo support such package IDs, I changed the PkgId struct to contain\r\na LocalPath and a RemotePath field, where the RemotePath reflects\r\nthe actual URL and the LocalPath reflects the file name of the cached\r\ncopy. Right now, the only difference is that the local path doesn't\r\ncontain dashes, but this will change when we implement #6407.\r\n\r\nAlso, PkgIds now have a short_name field -- though the short name\r\ncan be derived from the LocalPath, I thought it was cleaner not to\r\ncall option::get() wantonly.", "tree": {"sha": "83e6578a35cc91765d2470274114f0c38ef111be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83e6578a35cc91765d2470274114f0c38ef111be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a9c3bd86e0271f26dc63bd12e0d54a35b704dff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a9c3bd86e0271f26dc63bd12e0d54a35b704dff", "html_url": "https://github.com/rust-lang/rust/commit/6a9c3bd86e0271f26dc63bd12e0d54a35b704dff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a9c3bd86e0271f26dc63bd12e0d54a35b704dff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a15333c06b8ba491e1654c3fca3fa21d21def9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a15333c06b8ba491e1654c3fca3fa21d21def9b", "html_url": "https://github.com/rust-lang/rust/commit/8a15333c06b8ba491e1654c3fca3fa21d21def9b"}, {"sha": "80a7e2644c86846e06907a6bed5b0d7773051d20", "url": "https://api.github.com/repos/rust-lang/rust/commits/80a7e2644c86846e06907a6bed5b0d7773051d20", "html_url": "https://github.com/rust-lang/rust/commit/80a7e2644c86846e06907a6bed5b0d7773051d20"}], "stats": {"total": 729, "additions": 297, "deletions": 432}, "files": [{"sha": "680e0924d798c033fbf072e7fd1286481cce7882", "filename": "src/librustpkg/conditions.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a9c3bd86e0271f26dc63bd12e0d54a35b704dff/src%2Flibrustpkg%2Fconditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a9c3bd86e0271f26dc63bd12e0d54a35b704dff/src%2Flibrustpkg%2Fconditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fconditions.rs?ref=6a9c3bd86e0271f26dc63bd12e0d54a35b704dff", "patch": "@@ -28,3 +28,7 @@ condition! {\n condition! {\n     missing_pkg_files: (super::PkgId) -> ();\n }\n+\n+condition! {\n+    bad_pkg_id: (super::Path, ~str) -> ::util::PkgId;\n+}"}, {"sha": "bbd8d09235484f32689655997a5acaaeb2dc9de8", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 60, "deletions": 48, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/6a9c3bd86e0271f26dc63bd12e0d54a35b704dff/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a9c3bd86e0271f26dc63bd12e0d54a35b704dff/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=6a9c3bd86e0271f26dc63bd12e0d54a35b704dff", "patch": "@@ -10,12 +10,10 @@\n \n // rustpkg utilities having to do with paths and directories\n \n-use util::PkgId;\n+pub use util::{PkgId, RemotePath, LocalPath};\n use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n use core::os::mkdir_recursive;\n-\n-#[deriving(Eq)]\n-pub enum OutputType { Main, Lib, Bench, Test }\n+pub use util::{normalize, OutputType, Main, Lib, Bench, Test};\n \n /// Returns the value of RUST_PATH, as a list\n /// of Paths. In general this should be read from the\n@@ -31,67 +29,73 @@ pub static u_rwx: i32 = (S_IRUSR | S_IWUSR | S_IXUSR) as i32;\n /// succeeded.\n pub fn make_dir_rwx(p: &Path) -> bool { os::make_dir(p, u_rwx) }\n \n-/// Replace all occurrences of '-' in the stem part of path with '_'\n-/// This is because we treat rust-foo-bar-quux and rust_foo_bar_quux\n-/// as the same name\n-pub fn normalize(p: ~Path) -> ~Path {\n-    match p.filestem() {\n-        None => p,\n-        Some(st) => {\n-            let replaced = str::replace(st, \"-\", \"_\");\n-            if replaced != st {\n-                ~p.with_filestem(replaced)\n-            }\n-            else {\n-                p\n-            }\n-        }\n-    }\n-}\n-\n // n.b. So far this only handles local workspaces\n // n.b. The next three functions ignore the package version right\n // now. Should fix that.\n \n /// True if there's a directory in <workspace> with\n /// pkgid's short name\n pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n-    let pkgpath = workspace.push(\"src\").push(pkgid.path.to_str());\n+    let pkgpath = workspace.push(\"src\").push(pkgid.local_path.to_str());\n     os::path_is_dir(&pkgpath)\n }\n \n /// Return the directory for <pkgid>'s source files in <workspace>.\n /// Doesn't check that it exists.\n pub fn pkgid_src_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     let result = workspace.push(\"src\");\n-    result.push(pkgid.path.to_str())\n+    result.push(pkgid.local_path.to_str())\n }\n \n /// Figure out what the executable name for <pkgid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n pub fn built_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n     let mut result = workspace.push(\"build\");\n-    result = result.push_rel(&pkgid.path);\n     // should use a target-specific subdirectory\n-    result = mk_output_path(Main, fmt!(\"%s-%s\", pkgid.path.to_str(), pkgid.version.to_str()),\n-                                       result);\n+    result = mk_output_path(Main, pkgid, &result);\n     debug!(\"built_executable_in_workspace: checking whether %s exists\",\n            result.to_str());\n     if os::path_exists(&result) {\n         Some(result)\n     }\n     else {\n+        // This is not an error, but it's worth logging it\n+        error!(fmt!(\"built_executable_in_workspace: %s does not exist\", result.to_str()));\n         None\n     }\n }\n \n-/// Figure out what the library name for <pkgid> in <workspace>'s build\n+/// Figure out what the test name for <pkgid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n-pub fn built_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n+pub fn built_test_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n+    output_in_workspace(pkgid, workspace, Test)\n+}\n+\n+/// Figure out what the test name for <pkgid> in <workspace>'s build\n+/// directory is, and if the file exists, return it.\n+pub fn built_bench_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n+    output_in_workspace(pkgid, workspace, Bench)\n+}\n+\n+fn output_in_workspace(pkgid: &PkgId, workspace: &Path, what: OutputType) -> Option<Path> {\n     let mut result = workspace.push(\"build\");\n-    result = result.push_rel(&pkgid.path);\n     // should use a target-specific subdirectory\n-    result = mk_output_path(Lib, pkgid.path.to_str(), result);\n+    result = mk_output_path(what, pkgid, &result);\n+    debug!(\"output_in_workspace: checking whether %s exists\",\n+           result.to_str());\n+    if os::path_exists(&result) {\n+        Some(result)\n+    }\n+    else {\n+        error!(fmt!(\"output_in_workspace: %s does not exist\", result.to_str()));\n+        None\n+    }\n+}\n+\n+/// Figure out what the library name for <pkgid> in <workspace>'s build\n+/// directory is, and if the file exists, return it.\n+pub fn built_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n+    let result = mk_output_path(Lib, pkgid, &workspace.push(\"build\"));\n     debug!(\"built_library_in_workspace: checking whether %s exists\",\n            result.to_str());\n \n@@ -100,8 +104,7 @@ pub fn built_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Pat\n     let dir_contents = os::list_dir(&result.pop());\n     debug!(\"dir has %? entries\", dir_contents.len());\n \n-    // n.b. This code assumes the pkgid's path only has one element\n-    let lib_prefix = fmt!(\"%s%s\", os::consts::DLL_PREFIX, pkgid.path.to_str());\n+    let lib_prefix = fmt!(\"%s%s\", os::consts::DLL_PREFIX, pkgid.short_name);\n     let lib_filetype = fmt!(\"%s%s\", pkgid.version.to_str(), os::consts::DLL_SUFFIX);\n \n     debug!(\"lib_prefix = %s and lib_filetype = %s\", lib_prefix, lib_filetype);\n@@ -173,12 +176,14 @@ pub fn target_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n \n /// Returns the test executable that would be installed for <pkgid>\n /// in <workspace>\n+/// note that we *don't* install test executables, so this is just for unit testing\n pub fn target_test_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     target_file_in_workspace(pkgid, workspace, Test)\n }\n \n /// Returns the bench executable that would be installed for <pkgid>\n /// in <workspace>\n+/// note that we *don't* install bench executables, so this is just for unit testing\n pub fn target_bench_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     target_file_in_workspace(pkgid, workspace, Bench)\n }\n@@ -187,18 +192,14 @@ fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n                             what: OutputType) -> Path {\n     use conditions::bad_path::cond;\n \n-    let (subdir, create_dir) = match what {\n-        Main => (\"bin\", true), Lib => (\"lib\", true), Test | Bench => (\"build\", false)\n+    let subdir = match what {\n+        Lib => \"lib\", Main | Test | Bench => \"bin\"\n     };\n     let result = workspace.push(subdir);\n-    if create_dir {\n-        if !os::path_exists(&result) && !mkdir_recursive(&result, u_rwx) {\n-            cond.raise((copy result,\n-                        fmt!(\"I couldn't create the %s dir\", subdir)));\n-        }\n+    if !os::path_exists(&result) && !mkdir_recursive(&result, u_rwx) {\n+        cond.raise((copy result, fmt!(\"I couldn't create the %s dir\", subdir)));\n     }\n-    mk_output_path(what, pkgid.path.to_str(), result)\n-\n+    mk_output_path(what, pkgid, &result)\n }\n \n /// Return the directory for <pkgid>'s build artifacts in <workspace>.\n@@ -209,7 +210,7 @@ pub fn build_pkg_id_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     let mut result = workspace.push(\"build\");\n     // n.b. Should actually use a target-specific\n     // subdirectory of build/\n-    result = result.push(normalize(~copy pkgid.path).to_str());\n+    result = result.push_rel(&*pkgid.local_path);\n     if os::path_exists(&result) || os::mkdir_recursive(&result, u_rwx) {\n         result\n     }\n@@ -220,15 +221,26 @@ pub fn build_pkg_id_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n \n /// Return the output file for a given directory name,\n /// given whether we're building a library and whether we're building tests\n-pub fn mk_output_path(what: OutputType, short_name: ~str, dir: Path) -> Path {\n-    match what {\n-        Lib => dir.push(os::dll_filename(short_name)),\n-        _ => dir.push(fmt!(\"%s%s%s\", short_name,\n+pub fn mk_output_path(what: OutputType, pkg_id: &PkgId, workspace: &Path) -> Path {\n+    let short_name_with_version = pkg_id.short_name_with_version();\n+    // Not local_path.dir_path()! For package foo/bar/blat/, we want\n+    // the executable blat-0.5 to live under blat/\n+    let dir = workspace.push_rel(&*pkg_id.local_path);\n+    debug!(\"mk_output_path: short_name = %s, path = %s\",\n+           if what == Lib { copy short_name_with_version } else { copy pkg_id.short_name },\n+           dir.to_str());\n+    let output_path = match what {\n+        // this code is duplicated from elsewhere; fix this\n+        Lib => dir.push(os::dll_filename(short_name_with_version)),\n+        // executable names *aren't* versioned\n+        _ => dir.push(fmt!(\"%s%s%s\", copy pkg_id.short_name,\n                            match what {\n                                Test => \"test\",\n                                Bench => \"bench\",\n                                _     => \"\"\n                            }\n                            os::EXE_SUFFIX))\n-    }\n+    };\n+    debug!(\"mk_output_path: returning %s\", output_path.to_str());\n+    output_path\n }"}, {"sha": "a69613776efdc4ac8abb597cc44f0f0b33645e51", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 61, "deletions": 169, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/6a9c3bd86e0271f26dc63bd12e0d54a35b704dff/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6a9c3bd86e0271f26dc63bd12e0d54a35b704dff/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=6a9c3bd86e0271f26dc63bd12e0d54a35b704dff", "patch": "@@ -30,12 +30,10 @@ use rustc::metadata::filesearch;\n use std::{getopts};\n use syntax::{ast, diagnostic};\n use util::*;\n-use path_util::normalize;\n-use path_util::{build_pkg_id_in_workspace, pkgid_src_in_workspace};\n+use path_util::{build_pkg_id_in_workspace, pkgid_src_in_workspace, u_rwx};\n use path_util::{built_executable_in_workspace, built_library_in_workspace};\n use path_util::{target_executable_in_workspace, target_library_in_workspace};\n use workspace::pkg_parent_workspaces;\n-use rustc::driver::session::{lib_crate, bin_crate, crate_type};\n use context::Ctx;\n \n mod conditions;\n@@ -159,27 +157,6 @@ impl<'self> PkgScript<'self> {\n impl Ctx {\n \n     fn run(&self, cmd: ~str, args: ~[~str]) {\n-        let root = util::root();\n-\n-        util::need_dir(&root);\n-        util::need_dir(&root.push(~\"work\"));\n-        util::need_dir(&root.push(~\"lib\"));\n-        util::need_dir(&root.push(~\"bin\"));\n-        util::need_dir(&root.push(~\"tmp\"));\n-\n-        fn sep_name_vers(in: ~str) -> (Option<~str>, Option<~str>) {\n-            let mut name = None;\n-            let mut vers = None;\n-\n-            for str::each_split_char(in, '@') |s| {\n-                if      name.is_none() { name = Some(s.to_owned()); }\n-                else if vers.is_none() { vers = Some(s.to_owned()); }\n-                else                   { break;               }\n-            }\n-\n-            (name, vers)\n-        }\n-\n         match cmd {\n             ~\"build\" => {\n                 if args.len() < 1 {\n@@ -229,9 +206,7 @@ impl Ctx {\n                     return usage::uninstall();\n                 }\n \n-                let (name, vers) = sep_name_vers(copy args[0]);\n-\n-                self.prefer(name.get(), vers);\n+                self.prefer(args[0], None);\n             }\n             ~\"test\" => {\n                 self.test();\n@@ -241,20 +216,16 @@ impl Ctx {\n                     return usage::uninstall();\n                 }\n \n-                let (name, vers) = sep_name_vers(copy args[0]);\n-\n-                self.uninstall(name.get(), vers);\n+                self.uninstall(args[0], None);\n             }\n             ~\"unprefer\" => {\n                 if args.len() < 1 {\n                     return usage::uninstall();\n                 }\n \n-                let (name, vers) = sep_name_vers(copy args[0]);\n-\n-                self.unprefer(name.get(), vers);\n+                self.unprefer(args[0], None);\n             }\n-            _ => fail!(\"reached an unhandled command\")\n+            _ => fail!(fmt!(\"I don't know the command `%s`\", cmd))\n         }\n     }\n \n@@ -269,7 +240,7 @@ impl Ctx {\n         debug!(\"Destination dir = %s\", build_dir.to_str());\n \n         // Create the package source\n-        let mut src = PkgSrc::new(&workspace.push(\"src\"), &build_dir, pkgid);\n+        let mut src = PkgSrc::new(workspace, &build_dir, pkgid);\n         debug!(\"Package src = %?\", src);\n \n         // Is there custom build logic? If so, use it\n@@ -307,7 +278,6 @@ impl Ctx {\n             // Build it!\n             src.build(&build_dir, cfgs, self.sysroot_opt);\n         }\n-\n     }\n \n     fn clean(&self, workspace: &Path, id: &PkgId)  {\n@@ -319,7 +289,7 @@ impl Ctx {\n         util::note(fmt!(\"Cleaning package %s (removing directory %s)\",\n                         id.to_str(), dir.to_str()));\n         if os::path_exists(&dir) {\n-            util::remove_dir_r(&dir);\n+            os::remove_dir_recursive(&dir);\n             util::note(fmt!(\"Removed directory %s\", dir.to_str()));\n         }\n \n@@ -337,127 +307,55 @@ impl Ctx {\n         // Should use RUST_PATH in the future.\n         // Also should use workcache to not build if not necessary.\n         self.build(workspace, id);\n+        debug!(\"install: workspace = %s, id = %s\", workspace.to_str(),\n+               id.to_str());\n \n         // Now copy stuff into the install dirs\n         let maybe_executable = built_executable_in_workspace(id, workspace);\n         let maybe_library = built_library_in_workspace(id, workspace);\n         let target_exec = target_executable_in_workspace(id, workspace);\n         let target_lib = target_library_in_workspace(id, workspace);\n \n+        debug!(\"target_exec = %s target_lib = %s \\\n+                maybe_executable = %? maybe_library = %?\",\n+               target_exec.to_str(), target_lib.to_str(),\n+               maybe_executable, maybe_library);\n+\n         for maybe_executable.each |exec| {\n             debug!(\"Copying: %s -> %s\", exec.to_str(), target_exec.to_str());\n-            if !os::copy_file(exec, &target_exec) {\n+            if !(os::mkdir_recursive(&target_exec.dir_path(), u_rwx) &&\n+                 os::copy_file(exec, &target_exec)) {\n                 cond.raise((copy *exec, copy target_exec));\n             }\n         }\n         for maybe_library.each |lib| {\n             debug!(\"Copying: %s -> %s\", lib.to_str(), target_lib.to_str());\n-            if !os::copy_file(lib, &target_lib) {\n+            if !(os::mkdir_recursive(&target_lib.dir_path(), u_rwx) &&\n+                 os::copy_file(lib, &target_lib)) {\n                 cond.raise((copy *lib, copy target_lib));\n             }\n         }\n     }\n \n-    fn fetch(&self, _dir: &Path, _url: ~str, _target: Option<~str>)  {\n-        // stub\n-        fail!(\"fetch not yet implemented\");\n-    }\n-\n-    fn fetch_curl(&self, dir: &Path, url: ~str)  {\n-        util::note(fmt!(\"fetching from %s using curl\", url));\n-\n-        let tar = dir.dir_path().push(&dir.file_path().to_str() + ~\".tar\");\n-\n-        if run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\",\n-                                          ~\"-o\", tar.to_str(),\n-                                          url]).status != 0 {\n-            util::error(~\"fetching failed: downloading using curl failed\");\n-\n-            fail!();\n-        }\n-\n-        if run::program_output(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n-                                         ~\"-C\", dir.to_str(), ~\"-f\",\n-                                         tar.to_str()]).status != 0 {\n-            util::error(~\"fetching failed: extracting using tar failed\" +\n-                        ~\"(is it a valid tar archive?)\");\n-\n-           fail!();\n-        }\n-    }\n-\n-    fn fetch_git(&self, dir: &Path, url: ~str, mut target: Option<~str>)  {\n-        util::note(fmt!(\"fetching from %s using git\", url));\n-\n-        // Git can't clone into a non-empty directory\n-        util::remove_dir_r(dir);\n-\n-        if run::program_output(~\"git\", ~[~\"clone\", url,\n-                                         dir.to_str()]).status != 0 {\n-            util::error(~\"fetching failed: can't clone repository\");\n-            fail!();\n-        }\n-\n-        if !target.is_none() {\n-            let mut success = true;\n-\n-            do util::temp_change_dir(dir) {\n-                success = run::program_output(~\"git\",\n-                                              ~[~\"checkout\",\n-                                                target.swap_unwrap()]).status != 0\n-            }\n-\n-            if !success {\n-                util::error(~\"fetching failed: can't checkout target\");\n-                fail!();\n-            }\n-        }\n-    }\n-\n-    fn prefer(&self, id: ~str, vers: Option<~str>)  {\n-        let package = match util::get_pkg(id, vers) {\n-            result::Ok(package) => package,\n-            result::Err(err) => {\n-                util::error(err);\n-                fail!(); // Condition?\n-            }\n-        };\n-        let name = package.id.path.to_str(); // ???\n-\n-        util::note(fmt!(\"preferring %s v%s\", name, package.id.version.to_str()));\n-\n-        let bin_dir = util::root().push(~\"bin\");\n-\n-        for package.bins.each |&bin| {\n-            let path = Path(bin);\n-            let mut name = None;\n-            for str::each_split_char(path.file_path().to_str(), '-') |s| {\n-                name = Some(s.to_owned());\n-                break;\n-            }\n-            let out = bin_dir.push(name.unwrap());\n-\n-            util::link_exe(&path, &out);\n-            util::note(fmt!(\"linked %s\", out.to_str()));\n-        }\n-\n-        util::note(fmt!(\"preferred %s v%s\", name, package.id.version.to_str()));\n+    fn prefer(&self, _id: &str, _vers: Option<~str>)  {\n+        fail!(~\"prefer not yet implemented\");\n     }\n \n     fn test(&self)  {\n         // stub\n         fail!(\"test not yet implemented\");\n     }\n \n-    fn uninstall(&self, _id: ~str, _vers: Option<~str>)  {\n+    fn uninstall(&self, _id: &str, _vers: Option<~str>)  {\n         fail!(\"uninstall not yet implemented\");\n     }\n \n-    fn unprefer(&self, _id: ~str, _vers: Option<~str>)  {\n+    fn unprefer(&self, _id: &str, _vers: Option<~str>)  {\n         fail!(\"unprefer not yet implemented\");\n     }\n }\n \n+\n pub fn main() {\n     io::println(\"WARNING: The Rust package manager is experimental and may be unstable\");\n \n@@ -518,32 +416,6 @@ pub struct Crate {\n     cfgs: ~[~str]\n }\n \n-pub struct Listener {\n-    cmds: ~[~str],\n-    cb: ~fn()\n-}\n-\n-pub fn run(listeners: ~[Listener]) {\n-    let rcmd = copy os::args()[2];\n-    let mut found = false;\n-\n-    for listeners.each |listener| {\n-        for listener.cmds.each |&cmd| {\n-            if cmd == rcmd {\n-                (listener.cb)();\n-\n-                found = true;\n-\n-                break;\n-            }\n-        }\n-    }\n-\n-    if !found {\n-        os::set_exit_status(42);\n-    }\n-}\n-\n pub impl Crate {\n \n     fn new(p: &Path) -> Crate {\n@@ -602,10 +474,6 @@ pub fn src_dir() -> Path {\n     os::getcwd()\n }\n \n-condition! {\n-    bad_pkg_id: (super::Path, ~str) -> ::util::PkgId;\n-}\n-\n // An enumeration of the unpacked source of a package workspace.\n // This contains a list of files found in the source workspace.\n pub struct PkgSrc {\n@@ -641,17 +509,19 @@ impl PkgSrc {\n     fn check_dir(&self) -> Path {\n         use conditions::nonexistent_package::cond;\n \n-        debug!(\"Pushing onto root: %s | %s\", self.id.path.to_str(),\n+        debug!(\"Pushing onto root: %s | %s\", self.id.to_str(),\n                self.root.to_str());\n \n-        let dir = self.root.push_rel(&self.id.path).normalize();\n+        let mut dir = self.root.push(\"src\");\n+        dir = dir.push(self.id.to_str()); // ?? Should this use the version number?\n \n         debug!(\"Checking dir: %s\", dir.to_str());\n \n-        // tjc: Rather than erroring out, need to try downloading the\n-        // contents of the path to a local directory (#5679)\n         if !os::path_exists(&dir) {\n-            cond.raise((copy self.id, ~\"missing package dir\"));\n+            if !self.fetch_git() {\n+                cond.raise((copy self.id, ~\"supplied path for package dir does not \\\n+                    exist, and couldn't interpret it as a URL fragment\"));\n+            }\n         }\n \n         if !os::path_is_dir(&dir) {\n@@ -662,6 +532,28 @@ impl PkgSrc {\n         dir\n     }\n \n+    /// Try interpreting self's package id as a remote package, and try\n+    /// fetching it and caching it in a local directory. If that didn't\n+    /// work, return false.\n+    /// (right now we only support git)\n+    fn fetch_git(&self) -> bool {\n+\n+        let mut local = self.root.push(\"src\");\n+        local = local.push(self.id.to_str());\n+        // Git can't clone into a non-empty directory\n+        os::remove_dir_recursive(&local);\n+\n+        let url = fmt!(\"https://%s\", self.id.remote_path.to_str());\n+        util::note(fmt!(\"git clone %s %s\", url, local.to_str()));\n+\n+        if run::program_output(~\"git\", ~[~\"clone\", copy url, local.to_str()]).status != 0 {\n+            util::note(fmt!(\"fetching %s failed: can't clone repository\", url));\n+            return false;\n+        }\n+        true\n+    }\n+\n+\n     // If a file named \"pkg.rs\" in the current directory exists,\n     // return the path for it. Otherwise, None\n     fn package_script_option(&self, cwd: &Path) -> Option<Path> {\n@@ -680,7 +572,7 @@ impl PkgSrc {\n     /// Requires that dashes in p have already been normalized to\n     /// underscores\n     fn stem_matches(&self, p: &Path) -> bool {\n-        let self_id = normalize(~copy self.id.path).filestem();\n+        let self_id = self.id.local_path.filestem();\n         if self_id == p.filestem() {\n             return true;\n         }\n@@ -715,7 +607,7 @@ impl PkgSrc {\n \n         let dir = self.check_dir();\n         let prefix = dir.components.len();\n-        debug!(\"Matching against %?\", self.id.path.filestem());\n+        debug!(\"Matching against %?\", self.id.local_path.filestem());\n         for os::walk_dir(&dir) |pth| {\n             match pth.filename() {\n                 Some(~\"lib.rs\") => push_crate(&mut self.libs,\n@@ -752,8 +644,7 @@ impl PkgSrc {\n                     src_dir: &Path,\n                     crates: &[Crate],\n                     cfgs: &[~str],\n-                    test: bool, crate_type: crate_type) {\n-\n+                    what: OutputType) {\n         for crates.each |&crate| {\n             let path = &src_dir.push_rel(&crate.file).normalize();\n             util::note(fmt!(\"build_crates: compiling %s\", path.to_str()));\n@@ -763,7 +654,7 @@ impl PkgSrc {\n                                      dst_dir,\n                                      crate.flags,\n                                      crate.cfgs + cfgs,\n-                                     false, test, crate_type);\n+                                     false, what);\n             if !result {\n                 build_err::cond.raise(fmt!(\"build failure on %s\",\n                                            path.to_str()));\n@@ -776,12 +667,13 @@ impl PkgSrc {\n     fn build(&self, dst_dir: &Path, cfgs: ~[~str], maybe_sysroot: Option<@Path>) {\n         let dir = self.check_dir();\n         debug!(\"Building libs\");\n-        self.build_crates(maybe_sysroot, dst_dir, &dir, self.libs, cfgs, false, lib_crate);\n+        self.build_crates(maybe_sysroot, dst_dir, &dir, self.libs, cfgs, Lib);\n         debug!(\"Building mains\");\n-        self.build_crates(maybe_sysroot, dst_dir, &dir, self.mains, cfgs, false, bin_crate);\n+        self.build_crates(maybe_sysroot, dst_dir, &dir, self.mains, cfgs, Main);\n         debug!(\"Building tests\");\n-        self.build_crates(maybe_sysroot, dst_dir, &dir, self.tests, cfgs, true, bin_crate);\n+        self.build_crates(maybe_sysroot, dst_dir, &dir, self.tests, cfgs, Test);\n         debug!(\"Building benches\");\n-        self.build_crates(maybe_sysroot, dst_dir, &dir, self.benchs, cfgs, true, bin_crate);\n+        self.build_crates(maybe_sysroot, dst_dir, &dir, self.benchs, cfgs, Bench);\n     }\n }\n+"}, {"sha": "487e8d0da36e2d8f98535511392fc7fb0f46b7fd", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 75, "deletions": 15, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/6a9c3bd86e0271f26dc63bd12e0d54a35b704dff/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a9c3bd86e0271f26dc63bd12e0d54a35b704dff/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=6a9c3bd86e0271f26dc63bd12e0d54a35b704dff", "patch": "@@ -17,8 +17,8 @@ use std::tempfile::mkdtemp;\n use util::{PkgId, default_version};\n use path_util::{target_executable_in_workspace, target_library_in_workspace,\n                target_test_in_workspace, target_bench_in_workspace,\n-               make_dir_rwx, u_rwx};\n-use core::os::mkdir_recursive;\n+               make_dir_rwx, u_rwx, RemotePath, LocalPath, normalize,\n+               built_bench_in_workspace, built_test_in_workspace};\n \n fn fake_ctxt(sysroot_opt: Option<@Path>) -> Ctx {\n     Ctx {\n@@ -29,15 +29,22 @@ fn fake_ctxt(sysroot_opt: Option<@Path>) -> Ctx {\n }\n \n fn fake_pkg() -> PkgId {\n+    let sn = ~\"bogus\";\n+    let remote = RemotePath(Path(sn));\n     PkgId {\n-        path: Path(~\"bogus\"),\n+        local_path: normalize(copy remote),\n+        remote_path: remote,\n+        short_name: sn,\n         version: default_version()\n     }\n }\n \n fn remote_pkg() -> PkgId {\n+    let remote = RemotePath(Path(~\"github.com/catamorphism/test-pkg\"));\n     PkgId {\n-        path: Path(~\"github.com/catamorphism/test-pkg\"),\n+        local_path: normalize(copy remote),\n+        remote_path: remote,\n+        short_name: ~\"test_pkg\",\n         version: default_version()\n     }\n }\n@@ -49,10 +56,11 @@ fn writeFile(file_path: &Path, contents: ~str) {\n     out.write_line(contents);\n }\n \n-fn mk_temp_workspace(short_name: &Path) -> Path {\n+fn mk_temp_workspace(short_name: &LocalPath) -> Path {\n     let workspace = mkdtemp(&os::tmpdir(), \"test\").expect(\"couldn't create temp dir\");\n-    let package_dir = workspace.push(~\"src\").push_rel(short_name);\n-    assert!(mkdir_recursive(&package_dir, u_rwx));\n+    // include version number in directory name\n+    let package_dir = workspace.push(~\"src\").push(fmt!(\"%s-0.1\", short_name.to_str()));\n+    assert!(os::mkdir_recursive(&package_dir, u_rwx));\n     // Create main, lib, test, and bench files\n     writeFile(&package_dir.push(~\"main.rs\"),\n               ~\"fn main() { let _x = (); }\");\n@@ -104,7 +112,7 @@ fn test_install_valid() {\n     debug!(\"sysroot = %s\", sysroot.to_str());\n     let ctxt = fake_ctxt(Some(@sysroot));\n     let temp_pkg_id = fake_pkg();\n-    let temp_workspace = mk_temp_workspace(&temp_pkg_id.path);\n+    let temp_workspace = mk_temp_workspace(&temp_pkg_id.local_path);\n     // should have test, bench, lib, and main\n     ctxt.install(&temp_workspace, &temp_pkg_id);\n     // Check that all files exist\n@@ -146,27 +154,79 @@ fn test_install_invalid() {\n }\n \n #[test]\n-#[ignore(reason = \"install from URL-fragment not yet implemented\")]\n fn test_install_url() {\n+    let workspace = mkdtemp(&os::tmpdir(), \"test\").expect(\"couldn't create temp dir\");\n     let sysroot = test_sysroot();\n     debug!(\"sysroot = %s\", sysroot.to_str());\n     let ctxt = fake_ctxt(Some(@sysroot));\n     let temp_pkg_id = remote_pkg();\n-    let temp_workspace = mk_temp_workspace(&temp_pkg_id.path);\n     // should have test, bench, lib, and main\n-    ctxt.install(&temp_workspace, &temp_pkg_id);\n+    ctxt.install(&workspace, &temp_pkg_id);\n     // Check that all files exist\n-    let exec = target_executable_in_workspace(&temp_pkg_id, &temp_workspace);\n+    let exec = target_executable_in_workspace(&temp_pkg_id, &workspace);\n     debug!(\"exec = %s\", exec.to_str());\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n-    let lib = target_library_in_workspace(&temp_pkg_id, &temp_workspace);\n+    let lib = target_library_in_workspace(&temp_pkg_id, &workspace);\n     debug!(\"lib = %s\", lib.to_str());\n     assert!(os::path_exists(&lib));\n     assert!(is_rwx(&lib));\n+    let built_test = built_test_in_workspace(&temp_pkg_id, &workspace).expect(~\"test_install_url\");\n+    assert!(os::path_exists(&built_test));\n+    let built_bench = built_bench_in_workspace(&temp_pkg_id,\n+                                               &workspace).expect(~\"test_install_url\");\n+    assert!(os::path_exists(&built_bench));\n     // And that the test and bench executables aren't installed\n-    assert!(!os::path_exists(&target_test_in_workspace(&temp_pkg_id, &temp_workspace)));\n-    let bench = target_bench_in_workspace(&temp_pkg_id, &temp_workspace);\n+    let test = target_test_in_workspace(&temp_pkg_id, &workspace);\n+    assert!(!os::path_exists(&test));\n+    debug!(\"test = %s\", test.to_str());\n+    let bench = target_bench_in_workspace(&temp_pkg_id, &workspace);\n     debug!(\"bench = %s\", bench.to_str());\n     assert!(!os::path_exists(&bench));\n }\n+\n+#[test]\n+fn test_package_ids_must_be_relative_path_like() {\n+    use conditions::bad_pkg_id::cond;\n+\n+    /*\n+    Okay:\n+    - One identifier, with no slashes\n+    - Several slash-delimited things, with no / at the root\n+\n+    Not okay:\n+    - Empty string\n+    - Absolute path (as per os::is_absolute)\n+\n+    */\n+\n+    let default_version_str = \"0.1\";\n+    let addversion = |s| {\n+        fmt!(\"%s-%s\", s, default_version_str)\n+    };\n+\n+    let whatever = PkgId::new(\"foo\");\n+\n+    assert!(addversion(\"foo\") == whatever.to_str());\n+    assert!(addversion(\"github.com/mozilla/rust\") ==\n+            PkgId::new(\"github.com/mozilla/rust\").to_str());\n+\n+    do cond.trap(|(p, e)| {\n+        assert!(\"\" == p.to_str());\n+        assert!(\"0-length pkgid\" == e);\n+        copy whatever\n+    }).in {\n+        let x = PkgId::new(\"\");\n+        assert!(addversion(\"foo\") == x.to_str());\n+    }\n+\n+    do cond.trap(|(p, e)| {\n+        assert!(p.to_str() == os::make_absolute(&Path(\"foo/bar/quux\")).to_str());\n+        assert!(\"absolute pkgid\" == e);\n+        copy whatever\n+    }).in {\n+        let z = PkgId::new(os::make_absolute(&Path(\"foo/bar/quux\")).to_str());\n+        assert!(addversion(\"foo\") == z.to_str());\n+    }\n+\n+}"}, {"sha": "4a9c276948aa04a912e66fcfb84680d46ec037ae", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 92, "deletions": 196, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/6a9c3bd86e0271f26dc63bd12e0d54a35b704dff/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a9c3bd86e0271f26dc63bd12e0d54a35b704dff/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=6a9c3bd86e0271f26dc63bd12e0d54a35b704dff", "patch": "@@ -13,20 +13,18 @@ use core::cmp::Ord;\n use core::hash::Streaming;\n use core::rt::io::Writer;\n use rustc::driver::{driver, session};\n-use rustc::driver::session::{lib_crate, unknown_crate};\n use rustc::metadata::filesearch;\n use std::getopts::groups::getopts;\n use std::semver;\n-use std::{json, term, getopts};\n+use std::{term, getopts};\n use syntax::ast_util::*;\n use syntax::codemap::{dummy_sp, spanned, dummy_spanned};\n use syntax::ext::base::{mk_ctxt, ext_ctxt};\n-use syntax::ext::build;\n use syntax::{ast, attr, codemap, diagnostic, fold};\n-use syntax::ast::{meta_name_value, meta_list, attribute};\n+use syntax::ast::{meta_name_value, meta_list};\n use syntax::attr::{mk_attr};\n use rustc::back::link::output_type_exe;\n-use rustc::driver::session::{lib_crate, unknown_crate, crate_type};\n+use rustc::driver::session::{lib_crate, bin_crate};\n \n static Commands: &'static [&'static str] =\n     &[\"build\", \"clean\", \"do\", \"info\", \"install\", \"prefer\", \"test\", \"uninstall\",\n@@ -83,20 +81,34 @@ impl ToStr for Version {\n     }\n }\n \n+#[deriving(Eq)]\n+pub enum OutputType { Main, Lib, Bench, Test }\n+\n /// Placeholder\n pub fn default_version() -> Version { ExactRevision(0.1) }\n \n-// Path-fragment identifier of a package such as\n-// 'github.com/graydon/test'; path must be a relative\n-// path with >=1 component.\n+/// Path-fragment identifier of a package such as\n+/// 'github.com/graydon/test'; path must be a relative\n+/// path with >=1 component.\n pub struct PkgId {\n-    path: Path,\n+    /// Remote path: for example, github.com/mozilla/quux-whatever\n+    remote_path: RemotePath,\n+    /// Local path: for example, /home/quux/github.com/mozilla/quux_whatever\n+    /// Note that '-' normalizes to '_' when mapping a remote path\n+    /// onto a local path\n+    /// Also, this will change when we implement #6407, though we'll still\n+    /// need to keep track of separate local and remote paths\n+    local_path: LocalPath,\n+    /// Short name. This is the local path's filestem, but we store it\n+    /// redundantly so as to not call get() everywhere (filestem() returns an\n+    /// option)\n+    short_name: ~str,\n     version: Version\n }\n \n pub impl PkgId {\n     fn new(s: &str) -> PkgId {\n-        use bad_pkg_id::cond;\n+        use conditions::bad_pkg_id::cond;\n \n         let p = Path(s);\n         if p.is_absolute {\n@@ -105,31 +117,32 @@ pub impl PkgId {\n         if p.components.len() < 1 {\n             return cond.raise((p, ~\"0-length pkgid\"));\n         }\n+        let remote_path = RemotePath(p);\n+        let local_path = normalize(copy remote_path);\n+        let short_name = (copy local_path).filestem().expect(fmt!(\"Strange path! %s\", s));\n         PkgId {\n-            path: p,\n+            local_path: local_path,\n+            remote_path: remote_path,\n+            short_name: short_name,\n             version: default_version()\n         }\n     }\n \n     fn hash(&self) -> ~str {\n-        fmt!(\"%s-%s-%s\", self.path.to_str(),\n-             hash(self.path.to_str() + self.version.to_str()),\n+        fmt!(\"%s-%s-%s\", self.remote_path.to_str(),\n+             hash(self.remote_path.to_str() + self.version.to_str()),\n              self.version.to_str())\n     }\n \n+    fn short_name_with_version(&self) -> ~str {\n+        fmt!(\"%s-%s\", self.short_name, self.version.to_str())\n+    }\n }\n \n impl ToStr for PkgId {\n     fn to_str(&self) -> ~str {\n         // should probably use the filestem and not the whole path\n-        fmt!(\"%s-%s\", self.path.to_str(),\n-             // Replace dots with -s in the version\n-             // this is because otherwise rustc will think\n-             // that foo-0.1 has .1 as its extension\n-             // (Temporary hack until I figure out how to\n-             // get rustc to not name the object file\n-             // foo-0.o if I pass in foo-0.1 to build_output_filenames)\n-             str::replace(self.version.to_str(), \".\", \"-\"))\n+        fmt!(\"%s-%s\", self.local_path.to_str(), self.version.to_str())\n     }\n }\n \n@@ -156,26 +169,6 @@ pub fn is_cmd(cmd: &str) -> bool {\n     Commands.any(|&c| c == cmd)\n }\n \n-pub fn parse_name(id: ~str) -> result::Result<~str, ~str> {\n-    let mut last_part = None;\n-\n-    for str::each_split_char(id, '.') |part| {\n-        for str::each_char(part) |char| {\n-            if char::is_whitespace(char) {\n-                return result::Err(\n-                    ~\"could not parse id: contains whitespace\");\n-            } else if char::is_uppercase(char) {\n-                return result::Err(\n-                    ~\"could not parse id: should be all lowercase\");\n-            }\n-        }\n-        last_part = Some(part.to_owned());\n-    }\n-    if last_part.is_none() { return result::Err(~\"could not parse id: is empty\"); }\n-\n-    result::Ok(last_part.unwrap())\n-}\n-\n struct ListenerFn {\n     cmds: ~[~str],\n     span: codemap::span,\n@@ -248,52 +241,6 @@ fn fold_item(ctx: @mut ReadyCtx,\n     res\n }\n \n-fn add_pkg_module(ctx: @mut ReadyCtx, m: ast::_mod) -> ast::_mod {\n-    let listeners = mk_listener_vec(ctx);\n-    let ext_cx = ctx.ext_cx;\n-    let item = quote_item! (\n-        mod __pkg {\n-            extern mod rustpkg (vers=\"0.7-pre\");\n-            static listeners : &[rustpkg::Listener] = $listeners;\n-            #[main]\n-            fn main() {\n-                rustpkg::run(listeners);\n-            }\n-        }\n-    );\n-    ast::_mod {\n-        items: vec::append_one(/*bad*/copy m.items, item.get()),\n-        .. m\n-    }\n-}\n-\n-fn mk_listener_vec(ctx: @mut ReadyCtx) -> @ast::expr {\n-    let descs = do ctx.fns.map |listener| {\n-        mk_listener_rec(ctx, listener)\n-    };\n-    let ext_cx = ctx.ext_cx;\n-    build::mk_slice_vec_e(ext_cx, dummy_sp(), descs)\n-}\n-\n-fn mk_listener_rec(ctx: @mut ReadyCtx, listener: &ListenerFn) -> @ast::expr {\n-    let span = listener.span;\n-    let cmds = do listener.cmds.map |&cmd| {\n-        let ext_cx = ctx.ext_cx;\n-        build::mk_base_str(ext_cx, span, cmd)\n-    };\n-\n-    let ext_cx = ctx.ext_cx;\n-    let cmds_expr = build::mk_slice_vec_e(ext_cx, span, cmds);\n-    let cb_expr = build::mk_path(ext_cx, span, copy listener.path);\n-\n-    quote_expr!(\n-        Listener {\n-            cmds: $cmds_expr,\n-            cb: $cb_expr\n-        }\n-    )\n-}\n-\n /// Generate/filter main function, add the list of commands, etc.\n pub fn ready_crate(sess: session::Session,\n                    crate: @ast::crate) -> @ast::crate {\n@@ -375,67 +322,6 @@ pub fn hash(data: ~str) -> ~str {\n     hasher.result_str()\n }\n \n-pub fn temp_change_dir<T>(dir: &Path, cb: &fn() -> T) {\n-    let cwd = os::getcwd();\n-\n-    os::change_dir(dir);\n-    cb();\n-    os::change_dir(&cwd);\n-}\n-\n-pub fn touch(path: &Path) {\n-    match io::mk_file_writer(path, ~[io::Create]) {\n-        result::Ok(writer) => writer.write_line(~\"\"),\n-        _ => {}\n-    }\n-}\n-\n-pub fn remove_dir_r(path: &Path) {\n-    for os::walk_dir(path) |&file| {\n-        let mut cdir = file;\n-\n-        loop {\n-            if os::path_is_dir(&cdir) {\n-                os::remove_dir(&cdir);\n-            } else {\n-                os::remove_file(&cdir);\n-            }\n-\n-            cdir = cdir.dir_path();\n-\n-            if cdir == *path { break; }\n-        }\n-    }\n-\n-    os::remove_dir(path);\n-}\n-\n-pub fn wait_for_lock(path: &Path) {\n-    if os::path_exists(path) {\n-        warn(fmt!(\"the database appears locked, please wait (or rm %s)\",\n-                        path.to_str()));\n-\n-        loop {\n-            if !os::path_exists(path) { break; }\n-        }\n-    }\n-}\n-\n-pub fn load_pkgs() -> result::Result<~[json::Json], ~str> {\n-    fail!(\"load_pkg not implemented\");\n-}\n-\n-pub fn get_pkg(_id: ~str,\n-               _vers: Option<~str>) -> result::Result<Pkg, ~str> {\n-    fail!(\"get_pkg not implemented\");\n-}\n-\n-pub fn add_pkg(pkg: &Pkg) -> bool {\n-    note(fmt!(\"Would be adding package, but add_pkg is not yet implemented %s\",\n-         pkg.to_str()));\n-    false\n-}\n-\n // FIXME (#4432): Use workcache to only compile when needed\n pub fn compile_input(sysroot: Option<@Path>,\n                      pkg_id: &PkgId,\n@@ -444,31 +330,24 @@ pub fn compile_input(sysroot: Option<@Path>,\n                      flags: &[~str],\n                      cfgs: &[~str],\n                      opt: bool,\n-                     test: bool,\n-                     crate_type: session::crate_type) -> bool {\n-\n-    // Want just the directory component here\n-    let pkg_filename = pkg_id.path.filename().expect(~\"Weird pkg id\");\n-    let short_name = fmt!(\"%s-%s\", pkg_filename, pkg_id.version.to_str());\n+                     what: OutputType) -> bool {\n \n     assert!(in_file.components.len() > 1);\n     let input = driver::file_input(copy *in_file);\n-    debug!(\"compile_input: %s / %?\", in_file.to_str(), crate_type);\n+    debug!(\"compile_input: %s / %?\", in_file.to_str(), what);\n     // tjc: by default, use the package ID name as the link name\n     // not sure if we should support anything else\n \n-    let binary = @copy os::args()[0];\n-    let building_library = match crate_type {\n-        lib_crate | unknown_crate => true,\n-        _ => false\n-    };\n+    let binary = @(copy os::args()[0]);\n+    let building_library = what == Lib;\n \n     let out_file = if building_library {\n-        out_dir.push(os::dll_filename(short_name))\n+        out_dir.push(os::dll_filename(pkg_id.short_name))\n     }\n     else {\n-        out_dir.push(short_name + if test { ~\"test\" } else { ~\"\" }\n-                     + os::EXE_SUFFIX)\n+        out_dir.push(pkg_id.short_name + match what {\n+            Test => ~\"test\", Bench => ~\"bench\", Main | Lib => ~\"\"\n+        } + os::EXE_SUFFIX)\n     };\n \n     debug!(\"compiling %s into %s\",\n@@ -478,18 +357,24 @@ pub fn compile_input(sysroot: Option<@Path>,\n     debug!(\"cfgs: %s\", str::connect(cfgs, ~\" \"));\n     debug!(\"compile_input's sysroot = %?\", sysroot);\n \n+    let crate_type = match what {\n+        Lib => lib_crate,\n+        Test | Bench | Main => bin_crate\n+    };\n     let matches = getopts(~[~\"-Z\", ~\"time-passes\"]\n-                          + if building_library { ~[~\"--lib\"] }\n-                            else if test { ~[~\"--test\"] }\n-                            // bench?\n-                            else { ~[] }\n+                          + match what {\n+                              Lib => ~[~\"--lib\"],\n+                              // --test compiles both #[test] and #[bench] fns\n+                              Test | Bench => ~[~\"--test\"],\n+                              Main => ~[]\n+                          }\n                           + flags\n                           + cfgs.flat_map(|&c| { ~[~\"--cfg\", c] }),\n                           driver::optgroups()).get();\n     let mut options = session::options {\n         crate_type: crate_type,\n         optimize: if opt { session::Aggressive } else { session::No },\n-        test: test,\n+        test: what == Test || what == Bench,\n         maybe_sysroot: sysroot,\n         addl_lib_search_paths: ~[copy *out_dir],\n         // output_type should be conditional\n@@ -540,26 +425,27 @@ pub fn compile_crate_from_input(input: &driver::input,\n             debug!(\"Calling compile_upto, outputs = %?\", outputs);\n             let (crate, _) = driver::compile_upto(sess, copy cfg, input,\n                                                   driver::cu_parse, Some(outputs));\n+            let mut crate = crate;\n \n             debug!(\"About to inject link_meta info...\");\n             // Inject the inferred link_meta info if it's not already there\n             // (assumes that name and vers are the only linkage metas)\n-            let mut crate_to_use = crate;\n \n             debug!(\"How many attrs? %?\", attr::find_linkage_metas(crate.node.attrs).len());\n \n             if attr::find_linkage_metas(crate.node.attrs).is_empty() {\n-                crate_to_use = add_attrs(copy *crate,\n-                    ~[mk_attr(@dummy_spanned(meta_list(@~\"link\",\n-                                                  // change PkgId to have a <shortname> field?\n-                    ~[@dummy_spanned(meta_name_value(@~\"name\",\n-                                                    mk_string_lit(@pkg_id.path.filestem().get()))),\n-                      @dummy_spanned(meta_name_value(@~\"vers\",\n-                                                    mk_string_lit(@pkg_id.version.to_str())))])))]);\n+                crate = @codemap::respan(crate.span, ast::crate_ {\n+                    attrs: ~[mk_attr(@dummy_spanned(\n+                        meta_list(@~\"link\",\n+                                  ~[@dummy_spanned(meta_name_value(@~\"name\",\n+                                        mk_string_lit(@(copy pkg_id.short_name)))),\n+                                    @dummy_spanned(meta_name_value(@~\"vers\",\n+                                        mk_string_lit(@(copy pkg_id.version.to_str()))))])))],\n+                    ..copy crate.node});\n             }\n \n-            driver::compile_rest(sess, cfg, what, Some(outputs), Some(crate_to_use));\n-            crate_to_use\n+            driver::compile_rest(sess, cfg, what, Some(outputs), Some(crate));\n+            crate\n         }\n     }\n }\n@@ -573,30 +459,41 @@ pub fn exe_suffix() -> ~str { ~\".exe\" }\n #[cfg(target_os = \"macos\")]\n pub fn exe_suffix() -> ~str { ~\"\" }\n \n-\n-/// Returns a copy of crate `c` with attributes `attrs` added to its\n-/// attributes\n-fn add_attrs(mut c: ast::crate, new_attrs: ~[attribute]) -> @ast::crate {\n-    c.node.attrs += new_attrs;\n-    @c\n-}\n-\n // Called by build_crates\n // FIXME (#4432): Use workcache to only compile when needed\n pub fn compile_crate(sysroot: Option<@Path>, pkg_id: &PkgId,\n                      crate: &Path, dir: &Path,\n                      flags: &[~str], cfgs: &[~str], opt: bool,\n-                     test: bool, crate_type: crate_type) -> bool {\n+                     what: OutputType) -> bool {\n     debug!(\"compile_crate: crate=%s, dir=%s\", crate.to_str(), dir.to_str());\n     debug!(\"compile_crate: short_name = %s, flags =...\", pkg_id.to_str());\n     for flags.each |&fl| {\n         debug!(\"+++ %s\", fl);\n     }\n-    compile_input(sysroot, pkg_id,\n-                  crate, dir, flags, cfgs, opt, test, crate_type)\n+    compile_input(sysroot, pkg_id, crate, dir, flags, cfgs, opt, what)\n+}\n+\n+// normalize should be the only way to construct a LocalPath\n+// (though this isn't enforced)\n+/// Replace all occurrences of '-' in the stem part of path with '_'\n+/// This is because we treat rust-foo-bar-quux and rust_foo_bar_quux\n+/// as the same name\n+pub fn normalize(p_: RemotePath) -> LocalPath {\n+    let RemotePath(p) = p_;\n+    match p.filestem() {\n+        None => LocalPath(p),\n+        Some(st) => {\n+            let replaced = str::replace(st, \"-\", \"_\");\n+            if replaced != st {\n+                LocalPath(p.with_filestem(replaced))\n+            }\n+            else {\n+                LocalPath(p)\n+            }\n+        }\n+    }\n }\n \n-\n #[cfg(windows)]\n pub fn link_exe(_src: &Path, _dest: &Path) -> bool {\n     /* FIXME (#1768): Investigate how to do this on win32\n@@ -628,9 +525,13 @@ pub fn mk_string_lit(s: @~str) -> ast::lit {\n     }\n }\n \n+/// Wrappers to prevent local and remote paths from getting confused\n+pub struct RemotePath (Path);\n+pub struct LocalPath (Path);\n+\n #[cfg(test)]\n mod test {\n-    use super::{is_cmd, parse_name};\n+    use super::is_cmd;\n \n     #[test]\n     fn test_is_cmd() {\n@@ -645,9 +546,4 @@ mod test {\n         assert!(is_cmd(~\"unprefer\"));\n     }\n \n-    #[test]\n-    fn test_parse_name() {\n-        assert!(parse_name(~\"org.mozilla.servo\").get() == ~\"servo\");\n-        assert!(parse_name(~\"org. mozilla.servo 2131\").is_err());\n-    }\n }"}, {"sha": "cb9f735bce8d4cd8a4aec215b65e6d5969fe34a4", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6a9c3bd86e0271f26dc63bd12e0d54a35b704dff/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a9c3bd86e0271f26dc63bd12e0d54a35b704dff/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=6a9c3bd86e0271f26dc63bd12e0d54a35b704dff", "patch": "@@ -21,9 +21,10 @@ pub fn pkg_parent_workspaces(pkgid: &PkgId, action: &fn(&Path) -> bool) -> bool\n         workspace_contains_package_id(pkgid, ws));\n     if workspaces.is_empty() {\n         // tjc: make this a condition\n-        fail!(\"Package %s not found in any of the following workspaces: %s\",\n-              pkgid.path.to_str(),\n-              rust_path().to_str());\n+        fail!(\"Package %s not found in any of \\\n+                    the following workspaces: %s\",\n+                   pkgid.remote_path.to_str(),\n+                   rust_path().to_str());\n     }\n     for workspaces.each |ws| {\n         if action(ws) {"}, {"sha": "218ab86721eefd7b7e97fa6d9f95a80a1fa8686c", "filename": "src/libuv", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuv?ref=6a9c3bd86e0271f26dc63bd12e0d54a35b704dff", "patch": "@@ -1 +1 @@\n-Subproject commit 97ac7c087a0caf6b0f611b80e14f7fe3cb18bb27\n+Subproject commit 218ab86721eefd7b7e97fa6d9f95a80a1fa8686c"}]}