{"sha": "f9d328d7ffa17ab78eaa62a2976033a7176886d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ZDMyOGQ3ZmZhMTdhYjc4ZWFhNjJhMjk3NjAzM2E3MTc2ODg2ZDk=", "commit": {"author": {"name": "Michal 'vorner' Vaner", "email": "vorner@vorner.cz", "date": "2019-05-12T12:53:01Z"}, "committer": {"name": "Michal 'vorner' Vaner", "email": "vorner@vorner.cz", "date": "2019-05-26T06:53:59Z"}, "message": "sync::Weak::{as,from,into}_raw\n\nMethods on the Weak to access it as raw pointer to the data.", "tree": {"sha": "19c6c36da4f63a63675339347f522be596657184", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19c6c36da4f63a63675339347f522be596657184"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9d328d7ffa17ab78eaa62a2976033a7176886d9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEQ8wy/3jh6tM0kr/e9wDQwBnkxm8FAlzqOAcACgkQ9wDQwBnk\nxm/+DhAAmmY+BYpH+ZP++94v3tW02xx0C1b6eT9QTRfyQaumc0Iuthi79DGr6H0z\nFM3+2qszuGRM3IKOoLAhPS7HyUyKKXAoiJz1mjK5V9kfUEHnSJ+pxFlSM6wUEUwY\nr2xfJQAm4LR4cYwYrSInvvVsPfZ6w1Dh0M4Wsw18qa1ezIZbVLA0QxlDul8qd9XS\n7nE4ffOKBOrRTudPUhoRDkrEAx5fGZt6pILalTAD4qSt4BX2RuIxc7QqW/Letplx\nzE4iRYq5tOPZdXE9ISHqzUMZNq8A19Dae073CmWLT59gDVESLgfGgorjRDk5At2J\nS59Z/McZUeWTkp6VdJY4HIjMth5CRPrEgUuJ/JJGLXpKBFTD1Eu+kdy55dQwGHFd\niRA1WAuq46BHAONdqScAbkiQo3JwatPVKne7RWHszr0RTGinq8EkaCu+poD70fCW\nqC6OakfedLO0N7jNBC1AOmmP8KPNBB/t67R6hHnZ6rti7lbV9tX4+yUwzg2LwHG3\nISo1g5sb0Hb4e+lzw1hXSHCfhKi3ZXN1TQushYL2jT+fA51ZiPS+XDxfMjhB5Am6\n7NcN85a6Xs3N5Kh5+T6kQfhELINVESWaek/luww77DNMRwVfaBQkGlZkF5ZdTgEN\nm9kERYZffum7cnWQZ6RcXxOXGrGFv2FcaSpLbYZhDSy5rGRr0Gc=\n=+0/w\n-----END PGP SIGNATURE-----", "payload": "tree 19c6c36da4f63a63675339347f522be596657184\nparent 16e356ebdfa42b754c1497f1c58caacbe2f25d03\nauthor Michal 'vorner' Vaner <vorner@vorner.cz> 1557665581 +0200\ncommitter Michal 'vorner' Vaner <vorner@vorner.cz> 1558853639 +0200\n\nsync::Weak::{as,from,into}_raw\n\nMethods on the Weak to access it as raw pointer to the data.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9d328d7ffa17ab78eaa62a2976033a7176886d9", "html_url": "https://github.com/rust-lang/rust/commit/f9d328d7ffa17ab78eaa62a2976033a7176886d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9d328d7ffa17ab78eaa62a2976033a7176886d9/comments", "author": {"login": "vorner", "id": 11783500, "node_id": "MDQ6VXNlcjExNzgzNTAw", "avatar_url": "https://avatars.githubusercontent.com/u/11783500?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vorner", "html_url": "https://github.com/vorner", "followers_url": "https://api.github.com/users/vorner/followers", "following_url": "https://api.github.com/users/vorner/following{/other_user}", "gists_url": "https://api.github.com/users/vorner/gists{/gist_id}", "starred_url": "https://api.github.com/users/vorner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vorner/subscriptions", "organizations_url": "https://api.github.com/users/vorner/orgs", "repos_url": "https://api.github.com/users/vorner/repos", "events_url": "https://api.github.com/users/vorner/events{/privacy}", "received_events_url": "https://api.github.com/users/vorner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vorner", "id": 11783500, "node_id": "MDQ6VXNlcjExNzgzNTAw", "avatar_url": "https://avatars.githubusercontent.com/u/11783500?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vorner", "html_url": "https://github.com/vorner", "followers_url": "https://api.github.com/users/vorner/followers", "following_url": "https://api.github.com/users/vorner/following{/other_user}", "gists_url": "https://api.github.com/users/vorner/gists{/gist_id}", "starred_url": "https://api.github.com/users/vorner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vorner/subscriptions", "organizations_url": "https://api.github.com/users/vorner/orgs", "repos_url": "https://api.github.com/users/vorner/repos", "events_url": "https://api.github.com/users/vorner/events{/privacy}", "received_events_url": "https://api.github.com/users/vorner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16e356ebdfa42b754c1497f1c58caacbe2f25d03", "url": "https://api.github.com/repos/rust-lang/rust/commits/16e356ebdfa42b754c1497f1c58caacbe2f25d03", "html_url": "https://github.com/rust-lang/rust/commit/16e356ebdfa42b754c1497f1c58caacbe2f25d03"}], "stats": {"total": 164, "additions": 158, "deletions": 6}, "files": [{"sha": "70865656c510ee7b988d28ad86254a2e6b643f73", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 158, "deletions": 6, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/f9d328d7ffa17ab78eaa62a2976033a7176886d9/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d328d7ffa17ab78eaa62a2976033a7176886d9/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=f9d328d7ffa17ab78eaa62a2976033a7176886d9", "patch": "@@ -13,7 +13,7 @@ use core::borrow;\n use core::fmt;\n use core::cmp::{self, Ordering};\n use core::intrinsics::abort;\n-use core::mem::{self, align_of_val, size_of_val};\n+use core::mem::{self, align_of, align_of_val, size_of_val};\n use core::ops::{Deref, Receiver, CoerceUnsized, DispatchFromDyn};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n@@ -397,11 +397,7 @@ impl<T: ?Sized> Arc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n-        // Align the unsized value to the end of the ArcInner.\n-        // Because it is ?Sized, it will always be the last field in memory.\n-        let align = align_of_val(&*ptr);\n-        let layout = Layout::new::<ArcInner<()>>();\n-        let offset = (layout.size() + layout.padding_needed_for(align)) as isize;\n+        let offset = data_offset(ptr);\n \n         // Reverse the offset to find the original ArcInner.\n         let fake_ptr = ptr as *mut ArcInner<T>;\n@@ -1071,6 +1067,144 @@ impl<T> Weak<T> {\n             ptr: NonNull::new(usize::MAX as *mut ArcInner<T>).expect(\"MAX is not 0\"),\n         }\n     }\n+\n+    /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n+    ///\n+    /// It is up to the caller to ensure that the object is still alive when accessing it through\n+    /// the pointer.\n+    ///\n+    /// The pointer may be [`null`] or be dangling in case the object has already been destroyed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::sync::{Arc, Weak};\n+    /// use std::ptr;\n+    ///\n+    /// let strong = Arc::new(42);\n+    /// let weak = Arc::downgrade(&strong);\n+    /// // Both point to the same object\n+    /// assert!(ptr::eq(&*strong, Weak::as_raw(&weak)));\n+    /// // The strong here keeps it alive, so we can still access the object.\n+    /// assert_eq!(42, unsafe { *Weak::as_raw(&weak) });\n+    ///\n+    /// drop(strong);\n+    /// // But not any more. We can do Weak::as_raw(&weak), but accessing the pointer would lead to\n+    /// // undefined behaviour.\n+    /// // assert_eq!(42, unsafe { *Weak::as_raw(&weak) });\n+    /// ```\n+    ///\n+    /// [`null`]: ../../std/ptr/fn.null.html\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn as_raw(this: &Self) -> *const T {\n+        match this.inner() {\n+            None => ptr::null(),\n+            Some(inner) => {\n+                let offset = data_offset_sized::<T>();\n+                let ptr = inner as *const ArcInner<T>;\n+                // Note: while the pointer we create may already point to dropped value, the\n+                // allocation still lives (it must hold the weak point as long as we are alive).\n+                // Therefore, the offset is OK to do, it won't get out of the allocation.\n+                let ptr = unsafe { (ptr as *const u8).offset(offset) };\n+                ptr as *const T\n+            }\n+        }\n+    }\n+\n+    /// Consumes the `Weak<T>` and turns it into a raw pointer.\n+    ///\n+    /// This converts the weak pointer into a raw pointer, preserving the original weak count. It\n+    /// can be turned back into the `Weak<T>` with [`from_raw`].\n+    ///\n+    /// The same restrictions of accessing the target of the pointer as with\n+    /// [`as_raw`] apply.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::sync::{Arc, Weak};\n+    ///\n+    /// let strong = Arc::new(42);\n+    /// let weak = Arc::downgrade(&strong);\n+    /// let raw = Weak::into_raw(weak);\n+    ///\n+    /// assert_eq!(1, Arc::weak_count(&strong));\n+    /// assert_eq!(42, unsafe { *raw });\n+    ///\n+    /// drop(unsafe { Weak::from_raw(raw) });\n+    /// assert_eq!(0, Arc::weak_count(&strong));\n+    /// ```\n+    ///\n+    /// [`from_raw`]: struct.Weak.html#method.from_raw\n+    /// [`as_raw`]: struct.Weak.html#method.as_raw\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn into_raw(this: Self) -> *const T {\n+        let result = Self::as_raw(&this);\n+        mem::forget(this);\n+        result\n+    }\n+\n+    /// Converts a raw pointer previously created by [`into_raw`] back into\n+    /// `Weak<T>`.\n+    ///\n+    /// This can be used to safely get a strong reference (by calling [`upgrade`]\n+    /// later) or to deallocate the weak count by dropping the `Weak<T>`.\n+    ///\n+    /// It takes ownership of one weak count. In case a [`null`] is passed, a dangling [`Weak`] is\n+    /// returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The pointer must represent one valid weak count. In other words, it must point to `T` which\n+    /// is or *was* managed by an [`Arc`] and the weak count of that [`Arc`] must not have reached\n+    /// 0. It is allowed for the strong count to be 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::sync::{Arc, Weak};\n+    ///\n+    /// let strong = Arc::new(42);\n+    ///\n+    /// let raw_1 = Weak::into_raw(Arc::downgrade(&strong));\n+    /// let raw_2 = Weak::into_raw(Arc::downgrade(&strong));\n+    ///\n+    /// assert_eq!(2, Arc::weak_count(&strong));\n+    ///\n+    /// assert_eq!(42, *Weak::upgrade(&unsafe { Weak::from_raw(raw_1) }).unwrap());\n+    /// assert_eq!(1, Arc::weak_count(&strong));\n+    ///\n+    /// drop(strong);\n+    ///\n+    /// // Decrement the last weak count.\n+    /// assert!(Weak::upgrade(&unsafe { Weak::from_raw(raw_2) }).is_none());\n+    /// ```\n+    ///\n+    /// [`null`]: ../../std/ptr/fn.null.html\n+    /// [`into_raw`]: struct.Weak.html#method.into_raw\n+    /// [`upgrade`]: struct.Weak.html#method.upgrade\n+    /// [`Weak`]: struct.Weak.html\n+    /// [`Arc`]: struct.Arc.html\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub unsafe fn from_raw(ptr: *const T) -> Self {\n+        if ptr.is_null() {\n+            Self::new()\n+        } else {\n+            // See Arc::from_raw for details\n+            let offset = data_offset(ptr);\n+            let fake_ptr = ptr as *mut ArcInner<T>;\n+            let ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n+            Weak {\n+                ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\"),\n+            }\n+        }\n+    }\n }\n \n impl<T: ?Sized> Weak<T> {\n@@ -2150,3 +2284,21 @@ impl<T: ?Sized> AsRef<T> for Arc<T> {\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Arc<T> { }\n+\n+/// Computes the offset of the data field within ArcInner.\n+unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n+    // Align the unsized value to the end of the ArcInner.\n+    // Because it is ?Sized, it will always be the last field in memory.\n+    let align = align_of_val(&*ptr);\n+    let layout = Layout::new::<ArcInner<()>>();\n+    (layout.size() + layout.padding_needed_for(align)) as isize\n+}\n+\n+/// Computes the offset of the data field within ArcInner.\n+///\n+/// Unlike [`data_offset`], this doesn't need the pointer, but it works only on `T: Sized`.\n+fn data_offset_sized<T>() -> isize {\n+    let align = align_of::<T>();\n+    let layout = Layout::new::<ArcInner<()>>();\n+    (layout.size() + layout.padding_needed_for(align)) as isize\n+}"}]}