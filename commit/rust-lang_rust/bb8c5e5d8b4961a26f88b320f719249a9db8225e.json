{"sha": "bb8c5e5d8b4961a26f88b320f719249a9db8225e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiOGM1ZTVkOGI0OTYxYTI2Zjg4YjMyMGY3MTkyNDlhOWRiODIyNWU=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-11-15T22:09:51Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-11-15T22:09:51Z"}, "message": "Fix case when ExprUseVisitor is called after typeck writeback\n\nClippy uses `ExprUseVisitor` and atleast in some cases it runs\nafter writeback.\n\nWe currently don't writeback the min_capture results of closure\ncapture analysis since no place within the compiler itself uses it.\n\nIn the short term to fix clippy we add a fallback when walking captures\nof a closure to check if closure_capture analysis has any entries in it.\n\nWriteback for closure_min_captures will be implemented in\nrust-lang/project-rfc-2229#18", "tree": {"sha": "edf2da90649c0da6edafa9980f5a8776ee4165e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edf2da90649c0da6edafa9980f5a8776ee4165e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb8c5e5d8b4961a26f88b320f719249a9db8225e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb8c5e5d8b4961a26f88b320f719249a9db8225e", "html_url": "https://github.com/rust-lang/rust/commit/bb8c5e5d8b4961a26f88b320f719249a9db8225e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb8c5e5d8b4961a26f88b320f719249a9db8225e/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c50e57f946ee5a73b50fa5c52bb7a2a8a0cecf3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c50e57f946ee5a73b50fa5c52bb7a2a8a0cecf3f", "html_url": "https://github.com/rust-lang/rust/commit/c50e57f946ee5a73b50fa5c52bb7a2a8a0cecf3f"}], "stats": {"total": 49, "additions": 49, "deletions": 0}, "files": [{"sha": "72e5a7ef1b6e14ba667935240c0619862d358d03", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/bb8c5e5d8b4961a26f88b320f719249a9db8225e/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8c5e5d8b4961a26f88b320f719249a9db8225e/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=bb8c5e5d8b4961a26f88b320f719249a9db8225e", "patch": "@@ -15,6 +15,7 @@ use rustc_index::vec::Idx;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::hir::place::ProjectionKind;\n use rustc_middle::ty::{self, adjustment, TyCtxt};\n+use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n \n use crate::mem_categorization as mc;\n@@ -570,6 +571,38 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }));\n     }\n \n+    /// Walk closure captures but using `closure_caputes` instead\n+    /// of `closure_min_captures`.\n+    ///\n+    /// This is needed because clippy uses `ExprUseVisitor` after TypeckResults\n+    /// are written back. We don't currently writeback min_captures to\n+    /// TypeckResults.\n+    fn walk_captures_closure_captures(&mut self, closure_expr: &hir::Expr<'_>) {\n+        // FIXME(arora-aman): Remove this function once rust-lang/project-rfc-2229#18\n+        // is completed.\n+        debug!(\"walk_captures_closure_captures({:?}), \", closure_expr);\n+\n+        let closure_def_id = self.tcx().hir().local_def_id(closure_expr.hir_id).to_def_id();\n+        let cl_span = self.tcx().hir().span(closure_expr.hir_id);\n+\n+        let captures = &self.mc.typeck_results.closure_captures[&closure_def_id];\n+\n+        for (&var_id, &upvar_id) in captures {\n+            let upvar_capture = self.mc.typeck_results.upvar_capture(upvar_id);\n+            let captured_place =\n+                return_if_err!(self.cat_captured_var(closure_expr.hir_id, cl_span, var_id));\n+            match upvar_capture {\n+                ty::UpvarCapture::ByValue(_) => {\n+                    let mode = copy_or_move(&self.mc, &captured_place);\n+                    self.delegate.consume(&captured_place, captured_place.hir_id, mode);\n+                }\n+                ty::UpvarCapture::ByRef(upvar_borrow) => {\n+                    self.delegate.borrow(&captured_place, captured_place.hir_id, upvar_borrow.kind);\n+                }\n+            }\n+        }\n+    }\n+\n     /// Handle the case where the current body contains a closure.\n     ///\n     /// When the current body being handled is a closure, then we must make sure that\n@@ -625,6 +658,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                         PlaceBase::Upvar(upvar_id),\n                         place.projections.clone(),\n                     );\n+\n                     match capture_info.capture_kind {\n                         ty::UpvarCapture::ByValue(_) => {\n                             let mode = copy_or_move(&self.mc, &place_with_id);\n@@ -640,8 +674,23 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n+        } else if self.mc.typeck_results.closure_captures.contains_key(&closure_def_id) {\n+            // Handle the case where clippy calls ExprUseVisitor after\n+            self.walk_captures_closure_captures(closure_expr)\n         }\n     }\n+\n+    fn cat_captured_var(\n+        &mut self,\n+        closure_hir_id: hir::HirId,\n+        closure_span: Span,\n+        var_id: hir::HirId,\n+    ) -> mc::McResult<PlaceWithHirId<'tcx>> {\n+        // Create the place for the variable being borrowed, from the\n+        // perspective of the creator (parent) of the closure.\n+        let var_ty = self.mc.node_ty(var_id)?;\n+        self.mc.cat_res(closure_hir_id, closure_span, var_ty, Res::Local(var_id))\n+    }\n }\n \n fn copy_or_move<'a, 'tcx>("}]}