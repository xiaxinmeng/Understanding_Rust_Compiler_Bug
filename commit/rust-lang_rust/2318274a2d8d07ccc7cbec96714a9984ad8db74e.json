{"sha": "2318274a2d8d07ccc7cbec96714a9984ad8db74e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzMTgyNzRhMmQ4ZDA3Y2NjN2NiZWM5NjcxNGE5OTg0YWQ4ZGI3NGU=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2019-03-16T06:56:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-03-16T06:56:13Z"}, "message": "Rollup merge of #58855 - alexcrichton:wasm-multithreaded-alloc, r=fitzgen\n\nstd: Spin for a global malloc lock on wasm32\n\nThere's lots of comments in the code, but the main gist of this commit\nis that the acquisition of the global malloc lock on the\n`wasm32-unknown-unknown` target when threads are enabled will not spin\non contention rather than block.", "tree": {"sha": "7850be3f928adc1db94e0d04a3812f1fb2f1b21e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7850be3f928adc1db94e0d04a3812f1fb2f1b21e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2318274a2d8d07ccc7cbec96714a9984ad8db74e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcjJ4NCRBK7hj4Ov3rIwAAdHIIAKMUUYoTdmiF5Lm238O66UAt\n+39X8hgQxt/19ihRDaM296MEQsTbKH3YX0E8CWg1fJsyIsGXsCIA+kqrNW7y9I5H\nJrCRNG7q+PmhZFQ/w41CF3CReqiSeQfIhv37Dv8Y0XCxYzOhO0dvFjTnBj3WE1aT\nagAr5txj5BoBdx9gyzOpoE9Q31MQB0AkAVY8X29eGq6FKiLKKKDqeJzJ/PgJae6B\nyzTBLlfbe14Bld7rsY+wmTP6jdrJWxTXxgjndLPn/gGOWrTmj+iDpVIzBeL6fDpY\nhjhGjXXTzs9Bp5ftPWNgfEADSofWzueJNi+MeozV6jwYbodN1Y4T/OVTlH8rI10=\n=qBB4\n-----END PGP SIGNATURE-----\n", "payload": "tree 7850be3f928adc1db94e0d04a3812f1fb2f1b21e\nparent bc3bef83270eb9032471965624016ab9f6b4ff24\nparent 72958acd57fb32e0f8027c0d7e76c9a0c7f155d2\nauthor kennytm <kennytm@gmail.com> 1552719373 +0800\ncommitter GitHub <noreply@github.com> 1552719373 +0800\n\nRollup merge of #58855 - alexcrichton:wasm-multithreaded-alloc, r=fitzgen\n\nstd: Spin for a global malloc lock on wasm32\n\nThere's lots of comments in the code, but the main gist of this commit\nis that the acquisition of the global malloc lock on the\n`wasm32-unknown-unknown` target when threads are enabled will not spin\non contention rather than block.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2318274a2d8d07ccc7cbec96714a9984ad8db74e", "html_url": "https://github.com/rust-lang/rust/commit/2318274a2d8d07ccc7cbec96714a9984ad8db74e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2318274a2d8d07ccc7cbec96714a9984ad8db74e/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc3bef83270eb9032471965624016ab9f6b4ff24", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc3bef83270eb9032471965624016ab9f6b4ff24", "html_url": "https://github.com/rust-lang/rust/commit/bc3bef83270eb9032471965624016ab9f6b4ff24"}, {"sha": "72958acd57fb32e0f8027c0d7e76c9a0c7f155d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/72958acd57fb32e0f8027c0d7e76c9a0c7f155d2", "html_url": "https://github.com/rust-lang/rust/commit/72958acd57fb32e0f8027c0d7e76c9a0c7f155d2"}], "stats": {"total": 95, "additions": 80, "deletions": 15}, "files": [{"sha": "c1af6ec12623c51bf7d9509b398f41e7452157d7", "filename": "src/libstd/sys/wasm/alloc.rs", "status": "modified", "additions": 80, "deletions": 15, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/2318274a2d8d07ccc7cbec96714a9984ad8db74e/src%2Flibstd%2Fsys%2Fwasm%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2318274a2d8d07ccc7cbec96714a9984ad8db74e/src%2Flibstd%2Fsys%2Fwasm%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Falloc.rs?ref=2318274a2d8d07ccc7cbec96714a9984ad8db74e", "patch": "@@ -49,7 +49,6 @@ unsafe impl GlobalAlloc for System {\n \n #[cfg(target_feature = \"atomics\")]\n mod lock {\n-    use crate::arch::wasm32;\n     use crate::sync::atomic::{AtomicI32, Ordering::SeqCst};\n \n     static LOCKED: AtomicI32 = AtomicI32::new(0);\n@@ -61,27 +60,93 @@ mod lock {\n             if LOCKED.swap(1, SeqCst) == 0 {\n                 return DropLock\n             }\n-            unsafe {\n-                let r = wasm32::i32_atomic_wait(\n-                    &LOCKED as *const AtomicI32 as *mut i32,\n-                    1,  // expected value\n-                    -1, // timeout\n-                );\n-                debug_assert!(r == 0 || r == 1);\n-            }\n+            // Ok so here's where things get a little depressing. At this point\n+            // in time we need to synchronously acquire a lock, but we're\n+            // contending with some other thread. Typically we'd execute some\n+            // form of `i32.atomic.wait` like so:\n+            //\n+            //     unsafe {\n+            //         let r = core::arch::wasm32::i32_atomic_wait(\n+            //             &LOCKED as *const AtomicI32 as *mut i32,\n+            //             1,  //     expected value\n+            //             -1, //     timeout\n+            //         );\n+            //         debug_assert!(r == 0 || r == 1);\n+            //     }\n+            //\n+            // Unfortunately though in doing so we would cause issues for the\n+            // main thread. The main thread in a web browser *cannot ever\n+            // block*, no exceptions. This means that the main thread can't\n+            // actually execute the `i32.atomic.wait` instruction.\n+            //\n+            // As a result if we want to work within the context of browsers we\n+            // need to figure out some sort of allocation scheme for the main\n+            // thread where when there's contention on the global malloc lock we\n+            // do... something.\n+            //\n+            // Possible ideas include:\n+            //\n+            // 1. Attempt to acquire the global lock. If it fails, fall back to\n+            //    memory allocation via `memory.grow`. Later just ... somehow\n+            //    ... inject this raw page back into the main allocator as it\n+            //    gets sliced up over time. This strategy has the downside of\n+            //    forcing allocation of a page to happen whenever the main\n+            //    thread contents with other threads, which is unfortunate.\n+            //\n+            // 2. Maintain a form of \"two level\" allocator scheme where the main\n+            //    thread has its own allocator. Somehow this allocator would\n+            //    also be balanced with a global allocator, not only to have\n+            //    allocations cross between threads but also to ensure that the\n+            //    two allocators stay \"balanced\" in terms of free'd memory and\n+            //    such. This, however, seems significantly complicated.\n+            //\n+            // Out of a lack of other ideas, the current strategy implemented\n+            // here is to simply spin. Typical spin loop algorithms have some\n+            // form of \"hint\" here to the CPU that it's what we're doing to\n+            // ensure that the CPU doesn't get too hot, but wasm doesn't have\n+            // such an instruction.\n+            //\n+            // To be clear, spinning here is not a great solution.\n+            // Another thread with the lock may take quite a long time to wake\n+            // up. For example it could be in `memory.grow` or it could be\n+            // evicted from the CPU for a timeslice like 10ms. For these periods\n+            // of time our thread will \"helpfully\" sit here and eat CPU time\n+            // until it itself is evicted or the lock holder finishes. This\n+            // means we're just burning and wasting CPU time to no one's\n+            // benefit.\n+            //\n+            // Spinning does have the nice properties, though, of being\n+            // semantically correct, being fair to all threads for memory\n+            // allocation, and being simple enough to implement.\n+            //\n+            // This will surely (hopefully) be replaced in the future with a\n+            // real memory allocator that can handle the restriction of the main\n+            // thread.\n+            //\n+            //\n+            // FIXME: We can also possibly add an optimization here to detect\n+            // when a thread is the main thread or not and block on all\n+            // non-main-thread threads. Currently, however, we have no way\n+            // of knowing which wasm thread is on the browser main thread, but\n+            // if we could figure out we could at least somewhat mitigate the\n+            // cost of this spinning.\n         }\n     }\n \n     impl Drop for DropLock {\n         fn drop(&mut self) {\n             let r = LOCKED.swap(0, SeqCst);\n             debug_assert_eq!(r, 1);\n-            unsafe {\n-                wasm32::atomic_notify(\n-                    &LOCKED as *const AtomicI32 as *mut i32,\n-                    1, // only one thread\n-                );\n-            }\n+\n+            // Note that due to the above logic we don't actually need to wake\n+            // anyone up, but if we did it'd likely look something like this:\n+            //\n+            //     unsafe {\n+            //         core::arch::wasm32::atomic_notify(\n+            //             &LOCKED as *const AtomicI32 as *mut i32,\n+            //             1, //     only one thread\n+            //         );\n+            //     }\n         }\n     }\n }"}]}