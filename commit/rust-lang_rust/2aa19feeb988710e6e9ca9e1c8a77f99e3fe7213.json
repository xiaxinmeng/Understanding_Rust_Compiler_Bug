{"sha": "2aa19feeb988710e6e9ca9e1c8a77f99e3fe7213", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhYTE5ZmVlYjk4ODcxMGU2ZTljYTllMWM4YTc3Zjk5ZTNmZTcyMTM=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-03-08T03:50:43Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-03-08T04:30:43Z"}, "message": "Add with_lock, with_read_lock and with_write_lock", "tree": {"sha": "7c56683d8fc15dfc36f9feec67a89690efc50b01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c56683d8fc15dfc36f9feec67a89690efc50b01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2aa19feeb988710e6e9ca9e1c8a77f99e3fe7213", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2aa19feeb988710e6e9ca9e1c8a77f99e3fe7213", "html_url": "https://github.com/rust-lang/rust/commit/2aa19feeb988710e6e9ca9e1c8a77f99e3fe7213", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2aa19feeb988710e6e9ca9e1c8a77f99e3fe7213/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2789b067da2ac921b86199bde21dd231ace1da39", "url": "https://api.github.com/repos/rust-lang/rust/commits/2789b067da2ac921b86199bde21dd231ace1da39", "html_url": "https://github.com/rust-lang/rust/commit/2789b067da2ac921b86199bde21dd231ace1da39"}], "stats": {"total": 126, "additions": 87, "deletions": 39}, "files": [{"sha": "f17ab264bffbbf4e563d1f89d5ac1ae3dddf4d9b", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 87, "deletions": 39, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/2aa19feeb988710e6e9ca9e1c8a77f99e3fe7213/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa19feeb988710e6e9ca9e1c8a77f99e3fe7213/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=2aa19feeb988710e6e9ca9e1c8a77f99e3fe7213", "patch": "@@ -62,7 +62,7 @@ cfg_if! {\n         pub use std::cell::RefMut as WriteGuard;\n         pub use std::cell::RefMut as LockGuard;\n \n-        pub use std::cell::RefCell as RwLock;\n+        use std::cell::RefCell as InnerRwLock;\n         use std::cell::RefCell as InnerLock;\n \n         use std::cell::Cell;\n@@ -159,13 +159,12 @@ cfg_if! {\n \n         pub use parking_lot::MutexGuard as LockGuard;\n \n-        use parking_lot;\n-\n         pub use std::sync::Arc as Lrc;\n \n         pub use self::Lock as MTLock;\n \n         use parking_lot::Mutex as InnerLock;\n+        use parking_lot::RwLock as InnerRwLock;\n \n         pub type MetadataRef = OwningRef<Box<Erased + Send + Sync>, [u8]>;\n \n@@ -222,42 +221,6 @@ cfg_if! {\n                 self.0.lock().take()\n             }\n         }\n-\n-        #[derive(Debug)]\n-        pub struct RwLock<T>(parking_lot::RwLock<T>);\n-\n-        impl<T> RwLock<T> {\n-            #[inline(always)]\n-            pub fn new(inner: T) -> Self {\n-                RwLock(parking_lot::RwLock::new(inner))\n-            }\n-\n-            #[inline(always)]\n-            pub fn borrow(&self) -> ReadGuard<T> {\n-                if ERROR_CHECKING {\n-                    self.0.try_read().expect(\"lock was already held\")\n-                } else {\n-                    self.0.read()\n-                }\n-            }\n-\n-            #[inline(always)]\n-            pub fn borrow_mut(&self) -> WriteGuard<T> {\n-                if ERROR_CHECKING {\n-                    self.0.try_write().expect(\"lock was already held\")\n-                } else {\n-                    self.0.write()\n-                }\n-            }\n-        }\n-\n-        // FIXME: Probably a bad idea\n-        impl<T: Clone> Clone for RwLock<T> {\n-            #[inline]\n-            fn clone(&self) -> Self {\n-                RwLock::new(self.borrow().clone())\n-            }\n-        }\n     }\n }\n \n@@ -383,6 +346,11 @@ impl<T> Lock<T> {\n         self.0.borrow_mut()\n     }\n \n+    #[inline(always)]\n+    pub fn with_lock<F: FnOnce(&mut T) -> R, R>(&self, f: F) -> R {\n+        f(&mut *self.lock())\n+    }\n+\n     #[inline(always)]\n     pub fn borrow(&self) -> LockGuard<T> {\n         self.lock()\n@@ -401,3 +369,83 @@ impl<T: Clone> Clone for Lock<T> {\n         Lock::new(self.borrow().clone())\n     }\n }\n+\n+#[derive(Debug)]\n+pub struct RwLock<T>(InnerRwLock<T>);\n+\n+impl<T> RwLock<T> {\n+    #[inline(always)]\n+    pub fn new(inner: T) -> Self {\n+        RwLock(InnerRwLock::new(inner))\n+    }\n+\n+    #[inline(always)]\n+    pub fn into_inner(self) -> T {\n+        self.0.into_inner()\n+    }\n+\n+    #[inline(always)]\n+    pub fn get_mut(&mut self) -> &mut T {\n+        self.0.get_mut()\n+    }\n+\n+    #[cfg(not(parallel_queries))]\n+    #[inline(always)]\n+    pub fn read(&self) -> ReadGuard<T> {\n+        self.0.borrow()\n+    }\n+\n+    #[cfg(parallel_queries)]\n+    #[inline(always)]\n+    pub fn read(&self) -> ReadGuard<T> {\n+        if ERROR_CHECKING {\n+            self.0.try_read().expect(\"lock was already held\")\n+        } else {\n+            self.0.read()\n+        }\n+    }\n+\n+    #[inline(always)]\n+    pub fn with_read_lock<F: FnOnce(&T) -> R, R>(&self, f: F) -> R {\n+        f(&*self.read())\n+    }\n+\n+    #[cfg(not(parallel_queries))]\n+    #[inline(always)]\n+    pub fn write(&self) -> WriteGuard<T> {\n+        self.0.borrow_mut()\n+    }\n+\n+    #[cfg(parallel_queries)]\n+    #[inline(always)]\n+    pub fn write(&self) -> WriteGuard<T> {\n+        if ERROR_CHECKING {\n+            self.0.try_write().expect(\"lock was already held\")\n+        } else {\n+            self.0.write()\n+        }\n+    }\n+\n+    #[inline(always)]\n+    pub fn with_write_lock<F: FnOnce(&mut T) -> R, R>(&self, f: F) -> R {\n+        f(&mut *self.write())\n+    }\n+\n+    #[inline(always)]\n+    pub fn borrow(&self) -> ReadGuard<T> {\n+        self.read()\n+    }\n+\n+    #[inline(always)]\n+    pub fn borrow_mut(&self) -> WriteGuard<T> {\n+        self.write()\n+    }\n+}\n+\n+// FIXME: Probably a bad idea\n+impl<T: Clone> Clone for RwLock<T> {\n+    #[inline]\n+    fn clone(&self) -> Self {\n+        RwLock::new(self.borrow().clone())\n+    }\n+}"}]}