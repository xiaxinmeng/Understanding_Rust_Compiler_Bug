{"sha": "e98286b5944c27cde4a5a268ff4ca926b40b8e76", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5ODI4NmI1OTQ0YzI3Y2RlNGE1YTI2OGZmNGNhOTI2YjQwYjhlNzY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-23T19:57:34Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-23T19:57:34Z"}, "message": "Allow import directives in any block\n\nCloses #49", "tree": {"sha": "0c1f23fa08465a7048a87ff82336b101c4133f6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c1f23fa08465a7048a87ff82336b101c4133f6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e98286b5944c27cde4a5a268ff4ca926b40b8e76", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e98286b5944c27cde4a5a268ff4ca926b40b8e76", "html_url": "https://github.com/rust-lang/rust/commit/e98286b5944c27cde4a5a268ff4ca926b40b8e76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e98286b5944c27cde4a5a268ff4ca926b40b8e76/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03f6060e802e1acd8efe85b07bc98a97bf5caa7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/03f6060e802e1acd8efe85b07bc98a97bf5caa7d", "html_url": "https://github.com/rust-lang/rust/commit/03f6060e802e1acd8efe85b07bc98a97bf5caa7d"}], "stats": {"total": 195, "additions": 113, "deletions": 82}, "files": [{"sha": "955510864ea9e4a493588a689f322ad5091b04d8", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e98286b5944c27cde4a5a268ff4ca926b40b8e76/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98286b5944c27cde4a5a268ff4ca926b40b8e76/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=e98286b5944c27cde4a5a268ff4ca926b40b8e76", "patch": "@@ -70,7 +70,8 @@ fn fold_block(cfg: ast::crate_cfg, b: ast::blk_, fld: fold::ast_fold) ->\n    ast::blk_ {\n     let filter = bind filter_stmt(cfg, _);\n     let filtered_stmts = vec::filter_map(filter, b.stmts);\n-    ret {stmts: vec::map(fld.fold_stmt, filtered_stmts),\n+    ret {view_items: b.view_items,\n+         stmts: vec::map(fld.fold_stmt, filtered_stmts),\n          expr: option::map(fld.fold_expr, b.expr),\n          id: b.id,\n          rules: b.rules};"}, {"sha": "d704045c990eacadbe1ef18039194e4637294141", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e98286b5944c27cde4a5a268ff4ca926b40b8e76/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98286b5944c27cde4a5a268ff4ca926b40b8e76/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=e98286b5944c27cde4a5a268ff4ca926b40b8e76", "patch": "@@ -348,6 +348,7 @@ fn mk_test_wrapper(cx: test_ctxt,\n     };\n \n     let wrapper_body: ast::blk = nospan({\n+        view_items: [],\n         stmts: [@call_stmt],\n         expr: option::none,\n         id: cx.next_node_id(),"}, {"sha": "d5c70b35cef69536a2a1a8be4c7a8a5464e21d1b", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 88, "deletions": 72, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/e98286b5944c27cde4a5a268ff4ca926b40b8e76/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98286b5944c27cde4a5a268ff4ca926b40b8e76/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=e98286b5944c27cde4a5a268ff4ca926b40b8e76", "patch": "@@ -37,7 +37,6 @@ tag scope {\n     scope_fn(ast::fn_decl, ast::proto, [ast::ty_param]);\n     scope_native_item(@ast::native_item);\n     scope_loop(@ast::local); // there's only 1 decl per loop.\n-\n     scope_block(ast::blk, @mutable uint, @mutable uint);\n     scope_arm(ast::arm);\n }\n@@ -105,6 +104,7 @@ type env =\n      ast_map: ast_map::map,\n      imports: hashmap<ast::node_id, import_state>,\n      mod_map: hashmap<ast::node_id, @indexed_mod>,\n+     block_map: hashmap<ast::node_id, [glob_imp_def]>,\n      ext_map: hashmap<def_id, [ident]>,\n      ext_cache: ext_hash,\n      used_imports: {mutable track: bool,\n@@ -124,11 +124,12 @@ fn resolve_crate(sess: session, amap: ast_map::map, crate: @ast::crate) ->\n    {def_map: def_map, ext_map: ext_map} {\n     let e =\n         @{cstore: sess.get_cstore(),\n-          def_map: new_int_hash::<def>(),\n+          def_map: new_int_hash(),\n           ast_map: amap,\n-          imports: new_int_hash::<import_state>(),\n-          mod_map: new_int_hash::<@indexed_mod>(),\n-          ext_map: new_def_hash::<[ident]>(),\n+          imports: new_int_hash(),\n+          mod_map: new_int_hash(),\n+          block_map: new_int_hash(),\n+          ext_map: new_def_hash(),\n           ext_cache: new_ext_hash(),\n           used_imports: {mutable track: false, mutable data:  []},\n           mutable reported: [],\n@@ -149,14 +150,14 @@ fn resolve_crate(sess: session, amap: ast_map::map, crate: @ast::crate) ->\n // resolve through them.\n fn map_crate(e: @env, c: @ast::crate) {\n     // First, find all the modules, and index the names that they contain\n-\n     let v_map_mod =\n         @{visit_view_item: bind index_vi(e, _, _, _),\n-          visit_item: bind index_i(e, _, _, _)\n-             with *visit::default_visitor::<scopes>()};\n+          visit_item: bind index_i(e, _, _, _),\n+          visit_block: visit_block_with_scope\n+          with *visit::default_visitor::<scopes>()};\n     visit::visit_crate(*c, cons(scope_crate, @nil), visit::mk_vt(v_map_mod));\n-    // Register the top-level mod\n \n+    // Register the top-level mod\n     e.mod_map.insert(-1,\n                      @{m: some(c.node.module),\n                        index: index_mod(c.node.module),\n@@ -200,38 +201,36 @@ fn map_crate(e: @env, c: @ast::crate) {\n           _ { }\n         }\n     }\n-    // Next, assemble the links for globbed imports.\n \n+    // Next, assemble the links for globbed imports.\n     let v_link_glob =\n         @{visit_view_item: bind link_glob(e, _, _, _),\n+          visit_block: visit_block_with_scope,\n           visit_item: visit_item_with_scope\n-             with *visit::default_visitor::<scopes>()};\n+          with *visit::default_visitor::<scopes>()};\n     visit::visit_crate(*c, cons(scope_crate, @nil),\n                        visit::mk_vt(v_link_glob));\n     fn link_glob(e: @env, vi: @ast::view_item, sc: scopes, _v: vt<scopes>) {\n-        fn find_mod(e: @env, sc: scopes) -> @indexed_mod {\n-            alt sc {\n-              cons(scope_item(i), tl) {\n-                alt i.node {\n-                  ast::item_mod(_) | ast::item_native_mod(_) {\n-                    ret e.mod_map.get(i.id);\n-                  }\n-                  _ { be find_mod(e, *tl); }\n-                }\n-              }\n-              _ {\n-                ret e.mod_map.get(-1); //top-level\n-\n-              }\n-            }\n-        }\n         alt vi.node {\n           //if it really is a glob import, that is\n           ast::view_item_import_glob(path, _) {\n             let imp = follow_import(*e, sc, path, vi.span);\n             if option::is_some(imp) {\n-                find_mod(e, sc).glob_imports +=\n-                    [{def: option::get(imp), item: vi}];\n+                let glob = {def: option::get(imp), item: vi};;\n+                alt sc {\n+                  cons(scope_item(i), _) {\n+                    e.mod_map.get(i.id).glob_imports += [glob];\n+                  }\n+                  cons(scope_block(b, _, _), _) {\n+                    let globs = alt e.block_map.find(b.node.id) {\n+                      some(globs) { globs + [glob] } none. { [glob] }\n+                    };\n+                    e.block_map.insert(b.node.id, globs);\n+                  }\n+                  nil. {\n+                    e.mod_map.get(-1).glob_imports += [glob];\n+                  }\n+                }\n             }\n           }\n           _ { }\n@@ -370,6 +369,7 @@ fn visit_fn_with_scope(e: @env, f: ast::_fn, tp: [ast::ty_param], sp: span,\n fn visit_block_with_scope(b: ast::blk, sc: scopes, v: vt<scopes>) {\n     let pos = @mutable 0u, loc = @mutable 0u;\n     let block_sc = cons(scope_block(b, pos, loc), @sc);\n+    for vi in b.node.view_items { v.visit_view_item(vi, block_sc, v); }\n     for stmt in b.node.stmts {\n         v.visit_stmt(stmt, block_sc, v);;\n         *pos += 1u;;\n@@ -426,9 +426,8 @@ fn follow_import(e: env, sc: scopes, path: [ident], sp: span) ->\n         alt option::get(dcur) {\n           ast::def_mod(_) | ast::def_native_mod(_) { ret dcur; }\n           _ {\n-            e.sess.span_err(sp,\n-                            str::connect(path, \"::\") +\n-                                \" does not name a module.\");\n+            e.sess.span_err(sp, str::connect(path, \"::\") +\n+                            \" does not name a module.\");\n             ret none;\n           }\n         }\n@@ -678,7 +677,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n             }\n           }\n           scope_block(b, pos, loc) {\n-            ret lookup_in_block(name, b.node, *pos, *loc, ns);\n+            ret lookup_in_block(e, name, sp, b.node, *pos, *loc, ns);\n           }\n           scope_arm(a) {\n             if ns == ns_value {\n@@ -793,8 +792,8 @@ fn lookup_in_obj(name: ident, ob: ast::_obj, ty_params: [ast::ty_param],\n     }\n }\n \n-fn lookup_in_block(name: ident, b: ast::blk_, pos: uint, loc_pos: uint,\n-                   ns: namespace) -> option::t<def> {\n+fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n+                   loc_pos: uint, ns: namespace) -> option::t<def> {\n     let i = vec::len(b.stmts);\n     while i > 0u {\n         i -= 1u;\n@@ -849,7 +848,30 @@ fn lookup_in_block(name: ident, b: ast::blk_, pos: uint, loc_pos: uint,\n           _ { }\n         }\n     }\n-    ret none::<def>;\n+    for vi in b.view_items {\n+        alt vi.node {\n+          ast::view_item_import(ident, _, id) {\n+            if name == ident { ret lookup_import(e, local_def(id), ns); }\n+          }\n+          ast::view_item_import_from(mod_path, idents, id) {\n+            for ident in idents {\n+                if name == ident.node.name {\n+                    ret lookup_import(e, local_def(ident.node.id), ns);\n+                }\n+            }\n+          }\n+          ast::view_item_import_glob(_, _) {\n+            alt e.block_map.find(b.id) {\n+              some(globs) {\n+                let found = lookup_in_globs(e, globs, sp, name, ns, inside);\n+                if found != none { ret found; }\n+              }\n+              _ {}\n+            }\n+          }\n+        }\n+    }\n+    ret none;\n }\n \n fn found_def_item(i: @ast::item, ns: namespace) -> option::t<def> {\n@@ -991,57 +1013,51 @@ fn lookup_in_local_mod(e: env, node_id: node_id, sp: span, id: ident,\n         }\n       }\n     }\n-\n     // not local or explicitly imported; try globs:\n     ret lookup_glob_in_mod(e, info, sp, id, ns, outside);\n }\n \n-fn lookup_glob_in_mod(e: env, info: @indexed_mod, sp: span, id: ident,\n-                      wanted_ns: namespace, dr: dir) -> option::t<def> {\n-    fn per_ns(e: env, info: @indexed_mod, sp: span, id: ident, ns: namespace,\n-              dr: dir) -> option::t<def> {\n-\n-        fn lookup_in_mod_(e: env, def: glob_imp_def, sp: span, name: ident,\n-                          ns: namespace, dr: dir) -> option::t<glob_imp_def> {\n-            alt lookup_in_mod(e, def.def, sp, name, ns, dr) {\n-              option::some(d) { option::some({def: d, item: def.item}) }\n-              option::none. { option::none }\n-            }\n+fn lookup_in_globs(e: env, globs: [glob_imp_def], sp: span, id: ident,\n+                   ns: namespace, dr: dir) -> option::t<def> {\n+    fn lookup_in_mod_(e: env, def: glob_imp_def, sp: span, name: ident,\n+                      ns: namespace, dr: dir) -> option::t<glob_imp_def> {\n+        alt lookup_in_mod(e, def.def, sp, name, ns, dr) {\n+          option::some(d) { option::some({def: d, item: def.item}) }\n+          option::none. { option::none }\n         }\n-\n-        let matches =\n-            vec::filter_map(bind lookup_in_mod_(e, _, sp, id, ns, dr),\n-                            { info.glob_imports });\n-        if vec::len(matches) == 0u {\n-            ret none;\n-        } else if vec::len(matches) == 1u {\n-            ret some(matches[0].def);\n-        } else {\n-            for match: glob_imp_def in matches {\n-                let sp = match.item.span;\n-                e.sess.span_note(sp, #fmt[\"'%s' is imported here\", id]);\n-            }\n-            e.sess.span_fatal(sp,\n-                              \"'\" + id + \"' is glob-imported from\" +\n-                                  \" multiple different modules.\");\n+    }\n+    let matches =\n+        vec::filter_map(bind lookup_in_mod_(e, _, sp, id, ns, dr),\n+                        { globs });\n+    if vec::len(matches) == 0u {\n+        ret none;\n+    } else if vec::len(matches) == 1u {\n+        ret some(matches[0].def);\n+    } else {\n+        for match: glob_imp_def in matches {\n+            let sp = match.item.span;\n+            e.sess.span_note(sp, #fmt[\"'%s' is imported here\", id]);\n         }\n+        e.sess.span_fatal(sp, \"'\" + id + \"' is glob-imported from\" +\n+                          \" multiple different modules.\");\n     }\n+}\n+\n+fn lookup_glob_in_mod(e: env, info: @indexed_mod, sp: span, id: ident,\n+                      wanted_ns: namespace, dr: dir) -> option::t<def> {\n     // since we don't know what names we have in advance,\n     // absence takes the place of todo()\n-\n     if !info.glob_imported_names.contains_key(id) {\n         info.glob_imported_names.insert(id, resolving(sp));\n-        let val = per_ns(e, info, sp, id, ns_value, dr);\n-        let typ = per_ns(e, info, sp, id, ns_type, dr);\n-        let md = per_ns(e, info, sp, id, ns_module, dr);\n+        let val = lookup_in_globs(e, info.glob_imports, sp, id, ns_value, dr);\n+        let typ = lookup_in_globs(e, info.glob_imports, sp, id, ns_type, dr);\n+        let md = lookup_in_globs(e, info.glob_imports, sp, id, ns_module, dr);\n         info.glob_imported_names.insert(id, resolved(val, typ, md, id, sp));\n     }\n     alt info.glob_imported_names.get(id) {\n       todo(_, _, _, _, _) { e.sess.bug(\"Shouldn't've put a todo in.\"); }\n-      resolving(sp) {\n-        ret none::<def>; //circularity is okay in import globs\n-\n-      }\n+      //circularity is okay in import globs\n+      resolving(sp) { ret none::<def>; }\n       resolved(val, typ, md, _, _) {\n         ret alt wanted_ns {\n               ns_value. { val }"}, {"sha": "ecba4efceca96ccf4f795efbeede0f393cc229ca", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e98286b5944c27cde4a5a268ff4ca926b40b8e76/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98286b5944c27cde4a5a268ff4ca926b40b8e76/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=e98286b5944c27cde4a5a268ff4ca926b40b8e76", "patch": "@@ -76,9 +76,8 @@ tag meta_item_ {\n \n type blk = spanned<blk_>;\n \n-type blk_ =\n-    {stmts: [@stmt], expr: option::t<@expr>, id: node_id,\n-     rules: blk_check_mode};\n+type blk_ = {view_items: [@view_item], stmts: [@stmt], expr: option::t<@expr>,\n+             id: node_id, rules: blk_check_mode};\n \n type pat = {id: node_id, node: pat_, span: span};\n "}, {"sha": "2b574ae1cbe42989542cd5e980f6a5d06db18c3c", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e98286b5944c27cde4a5a268ff4ca926b40b8e76/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98286b5944c27cde4a5a268ff4ca926b40b8e76/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=e98286b5944c27cde4a5a268ff4ca926b40b8e76", "patch": "@@ -199,7 +199,7 @@ fn block_from_expr(e: @expr) -> blk {\n \n fn default_block(stmts1: [@stmt], expr1: option::t<@expr>, id1: node_id) ->\n    blk_ {\n-    ret {stmts: stmts1, expr: expr1, id: id1, rules: default_blk};\n+    {view_items: [], stmts: stmts1, expr: expr1, id: id1, rules: default_blk}\n }\n \n fn obj_field_from_anon_obj_field(f: anon_obj_field) -> obj_field {"}, {"sha": "f9c23b4de2505eb96d58aa77ca4eb9f86b5b544b", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e98286b5944c27cde4a5a268ff4ca926b40b8e76/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98286b5944c27cde4a5a268ff4ca926b40b8e76/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=e98286b5944c27cde4a5a268ff4ca926b40b8e76", "patch": "@@ -247,7 +247,8 @@ fn noop_fold_method(m: method_, fld: ast_fold) -> method_ {\n \n \n fn noop_fold_block(b: blk_, fld: ast_fold) -> blk_ {\n-    ret {stmts: vec::map(fld.fold_stmt, b.stmts),\n+    ret {view_items: vec::map(fld.fold_view_item, b.view_items),\n+         stmts: vec::map(fld.fold_stmt, b.stmts),\n          expr: option::map(fld.fold_expr, b.expr),\n          id: b.id,\n          rules: b.rules};"}, {"sha": "df76903302862d28ec0d6002847c34bffe17a933", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e98286b5944c27cde4a5a268ff4ca926b40b8e76/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98286b5944c27cde4a5a268ff4ca926b40b8e76/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=e98286b5944c27cde4a5a268ff4ca926b40b8e76", "patch": "@@ -1697,8 +1697,8 @@ fn parse_block_no_value(p: parser) -> ast::blk {\n // necessary, and this should take a qualifier.\n // some blocks start with \"#{\"...\n fn parse_block_tail(p: parser, lo: uint, s: ast::blk_check_mode) -> ast::blk {\n-    let stmts: [@ast::stmt] = [];\n-    let expr: option::t<@ast::expr> = none;\n+    let view_items = [], stmts = [], expr = none;\n+    while is_word(p, \"import\") { view_items += [parse_view_item(p)]; }\n     while p.peek() != token::RBRACE {\n         alt p.peek() {\n           token::SEMI. {\n@@ -1736,7 +1736,8 @@ fn parse_block_tail(p: parser, lo: uint, s: ast::blk_check_mode) -> ast::blk {\n     }\n     let hi = p.get_hi_pos();\n     p.bump();\n-    let bloc = {stmts: stmts, expr: expr, id: p.get_id(), rules: s};\n+    let bloc = {view_items: view_items, stmts: stmts, expr: expr,\n+                id: p.get_id(), rules: s};\n     ret spanned(lo, hi, bloc);\n }\n "}, {"sha": "5273d16e544caa7f4516c69ef5fca44ed852c096", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e98286b5944c27cde4a5a268ff4ca926b40b8e76/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98286b5944c27cde4a5a268ff4ca926b40b8e76/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=e98286b5944c27cde4a5a268ff4ca926b40b8e76", "patch": "@@ -200,7 +200,8 @@ fn visit_fn<E>(f: _fn, _tp: [ty_param], _sp: span, _i: fn_ident, _id: node_id,\n }\n \n fn visit_block<E>(b: ast::blk, e: E, v: vt<E>) {\n-    for s: @stmt in b.node.stmts { v.visit_stmt(s, e, v); }\n+    for vi in b.node.view_items { v.visit_view_item(vi, e, v); }\n+    for s in b.node.stmts { v.visit_stmt(s, e, v); }\n     visit_expr_opt(b.node.expr, e, v);\n }\n "}, {"sha": "fae30afa4ad8da1444d930b63e1af5df15b9ac8b", "filename": "src/test/run-pass/import-in-block.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e98286b5944c27cde4a5a268ff4ca926b40b8e76/src%2Ftest%2Frun-pass%2Fimport-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98286b5944c27cde4a5a268ff4ca926b40b8e76/src%2Ftest%2Frun-pass%2Fimport-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-in-block.rs?ref=e98286b5944c27cde4a5a268ff4ca926b40b8e76", "patch": "@@ -0,0 +1,11 @@\n+use std;\n+\n+fn main() {\n+    import std::vec;\n+    import vec::to_mut;\n+    log vec::len(to_mut([1, 2]));\n+    {\n+        import vec::*;\n+        log len([2]);\n+    }\n+}"}]}