{"sha": "8c2577c74731688ccc2d59ed92e8d334735c673c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjMjU3N2M3NDczMTY4OGNjYzJkNTllZDkyZThkMzM0NzM1YzY3M2M=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-07-20T13:33:57Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-07-20T13:33:57Z"}, "message": "Don't disable stdsimd anymore\n\nThis doesn't enable simd support. Actually using the functions will\nresult in a compilation error.", "tree": {"sha": "18594426506fd5ca3a9649f8e767245e91b13beb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18594426506fd5ca3a9649f8e767245e91b13beb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c2577c74731688ccc2d59ed92e8d334735c673c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c2577c74731688ccc2d59ed92e8d334735c673c", "html_url": "https://github.com/rust-lang/rust/commit/8c2577c74731688ccc2d59ed92e8d334735c673c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c2577c74731688ccc2d59ed92e8d334735c673c/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94effb972fa80c89a7d3cf2e209b84b2f301ce3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/94effb972fa80c89a7d3cf2e209b84b2f301ce3a", "html_url": "https://github.com/rust-lang/rust/commit/94effb972fa80c89a7d3cf2e209b84b2f301ce3a"}], "stats": {"total": 303, "additions": 230, "deletions": 73}, "files": [{"sha": "7fb003d199e0728fdd8501bee72574dd595b2354", "filename": "patches/0001-Disable-stdsimd.patch", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/94effb972fa80c89a7d3cf2e209b84b2f301ce3a/patches%2F0001-Disable-stdsimd.patch", "raw_url": "https://github.com/rust-lang/rust/raw/94effb972fa80c89a7d3cf2e209b84b2f301ce3a/patches%2F0001-Disable-stdsimd.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0001-Disable-stdsimd.patch?ref=94effb972fa80c89a7d3cf2e209b84b2f301ce3a", "patch": "@@ -1,67 +0,0 @@\n-From 95157a64120faffebc2cc67baf65f45f992e167e Mon Sep 17 00:00:00 2001\n-From: bjorn3 <bjorn3@users.noreply.github.com>\n-Date: Sun, 24 Feb 2019 11:27:11 +0100\n-Subject: [PATCH] Disable stdsimd\n-\n----\n- src/libcore/lib.rs | 2 ++\n- src/libstd/lib.rs  | 6 ++----\n- 2 files changed, 4 insertions(+), 4 deletions(-)\n-\n-diff --git a/src/libcore/lib.rs b/src/libcore/lib.rs\n-index f2165c6..cdb42c1 100644\n---- a/src/libcore/lib.rs\n-+++ b/src/libcore/lib.rs\n-@@ -222,6 +222,7 @@ pub mod alloc;\n- mod tuple;\n- mod unit;\n- \n-+/*\n- // Pull in the `core_arch` crate directly into libcore. The contents of\n- // `core_arch` are in a different repository: rust-lang/stdarch.\n- //\n-@@ -235,3 +236,4 @@ mod core_arch;\n- \n- #[stable(feature = \"simd_arch\", since = \"1.27.0\")]\n- pub use core_arch::arch;\n-+*/\n-diff --git a/src/libstd/lib.rs b/src/libstd/lib.rs\n-index 6dd3a6c..c7401e2 100644\n---- a/src/libstd/lib.rs\n-+++ b/src/libstd/lib.rs\n-@@ -291,7 +291,6 @@\n- #![feature(slice_patterns)]\n- #![feature(staged_api)]\n- #![feature(std_internals)]\n--#![feature(stdsimd)]\n- #![feature(stmt_expr_attributes)]\n- #![feature(str_internals)]\n- #![feature(thread_local)]\n-@@ -357,9 +356,6 @@ pub mod prelude;\n- // Public module declarations and re-exports\n- #[stable(feature = \"rust1\", since = \"1.0.0\")]\n- pub use core::any;\n--#[stable(feature = \"simd_arch\", since = \"1.27.0\")]\n--#[doc(no_inline)]\n--pub use core::arch;\n- #[stable(feature = \"rust1\", since = \"1.0.0\")]\n- pub use core::cell;\n- #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-@@ -489,6 +485,7 @@ mod memchr;\n- // compiler\n- pub mod rt;\n- \n-+/*\n- // Pull in the `std_detect` crate directly into libstd. The contents of\n- // `std_detect` are in a different repository: rust-lang/stdarch.\n- //\n-@@ -505,6 +502,7 @@ mod std_detect;\n- #[unstable(feature = \"stdsimd\", issue = \"48556\")]\n- #[cfg(not(test))]\n- pub use std_detect::detect;\n-+*/\n- \n- // Include a number of private modules that exist solely to provide\n- // the rustdoc documentation for primitive types. Using `include!`\n--- \n-2.17.2 (Apple Git-113)"}, {"sha": "0566170bba1d8840658fcfa3aaa1b15b1de8ff39", "filename": "src/base.rs", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8c2577c74731688ccc2d59ed92e8d334735c673c/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2577c74731688ccc2d59ed92e8d334735c673c/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=8c2577c74731688ccc2d59ed92e8d334735c673c", "patch": "@@ -656,7 +656,58 @@ fn trans_stmt<'a, 'tcx: 'a>(\n         | StatementKind::Retag { .. }\n         | StatementKind::AscribeUserType(..) => {}\n \n-        StatementKind::InlineAsm { .. } => unimpl!(\"Inline assembly is not supported\"),\n+        StatementKind::InlineAsm(asm) => {\n+            use syntax::ast::Name;\n+            let InlineAsm { asm, outputs: _, inputs: _ } = &**asm;\n+            let rustc::hir::InlineAsm {\n+                asm: asm_code, // Name\n+                outputs, // Vec<Name>\n+                inputs, // Vec<Name>\n+                clobbers, // Vec<Name>\n+                volatile, // bool\n+                alignstack, // bool\n+                dialect, // syntax::ast::AsmDialect\n+                asm_str_style: _,\n+                ctxt: _,\n+            } = asm;\n+            match &*asm_code.as_str() {\n+                \"cpuid\" | \"cpuid\\n\" => {\n+                    assert_eq!(inputs, &[Name::intern(\"{eax}\"), Name::intern(\"{ecx}\")]);\n+\n+                    assert_eq!(outputs.len(), 4);\n+                    for (i, c) in (&[\"={eax}\", \"={ebx}\", \"={ecx}\", \"={edx}\"]).iter().enumerate() {\n+                        assert_eq!(&outputs[i].constraint.as_str(), c);\n+                        assert!(!outputs[i].is_rw);\n+                        assert!(!outputs[i].is_indirect);\n+                    }\n+\n+                    assert_eq!(clobbers, &[Name::intern(\"rbx\")]);\n+\n+                    assert!(!volatile);\n+                    assert!(!alignstack);\n+\n+                    crate::trap::trap_unimplemented(fx, \"__cpuid_count arch intrinsic is not supported\");\n+                }\n+                \"xgetbv\" => {\n+                    assert_eq!(inputs, &[Name::intern(\"{ecx}\")]);\n+\n+                    assert_eq!(outputs.len(), 2);\n+                    for (i, c) in (&[\"={eax}\", \"={edx}\"]).iter().enumerate() {\n+                        assert_eq!(&outputs[i].constraint.as_str(), c);\n+                        assert!(!outputs[i].is_rw);\n+                        assert!(!outputs[i].is_indirect);\n+                    }\n+\n+                    assert_eq!(clobbers, &[]);\n+\n+                    assert!(!volatile);\n+                    assert!(!alignstack);\n+\n+                    crate::trap::trap_unimplemented(fx, \"_xgetbv arch intrinsic is not supported\");\n+                }\n+                _ => unimpl!(\"Inline assembly is not supported\"),\n+            }\n+        }\n     }\n }\n "}, {"sha": "c6f77954a869f2cc613d80d92c95eb495595f785", "filename": "src/lib.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8c2577c74731688ccc2d59ed92e8d334735c673c/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2577c74731688ccc2d59ed92e8d334735c673c/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=8c2577c74731688ccc2d59ed92e8d334735c673c", "patch": "@@ -43,6 +43,7 @@ mod linkage;\n mod main_shim;\n mod metadata;\n mod pretty_clif;\n+mod target_features_whitelist;\n mod trap;\n mod unimpl;\n mod unsize;\n@@ -164,7 +165,21 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         rustc_codegen_utils::symbol_names::provide(providers);\n         rustc_codegen_ssa::back::symbol_export::provide(providers);\n \n-        providers.target_features_whitelist = |tcx, _cnum| tcx.arena.alloc(FxHashMap::default());\n+        providers.target_features_whitelist = |tcx, cnum| {\n+            assert_eq!(cnum, LOCAL_CRATE);\n+            if tcx.sess.opts.actually_rustdoc {\n+                // rustdoc needs to be able to document functions that use all the features, so\n+                // whitelist them all\n+                 tcx.arena.alloc(target_features_whitelist::all_known_features()\n+                    .map(|(a, b)| (a.to_string(), b))\n+                    .collect())\n+            } else {\n+                tcx.arena.alloc(target_features_whitelist::target_feature_whitelist(tcx.sess)\n+                    .iter()\n+                    .map(|&(a, b)| (a.to_string(), b))\n+                    .collect())\n+            }\n+        };\n     }\n     fn provide_extern(&self, providers: &mut Providers) {\n         rustc_codegen_ssa::back::symbol_export::provide_extern(providers);"}, {"sha": "8049b615be227ba0d90bf46b1705cbfef0a3b9a5", "filename": "src/target_features_whitelist.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/8c2577c74731688ccc2d59ed92e8d334735c673c/src%2Ftarget_features_whitelist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2577c74731688ccc2d59ed92e8d334735c673c/src%2Ftarget_features_whitelist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftarget_features_whitelist.rs?ref=8c2577c74731688ccc2d59ed92e8d334735c673c", "patch": "@@ -0,0 +1,142 @@\n+use syntax::symbol::{sym, Symbol};\n+\n+use rustc::session::Session;\n+\n+// Copied from https://github.com/rust-lang/rust/blob/f69b07144a151f46aaee1b6230ba4160e9394562/src/librustc_codegen_llvm/llvm_util.rs#L93-L264\n+\n+// WARNING: the features after applying `to_llvm_feature` must be known\n+// to LLVM or the feature detection code will walk past the end of the feature\n+// array, leading to crashes.\n+\n+const ARM_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"aclass\", Some(sym::arm_target_feature)),\n+    (\"mclass\", Some(sym::arm_target_feature)),\n+    (\"rclass\", Some(sym::arm_target_feature)),\n+    (\"dsp\", Some(sym::arm_target_feature)),\n+    (\"neon\", Some(sym::arm_target_feature)),\n+    (\"v5te\", Some(sym::arm_target_feature)),\n+    (\"v6\", Some(sym::arm_target_feature)),\n+    (\"v6k\", Some(sym::arm_target_feature)),\n+    (\"v6t2\", Some(sym::arm_target_feature)),\n+    (\"v7\", Some(sym::arm_target_feature)),\n+    (\"v8\", Some(sym::arm_target_feature)),\n+    (\"vfp2\", Some(sym::arm_target_feature)),\n+    (\"vfp3\", Some(sym::arm_target_feature)),\n+    (\"vfp4\", Some(sym::arm_target_feature)),\n+];\n+\n+const AARCH64_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"fp\", Some(sym::aarch64_target_feature)),\n+    (\"neon\", Some(sym::aarch64_target_feature)),\n+    (\"sve\", Some(sym::aarch64_target_feature)),\n+    (\"crc\", Some(sym::aarch64_target_feature)),\n+    (\"crypto\", Some(sym::aarch64_target_feature)),\n+    (\"ras\", Some(sym::aarch64_target_feature)),\n+    (\"lse\", Some(sym::aarch64_target_feature)),\n+    (\"rdm\", Some(sym::aarch64_target_feature)),\n+    (\"fp16\", Some(sym::aarch64_target_feature)),\n+    (\"rcpc\", Some(sym::aarch64_target_feature)),\n+    (\"dotprod\", Some(sym::aarch64_target_feature)),\n+    (\"v8.1a\", Some(sym::aarch64_target_feature)),\n+    (\"v8.2a\", Some(sym::aarch64_target_feature)),\n+    (\"v8.3a\", Some(sym::aarch64_target_feature)),\n+];\n+\n+const X86_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"adx\", Some(sym::adx_target_feature)),\n+    (\"aes\", None),\n+    (\"avx\", None),\n+    (\"avx2\", None),\n+    (\"avx512bw\", Some(sym::avx512_target_feature)),\n+    (\"avx512cd\", Some(sym::avx512_target_feature)),\n+    (\"avx512dq\", Some(sym::avx512_target_feature)),\n+    (\"avx512er\", Some(sym::avx512_target_feature)),\n+    (\"avx512f\", Some(sym::avx512_target_feature)),\n+    (\"avx512ifma\", Some(sym::avx512_target_feature)),\n+    (\"avx512pf\", Some(sym::avx512_target_feature)),\n+    (\"avx512vbmi\", Some(sym::avx512_target_feature)),\n+    (\"avx512vl\", Some(sym::avx512_target_feature)),\n+    (\"avx512vpopcntdq\", Some(sym::avx512_target_feature)),\n+    (\"bmi1\", None),\n+    (\"bmi2\", None),\n+    (\"cmpxchg16b\", Some(sym::cmpxchg16b_target_feature)),\n+    (\"f16c\", Some(sym::f16c_target_feature)),\n+    (\"fma\", None),\n+    (\"fxsr\", None),\n+    (\"lzcnt\", None),\n+    (\"mmx\", Some(sym::mmx_target_feature)),\n+    (\"movbe\", Some(sym::movbe_target_feature)),\n+    (\"pclmulqdq\", None),\n+    (\"popcnt\", None),\n+    (\"rdrand\", None),\n+    (\"rdseed\", None),\n+    (\"rtm\", Some(sym::rtm_target_feature)),\n+    (\"sha\", None),\n+    (\"sse\", None),\n+    (\"sse2\", None),\n+    (\"sse3\", None),\n+    (\"sse4.1\", None),\n+    (\"sse4.2\", None),\n+    (\"sse4a\", Some(sym::sse4a_target_feature)),\n+    (\"ssse3\", None),\n+    (\"tbm\", Some(sym::tbm_target_feature)),\n+    (\"xsave\", None),\n+    (\"xsavec\", None),\n+    (\"xsaveopt\", None),\n+    (\"xsaves\", None),\n+];\n+\n+const HEXAGON_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"hvx\", Some(sym::hexagon_target_feature)),\n+    (\"hvx-double\", Some(sym::hexagon_target_feature)),\n+];\n+\n+const POWERPC_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"altivec\", Some(sym::powerpc_target_feature)),\n+    (\"power8-altivec\", Some(sym::powerpc_target_feature)),\n+    (\"power9-altivec\", Some(sym::powerpc_target_feature)),\n+    (\"power8-vector\", Some(sym::powerpc_target_feature)),\n+    (\"power9-vector\", Some(sym::powerpc_target_feature)),\n+    (\"vsx\", Some(sym::powerpc_target_feature)),\n+];\n+\n+const MIPS_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"fp64\", Some(sym::mips_target_feature)),\n+    (\"msa\", Some(sym::mips_target_feature)),\n+];\n+\n+const WASM_WHITELIST: &[(&str, Option<Symbol>)] = &[\n+    (\"simd128\", Some(sym::wasm_target_feature)),\n+    (\"atomics\", Some(sym::wasm_target_feature)),\n+];\n+\n+/// When rustdoc is running, provide a list of all known features so that all their respective\n+/// primitives may be documented.\n+///\n+/// IMPORTANT: If you're adding another whitelist to the above lists, make sure to add it to this\n+/// iterator!\n+pub fn all_known_features() -> impl Iterator<Item=(&'static str, Option<Symbol>)> {\n+    ARM_WHITELIST.iter().cloned()\n+        .chain(AARCH64_WHITELIST.iter().cloned())\n+        .chain(X86_WHITELIST.iter().cloned())\n+        .chain(HEXAGON_WHITELIST.iter().cloned())\n+        .chain(POWERPC_WHITELIST.iter().cloned())\n+        .chain(MIPS_WHITELIST.iter().cloned())\n+        .chain(WASM_WHITELIST.iter().cloned())\n+}\n+\n+pub fn target_feature_whitelist(sess: &Session)\n+    -> &'static [(&'static str, Option<Symbol>)]\n+{\n+    match &*sess.target.target.arch {\n+        \"arm\" => ARM_WHITELIST,\n+        \"aarch64\" => AARCH64_WHITELIST,\n+        \"x86\" | \"x86_64\" => X86_WHITELIST,\n+        \"hexagon\" => HEXAGON_WHITELIST,\n+        \"mips\" | \"mips64\" => MIPS_WHITELIST,\n+        \"powerpc\" | \"powerpc64\" => POWERPC_WHITELIST,\n+        // wasm32 on emscripten does not support these target features\n+        \"wasm32\" if !sess.target.target.options.is_like_emscripten => WASM_WHITELIST,\n+        _ => &[],\n+    }\n+}"}, {"sha": "cbbe5d203bb5d8e269a133b4ad466d506093d2bc", "filename": "src/trap.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8c2577c74731688ccc2d59ed92e8d334735c673c/src%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2577c74731688ccc2d59ed92e8d334735c673c/src%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftrap.rs?ref=8c2577c74731688ccc2d59ed92e8d334735c673c", "patch": "@@ -24,32 +24,48 @@ fn codegen_print(fx: &mut FunctionCx<'_, '_, impl cranelift_module::Backend>, ms\n     fx.bcx.ins().call(puts, &[msg_ptr]);\n }\n \n+/// Use this when `rustc_codegen_llvm` would insert a call to the panic handler.\n+///\n /// Trap code: user0\n pub fn trap_panic(fx: &mut FunctionCx<'_, '_, impl cranelift_module::Backend>, msg: impl AsRef<str>) {\n     codegen_print(fx, msg.as_ref());\n     fx.bcx.ins().trap(TrapCode::User(0));\n }\n \n+/// Use this for example when a function call should never return. This will fill the current block,\n+/// so you can **not** add instructions to it afterwards.\n+///\n /// Trap code: user65535\n pub fn trap_unreachable(fx: &mut FunctionCx<'_, '_, impl cranelift_module::Backend>, msg: impl AsRef<str>) {\n     codegen_print(fx, msg.as_ref());\n     fx.bcx.ins().trap(TrapCode::User(!0));\n }\n \n+/// Use this when something is unimplemented, but `libcore` or `libstd` requires it to codegen.\n+/// Unlike `trap_unreachable` this will not fill the current block, so you **must** add instructions\n+/// to it afterwards.\n+///\n /// Trap code: user65535\n-pub fn trap_unreachable_ret_value<'tcx>(fx: &mut FunctionCx<'_, 'tcx, impl cranelift_module::Backend>, dest_layout: TyLayout<'tcx>, msg: impl AsRef<str>) -> CValue<'tcx> {\n+pub fn trap_unimplemented(fx: &mut FunctionCx<'_, '_, impl cranelift_module::Backend>, msg: impl AsRef<str>) {\n     codegen_print(fx, msg.as_ref());\n     let true_ = fx.bcx.ins().iconst(types::I32, 1);\n     fx.bcx.ins().trapnz(true_, TrapCode::User(!0));\n+}\n+\n+/// Like `trap_unreachable` but returns a fake value of the specified type.\n+///\n+/// Trap code: user65535\n+pub fn trap_unreachable_ret_value<'tcx>(fx: &mut FunctionCx<'_, 'tcx, impl cranelift_module::Backend>, dest_layout: TyLayout<'tcx>, msg: impl AsRef<str>) -> CValue<'tcx> {\n+    trap_unimplemented(fx, msg);\n     let zero = fx.bcx.ins().iconst(fx.pointer_type, 0);\n     CValue::by_ref(zero, dest_layout)\n }\n \n+/// Like `trap_unreachable` but returns a fake place for the specified type.\n+///\n /// Trap code: user65535\n pub fn trap_unreachable_ret_place<'tcx>(fx: &mut FunctionCx<'_, 'tcx, impl cranelift_module::Backend>, dest_layout: TyLayout<'tcx>, msg: impl AsRef<str>) -> CPlace<'tcx> {\n-    codegen_print(fx, msg.as_ref());\n-    let true_ = fx.bcx.ins().iconst(types::I32, 1);\n-    fx.bcx.ins().trapnz(true_, TrapCode::User(!0));\n+    trap_unimplemented(fx, msg);\n     let zero = fx.bcx.ins().iconst(fx.pointer_type, 0);\n     CPlace::for_addr(zero, dest_layout)\n }"}]}