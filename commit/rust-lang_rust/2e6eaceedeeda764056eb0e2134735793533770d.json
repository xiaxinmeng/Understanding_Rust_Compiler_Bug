{"sha": "2e6eaceedeeda764056eb0e2134735793533770d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlNmVhY2VlZGVlZGE3NjQwNTZlYjBlMjEzNDczNTc5MzUzMzc3MGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-13T04:57:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-13T04:57:41Z"}, "message": "Auto merge of #69118 - Dylan-DPC:rollup-7hpm1fj, r=Dylan-DPC\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #67642 (Relax bounds on HashMap/HashSet)\n - #68848 (Hasten macro parsing)\n - #69008 (Properly use parent generics for opaque types)\n - #69048 (Suggestion when encountering assoc types from hrtb)\n - #69049 (Optimize image sizes)\n - #69050 (Micro-optimize the heck out of LEB128 reading and writing.)\n - #69068 (Make the SGX arg cleanup implementation a NOP)\n - #69082 (When expecting `BoxFuture` and using `async {}`, suggest `Box::pin`)\n - #69104 (bootstrap: Configure cmake when building sanitizer runtimes)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "216828e2f51b7a84753ef693b97e09577d12c2bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/216828e2f51b7a84753ef693b97e09577d12c2bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e6eaceedeeda764056eb0e2134735793533770d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e6eaceedeeda764056eb0e2134735793533770d", "html_url": "https://github.com/rust-lang/rust/commit/2e6eaceedeeda764056eb0e2134735793533770d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e6eaceedeeda764056eb0e2134735793533770d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba18875557aabffe386a2534a1aa6118efb6ab88", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba18875557aabffe386a2534a1aa6118efb6ab88", "html_url": "https://github.com/rust-lang/rust/commit/ba18875557aabffe386a2534a1aa6118efb6ab88"}, {"sha": "1ddf2504fdeb26bce320c8198c2e594b22efd71a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ddf2504fdeb26bce320c8198c2e594b22efd71a", "html_url": "https://github.com/rust-lang/rust/commit/1ddf2504fdeb26bce320c8198c2e594b22efd71a"}], "stats": {"total": 837, "additions": 584, "deletions": 253}, "files": [{"sha": "21dcb1d8aa0e1bc2a7908d6a9cbc09209b54fd9e", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -262,7 +262,7 @@ impl Step for Llvm {\n             cfg.define(\"PYTHON_EXECUTABLE\", python);\n         }\n \n-        configure_cmake(builder, target, &mut cfg);\n+        configure_cmake(builder, target, &mut cfg, true);\n \n         // FIXME: we don't actually need to build all LLVM tools and all LLVM\n         //        libraries here, e.g., we just want a few components and a few\n@@ -301,7 +301,12 @@ fn check_llvm_version(builder: &Builder<'_>, llvm_config: &Path) {\n     panic!(\"\\n\\nbad LLVM version: {}, need >=7.0\\n\\n\", version)\n }\n \n-fn configure_cmake(builder: &Builder<'_>, target: Interned<String>, cfg: &mut cmake::Config) {\n+fn configure_cmake(\n+    builder: &Builder<'_>,\n+    target: Interned<String>,\n+    cfg: &mut cmake::Config,\n+    use_compiler_launcher: bool,\n+) {\n     // Do not print installation messages for up-to-date files.\n     // LLVM and LLD builds can produce a lot of those and hit CI limits on log size.\n     cfg.define(\"CMAKE_INSTALL_MESSAGE\", \"LAZY\");\n@@ -372,9 +377,11 @@ fn configure_cmake(builder: &Builder<'_>, target: Interned<String>, cfg: &mut cm\n     } else {\n         // If ccache is configured we inform the build a little differently how\n         // to invoke ccache while also invoking our compilers.\n-        if let Some(ref ccache) = builder.config.ccache {\n-            cfg.define(\"CMAKE_C_COMPILER_LAUNCHER\", ccache)\n-                .define(\"CMAKE_CXX_COMPILER_LAUNCHER\", ccache);\n+        if use_compiler_launcher {\n+            if let Some(ref ccache) = builder.config.ccache {\n+                cfg.define(\"CMAKE_C_COMPILER_LAUNCHER\", ccache)\n+                    .define(\"CMAKE_CXX_COMPILER_LAUNCHER\", ccache);\n+            }\n         }\n         cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(cc))\n             .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(cxx));\n@@ -458,7 +465,7 @@ impl Step for Lld {\n         t!(fs::create_dir_all(&out_dir));\n \n         let mut cfg = cmake::Config::new(builder.src.join(\"src/llvm-project/lld\"));\n-        configure_cmake(builder, target, &mut cfg);\n+        configure_cmake(builder, target, &mut cfg, true);\n \n         // This is an awful, awful hack. Discovered when we migrated to using\n         // clang-cl to compile LLVM/LLD it turns out that LLD, when built out of\n@@ -595,10 +602,7 @@ impl Step for Sanitizers {\n         let _time = util::timeit(&builder);\n \n         let mut cfg = cmake::Config::new(&compiler_rt_dir);\n-        cfg.target(&self.target);\n-        cfg.host(&builder.config.build);\n         cfg.profile(\"Release\");\n-\n         cfg.define(\"CMAKE_C_COMPILER_TARGET\", self.target);\n         cfg.define(\"COMPILER_RT_BUILD_BUILTINS\", \"OFF\");\n         cfg.define(\"COMPILER_RT_BUILD_CRT\", \"OFF\");\n@@ -610,6 +614,12 @@ impl Step for Sanitizers {\n         cfg.define(\"COMPILER_RT_USE_LIBCXX\", \"OFF\");\n         cfg.define(\"LLVM_CONFIG_PATH\", &llvm_config);\n \n+        // On Darwin targets the sanitizer runtimes are build as universal binaries.\n+        // Unfortunately sccache currently lacks support to build them successfully.\n+        // Disable compiler launcher on Darwin targets to avoid potential issues.\n+        let use_compiler_launcher = !self.target.contains(\"apple-darwin\");\n+        configure_cmake(builder, self.target, &mut cfg, use_compiler_launcher);\n+\n         t!(fs::create_dir_all(&out_dir));\n         cfg.out_dir(out_dir);\n "}, {"sha": "99ee7507fa2fb0d121ca340682204ca92a1b781e", "filename": "src/etc/installer/gfx/rust-logo.png", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Fetc%2Finstaller%2Fgfx%2Frust-logo.png", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Fetc%2Finstaller%2Fgfx%2Frust-logo.png", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fgfx%2Frust-logo.png?ref=2e6eaceedeeda764056eb0e2134735793533770d"}, {"sha": "2800f11cc01b1ae43600b4e82df2ceac154050e8", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -727,6 +727,10 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n /// [`Pin<P>`]: ../pin/struct.Pin.html\n /// [`pin module`]: ../../std/pin/index.html\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n+#[rustc_on_unimplemented(\n+    on(_Self = \"std::future::Future\", note = \"consider using `Box::pin`\",),\n+    message = \"`{Self}` cannot be unpinned\"\n+)]\n #[lang = \"unpin\"]\n pub auto trait Unpin {}\n "}, {"sha": "ab2d74b1c8deb809bbbc2a0e4baad96811e601c4", "filename": "src/librustc/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -201,6 +201,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 }\n             }\n         }\n+        if let ty::Dynamic(traits, _) = self_ty.kind {\n+            for t in *traits.skip_binder() {\n+                match t {\n+                    ty::ExistentialPredicate::Trait(trait_ref) => {\n+                        flags.push((sym::_Self, Some(self.tcx.def_path_str(trait_ref.def_id))))\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n \n         if let Ok(Some(command)) =\n             OnUnimplementedDirective::of_item(self.tcx, trait_ref.def_id, def_id)"}, {"sha": "82b73518d09a86d4e84ee6aa5b5f322df38b322d", "filename": "src/librustc/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -701,10 +701,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     })\n                     .collect::<Vec<_>>();\n                 // Add the suggestion for the return type.\n-                suggestions.push((\n-                    ret_ty.span,\n-                    format!(\"Box<{}{}>\", if has_dyn { \"\" } else { \"dyn \" }, snippet),\n-                ));\n+                suggestions.push((ret_ty.span, format!(\"Box<dyn {}>\", trait_obj)));\n                 err.multipart_suggestion(\n                     \"return a boxed trait object instead\",\n                     suggestions,"}, {"sha": "f119c956ced04e078bef2d823b97041276eb4f71", "filename": "src/librustc_expand/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustc_expand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustc_expand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Flib.rs?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -1,3 +1,4 @@\n+#![feature(cow_is_borrowed)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(proc_macro_diagnostic)]"}, {"sha": "5bf7602ea6e8f7a37e98fa372e85391b8de4167e", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 14, "deletions": 34, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -78,20 +78,19 @@ use crate::mbe::{self, TokenTree};\n \n use rustc_ast_pretty::pprust;\n use rustc_parse::parser::{FollowedByType, Parser, PathStyle};\n-use rustc_parse::Directory;\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::{kw, sym, Symbol};\n use syntax::ast::{Ident, Name};\n use syntax::ptr::P;\n use syntax::token::{self, DocComment, Nonterminal, Token};\n-use syntax::tokenstream::TokenStream;\n \n use rustc_errors::{FatalError, PResult};\n use rustc_span::Span;\n use smallvec::{smallvec, SmallVec};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n+use std::borrow::Cow;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::mem;\n use std::ops::{Deref, DerefMut};\n@@ -613,28 +612,9 @@ fn inner_parse_loop<'root, 'tt>(\n     Success(())\n }\n \n-/// Use the given sequence of token trees (`ms`) as a matcher. Match the given token stream `tts`\n-/// against it and return the match.\n-///\n-/// # Parameters\n-///\n-/// - `sess`: The session into which errors are emitted\n-/// - `tts`: The tokenstream we are matching against the pattern `ms`\n-/// - `ms`: A sequence of token trees representing a pattern against which we are matching\n-/// - `directory`: Information about the file locations (needed for the black-box parser)\n-/// - `recurse_into_modules`: Whether or not to recurse into modules (needed for the black-box\n-///   parser)\n-pub(super) fn parse(\n-    sess: &ParseSess,\n-    tts: TokenStream,\n-    ms: &[TokenTree],\n-    directory: Option<Directory<'_>>,\n-    recurse_into_modules: bool,\n-) -> NamedParseResult {\n-    // Create a parser that can be used for the \"black box\" parts.\n-    let mut parser =\n-        Parser::new(sess, tts, directory, recurse_into_modules, true, rustc_parse::MACRO_ARGUMENTS);\n-\n+/// Use the given sequence of token trees (`ms`) as a matcher. Match the token\n+/// stream from the given `parser` against it and return the match.\n+pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> NamedParseResult {\n     // A queue of possible matcher positions. We initialize it with the matcher position in which\n     // the \"dot\" is before the first token of the first token tree in `ms`. `inner_parse_loop` then\n     // processes all of these possible matcher positions and produces possible next positions into\n@@ -659,7 +639,7 @@ pub(super) fn parse(\n         // parsing from the black-box parser done. The result is that `next_items` will contain a\n         // bunch of possible next matcher positions in `next_items`.\n         match inner_parse_loop(\n-            sess,\n+            parser.sess,\n             &mut cur_items,\n             &mut next_items,\n             &mut eof_items,\n@@ -684,7 +664,7 @@ pub(super) fn parse(\n             if eof_items.len() == 1 {\n                 let matches =\n                     eof_items[0].matches.iter_mut().map(|dv| Lrc::make_mut(dv).pop().unwrap());\n-                return nameize(sess, ms, matches);\n+                return nameize(parser.sess, ms, matches);\n             } else if eof_items.len() > 1 {\n                 return Error(\n                     parser.token.span,\n@@ -709,9 +689,14 @@ pub(super) fn parse(\n         // unnecessary implicit clone later in Rc::make_mut.\n         drop(eof_items);\n \n+        // If there are no possible next positions AND we aren't waiting for the black-box parser,\n+        // then there is a syntax error.\n+        if bb_items.is_empty() && next_items.is_empty() {\n+            return Failure(parser.token.clone(), \"no rules expected this token in macro call\");\n+        }\n         // Another possibility is that we need to call out to parse some rust nonterminal\n         // (black-box) parser. However, if there is not EXACTLY ONE of these, something is wrong.\n-        if (!bb_items.is_empty() && !next_items.is_empty()) || bb_items.len() > 1 {\n+        else if (!bb_items.is_empty() && !next_items.is_empty()) || bb_items.len() > 1 {\n             let nts = bb_items\n                 .iter()\n                 .map(|item| match item.top_elts.get_tt(item.idx) {\n@@ -733,16 +718,11 @@ pub(super) fn parse(\n                 ),\n             );\n         }\n-        // If there are no possible next positions AND we aren't waiting for the black-box parser,\n-        // then there is a syntax error.\n-        else if bb_items.is_empty() && next_items.is_empty() {\n-            return Failure(parser.token.take(), \"no rules expected this token in macro call\");\n-        }\n         // Dump all possible `next_items` into `cur_items` for the next iteration.\n         else if !next_items.is_empty() {\n             // Now process the next token\n             cur_items.extend(next_items.drain(..));\n-            parser.bump();\n+            parser.to_mut().bump();\n         }\n         // Finally, we have the case where we need to call the black-box parser to get some\n         // nonterminal.\n@@ -754,7 +734,7 @@ pub(super) fn parse(\n                 let match_cur = item.match_cur;\n                 item.push_match(\n                     match_cur,\n-                    MatchedNonterminal(Lrc::new(parse_nt(&mut parser, span, ident.name))),\n+                    MatchedNonterminal(Lrc::new(parse_nt(parser.to_mut(), span, ident.name))),\n                 );\n                 item.idx += 1;\n                 item.match_cur += 1;"}, {"sha": "9e6edee265c989261b17f0049ac7157171e5597c", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 47, "deletions": 17, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -1,11 +1,11 @@\n-use crate::base::{DummyResult, ExtCtxt, MacResult, TTMacroExpander};\n+use crate::base::{DummyResult, ExpansionData, ExtCtxt, MacResult, TTMacroExpander};\n use crate::base::{SyntaxExtension, SyntaxExtensionKind};\n use crate::expand::{ensure_complete_parse, parse_ast_fragment, AstFragment, AstFragmentKind};\n use crate::mbe;\n use crate::mbe::macro_check;\n-use crate::mbe::macro_parser::parse;\n+use crate::mbe::macro_parser::parse_tt;\n use crate::mbe::macro_parser::{Error, Failure, Success};\n-use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq, NamedParseResult};\n+use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq};\n use crate::mbe::transcribe::transcribe;\n \n use rustc_ast_pretty::pprust;\n@@ -166,9 +166,9 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n     }\n }\n \n-fn trace_macros_note(cx: &mut ExtCtxt<'_>, sp: Span, message: String) {\n+fn trace_macros_note(cx_expansions: &mut FxHashMap<Span, Vec<String>>, sp: Span, message: String) {\n     let sp = sp.macro_backtrace().last().map(|trace| trace.call_site).unwrap_or(sp);\n-    cx.expansions.entry(sp).or_default().push(message);\n+    cx_expansions.entry(sp).or_default().push(message);\n }\n \n /// Given `lhses` and `rhses`, this is the new macro we create\n@@ -184,12 +184,36 @@ fn generic_extension<'cx>(\n ) -> Box<dyn MacResult + 'cx> {\n     if cx.trace_macros() {\n         let msg = format!(\"expanding `{}! {{ {} }}`\", name, pprust::tts_to_string(arg.clone()));\n-        trace_macros_note(cx, sp, msg);\n+        trace_macros_note(&mut cx.expansions, sp, msg);\n     }\n \n     // Which arm's failure should we report? (the one furthest along)\n     let mut best_failure: Option<(Token, &str)> = None;\n+\n+    // We create a base parser that can be used for the \"black box\" parts.\n+    // Every iteration needs a fresh copy of that base parser. However, the\n+    // parser is not mutated on many of the iterations, particularly when\n+    // dealing with macros like this:\n+    //\n+    // macro_rules! foo {\n+    //     (\"a\") => (A);\n+    //     (\"b\") => (B);\n+    //     (\"c\") => (C);\n+    //     // ... etc. (maybe hundreds more)\n+    // }\n+    //\n+    // as seen in the `html5ever` benchmark. We use a `Cow` so that the base\n+    // parser is only cloned when necessary (upon mutation). Furthermore, we\n+    // reinitialize the `Cow` with the base parser at the start of every\n+    // iteration, so that any mutated parsers are not reused. This is all quite\n+    // hacky, but speeds up the `html5ever` benchmark significantly. (Issue\n+    // 68836 suggests a more comprehensive but more complex change to deal with\n+    // this situation.)\n+    let base_parser = base_parser_from_cx(&cx.current_expansion, &cx.parse_sess, arg.clone());\n+\n     for (i, lhs) in lhses.iter().enumerate() {\n+        let mut parser = Cow::Borrowed(&base_parser);\n+\n         // try each arm's matchers\n         let lhs_tt = match *lhs {\n             mbe::TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n@@ -202,7 +226,7 @@ fn generic_extension<'cx>(\n         // are not recorded. On the first `Success(..)`ful matcher, the spans are merged.\n         let mut gated_spans_snaphot = mem::take(&mut *cx.parse_sess.gated_spans.spans.borrow_mut());\n \n-        match parse_tt(cx, lhs_tt, arg.clone()) {\n+        match parse_tt(&mut parser, lhs_tt) {\n             Success(named_matches) => {\n                 // The matcher was `Success(..)`ful.\n                 // Merge the gated spans from parsing the matcher with the pre-existing ones.\n@@ -232,11 +256,11 @@ fn generic_extension<'cx>(\n \n                 if cx.trace_macros() {\n                     let msg = format!(\"to `{}`\", pprust::tts_to_string(tts.clone()));\n-                    trace_macros_note(cx, sp, msg);\n+                    trace_macros_note(&mut cx.expansions, sp, msg);\n                 }\n \n                 let directory = Directory {\n-                    path: Cow::from(cx.current_expansion.module.directory.as_path()),\n+                    path: cx.current_expansion.module.directory.clone(),\n                     ownership: cx.current_expansion.directory_ownership,\n                 };\n                 let mut p = Parser::new(cx.parse_sess(), tts, Some(directory), true, false, None);\n@@ -269,6 +293,7 @@ fn generic_extension<'cx>(\n         // Restore to the state before snapshotting and maybe try again.\n         mem::swap(&mut gated_spans_snaphot, &mut cx.parse_sess.gated_spans.spans.borrow_mut());\n     }\n+    drop(base_parser);\n \n     let (token, label) = best_failure.expect(\"ran no matchers\");\n     let span = token.span.substitute_dummy(sp);\n@@ -286,7 +311,9 @@ fn generic_extension<'cx>(\n                 mbe::TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n                 _ => continue,\n             };\n-            match parse_tt(cx, lhs_tt, arg.clone()) {\n+            let base_parser =\n+                base_parser_from_cx(&cx.current_expansion, &cx.parse_sess, arg.clone());\n+            match parse_tt(&mut Cow::Borrowed(&base_parser), lhs_tt) {\n                 Success(_) => {\n                     if comma_span.is_dummy() {\n                         err.note(\"you might be missing a comma\");\n@@ -368,7 +395,8 @@ pub fn compile_declarative_macro(\n         ),\n     ];\n \n-    let argument_map = match parse(sess, body, &argument_gram, None, true) {\n+    let base_parser = Parser::new(sess, body, None, true, true, rustc_parse::MACRO_ARGUMENTS);\n+    let argument_map = match parse_tt(&mut Cow::Borrowed(&base_parser), &argument_gram) {\n         Success(m) => m,\n         Failure(token, msg) => {\n             let s = parse_failure_msg(&token);\n@@ -1184,14 +1212,16 @@ fn quoted_tt_to_string(tt: &mbe::TokenTree) -> String {\n     }\n }\n \n-/// Use this token tree as a matcher to parse given tts.\n-fn parse_tt(cx: &ExtCtxt<'_>, mtch: &[mbe::TokenTree], tts: TokenStream) -> NamedParseResult {\n-    // `None` is because we're not interpolating\n+fn base_parser_from_cx<'cx>(\n+    current_expansion: &'cx ExpansionData,\n+    sess: &'cx ParseSess,\n+    tts: TokenStream,\n+) -> Parser<'cx> {\n     let directory = Directory {\n-        path: Cow::from(cx.current_expansion.module.directory.as_path()),\n-        ownership: cx.current_expansion.directory_ownership,\n+        path: current_expansion.module.directory.clone(),\n+        ownership: current_expansion.directory_ownership,\n     };\n-    parse(cx.parse_sess(), tts, mtch, Some(directory), true)\n+    Parser::new(sess, tts, Some(directory), true, true, rustc_parse::MACRO_ARGUMENTS)\n }\n \n /// Generates an appropriate parsing failure message. For EOF, this is \"unexpected end...\". For"}, {"sha": "4aad2c0f68a29f9e36336cd021108fa1803b6f4f", "filename": "src/librustc_parse/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -12,8 +12,7 @@ use syntax::ast;\n use syntax::token::{self, Nonterminal};\n use syntax::tokenstream::{self, TokenStream, TokenTree};\n \n-use std::borrow::Cow;\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n use std::str;\n \n use log::info;\n@@ -29,8 +28,8 @@ pub mod validate_attr;\n pub mod config;\n \n #[derive(Clone)]\n-pub struct Directory<'a> {\n-    pub path: Cow<'a, Path>,\n+pub struct Directory {\n+    pub path: PathBuf,\n     pub ownership: DirectoryOwnership,\n }\n \n@@ -274,7 +273,7 @@ pub fn stream_to_parser<'a>(\n pub fn stream_to_parser_with_base_dir<'a>(\n     sess: &'a ParseSess,\n     stream: TokenStream,\n-    base_dir: Directory<'a>,\n+    base_dir: Directory,\n ) -> Parser<'a> {\n     Parser::new(sess, stream, Some(base_dir), true, false, None)\n }"}, {"sha": "e1461dbb8e763c25f143e5c5b06bbbf4b07125f3", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -29,7 +29,6 @@ use syntax::token::{self, DelimToken, Token, TokenKind};\n use syntax::tokenstream::{self, DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n use syntax::util::comments::{doc_comment_style, strip_doc_comment_decoration};\n \n-use std::borrow::Cow;\n use std::path::PathBuf;\n use std::{cmp, mem, slice};\n \n@@ -108,7 +107,7 @@ pub struct Parser<'a> {\n     pub prev_span: Span,\n     restrictions: Restrictions,\n     /// Used to determine the path to externally loaded source files.\n-    pub(super) directory: Directory<'a>,\n+    pub(super) directory: Directory,\n     /// `true` to parse sub-modules in other files.\n     // Public for rustfmt usage.\n     pub recurse_into_file_modules: bool,\n@@ -370,7 +369,7 @@ impl<'a> Parser<'a> {\n     pub fn new(\n         sess: &'a ParseSess,\n         tokens: TokenStream,\n-        directory: Option<Directory<'a>>,\n+        directory: Option<Directory>,\n         recurse_into_file_modules: bool,\n         desugar_doc_comments: bool,\n         subparser_name: Option<&'static str>,\n@@ -385,7 +384,7 @@ impl<'a> Parser<'a> {\n             restrictions: Restrictions::empty(),\n             recurse_into_file_modules,\n             directory: Directory {\n-                path: Cow::from(PathBuf::new()),\n+                path: PathBuf::new(),\n                 ownership: DirectoryOwnership::Owned { relative: None },\n             },\n             root_module_name: None,\n@@ -413,7 +412,7 @@ impl<'a> Parser<'a> {\n                 &sess.source_map().lookup_char_pos(parser.token.span.lo()).file.unmapped_path\n             {\n                 if let Some(directory_path) = path.parent() {\n-                    parser.directory.path = Cow::from(directory_path.to_path_buf());\n+                    parser.directory.path = directory_path.to_path_buf();\n                 }\n             }\n         }"}, {"sha": "0c8fad03d869053b0def50ac6c40153a48d52bbc", "filename": "src/librustc_parse/parser/module.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmodule.rs?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -285,7 +285,7 @@ impl<'a> Parser<'a> {\n \n     fn push_directory(&mut self, id: Ident, attrs: &[Attribute]) {\n         if let Some(path) = attr::first_attr_value_str_by_name(attrs, sym::path) {\n-            self.directory.path.to_mut().push(&*path.as_str());\n+            self.directory.path.push(&*path.as_str());\n             self.directory.ownership = DirectoryOwnership::Owned { relative: None };\n         } else {\n             // We have to push on the current module name in the case of relative\n@@ -297,10 +297,10 @@ impl<'a> Parser<'a> {\n             if let DirectoryOwnership::Owned { relative } = &mut self.directory.ownership {\n                 if let Some(ident) = relative.take() {\n                     // remove the relative offset\n-                    self.directory.path.to_mut().push(&*ident.as_str());\n+                    self.directory.path.push(&*ident.as_str());\n                 }\n             }\n-            self.directory.path.to_mut().push(&*id.as_str());\n+            self.directory.path.push(&*id.as_str());\n         }\n     }\n }"}, {"sha": "4a98095ec89c6b058db26867a2fec95c9fdca8d0", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -24,6 +24,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.annotate_expected_due_to_let_ty(err, expr);\n         self.suggest_compatible_variants(err, expr, expected, expr_ty);\n         self.suggest_ref_or_into(err, expr, expected, expr_ty);\n+        if self.suggest_calling_boxed_future_when_appropriate(err, expr, expected, expr_ty) {\n+            return;\n+        }\n         self.suggest_boxing_when_appropriate(err, expr, expected, expr_ty);\n         self.suggest_missing_await(err, expr, expected, expr_ty);\n     }"}, {"sha": "fd0c994a6eadfb39e1ff83954384752f0676a702", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 50, "deletions": 4, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -5038,14 +5038,60 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Applicability::MachineApplicable,\n             );\n             err.note(\n-                \"for more on the distinction between the stack and the \\\n-                        heap, read https://doc.rust-lang.org/book/ch15-01-box.html, \\\n-                        https://doc.rust-lang.org/rust-by-example/std/box.html, and \\\n-                        https://doc.rust-lang.org/std/boxed/index.html\",\n+                \"for more on the distinction between the stack and the heap, read \\\n+                 https://doc.rust-lang.org/book/ch15-01-box.html, \\\n+                 https://doc.rust-lang.org/rust-by-example/std/box.html, and \\\n+                 https://doc.rust-lang.org/std/boxed/index.html\",\n             );\n         }\n     }\n \n+    /// When encountering an `impl Future` where `BoxFuture` is expected, suggest `Box::pin`.\n+    fn suggest_calling_boxed_future_when_appropriate(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        expr: &hir::Expr<'_>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) -> bool {\n+        // Handle #68197.\n+\n+        if self.tcx.hir().is_const_context(expr.hir_id) {\n+            // Do not suggest `Box::new` in const context.\n+            return false;\n+        }\n+        let pin_did = self.tcx.lang_items().pin_type();\n+        match expected.kind {\n+            ty::Adt(def, _) if Some(def.did) != pin_did => return false,\n+            // This guards the `unwrap` and `mk_box` below.\n+            _ if pin_did.is_none() || self.tcx.lang_items().owned_box().is_none() => return false,\n+            _ => {}\n+        }\n+        let boxed_found = self.tcx.mk_box(found);\n+        let new_found = self.tcx.mk_lang_item(boxed_found, lang_items::PinTypeLangItem).unwrap();\n+        if let (true, Ok(snippet)) = (\n+            self.can_coerce(new_found, expected),\n+            self.sess().source_map().span_to_snippet(expr.span),\n+        ) {\n+            match found.kind {\n+                ty::Adt(def, _) if def.is_box() => {\n+                    err.help(\"use `Box::pin`\");\n+                }\n+                _ => {\n+                    err.span_suggestion(\n+                        expr.span,\n+                        \"you need to pin and box this expression\",\n+                        format!(\"Box::pin({})\", snippet),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n     /// A common error is to forget to add a semicolon at the end of a block, e.g.,\n     ///\n     /// ```"}, {"sha": "f3a1f412d0d59009a7357c816ae1b1086d7aa2b7", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 102, "deletions": 13, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -278,6 +278,17 @@ impl ItemCtxt<'tcx> {\n     pub fn to_ty(&self, ast_ty: &'tcx hir::Ty<'tcx>) -> Ty<'tcx> {\n         AstConv::ast_ty_to_ty(self, ast_ty)\n     }\n+\n+    pub fn hir_id(&self) -> hir::HirId {\n+        self.tcx\n+            .hir()\n+            .as_local_hir_id(self.item_def_id)\n+            .expect(\"Non-local call to local provider is_const_fn\")\n+    }\n+\n+    pub fn node(&self) -> hir::Node<'tcx> {\n+        self.tcx.hir().get(self.hir_id())\n+    }\n }\n \n impl AstConv<'tcx> for ItemCtxt<'tcx> {\n@@ -290,15 +301,7 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n     }\n \n     fn default_constness_for_trait_bounds(&self) -> ast::Constness {\n-        // FIXME: refactor this into a method\n-        let hir_id = self\n-            .tcx\n-            .hir()\n-            .as_local_hir_id(self.item_def_id)\n-            .expect(\"Non-local call to local provider is_const_fn\");\n-\n-        let node = self.tcx.hir().get(hir_id);\n-        if let Some(fn_like) = FnLikeNode::from_node(node) {\n+        if let Some(fn_like) = FnLikeNode::from_node(self.node()) {\n             fn_like.constness()\n         } else {\n             ast::Constness::NotConst\n@@ -352,14 +355,80 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n             self.tcx().mk_projection(item_def_id, item_substs)\n         } else {\n             // There are no late-bound regions; we can just ignore the binder.\n-            struct_span_err!(\n+            let mut err = struct_span_err!(\n                 self.tcx().sess,\n                 span,\n                 E0212,\n                 \"cannot extract an associated type from a higher-ranked trait bound \\\n                  in this context\"\n-            )\n-            .emit();\n+            );\n+\n+            match self.node() {\n+                hir::Node::Field(_) | hir::Node::Ctor(_) | hir::Node::Variant(_) => {\n+                    let item =\n+                        self.tcx.hir().expect_item(self.tcx.hir().get_parent_item(self.hir_id()));\n+                    match &item.kind {\n+                        hir::ItemKind::Enum(_, generics)\n+                        | hir::ItemKind::Struct(_, generics)\n+                        | hir::ItemKind::Union(_, generics) => {\n+                            // FIXME: look for an appropriate lt name if `'a` is already used\n+                            let (lt_sp, sugg) = match &generics.params[..] {\n+                                [] => (generics.span, \"<'a>\".to_string()),\n+                                [bound, ..] => (bound.span.shrink_to_lo(), \"'a, \".to_string()),\n+                            };\n+                            let suggestions = vec![\n+                                (lt_sp, sugg),\n+                                (\n+                                    span,\n+                                    format!(\n+                                        \"{}::{}\",\n+                                        // Replace the existing lifetimes with a new named lifetime.\n+                                        self.tcx\n+                                            .replace_late_bound_regions(&poly_trait_ref, |_| {\n+                                                self.tcx.mk_region(ty::ReEarlyBound(\n+                                                    ty::EarlyBoundRegion {\n+                                                        def_id: item_def_id,\n+                                                        index: 0,\n+                                                        name: Symbol::intern(\"'a\"),\n+                                                    },\n+                                                ))\n+                                            })\n+                                            .0,\n+                                        item_segment.ident\n+                                    ),\n+                                ),\n+                            ];\n+                            err.multipart_suggestion(\n+                                \"use a fully qualified path with explicit lifetimes\",\n+                                suggestions,\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+                hir::Node::Item(hir::Item { kind: hir::ItemKind::Struct(..), .. })\n+                | hir::Node::Item(hir::Item { kind: hir::ItemKind::Enum(..), .. })\n+                | hir::Node::Item(hir::Item { kind: hir::ItemKind::Union(..), .. }) => {}\n+                hir::Node::Item(_)\n+                | hir::Node::ForeignItem(_)\n+                | hir::Node::TraitItem(_)\n+                | hir::Node::ImplItem(_) => {\n+                    err.span_suggestion(\n+                        span,\n+                        \"use a fully qualified path with inferred lifetimes\",\n+                        format!(\n+                            \"{}::{}\",\n+                            // Erase named lt, we want `<A as B<'_>::C`, not `<A as B<'a>::C`.\n+                            self.tcx.anonymize_late_bound_regions(&poly_trait_ref).skip_binder(),\n+                            item_segment.ident\n+                        ),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                _ => {}\n+            }\n+            err.emit();\n             self.tcx().types.err\n         }\n     }\n@@ -1054,7 +1123,27 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n             Some(tcx.closure_base_def_id(def_id))\n         }\n         Node::Item(item) => match item.kind {\n-            ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn, .. }) => impl_trait_fn,\n+            ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn, .. }) => {\n+                impl_trait_fn.or_else(|| {\n+                    let parent_id = tcx.hir().get_parent_item(hir_id);\n+                    if parent_id != hir_id && parent_id != CRATE_HIR_ID {\n+                        debug!(\"generics_of: parent of opaque ty {:?} is {:?}\", def_id, parent_id);\n+                        // If this 'impl Trait' is nested inside another 'impl Trait'\n+                        // (e.g. `impl Foo<MyType = impl Bar<A>>`), we need to use the 'parent'\n+                        // 'impl Trait' for its generic parameters, since we can reference them\n+                        // from the 'child' 'impl Trait'\n+                        if let Node::Item(hir::Item { kind: ItemKind::OpaqueTy(..), .. }) =\n+                            tcx.hir().get(parent_id)\n+                        {\n+                            Some(tcx.hir().local_def_id(parent_id))\n+                        } else {\n+                            None\n+                        }\n+                    } else {\n+                        None\n+                    }\n+                })\n+            }\n             _ => None,\n         },\n         _ => None,"}, {"sha": "ea266e856a9d8126541b0839a21a54ead0f91561", "filename": "src/librustdoc/html/static/brush.svg", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fbrush.svg", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fbrush.svg", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fbrush.svg?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -1 +1 @@\n-<?xml version=\"1.0\" ?><svg height=\"1792\" viewBox=\"0 0 1792 1792\" width=\"1792\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M1615 0q70 0 122.5 46.5t52.5 116.5q0 63-45 151-332 629-465 752-97 91-218 91-126 0-216.5-92.5t-90.5-219.5q0-128 92-212l638-579q59-54 130-54zm-909 1034q39 76 106.5 130t150.5 76l1 71q4 213-129.5 347t-348.5 134q-123 0-218-46.5t-152.5-127.5-86.5-183-29-220q7 5 41 30t62 44.5 59 36.5 46 17q41 0 55-37 25-66 57.5-112.5t69.5-76 88-47.5 103-25.5 125-10.5z\"/></svg>\n\\ No newline at end of file\n+<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"1792\" height=\"1792\" viewBox=\"0 0 1792 1792\"><path d=\"M1615 0q70 0 122.5 46.5t52.5 116.5q0 63-45 151-332 629-465 752-97 91-218 91-126 0-216.5-92.5t-90.5-219.5q0-128 92-212l638-579q59-54 130-54zm-909 1034q39 76 106.5 130t150.5 76l1 71q4 213-129.5 347t-348.5 134q-123 0-218-46.5t-152.5-127.5-86.5-183-29-220q7 5 41 30t62 44.5 59 36.5 46 17q41 0 55-37 25-66 57.5-112.5t69.5-76 88-47.5 103-25.5 125-10.5z\"/></svg>\n\\ No newline at end of file"}, {"sha": "35437e77a710cac4f1aec365dbfc38d478e3425f", "filename": "src/librustdoc/html/static/down-arrow.svg", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fdown-arrow.svg", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fdown-arrow.svg", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fdown-arrow.svg?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -1 +1 @@\n-<?xml version=\"1.0\" ?><!DOCTYPE svg  PUBLIC '-//W3C//DTD SVG 1.1//EN'  'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'><svg height=\"128px\" id=\"Layer_1\" style=\"enable-background:new 0 0 128 128;\" version=\"1.1\" viewBox=\"-30 -20 176 176\" width=\"128px\" xml:space=\"preserve\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><g><line style=\"fill:none;stroke:#2F3435;stroke-width:12;stroke-linecap:square;stroke-miterlimit:10;\" x1=\"111\" x2=\"64\" y1=\"40.5\" y2=\"87.499\"/><line style=\"fill:none;stroke:#2F3435;stroke-width:12;stroke-linecap:square;stroke-miterlimit:10;\" x1=\"64\" x2=\"17\" y1=\"87.499\" y2=\"40.5\"/></g></svg>\n\\ No newline at end of file\n+<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" id=\"Layer_1\" width=\"128\" height=\"128\" enable-background=\"new 0 0 128 128\" version=\"1.1\" viewBox=\"-30 -20 176 176\" xml:space=\"preserve\"><g><line x1=\"111\" x2=\"64\" y1=\"40.5\" y2=\"87.499\" fill=\"none\" stroke=\"#2F3435\" stroke-linecap=\"square\" stroke-miterlimit=\"10\" stroke-width=\"12\"/><line x1=\"64\" x2=\"17\" y1=\"87.499\" y2=\"40.5\" fill=\"none\" stroke=\"#2F3435\" stroke-linecap=\"square\" stroke-miterlimit=\"10\" stroke-width=\"12\"/></g></svg>\n\\ No newline at end of file"}, {"sha": "01da3b24c7c4f3cba6ed2123a4a3ddfb2cb21a21", "filename": "src/librustdoc/html/static/wheel.svg", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fwheel.svg", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fwheel.svg", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fwheel.svg?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -1 +1 @@\n-<?xml version=\"1.0\" ?><!DOCTYPE svg  PUBLIC '-//W3C//DTD SVG 1.1//EN'  'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'><svg enable-background=\"new 0 0 27.434 29.5\" height=\"29.5px\" id=\"Capa_1\" version=\"1.1\" viewBox=\"0 0 27.434 29.5\" width=\"27.434px\" xml:space=\"preserve\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"><g><path d=\"M27.315,18.389c-0.165-0.604-0.509-1.113-0.981-1.459c-0.042-0.144-0.083-0.429-0.015-0.761l0.037-0.177v-0.182V14.8   c0-1.247-0.006-1.277-0.048-1.472c-0.076-0.354-0.035-0.653,0.007-0.803c0.477-0.346,0.828-0.861,0.996-1.476   c0.261-0.956,0.076-2.091-0.508-3.114l-0.591-1.032c-0.746-1.307-1.965-2.119-3.182-2.119c-0.378,0-0.75,0.081-1.085,0.235   c-0.198-0.025-0.554-0.15-0.855-0.389l-0.103-0.082l-0.114-0.065l-1.857-1.067L18.92,3.36l-0.105-0.044   c-0.376-0.154-0.658-0.41-0.768-0.556C17.918,1.172,16.349,0,14.296,0H13.14c-2.043,0-3.608,1.154-3.749,2.721   C9.277,2.862,8.999,3.104,8.633,3.25l-0.1,0.039L8.439,3.341L6.495,4.406L6.363,4.479L6.245,4.573   C5.936,4.82,5.596,4.944,5.416,4.977c-0.314-0.139-0.66-0.21-1.011-0.21c-1.198,0-2.411,0.819-3.165,2.139L0.65,7.938   c-0.412,0.72-0.642,1.521-0.644,2.258c-0.003,0.952,0.362,1.756,1.013,2.256c0.034,0.155,0.061,0.448-0.016,0.786   c-0.038,0.168-0.062,0.28-0.062,1.563c0,1.148,0,1.148,0.015,1.262l0.009,0.073l0.017,0.073c0.073,0.346,0.045,0.643,0.011,0.802   C0.348,17.512-0.01,18.314,0,19.268c0.008,0.729,0.238,1.523,0.648,2.242l0.589,1.031c0.761,1.331,1.967,2.159,3.15,2.159   c0.324,0,0.645-0.064,0.938-0.187c0.167,0.038,0.492,0.156,0.813,0.416l0.11,0.088l0.124,0.07l2.045,1.156l0.102,0.057l0.107,0.043   c0.364,0.147,0.646,0.381,0.766,0.521c0.164,1.52,1.719,2.634,3.745,2.634h1.155c2.037,0,3.598-1.134,3.747-2.675   c0.117-0.145,0.401-0.393,0.774-0.549l0.111-0.047l0.105-0.062l1.96-1.159l0.105-0.062l0.097-0.075   c0.309-0.246,0.651-0.371,0.832-0.402c0.313,0.138,0.662,0.212,1.016,0.212c1.199,0,2.412-0.82,3.166-2.139l0.59-1.032   C27.387,20.48,27.575,19.342,27.315,18.389z M25.274,20.635l-0.59,1.032c-0.438,0.765-1.104,1.251-1.639,1.251   c-0.133,0-0.258-0.029-0.369-0.094c-0.15-0.086-0.346-0.127-0.566-0.127c-0.596,0-1.383,0.295-2.01,0.796l-1.96,1.157   c-1.016,0.425-1.846,1.291-1.846,1.929s-0.898,1.159-1.998,1.159H13.14c-1.1,0-1.998-0.514-1.998-1.141s-0.834-1.477-1.854-1.888   l-2.046-1.157c-0.636-0.511-1.425-0.814-2.006-0.814c-0.202,0-0.379,0.037-0.516,0.115c-0.101,0.057-0.214,0.084-0.333,0.084   c-0.518,0-1.179-0.498-1.62-1.271l-0.591-1.032c-0.545-0.954-0.556-1.983-0.024-2.286c0.532-0.305,0.78-1.432,0.551-2.506   c0,0,0-0.003,0-1.042c0-1.088,0.021-1.18,0.021-1.18c0.238-1.072-0.01-2.203-0.552-2.513C1.631,10.8,1.634,9.765,2.18,8.812   L2.769,7.78c0.438-0.766,1.103-1.251,1.636-1.251c0.131,0,0.255,0.029,0.365,0.092C4.92,6.707,5.114,6.747,5.334,6.747   c0.596,0,1.38-0.296,2.007-0.795l1.944-1.065c1.021-0.407,1.856-1.277,1.856-1.933c0-0.656,0.898-1.192,1.998-1.192h1.156V1.761   c1.1,0,1.998,0.545,1.998,1.211c0,0.667,0.832,1.554,1.849,1.973L20,6.013c0.618,0.489,1.401,0.775,2.012,0.775   c0.24,0,0.454-0.045,0.62-0.139c0.122-0.069,0.259-0.102,0.403-0.102c0.551,0,1.221,0.476,1.653,1.231l0.59,1.032   c0.544,0.953,0.518,2.004-0.062,2.334c-0.577,0.331-0.859,1.48-0.627,2.554c0,0,0.01,0.042,0.01,1.103c0,1.012,0,1.012,0,1.012   c-0.218,1.049,0.068,2.174,0.636,2.498C25.802,18.635,25.819,19.68,25.274,20.635z\"/><path d=\"M13.61,7.611c-3.913,0-7.084,3.173-7.084,7.085c0,3.914,3.171,7.085,7.084,7.085s7.085-3.172,7.085-7.085   C20.695,10.784,17.523,7.611,13.61,7.611z M13.61,20.02c-2.936,0-5.323-2.388-5.323-5.323c0-2.935,2.388-5.323,5.323-5.323   s5.324,2.388,5.324,5.323C18.934,17.632,16.546,20.02,13.61,20.02z\"/><path d=\"M13.682,9.908c-2.602,0-4.718,2.116-4.718,4.718c0,2.601,2.116,4.716,4.718,4.716c2.601,0,4.717-2.115,4.717-4.716   C18.399,12.024,16.283,9.908,13.682,9.908z M13.682,17.581c-1.633,0-2.956-1.323-2.956-2.955s1.323-2.956,2.956-2.956   c1.632,0,2.956,1.324,2.956,2.956S15.314,17.581,13.682,17.581z\"/></g></svg>\n\\ No newline at end of file\n+<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" id=\"Capa_1\" width=\"27.434\" height=\"29.5\" enable-background=\"new 0 0 27.434 29.5\" version=\"1.1\" viewBox=\"0 0 27.434 29.5\" xml:space=\"preserve\"><g><path d=\"M27.315,18.389c-0.165-0.604-0.509-1.113-0.981-1.459c-0.042-0.144-0.083-0.429-0.015-0.761l0.037-0.177v-0.182V14.8 c0-1.247-0.006-1.277-0.048-1.472c-0.076-0.354-0.035-0.653,0.007-0.803c0.477-0.346,0.828-0.861,0.996-1.476 c0.261-0.956,0.076-2.091-0.508-3.114l-0.591-1.032c-0.746-1.307-1.965-2.119-3.182-2.119c-0.378,0-0.75,0.081-1.085,0.235 c-0.198-0.025-0.554-0.15-0.855-0.389l-0.103-0.082l-0.114-0.065l-1.857-1.067L18.92,3.36l-0.105-0.044 c-0.376-0.154-0.658-0.41-0.768-0.556C17.918,1.172,16.349,0,14.296,0H13.14c-2.043,0-3.608,1.154-3.749,2.721 C9.277,2.862,8.999,3.104,8.633,3.25l-0.1,0.039L8.439,3.341L6.495,4.406L6.363,4.479L6.245,4.573 C5.936,4.82,5.596,4.944,5.416,4.977c-0.314-0.139-0.66-0.21-1.011-0.21c-1.198,0-2.411,0.819-3.165,2.139L0.65,7.938 c-0.412,0.72-0.642,1.521-0.644,2.258c-0.003,0.952,0.362,1.756,1.013,2.256c0.034,0.155,0.061,0.448-0.016,0.786 c-0.038,0.168-0.062,0.28-0.062,1.563c0,1.148,0,1.148,0.015,1.262l0.009,0.073l0.017,0.073c0.073,0.346,0.045,0.643,0.011,0.802 C0.348,17.512-0.01,18.314,0,19.268c0.008,0.729,0.238,1.523,0.648,2.242l0.589,1.031c0.761,1.331,1.967,2.159,3.15,2.159 c0.324,0,0.645-0.064,0.938-0.187c0.167,0.038,0.492,0.156,0.813,0.416l0.11,0.088l0.124,0.07l2.045,1.156l0.102,0.057l0.107,0.043 c0.364,0.147,0.646,0.381,0.766,0.521c0.164,1.52,1.719,2.634,3.745,2.634h1.155c2.037,0,3.598-1.134,3.747-2.675 c0.117-0.145,0.401-0.393,0.774-0.549l0.111-0.047l0.105-0.062l1.96-1.159l0.105-0.062l0.097-0.075 c0.309-0.246,0.651-0.371,0.832-0.402c0.313,0.138,0.662,0.212,1.016,0.212c1.199,0,2.412-0.82,3.166-2.139l0.59-1.032 C27.387,20.48,27.575,19.342,27.315,18.389z M25.274,20.635l-0.59,1.032c-0.438,0.765-1.104,1.251-1.639,1.251 c-0.133,0-0.258-0.029-0.369-0.094c-0.15-0.086-0.346-0.127-0.566-0.127c-0.596,0-1.383,0.295-2.01,0.796l-1.96,1.157 c-1.016,0.425-1.846,1.291-1.846,1.929s-0.898,1.159-1.998,1.159H13.14c-1.1,0-1.998-0.514-1.998-1.141s-0.834-1.477-1.854-1.888 l-2.046-1.157c-0.636-0.511-1.425-0.814-2.006-0.814c-0.202,0-0.379,0.037-0.516,0.115c-0.101,0.057-0.214,0.084-0.333,0.084 c-0.518,0-1.179-0.498-1.62-1.271l-0.591-1.032c-0.545-0.954-0.556-1.983-0.024-2.286c0.532-0.305,0.78-1.432,0.551-2.506 c0,0,0-0.003,0-1.042c0-1.088,0.021-1.18,0.021-1.18c0.238-1.072-0.01-2.203-0.552-2.513C1.631,10.8,1.634,9.765,2.18,8.812 L2.769,7.78c0.438-0.766,1.103-1.251,1.636-1.251c0.131,0,0.255,0.029,0.365,0.092C4.92,6.707,5.114,6.747,5.334,6.747 c0.596,0,1.38-0.296,2.007-0.795l1.944-1.065c1.021-0.407,1.856-1.277,1.856-1.933c0-0.656,0.898-1.192,1.998-1.192h1.156V1.761 c1.1,0,1.998,0.545,1.998,1.211c0,0.667,0.832,1.554,1.849,1.973L20,6.013c0.618,0.489,1.401,0.775,2.012,0.775 c0.24,0,0.454-0.045,0.62-0.139c0.122-0.069,0.259-0.102,0.403-0.102c0.551,0,1.221,0.476,1.653,1.231l0.59,1.032 c0.544,0.953,0.518,2.004-0.062,2.334c-0.577,0.331-0.859,1.48-0.627,2.554c0,0,0.01,0.042,0.01,1.103c0,1.012,0,1.012,0,1.012 c-0.218,1.049,0.068,2.174,0.636,2.498C25.802,18.635,25.819,19.68,25.274,20.635z\"/><path d=\"M13.61,7.611c-3.913,0-7.084,3.173-7.084,7.085c0,3.914,3.171,7.085,7.084,7.085s7.085-3.172,7.085-7.085 C20.695,10.784,17.523,7.611,13.61,7.611z M13.61,20.02c-2.936,0-5.323-2.388-5.323-5.323c0-2.935,2.388-5.323,5.323-5.323 s5.324,2.388,5.324,5.323C18.934,17.632,16.546,20.02,13.61,20.02z\"/><path d=\"M13.682,9.908c-2.602,0-4.718,2.116-4.718,4.718c0,2.601,2.116,4.716,4.718,4.716c2.601,0,4.717-2.115,4.717-4.716 C18.399,12.024,16.283,9.908,13.682,9.908z M13.682,17.581c-1.633,0-2.956-1.323-2.956-2.955s1.323-2.956,2.956-2.956 c1.632,0,2.956,1.324,2.956,2.956S15.314,17.581,13.682,17.581z\"/></g></svg>\n\\ No newline at end of file"}, {"sha": "1fe6a309e9650a90f39f8cf639aff03538268e28", "filename": "src/libserialize/leb128.rs", "status": "modified", "additions": 14, "deletions": 50, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibserialize%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibserialize%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fleb128.rs?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -1,46 +1,14 @@\n-#[inline]\n-pub fn write_to_vec(vec: &mut Vec<u8>, byte: u8) {\n-    vec.push(byte);\n-}\n-\n-#[cfg(target_pointer_width = \"32\")]\n-const USIZE_LEB128_SIZE: usize = 5;\n-#[cfg(target_pointer_width = \"64\")]\n-const USIZE_LEB128_SIZE: usize = 10;\n-\n-macro_rules! leb128_size {\n-    (u16) => {\n-        3\n-    };\n-    (u32) => {\n-        5\n-    };\n-    (u64) => {\n-        10\n-    };\n-    (u128) => {\n-        19\n-    };\n-    (usize) => {\n-        USIZE_LEB128_SIZE\n-    };\n-}\n-\n macro_rules! impl_write_unsigned_leb128 {\n     ($fn_name:ident, $int_ty:ident) => {\n         #[inline]\n         pub fn $fn_name(out: &mut Vec<u8>, mut value: $int_ty) {\n-            for _ in 0..leb128_size!($int_ty) {\n-                let mut byte = (value & 0x7F) as u8;\n-                value >>= 7;\n-                if value != 0 {\n-                    byte |= 0x80;\n-                }\n-\n-                write_to_vec(out, byte);\n-\n-                if value == 0 {\n+            loop {\n+                if value < 0x80 {\n+                    out.push(value as u8);\n                     break;\n+                } else {\n+                    out.push(((value & 0x7f) | 0x80) as u8);\n+                    value >>= 7;\n                 }\n             }\n         }\n@@ -57,24 +25,20 @@ macro_rules! impl_read_unsigned_leb128 {\n     ($fn_name:ident, $int_ty:ident) => {\n         #[inline]\n         pub fn $fn_name(slice: &[u8]) -> ($int_ty, usize) {\n-            let mut result: $int_ty = 0;\n+            let mut result = 0;\n             let mut shift = 0;\n             let mut position = 0;\n-\n-            for _ in 0..leb128_size!($int_ty) {\n-                let byte = unsafe { *slice.get_unchecked(position) };\n+            loop {\n+                let byte = slice[position];\n                 position += 1;\n-                result |= ((byte & 0x7F) as $int_ty) << shift;\n                 if (byte & 0x80) == 0 {\n-                    break;\n+                    result |= (byte as $int_ty) << shift;\n+                    return (result, position);\n+                } else {\n+                    result |= ((byte & 0x7F) as $int_ty) << shift;\n                 }\n                 shift += 7;\n             }\n-\n-            // Do a single bounds check at the end instead of for every byte.\n-            assert!(position <= slice.len());\n-\n-            (result, position)\n         }\n     };\n }\n@@ -116,7 +80,7 @@ where\n \n #[inline]\n pub fn write_signed_leb128(out: &mut Vec<u8>, value: i128) {\n-    write_signed_leb128_to(value, |v| write_to_vec(out, v))\n+    write_signed_leb128_to(value, |v| out.push(v))\n }\n \n #[inline]"}, {"sha": "d0e1a01b006549b8223c59388bbc0bc53a043a52", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 62, "deletions": 64, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -203,7 +203,7 @@ pub struct HashMap<K, V, S = RandomState> {\n     base: base::HashMap<K, V, S>,\n }\n \n-impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n+impl<K, V> HashMap<K, V, RandomState> {\n     /// Creates an empty `HashMap`.\n     ///\n     /// The hash map is initially created with a capacity of 0, so it will not allocate until it\n@@ -240,6 +240,59 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n }\n \n impl<K, V, S> HashMap<K, V, S> {\n+    /// Creates an empty `HashMap` which will use the given hash builder to hash\n+    /// keys.\n+    ///\n+    /// The created map has the default initial capacity.\n+    ///\n+    /// Warning: `hash_builder` is normally randomly generated, and\n+    /// is designed to allow HashMaps to be resistant to attacks that\n+    /// cause many collisions and very poor performance. Setting it\n+    /// manually using this function can expose a DoS attack vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::RandomState;\n+    ///\n+    /// let s = RandomState::new();\n+    /// let mut map = HashMap::with_hasher(s);\n+    /// map.insert(1, 2);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n+    pub fn with_hasher(hash_builder: S) -> HashMap<K, V, S> {\n+        HashMap { base: base::HashMap::with_hasher(hash_builder) }\n+    }\n+\n+    /// Creates an empty `HashMap` with the specified capacity, using `hash_builder`\n+    /// to hash the keys.\n+    ///\n+    /// The hash map will be able to hold at least `capacity` elements without\n+    /// reallocating. If `capacity` is 0, the hash map will not allocate.\n+    ///\n+    /// Warning: `hash_builder` is normally randomly generated, and\n+    /// is designed to allow HashMaps to be resistant to attacks that\n+    /// cause many collisions and very poor performance. Setting it\n+    /// manually using this function can expose a DoS attack vector.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::RandomState;\n+    ///\n+    /// let s = RandomState::new();\n+    /// let mut map = HashMap::with_capacity_and_hasher(10, s);\n+    /// map.insert(1, 2);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n+    pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S) -> HashMap<K, V, S> {\n+        HashMap { base: base::HashMap::with_capacity_and_hasher(capacity, hash_builder) }\n+    }\n+\n     /// Returns the number of elements the map can hold without reallocating.\n     ///\n     /// This number is a lower bound; the `HashMap<K, V>` might be able to hold\n@@ -457,65 +510,6 @@ impl<K, V, S> HashMap<K, V, S> {\n     pub fn clear(&mut self) {\n         self.base.clear();\n     }\n-}\n-\n-impl<K, V, S> HashMap<K, V, S>\n-where\n-    K: Eq + Hash,\n-    S: BuildHasher,\n-{\n-    /// Creates an empty `HashMap` which will use the given hash builder to hash\n-    /// keys.\n-    ///\n-    /// The created map has the default initial capacity.\n-    ///\n-    /// Warning: `hash_builder` is normally randomly generated, and\n-    /// is designed to allow HashMaps to be resistant to attacks that\n-    /// cause many collisions and very poor performance. Setting it\n-    /// manually using this function can expose a DoS attack vector.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::collections::hash_map::RandomState;\n-    ///\n-    /// let s = RandomState::new();\n-    /// let mut map = HashMap::with_hasher(s);\n-    /// map.insert(1, 2);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n-    pub fn with_hasher(hash_builder: S) -> HashMap<K, V, S> {\n-        HashMap { base: base::HashMap::with_hasher(hash_builder) }\n-    }\n-\n-    /// Creates an empty `HashMap` with the specified capacity, using `hash_builder`\n-    /// to hash the keys.\n-    ///\n-    /// The hash map will be able to hold at least `capacity` elements without\n-    /// reallocating. If `capacity` is 0, the hash map will not allocate.\n-    ///\n-    /// Warning: `hash_builder` is normally randomly generated, and\n-    /// is designed to allow HashMaps to be resistant to attacks that\n-    /// cause many collisions and very poor performance. Setting it\n-    /// manually using this function can expose a DoS attack vector.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::HashMap;\n-    /// use std::collections::hash_map::RandomState;\n-    ///\n-    /// let s = RandomState::new();\n-    /// let mut map = HashMap::with_capacity_and_hasher(10, s);\n-    /// map.insert(1, 2);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"hashmap_build_hasher\", since = \"1.7.0\")]\n-    pub fn with_capacity_and_hasher(capacity: usize, hash_builder: S) -> HashMap<K, V, S> {\n-        HashMap { base: base::HashMap::with_capacity_and_hasher(capacity, hash_builder) }\n-    }\n \n     /// Returns a reference to the map's [`BuildHasher`].\n     ///\n@@ -536,7 +530,13 @@ where\n     pub fn hasher(&self) -> &S {\n         self.base.hasher()\n     }\n+}\n \n+impl<K, V, S> HashMap<K, V, S>\n+where\n+    K: Eq + Hash,\n+    S: BuildHasher,\n+{\n     /// Reserves capacity for at least `additional` more elements to be inserted\n     /// in the `HashMap`. The collection may reserve more space to avoid\n     /// frequent reallocations.\n@@ -984,9 +984,8 @@ where\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> Debug for HashMap<K, V, S>\n where\n-    K: Eq + Hash + Debug,\n+    K: Debug,\n     V: Debug,\n-    S: BuildHasher,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_map().entries(self.iter()).finish()\n@@ -996,8 +995,7 @@ where\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S> Default for HashMap<K, V, S>\n where\n-    K: Eq + Hash,\n-    S: BuildHasher + Default,\n+    S: Default,\n {\n     /// Creates an empty `HashMap<K, V, S>`, with the `Default` value for the hasher.\n     #[inline]"}, {"sha": "1ad99f03703dd2da15616898a956d59b99d2efb2", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -110,7 +110,7 @@ pub struct HashSet<T, S = RandomState> {\n     map: HashMap<T, (), S>,\n }\n \n-impl<T: Hash + Eq> HashSet<T, RandomState> {\n+impl<T> HashSet<T, RandomState> {\n     /// Creates an empty `HashSet`.\n     ///\n     /// The hash set is initially created with a capacity of 0, so it will not allocate until it\n@@ -261,13 +261,7 @@ impl<T, S> HashSet<T, S> {\n     pub fn clear(&mut self) {\n         self.map.clear()\n     }\n-}\n \n-impl<T, S> HashSet<T, S>\n-where\n-    T: Eq + Hash,\n-    S: BuildHasher,\n-{\n     /// Creates a new empty hash set which will use the given hasher to hash\n     /// keys.\n     ///\n@@ -340,7 +334,13 @@ where\n     pub fn hasher(&self) -> &S {\n         self.map.hasher()\n     }\n+}\n \n+impl<T, S> HashSet<T, S>\n+where\n+    T: Eq + Hash,\n+    S: BuildHasher,\n+{\n     /// Reserves capacity for at least `additional` more elements to be inserted\n     /// in the `HashSet`. The collection may reserve more space to avoid\n     /// frequent reallocations.\n@@ -928,8 +928,7 @@ where\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S> fmt::Debug for HashSet<T, S>\n where\n-    T: Eq + Hash + fmt::Debug,\n-    S: BuildHasher,\n+    T: fmt::Debug,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_set().entries(self.iter()).finish()\n@@ -977,8 +976,7 @@ where\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S> Default for HashSet<T, S>\n where\n-    T: Eq + Hash,\n-    S: BuildHasher + Default,\n+    S: Default,\n {\n     /// Creates an empty `HashSet<T, S>` with the `Default` value for the hasher.\n     #[inline]"}, {"sha": "5a53695a8466b5e52e075dc7bd646b62b5702a17", "filename": "src/libstd/sys/sgx/args.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fargs.rs?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -22,12 +22,7 @@ pub unsafe fn init(argc: isize, argv: *const *const u8) {\n     }\n }\n \n-pub unsafe fn cleanup() {\n-    let args = ARGS.swap(0, Ordering::Relaxed);\n-    if args != 0 {\n-        drop(Box::<ArgsStore>::from_raw(args as _))\n-    }\n-}\n+pub unsafe fn cleanup() {}\n \n pub fn args() -> Args {\n     let args = unsafe { (ARGS.load(Ordering::Relaxed) as *const ArgsStore).as_ref() };"}, {"sha": "760d2b433c87aa99148005214b1a2758374c265d", "filename": "src/test/ui/associated-types/associated-types-project-from-hrtb-in-fn.fixed", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-fn.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-fn.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-fn.fixed?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -0,0 +1,37 @@\n+#![allow(dead_code, unused_variables)]\n+// run-rustfix\n+// Check projection of an associated type out of a higher-ranked trait-bound\n+// in the context of a function signature.\n+\n+pub trait Foo<T> {\n+    type A;\n+\n+    fn get(&self, t: T) -> Self::A;\n+}\n+\n+fn foo2<I : for<'x> Foo<&'x isize>>(\n+    x: <I as Foo<&isize>>::A)\n+    //~^ ERROR cannot extract an associated type from a higher-ranked trait bound in this context\n+{\n+    // This case is illegal because we have to instantiate `'x`, and\n+    // we don't know what region to instantiate it with.\n+    //\n+    // This could perhaps be made equivalent to the examples below,\n+    // specifically for fn signatures.\n+}\n+\n+fn foo3<I : for<'x> Foo<&'x isize>>(\n+    x: <I as Foo<&isize>>::A)\n+{\n+    // OK, in this case we spelled out the precise regions involved, though we left one of\n+    // them anonymous.\n+}\n+\n+fn foo4<'a, I : for<'x> Foo<&'x isize>>(\n+    x: <I as Foo<&'a isize>>::A)\n+{\n+    // OK, in this case we spelled out the precise regions involved.\n+}\n+\n+\n+pub fn main() {}"}, {"sha": "6eb584ea645ac4b6eb19a75956afcf7283972103", "filename": "src/test/ui/associated-types/associated-types-project-from-hrtb-in-fn.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-fn.rs?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -1,3 +1,5 @@\n+#![allow(dead_code, unused_variables)]\n+// run-rustfix\n // Check projection of an associated type out of a higher-ranked trait-bound\n // in the context of a function signature.\n "}, {"sha": "f2137f68665db3c7db89f63becf75f3404b18357", "filename": "src/test/ui/associated-types/associated-types-project-from-hrtb-in-fn.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-fn.stderr?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -1,8 +1,8 @@\n error[E0212]: cannot extract an associated type from a higher-ranked trait bound in this context\n-  --> $DIR/associated-types-project-from-hrtb-in-fn.rs:11:8\n+  --> $DIR/associated-types-project-from-hrtb-in-fn.rs:13:8\n    |\n LL |     x: I::A)\n-   |        ^^^^\n+   |        ^^^^ help: use a fully qualified path with inferred lifetimes: `<I as Foo<&isize>>::A`\n \n error: aborting due to previous error\n "}, {"sha": "8a5777d4d7cb519d31b78dba1fc6e82eb6210c94", "filename": "src/test/ui/associated-types/associated-types-project-from-hrtb-in-struct.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-struct.rs?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -7,18 +7,25 @@ pub trait Foo<T> {\n     fn get(&self, t: T) -> Self::A;\n }\n \n-struct SomeStruct<I : for<'x> Foo<&'x isize>> {\n+struct SomeStruct<I: for<'x> Foo<&'x isize>> {\n     field: I::A\n     //~^ ERROR cannot extract an associated type from a higher-ranked trait bound in this context\n }\n \n+enum SomeEnum<I: for<'x> Foo<&'x isize>> {\n+    TupleVariant(I::A),\n+    //~^ ERROR cannot extract an associated type from a higher-ranked trait bound in this context\n+    StructVariant { field: I::A },\n+    //~^ ERROR cannot extract an associated type from a higher-ranked trait bound in this context\n+}\n+\n // FIXME(eddyb) This one doesn't even compile because of the unsupported syntax.\n \n // struct AnotherStruct<I : for<'x> Foo<&'x isize>> {\n //     field: <I as for<'y> Foo<&'y isize>>::A\n // }\n \n-struct YetAnotherStruct<'a, I : for<'x> Foo<&'x isize>> {\n+struct YetAnotherStruct<'a, I: for<'x> Foo<&'x isize>> {\n     field: <I as Foo<&'a isize>>::A\n }\n "}, {"sha": "c71bc70ea6c4e778fd645839f2ccefcf0ec6e5b6", "filename": "src/test/ui/associated-types/associated-types-project-from-hrtb-in-struct.stderr", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-struct.stderr?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -3,6 +3,38 @@ error[E0212]: cannot extract an associated type from a higher-ranked trait bound\n    |\n LL |     field: I::A\n    |            ^^^^\n+   |\n+help: use a fully qualified path with explicit lifetimes\n+   |\n+LL | struct SomeStruct<'a, I: for<'x> Foo<&'x isize>> {\n+LL |     field: <I as Foo<&'a isize>>::A\n+   |\n+\n+error[E0212]: cannot extract an associated type from a higher-ranked trait bound in this context\n+  --> $DIR/associated-types-project-from-hrtb-in-struct.rs:16:18\n+   |\n+LL |     TupleVariant(I::A),\n+   |                  ^^^^\n+   |\n+help: use a fully qualified path with explicit lifetimes\n+   |\n+LL | enum SomeEnum<'a, I: for<'x> Foo<&'x isize>> {\n+LL |     TupleVariant(<I as Foo<&'a isize>>::A),\n+   |\n+\n+error[E0212]: cannot extract an associated type from a higher-ranked trait bound in this context\n+  --> $DIR/associated-types-project-from-hrtb-in-struct.rs:18:28\n+   |\n+LL |     StructVariant { field: I::A },\n+   |                            ^^^^\n+   |\n+help: use a fully qualified path with explicit lifetimes\n+   |\n+LL | enum SomeEnum<'a, I: for<'x> Foo<&'x isize>> {\n+LL |     TupleVariant(I::A),\n+LL |\n+LL |     StructVariant { field: <I as Foo<&'a isize>>::A },\n+   |\n \n-error: aborting due to previous error\n+error: aborting due to 3 previous errors\n "}, {"sha": "acf32bccbecfdf22db7c42d611336455ddf0ddb1", "filename": "src/test/ui/associated-types/associated-types-project-from-hrtb-in-trait-method.fixed", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-trait-method.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-trait-method.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-trait-method.fixed?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -0,0 +1,38 @@\n+#![allow(dead_code)]\n+// run-rustfix\n+// Check projection of an associated type out of a higher-ranked trait-bound\n+// in the context of a method definition in a trait.\n+\n+pub trait Foo<T> {\n+    type A;\n+\n+    fn get(&self, t: T) -> Self::A;\n+}\n+\n+trait SomeTrait<I : for<'x> Foo<&'x isize>> {\n+    fn some_method(&self, arg: <I as Foo<&isize>>::A);\n+    //~^ ERROR cannot extract an associated type from a higher-ranked trait bound in this context\n+}\n+\n+trait AnotherTrait<I : for<'x> Foo<&'x isize>> {\n+    fn some_method(&self, arg: <I as Foo<&isize>>::A);\n+}\n+\n+trait YetAnotherTrait<I : for<'x> Foo<&'x isize>> {\n+    fn some_method<'a>(&self, arg: <I as Foo<&'a isize>>::A);\n+}\n+\n+trait Banana<'a> {\n+    type Assoc: Default;\n+}\n+\n+struct Peach<X>(std::marker::PhantomData<X>);\n+\n+impl<X: for<'a> Banana<'a>> Peach<X> {\n+    fn mango(&self) -> <X as Banana<'_>>::Assoc {\n+    //~^ ERROR cannot extract an associated type from a higher-ranked trait bound in this context\n+        Default::default()\n+    }\n+}\n+\n+pub fn main() {}"}, {"sha": "a249f89685e3983098d1d708416636d39ae46e5f", "filename": "src/test/ui/associated-types/associated-types-project-from-hrtb-in-trait-method.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-trait-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-trait-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-trait-method.rs?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -1,3 +1,5 @@\n+#![allow(dead_code)]\n+// run-rustfix\n // Check projection of an associated type out of a higher-ranked trait-bound\n // in the context of a method definition in a trait.\n \n@@ -20,4 +22,17 @@ trait YetAnotherTrait<I : for<'x> Foo<&'x isize>> {\n     fn some_method<'a>(&self, arg: <I as Foo<&'a isize>>::A);\n }\n \n+trait Banana<'a> {\n+    type Assoc: Default;\n+}\n+\n+struct Peach<X>(std::marker::PhantomData<X>);\n+\n+impl<X: for<'a> Banana<'a>> Peach<X> {\n+    fn mango(&self) -> X::Assoc {\n+    //~^ ERROR cannot extract an associated type from a higher-ranked trait bound in this context\n+        Default::default()\n+    }\n+}\n+\n pub fn main() {}"}, {"sha": "a37fec244933cb172ec1a953e7b89e405e4b2b27", "filename": "src/test/ui/associated-types/associated-types-project-from-hrtb-in-trait-method.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-trait-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-trait-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-project-from-hrtb-in-trait-method.stderr?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -1,8 +1,14 @@\n error[E0212]: cannot extract an associated type from a higher-ranked trait bound in this context\n-  --> $DIR/associated-types-project-from-hrtb-in-trait-method.rs:11:32\n+  --> $DIR/associated-types-project-from-hrtb-in-trait-method.rs:13:32\n    |\n LL |     fn some_method(&self, arg: I::A);\n-   |                                ^^^^\n+   |                                ^^^^ help: use a fully qualified path with inferred lifetimes: `<I as Foo<&isize>>::A`\n \n-error: aborting due to previous error\n+error[E0212]: cannot extract an associated type from a higher-ranked trait bound in this context\n+  --> $DIR/associated-types-project-from-hrtb-in-trait-method.rs:32:24\n+   |\n+LL |     fn mango(&self) -> X::Assoc {\n+   |                        ^^^^^^^^ help: use a fully qualified path with inferred lifetimes: `<X as Banana<'_>>::Assoc`\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "8397d204f35cf76e9239a904fd4d865da38607c2", "filename": "src/test/ui/const-generics/array-impls/core-traits-no-impls-length-33.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Fcore-traits-no-impls-length-33.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Fcore-traits-no-impls-length-33.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Fcore-traits-no-impls-length-33.rs?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -6,7 +6,6 @@ pub fn no_debug() {\n pub fn no_hash() {\n     use std::collections::HashSet;\n     let mut set = HashSet::new();\n-    //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n     set.insert([0_usize; 33]);\n     //~^ ERROR arrays only have std trait implementations for lengths 0..=32\n }"}, {"sha": "781a179624e77644a8af385969537b1b9389f8d3", "filename": "src/test/ui/const-generics/array-impls/core-traits-no-impls-length-33.stderr", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Fcore-traits-no-impls-length-33.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Fcore-traits-no-impls-length-33.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Fcore-traits-no-impls-length-33.stderr?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -9,24 +9,15 @@ LL |     println!(\"{:?}\", [0_usize; 33]);\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: arrays only have std trait implementations for lengths 0..=32\n-  --> $DIR/core-traits-no-impls-length-33.rs:10:16\n+  --> $DIR/core-traits-no-impls-length-33.rs:9:16\n    |\n LL |     set.insert([0_usize; 33]);\n    |                ^^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[usize; 33]`\n    |\n    = note: required because of the requirements on the impl of `std::cmp::Eq` for `[usize; 33]`\n \n-error[E0277]: arrays only have std trait implementations for lengths 0..=32\n-  --> $DIR/core-traits-no-impls-length-33.rs:8:19\n-   |\n-LL |     let mut set = HashSet::new();\n-   |                   ^^^^^^^^^^^^ the trait `std::array::LengthAtMost32` is not implemented for `[usize; 33]`\n-   |\n-   = note: required because of the requirements on the impl of `std::cmp::Eq` for `[usize; 33]`\n-   = note: required by `std::collections::HashSet::<T>::new`\n-\n error[E0369]: binary operation `==` cannot be applied to type `[usize; 33]`\n-  --> $DIR/core-traits-no-impls-length-33.rs:15:19\n+  --> $DIR/core-traits-no-impls-length-33.rs:14:19\n    |\n LL |     [0_usize; 33] == [1_usize; 33]\n    |     ------------- ^^ ------------- [usize; 33]\n@@ -36,7 +27,7 @@ LL |     [0_usize; 33] == [1_usize; 33]\n    = note: an implementation of `std::cmp::PartialEq` might be missing for `[usize; 33]`\n \n error[E0369]: binary operation `<` cannot be applied to type `[usize; 33]`\n-  --> $DIR/core-traits-no-impls-length-33.rs:20:19\n+  --> $DIR/core-traits-no-impls-length-33.rs:19:19\n    |\n LL |     [0_usize; 33] < [1_usize; 33]\n    |     ------------- ^ ------------- [usize; 33]\n@@ -46,7 +37,7 @@ LL |     [0_usize; 33] < [1_usize; 33]\n    = note: an implementation of `std::cmp::PartialOrd` might be missing for `[usize; 33]`\n \n error[E0277]: the trait bound `&[usize; 33]: std::iter::IntoIterator` is not satisfied\n-  --> $DIR/core-traits-no-impls-length-33.rs:25:14\n+  --> $DIR/core-traits-no-impls-length-33.rs:24:14\n    |\n LL |     for _ in &[0_usize; 33] {\n    |              ^^^^^^^^^^^^^^ the trait `std::iter::IntoIterator` is not implemented for `&[usize; 33]`\n@@ -58,7 +49,7 @@ LL |     for _ in &[0_usize; 33] {\n              <&'a mut [T] as std::iter::IntoIterator>\n    = note: required by `std::iter::IntoIterator::into_iter`\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 5 previous errors\n \n Some errors have detailed explanations: E0277, E0369.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "cfcb94737be6f46c8bae504d2b06551890121796", "filename": "src/test/ui/generator/static-not-unpin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fgenerator%2Fstatic-not-unpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fgenerator%2Fstatic-not-unpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fstatic-not-unpin.rs?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -11,5 +11,5 @@ fn main() {\n     let mut generator = static || {\n         yield;\n     };\n-    assert_unpin(generator); //~ ERROR std::marker::Unpin` is not satisfied\n+    assert_unpin(generator); //~ ERROR E0277\n }"}, {"sha": "6512d67319b0b6327cf6666040f80711ae144167", "filename": "src/test/ui/generator/static-not-unpin.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fgenerator%2Fstatic-not-unpin.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fgenerator%2Fstatic-not-unpin.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fstatic-not-unpin.stderr?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -1,4 +1,4 @@\n-error[E0277]: the trait bound `[static generator@$DIR/static-not-unpin.rs:11:25: 13:6 _]: std::marker::Unpin` is not satisfied\n+error[E0277]: `[static generator@$DIR/static-not-unpin.rs:11:25: 13:6 _]` cannot be unpinned\n   --> $DIR/static-not-unpin.rs:14:18\n    |\n LL | fn assert_unpin<T: Unpin>(_: T) {"}, {"sha": "0a1686eac9d349ec3320a0486a160e0bf39a7024", "filename": "src/test/ui/suggestions/expected-boxed-future-isnt-pinned.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.rs?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -0,0 +1,29 @@\n+// edition:2018\n+#![allow(dead_code)]\n+use std::future::Future;\n+use std::pin::Pin;\n+\n+type BoxFuture<'a, T> = Pin<Box<dyn Future<Output = T> + Send + 'a>>;\n+//   ^^^^^^^^^ This would come from the `futures` crate in real code.\n+\n+fn foo<F: Future<Output=i32> + Send + 'static>(x: F) -> BoxFuture<'static, i32> {\n+    // We could instead use an `async` block, but this way we have no std spans.\n+    x //~ ERROR mismatched types\n+}\n+\n+// FIXME: uncomment these once this commit is in Beta and we can rely on `rustc_on_unimplemented`\n+//        having filtering for `Self` being a trait.\n+//\n+// fn bar<F: Future<Output=i32> + Send + 'static>(x: F) -> BoxFuture<'static, i32> {\n+//     Box::new(x)\n+// }\n+//\n+// fn baz<F: Future<Output=i32> + Send + 'static>(x: F) -> BoxFuture<'static, i32> {\n+//     Pin::new(x)\n+// }\n+//\n+// fn qux<F: Future<Output=i32> + Send + 'static>(x: F) -> BoxFuture<'static, i32> {\n+//     Pin::new(Box::new(x))\n+// }\n+\n+fn main() {}"}, {"sha": "48d941283b62de912189fe0811766552ea3fe001", "filename": "src/test/ui/suggestions/expected-boxed-future-isnt-pinned.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fexpected-boxed-future-isnt-pinned.stderr?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -0,0 +1,20 @@\n+error[E0308]: mismatched types\n+  --> $DIR/expected-boxed-future-isnt-pinned.rs:11:5\n+   |\n+LL | fn foo<F: Future<Output=i32> + Send + 'static>(x: F) -> BoxFuture<'static, i32> {\n+   |        - this type parameter                            ----------------------- expected `std::pin::Pin<std::boxed::Box<(dyn std::future::Future<Output = i32> + std::marker::Send + 'static)>>` because of return type\n+LL |     // We could instead use an `async` block, but this way we have no std spans.\n+LL |     x\n+   |     ^\n+   |     |\n+   |     expected struct `std::pin::Pin`, found type parameter `F`\n+   |     help: you need to pin and box this expression: `Box::pin(x)`\n+   |\n+   = note:      expected struct `std::pin::Pin<std::boxed::Box<(dyn std::future::Future<Output = i32> + std::marker::Send + 'static)>>`\n+           found type parameter `F`\n+   = help: type parameters must be constrained to match other types\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "2f844b4a05f5f6bc884a35b0ee2ad11b8b3a6c85", "filename": "src/test/ui/type-alias-impl-trait/issue-67844-nested-opaque.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-67844-nested-opaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6eaceedeeda764056eb0e2134735793533770d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-67844-nested-opaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-67844-nested-opaque.rs?ref=2e6eaceedeeda764056eb0e2134735793533770d", "patch": "@@ -0,0 +1,32 @@\n+// check-pass\n+// Regression test for issue #67844\n+// Ensures that we properly handle nested TAIT occurences\n+// with generic parameters\n+\n+#![feature(type_alias_impl_trait)]\n+\n+trait WithAssoc { type AssocType; }\n+\n+trait WithParam<A> {}\n+\n+type Return<A> = impl WithAssoc<AssocType = impl WithParam<A>>;\n+\n+struct MyParam;\n+impl<A> WithParam<A> for MyParam {}\n+\n+struct MyStruct;\n+\n+impl WithAssoc for MyStruct {\n+    type AssocType = MyParam;\n+}\n+\n+\n+fn my_fun<A>() -> Return<A> {\n+    MyStruct\n+}\n+\n+fn my_other_fn<A>() -> impl WithAssoc<AssocType = impl WithParam<A>> {\n+    MyStruct\n+}\n+\n+fn main() {}"}]}