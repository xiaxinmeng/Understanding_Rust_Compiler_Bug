{"sha": "07ca1ab1ec32ac99a61312ec07d66db5f3657040", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3Y2ExYWIxZWMzMmFjOTlhNjEzMTJlYzA3ZDY2ZGI1ZjM2NTcwNDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-23T03:56:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-09-23T03:56:27Z"}, "message": "Auto merge of #28585 - ranma42:simpler-panic, r=alexcrichton\n\nThis is part of some cleanup I did while investigating #28129.\r\nThis also ensures that `on_panic` is run even if the user has registered too many callbacks.", "tree": {"sha": "2263ec09414f3b1c117a44df24cd00d84000f985", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2263ec09414f3b1c117a44df24cd00d84000f985"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07ca1ab1ec32ac99a61312ec07d66db5f3657040", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07ca1ab1ec32ac99a61312ec07d66db5f3657040", "html_url": "https://github.com/rust-lang/rust/commit/07ca1ab1ec32ac99a61312ec07d66db5f3657040", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07ca1ab1ec32ac99a61312ec07d66db5f3657040/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cefe5f25b27b27c9d2f8685a7e16c852f9f77f60", "url": "https://api.github.com/repos/rust-lang/rust/commits/cefe5f25b27b27c9d2f8685a7e16c852f9f77f60", "html_url": "https://github.com/rust-lang/rust/commit/cefe5f25b27b27c9d2f8685a7e16c852f9f77f60"}, {"sha": "c6d277ade642a8cf166d6e4706add90fb9181ec2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6d277ade642a8cf166d6e4706add90fb9181ec2", "html_url": "https://github.com/rust-lang/rust/commit/c6d277ade642a8cf166d6e4706add90fb9181ec2"}], "stats": {"total": 88, "additions": 5, "deletions": 83}, "files": [{"sha": "8148bb6b7b82e6de8d3457950868477516640537", "filename": "src/libstd/sys/common/unwind/mod.rs", "status": "modified", "additions": 5, "deletions": 83, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/07ca1ab1ec32ac99a61312ec07d66db5f3657040/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07ca1ab1ec32ac99a61312ec07d66db5f3657040/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fmod.rs?ref=07ca1ab1ec32ac99a61312ec07d66db5f3657040", "patch": "@@ -92,23 +92,6 @@ pub mod imp;\n #[path = \"gcc.rs\"] #[doc(hidden)]\n pub mod imp;\n \n-pub type Callback = fn(msg: &(Any + Send), file: &'static str, line: u32);\n-\n-// Variables used for invoking callbacks when a thread starts to unwind.\n-//\n-// For more information, see below.\n-const MAX_CALLBACKS: usize = 16;\n-static CALLBACKS: [atomic::AtomicUsize; MAX_CALLBACKS] =\n-        [atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n-         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n-         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n-         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n-         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n-         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n-         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0),\n-         atomic::AtomicUsize::new(0), atomic::AtomicUsize::new(0)];\n-static CALLBACK_CNT: atomic::AtomicUsize = atomic::AtomicUsize::new(0);\n-\n thread_local! { static PANICKING: Cell<bool> = Cell::new(false) }\n \n /// Invoke a closure, capturing the cause of panic if one occurs.\n@@ -246,45 +229,11 @@ pub fn begin_unwind<M: Any + Send>(msg: M, file_line: &(&'static str, u32)) -> !\n #[inline(never)] #[cold] // this is the slow path, please never inline this\n fn begin_unwind_inner(msg: Box<Any + Send>,\n                       file_line: &(&'static str, u32)) -> ! {\n-    // Make sure the default failure handler is registered before we look at the\n-    // callbacks. We also use a raw sys-based mutex here instead of a\n-    // `std::sync` one as accessing TLS can cause weird recursive problems (and\n-    // we don't need poison checking).\n-    unsafe {\n-        static LOCK: Mutex = Mutex::new();\n-        static mut INIT: bool = false;\n-        LOCK.lock();\n-        if !INIT {\n-            register(panicking::on_panic);\n-            INIT = true;\n-        }\n-        LOCK.unlock();\n-    }\n+    let (file, line) = *file_line;\n \n-    // First, invoke call the user-defined callbacks triggered on thread panic.\n-    //\n-    // By the time that we see a callback has been registered (by reading\n-    // MAX_CALLBACKS), the actual callback itself may have not been stored yet,\n-    // so we just chalk it up to a race condition and move on to the next\n-    // callback. Additionally, CALLBACK_CNT may briefly be higher than\n-    // MAX_CALLBACKS, so we're sure to clamp it as necessary.\n-    let callbacks = {\n-        let amt = CALLBACK_CNT.load(Ordering::SeqCst);\n-        &CALLBACKS[..cmp::min(amt, MAX_CALLBACKS)]\n-    };\n-    for cb in callbacks {\n-        match cb.load(Ordering::SeqCst) {\n-            0 => {}\n-            n => {\n-                let f: Callback = unsafe { mem::transmute(n) };\n-                let (file, line) = *file_line;\n-                f(&*msg, file, line);\n-            }\n-        }\n-    };\n+    // First, invoke the default panic handler.\n+    panicking::on_panic(&*msg, file, line);\n \n-    // Now that we've run all the necessary unwind callbacks, we actually\n-    // perform the unwinding.\n     if panicking() {\n         // If a thread panics while it's already unwinding then we\n         // have limited options. Currently our preference is to\n@@ -295,34 +244,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>,\n         unsafe { intrinsics::abort() }\n     }\n     PANICKING.with(|s| s.set(true));\n-    rust_panic(msg);\n-}\n \n-/// Register a callback to be invoked when a thread unwinds.\n-///\n-/// This is an unsafe and experimental API which allows for an arbitrary\n-/// callback to be invoked when a thread panics. This callback is invoked on both\n-/// the initial unwinding and a double unwinding if one occurs. Additionally,\n-/// the local `Thread` will be in place for the duration of the callback, and\n-/// the callback must ensure that it remains in place once the callback returns.\n-///\n-/// Only a limited number of callbacks can be registered, and this function\n-/// returns whether the callback was successfully registered or not. It is not\n-/// currently possible to unregister a callback once it has been registered.\n-pub unsafe fn register(f: Callback) -> bool {\n-    match CALLBACK_CNT.fetch_add(1, Ordering::SeqCst) {\n-        // The invocation code has knowledge of this window where the count has\n-        // been incremented, but the callback has not been stored. We're\n-        // guaranteed that the slot we're storing into is 0.\n-        n if n < MAX_CALLBACKS => {\n-            let prev = CALLBACKS[n].swap(mem::transmute(f), Ordering::SeqCst);\n-            rtassert!(prev == 0);\n-            true\n-        }\n-        // If we accidentally bumped the count too high, pull it back.\n-        _ => {\n-            CALLBACK_CNT.store(MAX_CALLBACKS, Ordering::SeqCst);\n-            false\n-        }\n-    }\n+    // Finally, perform the unwinding.\n+    rust_panic(msg);\n }"}]}