{"sha": "479d1f7eec22c3564867223e2093f14774092528", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3OWQxZjdlZWMyMmMzNTY0ODY3MjIzZTIwOTNmMTQ3NzQwOTI1Mjg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-12-12T14:35:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-12T14:35:38Z"}, "message": "Merge #6818\n\n6818: Add Lifetimes to the HIR r=matklad a=Veykril\n\nThis doesn't handle resolve yet as I don't know yet how that will be used. I'll get to that once I start moving the lifetime reference PR to the hir.\r\n\r\nThis also adds a new `hir` name type for lifetimes and labels, `hir::LifetimeName`.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "0b7b74f69d33ca5c86267ace1ac38c2c15248e50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b7b74f69d33ca5c86267ace1ac38c2c15248e50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/479d1f7eec22c3564867223e2093f14774092528", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf1NU6CRBK7hj4Ov3rIwAAdHIIAHk43YLQ/IUSahrtxBmaGUM7\nIcufbyhvghp31Dn475zJ322mhvNFy1SMBDeLq7z1QVqclMZ57w46kcKQ6OGo8ko0\nuEc3rDdtUaJgEW8HwJAhAmJP6JvNo87LinwJvwhx4/WDblml8uumOFRd4lqZzymY\nj/qkxWhf3OIzkOSGqnbek5q59/dZ+fCGFhK+JGPRQIXjiJgHaN10iXuWBsV7ju3p\npKEuLxynSSm3RZg4pneL0987y0RibkP/tsjkNR1OL5q4KJg0d7ce7m6DLIKZjDGb\nNp92JuMMEP79ouMxyHP0e7iDA8RQQu/79ek5yfrAEqhBqFcQoBRKKPHd3EV46ZU=\n=dZsT\n-----END PGP SIGNATURE-----\n", "payload": "tree 0b7b74f69d33ca5c86267ace1ac38c2c15248e50\nparent 64a1c9810d5979cfd0fe6e7c385d9ca3caac2163\nparent 11f86641829273e2b2b7023c2028bb475fce58ee\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1607783738 +0000\ncommitter GitHub <noreply@github.com> 1607783738 +0000\n\nMerge #6818\n\n6818: Add Lifetimes to the HIR r=matklad a=Veykril\n\nThis doesn't handle resolve yet as I don't know yet how that will be used. I'll get to that once I start moving the lifetime reference PR to the hir.\r\n\r\nThis also adds a new `hir` name type for lifetimes and labels, `hir::LifetimeName`.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/479d1f7eec22c3564867223e2093f14774092528", "html_url": "https://github.com/rust-lang/rust/commit/479d1f7eec22c3564867223e2093f14774092528", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/479d1f7eec22c3564867223e2093f14774092528/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64a1c9810d5979cfd0fe6e7c385d9ca3caac2163", "url": "https://api.github.com/repos/rust-lang/rust/commits/64a1c9810d5979cfd0fe6e7c385d9ca3caac2163", "html_url": "https://github.com/rust-lang/rust/commit/64a1c9810d5979cfd0fe6e7c385d9ca3caac2163"}, {"sha": "11f86641829273e2b2b7023c2028bb475fce58ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/11f86641829273e2b2b7023c2028bb475fce58ee", "html_url": "https://github.com/rust-lang/rust/commit/11f86641829273e2b2b7023c2028bb475fce58ee"}], "stats": {"total": 345, "additions": 249, "deletions": 96}, "files": [{"sha": "da94e9987c6637c57f2d8cc8b2cf01eb6a3929b5", "filename": "crates/assists/src/ast_transform.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/479d1f7eec22c3564867223e2093f14774092528/crates%2Fassists%2Fsrc%2Fast_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/479d1f7eec22c3564867223e2093f14774092528/crates%2Fassists%2Fsrc%2Fast_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fast_transform.rs?ref=479d1f7eec22c3564867223e2093f14774092528", "patch": "@@ -89,7 +89,7 @@ impl<'a> SubstituteTypeParams<'a> {\n         let substs = get_syntactic_substs(impl_def).unwrap_or_default();\n         let generic_def: hir::GenericDef = trait_.into();\n         let substs_by_param: FxHashMap<_, _> = generic_def\n-            .params(source_scope.db)\n+            .type_params(source_scope.db)\n             .into_iter()\n             // this is a trait impl, so we need to skip the first type parameter -- this is a bit hacky\n             .skip(1)"}, {"sha": "fcc42c6bbc4ef01fae8f43df60885b1e330ab64a", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 42, "deletions": 5, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=479d1f7eec22c3564867223e2093f14774092528", "patch": "@@ -19,8 +19,9 @@ use hir_def::{\n     src::HasSource as _,\n     type_ref::{Mutability, TypeRef},\n     AdtId, AssocContainerId, AssocItemId, AssocItemLoc, AttrDefId, ConstId, DefWithBodyId, EnumId,\n-    FunctionId, GenericDefId, HasModule, ImplId, LocalEnumVariantId, LocalFieldId, LocalModuleId,\n-    Lookup, ModuleId, StaticId, StructId, TraitId, TypeAliasId, TypeParamId, UnionId,\n+    FunctionId, GenericDefId, HasModule, ImplId, LifetimeParamId, LocalEnumVariantId, LocalFieldId,\n+    LocalModuleId, Lookup, ModuleId, StaticId, StructId, TraitId, TypeAliasId, TypeParamId,\n+    UnionId,\n };\n use hir_def::{find_path::PrefixKind, item_scope::ItemInNs, visibility::Visibility};\n use hir_expand::{\n@@ -831,7 +832,7 @@ impl SelfParam {\n             .params\n             .first()\n             .map(|param| match *param {\n-                TypeRef::Reference(_, mutability) => mutability.into(),\n+                TypeRef::Reference(.., mutability) => mutability.into(),\n                 _ => Access::Owned,\n             })\n             .unwrap_or(Access::Owned)\n@@ -1098,8 +1099,25 @@ impl_from!(\n );\n \n impl GenericDef {\n-    pub fn params(self, db: &dyn HirDatabase) -> Vec<TypeParam> {\n-        let generics: Arc<hir_def::generics::GenericParams> = db.generic_params(self.into());\n+    pub fn params(self, db: &dyn HirDatabase) -> Vec<GenericParam> {\n+        let generics = db.generic_params(self.into());\n+        let ty_params = generics\n+            .types\n+            .iter()\n+            .map(|(local_id, _)| TypeParam { id: TypeParamId { parent: self.into(), local_id } })\n+            .map(GenericParam::TypeParam);\n+        let lt_params = generics\n+            .lifetimes\n+            .iter()\n+            .map(|(local_id, _)| LifetimeParam {\n+                id: LifetimeParamId { parent: self.into(), local_id },\n+            })\n+            .map(GenericParam::LifetimeParam);\n+        ty_params.chain(lt_params).collect()\n+    }\n+\n+    pub fn type_params(self, db: &dyn HirDatabase) -> Vec<TypeParam> {\n+        let generics = db.generic_params(self.into());\n         generics\n             .types\n             .iter()\n@@ -1175,6 +1193,13 @@ impl Local {\n     }\n }\n \n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum GenericParam {\n+    TypeParam(TypeParam),\n+    LifetimeParam(LifetimeParam),\n+}\n+impl_from!(TypeParam, LifetimeParam for GenericParam);\n+\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct TypeParam {\n     pub(crate) id: TypeParamId,\n@@ -1215,6 +1240,18 @@ impl TypeParam {\n     }\n }\n \n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub struct LifetimeParam {\n+    pub(crate) id: LifetimeParamId,\n+}\n+\n+impl LifetimeParam {\n+    pub fn name(self, db: &dyn HirDatabase) -> Name {\n+        let params = db.generic_params(self.id.parent);\n+        params.lifetimes[self.id.local_id].name.clone()\n+    }\n+}\n+\n // FIXME: rename from `ImplDef` to `Impl`\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ImplDef {"}, {"sha": "0f399a2c6ec493db60026a639497b4949a5a1bc3", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=479d1f7eec22c3564867223e2093f14774092528", "patch": "@@ -35,8 +35,8 @@ pub use crate::{\n     code_model::{\n         Access, Adt, AsAssocItem, AssocItem, AssocItemContainer, Callable, CallableKind, Const,\n         Crate, CrateDependency, DefWithBody, Enum, EnumVariant, Field, FieldSource, Function,\n-        GenericDef, HasVisibility, ImplDef, Local, MacroDef, Module, ModuleDef, ScopeDef, Static,\n-        Struct, Trait, Type, TypeAlias, TypeParam, Union, VariantDef,\n+        GenericDef, HasVisibility, ImplDef, LifetimeParam, Local, MacroDef, Module, ModuleDef,\n+        ScopeDef, Static, Struct, Trait, Type, TypeAlias, TypeParam, Union, VariantDef,\n     },\n     has_source::HasSource,\n     semantics::{PathResolution, Semantics, SemanticsScope},\n@@ -56,8 +56,9 @@ pub use hir_def::{\n     visibility::Visibility,\n };\n pub use hir_expand::{\n-    name::known, name::AsName, name::Name, ExpandResult, HirFileId, InFile, MacroCallId,\n-    MacroCallLoc, /* FIXME */ MacroDefId, MacroFile, Origin,\n+    name::{known, AsName, Name},\n+    ExpandResult, HirFileId, InFile, MacroCallId, MacroCallLoc, /* FIXME */ MacroDefId,\n+    MacroFile, Origin,\n };\n pub use hir_ty::display::HirDisplay;\n "}, {"sha": "5189c7e9f38d966444d9707132863376e7ad4b87", "filename": "crates/hir_def/src/generics.rs", "status": "modified", "additions": 48, "deletions": 21, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fgenerics.rs?ref=479d1f7eec22c3564867223e2093f14774092528", "patch": "@@ -21,7 +21,7 @@ use crate::{\n     keys,\n     src::HasChildSource,\n     src::HasSource,\n-    type_ref::{TypeBound, TypeRef},\n+    type_ref::{LifetimeRef, TypeBound, TypeRef},\n     AdtId, GenericDefId, LocalTypeParamId, Lookup, TypeParamId,\n };\n \n@@ -33,6 +33,12 @@ pub struct TypeParamData {\n     pub provenance: TypeParamProvenance,\n }\n \n+/// Data about a generic parameter (to a function, struct, impl, ...).\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct LifetimeParamData {\n+    pub name: Name,\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum TypeParamProvenance {\n     TypeParamList,\n@@ -44,7 +50,7 @@ pub enum TypeParamProvenance {\n #[derive(Clone, PartialEq, Eq, Debug, Default)]\n pub struct GenericParams {\n     pub types: Arena<TypeParamData>,\n-    // lifetimes: Arena<LocalLifetimeParamId, LifetimeParamData>,\n+    pub lifetimes: Arena<LifetimeParamData>,\n     pub where_predicates: Vec<WherePredicate>,\n }\n \n@@ -53,16 +59,17 @@ pub struct GenericParams {\n /// It might still result in multiple actual predicates though, because of\n /// associated type bindings like `Iterator<Item = u32>`.\n #[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct WherePredicate {\n-    pub target: WherePredicateTarget,\n-    pub bound: TypeBound,\n+pub enum WherePredicate {\n+    TypeBound { target: WherePredicateTypeTarget, bound: TypeBound },\n+    Lifetime { target: LifetimeRef, bound: LifetimeRef },\n }\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum WherePredicateTarget {\n+pub enum WherePredicateTypeTarget {\n     TypeRef(TypeRef),\n     /// For desugared where predicates that can directly refer to a type param.\n     TypeParam(LocalTypeParamId),\n+    // FIXME: ForLifetime(Vec<LifetimeParamId>, TypeRef)\n }\n \n type SourceMap = ArenaMap<LocalTypeParamId, Either<ast::Trait, ast::TypeParam>>;\n@@ -123,7 +130,7 @@ impl GenericParams {\n     }\n \n     fn new(db: &dyn DefDatabase, def: GenericDefId) -> (GenericParams, InFile<SourceMap>) {\n-        let mut generics = GenericParams { types: Arena::default(), where_predicates: Vec::new() };\n+        let mut generics = GenericParams::default();\n         let mut sm = ArenaMap::default();\n \n         // FIXME: add `: Sized` bound for everything except for `Self` in traits\n@@ -171,7 +178,7 @@ impl GenericParams {\n                 // add super traits as bounds on Self\n                 // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n                 let self_param = TypeRef::Path(name![Self].into());\n-                generics.fill_bounds(&lower_ctx, &src.value, self_param);\n+                generics.fill_bounds(&lower_ctx, &src.value, Either::Left(self_param));\n \n                 generics.fill(&lower_ctx, &mut sm, &src.value);\n                 src.file_id\n@@ -218,12 +225,12 @@ impl GenericParams {\n         &mut self,\n         lower_ctx: &LowerCtx,\n         node: &dyn ast::TypeBoundsOwner,\n-        type_ref: TypeRef,\n+        target: Either<TypeRef, LifetimeRef>,\n     ) {\n         for bound in\n             node.type_bound_list().iter().flat_map(|type_bound_list| type_bound_list.bounds())\n         {\n-            self.add_where_predicate_from_bound(lower_ctx, bound, type_ref.clone());\n+            self.add_where_predicate_from_bound(lower_ctx, bound, target.clone());\n         }\n     }\n \n@@ -246,19 +253,30 @@ impl GenericParams {\n             sm.insert(param_id, Either::Right(type_param.clone()));\n \n             let type_ref = TypeRef::Path(name.into());\n-            self.fill_bounds(&lower_ctx, &type_param, type_ref);\n+            self.fill_bounds(&lower_ctx, &type_param, Either::Left(type_ref));\n+        }\n+        for lifetime_param in params.lifetime_params() {\n+            let name = lifetime_param\n+                .lifetime_token()\n+                .map_or_else(Name::missing, |tok| Name::new_lifetime(&tok));\n+            let param = LifetimeParamData { name: name.clone() };\n+            let _param_id = self.lifetimes.alloc(param);\n+            let lifetime_ref = LifetimeRef::new_name(name);\n+            self.fill_bounds(&lower_ctx, &lifetime_param, Either::Right(lifetime_ref));\n         }\n     }\n \n     fn fill_where_predicates(&mut self, lower_ctx: &LowerCtx, where_clause: ast::WhereClause) {\n         for pred in where_clause.predicates() {\n-            let type_ref = match pred.ty() {\n-                Some(type_ref) => type_ref,\n-                None => continue,\n+            let target = if let Some(type_ref) = pred.ty() {\n+                Either::Left(TypeRef::from_ast(lower_ctx, type_ref))\n+            } else if let Some(lifetime_tok) = pred.lifetime_token() {\n+                Either::Right(LifetimeRef::from_token(lifetime_tok))\n+            } else {\n+                continue;\n             };\n-            let type_ref = TypeRef::from_ast(lower_ctx, type_ref);\n             for bound in pred.type_bound_list().iter().flat_map(|l| l.bounds()) {\n-                self.add_where_predicate_from_bound(lower_ctx, bound, type_ref.clone());\n+                self.add_where_predicate_from_bound(lower_ctx, bound, target.clone());\n             }\n         }\n     }\n@@ -267,15 +285,24 @@ impl GenericParams {\n         &mut self,\n         lower_ctx: &LowerCtx,\n         bound: ast::TypeBound,\n-        type_ref: TypeRef,\n+        target: Either<TypeRef, LifetimeRef>,\n     ) {\n         if bound.question_mark_token().is_some() {\n             // FIXME: remove this bound\n             return;\n         }\n         let bound = TypeBound::from_ast(lower_ctx, bound);\n-        self.where_predicates\n-            .push(WherePredicate { target: WherePredicateTarget::TypeRef(type_ref), bound });\n+        let predicate = match (target, bound) {\n+            (Either::Left(type_ref), bound) => WherePredicate::TypeBound {\n+                target: WherePredicateTypeTarget::TypeRef(type_ref),\n+                bound,\n+            },\n+            (Either::Right(lifetime), TypeBound::Lifetime(bound)) => {\n+                WherePredicate::Lifetime { target: lifetime, bound }\n+            }\n+            _ => return,\n+        };\n+        self.where_predicates.push(predicate);\n     }\n \n     pub(crate) fn fill_implicit_impl_trait_args(&mut self, type_ref: &TypeRef) {\n@@ -288,8 +315,8 @@ impl GenericParams {\n                 };\n                 let param_id = self.types.alloc(param);\n                 for bound in bounds {\n-                    self.where_predicates.push(WherePredicate {\n-                        target: WherePredicateTarget::TypeParam(param_id),\n+                    self.where_predicates.push(WherePredicate::TypeBound {\n+                        target: WherePredicateTypeTarget::TypeParam(param_id),\n                         bound: bound.clone(),\n                     });\n                 }"}, {"sha": "c6ada271e998158b7ff1434359a6d6588c277a54", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=479d1f7eec22c3564867223e2093f14774092528", "patch": "@@ -255,7 +255,7 @@ impl GenericParamsStorage {\n }\n \n static EMPTY_GENERICS: GenericParams =\n-    GenericParams { types: Arena::new(), where_predicates: Vec::new() };\n+    GenericParams { types: Arena::new(), lifetimes: Arena::new(), where_predicates: Vec::new() };\n \n #[derive(Default, Debug, Eq, PartialEq)]\n struct ItemTreeData {"}, {"sha": "f7ce2e26df8f5ee9848eedd6070a81ce9d66a91f", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=479d1f7eec22c3564867223e2093f14774092528", "patch": "@@ -13,6 +13,7 @@ use syntax::{\n use crate::{\n     attr::Attrs,\n     generics::{GenericParams, TypeParamData, TypeParamProvenance},\n+    type_ref::LifetimeRef,\n };\n \n use super::*;\n@@ -292,12 +293,16 @@ impl Ctx {\n                         let self_type = TypeRef::Path(name![Self].into());\n                         match self_param.kind() {\n                             ast::SelfParamKind::Owned => self_type,\n-                            ast::SelfParamKind::Ref => {\n-                                TypeRef::Reference(Box::new(self_type), Mutability::Shared)\n-                            }\n-                            ast::SelfParamKind::MutRef => {\n-                                TypeRef::Reference(Box::new(self_type), Mutability::Mut)\n-                            }\n+                            ast::SelfParamKind::Ref => TypeRef::Reference(\n+                                Box::new(self_type),\n+                                self_param.lifetime_token().map(LifetimeRef::from_token),\n+                                Mutability::Shared,\n+                            ),\n+                            ast::SelfParamKind::MutRef => TypeRef::Reference(\n+                                Box::new(self_type),\n+                                self_param.lifetime_token().map(LifetimeRef::from_token),\n+                                Mutability::Mut,\n+                            ),\n                         }\n                     }\n                 };\n@@ -629,8 +634,7 @@ impl Ctx {\n                 // add super traits as bounds on Self\n                 // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n                 let self_param = TypeRef::Path(name![Self].into());\n-                generics.fill_bounds(&self.body_ctx, trait_def, self_param);\n-\n+                generics.fill_bounds(&self.body_ctx, trait_def, Either::Left(self_param));\n                 generics.fill(&self.body_ctx, &mut sm, node);\n             }\n             GenericsOwner::Impl => {"}, {"sha": "7e2199a9c7f6e5be73a411c699f9f3ae55c9f0dc", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=479d1f7eec22c3564867223e2093f14774092528", "patch": "@@ -224,6 +224,13 @@ pub struct TypeParamId {\n \n pub type LocalTypeParamId = Idx<generics::TypeParamData>;\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct LifetimeParamId {\n+    pub parent: GenericDefId,\n+    pub local_id: LocalLifetimeParamId,\n+}\n+pub type LocalLifetimeParamId = Idx<generics::LifetimeParamData>;\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum ContainerId {\n     ModuleId(ModuleId),"}, {"sha": "00a69a8a63d23b4ebea0e1c185e1318d5276736b", "filename": "crates/hir_def/src/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath.rs?ref=479d1f7eec22c3564867223e2093f14774092528", "patch": "@@ -7,7 +7,7 @@ use std::{\n     sync::Arc,\n };\n \n-use crate::body::LowerCtx;\n+use crate::{body::LowerCtx, type_ref::LifetimeRef};\n use base_db::CrateId;\n use hir_expand::{\n     hygiene::Hygiene,\n@@ -145,7 +145,7 @@ pub struct AssociatedTypeBinding {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum GenericArg {\n     Type(TypeRef),\n-    // or lifetime...\n+    Lifetime(LifetimeRef),\n }\n \n impl Path {"}, {"sha": "60fa7646b2cecf9ac0d90e19111ed214877497f6", "filename": "crates/hir_def/src/path/lower.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs?ref=479d1f7eec22c3564867223e2093f14774092528", "patch": "@@ -15,7 +15,7 @@ use super::AssociatedTypeBinding;\n use crate::{\n     body::LowerCtx,\n     path::{GenericArg, GenericArgs, ModPath, Path, PathKind},\n-    type_ref::{TypeBound, TypeRef},\n+    type_ref::{LifetimeRef, TypeBound, TypeRef},\n };\n \n pub(super) use lower_use::lower_use_tree;\n@@ -170,8 +170,14 @@ pub(super) fn lower_generic_args(\n                     bindings.push(AssociatedTypeBinding { name, type_ref, bounds });\n                 }\n             }\n-            // Lifetimes and constants are ignored for now.\n-            ast::GenericArg::LifetimeArg(_) | ast::GenericArg::ConstArg(_) => (),\n+            ast::GenericArg::LifetimeArg(lifetime_arg) => {\n+                if let Some(lifetime) = lifetime_arg.lifetime_token() {\n+                    let lifetime_ref = LifetimeRef::from_token(lifetime);\n+                    args.push(GenericArg::Lifetime(lifetime_ref))\n+                }\n+            }\n+            // constants are ignored for now.\n+            ast::GenericArg::ConstArg(_) => (),\n         }\n     }\n "}, {"sha": "347ceabb9b03c745eabcfa7cdb3f87bbb03df2bb", "filename": "crates/hir_def/src/type_ref.rs", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs?ref=479d1f7eec22c3564867223e2093f14774092528", "patch": "@@ -1,6 +1,7 @@\n //! HIR for references to types. Paths in these are not yet resolved. They can\n //! be directly created from an ast::TypeRef, without further queries.\n-use syntax::ast::{self};\n+use hir_expand::name::Name;\n+use syntax::{ast, SyntaxToken};\n \n use crate::{body::LowerCtx, path::Path};\n \n@@ -58,7 +59,7 @@ pub enum TypeRef {\n     Tuple(Vec<TypeRef>),\n     Path(Path),\n     RawPtr(Box<TypeRef>, Mutability),\n-    Reference(Box<TypeRef>, Mutability),\n+    Reference(Box<TypeRef>, Option<LifetimeRef>, Mutability),\n     Array(Box<TypeRef> /*, Expr*/),\n     Slice(Box<TypeRef>),\n     /// A fn pointer. Last element of the vector is the return type.\n@@ -69,11 +70,30 @@ pub enum TypeRef {\n     Error,\n }\n \n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct LifetimeRef {\n+    pub name: Name,\n+}\n+\n+impl LifetimeRef {\n+    pub(crate) fn new_name(name: Name) -> Self {\n+        LifetimeRef { name }\n+    }\n+\n+    pub(crate) fn from_token(token: SyntaxToken) -> Self {\n+        LifetimeRef { name: Name::new_lifetime(&token) }\n+    }\n+\n+    pub fn missing() -> LifetimeRef {\n+        LifetimeRef { name: Name::missing() }\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum TypeBound {\n     Path(Path),\n-    // also for<> bounds\n-    // also Lifetimes\n+    // ForLifetime(Vec<LifetimeRef>, Path), FIXME ForLifetime\n+    Lifetime(LifetimeRef),\n     Error,\n }\n \n@@ -107,8 +127,9 @@ impl TypeRef {\n             }\n             ast::Type::RefType(inner) => {\n                 let inner_ty = TypeRef::from_ast_opt(&ctx, inner.ty());\n+                let lifetime = inner.lifetime_token().map(|t| LifetimeRef::from_token(t));\n                 let mutability = Mutability::from_mutable(inner.mut_token().is_some());\n-                TypeRef::Reference(Box::new(inner_ty), mutability)\n+                TypeRef::Reference(Box::new(inner_ty), lifetime, mutability)\n             }\n             ast::Type::InferType(_inner) => TypeRef::Placeholder,\n             ast::Type::FnPtrType(inner) => {\n@@ -163,14 +184,14 @@ impl TypeRef {\n                     types.iter().for_each(|t| go(t, f))\n                 }\n                 TypeRef::RawPtr(type_ref, _)\n-                | TypeRef::Reference(type_ref, _)\n+                | TypeRef::Reference(type_ref, ..)\n                 | TypeRef::Array(type_ref)\n                 | TypeRef::Slice(type_ref) => go(&type_ref, f),\n                 TypeRef::ImplTrait(bounds) | TypeRef::DynTrait(bounds) => {\n                     for bound in bounds {\n                         match bound {\n                             TypeBound::Path(path) => go_path(path, f),\n-                            TypeBound::Error => (),\n+                            TypeBound::Lifetime(_) | TypeBound::Error => (),\n                         }\n                     }\n                 }\n@@ -186,8 +207,12 @@ impl TypeRef {\n             for segment in path.segments().iter() {\n                 if let Some(args_and_bindings) = segment.args_and_bindings {\n                     for arg in &args_and_bindings.args {\n-                        let crate::path::GenericArg::Type(type_ref) = arg;\n-                        go(type_ref, f);\n+                        match arg {\n+                            crate::path::GenericArg::Type(type_ref) => {\n+                                go(type_ref, f);\n+                            }\n+                            crate::path::GenericArg::Lifetime(_) => {}\n+                        }\n                     }\n                     for binding in &args_and_bindings.bindings {\n                         if let Some(type_ref) = &binding.type_ref {\n@@ -196,7 +221,7 @@ impl TypeRef {\n                         for bound in &binding.bounds {\n                             match bound {\n                                 TypeBound::Path(path) => go_path(path, f),\n-                                TypeBound::Error => (),\n+                                TypeBound::Lifetime(_) | TypeBound::Error => (),\n                             }\n                         }\n                     }\n@@ -232,7 +257,10 @@ impl TypeBound {\n                 };\n                 TypeBound::Path(path)\n             }\n-            ast::TypeBoundKind::ForType(_) | ast::TypeBoundKind::Lifetime(_) => TypeBound::Error,\n+            ast::TypeBoundKind::ForType(_) => TypeBound::Error, // FIXME ForType\n+            ast::TypeBoundKind::Lifetime(lifetime) => {\n+                TypeBound::Lifetime(LifetimeRef::from_token(lifetime))\n+            }\n         }\n     }\n "}, {"sha": "583ed6142bcd38ba20b829d1387ca5cb94bc6325", "filename": "crates/hir_expand/src/name.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fname.rs?ref=479d1f7eec22c3564867223e2093f14774092528", "patch": "@@ -38,7 +38,7 @@ impl Name {\n     }\n \n     pub fn new_lifetime(lt: &syntax::SyntaxToken) -> Name {\n-        assert!(lt.kind() == syntax::SyntaxKind::LIFETIME);\n+        assert_eq!(lt.kind(), syntax::SyntaxKind::LIFETIME);\n         Name(Repr::Text(lt.text().clone()))\n     }\n \n@@ -250,6 +250,8 @@ pub mod known {\n     pub const SELF_PARAM: super::Name = super::Name::new_inline(\"self\");\n     pub const SELF_TYPE: super::Name = super::Name::new_inline(\"Self\");\n \n+    pub const STATIC_LIFETIME: super::Name = super::Name::new_inline(\"'static\");\n+\n     #[macro_export]\n     macro_rules! name {\n         (self) => {\n@@ -258,6 +260,9 @@ pub mod known {\n         (Self) => {\n             $crate::name::known::SELF_TYPE\n         };\n+        ('static) => {\n+            $crate::name::known::STATIC_LIFETIME\n+        };\n         ($ident:ident) => {\n             $crate::name::known::$ident\n         };"}, {"sha": "0d968cc68654409c95bbe49dac49afcd57086fa8", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=479d1f7eec22c3564867223e2093f14774092528", "patch": "@@ -4,7 +4,7 @@ use std::fmt;\n \n use crate::{\n     db::HirDatabase, utils::generics, ApplicationTy, CallableDefId, FnSig, GenericPredicate,\n-    Obligation, OpaqueTyId, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n+    Lifetime, Obligation, OpaqueTyId, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n };\n use hir_def::{\n     find_path, generics::TypeParamProvenance, item_scope::ItemInNs, AdtId, AssocContainerId,\n@@ -710,6 +710,19 @@ impl HirDisplay for GenericPredicate {\n     }\n }\n \n+impl HirDisplay for Lifetime {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        match self {\n+            Lifetime::Parameter(id) => {\n+                let generics = generics(f.db.upcast(), id.parent);\n+                let param_data = &generics.params.lifetimes[id.local_id];\n+                write!(f, \"{}\", &param_data.name)\n+            }\n+            Lifetime::Static => write!(f, \"'static\"),\n+        }\n+    }\n+}\n+\n impl HirDisplay for Obligation {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         match self {"}, {"sha": "ca005bc99d693930149f1d8367e8d77c9318efc5", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=479d1f7eec22c3564867223e2093f14774092528", "patch": "@@ -862,6 +862,7 @@ impl<'a> InferenceContext<'a> {\n                         let ty = self.make_ty(type_ref);\n                         substs.push(ty);\n                     }\n+                    GenericArg::Lifetime(_) => {}\n                 }\n             }\n         };"}, {"sha": "357bd92f997720798c4950156dd596eacb9a318d", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=479d1f7eec22c3564867223e2093f14774092528", "patch": "@@ -29,8 +29,8 @@ use base_db::{salsa, CrateId};\n use hir_def::{\n     expr::ExprId,\n     type_ref::{Mutability, Rawness},\n-    AdtId, AssocContainerId, DefWithBodyId, GenericDefId, HasModule, Lookup, TraitId, TypeAliasId,\n-    TypeParamId,\n+    AdtId, AssocContainerId, DefWithBodyId, GenericDefId, HasModule, LifetimeParamId, Lookup,\n+    TraitId, TypeAliasId, TypeParamId,\n };\n use itertools::Itertools;\n \n@@ -52,6 +52,12 @@ pub use traits::{InEnvironment, Obligation, ProjectionPredicate, TraitEnvironmen\n \n pub use chalk_ir::{BoundVar, DebruijnIndex};\n \n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum Lifetime {\n+    Parameter(LifetimeParamId),\n+    Static,\n+}\n+\n /// A type constructor or type name: this might be something like the primitive\n /// type `bool`, a struct like `Vec`, or things like function pointers or\n /// tuples."}, {"sha": "92f779360f7dfaee458c3c9e78e721a6eda3b9c9", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 40, "deletions": 26, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=479d1f7eec22c3564867223e2093f14774092528", "patch": "@@ -12,7 +12,7 @@ use base_db::CrateId;\n use hir_def::{\n     adt::StructKind,\n     builtin_type::BuiltinType,\n-    generics::{TypeParamProvenance, WherePredicate, WherePredicateTarget},\n+    generics::{TypeParamProvenance, WherePredicate, WherePredicateTypeTarget},\n     path::{GenericArg, Path, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{TypeBound, TypeRef},\n@@ -171,7 +171,7 @@ impl Ty {\n                 let inner_ty = Ty::from_hir(ctx, inner);\n                 Ty::apply_one(TypeCtor::Slice, inner_ty)\n             }\n-            TypeRef::Reference(inner, mutability) => {\n+            TypeRef::Reference(inner, _, mutability) => {\n                 let inner_ty = Ty::from_hir(ctx, inner);\n                 Ty::apply_one(TypeCtor::Ref(*mutability), inner_ty)\n             }\n@@ -555,7 +555,7 @@ fn substs_from_path_segment(\n \n     substs.extend(iter::repeat(Ty::Unknown).take(parent_params));\n \n-    let mut had_explicit_args = false;\n+    let mut had_explicit_type_args = false;\n \n     if let Some(generic_args) = &segment.args_and_bindings {\n         if !generic_args.has_self_type {\n@@ -568,18 +568,19 @@ fn substs_from_path_segment(\n         for arg in generic_args.args.iter().skip(skip).take(expected_num) {\n             match arg {\n                 GenericArg::Type(type_ref) => {\n-                    had_explicit_args = true;\n+                    had_explicit_type_args = true;\n                     let ty = Ty::from_hir(ctx, type_ref);\n                     substs.push(ty);\n                 }\n+                GenericArg::Lifetime(_) => {}\n             }\n         }\n     }\n \n     // handle defaults. In expression or pattern path segments without\n     // explicitly specified type arguments, missing type arguments are inferred\n     // (i.e. defaults aren't used).\n-    if !infer_args || had_explicit_args {\n+    if !infer_args || had_explicit_type_args {\n         if let Some(def_generic) = def_generic {\n             let defaults = ctx.db.generic_defaults(def_generic);\n             assert_eq!(total_len, defaults.len());\n@@ -657,7 +658,7 @@ impl TraitRef {\n     ) -> Option<TraitRef> {\n         match bound {\n             TypeBound::Path(path) => TraitRef::from_path(ctx, path, Some(self_ty)),\n-            TypeBound::Error => None,\n+            TypeBound::Lifetime(_) | TypeBound::Error => None,\n         }\n     }\n }\n@@ -667,22 +668,30 @@ impl GenericPredicate {\n         ctx: &'a TyLoweringContext<'a>,\n         where_predicate: &'a WherePredicate,\n     ) -> impl Iterator<Item = GenericPredicate> + 'a {\n-        let self_ty = match &where_predicate.target {\n-            WherePredicateTarget::TypeRef(type_ref) => Ty::from_hir(ctx, type_ref),\n-            WherePredicateTarget::TypeParam(param_id) => {\n-                let generic_def = ctx.resolver.generic_def().expect(\"generics in scope\");\n-                let generics = generics(ctx.db.upcast(), generic_def);\n-                let param_id = hir_def::TypeParamId { parent: generic_def, local_id: *param_id };\n-                match ctx.type_param_mode {\n-                    TypeParamLoweringMode::Placeholder => Ty::Placeholder(param_id),\n-                    TypeParamLoweringMode::Variable => {\n-                        let idx = generics.param_idx(param_id).expect(\"matching generics\");\n-                        Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, idx))\n+        match where_predicate {\n+            WherePredicate::TypeBound { target, bound } => {\n+                let self_ty = match target {\n+                    WherePredicateTypeTarget::TypeRef(type_ref) => Ty::from_hir(ctx, type_ref),\n+                    WherePredicateTypeTarget::TypeParam(param_id) => {\n+                        let generic_def = ctx.resolver.generic_def().expect(\"generics in scope\");\n+                        let generics = generics(ctx.db.upcast(), generic_def);\n+                        let param_id =\n+                            hir_def::TypeParamId { parent: generic_def, local_id: *param_id };\n+                        match ctx.type_param_mode {\n+                            TypeParamLoweringMode::Placeholder => Ty::Placeholder(param_id),\n+                            TypeParamLoweringMode::Variable => {\n+                                let idx = generics.param_idx(param_id).expect(\"matching generics\");\n+                                Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, idx))\n+                            }\n+                        }\n                     }\n-                }\n+                };\n+                GenericPredicate::from_type_bound(ctx, bound, self_ty)\n+                    .collect::<Vec<_>>()\n+                    .into_iter()\n             }\n-        };\n-        GenericPredicate::from_type_bound(ctx, &where_predicate.bound, self_ty)\n+            WherePredicate::Lifetime { .. } => vec![].into_iter(),\n+        }\n     }\n \n     pub(crate) fn from_type_bound<'a>(\n@@ -707,7 +716,7 @@ fn assoc_type_bindings_from_type_bound<'a>(\n ) -> impl Iterator<Item = GenericPredicate> + 'a {\n     let last_segment = match bound {\n         TypeBound::Path(path) => path.segments().last(),\n-        TypeBound::Error => None,\n+        TypeBound::Error | TypeBound::Lifetime(_) => None,\n     };\n     last_segment\n         .into_iter()\n@@ -872,11 +881,16 @@ pub(crate) fn generic_predicates_for_param_query(\n     resolver\n         .where_predicates_in_scope()\n         // we have to filter out all other predicates *first*, before attempting to lower them\n-        .filter(|pred| match &pred.target {\n-            WherePredicateTarget::TypeRef(type_ref) => {\n-                Ty::from_hir_only_param(&ctx, type_ref) == Some(param_id)\n-            }\n-            WherePredicateTarget::TypeParam(local_id) => *local_id == param_id.local_id,\n+        .filter(|pred| match pred {\n+            WherePredicate::TypeBound {\n+                target: WherePredicateTypeTarget::TypeRef(type_ref),\n+                ..\n+            } => Ty::from_hir_only_param(&ctx, type_ref) == Some(param_id),\n+            WherePredicate::TypeBound {\n+                target: WherePredicateTypeTarget::TypeParam(local_id),\n+                ..\n+            } => *local_id == param_id.local_id,\n+            WherePredicate::Lifetime { .. } => false,\n         })\n         .flat_map(|pred| {\n             GenericPredicate::from_where_predicate(&ctx, pred)"}, {"sha": "af880c0658ce439a7f1c7f3377c151d423ed17bc", "filename": "crates/hir_ty/src/utils.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/479d1f7eec22c3564867223e2093f14774092528/crates%2Fhir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Futils.rs?ref=479d1f7eec22c3564867223e2093f14774092528", "patch": "@@ -2,11 +2,10 @@\n //! query, but can't be computed directly from `*Data` (ie, which need a `db`).\n use std::sync::Arc;\n \n-use hir_def::generics::WherePredicateTarget;\n use hir_def::{\n     adt::VariantData,\n     db::DefDatabase,\n-    generics::{GenericParams, TypeParamData, TypeParamProvenance},\n+    generics::{GenericParams, TypeParamData, TypeParamProvenance, WherePredicateTypeTarget},\n     path::Path,\n     resolver::{HasResolver, TypeNs},\n     type_ref::TypeRef,\n@@ -27,14 +26,19 @@ fn direct_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n     generic_params\n         .where_predicates\n         .iter()\n-        .filter_map(|pred| match &pred.target {\n-            WherePredicateTarget::TypeRef(TypeRef::Path(p)) if p == &Path::from(name![Self]) => {\n-                pred.bound.as_path()\n-            }\n-            WherePredicateTarget::TypeParam(local_id) if Some(*local_id) == trait_self => {\n-                pred.bound.as_path()\n-            }\n-            _ => None,\n+        .filter_map(|pred| match pred {\n+            hir_def::generics::WherePredicate::TypeBound { target, bound } => match target {\n+                WherePredicateTypeTarget::TypeRef(TypeRef::Path(p))\n+                    if p == &Path::from(name![Self]) =>\n+                {\n+                    bound.as_path()\n+                }\n+                WherePredicateTypeTarget::TypeParam(local_id) if Some(*local_id) == trait_self => {\n+                    bound.as_path()\n+                }\n+                _ => None,\n+            },\n+            hir_def::generics::WherePredicate::Lifetime { .. } => None,\n         })\n         .filter_map(|path| match resolver.resolve_path_in_type_ns_fully(db, path.mod_path()) {\n             Some(TypeNs::TraitId(t)) => Some(t),"}]}