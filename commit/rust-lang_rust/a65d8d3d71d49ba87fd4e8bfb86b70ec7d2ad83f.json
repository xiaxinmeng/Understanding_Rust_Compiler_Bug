{"sha": "a65d8d3d71d49ba87fd4e8bfb86b70ec7d2ad83f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2NWQ4ZDNkNzFkNDliYTg3ZmQ0ZThiZmI4NmI3MGVjN2QyYWQ4M2Y=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-06-14T16:46:14Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-06-17T09:39:48Z"}, "message": "move `implied_bounds` into regionck", "tree": {"sha": "39ea400283c08cbffb32c2d39cd449287e70e4e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39ea400283c08cbffb32c2d39cd449287e70e4e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a65d8d3d71d49ba87fd4e8bfb86b70ec7d2ad83f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a65d8d3d71d49ba87fd4e8bfb86b70ec7d2ad83f", "html_url": "https://github.com/rust-lang/rust/commit/a65d8d3d71d49ba87fd4e8bfb86b70ec7d2ad83f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a65d8d3d71d49ba87fd4e8bfb86b70ec7d2ad83f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff9f2d2ae94fd951229c33ae55076fce4f68fab0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff9f2d2ae94fd951229c33ae55076fce4f68fab0", "html_url": "https://github.com/rust-lang/rust/commit/ff9f2d2ae94fd951229c33ae55076fce4f68fab0"}], "stats": {"total": 307, "additions": 142, "deletions": 165}, "files": [{"sha": "de738fba30e928796ff762229671555fd07360ff", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a65d8d3d71d49ba87fd4e8bfb86b70ec7d2ad83f/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a65d8d3d71d49ba87fd4e8bfb86b70ec7d2ad83f/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=a65d8d3d71d49ba87fd4e8bfb86b70ec7d2ad83f", "patch": "@@ -18,7 +18,6 @@\n use hir::def_id::DefId;\n use middle::region::RegionMaps;\n use ty::{self, Lift, TyCtxt, Region};\n-use ty::wf::ImpliedBound;\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n \n /// Combines a `RegionMaps` (which governs relationships between\n@@ -136,23 +135,6 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         self.relation.is_empty()\n     }\n \n-    pub fn relate_free_regions_from_implied_bounds(&mut self,\n-                                                   implied_bounds: &[ImpliedBound<'tcx>])\n-    {\n-        debug!(\"relate_free_regions_from_implied_bounds()\");\n-        for implied_bound in implied_bounds {\n-            debug!(\"implied bound: {:?}\", implied_bound);\n-            match *implied_bound {\n-                ImpliedBound::RegionSubRegion(a, b) => {\n-                    self.relate_regions(a, b);\n-                }\n-                ImpliedBound::RegionSubParam(..) |\n-                ImpliedBound::RegionSubProjection(..) => {\n-                }\n-            }\n-        }\n-    }\n-\n     pub fn relate_free_regions_from_predicates(&mut self,\n                                                predicates: &[ty::Predicate<'tcx>]) {\n         debug!(\"relate_free_regions_from_predicates(predicates={:?})\", predicates);\n@@ -177,7 +159,7 @@ impl<'tcx> FreeRegionMap<'tcx> {\n \n     // Record that `'sup:'sub`. Or, put another way, `'sub <= 'sup`.\n     // (with the exception that `'static: 'x` is not notable)\n-    fn relate_regions(&mut self, sub: Region<'tcx>, sup: Region<'tcx>) {\n+    pub fn relate_regions(&mut self, sub: Region<'tcx>, sup: Region<'tcx>) {\n         if (is_free(sub) || *sub == ty::ReStatic) && is_free(sup) {\n             self.relation.add(sub, sup)\n         }"}, {"sha": "2eb0acac4f7ec398b363c62186b43417f76d81b4", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 0, "deletions": 128, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/a65d8d3d71d49ba87fd4e8bfb86b70ec7d2ad83f/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a65d8d3d71d49ba87fd4e8bfb86b70ec7d2ad83f/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=a65d8d3d71d49ba87fd4e8bfb86b70ec7d2ad83f", "patch": "@@ -10,7 +10,6 @@\n \n use hir::def_id::DefId;\n use infer::InferCtxt;\n-use ty::outlives::Component;\n use ty::subst::Substs;\n use traits;\n use ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n@@ -107,133 +106,6 @@ pub fn predicate_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     wf.normalize()\n }\n \n-/// Implied bounds are region relationships that we deduce\n-/// automatically.  The idea is that (e.g.) a caller must check that a\n-/// function's argument types are well-formed immediately before\n-/// calling that fn, and hence the *callee* can assume that its\n-/// argument types are well-formed. This may imply certain relationships\n-/// between generic parameters. For example:\n-///\n-///     fn foo<'a,T>(x: &'a T)\n-///\n-/// can only be called with a `'a` and `T` such that `&'a T` is WF.\n-/// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n-#[derive(Debug)]\n-pub enum ImpliedBound<'tcx> {\n-    RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n-    RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n-    RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n-}\n-\n-/// Compute the implied bounds that a callee/impl can assume based on\n-/// the fact that caller/projector has ensured that `ty` is WF.  See\n-/// the `ImpliedBound` type for more details.\n-pub fn implied_bounds<'a, 'gcx, 'tcx>(\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    body_id: ast::NodeId,\n-    ty: Ty<'tcx>,\n-    span: Span)\n-    -> Vec<ImpliedBound<'tcx>>\n-{\n-    // Sometimes when we ask what it takes for T: WF, we get back that\n-    // U: WF is required; in that case, we push U onto this stack and\n-    // process it next. Currently (at least) these resulting\n-    // predicates are always guaranteed to be a subset of the original\n-    // type, so we need not fear non-termination.\n-    let mut wf_types = vec![ty];\n-\n-    let mut implied_bounds = vec![];\n-\n-    while let Some(ty) = wf_types.pop() {\n-        // Compute the obligations for `ty` to be well-formed. If `ty` is\n-        // an unresolved inference variable, just substituted an empty set\n-        // -- because the return type here is going to be things we *add*\n-        // to the environment, it's always ok for this set to be smaller\n-        // than the ultimate set. (Note: normally there won't be\n-        // unresolved inference variables here anyway, but there might be\n-        // during typeck under some circumstances.)\n-        let obligations = obligations(infcx, param_env, body_id, ty, span).unwrap_or(vec![]);\n-\n-        // From the full set of obligations, just filter down to the\n-        // region relationships.\n-        implied_bounds.extend(\n-            obligations\n-            .into_iter()\n-            .flat_map(|obligation| {\n-                assert!(!obligation.has_escaping_regions());\n-                match obligation.predicate {\n-                    ty::Predicate::Trait(..) |\n-                    ty::Predicate::Equate(..) |\n-                    ty::Predicate::Subtype(..) |\n-                    ty::Predicate::Projection(..) |\n-                    ty::Predicate::ClosureKind(..) |\n-                    ty::Predicate::ObjectSafe(..) =>\n-                        vec![],\n-\n-                    ty::Predicate::WellFormed(subty) => {\n-                        wf_types.push(subty);\n-                        vec![]\n-                    }\n-\n-                    ty::Predicate::RegionOutlives(ref data) =>\n-                        match infcx.tcx.no_late_bound_regions(data) {\n-                            None =>\n-                                vec![],\n-                            Some(ty::OutlivesPredicate(r_a, r_b)) =>\n-                                vec![ImpliedBound::RegionSubRegion(r_b, r_a)],\n-                        },\n-\n-                    ty::Predicate::TypeOutlives(ref data) =>\n-                        match infcx.tcx.no_late_bound_regions(data) {\n-                            None => vec![],\n-                            Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                                let ty_a = infcx.resolve_type_vars_if_possible(&ty_a);\n-                                let components = infcx.tcx.outlives_components(ty_a);\n-                                implied_bounds_from_components(r_b, components)\n-                            }\n-                        },\n-                }}));\n-    }\n-\n-    implied_bounds\n-}\n-\n-/// When we have an implied bound that `T: 'a`, we can further break\n-/// this down to determine what relationships would have to hold for\n-/// `T: 'a` to hold. We get to assume that the caller has validated\n-/// those relationships.\n-fn implied_bounds_from_components<'tcx>(sub_region: ty::Region<'tcx>,\n-                                        sup_components: Vec<Component<'tcx>>)\n-                                        -> Vec<ImpliedBound<'tcx>>\n-{\n-    sup_components\n-        .into_iter()\n-        .flat_map(|component| {\n-            match component {\n-                Component::Region(r) =>\n-                    vec![ImpliedBound::RegionSubRegion(sub_region, r)],\n-                Component::Param(p) =>\n-                    vec![ImpliedBound::RegionSubParam(sub_region, p)],\n-                Component::Projection(p) =>\n-                    vec![ImpliedBound::RegionSubProjection(sub_region, p)],\n-                Component::EscapingProjection(_) =>\n-                    // If the projection has escaping regions, don't\n-                    // try to infer any implied bounds even for its\n-                    // free components. This is conservative, because\n-                    // the caller will still have to prove that those\n-                    // free components outlive `sub_region`. But the\n-                    // idea is that the WAY that the caller proves\n-                    // that may change in the future and we want to\n-                    // give ourselves room to get smarter here.\n-                    vec![],\n-                Component::UnresolvedInferenceVariable(..) =>\n-                    vec![],\n-            }\n-        })\n-        .collect()\n-}\n-\n struct WfPredicates<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,"}, {"sha": "bbcd0eadef7505c907fdcfe921e493a5a517f041", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 141, "deletions": 18, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/a65d8d3d71d49ba87fd4e8bfb86b70ec7d2ad83f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a65d8d3d71d49ba87fd4e8bfb86b70ec7d2ad83f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=a65d8d3d71d49ba87fd4e8bfb86b70ec7d2ad83f", "patch": "@@ -94,7 +94,8 @@ use rustc::traits;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::infer::{self, GenericKind, SubregionOrigin, VerifyBound};\n use rustc::ty::adjustment;\n-use rustc::ty::wf::ImpliedBound;\n+use rustc::ty::outlives::Component;\n+use rustc::ty::wf;\n \n use std::mem;\n use std::ops::Deref;\n@@ -196,6 +197,24 @@ pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n }\n \n+/// Implied bounds are region relationships that we deduce\n+/// automatically.  The idea is that (e.g.) a caller must check that a\n+/// function's argument types are well-formed immediately before\n+/// calling that fn, and hence the *callee* can assume that its\n+/// argument types are well-formed. This may imply certain relationships\n+/// between generic parameters. For example:\n+///\n+///     fn foo<'a,T>(x: &'a T)\n+///\n+/// can only be called with a `'a` and `T` such that `&'a T` is WF.\n+/// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n+#[derive(Debug)]\n+enum ImpliedBound<'tcx> {\n+    RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n+    RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n+    RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n+}\n+\n impl<'a, 'gcx, 'tcx> Deref for RegionCtxt<'a, 'gcx, 'tcx> {\n     type Target = FnCtxt<'a, 'gcx, 'tcx>;\n     fn deref(&self) -> &Self::Target {\n@@ -386,11 +405,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         for &ty in fn_sig_tys {\n             let ty = self.resolve_type(ty);\n             debug!(\"relate_free_regions(t={:?})\", ty);\n-            let implied_bounds =\n-                ty::wf::implied_bounds(self, self.fcx.param_env, body_id, ty, span);\n-\n-            // Record any relations between free regions that we observe into the free-region-map.\n-            self.free_region_map.relate_free_regions_from_implied_bounds(&implied_bounds);\n+            let implied_bounds = self.implied_bounds(body_id, ty, span);\n \n             // But also record other relationships, such as `T:'x`,\n             // that don't go into the free-region-map but which we use\n@@ -410,16 +425,18 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     ImpliedBound::RegionSubProjection(r_a, projection_b) => {\n                         self.region_bound_pairs.push((r_a, GenericKind::Projection(projection_b)));\n                     }\n-                    ImpliedBound::RegionSubRegion(..) => {\n+                    ImpliedBound::RegionSubRegion(r_a, r_b) => {\n                         // In principle, we could record (and take\n                         // advantage of) every relationship here, but\n                         // we are also free not to -- it simply means\n                         // strictly less that we can successfully type\n-                        // check. (It may also be that we should\n-                        // revise our inference system to be more\n-                        // general and to make use of *every*\n-                        // relationship that arises here, but\n-                        // presently we do not.)\n+                        // check. Right now we only look for things\n+                        // relationships between free regions. (It may\n+                        // also be that we should revise our inference\n+                        // system to be more general and to make use\n+                        // of *every* relationship that arises here,\n+                        // but presently we do not.)\n+                        self.free_region_map.relate_regions(r_a, r_b);\n                     }\n                 }\n             }\n@@ -428,6 +445,112 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"<< relate_free_regions\");\n     }\n \n+    /// Compute the implied bounds that a callee/impl can assume based on\n+    /// the fact that caller/projector has ensured that `ty` is WF.  See\n+    /// the `ImpliedBound` type for more details.\n+    fn implied_bounds(&mut self, body_id: ast::NodeId, ty: Ty<'tcx>, span: Span)\n+                      -> Vec<ImpliedBound<'tcx>> {\n+        // Sometimes when we ask what it takes for T: WF, we get back that\n+        // U: WF is required; in that case, we push U onto this stack and\n+        // process it next. Currently (at least) these resulting\n+        // predicates are always guaranteed to be a subset of the original\n+        // type, so we need not fear non-termination.\n+        let mut wf_types = vec![ty];\n+\n+        let mut implied_bounds = vec![];\n+\n+        while let Some(ty) = wf_types.pop() {\n+            // Compute the obligations for `ty` to be well-formed. If `ty` is\n+            // an unresolved inference variable, just substituted an empty set\n+            // -- because the return type here is going to be things we *add*\n+            // to the environment, it's always ok for this set to be smaller\n+            // than the ultimate set. (Note: normally there won't be\n+            // unresolved inference variables here anyway, but there might be\n+            // during typeck under some circumstances.)\n+            let obligations =\n+                wf::obligations(self, self.fcx.param_env, body_id, ty, span)\n+                .unwrap_or(vec![]);\n+\n+            // From the full set of obligations, just filter down to the\n+            // region relationships.\n+            implied_bounds.extend(\n+                obligations\n+                    .into_iter()\n+                    .flat_map(|obligation| {\n+                        assert!(!obligation.has_escaping_regions());\n+                        match obligation.predicate {\n+                            ty::Predicate::Trait(..) |\n+                            ty::Predicate::Equate(..) |\n+                            ty::Predicate::Subtype(..) |\n+                            ty::Predicate::Projection(..) |\n+                            ty::Predicate::ClosureKind(..) |\n+                            ty::Predicate::ObjectSafe(..) =>\n+                                vec![],\n+\n+                            ty::Predicate::WellFormed(subty) => {\n+                                wf_types.push(subty);\n+                                vec![]\n+                            }\n+\n+                            ty::Predicate::RegionOutlives(ref data) =>\n+                                match self.tcx.no_late_bound_regions(data) {\n+                                    None =>\n+                                        vec![],\n+                                    Some(ty::OutlivesPredicate(r_a, r_b)) =>\n+                                        vec![ImpliedBound::RegionSubRegion(r_b, r_a)],\n+                                },\n+\n+                            ty::Predicate::TypeOutlives(ref data) =>\n+                                match self.tcx.no_late_bound_regions(data) {\n+                                    None => vec![],\n+                                    Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n+                                        let ty_a = self.resolve_type_vars_if_possible(&ty_a);\n+                                        let components = self.tcx.outlives_components(ty_a);\n+                                        self.implied_bounds_from_components(r_b, components)\n+                                    }\n+                                },\n+                        }}));\n+        }\n+\n+        implied_bounds\n+    }\n+\n+    /// When we have an implied bound that `T: 'a`, we can further break\n+    /// this down to determine what relationships would have to hold for\n+    /// `T: 'a` to hold. We get to assume that the caller has validated\n+    /// those relationships.\n+    fn implied_bounds_from_components(&self,\n+                                      sub_region: ty::Region<'tcx>,\n+                                      sup_components: Vec<Component<'tcx>>)\n+                                      -> Vec<ImpliedBound<'tcx>>\n+    {\n+        sup_components\n+            .into_iter()\n+            .flat_map(|component| {\n+                match component {\n+                    Component::Region(r) =>\n+                        vec![ImpliedBound::RegionSubRegion(sub_region, r)],\n+                    Component::Param(p) =>\n+                        vec![ImpliedBound::RegionSubParam(sub_region, p)],\n+                    Component::Projection(p) =>\n+                        vec![ImpliedBound::RegionSubProjection(sub_region, p)],\n+                    Component::EscapingProjection(_) =>\n+                    // If the projection has escaping regions, don't\n+                    // try to infer any implied bounds even for its\n+                    // free components. This is conservative, because\n+                    // the caller will still have to prove that those\n+                    // free components outlive `sub_region`. But the\n+                    // idea is that the WAY that the caller proves\n+                    // that may change in the future and we want to\n+                    // give ourselves room to get smarter here.\n+                        vec![],\n+                    Component::UnresolvedInferenceVariable(..) =>\n+                        vec![],\n+                }\n+            })\n+            .collect()\n+    }\n+\n     fn resolve_regions_and_report_errors(&self) {\n         self.fcx.resolve_regions_and_report_errors(self.subject_def_id,\n                                                    &self.region_maps,\n@@ -1353,25 +1476,25 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn components_must_outlive(&self,\n                                origin: infer::SubregionOrigin<'tcx>,\n-                               components: Vec<ty::outlives::Component<'tcx>>,\n+                               components: Vec<Component<'tcx>>,\n                                region: ty::Region<'tcx>)\n     {\n         for component in components {\n             let origin = origin.clone();\n             match component {\n-                ty::outlives::Component::Region(region1) => {\n+                Component::Region(region1) => {\n                     self.sub_regions(origin, region, region1);\n                 }\n-                ty::outlives::Component::Param(param_ty) => {\n+                Component::Param(param_ty) => {\n                     self.param_ty_must_outlive(origin, region, param_ty);\n                 }\n-                ty::outlives::Component::Projection(projection_ty) => {\n+                Component::Projection(projection_ty) => {\n                     self.projection_must_outlive(origin, region, projection_ty);\n                 }\n-                ty::outlives::Component::EscapingProjection(subcomponents) => {\n+                Component::EscapingProjection(subcomponents) => {\n                     self.components_must_outlive(origin, subcomponents, region);\n                 }\n-                ty::outlives::Component::UnresolvedInferenceVariable(v) => {\n+                Component::UnresolvedInferenceVariable(v) => {\n                     // ignore this, we presume it will yield an error\n                     // later, since if a type variable is not resolved by\n                     // this point it never will be"}]}