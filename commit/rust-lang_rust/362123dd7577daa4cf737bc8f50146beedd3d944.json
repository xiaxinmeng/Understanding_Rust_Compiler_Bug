{"sha": "362123dd7577daa4cf737bc8f50146beedd3d944", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2MjEyM2RkNzU3N2RhYTRjZjczN2JjOGY1MDE0NmJlZWRkM2Q5NDQ=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-09-26T13:15:35Z"}, "committer": {"name": "oli", "email": "github35764891676564198441@oli-obk.de", "date": "2020-11-04T09:58:59Z"}, "message": "Split the \"raw integer bytes\" part out of `Scalar`", "tree": {"sha": "d0fa1d0538039e2f7cb227eb6323f07fcc6ba74f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0fa1d0538039e2f7cb227eb6323f07fcc6ba74f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/362123dd7577daa4cf737bc8f50146beedd3d944", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/362123dd7577daa4cf737bc8f50146beedd3d944", "html_url": "https://github.com/rust-lang/rust/commit/362123dd7577daa4cf737bc8f50146beedd3d944", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/362123dd7577daa4cf737bc8f50146beedd3d944/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56293097f7f877f1350a6cd00f79d03132f16515", "url": "https://api.github.com/repos/rust-lang/rust/commits/56293097f7f877f1350a6cd00f79d03132f16515", "html_url": "https://github.com/rust-lang/rust/commit/56293097f7f877f1350a6cd00f79d03132f16515"}], "stats": {"total": 509, "additions": 325, "deletions": 184}, "files": [{"sha": "8bcb8b62076e7dde6a28215130b1b0050b3961e9", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=362123dd7577daa4cf737bc8f50146beedd3d944", "patch": "@@ -12,7 +12,7 @@ use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n use rustc_middle::bug;\n use rustc_middle::mir::interpret::{Allocation, GlobalAlloc, Scalar};\n-use rustc_middle::ty::layout::TyAndLayout;\n+use rustc_middle::ty::{layout::TyAndLayout, ScalarInt};\n use rustc_span::symbol::Symbol;\n use rustc_target::abi::{self, AddressSpace, HasDataLayout, LayoutOf, Pointer, Size};\n \n@@ -230,12 +230,12 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn scalar_to_backend(&self, cv: Scalar, layout: &abi::Scalar, llty: &'ll Type) -> &'ll Value {\n         let bitsize = if layout.is_bool() { 1 } else { layout.value.size(self).bits() };\n         match cv {\n-            Scalar::Raw { size: 0, .. } => {\n+            Scalar::Raw(ScalarInt::ZST) => {\n                 assert_eq!(0, layout.value.size(self).bytes());\n                 self.const_undef(self.type_ix(0))\n             }\n-            Scalar::Raw { data, size } => {\n-                assert_eq!(size as u64, layout.value.size(self).bytes());\n+            Scalar::Raw(int) => {\n+                let data = int.assert_bits(layout.value.size(self));\n                 let llval = self.const_uint_big(self.type_ix(bitsize), data);\n                 if layout.value == Pointer {\n                     unsafe { llvm::LLVMConstIntToPtr(llval, llty) }"}, {"sha": "4a1d5459d1eec0c6d0222a725440d940b9a92911", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=362123dd7577daa4cf737bc8f50146beedd3d944", "patch": "@@ -24,6 +24,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(array_windows)]\n+#![feature(assoc_char_funcs)]\n #![feature(backtrace)]\n #![feature(bool_to_option)]\n #![feature(box_patterns)]"}, {"sha": "c94a882df0124e165d571a386523432c9a9e855b", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=362123dd7577daa4cf737bc8f50146beedd3d944", "patch": "@@ -71,7 +71,7 @@ macro_rules! throw_inval {\n \n #[macro_export]\n macro_rules! throw_ub {\n-    ($($tt:tt)*) => { Err::<!, _>(err_ub!($($tt)*))? };\n+    ($($tt:tt)*) => { Err::<!, _>($crate::err_ub!($($tt)*))? };\n }\n \n #[macro_export]"}, {"sha": "d3a75cd099e3807324a376f9e85cbea78ff1ddac", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 21, "deletions": 86, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=362123dd7577daa4cf737bc8f50146beedd3d944", "patch": "@@ -8,9 +8,9 @@ use rustc_apfloat::{\n use rustc_macros::HashStable;\n use rustc_target::abi::{HasDataLayout, Size, TargetDataLayout};\n \n-use crate::ty::{ParamEnv, Ty, TyCtxt};\n+use crate::ty::{ParamEnv, ScalarInt, Ty, TyCtxt};\n \n-use super::{sign_extend, truncate, AllocId, Allocation, InterpResult, Pointer, PointerArithmetic};\n+use super::{sign_extend, AllocId, Allocation, InterpResult, Pointer, PointerArithmetic};\n \n /// Represents the result of const evaluation via the `eval_to_allocation` query.\n #[derive(Clone, HashStable, TyEncodable, TyDecodable)]\n@@ -103,12 +103,7 @@ impl<'tcx> ConstValue<'tcx> {\n #[derive(HashStable)]\n pub enum Scalar<Tag = ()> {\n     /// The raw bytes of a simple value.\n-    Raw {\n-        /// The first `size` bytes of `data` are the value.\n-        /// Do not try to read less or more bytes than that. The remaining bytes must be 0.\n-        data: u128,\n-        size: u8,\n-    },\n+    Raw(ScalarInt),\n \n     /// A pointer into an `Allocation`. An `Allocation` in the `memory` module has a list of\n     /// relocations, but a `Scalar` is only large enough to contain one, so we just represent the\n@@ -125,16 +120,7 @@ impl<Tag: fmt::Debug> fmt::Debug for Scalar<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Scalar::Ptr(ptr) => write!(f, \"{:?}\", ptr),\n-            &Scalar::Raw { data, size } => {\n-                Scalar::check_data(data, size);\n-                if size == 0 {\n-                    write!(f, \"<ZST>\")\n-                } else {\n-                    // Format as hex number wide enough to fit any value of the given `size`.\n-                    // So data=20, size=1 will be \"0x14\", but with size=4 it'll be \"0x00000014\".\n-                    write!(f, \"0x{:>0width$x}\", data, width = (size * 2) as usize)\n-                }\n-            }\n+            Scalar::Raw(int) => write!(f, \"{:?}\", int),\n         }\n     }\n }\n@@ -163,29 +149,14 @@ impl<Tag> From<Double> for Scalar<Tag> {\n }\n \n impl Scalar<()> {\n-    /// Make sure the `data` fits in `size`.\n-    /// This is guaranteed by all constructors here, but since the enum variants are public,\n-    /// it could still be violated (even though no code outside this file should\n-    /// construct `Scalar`s).\n-    #[inline(always)]\n-    fn check_data(data: u128, size: u8) {\n-        debug_assert_eq!(\n-            truncate(data, Size::from_bytes(u64::from(size))),\n-            data,\n-            \"Scalar value {:#x} exceeds size of {} bytes\",\n-            data,\n-            size\n-        );\n-    }\n-\n     /// Tag this scalar with `new_tag` if it is a pointer, leave it unchanged otherwise.\n     ///\n     /// Used by `MemPlace::replace_tag`.\n     #[inline]\n     pub fn with_tag<Tag>(self, new_tag: Tag) -> Scalar<Tag> {\n         match self {\n             Scalar::Ptr(ptr) => Scalar::Ptr(ptr.with_tag(new_tag)),\n-            Scalar::Raw { data, size } => Scalar::Raw { data, size },\n+            Scalar::Raw(int) => Scalar::Raw(int),\n         }\n     }\n }\n@@ -198,18 +169,18 @@ impl<'tcx, Tag> Scalar<Tag> {\n     pub fn erase_tag(self) -> Scalar {\n         match self {\n             Scalar::Ptr(ptr) => Scalar::Ptr(ptr.erase_tag()),\n-            Scalar::Raw { data, size } => Scalar::Raw { data, size },\n+            Scalar::Raw(int) => Scalar::Raw(int),\n         }\n     }\n \n     #[inline]\n     pub fn null_ptr(cx: &impl HasDataLayout) -> Self {\n-        Scalar::Raw { data: 0, size: cx.data_layout().pointer_size.bytes() as u8 }\n+        Scalar::Raw(ScalarInt::null(cx.data_layout().pointer_size))\n     }\n \n     #[inline]\n     pub fn zst() -> Self {\n-        Scalar::Raw { data: 0, size: 0 }\n+        Scalar::Raw(ScalarInt::zst())\n     }\n \n     #[inline(always)]\n@@ -220,10 +191,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n         f_ptr: impl FnOnce(Pointer<Tag>) -> InterpResult<'tcx, Pointer<Tag>>,\n     ) -> InterpResult<'tcx, Self> {\n         match self {\n-            Scalar::Raw { data, size } => {\n-                assert_eq!(u64::from(size), dl.pointer_size.bytes());\n-                Ok(Scalar::Raw { data: u128::from(f_int(u64::try_from(data).unwrap())?), size })\n-            }\n+            Scalar::Raw(int) => Ok(Scalar::Raw(int.ptr_sized_op(dl, f_int)?)),\n             Scalar::Ptr(ptr) => Ok(Scalar::Ptr(f_ptr(ptr)?)),\n         }\n     }\n@@ -264,24 +232,17 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     #[inline]\n     pub fn from_bool(b: bool) -> Self {\n-        // Guaranteed to be truncated and does not need sign extension.\n-        Scalar::Raw { data: b as u128, size: 1 }\n+        Scalar::Raw(b.into())\n     }\n \n     #[inline]\n     pub fn from_char(c: char) -> Self {\n-        // Guaranteed to be truncated and does not need sign extension.\n-        Scalar::Raw { data: c as u128, size: 4 }\n+        Scalar::Raw(c.into())\n     }\n \n     #[inline]\n     pub fn try_from_uint(i: impl Into<u128>, size: Size) -> Option<Self> {\n-        let i = i.into();\n-        if truncate(i, size) == i {\n-            Some(Scalar::Raw { data: i, size: size.bytes() as u8 })\n-        } else {\n-            None\n-        }\n+        ScalarInt::try_from_uint(i, size).map(Scalar::Raw)\n     }\n \n     #[inline]\n@@ -293,26 +254,22 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     #[inline]\n     pub fn from_u8(i: u8) -> Self {\n-        // Guaranteed to be truncated and does not need sign extension.\n-        Scalar::Raw { data: i.into(), size: 1 }\n+        Scalar::Raw(i.into())\n     }\n \n     #[inline]\n     pub fn from_u16(i: u16) -> Self {\n-        // Guaranteed to be truncated and does not need sign extension.\n-        Scalar::Raw { data: i.into(), size: 2 }\n+        Scalar::Raw(i.into())\n     }\n \n     #[inline]\n     pub fn from_u32(i: u32) -> Self {\n-        // Guaranteed to be truncated and does not need sign extension.\n-        Scalar::Raw { data: i.into(), size: 4 }\n+        Scalar::Raw(i.into())\n     }\n \n     #[inline]\n     pub fn from_u64(i: u64) -> Self {\n-        // Guaranteed to be truncated and does not need sign extension.\n-        Scalar::Raw { data: i.into(), size: 8 }\n+        Scalar::Raw(i.into())\n     }\n \n     #[inline]\n@@ -322,14 +279,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     #[inline]\n     pub fn try_from_int(i: impl Into<i128>, size: Size) -> Option<Self> {\n-        let i = i.into();\n-        // `into` performed sign extension, we have to truncate\n-        let truncated = truncate(i as u128, size);\n-        if sign_extend(truncated, size) as i128 == i {\n-            Some(Scalar::Raw { data: truncated, size: size.bytes() as u8 })\n-        } else {\n-            None\n-        }\n+        ScalarInt::try_from_int(i, size).map(Scalar::Raw)\n     }\n \n     #[inline]\n@@ -366,14 +316,12 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     #[inline]\n     pub fn from_f32(f: Single) -> Self {\n-        // We trust apfloat to give us properly truncated data.\n-        Scalar::Raw { data: f.to_bits(), size: 4 }\n+        Scalar::Raw(f.into())\n     }\n \n     #[inline]\n     pub fn from_f64(f: Double) -> Self {\n-        // We trust apfloat to give us properly truncated data.\n-        Scalar::Raw { data: f.to_bits(), size: 8 }\n+        Scalar::Raw(f.into())\n     }\n \n     /// This is very rarely the method you want!  You should dispatch on the type\n@@ -388,11 +336,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n     ) -> Result<u128, Pointer<Tag>> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n         match self {\n-            Scalar::Raw { data, size } => {\n-                assert_eq!(target_size.bytes(), u64::from(size));\n-                Scalar::check_data(data, size);\n-                Ok(data)\n-            }\n+            Scalar::Raw(int) => Ok(int.assert_bits(target_size)),\n             Scalar::Ptr(ptr) => {\n                 assert_eq!(target_size, cx.data_layout().pointer_size);\n                 Err(ptr)\n@@ -406,16 +350,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n     fn to_bits(self, target_size: Size) -> InterpResult<'tcx, u128> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n         match self {\n-            Scalar::Raw { data, size } => {\n-                if target_size.bytes() != u64::from(size) {\n-                    throw_ub!(ScalarSizeMismatch {\n-                        target_size: target_size.bytes(),\n-                        data_size: u64::from(size),\n-                    });\n-                }\n-                Scalar::check_data(data, size);\n-                Ok(data)\n-            }\n+            Scalar::Raw(int) => int.to_bits(target_size),\n             Scalar::Ptr(_) => throw_unsup!(ReadPointerAsBytes),\n         }\n     }"}, {"sha": "db89a4ad4b64d0197c233766036c32a6b256939c", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=362123dd7577daa4cf737bc8f50146beedd3d944", "patch": "@@ -28,7 +28,6 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_serialize::{Decodable, Encodable};\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n-use rustc_target::abi;\n use rustc_target::asm::InlineAsmRegOrRegClass;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Display, Formatter, Write};\n@@ -1952,10 +1951,10 @@ impl<'tcx> Operand<'tcx> {\n                 .layout_of(param_env_and_ty)\n                 .unwrap_or_else(|e| panic!(\"could not compute layout for {:?}: {:?}\", ty, e))\n                 .size;\n-            let scalar_size = abi::Size::from_bytes(match val {\n-                Scalar::Raw { size, .. } => size,\n+            let scalar_size = match val {\n+                Scalar::Raw(int) => int.size(),\n                 _ => panic!(\"Invalid scalar type {:?}\", val),\n-            });\n+            };\n             scalar_size == type_size\n         });\n         Operand::Constant(box Constant {"}, {"sha": "807005b4595e8f41a5bbaf0b363d20ea5153e895", "filename": "compiler/rustc_middle/src/ty/consts/int.rs", "status": "modified", "additions": 227, "deletions": 12, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fint.rs?ref=362123dd7577daa4cf737bc8f50146beedd3d944", "patch": "@@ -1,31 +1,34 @@\n-use crate::mir::interpret::truncate;\n-use rustc_target::abi::Size;\n+use crate::mir::interpret::{sign_extend, truncate, InterpErrorInfo, InterpResult};\n+use crate::throw_ub;\n+use rustc_apfloat::ieee::{Double, Single};\n+use rustc_apfloat::Float;\n+use rustc_macros::HashStable;\n+use rustc_target::abi::{Size, TargetDataLayout};\n+use std::convert::{TryFrom, TryInto};\n+use std::fmt;\n \n #[derive(Copy, Clone)]\n /// A type for representing any integer. Only used for printing.\n-// FIXME: Use this for the integer-tree representation needed for type level ints and\n-// const generics?\n pub struct ConstInt {\n-    /// Number of bytes of the integer. Only 1, 2, 4, 8, 16 are legal values.\n-    size: u8,\n+    /// The \"untyped\" variant of `ConstInt`.\n+    int: ScalarInt,\n     /// Whether the value is of a signed integer type.\n     signed: bool,\n     /// Whether the value is a `usize` or `isize` type.\n     is_ptr_sized_integral: bool,\n-    /// Raw memory of the integer. All bytes beyond the `size` are unused and must be zero.\n-    raw: u128,\n }\n \n impl ConstInt {\n-    pub fn new(raw: u128, size: Size, signed: bool, is_ptr_sized_integral: bool) -> Self {\n-        assert!(raw <= truncate(u128::MAX, size));\n-        Self { raw, size: size.bytes() as u8, signed, is_ptr_sized_integral }\n+    pub fn new(int: ScalarInt, signed: bool, is_ptr_sized_integral: bool) -> Self {\n+        Self { int, signed, is_ptr_sized_integral }\n     }\n }\n \n impl std::fmt::Debug for ConstInt {\n     fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        let Self { size, signed, raw, is_ptr_sized_integral } = *self;\n+        let Self { int, signed, is_ptr_sized_integral } = *self;\n+        let size = int.size().bytes();\n+        let raw = int.data();\n         if signed {\n             let bit_size = size * 8;\n             let min = 1u128 << (bit_size - 1);\n@@ -109,3 +112,215 @@ impl std::fmt::Debug for ConstInt {\n         }\n     }\n }\n+\n+// FIXME: reuse in `super::int::ConstInt` and `Scalar::Bits`\n+/// The raw bytes of a simple value.\n+#[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, TyEncodable, TyDecodable, Hash)]\n+#[derive(HashStable)]\n+pub struct ScalarInt {\n+    /// The first `size` bytes of `data` are the value.\n+    /// Do not try to read less or more bytes than that. The remaining bytes must be 0.\n+    ///\n+    /// This is an array in order to allow this type to be optimally embedded in enums\n+    /// (like Scalar).\n+    bytes: [u8; 16],\n+    size: u8,\n+}\n+\n+impl ScalarInt {\n+    pub const TRUE: ScalarInt = ScalarInt { bytes: 1_u128.to_ne_bytes(), size: 1 };\n+\n+    pub const FALSE: ScalarInt = ScalarInt { bytes: 0_u128.to_ne_bytes(), size: 1 };\n+\n+    pub const ZST: ScalarInt = ScalarInt { bytes: 0_u128.to_ne_bytes(), size: 0 };\n+\n+    fn data(self) -> u128 {\n+        u128::from_ne_bytes(self.bytes)\n+    }\n+\n+    #[inline]\n+    pub fn size(self) -> Size {\n+        Size::from_bytes(self.size)\n+    }\n+\n+    /// Make sure the `data` fits in `size`.\n+    /// This is guaranteed by all constructors here, but since the enum variants are public,\n+    /// it could still be violated (even though no code outside this file should\n+    /// construct `Scalar`s).\n+    #[inline(always)]\n+    fn check_data(self) {\n+        debug_assert_eq!(\n+            truncate(self.data(), self.size()),\n+            self.data(),\n+            \"Scalar value {:#x} exceeds size of {} bytes\",\n+            self.data(),\n+            self.size\n+        );\n+    }\n+\n+    #[inline]\n+    pub fn zst() -> Self {\n+        Self::null(Size::ZERO)\n+    }\n+\n+    #[inline]\n+    pub fn null(size: Size) -> Self {\n+        Self { bytes: [0; 16], size: size.bytes() as u8 }\n+    }\n+\n+    pub(crate) fn ptr_sized_op<'tcx>(\n+        self,\n+        dl: &TargetDataLayout,\n+        f_int: impl FnOnce(u64) -> InterpResult<'tcx, u64>,\n+    ) -> InterpResult<'tcx, Self> {\n+        assert_eq!(u64::from(self.size), dl.pointer_size.bytes());\n+        Ok(Self {\n+            bytes: u128::from(f_int(u64::try_from(self.data()).unwrap())?).to_ne_bytes(),\n+            size: self.size,\n+        })\n+    }\n+\n+    #[inline]\n+    pub fn try_from_uint(i: impl Into<u128>, size: Size) -> Option<Self> {\n+        let data = i.into();\n+        if truncate(data, size) == data {\n+            Some(Self { bytes: data.to_ne_bytes(), size: size.bytes() as u8 })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn try_from_int(i: impl Into<i128>, size: Size) -> Option<Self> {\n+        let i = i.into();\n+        // `into` performed sign extension, we have to truncate\n+        let truncated = truncate(i as u128, size);\n+        if sign_extend(truncated, size) as i128 == i {\n+            Some(Self { bytes: truncated.to_ne_bytes(), size: size.bytes() as u8 })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn assert_bits(self, target_size: Size) -> u128 {\n+        assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n+        assert_eq!(target_size.bytes(), u64::from(self.size));\n+        self.check_data();\n+        self.data()\n+    }\n+\n+    #[inline]\n+    pub fn to_bits(self, target_size: Size) -> InterpResult<'static, u128> {\n+        assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n+        if target_size.bytes() != u64::from(self.size) {\n+            throw_ub!(ScalarSizeMismatch {\n+                target_size: target_size.bytes(),\n+                data_size: u64::from(self.size),\n+            });\n+        }\n+        self.check_data();\n+        Ok(self.data())\n+    }\n+}\n+\n+macro_rules! from {\n+    ($($ty:ty),*) => {\n+        $(\n+            impl From<$ty> for ScalarInt {\n+                #[inline]\n+                fn from(u: $ty) -> Self {\n+                    Self {\n+                        bytes: u128::from(u).to_ne_bytes(),\n+                        size: std::mem::size_of::<$ty>() as u8,\n+                    }\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+macro_rules! try_from {\n+    ($($ty:ty),*) => {\n+        $(\n+            impl TryFrom<ScalarInt> for $ty {\n+                type Error = InterpErrorInfo<'static>;\n+                #[inline]\n+                fn try_from(int: ScalarInt) -> InterpResult<'static, Self> {\n+                    int.to_bits(Size::from_bytes(std::mem::size_of::<$ty>())).map(|u| u.try_into().unwrap())\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+from!(u8, u16, u32, u64, u128, bool);\n+try_from!(u8, u16, u32, u64, u128);\n+\n+impl From<char> for ScalarInt {\n+    #[inline]\n+    fn from(c: char) -> Self {\n+        Self { bytes: (c as u128).to_ne_bytes(), size: std::mem::size_of::<char>() as u8 }\n+    }\n+}\n+\n+impl TryFrom<ScalarInt> for char {\n+    type Error = InterpErrorInfo<'static>;\n+    #[inline]\n+    fn try_from(int: ScalarInt) -> InterpResult<'static, Self> {\n+        int.to_bits(Size::from_bytes(std::mem::size_of::<char>()))\n+            .map(|u| char::from_u32(u.try_into().unwrap()).unwrap())\n+    }\n+}\n+\n+impl From<Single> for ScalarInt {\n+    #[inline]\n+    fn from(f: Single) -> Self {\n+        // We trust apfloat to give us properly truncated data.\n+        Self { bytes: f.to_bits().to_ne_bytes(), size: 4 }\n+    }\n+}\n+\n+impl TryFrom<ScalarInt> for Single {\n+    type Error = InterpErrorInfo<'static>;\n+    #[inline]\n+    fn try_from(int: ScalarInt) -> InterpResult<'static, Self> {\n+        int.to_bits(Size::from_bytes(4)).map(Self::from_bits)\n+    }\n+}\n+\n+impl From<Double> for ScalarInt {\n+    #[inline]\n+    fn from(f: Double) -> Self {\n+        // We trust apfloat to give us properly truncated data.\n+        Self { bytes: f.to_bits().to_ne_bytes(), size: 8 }\n+    }\n+}\n+\n+impl TryFrom<ScalarInt> for Double {\n+    type Error = InterpErrorInfo<'static>;\n+    #[inline]\n+    fn try_from(int: ScalarInt) -> InterpResult<'static, Self> {\n+        int.to_bits(Size::from_bytes(8)).map(Self::from_bits)\n+    }\n+}\n+\n+impl fmt::Debug for ScalarInt {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self.size == 0 {\n+            self.check_data();\n+            write!(f, \"<ZST>\")\n+        } else {\n+            write!(f, \"0x{:x}\", self)\n+        }\n+    }\n+}\n+\n+impl fmt::LowerHex for ScalarInt {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.check_data();\n+        // Format as hex number wide enough to fit any value of the given `size`.\n+        // So data=20, size=1 will be \"0x14\", but with size=4 it'll be \"0x00000014\".\n+        write!(f, \"{:01$x}\", self.data(), self.size as usize * 2)\n+    }\n+}"}, {"sha": "0a7bec1a342f3661f4b3e7da2cb0c981a326fca6", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=362123dd7577daa4cf737bc8f50146beedd3d944", "patch": "@@ -87,7 +87,7 @@ pub use self::trait_def::TraitDef;\n \n pub use self::query::queries;\n \n-pub use self::consts::{Const, ConstInt, ConstKind, InferConst};\n+pub use self::consts::{Const, ConstInt, ConstKind, InferConst, ScalarInt};\n \n pub mod _match;\n pub mod adjustment;"}, {"sha": "f972a4cc1ac15ae31b9c0944a7d75eb34d938d82", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 24, "deletions": 33, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=362123dd7577daa4cf737bc8f50146beedd3d944", "patch": "@@ -1,12 +1,9 @@\n use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n use crate::mir::interpret::{AllocId, ConstValue, GlobalAlloc, Pointer, Scalar};\n-use crate::ty::layout::IntegerExt;\n use crate::ty::subst::{GenericArg, GenericArgKind, Subst};\n-use crate::ty::{self, ConstInt, DefIdTree, ParamConst, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{self, ConstInt, DefIdTree, ParamConst, ScalarInt, Ty, TyCtxt, TypeFoldable};\n use rustc_apfloat::ieee::{Double, Single};\n-use rustc_apfloat::Float;\n use rustc_ast as ast;\n-use rustc_attr::{SignedInt, UnsignedInt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def::{self, CtorKind, DefKind, Namespace};\n@@ -15,12 +12,13 @@ use rustc_hir::definitions::{DefPathData, DefPathDataName, DisambiguatedDefPathD\n use rustc_hir::ItemKind;\n use rustc_session::config::TrimmedDefPaths;\n use rustc_span::symbol::{kw, Ident, Symbol};\n-use rustc_target::abi::{Integer, Size};\n+use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n \n use std::cell::Cell;\n use std::char;\n use std::collections::BTreeMap;\n+use std::convert::TryFrom;\n use std::fmt::{self, Write as _};\n use std::ops::{ControlFlow, Deref, DerefMut};\n \n@@ -960,11 +958,7 @@ pub trait PrettyPrinter<'tcx>:\n                             ty::Array(\n                                 ty::TyS { kind: ty::Uint(ast::UintTy::U8), .. },\n                                 ty::Const {\n-                                    val:\n-                                        ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw {\n-                                            data,\n-                                            ..\n-                                        })),\n+                                    val: ty::ConstKind::Value(ConstValue::Scalar(int)),\n                                     ..\n                                 },\n                             ),\n@@ -974,8 +968,9 @@ pub trait PrettyPrinter<'tcx>:\n                 ),\n             ) => match self.tcx().get_global_alloc(ptr.alloc_id) {\n                 Some(GlobalAlloc::Memory(alloc)) => {\n-                    if let Ok(byte_str) = alloc.get_bytes(&self.tcx(), ptr, Size::from_bytes(*data))\n-                    {\n+                    let bytes = int.assert_bits(self.tcx().data_layout.pointer_size);\n+                    let size = Size::from_bytes(bytes);\n+                    if let Ok(byte_str) = alloc.get_bytes(&self.tcx(), ptr, size) {\n                         p!(pretty_print_byte_str(byte_str))\n                     } else {\n                         p!(\"<too short allocation>\")\n@@ -987,32 +982,28 @@ pub trait PrettyPrinter<'tcx>:\n                 None => p!(\"<dangling pointer>\"),\n             },\n             // Bool\n-            (Scalar::Raw { data: 0, .. }, ty::Bool) => p!(\"false\"),\n-            (Scalar::Raw { data: 1, .. }, ty::Bool) => p!(\"true\"),\n+            (Scalar::Raw(ScalarInt::FALSE), ty::Bool) => p!(\"false\"),\n+            (Scalar::Raw(ScalarInt::TRUE), ty::Bool) => p!(\"true\"),\n             // Float\n-            (Scalar::Raw { data, .. }, ty::Float(ast::FloatTy::F32)) => {\n-                p!(write(\"{}f32\", Single::from_bits(data)))\n+            (Scalar::Raw(int), ty::Float(ast::FloatTy::F32)) => {\n+                p!(write(\"{}f32\", Single::try_from(int).unwrap()))\n             }\n-            (Scalar::Raw { data, .. }, ty::Float(ast::FloatTy::F64)) => {\n-                p!(write(\"{}f64\", Double::from_bits(data)))\n+            (Scalar::Raw(int), ty::Float(ast::FloatTy::F64)) => {\n+                p!(write(\"{}f64\", Double::try_from(int).unwrap()))\n             }\n             // Int\n-            (Scalar::Raw { data, .. }, ty::Uint(ui)) => {\n-                let size = Integer::from_attr(&self.tcx(), UnsignedInt(*ui)).size();\n-                let int = ConstInt::new(data, size, false, ty.is_ptr_sized_integral());\n-                if print_ty { p!(write(\"{:#?}\", int)) } else { p!(write(\"{:?}\", int)) }\n-            }\n-            (Scalar::Raw { data, .. }, ty::Int(i)) => {\n-                let size = Integer::from_attr(&self.tcx(), SignedInt(*i)).size();\n-                let int = ConstInt::new(data, size, true, ty.is_ptr_sized_integral());\n+            (Scalar::Raw(int), ty::Uint(_) | ty::Int(_)) => {\n+                let int =\n+                    ConstInt::new(int, matches!(ty.kind(), ty::Int(_)), ty.is_ptr_sized_integral());\n                 if print_ty { p!(write(\"{:#?}\", int)) } else { p!(write(\"{:?}\", int)) }\n             }\n             // Char\n-            (Scalar::Raw { data, .. }, ty::Char) if char::from_u32(data as u32).is_some() => {\n-                p!(write(\"{:?}\", char::from_u32(data as u32).unwrap()))\n+            (Scalar::Raw(int), ty::Char) if char::try_from(int).is_ok() => {\n+                p!(write(\"{:?}\", char::try_from(int).unwrap()))\n             }\n             // Raw pointers\n-            (Scalar::Raw { data, .. }, ty::RawPtr(_)) => {\n+            (Scalar::Raw(int), ty::RawPtr(_)) => {\n+                let data = int.assert_bits(self.tcx().data_layout.pointer_size);\n                 self = self.typed_value(\n                     |mut this| {\n                         write!(this, \"0x{:x}\", data)?;\n@@ -1034,14 +1025,14 @@ pub trait PrettyPrinter<'tcx>:\n                 )?;\n             }\n             // For function type zsts just printing the path is enough\n-            (Scalar::Raw { size: 0, .. }, ty::FnDef(d, s)) => p!(print_value_path(*d, s)),\n+            (Scalar::Raw(ScalarInt::ZST), ty::FnDef(d, s)) => p!(print_value_path(*d, s)),\n             // Nontrivial types with scalar bit representation\n-            (Scalar::Raw { data, size }, _) => {\n+            (Scalar::Raw(int), _) => {\n                 let print = |mut this: Self| {\n-                    if size == 0 {\n+                    if int.size() == Size::ZERO {\n                         write!(this, \"transmute(())\")?;\n                     } else {\n-                        write!(this, \"transmute(0x{:01$x})\", data, size as usize * 2)?;\n+                        write!(this, \"transmute(0x{:x})\", int)?;\n                     }\n                     Ok(this)\n                 };"}, {"sha": "37bb841a34b875ce8630ae6e96c659ff43e34b66", "filename": "compiler/rustc_mir/src/const_eval/eval_queries.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=362123dd7577daa4cf737bc8f50146beedd3d944", "patch": "@@ -137,10 +137,10 @@ pub(super) fn op_to_const<'tcx>(\n             let alloc = ecx.tcx.global_alloc(ptr.alloc_id).unwrap_memory();\n             ConstValue::ByRef { alloc, offset: ptr.offset }\n         }\n-        Scalar::Raw { data, .. } => {\n+        Scalar::Raw(int) => {\n             assert!(mplace.layout.is_zst());\n             assert_eq!(\n-                u64::try_from(data).unwrap() % mplace.layout.align.abi.bytes(),\n+                u64::try_from(int).unwrap() % mplace.layout.align.abi.bytes(),\n                 0,\n                 \"this MPlaceTy must come from a validated constant, thus we can assume the \\\n                 alignment is correct\","}, {"sha": "b734c724274afeb91e56258fae7a55a41c805a50", "filename": "compiler/rustc_mir/src/const_eval/machine.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=362123dd7577daa4cf737bc8f50146beedd3d944", "patch": "@@ -1,6 +1,6 @@\n use rustc_middle::mir;\n use rustc_middle::ty::layout::HasTyCtxt;\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, ScalarInt, Ty};\n use std::borrow::Borrow;\n use std::collections::hash_map::Entry;\n use std::hash::Hash;\n@@ -194,13 +194,13 @@ impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n     fn guaranteed_ne(&mut self, a: Scalar, b: Scalar) -> bool {\n         match (a, b) {\n             // Comparisons between integers are always known.\n-            (Scalar::Raw { .. }, Scalar::Raw { .. }) => a != b,\n+            (Scalar::Raw(_), Scalar::Raw(_)) => a != b,\n             // Comparisons of abstract pointers with null pointers are known if the pointer\n             // is in bounds, because if they are in bounds, the pointer can't be null.\n-            (Scalar::Raw { data: 0, .. }, Scalar::Ptr(ptr))\n-            | (Scalar::Ptr(ptr), Scalar::Raw { data: 0, .. }) => !self.memory.ptr_may_be_null(ptr),\n             // Inequality with integers other than null can never be known for sure.\n-            (Scalar::Raw { .. }, Scalar::Ptr(_)) | (Scalar::Ptr(_), Scalar::Raw { .. }) => false,\n+            (Scalar::Raw(int), Scalar::Ptr(ptr)) | (Scalar::Ptr(ptr), Scalar::Raw(int)) => {\n+                int == ScalarInt::null(int.size()) && !self.memory.ptr_may_be_null(ptr)\n+            }\n             // FIXME: return `true` for at least some comparisons where we can reliably\n             // determine the result of runtime inequality tests at compile-time.\n             // Examples include comparison of addresses in different static items."}, {"sha": "bdb72297f0041172494092d1269e5b580c564e1f", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=362123dd7577daa4cf737bc8f50146beedd3d944", "patch": "@@ -211,14 +211,11 @@ impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag> {\n     #[inline]\n     pub fn to_const_int(self) -> ConstInt {\n         assert!(self.layout.ty.is_integral());\n-        ConstInt::new(\n-            self.to_scalar()\n-                .expect(\"to_const_int doesn't work on scalar pairs\")\n-                .assert_bits(self.layout.size),\n-            self.layout.size,\n-            self.layout.ty.is_signed(),\n-            self.layout.ty.is_ptr_sized_integral(),\n-        )\n+        let int = match self.to_scalar().expect(\"to_const_int doesn't work on scalar pairs\") {\n+            Scalar::Raw(int) => int,\n+            Scalar::Ptr(_) => bug!(\"to_const_int doesn't work on pointers\"),\n+        };\n+        ConstInt::new(int, self.layout.ty.is_signed(), self.layout.ty.is_ptr_sized_integral())\n     }\n }\n \n@@ -544,7 +541,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let tag_scalar = |scalar| -> InterpResult<'tcx, _> {\n             Ok(match scalar {\n                 Scalar::Ptr(ptr) => Scalar::Ptr(self.global_base_pointer(ptr)?),\n-                Scalar::Raw { data, size } => Scalar::Raw { data, size },\n+                Scalar::Raw(int) => Scalar::Raw(int),\n             })\n         };\n         // Early-return cases."}, {"sha": "ceae436b18e5350a94adec24e51257fd03f4345e", "filename": "compiler/rustc_mir/src/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fplace.rs?ref=362123dd7577daa4cf737bc8f50146beedd3d944", "patch": "@@ -721,12 +721,8 @@ where\n                     dest.layout.size,\n                     \"Size mismatch when writing pointer\"\n                 ),\n-                Immediate::Scalar(ScalarMaybeUninit::Scalar(Scalar::Raw { size, .. })) => {\n-                    assert_eq!(\n-                        Size::from_bytes(size),\n-                        dest.layout.size,\n-                        \"Size mismatch when writing bits\"\n-                    )\n+                Immediate::Scalar(ScalarMaybeUninit::Scalar(Scalar::Raw(int))) => {\n+                    assert_eq!(int.size(), dest.layout.size, \"Size mismatch when writing bits\")\n                 }\n                 Immediate::Scalar(ScalarMaybeUninit::Uninit) => {} // uninit can have any size\n                 Immediate::ScalarPair(_, _) => {"}, {"sha": "620b9ac673a6579d718a62d2e09965c06f27e72b", "filename": "compiler/rustc_mir/src/transform/const_prop.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs?ref=362123dd7577daa4cf737bc8f50146beedd3d944", "patch": "@@ -19,7 +19,9 @@ use rustc_middle::mir::{\n };\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutError, TyAndLayout};\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n-use rustc_middle::ty::{self, ConstInt, ConstKind, Instance, ParamEnv, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{\n+    self, ConstInt, ConstKind, Instance, ParamEnv, ScalarInt, Ty, TyCtxt, TypeFoldable,\n+};\n use rustc_session::lint;\n use rustc_span::{def_id::DefId, Span};\n use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TargetDataLayout};\n@@ -578,8 +580,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                             Some(l) => l.to_const_int(),\n                             // Invent a dummy value, the diagnostic ignores it anyway\n                             None => ConstInt::new(\n-                                1,\n-                                left_size,\n+                                ScalarInt::try_from_uint(1_u8, left_size).unwrap(),\n                                 left_ty.is_signed(),\n                                 left_ty.is_ptr_sized_integral(),\n                             ),"}, {"sha": "2ed27a6ed0a9549b6b3837942bd20c0d65b3775b", "filename": "compiler/rustc_mir/src/transform/simplify_comparison_integral.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/362123dd7577daa4cf737bc8f50146beedd3d944/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_comparison_integral.rs?ref=362123dd7577daa4cf737bc8f50146beedd3d944", "patch": "@@ -26,22 +26,26 @@ use rustc_middle::{\n pub struct SimplifyComparisonIntegral;\n \n impl<'tcx> MirPass<'tcx> for SimplifyComparisonIntegral {\n-    fn run_pass(&self, _: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         trace!(\"Running SimplifyComparisonIntegral on {:?}\", body.source);\n \n         let helper = OptimizationFinder { body };\n         let opts = helper.find_optimizations();\n         let mut storage_deads_to_insert = vec![];\n         let mut storage_deads_to_remove: Vec<(usize, BasicBlock)> = vec![];\n+        let param_env = tcx.param_env(body.source.def_id());\n         for opt in opts {\n             trace!(\"SUCCESS: Applying {:?}\", opt);\n             // replace terminator with a switchInt that switches on the integer directly\n             let bbs = &mut body.basic_blocks_mut();\n             let bb = &mut bbs[opt.bb_idx];\n-            // We only use the bits for the untyped, not length checked `values` field. Thus we are\n-            // not using any of the convenience wrappers here and directly access the bits.\n             let new_value = match opt.branch_value_scalar {\n-                Scalar::Raw { data, .. } => data,\n+                Scalar::Raw(int) => {\n+                    let layout = tcx\n+                        .layout_of(param_env.and(opt.branch_value_ty))\n+                        .expect(\"if we have an evaluated constant we must know the layout\");\n+                    int.assert_bits(layout.size)\n+                }\n                 Scalar::Ptr(_) => continue,\n             };\n             const FALSE: u128 = 0;"}, {"sha": "167b06428e50c243cc53ee0a3c49c3eb8077f2af", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/362123dd7577daa4cf737bc8f50146beedd3d944/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/362123dd7577daa4cf737bc8f50146beedd3d944/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=362123dd7577daa4cf737bc8f50146beedd3d944", "patch": "@@ -14,7 +14,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_middle::mir::interpret::{sign_extend, ConstValue, Scalar};\n+use rustc_middle::mir::interpret::{sign_extend, ConstValue};\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::{self, DefIdTree, Ty};\n use rustc_span::symbol::{kw, sym, Symbol};\n@@ -499,12 +499,13 @@ fn print_const_with_custom_print_scalar(cx: &DocContext<'_>, ct: &'tcx ty::Const\n     // Use a slightly different format for integer types which always shows the actual value.\n     // For all other types, fallback to the original `pretty_print_const`.\n     match (ct.val, ct.ty.kind()) {\n-        (ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { data, .. })), ty::Uint(ui)) => {\n-            format!(\"{}{}\", format_integer_with_underscore_sep(&data.to_string()), ui.name_str())\n+        (ty::ConstKind::Value(ConstValue::Scalar(int)), ty::Uint(ui)) => {\n+            format!(\"{}{}\", format_integer_with_underscore_sep(&int.to_string()), ui.name_str())\n         }\n-        (ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { data, .. })), ty::Int(i)) => {\n+        (ty::ConstKind::Value(ConstValue::Scalar(int)), ty::Int(i)) => {\n             let ty = cx.tcx.lift(ct.ty).unwrap();\n             let size = cx.tcx.layout_of(ty::ParamEnv::empty().and(ty)).unwrap().size;\n+            let data = int.assert_bits(size);\n             let sign_extended_data = sign_extend(data, size) as i128;\n \n             format!("}, {"sha": "ff4a8b1ad0a5cd4a4ff6dc5128c4536c623ed2d8", "filename": "src/test/ui/symbol-names/impl1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/362123dd7577daa4cf737bc8f50146beedd3d944/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/362123dd7577daa4cf737bc8f50146beedd3d944/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs?ref=362123dd7577daa4cf737bc8f50146beedd3d944", "patch": "@@ -3,8 +3,8 @@\n // revisions: legacy v0\n //[legacy]compile-flags: -Z symbol-mangling-version=legacy\n     //[v0]compile-flags: -Z symbol-mangling-version=v0\n-//[legacy]normalize-stderr-32bit: \"hee444285569b39c2\" -> \"SYMBOL_HASH\"\n-//[legacy]normalize-stderr-64bit: \"h310ea0259fc3d32d\" -> \"SYMBOL_HASH\"\n+//[legacy]normalize-stderr-32bit: \"h30edc7aa010c48ae\" -> \"SYMBOL_HASH\"\n+//[legacy]normalize-stderr-64bit: \"h56362331c4f93d19\" -> \"SYMBOL_HASH\"\n \n #![feature(optin_builtin_traits, rustc_attrs)]\n #![allow(dead_code)]"}, {"sha": "b54d2654579f70f75845b706b66af873b72df2e2", "filename": "src/tools/clippy/clippy_lints/src/consts.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/362123dd7577daa4cf737bc8f50146beedd3d944/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/362123dd7577daa4cf737bc8f50146beedd3d944/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fconsts.rs?ref=362123dd7577daa4cf737bc8f50146beedd3d944", "patch": "@@ -8,8 +8,9 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{BinOp, BinOpKind, Block, Expr, ExprKind, HirId, QPath, UnOp};\n use rustc_lint::LateContext;\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt, ScalarInt};\n use rustc_middle::{bug, span_bug};\n+use rustc_middle::mir::interpret::Scalar;\n use rustc_span::symbol::Symbol;\n use std::cmp::Ordering::{self, Equal};\n use std::convert::TryInto;\n@@ -500,21 +501,21 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n }\n \n pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n-    use rustc_middle::mir::interpret::{ConstValue, Scalar};\n+    use rustc_middle::mir::interpret::{ConstValue};\n     match result.val {\n-        ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw { data: d, .. })) => {\n+        ty::ConstKind::Value(ConstValue::Scalar(Scalar::Raw(int))) => {\n             match result.ty.kind() {\n-                ty::Bool => Some(Constant::Bool(d == 1)),\n-                ty::Uint(_) | ty::Int(_) => Some(Constant::Int(d)),\n+                ty::Bool => Some(Constant::Bool(int == ScalarInt::TRUE)),\n+                ty::Uint(_) | ty::Int(_) => Some(Constant::Int(int.assert_bits(int.size()))),\n                 ty::Float(FloatTy::F32) => Some(Constant::F32(f32::from_bits(\n-                    d.try_into().expect(\"invalid f32 bit representation\"),\n+                    int.try_into().expect(\"invalid f32 bit representation\"),\n                 ))),\n                 ty::Float(FloatTy::F64) => Some(Constant::F64(f64::from_bits(\n-                    d.try_into().expect(\"invalid f64 bit representation\"),\n+                    int.try_into().expect(\"invalid f64 bit representation\"),\n                 ))),\n                 ty::RawPtr(type_and_mut) => {\n                     if let ty::Uint(_) = type_and_mut.ty.kind() {\n-                        return Some(Constant::RawPtr(d));\n+                        return Some(Constant::RawPtr(int.assert_bits(int.size())));\n                     }\n                     None\n                 },"}]}