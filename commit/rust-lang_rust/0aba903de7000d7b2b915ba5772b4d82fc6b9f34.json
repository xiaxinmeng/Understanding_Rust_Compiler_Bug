{"sha": "0aba903de7000d7b2b915ba5772b4d82fc6b9f34", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhYmE5MDNkZTcwMDBkN2IyYjkxNWJhNTc3MmI0ZDgyZmM2YjlmMzQ=", "commit": {"author": {"name": "Gareth Daniel Smith", "email": "garethdanielsmith@gmail.com", "date": "2012-11-04T10:14:49Z"}, "committer": {"name": "Gareth Daniel Smith", "email": "garethdanielsmith@gmail.com", "date": "2012-11-04T10:14:49Z"}, "message": "Add size-specific int reading methods to ReaderUtil to match the existing int writing methods in WriterUtil (for issue #2004).", "tree": {"sha": "5680d6352fcbd0cd6055c28bf82478d66cd08b23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5680d6352fcbd0cd6055c28bf82478d66cd08b23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0aba903de7000d7b2b915ba5772b4d82fc6b9f34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0aba903de7000d7b2b915ba5772b4d82fc6b9f34", "html_url": "https://github.com/rust-lang/rust/commit/0aba903de7000d7b2b915ba5772b4d82fc6b9f34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0aba903de7000d7b2b915ba5772b4d82fc6b9f34/comments", "author": {"login": "Dretch", "id": 1428731, "node_id": "MDQ6VXNlcjE0Mjg3MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1428731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dretch", "html_url": "https://github.com/Dretch", "followers_url": "https://api.github.com/users/Dretch/followers", "following_url": "https://api.github.com/users/Dretch/following{/other_user}", "gists_url": "https://api.github.com/users/Dretch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dretch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dretch/subscriptions", "organizations_url": "https://api.github.com/users/Dretch/orgs", "repos_url": "https://api.github.com/users/Dretch/repos", "events_url": "https://api.github.com/users/Dretch/events{/privacy}", "received_events_url": "https://api.github.com/users/Dretch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Dretch", "id": 1428731, "node_id": "MDQ6VXNlcjE0Mjg3MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1428731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dretch", "html_url": "https://github.com/Dretch", "followers_url": "https://api.github.com/users/Dretch/followers", "following_url": "https://api.github.com/users/Dretch/following{/other_user}", "gists_url": "https://api.github.com/users/Dretch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dretch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dretch/subscriptions", "organizations_url": "https://api.github.com/users/Dretch/orgs", "repos_url": "https://api.github.com/users/Dretch/repos", "events_url": "https://api.github.com/users/Dretch/events{/privacy}", "received_events_url": "https://api.github.com/users/Dretch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a42d2d408a74f677bb58a799f995d69f9fdd8438", "url": "https://api.github.com/repos/rust-lang/rust/commits/a42d2d408a74f677bb58a799f995d69f9fdd8438", "html_url": "https://github.com/rust-lang/rust/commit/a42d2d408a74f677bb58a799f995d69f9fdd8438"}], "stats": {"total": 283, "additions": 250, "deletions": 33}, "files": [{"sha": "d409cc5a41e462a4586fcd36b30fe613cc7e580d", "filename": "src/libcore/io.rs", "status": "modified", "additions": 250, "deletions": 33, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/0aba903de7000d7b2b915ba5772b4d82fc6b9f34/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aba903de7000d7b2b915ba5772b4d82fc6b9f34/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=0aba903de7000d7b2b915ba5772b4d82fc6b9f34", "patch": "@@ -46,24 +46,87 @@ pub trait Reader {\n }\n \n // Generic utility functions defined on readers\n-\n pub trait ReaderUtil {\n     fn read_bytes(len: uint) -> ~[u8];\n     fn read_line() -> ~str;\n \n     fn read_chars(n: uint) -> ~[char];\n     fn read_char() -> char;\n     fn read_c_str() -> ~str;\n-    fn read_le_uint(size: uint) -> uint;\n-    fn read_le_int(size: uint) -> int;\n-    fn read_be_uint(size: uint) -> uint;\n     fn read_whole_stream() -> ~[u8];\n     fn each_byte(it: fn(int) -> bool);\n     fn each_char(it: fn(char) -> bool);\n     fn each_line(it: fn((&str)) -> bool);\n+\n+    /// read n (between 1 and 8) little-endian unsigned integer bytes\n+    fn read_le_uint_n(nbytes: uint) -> u64;\n+\n+    /// read n (between 1 and 8) little-endian signed integer bytes\n+    fn read_le_int_n(nbytes: uint) -> i64;\n+\n+    /// read n (between 1 and 8) big-endian unsigned integer bytes\n+    fn read_be_uint_n(nbytes: uint) -> u64;\n+\n+    /// read n (between 1 and 8) big-endian signed integer bytes\n+    fn read_be_int_n(nbytes: uint) -> i64;\n+\n+    /// read a little-endian uint (number of bytes read depends on system)\n+    fn read_le_uint() -> uint;\n+\n+    /// read a little-endian int (number of bytes read depends on system)\n+    fn read_le_int() -> int;\n+\n+    /// read a big-endian uint (number of bytes read depends on system)\n+    fn read_be_uint() -> uint;\n+\n+    /// read a big-endian int (number of bytes read depends on system)\n+    fn read_be_int() -> int;\n+\n+    /// read a big-endian u64 (8 bytes)\n+    fn read_be_u64() -> u64;\n+\n+    /// read a big-endian u32 (4 bytes)\n+    fn read_be_u32() -> u32;\n+\n+    /// read a big-endian u16 (2 bytes)\n+    fn read_be_u16() -> u16;\n+\n+    /// read a big-endian i64 (8 bytes)\n+    fn read_be_i64() -> i64;\n+\n+    /// read a big-endian i32 (4 bytes)\n+    fn read_be_i32() -> i32;\n+\n+    /// read a big-endian i16 (2 bytes)\n+    fn read_be_i16() -> i16;\n+\n+    /// read a little-endian u64 (8 bytes)\n+    fn read_le_u64() -> u64;\n+\n+    /// read a little-endian u32 (4 bytes)\n+    fn read_le_u32() -> u32;\n+\n+    /// read a little-endian u16 (2 bytes)\n+    fn read_le_u16() -> u16;\n+\n+    /// read a litle-endian i64 (8 bytes)\n+    fn read_le_i64() -> i64;\n+\n+    /// read a litle-endian i32 (4 bytes)\n+    fn read_le_i32() -> i32;\n+\n+    /// read a litle-endian i16 (2 bytes)\n+    fn read_le_i16() -> i16;\n+\n+    /// read a u8 (1 byte)\n+    fn read_u8() -> u8;\n+\n+    /// read a i8 (1 byte)\n+    fn read_i8() -> i8;\n }\n \n impl<T: Reader> T : ReaderUtil {\n+\n     fn read_bytes(len: uint) -> ~[u8] {\n         let mut bytes = vec::with_capacity(len);\n         unsafe { vec::raw::set_len(&mut bytes, len); }\n@@ -73,6 +136,7 @@ impl<T: Reader> T : ReaderUtil {\n         unsafe { vec::raw::set_len(&mut bytes, count); }\n         move bytes\n     }\n+\n     fn read_line() -> ~str {\n         let mut bytes = ~[];\n         loop {\n@@ -162,34 +226,6 @@ impl<T: Reader> T : ReaderUtil {\n         str::from_bytes(bytes)\n     }\n \n-    // FIXME deal with eof? // #2004\n-    fn read_le_uint(size: uint) -> uint {\n-        let mut val = 0u, pos = 0u, i = size;\n-        while i > 0u {\n-            val += (self.read_byte() as uint) << pos;\n-            pos += 8u;\n-            i -= 1u;\n-        }\n-        val\n-    }\n-    fn read_le_int(size: uint) -> int {\n-        let mut val = 0u, pos = 0u, i = size;\n-        while i > 0u {\n-            val += (self.read_byte() as uint) << pos;\n-            pos += 8u;\n-            i -= 1u;\n-        }\n-        val as int\n-    }\n-    fn read_be_uint(size: uint) -> uint {\n-        let mut val = 0u, i = size;\n-        while i > 0u {\n-            i -= 1u;\n-            val += (self.read_byte() as uint) << i * 8u;\n-        }\n-        val\n-    }\n-\n     fn read_whole_stream() -> ~[u8] {\n         let mut bytes: ~[u8] = ~[];\n         while !self.eof() { bytes.push_all(self.read_bytes(2048u)); }\n@@ -213,6 +249,116 @@ impl<T: Reader> T : ReaderUtil {\n             if !it(self.read_line()) { break; }\n         }\n     }\n+\n+    // FIXME int reading methods need to deal with eof - issue #2004\n+\n+    fn read_le_uint_n(nbytes: uint) -> u64 {\n+        assert nbytes > 0 && nbytes <= 8;\n+\n+        let mut val = 0u64, pos = 0, i = nbytes;\n+        while i > 0 {\n+            val += (self.read_u8() as u64) << pos;\n+            pos += 8;\n+            i -= 1;\n+        }\n+        val\n+    }\n+\n+    fn read_le_int_n(nbytes: uint) -> i64 {\n+        extend_sign(self.read_le_uint_n(nbytes), nbytes)\n+    }\n+\n+    fn read_be_uint_n(nbytes: uint) -> u64 {\n+        assert nbytes > 0 && nbytes <= 8;\n+\n+        let mut val = 0u64, i = nbytes;\n+        while i > 0 {\n+            i -= 1;\n+            val += (self.read_u8() as u64) << i * 8;\n+        }\n+        val\n+    }\n+\n+    fn read_be_int_n(nbytes: uint) -> i64 {\n+        extend_sign(self.read_be_uint_n(nbytes), nbytes)\n+    }\n+\n+    fn read_le_uint() -> uint {\n+        self.read_le_uint_n(uint::bytes) as uint\n+    }\n+\n+    fn read_le_int() -> int {\n+        self.read_le_int_n(int::bytes) as int\n+    }\n+\n+    fn read_be_uint() -> uint {\n+        self.read_be_uint_n(uint::bytes) as uint\n+    }\n+\n+    fn read_be_int() -> int {\n+        self.read_be_int_n(int::bytes) as int\n+    }\n+\n+    fn read_be_u64() -> u64 {\n+        self.read_be_uint_n(8) as u64\n+    }\n+\n+    fn read_be_u32() -> u32 {\n+        self.read_be_uint_n(4) as u32\n+    }\n+\n+    fn read_be_u16() -> u16 {\n+        self.read_be_uint_n(2) as u16\n+    }\n+\n+    fn read_be_i64() -> i64 {\n+        self.read_be_int_n(8) as i64\n+    }\n+\n+    fn read_be_i32() -> i32 {\n+        self.read_be_int_n(4) as i32\n+    }\n+\n+    fn read_be_i16() -> i16 {\n+        self.read_be_int_n(2) as i16\n+    }\n+\n+    fn read_le_u64() -> u64 {\n+        self.read_le_uint_n(8) as u64\n+    }\n+\n+    fn read_le_u32() -> u32 {\n+        self.read_le_uint_n(4) as u32\n+    }\n+\n+    fn read_le_u16() -> u16 {\n+        self.read_le_uint_n(2) as u16\n+    }\n+\n+    fn read_le_i64() -> i64 {\n+        self.read_le_int_n(8) as i64\n+    }\n+\n+    fn read_le_i32() -> i32 {\n+        self.read_le_int_n(4) as i32\n+    }\n+\n+    fn read_le_i16() -> i16 {\n+        self.read_le_int_n(2) as i16\n+    }\n+\n+    fn read_u8() -> u8 {\n+        self.read_byte() as u8\n+    }\n+\n+    fn read_i8() -> i8 {\n+        self.read_byte() as i8\n+    }\n+}\n+\n+fn extend_sign(val: u64, nbytes: uint) -> i64 {\n+    let shift = (8 - nbytes) * 8;\n+    (val << shift) as i64 >> shift\n }\n \n // Reader implementations\n@@ -589,6 +735,7 @@ pub trait WriterUtil {\n     fn write_le_i32(n: i32);\n     fn write_le_i16(n: i16);\n     fn write_u8(n: u8);\n+    fn write_i8(n: i8);\n }\n \n impl<T: Writer> T : WriterUtil {\n@@ -659,7 +806,8 @@ impl<T: Writer> T : WriterUtil {\n         u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n     }\n \n-    fn write_u8(n: u8) { self.write(&[n]) }\n+    fn write_u8(n: u8) { self.write([n]) }\n+    fn write_i8(n: i8) { self.write([n as u8]) }\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n@@ -1001,6 +1149,75 @@ mod tests {\n         assert wr.bytes.borrow(|bytes| bytes ==\n             ~[0u8, 9u8, 4u8, 5u8, 8u8, 7u8]);\n     }\n+\n+    #[test]\n+    fn test_read_write_le() {\n+        let path = Path(\"tmp/lib-io-test-read-write-le.tmp\");\n+        let uints = [0, 1, 2, 42, 10_123, 100_123_456, u64::max_value];\n+\n+        // write the ints to the file\n+        {\n+            let file = io::file_writer(&path, [io::Create]).get();\n+            for uints.each |i| {\n+                file.write_le_u64(*i);\n+            }\n+        }\n+\n+        // then read them back and check that they are the same\n+        {\n+            let file = io::file_reader(&path).get();\n+            for uints.each |i| {\n+                assert file.read_le_u64() == *i;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_read_write_be() {\n+        let path = Path(\"tmp/lib-io-test-read-write-be.tmp\");\n+        let uints = [0, 1, 2, 42, 10_123, 100_123_456, u64::max_value];\n+\n+        // write the ints to the file\n+        {\n+            let file = io::file_writer(&path, [io::Create]).get();\n+            for uints.each |i| {\n+                file.write_be_u64(*i);\n+            }\n+        }\n+\n+        // then read them back and check that they are the same\n+        {\n+            let file = io::file_reader(&path).get();\n+            for uints.each |i| {\n+                assert file.read_be_u64() == *i;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_read_be_int_n() {\n+        let path = Path(\"tmp/lib-io-test-read-be-int-n.tmp\");\n+        let ints = [i32::min_value, -123456, -42, -5, 0, 1, i32::max_value];\n+\n+        // write the ints to the file\n+        {\n+            let file = io::file_writer(&path, [io::Create]).get();\n+            for ints.each |i| {\n+                file.write_be_i32(*i);\n+            }\n+        }\n+\n+        // then read them back and check that they are the same\n+        {\n+            let file = io::file_reader(&path).get();\n+            for ints.each |i| {\n+                // this tests that the sign extension is working\n+                // (comparing the values as i32 would not test this)\n+                assert file.read_be_int_n(4) == *i as i64;\n+            }\n+        }\n+    }\n+\n }\n \n //"}]}