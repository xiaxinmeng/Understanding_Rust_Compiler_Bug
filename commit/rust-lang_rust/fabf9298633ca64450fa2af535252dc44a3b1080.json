{"sha": "fabf9298633ca64450fa2af535252dc44a3b1080", "node_id": "C_kwDOAAsO6NoAKGZhYmY5Mjk4NjMzY2E2NDQ1MGZhMmFmNTM1MjUyZGM0NGEzYjEwODA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-01T08:06:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-01T08:06:07Z"}, "message": "Auto merge of #112164 - Dylan-DPC:rollup-93zj7jw, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #108459 (rustdoc: Fix LinkReplacer link matching)\n - #111318 (Add a distinct `OperandValue::ZeroSized` variant for ZSTs)\n - #111892 (rustdoc: add interaction delays for tooltip popovers)\n - #111980 (Preserve substs in opaques recorded in typeck results)\n - #112024 (Don't suggest break through nested items)\n - #112128 (Don't compute inlining status of mono items in advance.)\n - #112141 (remove reference to Into in ? operator core/std docs, fix #111655)\n\nFailed merges:\n\n - #112071 (Group rfcs tests)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "3282afeed0ad7bed91ef3e3c4b88ce67a5dad326", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3282afeed0ad7bed91ef3e3c4b88ce67a5dad326"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fabf9298633ca64450fa2af535252dc44a3b1080", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fabf9298633ca64450fa2af535252dc44a3b1080", "html_url": "https://github.com/rust-lang/rust/commit/fabf9298633ca64450fa2af535252dc44a3b1080", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fabf9298633ca64450fa2af535252dc44a3b1080/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23f93a1266e0530445db590c15e0bb5c1c624eb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/23f93a1266e0530445db590c15e0bb5c1c624eb6", "html_url": "https://github.com/rust-lang/rust/commit/23f93a1266e0530445db590c15e0bb5c1c624eb6"}, {"sha": "129c5597644b27def33d650f8d8004c90698d34c", "url": "https://api.github.com/repos/rust-lang/rust/commits/129c5597644b27def33d650f8d8004c90698d34c", "html_url": "https://github.com/rust-lang/rust/commit/129c5597644b27def33d650f8d8004c90698d34c"}], "stats": {"total": 988, "additions": 638, "deletions": 350}, "files": [{"sha": "13e346b86bce315387bba6dd6bfeb94c3fed619f", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -279,8 +279,18 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         // HACK This bubble is required for this tests to pass:\n         // nested-return-type2-tait2.rs\n         // nested-return-type2-tait3.rs\n-        let infcx =\n-            self.tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).build();\n+        // FIXME(-Ztrait-solver=next): We probably should use `DefiningAnchor::Error`\n+        // and prepopulate this `InferCtxt` with known opaque values, rather than\n+        // using the `Bind` anchor here. For now it's fine.\n+        let infcx = self\n+            .tcx\n+            .infer_ctxt()\n+            .with_opaque_type_inference(if self.tcx.trait_solver_next() {\n+                DefiningAnchor::Bind(def_id)\n+            } else {\n+                DefiningAnchor::Bubble\n+            })\n+            .build();\n         let ocx = ObligationCtxt::new(&infcx);\n         // Require the hidden type to be well-formed with only the generics of the opaque type.\n         // Defining use functions may have more bounds than the opaque type, which is ok, as long as the"}, {"sha": "908ff3da5ca0b4388358879094f8b50147678e1c", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -188,9 +188,6 @@ pub(crate) fn type_check<'mir, 'tcx>(\n \n     // FIXME(-Ztrait-solver=next): A bit dubious that we're only registering\n     // predefined opaques in the typeck root.\n-    // FIXME(-Ztrait-solver=next): This is also totally wrong for TAITs, since\n-    // the HIR typeck map defining usages back to their definition params,\n-    // they won't actually match up with the usages in this body...\n     if infcx.tcx.trait_solver_next() && !infcx.tcx.is_typeck_child(body.source.def_id()) {\n         checker.register_predefined_opaques_in_new_solver();\n     }\n@@ -1042,10 +1039,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             .typeck(self.body.source.def_id().expect_local())\n             .concrete_opaque_types\n             .iter()\n-            .map(|(&def_id, &hidden_ty)| {\n-                let substs = ty::InternalSubsts::identity_for_item(self.infcx.tcx, def_id);\n-                (ty::OpaqueTypeKey { def_id, substs }, hidden_ty)\n-            })\n+            .map(|(k, v)| (*k, *v))\n             .collect();\n \n         let renumbered_opaques = self.infcx.tcx.fold_regions(opaques, |_, _| {"}, {"sha": "f9ea0f004564b4a0b1f07801664e33b552c14f46", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -758,7 +758,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         assert_eq!(place.llextra.is_some(), place.layout.is_unsized());\n \n         if place.layout.is_zst() {\n-            return OperandRef::new_zst(self, place.layout);\n+            return OperandRef::zero_sized(place.layout);\n         }\n \n         fn scalar_load_metadata<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>, load: RValue<'gcc>, scalar: &abi::Scalar) {"}, {"sha": "30a3fe67b854396011f70fec7c5df0f249c64d41", "filename": "compiler/rustc_codegen_gcc/src/type_of.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -159,8 +159,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n     fn is_gcc_immediate(&self) -> bool {\n         match self.abi {\n             Abi::Scalar(_) | Abi::Vector { .. } => true,\n-            Abi::ScalarPair(..) => false,\n-            Abi::Uninhabited | Abi::Aggregate { .. } => self.is_zst(),\n+            Abi::ScalarPair(..) | Abi::Uninhabited | Abi::Aggregate { .. } => false,\n         }\n     }\n "}, {"sha": "5968e70b1cccef32108b94113ca8ac780ea00153", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -486,7 +486,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         assert_eq!(place.llextra.is_some(), place.layout.is_unsized());\n \n         if place.layout.is_zst() {\n-            return OperandRef::new_zst(self, place.layout);\n+            return OperandRef::zero_sized(place.layout);\n         }\n \n         #[instrument(level = \"trace\", skip(bx))]"}, {"sha": "a493c9c0548e90f505ba4b2fc092d9676b1d1db7", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -198,8 +198,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n     fn is_llvm_immediate(&self) -> bool {\n         match self.abi {\n             Abi::Scalar(_) | Abi::Vector { .. } => true,\n-            Abi::ScalarPair(..) => false,\n-            Abi::Uninhabited | Abi::Aggregate { .. } => self.is_zst(),\n+            Abi::ScalarPair(..) | Abi::Uninhabited | Abi::Aggregate { .. } => false,\n         }\n     }\n "}, {"sha": "242d209b68425db326f234e0f016b90fc87356fe", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -295,7 +295,7 @@ pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             let (base, info) = match bx.load_operand(src).val {\n                 OperandValue::Pair(base, info) => unsize_ptr(bx, base, src_ty, dst_ty, Some(info)),\n                 OperandValue::Immediate(base) => unsize_ptr(bx, base, src_ty, dst_ty, None),\n-                OperandValue::Ref(..) => bug!(),\n+                OperandValue::Ref(..) | OperandValue::ZeroSized => bug!(),\n             };\n             OperandValue::Pair(base, info).store(bx, dst);\n         }"}, {"sha": "e0cb26d3ba8667548f844327b1ce084c5fac03fd", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -1,5 +1,5 @@\n use super::operand::OperandRef;\n-use super::operand::OperandValue::{Immediate, Pair, Ref};\n+use super::operand::OperandValue::{Immediate, Pair, Ref, ZeroSized};\n use super::place::PlaceRef;\n use super::{CachedLlbb, FunctionCx, LocalRef};\n \n@@ -427,6 +427,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         assert_eq!(align, op.layout.align.abi, \"return place is unaligned!\");\n                         llval\n                     }\n+                    ZeroSized => bug!(\"ZST return value shouldn't be in PassMode::Cast\"),\n                 };\n                 let ty = bx.cast_backend_type(cast_ty);\n                 let addr = bx.pointercast(llslot, bx.type_ptr_to(ty));\n@@ -1386,6 +1387,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     (llval, align, true)\n                 }\n             }\n+            ZeroSized => match arg.mode {\n+                PassMode::Indirect { .. } => {\n+                    // Though `extern \"Rust\"` doesn't pass ZSTs, some ABIs pass\n+                    // a pointer for `repr(C)` structs even when empty, so get\n+                    // one from an `alloca` (which can be left uninitialized).\n+                    let scratch = PlaceRef::alloca(bx, arg.layout);\n+                    (scratch.llval, scratch.align, true)\n+                }\n+                _ => bug!(\"ZST {op:?} wasn't ignored, but was passed with abi {arg:?}\"),\n+            },\n         };\n \n         if by_ref && !arg.is_indirect() {"}, {"sha": "4f79c6a3d823c83e912348e0e192a08a754020b0", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -352,6 +352,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         bx.set_var_name(a, &(name.clone() + \".0\"));\n                         bx.set_var_name(b, &(name.clone() + \".1\"));\n                     }\n+                    OperandValue::ZeroSized => {\n+                        // These never have a value to talk about\n+                    }\n                 },\n                 LocalRef::PendingOperand => {}\n             }"}, {"sha": "2809ec2deb550c1926265bc6557aa7290a8f8c59", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -129,16 +129,13 @@ enum LocalRef<'tcx, V> {\n     PendingOperand,\n }\n \n-impl<'a, 'tcx, V: CodegenObject> LocalRef<'tcx, V> {\n-    fn new_operand<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n-        bx: &mut Bx,\n-        layout: TyAndLayout<'tcx>,\n-    ) -> LocalRef<'tcx, V> {\n+impl<'tcx, V: CodegenObject> LocalRef<'tcx, V> {\n+    fn new_operand(layout: TyAndLayout<'tcx>) -> LocalRef<'tcx, V> {\n         if layout.is_zst() {\n             // Zero-size temporaries aren't always initialized, which\n             // doesn't matter because they don't contain data, but\n             // we need something in the operand.\n-            LocalRef::Operand(OperandRef::new_zst(bx, layout))\n+            LocalRef::Operand(OperandRef::zero_sized(layout))\n         } else {\n             LocalRef::PendingOperand\n         }\n@@ -249,7 +246,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 }\n             } else {\n                 debug!(\"alloc: {:?} -> operand\", local);\n-                LocalRef::new_operand(&mut start_bx, layout)\n+                LocalRef::new_operand(layout)\n             }\n         };\n \n@@ -355,7 +352,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 let local = |op| LocalRef::Operand(op);\n                 match arg.mode {\n                     PassMode::Ignore => {\n-                        return local(OperandRef::new_zst(bx, arg.layout));\n+                        return local(OperandRef::zero_sized(arg.layout));\n                     }\n                     PassMode::Direct(_) => {\n                         let llarg = bx.get_param(llarg_idx);"}, {"sha": "31c293d7c298ec555eb18e044bc58bb12326fbcc", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -45,6 +45,14 @@ pub enum OperandValue<V> {\n     /// as returned by [`LayoutTypeMethods::scalar_pair_element_backend_type`]\n     /// with `immediate: true`.\n     Pair(V, V),\n+    /// A value taking no bytes, and which therefore needs no LLVM value at all.\n+    ///\n+    /// If you ever need a `V` to pass to something, get a fresh poison value\n+    /// from [`ConstMethods::const_poison`].\n+    ///\n+    /// An `OperandValue` *must* be this variant for any type for which\n+    /// `is_zst` on its `Layout` returns `true`.\n+    ZeroSized,\n }\n \n /// An `OperandRef` is an \"SSA\" reference to a Rust value, along with\n@@ -71,15 +79,9 @@ impl<V: CodegenObject> fmt::Debug for OperandRef<'_, V> {\n }\n \n impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n-    pub fn new_zst<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n-        bx: &mut Bx,\n-        layout: TyAndLayout<'tcx>,\n-    ) -> OperandRef<'tcx, V> {\n+    pub fn zero_sized(layout: TyAndLayout<'tcx>) -> OperandRef<'tcx, V> {\n         assert!(layout.is_zst());\n-        OperandRef {\n-            val: OperandValue::Immediate(bx.const_poison(bx.immediate_backend_type(layout))),\n-            layout,\n-        }\n+        OperandRef { val: OperandValue::ZeroSized, layout }\n     }\n \n     pub fn from_const<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n@@ -97,7 +99,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n                 let llval = bx.scalar_to_backend(x, scalar, bx.immediate_backend_type(layout));\n                 OperandValue::Immediate(llval)\n             }\n-            ConstValue::ZeroSized => return OperandRef::new_zst(bx, layout),\n+            ConstValue::ZeroSized => return OperandRef::zero_sized(layout),\n             ConstValue::Slice { data, start, end } => {\n                 let Abi::ScalarPair(a_scalar, _) = layout.abi else {\n                     bug!(\"from_const: invalid ScalarPair layout: {:#?}\", layout);\n@@ -178,7 +180,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n                 );\n                 OperandRef { val: OperandValue::Pair(a_val, b_val), layout }\n             }\n-            _ if layout.is_zst() => OperandRef::new_zst(bx, layout),\n+            _ if layout.is_zst() => OperandRef::zero_sized(layout),\n             _ => {\n                 // Neither a scalar nor scalar pair. Load from a place\n                 let init = bx.const_data_from_alloc(alloc);\n@@ -216,6 +218,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n             OperandValue::Immediate(llptr) => (llptr, None),\n             OperandValue::Pair(llptr, llextra) => (llptr, Some(llextra)),\n             OperandValue::Ref(..) => bug!(\"Deref of by-Ref operand {:?}\", self),\n+            OperandValue::ZeroSized => bug!(\"Deref of ZST operand {:?}\", self),\n         };\n         let layout = cx.layout_of(projected_ty);\n         PlaceRef { llval: llptr, llextra, layout, align: layout.align.abi }\n@@ -273,9 +276,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n \n         let mut val = match (self.val, self.layout.abi) {\n             // If the field is ZST, it has no data.\n-            _ if field.is_zst() => {\n-                return OperandRef::new_zst(bx, field);\n-            }\n+            _ if field.is_zst() => OperandValue::ZeroSized,\n \n             // Newtype of a scalar, scalar pair or vector.\n             (OperandValue::Immediate(_) | OperandValue::Pair(..), _)\n@@ -306,6 +307,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n         };\n \n         match (&mut val, field.abi) {\n+            (OperandValue::ZeroSized, _) => {}\n             (\n                 OperandValue::Immediate(llval),\n                 Abi::Scalar(_) | Abi::ScalarPair(..) | Abi::Vector { .. },\n@@ -359,16 +361,18 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n     /// Returns an `OperandValue` that's generally UB to use in any way.\n     ///\n-    /// Depending on the `layout`, returns an `Immediate` or `Pair` containing\n-    /// poison value(s), or a `Ref` containing a poison pointer.\n+    /// Depending on the `layout`, returns `ZeroSized` for ZSTs, an `Immediate` or\n+    /// `Pair` containing poison value(s), or a `Ref` containing a poison pointer.\n     ///\n     /// Supports sized types only.\n     pub fn poison<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n         layout: TyAndLayout<'tcx>,\n     ) -> OperandValue<V> {\n         assert!(layout.is_sized());\n-        if bx.cx().is_backend_immediate(layout) {\n+        if layout.is_zst() {\n+            OperandValue::ZeroSized\n+        } else if bx.cx().is_backend_immediate(layout) {\n             let ibty = bx.cx().immediate_backend_type(layout);\n             OperandValue::Immediate(bx.const_poison(ibty))\n         } else if bx.cx().is_backend_scalar_pair(layout) {\n@@ -421,12 +425,11 @@ impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n         flags: MemFlags,\n     ) {\n         debug!(\"OperandRef::store: operand={:?}, dest={:?}\", self, dest);\n-        // Avoid generating stores of zero-sized values, because the only way to have a zero-sized\n-        // value is through `undef`, and store itself is useless.\n-        if dest.layout.is_zst() {\n-            return;\n-        }\n         match self {\n+            OperandValue::ZeroSized => {\n+                // Avoid generating stores of zero-sized values, because the only way to have a zero-sized\n+                // value is through `undef`/`poison`, and the store itself is useless.\n+            }\n             OperandValue::Ref(r, None, source_align) => {\n                 if flags.contains(MemFlags::NONTEMPORAL) {\n                     // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n@@ -527,7 +530,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             // checks in `codegen_consume` and `extract_field`.\n                             let elem = o.layout.field(bx.cx(), 0);\n                             if elem.is_zst() {\n-                                o = OperandRef::new_zst(bx, elem);\n+                                o = OperandRef::zero_sized(elem);\n                             } else {\n                                 return None;\n                             }\n@@ -561,7 +564,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // ZSTs don't require any actual memory access.\n         if layout.is_zst() {\n-            return OperandRef::new_zst(bx, layout);\n+            return OperandRef::zero_sized(layout);\n         }\n \n         if let Some(o) = self.maybe_codegen_consume_direct(bx, place_ref) {"}, {"sha": "5241a5aee008e4b09d9de6fca5da74051251668b", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -70,6 +70,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     OperandValue::Ref(_, Some(_), _) => {\n                         bug!(\"unsized coercion on an unsized rvalue\");\n                     }\n+                    OperandValue::ZeroSized => {\n+                        bug!(\"unsized coercion on a ZST rvalue\");\n+                    }\n                 }\n             }\n \n@@ -165,11 +168,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n \n         match src.val {\n-            OperandValue::Ref(..) => {\n+            OperandValue::Ref(..) | OperandValue::ZeroSized => {\n                 span_bug!(\n                     self.mir.span,\n                     \"Operand path should have handled transmute \\\n-                    from `Ref` {src:?} to place {dst:?}\"\n+                    from {src:?} to place {dst:?}\"\n                 );\n             }\n             OperandValue::Immediate(..) | OperandValue::Pair(..) => {\n@@ -220,17 +223,22 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let fake_place = PlaceRef::new_sized_aligned(cast_ptr, cast, align);\n                 Some(bx.load_operand(fake_place).val)\n             }\n+            OperandValue::ZeroSized => {\n+                let OperandValueKind::ZeroSized = operand_kind else {\n+                    bug!(\"Found {operand_kind:?} for operand {operand:?}\");\n+                };\n+                if let OperandValueKind::ZeroSized = cast_kind {\n+                    Some(OperandValue::ZeroSized)\n+                } else {\n+                    None\n+                }\n+            }\n             OperandValue::Immediate(imm) => {\n                 let OperandValueKind::Immediate(in_scalar) = operand_kind else {\n                     bug!(\"Found {operand_kind:?} for operand {operand:?}\");\n                 };\n-                if let OperandValueKind::Immediate(out_scalar) = cast_kind {\n-                    match (in_scalar, out_scalar) {\n-                        (ScalarOrZst::Zst, ScalarOrZst::Zst) => {\n-                            Some(OperandRef::new_zst(bx, cast).val)\n-                        }\n-                        (ScalarOrZst::Scalar(in_scalar), ScalarOrZst::Scalar(out_scalar))\n-                            if in_scalar.size(self.cx) == out_scalar.size(self.cx) =>\n+                if let OperandValueKind::Immediate(out_scalar) = cast_kind\n+                    && in_scalar.size(self.cx) == out_scalar.size(self.cx)\n                         {\n                             let operand_bty = bx.backend_type(operand.layout);\n                             let cast_bty = bx.backend_type(cast);\n@@ -242,9 +250,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 out_scalar,\n                                 cast_bty,\n                             )))\n-                        }\n-                        _ => None,\n-                    }\n                 } else {\n                     None\n                 }\n@@ -457,6 +462,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             OperandValue::Ref(..) => {\n                                 bug!(\"by-ref operand {:?} in `codegen_rvalue_operand`\", operand);\n                             }\n+                            OperandValue::ZeroSized => {\n+                                bug!(\"zero-sized operand {:?} in `codegen_rvalue_operand`\", operand);\n+                            }\n                         };\n                         let (lldata, llextra) =\n                             base::unsize_ptr(bx, lldata, operand.layout.ty, cast.ty, llextra);\n@@ -490,6 +498,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             OperandValue::Ref(_, _, _) => todo!(),\n                             OperandValue::Immediate(v) => (v, None),\n                             OperandValue::Pair(v, l) => (v, Some(l)),\n+                            OperandValue::ZeroSized => bug!(\"ZST -- which is not PointerLike -- in DynStar\"),\n                         };\n                         let (lldata, llextra) =\n                             base::cast_to_dyn_star(bx, lldata, operand.layout, cast.ty, llextra);\n@@ -718,7 +727,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 // According to `rvalue_creates_operand`, only ZST\n                 // aggregate rvalues are allowed to be operands.\n                 let ty = rvalue.ty(self.mir, self.cx.tcx());\n-                OperandRef::new_zst(bx, self.cx.layout_of(self.monomorphize(ty)))\n+                OperandRef::zero_sized(self.cx.layout_of(self.monomorphize(ty)))\n             }\n             mir::Rvalue::ShallowInitBox(ref operand, content_ty) => {\n                 let operand = self.codegen_operand(bx, operand);\n@@ -936,6 +945,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     // Can always load from a pointer as needed\n                     (OperandValueKind::Ref, _) => true,\n \n+                    // ZST-to-ZST is the easiest thing ever\n+                    (OperandValueKind::ZeroSized, OperandValueKind::ZeroSized) => true,\n+\n+                    // But if only one of them is a ZST the sizes can't match\n+                    (OperandValueKind::ZeroSized, _) | (_, OperandValueKind::ZeroSized) => false,\n+\n                     // Need to generate an `alloc` to get a pointer from an immediate\n                     (OperandValueKind::Immediate(..) | OperandValueKind::Pair(..), OperandValueKind::Ref) => false,\n \n@@ -979,12 +994,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n     /// Gets which variant of [`OperandValue`] is expected for a particular type.\n     fn value_kind(&self, layout: TyAndLayout<'tcx>) -> OperandValueKind {\n-        if self.cx.is_backend_immediate(layout) {\n+        if layout.is_zst() {\n+            OperandValueKind::ZeroSized\n+        } else if self.cx.is_backend_immediate(layout) {\n             debug_assert!(!self.cx.is_backend_scalar_pair(layout));\n             OperandValueKind::Immediate(match layout.abi {\n-                abi::Abi::Scalar(s) => ScalarOrZst::Scalar(s),\n-                abi::Abi::Vector { element, .. } => ScalarOrZst::Scalar(element),\n-                _ if layout.is_zst() => ScalarOrZst::Zst,\n+                abi::Abi::Scalar(s) => s,\n+                abi::Abi::Vector { element, .. } => element,\n                 x => span_bug!(self.mir.span, \"Couldn't translate {x:?} as backend immediate\"),\n             })\n         } else if self.cx.is_backend_scalar_pair(layout) {\n@@ -1007,21 +1023,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n #[derive(Debug, Copy, Clone)]\n enum OperandValueKind {\n     Ref,\n-    Immediate(ScalarOrZst),\n+    Immediate(abi::Scalar),\n     Pair(abi::Scalar, abi::Scalar),\n-}\n-\n-#[derive(Debug, Copy, Clone)]\n-enum ScalarOrZst {\n-    Zst,\n-    Scalar(abi::Scalar),\n-}\n-\n-impl ScalarOrZst {\n-    pub fn size(self, cx: &impl abi::HasDataLayout) -> abi::Size {\n-        match self {\n-            ScalarOrZst::Zst => abi::Size::ZERO,\n-            ScalarOrZst::Scalar(s) => s.size(cx),\n-        }\n-    }\n+    ZeroSized,\n }"}, {"sha": "4d96a7ff4c3d7de99c774c6ce0c1ff6b25787d65", "filename": "compiler/rustc_hir_analysis/src/collect/type_of/opaque.rs", "status": "modified", "additions": 78, "deletions": 33, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of%2Fopaque.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -1,3 +1,4 @@\n+use rustc_errors::StashKey;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{self as hir, Expr, ImplItem, Item, Node, TraitItem};\n@@ -59,7 +60,20 @@ pub(super) fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: Local\n         }\n     }\n \n-    let Some(hidden) = locator.found else {\n+    if let Some(hidden) = locator.found {\n+        // Only check against typeck if we didn't already error\n+        if !hidden.ty.references_error() {\n+            for concrete_type in locator.typeck_types {\n+                if concrete_type.ty != tcx.erase_regions(hidden.ty)\n+                    && !(concrete_type, hidden).references_error()\n+                {\n+                    hidden.report_mismatch(&concrete_type, def_id, tcx).emit();\n+                }\n+            }\n+        }\n+\n+        hidden.ty\n+    } else {\n         let reported = tcx.sess.emit_err(UnconstrainedOpaqueType {\n             span: tcx.def_span(def_id),\n             name: tcx.item_name(tcx.local_parent(def_id).to_def_id()),\n@@ -70,21 +84,8 @@ pub(super) fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: Local\n                 _ => \"item\",\n             },\n         });\n-        return tcx.ty_error(reported);\n-    };\n-\n-    // Only check against typeck if we didn't already error\n-    if !hidden.ty.references_error() {\n-        for concrete_type in locator.typeck_types {\n-            if concrete_type.ty != tcx.erase_regions(hidden.ty)\n-                && !(concrete_type, hidden).references_error()\n-            {\n-                hidden.report_mismatch(&concrete_type, def_id, tcx).emit();\n-            }\n-        }\n+        tcx.ty_error(reported)\n     }\n-\n-    hidden.ty\n }\n \n struct TaitConstraintLocator<'tcx> {\n@@ -130,13 +131,28 @@ impl TaitConstraintLocator<'_> {\n             self.found = Some(ty::OpaqueHiddenType { span: DUMMY_SP, ty: self.tcx.ty_error(guar) });\n             return;\n         }\n-        let Some(&typeck_hidden_ty) = tables.concrete_opaque_types.get(&self.def_id) else {\n+\n+        let mut constrained = false;\n+        for (&opaque_type_key, &hidden_type) in &tables.concrete_opaque_types {\n+            if opaque_type_key.def_id != self.def_id {\n+                continue;\n+            }\n+            constrained = true;\n+            let concrete_type =\n+                self.tcx.erase_regions(hidden_type.remap_generic_params_to_declaration_params(\n+                    opaque_type_key,\n+                    self.tcx,\n+                    true,\n+                ));\n+            if self.typeck_types.iter().all(|prev| prev.ty != concrete_type.ty) {\n+                self.typeck_types.push(concrete_type);\n+            }\n+        }\n+\n+        if !constrained {\n             debug!(\"no constraints in typeck results\");\n             return;\n         };\n-        if self.typeck_types.iter().all(|prev| prev.ty != typeck_hidden_ty.ty) {\n-            self.typeck_types.push(typeck_hidden_ty);\n-        }\n \n         // Use borrowck to get the type with unerased regions.\n         let concrete_opaque_types = &self.tcx.mir_borrowck(item_def_id).concrete_opaque_types;\n@@ -190,45 +206,74 @@ impl<'tcx> intravisit::Visitor<'tcx> for TaitConstraintLocator<'tcx> {\n     }\n }\n \n-pub(super) fn find_opaque_ty_constraints_for_rpit(\n-    tcx: TyCtxt<'_>,\n+pub(super) fn find_opaque_ty_constraints_for_rpit<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     def_id: LocalDefId,\n     owner_def_id: LocalDefId,\n ) -> Ty<'_> {\n-    let concrete = tcx.mir_borrowck(owner_def_id).concrete_opaque_types.get(&def_id).copied();\n+    let tables = tcx.typeck(owner_def_id);\n+\n+    // Check that all of the opaques we inferred during HIR are compatible.\n+    // FIXME: We explicitly don't check that the types inferred during HIR\n+    // typeck are compatible with the one that we infer during borrowck,\n+    // because that one actually sometimes has consts evaluated eagerly so\n+    // using strict type equality will fail.\n+    let mut hir_opaque_ty: Option<ty::OpaqueHiddenType<'tcx>> = None;\n+    if tables.tainted_by_errors.is_none() {\n+        for (&opaque_type_key, &hidden_type) in &tables.concrete_opaque_types {\n+            if opaque_type_key.def_id != def_id {\n+                continue;\n+            }\n+            let concrete_type = tcx.erase_regions(\n+                hidden_type.remap_generic_params_to_declaration_params(opaque_type_key, tcx, true),\n+            );\n+            if let Some(prev) = &mut hir_opaque_ty {\n+                if concrete_type.ty != prev.ty && !(concrete_type, prev.ty).references_error() {\n+                    prev.report_mismatch(&concrete_type, def_id, tcx).stash(\n+                        tcx.def_span(opaque_type_key.def_id),\n+                        StashKey::OpaqueHiddenTypeMismatch,\n+                    );\n+                }\n+            } else {\n+                hir_opaque_ty = Some(concrete_type);\n+            }\n+        }\n+    }\n \n-    if let Some(concrete) = concrete {\n+    let mir_opaque_ty = tcx.mir_borrowck(owner_def_id).concrete_opaque_types.get(&def_id).copied();\n+    if let Some(mir_opaque_ty) = mir_opaque_ty {\n         let scope = tcx.hir().local_def_id_to_hir_id(owner_def_id);\n         debug!(?scope);\n-        let mut locator = RpitConstraintChecker { def_id, tcx, found: concrete };\n+        let mut locator = RpitConstraintChecker { def_id, tcx, found: mir_opaque_ty };\n \n         match tcx.hir().get(scope) {\n             Node::Item(it) => intravisit::walk_item(&mut locator, it),\n             Node::ImplItem(it) => intravisit::walk_impl_item(&mut locator, it),\n             Node::TraitItem(it) => intravisit::walk_trait_item(&mut locator, it),\n             other => bug!(\"{:?} is not a valid scope for an opaque type item\", other),\n         }\n-    }\n \n-    concrete.map(|concrete| concrete.ty).unwrap_or_else(|| {\n-        let table = tcx.typeck(owner_def_id);\n-        if let Some(guar) = table.tainted_by_errors {\n-            // Some error in the\n-            // owner fn prevented us from populating\n+        mir_opaque_ty.ty\n+    } else {\n+        if let Some(guar) = tables.tainted_by_errors {\n+            // Some error in the owner fn prevented us from populating\n             // the `concrete_opaque_types` table.\n             tcx.ty_error(guar)\n         } else {\n-            table.concrete_opaque_types.get(&def_id).map(|ty| ty.ty).unwrap_or_else(|| {\n+            // Fall back to the RPIT we inferred during HIR typeck\n+            if let Some(hir_opaque_ty) = hir_opaque_ty {\n+                hir_opaque_ty.ty\n+            } else {\n                 // We failed to resolve the opaque type or it\n                 // resolves to itself. We interpret this as the\n                 // no values of the hidden type ever being constructed,\n                 // so we can just make the hidden type be `!`.\n                 // For backwards compatibility reasons, we fall back to\n                 // `()` until we the diverging default is changed.\n                 tcx.mk_diverging_default()\n-            })\n+            }\n         }\n-    })\n+    }\n }\n \n struct RpitConstraintChecker<'tcx> {"}, {"sha": "e19b0664461a964c9ba4d409be4fcf288db90bef", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -874,7 +874,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let found = self.resolve_vars_with_obligations(found);\n \n         let in_loop = self.is_loop(id)\n-            || self.tcx.hir().parent_iter(id).any(|(parent_id, _)| self.is_loop(parent_id));\n+            || self\n+                .tcx\n+                .hir()\n+                .parent_iter(id)\n+                .take_while(|(_, node)| {\n+                    // look at parents until we find the first body owner\n+                    node.body_id().is_none()\n+                })\n+                .any(|(parent_id, _)| self.is_loop(parent_id));\n \n         let in_local_statement = self.is_local_statement(id)\n             || self"}, {"sha": "964acc4eb77ef803a6741f4fce489302da8cd8c9", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -583,19 +583,15 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 continue;\n             }\n \n-            let hidden_type =\n-                self.tcx().erase_regions(hidden_type.remap_generic_params_to_declaration_params(\n-                    opaque_type_key,\n-                    self.tcx(),\n-                    true,\n-                ));\n-\n+            // Here we only detect impl trait definition conflicts when they\n+            // are equal modulo regions.\n             if let Some(last_opaque_ty) = self\n                 .typeck_results\n                 .concrete_opaque_types\n-                .insert(opaque_type_key.def_id, hidden_type)\n+                .insert(opaque_type_key, hidden_type)\n                 && last_opaque_ty.ty != hidden_type.ty\n             {\n+                assert!(!self.tcx().trait_solver_next());\n                 hidden_type\n                     .report_mismatch(&last_opaque_ty, opaque_type_key.def_id, self.tcx())\n                     .stash("}, {"sha": "8cbffa14850fac3a5187fb83b6dbf1b6ef5674d5", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -155,11 +155,7 @@ pub struct TypeckResults<'tcx> {\n     /// We also store the type here, so that the compiler can use it as a hint\n     /// for figuring out hidden types, even if they are only set in dead code\n     /// (which doesn't show up in MIR).\n-    ///\n-    /// These types are mapped back to the opaque's identity substitutions\n-    /// (with erased regions), which is why we don't associated substs with any\n-    /// of these usages.\n-    pub concrete_opaque_types: FxIndexMap<LocalDefId, ty::OpaqueHiddenType<'tcx>>,\n+    pub concrete_opaque_types: FxIndexMap<ty::OpaqueTypeKey<'tcx>, ty::OpaqueHiddenType<'tcx>>,\n \n     /// Tracks the minimum captures required for a closure;\n     /// see `MinCaptureInformationMap` for more details."}, {"sha": "09025c1ee3319fe2f07d1fde2a1cb208da233db5", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 13, "deletions": 63, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -179,7 +179,6 @@ use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n-use rustc_index::bit_set::GrowableBitSet;\n use rustc_middle::mir::interpret::{AllocId, ConstValue};\n use rustc_middle::mir::interpret::{ErrorHandled, GlobalAlloc, Scalar};\n use rustc_middle::mir::mono::{InstantiationMode, MonoItem};\n@@ -220,78 +219,29 @@ pub struct InliningMap<'tcx> {\n     // The range selects elements within the `targets` vecs.\n     index: FxHashMap<MonoItem<'tcx>, Range<usize>>,\n     targets: Vec<MonoItem<'tcx>>,\n-\n-    // Contains one bit per mono item in the `targets` field. That bit\n-    // is true if that mono item needs to be inlined into every CGU.\n-    inlines: GrowableBitSet<usize>,\n-}\n-\n-/// Struct to store mono items in each collecting and if they should\n-/// be inlined. We call `instantiation_mode` to get their inlining\n-/// status when inserting new elements, which avoids calling it in\n-/// `inlining_map.lock_mut()`. See the `collect_items_rec` implementation\n-/// below.\n-struct MonoItems<'tcx> {\n-    // If this is false, we do not need to compute whether items\n-    // will need to be inlined.\n-    compute_inlining: bool,\n-\n-    // The TyCtxt used to determine whether the a item should\n-    // be inlined.\n-    tcx: TyCtxt<'tcx>,\n-\n-    // The collected mono items. The bool field in each element\n-    // indicates whether this element should be inlined.\n-    items: Vec<(Spanned<MonoItem<'tcx>>, bool /*inlined*/)>,\n }\n \n-impl<'tcx> MonoItems<'tcx> {\n-    #[inline]\n-    fn push(&mut self, item: Spanned<MonoItem<'tcx>>) {\n-        self.extend([item]);\n-    }\n-\n-    #[inline]\n-    fn extend<T: IntoIterator<Item = Spanned<MonoItem<'tcx>>>>(&mut self, iter: T) {\n-        self.items.extend(iter.into_iter().map(|mono_item| {\n-            let inlined = if !self.compute_inlining {\n-                false\n-            } else {\n-                mono_item.node.instantiation_mode(self.tcx) == InstantiationMode::LocalCopy\n-            };\n-            (mono_item, inlined)\n-        }))\n-    }\n-}\n+type MonoItems<'tcx> = Vec<Spanned<MonoItem<'tcx>>>;\n \n impl<'tcx> InliningMap<'tcx> {\n     fn new() -> InliningMap<'tcx> {\n-        InliningMap {\n-            index: FxHashMap::default(),\n-            targets: Vec::new(),\n-            inlines: GrowableBitSet::with_capacity(1024),\n-        }\n+        InliningMap { index: FxHashMap::default(), targets: Vec::new() }\n     }\n \n     fn record_accesses<'a>(\n         &mut self,\n         source: MonoItem<'tcx>,\n-        new_targets: &'a [(Spanned<MonoItem<'tcx>>, bool)],\n+        new_targets: &'a [Spanned<MonoItem<'tcx>>],\n     ) where\n         'tcx: 'a,\n     {\n         let start_index = self.targets.len();\n         let new_items_count = new_targets.len();\n-        let new_items_count_total = new_items_count + self.targets.len();\n \n         self.targets.reserve(new_items_count);\n-        self.inlines.ensure(new_items_count_total);\n \n-        for (i, (Spanned { node: mono_item, .. }, inlined)) in new_targets.into_iter().enumerate() {\n+        for Spanned { node: mono_item, .. } in new_targets.into_iter() {\n             self.targets.push(*mono_item);\n-            if *inlined {\n-                self.inlines.insert(i + start_index);\n-            }\n         }\n \n         let end_index = self.targets.len();\n@@ -300,13 +250,14 @@ impl<'tcx> InliningMap<'tcx> {\n \n     /// Internally iterate over all items referenced by `source` which will be\n     /// made available for inlining.\n-    pub fn with_inlining_candidates<F>(&self, source: MonoItem<'tcx>, mut f: F)\n+    pub fn with_inlining_candidates<F>(&self, tcx: TyCtxt<'tcx>, source: MonoItem<'tcx>, mut f: F)\n     where\n         F: FnMut(MonoItem<'tcx>),\n     {\n         if let Some(range) = self.index.get(&source) {\n-            for (i, candidate) in self.targets[range.clone()].iter().enumerate() {\n-                if self.inlines.contains(range.start + i) {\n+            for candidate in self.targets[range.clone()].iter() {\n+                let is_inlined = candidate.instantiation_mode(tcx) == InstantiationMode::LocalCopy;\n+                if is_inlined {\n                     f(*candidate);\n                 }\n             }\n@@ -367,7 +318,7 @@ pub fn collect_crate_mono_items(\n #[instrument(skip(tcx, mode), level = \"debug\")]\n fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<'_>> {\n     debug!(\"collecting roots\");\n-    let mut roots = MonoItems { compute_inlining: false, tcx, items: Vec::new() };\n+    let mut roots = Vec::new();\n \n     {\n         let entry_fn = tcx.entry_fn(());\n@@ -393,9 +344,8 @@ fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<\n     // whose predicates hold. Luckily, items that aren't instantiable\n     // can't actually be used, so we can just skip codegenning them.\n     roots\n-        .items\n         .into_iter()\n-        .filter_map(|(Spanned { node: mono_item, .. }, _)| {\n+        .filter_map(|Spanned { node: mono_item, .. }| {\n             mono_item.is_instantiable(tcx).then_some(mono_item)\n         })\n         .collect()\n@@ -417,7 +367,7 @@ fn collect_items_rec<'tcx>(\n         return;\n     }\n \n-    let mut neighbors = MonoItems { compute_inlining: true, tcx, items: Vec::new() };\n+    let mut neighbors = Vec::new();\n     let recursion_depth_reset;\n \n     //\n@@ -542,9 +492,9 @@ fn collect_items_rec<'tcx>(\n             formatted_item,\n         });\n     }\n-    inlining_map.lock_mut().record_accesses(starting_point.node, &neighbors.items);\n+    inlining_map.lock_mut().record_accesses(starting_point.node, &neighbors);\n \n-    for (neighbour, _) in neighbors.items {\n+    for neighbour in neighbors {\n         collect_items_rec(tcx, neighbour, visited, recursion_depths, recursion_limit, inlining_map);\n     }\n "}, {"sha": "0bacb58383dc09e6bf745f8b594f76792850ad5e", "filename": "compiler/rustc_monomorphize/src/partitioning.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -424,7 +424,7 @@ fn place_inlined_mono_items<'tcx>(\n         // Collect all items that need to be available in this codegen unit.\n         let mut reachable = FxHashSet::default();\n         for root in old_codegen_unit.items().keys() {\n-            follow_inlining(*root, cx.inlining_map, &mut reachable);\n+            follow_inlining(cx.tcx, *root, cx.inlining_map, &mut reachable);\n         }\n \n         let mut new_codegen_unit = CodegenUnit::new(old_codegen_unit.name());\n@@ -478,6 +478,7 @@ fn place_inlined_mono_items<'tcx>(\n     return mono_item_placements;\n \n     fn follow_inlining<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n         mono_item: MonoItem<'tcx>,\n         inlining_map: &InliningMap<'tcx>,\n         visited: &mut FxHashSet<MonoItem<'tcx>>,\n@@ -486,8 +487,8 @@ fn place_inlined_mono_items<'tcx>(\n             return;\n         }\n \n-        inlining_map.with_inlining_candidates(mono_item, |target| {\n-            follow_inlining(target, inlining_map, visited);\n+        inlining_map.with_inlining_candidates(tcx, mono_item, |target| {\n+            follow_inlining(tcx, target, inlining_map, visited);\n         });\n     }\n }"}, {"sha": "799085e9a8307cef532c6169ea1cb4a449dad14a", "filename": "library/core/src/convert/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -495,8 +495,7 @@ pub trait Into<T>: Sized {\n /// By converting underlying error types to our own custom error type that encapsulates the\n /// underlying error type, we can return a single error type without losing information on the\n /// underlying cause. The '?' operator automatically converts the underlying error type to our\n-/// custom error type by calling `Into<CliError>::into` which is automatically provided when\n-/// implementing `From`. The compiler then infers which implementation of `Into` should be used.\n+/// custom error type with `From::from`.\n ///\n /// ```\n /// use std::fs;"}, {"sha": "1c27320024a9f5d3e3347d7ca5cf66058e5376e4", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -381,7 +381,6 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, I> {\n             Some(Event::Code(text)) => {\n                 trace!(\"saw code {}\", text);\n                 if let Some(link) = self.shortcut_link {\n-                    trace!(\"original text was {}\", link.original_text);\n                     // NOTE: this only replaces if the code block is the *entire* text.\n                     // If only part of the link has code highlighting, the disambiguator will not be removed.\n                     // e.g. [fn@`f`]\n@@ -390,8 +389,11 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, I> {\n                     // So we could never be sure we weren't replacing too much:\n                     // [fn@my_`f`unc] is treated the same as [my_func()] in that pass.\n                     //\n-                    // NOTE: &[1..len() - 1] is to strip the backticks\n-                    if **text == link.original_text[1..link.original_text.len() - 1] {\n+                    // NOTE: .get(1..len() - 1) is to strip the backticks\n+                    if let Some(link) = self.links.iter().find(|l| {\n+                        l.href == link.href\n+                            && Some(&**text) == l.original_text.get(1..l.original_text.len() - 1)\n+                    }) {\n                         debug!(\"replacing {} with {}\", text, link.new_text);\n                         *text = CowStr::Borrowed(&link.new_text);\n                     }\n@@ -402,9 +404,12 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, I> {\n             Some(Event::Text(text)) => {\n                 trace!(\"saw text {}\", text);\n                 if let Some(link) = self.shortcut_link {\n-                    trace!(\"original text was {}\", link.original_text);\n                     // NOTE: same limitations as `Event::Code`\n-                    if **text == *link.original_text {\n+                    if let Some(link) = self\n+                        .links\n+                        .iter()\n+                        .find(|l| l.href == link.href && **text == *l.original_text)\n+                    {\n                         debug!(\"replacing {} with {}\", text, link.new_text);\n                         *text = CowStr::Borrowed(&link.new_text);\n                     }"}, {"sha": "054cfe7597ea52fe6d5edcb8b10a4beb5e5d07a1", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -1179,6 +1179,10 @@ a.test-arrow:hover {\n \tposition: relative;\n }\n \n+.code-header a.tooltip:hover {\n+\tcolor: var(--link-color);\n+}\n+\n /* placeholder thunk so that the mouse can easily travel from \"(i)\" to popover\n \tthe resulting \"hover tunnel\" is a stepped triangle, approximating\n \thttps://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown */\n@@ -1191,6 +1195,14 @@ a.tooltip:hover::after {\n \tcontent: \"\\00a0\";\n }\n \n+/* This animation is layered onto the mistake-proofing delay for dismissing\n+\ta hovered tooltip, to ensure it feels responsive even with the delay.\n+\t*/\n+.fade-out {\n+\topacity: 0;\n+\ttransition: opacity 0.45s cubic-bezier(0, 0, 0.1, 1.0);\n+}\n+\n .popover.tooltip .content {\n \tmargin: 0.25em 0.5em;\n }"}, {"sha": "6da51ea0a55e7f58675dd0370972d48e3079450d", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 138, "deletions": 10, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -4,6 +4,13 @@\n \n \"use strict\";\n \n+// The amount of time that the cursor must remain still over a hover target before\n+// revealing a tooltip.\n+//\n+// https://www.nngroup.com/articles/timing-exposing-content/\n+window.RUSTDOC_TOOLTIP_HOVER_MS = 300;\n+window.RUSTDOC_TOOLTIP_HOVER_EXIT_MS = 450;\n+\n // Given a basename (e.g. \"storage\") and an extension (e.g. \".js\"), return a URL\n // for a resource under the root-path, with the resource-suffix.\n function resourcePath(basename, extension) {\n@@ -772,6 +779,13 @@ function preLoadCss(cssUrl) {\n         });\n     });\n \n+    /**\n+     * Show a tooltip immediately.\n+     *\n+     * @param {DOMElement} e - The tooltip's anchor point. The DOM is consulted to figure\n+     *                         out what the tooltip should contain, and where it should be\n+     *                         positioned.\n+     */\n     function showTooltip(e) {\n         const notable_ty = e.getAttribute(\"data-notable-ty\");\n         if (!window.NOTABLE_TRAITS && notable_ty) {\n@@ -782,20 +796,29 @@ function preLoadCss(cssUrl) {\n                 throw new Error(\"showTooltip() called with notable without any notable traits!\");\n             }\n         }\n+        // Make this function idempotent. If the tooltip is already shown, avoid doing extra work\n+        // and leave it alone.\n         if (window.CURRENT_TOOLTIP_ELEMENT && window.CURRENT_TOOLTIP_ELEMENT.TOOLTIP_BASE === e) {\n-            // Make this function idempotent.\n+            clearTooltipHoverTimeout(window.CURRENT_TOOLTIP_ELEMENT);\n             return;\n         }\n         window.hideAllModals(false);\n         const wrapper = document.createElement(\"div\");\n         if (notable_ty) {\n             wrapper.innerHTML = \"<div class=\\\"content\\\">\" +\n                 window.NOTABLE_TRAITS[notable_ty] + \"</div>\";\n-        } else if (e.getAttribute(\"title\") !== undefined) {\n-            const titleContent = document.createElement(\"div\");\n-            titleContent.className = \"content\";\n-            titleContent.appendChild(document.createTextNode(e.getAttribute(\"title\")));\n-            wrapper.appendChild(titleContent);\n+        } else {\n+            // Replace any `title` attribute with `data-title` to avoid double tooltips.\n+            if (e.getAttribute(\"title\") !== null) {\n+                e.setAttribute(\"data-title\", e.getAttribute(\"title\"));\n+                e.removeAttribute(\"title\");\n+            }\n+            if (e.getAttribute(\"data-title\") !== null) {\n+                const titleContent = document.createElement(\"div\");\n+                titleContent.className = \"content\";\n+                titleContent.appendChild(document.createTextNode(e.getAttribute(\"data-title\")));\n+                wrapper.appendChild(titleContent);\n+            }\n         }\n         wrapper.className = \"tooltip popover\";\n         const focusCatcher = document.createElement(\"div\");\n@@ -824,17 +847,77 @@ function preLoadCss(cssUrl) {\n         wrapper.style.visibility = \"\";\n         window.CURRENT_TOOLTIP_ELEMENT = wrapper;\n         window.CURRENT_TOOLTIP_ELEMENT.TOOLTIP_BASE = e;\n+        clearTooltipHoverTimeout(window.CURRENT_TOOLTIP_ELEMENT);\n+        wrapper.onpointerenter = function(ev) {\n+            // If this is a synthetic touch event, ignore it. A click event will be along shortly.\n+            if (ev.pointerType !== \"mouse\") {\n+                return;\n+            }\n+            clearTooltipHoverTimeout(e);\n+        };\n         wrapper.onpointerleave = function(ev) {\n             // If this is a synthetic touch event, ignore it. A click event will be along shortly.\n             if (ev.pointerType !== \"mouse\") {\n                 return;\n             }\n-            if (!e.TOOLTIP_FORCE_VISIBLE && !elemIsInParent(event.relatedTarget, e)) {\n-                hideTooltip(true);\n+            if (!e.TOOLTIP_FORCE_VISIBLE && !elemIsInParent(ev.relatedTarget, e)) {\n+                // See \"Tooltip pointer leave gesture\" below.\n+                setTooltipHoverTimeout(e, false);\n+                addClass(wrapper, \"fade-out\");\n             }\n         };\n     }\n \n+    /**\n+     * Show or hide the tooltip after a timeout. If a timeout was already set before this function\n+     * was called, that timeout gets cleared. If the tooltip is already in the requested state,\n+     * this function will still clear any pending timeout, but otherwise do nothing.\n+     *\n+     * @param {DOMElement} element - The tooltip's anchor point. The DOM is consulted to figure\n+     *                               out what the tooltip should contain, and where it should be\n+     *                               positioned.\n+     * @param {boolean}    show    - If true, the tooltip will be made visible. If false, it will\n+     *                               be hidden.\n+     */\n+    function setTooltipHoverTimeout(element, show) {\n+        clearTooltipHoverTimeout(element);\n+        if (!show && !window.CURRENT_TOOLTIP_ELEMENT) {\n+            // To \"hide\" an already hidden element, just cancel its timeout.\n+            return;\n+        }\n+        if (show && window.CURRENT_TOOLTIP_ELEMENT) {\n+            // To \"show\" an already visible element, just cancel its timeout.\n+            return;\n+        }\n+        if (window.CURRENT_TOOLTIP_ELEMENT &&\n+            window.CURRENT_TOOLTIP_ELEMENT.TOOLTIP_BASE !== element) {\n+            // Don't do anything if another tooltip is already visible.\n+            return;\n+        }\n+        element.TOOLTIP_HOVER_TIMEOUT = setTimeout(() => {\n+            if (show) {\n+                showTooltip(element);\n+            } else if (!element.TOOLTIP_FORCE_VISIBLE) {\n+                hideTooltip(false);\n+            }\n+        }, show ? window.RUSTDOC_TOOLTIP_HOVER_MS : window.RUSTDOC_TOOLTIP_HOVER_EXIT_MS);\n+    }\n+\n+    /**\n+     * If a show/hide timeout was set by `setTooltipHoverTimeout`, cancel it. If none exists,\n+     * do nothing.\n+     *\n+     * @param {DOMElement} element - The tooltip's anchor point,\n+     *                               as passed to `setTooltipHoverTimeout`.\n+     */\n+    function clearTooltipHoverTimeout(element) {\n+        if (element.TOOLTIP_HOVER_TIMEOUT !== undefined) {\n+            removeClass(window.CURRENT_TOOLTIP_ELEMENT, \"fade-out\");\n+            clearTimeout(element.TOOLTIP_HOVER_TIMEOUT);\n+            delete element.TOOLTIP_HOVER_TIMEOUT;\n+        }\n+    }\n+\n     function tooltipBlurHandler(event) {\n         if (window.CURRENT_TOOLTIP_ELEMENT &&\n             !elemIsInParent(document.activeElement, window.CURRENT_TOOLTIP_ELEMENT) &&\n@@ -854,6 +937,12 @@ function preLoadCss(cssUrl) {\n         }\n     }\n \n+    /**\n+     * Hide the current tooltip immediately.\n+     *\n+     * @param {boolean} focus - If set to `true`, move keyboard focus to the tooltip anchor point.\n+     *                          If set to `false`, leave keyboard focus alone.\n+     */\n     function hideTooltip(focus) {\n         if (window.CURRENT_TOOLTIP_ELEMENT) {\n             if (window.CURRENT_TOOLTIP_ELEMENT.TOOLTIP_BASE.TOOLTIP_FORCE_VISIBLE) {\n@@ -864,6 +953,7 @@ function preLoadCss(cssUrl) {\n             }\n             const body = document.getElementsByTagName(\"body\")[0];\n             body.removeChild(window.CURRENT_TOOLTIP_ELEMENT);\n+            clearTooltipHoverTimeout(window.CURRENT_TOOLTIP_ELEMENT);\n             window.CURRENT_TOOLTIP_ELEMENT = null;\n         }\n     }\n@@ -886,7 +976,14 @@ function preLoadCss(cssUrl) {\n             if (ev.pointerType !== \"mouse\") {\n                 return;\n             }\n-            showTooltip(this);\n+            setTooltipHoverTimeout(this, true);\n+        };\n+        e.onpointermove = function(ev) {\n+            // If this is a synthetic touch event, ignore it. A click event will be along shortly.\n+            if (ev.pointerType !== \"mouse\") {\n+                return;\n+            }\n+            setTooltipHoverTimeout(this, true);\n         };\n         e.onpointerleave = function(ev) {\n             // If this is a synthetic touch event, ignore it. A click event will be along shortly.\n@@ -895,7 +992,38 @@ function preLoadCss(cssUrl) {\n             }\n             if (!this.TOOLTIP_FORCE_VISIBLE &&\n                 !elemIsInParent(ev.relatedTarget, window.CURRENT_TOOLTIP_ELEMENT)) {\n-                hideTooltip(true);\n+                // Tooltip pointer leave gesture:\n+                //\n+                // Designing a good hover microinteraction is a matter of guessing user\n+                // intent from what are, literally, vague gestures. In this case, guessing if\n+                // hovering in or out of the tooltip base is intentional or not.\n+                //\n+                // To figure this out, a few different techniques are used:\n+                //\n+                // * When the mouse pointer enters a tooltip anchor point, its hitbox is grown\n+                //   on the bottom, where the popover is/will appear. Search \"hover tunnel\" in\n+                //   rustdoc.css for the implementation.\n+                // * There's a delay when the mouse pointer enters the popover base anchor, in\n+                //   case the mouse pointer was just passing through and the user didn't want\n+                //   to open it.\n+                // * Similarly, a delay is added when exiting the anchor, or the popover\n+                //   itself, before hiding it.\n+                // * A fade-out animation is layered onto the pointer exit delay to immediately\n+                //   inform the user that they successfully dismissed the popover, while still\n+                //   providing a way for them to cancel it if it was a mistake and they still\n+                //   wanted to interact with it.\n+                // * No animation is used for revealing it, because we don't want people to try\n+                //   to interact with an element while it's in the middle of fading in: either\n+                //   they're allowed to interact with it while it's fading in, meaning it can't\n+                //   serve as mistake-proofing for the popover, or they can't, but\n+                //   they might try and be frustrated.\n+                //\n+                // See also:\n+                // * https://www.nngroup.com/articles/timing-exposing-content/\n+                // * https://www.nngroup.com/articles/tooltip-guidelines/\n+                // * https://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown\n+                setTooltipHoverTimeout(e, false);\n+                addClass(window.CURRENT_TOOLTIP_ELEMENT, \"fade-out\");\n             }\n         };\n     });"}, {"sha": "fe42494000e1704bd40c95d262195428e3cad26b", "filename": "tests/codegen/intrinsics/transmute.rs", "status": "modified", "additions": 71, "deletions": 4, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -14,10 +14,10 @@ use std::intrinsics::{transmute, transmute_unchecked};\n // Some of these need custom MIR to not get removed by MIR optimizations.\n use std::intrinsics::mir::*;\n \n-enum Never {}\n+pub enum ZstNever {}\n \n #[repr(align(2))]\n-pub struct BigNever(Never, u16, Never);\n+pub struct BigNever(ZstNever, u16, ZstNever);\n \n #[repr(align(8))]\n pub struct Scalar64(i64);\n@@ -56,11 +56,13 @@ pub unsafe fn check_bigger_array(x: [u32; 3]) -> [u32; 7] {\n     transmute_unchecked(x)\n }\n \n-// CHECK-LABEL: @check_to_uninhabited(\n+// CHECK-LABEL: @check_to_empty_array(\n #[no_mangle]\n #[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n-pub unsafe fn check_to_uninhabited(x: u16) -> BigNever {\n+pub unsafe fn check_to_empty_array(x: [u32; 5]) -> [u32; 0] {\n+    // CHECK-NOT: trap\n     // CHECK: call void @llvm.trap\n+    // CHECK-NOT: trap\n     mir!{\n         {\n             RET = CastTransmute(x);\n@@ -69,6 +71,37 @@ pub unsafe fn check_to_uninhabited(x: u16) -> BigNever {\n     }\n }\n \n+// CHECK-LABEL: @check_from_empty_array(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n+pub unsafe fn check_from_empty_array(x: [u32; 0]) -> [u32; 5] {\n+    // CHECK-NOT: trap\n+    // CHECK: call void @llvm.trap\n+    // CHECK-NOT: trap\n+    mir!{\n+        {\n+            RET = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n+// CHECK-LABEL: @check_to_uninhabited(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n+pub unsafe fn check_to_uninhabited(x: u16) {\n+    // CHECK-NOT: trap\n+    // CHECK: call void @llvm.trap\n+    // CHECK-NOT: trap\n+    mir!{\n+        let temp: BigNever;\n+        {\n+            temp = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n // CHECK-LABEL: @check_from_uninhabited(\n #[no_mangle]\n #[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n@@ -366,6 +399,40 @@ pub unsafe fn check_issue_109992(x: ()) -> [(); 1] {\n     }\n }\n \n+// CHECK-LABEL: @check_unit_to_never(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n+pub unsafe fn check_unit_to_never(x: ()) {\n+    // This uses custom MIR to avoid MIR optimizations having removed ZST ops.\n+\n+    // CHECK-NOT: trap\n+    // CHECK: call void @llvm.trap\n+    // CHECK-NOT: trap\n+    mir!{\n+        let temp: ZstNever;\n+        {\n+            temp = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n+// CHECK-LABEL: @check_unit_from_never(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n+pub unsafe fn check_unit_from_never(x: ZstNever) -> () {\n+    // This uses custom MIR to avoid MIR optimizations having removed ZST ops.\n+\n+    // CHECK: start\n+    // CHECK-NEXT: ret void\n+    mir!{\n+        {\n+            RET = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n // CHECK-LABEL: @check_maybe_uninit_pair(i16 %x.0, i64 %x.1)\n #[no_mangle]\n pub unsafe fn check_maybe_uninit_pair("}, {"sha": "7be5e39ba4727f87ee42622bcb84482078794cea", "filename": "tests/rustdoc-gui/codeblock-tooltip.goml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Frustdoc-gui%2Fcodeblock-tooltip.goml", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Frustdoc-gui%2Fcodeblock-tooltip.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fcodeblock-tooltip.goml?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -40,6 +40,7 @@ define-function: (\n             \"background-color\": |background|,\n             \"border-color\": |border|,\n         })\n+        click: \".docblock .example-wrap.compile_fail .tooltip\"\n \n         // should_panic block\n         assert-css: (\n@@ -71,6 +72,7 @@ define-function: (\n             \"background-color\": |background|,\n             \"border-color\": |border|,\n         })\n+        click: \".docblock .example-wrap.should_panic .tooltip\"\n \n         // ignore block\n         assert-css: ("}, {"sha": "371931d51fccc76ef7207072ee8af87ca70c7c4c", "filename": "tests/rustdoc-gui/notable-trait.goml", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Frustdoc-gui%2Fnotable-trait.goml", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Frustdoc-gui%2Fnotable-trait.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fnotable-trait.goml?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -122,7 +122,7 @@ assert-count: (\"//*[@class='tooltip popover']\", 0)\n // Now check the colors.\n define-function: (\n     \"check-colors\",\n-    (theme, header_color, content_color, type_color, trait_color),\n+    (theme, header_color, content_color, type_color, trait_color, link_color),\n     block {\n         go-to: \"file://\" + |DOC_PATH| + \"/test_docs/struct.NotableStructWithLongName.html\"\n         // This is needed to ensure that the text color is computed.\n@@ -133,8 +133,20 @@ define-function: (\n         // We reload the page so the local storage settings are being used.\n         reload:\n \n+        assert-css: (\n+             \"//*[@id='method.create_an_iterator_from_read']//*[@class='tooltip']\",\n+             {\"color\": |content_color|},\n+             ALL,\n+        )\n+\n         move-cursor-to: \"//*[@id='method.create_an_iterator_from_read']//*[@class='tooltip']\"\n-        assert-count: (\".tooltip.popover\", 1)\n+        wait-for-count: (\".tooltip.popover\", 1)\n+\n+        assert-css: (\n+             \"//*[@id='method.create_an_iterator_from_read']//*[@class='tooltip']\",\n+             {\"color\": |link_color|},\n+             ALL,\n+        )\n \n         assert-css: (\n              \".tooltip.popover h3\",\n@@ -163,6 +175,7 @@ call-function: (\n     \"check-colors\",\n     {\n         \"theme\": \"ayu\",\n+        \"link_color\": \"rgb(57, 175, 215)\",\n         \"content_color\": \"rgb(230, 225, 207)\",\n         \"header_color\": \"rgb(255, 255, 255)\",\n         \"type_color\": \"rgb(255, 160, 165)\",\n@@ -174,6 +187,7 @@ call-function: (\n     \"check-colors\",\n     {\n         \"theme\": \"dark\",\n+        \"link_color\": \"rgb(210, 153, 29)\",\n         \"content_color\": \"rgb(221, 221, 221)\",\n         \"header_color\": \"rgb(221, 221, 221)\",\n         \"type_color\": \"rgb(45, 191, 184)\",\n@@ -185,6 +199,7 @@ call-function: (\n     \"check-colors\",\n     {\n         \"theme\": \"light\",\n+        \"link_color\": \"rgb(56, 115, 173)\",\n         \"content_color\": \"rgb(0, 0, 0)\",\n         \"header_color\": \"rgb(0, 0, 0)\",\n         \"type_color\": \"rgb(173, 55, 138)\","}, {"sha": "eb1c7a05e54097098212a322763d475a010d5267", "filename": "tests/rustdoc/intra-doc/issue-108459.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Frustdoc%2Fintra-doc%2Fissue-108459.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Frustdoc%2Fintra-doc%2Fissue-108459.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fintra-doc%2Fissue-108459.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -0,0 +1,37 @@\n+#![deny(rustdoc::broken_intra_doc_links)]\n+\n+pub struct S;\n+pub mod char {}\n+\n+// Ensure this doesn't ICE due to trying to slice off non-existent backticks from \"S\"\n+\n+/// See [S] and [`S`]\n+pub struct MyStruct1;\n+\n+// Ensure that link texts are replaced correctly even if there are multiple links with\n+// the same target but different text\n+\n+/// See also [crate::char] and [mod@char] and [prim@char]\n+// @has issue_108459/struct.MyStruct2.html '//*[@href=\"char/index.html\"]' 'crate::char'\n+// @has - '//*[@href=\"char/index.html\"]' 'char'\n+// @has - '//*[@href=\"{{channel}}/std/primitive.char.html\"]' 'char'\n+pub struct MyStruct2;\n+\n+/// See also [mod@char] and [prim@char] and [crate::char]\n+// @has issue_108459/struct.MyStruct3.html '//*[@href=\"char/index.html\"]' 'crate::char'\n+// @has - '//*[@href=\"char/index.html\"]' 'char'\n+// @has - '//*[@href=\"{{channel}}/std/primitive.char.html\"]' 'char'\n+pub struct MyStruct3;\n+\n+// Ensure that links are correct even if there are multiple links with the same text but\n+// different targets\n+\n+/// See also [char][mod@char] and [char][prim@char]\n+// @has issue_108459/struct.MyStruct4.html '//*[@href=\"char/index.html\"]' 'char'\n+// @has - '//*[@href=\"{{channel}}/std/primitive.char.html\"]' 'char'\n+pub struct MyStruct4;\n+\n+/// See also [char][prim@char] and [char][crate::char]\n+// @has issue_108459/struct.MyStruct5.html '//*[@href=\"char/index.html\"]' 'char'\n+// @has - '//*[@href=\"{{channel}}/std/primitive.char.html\"]' 'char'\n+pub struct MyStruct5;"}, {"sha": "c5a64e42a01248001d5b11eba64c6745307398eb", "filename": "tests/rustdoc/intra-doc/prim-precedence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Frustdoc%2Fintra-doc%2Fprim-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Frustdoc%2Fintra-doc%2Fprim-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fintra-doc%2Fprim-precedence.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -12,5 +12,5 @@ pub struct MyString;\n \n /// See also [crate::char] and [mod@char]\n // @has prim_precedence/struct.MyString2.html '//*[@href=\"char/index.html\"]' 'crate::char'\n-// @has - '//*[@href=\"char/index.html\"]' 'mod@char'\n+// @has - '//*[@href=\"char/index.html\"]' 'char'\n pub struct MyString2;"}, {"sha": "e6d46b02706b1c523c13f4fb2b73e898c397498d", "filename": "tests/ui/chalkify/bugs/async.stderr", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchalkify%2Fbugs%2Fasync.stderr?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -13,16 +13,9 @@ error: internal compiler error: projection clauses should be implied from elsewh\n LL | async fn foo(x: u32) -> u32 {\n    |                         ^^^query stack during panic:\n #0 [typeck] type-checking `foo`\n-#1 [thir_body] building THIR for `foo`\n-#2 [check_match] match-checking `foo`\n-#3 [mir_built] building MIR for `foo`\n-#4 [unsafety_check_result] unsafety-checking `foo`\n-#5 [mir_const] preparing `foo` for borrow checking\n-#6 [mir_promoted] promoting constants in MIR for `foo`\n-#7 [mir_borrowck] borrow-checking `foo`\n-#8 [type_of] computing type of `foo::{opaque#0}`\n-#9 [check_mod_item_types] checking item types in top-level module\n-#10 [analysis] running analysis passes on this crate\n+#1 [type_of] computing type of `foo::{opaque#0}`\n+#2 [check_mod_item_types] checking item types in top-level module\n+#3 [analysis] running analysis passes on this crate\n end of query stack\n error: aborting due to 2 previous errors\n "}, {"sha": "408abecc30d4426929f583034ecf1b58a6c246ca", "filename": "tests/ui/dyn-star/param-env-infer.next.stderr", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Fui%2Fdyn-star%2Fparam-env-infer.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Fui%2Fdyn-star%2Fparam-env-infer.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdyn-star%2Fparam-env-infer.next.stderr?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -13,41 +13,6 @@ error[E0391]: cycle detected when computing type of `make_dyn_star::{opaque#0}`\n LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n    |                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-note: ...which requires borrow-checking `make_dyn_star`...\n-  --> $DIR/param-env-infer.rs:11:1\n-   |\n-LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires promoting constants in MIR for `make_dyn_star`...\n-  --> $DIR/param-env-infer.rs:11:1\n-   |\n-LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires preparing `make_dyn_star` for borrow checking...\n-  --> $DIR/param-env-infer.rs:11:1\n-   |\n-LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires unsafety-checking `make_dyn_star`...\n-  --> $DIR/param-env-infer.rs:11:1\n-   |\n-LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building MIR for `make_dyn_star`...\n-  --> $DIR/param-env-infer.rs:11:1\n-   |\n-LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires match-checking `make_dyn_star`...\n-  --> $DIR/param-env-infer.rs:11:1\n-   |\n-LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building THIR for `make_dyn_star`...\n-  --> $DIR/param-env-infer.rs:11:1\n-   |\n-LL | fn make_dyn_star<'a, T: PointerLike + Debug + 'a>(t: T) -> impl PointerLike + Debug + 'a {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires type-checking `make_dyn_star`...\n   --> $DIR/param-env-infer.rs:11:1\n    |"}, {"sha": "c0c4cd5013e5fffaafe68a0f581fcd36b7d43cd5", "filename": "tests/ui/impl-trait/auto-trait-leak.stderr", "status": "modified", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -4,41 +4,6 @@ error[E0391]: cycle detected when computing type of `cycle1::{opaque#0}`\n LL | fn cycle1() -> impl Clone {\n    |                ^^^^^^^^^^\n    |\n-note: ...which requires borrow-checking `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires promoting constants in MIR for `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires preparing `cycle1` for borrow checking...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires unsafety-checking `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building MIR for `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires match-checking `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building THIR for `cycle1`...\n-  --> $DIR/auto-trait-leak.rs:12:1\n-   |\n-LL | fn cycle1() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires type-checking `cycle1`...\n   --> $DIR/auto-trait-leak.rs:14:5\n    |\n@@ -50,41 +15,6 @@ note: ...which requires computing type of `cycle2::{opaque#0}`...\n    |\n LL | fn cycle2() -> impl Clone {\n    |                ^^^^^^^^^^\n-note: ...which requires borrow-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires promoting constants in MIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires preparing `cycle2` for borrow checking...\n-  --> $DIR/auto-trait-leak.rs:19:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires unsafety-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building MIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires match-checking `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: ...which requires building THIR for `cycle2`...\n-  --> $DIR/auto-trait-leak.rs:19:1\n-   |\n-LL | fn cycle2() -> impl Clone {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires type-checking `cycle2`...\n   --> $DIR/auto-trait-leak.rs:20:5\n    |"}, {"sha": "86661153a0d098a57e985b87256b0eb6e6d3e41a", "filename": "tests/ui/impl-trait/multiple-defining-usages-in-body.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Fui%2Fimpl-trait%2Fmultiple-defining-usages-in-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Fui%2Fimpl-trait%2Fmultiple-defining-usages-in-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fmultiple-defining-usages-in-body.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -4,9 +4,9 @@ impl Trait for () {}\n fn foo<T: Trait, U: Trait>() -> impl Trait {\n     //~^ WARN function cannot return without recursing [unconditional_recursion]\n     let a: T = foo::<T, U>();\n-    //~^ ERROR concrete type differs from previous defining opaque type use\n     loop {}\n     let _: T = foo::<U, T>();\n+    //~^ ERROR concrete type differs from previous defining opaque type use\n }\n \n fn main() {}"}, {"sha": "f3c090408b42e804f89fde74ab66b82fb7d35d2f", "filename": "tests/ui/impl-trait/multiple-defining-usages-in-body.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Fui%2Fimpl-trait%2Fmultiple-defining-usages-in-body.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Fui%2Fimpl-trait%2Fmultiple-defining-usages-in-body.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fmultiple-defining-usages-in-body.stderr?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -11,15 +11,15 @@ LL |     let a: T = foo::<T, U>();\n    = note: `#[warn(unconditional_recursion)]` on by default\n \n error: concrete type differs from previous defining opaque type use\n-  --> $DIR/multiple-defining-usages-in-body.rs:6:16\n+  --> $DIR/multiple-defining-usages-in-body.rs:8:16\n    |\n-LL |     let a: T = foo::<T, U>();\n-   |                ^^^^^^^^^^^^^ expected `U`, got `T`\n+LL |     let _: T = foo::<U, T>();\n+   |                ^^^^^^^^^^^^^ expected `T`, got `U`\n    |\n note: previous use here\n-  --> $DIR/multiple-defining-usages-in-body.rs:9:16\n+  --> $DIR/multiple-defining-usages-in-body.rs:6:16\n    |\n-LL |     let _: T = foo::<U, T>();\n+LL |     let a: T = foo::<T, U>();\n    |                ^^^^^^^^^^^^^\n \n error: aborting due to previous error; 1 warning emitted"}, {"sha": "b46ba89e81d7f7c31af50ca113dd0621a05fa579", "filename": "tests/ui/loops/dont-suggest-break-thru-item.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Fui%2Floops%2Fdont-suggest-break-thru-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Fui%2Floops%2Fdont-suggest-break-thru-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Floops%2Fdont-suggest-break-thru-item.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -0,0 +1,55 @@\n+// edition:2021\n+\n+#![feature(inline_const)]\n+\n+fn closure() {\n+    loop {\n+        let closure = || {\n+            if true {\n+                Err(1)\n+                //~^ ERROR mismatched types\n+            }\n+\n+            Ok(())\n+        };\n+    }\n+}\n+\n+fn async_block() {\n+    loop {\n+        let fut = async {\n+            if true {\n+                Err(1)\n+                //~^ ERROR mismatched types\n+            }\n+\n+            Ok(())\n+        };\n+    }\n+}\n+\n+fn fn_item() {\n+    let _ = loop {\n+        fn foo() -> Result<(), ()> {\n+            if true {\n+                Err(1)\n+                //~^ ERROR mismatched types\n+            }\n+            Err(())\n+        }\n+    };\n+}\n+\n+fn const_block() {\n+    let _ = loop {\n+        const {\n+            if true {\n+                Err(1)\n+                //~^ ERROR mismatched types\n+            }\n+            Err(())\n+        };\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "4fce4715119047f7633686ad3663fac051f7600e", "filename": "tests/ui/loops/dont-suggest-break-thru-item.stderr", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Fui%2Floops%2Fdont-suggest-break-thru-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Fui%2Floops%2Fdont-suggest-break-thru-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Floops%2Fdont-suggest-break-thru-item.stderr?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -0,0 +1,55 @@\n+error[E0308]: mismatched types\n+  --> $DIR/dont-suggest-break-thru-item.rs:9:17\n+   |\n+LL | /             if true {\n+LL | |                 Err(1)\n+   | |                 ^^^^^^ expected `()`, found `Result<_, {integer}>`\n+LL | |\n+LL | |             }\n+   | |_____________- expected this to be `()`\n+   |\n+   = note: expected unit type `()`\n+                   found enum `Result<_, {integer}>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/dont-suggest-break-thru-item.rs:22:17\n+   |\n+LL | /             if true {\n+LL | |                 Err(1)\n+   | |                 ^^^^^^ expected `()`, found `Result<_, {integer}>`\n+LL | |\n+LL | |             }\n+   | |_____________- expected this to be `()`\n+   |\n+   = note: expected unit type `()`\n+                   found enum `Result<_, {integer}>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/dont-suggest-break-thru-item.rs:35:17\n+   |\n+LL | /             if true {\n+LL | |                 Err(1)\n+   | |                 ^^^^^^ expected `()`, found `Result<_, {integer}>`\n+LL | |\n+LL | |             }\n+   | |_____________- expected this to be `()`\n+   |\n+   = note: expected unit type `()`\n+                   found enum `Result<_, {integer}>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/dont-suggest-break-thru-item.rs:47:17\n+   |\n+LL | /             if true {\n+LL | |                 Err(1)\n+   | |                 ^^^^^^ expected `()`, found `Result<_, {integer}>`\n+LL | |\n+LL | |             }\n+   | |_____________- expected this to be `()`\n+   |\n+   = note: expected unit type `()`\n+                   found enum `Result<_, {integer}>`\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "028222f4e6dba451272373f4ed485bdce95aaf57", "filename": "tests/ui/traits/new-solver/dont-remap-tait-substs.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Fui%2Ftraits%2Fnew-solver%2Fdont-remap-tait-substs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Fui%2Ftraits%2Fnew-solver%2Fdont-remap-tait-substs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fdont-remap-tait-substs.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -0,0 +1,19 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+// Makes sure we don't prepopulate the MIR typeck of `define`\n+// with `Foo<T, U> = T`, but instead, `Foo<B, A> = B`, so that\n+// the param-env predicates actually apply.\n+\n+#![feature(type_alias_impl_trait)]\n+\n+type Foo<T: Send, U> = impl NeedsSend<T>;\n+\n+trait NeedsSend<T> {}\n+impl<T: Send> NeedsSend<T> for T {}\n+\n+fn define<A, B: Send>(a: A, b: B) {\n+    let y: Option<Foo<B, A>> = Some(b);\n+}\n+\n+fn main() {}"}, {"sha": "07f3dd1997bed87584b3bc001aa41c898cfe04cd", "filename": "tests/ui/type-alias-impl-trait/cross_inference.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Fui%2Ftype-alias-impl-trait%2Fcross_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Fui%2Ftype-alias-impl-trait%2Fcross_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fcross_inference.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -1,3 +1,5 @@\n+// revisions: current next\n+//[next] compile-flags: -Ztrait-solver=next\n // check-pass\n \n #![feature(type_alias_impl_trait)]"}, {"sha": "da845e86147b7ffb620f880936aae59069a2095f", "filename": "tests/ui/type-alias-impl-trait/multiple-def-uses-in-one-fn.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.rs?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -8,7 +8,6 @@ type X<A, B> = impl Into<&'static A>;\n \n fn f<A, B: 'static>(a: &'static A, b: B) -> (X<A, B>, X<B, A>) {\n     //~^ ERROR the trait bound `&'static B: From<&A>` is not satisfied\n-    //~| ERROR concrete type differs from previous defining opaque type use\n     (a, a)\n }\n "}, {"sha": "66a6b0bbf743148407ae5faa5a4d9d00815da3aa", "filename": "tests/ui/type-alias-impl-trait/multiple-def-uses-in-one-fn.stderr", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fabf9298633ca64450fa2af535252dc44a3b1080/tests%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn.stderr?ref=fabf9298633ca64450fa2af535252dc44a3b1080", "patch": "@@ -10,15 +10,6 @@ help: consider introducing a `where` clause, but there might be an alternative b\n LL | fn f<A, B: 'static>(a: &'static A, b: B) -> (X<A, B>, X<B, A>) where &'static B: From<&A> {\n    |                                                                ++++++++++++++++++++++++++\n \n-error: concrete type differs from previous defining opaque type use\n-  --> $DIR/multiple-def-uses-in-one-fn.rs:9:45\n-   |\n-LL | fn f<A, B: 'static>(a: &'static A, b: B) -> (X<A, B>, X<B, A>) {\n-   |                                             ^^^^^^^^^^^^^^^^^^\n-   |                                             |\n-   |                                             expected `&B`, got `&A`\n-   |                                             this expression supplies two conflicting concrete types for the same opaque type\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0277`."}]}