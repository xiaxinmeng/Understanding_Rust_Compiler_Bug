{"sha": "41a60ab7acb446ef190917ad95bdee7c18bed053", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxYTYwYWI3YWNiNDQ2ZWYxOTA5MTdhZDk1YmRlZTdjMThiZWQwNTM=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-08-14T11:35:46Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-08-15T02:09:19Z"}, "message": "Ported typeck/check/mod.rs from oldvisit to <V:Visitor> trait API.", "tree": {"sha": "aaec4a4f0abdd6f13fe9160b4390362b4fbf4b79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aaec4a4f0abdd6f13fe9160b4390362b4fbf4b79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41a60ab7acb446ef190917ad95bdee7c18bed053", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41a60ab7acb446ef190917ad95bdee7c18bed053", "html_url": "https://github.com/rust-lang/rust/commit/41a60ab7acb446ef190917ad95bdee7c18bed053", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41a60ab7acb446ef190917ad95bdee7c18bed053/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7328f4cc12cc271d458a03786ff7ec6c2f37b3cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/7328f4cc12cc271d458a03786ff7ec6c2f37b3cb", "html_url": "https://github.com/rust-lang/rust/commit/7328f4cc12cc271d458a03786ff7ec6c2f37b3cb"}], "stats": {"total": 169, "additions": 87, "deletions": 82}, "files": [{"sha": "258802c2699ff6af0e923f95cdfd417c18a7b037", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 87, "deletions": 82, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/41a60ab7acb446ef190917ad95bdee7c18bed053/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a60ab7acb446ef190917ad95bdee7c18bed053/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=41a60ab7acb446ef190917ad95bdee7c18bed053", "patch": "@@ -129,7 +129,8 @@ use syntax::opt_vec;\n use syntax::parse::token;\n use syntax::parse::token::special_idents;\n use syntax::print::pprust;\n-use syntax::oldvisit;\n+use syntax::visit;\n+use syntax::visit::Visitor;\n use syntax;\n \n pub mod _match;\n@@ -296,12 +297,18 @@ impl ExprTyProvider for FnCtxt {\n     }\n }\n \n+struct CheckItemTypesVisitor { ccx: @mut CrateCtxt }\n+\n+impl Visitor<()> for CheckItemTypesVisitor {\n+    fn visit_item(&mut self, i:@ast::item, _:()) {\n+        check_item(self.ccx, i);\n+        visit::walk_item(self, i, ());\n+    }\n+}\n+\n pub fn check_item_types(ccx: @mut CrateCtxt, crate: &ast::Crate) {\n-    let visit = oldvisit::mk_simple_visitor(@oldvisit::SimpleVisitor {\n-        visit_item: |a| check_item(ccx, a),\n-        .. *oldvisit::default_simple_visitor()\n-    });\n-    oldvisit::visit_crate(crate, ((), visit));\n+    let mut visit = CheckItemTypesVisitor { ccx: ccx };\n+    visit::walk_crate(&mut visit, crate, ());\n }\n \n pub fn check_bare_fn(ccx: @mut CrateCtxt,\n@@ -326,6 +333,76 @@ pub fn check_bare_fn(ccx: @mut CrateCtxt,\n     }\n }\n \n+struct GatherLocalsVisitor {\n+                     fcx: @mut FnCtxt,\n+                     tcx: ty::ctxt,\n+}\n+\n+impl GatherLocalsVisitor {\n+    fn assign(&mut self, nid: ast::NodeId, ty_opt: Option<ty::t>) {\n+            match ty_opt {\n+                None => {\n+                    // infer the variable's type\n+                    let var_id = self.fcx.infcx().next_ty_var_id();\n+                    let var_ty = ty::mk_var(self.fcx.tcx(), var_id);\n+                    self.fcx.inh.locals.insert(nid, var_ty);\n+                }\n+                Some(typ) => {\n+                    // take type that the user specified\n+                    self.fcx.inh.locals.insert(nid, typ);\n+                }\n+            }\n+    }\n+}\n+\n+impl Visitor<()> for GatherLocalsVisitor {\n+        // Add explicitly-declared locals.\n+    fn visit_local(&mut self, local:@ast::Local, _:()) {\n+            let o_ty = match local.ty.node {\n+              ast::ty_infer => None,\n+              _ => Some(self.fcx.to_ty(&local.ty))\n+            };\n+            self.assign(local.id, o_ty);\n+            debug!(\"Local variable %s is assigned type %s\",\n+                   self.fcx.pat_to_str(local.pat),\n+                   self.fcx.infcx().ty_to_str(\n+                       self.fcx.inh.locals.get_copy(&local.id)));\n+            visit::walk_local(self, local, ());\n+\n+    }\n+        // Add pattern bindings.\n+    fn visit_pat(&mut self, p:@ast::pat, _:()) {\n+            match p.node {\n+              ast::pat_ident(_, ref path, _)\n+                  if pat_util::pat_is_binding(self.fcx.ccx.tcx.def_map, p) => {\n+                self.assign(p.id, None);\n+                debug!(\"Pattern binding %s is assigned to %s\",\n+                       self.tcx.sess.str_of(path.idents[0]),\n+                       self.fcx.infcx().ty_to_str(\n+                           self.fcx.inh.locals.get_copy(&p.id)));\n+              }\n+              _ => {}\n+            }\n+            visit::walk_pat(self, p, ());\n+\n+    }\n+\n+    fn visit_block(&mut self, b:&ast::Block, _:()) {\n+            // non-obvious: the `blk` variable maps to region lb, so\n+            // we have to keep this up-to-date.  This\n+            // is... unfortunate.  It'd be nice to not need this.\n+            do self.fcx.with_region_lb(b.id) {\n+                visit::walk_block(self, b, ());\n+            }\n+    }\n+\n+        // Don't descend into fns and items\n+    fn visit_fn(&mut self, _:&visit::fn_kind, _:&ast::fn_decl,\n+                _:&ast::Block, _:span, _:ast::NodeId, _:()) { }\n+    fn visit_item(&mut self, _:@ast::item, _:()) { }\n+\n+}\n+\n pub fn check_fn(ccx: @mut CrateCtxt,\n                 opt_self_info: Option<SelfInfo>,\n                 purity: ast::purity,\n@@ -429,24 +506,11 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                      opt_self_info: Option<SelfInfo>) {\n         let tcx = fcx.ccx.tcx;\n \n-        let assign: @fn(ast::NodeId, Option<ty::t>) = |nid, ty_opt| {\n-            match ty_opt {\n-                None => {\n-                    // infer the variable's type\n-                    let var_id = fcx.infcx().next_ty_var_id();\n-                    let var_ty = ty::mk_var(fcx.tcx(), var_id);\n-                    fcx.inh.locals.insert(nid, var_ty);\n-                }\n-                Some(typ) => {\n-                    // take type that the user specified\n-                    fcx.inh.locals.insert(nid, typ);\n-                }\n-            }\n-        };\n+        let mut visit = GatherLocalsVisitor { fcx: fcx, tcx: tcx, };\n \n         // Add the self parameter\n         for self_info in opt_self_info.iter() {\n-            assign(self_info.self_id, Some(self_info.self_ty));\n+            visit.assign(self_info.self_id, Some(self_info.self_ty));\n             debug!(\"self is assigned to %s\",\n                    fcx.infcx().ty_to_str(\n                        fcx.inh.locals.get_copy(&self_info.self_id)));\n@@ -457,7 +521,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n             // Create type variables for each argument.\n             do pat_util::pat_bindings(tcx.def_map, input.pat)\n                     |_bm, pat_id, _sp, _path| {\n-                assign(pat_id, None);\n+                visit.assign(pat_id, None);\n             }\n \n             // Check the pattern.\n@@ -468,66 +532,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n             _match::check_pat(&pcx, input.pat, *arg_ty);\n         }\n \n-        // Add explicitly-declared locals.\n-        let visit_local: @fn(@ast::Local, ((), oldvisit::vt<()>)) =\n-                |local, (e, v)| {\n-            let o_ty = match local.ty.node {\n-              ast::ty_infer => None,\n-              _ => Some(fcx.to_ty(&local.ty))\n-            };\n-            assign(local.id, o_ty);\n-            debug!(\"Local variable %s is assigned type %s\",\n-                   fcx.pat_to_str(local.pat),\n-                   fcx.infcx().ty_to_str(\n-                       fcx.inh.locals.get_copy(&local.id)));\n-            oldvisit::visit_local(local, (e, v));\n-        };\n-\n-        // Add pattern bindings.\n-        let visit_pat: @fn(@ast::pat, ((), oldvisit::vt<()>)) = |p, (e, v)| {\n-            match p.node {\n-              ast::pat_ident(_, ref path, _)\n-                  if pat_util::pat_is_binding(fcx.ccx.tcx.def_map, p) => {\n-                assign(p.id, None);\n-                debug!(\"Pattern binding %s is assigned to %s\",\n-                       tcx.sess.str_of(path.idents[0]),\n-                       fcx.infcx().ty_to_str(\n-                           fcx.inh.locals.get_copy(&p.id)));\n-              }\n-              _ => {}\n-            }\n-            oldvisit::visit_pat(p, (e, v));\n-        };\n-\n-        let visit_block:\n-                @fn(&ast::Block, ((), oldvisit::vt<()>)) = |b, (e, v)| {\n-            // non-obvious: the `blk` variable maps to region lb, so\n-            // we have to keep this up-to-date.  This\n-            // is... unfortunate.  It'd be nice to not need this.\n-            do fcx.with_region_lb(b.id) {\n-                oldvisit::visit_block(b, (e, v));\n-            }\n-        };\n-\n-        // Don't descend into fns and items\n-        fn visit_fn(_fk: &oldvisit::fn_kind,\n-                    _decl: &ast::fn_decl,\n-                    _body: &ast::Block,\n-                    _sp: span,\n-                    _id: ast::NodeId,\n-                    (_t,_v): ((), oldvisit::vt<()>)) {\n-        }\n-        fn visit_item(_i: @ast::item, (_e,_v): ((), oldvisit::vt<()>)) { }\n-\n-        let visit = oldvisit::mk_vt(\n-            @oldvisit::Visitor {visit_local: visit_local,\n-                             visit_pat: visit_pat,\n-                             visit_fn: visit_fn,\n-                             visit_item: visit_item,\n-                             visit_block: visit_block,\n-                             ..*oldvisit::default_visitor()});\n-\n-        (visit.visit_block)(body, ((), visit));\n+        visit.visit_block(body, ());\n     }\n }\n "}]}