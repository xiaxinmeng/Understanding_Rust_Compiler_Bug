{"sha": "4fa4bb56339868a125c2f5a80a1cea982d92d545", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmYTRiYjU2MzM5ODY4YTEyNWMyZjVhODBhMWNlYTk4MmQ5MmQ1NDU=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-08-22T15:45:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-08-22T15:45:34Z"}, "message": "Rollup merge of #53504 - ekse:suggestions-applicability-2, r=estebank\n\nSet applicability for more suggestions.\n\nConverts a couple more calls to `span_suggestion_with_applicability`  (#50723). To be on the safe side, I marked suggestions that depend on the intent of the user or that are potentially lossy conversions as MaybeIncorrect.\n\nr? @estebank", "tree": {"sha": "a031de63ea6d04b05e36a01eb99057444a4a8f23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a031de63ea6d04b05e36a01eb99057444a4a8f23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fa4bb56339868a125c2f5a80a1cea982d92d545", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbfYUeCRBK7hj4Ov3rIwAAdHIIAE8jCdutYw0QgH/oJfuE2qS+\nZcEh8jGQ4ZyNgM8p3yygNpGLJ0G+X5a0Jls18Sq+pXLaDKfLhqjEs9FG8zWFT39Y\n98fj1XovRiKOtZNlT7j88R/uEgAOepnF6NSVmwW6icpXyQ8zTwHFkhMWhjM+4DjL\ngBRRAP7BKipVk8JUwa+a29b59WMUVcsDyQH8MfsCSMNYLXDYwdrMbxmgq14Q57R8\nDEMh/uQvMTfrjKM+1t8nzWC2NfHBpOJ+LzIkFTQ3FW+uRZyhyvYBY2mZmZYIBhgL\n9a9DHhliTgQw2h2l8jAKXmMHB9p5wikXOrOX4mgchAuMcR6M6HT3AVdBuOfvO8g=\n=dK/i\n-----END PGP SIGNATURE-----\n", "payload": "tree a031de63ea6d04b05e36a01eb99057444a4a8f23\nparent 55d98236f9fcdf88f574bcf8180c0e92924d616c\nparent 5a23a0d283653c79fd623b479b1e8e71d5eea093\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1534952734 +0200\ncommitter GitHub <noreply@github.com> 1534952734 +0200\n\nRollup merge of #53504 - ekse:suggestions-applicability-2, r=estebank\n\nSet applicability for more suggestions.\n\nConverts a couple more calls to `span_suggestion_with_applicability`  (#50723). To be on the safe side, I marked suggestions that depend on the intent of the user or that are potentially lossy conversions as MaybeIncorrect.\n\nr? @estebank\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fa4bb56339868a125c2f5a80a1cea982d92d545", "html_url": "https://github.com/rust-lang/rust/commit/4fa4bb56339868a125c2f5a80a1cea982d92d545", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fa4bb56339868a125c2f5a80a1cea982d92d545/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55d98236f9fcdf88f574bcf8180c0e92924d616c", "url": "https://api.github.com/repos/rust-lang/rust/commits/55d98236f9fcdf88f574bcf8180c0e92924d616c", "html_url": "https://github.com/rust-lang/rust/commit/55d98236f9fcdf88f574bcf8180c0e92924d616c"}, {"sha": "5a23a0d283653c79fd623b479b1e8e71d5eea093", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a23a0d283653c79fd623b479b1e8e71d5eea093", "html_url": "https://github.com/rust-lang/rust/commit/5a23a0d283653c79fd623b479b1e8e71d5eea093"}], "stats": {"total": 342, "additions": 217, "deletions": 125}, "files": [{"sha": "87f2c7576a4e6e179af4374ac7bf33fa6db4c383", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4fa4bb56339868a125c2f5a80a1cea982d92d545/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa4bb56339868a125c2f5a80a1cea982d92d545/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=4fa4bb56339868a125c2f5a80a1cea982d92d545", "patch": "@@ -17,7 +17,7 @@ use rustc::ty;\n use rustc_mir::util::borrowck_errors::{BorrowckErrors, Origin};\n use syntax::ast;\n use syntax_pos;\n-use errors::DiagnosticBuilder;\n+use errors::{DiagnosticBuilder, Applicability};\n use borrowck::gather_loans::gather_moves::PatternSource;\n \n pub struct MoveErrorCollector<'tcx> {\n@@ -80,9 +80,12 @@ fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>, errors: &[MoveErr\n                 let initializer =\n                     e.init.as_ref().expect(\"should have an initializer to get an error\");\n                 if let Ok(snippet) = bccx.tcx.sess.source_map().span_to_snippet(initializer.span) {\n-                    err.span_suggestion(initializer.span,\n-                                        \"consider using a reference instead\",\n-                                        format!(\"&{}\", snippet));\n+                    err.span_suggestion_with_applicability(\n+                        initializer.span,\n+                        \"consider using a reference instead\",\n+                        format!(\"&{}\", snippet),\n+                        Applicability::MaybeIncorrect // using a reference may not be the right fix\n+                    );\n                 }\n             }\n             _ => {"}, {"sha": "bca119660aa2a4e93a9dd14768fa1d64b0dd2032", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fa4bb56339868a125c2f5a80a1cea982d92d545/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa4bb56339868a125c2f5a80a1cea982d92d545/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=4fa4bb56339868a125c2f5a80a1cea982d92d545", "patch": "@@ -25,6 +25,7 @@ use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n use syntax_pos::Span;\n use errors;\n+use errors::Applicability;\n \n struct AstValidator<'a> {\n     session: &'a Session,\n@@ -185,11 +186,12 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 );\n                 match val.node {\n                     ExprKind::Lit(ref v) if v.node.is_numeric() => {\n-                        err.span_suggestion(\n+                        err.span_suggestion_with_applicability(\n                             place.span.between(val.span),\n                             \"if you meant to write a comparison against a negative value, add a \\\n                              space in between `<` and `-`\",\n                             \"< -\".to_string(),\n+                            Applicability::MaybeIncorrect\n                         );\n                     }\n                     _ => {}"}, {"sha": "fcdb8fb1465eb2ab0f01f861e1919d685ad26e79", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4fa4bb56339868a125c2f5a80a1cea982d92d545/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa4bb56339868a125c2f5a80a1cea982d92d545/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=4fa4bb56339868a125c2f5a80a1cea982d92d545", "patch": "@@ -38,6 +38,7 @@ use syntax::symbol::{Symbol, keywords};\n use syntax::tokenstream::{TokenStream, TokenTree, Delimited};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{Span, DUMMY_SP};\n+use errors::Applicability;\n \n use std::cell::Cell;\n use std::mem;\n@@ -938,9 +939,19 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         if let Some(suggestion) = suggestion {\n             if suggestion != name {\n                 if let MacroKind::Bang = kind {\n-                    err.span_suggestion(span, \"you could try the macro\", suggestion.to_string());\n+                    err.span_suggestion_with_applicability(\n+                        span,\n+                        \"you could try the macro\",\n+                        suggestion.to_string(),\n+                        Applicability::MaybeIncorrect\n+                    );\n                 } else {\n-                    err.span_suggestion(span, \"try\", suggestion.to_string());\n+                    err.span_suggestion_with_applicability(\n+                        span,\n+                        \"try\",\n+                        suggestion.to_string(),\n+                        Applicability::MaybeIncorrect\n+                    );\n                 }\n             } else {\n                 err.help(\"have you added the `#[macro_use]` on the module/import?\");\n@@ -1065,10 +1076,11 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             if let Some(span) = span {\n                 let found_use = if found_use { \"\" } else { \"\\n\" };\n                 self.session.struct_span_err(err.use_span, err.warn_msg)\n-                    .span_suggestion(\n+                    .span_suggestion_with_applicability(\n                         span,\n                         \"instead, import the procedural macro like any other item\",\n                         format!(\"use {}::{};{}\", err.crate_name, err.name, found_use),\n+                        Applicability::MachineApplicable\n                     ).emit();\n             } else {\n                 self.session.struct_span_err(err.use_span, err.warn_msg)"}, {"sha": "7f3aaa6792ffe683f5ebc4181d78afa9b838e726", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4fa4bb56339868a125c2f5a80a1cea982d92d545/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa4bb56339868a125c2f5a80a1cea982d92d545/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=4fa4bb56339868a125c2f5a80a1cea982d92d545", "patch": "@@ -20,6 +20,7 @@ use rustc::ty::adjustment::{Adjustment, Adjust, AllowTwoPhase, AutoBorrow, AutoB\n use rustc_target::spec::abi;\n use syntax::ast::Ident;\n use syntax_pos::Span;\n+use errors::Applicability;\n \n use rustc::hir;\n \n@@ -234,10 +235,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 err.span_label(call_expr.span, \"not a function\");\n \n                 if let Some(ref path) = unit_variant {\n-                    err.span_suggestion(call_expr.span,\n-                                        &format!(\"`{}` is a unit variant, you need to write it \\\n-                                                  without the parenthesis\", path),\n-                                        path.to_string());\n+                    err.span_suggestion_with_applicability(\n+                        call_expr.span,\n+                        &format!(\"`{}` is a unit variant, you need to write it \\\n+                                 without the parenthesis\", path),\n+                        path.to_string(),\n+                        Applicability::MachineApplicable\n+                    );\n                 }\n \n                 if let hir::ExprKind::Call(ref expr, _) = call_expr.node {"}, {"sha": "9ca8686eb226f40b352f3c0146d596a37402d1a4", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 146, "deletions": 95, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/4fa4bb56339868a125c2f5a80a1cea982d92d545/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa4bb56339868a125c2f5a80a1cea982d92d545/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=4fa4bb56339868a125c2f5a80a1cea982d92d545", "patch": "@@ -21,7 +21,7 @@ use rustc::hir::map::{NodeItem, NodeExpr};\n use rustc::hir::{Item, ItemKind, print};\n use rustc::ty::{self, Ty, AssociatedItem};\n use rustc::ty::adjustment::AllowTwoPhase;\n-use errors::{DiagnosticBuilder, SourceMapper};\n+use errors::{Applicability, DiagnosticBuilder, SourceMapper};\n \n use super::method::probe;\n \n@@ -422,24 +422,31 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     match (found.bit_width(), exp.bit_width()) {\n                         (Some(found), Some(exp)) if found > exp => {\n                             if can_cast {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\", msg, will_truncate),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                    cast_suggestion,\n+                                    Applicability::MaybeIncorrect // lossy conversion\n+                                );\n                             }\n                         }\n                         (None, _) | (_, None) => {\n                             if can_cast {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\",\n-                                                             msg,\n-                                                             depending_on_isize),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, depending_on_isize),\n+                                    cast_suggestion,\n+                                    Applicability::MaybeIncorrect // lossy conversion\n+                                );\n                             }\n                         }\n                         _ => {\n-                            err.span_suggestion(expr.span,\n-                                                &format!(\"{}, which {}\", msg, will_sign_extend),\n-                                                into_suggestion);\n+                            err.span_suggestion_with_applicability(\n+                                expr.span,\n+                                &format!(\"{}, which {}\", msg, will_sign_extend),\n+                                into_suggestion,\n+                                Applicability::MachineApplicable\n+                            );\n                         }\n                     }\n                     true\n@@ -448,24 +455,31 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     match (found.bit_width(), exp.bit_width()) {\n                         (Some(found), Some(exp)) if found > exp => {\n                             if can_cast {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\", msg, will_truncate),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                    cast_suggestion,\n+                                    Applicability::MaybeIncorrect  // lossy conversion\n+                                );\n                             }\n                         }\n                         (None, _) | (_, None) => {\n                             if can_cast {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\",\n-                                                             msg,\n-                                                             depending_on_usize),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, depending_on_usize),\n+                                    cast_suggestion,\n+                                    Applicability::MaybeIncorrect  // lossy conversion\n+                                );\n                             }\n                         }\n                         _ => {\n-                            err.span_suggestion(expr.span,\n-                                                &format!(\"{}, which {}\", msg, will_zero_extend),\n-                                                into_suggestion);\n+                            err.span_suggestion_with_applicability(\n+                                expr.span,\n+                                &format!(\"{}, which {}\", msg, will_zero_extend),\n+                                into_suggestion,\n+                                Applicability::MachineApplicable\n+                            );\n                         }\n                     }\n                     true\n@@ -474,33 +488,44 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if can_cast {\n                         match (found.bit_width(), exp.bit_width()) {\n                             (Some(found), Some(exp)) if found > exp - 1 => {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\", msg, will_truncate),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                    cast_suggestion,\n+                                    Applicability::MaybeIncorrect  // lossy conversion\n+                                );\n                             }\n                             (None, None) => {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\", msg, will_truncate),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                    cast_suggestion,\n+                                    Applicability::MaybeIncorrect  // lossy conversion\n+                                );\n                             }\n                             (None, _) => {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\",\n-                                                             msg,\n-                                                             depending_on_isize),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, depending_on_isize),\n+                                    cast_suggestion,\n+                                    Applicability::MaybeIncorrect  // lossy conversion\n+                                );\n                             }\n                             (_, None) => {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\",\n-                                                             msg,\n-                                                             depending_on_usize),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, depending_on_usize),\n+                                    cast_suggestion,\n+                                    Applicability::MaybeIncorrect  // lossy conversion\n+                                );\n                             }\n                             _ => {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\", msg, will_zero_extend),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, will_zero_extend),\n+                                    cast_suggestion,\n+                                    Applicability::MachineApplicable\n+                                );\n                             }\n                         }\n                     }\n@@ -510,58 +535,75 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if can_cast {\n                         match (found.bit_width(), exp.bit_width()) {\n                             (Some(found), Some(exp)) if found - 1 > exp => {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\", msg, will_truncate),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, will_truncate),\n+                                    cast_suggestion,\n+                                    Applicability::MaybeIncorrect  // lossy conversion\n+                                );\n                             }\n                             (None, None) => {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\", msg, will_sign_extend),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, will_sign_extend),\n+                                    cast_suggestion,\n+                                    Applicability::MachineApplicable  // lossy conversion\n+                                );\n                             }\n                             (None, _) => {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\",\n-                                                             msg,\n-                                                             depending_on_usize),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, depending_on_usize),\n+                                    cast_suggestion,\n+                                    Applicability::MaybeIncorrect  // lossy conversion\n+                                );\n                             }\n                             (_, None) => {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\",\n-                                                             msg,\n-                                                             depending_on_isize),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, depending_on_isize),\n+                                    cast_suggestion,\n+                                    Applicability::MaybeIncorrect  // lossy conversion\n+                                );\n                             }\n                             _ => {\n-                                err.span_suggestion(expr.span,\n-                                                    &format!(\"{}, which {}\", msg, will_sign_extend),\n-                                                    cast_suggestion);\n+                                err.span_suggestion_with_applicability(\n+                                    expr.span,\n+                                    &format!(\"{}, which {}\", msg, will_sign_extend),\n+                                    cast_suggestion,\n+                                    Applicability::MachineApplicable\n+                                );\n                             }\n                         }\n                     }\n                     true\n                 }\n                 (&ty::TyFloat(ref exp), &ty::TyFloat(ref found)) => {\n                     if found.bit_width() < exp.bit_width() {\n-                        err.span_suggestion(expr.span,\n-                                            &format!(\"{} in a lossless way\",\n-                                                     msg),\n-                                            into_suggestion);\n+                        err.span_suggestion_with_applicability(\n+                            expr.span,\n+                            &format!(\"{} in a lossless way\", msg),\n+                            into_suggestion,\n+                            Applicability::MachineApplicable\n+                        );\n                     } else if can_cast {\n-                        err.span_suggestion(expr.span,\n-                                            &format!(\"{}, producing the closest possible value\",\n-                                                     msg),\n-                                            cast_suggestion);\n+                        err.span_suggestion_with_applicability(\n+                            expr.span,\n+                            &format!(\"{}, producing the closest possible value\", msg),\n+                            cast_suggestion,\n+                            Applicability::MaybeIncorrect  // lossy conversion\n+                        );\n                     }\n                     true\n                 }\n                 (&ty::TyUint(_), &ty::TyFloat(_)) | (&ty::TyInt(_), &ty::TyFloat(_)) => {\n                     if can_cast {\n-                        err.span_suggestion(expr.span,\n-                                            &format!(\"{}, rounding the float towards zero\",\n-                                                     msg),\n-                                            cast_suggestion);\n+                        err.span_suggestion_with_applicability(\n+                            expr.span,\n+                            &format!(\"{}, rounding the float towards zero\", msg),\n+                            cast_suggestion,\n+                            Applicability::MaybeIncorrect  // lossy conversion\n+                        );\n                         err.warn(\"casting here will cause undefined behavior if the rounded value \\\n                                   cannot be represented by the target integer type, including \\\n                                   `Inf` and `NaN` (this is a bug and will be fixed)\");\n@@ -571,36 +613,45 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 (&ty::TyFloat(ref exp), &ty::TyUint(ref found)) => {\n                     // if `found` is `None` (meaning found is `usize`), don't suggest `.into()`\n                     if exp.bit_width() > found.bit_width().unwrap_or(256) {\n-                        err.span_suggestion(expr.span,\n-                                            &format!(\"{}, producing the floating point \\\n-                                                      representation of the integer\",\n-                                                      msg),\n-                                            into_suggestion);\n+                        err.span_suggestion_with_applicability(\n+                            expr.span,\n+                            &format!(\"{}, producing the floating point representation of the \\\n+                                      integer\",\n+                                      msg),\n+                            into_suggestion,\n+                            Applicability::MachineApplicable\n+                        );\n                     } else if can_cast {\n-                        err.span_suggestion(expr.span,\n-                                            &format!(\"{}, producing the floating point \\\n-                                                      representation of the integer, rounded if \\\n-                                                      necessary\",\n-                                                      msg),\n-                                            cast_suggestion);\n+                        err.span_suggestion_with_applicability(expr.span,\n+                            &format!(\"{}, producing the floating point representation of the \\\n+                                      integer, rounded if necessary\",\n+                                      msg),\n+                            cast_suggestion,\n+                            Applicability::MaybeIncorrect  // lossy conversion\n+                        );\n                     }\n                     true\n                 }\n                 (&ty::TyFloat(ref exp), &ty::TyInt(ref found)) => {\n                     // if `found` is `None` (meaning found is `isize`), don't suggest `.into()`\n                     if exp.bit_width() > found.bit_width().unwrap_or(256) {\n-                        err.span_suggestion(expr.span,\n-                                            &format!(\"{}, producing the floating point \\\n-                                                      representation of the integer\",\n-                                                      msg),\n-                                            into_suggestion);\n+                        err.span_suggestion_with_applicability(\n+                            expr.span,\n+                            &format!(\"{}, producing the floating point representation of the \\\n+                                      integer\",\n+                                      msg),\n+                            into_suggestion,\n+                            Applicability::MachineApplicable\n+                        );\n                     } else if can_cast {\n-                        err.span_suggestion(expr.span,\n-                                            &format!(\"{}, producing the floating point \\\n-                                                      representation of the integer, rounded if \\\n-                                                      necessary\",\n-                                                      msg),\n-                                            cast_suggestion);\n+                        err.span_suggestion_with_applicability(\n+                            expr.span,\n+                            &format!(\"{}, producing the floating point representation of the \\\n+                                      integer, rounded if necessary\",\n+                                      msg),\n+                            cast_suggestion,\n+                            Applicability::MaybeIncorrect  // lossy conversion\n+                        );\n                     }\n                     true\n                 }"}, {"sha": "baf1de1d4e678d56b28cf044eade67d490c201d4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4fa4bb56339868a125c2f5a80a1cea982d92d545/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa4bb56339868a125c2f5a80a1cea982d92d545/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4fa4bb56339868a125c2f5a80a1cea982d92d545", "patch": "@@ -102,7 +102,7 @@ use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoB\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::query::Providers;\n use rustc::ty::util::{Representability, IntTypeExt, Discr};\n-use errors::{DiagnosticBuilder, DiagnosticId};\n+use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n \n use require_c_abi_if_variadic;\n use session::{CompileIncomplete, config, Session};\n@@ -2678,10 +2678,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let sugg_span = tcx.sess.source_map().end_point(expr_sp);\n                 // remove closing `)` from the span\n                 let sugg_span = sugg_span.shrink_to_lo();\n-                err.span_suggestion(\n+                err.span_suggestion_with_applicability(\n                     sugg_span,\n                     \"expected the unit value `()`; create it with empty parentheses\",\n-                    String::from(\"()\"));\n+                    String::from(\"()\"),\n+                    Applicability::MachineApplicable);\n             } else {\n                 err.span_label(sp, format!(\"expected {}{} parameter{}\",\n                                             if variadic {\"at least \"} else {\"\"},\n@@ -2943,7 +2944,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         self.tcx.sess.source_map().span_to_snippet(lhs.span),\n                         self.tcx.sess.source_map().span_to_snippet(rhs.span))\n                     {\n-                        err.span_suggestion(expr.span, msg, format!(\"{} == {}\", left, right));\n+                        err.span_suggestion_with_applicability(\n+                            expr.span,\n+                            msg,\n+                            format!(\"{} == {}\", left, right),\n+                            Applicability::MaybeIncorrect);\n                     } else {\n                         err.help(msg);\n                     }\n@@ -4237,9 +4242,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                             ast::LitIntType::Unsuffixed) = lit.node {\n                                         let snip = tcx.sess.source_map().span_to_snippet(base.span);\n                                         if let Ok(snip) = snip {\n-                                            err.span_suggestion(expr.span,\n-                                                                \"to access tuple elements, use\",\n-                                                                format!(\"{}.{}\", snip, i));\n+                                            err.span_suggestion_with_applicability(\n+                                                expr.span,\n+                                                \"to access tuple elements, use\",\n+                                                format!(\"{}.{}\", snip, i),\n+                                                Applicability::MachineApplicable);\n                                             needs_note = false;\n                                         }\n                                     }\n@@ -4677,9 +4684,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 hir::ExprKind::Match(..) |\n                 hir::ExprKind::Block(..) => {\n                     let sp = self.tcx.sess.source_map().next_point(cause_span);\n-                    err.span_suggestion(sp,\n-                                        \"try adding a semicolon\",\n-                                        \";\".to_string());\n+                    err.span_suggestion_with_applicability(\n+                        sp,\n+                        \"try adding a semicolon\",\n+                        \";\".to_string(),\n+                        Applicability::MachineApplicable);\n                 }\n                 _ => (),\n             }\n@@ -4708,10 +4717,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // haven't set a return type at all (and aren't `fn main()` or an impl).\n         match (&fn_decl.output, found.is_suggestable(), can_suggest, expected.is_nil()) {\n             (&hir::FunctionRetTy::DefaultReturn(span), true, true, true) => {\n-                err.span_suggestion(span,\n-                                    \"try adding a return type\",\n-                                    format!(\"-> {} \",\n-                                            self.resolve_type_vars_with_obligations(found)));\n+                err.span_suggestion_with_applicability(\n+                    span,\n+                    \"try adding a return type\",\n+                    format!(\"-> {} \", self.resolve_type_vars_with_obligations(found)),\n+                    Applicability::MachineApplicable);\n             }\n             (&hir::FunctionRetTy::DefaultReturn(span), false, true, true) => {\n                 err.span_label(span, \"possibly return type missing here?\");\n@@ -4770,7 +4780,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n         let original_span = original_sp(last_stmt.span, blk.span);\n         let span_semi = original_span.with_lo(original_span.hi() - BytePos(1));\n-        err.span_suggestion(span_semi, \"consider removing this semicolon\", \"\".to_string());\n+        err.span_suggestion_with_applicability(\n+            span_semi,\n+            \"consider removing this semicolon\",\n+            \"\".to_string(),\n+            Applicability::MachineApplicable);\n     }\n \n     fn def_ids_for_path_segments(&self,"}, {"sha": "03bf1b5a4e1ed53069e3ddc118a04e1bc8ce9007", "filename": "src/libsyntax/parse/lexer/unicode_chars.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4fa4bb56339868a125c2f5a80a1cea982d92d545/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa4bb56339868a125c2f5a80a1cea982d92d545/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=4fa4bb56339868a125c2f5a80a1cea982d92d545", "patch": "@@ -12,7 +12,7 @@\n // http://www.unicode.org/Public/security/10.0.0/confusables.txt\n \n use syntax_pos::{Span, NO_EXPANSION};\n-use errors::DiagnosticBuilder;\n+use errors::{Applicability, DiagnosticBuilder};\n use super::StringReader;\n \n const UNICODE_ARRAY: &[(char, &str, char)] = &[\n@@ -346,7 +346,11 @@ crate fn check_for_substitution<'a>(reader: &StringReader<'a>,\n                 let msg =\n                     format!(\"Unicode character '{}' ({}) looks like '{}' ({}), but it is not\",\n                             ch, u_name, ascii_char, ascii_name);\n-                err.span_suggestion(span, &msg, ascii_char.to_string());\n+                err.span_suggestion_with_applicability(\n+                    span,\n+                    &msg,\n+                    ascii_char.to_string(),\n+                    Applicability::MaybeIncorrect);\n                 true\n             },\n             None => {"}, {"sha": "b23c2ec3db1011437ac717d9212794b410fbd8c7", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fa4bb56339868a125c2f5a80a1cea982d92d545/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fa4bb56339868a125c2f5a80a1cea982d92d545/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=4fa4bb56339868a125c2f5a80a1cea982d92d545", "patch": "@@ -22,6 +22,7 @@ use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax::tokenstream;\n use syntax_pos::{MultiSpan, Span, DUMMY_SP};\n+use errors::Applicability;\n \n use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n@@ -791,10 +792,11 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n                 0 => \"{}\".to_string(),\n                 _ => format!(\"{}{{}}\", \"{} \".repeat(args.len())),\n             };\n-            err.span_suggestion(\n+            err.span_suggestion_with_applicability(\n                 fmt_sp.shrink_to_lo(),\n                 \"you might be missing a string literal to format with\",\n                 format!(\"\\\"{}\\\", \", sugg_fmt),\n+                Applicability::MaybeIncorrect,\n             );\n             err.emit();\n             return DummyResult::raw_expr(sp);"}]}