{"sha": "9063edaf3bcf3d0897ee3e73b6468c3984883b18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwNjNlZGFmM2JjZjNkMDg5N2VlM2U3M2I2NDY4YzM5ODQ4ODNiMTg=", "commit": {"author": {"name": "Christiaan Dirkx", "email": "christiaan@dirkx.email", "date": "2021-04-29T09:40:14Z"}, "committer": {"name": "Christiaan Dirkx", "email": "christiaan@dirkx.email", "date": "2021-06-21T09:01:46Z"}, "message": "Move `available_concurrency` implementation to `sys`", "tree": {"sha": "1b57b0dde3109e46a405a1353473a89a61fce447", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b57b0dde3109e46a405a1353473a89a61fce447"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9063edaf3bcf3d0897ee3e73b6468c3984883b18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9063edaf3bcf3d0897ee3e73b6468c3984883b18", "html_url": "https://github.com/rust-lang/rust/commit/9063edaf3bcf3d0897ee3e73b6468c3984883b18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9063edaf3bcf3d0897ee3e73b6468c3984883b18/comments", "author": {"login": "CDirkx", "id": 11176562, "node_id": "MDQ6VXNlcjExMTc2NTYy", "avatar_url": "https://avatars.githubusercontent.com/u/11176562?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CDirkx", "html_url": "https://github.com/CDirkx", "followers_url": "https://api.github.com/users/CDirkx/followers", "following_url": "https://api.github.com/users/CDirkx/following{/other_user}", "gists_url": "https://api.github.com/users/CDirkx/gists{/gist_id}", "starred_url": "https://api.github.com/users/CDirkx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CDirkx/subscriptions", "organizations_url": "https://api.github.com/users/CDirkx/orgs", "repos_url": "https://api.github.com/users/CDirkx/repos", "events_url": "https://api.github.com/users/CDirkx/events{/privacy}", "received_events_url": "https://api.github.com/users/CDirkx/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CDirkx", "id": 11176562, "node_id": "MDQ6VXNlcjExMTc2NTYy", "avatar_url": "https://avatars.githubusercontent.com/u/11176562?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CDirkx", "html_url": "https://github.com/CDirkx", "followers_url": "https://api.github.com/users/CDirkx/followers", "following_url": "https://api.github.com/users/CDirkx/following{/other_user}", "gists_url": "https://api.github.com/users/CDirkx/gists{/gist_id}", "starred_url": "https://api.github.com/users/CDirkx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CDirkx/subscriptions", "organizations_url": "https://api.github.com/users/CDirkx/orgs", "repos_url": "https://api.github.com/users/CDirkx/repos", "events_url": "https://api.github.com/users/CDirkx/events{/privacy}", "received_events_url": "https://api.github.com/users/CDirkx/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3824017f8e57ce9dac6d69a1ce07f41c7034f82d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3824017f8e57ce9dac6d69a1ce07f41c7034f82d", "html_url": "https://github.com/rust-lang/rust/commit/3824017f8e57ce9dac6d69a1ce07f41c7034f82d"}], "stats": {"total": 356, "additions": 194, "deletions": 162}, "files": [{"sha": "3d00e626e1ac76c599a9e74a937af28f23132738", "filename": "library/std/src/sys/hermit/thread.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9063edaf3bcf3d0897ee3e73b6468c3984883b18/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9063edaf3bcf3d0897ee3e73b6468c3984883b18/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs?ref=9063edaf3bcf3d0897ee3e73b6468c3984883b18", "patch": "@@ -3,6 +3,7 @@\n use crate::ffi::CStr;\n use crate::io;\n use crate::mem;\n+use crate::num::NonZeroUsize;\n use crate::sys::hermit::abi;\n use crate::sys::hermit::thread_local_dtor::run_dtors;\n use crate::time::Duration;\n@@ -95,6 +96,13 @@ impl Thread {\n     }\n }\n \n+pub fn available_concurrency() -> io::Result<NonZeroUsize> {\n+    Err(io::Error::new_const(\n+        io::ErrorKind::NotFound,\n+        &\"The number of hardware threads is not known for the target platform\",\n+    ))\n+}\n+\n pub mod guard {\n     pub type Guard = !;\n     pub unsafe fn current() -> Option<Guard> {"}, {"sha": "b82ae86521a0b91311f9c3b9ee222976a96852ca", "filename": "library/std/src/sys/sgx/thread.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9063edaf3bcf3d0897ee3e73b6468c3984883b18/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9063edaf3bcf3d0897ee3e73b6468c3984883b18/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fthread.rs?ref=9063edaf3bcf3d0897ee3e73b6468c3984883b18", "patch": "@@ -1,6 +1,7 @@\n #![cfg_attr(test, allow(dead_code))] // why is this necessary?\n use crate::ffi::CStr;\n use crate::io;\n+use crate::num::NonZeroUsize;\n use crate::time::Duration;\n \n use super::abi::usercalls;\n@@ -135,6 +136,13 @@ impl Thread {\n     }\n }\n \n+pub fn available_concurrency() -> io::Result<NonZeroUsize> {\n+    Err(io::Error::new_const(\n+        io::ErrorKind::NotFound,\n+        &\"The number of hardware threads is not known for the target platform\",\n+    ))\n+}\n+\n pub mod guard {\n     pub type Guard = !;\n     pub unsafe fn current() -> Option<Guard> {"}, {"sha": "e49971de940ba693339249401045e25d32490a7c", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/9063edaf3bcf3d0897ee3e73b6468c3984883b18/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9063edaf3bcf3d0897ee3e73b6468c3984883b18/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=9063edaf3bcf3d0897ee3e73b6468c3984883b18", "patch": "@@ -2,6 +2,7 @@ use crate::cmp;\n use crate::ffi::CStr;\n use crate::io;\n use crate::mem;\n+use crate::num::NonZeroUsize;\n use crate::ptr;\n use crate::sys::{os, stack_overflow};\n use crate::time::Duration;\n@@ -198,6 +199,88 @@ impl Drop for Thread {\n     }\n }\n \n+pub fn available_concurrency() -> io::Result<NonZeroUsize> {\n+    cfg_if::cfg_if! {\n+        if #[cfg(any(\n+            target_os = \"android\",\n+            target_os = \"emscripten\",\n+            target_os = \"fuchsia\",\n+            target_os = \"ios\",\n+            target_os = \"linux\",\n+            target_os = \"macos\",\n+            target_os = \"solaris\",\n+            target_os = \"illumos\",\n+        ))] {\n+            match unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) } {\n+                -1 => Err(io::Error::last_os_error()),\n+                0 => Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\")),\n+                cpus => Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) }),\n+            }\n+        } else if #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"netbsd\"))] {\n+            use crate::ptr;\n+\n+            let mut cpus: libc::c_uint = 0;\n+            let mut cpus_size = crate::mem::size_of_val(&cpus);\n+\n+            unsafe {\n+                cpus = libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as libc::c_uint;\n+            }\n+\n+            // Fallback approach in case of errors or no hardware threads.\n+            if cpus < 1 {\n+                let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n+                let res = unsafe {\n+                    libc::sysctl(\n+                        mib.as_mut_ptr(),\n+                        2,\n+                        &mut cpus as *mut _ as *mut _,\n+                        &mut cpus_size as *mut _ as *mut _,\n+                        ptr::null_mut(),\n+                        0,\n+                    )\n+                };\n+\n+                // Handle errors if any.\n+                if res == -1 {\n+                    return Err(io::Error::last_os_error());\n+                } else if cpus == 0 {\n+                    return Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\"));\n+                }\n+            }\n+            Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) })\n+        } else if #[cfg(target_os = \"openbsd\")] {\n+            use crate::ptr;\n+\n+            let mut cpus: libc::c_uint = 0;\n+            let mut cpus_size = crate::mem::size_of_val(&cpus);\n+            let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n+\n+            let res = unsafe {\n+                libc::sysctl(\n+                    mib.as_mut_ptr(),\n+                    2,\n+                    &mut cpus as *mut _ as *mut _,\n+                    &mut cpus_size as *mut _ as *mut _,\n+                    ptr::null_mut(),\n+                    0,\n+                )\n+            };\n+\n+            // Handle errors if any.\n+            if res == -1 {\n+                return Err(io::Error::last_os_error());\n+            } else if cpus == 0 {\n+                return Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\"));\n+            }\n+\n+            Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) })\n+        } else {\n+            // FIXME: implement on vxWorks, Redox, Haiku, l4re\n+            Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\"))\n+        }\n+    }\n+}\n+\n #[cfg(all(\n     not(target_os = \"linux\"),\n     not(target_os = \"freebsd\"),"}, {"sha": "47005ead196a55cf3fcc4327d2757f6a582ad671", "filename": "library/std/src/sys/unsupported/thread.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9063edaf3bcf3d0897ee3e73b6468c3984883b18/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9063edaf3bcf3d0897ee3e73b6468c3984883b18/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fthread.rs?ref=9063edaf3bcf3d0897ee3e73b6468c3984883b18", "patch": "@@ -1,6 +1,7 @@\n use super::unsupported;\n use crate::ffi::CStr;\n use crate::io;\n+use crate::num::NonZeroUsize;\n use crate::time::Duration;\n \n pub struct Thread(!);\n@@ -30,6 +31,13 @@ impl Thread {\n     }\n }\n \n+pub fn available_concurrency() -> io::Result<NonZeroUsize> {\n+    Err(io::Error::new_const(\n+        io::ErrorKind::NotFound,\n+        &\"The number of hardware threads is not known for the target platform\",\n+    ))\n+}\n+\n pub mod guard {\n     pub type Guard = !;\n     pub unsafe fn current() -> Option<Guard> {"}, {"sha": "959077f7b54b69ce9304343a8306d95ce719b150", "filename": "library/std/src/sys/wasi/thread.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9063edaf3bcf3d0897ee3e73b6468c3984883b18/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9063edaf3bcf3d0897ee3e73b6468c3984883b18/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fthread.rs?ref=9063edaf3bcf3d0897ee3e73b6468c3984883b18", "patch": "@@ -3,6 +3,7 @@\n use crate::ffi::CStr;\n use crate::io;\n use crate::mem;\n+use crate::num::NonZeroUsize;\n use crate::sys::unsupported;\n use crate::time::Duration;\n \n@@ -63,6 +64,13 @@ impl Thread {\n     }\n }\n \n+pub fn available_concurrency() -> io::Result<NonZeroUsize> {\n+    Err(io::Error::new_const(\n+        io::ErrorKind::NotFound,\n+        &\"The number of hardware threads is not known for the target platform\",\n+    ))\n+}\n+\n pub mod guard {\n     pub type Guard = !;\n     pub unsafe fn current() -> Option<Guard> {"}, {"sha": "8207a41035db8645bbd7bd2e5c0bb5b5cce8030f", "filename": "library/std/src/sys/wasm/atomics/thread.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9063edaf3bcf3d0897ee3e73b6468c3984883b18/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9063edaf3bcf3d0897ee3e73b6468c3984883b18/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fthread.rs?ref=9063edaf3bcf3d0897ee3e73b6468c3984883b18", "patch": "@@ -1,5 +1,6 @@\n use crate::ffi::CStr;\n use crate::io;\n+use crate::num::NonZeroUsize;\n use crate::sys::unsupported;\n use crate::time::Duration;\n \n@@ -39,6 +40,13 @@ impl Thread {\n     pub fn join(self) {}\n }\n \n+pub fn available_concurrency() -> io::Result<NonZeroUsize> {\n+    Err(io::Error::new_const(\n+        io::ErrorKind::NotFound,\n+        &\"The number of hardware threads is not known for the target platform\",\n+    ))\n+}\n+\n pub mod guard {\n     pub type Guard = !;\n     pub unsafe fn current() -> Option<Guard> {"}, {"sha": "193c28c7673d71e956bced47ef00e65eff272ca7", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9063edaf3bcf3d0897ee3e73b6468c3984883b18/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9063edaf3bcf3d0897ee3e73b6468c3984883b18/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=9063edaf3bcf3d0897ee3e73b6468c3984883b18", "patch": "@@ -13,6 +13,7 @@ use libc::{c_void, size_t, wchar_t};\n pub use self::EXCEPTION_DISPOSITION::*;\n pub use self::FILE_INFO_BY_HANDLE_CLASS::*;\n \n+pub type DWORD_PTR = ULONG_PTR;\n pub type DWORD = c_ulong;\n pub type NonZeroDWORD = NonZero_c_ulong;\n pub type HANDLE = LPVOID;\n@@ -53,6 +54,7 @@ pub type LPWSADATA = *mut WSADATA;\n pub type LPWSAPROTOCOL_INFO = *mut WSAPROTOCOL_INFO;\n pub type LPWSTR = *mut WCHAR;\n pub type LPFILETIME = *mut FILETIME;\n+pub type LPSYSTEM_INFO = *mut SYSTEM_INFO;\n pub type LPWSABUF = *mut WSABUF;\n pub type LPWSAOVERLAPPED = *mut c_void;\n pub type LPWSAOVERLAPPED_COMPLETION_ROUTINE = *mut c_void;\n@@ -533,6 +535,21 @@ pub struct FILETIME {\n     pub dwHighDateTime: DWORD,\n }\n \n+#[repr(C)]\n+pub struct SYSTEM_INFO {\n+    pub wProcessorArchitecture: WORD,\n+    pub wReserved: WORD,\n+    pub dwPageSize: DWORD,\n+    pub lpMinimumApplicationAddress: LPVOID,\n+    pub lpMaximumApplicationAddress: LPVOID,\n+    pub dwActiveProcessorMask: DWORD_PTR,\n+    pub dwNumberOfProcessors: DWORD,\n+    pub dwProcessorType: DWORD,\n+    pub dwAllocationGranularity: DWORD,\n+    pub wProcessorLevel: WORD,\n+    pub wProcessorRevision: WORD,\n+}\n+\n #[repr(C)]\n pub struct OVERLAPPED {\n     pub Internal: *mut c_ulong,\n@@ -934,6 +951,7 @@ extern \"system\" {\n     pub fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n \n     pub fn GetSystemTimeAsFileTime(lpSystemTimeAsFileTime: LPFILETIME);\n+    pub fn GetSystemInfo(lpSystemInfo: LPSYSTEM_INFO);\n \n     pub fn CreateEventW(\n         lpEventAttributes: LPSECURITY_ATTRIBUTES,"}, {"sha": "ef7a9733fd880e19d8eff8383fa5fe7ae654e732", "filename": "library/std/src/sys/windows/thread.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9063edaf3bcf3d0897ee3e73b6468c3984883b18/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9063edaf3bcf3d0897ee3e73b6468c3984883b18/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread.rs?ref=9063edaf3bcf3d0897ee3e73b6468c3984883b18", "patch": "@@ -1,5 +1,6 @@\n use crate::ffi::CStr;\n use crate::io;\n+use crate::num::NonZeroUsize;\n use crate::ptr;\n use crate::sys::c;\n use crate::sys::handle::Handle;\n@@ -98,6 +99,21 @@ impl Thread {\n     }\n }\n \n+pub fn available_concurrency() -> io::Result<NonZeroUsize> {\n+    let res = unsafe {\n+        let mut sysinfo: c::SYSTEM_INFO = crate::mem::zeroed();\n+        c::GetSystemInfo(&mut sysinfo);\n+        sysinfo.dwNumberOfProcessors as usize\n+    };\n+    match res {\n+        0 => Err(io::Error::new_const(\n+            io::ErrorKind::NotFound,\n+            &\"The number of hardware threads is not known for the target platform\",\n+        )),\n+        cpus => Ok(unsafe { NonZeroUsize::new_unchecked(cpus) }),\n+    }\n+}\n+\n #[cfg_attr(test, allow(dead_code))]\n pub mod guard {\n     pub type Guard = !;"}, {"sha": "e8cdde880145935c8028a193abd738300ef8bab7", "filename": "library/std/src/thread/available_concurrency.rs", "status": "removed", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/3824017f8e57ce9dac6d69a1ce07f41c7034f82d/library%2Fstd%2Fsrc%2Fthread%2Favailable_concurrency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3824017f8e57ce9dac6d69a1ce07f41c7034f82d/library%2Fstd%2Fsrc%2Fthread%2Favailable_concurrency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Favailable_concurrency.rs?ref=3824017f8e57ce9dac6d69a1ce07f41c7034f82d", "patch": "@@ -1,156 +0,0 @@\n-use crate::io;\n-use crate::num::NonZeroUsize;\n-\n-/// Returns the number of hardware threads available to the program.\n-///\n-/// This value should be considered only a hint.\n-///\n-/// # Platform-specific behavior\n-///\n-/// If interpreted as the number of actual hardware threads, it may undercount on\n-/// Windows systems with more than 64 hardware threads. If interpreted as the\n-/// available concurrency for that process, it may overcount on Windows systems\n-/// when limited by a process wide affinity mask or job object limitations, and\n-/// it may overcount on Linux systems when limited by a process wide affinity\n-/// mask or affected by cgroups limits.\n-///\n-/// # Errors\n-///\n-/// This function will return an error in the following situations, but is not\n-/// limited to just these cases:\n-///\n-/// - If the number of hardware threads is not known for the target platform.\n-/// - The process lacks permissions to view the number of hardware threads\n-///   available.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![allow(dead_code)]\n-/// #![feature(available_concurrency)]\n-/// use std::thread;\n-///\n-/// let count = thread::available_concurrency().map(|n| n.get()).unwrap_or(1);\n-/// ```\n-#[unstable(feature = \"available_concurrency\", issue = \"74479\")]\n-pub fn available_concurrency() -> io::Result<NonZeroUsize> {\n-    available_concurrency_internal()\n-}\n-\n-cfg_if::cfg_if! {\n-    if #[cfg(windows)] {\n-        #[allow(nonstandard_style)]\n-        fn available_concurrency_internal() -> io::Result<NonZeroUsize> {\n-            #[repr(C)]\n-            struct SYSTEM_INFO {\n-                wProcessorArchitecture: u16,\n-                wReserved: u16,\n-                dwPageSize: u32,\n-                lpMinimumApplicationAddress: *mut u8,\n-                lpMaximumApplicationAddress: *mut u8,\n-                dwActiveProcessorMask: *mut u8,\n-                dwNumberOfProcessors: u32,\n-                dwProcessorType: u32,\n-                dwAllocationGranularity: u32,\n-                wProcessorLevel: u16,\n-                wProcessorRevision: u16,\n-            }\n-            extern \"system\" {\n-                fn GetSystemInfo(info: *mut SYSTEM_INFO) -> i32;\n-            }\n-            let res = unsafe {\n-                let mut sysinfo = crate::mem::zeroed();\n-                GetSystemInfo(&mut sysinfo);\n-                sysinfo.dwNumberOfProcessors as usize\n-            };\n-            match res {\n-                0 => Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\")),\n-                cpus => Ok(unsafe { NonZeroUsize::new_unchecked(cpus) }),\n-            }\n-        }\n-    } else if #[cfg(any(\n-        target_os = \"android\",\n-        target_os = \"emscripten\",\n-        target_os = \"fuchsia\",\n-        target_os = \"ios\",\n-        target_os = \"linux\",\n-        target_os = \"macos\",\n-        target_os = \"solaris\",\n-        target_os = \"illumos\",\n-    ))] {\n-        fn available_concurrency_internal() -> io::Result<NonZeroUsize> {\n-            match unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) } {\n-                -1 => Err(io::Error::last_os_error()),\n-                0 => Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\")),\n-                cpus => Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) }),\n-            }\n-        }\n-    } else if #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"netbsd\"))] {\n-        fn available_concurrency_internal() -> io::Result<NonZeroUsize> {\n-            use crate::ptr;\n-\n-            let mut cpus: libc::c_uint = 0;\n-            let mut cpus_size = crate::mem::size_of_val(&cpus);\n-\n-            unsafe {\n-                cpus = libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as libc::c_uint;\n-            }\n-\n-            // Fallback approach in case of errors or no hardware threads.\n-            if cpus < 1 {\n-                let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n-                let res = unsafe {\n-                    libc::sysctl(\n-                        mib.as_mut_ptr(),\n-                        2,\n-                        &mut cpus as *mut _ as *mut _,\n-                        &mut cpus_size as *mut _ as *mut _,\n-                        ptr::null_mut(),\n-                        0,\n-                    )\n-                };\n-\n-                // Handle errors if any.\n-                if res == -1 {\n-                    return Err(io::Error::last_os_error());\n-                } else if cpus == 0 {\n-                    return Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\"));\n-                }\n-            }\n-            Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) })\n-        }\n-    } else if #[cfg(target_os = \"openbsd\")] {\n-        fn available_concurrency_internal() -> io::Result<NonZeroUsize> {\n-            use crate::ptr;\n-\n-            let mut cpus: libc::c_uint = 0;\n-            let mut cpus_size = crate::mem::size_of_val(&cpus);\n-            let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n-\n-            let res = unsafe {\n-                libc::sysctl(\n-                    mib.as_mut_ptr(),\n-                    2,\n-                    &mut cpus as *mut _ as *mut _,\n-                    &mut cpus_size as *mut _ as *mut _,\n-                    ptr::null_mut(),\n-                    0,\n-                )\n-            };\n-\n-            // Handle errors if any.\n-            if res == -1 {\n-                return Err(io::Error::last_os_error());\n-            } else if cpus == 0 {\n-                return Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\"));\n-            }\n-\n-            Ok(unsafe { NonZeroUsize::new_unchecked(cpus as usize) })\n-        }\n-    } else {\n-        // FIXME: implement on vxWorks, Redox, HermitCore, Haiku, l4re\n-        fn available_concurrency_internal() -> io::Result<NonZeroUsize> {\n-            Err(io::Error::new_const(io::ErrorKind::NotFound, &\"The number of hardware threads is not known for the target platform\"))\n-        }\n-    }\n-}"}, {"sha": "f7e791419038d197d42e66054f2100eaec38da07", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 37, "deletions": 6, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9063edaf3bcf3d0897ee3e73b6468c3984883b18/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9063edaf3bcf3d0897ee3e73b6468c3984883b18/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=9063edaf3bcf3d0897ee3e73b6468c3984883b18", "patch": "@@ -155,6 +155,7 @@ use crate::fmt;\n use crate::io;\n use crate::mem;\n use crate::num::NonZeroU64;\n+use crate::num::NonZeroUsize;\n use crate::panic;\n use crate::panicking;\n use crate::str;\n@@ -174,15 +175,9 @@ use crate::time::Duration;\n #[macro_use]\n mod local;\n \n-#[unstable(feature = \"available_concurrency\", issue = \"74479\")]\n-mod available_concurrency;\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::local::{AccessError, LocalKey};\n \n-#[unstable(feature = \"available_concurrency\", issue = \"74479\")]\n-pub use available_concurrency::available_concurrency;\n-\n // The types used by the thread_local! macro to access TLS keys. Note that there\n // are two types, the \"OS\" type and the \"fast\" type. The OS thread local key\n // type is accessed via platform-specific API calls and is slow, while the fast\n@@ -1422,3 +1417,39 @@ fn _assert_sync_and_send() {\n     _assert_both::<JoinHandle<()>>();\n     _assert_both::<Thread>();\n }\n+\n+/// Returns the number of hardware threads available to the program.\n+///\n+/// This value should be considered only a hint.\n+///\n+/// # Platform-specific behavior\n+///\n+/// If interpreted as the number of actual hardware threads, it may undercount on\n+/// Windows systems with more than 64 hardware threads. If interpreted as the\n+/// available concurrency for that process, it may overcount on Windows systems\n+/// when limited by a process wide affinity mask or job object limitations, and\n+/// it may overcount on Linux systems when limited by a process wide affinity\n+/// mask or affected by cgroups limits.\n+///\n+/// # Errors\n+///\n+/// This function will return an error in the following situations, but is not\n+/// limited to just these cases:\n+///\n+/// - If the number of hardware threads is not known for the target platform.\n+/// - The process lacks permissions to view the number of hardware threads\n+///   available.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// # #![allow(dead_code)]\n+/// #![feature(available_concurrency)]\n+/// use std::thread;\n+///\n+/// let count = thread::available_concurrency().map(|n| n.get()).unwrap_or(1);\n+/// ```\n+#[unstable(feature = \"available_concurrency\", issue = \"74479\")]\n+pub fn available_concurrency() -> io::Result<NonZeroUsize> {\n+    imp::available_concurrency()\n+}"}]}