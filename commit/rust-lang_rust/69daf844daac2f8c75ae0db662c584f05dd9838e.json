{"sha": "69daf844daac2f8c75ae0db662c584f05dd9838e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5ZGFmODQ0ZGFhYzJmOGM3NWFlMGRiNjYyYzU4NGYwNWRkOTgzOGU=", "commit": {"author": {"name": "Saleem Jaffer", "email": "ssaleem1992@gmail.com", "date": "2019-07-30T09:55:12Z"}, "committer": {"name": "Saleem Jaffer", "email": "ssaleem1992@gmail.com", "date": "2019-07-30T09:55:12Z"}, "message": "adding throw_ and err_ macros for InterpError", "tree": {"sha": "dccf65ced0a084954eff2c5c3ca2aa81ee1640e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dccf65ced0a084954eff2c5c3ca2aa81ee1640e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69daf844daac2f8c75ae0db662c584f05dd9838e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69daf844daac2f8c75ae0db662c584f05dd9838e", "html_url": "https://github.com/rust-lang/rust/commit/69daf844daac2f8c75ae0db662c584f05dd9838e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69daf844daac2f8c75ae0db662c584f05dd9838e/comments", "author": {"login": "saleemjaffer", "id": 19221716, "node_id": "MDQ6VXNlcjE5MjIxNzE2", "avatar_url": "https://avatars.githubusercontent.com/u/19221716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saleemjaffer", "html_url": "https://github.com/saleemjaffer", "followers_url": "https://api.github.com/users/saleemjaffer/followers", "following_url": "https://api.github.com/users/saleemjaffer/following{/other_user}", "gists_url": "https://api.github.com/users/saleemjaffer/gists{/gist_id}", "starred_url": "https://api.github.com/users/saleemjaffer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saleemjaffer/subscriptions", "organizations_url": "https://api.github.com/users/saleemjaffer/orgs", "repos_url": "https://api.github.com/users/saleemjaffer/repos", "events_url": "https://api.github.com/users/saleemjaffer/events{/privacy}", "received_events_url": "https://api.github.com/users/saleemjaffer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saleemjaffer", "id": 19221716, "node_id": "MDQ6VXNlcjE5MjIxNzE2", "avatar_url": "https://avatars.githubusercontent.com/u/19221716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saleemjaffer", "html_url": "https://github.com/saleemjaffer", "followers_url": "https://api.github.com/users/saleemjaffer/followers", "following_url": "https://api.github.com/users/saleemjaffer/following{/other_user}", "gists_url": "https://api.github.com/users/saleemjaffer/gists{/gist_id}", "starred_url": "https://api.github.com/users/saleemjaffer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saleemjaffer/subscriptions", "organizations_url": "https://api.github.com/users/saleemjaffer/orgs", "repos_url": "https://api.github.com/users/saleemjaffer/repos", "events_url": "https://api.github.com/users/saleemjaffer/events{/privacy}", "received_events_url": "https://api.github.com/users/saleemjaffer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a33fbff22c1145f59805aee0c4fa458d4242ebb", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a33fbff22c1145f59805aee0c4fa458d4242ebb", "html_url": "https://github.com/rust-lang/rust/commit/2a33fbff22c1145f59805aee0c4fa458d4242ebb"}], "stats": {"total": 225, "additions": 111, "deletions": 114}, "files": [{"sha": "00f908007941e18a62e6f9d30428e28ec5402a36", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=69daf844daac2f8c75ae0db662c584f05dd9838e", "patch": "@@ -244,7 +244,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n                 Ok(&self.get_bytes(cx, ptr, size_with_null)?[..size])\n             }\n             // This includes the case where `offset` is out-of-bounds to begin with.\n-            None => err!(UnterminatedCString(ptr.erase_tag())),\n+            None => throw_err!(UnterminatedCString(ptr.erase_tag())),\n         }\n     }\n \n@@ -446,7 +446,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         if self.relocations(cx, ptr, size).is_empty() {\n             Ok(())\n         } else {\n-            err!(ReadPointerAsBytes)\n+            throw_err!(ReadPointerAsBytes)\n         }\n     }\n \n@@ -516,7 +516,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n         self.undef_mask.is_range_defined(\n             ptr.offset,\n             ptr.offset + size,\n-        ).or_else(|idx| err!(ReadUndefBytes(idx)))\n+        ).or_else(|idx| throw_err!(ReadUndefBytes(idx)))\n     }\n \n     pub fn mark_definedness("}, {"sha": "183298ee3f1e3a2ec9a081f6867a9b526c4c287b", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=69daf844daac2f8c75ae0db662c584f05dd9838e", "patch": "@@ -184,7 +184,7 @@ pub fn struct_error<'tcx>(tcx: TyCtxtAt<'tcx>, msg: &str) -> DiagnosticBuilder<'\n /// Packages the kind of error we got from the const code interpreter\n /// up with a Rust-level backtrace of where the error occured.\n /// Thsese should always be constructed by calling `.into()` on\n-/// a `InterpError`. In `librustc_mir::interpret`, we have the `err!`\n+/// a `InterpError`. In `librustc_mir::interpret`, we have the `throw_err!`\n /// macro for this.\n #[derive(Debug, Clone)]\n pub struct InterpErrorInfo<'tcx> {"}, {"sha": "c5a7adf1b6710999240b05af39d140840c71d094", "filename": "src/librustc/mir/interpret/interp_error.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2a33fbff22c1145f59805aee0c4fa458d4242ebb/src%2Flibrustc%2Fmir%2Finterpret%2Finterp_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a33fbff22c1145f59805aee0c4fa458d4242ebb/src%2Flibrustc%2Fmir%2Finterpret%2Finterp_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Finterp_error.rs?ref=2a33fbff22c1145f59805aee0c4fa458d4242ebb", "patch": "@@ -1,20 +0,0 @@\n-//! macros to do something like `.ok_or_else(|| inval!(TooGeneric).into())` rather than\n-//! `.ok_or_else(|| InterpError::InvalidProgram(TooGeneric).into())`\n-\n-#[macro_export]\n-macro_rules! inval {\n-    ($($tt:tt)*) => {\n-        $crate::mir::interpret::InterpError::InvalidProgram(\n-            $crate::mir::interpret::InvalidProgramInfo::$($tt)*\n-        )\n-    };\n-}\n-\n-#[macro_export]\n-macro_rules! unsup {\n-    ($($tt:tt)*) => {\n-        $crate::mir::interpret::InterpError::Unsupported(\n-            $crate::mir::interpret::UnsupportedOpInfo::$($tt)*\n-        )\n-    };\n-}"}, {"sha": "6e8e56a1b11f5f49610b12fe16b345eeeafd3bec", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=69daf844daac2f8c75ae0db662c584f05dd9838e", "patch": "@@ -1,7 +1,7 @@\n //! An interpreter for MIR used in CTFE and by miri\n \n #[macro_export]\n-macro_rules! err {\n+macro_rules! throw_err {\n     ($($tt:tt)*) => {\n         Err($crate::mir::interpret::InterpError::Unsupported(\n             $crate::mir::interpret::UnsupportedOpInfo::$($tt)*\n@@ -10,7 +10,7 @@ macro_rules! err {\n }\n \n #[macro_export]\n-macro_rules! err_inval {\n+macro_rules! throw_err_inval {\n     ($($tt:tt)*) => {\n         Err($crate::mir::interpret::InterpError::InvalidProgram(\n             $crate::mir::interpret::InvalidProgramInfo::$($tt)*\n@@ -19,7 +19,7 @@ macro_rules! err_inval {\n }\n \n #[macro_export]\n-macro_rules! err_ub {\n+macro_rules! throw_err_ub {\n     ($($tt:tt)*) => {\n         Err($crate::mir::interpret::InterpError::UndefinedBehaviour(\n             $crate::mir::interpret::UndefinedBehaviourInfo::$($tt)*\n@@ -28,7 +28,7 @@ macro_rules! err_ub {\n }\n \n #[macro_export]\n-macro_rules! err_panic {\n+macro_rules! throw_err_panic {\n     ($($tt:tt)*) => {\n         Err($crate::mir::interpret::InterpError::Panic(\n             $crate::mir::interpret::PanicInfo::$($tt)*\n@@ -37,19 +37,36 @@ macro_rules! err_panic {\n }\n \n #[macro_export]\n-macro_rules! err_exhaust {\n+macro_rules! throw_err_exhaust {\n     ($($tt:tt)*) => {\n         Err($crate::mir::interpret::InterpError::ResourceExhaustion(\n             $crate::mir::interpret::ResourceExhaustionInfo::$($tt)*\n         ).into())\n     };\n }\n \n+#[macro_export]\n+macro_rules! err_inval {\n+    ($($tt:tt)*) => {\n+        $crate::mir::interpret::InterpError::InvalidProgram(\n+            $crate::mir::interpret::InvalidProgramInfo::$($tt)*\n+        )\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! err {\n+    ($($tt:tt)*) => {\n+        $crate::mir::interpret::InterpError::Unsupported(\n+            $crate::mir::interpret::UnsupportedOpInfo::$($tt)*\n+        )\n+    };\n+}\n+\n mod error;\n mod value;\n mod allocation;\n mod pointer;\n-mod interp_error;\n \n pub use self::error::{\n     InterpErrorInfo, InterpResult, InterpError, AssertMessage, ConstEvalErr, struct_error,"}, {"sha": "27a41bba4c1b1d8c4f375051abe85487a56bf3b5", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=69daf844daac2f8c75ae0db662c584f05dd9838e", "patch": "@@ -74,13 +74,13 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n     #[inline]\n     fn offset<'tcx>(&self, val: u64, i: u64) -> InterpResult<'tcx, u64> {\n         let (res, over) = self.overflowing_offset(val, i);\n-        if over { err_panic!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n+        if over { throw_err_panic!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n     }\n \n     #[inline]\n     fn signed_offset<'tcx>(&self, val: u64, i: i64) -> InterpResult<'tcx, u64> {\n         let (res, over) = self.overflowing_signed_offset(val, i128::from(i));\n-        if over { err_panic!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n+        if over { throw_err_panic!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n     }\n }\n \n@@ -196,7 +196,7 @@ impl<'tcx, Tag> Pointer<Tag> {\n         msg: CheckInAllocMsg,\n     ) -> InterpResult<'tcx, ()> {\n         if self.offset > allocation_size {\n-            err!(PointerOutOfBounds { ptr: self.erase_tag(), msg, allocation_size })\n+            throw_err!(PointerOutOfBounds { ptr: self.erase_tag(), msg, allocation_size })\n         } else {\n             Ok(())\n         }"}, {"sha": "9379054bdfc9d7a70779e776e80fb55da78e0cbc", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=69daf844daac2f8c75ae0db662c584f05dd9838e", "patch": "@@ -360,7 +360,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n                 Scalar::check_data(data, size);\n                 Ok(data)\n             }\n-            Scalar::Ptr(_) => err!(ReadPointerAsBytes),\n+            Scalar::Ptr(_) => throw_err!(ReadPointerAsBytes),\n         }\n     }\n \n@@ -373,8 +373,8 @@ impl<'tcx, Tag> Scalar<Tag> {\n     #[inline]\n     pub fn to_ptr(self) -> InterpResult<'tcx, Pointer<Tag>> {\n         match self {\n-            Scalar::Raw { data: 0, .. } => err!(InvalidNullPointerUsage),\n-            Scalar::Raw { .. } => err!(ReadBytesAsPointer),\n+            Scalar::Raw { data: 0, .. } => throw_err!(InvalidNullPointerUsage),\n+            Scalar::Raw { .. } => throw_err!(ReadBytesAsPointer),\n             Scalar::Ptr(p) => Ok(p),\n         }\n     }\n@@ -406,15 +406,15 @@ impl<'tcx, Tag> Scalar<Tag> {\n         match self {\n             Scalar::Raw { data: 0, size: 1 } => Ok(false),\n             Scalar::Raw { data: 1, size: 1 } => Ok(true),\n-            _ => err!(InvalidBool),\n+            _ => throw_err!(InvalidBool),\n         }\n     }\n \n     pub fn to_char(self) -> InterpResult<'tcx, char> {\n         let val = self.to_u32()?;\n         match ::std::char::from_u32(val) {\n             Some(c) => Ok(c),\n-            None => err!(InvalidChar(val as u128)),\n+            None => throw_err!(InvalidChar(val as u128)),\n         }\n     }\n \n@@ -537,7 +537,7 @@ impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n     pub fn not_undef(self) -> InterpResult<'static, Scalar<Tag>> {\n         match self {\n             ScalarMaybeUndef::Scalar(scalar) => Ok(scalar),\n-            ScalarMaybeUndef::Undef => err!(ReadUndefBytes(Size::from_bytes(0))),\n+            ScalarMaybeUndef::Undef => throw_err!(ReadUndefBytes(Size::from_bytes(0))),\n         }\n     }\n "}, {"sha": "786e2e71ec664736f7150f9f1399fb1ff720a39d", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=69daf844daac2f8c75ae0db662c584f05dd9838e", "patch": "@@ -352,7 +352,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                     ecx.goto_block(ret)?; // fully evaluated and done\n                     Ok(None)\n                 } else {\n-                    err!(MachineError(format!(\"calling non-const function `{}`\", instance)))\n+                    throw_err!(MachineError(format!(\"calling non-const function `{}`\", instance)))\n                 };\n             }\n         }\n@@ -412,7 +412,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         _tcx: TyCtxt<'tcx>,\n         _def_id: DefId,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n-        err!(ReadForeignStatic)\n+        throw_err!(ReadForeignStatic)\n     }\n \n     #[inline(always)]"}, {"sha": "fb0ad26d56695201d9573d9dce14dad750e84735", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=69daf844daac2f8c75ae0db662c584f05dd9838e", "patch": "@@ -85,7 +85,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             self.param_env,\n                             def_id,\n                             substs,\n-                        ).ok_or_else(|| inval!(TooGeneric).into());\n+                        ).ok_or_else(|| err_inval!(TooGeneric).into());\n                         let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance?));\n                         self.write_scalar(Scalar::Ptr(fn_ptr.into()), dest)?;\n                     }\n@@ -199,7 +199,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             },\n \n             // Casts to bool are not permitted by rustc, no need to handle them here.\n-            _ => err!(Unimplemented(format!(\"int to {:?} cast\", dest_layout.ty))),\n+            _ => throw_err!(Unimplemented(format!(\"int to {:?} cast\", dest_layout.ty))),\n         }\n     }\n "}, {"sha": "61ebcb58b91b29e3780f17c40cbb77797eb3e951", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=69daf844daac2f8c75ae0db662c584f05dd9838e", "patch": "@@ -135,7 +135,7 @@ pub enum LocalValue<Tag=(), Id=AllocId> {\n impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n     pub fn access(&self) -> InterpResult<'tcx, Operand<Tag>> {\n         match self.value {\n-            LocalValue::Dead => err!(DeadLocal),\n+            LocalValue::Dead => throw_err!(DeadLocal),\n             LocalValue::Uninitialized =>\n                 bug!(\"The type checker should prevent reading from a never-written local\"),\n             LocalValue::Live(val) => Ok(val),\n@@ -148,7 +148,7 @@ impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n         &mut self,\n     ) -> InterpResult<'tcx, Result<&mut LocalValue<Tag>, MemPlace<Tag>>> {\n         match self.value {\n-            LocalValue::Dead => err!(DeadLocal),\n+            LocalValue::Dead => throw_err!(DeadLocal),\n             LocalValue::Live(Operand::Indirect(mplace)) => Ok(Err(mplace)),\n             ref mut local @ LocalValue::Live(Operand::Immediate(_)) |\n             ref mut local @ LocalValue::Uninitialized => {\n@@ -305,7 +305,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 &substs,\n             )),\n             None => if substs.needs_subst() {\n-                err_inval!(TooGeneric)\n+                throw_err_inval!(TooGeneric)\n             } else {\n                 Ok(substs)\n             },\n@@ -326,7 +326,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             self.param_env,\n             def_id,\n             substs,\n-        ).ok_or_else(|| inval!(TooGeneric).into())\n+        ).ok_or_else(|| err_inval!(TooGeneric).into())\n     }\n \n     pub fn load_mir(\n@@ -339,14 +339,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             && self.tcx.has_typeck_tables(did)\n             && self.tcx.typeck_tables_of(did).tainted_by_errors\n         {\n-            return err_inval!(TypeckError);\n+            return throw_err_inval!(TypeckError);\n         }\n         trace!(\"load mir {:?}\", instance);\n         match instance {\n             ty::InstanceDef::Item(def_id) => if self.tcx.is_mir_available(did) {\n                 Ok(self.tcx.optimized_mir(did))\n             } else {\n-                err!(NoMirFor(self.tcx.def_path_str(def_id)))\n+                throw_err!(NoMirFor(self.tcx.def_path_str(def_id)))\n             },\n             _ => Ok(self.tcx.instance_mir(instance)),\n         }\n@@ -359,7 +359,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match self.stack.last() {\n             Some(frame) => Ok(self.monomorphize_with_substs(t, frame.instance.substs)?),\n             None => if t.needs_subst() {\n-                err_inval!(TooGeneric).into()\n+                throw_err_inval!(TooGeneric).into()\n             } else {\n                 Ok(t)\n             },\n@@ -376,7 +376,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let substituted = t.subst(*self.tcx, substs);\n \n         if substituted.needs_subst() {\n-            return err_inval!(TooGeneric);\n+            return throw_err_inval!(TooGeneric);\n         }\n \n         Ok(self.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), substituted))\n@@ -575,7 +575,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         info!(\"ENTERING({}) {}\", self.cur_frame(), self.frame().instance);\n \n         if self.stack.len() > self.tcx.sess.const_eval_stack_frame_limit {\n-            err_exhaust!(StackFrameLimitReached)\n+            throw_err_exhaust!(StackFrameLimitReached)\n         } else {\n             Ok(())\n         }\n@@ -623,7 +623,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         } else {\n             // Uh, that shouldn't happen... the function did not intend to return\n-            return err_ub!(Unreachable);\n+            return throw_err_ub!(Unreachable);\n         }\n         // Jump to new block -- *after* validation so that the spans make more sense.\n         match frame.return_to_block {"}, {"sha": "f362ea812f5fab34d47a49b728ce4a1a286739d0", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=69daf844daac2f8c75ae0db662c584f05dd9838e", "patch": "@@ -328,7 +328,7 @@ pub fn intern_const_alloc_recursive(\n             }\n         } else if ecx.memory().dead_alloc_map.contains_key(&alloc_id) {\n             // dangling pointer\n-            return err!(ValidationFailure(\"encountered dangling pointer in final constant\".into()))\n+            return throw_err!(ValidationFailure(\"encountered dangling pointer in final constant\".into()))\n         }\n     }\n     Ok(())"}, {"sha": "d571d90e896f89d40f1bf41726ea13c3ce97bc64", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=69daf844daac2f8c75ae0db662c584f05dd9838e", "patch": "@@ -104,7 +104,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 let out_val = if intrinsic_name.ends_with(\"_nonzero\") {\n                     if bits == 0 {\n-                        return err!(Intrinsic(format!(\"{} called on 0\", intrinsic_name)));\n+                        return throw_err!(Intrinsic(format!(\"{} called on 0\", intrinsic_name)));\n                     }\n                     numeric_intrinsic(intrinsic_name.trim_end_matches(\"_nonzero\"), bits, kind)?\n                 } else {\n@@ -190,7 +190,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 if overflowed {\n                     let layout = self.layout_of(substs.type_at(0))?;\n                     let r_val =  r.to_scalar()?.to_bits(layout.size)?;\n-                    return err!(Intrinsic(\n+                    return throw_err!(Intrinsic(\n                         format!(\"Overflowing shift by {} in {}\", r_val, intrinsic_name),\n                     ));\n                 }"}, {"sha": "5fc43c7712c552f45f6a6481f2819d59cafb35d0", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=69daf844daac2f8c75ae0db662c584f05dd9838e", "patch": "@@ -251,6 +251,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         _mem: &Memory<'mir, 'tcx, Self>,\n         _ptr: Pointer<Self::PointerTag>,\n     ) -> InterpResult<'tcx, u64> {\n-        err!(ReadPointerAsBytes)\n+        throw_err!(ReadPointerAsBytes)\n     }\n }"}, {"sha": "ee5607c49386c5b7552aae96001afdcb4ce26c3e", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=69daf844daac2f8c75ae0db662c584f05dd9838e", "patch": "@@ -66,7 +66,7 @@ impl<'tcx, Other> FnVal<'tcx, Other> {\n         match self {\n             FnVal::Instance(instance) =>\n                 Ok(instance),\n-            FnVal::Other(_) => err!(MachineError(format!(\n+            FnVal::Other(_) => throw_err!(MachineError(format!(\n                 \"Expected instance function pointer, got 'other' pointer\"\n             ))),\n         }\n@@ -202,7 +202,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n         if ptr.offset.bytes() != 0 {\n-            return err!(ReallocateNonBasePtr);\n+            return throw_err!(ReallocateNonBasePtr);\n         }\n \n         // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\".\n@@ -243,38 +243,38 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         trace!(\"deallocating: {}\", ptr.alloc_id);\n \n         if ptr.offset.bytes() != 0 {\n-            return err!(DeallocateNonBasePtr);\n+            return throw_err!(DeallocateNonBasePtr);\n         }\n \n         let (alloc_kind, mut alloc) = match self.alloc_map.remove(&ptr.alloc_id) {\n             Some(alloc) => alloc,\n             None => {\n                 // Deallocating static memory -- always an error\n                 return match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n-                    Some(GlobalAlloc::Function(..)) => err!(DeallocatedWrongMemoryKind(\n+                    Some(GlobalAlloc::Function(..)) => throw_err!(DeallocatedWrongMemoryKind(\n                         \"function\".to_string(),\n                         format!(\"{:?}\", kind),\n                     )),\n                     Some(GlobalAlloc::Static(..)) |\n-                    Some(GlobalAlloc::Memory(..)) => err!(DeallocatedWrongMemoryKind(\n+                    Some(GlobalAlloc::Memory(..)) => throw_err!(DeallocatedWrongMemoryKind(\n                         \"static\".to_string(),\n                         format!(\"{:?}\", kind),\n                     )),\n-                    None => err!(DoubleFree)\n+                    None => throw_err!(DoubleFree)\n                 }\n             }\n         };\n \n         if alloc_kind != kind {\n-            return err!(DeallocatedWrongMemoryKind(\n+            return throw_err!(DeallocatedWrongMemoryKind(\n                 format!(\"{:?}\", alloc_kind),\n                 format!(\"{:?}\", kind),\n             ));\n         }\n         if let Some((size, align)) = old_size_and_align {\n             if size.bytes() != alloc.bytes.len() as u64 || align != alloc.align {\n                 let bytes = Size::from_bytes(alloc.bytes.len() as u64);\n-                return err!(IncorrectAllocationInformation(size, bytes, align, alloc.align));\n+                return throw_err!(IncorrectAllocationInformation(size, bytes, align, alloc.align));\n             }\n         }\n \n@@ -319,7 +319,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             } else {\n                 // The biggest power of two through which `offset` is divisible.\n                 let offset_pow2 = 1 << offset.trailing_zeros();\n-                err!(AlignmentCheckFailed {\n+                throw_err!(AlignmentCheckFailed {\n                     has: Align::from_bytes(offset_pow2).unwrap(),\n                     required: align,\n                 })\n@@ -341,7 +341,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 assert!(size.bytes() == 0);\n                 // Must be non-NULL and aligned.\n                 if bits == 0 {\n-                    return err!(InvalidNullPointerUsage);\n+                    return throw_err!(InvalidNullPointerUsage);\n                 }\n                 check_offset_align(bits, align)?;\n                 None\n@@ -362,7 +362,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     // got picked we might be aligned even if this check fails.\n                     // We instead have to fall back to converting to an integer and checking\n                     // the \"real\" alignment.\n-                    return err!(AlignmentCheckFailed {\n+                    return throw_err!(AlignmentCheckFailed {\n                         has: alloc_align,\n                         required: align,\n                     });\n@@ -413,9 +413,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(GlobalAlloc::Memory(mem)) =>\n                 Cow::Borrowed(mem),\n             Some(GlobalAlloc::Function(..)) =>\n-                return err!(DerefFunctionPointer),\n+                return throw_err!(DerefFunctionPointer),\n             None =>\n-                return err!(DanglingPointerDeref),\n+                return throw_err!(DanglingPointerDeref),\n             Some(GlobalAlloc::Static(def_id)) => {\n                 // We got a \"lazy\" static that has not been computed yet.\n                 if tcx.is_foreign_item(def_id) {\n@@ -505,11 +505,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             // to give us a cheap reference.\n             let alloc = Self::get_static_alloc(memory_extra, tcx, id)?;\n             if alloc.mutability == Mutability::Immutable {\n-                return err!(ModifiedConstantMemory);\n+                return throw_err!(ModifiedConstantMemory);\n             }\n             match M::STATIC_KIND {\n                 Some(kind) => Ok((MemoryKind::Machine(kind), alloc.into_owned())),\n-                None => err!(ModifiedStatic),\n+                None => throw_err!(ModifiedStatic),\n             }\n         });\n         // Unpack the error type manually because type inference doesn't\n@@ -519,7 +519,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Ok(a) => {\n                 let a = &mut a.1;\n                 if a.mutability == Mutability::Immutable {\n-                    return err!(ModifiedConstantMemory);\n+                    return throw_err!(ModifiedConstantMemory);\n                 }\n                 Ok(a)\n             }\n@@ -548,7 +548,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         if let Ok(_) = self.get_fn_alloc(id) {\n             return if let AllocCheck::Dereferencable = liveness {\n                 // The caller requested no function pointers.\n-                err!(DerefFunctionPointer)\n+                throw_err!(DerefFunctionPointer)\n             } else {\n                 Ok((Size::ZERO, Align::from_bytes(1).unwrap()))\n             };\n@@ -579,7 +579,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     .expect(\"deallocated pointers should all be recorded in \\\n                             `dead_alloc_map`\"))\n             } else {\n-                err!(DanglingPointerDeref)\n+                throw_err!(DanglingPointerDeref)\n             },\n         }\n     }\n@@ -591,7 +591,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         } else {\n             match self.tcx.alloc_map.lock().get(id) {\n                 Some(GlobalAlloc::Function(instance)) => Ok(FnVal::Instance(instance)),\n-                _ => err!(ExecuteMemory),\n+                _ => throw_err!(ExecuteMemory),\n             }\n         }\n     }\n@@ -602,7 +602,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         let ptr = self.force_ptr(ptr)?; // We definitely need a pointer value.\n         if ptr.offset.bytes() != 0 {\n-            return err!(InvalidFunctionPointer);\n+            return throw_err!(InvalidFunctionPointer);\n         }\n         self.get_fn_alloc(ptr.alloc_id)\n     }\n@@ -837,7 +837,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     if (src.offset <= dest.offset && src.offset + size > dest.offset) ||\n                         (dest.offset <= src.offset && dest.offset + size > src.offset)\n                     {\n-                        return err!(Intrinsic(\n+                        return throw_err!(Intrinsic(\n                             \"copy_nonoverlapping called on overlapping ranges\".to_string(),\n                         ));\n                     }"}, {"sha": "346dd83f1d59a3ea0a9a7e0cf3b4722cc1e9601a", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=69daf844daac2f8c75ae0db662c584f05dd9838e", "patch": "@@ -461,7 +461,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         mir_place.iterate(|place_base, place_projection| {\n             let mut op = match place_base {\n                 PlaceBase::Local(mir::RETURN_PLACE) =>\n-                    return err!(ReadFromReturnPointer),\n+                    return throw_err!(ReadFromReturnPointer),\n                 PlaceBase::Local(local) => {\n                     // Do not use the layout passed in as argument if the base we are looking at\n                     // here is not the entire place.\n@@ -534,7 +534,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match val.val {\n             ConstValue::Param(_) =>\n                 // FIXME(oli-obk): try to monomorphize\n-                return err_inval!(TooGeneric),\n+                return throw_err_inval!(TooGeneric),\n             ConstValue::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n                 return Ok(OpTy::from(self.const_eval_raw(GlobalId {\n@@ -610,7 +610,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let bits_discr = match raw_discr.to_bits(discr_val.layout.size) {\n                     Ok(raw_discr) => raw_discr,\n                     Err(_) =>\n-                        return err!(InvalidDiscriminant(raw_discr.erase_tag())),\n+                        return throw_err!(InvalidDiscriminant(raw_discr.erase_tag())),\n                 };\n                 let real_discr = if discr_val.layout.ty.is_signed() {\n                     // going from layout tag type to typeck discriminant type\n@@ -637,7 +637,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         .find(|(_, var)| var.val == real_discr),\n                     _ => bug!(\"tagged layout for non-adt non-generator\"),\n                 }.ok_or_else(\n-                    || unsup!(InvalidDiscriminant(raw_discr.erase_tag()))\n+                    || err!(InvalidDiscriminant(raw_discr.erase_tag()))\n                 )?;\n                 (real_discr, index.0)\n             },\n@@ -657,7 +657,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         let ptr_valid = niche_start == 0 && variants_start == variants_end &&\n                             !self.memory.ptr_may_be_null(ptr);\n                         if !ptr_valid {\n-                            return err!(InvalidDiscriminant(raw_discr.erase_tag().into()));\n+                            return throw_err!(InvalidDiscriminant(raw_discr.erase_tag().into()));\n                         }\n                         (dataful_variant.as_u32() as u128, dataful_variant)\n                     },"}, {"sha": "5aea423e388abe0f4b2a6620fbb82e00936c2c1d", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=69daf844daac2f8c75ae0db662c584f05dd9838e", "patch": "@@ -155,7 +155,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 r,\n                 right_layout.ty\n             );\n-            return err!(Unimplemented(msg));\n+            return throw_err!(Unimplemented(msg));\n         }\n \n         // Operations that need special treatment for signed integers\n@@ -173,8 +173,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 return Ok((Scalar::from_bool(op(&l, &r)), false));\n             }\n             let op: Option<fn(i128, i128) -> (i128, bool)> = match bin_op {\n-                Div if r == 0 => return err_panic!(DivisionByZero),\n-                Rem if r == 0 => return err_panic!(RemainderByZero),\n+                Div if r == 0 => return throw_err_panic!(DivisionByZero),\n+                Rem if r == 0 => return throw_err_panic!(RemainderByZero),\n                 Div => Some(i128::overflowing_div),\n                 Rem => Some(i128::overflowing_rem),\n                 Add => Some(i128::overflowing_add),\n@@ -231,8 +231,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Add => u128::overflowing_add,\n                     Sub => u128::overflowing_sub,\n                     Mul => u128::overflowing_mul,\n-                    Div if r == 0 => return err_panic!(DivisionByZero),\n-                    Rem if r == 0 => return err_panic!(RemainderByZero),\n+                    Div if r == 0 => return throw_err_panic!(DivisionByZero),\n+                    Rem if r == 0 => return throw_err_panic!(RemainderByZero),\n                     Div => u128::overflowing_div,\n                     Rem => u128::overflowing_rem,\n                     _ => bug!(),\n@@ -250,7 +250,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     r,\n                     right_layout.ty,\n                 );\n-                return err!(Unimplemented(msg));\n+                return throw_err!(Unimplemented(msg));\n             }\n         };\n "}, {"sha": "4349c99a6196c7d2131ee4a2b468e7969b067776", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=69daf844daac2f8c75ae0db662c584f05dd9838e", "patch": "@@ -356,7 +356,7 @@ where\n                     // This can be violated because this runs during promotion on code where the\n                     // type system has not yet ensured that such things don't happen.\n                     debug!(\"tried to access element {} of array/slice with length {}\", field, len);\n-                    return err_panic!(BoundsCheck { len, index: field });\n+                    return throw_err_panic!(BoundsCheck { len, index: field });\n                 }\n                 stride * field\n             }\n@@ -622,7 +622,7 @@ where\n                                 .layout_of(self.monomorphize(self.frame().body.return_ty())?)?,\n                         }\n                     }\n-                    None => return err!(InvalidNullPointerUsage),\n+                    None => return throw_err!(InvalidNullPointerUsage),\n                 },\n                 PlaceBase::Local(local) => PlaceTy {\n                     // This works even for dead/uninitialized locals; we check further when writing"}, {"sha": "3aa0144fa8f68a08c4d65b792c09f2de41456d18", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=69daf844daac2f8c75ae0db662c584f05dd9838e", "patch": "@@ -121,7 +121,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // size of MIR constantly.\n             Nop => {}\n \n-            InlineAsm { .. } => return err!(InlineAsm),\n+            InlineAsm { .. } => return throw_err!(InlineAsm),\n         }\n \n         self.stack[frame_idx].stmt += 1;"}, {"sha": "5399220108118801fdbe3872cbdb7a3dd9d643ee", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=69daf844daac2f8c75ae0db662c584f05dd9838e", "patch": "@@ -19,7 +19,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             self.frame_mut().stmt = 0;\n             Ok(())\n         } else {\n-            err_ub!(Unreachable)\n+            throw_err_ub!(Unreachable)\n         }\n     }\n \n@@ -89,7 +89,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     },\n                     _ => {\n                         let msg = format!(\"can't handle callee of type {:?}\", func.layout.ty);\n-                        return err!(Unimplemented(msg));\n+                        return throw_err!(Unimplemented(msg));\n                     }\n                 };\n                 let args = self.eval_operands(args)?;\n@@ -144,20 +144,20 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             let index = self.read_immediate(self.eval_operand(index, None)?)\n                                 .expect(\"can't eval index\").to_scalar()?\n                                 .to_bits(self.memory().pointer_size())? as u64;\n-                            err_panic!(BoundsCheck { len, index })\n+                            throw_err_panic!(BoundsCheck { len, index })\n                         }\n                         Overflow(op) =>\n-                            err_panic!(Overflow(*op)),\n+                            throw_err_panic!(Overflow(*op)),\n                         OverflowNeg =>\n-                            err_panic!(OverflowNeg),\n+                            throw_err_panic!(OverflowNeg),\n                         DivisionByZero =>\n-                            err_panic!(DivisionByZero),\n+                            throw_err_panic!(DivisionByZero),\n                         RemainderByZero =>\n-                            err_panic!(RemainderByZero),\n+                            throw_err_panic!(RemainderByZero),\n                         GeneratorResumedAfterReturn =>\n-                            err_panic!(GeneratorResumedAfterReturn),\n+                            throw_err_panic!(GeneratorResumedAfterReturn),\n                         GeneratorResumedAfterPanic =>\n-                            err_panic!(GeneratorResumedAfterPanic),\n+                            throw_err_panic!(GeneratorResumedAfterPanic),\n                         Panic { .. } =>\n                             bug!(\"`Panic` variant cannot occur in MIR\"),\n                     };\n@@ -173,7 +173,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                                       `simplify_branches` mir pass\"),\n             FalseUnwind { .. } => bug!(\"should have been eliminated by\\\n                                        `simplify_branches` mir pass\"),\n-            Unreachable => return err_ub!(Unreachable),\n+            Unreachable => return throw_err_ub!(Unreachable),\n         }\n \n         Ok(())\n@@ -220,13 +220,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(());\n         }\n         let caller_arg = caller_arg.next()\n-            .ok_or_else(|| unsup!(FunctionArgCountMismatch)) ?;\n+            .ok_or_else(|| err!(FunctionArgCountMismatch)) ?;\n         if rust_abi {\n             debug_assert!(!caller_arg.layout.is_zst(), \"ZSTs must have been already filtered out\");\n         }\n         // Now, check\n         if !Self::check_argument_compat(rust_abi, caller_arg.layout, callee_arg.layout) {\n-            return err!(FunctionArgMismatch(caller_arg.layout.ty, callee_arg.layout.ty));\n+            return throw_err!(FunctionArgMismatch(caller_arg.layout.ty, callee_arg.layout.ty));\n         }\n         // We allow some transmutes here\n         self.copy_op_transmute(caller_arg, callee_arg)\n@@ -254,13 +254,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match instance.def {\n             ty::InstanceDef::Intrinsic(..) => {\n                 if caller_abi != Abi::RustIntrinsic {\n-                    return err!(FunctionAbiMismatch(caller_abi, Abi::RustIntrinsic));\n+                    return throw_err!(FunctionAbiMismatch(caller_abi, Abi::RustIntrinsic));\n                 }\n                 // The intrinsic itself cannot diverge, so if we got here without a return\n                 // place... (can happen e.g., for transmute returning `!`)\n                 let dest = match dest {\n                     Some(dest) => dest,\n-                    None => return err_ub!(Unreachable)\n+                    None => return throw_err_ub!(Unreachable)\n                 };\n                 M::call_intrinsic(self, instance, args, dest)?;\n                 // No stack frame gets pushed, the main loop will just act as if the\n@@ -295,7 +295,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             abi,\n                     };\n                     if normalize_abi(caller_abi) != normalize_abi(callee_abi) {\n-                        return err!(FunctionAbiMismatch(caller_abi, callee_abi));\n+                        return throw_err!(FunctionAbiMismatch(caller_abi, callee_abi));\n                     }\n                 }\n \n@@ -390,7 +390,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // Now we should have no more caller args\n                     if caller_iter.next().is_some() {\n                         trace!(\"Caller has passed too many args\");\n-                        return err!(FunctionArgCountMismatch);\n+                        return throw_err!(FunctionArgCountMismatch);\n                     }\n                     // Don't forget to check the return type!\n                     if let Some(caller_ret) = dest {\n@@ -402,15 +402,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             caller_ret.layout,\n                             callee_ret.layout,\n                         ) {\n-                            return err!(\n+                            return throw_err!(\n                                 FunctionRetMismatch(caller_ret.layout.ty, callee_ret.layout.ty)\n                             );\n                         }\n                     } else {\n                         let local = mir::RETURN_PLACE;\n                         let ty = self.frame().body.local_decls[local].ty;\n                         if !self.tcx.is_ty_uninhabited_from_any_module(ty) {\n-                            return err!(FunctionRetMismatch(self.tcx.types.never, ty));\n+                            return throw_err!(FunctionRetMismatch(self.tcx.types.never, ty));\n                         }\n                     }\n                     Ok(())"}, {"sha": "e55b0d0fb1f2a56e6f572a3b78b6fd2a5070415c", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=69daf844daac2f8c75ae0db662c584f05dd9838e", "patch": "@@ -83,7 +83,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     self.param_env,\n                     def_id,\n                     substs,\n-                ).ok_or_else(|| inval!(TooGeneric))?;\n+                ).ok_or_else(|| err_inval!(TooGeneric))?;\n                 let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), self)?;\n                 self.memory"}, {"sha": "511ebfd023cd38d20e25ea362c713582276ccca3", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=69daf844daac2f8c75ae0db662c584f05dd9838e", "patch": "@@ -22,7 +22,7 @@ macro_rules! validation_failure {\n         } else {\n             format!(\" at {}\", where_)\n         };\n-        err!(ValidationFailure(format!(\n+        throw_err!(ValidationFailure(format!(\n             \"encountered {}{}, but expected {}\",\n             $what, where_, $details,\n         )))\n@@ -34,7 +34,7 @@ macro_rules! validation_failure {\n         } else {\n             format!(\" at {}\", where_)\n         };\n-        err!(ValidationFailure(format!(\n+        throw_err!(ValidationFailure(format!(\n             \"encountered {}{}\",\n             $what, where_,\n         )))"}, {"sha": "db6b62e95ce0a84897e8149cacbd7dea5a89a95c", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69daf844daac2f8c75ae0db662c584f05dd9838e/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=69daf844daac2f8c75ae0db662c584f05dd9838e", "patch": "@@ -441,7 +441,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                             // Need to do overflow check here: For actual CTFE, MIR\n                             // generation emits code that does this before calling the op.\n                             if prim.to_bits()? == (1 << (prim.layout.size.bits() - 1)) {\n-                                return err_panic!(OverflowNeg);\n+                                return throw_err_panic!(OverflowNeg);\n                             }\n                         }\n                         UnOp::Not => {"}]}