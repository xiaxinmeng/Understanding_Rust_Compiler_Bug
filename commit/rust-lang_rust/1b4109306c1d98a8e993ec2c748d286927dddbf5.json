{"sha": "1b4109306c1d98a8e993ec2c748d286927dddbf5", "node_id": "C_kwDOAAsO6NoAKDFiNDEwOTMwNmMxZDk4YThlOTkzZWMyYzc0OGQyODY5MjdkZGRiZjU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-27T22:34:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-01-27T22:34:34Z"}, "message": "Auto merge of #93390 - matthiaskrgr:rollup-4xeki5w, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #91641 (Define c_char using cfg_if rather than repeating 40-line cfg)\n - #92899 (Mention std::iter::zip in Iterator::zip docs)\n - #93193 (Add test for stable hash uniqueness of adjacent field values)\n - #93325 (Introduce a limit to Levenshtein distance computation)\n - #93339 (rustdoc: add test case for multiple traits and erased names)\n - #93357 (Clarify the `usage-of-qualified-ty` error message.)\n - #93363 (`#[rustc_pass_by_value]` cleanup)\n - #93365 (More arena cleanups)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "f23c58fd80951d088f213afdc24daa91a665fd98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f23c58fd80951d088f213afdc24daa91a665fd98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b4109306c1d98a8e993ec2c748d286927dddbf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b4109306c1d98a8e993ec2c748d286927dddbf5", "html_url": "https://github.com/rust-lang/rust/commit/1b4109306c1d98a8e993ec2c748d286927dddbf5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b4109306c1d98a8e993ec2c748d286927dddbf5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21b4a9cfdcbb1e76f4b36b5c3cfd64d627285093", "url": "https://api.github.com/repos/rust-lang/rust/commits/21b4a9cfdcbb1e76f4b36b5c3cfd64d627285093", "html_url": "https://github.com/rust-lang/rust/commit/21b4a9cfdcbb1e76f4b36b5c3cfd64d627285093"}, {"sha": "0eb6753fc5b51df9d79b495c3812440958cd0052", "url": "https://api.github.com/repos/rust-lang/rust/commits/0eb6753fc5b51df9d79b495c3812440958cd0052", "html_url": "https://github.com/rust-lang/rust/commit/0eb6753fc5b51df9d79b495c3812440958cd0052"}], "stats": {"total": 502, "additions": 322, "deletions": 180}, "files": [{"sha": "3928d70c0ede2c9b9c716e822e35f9649e5d020c", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 40, "deletions": 21, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -45,24 +45,24 @@ pub struct TypedArena<T> {\n     end: Cell<*mut T>,\n \n     /// A vector of arena chunks.\n-    chunks: RefCell<Vec<TypedArenaChunk<T>>>,\n+    chunks: RefCell<Vec<ArenaChunk<T>>>,\n \n     /// Marker indicating that dropping the arena causes its owned\n     /// instances of `T` to be dropped.\n     _own: PhantomData<T>,\n }\n \n-struct TypedArenaChunk<T> {\n+struct ArenaChunk<T = u8> {\n     /// The raw storage for the arena chunk.\n     storage: Box<[MaybeUninit<T>]>,\n     /// The number of valid entries in the chunk.\n     entries: usize,\n }\n \n-impl<T> TypedArenaChunk<T> {\n+impl<T> ArenaChunk<T> {\n     #[inline]\n-    unsafe fn new(capacity: usize) -> TypedArenaChunk<T> {\n-        TypedArenaChunk { storage: Box::new_uninit_slice(capacity), entries: 0 }\n+    unsafe fn new(capacity: usize) -> ArenaChunk<T> {\n+        ArenaChunk { storage: Box::new_uninit_slice(capacity), entries: 0 }\n     }\n \n     /// Destroys this arena chunk.\n@@ -125,6 +125,11 @@ impl<I, T> IterExt<T> for I\n where\n     I: IntoIterator<Item = T>,\n {\n+    // This default collects into a `SmallVec` and then allocates by copying\n+    // from it. The specializations below for types like `Vec` are more\n+    // efficient, copying directly without the intermediate collecting step.\n+    // This default could be made more efficient, like\n+    // `DroplessArena::alloc_from_iter`, but it's not hot enough to bother.\n     #[inline]\n     default fn alloc_from_iter(self, arena: &TypedArena<T>) -> &mut [T] {\n         let vec: SmallVec<[_; 8]> = self.into_iter().collect();\n@@ -139,7 +144,7 @@ impl<T, const N: usize> IterExt<T> for std::array::IntoIter<T, N> {\n         if len == 0 {\n             return &mut [];\n         }\n-        // Move the content to the arena by copying and then forgetting it\n+        // Move the content to the arena by copying and then forgetting it.\n         unsafe {\n             let start_ptr = arena.alloc_raw_slice(len);\n             self.as_slice().as_ptr().copy_to_nonoverlapping(start_ptr, len);\n@@ -156,7 +161,7 @@ impl<T> IterExt<T> for Vec<T> {\n         if len == 0 {\n             return &mut [];\n         }\n-        // Move the content to the arena by copying and then forgetting it\n+        // Move the content to the arena by copying and then forgetting it.\n         unsafe {\n             let start_ptr = arena.alloc_raw_slice(len);\n             self.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n@@ -173,7 +178,7 @@ impl<A: smallvec::Array> IterExt<A::Item> for SmallVec<A> {\n         if len == 0 {\n             return &mut [];\n         }\n-        // Move the content to the arena by copying and then forgetting it\n+        // Move the content to the arena by copying and then forgetting it.\n         unsafe {\n             let start_ptr = arena.alloc_raw_slice(len);\n             self.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n@@ -272,7 +277,7 @@ impl<T> TypedArena<T> {\n             // Also ensure that this chunk can fit `additional`.\n             new_cap = cmp::max(additional, new_cap);\n \n-            let mut chunk = TypedArenaChunk::<T>::new(new_cap);\n+            let mut chunk = ArenaChunk::<T>::new(new_cap);\n             self.ptr.set(chunk.start());\n             self.end.set(chunk.end());\n             chunks.push(chunk);\n@@ -281,7 +286,7 @@ impl<T> TypedArena<T> {\n \n     // Drops the contents of the last chunk. The last chunk is partially empty, unlike all other\n     // chunks.\n-    fn clear_last_chunk(&self, last_chunk: &mut TypedArenaChunk<T>) {\n+    fn clear_last_chunk(&self, last_chunk: &mut ArenaChunk<T>) {\n         // Determine how much was filled.\n         let start = last_chunk.start() as usize;\n         // We obtain the value of the pointer to the first uninitialized element.\n@@ -340,7 +345,7 @@ pub struct DroplessArena {\n     end: Cell<*mut u8>,\n \n     /// A vector of arena chunks.\n-    chunks: RefCell<Vec<TypedArenaChunk<u8>>>,\n+    chunks: RefCell<Vec<ArenaChunk>>,\n }\n \n unsafe impl Send for DroplessArena {}\n@@ -378,7 +383,7 @@ impl DroplessArena {\n             // Also ensure that this chunk can fit `additional`.\n             new_cap = cmp::max(additional, new_cap);\n \n-            let mut chunk = TypedArenaChunk::<u8>::new(new_cap);\n+            let mut chunk = ArenaChunk::new(new_cap);\n             self.start.set(chunk.start());\n             self.end.set(chunk.end());\n             chunks.push(chunk);\n@@ -520,10 +525,19 @@ impl DroplessArena {\n     }\n }\n \n-// Declare an `Arena` containing one dropless arena and many typed arenas (the\n-// types of the typed arenas are specified by the arguments). The dropless\n-// arena will be used for any types that impl `Copy`, and also for any of the\n-// specified types that satisfy `!mem::needs_drop`.\n+/// Declare an `Arena` containing one dropless arena and many typed arenas (the\n+/// types of the typed arenas are specified by the arguments).\n+///\n+/// There are three cases of interest.\n+/// - Types that are `Copy`: these need not be specified in the arguments. They\n+///   will use the `DroplessArena`.\n+/// - Types that are `!Copy` and `!Drop`: these must be specified in the\n+///   arguments. An empty `TypedArena` will be created for each one, but the\n+///   `DroplessArena` will always be used and the `TypedArena` will stay empty.\n+///   This is odd but harmless, because an empty arena allocates no memory.\n+/// - Types that are `!Copy` and `Drop`: these must be specified in the\n+///   arguments. The `TypedArena` will be used for them.\n+///\n #[rustc_macro_transparency = \"semitransparent\"]\n pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n     #[derive(Default)]\n@@ -532,7 +546,7 @@ pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n         $($name: $crate::TypedArena<$ty>,)*\n     }\n \n-    pub trait ArenaAllocatable<'tcx, T = Self>: Sized {\n+    pub trait ArenaAllocatable<'tcx, C = rustc_arena::IsNotCopy>: Sized {\n         fn allocate_on<'a>(self, arena: &'a Arena<'tcx>) -> &'a mut Self;\n         fn allocate_from_iter<'a>(\n             arena: &'a Arena<'tcx>,\n@@ -541,7 +555,7 @@ pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n     }\n \n     // Any type that impls `Copy` can be arena-allocated in the `DroplessArena`.\n-    impl<'tcx, T: Copy> ArenaAllocatable<'tcx, ()> for T {\n+    impl<'tcx, T: Copy> ArenaAllocatable<'tcx, rustc_arena::IsCopy> for T {\n         #[inline]\n         fn allocate_on<'a>(self, arena: &'a Arena<'tcx>) -> &'a mut Self {\n             arena.dropless.alloc(self)\n@@ -555,7 +569,7 @@ pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n         }\n     }\n     $(\n-        impl<'tcx> ArenaAllocatable<'tcx, $ty> for $ty {\n+        impl<'tcx> ArenaAllocatable<'tcx, rustc_arena::IsNotCopy> for $ty {\n             #[inline]\n             fn allocate_on<'a>(self, arena: &'a Arena<'tcx>) -> &'a mut Self {\n                 if !::std::mem::needs_drop::<Self>() {\n@@ -581,7 +595,7 @@ pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n \n     impl<'tcx> Arena<'tcx> {\n         #[inline]\n-        pub fn alloc<T: ArenaAllocatable<'tcx, U>, U>(&self, value: T) -> &mut T {\n+        pub fn alloc<T: ArenaAllocatable<'tcx, C>, C>(&self, value: T) -> &mut T {\n             value.allocate_on(self)\n         }\n \n@@ -594,7 +608,7 @@ pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n             self.dropless.alloc_slice(value)\n         }\n \n-        pub fn alloc_from_iter<'a, T: ArenaAllocatable<'tcx, U>, U>(\n+        pub fn alloc_from_iter<'a, T: ArenaAllocatable<'tcx, C>, C>(\n             &'a self,\n             iter: impl ::std::iter::IntoIterator<Item = T>,\n         ) -> &'a mut [T] {\n@@ -603,5 +617,10 @@ pub macro declare_arena([$($a:tt $name:ident: $ty:ty,)*]) {\n     }\n }\n \n+// Marker types that let us give different behaviour for arenas allocating\n+// `Copy` types vs `!Copy` types.\n+pub struct IsCopy;\n+pub struct IsNotCopy;\n+\n #[cfg(test)]\n mod tests;"}, {"sha": "96dbd3dca156eaaf7d1c17b1661e6aee152f95a2", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -607,7 +607,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         &mut self,\n         macro_def: &ast::MacroDef,\n         ident: &Ident,\n-        sp: &Span,\n+        sp: Span,\n         print_visibility: impl FnOnce(&mut Self),\n     ) {\n         let (kw, has_bang) = if macro_def.macro_rules {\n@@ -623,7 +623,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n             macro_def.body.delim(),\n             &macro_def.body.inner_tokens(),\n             true,\n-            *sp,\n+            sp,\n         );\n         if macro_def.body.need_semicolon() {\n             self.word(\";\");"}, {"sha": "e575d6aa7e2fcf446cf2afecb81a0668aa564768", "filename": "compiler/rustc_ast_pretty/src/pprust/state/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -347,7 +347,7 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::ItemKind::MacroDef(ref macro_def) => {\n-                self.print_mac_def(macro_def, &item.ident, &item.span, |state| {\n+                self.print_mac_def(macro_def, &item.ident, item.span, |state| {\n                     state.print_visibility(&item.vis)\n                 });\n             }"}, {"sha": "31190363eb61bb48875374b0a9f381df5cfc56b6", "filename": "compiler/rustc_data_structures/src/stable_hasher/tests.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -98,3 +98,45 @@ fn test_hash_bit_matrix() {\n     assert_ne!(a, b);\n     assert_ne!(hash(&a), hash(&b));\n }\n+\n+// Check that exchanging the value of two adjacent fields changes the hash.\n+#[test]\n+fn test_attribute_permutation() {\n+    macro_rules! test_type {\n+        ($ty: ty) => {{\n+            struct Foo {\n+                a: $ty,\n+                b: $ty,\n+            }\n+\n+            impl<CTX> HashStable<CTX> for Foo {\n+                fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+                    self.a.hash_stable(hcx, hasher);\n+                    self.b.hash_stable(hcx, hasher);\n+                }\n+            }\n+\n+            #[allow(overflowing_literals)]\n+            let mut item = Foo { a: 0xFF, b: 0xFF_FF };\n+            let hash_a = hash(&item);\n+            std::mem::swap(&mut item.a, &mut item.b);\n+            let hash_b = hash(&item);\n+            assert_ne!(\n+                hash_a,\n+                hash_b,\n+                \"The hash stayed the same after values were swapped for type `{}`!\",\n+                stringify!($ty)\n+            );\n+        }};\n+    }\n+\n+    test_type!(u16);\n+    test_type!(u32);\n+    test_type!(u64);\n+    test_type!(u128);\n+\n+    test_type!(i16);\n+    test_type!(i32);\n+    test_type!(i64);\n+    test_type!(i128);\n+}"}, {"sha": "fc7f01f041d34cbb14065600e3a34bfeaea00fa1", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -625,7 +625,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ),\n     rustc_attr!(\n         rustc_pass_by_value, Normal,\n-        template!(Word), WarnFollowing,\n+        template!(Word), ErrorFollowing,\n         \"#[rustc_pass_by_value] is used to mark types that must be passed by value instead of reference.\"\n     ),\n     BuiltinAttribute {"}, {"sha": "a47ebaf1237a1ec611a12dc642a13faef5414fc6", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -571,7 +571,7 @@ impl<'a> State<'a> {\n                 self.ann.nested(self, Nested::Body(body));\n             }\n             hir::ItemKind::Macro(ref macro_def) => {\n-                self.print_mac_def(macro_def, &item.ident, &item.span, |state| {\n+                self.print_mac_def(macro_def, &item.ident, item.span, |state| {\n                     state.print_visibility(&item.vis)\n                 });\n             }"}, {"sha": "d8e1162890c609418efa900a76a78384f8e43467", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -108,7 +108,7 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n                                     lint.build(&format!(\"usage of qualified `ty::{}`\", t))\n                                         .span_suggestion(\n                                             path.span,\n-                                            \"try using it unqualified\",\n+                                            \"try importing it and using it unqualified\",\n                                             t,\n                                             // The import probably needs to be changed\n                                             Applicability::MaybeIncorrect,"}, {"sha": "6bf25732f6035fc485044dfb840fd339accfbe8a", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -336,5 +336,5 @@ fn is_arg_inside_call(arg: Span, call: Span) -> bool {\n     // panic call in the source file, to avoid invalid suggestions when macros are involved.\n     // We specifically check for the spans to not be identical, as that happens sometimes when\n     // proc_macros lie about spans and apply the same span to all the tokens they produce.\n-    call.contains(arg) && !call.source_equal(&arg)\n+    call.contains(arg) && !call.source_equal(arg)\n }"}, {"sha": "2caf929788f182f6efbc873525aa92a7824633fc", "filename": "compiler/rustc_lint/src/pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -76,10 +76,10 @@ fn gen_args(cx: &LateContext<'_>, segment: &PathSegment<'_>) -> String {\n             .map(|arg| match arg {\n                 GenericArg::Lifetime(lt) => lt.name.ident().to_string(),\n                 GenericArg::Type(ty) => {\n-                    cx.tcx.sess.source_map().span_to_snippet(ty.span).unwrap_or_default()\n+                    cx.tcx.sess.source_map().span_to_snippet(ty.span).unwrap_or_else(|_| \"_\".into())\n                 }\n                 GenericArg::Const(c) => {\n-                    cx.tcx.sess.source_map().span_to_snippet(c.span).unwrap_or_default()\n+                    cx.tcx.sess.source_map().span_to_snippet(c.span).unwrap_or_else(|_| \"_\".into())\n                 }\n                 GenericArg::Infer(_) => String::from(\"_\"),\n             })"}, {"sha": "965d30a7b92c9121dfd13f43695f1b6d91c0c4df", "filename": "compiler/rustc_middle/src/mir/spanview.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -230,7 +230,7 @@ where\n }\n \n /// Format a string showing the start line and column, and end line and column within a file.\n-pub fn source_range_no_file<'tcx>(tcx: TyCtxt<'tcx>, span: &Span) -> String {\n+pub fn source_range_no_file<'tcx>(tcx: TyCtxt<'tcx>, span: Span) -> String {\n     let source_map = tcx.sess.source_map();\n     let start = source_map.lookup_char_pos(span.lo());\n     let end = source_map.lookup_char_pos(span.hi());\n@@ -629,7 +629,7 @@ fn tooltip<'tcx>(\n     let mut text = Vec::new();\n     text.push(format!(\"{}: {}:\", spanview_id, &source_map.span_to_embeddable_string(span)));\n     for statement in statements {\n-        let source_range = source_range_no_file(tcx, &statement.source_info.span);\n+        let source_range = source_range_no_file(tcx, statement.source_info.span);\n         text.push(format!(\n             \"\\n{}{}: {}: {:?}\",\n             TOOLTIP_INDENT,\n@@ -639,7 +639,7 @@ fn tooltip<'tcx>(\n         ));\n     }\n     if let Some(term) = terminator {\n-        let source_range = source_range_no_file(tcx, &term.source_info.span);\n+        let source_range = source_range_no_file(tcx, term.source_info.span);\n         text.push(format!(\n             \"\\n{}{}: {}: {:?}\",\n             TOOLTIP_INDENT,"}, {"sha": "d1cb2826dedfcffb90990613206039496703b06b", "filename": "compiler/rustc_mir_transform/src/coverage/spans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -28,7 +28,7 @@ impl CoverageStatement {\n                 let stmt = &mir_body[bb].statements[stmt_index];\n                 format!(\n                     \"{}: @{}[{}]: {:?}\",\n-                    source_range_no_file(tcx, &span),\n+                    source_range_no_file(tcx, span),\n                     bb.index(),\n                     stmt_index,\n                     stmt\n@@ -38,7 +38,7 @@ impl CoverageStatement {\n                 let term = mir_body[bb].terminator();\n                 format!(\n                     \"{}: @{}.{}: {:?}\",\n-                    source_range_no_file(tcx, &span),\n+                    source_range_no_file(tcx, span),\n                     bb.index(),\n                     term_type(&term.kind),\n                     term.kind\n@@ -155,7 +155,7 @@ impl CoverageSpan {\n     pub fn format<'tcx>(&self, tcx: TyCtxt<'tcx>, mir_body: &mir::Body<'tcx>) -> String {\n         format!(\n             \"{}\\n    {}\",\n-            source_range_no_file(tcx, &self.span),\n+            source_range_no_file(tcx, self.span),\n             self.format_coverage_statements(tcx, mir_body).replace('\\n', \"\\n    \"),\n         )\n     }"}, {"sha": "06849b3125683b5a13ddf1098c8b0df42f7fc6dd", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -423,7 +423,7 @@ impl<'a> Parser<'a> {\n                 // Maybe the user misspelled `macro_rules` (issue #91227)\n                 if self.token.is_ident()\n                     && path.segments.len() == 1\n-                    && lev_distance(\"macro_rules\", &path.segments[0].ident.to_string()) <= 3\n+                    && lev_distance(\"macro_rules\", &path.segments[0].ident.to_string(), 3).is_some()\n                 {\n                     err.span_suggestion(\n                         path.span,"}, {"sha": "93cf965f1056be7b1e95415e4d2d16592f73fd9b", "filename": "compiler/rustc_span/src/lev_distance.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_span%2Fsrc%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_span%2Fsrc%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flev_distance.rs?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -11,16 +11,21 @@ use std::cmp;\n mod tests;\n \n /// Finds the Levenshtein distance between two strings.\n-pub fn lev_distance(a: &str, b: &str) -> usize {\n-    // cases which don't require further computation\n-    if a.is_empty() {\n-        return b.chars().count();\n-    } else if b.is_empty() {\n-        return a.chars().count();\n+///\n+/// Returns None if the distance exceeds the limit.\n+pub fn lev_distance(a: &str, b: &str, limit: usize) -> Option<usize> {\n+    let n = a.chars().count();\n+    let m = b.chars().count();\n+    let min_dist = if n < m { m - n } else { n - m };\n+\n+    if min_dist > limit {\n+        return None;\n+    }\n+    if n == 0 || m == 0 {\n+        return (min_dist <= limit).then_some(min_dist);\n     }\n \n-    let mut dcol: Vec<_> = (0..=b.len()).collect();\n-    let mut t_last = 0;\n+    let mut dcol: Vec<_> = (0..=m).collect();\n \n     for (i, sc) in a.chars().enumerate() {\n         let mut current = i;\n@@ -35,10 +40,10 @@ pub fn lev_distance(a: &str, b: &str) -> usize {\n                 dcol[j + 1] = cmp::min(dcol[j + 1], dcol[j]) + 1;\n             }\n             current = next;\n-            t_last = j;\n         }\n     }\n-    dcol[t_last + 1]\n+\n+    (dcol[m] <= limit).then_some(dcol[m])\n }\n \n /// Finds the best match for a given word in the given iterator.\n@@ -51,39 +56,38 @@ pub fn lev_distance(a: &str, b: &str) -> usize {\n /// on an edge case with a lower(upper)case letters mismatch.\n #[cold]\n pub fn find_best_match_for_name(\n-    name_vec: &[Symbol],\n+    candidates: &[Symbol],\n     lookup: Symbol,\n     dist: Option<usize>,\n ) -> Option<Symbol> {\n     let lookup = lookup.as_str();\n-    let max_dist = dist.unwrap_or_else(|| cmp::max(lookup.len(), 3) / 3);\n+    let lookup_uppercase = lookup.to_uppercase();\n \n     // Priority of matches:\n     // 1. Exact case insensitive match\n     // 2. Levenshtein distance match\n     // 3. Sorted word match\n-    if let Some(case_insensitive_match) =\n-        name_vec.iter().find(|candidate| candidate.as_str().to_uppercase() == lookup.to_uppercase())\n-    {\n-        return Some(*case_insensitive_match);\n+    if let Some(c) = candidates.iter().find(|c| c.as_str().to_uppercase() == lookup_uppercase) {\n+        return Some(*c);\n     }\n-    let levenshtein_match = name_vec\n-        .iter()\n-        .filter_map(|&name| {\n-            let dist = lev_distance(lookup, name.as_str());\n-            if dist <= max_dist { Some((name, dist)) } else { None }\n-        })\n-        // Here we are collecting the next structure:\n-        // (levenshtein_match, levenshtein_distance)\n-        .fold(None, |result, (candidate, dist)| match result {\n-            None => Some((candidate, dist)),\n-            Some((c, d)) => Some(if dist < d { (candidate, dist) } else { (c, d) }),\n-        });\n-    if levenshtein_match.is_some() {\n-        levenshtein_match.map(|(candidate, _)| candidate)\n-    } else {\n-        find_match_by_sorted_words(name_vec, lookup)\n+\n+    let mut dist = dist.unwrap_or_else(|| cmp::max(lookup.len(), 3) / 3);\n+    let mut best = None;\n+    for c in candidates {\n+        match lev_distance(lookup, c.as_str(), dist) {\n+            Some(0) => return Some(*c),\n+            Some(d) => {\n+                dist = d - 1;\n+                best = Some(*c);\n+            }\n+            None => {}\n+        }\n     }\n+    if best.is_some() {\n+        return best;\n+    }\n+\n+    find_match_by_sorted_words(candidates, lookup)\n }\n \n fn find_match_by_sorted_words(iter_names: &[Symbol], lookup: &str) -> Option<Symbol> {"}, {"sha": "4e34219248d413bbc62e1364c211ca17d8c8ffbf", "filename": "compiler/rustc_span/src/lev_distance/tests.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_span%2Fsrc%2Flev_distance%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_span%2Fsrc%2Flev_distance%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flev_distance%2Ftests.rs?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -5,18 +5,26 @@ fn test_lev_distance() {\n     use std::char::{from_u32, MAX};\n     // Test bytelength agnosticity\n     for c in (0..MAX as u32).filter_map(from_u32).map(|i| i.to_string()) {\n-        assert_eq!(lev_distance(&c[..], &c[..]), 0);\n+        assert_eq!(lev_distance(&c[..], &c[..], usize::MAX), Some(0));\n     }\n \n     let a = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n     let b = \"\\nMary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n     let c = \"Mary h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n-    assert_eq!(lev_distance(a, b), 1);\n-    assert_eq!(lev_distance(b, a), 1);\n-    assert_eq!(lev_distance(a, c), 2);\n-    assert_eq!(lev_distance(c, a), 2);\n-    assert_eq!(lev_distance(b, c), 1);\n-    assert_eq!(lev_distance(c, b), 1);\n+    assert_eq!(lev_distance(a, b, usize::MAX), Some(1));\n+    assert_eq!(lev_distance(b, a, usize::MAX), Some(1));\n+    assert_eq!(lev_distance(a, c, usize::MAX), Some(2));\n+    assert_eq!(lev_distance(c, a, usize::MAX), Some(2));\n+    assert_eq!(lev_distance(b, c, usize::MAX), Some(1));\n+    assert_eq!(lev_distance(c, b, usize::MAX), Some(1));\n+}\n+\n+#[test]\n+fn test_lev_distance_limit() {\n+    assert_eq!(lev_distance(\"abc\", \"abcd\", 1), Some(1));\n+    assert_eq!(lev_distance(\"abc\", \"abcd\", 0), None);\n+    assert_eq!(lev_distance(\"abc\", \"xyz\", 3), Some(3));\n+    assert_eq!(lev_distance(\"abc\", \"xyz\", 2), None);\n }\n \n #[test]"}, {"sha": "2c3db35bb66cb34b170623265b09019f6d5999d3", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -15,6 +15,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(array_windows)]\n+#![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n #![feature(if_let_guard)]\n #![feature(negative_impls)]\n@@ -611,7 +612,7 @@ impl Span {\n \n     #[inline]\n     /// Returns `true` if `hi == lo`.\n-    pub fn is_empty(&self) -> bool {\n+    pub fn is_empty(self) -> bool {\n         let span = self.data_untracked();\n         span.hi == span.lo\n     }\n@@ -639,7 +640,7 @@ impl Span {\n     ///\n     /// Use this instead of `==` when either span could be generated code,\n     /// and you only care that they point to the same bytes of source text.\n-    pub fn source_equal(&self, other: &Span) -> bool {\n+    pub fn source_equal(self, other: Span) -> bool {\n         let span = self.data();\n         let other = other.data();\n         span.lo == other.lo && span.hi == other.hi\n@@ -680,17 +681,17 @@ impl Span {\n     }\n \n     #[inline]\n-    pub fn rust_2015(&self) -> bool {\n+    pub fn rust_2015(self) -> bool {\n         self.edition() == edition::Edition::Edition2015\n     }\n \n     #[inline]\n-    pub fn rust_2018(&self) -> bool {\n+    pub fn rust_2018(self) -> bool {\n         self.edition() >= edition::Edition::Edition2018\n     }\n \n     #[inline]\n-    pub fn rust_2021(&self) -> bool {\n+    pub fn rust_2021(self) -> bool {\n         self.edition() >= edition::Edition::Edition2021\n     }\n \n@@ -711,15 +712,15 @@ impl Span {\n     /// Checks if a span is \"internal\" to a macro in which `#[unstable]`\n     /// items can be used (that is, a macro marked with\n     /// `#[allow_internal_unstable]`).\n-    pub fn allows_unstable(&self, feature: Symbol) -> bool {\n+    pub fn allows_unstable(self, feature: Symbol) -> bool {\n         self.ctxt()\n             .outer_expn_data()\n             .allow_internal_unstable\n             .map_or(false, |features| features.iter().any(|&f| f == feature))\n     }\n \n     /// Checks if this span arises from a compiler desugaring of kind `kind`.\n-    pub fn is_desugaring(&self, kind: DesugaringKind) -> bool {\n+    pub fn is_desugaring(self, kind: DesugaringKind) -> bool {\n         match self.ctxt().outer_expn_data().kind {\n             ExpnKind::Desugaring(k) => k == kind,\n             _ => false,\n@@ -728,7 +729,7 @@ impl Span {\n \n     /// Returns the compiler desugaring that created this span, or `None`\n     /// if this span is not from a desugaring.\n-    pub fn desugaring_kind(&self) -> Option<DesugaringKind> {\n+    pub fn desugaring_kind(self) -> Option<DesugaringKind> {\n         match self.ctxt().outer_expn_data().kind {\n             ExpnKind::Desugaring(k) => Some(k),\n             _ => None,\n@@ -738,7 +739,7 @@ impl Span {\n     /// Checks if a span is \"internal\" to a macro in which `unsafe`\n     /// can be used without triggering the `unsafe_code` lint.\n     //  (that is, a macro marked with `#[allow_internal_unsafe]`).\n-    pub fn allows_unsafe(&self) -> bool {\n+    pub fn allows_unsafe(self) -> bool {\n         self.ctxt().outer_expn_data().allow_internal_unsafe\n     }\n \n@@ -751,7 +752,7 @@ impl Span {\n                     return None;\n                 }\n \n-                let is_recursive = expn_data.call_site.source_equal(&prev_span);\n+                let is_recursive = expn_data.call_site.source_equal(prev_span);\n \n                 prev_span = self;\n                 self = expn_data.call_site;\n@@ -865,13 +866,13 @@ impl Span {\n \n     /// Equivalent of `Span::call_site` from the proc macro API,\n     /// except that the location is taken from the `self` span.\n-    pub fn with_call_site_ctxt(&self, expn_id: ExpnId) -> Span {\n+    pub fn with_call_site_ctxt(self, expn_id: ExpnId) -> Span {\n         self.with_ctxt_from_mark(expn_id, Transparency::Transparent)\n     }\n \n     /// Equivalent of `Span::mixed_site` from the proc macro API,\n     /// except that the location is taken from the `self` span.\n-    pub fn with_mixed_site_ctxt(&self, expn_id: ExpnId) -> Span {\n+    pub fn with_mixed_site_ctxt(self, expn_id: ExpnId) -> Span {\n         self.with_ctxt_from_mark(expn_id, Transparency::SemiTransparent)\n     }\n "}, {"sha": "61e4074a7c80bf1cf9d846df96bccb2a9f91000c", "filename": "compiler/rustc_span/src/span_encoding.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_span%2Fsrc%2Fspan_encoding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_span%2Fsrc%2Fspan_encoding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fspan_encoding.rs?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -61,6 +61,15 @@ use rustc_data_structures::fx::FxIndexSet;\n /// using the callback `SPAN_TRACK` to access the query engine.\n ///\n #[derive(Clone, Copy, Eq, PartialEq, Hash)]\n+// FIXME(@lcnr): Enable this attribute once the bootstrap\n+// compiler knows of `rustc_pass_by_value`.\n+//\n+// Right now, this lint would only trigger when compiling the\n+// stage 2 compiler, which is fairly annoying as there are\n+// a lot of places using `&Span` right now. After the next bootstrap bump,\n+// the lint will already trigger when using stage 1, which is a lot less annoying.\n+//\n+// #[cfg_attr(not(bootstrap), rustc_pass_by_value)]\n pub struct Span {\n     base_or_index: u32,\n     len_or_tag: u16,"}, {"sha": "3815fd1992bf318b6806873052bfc84a554df097", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -1904,8 +1904,13 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     .associated_items(def_id)\n                     .in_definition_order()\n                     .filter(|x| {\n-                        let dist = lev_distance(name.as_str(), x.name.as_str());\n-                        x.kind.namespace() == Namespace::ValueNS && dist > 0 && dist <= max_dist\n+                        if x.kind.namespace() != Namespace::ValueNS {\n+                            return false;\n+                        }\n+                        match lev_distance(name.as_str(), x.name.as_str(), max_dist) {\n+                            Some(d) => d > 0,\n+                            None => false,\n+                        }\n                     })\n                     .copied()\n                     .collect()"}, {"sha": "65cadcb6c5a4f2aa79392907647875cf7bfb7568", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -515,8 +515,44 @@ pub trait Iterator {\n     /// assert_eq!((2, 'o'), zipper[2]);\n     /// ```\n     ///\n+    /// If both iterators have roughly equivalent syntax, it may me more readable to use [`zip`]:\n+    ///\n+    /// ```\n+    /// use std::iter::zip;\n+    ///\n+    /// let a = [1, 2, 3];\n+    /// let b = [2, 3, 4];\n+    ///\n+    /// let mut zipped = zip(\n+    ///     a.into_iter().map(|x| x * 2).skip(1),\n+    ///     b.into_iter().map(|x| x * 2).skip(1),\n+    /// );\n+    ///\n+    /// assert_eq!(zipped.next(), Some((4, 6)));\n+    /// assert_eq!(zipped.next(), Some((6, 8)));\n+    /// assert_eq!(zipped.next(), None);\n+    /// ```\n+    ///\n+    /// compared to:\n+    ///\n+    /// ```\n+    /// # let a = [1, 2, 3];\n+    /// # let b = [2, 3, 4];\n+    /// #\n+    /// let mut zipped = a\n+    ///     .into_iter()\n+    ///     .map(|x| x * 2)\n+    ///     .skip(1)\n+    ///     .zip(b.into_iter().map(|x| x * 2).skip(1));\n+    /// #\n+    /// # assert_eq!(zipped.next(), Some((4, 6)));\n+    /// # assert_eq!(zipped.next(), Some((6, 8)));\n+    /// # assert_eq!(zipped.next(), None);\n+    /// ```\n+    ///\n     /// [`enumerate`]: Iterator::enumerate\n     /// [`next`]: Iterator::next\n+    /// [`zip`]: crate::iter::zip\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn zip<U>(self, other: U) -> Zip<Self, U::IntoIter>"}, {"sha": "b6d5199341c7db7739874300b8fa8a45cc4fa7e4", "filename": "library/std/src/os/raw/mod.rs", "status": "modified", "additions": 62, "deletions": 88, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fmod.rs?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -45,94 +45,13 @@ macro_rules! type_alias {\n     }\n }\n \n-type_alias! { \"char.md\", c_char = u8, NonZero_c_char = NonZeroU8;\n-#[doc(cfg(all()))]\n-#[cfg(any(\n-    all(\n-        target_os = \"linux\",\n-        any(\n-            target_arch = \"aarch64\",\n-            target_arch = \"arm\",\n-            target_arch = \"hexagon\",\n-            target_arch = \"powerpc\",\n-            target_arch = \"powerpc64\",\n-            target_arch = \"s390x\",\n-            target_arch = \"riscv64\",\n-            target_arch = \"riscv32\"\n-        )\n-    ),\n-    all(target_os = \"android\", any(target_arch = \"aarch64\", target_arch = \"arm\")),\n-    all(target_os = \"l4re\", target_arch = \"x86_64\"),\n-    all(\n-        target_os = \"freebsd\",\n-        any(\n-            target_arch = \"aarch64\",\n-            target_arch = \"arm\",\n-            target_arch = \"powerpc\",\n-            target_arch = \"powerpc64\",\n-            target_arch = \"riscv64\"\n-        )\n-    ),\n-    all(\n-        target_os = \"netbsd\",\n-        any(target_arch = \"aarch64\", target_arch = \"arm\", target_arch = \"powerpc\")\n-    ),\n-    all(target_os = \"openbsd\", target_arch = \"aarch64\"),\n-    all(\n-        target_os = \"vxworks\",\n-        any(\n-            target_arch = \"aarch64\",\n-            target_arch = \"arm\",\n-            target_arch = \"powerpc64\",\n-            target_arch = \"powerpc\"\n-        )\n-    ),\n-    all(target_os = \"fuchsia\", target_arch = \"aarch64\")\n-))]}\n-type_alias! { \"char.md\", c_char = i8, NonZero_c_char = NonZeroI8;\n-#[doc(cfg(all()))]\n-#[cfg(not(any(\n-    all(\n-        target_os = \"linux\",\n-        any(\n-            target_arch = \"aarch64\",\n-            target_arch = \"arm\",\n-            target_arch = \"hexagon\",\n-            target_arch = \"powerpc\",\n-            target_arch = \"powerpc64\",\n-            target_arch = \"s390x\",\n-            target_arch = \"riscv64\",\n-            target_arch = \"riscv32\"\n-        )\n-    ),\n-    all(target_os = \"android\", any(target_arch = \"aarch64\", target_arch = \"arm\")),\n-    all(target_os = \"l4re\", target_arch = \"x86_64\"),\n-    all(\n-        target_os = \"freebsd\",\n-        any(\n-            target_arch = \"aarch64\",\n-            target_arch = \"arm\",\n-            target_arch = \"powerpc\",\n-            target_arch = \"powerpc64\",\n-            target_arch = \"riscv64\"\n-        )\n-    ),\n-    all(\n-        target_os = \"netbsd\",\n-        any(target_arch = \"aarch64\", target_arch = \"arm\", target_arch = \"powerpc\")\n-    ),\n-    all(target_os = \"openbsd\", target_arch = \"aarch64\"),\n-    all(\n-        target_os = \"vxworks\",\n-        any(\n-            target_arch = \"aarch64\",\n-            target_arch = \"arm\",\n-            target_arch = \"powerpc64\",\n-            target_arch = \"powerpc\"\n-        )\n-    ),\n-    all(target_os = \"fuchsia\", target_arch = \"aarch64\")\n-)))]}\n+type_alias! { \"char.md\", c_char = c_char_definition::c_char, NonZero_c_char = c_char_definition::NonZero_c_char;\n+// Make this type alias appear cfg-dependent so that Clippy does not suggest\n+// replacing `0 as c_char` with `0_i8`/`0_u8`. This #[cfg(all())] can be removed\n+// after the false positive in https://github.com/rust-lang/rust-clippy/issues/8093\n+// is fixed.\n+#[cfg(all())]\n+#[doc(cfg(all()))] }\n type_alias! { \"schar.md\", c_schar = i8, NonZero_c_schar = NonZeroI8; }\n type_alias! { \"uchar.md\", c_uchar = u8, NonZero_c_uchar = NonZeroU8; }\n type_alias! { \"short.md\", c_short = i16, NonZero_c_short = NonZeroI16; }\n@@ -180,3 +99,58 @@ pub type c_ptrdiff_t = isize;\n /// platforms where this is not the case.\n #[unstable(feature = \"c_size_t\", issue = \"88345\")]\n pub type c_ssize_t = isize;\n+\n+mod c_char_definition {\n+    cfg_if::cfg_if! {\n+        // These are the targets on which c_char is unsigned.\n+        if #[cfg(any(\n+            all(\n+                target_os = \"linux\",\n+                any(\n+                    target_arch = \"aarch64\",\n+                    target_arch = \"arm\",\n+                    target_arch = \"hexagon\",\n+                    target_arch = \"powerpc\",\n+                    target_arch = \"powerpc64\",\n+                    target_arch = \"s390x\",\n+                    target_arch = \"riscv64\",\n+                    target_arch = \"riscv32\"\n+                )\n+            ),\n+            all(target_os = \"android\", any(target_arch = \"aarch64\", target_arch = \"arm\")),\n+            all(target_os = \"l4re\", target_arch = \"x86_64\"),\n+            all(\n+                target_os = \"freebsd\",\n+                any(\n+                    target_arch = \"aarch64\",\n+                    target_arch = \"arm\",\n+                    target_arch = \"powerpc\",\n+                    target_arch = \"powerpc64\",\n+                    target_arch = \"riscv64\"\n+                )\n+            ),\n+            all(\n+                target_os = \"netbsd\",\n+                any(target_arch = \"aarch64\", target_arch = \"arm\", target_arch = \"powerpc\")\n+            ),\n+            all(target_os = \"openbsd\", target_arch = \"aarch64\"),\n+            all(\n+                target_os = \"vxworks\",\n+                any(\n+                    target_arch = \"aarch64\",\n+                    target_arch = \"arm\",\n+                    target_arch = \"powerpc64\",\n+                    target_arch = \"powerpc\"\n+                )\n+            ),\n+            all(target_os = \"fuchsia\", target_arch = \"aarch64\")\n+        ))] {\n+            pub type c_char = u8;\n+            pub type NonZero_c_char = core::num::NonZeroU8;\n+        } else {\n+            // On every other target, c_char is signed.\n+            pub type c_char = i8;\n+            pub type NonZero_c_char = core::num::NonZeroI8;\n+        }\n+    }\n+}"}, {"sha": "e7fcea876c85c4e515eb843f518b707b186525bc", "filename": "src/test/rustdoc-js/generics-multi-trait.js", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/src%2Ftest%2Frustdoc-js%2Fgenerics-multi-trait.js", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/src%2Ftest%2Frustdoc-js%2Fgenerics-multi-trait.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fgenerics-multi-trait.js?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -0,0 +1,32 @@\n+// exact-check\n+\n+const QUERY = [\n+    'Result<SomeTrait>',\n+    'Zzzzzzzzzzzzzzzzzz',\n+    'Nonononononononono',\n+];\n+\n+const EXPECTED = [\n+    // check one of the generic items\n+    {\n+        'in_args': [\n+            { 'path': 'generics_multi_trait', 'name': 'beta' },\n+        ],\n+        'returned': [\n+            { 'path': 'generics_multi_trait', 'name': 'bet' },\n+        ],\n+    },\n+    {\n+        'in_args': [\n+            { 'path': 'generics_multi_trait', 'name': 'beta' },\n+        ],\n+        'returned': [\n+            { 'path': 'generics_multi_trait', 'name': 'bet' },\n+        ],\n+    },\n+    // ignore the name of the generic itself\n+    {\n+        'in_args': [],\n+        'returned': [],\n+    },\n+];"}, {"sha": "e6fd06d254ccd792471cc9605e941834d0d33748", "filename": "src/test/rustdoc-js/generics-multi-trait.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/src%2Ftest%2Frustdoc-js%2Fgenerics-multi-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/src%2Ftest%2Frustdoc-js%2Fgenerics-multi-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fgenerics-multi-trait.rs?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -0,0 +1,12 @@\n+pub trait SomeTrait {}\n+pub trait Zzzzzzzzzzzzzzzzzz {}\n+\n+pub fn bet<Nonononononononono: SomeTrait + Zzzzzzzzzzzzzzzzzz>() -> Result<Nonononononononono, ()> {\n+    loop {}\n+}\n+\n+pub fn beta<Nonononononononono: SomeTrait + Zzzzzzzzzzzzzzzzzz>(\n+    _param: Result<Nonononononononono, ()>,\n+) {\n+    loop {}\n+}"}, {"sha": "a1056cf85d307d7efa558cda3ab8d5153391cb59", "filename": "src/test/ui-fulldeps/internal-lints/qualified_ty_ty_ctxt.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1b4109306c1d98a8e993ec2c748d286927dddbf5/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fqualified_ty_ty_ctxt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1b4109306c1d98a8e993ec2c748d286927dddbf5/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fqualified_ty_ty_ctxt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fqualified_ty_ty_ctxt.stderr?ref=1b4109306c1d98a8e993ec2c748d286927dddbf5", "patch": "@@ -2,7 +2,7 @@ error: usage of qualified `ty::Ty<'_>`\n   --> $DIR/qualified_ty_ty_ctxt.rs:25:11\n    |\n LL |     ty_q: ty::Ty<'_>,\n-   |           ^^^^^^^^^^ help: try using it unqualified: `Ty<'_>`\n+   |           ^^^^^^^^^^ help: try importing it and using it unqualified: `Ty<'_>`\n    |\n note: the lint level is defined here\n   --> $DIR/qualified_ty_ty_ctxt.rs:4:9\n@@ -14,7 +14,7 @@ error: usage of qualified `ty::TyCtxt<'_>`\n   --> $DIR/qualified_ty_ty_ctxt.rs:27:16\n    |\n LL |     ty_ctxt_q: ty::TyCtxt<'_>,\n-   |                ^^^^^^^^^^^^^^ help: try using it unqualified: `TyCtxt<'_>`\n+   |                ^^^^^^^^^^^^^^ help: try importing it and using it unqualified: `TyCtxt<'_>`\n \n error: aborting due to 2 previous errors\n "}]}