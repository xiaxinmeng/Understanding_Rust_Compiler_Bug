{"sha": "1465cc0c4feb52958d3281f066a663e0a52ed67e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0NjVjYzBjNGZlYjUyOTU4ZDMyODFmMDY2YTY2M2UwYTUyZWQ2N2U=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-03-02T06:05:15Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-03-03T17:21:14Z"}, "message": "Implement concat macro", "tree": {"sha": "933d006064847260d5ec0d816fef5a381e674f90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/933d006064847260d5ec0d816fef5a381e674f90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1465cc0c4feb52958d3281f066a663e0a52ed67e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1465cc0c4feb52958d3281f066a663e0a52ed67e", "html_url": "https://github.com/rust-lang/rust/commit/1465cc0c4feb52958d3281f066a663e0a52ed67e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1465cc0c4feb52958d3281f066a663e0a52ed67e/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d554540730925c074693b43503e65476eadbd65", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d554540730925c074693b43503e65476eadbd65", "html_url": "https://github.com/rust-lang/rust/commit/0d554540730925c074693b43503e65476eadbd65"}], "stats": {"total": 382, "additions": 305, "deletions": 77}, "files": [{"sha": "a3d617e1f0d35d3d5e59b1bc9316987602d0d574", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1465cc0c4feb52958d3281f066a663e0a52ed67e/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1465cc0c4feb52958d3281f066a663e0a52ed67e/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=1465cc0c4feb52958d3281f066a663e0a52ed67e", "patch": "@@ -47,8 +47,8 @@ mod marks;\n use std::hash::Hash;\n \n use hir_expand::{\n-    ast_id_map::FileAstId, db::AstDatabase, hygiene::Hygiene, AstId, HirFileId, InFile,\n-    MacroCallId, MacroCallKind, MacroDefId,\n+    ast_id_map::FileAstId, db::AstDatabase, eager::expand_eager_macro, hygiene::Hygiene, AstId,\n+    HirFileId, InFile, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n };\n use ra_arena::{impl_arena_id, RawId};\n use ra_db::{impl_intern_key, salsa, CrateId};\n@@ -459,8 +459,21 @@ impl AsMacroCall for AstIdWithPath<ast::MacroCall> {\n         db: &impl AstDatabase,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n     ) -> Option<MacroCallId> {\n-        let def = resolver(self.path.clone())?;\n-        Some(def.as_call_id(db, MacroCallKind::FnLike(self.ast_id)))\n+        let def: MacroDefId = resolver(self.path.clone())?;\n+\n+        if let MacroDefKind::BuiltInEager(_) = def.kind {\n+            let macro_call = InFile::new(self.ast_id.file_id, self.ast_id.to_node(db));\n+            let hygiene = Hygiene::new(db, self.ast_id.file_id);\n+\n+            Some(\n+                expand_eager_macro(db, macro_call, def, &|path: ast::Path| {\n+                    resolver(path::ModPath::from_src(path, &hygiene)?)\n+                })?\n+                .into(),\n+            )\n+        } else {\n+            Some(def.as_lazy_macro(db, MacroCallKind::FnLike(self.ast_id)).into())\n+        }\n     }\n }\n \n@@ -471,6 +484,6 @@ impl AsMacroCall for AstIdWithPath<ast::ModuleItem> {\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n     ) -> Option<MacroCallId> {\n         let def = resolver(self.path.clone())?;\n-        Some(def.as_call_id(db, MacroCallKind::Attr(self.ast_id)))\n+        Some(def.as_lazy_macro(db, MacroCallKind::Attr(self.ast_id)).into())\n     }\n }"}, {"sha": "87224481ce6d2c9bd2597041cec21d6ec80c039d", "filename": "crates/ra_hir_expand/src/builtin_derive.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1465cc0c4feb52958d3281f066a663e0a52ed67e/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1465cc0c4feb52958d3281f066a663e0a52ed67e/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_derive.rs?ref=1465cc0c4feb52958d3281f066a663e0a52ed67e", "patch": "@@ -9,7 +9,7 @@ use ra_syntax::{\n };\n \n use crate::db::AstDatabase;\n-use crate::{name, quote, MacroCallId, MacroDefId, MacroDefKind};\n+use crate::{name, quote, LazyMacroId, MacroDefId, MacroDefKind};\n \n macro_rules! register_builtin {\n     ( $($trait:ident => $expand:ident),* ) => {\n@@ -22,7 +22,7 @@ macro_rules! register_builtin {\n             pub fn expand(\n                 &self,\n                 db: &dyn AstDatabase,\n-                id: MacroCallId,\n+                id: LazyMacroId,\n                 tt: &tt::Subtree,\n             ) -> Result<tt::Subtree, mbe::ExpandError> {\n                 let expander = match *self {\n@@ -155,71 +155,71 @@ fn expand_simple_derive(\n \n fn copy_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     expand_simple_derive(tt, quote! { std::marker::Copy })\n }\n \n fn clone_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     expand_simple_derive(tt, quote! { std::clone::Clone })\n }\n \n fn default_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     expand_simple_derive(tt, quote! { std::default::Default })\n }\n \n fn debug_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     expand_simple_derive(tt, quote! { std::fmt::Debug })\n }\n \n fn hash_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     expand_simple_derive(tt, quote! { std::hash::Hash })\n }\n \n fn eq_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     expand_simple_derive(tt, quote! { std::cmp::Eq })\n }\n \n fn partial_eq_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     expand_simple_derive(tt, quote! { std::cmp::PartialEq })\n }\n \n fn ord_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     expand_simple_derive(tt, quote! { std::cmp::Ord })\n }\n \n fn partial_ord_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     expand_simple_derive(tt, quote! { std::cmp::PartialOrd })\n@@ -228,7 +228,7 @@ fn partial_ord_expand(\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::{test_db::TestDB, AstId, MacroCallKind, MacroCallLoc};\n+    use crate::{test_db::TestDB, AstId, MacroCallId, MacroCallKind, MacroCallLoc};\n     use ra_db::{fixture::WithFixture, SourceDatabase};\n \n     fn expand_builtin_derive(s: &str, expander: BuiltinDeriveExpander) -> String {"}, {"sha": "1f380b5716c3c0b34684341ec9496777541e9ff2", "filename": "crates/ra_hir_expand/src/builtin_macro.rs", "status": "modified", "additions": 90, "deletions": 36, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/1465cc0c4feb52958d3281f066a663e0a52ed67e/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1465cc0c4feb52958d3281f066a663e0a52ed67e/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs?ref=1465cc0c4feb52958d3281f066a663e0a52ed67e", "patch": "@@ -1,53 +1,86 @@\n //! Builtin macro\n use crate::db::AstDatabase;\n use crate::{\n-    ast::{self},\n-    name, AstId, CrateId, MacroCallId, MacroDefId, MacroDefKind, TextUnit,\n+    ast::{self, AstToken, HasStringValue},\n+    name, AstId, CrateId, MacroDefId, MacroDefKind, TextUnit,\n };\n \n-use crate::quote;\n+use crate::{quote, LazyMacroId};\n+use either::Either;\n+use ra_parser::FragmentKind;\n \n macro_rules! register_builtin {\n-    ( $(($name:ident, $kind: ident) => $expand:ident),* ) => {\n+    ( LAZY: $(($name:ident, $kind: ident) => $expand:ident),* , EAGER: $(($e_name:ident, $e_kind: ident) => $e_expand:ident),*  ) => {\n         #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n         pub enum BuiltinFnLikeExpander {\n             $($kind),*\n         }\n \n+        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+        pub enum EagerExpander {\n+            $($e_kind),*\n+        }\n+\n         impl BuiltinFnLikeExpander {\n             pub fn expand(\n                 &self,\n                 db: &dyn AstDatabase,\n-                id: MacroCallId,\n+                id: LazyMacroId,\n                 tt: &tt::Subtree,\n             ) -> Result<tt::Subtree, mbe::ExpandError> {\n                 let expander = match *self {\n                     $( BuiltinFnLikeExpander::$kind => $expand, )*\n                 };\n                 expander(db, id, tt)\n             }\n+        }\n \n-            fn by_name(ident: &name::Name) -> Option<BuiltinFnLikeExpander> {\n-                match ident {\n-                    $( id if id == &name::name![$name] => Some(BuiltinFnLikeExpander::$kind), )*\n-                    _ => return None,\n-                }\n+        impl EagerExpander {\n+            pub fn expand(\n+                &self,\n+                tt: &tt::Subtree,\n+            ) -> Result<(tt::Subtree, FragmentKind), mbe::ExpandError> {\n+                let expander = match *self {\n+                    $( EagerExpander::$e_kind => $e_expand, )*\n+                };\n+                expander(tt)\n             }\n         }\n \n-        pub fn find_builtin_macro(\n-            ident: &name::Name,\n-            krate: CrateId,\n-            ast_id: AstId<ast::MacroCall>,\n-        ) -> Option<MacroDefId> {\n-            let kind = BuiltinFnLikeExpander::by_name(ident)?;\n-\n-            Some(MacroDefId { krate: Some(krate), ast_id: Some(ast_id), kind: MacroDefKind::BuiltIn(kind) })\n+        fn find_by_name(ident: &name::Name) -> Option<Either<BuiltinFnLikeExpander, EagerExpander>> {\n+            match ident {\n+                $( id if id == &name::name![$name] => Some(Either::Left(BuiltinFnLikeExpander::$kind)), )*\n+                $( id if id == &name::name![$e_name] => Some(Either::Right(EagerExpander::$e_kind)), )*\n+                _ => return None,\n+            }\n         }\n     };\n }\n \n+pub fn find_builtin_macro(\n+    ident: &name::Name,\n+    krate: CrateId,\n+    ast_id: AstId<ast::MacroCall>,\n+) -> Option<MacroDefId> {\n+    let kind = find_by_name(ident)?;\n+\n+    match kind {\n+        Either::Left(kind) => Some(MacroDefId {\n+            krate: Some(krate),\n+            ast_id: Some(ast_id),\n+            kind: MacroDefKind::BuiltIn(kind),\n+        }),\n+        Either::Right(kind) => Some(MacroDefId {\n+            krate: Some(krate),\n+            ast_id: Some(ast_id),\n+            kind: MacroDefKind::BuiltInEager(kind),\n+        }),\n+    }\n+}\n+\n register_builtin! {\n+    LAZY:\n+\n     (column, Column) => column_expand,\n     (compile_error, CompileError) => compile_error_expand,\n     (file, File) => file_expand,\n@@ -58,12 +91,16 @@ register_builtin! {\n     (option_env, OptionEnv) => option_env_expand,\n     // format_args_nl only differs in that it adds a newline in the end,\n     // so we use the same stub expansion for now\n-    (format_args_nl, FormatArgsNl) => format_args_expand\n+    (format_args_nl, FormatArgsNl) => format_args_expand,\n+\n+    EAGER:\n+    // eagers\n+    (concat, Concat) => concat_expand\n }\n \n fn line_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     _tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     // dummy implementation for type-checking purposes\n@@ -77,13 +114,9 @@ fn line_expand(\n \n fn stringify_expand(\n     db: &dyn AstDatabase,\n-    id: MacroCallId,\n+    id: LazyMacroId,\n     _tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n-    let id = match id {\n-        MacroCallId::LazyMacro(id) => id,\n-    };\n-\n     let loc = db.lookup_intern_macro(id);\n \n     let macro_content = {\n@@ -103,7 +136,7 @@ fn stringify_expand(\n \n fn env_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     _tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     // dummy implementation for type-checking purposes\n@@ -114,7 +147,7 @@ fn env_expand(\n \n fn option_env_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     _tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     // dummy implementation for type-checking purposes\n@@ -125,7 +158,7 @@ fn option_env_expand(\n \n fn column_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     _tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     // dummy implementation for type-checking purposes\n@@ -139,7 +172,7 @@ fn column_expand(\n \n fn file_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     _tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     // FIXME: RA purposefully lacks knowledge of absolute file names\n@@ -155,7 +188,7 @@ fn file_expand(\n \n fn compile_error_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     if tt.count() == 1 {\n@@ -172,7 +205,7 @@ fn compile_error_expand(\n \n fn format_args_expand(\n     _db: &dyn AstDatabase,\n-    _id: MacroCallId,\n+    _id: LazyMacroId,\n     tt: &tt::Subtree,\n ) -> Result<tt::Subtree, mbe::ExpandError> {\n     // We expand `format_args!(\"\", a1, a2)` to\n@@ -212,23 +245,44 @@ fn format_args_expand(\n     Ok(expanded)\n }\n \n+fn unquote_str(lit: &tt::Literal) -> Option<String> {\n+    let lit = ast::make::tokens::literal(&lit.to_string());\n+    let token = ast::String::cast(lit)?;\n+    token.value()\n+}\n+\n+fn concat_expand(tt: &tt::Subtree) -> Result<(tt::Subtree, FragmentKind), mbe::ExpandError> {\n+    let mut text = String::new();\n+    for (i, t) in tt.token_trees.iter().enumerate() {\n+        match t {\n+            tt::TokenTree::Leaf(tt::Leaf::Literal(it)) if i % 2 == 0 => {\n+                text += &unquote_str(&it).ok_or_else(|| mbe::ExpandError::ConversionError)?;\n+            }\n+            tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) if i % 2 == 1 && punct.char == ',' => (),\n+            _ => return Err(mbe::ExpandError::UnexpectedToken),\n+        }\n+    }\n+\n+    Ok((quote!(#text), FragmentKind::Expr))\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::{name::AsName, test_db::TestDB, AstNode, MacroCallKind, MacroCallLoc};\n+    use crate::{name::AsName, test_db::TestDB, AstNode, MacroCallId, MacroCallKind, MacroCallLoc};\n     use ra_db::{fixture::WithFixture, SourceDatabase};\n     use ra_syntax::ast::NameOwner;\n \n-    fn expand_builtin_macro(s: &str) -> String {\n-        let (db, file_id) = TestDB::with_single_file(&s);\n+    fn expand_builtin_macro(ra_fixture: &str) -> String {\n+        let (db, file_id) = TestDB::with_single_file(&ra_fixture);\n         let parsed = db.parse(file_id);\n         let macro_calls: Vec<_> =\n             parsed.syntax_node().descendants().filter_map(ast::MacroCall::cast).collect();\n \n         let ast_id_map = db.ast_id_map(file_id.into());\n \n-        let expander =\n-            BuiltinFnLikeExpander::by_name(&macro_calls[0].name().unwrap().as_name()).unwrap();\n+        let expander = find_by_name(&macro_calls[0].name().unwrap().as_name()).unwrap();\n+        let expander = expander.left().unwrap();\n \n         // the first one should be a macro_rules\n         let def = MacroDefId {"}, {"sha": "ac8256a8455a573e389862529bf5994083f9c21d", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1465cc0c4feb52958d3281f066a663e0a52ed67e/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1465cc0c4feb52958d3281f066a663e0a52ed67e/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=1465cc0c4feb52958d3281f066a663e0a52ed67e", "patch": "@@ -9,8 +9,9 @@ use ra_prof::profile;\n use ra_syntax::{AstNode, Parse, SyntaxKind::*, SyntaxNode};\n \n use crate::{\n-    ast_id_map::AstIdMap, BuiltinDeriveExpander, BuiltinFnLikeExpander, HirFileId, HirFileIdRepr,\n-    LazyMacroId, MacroCallId, MacroCallLoc, MacroDefId, MacroDefKind, MacroFile,\n+    ast_id_map::AstIdMap, BuiltinDeriveExpander, BuiltinFnLikeExpander, EagerCallLoc, EagerMacroId,\n+    HirFileId, HirFileIdRepr, LazyMacroId, MacroCallId, MacroCallLoc, MacroDefId, MacroDefKind,\n+    MacroFile,\n };\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n@@ -24,7 +25,7 @@ impl TokenExpander {\n     pub fn expand(\n         &self,\n         db: &dyn AstDatabase,\n-        id: MacroCallId,\n+        id: LazyMacroId,\n         tt: &tt::Subtree,\n     ) -> Result<tt::Subtree, mbe::ExpandError> {\n         match self {\n@@ -66,6 +67,9 @@ pub trait AstDatabase: SourceDatabase {\n     fn parse_macro(&self, macro_file: MacroFile)\n         -> Option<(Parse<SyntaxNode>, Arc<mbe::TokenMap>)>;\n     fn macro_expand(&self, macro_call: MacroCallId) -> Result<Arc<tt::Subtree>, String>;\n+\n+    #[salsa::interned]\n+    fn intern_eager_expansion(&self, eager: EagerCallLoc) -> EagerMacroId;\n }\n \n pub(crate) fn ast_id_map(db: &dyn AstDatabase, file_id: HirFileId) -> Arc<AstIdMap> {\n@@ -101,6 +105,7 @@ pub(crate) fn macro_def(\n         MacroDefKind::BuiltInDerive(expander) => {\n             Some(Arc::new((TokenExpander::BuiltinDerive(expander), mbe::TokenMap::default())))\n         }\n+        MacroDefKind::BuiltInEager(_expander) => None,\n     }\n }\n \n@@ -110,6 +115,10 @@ pub(crate) fn macro_arg(\n ) -> Option<Arc<(tt::Subtree, mbe::TokenMap)>> {\n     let id = match id {\n         MacroCallId::LazyMacro(id) => id,\n+        MacroCallId::EagerMacro(_id) => {\n+            // FIXME: support macro_arg for eager macro\n+            return None;\n+        }\n     };\n     let loc = db.lookup_intern_macro(id);\n     let arg = loc.kind.arg(db)?;\n@@ -123,13 +132,16 @@ pub(crate) fn macro_expand(\n ) -> Result<Arc<tt::Subtree>, String> {\n     let lazy_id = match id {\n         MacroCallId::LazyMacro(id) => id,\n+        MacroCallId::EagerMacro(id) => {\n+            return Ok(db.lookup_intern_eager_expansion(id).subtree);\n+        }\n     };\n \n     let loc = db.lookup_intern_macro(lazy_id);\n     let macro_arg = db.macro_arg(id).ok_or(\"Fail to args in to tt::TokenTree\")?;\n \n     let macro_rules = db.macro_def(loc.def).ok_or(\"Fail to find macro definition\")?;\n-    let tt = macro_rules.0.expand(db, id, &macro_arg.0).map_err(|err| format!(\"{:?}\", err))?;\n+    let tt = macro_rules.0.expand(db, lazy_id, &macro_arg.0).map_err(|err| format!(\"{:?}\", err))?;\n     // Set a hard limit for the expanded tt\n     let count = tt.count();\n     if count > 65536 {\n@@ -177,6 +189,9 @@ pub(crate) fn parse_macro(\n fn to_fragment_kind(db: &dyn AstDatabase, id: MacroCallId) -> FragmentKind {\n     let lazy_id = match id {\n         MacroCallId::LazyMacro(id) => id,\n+        MacroCallId::EagerMacro(id) => {\n+            return db.lookup_intern_eager_expansion(id).fragment;\n+        }\n     };\n     let syn = db.lookup_intern_macro(lazy_id).kind.node(db).value;\n "}, {"sha": "8caf8497e8bda84f131c7f46bcc0141cae473bbe", "filename": "crates/ra_hir_expand/src/eager.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/1465cc0c4feb52958d3281f066a663e0a52ed67e/crates%2Fra_hir_expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1465cc0c4feb52958d3281f066a663e0a52ed67e/crates%2Fra_hir_expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Feager.rs?ref=1465cc0c4feb52958d3281f066a663e0a52ed67e", "patch": "@@ -0,0 +1,93 @@\n+//! Eager expansion related utils\n+\n+use crate::{\n+    ast::{self, AstNode},\n+    db::AstDatabase,\n+    EagerCallLoc, EagerMacroId, InFile, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n+};\n+\n+use ra_parser::FragmentKind;\n+use ra_syntax::{algo::replace_descendants, SyntaxElement, SyntaxNode};\n+use std::{collections::HashMap, sync::Arc};\n+\n+fn to_subtree(node: &SyntaxNode) -> Option<tt::Subtree> {\n+    let mut subtree = mbe::syntax_node_to_token_tree(node)?.0;\n+    subtree.delimiter = None;\n+    Some(subtree)\n+}\n+\n+fn lazy_expand(\n+    db: &impl AstDatabase,\n+    def: &MacroDefId,\n+    macro_call: InFile<ast::MacroCall>,\n+) -> Option<InFile<SyntaxNode>> {\n+    let ast_id = db.ast_id_map(macro_call.file_id).ast_id(&macro_call.value);\n+\n+    let id: MacroCallId =\n+        def.as_lazy_macro(db, MacroCallKind::FnLike(macro_call.with_value(ast_id))).into();\n+\n+    db.parse_or_expand(id.as_file()).map(|node| InFile::new(id.as_file(), node))\n+}\n+\n+fn eager_macro_recur(\n+    db: &impl AstDatabase,\n+    curr: InFile<SyntaxNode>,\n+    macro_resolver: &dyn Fn(ast::Path) -> Option<MacroDefId>,\n+) -> Option<SyntaxNode> {\n+    let mut original = curr.value.clone();\n+\n+    let children = curr.value.descendants().filter_map(ast::MacroCall::cast);\n+    let mut replaces: HashMap<SyntaxElement, SyntaxElement> = HashMap::default();\n+\n+    // Collect replacement\n+    for child in children {\n+        let def: MacroDefId = macro_resolver(child.path()?)?;\n+        let insert = match def.kind {\n+            MacroDefKind::BuiltInEager(_) => {\n+                let id: MacroCallId =\n+                    expand_eager_macro(db, curr.with_value(child.clone()), def, macro_resolver)?\n+                        .into();\n+                db.parse_or_expand(id.as_file())?\n+            }\n+            MacroDefKind::Declarative\n+            | MacroDefKind::BuiltIn(_)\n+            | MacroDefKind::BuiltInDerive(_) => {\n+                let expanded = lazy_expand(db, &def, curr.with_value(child.clone()))?;\n+                // replace macro inside\n+                eager_macro_recur(db, expanded, macro_resolver)?\n+            }\n+        };\n+\n+        replaces.insert(child.syntax().clone().into(), insert.into());\n+    }\n+\n+    if !replaces.is_empty() {\n+        original = replace_descendants(&original, |n| replaces.get(n).cloned());\n+    }\n+\n+    Some(original)\n+}\n+\n+pub fn expand_eager_macro(\n+    db: &impl AstDatabase,\n+    macro_call: InFile<ast::MacroCall>,\n+    def: MacroDefId,\n+    resolver: &dyn Fn(ast::Path) -> Option<MacroDefId>,\n+) -> Option<EagerMacroId> {\n+    let args = macro_call.value.token_tree()?;\n+    let parsed_args = mbe::ast_to_token_tree(&args)?.0;\n+    let parsed_args = mbe::token_tree_to_syntax_node(&parsed_args, FragmentKind::Expr).ok()?.0;\n+    let result = eager_macro_recur(db, macro_call.with_value(parsed_args.syntax_node()), resolver)?;\n+\n+    let subtree = to_subtree(&result)?;\n+\n+    if let MacroDefKind::BuiltInEager(eager) = def.kind {\n+        let (subtree, fragment) = eager.expand(&subtree).ok()?;\n+        let eager =\n+            EagerCallLoc { def, fragment, subtree: Arc::new(subtree), file_id: macro_call.file_id };\n+\n+        Some(db.intern_eager_expansion(eager))\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "cb554ae4bef4df914eb6fbf454bad0e0ff16ac5f", "filename": "crates/ra_hir_expand/src/hygiene.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1465cc0c4feb52958d3281f066a663e0a52ed67e/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1465cc0c4feb52958d3281f066a663e0a52ed67e/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fhygiene.rs?ref=1465cc0c4feb52958d3281f066a663e0a52ed67e", "patch": "@@ -9,7 +9,7 @@ use ra_syntax::ast;\n use crate::{\n     db::AstDatabase,\n     name::{AsName, Name},\n-    HirFileId, HirFileIdRepr, MacroDefKind,\n+    HirFileId, HirFileIdRepr, MacroCallId, MacroDefKind,\n };\n \n #[derive(Debug)]\n@@ -22,17 +22,18 @@ impl Hygiene {\n     pub fn new(db: &impl AstDatabase, file_id: HirFileId) -> Hygiene {\n         let def_crate = match file_id.0 {\n             HirFileIdRepr::FileId(_) => None,\n-            HirFileIdRepr::MacroFile(macro_file) => {\n-                let lazy_id = match macro_file.macro_call_id {\n-                    crate::MacroCallId::LazyMacro(id) => id,\n-                };\n-                let loc = db.lookup_intern_macro(lazy_id);\n-                match loc.def.kind {\n-                    MacroDefKind::Declarative => loc.def.krate,\n-                    MacroDefKind::BuiltIn(_) => None,\n-                    MacroDefKind::BuiltInDerive(_) => None,\n+            HirFileIdRepr::MacroFile(macro_file) => match macro_file.macro_call_id {\n+                MacroCallId::LazyMacro(id) => {\n+                    let loc = db.lookup_intern_macro(id);\n+                    match loc.def.kind {\n+                        MacroDefKind::Declarative => loc.def.krate,\n+                        MacroDefKind::BuiltIn(_) => None,\n+                        MacroDefKind::BuiltInDerive(_) => None,\n+                        MacroDefKind::BuiltInEager(_) => None,\n+                    }\n                 }\n-            }\n+                MacroCallId::EagerMacro(_id) => None,\n+            },\n         };\n         Hygiene { def_crate }\n     }"}, {"sha": "3fce73e8ad3507dc0eae3e050d13dfe983b24cff", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 52, "deletions": 7, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/1465cc0c4feb52958d3281f066a663e0a52ed67e/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1465cc0c4feb52958d3281f066a663e0a52ed67e/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=1465cc0c4feb52958d3281f066a663e0a52ed67e", "patch": "@@ -12,6 +12,7 @@ pub mod diagnostics;\n pub mod builtin_derive;\n pub mod builtin_macro;\n pub mod quote;\n+pub mod eager;\n \n use std::hash::Hash;\n use std::sync::Arc;\n@@ -25,7 +26,7 @@ use ra_syntax::{\n \n use crate::ast_id_map::FileAstId;\n use crate::builtin_derive::BuiltinDeriveExpander;\n-use crate::builtin_macro::BuiltinFnLikeExpander;\n+use crate::builtin_macro::{BuiltinFnLikeExpander, EagerExpander};\n \n #[cfg(test)]\n mod test_db;\n@@ -70,11 +71,17 @@ impl HirFileId {\n         match self.0 {\n             HirFileIdRepr::FileId(file_id) => file_id,\n             HirFileIdRepr::MacroFile(macro_file) => {\n-                let lazy_id = match macro_file.macro_call_id {\n-                    MacroCallId::LazyMacro(id) => id,\n+                let file_id = match macro_file.macro_call_id {\n+                    MacroCallId::LazyMacro(id) => {\n+                        let loc = db.lookup_intern_macro(id);\n+                        loc.kind.file_id()\n+                    }\n+                    MacroCallId::EagerMacro(id) => {\n+                        let loc = db.lookup_intern_eager_expansion(id);\n+                        loc.file_id\n+                    }\n                 };\n-                let loc = db.lookup_intern_macro(lazy_id);\n-                loc.kind.file_id().original_file(db)\n+                file_id.original_file(db)\n             }\n         }\n     }\n@@ -86,6 +93,10 @@ impl HirFileId {\n             HirFileIdRepr::MacroFile(macro_file) => {\n                 let lazy_id = match macro_file.macro_call_id {\n                     MacroCallId::LazyMacro(id) => id,\n+                    MacroCallId::EagerMacro(_id) => {\n+                        // FIXME: handle call node for eager macro\n+                        return None;\n+                    }\n                 };\n                 let loc = db.lookup_intern_macro(lazy_id);\n                 Some(loc.kind.node(db))\n@@ -100,6 +111,10 @@ impl HirFileId {\n             HirFileIdRepr::MacroFile(macro_file) => {\n                 let lazy_id = match macro_file.macro_call_id {\n                     MacroCallId::LazyMacro(id) => id,\n+                    MacroCallId::EagerMacro(_id) => {\n+                        // FIXME: handle expansion_info for eager macro\n+                        return None;\n+                    }\n                 };\n                 let loc: MacroCallLoc = db.lookup_intern_macro(lazy_id);\n \n@@ -129,6 +144,9 @@ impl HirFileId {\n             HirFileIdRepr::MacroFile(macro_file) => {\n                 let lazy_id = match macro_file.macro_call_id {\n                     MacroCallId::LazyMacro(id) => id,\n+                    MacroCallId::EagerMacro(_id) => {\n+                        return None;\n+                    }\n                 };\n                 let loc: MacroCallLoc = db.lookup_intern_macro(lazy_id);\n                 let item = match loc.def.kind {\n@@ -151,6 +169,7 @@ pub struct MacroFile {\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum MacroCallId {\n     LazyMacro(LazyMacroId),\n+    EagerMacro(EagerMacroId),\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -164,11 +183,27 @@ impl salsa::InternKey for LazyMacroId {\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct EagerMacroId(salsa::InternId);\n+impl salsa::InternKey for EagerMacroId {\n+    fn from_intern_id(v: salsa::InternId) -> Self {\n+        EagerMacroId(v)\n+    }\n+    fn as_intern_id(&self) -> salsa::InternId {\n+        self.0\n+    }\n+}\n+\n impl From<LazyMacroId> for MacroCallId {\n     fn from(it: LazyMacroId) -> Self {\n         MacroCallId::LazyMacro(it)\n     }\n }\n+impl From<EagerMacroId> for MacroCallId {\n+    fn from(it: EagerMacroId) -> Self {\n+        MacroCallId::EagerMacro(it)\n+    }\n+}\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct MacroDefId {\n@@ -184,8 +219,8 @@ pub struct MacroDefId {\n }\n \n impl MacroDefId {\n-    pub fn as_call_id(self, db: &dyn db::AstDatabase, kind: MacroCallKind) -> MacroCallId {\n-        db.intern_macro(MacroCallLoc { def: self, kind }).into()\n+    pub fn as_lazy_macro(self, db: &dyn db::AstDatabase, kind: MacroCallKind) -> LazyMacroId {\n+        db.intern_macro(MacroCallLoc { def: self, kind })\n     }\n }\n \n@@ -195,6 +230,7 @@ pub enum MacroDefKind {\n     BuiltIn(BuiltinFnLikeExpander),\n     // FIXME: maybe just Builtin and rename BuiltinFnLikeExpander to BuiltinExpander\n     BuiltInDerive(BuiltinDeriveExpander),\n+    BuiltInEager(EagerExpander),\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -240,6 +276,14 @@ impl MacroCallId {\n     }\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct EagerCallLoc {\n+    pub(crate) def: MacroDefId,\n+    pub(crate) fragment: FragmentKind,\n+    pub(crate) subtree: Arc<tt::Subtree>,\n+    pub(crate) file_id: HirFileId,\n+}\n+\n /// ExpansionInfo mainly describes how to map text range between src and expanded macro\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ExpansionInfo {\n@@ -253,6 +297,7 @@ pub struct ExpansionInfo {\n }\n \n pub use mbe::Origin;\n+use ra_parser::FragmentKind;\n \n impl ExpansionInfo {\n     pub fn call_node(&self) -> Option<InFile<SyntaxNode>> {"}, {"sha": "036cf7d1e047fa0833dab92e4e7944e56d95da5d", "filename": "crates/ra_hir_expand/src/name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1465cc0c4feb52958d3281f066a663e0a52ed67e/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1465cc0c4feb52958d3281f066a663e0a52ed67e/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fname.rs?ref=1465cc0c4feb52958d3281f066a663e0a52ed67e", "patch": "@@ -173,6 +173,7 @@ pub mod known {\n         compile_error,\n         line,\n         stringify,\n+        concat,\n         format_args,\n         format_args_nl,\n         env,"}, {"sha": "652492c1ed964dd0176ccf358e64d4b1d794af9d", "filename": "crates/ra_parser/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1465cc0c4feb52958d3281f066a663e0a52ed67e/crates%2Fra_parser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1465cc0c4feb52958d3281f066a663e0a52ed67e/crates%2Fra_parser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Flib.rs?ref=1465cc0c4feb52958d3281f066a663e0a52ed67e", "patch": "@@ -83,7 +83,7 @@ pub fn parse(token_source: &mut dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n     parse_from_tokens(token_source, tree_sink, grammar::root);\n }\n \n-#[derive(Clone, Copy)]\n+#[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]\n pub enum FragmentKind {\n     Path,\n     Expr,"}, {"sha": "0da24560ead46fd6918dc71c0c4e6ef81c7389a5", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1465cc0c4feb52958d3281f066a663e0a52ed67e/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1465cc0c4feb52958d3281f066a663e0a52ed67e/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=1465cc0c4feb52958d3281f066a663e0a52ed67e", "patch": "@@ -219,7 +219,7 @@ fn unroot(n: SyntaxNode) -> SyntaxNode {\n }\n \n pub mod tokens {\n-    use crate::{AstNode, Parse, SourceFile, SyntaxKind::*, SyntaxToken, T};\n+    use crate::{ast, AstNode, Parse, SourceFile, SyntaxKind::*, SyntaxToken, T};\n     use once_cell::sync::Lazy;\n \n     pub(super) static SOURCE_FILE: Lazy<Parse<SourceFile>> =\n@@ -251,6 +251,12 @@ pub mod tokens {\n         sf.syntax().first_child_or_token().unwrap().into_token().unwrap()\n     }\n \n+    pub fn literal(text: &str) -> SyntaxToken {\n+        assert_eq!(text.trim(), text);\n+        let lit: ast::Literal = super::ast_from_text(&format!(\"fn f() {{ let _ = {}; }}\", text));\n+        lit.syntax().first_child_or_token().unwrap().into_token().unwrap()\n+    }\n+\n     pub fn single_newline() -> SyntaxToken {\n         SOURCE_FILE\n             .tree()"}]}